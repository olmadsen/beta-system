ORIGIN 'evlib';
INCLUDE 'evval2';
INCLUDE 'inlinNXitem'
---mkCstEvVal:descriptor--
(# CV: ^CstEvVal
do &CstEvval[]->CV[]->V[]; C->CV.C
#)
---mkSimpleEvVal:descriptor---
(# SV: ^SimpleEvVal
do &SimpleEvVal[]->SV[]->V[]; A[]->SV
#)
---EvalLib:attributes------
(* NOTE that loadAdrOp from evval2 is used below *)

CstEvVal: EvVal
  (# thisVal::<(# V: @CstEvVal do C->V.C; V[]->thisV[] #);
     display::<(#do 'CstV:'->xT; C->xI #);
     loadVal::<(#do this(CstEvVal)[]->V[] #);
     loadVal2::<(#do this(CstEvVal)[]->V[] #);
     toDataRegA::<(#do (C[],mch.DataRegA[])->mch.ldCst #);
     toDataRegX::<(#do (C[],mch.DataRegX[])->mch.ldCst #);
     toDataRegY::<(#do (C[],mch.DataRegY[])->mch.ldCst #);
     toRangeReg::<(#do (C[],mch.DataRegB[](*1->mch.NewDataRegOp*))->mch.ldCst #);
     toDataReg::<(#do (C[],dReg[])->mch.ldCst #); 
     toPrimDest::<
       (# (* pNo -> C.toPrimDest, possible, but check firs getPrimReg in
           * super of this(toPrimDest)
           *)
       do (if primDest.isPrimRegOp then
              (C[],primDest[])->mch.ldCst 
           else
              (C[],primDest[],4) -> mch.stCst 
          if)
       #);
     evType::<(#do 1->type #);
     mkReal::< 
       (# T: @text 
       do C->T.putInt; '.0'->T.puttext; 
          (T[],C)->mch.floatConst->mkFloatEvVal->V[] 
       #);
     asgToAdr::< 
       (#do (C[],rA[],rA.size)->mch.stCst; rA.freeAdr; this(CstEvVal)[]->V[] #);
     asgToRefAdr::< (* NONE -> R[]/F## *)
       (# rA: ^mch.address; EV: @AST.index
       do (if C <> 0 then
              (* This may be  
               *    T: (# exit 'q' #);
               *    R: ^text
               * do T -> R[]
               *)
              (# T: @ text
              do C -> T.put;
                 T -> mkTxtCstEvVal->V[]; true->V.sourceIsref;
                 (rAbase[],destEV[],rChain[]) ->  V.asgToRefAdr->V[]
              #)
           else
              destEv.son->EV;
              (rABase.copy,EV[],false,rChain[])->genAdr->rA[];
              (C[],rA[],rA.size)->mch.stCst; rA.freeAdr; this(CstEvVal)[]->V[]
       if)#);
     asgToRealAdr::<
       (# FL : ^mch.floatRegOp; T: @text
       do C->T.putInt; '.0'->T.puttext; 
          (T[],C)->mch.floatConst->FL[]; rA[]->FL.store;
          Fl.deAlloc; this(CstEvVal)[]->V[]
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan; this(CstEvVal)[]->nScan.AsgToNelm;
          nScan.reset
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[]->inx[];
          C->inx.newConstToN;
          (*inx.eval->V[]*)
       #);
     asgToList::< (#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (externalName,Desc[],extKind)->CP; (* init *)
          (if (extKind = semAtt.virtExt) then                 
              (EV.son,extKind->mch.xParForward) -> CP.transferObject;
          if);
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo) -> pushCpar;
          CP.call;
          CP.getExitP->V[];
          (* CP.endc *)
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do mch.getData->D[1]; (C[],D[1]->mch.NewDataRegOp)->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     asgToNewPrim::<
       (# EV1,op: @AST.index; A: ^mch.address; opcode: @integer
       do EV.son->EV1; EV1.son->EV1; EV1.brother->op;
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
          (if op[]->sematt.primitiveToNumber->opCode
           // 5 (* getByte *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then (A[],C,1,false)->primGet->V[]
	       // sematt.repValEval then 
		  (toDataReg,A[],1,false)->primInxGet->V[]
	       else 'unknow evalKind:'->putLine
              if);
           // 6 (* getShort *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 
	          (A[],C*2,2,false)->primGet->V[]
	       // sematt.repValEval then 
	          (toDataReg,A[],2,false)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 7 (* getSignedByte *) then
	      (if EV.evalKind
	       // sematt.simpleEval then (A[],C,1,true)->primGet->V[] 
	       // sematt.repValEval then 
		  (toDataReg,A[],1,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 8 (* getSignedShort *) then
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (A[],C*2,2,true)->primGet->V[]
	       // sematt.repValEval then 
		  (toDataReg,A[],2,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
	   // 13 (* getLong *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (A[],0,4,true)->primGet->V[]
	       // sematt.repValEval then 
		  (toDataReg,A[],4,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
	  if);
          A.freeAdr
       #);
     pushCpar::<
       (# V: ^evVal
       do (if type
           // 1 then C[]->mch.pushCByte
           // 2 then C[]->mch.pushCword
           // 3 // 6 // 10 (*none[ref,dataref]->someExternal*) 
              then C[]->mch.pushClong
           // 7 (*real *) then 
              mkReal->V[]; (7,extKind,size,0)->V.pushCpar
              (* in previous version (v5.1) 7 above was 6! *)
           // 8//9//11 then (* NONE to external call-back *)
              C[]->mch.pushClong
           else 'cstEvVal:pushCpar:Illegal type'->cError
          if)
       #);
     unMinus::< (# W: @cstEvVal do -C->W.C; W[]->res[] #);
     notExp::< (# W: @cstEvVal do (C+1 ) mod 2 -> W.C; W[]->res[] #);
     cmp::< (#do C->lV.cstCmp->doCmp (*gCmp(#do C->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do C->lV.cstAdd->res[] #);
     cstAdd::< (# W: @cstEvVal do C+rN->W.C; W[]->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
          (C[],W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal 
       do rReg->W.dr.reUse; (C[],W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     sub::<(#do C->lV.cstSub->res[] #);
     cstSub::< (# W: @cstEvVal do C-rN->W.C; W[]->V[] #);
     adrSub::<
       (# W: @ComputedEvVal 
       do W.dr.alloc; (C[],W.dr[])->mch.ldCst;
          rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gSub#); 
          W[]->V[] 
       #);
     regSub::< 
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (C[],W1.dr[])->mch.ldCst;
          (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do C->lV.cstTimes->res[] #);
     adrTimes::<
       (# dr: @mch.dataRegOperand; W: @computedEvVal;
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
          (* Datpete 22/7/94: optimization of known constants *)
          (W.dr[], C[], 4) -> cstMult;
          (* (C->mch.newCstOp,W.dr[],4)->mch.gMult; *)
          W[]->V[]
       #);
     cstTimes::< (# W: @cstEvVal do rN*C->W.C; W[]->V[] #);
     regTimes::<
       (# W: @computedEvVal; 
       do rReg->W.dr.reUse; 
          (* Datpete 22/7/94: optimization of known constants *)
          (rReg[], C[], 4) -> cstMult;
          (* (C[],rReg[],4)->mch.gMult; *)
          W[]->V[]
       #);
     divMod::< (#do (C,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::<
       (#(* A div C *)
       do ddr.alloc; (C[],ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# W: @cstEvVal;
          ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN=0 then
              ddr.alloc;
              dr.alloc;
              (C->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then C div rN -> W.C else C mod rN -> W.C if);
          if);
          W[]->V[]
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (C[],ddr.dNo2[])->mch.ldCst;
          (*rReg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     orr::< (#do C->lV.cstOr->res[] #);
     adrOr::< 
       (#do 
          (if C=1 then 1->mkCstEvVal->V[]
           else rA[]->mkSimpleEvVal->V[]
       if)#);
     cstOr::< 
       (#
       do (* bootstrap problem here: C or rN is not implemeted
           * by previous compier version
           *)
          (if C=1 then 1->mkCstEvVal->V[]
           else (if rN=1 then 1->mkCstEvVal->V[]
                 else 0->mkCstEvVal->V[]
       if)if)#); 
     regOr::<
       (#
       do (if C=1 then 1->mkCstEvVal->V[]
           else rReg->rReg.reUse;
              (rReg,false,false)->mkComputedEvVal->V[]
       if)#);
     andd::< (#do C->lV.cstAnd->res[] #);
     adrAnd::< 
       (#do 
          (if C=0 then 0->mkCstEvVal->V[]
           else rA[]->mkSimpleEvVal->V[]
       if)#);
     cstAnd::< 
       (#
       do (if C=0 then 0->mkCstEvVal->V[]
           else (if rN=0 then 0->mkCstEvVal->V[]
                 else 1->mkCstEvVal->V[]
       if)if)#);
     regAnd::< 
       (#
       do (if C=0 then 0->mkCstEvVal->V[]
           else rReg->rReg.reUse;
              (rReg,false,false)->mkComputedEvVal->V[]
       if)#);
     
     C: @mch.cstOperand
  #);
simpleEvVal: EvVal
  (* 'A' is the adr. of a basic item to be assigned to EV*)
  (# thisVal::<(# V: @SimpleEvVal do A[]->V.A[] ; V[]->thisV[] #);
     display::<(#do 'SimpleV:'->xT; thisA->xT #); 
     thisA: (# t:@text do A.display->t exit t[] #);
     loadVal::<
       (# dR1: ^mch.dataRegOperand
       do (if A.regType//mch.thisO//mch.callO then this(SimpleEvVal)[]->V[]
           else(# W: @computedEvVal 
               do toDataReg->dR1[]; dR1->W.dr; release; (*!!*) W[]->V[]
       #)if)#);
     loadVal2::<
       (# W: @computedEvval;dR1: ^mch.dataRegOperand
       do toDataReg->dR1[]; dR1->W.dr; release; W[]->V[]
       #);
     xVal: (# V: @SimpleEvVal enter V.A[] exit V[] #);
     regVal: 
       (# dr: @mch.dataRegOperand ; V: ^computedEvVal
       enter dr
       do (dr,false,false)->mkComputedEvVal->V[]
       exit V[]
       #);
     release::<
       (# delay: @boolean 
       enter delay do A.freeAdr; (if not delay  then none->A[] if) #);
     mkReal::< 
       (#
       do (if A.size//1//2 then
              (# W: @computedEvval
              do W.dr.alloc;
                 (A[],W.dr[],A.size)->mch.ldVl;
                 W.mkReal->V[]
              #)
           else
              A[]->mch.int2float->mkFloatEvVal->V[]
          if); 
          release 
       #);
     toTmp::<
       (#do(if A.useCallReg then A.toTmp->A[];(*mch.decrCallReg*)if)#);
     elimReg::< (# do (elimThis,elimCall)->A.elimReg #);
     toDataRegA::<(#do (A[],mch.DataRegA[],A.size)->mch.ldVl; A.freeAdr #);
     toDataRegX::<(#do (A[],mch.DataRegX[],A.size)->mch.ldVl; A.freeAdr #);
     toDataRegY::<(#do (A[],mch.DataRegY[],A.size)->mch.ldVl; A.freeAdr #);
     toRangeReg::<(#do (A[],mch.DataRegB[],A.size)->mch.ldVl #);
     toDataReg::<(#do (A[],dReg[],A.size)->mch.ldVl; release #);
     toPrimDest::<
       (# 
       do (if primDest.isPrimRegOp then
              (A[],primDest[],A.size)->mch.ldVl 
           else
              (A[],primDest[]) -> mch.cpMem
          if)
       #);
     evType::<(#do 1->type #);
     asgToAdr::<
       (# dr: @mch.dataRegOperand; dr1: ^mch.dataRegOperand
       do (if A.Size
           // 1 then
              (if rA.Size // 1 then 
                  (A[],rA[])->mch.cpByteMem;
                  rA[]->xVal->V[]
               else
                  dr.alloc; dr[]->mch.gClr; 
                  (A[],dr[])->mch.ldByte;
                  (if rA.Size // 2 then (dr[],rA[])->mch.stHalf
                   else (dr[],rA[])->mch.stVal; 
                  if);
                  dr->regVal->V[]; rA.freeAdr
              if)
           // 2 then
              (if rA.Size // 2 then 
                  (A[],rA[])->mch.cpHalfMem;
                  rA[]->xVal->V[]
               else
                  dr.alloc; dr[]->mch.gClr; (A[],dr[])->mch.ldHalf;
                  (if rA.Size // 1 then (dr[],rA[])->mch.stByte
                   else (dr[],rA[])->mch.stVal
                  if);
                  dr->regVal->V[]; rA.freeAdr
              if)
           else 
              (if rA.Size//4 then 
                  (if ((A[],rA[])->mch.cpMem->dr1[]) = NONE then
                      rA[]->xVal->V[]
                   else
                      dr1->regVal->V[]; rA.freeAdr
                  if)
               else
                  dr.alloc; (A[],dr[])->mch.ldVal;
                  (if rA.Size // 1 then (dr[],rA[])->mch.stByte
                   else (dr[],rA[])->mch.stHalf
                  if);
                  dr->regVal->V[]; rA.freeAdr
          if)if);
          A.freeAdr; (*rA[]->xVal->V[]*)
       #);
     asgToRealAdr::<
       (# FV: ^ floatEvVal
       do A[]->mch.int2float->mkFloatEvVal->FV[];
          rA[]->FV.asgToRealAdr->V[]; A.freeAdr
       #);
     asgToItem::< (* A -> rA *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan;
          this(SimpleEvVal)[]->nScan.AsgToNelm;
          nscan.reset
       #);
     asgToInlineItem::
       (# dr: ^mch.dataRegOperand;
          inx: ^inlineNXitem
       do inlNX[]->inx[]; inx.newDataRegToN->dr[];
          (A[],dr[],A.size)->mch.ldVl;
          release;
       #);
     asgToList::< (#do toListOne #);
     asgToCproc::<
       (# CP: @ExternalCall; dr: ^mch.dataRegOperand; W: ^evVal
       do (if A.struc//mch.InxRegAdr## then
              (* The execution of CP will push all busy registers, including
               * the ones possibly used by A. If A is a repetition index, like
               * R[i], A will be an instance of InxRegAdr. If release is called
               * for A, the adr. register will be cleared. This happens
               * before A is pushed and will thus result in an error. In this
               * case A is move to a dataregister before the release.
               * It would be better to have a cleaner solution
               *)
              toDataReg->dr[]; 
              (dr,false,false)->mkComputedEvVal->W[];
              (EV[],externalName[],desc[],extKind)->W.asgToCproc->V[]
           else              
              true->release; (* Dirty, free possible data reg. in A *)
              (externalName,Desc[],extKind)->CP; (* init *)
              (if (extKind = semAtt.virtExt) then                 
                  (EV.son,extKind->mch.xParForward) -> CP.transferObject;
              if);
              (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo) -> pushCpar;
              CP.call;
              CP.getExitP->V[];
              (* CP.endc *)
          if)
       #);
     asgToPrimitive::<
       (# CP: @primitiveCall
       do (1,T[])->CP;
          (3(* always long *),sematt.asmExt,0,0)->(*thisEvVal.*)pushCpar;
          CP.call->V[]
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do mch.getData->D[1]; (A[],D[1]->mch.NewDataRegOp)->mch.ldVal;
          A.freeAdr;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     asgToNewPrim::<
       (# EV1,op: @AST.index;
	  rA: ^mch.address;
          dr: ^mch.dataregOperand
       do EV.son->EV1; EV1.son->EV1; EV1.brother->op;	
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->rA[];
	  toDataReg->dr[];
          (if op[]->sematt.primitiveToNumber
           // 5 (* getByte *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 
                  (rA[],dr[],1,false)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],1,false)->primInxGet->V[]
	       else 'unknow evalKind:'->putLine
              if);
           // 6 (* getShort *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 
	          (rA[],dr[],2,false)->primGet2->V[]
	       // sematt.repValEval then 
	          (dr[],rA[],2,false)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 7 (* getSignedByte *) then
	      (if EV.evalKind
	       // sematt.simpleEval then 
                  (rA[],dr[],1,true)->primGet2->V[] 
	       // sematt.repValEval then 
		  (dr[],rA[],1,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 8 (* getSignedShort *) then
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (rA[],dr[],2,true)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],2,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 13 (* getLong *) then
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (rA[],dr[],4,true)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],4,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
          if)
       #);
     pushCpar::<
       (# W: ^computedEvVal; v: ^evVal
       do (if released then reAlloc if);
          (if type
           // 1 then toReg->W[]; W.dr[]->mch.pushCbyte; W.release
           // 2 then toReg->W[]; W.dr[]->mch.pushCword; W.release
           // 3 then
              (if A.size 
               //4 then A[]->mch.pushClong
               //2
               //1 then toReg->W[]; W.dr[]->mch.pushCbyte; W.release
              if)
           // 7 (* real *) then
              mkReal->V[]; (*  A[] = NONE *)
              (7,extKind,size,0)->V.pushCpar;
           else 'simpleEvVal:pushCpar:Illegal type'->cError
          if);
          (if type <> 7 then A.freeAdr (*else A[] = NONE *) if);
          none->A[];
       #);
     unMinus::<
       (# W: ^computedEvVal do toReg->W[]->res[]; (W.dr[],4)->mch.gNeg #);
     notExp::< 
       (# W: ^computedEvVal do toReg->W[]->res[]; (W.dr[],4)->mch.gNot #);
     cmpBoolAndJmp::<
       (#
       do 'simple adr'->putline
       #);
     cmp::< 
       (#do A[]->lV.adrCmp->doCmp (*gCmp(#do A[]->lV.adrCmp #) *) #);
     adrCmp::< 
       (# W: ^ComputedEvVal
       do (*rA[]->A.cmp *) 
          rA[]->op1[]; toReg->W[]; W.dr[]->op2[]; 
          rA.size->size; true->deAllocOp2
       #);
     cstCmp::< 
       (# W: ^ComputedEvVal
       do toReg->W[]; (*(rC[],W.dr[],4)->mch.gCmp;*)
          rC[]->op1[]; W.dr[]->op2[];4->size;true->deAllocOp2
          (*W.dr.deAlloc*)
       #);
     regCmp::<(* A COMP rReg *)
       (# W: ^computedEvVal
       do toReg->W[];
          (*(rReg[],W.dr[],4)->mch.gCmp;*) 
          rReg[]->op1[]; W.dr[]->op2[]; 4->size;true->deAllocOp2
          (*W.dr.deAlloc *)
       #);
     add::< (#do A[]->lV.adrAdd->res[] #);
     adrAdd::<
       (# W: ^ComputedEvVal
       do toReg->W[]->V[]; 
          rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gAdd#)
       #);
     cstAdd::<
       (# W: ^ComputedEvVal do toReg->W[]->V[]; (rN[],W.dr[],4)->mch.gAdd#);
     regAdd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; 
          A[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gAdd#); 
          W[]->V[]
       #);
     sub::< (#do A[]->lV.adrSub->res[] #);
     adrSub::< 
       (# W: ^ComputedEvVal; dr: @mch.dataRegOperand
       do toReg->W[]->V[];
          dr.alloc; 
          (if rA.size
           // 4 then (rA[],dr[])->mch.ldVal
           else dr[]->mch.gClr;
              (if rA.size//1 then (rA[],dr[])->mch.ldByte
               else (rA[],dr[])->mch.ldHalf
          if)if);
          (dr[],W.dr[],4)->mch.gSub; dr.deAlloc
       #);
     cstSub::<
       (# W: ^ComputedEvVal; dr: @mch.dataRegOperand
       do toReg->W[]->V[];;
          dr.alloc; (rN[],dr[])->mch.ldCst;
          (dr[],W.dr[],4)->mch.gSub; dr.deAlloc; W[]->V[]
       #);
     regSub::<
       (# W: ^computedEvVal
       do toReg->W[]->V[]; (rReg[],W.dr[],4)->mch.gSub
       #);
     times::< (#do A[]->lV.adrTimes->res[] #);
     adrTimes::<
       (# W: @computedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl; 
          (if A.size//1 then
              (# dl: @mch.dataRegOperand
              do dl.alloc; dl[]->mch.gClr; (A[],dl[])->mch.ldByte;
                 (dl[],W.dr[],4)->mch.gMult; dl.deAlloc
              #)
           else (* MC680x0 only accepts word and long for mult*)
              A[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gMult#)
          if); 
          W[]->V[]
       #);
     cstTimes::<
       (# W: @computedEvVal
       do W.dr.alloc; (A[],W.dr[],A.size)->mch.ldVl;
          (* Datpete 22/7/94: optimization of known constants *)
          (W.dr[], rN[], 4) -> cstMult;
          (* (rN->mch.newCstOp,W.dr[],4)->mch.gMult;  *)
          W[]->V[]
       #);
     regTimes::<
       (# W: @computedEvVal 
       do rReg->W.dr.reUse;
          (if A.size//1 then
              (# dl: @mch.dataRegOperand
              do dl.alloc; dl[]->mch.gClr; (A[],dl[])->mch.ldByte;
                 (dl[],W.dr[],4)->mch.gMult; dl.deAlloc
              #)
           else (* MC680x0 only accepts word and long for mult*)
              A[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gMult#)
          if); 
          W[]->V[]
       #);
     divMod::< (#do (A[],isDiv)->lV.adrDivMod->res[] #);
     adrDivMod::< (* A div rA *)
       (#
       do ddr.alloc; (A[],ddr.dNo2[],A.size)->mch.ldVl;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# W: @ComputedEvVal; dr: @mch.dataRegOperand
       do (* optimized kjm 2-8-94 *)
          dr.alloc; (A[],dr[],A.size)->mch.ldVl;
          (dr[],rN[],A.size,isDiv) -> cstDiv -> W.dr; (* A div rN *)
          W[]->V[];
       #);
     regDivMod::<
       (#
       do ddr.alloc; (A[],ddr.dNo2[],A.size)->mch.ldVl;
          (*rReg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* A div rReg *)
       #);
     orr::< (#do A[]->lV.adrOr->res[] #);
     adrOr::<
       (# W: ^computedEvVal
       do toReg->W[]->V[]; (rA[],W.dr[],rA.size)->mch.gOr 
          (* bool is always 8 bit? Otherwise loadAdrOp mus be used*)
       #);
     cstOr::<
       (# W: @computedEvVal
       do W.dr.alloc; (rN[],W.dr[])->mch.ldCst;
          (* could this be as cstAdd?*)
          (A[],W.dr[],A.size)->mch.gOr; W[]->V[]
       #);
     regOr::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (A[],rReg[],A.size)->mch.gOr; W[]->V[]
       #);
     andd::< (#do A[]->lV.adrAnd->res[] #);
     adrAnd::<
       (# W: ^computedEvVal
       do toReg->W[]->V[]; (rA[],W.dr[],rA.size)->mch.gAnd
       #);
     cstAnd::<
       (# W: @computedEvVal
       do W.dr.alloc; (rN[],W.dr[])->mch.ldCst;
          (A[],W.dr[],A.size)->mch.gAnd; W[]->V[]
       #);
     regAnd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (A[],rReg[],A.size)->mch.gAnd; W[]->V[]
       #);
     toReg:
       (# W: @ComputedEvVal;
       do W.dr.alloc;
          (if A.size
           // 4 then (A[],W.dr[])->mch.ldVal
           else  W.dr[]->mch.gClr;
              (if A.size //1 then (A[],W.dr[])->mch.ldByte
               else (A[],W.dr[])->mch.ldHalf
          if)if)
       exit W[]
       #);
     
     A: ^Mch.Address
  enter A[]
  #);
