ORIGIN 'genlib'
---genlib_genobj:dopart---
do &ProtoType[]->R[];
   ProtoHead[]->R.succ[];
   R[]->GS.thisPT[]->Protohead[];
   objKind -> R.objKind;
   307->trace
   (#do 'genlib: ' -> xT; thisDesc[] -> xA;
      thisDesc[]->sematt.hasAcode-> xB;
      returnSaved -> xB
   #);
   (objKind = sematt.externalVirtualKind) -> isComVirtual;
   (if (thisDesc[]->sematt.hasAcode->hasAcode) 
       or switch68 (* V-entry points *) 
       or isComVirtual then
       thisDesc.father -> N;
       (*301 -> trace(# do 'descFather:'->xT; N[] ->xA #);*)
       (if N.label 
        // gram.staticItem // gram.staticComponent then
           singularData -> objKind2;
        // gram.descriptorForm // gram.virtualDecl // gram.bindingDecl then
           dynamicObj -> objKind2
       if);
       (if common.switch[323] then
           (if false and desc2alias and (thisDescNo = 2) then
               'bingo'->putline;
               ('X',thisDesc[]) -> mkEntryPoint -> (T[],local);
            else
               ('G',thisDesc[]) -> mkEntryPoint -> (T[],local);
           if);
           (0,T[],false,none,0,none) -> mch.initGen
        else
           (thisFormName[],thisForm[],thisDescNo,theFormIndex
           ,thisDesc.nodeId
           ,ThisDesc.size,hasAcode
           ,objKind2)
             -> gen.BeginAlloc;    
       if);
       (if isComVirtual and not ReturnSaved then
           (true,thisDesc.returnOff)->mch.SaveReturn;
           true -> ReturnSaved
       if)
   if);
   (if objKind <> sematt.stateKind then
       (pref,common.itemKind)->PrefixAlloc;
   if);
   (att,0,&RepList[])->GenAlloc;
   (if isComVirtual then
       (* do NOT generate normal return 
        * Transfer arguments to object
        * May be proto should not be in %i1 and
        * may be we should call G direcly a la V-entry,
        * i.e. NO AlloCom
        *)
       (*<<SLOT TransferCOMarguments:descriptor>>*)
    else
       (* normal object*)
       (if common.switch[68] then
           (if hasAcode or (common.targetMachineId = common.sgi)
               (*or common.switch[68]*) then
               (false,thisDesc.returnOff)->mch.return
            else
               (if common.switch[65] then
                   (if hasAcode then mch.rts if)
                else 
                   (if common.switch[64] then mch.rts if)
           if)if)
        else
           (if hasAcode then
               (if returnSaved (*probably always true?*) then
                   (false,thisDesc.returnOff)->mch.return
                else
                   mch.rts
               if)
           if)
   if)if);
   (# exitOffStart: @integer
   do (if (thisDesc[] -> sematt.hasNcode) AND common.switch[180] then
          GenNpart -> exitOffStart
       else
          thisDesc.returnOff -> exitOffStart;
          (if enterP.label <> gram.empty then 
              (* with switch[180] not necessary, since there will be Ncode
               * if there are singular descriptors
               *)
              enterP.son->getSingular;
      if)if);
      (if (thisDescNo = 1)
          or (ThisDesc[]->Sematt.hasDo) 
          or (formKind = mainPartForm) then
          (if not (ThisDesc[]->sematt.hasOnlyInner) then
              (if not doP.isSlot then 
                  (0,NONE,NONE,NOT isComVirtual,isComVirtual,none,none) -> GenDo
              if)
          if)
      if);
      (if (thisDesc[] -> sematt.hasXcode) AND common.switch[180] then
          exitOffStart -> GenXpart
       else
          (if exitP.label <> gram.empty then 
              exitP.son->getSingular;
      if)if);
   #);
   (pref[],att[])->BindVirtuals;
   (nameId[],singular)->genSymbTable
   
