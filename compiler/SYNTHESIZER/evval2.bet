ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE '~beta/betaast/scanBetaText';
INCLUDE 'aux';
INCLUDE 'inlinNXitem';
INCLUDE 'storeReg';
INCLUDE 'asgtoitem'
---mkListEvVal:descriptor---
(# LV: ^ListEvVal
do &ListEvVal[]->LV[]->V[]; (evl[],thisBaseAdr[],lChain[])->LV
#)
---mkComputedEvVal:descriptor--
(# CV: ^ComputedEvVal
do &ComputedEvVal[]->CV[]->V[]; 
   dr->CV.dr; 
   isAreg->CV.isAreg; strucRef->CV.strucRef;
   comTxt -> CV.comTxt
#)
---mkTxtCstEvVal:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; T->TV.T; 
#)
---mkTxtVarEvVal:descriptor---
(# TV: ^TxtVarVal
do &TxtVarVal[]->TV[]->V[]; 
   (if A.access <> common.direct then 
       (if not (switch180 or switch181) then 
           'mkTxtVarVal:base:indirect:notSwitch180/181'->SystemError
       if);
       A.toTmp->A[]
   if);
   (A[],EV[],evalKind,slice)->TV
#)
---mkDoubleEvVal:descriptor---
(# DV: ^DoubleEvVal
do &DoubleEvVal[]->DV[]->V[]; (drX,drY)->DV
#)
---mkRealEvVal:descriptor---
(# RV: ^RealEvVal
do &RealEvVal[]->RV[]->V[]; A[]->RV.A[]
#)
---mkFloatEvVal:descriptor---
(# RV: ^FloatEvVal
do &FloatEvVal[]->RV[]->V[]; FR->RV.FL
#)
---EvalLib:attributes---
listEvVal: EvVal
  (# thisVal::
       (#V: @ListEvVal do (evl[],thisBaseAdr[],lChain[])->V; V[]->thisV[] #);
     evId:: (# do 'ListVal:' -> id[] #);
     display::
       (# 
       do 'evl='->xT; evl[]->xA; xN;
          'thisBaseAdr='->xT; thisBaseAdr.display->xT;
          (*lCHain[]->printChain*)
       #);
     loadVal::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'listVal: loadVal'->xT #)#);
     theReg::<(#do thisBaseAdr.theReg -> aR #);
     release::
       (#
       do (*179->trace(#do 'list1:'-> xT; mch.dumpreg #);*)
          thisBaseAdr.freeAdr; 
          none->evl[]; none->thisBaseAdr[]; none->lChain[];
          (*179->trace(#do 'list2:'-> xT; mch.dumpreg #);*)
       #);
     toTmp::
       (#
       do (if thisBaseAdr.useCallReg then
              thisBaseAdr.toTmp->thisBaseAdr[]; mch.decrCallReg if)
       #);
     elimReg:: (# do (elimThis,elimCall)->thisBaseAdr.elimReg #);
     asgToAdr:: (* (E1,E2,...)->rA *)
       (#do cError(#do 'ListVal:asgToAdr'->xT; evl[]->xA #)#);
     asgToRepAdr::
       (# length: @integer; isValueRep,unfreeze: @boolean
       do (if stest then
              301->trace(#do 'ListVal:asgToRepAdr;'->xT; evl[]->xA;
                           thisBaseAdr.display; xN;
                           100->SwitchOn;
                           rEv[]->xA;
                           100->SwitchOff
                        #)
          if);
          (if not thisBaseAdr.frozenReg then
              thisBaseAdr.freezeReg;
              true ->unfreeze
          if);
          evl->scanList(# do length + 1 -> length #);
          (* Value repetion is assumed, later ref rep should be supported *)
          
          (if rEV.son -> sematt.simpleOrRep 
           // gram.staticItem // gram.staticComponent then
              true -> isValueRep
           // gram.dynamicItem // gram.dynamicComponent then
              false -> isValueRep
          if);
          (isValueRep,rA.size,length,rA[]) -> asgToNewRep
          (#
          do evl->scanList
             (# EV: @AStindex
             do currentNode -> EV;
                (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                  -> ExpEval
                  -> V[];
                (* OBS: Currently asgToRepElm is used, but we might
                 * as well here decide whether to use asgToAdr,
                 * asgToRealAdr, etc. And later also asgToRefAdr
                 * when reference repetitions are supported
                 *)
                (if stest then
                    301->ctrace
                    (#
                    do 'listVal:asgToRepAdr:elm:'->xT;
                       V.display;
                       mch.dumpreg;
                #)if);
                (if false then
                    (if rA.size < 8 then
                        NextElmAdr -> V.asgToAdr -> V[]
                     else
                        NextElmAdr -> V.asgToRealAdr -> V[];
                    if)
                 else
                    (NextElmAdr,rEV[],rChain[]) -> V.asgToRepElm -> V[]
                if);
                V.release;
             #);
          #);
          (if unFreeze then false -> baseAdr.frozenReg if);
          rA.freeAdr;
          this(listEvVal)[] -> V[]
       #);
     asgToItem::
       (* evl=(E1,E2,...)
        * E1 -> EV.n1; E2 -> EV.n2 ... *)
       (# nScan: @ | scanNadr;
          NA: ^Mch.Address; more,first,onStack: @boolean;
          theEVL : @ASTindex;
          nxLevel: @integer;
          isSimple: @boolean; hasCode: @boolean
       do (if switch181 then
              evl.father -> theEVL;
              (theEVL[],false,lChain[]) -> sematt.NXdepth -> (nxLevel,hasCode);
              (if hasCode then
                  false -> isSimple;
                  (if rA.useCallReg then 
                      (if rA.isCallReg then mch.decrCallReg
                       else
                          '\n***evval2:listVal::asgToItem:rA is NOT callreg'
                            -> putline
                      if);
                      rA.toTmp -> rA[];
                      (* rA.freezeReg (* who will release it? *)
                  if)
               else
                  true -> isSimple;
              if);
              
              (rDesc[],rA[](*not used*),0,rChain[],true) -> nScan;
              
              (rDesc[],rA[],rchain[],nScan[],isSimple) -> asgToN
              (# V: ^evVal;
                 EH: @EvalHandler;
                 localDesc: ^ASTindex
              do (if nScan.N = 1 then
                     301->trace(#do 'listVal:asgToItem:N=1'->xT #);
                     (rObjAdr[],this(listEvVal)[],nscan.thisEv[],nScan.thisChain[])
                       -> EH.AssignValToEval 
                       -> V[];
                     (if V[] <> NONE then V.release
                      else '\nlistEvVal:asgToItem-1:V_is_None'->putline
                     if);                        
                  else
                     evl -> scanList
                     (# EV: @ASTindex;
                        lV,V: ^evVal;
                        rObjTmp: @addressTmpHandler;
                     do currentNode -> EV;
                        (EV[],false,lChain[]) 
                          -> sematt.NXdepth 
                          -> (nxLevel,hasCode);
                        (if hasCode then rObjAdr[]->rObjTmp.save if);
                        (thisBaseAdr[],EV[],false,lChain[])
                          -> ExpEval
                          -> lV[];
                        rObjAdr.bAdr.localDesc[] -> localDesc[];
                        (rObjAdr[],nScanN.PL,rObjAdr[]) 
                          -> SetSuperDesc 
                          -> rObjAdr[]; (* rObjAdr is a new object! *)
                        rObjTmp.restore;
                        rObjTmp.deAlloc;
                        rObjAdr.freezeReg; (* OBS! Overrides a possible 
                                            * non-freeze in asgToN. Gave
                                            * adr-negative during clean-up,
                                            * but should be reconsidered
                                            *)
                 
                        (rObjAdr[],lV[],nscan.thisEv[],nScan.thisChain[])
                          -> EH.AssignValToEval 
                          -> V[];
                        (if stest then
                            301->ctrace(#do 'listVal:in:asgtoItem:'->xT;
                                         display; xN;
                                         'V='->xT; V.display
                        #)if);
                        localDesc[] -> rObjAdr.bAdr.localDesc[];       
                        (if V[] <> NONE then V.release
                         else '\nlistEvVal:asgToItem:VISNone'->putline
                        if);
                        nextEnterEval;
                     #)
                 if);
              #)
              -> this(asgToItem).rAx[] -> this(asgToItem).rA[]
           else
              rA[] -> moveToCallReg
              (# chain1: ^DH.SuperChain
              do EHchain[] -> chain1[];
                 (if rA.isCallReg and thisBaseAdr.isCallReg then
                     (* why does this never happen?*)
                     cError(#do 'ListVal:asgToItem:CallReg conflict'-> xT #)
                 if);
                 (rDesc[],thisA[]->rA[],0,rChain[],true) -> nScan -> more;
                 (if nScan.N=1 (*isSingleObj//true*) then
                     (*350->cTrace(#do 'list->list:isSingle'->T;rDesc[]->A #);*)
                     this(ListEvVal)[] -> nScan.asgToNelm
                  else 
                     (if thisBaseAdr.regType // mch.thisO // mch.callO then
                         evl -> scanList 
                         (# EV: @ASTindex
                         do currentNode -> EV;
                            (* chain is valid for Left-side, 
                             * rChain for right-side *)
                            (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                              -> ExpEval
                              -> nScan.asgToNelm; 
                            nScan -> more;
                            (if stest then
                                301->trace(#do 'ListVal:asgToItem2'->xT; mch.dumpreg#)
                            if);
                         #)
                      else
                         (* with NXoffSets, baseAdr of a list should always
                          * be thisReg.
                          *)
                         (if switch180 then 
                             cError(#do'listVal:asgToItem:Wrong Register'->xT#)
                         if);
                         pushThis; 
                         thisBaseAdr[] -> toThis -> thisBaseAdr[];
                         evl -> scanList 
                         (# EV: @ASTindex
                         do currentNode->EV;
                            (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                              -> ExpEval
                              -> nScan.asgToNelm; 
                            nScan -> more
                         #);
                         popThis
                 if)if);
                 nScan.reset;
              #)->rA[]; (* 27.4.93 *)
              (* this could be handled more efficient, since a push callReg by
               * moveToCallReg should not restore until the item has been 
               * executed. Not possible with current structure.
               * Might perhaps be done by push/pop of rA in the calls to
               * asgToItem in transferEnter in evLib?
               *)
          if)
       #);
     asgToNxOffSets::
       (# off: @integer; isRef,toCall: @boolean; A: ^mch.address;
          V: ^evVal
       do (if stest then 178->trace(#do 'listVal:asgToNXoffSets:'-> xT #)if);
          (if rA.isCallReg then
              (* this is only necessary if some Ev in evl is an object
               * that has to be executed. Some simple way of testing
               * this is missing
               *)
              rA.toTmp -> rA[]; 
              rA.freezeReg; (* freeze seems necessary
                             * since someone makes a freeAdr. 
                             *)
              mch.decrCallReg;
              true -> toCall;
              (*178->trace(#
                        do 'listVal:asgToNXoffSets2:'-> xT; 
                           rA.display->xT;
               mch.dumpReg #);*)
          if);          
          evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rA[],NX[],inXpart) -> V.asgToNxOffSets -> rA[];
             (if stest then
                 178->trace(# do 'listVal:asgToNXoffSets2B:'-> xT; 
                              mch.dumpReg #)
             if);             
             V.release
          #);
          (if toCall then
              (if rA.isCallReg then
                  cError(#do 'listVal:asgToNXoffSets:callRegproblem'->xT #)
              if);
              false -> rA.frozenReg;
              mch.GetCallReg; (* can callReg be busy here - and should
                               * it then be pushed, and where will it 
                               * then be popped
                               *)
              rA.toCallReg -> rA[];
              (if stest then
                  178->trace(#do 'listVal:asgToNXoffSets3:'-> xT; mch.dumpReg #)
              if);
          if)              
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do evl->scanList
          (# Ev: @ASTindex
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rDesc[],inlNX[],rChain[])->V.asgToInlineItem
          #);
          (*inlNX[]->inx[]; inx.eval->V[]*)
       #);
     asgToList::< (* assign evl=(le1,le2,...)->EV=(re1,re2,...) *)
       (# scanRevl: @ | 
            (# 
            do EV->scanList(#do currentNode->rEv; SUSPEND #)
            #);
          rEv: @ASTindex;
          W: @ListEvVal;
       do (if switch181 then
              evl->scanList
              (# EV: @ASTindex
              do currentNode->EV;
                 scanRevl;
                 (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                 (BA[],V[],rEv[],rChain[])->AssignValToEval->V[]; 
                 V.release
              #)
           else
          (if thisBaseAdr.regType//mch.thisO//mch.callO then
              301->trace(#do 'ListVal:asgToList2:'->xT #);
              evl->scanList
              (# EV: @ASTindex
              do currentNode->EV;
                 scanRevl;
                 (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                 (BA[],V[],rEv[],rChain[])->AssignValToEval->V[]; V.release
              #)
           else
              (if switch180 then 
                  cError(#do 'listVal:asgToList:Wrong register'->xT #)
              if);
              BA[]->moveToCallReg
              (#
              do (*350->trace(#do 'PushThis6'-> xT #);*)
                 pushThis; 
                 thisBaseAdr[]->toThis->thisBaseAdr[];
                 evl->scanList
                 (# EV: @ASTindex
                 do currentNode->EV;
                    scanRevl;
                    (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                    (thisA[],V[],rEv[],rChain[])->AssignValToEval->V[]; 
                    V.release;
                 #);
                 thisA[]->BA[]; popThis
              #)->BA[]; (* 27.4.93 - see asgToItem above *)
          if)if);
          (* return the right-side evalList, ev *)
          (ev[],BA[],rChain[])->W; W[]->V[]
       #);
     asgToDispatch::
       (# CP: @ExternalCall; C: @mch.cstOperand;
          objectReg,vTableReg,procReg: @mch.adrRegOperand;
          A: ^mch.address; A1: @mch.RegAdr;
          dr,dr1,dr2: @mch.dataRegOperand;
          D: @ASTindex; msgName: ^text
       do 311 -> ctrace
          (#
          do 'listVal:asgToDispatch:' -> xT;
             EV[] -> xA; xN;
             desc[]-> xA;
          #);          
          (externalName,Desc[],sematt.dispatchExt,EV.son)->CP; (* init *)
          CP.top -> C.C;
          C[] -> mch.pushClong;
          
          (* create an arglist *)
          'InitDispatch' ->mch. CallPrim;
          CP.getExitP -> V[];
          mch.getSimpleXres -> dr; (* args *)          
          
          (* transfer arguments to arglist *)
          evl -> scanList
          (# EV: @ASTindex
          do currentNode -> EV;
             2 -> mch.initPrimCall;
             dr[] -> mch.pushClong;  (* args *)
             dr.deAlloc;
             (thisBaseAdr.copy,EV[],false,lChain[]) -> ExpEval -> V[];
             (true->CP.getEnterP,sematt.dispatchExt) 
               -> V.asgToDispatchPar;
             mch.getSimpleXres -> dr; (* args *)
          #);

          CP.getExitP -> V[]; (* needed - otherwise a ref none will happen*)
          
          3->mch.initPrimCall;
          objectReg.alloc;
          EV.son -> EV;
           ((gen.thisRegAdr,Desc[],EV[],thisSuperChain)
            -> genOrgAdr->A[],objectReg[])
            -> mch.gLea;
          A.freeAdr;
          
          vTableReg.alloc;
          (objectReg[],vTableReg[]) -> mch.cpReg;
          vTableReg->A1.reg;
          (A1[],vTableReg[])->mch.ldVal;

          procReg.alloc;          
          
          (* call GetIDsOfNames via vTable-entry *)
          (* First build arguments: *)
          EV -> sematt.getName -> D; D.dclRef -> D;
          D.gettext -> msgName[];
          (* 'name= '->puttext; msgName[] -> putline;*)
          2 -> mch.initPrimCall;
          (common.textXpar,sematt.virtExt,4,0) 
            -> (msgName -> mkTxtCstEvVal).pushCpar;
          'MkNameList' -> mch.CallPrim;
          mch.getSimpleXres -> dr1; 
          
          0 -> mch.initPrimCall;
          'MkResList' -> mch.CallPrim;
          mch.getSimpleXres -> dr2;
          
          3->mch.initPrimCall;
          objectReg[]->mch.pushClong; (*  object *)
          dr1[]-> mch.pushClong; 
          dr1.deAlloc;
          dr2[]-> mch.pushClong; 
          
          8 (* GetIDsOfNames *)-> A1.off;
          (A1[],procReg[])->mch.ldVal;
          (procReg[],sematt.virtExt,0,0)->mch.externalDispatch;
          mch.getSimpleXRes -> dr1;
          dr1.deAlloc;
          
          1 -> mch.initPrimCall;
          dr2[] -> mch.pushClong;
          'GetDispId' -> mch.callPrim;
          mch.getSimpleXres -> dr2;
          
          (* call Invoke via vTable-entry *)
          3->mch.initPrimCall;
          objectReg[]->mch.pushClong; (*  object *)

          (*1 -> mch.newCstOp -> mch.pushClong; (* dispID *)
          dr2[] -> mch.pushClong; (* dispID *)
          dr[] -> mch.pushClong;  (* args *)
          12 (* invoke *)-> A1.off;
          (A1[],procReg[])->mch.ldVal;
          (procReg[],sematt.virtExt,0,0)->mch.externalDispatch;
          mch.getSimpleXRes -> dr1;
          dr1.deAlloc;
          
          objectReg.deAlloc;
          vTableReg.deAlloc;
          procReg.deAlloc;
       #);
     asgToCproc::<
       (# CP: @ ExTernalCall; 
          EL: [100] ^ASTindex; top,max: @integer;
          chain1: ^DH.SuperChain; 
          inThis,popCall,popThis,arg2Saved: @boolean;
          savedArg2: @mch.dataRegOperand;
          callRegParNo: @integer
       do (if stest then
              301->ctrace(#do 'listVal:asgtoCproc:'->xT;  #);
          if);
          FixBase
          (#
          do EHchain[]->chain1[];
             (externalName,Desc[],extKind,EV.son)->CP; (* init *)
             evl->scanList
             (#
             do &ASTindex[]->EL[top+1->top][];
                currentNode->EL[top]
             #);
             (if extKind->mch.xParForward then
                 (* For some tstcproc.bet
                  * of the RISC's: mips, ppc, sparc (eventually),
                  * callReg is the same register as the 2nd argument register.
                  * (1) Before transferring external arguments, it must be
                  *     tested if callReg is busy, and if so, callReg MUST be
                  *     saved and later restored.
                  * (2) Evaluation of an argument may involve execution
                  *     of primitive operations, like AlloI, CopyT, etc; these
                  *     primitives may use argument registers; initPrimCall
                  *     will push possible busy arg. registers and getPrimRes
                  *     will restore them .....
                  * (3) Evaluation of arguments may call Beta procedures:
                  *     Eval of e.g. arg. 3:
                  *     Push arg1,arg2 (callreg)
                  *     AlloI -> callReg(arg2)
                  *     Pop arg1,arg2   - override callReg
                  *     .... transfer enter-params to callReg 
                  *     call M12FOO
                  *     We thus SAVE calReg(arg1) in a dataRegister when
                  *     it has been evaluated.
                  *     After AlloI we dont override callReg with arg. pop.
                  *     Before external call arg1 must be restored.
                  * RE 1. It seems that NO registers are ever stored before
                  * an external call? All busy registers should be saved?
                  * We now do it for MIPS/PPC - but should it be done
                  * in general?
                  *)
                 (if common.switch[61] then
                     (*mch.pushReg -> max; - dont work
                      * since some of the registers may have been released
                      * when the external is called. And then
                      * allocated after the call and then overwritten
                      * by mch.popReg
                      *)
                     (if extKind = sematt.VirtExt then
                         (* first arg. is theObject, so first eval
                          * in the list goes to callReg *)
                         1 -> callRegParNo
                      else
                         2 -> callRegParNo
                     if);                   
                     (if mch.callRegBusy and (top >= callRegParNo) then
                         (false,true) -> mch.pushThisOrCall;
                         true -> popCall;
                         (if thisBaseAdr.useCallReg then
                             (*350->trace(#do 'PushThis7'-> xT #);*)
                             pushThis;
                             true -> popThis;
			     thisBaseAdr[] -> toThis -> thisBaseAdr[];
                             (*'CallReg in use at listEvVal:asgToCproc'
                              * ->systemError*)
                 if)if)if);
                 (if stest then
                     301->trace(#do 'ParNo: ' -> xT; callRegParNo -> xI;
                                  'extKind' -> xT; extKind -> xI#)
                 if);
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[i][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (true->CP.getEnterP,extKind,CP.getEnterP.size
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                      (* arg2/callReg may be used during evaluation of 
                       * arg 3, 4, ... We thus save it and restore it
                       * when all arguments have been evaluated
                       *)
                      (if common.switch[61]
                          and (i = callRegParNo) and (top > callRegParNo) then
                          (* par no. 2 in callReg - MUST be saved *)
                          savedArg2.alloc; (* potentially dataReg overflow
                                            * if many nested C calls in
                                            * position of par. 2 of C-calls
                                            *)
                          (mch.callRegOp[],savedArg2[]) -> mch.cpReg;
                          true -> arg2Saved;
                         (* savedArg2[] -> mch.push (*data*)
                      if)
                 for);
              else                 
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[top-i+1][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (false->CP.getEnterP,extKind,CP.getEnterP.size
                      
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                 for)
             if);
             (if arg2Saved then 
                 (*savedArg2[] -> mch.pop (*data*);
                 (savedArg2[],mch.callRegOp[]) -> mch.cpReg;
                 savedArg2.deAlloc
             if);
             CP.call;
             CP.getExitP->V[]; 
             (if popThis then (true,false) -> mch.popThisOrCall if);
             (if popCall then (false,true) -> mch.popThisOrCall if);
                 (*(if common.switch[61] then max -> mch.popReg if)*)
       #)#);
     asgToPrimitive::<
       (# CP: @primitiveCall; inThis: @boolean; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# n: @integer
          do evl->scanlist(#do n+1->n (* this ONLY count 1 pr. elm!! *)#);
             (n,T[])->CP;
             evl->Scanlist
             (# EV: @ASTindex; V: ^EvVal
             do currentNode->EV;
                (thisBaseAdr.copy,EV[],false,lChain[])->ExpEval->V[];
                (3(* always long *),sematt.asmExt,0,0)->V.pushCpar;
             #);
             CP.call->V[];
       #)#);
     asgToInLinePrimitive::<
       (# xDr: [3] ^mch.dataRegOperand;  D: [3]@integer; Dmax,dRes: @integer;
          W: @ComputedEvVal; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# dR1: ^mch.dataRegOperand
          do evl->scanList
             (# E: @ASTindex; V: ^evVal
             do currentNode->E; 
                (thisBaseAdr.copy,E[],false,lChain[])->ExpEval->V[];
                V.toDataReg->xDr[Dmax+1->Dmax][];
                xDr[Dmax]->D[Dmax]; (*V.release; !!*)
                (*350->trace(#do mch.dumpReg #)*)
             #);
             (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
             W[]->V[];
             (for i: Dmax repeat
                  (if dRes = D[i] then else xDr[i].deAlloc if);
       for)#)#);
     asgToNewPrim::<
       (# EV1,EV2,op: @ASTindex; lv,rv,V1,V2: ^evVal; 
          opCode,pos,length,val: @integer;
	  dr,lDr,rDr,pDr,wDr: ^mch.dataRegOperand; opT: ^text; A: ^mch.address;
	  ar: @mch.adrRegOperand;

          putBW:
            (* (val,byteNo)->A.putByte/Short *)
	    (* (@@A,val)->putByte/Short *) 
          (# size: @integer; bsNo: @integer
          enter size
          do evl->scanList
             (# E: @ASTindex; i: @integer; dr1: ^mch.dataRegOperand
             do currentNode->E;
                (if i+1->i
                 // 1 then (* val *)
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                 // 2 then (* byteNo *) 
                    E[]->getConst->(bsNo,V1[]); 
                    (if V1[]=none then
                        (if size//2 then bsNo*2->bsNo if);
                        bsNo->A.addOff->A[]
                     else
                        V1.loadVal2->V1[]; (*Check this evrywhere*)
                        V1.toDataReg->dr1[];
                        (A[],dr1[],size)->primIndex->A[]
                    if)
                if);
             #) ;
             lv.toDataReg->dr[];
             (if size
              // 1 then (dr[],A[])->mch.stByte
              // 2 then (dr[],A[])->mch.stHalf
              // 4 then (dr[],A[])->mch.stVal
             if);
             A.freeAdr; (* cleared if InxRegAdr *)
             (dr,false,false,false)->mkComputedEvVal->V[]
             (* A.aReg does NOT denoet a real object - must be cleared *)
          #);

          inxPut:
	    (* (val,inx)->R.inxPut/byte/short/long *)
	    (* (R,inx,val) -> inxPut/byte/short/long 
             * R is a repetition
	     * D[1]=adr(R), D[2]=inx, D[3]=val 
             *)
          (# val: ^mch.dataRegOperand;      
             size: @integer (* 0=byte, 1=word, 2=long *);
             oldS14,oldS15: @boolean
          enter size
          do common.switch[14]->oldS14; common.switch[15]->oldS15;
             true->common.switch[14]->common.switch[15];
             evl->scanList
             (# E: @ASTindex;; i: @integer
             do currentNode->E;
                (if i+1->i
                 // 1 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->val[];
                 // 2 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->dr[];
                if);
             #);
             (dr,true,size)->A.index->A[];
             size->A.addOff->A[]; (* check that this works *)
             (if size
              // 1 then (val[],A[])->mch.stByte
              // 2 then (val[],A[])->mch.stHalf
              // 4 then (val[],A[])->mch.stVal
             if);
             oldS14->common.switch[14]; oldS15->common.switch[15];
             (* A.aReg does NOT denote a real object - must be cleared *)
             A.freeAdr; (* cleared if InxRegAdr *)
             (val,false,false,false)->mkComputedEvVal->V[]

          #);
          getConst: 
            (# E: ^ASTindex; T: ^text; val: @integer; V: ^evVal
            enter E[]
            do (if E.label // gram.integerConst then
	           E.getText->T[]; 0->T.setPos; T.getInt->val
		else 
		   (thisBaseAdr.copy,E[],false,rchain[])->ExpEval->V[]
	       if)
            exit(val,V[])
            #);
	  ClrAndDeAlloc:
            (# ar: @mch.adrRegOperand
            enter ar
            do ar[]->mch.gClr; ar.deAlloc
            #)
       do EV.son-> EV1; EV1.son->EV1; Ev1.brother->op;
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
          (if op[]->sematt.primitiveToNumber->opCode
           // 9 (* putByte *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  1->inxPut
	       else 1->putBW
	      if)
           // 10 (* putShort *) then 
	      (if EV.evalKind = sematt.repValEval then 
                  2->inxPut
	       else 2->putBW
	      if)
           // 31 (* putLong *) then
	      (if EV.evalKind = sematt.repValEval then 
                  4->inxPut
	       else (* sematt.simpleEval, realVal, ... *) 
                  4->putBW
	      if)
           // 19 (* (pos,length)->R.%getBits    *)
           // 20 (* (pos,length)->getSignedBits *) then
	      (* address of R is in A *)
              (# dr: @mch.dataRegOperand; pos,length: @integer
              do dr.alloc; (A[],dr[])->mch.ldVal; A.freeAdr;
	         evl->scanList
                 (# E: @ASTindex;; i: @integer
                 do currentNode->E;
                    (if i+1->i
                     // 1 then (* pos *) E[]->getConst->(pos,V1[])
                     // 2 then (* length *) E[]->getConst->(length,V2[]);
                    if);
                 #) ;
	         (* V1[]=nil => pos is constant
	          * V2[]=nil => length is constant
	          *)                 
	         (if (V1[]<>none) or (V2[]<>none)  then
                     (V1[],pos)->const2Reg->pDr[];
                     (V2[],length)->const2Reg->wDr[];
                     (if opCode=19 then
                         (dr[],pDr[],wDr[])->mch.gGetBits
                      else
                         (dr[],pDr[],wDr[])->mch.gGetSignedBits
                     if)
                  else
	             (if opCode = 19 then 
                         (dr[],pos,length,dr[],none)->mch.getBits
	              else (dr[],pos,length,dr[],none)->mch.getSignedBits
	         if)if);
	         (dr,false,false,false)->mkComputedEvval->V[];
	      #)
           // 21 (* (Val,pos,length)->R.%putbits *) then 
	      evl->scanList
              (# E: @ASTindex;; i: @integer
              do currentNode->E;
                 (if i+1->i
                  // 1 then (* val *) E[]->getConst->(val,V[])
                  // 2 then (* pos *) E[]->getConst->(pos,V1[])
                  // 3 then (* length *) E[]->getConst->(length,V2[])
                 if);
              #);
	      A.toReg2->ar; ar.mkIndirect;
              (V[],val)->const2Reg->lDr[];
              (if v1[]=none then (* pos is constant *)
                  (if v2[]=NONE then (* pos and width are constant *)
                      (* the current case of putBits *)
                      (lDr[],pos,length,ar[],none)->mch.putBits
                   else (* length is variable *)
                      (* general case *)
                      (V2[],pos)->const2Reg->pDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                  if)
               else 
                  V1.toDataReg->pDr[];
                  (if (v2[]=NONE) then
                      (V2[],length)->const2Reg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                   else 
                      (* pos is variable *)
                      (* general case *)
                      V2.todataReg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
              if)if);
              (lDr,false,false,false)->mkComputedEvval->V[];
              (* the following call is 'inherited' from the old primitive-code
               * from gen1body! It is a coincidence that it works,since ar 
               * is marked as indirect. This should generate set 0, [%ar].
               * It works since ar is transferred by value, which does NOT
               * transfer the inDirect flag!!!! Ugly:-(
               *)
              ar->ClrAndDeAlloc;
          if)
       #);
     pushCPar::<(#do 'ListPushCpar'->NotImpl #);
     FixBase:
       (# 
       do (if thisBaseAdr.regType//mch.thisO//mch.callO then
              INNER
           else
              (if switch180 then 
                  cError(#do 'listVal:FixBase:Wrong register'->xT #)
              if);
                  (*350->trace(#do 'PushThis8'-> xT #);*)
              pushThis; thisBaseAdr[]->toThis->thisBaseAdr[];
              INNER;
              popThis
       if)#);
     
     evl: ^ASTindex; 
     thisBaseAdr: ^mch.address;
     lChain: ^DH.SuperChain;
     (* evl must be evaluated relative to thisBaseAdr *)
  enter(evl[],thisBaseAdr[],lChain[])
  #);
ComputedEvVal: EvVal 
  (* Holds the result of an evaluation 
   * - in most cases data register dr holds a (non reference) value
   * - if isAreg is true dr holds an address to an object
   * - if strucRef, dr refers an structure object (ptn var)
   * - if comTxt, dr is the address of an (external) text 
   *   passed to a COM virtual
   *)
  (# dr: @mch.DataRegOperand; (* result in data register 'dr' *)
     isAreg: @boolean; (* result in address register 'dr' *)
     (* this is only possible for references to dynamic objects*)
     strucRef: @boolean; (* adr. register has a structureReference,dirty! *)
     comTxt: @boolean;
     thisVal::<
       (#V: @ComputedEvVal 
       do dr->V.dr; 
          isAreg->V.isAreg; strucRef->V.strucRef; comTxt->V.comTxt;
          V[]->thisV[] 
       #);
     EvId:: (# do 'ComputedVal:' -> id[] #);
     display::<
       (#
       do (if isAreg then 'aReg='->xT else 'dReg='->xT if);
          dr->xI
       #);
     reUse: 
       (#
       do (if isAreg then (# aR: @mch.adrRegOperand do dr->aR.reUse #)
           else dr->dr.reUse 
          if)
       #);
     loadVal::<(#do this(ComputedEvVal)[]->V[] #);
     loadVal2::<(#do this(ComputedEvVal)[]->V[] #);
     thisReg:
       (# RA: @mch.adrRegOperand; op: ^mch.mOperand
       do (if isAreg then dr->RA; RA[]->op[] else dr[]->op[] if)
       exit op[]
       #);
     needExtraAreg:: (# do false -> value #);
     theReg:: (#do (if isAreg then dr -> aR if)#);
     release::<
       (#
       do (if isAreg then dr->mch.freeAdr else dr.deAlloc if)
       #);
     reAlloc::< (#do reUse #);
     toTmp::<
       (#
       do (if isAreg then 
              (if dr = mch.callO then
                  (* this(ComputedEvVal) is &T[] *)
                  (# aR1,aR2: @mch.adrRegOperand
                  do dr->aR1; aR2.alloc; (aR1[],aR2[])->mch.cpReg;
                     aR2->dr;
                     mch.decrCallReg
       #)if)if)#);
     toDataRegA::< (* OBS! is d0 always free here ?*)
       (#
       do (if dr <> 0 then (dr[],mch.DataRegA[])->mch.cpReg; dr.deAlloc if)
       #);
     toDataRegX::< 
       (#
       do (if dr <> 7 then (dr[],mch.DataRegX[])->mch.cpReg; release if)
       #);
     toDataRegY::<
       (#
       do (if dr <> 6 then (dr[],mch.DataRegY[])->Mch.CpReg; dr.deAlloc if)
       #);
     toRangeReg::< (* OBS! is d1 always free here ? *)  
       (#
       do (if dr <> 1 then 
              (dr[],mch.dataRegB[])->Mch.CpReg;
	      (* dr.deAlloc*)
          if)
       #);
     toDataReg::<
       (#
       do dReg.deAlloc; (* this was introduced in order to free an otherwise
                         * unused dataregister, which may cause data reg overflow.
                         * The code in comments below was here before the LINUX 
                         * implementation - reuse cannot be used - hopefully
                         * this correction will work!
                         *)
          dr->dReg; dr.fn->dReg.fn; 
          (*dReg->mch.freeData; dr->dReg.reUse !!*) 
       #);
     toPrimDest::<
       (# 
       do (if primDest.isPrimRegOp then
              (mkReg,primDest[])->mch.cpReg
           else
              (mkReg,primDest[]) -> mch.stVal
          if)
       #);
     evType::<(#do (if strucRef then 4->type else 1->type if)#);
     mkReal::<
       (# W: @floatEvVal; FR: ^mch.floatRegOp
       do thisReg->mch.intReg2Float->FR[]; FR->W.FL; W[]->V[]; 
          release
       #);
     asgToSimpleEv::
       (#
       do (if stest then
              301->ctrace(#do 'computedVal:asgToSimpleEv:'->xH;
                           rBaseAdr.display->xT; xN;
                           rEv[] -> xA;
                           mch.dumpreg;
                        #);
          if);
          rEvAdr -> asgToAdr -> V[]
       #);

     asgToAdr::<
       (#
       do (if StrucRef then (thisReg,false)->rA.asgRefReg
           else 
              (if rA.size
               // 1 then (thisReg,rA[])->mch.stByte
               // 2 then (thisReg,rA[])->mch.stHalf
               else (* 4 or undefined *)
                    (* OBS! Error here!
                     * strucRef may be false if the reference is computed as 
                     * a result of a TOS call as in R.struc. This is bad 
                     * since a checkRefAsg will not be generated. Also stByte
                     * is generated instead of stVal.
                     *)
                  (thisReg,rA[])->mch.stVal
          if)if);
          rA.freeAdr; (*reUse;*) this(ComputedEvVal)[]->V[] 
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; EV: @ASTindex
       do (*301->trace(#do 'computedVal:asgToRefAdr:'->xT; destEV[]->xA#);*)
          (* do we ever come here or is this just a leftover from
           * early COM experiments?
           * YES: we come here via e.g. GetXobj -> xR[]
           * where a COMobject is exited from an external
           * 'computedVal:asgToRefAdr:'->systemError;
           * In genexternal.bet:common.COMobjectXpar
           * generates a ComputedEvVal. This should be perhaps
           * be changed ??? and generation of something else
           * than computedEvVal, perhaps unite with genlib_COM.bet
           * evVals.....
           *)
          destEV.son -> EV;
          (EV[],strucRef,rAbase[],thisReg,0,rChain[]) -> storeRegRef -> rA[];
          (rAbase[],EV[],false,rChain[]) -> genAdr -> rA[];
          rA.freeAdr; 
          this(ComputedEvVal)[] -> V[]
       #);
     asgToRepAdr:: 
       (* This operation is called when assigning a text to
        * a char rep in a COM virtual function. It does NOT
        * necessarily work in all cases, including switch[61],
        * etc.
        *)
       (# 
       do (if stest then
              301->trace(#do 'computedVal:asgToRepAdr:'->xT; dr.display->xT #)
          if);
          (if comTxt then
              (rA[],0) -> CopyT(#do 1 -> dr.toPrimDest #);
              rA.freeAdr;
              this(ComputedEvVal)[] -> V[]
           else
              (* val -> aRep *)
              (true,rA.size,1,rA[]) -> asgToNewRep
              (#
              do NextElmAdr -> asgToAdr -> V[]
              #);
          if);
       #);
     asgToRepElm::<
       (#
       do (if stest then
              301->trace(#do 'ComputedVal:asgToRepElm: '-> xT #)
          if);
          rA[] -> asgToAdr -> V[]
       #);
     asgToRealAdr::<
       (# FR: ^mch.floatRegOp;
       do thisReg->mch.intReg2float->FR[];
          rA[]->FR.store; FR.deAlloc; rA.freeAdr;
          this(ComputedEvVal)[]->V[] ;
          release
       #);
     asgToItem::< 
       (* A -> rA *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan;
          this(ComputedEvVal)[]->nScan.AsgToNelm -> rAx[];
          nScan.reset
       #);
     asgToNXoffSets::
       (# off: @integer; rAx: ^mch.address
       do (if stest then
              179->trace(#do 'computedVal:asgToNxOffSetsVal:'->xT#);
          if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> rAx[];
          NX.getSize-> rAx.size;
          (if rAx.size 
           // 4 then (thisReg,rAx[]) -> mch.stVal
           // 1 then (thisReg,rAx[]) -> mch.stByte
           // 2 then (thisReg,rAx[]) -> mch.stHalf
           else
              cError(#do 'ComputedEvVal:asgToNXoffSetsVal:UndefSize'->xT#)
          if);
          release
       #);
     asgToDataReg::
       (#
       do (*312->trace(#do'computedEvVal:asgToDataReg:'->xT #);*)
          (dr[],destDR[])->mch.cpReg;
          (*release;
           (destDR,false,false,false)->mkComputedEvVal->V[]*)
          this(computedEvVal)[]->V[]
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[]->inx[];
          dr[]->inx.dataRegToN;
          (*inx.eval->V[]*)
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do release;
          (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            -> pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     asgToPrimitive::<
       (# CP: @primitiveCall
       do (1,T[])->CP;
          (3(* always long *),sematt.asmExt,0,0)->(*thisEvVal.*)pushCpar;
          CP.call->V[]
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do (*dr->dr.reUse; *) dr->D[1]; 
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     asgToNewPrim::<
       (# EV1,op: @ASTindex;
	  rA: ^mch.address;
       do (if stest then
              301->trace
              (#do 'computedVal: '->xT; EV[] -> xA; 
                 baseA.display-> xT;
              #)
          if);
          EV.son->EV1; EV1.son->EV1; EV1.brother->op;	  
          (baseA.copy,EV1[],false,rchain[])->genAdr->rA[];
          (if op[]->sematt.primitiveToNumber
           // 5 (* getByte *) then 
	      (if EV.evalKind = sematt.repValEval then 
		  (dr[],rA[],1,false)->primInxGet->V[]
               else
                  (rA[],dr[],1,false)->primGet2->V[]
              if);
           // 6 (* getShort *) then 
	      (if EV.evalKind = sematt.repValEval then 
	          (dr[],rA[],2,false)->primInxGet->V[]
               else
	          (rA[],dr[],2,false)->primGet2->V[]
              if)
           // 7 (* getSignedByte *) then
	      (if EV.evalKind = sematt.repValEval then 
		  (dr[],rA[],1,true)->primInxGet->V[]
               else
                  (rA[],dr[],1,true)->primGet2->V[] 
              if)
           // 8 (* getSignedShort *) then
	      (if EV.evalKind = sematt.repValEval then 
		  (dr[],rA[],2,true)->primInxGet->V[]
               else
		  (rA[],dr[],2,true)->primGet2->V[]
              if)
           // 13 (* getLong *) then
	      (if EV.evalKind = sematt.repValEval then 
		  (dr[],rA[],4,true)->primInxGet->V[]
               else
		  (rA[],dr[],4,true)->primGet2->V[]
              if)
          if);
          (*rA.freeAdr - is cleared by primGet2 *)
       #);
     pushCpar::<
       (# V: ^evval
       do (if released then reAlloc if); (* necessary for I386 *)
          (if type
           // common.byteXpar then dr[]->mch.pushCbyte
           // common.shortXpar then dr[]->mch.pushCword
           // common.longXpar
           // common.dataXpar (* may be called from refEvval:asgToCproc *) 
           // common.textXpar (* may be called from itemEvVal:pushCpar *)
           // common.cStructXpar 
              (* a hack:
               * IUnknown: (# ...; R: @RefToCOMref
               *           enter (...,R) ...
               * scanCNX is incomplete and returns cStructXpar
               *)
              then mkReg->mch.pushClong
              (* may be called from scmp, with adr. reg. *)
           // common.doubleXpar  then mkReal->V[]; (7,extKind,size,0)->V.pushCpar
           // common.int64Xpar then
              0 -> mch.NewCstOp -> mch.pushClong;
              dr[] -> mch.pushClong
           // common.varPtnCXpar then (* c *)
              1->mch.initPrimCall;
              (if common.switch[61] or common.switch[64] then
                  (mkAreg,1->mch.getPrimReg) -> mch.cpReg
               else                      
                  mkAreg->mch.pushClong;  (* should be prim *)
              if);
              protectCallReg(# do 'CopyCPP'->mch.callprim #); 
              2->mch.getPrimRes
           // common.varPtnPascalXpar then
	      (univProcInfo,mkAreg,size[]) -> genCopyPPP
           // common.varPtnStdXpar then
              7 ->mch.initPrimCall;
              mkAreg->mch.pushClong; size[]->mch.pushClong;
              'CopySPP'->mch.callPrim;
              2->mch.getPrimRes
	      (* others not used *)
           else
              'ComputedVal:pushCpar:unKnownType'-> systemError
          if);
          release
       #);
     mkTrue::< (#do d1->dr; (1->mch.NewCstOp,dr[])->mch.ldCst #);
     relOp::<
       (#
       do (# Lab: @mch.localLab
          do Lab.new;
             (if op	      (* IF T1 cc R then goto L *)
              // gram.eqExp then Lab[]->mch.gBeq
              // gram.neExp then Lab[]->mch.gBne
              // gram.ltExp then Lab[]->mch.gBlt
              // gram.leExp then Lab[]->mch.gBle
              // gram.gtExp then Lab[]->mch.gBgt
              // gram.geExp then Lab[]->mch.gBge
             if);
             dr[]->mch.gClr;
             Lab.Def
       #)#);
     relRealOp::<
       (#
       do (# Lab: @mch.localLab
          do Lab.new;
             (if op	      (* IF T1 cc R then goto L *)
              // gram.eqExp then Lab[]->mch.fBeq
              // gram.neExp then Lab[]->mch.fBne
              // gram.ltExp then Lab[]->mch.fBlt
              // gram.leExp then Lab[]->mch.fBle
              // gram.gtExp then Lab[]->mch.fBgt
              // gram.geExp then Lab[]->mch.fBge
             if);
             dr[]->mch.gClr;
             Lab.Def
       #)#);
     unMinus::<
       (# W: @computedEvVal do dr->W.dr.reUse; (dr[],4)->mch.gNeg; W[]->res[]#);
     notEXP::<
       (# W: @computedEvVal do dr->W.dr.reUse; (dr[],4)->mch.gNot; W[]->res[]#);
     cmpBoolAndJmp::
       (#
       do (cond,dr[],4,lab[])->mch.cmpBoolAndJmp
       #);
     cmp::<(#do dr->Lv.regCmp->doCmp (*gCmp(#do dr->lV.regCmp #)*)#);
     cstCmp::< (* dr COMP rC *) 
       (#
       do (*(rC[],dr[],4)->mch.gCmp *)
          rC[]->op1[]; dr[]->op2[]; 4->size; (*deAllocOp2=false*)
       #);
     adrCmp::<(* dr COMP rA *)
       (# dn: @mch.dataRegOperand
       do dn.alloc; (rA[],dn[],rA.size)->Mch.ldVl;
          (*(dn[],dr[],4)->mch.gCmp; dn.deAlloc;*)
          dn[]->op1[]; dr[]->op2[]; 4->size; true->deAllocOp1
       #);
     regCmp::<(* dr COMP rReg *)
       (#do (*(rReg[],dr[],4)->mch.gCmp*)
          rReg[]->op1[]; dr[]->op2[]; 4->size; (*deAllocOp2=false*)
       #);
     add::< (#do dr->lV.regAdd->res[] #);
     adrAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; 
          rA[]->loadAdrOp(#do (op[],dr[],4)->mch.gAdd#); W[]->V[]
       #);
     cstAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gAdd; W[]->V[]#);
     regAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rReg[],dr[],4)->mch.gAdd;  W[]->V[] 
       #);
     sub::< (#do dr->lV.regSub->res[] #);
     adrSub::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; rA[]->loadAdrOp(#do (op[],dr[],4)->mch.gSub#); 
          W[]->V[]
       #);
     cstSub::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gSub; W[]->V[]
       #);
     regSub::<
       (# W1: @computedEvVal 
       do dr->W1.dr.reUse; (rReg[],dr[],4)->mch.gSub; W1[]->V[] 
       #);
     times::<(#do dr->lV.regTimes->res[] #);
     adrTimes::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse;
          (if rA.size//1 then
              (# dl: @mch.dataRegOperand
              do dl.alloc; dl[]->mch.gClr; (rA[],dl[])->mch.ldByte;
                 (dl[],W.dr[],4)->mch.gMult; dl.deAlloc
              #)
           else (* MC680x0 only accepts word and long for mult*)
              rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gMult#)
          if); 
          W[]->V[] 
       #);
     cstTimes::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; 
          (* datpete 22/7/94: optimization *)
          (dr[], rN[], 4) -> cstMult;
          (* (rN->mch.NewCstOp,dr[],4)->mch.gMult; *)
          W[]->V[]
       #);
     regTimes::<
       (# W: @computedEvVal 
       do rReg->W.dr.reUse; (dr[],rReg[],4)->mch.gMult; W[]->V[]
       #);
     divMod::< (#do (dr,isDiv)->lV.regDivMod->res[] #);
     cstDivMod::<
       (* dataReg alloc is messy here and below:
        * ddr.dNo1 is allocated - ddr.dNo1 takes over from dr.
        * dr is allocated a new register to avoid release problems
        * of dr and ddr
        *)
       (# ddr: @mch.doubleDataRegOperand; drx: @mch.dataRegOperand;
          W: @ComputedEvVal
       do (* dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
           * ddr.dNo1.alloc; dr.alloc;
           * drx.alloc; (rN[],drx[])->mch.ldCst; 
           * (drx[],ddr[],isDiv)->mch.gDiv; 
           * (if isDiv then
           *     ddr.dNo2->W.dr; ddr.dNo1.deAlloc
           *  else ddr.dNo1->W.dr; ddr.dNo2.deAlloc
           * if);
           * drx.deAlloc;
           *)
          (dr[],rN[],4,isDiv)->cstDiv->W.dr;
          (* if isDiv then result is dr
           * else dr has been deAllocated.
           * Alloc new dr to avoid data reg negative
           *)
          dr.alloc;
          W[]->V[]
       #);
     adrDivMod::<
       (# drx: @mch.dataRegOperand
       do dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
          ddr.dNo1.alloc; dr.alloc;
          drx.alloc; (rA[],drx[],rA.size)->mch.ldVl; 
          (*dr->ddr.dNo2.reUse;*)
          (drx[],ddr[],isDiv)->mch.gDiv; (* dr div rA *)
       #);
     regDivMod::<
       (# 
       do dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
          ddr.dNo1.alloc; dr.alloc;
          (* rReg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* dr div rReg *)
       #);
     orr::<(#do dr->lV.regOr->res[] #);
     adrOr::< (# W: @computedEvVal 
	      do dr->W.dr.reUse; (rA[],dr[],rA.size)->mch.gOr; W[]->V[]
	      #);
     cstOr::<  
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gOr; W[]->V[]
       #);
     regOr::< 
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (dr[],rReg[],4)->mch.gOr; W[]->V[]
       #);
     andd::<(#do dr->lV.regAnd->res[] #);
     adrAnd::< 
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rA[],dr[],rA.size)->mch.gAnd; W[]->V[]
       #);
     cstAnd::< 
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gAnd; W[]->V[]
       #);
     regAnd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rReg[],dr[],4)->mch.gAnd; W[]->V[]
       #);
     ToDreg::<
       (* used when computing primitive address expressions like @@ch;
        * the address of ch is in A; mch.move A to the 'dr' data register
        *)
       (# aReg: @mch.adrRegOperand
       do aReg.alloc; (A[],aReg[])->mch.gLea;
	  dr.alloc; (aReg[],dr[])->mch.CpReg;
	  (*(0->mch.newCstOp,aReg[])->mch.ldCst;*) aReg[]->mch.gClr;
	  (* in order NOT to confuse garbage collection *)
	  aReg.deAlloc; A.freeAdr
       #);
     mkAreg: (# aR: @mch.adrRegOperand do dr->aR exit aR[] #);
     mkReg:
       (# R: ^mch.mOperand
       do (if isAreg then mkAreg->R[] else dr[]->R[] if)
       exit R[]
       #);
     
     scmp::<(#do doCmp(#do 2->toPrimDest#)#);
  #);
TxtCstVal: EvVal
  (# thisVal::<(#V: @TxtCstVal do T->V.T; evalKind->V.evalKind; V[]->thisV[]#);
     evId:: (# do 'TxtCstVal:'-> id[] #);
     display::< (#do ThisT->xT #); 
     thisT: (#exit T[]#);
     release::(#do (if cTxt[] <> NONE then cTxt.deAlloc if)#);
     loadVal::<(#do this(TxtCstVal)[]->V[] #);
     loadVal2::<(#do this(TxtCstVal)[]->V[] #);
     toDataRegA::<(#do (thisChOp,mch.DataRegA[])->mch.ldCst#);
     toDataRegX::<(#do (thisChOp,mch.DataRegX[])->mch.ldCst#);
     toDataRegY::<(#do (thisChOp,mch.DataRegY[])->mch.ldCst#);
     toRangeReg::<
       (#do (thisCh->mch.newCstOp,mch.dataRegB[])->mch.ldCst#);
     toDataReg::< (#do (thisCh->mch.newCstOp,dReg[])->mch.ldCst #);
     toPrimDest::
       (# 
       do (if primDest.isPrimRegOp then
              (thisCh->mch.newCstOp,primDest[])->mch.ldCst
           else
              (thisCh->mch.NewCstOp,primDest[],4) -> mch.stCst
          if)
       #);
     evType::<(#do 1->type (* if char?*)#);
     mkReal::< 
       (# T: @text; thisInt: @(# I: @integer do thisCh->I exit I #)
       do thisCh->T.putInt; '.0'->T.puttext; 
          (T[],thisInt) -> mch.floatConst->mkFloatEvVal->V[] 
       #);
     asgToAdr::<
       (# max: @integer; pop: @boolean
       do (if not sourceIsRef then
              (thisChOp,rA[],rA.size)->mch.stCst;
              this(TxtCstVal)[]->V[];
              rA.freeAdr
           else
              rA[] -> loadtextConst;
              (rA[],false,none,EHchain[])->mkRefEvval->V[]
              (* do we ever come here? In this case chain is for the left-side,
               * NOT for the right-side - this may be a problem??
               * However, the constructed RefEvVal will have sourceEV=none
               * (here destEV here), chain will probably never be used?
               *)
          if);
          (*rA.freeAdr - see FEJL/text2ref.bet *)
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; dEV,dDesc: @ASTindex; mn,dKind,max: @integer;
          RC: ^DH.superChain; found,pop: @boolean
       do destEV.son->dEV;
          (rAbase[],dEV[],false,rChain[]) -> genAdr -> rA[];
          (if not sourceIsRef then 
              (* assign to a char var - not possible? *)
              
              cError(#do 'txtCstVal:asgToRefAdr'->xT #);
              this(TxtCstVal)[]->V[]
           else
              rA[] -> loadTextConst;
              (rChain[],dEV)->DH.theDesc->(dDesc,mn,RC[],dKind);
              (if RC.ptnForm >= sematt.virtualForm then 
                  (* virtual QUA-check is needed *)
                  (dEV[],dDesc[],raBase[],rchain[])
                    ->virtualQua
                  (# doAssign::
                       (# dest: @mch.adrRegOperand
                       do this(asgToRefAdr).rA[]->rAx[]; 
                          (*check why the rA of doAssign must be overwritten!*)
                          common.direct->rAx.access;
                          rAx.toReg2->dest;
                          dest[]->destX[]
                       #)
                  do
                   #)
               else
                  (*312->trace(#do 'txtcst:asgtorefadr'->xT; 
                   sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
                  (sematt.textDesc[],dDesc[])->sematt.chkQua->(mn,found);
                  (if not found then 
                      (* qua-check is needed, but should NEVER happen! *)
                      cError(#do 'text2ref:missing qua-check'->xT #);
              if)if);
              (rA[],false,sematt.textDesc[],rChain[])->mkRefEvval->V[]
          if);
          (*rA.freeAdr -- see FEJL/text2ref.bet *)
          (*312->trace(#do 'txtcst:asgtorefadr2'->xT; 
           sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
       #);
     asgToRepAdr::<
       (# max: @integer
       do (if stest then
              301->trace(#do 'txtcstval:asgToRepAdr: '->xT;
                           'rEv='->xT; rEv[]->xA; 
                           ' rA='->xT; rA.display->xT; 
          #)if);
          (if T.isBetaChar then (*rA.size > 1 then*)
              (rA[],rEV[],rChain[]) -> ((thisChOp).C -> mkCstEvVal).asgToRepAdr
           else
              (if common.switch[61] then
                  protectCallReg
                  (# dr: @mch.DataRegOperand;
                     A: @mch.RegAdr
                  do release; (* we MUST dealloc cTxt before pushReg, since
                               * this will confuse callBack
                               * (Inconsistent stack frame size for CB entry)
                               *)
                     mch.pushReg -> max; (* 6.12.95 *)
                     
                     (if (cTxt[] = NONE) and not callBack then
                         (rA[],0) -> CopyT
                         (#
                         do (T[],1)->gen.TextConst;
                            (4,1) -> mch.SPtoPrimReg
                         #)
                      else
                         (* (cTxt[] <> NONE) or callBack *)
                         (rA[],3) -> CopyT
                         (#
                         do 1 -> cTxt.toPrimDest;
                            (* Set BetaStackTop *)
                            A.reg.alloc;
                            ('BetaStackTop' -> mch.newTextOp,A.reg[]) 
                              -> mch.gLea;
                            4 -> A.toPrimDest;
                            A.freeAdr
                         #)-> dr;
                         (* copy dr to callReg and thisReg *)
                         (dr[],mch.callRegOp[]) -> mch.cpReg;
                         (dr[],mch.thisRegOp[]) -> mch.cpReg
                     if); 
                     max->mch.popReg 
                  #)
               else
                  (rA[],0) -> CopyT(#do (T[],1)->gen.TextConst #)
          if)if); 
          this(TxtCstVal)[]->V[]; rA.freeAdr
       #);
     asgToRepElm::<
       (#
       do (if stest then 
              301->trace(#do 'TxtCstVal:asgToRepElm: '-> xT;
                           display;
                           rEv[]->xA
                        #)
          if);
          (if rEv.son -> sematt.SimpleOrRep
           // gram.dynamicItem then
              (* we assume R: [e] ^text *)
              rA[] -> loadTextConst
           // gram.staticItem then        
              (* we assume R: [e] @char *)
              rA[] -> asgToAdr 
           else
              'TxtCstVal:asgToRepElm:illegalRepetition'->systemError
          if);
          this(TxtCstVal)[] -> V[]
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr; 
       do (rDesc[],rA[],0,rChain[],true) -> nScan;
          this(TxtCstVal)[] -> nScan.AsgToNelm -> rAx[];  
          nScan.reset
       #);
     asgToNXoffSets::
       (# off: @integer; A: ^mch.address; N: ^ASTindex
       do (* sourceISrRef means assignment to a Text-reference;
           * False means that a char is assigned to a char
           *)
          (if stest then 179->trace(#do 'TxtCstVal:asgToNXoffsest:'->xT#)if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> A[]; 
          (if NX.getKInd
           // NX.refTmp // NX.refOff then
              NX.getNode->N[]; N.son->N;
              true->SourceISRef; (* why is thus necessary?*)
              (baseAdr.copy,N[],NX.getChain) -> asgToRefAdr
           // NX.repTmp // NX.repOff then
              (A[],none,none) -> asgToRepAdr (* OBS Fix 2. and 3. argument*)
           else
              NX.getSize -> A.size;
              (thisChOp,A[],A.size) -> mch.stCst;
          if);
          A.freeAdr;

          (if stest then
              179->trace(#do 'TxtCstVal:asgToNXoffSets:'->xT; off->xI; thisCh->put#)
          if);
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[] -> inx[];
          thisCh -> inx.newConstToN;
          (*inx.eval->V[]*)
       #);

     asgToList::<(#do toListOne #);
     asgToDispatchPar::
       (# 
       do (if stest then
              301->ctrace(#do'txtCstVal:asgToDispatchPar:'->xT#)
          if);
          (if type
           // 1 then 
              thisChOp->mch.pushCbyte;
              'AddDispatchInt8' -> mch.CallPrim;
           // 2 then 
              thisChOp->mch.pushCword;
              'AddDispatchInt16' -> mch.CallPrim;
           // 3 then 
              thisChOp->mch.pushClong;
              'AddDispatchInt32' -> mch.CallPrim;
           // common.textXpar // common.wtextXpar then
              (T[],-1) ->gen.TextConst;
              'AddDispatchTxtCst' -> mch.CallPrim;
          if)
       #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            -> pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     asgToInLinePrimitive::< (*!!!!!!!!! only CHAR not TEXT !!!!! *)
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal;
          dr: @mch.dataRegOperand
       do dr.alloc; dr -> D[1]; (* mch.getData->D[1]; *)
          (thisChOp,dr[] (*D[1]->mch.NewDataRegOp*))->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes <> D[1] then D[1] -> dr; dr.deAlloc (* D[1]->mch.freeData*) if)
       #);
     pushCpar::< 
       (# S: @text
       do (if type
           // 1 then thisChOp->mch.pushCbyte
           // 2 then thisChOp->mch.pushCword
           // 3 then thisChOp->mch.pushClong
           // common.textXpar // common.wtextXpar then
              (if type = common.wtextXpar then
                  '\n*** Warning: external enter type "[...]@wchar" may not'
                  ' have been implemented!(txtcstval:pushCpar)' -> putline
              if);
              (if common.targetMachineId = common.ppcmac then
                  (if extKind 
                   // sematt.pascExt
                   // semAtt.pascTrapExt then
                      T.scanAll(#do size + 1 -> size #);
                      (if size < 255 then
                          size -> S.put;
                          S[] -> T.prePend;
                         (* 301 -> trace
                          (#do 1 -> T.inxGet -> xI; ':'->put;
                             (for i: T.length-1 repeat
                                  i+1 -> T.inxGet -> put
                             for);
                          newline
                          #)*)
                       else
		          'Pascal Text constant longer than 255 chars!' 
                            -> SystemError
                      if);
                  if);
                  (T[],-1) ->gen.TextConst;
               else 
                  (T[],-1) ->gen.TextConst;
                  (* OBS! textConst is used BOTH for C-par and primitive arg;
                   * -1 means external argument
                   *)
                  (if extKind // sematt.pascExt//semAtt.pascTrapExt then
                      0->mch.initPrimCall; 
                      protectCallReg(#do 'PpkCT'->mch.callPrim #); 
                      0->mch.getPrimRes
                      (*else 'PackConstTextToC'->mch.jsrT *)
                  if)
              if);
           else
              'Unknown type for txtCstVal:pushCpar' -> SystemError
          if);
       #);
     cmp::< (#do thisCh->lV.cstCmp->doCmp (*gCmp(#do thisCh->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do  thisCh->lV.cstAdd->res[] #);
     cstAdd::< (#do rN+thisCh->mkCstEvVal->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
	  (thisChOp,W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (thisChOp,rReg[],4)->mch.gAdd; W[]->V[] #);
     sub::<(#do thisCh->lV.cstSub->res[] #);
     cstSub::< (#do (thisCh-rN)->mkCstEvVal->V[] #);
     adrSub::< 
       (# W: @ComputedEvVal 
       do W.dr.alloc; (thisChOp,W.dr[])->mch.ldCst;
	  rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gSub#); W[]->V[] 
       #);
     regSub::< (* thisCh-lReg->W *)
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (thisChOp,W1.dr[])->mch.ldCst;
	  (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do thisCh->lV.cstTimes->res[] #);
     adrTimes::< (# W: ^evVal do mkConstEv->W[]; rA[]->W.adrTimes->V[] #);
     cstTimes::< (#do (rN*thisCh)->mkCstEvVal->V[] #);
     regTimes::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; 
          (thisChOp,rReg[],4)->mch.gMult; (* datpete 22/7/94: cstMult here??? *)
          W[]->V[]
       #);
     divMod::< (#do (thisCh,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::< (* rA div C *)
       (#
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN//0 then
              ddr.alloc;
              dr.alloc;
              (thisCh->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then (thisCh div rN)->mkCstEvVal->V[]
               else (thisCh mod rN)->mkCstEvVal->V[]
              if)
          if);
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (*Reg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     
     thisCh:
       (# c: @Char
       do (if T.isBetaChar then T.scanBeta(#do ch->c #)
           else ' OOPS char expected here!'->bugstream.putline if)
       exit c
       #);
     mkConstEv:
       (# V: ^evVal
       do thisCh->mkCstEvVal->V[]
       exit V[]
       #);
     thisChOp: (# C: @mch.cstOperand do thisCh->C exit C[] #);
     loadTextConst:
       (# rA: ^mch.Address; max: @integer
       enter rA[]
       do (if common.switch[61] then
              protectCallReg
              (#
              do mch.pushReg->max;
                 4 -> mch.initPrimCall;
                 (T[],1) -> gen.textConst; (* FIX this one to primReg *)
                 2 -> rA.pushRegAndOff;
                 (4,1) -> mch.SPtoPrimReg;
                 'MkTO'->mch.callPrim;
                 0->mch.getPrimRes;
                 max->mch.popReg;
              #)
           else
              mch.pushReg->max;
              3 -> mch.initPrimCall;
              (T[],1)->gen.textConst; 
              rA.pushRegAndOff;
              'MkTO'->mch.callPrim;
              0->mch.getPrimRes;
              max->mch.popReg;
          if);
       #);
     T: @Text; evalKind: @integer; 
     cTxt: ^mch.dataRegOperand; (* if cTxt[] <> NONE then this(TxtCstVal)
                                   * represents a text returned from C.
                                   * cTxt is a register denoting the txt.
                                   * The txt may be a callback parameter or
                                   * the result of an external call.
                                   * callBack is true if callBack
                                   *)
     callback: @boolean;
  enter T
  #);
TxtVarVal: EvVal
  (# thisVal::<
       (# V: @TxtVarVal 
       do (baseAdr[],EV[],evalKind,slice)->V ; V[]->thisV[] 
       #);
     evId:: (# do 'TxtVarVal:'-> id[] #);
     display::< 
       (#
       do 'EV='->xT; EV[]->xA; xN;
          'baseAdr=' -> xT; baseAdr.display->xT 
       #); 
     theReg:: (#do baseAdr.theReg -> aR #);
     release::<
       (# delay: @boolean
       enter delay
       do baseAdr.freeAdr; 
          (if not delay then none->baseAdr[]; none->EV[] if)
       #);
     loadVal::< (#do cError(#do 'TxtVarVal:loadVal'->xT #)#);
     loadVal2::< (#do cError(#do 'TxtVarVal:loadVal2'->xT #)#);
     toTmp::<
	(#
	do (if baseAdr.useCallReg then
               baseAdr.toTmp->baseAdr[];
           if)
	#);
     elimReg::< (# do (elimThis,elimCall)->baseAdr.elimReg #);
     toDataRegA:: (* return txt from COM virtual *)
       (# 
       do PushCpar(#do 4 -> returnType #)
       #);
     toDataReg::<
	(# A: ^mch.address; EV1: @ASTindex
	do EV.son->EV1; 
           (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
	   common.cstInd->A.access; 
           4->A.size; (* ugly, fix for SPARC *)
           (A[],dReg[])->mch.ldVal; 
           A.freeAdr; 
           release; (*!!*)
	#);
     asgToRepAdr::< 
	(* rA is the address of a repetition;
	 * assign the repetition denoted by A to rA 
	 *)
	(# EV0,EV1,EV2: @ASTindex; V1,V2: ^evVal; W: @computedEvVal;
	   A: ^mch.address; callRegOnStack,pop,old61,unFreeze: @boolean;
           dR1: ^mch.dataRegOperand; chain1: ^DH.SuperChain;
           pDest: ^mch.mOperand; p: @integer; c: @char; T: @text
	do (if stest then 
               301->ctrace
               (# 
               do 'TxtVarVal:asgToRepAdr: EV=' -> xT; EV[]-> xA; xN;
                  'baseAdr=' -> xT; baseadr.display->xT;
                  mch.dumpreg;
                  EHchain.print
               #)
           if);
           (if EHchain[] = NONE then
               cError(#Do 'EHchain is none'-> xT #)
           if);
           EHchain[]->chain1[];
           (if baseAdr.regType // mch.thisO // mch.callO then 
            else
               (if switch180 or switch181 then
                   (if not baseAdr.frozenReg then (* 27.12.97: v5.4 *)
                       baseAdr.freezeReg; (* 11/5/99: used to be freeReg??*)
                       true -> unFreeze
                   if)
                else
                   AllocCallReg -> callRegOnstack;
                   baseAdr.toCallReg->baseAdr[]
               if)
           if);
	   EV.son->EV0; 
           (* Note: in the computation of ev1,ev2 below, V1 and V2 may be 
            * addressed via callReg, which may be destroyed/released during
            * generation of genAdr. GenAdr has been moved to after if-imp
            *)
           6 -> mch.initPrimCall ;
           (if slice then
               EV0.brother->EV1; EV1.brother->EV2;  
	       (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
               V1.toDataReg->dR1[]; dR1->W.dr;
               (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];

               4->mch.getPrimReg->pDest[];
               (if pDest.isPrimRegop then
                   (W.dr[],pDest[]) -> mch.cpReg
                else
                   (W.dr[],pDest[]) -> mch.stval
               if);
               W.release;
               5->V2.toPrimDest;
               V2.release;
               (* NOTE: toPrimDest should do the release, but this
                * gives problems in dobody:if; see scmp in synthlib.bet
                *)
               6->p
            else 4->p
           if);
           (* compute address of EV/EV0 *)
           baseAdr.copy -> A[];
           (A[],EV0[],false,chain1[]) -> genAdr -> A[];
           common.direct->A.access;  
           4->A.size; (* ugly, fix for SPARC *)
           
           1 -> A.toPrimDest;
           (if mch.callRegInPrimReg2 and mch.callRegBusy then
               (false,true) -> mch.pushThisOrCall;
               true->pop
           if);

           common.switch[61] -> old61; true->common.switch[61];
           2 -> rA.pushRegAndOff; (* 2 - 3 *)
           old61 -> common.switch[61];
           

           EV0[] -> sematt.RepSize -> c; 
	   (if not slice then 
	       (if evalKind 
	        // sematt.repValEval then 'CopyVR'->T; c -> T.put; 
	        // sematt.repRefEval then 'CopyRR'->T; 
	       if);
               (p,1) -> mch.SPtoPrimReg;
	    else
               (if evalKind 
	        // sematt.repValEval then 'CopySVR'->T; c -> T.put; 
	        // sematt.repRefEval then 'CopySRR'->T;
	       if);
               (if common.switch[79] then
                   (p,1) -> mch.SPtoPrimReg;
               if)
           if);
	   A.freeAdr; rA.freeAdr;
           
           T -> mch.callPrim;
           (* double CallReg push/pop may happen here: 
            * one for  A and one for rA - should be cleaned up
            *)
           (if pop then (false,true) -> mch.popThisOrCall if);
           0->mch.getPrimRes; (* must match initPrimCall *)
	   callRegOnStack->PopCall;
           (if unFreeze then false -> baseAdr.frozenReg if);
	   this(TxtVarVal)[]->V[]; 
           (if stest then
               179->trace(#do 'txtVarVal:AsgToRepAdr:exit:'->xT; mch.dumpreg #)
           if)
        #);
     asgToRepElm::<
       (#
       do (if stest then
              301->trace(#do 'TxtVarVal:asgToRepElm: '-> xT #)
          if);
          rA[] -> asgToAdr;
          this(TxtVarVal)[] -> V[]
       #);
     asgToCproc::<
       (* 'A' cannot be an InxRegAdr! *)
       (# CP: @ExTernalCall
       do true->release; 
          (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            ->pushCpar;
          CP.call;
          CP.getExitP->V[];
       #);
     pushCpar:: (* type = 4 for text *)
       (# EV0,EV1,EV2: @ASTindex; A: ^mch.address; V1,V2: ^evVal; 
          pReg: ^mch.mOperand; chain1: ^DH.SuperChain;
          returnType: @integer;
          isWtext: @boolean;
          mkEntry: @
            (# T: @text
            enter T
            do (if isWtext then
                   '_W' -> T.append
               if)
            exit T
            #);
               
       do (if type
           // common.textXpar then
           // common.wtextXpar then
              true -> isWtext;
              '\n*** Warning: external enter type "[...]@wchar" may not'
              ' have been implemented!(txtvarval:pushCpar)' -> putline
           else
              'TxtVarVal:pushCpar:unKnownType'-> systemError
          if);
          EHchain[]->chain1[];
          (* common.cstInd->A.access; !!!!*)
          (if released then reAlloc if);
          EV.son->EV0;
	  (if slice then 
              EV0.brother->EV1; EV1.brother->EV2;
              (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
              (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
              (if common.switch[61] then 4->mch.initPrimCall 
               else 3->mch.initPrimCall
              if)
           else 
              (if common.switch[61] then 2->mch.initPrimCall
               else 1->mch.initPrimCall
              if)
	  if);
          EV.son->EV1; (baseAdr.copy,EV1[],false,chain1[])->genAdr->A[];
          4->A.size; (* ugly, fix for SPARC *)
          1->mch.getPrimReg->pReg[];
          (A[],pReg[])->mch.ldVal;
          A.freeAdr; (* OLM: 2/5/99 *)
          (if not slice then
              (if common.switch[79(*61*)] then (2,0) -> mch.SpToPrimReg if);
              protectCallReg
              (#do (if extKind // sematt.pascExt // semAtt.pascTrapExt then
                       'PpkVT' -> mkEntry -> mch.callPrim
	            else 'CpkVT' -> mkEntry -> mch.callprim 
              if)#)
           else (* OBS new primitive OPs to be called here *)
              (* Note: on some architectures (e.g. mips), primReg2 and
               * callreg is the same register; V2 may use callReg and
               * 2->V1.toPrimDest should therefore protect callReg.
               * See synthlib:EvVal:ProtectCallReg
               *)
              3->V2.toPrimDest;  
              ProtectCallReg
              (#
              do 2->V1.toPrimDest;
                 (* should V1, V2 be  released? Perhaps also in asgToRepAdr?*)
                 (if common.switch[79(*61*)] then (4,0) -> mch.SpToPrimReg if);
	         (if extKind // sematt.pascExt // semAtt.pascTrapExt then
                     'PpkSVT' -> mkEntry -> mch.callPrim
	          else 'CpkSVT' -> mkEntry -> mch.callprim 
                 if)
              #)
          if);
          
          2 -> returnType;
          INNER; (* added to handle return from COM virtual;
                  * called from toDataReg will overwrite returnType
                  *)
          returnType -> mch.getPrimRes;
          none->baseAdr[];
       #);
     toPrimDest::<
       (# A: ^mch.address; EV1: @ASTindex;
          dr: ^mch.dataRegOperand
       do EV.son->EV1; (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
          common.cstInd->A.access; 
          4->A.size; (* ugly, fix for SPARC *)
          (if primDest.isPrimRegOp then
              (A[],primDest[])->mch.ldVal
           else
              (if ((A[],primDest[]) -> mch.cpMem -> dr[]) <> NONE then
                  dr.deAlloc
              if)
          if);
          A.freeAdr
	#);
     asgToItem::<
        (* A -> EV.N1 *)
	(# nScan: @ | scanNadr
	do (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(TxtVarVal)[]->nScan.asgToNelm -> rAx[];
           nScan.reset
	#);
     asgToNXoffSets::
       (* baseadr = basis address for this(txtVarVal)
        * rA = address in enter part (nxoffSets)
        *)
       (# off: @integer; rAx: ^mch.address; dr: ^mch.dataRegOperand 
       do (if stest then
              179->trace
              (#
              do 'TxtVarVal:asgToNXoffSets: '-> xT; EV[] -> xA;
                 xN; 'baseAdr = ' -> xT; baseAdr.display->xT;
                 xN; 'rA = ' -> xT; rA.display -> xT 
              #)
          if);
          NX.getNext -> off;
          off -> (rA.copy).addOff -> rAx[]; 
          (if stest then
              179->trace
              (#do 'TxtVarVal:asgToNXoffSets2: '-> xT; off->xI; 
                 '\n\t rAx = ' -> xT; rAx.display->xT
              #)
          if);
          (*common.varInd -> rAx.access;*)
          (**** see nxoffsetsval:asgToNxOffSet: repTmp case *****)
          (* Is baseAdr for this(txtVarVal) the address of EV
           * or a baseAdr to be used to compute the adrress of EV.
           * For some cases that latter is true ie it is OK to call
           * asgToRepAdr; in other cases the latter is true and
           * cpMem should be called
           *)
          (if NX.getKind
           // NX.repTmp // NX.repOff then 
              (rAx[],none,none) -> asgToRepAdr (*OBS. Fix 2. and 3. argument *)
           // NX.refTmp // NX.refOff then
              cError(#do 'TxtVarVal:asgToNXoffSets:notRep,butRef'-> xT #)
           else
              cError(#do 'TxtVarVal:asgToNXoffSets:not rep'-> xT #)
          if);
          baseAdr.freeAdr;
          (* rA is exited *)
       #);
     asgToList::<(#do toListOne #);
     baseAdr: ^mch.address; 
     evalKind: @integer; (* repValEval or repRefEval *)
     EV: ^ASTindex; slice: @ Boolean
  enter(baseAdr[],EV[],evalKind,slice)
  #);
DoubleEvVal: EvVal
  (# thisVal::<(#V: @DoubleEvVal do (drX,drY)->V; V[]->thisV[] #);
     evId:: (# do 'DoubleVal:'-> id[] #);
     display::<(#do 'dReg='->xT; drX->xI; drY->xI #);
     reUse: (# do drX->drX.reUse; drY->drY.reuse #);
     needExtraAreg:: (# do false -> value #);     
     loadVal::<(#do this(DoubleEvVal)[]->V[] #);
     loadVal2::<(#do loadVal->V[] #);
     release::<(#do drX.deAlloc; drY.deAlloc #);
     realloc:: (# do drX -> drX.reUse; drY -> drY.reUse #);
     evType::<(#do 3->type#);
     mkReal::<(# do this(DoubleEvVal)[]->V[] #);      
     loadFloat::<
	(# FR: @mch.floatRegOp
	do FR.alloc; drY[]->mch.pushClong; drX[]->mch.pushClong; release;
	   &mch.stackTopAdr[]->FR.load; 
           FR[]->res[]
	#);
     AsgToRepAdr::<
       (#
       do (if stest then
              301->trace(#do 'DoubleVal:asgToRepAdr:'->xT; display#)
          if);
          (true,8(*size*),1(*range*),rA[]) -> asgToNewRep
          (#
          do NextElmAdr -> asgToRealAdr
          #);
          rA.freeAdr;
          this(DoubleEvVal)[] -> V[]
       #);
     AsgToRepElm::
       (#
       do (if rA.size = 8 then
              rA[] -> AsgToRealAdr
           else
              rA[] -> AsgToAdr
          if);
          rA.freeAdr;
          this(DoubleEvVal)[] -> V[] 
       #);
     AsgToAdr::<
       (* NOTE; This is just for eperimenting with returing int64 values
        * from external routines - see genexternal
        *)
       (# rAx: ^ mch.address
       do (if stest then
              301->trace(#do 'DoubleEvVal:asgToAdr:size'->xT; ra.size -> xI; xN#)
          if);
          (if rA.size
           // 8 then
              rA.copy -> rAx[];
              (*4 -> rAx.size;*)
              (drX[],rAx[])->mch.stVal; 
              (drY[],4->rAx.addOff)->mch.stVal;
           // 4 then (drY[],rA[])->mch.stVal
           // 2 then (drY[],rA[])->mch.stHalf
           // 1 then (drY[],rA[])->mch.stByte
          if);
          rA.freeAdr; 
          this(DoubleEvVal)[]->V[]
       #);
     AsgToRealAdr::<
	(#do (drX[],rA[])->mch.stVal; (drY[],4->rA.addOff)->mch.stVal;
	     rA.freeAdr; this(DoubleEvVal)[]->V[]
        #);
     rCmp::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; 
           (lV[],op,jmpCond,lab[])->FV.rCmp->res[]
	#);
     unMinus::<
       (# FR: ^mch.floatRegOp 
       do loadFloat->FR[]->mch.negFloat; FR[]->mkFloatEvVal->res[]
       #);
     rAdd::< (* lV + this(DoubleEvVal) *)
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rAdd->res[]
	#);
     rSub::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rSub->res[]
	#);
     rMult::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rMult->res[]
	#);
     rDiv::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rDiv->res[]
	#);
     asgToItem::<
	(# W: @computedEvVal; A: ^mch.address; nScan: @ | scanNadr
	do (*352->trace(#do 'DoubleEvVal:asgToItem'->T #);*)
	   (if (rDesc->sematt.realDesc.equal) then
		rA.copy->A[];
               (*352->trace(#do 'ToRealDesc'->T #);*)
		12->A.addOff; drX->W.dr; A[]->W.asgToAdr;
		4->A.addOff; drY->W.dr; A[]->W.asgToAdr;
            else 
               (rDesc[],rA[],0,rChain[],true)->nScan;
               this(DoubleEvVal)[]->nScan.asgToNelm -> rAx[];
               nScan.reset
	   if)#);
     asgToNxOffsets:: 
       (# off: @integer
       do (if stest then
              178-> trace(#do 'doubleVal:asgToNxoffSets:'-> xT #)
          if);
          NX.getNext -> off;
          (if NOT (inXpart AND (NX.getKind = NX.valOff)) then
              off -> (rA.copy).addOff -> asgToRealAdr    
          if);
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do release; (* see also pushCpar *)
          (externalName,Desc[],extKind,EV.son)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
            -> pushCpar;
          CP.call; CP.getExitP->V[]; 
       #);
     pushCpar::< 
       (#
       do (if released then reAlloc if);
          drX[]->mch.pushClong;
          drY[]->mch.pushClong; 
          release;(* may have been done by asgToCproc *)
       #);
     drX,drY: @mch.dataRegOperand;
  enter(drX,drY)
  #);
FloatEvVal: EvVal
  (# thisVal::<(# V: @FloatEvVal do FL->V; V[]->thisV[] #);
     evId:: (# do 'FloatVal:'-> id[] #);
     display::< (#do '%frNo='->xT;  FL.rn->xI #);
     reUse: (# do  #);
     needExtraAreg:: (# do false -> value #);     
     loadVal::<(#do this(FloatEvVal)[]->V[] #);
     loadVal2::<(#do this(FloatEvVal)[]->V[] #);
     release::<(#do FL.deAlloc #);
     reAlloc::<(#do FL.rN->FL.reUse #);
     evType::<(#do 3->type#);
     mkReal::<(# do this(FloatEvVal)[]->V[] #);      
     toDataRegA:: 
       (#
       do 'FloatEvVal:toDataRegA: BETA call-back cannot return a float'
            -> SystemError
       #);
     toDataRegX:: (#do (FL[],mch.dataRegX[]) -> mch.float2int #);
     toDataRegY:: (#do (FL[],mch.dataRegY[]) -> mch.float2int #);
     toRangeReg:: (#do (FL[],mch.dataRegB[]) -> mch.float2int #);
     toDataReg:: (#do (FL[],dReg[]) -> mch.float2int #);
     toPrimDest::
       (# 
       do (if primDest.isPrimRegOp then
              (FL[],primDest[]) -> mch.float2int 
           else
              (# dr: @mch.dataRegOperand
              do dr.alloc;
                 (FL[],dr[]) -> mch.float2int ;
                 (dr[],primDest[]) -> mch.stVal;
                 dr.deAlloc;
              #)
          if)
       #);
     asgToAdr::< 
       (# D: ^mch.dataRegOperand; 
       do rA[]->FL.store2Int->D[]; 
          (D,false,false,false)->mkComputedEvVal->V[]
       #);
     asgToRealAdr::< 
       (#
       do (if stest then
              301 -> trace
              (#do 'FloatVal:asgToRealAdr:'->xT; display; rA.display->xT #)
          if);
          rA[]->FL.store; 
          (if mch.floatStackUnit then 
              release; rA[]->mkRealEvVal->V[]
           else rA.freeAdr; this(FloatEvVal)[]->V[] 
          if)
       #);
     AsgToRepAdr::<
       (#
       do (if stest then
              301->trace(#do 'FloatVal:asgToRepAdr:'->xT; display#)
          if);
          (true,8(*size*),1(*range*),rA[]) -> asgToNewRep
          (#
          do NextElmAdr -> asgToRealAdr
          #);
          rA.freeAdr;
          this(FloatEvVal)[] -> V[]
       #);
     AsgToRepElm::
       (#
       do (if rA.size = 8 then
              rA[] -> AsgToRealAdr
           else
              rA[] -> AsgToAdr
          if);
          rA.freeAdr;
          this(FloatEvVal)[] -> V[] 
       #);
     loadFloat::< (#do FL.rn -> FL.reuse; FL[]->res[] #);
     getFloatArg::<
       (#
       do (if stest then
              301->trace(#do 'floatVal:getFloatArg:'->xT; display#)
          if);
          FL[]->F[]; true->inFreg 
       #);
     rCmp::<
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand (*address*)
	do FL.storeTmp->A[]; (* when is A released *)
          (A[],lV.loadFloat->LF[],0,false,false)->doCmp;
          LF.deAlloc
	#);
     unMinus::<
       (#
       do FL[]->mch.negFloat; 
          FL.rN->FL.reUse; 
          FL[] -> mkFloatEvVal -> res[]
          (* used to be:
           *      this(FloatEvVal)[]->res[] 
           *)
       #);
     rAdd::< (* lV + this(FloatEvVal).FL *)
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal;
          F: ^mch.mOperand; inFreg: @boolean
       do (if stest then
              301 -> trace
              (#do 'floatRegOp:rAdd:' -> xT; display;
                 ' lV:'->xT; lV.display
              #)
          if);
          lV.getFloatArg -> (F[],inFreg);
          (FL[],F[],inFreg) -> mch.addFloat;
          (* FL hold result:
           * FL.reUse is made since binop will release this(floatEvVal)
           * we return a new floatEvVal, since this(floatEvVal)
           * is release and even if FL.reUse has been made,
           * a subsequent release will never make a FL.deAlloc
           *)
          FL.rN->FL.reUse;  
          FL[]->mkFloatEvVal->res[]
          (* used to be
              FL.rN->FL.reUse;  
              this(FloatEvVal)[]->res[]
           *)
	#);
     rSub::< (* lV + this(DoubleEvVal) *)
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
       do (if stest then
              301 -> trace
              (#do 'floatRegOp:Sub:' -> xT; display;
                 ' lV:'->xT; lV.display
              #)
          if);          
          lV.loadFloat->LF[];
          FL.storeTmp->A[];
          (LF[],A[],false)->mch.subFloat;
          LF->Fval; 
          Fval[]->res[];
          (* problem to do as for rAdd, since this will switch
           * the order of the arguments to subFloat
           *)
          release (* not really necessary, since binop does release?*)
	#);
     rMult::<
	(# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
	do lV.loadFloat->LF[]; 
           FL.storeTmp->A[];
	   (LF[],A[],false)->mch.mulFloat;
	   LF->Fval; 
           Fval[]->res[]
	#);
     rDiv::<
	(# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
	do lV.loadFloat->LF[]; 
           FL.storeTmp->A[];
	   (LF[],A[],false)->mch.divFloat;
	   LF->Fval; 
           Fval[]->res[]
	#);
     asgToItem::<
	(# nScan: @ | scanNadr
	do (*352->trace(#do 'FloatEvVal:asgToItem'->T #);*)
           (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(FloatEvVal)[]->nScan.asgToNelm -> rAx[];
           nScan.reset
	#);
     asgToNxOffsets:: 
       (# off: @integer
       do (if stest then
              178->trace(#do 'floatVal:asgToNxoffSets:'-> xT #)
          if);
          NX.getNext -> off;
          (if NOT (inXpart AND (NX.getKind = NX.valOff)) then
              off -> (rA.copy).addOff -> asgToRealAdr    
          if);
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
	(# CP: @ExTernalCall
        do release; (* see also pushCpar *)
	   (externalName,Desc[],extKind,EV.son)->CP; (* init *)
	   (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
             -> pushCpar;
	   CP.call; CP.getExitP->V[]; 
	#);
     pushCpar::< 
	(# doRelease: @boolean; dr: @mch.dataRegOperand;
	do (if released then reAlloc; true -> doRelease if);
           (if type
            // common.byteXpar 
            // common.shortXpar
            // common.longXpar then
               dr.alloc;
               (FL[],dr[]) -> mch.float2int;
               (if type
                // common.byteXpar then dr[]->mch.pushCbyte
                // common.shortXpar then dr[]->mch.pushCword
                // common.longXpar then dr[]->mch.pushClong
               if);
               dr.deAlloc;
            // common.doubleXpar then
               FL[]->mch.pushCfloat; 
           if);
           (if doRelease then
               (* in this case 'release' will not work, since
                * 'released=true' will prevent 'release' to be executed
                *)
               FL.deAlloc
            else
               release
           if)
	#);
     FL: @mch.floatRegOp
   enter FL
   #);
RealEvVal: EvVal
  (# thisVal::< (* NOTE: super thisVal has true->released! *)
       (# do A[]->mkRealEvVal->thisV[] #);
     evId:: (# do 'RealVal:'-> id[] #);
     display::<
       (# 
       do 'A='->xT; A.display->xT;
          (if released then 'R+'->xT else 'R-'->xT
       if)#); 
     evType::<(#do 3->type #);
     needExtraAreg:: (# do false -> value #);
     theReg::<(#do A.theReg -> aR #);
     release::<
       (#do (*351->trace(#do 'ReavEvval:release'->T; display#);*) A.freeAdr #);
     (* reAlloc::< *)
     mkReal::<(# do this(RealEvVal)[]->V[] #);      
     loadVal::<(#do this(RealEvVal)[]->V[]#);
     loadVal2::<
       (# fVal: @floatEvVal; F: ^mch.floatRegOp
       do loadFloat->F[]; F->Fval; release; Fval[]->V[]
       #);
     toTmp::< (#do(if A.useCallReg then A.toTmp->A[] if)#);
     elimReg::< (# do (elimThis,elimCall)->A.elimReg #);
     toDataRegA:: 
       (#
       do 'FloatEvVal:toDataRegA: BETA call-back cannot return a float'
            -> systemError
       #);
     toDataRegX:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegX[]) -> mch.float2int; FL.deAlloc
       #);
     toDataRegY:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegY[]) -> mch.float2int; FL.deAlloc
       #);
     toRangeReG:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegB[]) -> mch.float2int; FL.deAlloc
       #);
     toDataReg:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],dReg[]) -> mch.float2int; FL.deAlloc
       #);
     toPrimDest::
       (# FL: @mch.floatRegOp; dr: @mch.dataRegOperand
       do FL.alloc; A[]->FL.load; 
          (if primDest.isPrimRegOp then
              (FL[],primDest[]) -> mch.float2int;
           else
              dr.alloc;
              (dr[],primDest[]) -> mch.stVal;
              (FL[],dr[]) -> mch.float2int;
              dr.deAlloc;               
          if);
          FL.deAlloc
       #);
     (* getRefEval::<; theAdr::<; adrVal::< *)
     real2int:
       (# A: ^mch.address; 
          dr: @mch.dataRegOperand;
          FL: @mch.floatRegOp;
       enter A[]
       do FL.alloc; 
          dr.alloc;
          A[]->FL.load; 
          (FL[],dr[]) -> mch.float2int;
          FL.deAlloc;
       exit dr[]
       #);
     asgToAdr::<
       (# FL: @ mch.floatRegOp;  D: ^mch.dataRegOperand
       do FL.alloc; A[]->FL.load; rA[]->FL.store2int->D[];
          Release; rA.freeAdr;
	  (D,false,false,false)->mkComputedEvVal->V[]
       #);
     asgToRealAdr::<
       (# A1,A2: ^mch.address; dr: ^mch.dataRegOperand
       do (if stest then
              301 -> trace
              (#do 'FloatVal:asgToRealAdr:'->xT; display; rA.display->xT #)
          if);
          (A[],rA[])->mch.cpMem->dr[]; 
          (if dr[]<>none then dr.deAlloc if);
          A.copy->A1[]; rA.copy->A2[];
          (4->A1.addOff,4->A2.addOff)->mch.cpMem->dr[];
          (if dr[]<>none then dr.deAlloc if);
          rA.freeAdr; this(RealEvVal)[]->V[];
          (*351->trace(#do 'RealEvVal:asgToRealAdr'->T; V.display #)*)
       #);
     AsgToRepAdr::<
       (#
       do (if stest then
              301->trace(#do 'RealVal:asgToRepAdr:'->xT; display#)
          if);
          (true,8(*size*),1(*range*),rA[]) -> asgToNewRep
          (#
          do NextElmAdr -> asgToRealAdr
          #);
          rA.freeAdr;
          this(RealEvVal)[] -> V[]
       #);
     AsgToRepElm::
       (#
       do (if rA.size = 8 then
              rA[] -> AsgToRealAdr
           else
              rA[] -> AsgToAdr
          if);
          rA.freeAdr;
          this(RealEvVal)[] -> V[] 
       #);
     asgToItem::<
       (# W: @computedEvVal; A: ^mch.address; nScan: @ | scanNadr
       do (*352->trace(#do 'RealEvVal:asgToItem'->T #);*)
          (rDesc[],rA[],0,rChain[],true)->nScan; 
          this(RealEvVal)[]->nScan.asgToNelm -> rAx[];
          nScan.reset
       #);
     asgToNxOffsets:: 
       (# off: @integer
       do (if stest then
              179->trace(#do'realVal:asgToNxoffSets:'-> xT#)
          if);   
          NX.getNext -> off;
          (if NOT (inXpart AND (NX.getKind = NX.valOff)) then
              off  -> (rA.copy).addOff -> asgToRealAdr    
          if);
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (if A._struc = mch.InxRegAdr## then
              (* The execution of CP will push all busy registers, including
               * the ones possibly used by A. If A is a repetition index, like
               * R[i], A will be an instance of InxRegAdr. If release is called
               * for A, the adr. register will be cleared. This happens
               * before A is pushed and will thus result in an error. In this
               * case A is move to a dataregister before the release.
               * It would be better to have a cleaner solution
               *)
              loadVal2->V[];
              (EV[],externalName[],desc[],extKind)->V.asgToCproc->V[]
           else              
              release; (* see also pushCpar *)
              (externalName,Desc[],extKind,EV.son)->CP; (* init *)
              (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)
                -> pushCpar;
              CP.call; CP.getExitP->V[]; 
          if)
       #);
     (* asgToPrimitive::< asgToInlinePrimitive::< *)
     pushCpar::< 
       (# dr: ^ mch.dataRegOperand
       do (if released then reAlloc if);
          (if type
           // common.byteXpar 
           // common.shortXpar
           // common.longXpar then
              A[] -> real2int -> dr[];
              (if type
               // common.byteXpar then dr[]->mch.pushCbyte
               // common.shortXpar then dr[]->mch.pushCword
               // common.longXpar then dr[]->mch.pushClong
              if);
              dr.deAlloc;
           // common.doubleXpar then
              A[]->mch.pushCdoubleAdr;
           else
              'realVal:pushCpar:unknown type' -> systemError
          if);
          release; (*may have been done by asgToCproc*)
       #);
     rCmp::<
       (# LF: ^ mch.floatRegOp
       do (A[],lV.loadFloat,0,false,true)->doCmp
          (* Release?*)
       #);
     unMinus::<
       (# Fval: @floatEvVal; F: ^mch.floatRegOp
       do loadFloat->F[]->mch.negFloat; F->Fval; Release; Fval[]->res[] 
       #);
     (* they following operations are only there to avoid compiler chrash;
      * they do not give meaningful results!
      *)
     notExp::< (#do 1->mkCstEvval->res[] #);
     orr:: <(#do A[]->lV.adrOr->res[] #);
     adrOr::< (#do 1->mkCstEvval->V[] #);
     cstOr::< (#do 1->mkCstEvval->V[] #);
     regOr::< (#do 1->mkCstEvval->V[] #);
     andd::< (#do A[]->lV.adrAnd->res[] #);
     adrAnd::< (#do 1->mkCstEvval->V[] #);
     cstAnd::< (#do 1->mkCstEvval->V[] #);
     regAnd::< (#do 1->mkCstEvval->V[] #);
     
     rAdd::< (* lV + this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.addFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     rSub::< (* lV - this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do (if stest then
              301 -> trace
              (#do 'RealVal:Sub:' -> xT;
                 display;
                 ' lV:'->xT; lV.display
              #)
          if);          
          
          lV.loadFloat->LF[]; 
          (LF[],A[],false)->mch.subFloat;
          LF->Fval; 
          Release; 
          Fval[]->res[]
       #);
     rMult::< (* lV * this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.mulFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     rDiv::< (* lV / this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.divFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     loadFloat::< 
       (# FL: @ mch.floatRegOp 
       do FL.alloc; A[]->FL.load; Release; FL[]->res[] 
       #);
     getFloatArg::<
       (#
       do (if stest then
              301->trace(#do 'realVal:getFloatArg:'->xT; display#)
          if);
          A[]->F[] 
       #);
      A: ^mch.Address
  #)

