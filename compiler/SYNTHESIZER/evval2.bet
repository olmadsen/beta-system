ORIGIN 'evlib';
INCLUDE '../CHECKER/scanBetaText';
INCLUDE 'inlinNXitem'
---mkListEvVal:descriptor---
(# LV: ^ListEvVal
do &ListEvVal[]->LV[]->V[]; (evl[],thisBaseAdr[],lChain[])->LV
#)
---mkComputedEvVal:descriptor--
(# CV: ^ComputedEvVal
do &ComputedEvVal[]->CV[]->V[]; 
   dr->CV.dr; isAreg->CV.isAreg; strucRef->CV.strucRef
#)
---mkComputedAdrVal:descriptor--
(# CV: ^ComputedAdrVal
do &ComputedAdrVal[]->CV[]->V[]; 
   dr[]->CV.dr[]; isAreg->CV.isAreg; strucRef->CV.strucRef
#)
---mkTxtCstEvVal:descriptor---
(# TV: ^TxtCstVal
do &TxtCstVal[]->TV[]->V[]; T->TV.T; 
#)
---mkTxtVarEvVal:descriptor---
(# TV: ^TxtVarVal
do &TxtVarVal[]->TV[]->V[]; (A[],EV[],evalKind,slice)->TV
#)
---mkDoubleEvVal:descriptor---
(# DV: ^DoubleEvVal
do &DoubleEvVal[]->DV[]->V[]; (drX,drY)->DV
#)
---mkRealEvVal:descriptor---
(# RV: ^RealEvVal
do &RealEvVal[]->RV[]->V[]; A[]->RV.A[]
#)
---mkFloatEvVal:descriptor---
(# RV: ^FloatEvVal
do &FloatEvVal[]->RV[]->V[]; FR->RV.FL
#)
---EvalLib:attributes---
loadAdrOp: 
  (* in cases like ch: @char; a,b: @integer;
   * a*b+ch, code like addByte,ch,dataReg has to be generated.
   * ch must be loaded to dataReg since addByte(ch),dataReg only will
   * operate on 8-bit of MC68 dataReg
   *)
  (# Ax: ^mch.address; op: ^mch.mOperand; drx: @mch.dataRegOperand
  enter Ax[]
  do (if Ax.size//1//2 then (* byte/word*)
         drx.alloc; (Ax[],drx[],AX.size)->mch.ldVl; drx[]->op[];
         INNER;
         drx.deAlloc
      else (*long*) Ax[]->op[]; INNER
     if)
  #);
const2Reg:
  (# V: ^evVal; val: @integer; dr: ^mch.dataRegOperand
  enter(V[],val)
  do (if V[]=none then
         &mch.dataRegOperand[]->dr[]; dr.alloc; 
         (val->mch.newCstOp,dr[])->mch.ldCst
      else
         V.toDataReg->dr[]
     if)
  exit dr[]
  #);
primIndex:
  (* used for implementing
   *    (val,e)->X.%putByte, etc where X is a simple integer, etc.
   * A  is the address of X and dr has the value of e.
   * primIndex returns an inxRegAdr denoting the byte, etc.
   *)
  (# A: ^mch.address; dr: ^mch.dataRegOperand; size: @integer;
     IA: @mch.inxRegAdr; RA: ^mch.regAdr; 
  enter(A[],dr[],size)
  do (if size=4 then leave primIndex if);
     (if size=2 then
         (1->mch.newCstOp,dr[])->mch.logicalShiftLeft
     if);
     (0x3->mch.newcstOp,dr[],4)->mch.gAnd; (* dr mod 4 -> dr *)
     (if A.access//common.direct then
         (if A##=mch.regAdr## then
             A[]->RA[];
             RA.reg->IA.aReg; RA.off->IA.off
          else A.toReg2->IA.aReg;
             '\n***Non regAdr in primIndex: never tested!'->putLine;
         if)
      else
         '\n***Indirect in primIndex: never tested!'->putLine;
         A.toReg2->IA.aReg; 
     if);
     dr->IA.dReg; A.frozenReg->IA.frozenReg; A.size->IA.size; IA[]->A[]
  exit A[]
  #);
primGet2:
  (* get mem[A + (dr mod 4 )]  *)
  (# A: ^mch.Address; dr: ^mch.dataRegOperand; 
     size: @integer; signed: @boolean;
     V: ^evVal;
     val: @mch.dataRegOperand; 
  enter(A[],dr[],size,signed)
  do val.alloc;
     (A[],dr[],size)->primIndex->A[];
     (if size
      // 1 then val[]->mch.gClr; (A[],val[])->mch.ldByte
      // 2 then val[]->mch.gClr; (A[],val[])->mch.ldHalf
      // 4 then (A[],val[])->mch.ldVal
     if);
     (if signed then
         (if size
          // 1 then val[]->mch.SignExtByte
          // 2 then val[]->mch.SignExtWord
     if)if);
     (*A is NOT referring an object - must be cleared upon release *)
     A.freeAdr; (* is cleared if InxRegAdr - no clear needed for RegAdr *)
     (val,false,false)->mkComputedEvVal->V[]
  exit V[]
  #);
primGet:
  (# A: ^mch.Address; I1,size,reg: @integer; signed: @boolean;
     V: ^evVal; T0: @mch.dataRegOperand; 
  enter(A[],I1,size,signed)
  do T0.alloc;
     I1->A.addOff;
     (if size
      // 1 then T0[]->mch.gClr; (A[],T0[])->mch.ldByte;
      // 2 then T0[]->mch.gClr; (A[],T0[])->mch.ldHalf
      // 4 then (A[],T0[])->mch.ldVal
     if);
     (if signed then
         (if size
          // 1 then T0[]->mch.SignExtByte
          // 2 then T0[]->mch.SignExtWord
     if)if);
     (T0,false,false)->mkComputedEvVal->V[];
     (* A.aReg should denote a real object - no clear needed! *)
  exit V[]
  #);
primInxGet:
  (* inx ->R.%inxGet/byte/short/long -> val
   * R is a repetition
   * dr: register with 'inx'
   * rA: address of R
   *)
  (# rA: ^mch.address;
     dr: ^mch.dataRegOperand; val: @mch.dataRegOperand; 
     size: @integer; signed: @boolean;
     V: ^evVal; oldS14,oldS15: @boolean
  enter(dr[],rA[],size,signed)
  do common.switch[14]->oldS14; common.switch[15]->oldS15;
     true->common.switch[14]->common.switch[15];
     val.alloc;
     (if size
      // 1 then 
         (dr,true,1)->rA.index->rA[];
         1->rA.addOff->rA[];
         val[]->mch.gClr; (rA[],val[])->mch.ldByte
      // 2 then 
         (dr,true,2)->rA.index->rA[];
         2->rA.addOff->rA[];
         val[]->mch.gClr; (rA[],val[])->mch.ldHalf
      // 4 then 
         (dr,true,4)->rA.index->rA[];
         4->rA.addOff->rA[];
         (rA[],val[])->mch.ldVal
     if);
     (if signed then
         (if size
          // 1 then val[]->mch.SignExtByte
          // 2 then val[]->mch.SignExtWord
     if)if);
     (* rA.aReg does NOT denote a real object - release *)
     rA.freeAdr; (* cleared if inxRegAdr which it is! *)
     (val,false,false)->mkComputedEvVal->V[];
     oldS14->common.switch[14]; oldS15->common.switch[15]

  exit V[]
  #);

listEvVal: EvVal
  (# thisVal::<
       (#V: @ListEvVal do (evl[],thisBaseAdr[],lChain[])->V; V[]->thisV[] #);
     display::<
       (# t1:@text 
       do 'ListV:'->xT;evl[]->xA;thisBaseAdr.display->T1;T1[]->xT;
          lCHain[]->printChain
       #);
     loadVal::<(#do cError(#do 'ListEvVal: loadVal'->xT #)#);
     loadVal2::<(#do cError(#do 'ListEvVal: loadVal'->xT #)#);
     release::<
       (#
       do thisBaseAdr.freeAdr; 
          none->evl[]; none->thisBaseAdr[]; none->lChain[]
       #);
     toTmp::<
       (#do (if thisBaseAdr.useCallReg then
          thisBaseAdr.toTmp->thisBaseAdr[]; mch.decrCallReg if)#);
     elimReg::< (# do (elimThis,elimCall)->thisBaseAdr.elimReg #);
     asgToAdr::< (* (E1,E2,...)->rA *)
       (#do cError(#do 'List:asgToAdr'->xT; evl[]->xA #)#);
     asgToItem::<
       (* evl=(E1,E2,...)
        * E1 -> EV.n1; E2 -> EV.n2 ... *)
       (# nScan: @ | scanNadr;
          NA: ^Mch.Address; more,first,onStack: @boolean
       do (*350->cTrace(#do 'Assign List to Item'->T; evl[]->A #);*)
          rA[]->moveToCallReg
          (# chain1: ^DH.SuperChain
          do EHchain[]->chain1[];
             (rDesc[],thisA[]->rA[],0,rChain[],true)->nScan->more;
             (if nScan.N=1 (*isSingleObj//true*) then
                 (*350->cTrace(#do 'list->list:isSingle'->T;rDesc[]->A #);*)
                 this(ListEvVal)[]->nScan.asgToNelm
              else 
                 (if thisBaseAdr.regType//mch.thisO//mch.callO then
                     evl->AST.scanList 
                     (# EV: @AST.index
                     do currentNode->EV;
                        (* chain is valid for Left-side, 
                         * rChain for right-side *)
                        (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                          ->ExpEval->nScan.asgToNelm; 
                        nScan->more
                     #)
                  else
                     pushThis; 
                     thisBaseAdr[]->toThis->thisBaseAdr[];
                     evl->AST.scanList 
                     (# EV: @AST.index
                     do currentNode->EV;
                        (thisBaseAdr.copy,EV[],false,lChain[](*rChain[]*))
                          ->ExpEval->nScan.asgToNelm; 
                        nScan->more
                     #);
                     popThis
             if)if);
             nScan.reset;
          #)->rA[]; (* 27.4.93 *)
          (* this could be handled more efficient, since a push callReg by
           * moveToCallReg should not restore until the item has been executed.
           * Not possible with current structure.
           * Might perhaps be done by push/pop of rA in the calls to
           * asgToItem in transferEnter in evLib?
           *)
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do evl->AST.scanList
          (# Ev: @AST.index
          do currentNode->Ev;
             (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
             (rDesc[],inlNX[],rChain[])->V.asgToInlineItem
          #);
          (*inlNX[]->inx[]; inx.eval->V[]*)
       #);
     asgToList::< (* assign evl=(le1,le2,...)->EV=(re1,re2,...) *)
       (# scanRevl: @ | 
            (# 
            do EV->AST.scanList(#do currentNode->rEv; SUSPEND #)
            #);
          rEv: @AST.index;
          W: @ListEvVal ;chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          (if thisBaseAdr.regType//mch.thisO//mch.callO then
              evl->AST.scanList
              (# EV: @AST.index
              do currentNode->EV;
                 scanRevl;
                 (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                 (BA[],V[],rEv[],rChain[])->AssignValToEval->V[]; V.release
              #)
           else
              BA[]->moveToCallReg
              (#
              do pushThis; 
                 thisBaseAdr[]->toThis->thisBaseAdr[];
                 evl->AST.scanList
                 (# EV: @AST.index
                 do currentNode->EV;
                    scanRevl;
                    (thisBaseAdr.copy,Ev[],false,lChain[])->ExpEval->V[];
                    (thisA[],V[],rEv[],rChain[])->AssignValToEval->V[]; 
                    V.release;
                 #);
                 thisA[]->BA[]; popThis
              #)->BA[]; (* 27.4.93 - see asgToItem above *)
          if);
          (* return the right-side evalList, ev *)
          (ev[],BA[],rChain[])->W; W[]->V[]
       #);
     asgToCproc::<
       (# CP: @ ExTernalCall; EL: [100] ^AST.index; top,max: @integer;
          chain1: ^DH.SuperChain; inThis,pop,arg2Saved: @boolean;
          savedArg2: @mch.dataRegOperand;
       do FixBase
          (#
          do EHchain[]->chain1[];
             (externalName,Desc[],extKind)->CP; (* init *)
             (if (extKind = semAtt.virtExt) then                 
                 (EV.son,extKind->mch.xParForward) -> CP.transferObject;
             if);
             evl->AST.scanList
             (#
             do &AST.index[]->EL[top+1->top][];
                currentNode->EL[top]
             #);
             (if extKind->mch.xParForward then
                 (* For some tstcproc.bet
                  * of the RISC's: mips, ppc, sparc (eventually),
                  * callReg is the same register as the 2nd argument register.
                  * (1) Before transferring external arguments, it must be
                  *     tested if callReg is busy, and if so, callReg MUST be
                  *     saved and later restored.
                  * (2) Evaluation of an argument may involve execution
                  *     of primitive operations, like AlloI, CopyT, etc; these
                  *     primitives may use argument registers; initPrimCall
                  *     will push possible busy arg. registers and getPrimRes
                  *     will restore them .....
                  * (3) Evaluation of arguments may call Beta procedures:
                  *     Eval of e.g. arg. 3:
                  *     Push arg1,arg2 (callreg)
                  *     AlloI -> callReg(arg2)
                  *     Pop arg1,arg2   - override callReg
                  *     .... transfer enter-params to callReg 
                  *     call M12FOO
                  *     We thus SAVE calReg(arg1) in a dataRegister when
                  *     it has been evaluated.
                  *     After AlloI we dont override callReg with arg. pop.
                  *     Before external call arg1 must be restored.
                  * RE 1. It seems that NO registers are ever stored before
                  * an external call? All busy registers should be saved?
                  * We now do it for MIPS/PPC - but should it be done
                  * in general?
                  *)
                 (if common.switch[61] then
                     (*mch.pushReg -> max; - dont work
                      * since some of the registers may have been released
                      * when the external is called. And then
                      * allocated after the call and then overwritten
                      * by mch.popReg
                      *)
                     (if mch.callRegBusy and (top > 1) then
                         (false,true) -> mch.pushThisOrCall;
                         true -> pop;
                         (if thisBaseAdr.useCallReg then
                             'CallReg in use at listEvVal:asgToCproc'->cError
                 if)if)if);
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[i][],false,lChain[])
                        ->ExpEval
                        ->V[];
                      (true->CP.getEnterP,extKind,CP.getEnterP.size
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                      (if common.switch[61] and (i = 2) and (top > 2) then
                          (* par no. 2 in callReg - MUST be saved *)
                          savedArg2.alloc; (* potentially dataReg overflow
                                            * if many nested C calls in
                                            * position of par. 2 of C-calls
                                            *)
                          (mch.callRegOp[],savedArg2[]) -> mch.cpReg;
                          true -> arg2Saved;
                         (* savedArg2[] -> mch.push (*data*)
                      if)
                 for);
              else                 
                 (for i:top repeat
                      (thisBaseAdr.copy,EL[top-i+1][],false,lChain[])
                        -> ExpEval
                        -> V[];
                      (false->CP.getEnterP,extKind,CP.getEnterP.size
                      ,CP.pascExtProcInfo)
                        -> V.pushCpar;
                 for)
             if);
             (if arg2Saved then 
                 (*savedArg2[] -> mch.pop (*data*);
                 (savedArg2[],mch.callRegOp[]) -> mch.cpReg;
                 savedArg2.deAlloc
             if);
             CP.call;
             CP.getExitP->V[]; (* cp.endc *);
             (if pop then (false,true) -> mch.popThisOrCall if);
                 (*(if common.switch[61] then max -> mch.popReg if)*)
       #)#);
     asgToPrimitive::<
       (# CP: @primitiveCall; inThis: @boolean; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# n: @integer
          do evl->AST.scanlist(#do n+1->n (* this ONLY count 1 pr. elm!! *)#);
             (n,T[])->CP;
             evl->AST.Scanlist
             (# EV: @AST.index; V: ^EvVal
             do currentNode->EV;
                (thisBaseAdr.copy,EV[],false,lChain[])->ExpEval->V[];
                (3(* always long *),sematt.asmExt,0,0)->V.pushCpar;
             #);
             CP.call->V[];
       #)#);
     asgToInLinePrimitive::<
       (# xDr: [3] ^mch.dataRegOperand;  D: [3]@integer; Dmax,dRes: @integer;
          W: @ComputedEvVal; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          FixBase
          (# dR1: ^mch.dataRegOperand
          do evl->AST.scanList
             (# E: @AST.index; V: ^evVal
             do currentNode->E; 
                (thisBaseAdr.copy,E[],false,lChain[])->ExpEval->V[];
                V.toDataReg->xDr[Dmax+1->Dmax][];
                xDr[Dmax]->D[Dmax]; (*V.release; !!*)
                (*350->trace(#do mch.dumpReg #)*)
             #);
             (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
             W[]->V[];
             (for i: Dmax repeat
                  (if dRes//D[i] then else xDr[i].deAlloc if);
       for)#)#);
     asgToNewPrim::<
       (# EV1,EV2,op: @AST.index; lv,rv,V1,V2: ^evVal; 
          opCode,pos,length,val: @integer;
	  dr,lDr,rDr,pDr,wDr: ^mch.dataRegOperand; opT: ^text; A: ^mch.address;
	  ar: @mch.adrRegOperand;

          putBW:
            (* (val,byteNo)->A.putByte/Short *)
	    (* (@@A,val)->putByte/Short *) 
          (# size: @integer; bsNo: @integer
          enter size
          do evl->AST.scanList
             (# E: @AST.index; i: @integer; dr1: ^mch.dataRegOperand
             do currentNode->E;
                (if i+1->i
                 // 1 then (* val *)
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                 // 2 then (* byteNo *) 
                    E[]->getConst->(bsNo,V1[]); 
                    (if V1[]=none then
                        (if size//2 then bsNo*2->bsNo if);
                        bsNo->A.addOff->A[]
                     else
                        V1.loadVal2->V1[]; (*Check this evrywhere*)
                        V1.toDataReg->dr1[];
                        (A[],dr1[],size)->primIndex->A[]
                    if)
                if);
             #) ;
             lv.toDataReg->dr[];
             (if size
              // 1 then (dr[],A[])->mch.stByte
              // 2 then (dr[],A[])->mch.stHalf
              // 4 then (dr[],A[])->mch.stVal
             if);
             A.freeAdr; (* cleared if InxRegAdr *)
             (dr,false,false)->mkComputedEvVal->V[]
             (* A.aReg does NOT denoet a real object - must be cleared *)
          #);

          inxPut:
	    (* (val,inx)->R.inxPut/byte/short/long *)
	    (* (R,inx,val) -> inxPut/byte/short/long 
             * R is a repetition
	     * D[1]=adr(R), D[2]=inx, D[3]=val 
             *)
          (# val: ^mch.dataRegOperand;      
             size: @integer (* 0=byte, 1=word, 2=long *);
             oldS14,oldS15: @boolean
          enter size
          do common.switch[14]->oldS14; common.switch[15]->oldS15;
             true->common.switch[14]->common.switch[15];
             evl->AST.scanList
             (# E: @AST.index;; i: @integer
             do currentNode->E;
                (if i+1->i
                 // 1 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->val[];
                 // 2 then
                    (baseAdr.copy,E[],false,rchain[])->ExpEval->lv[];
                    lv.toDataReg->dr[];
                if);
             #);
             (dr,true,size)->A.index->A[];
             size->A.addOff->A[]; (* check that this works *)
             (if size
              // 1 then (val[],A[])->mch.stByte
              // 2 then (val[],A[])->mch.stHalf
              // 4 then (val[],A[])->mch.stVal
             if);
             oldS14->common.switch[14]; oldS15->common.switch[15];
             (* A.aReg does NOT denote a real object - must be cleared *)
             A.freeAdr; (* cleared if InxRegAdr *)
             (val,false,false)->mkComputedEvVal->V[]

          #);
          getConst: 
            (# E: ^AST.index; T: ^text; val: @integer; V: ^evVal
            enter E[]
            do (if E.label // gram.integerConst then
	           E.getText->T[]; 0->T.setPos; T.getInt->val
		else 
		   (thisBaseAdr.copy,E[],false,rchain[])->ExpEval->V[]
	       if)
            exit(val,V[])
            #);
	  ClrAndDeAlloc:
            (# ar: @mch.adrRegOperand
            enter ar
            do ar[]->mch.gClr; ar.deAlloc
            #)
       do EV.son-> EV1; EV1.son->EV1; Ev1.brother->op;
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
          (if op[]->sematt.primitiveToNumber->opCode
           // 9 (* putByte *) then 
	      (if EV.evalKind 
	       // sematt.simpleEval then 1->putBW
	       // sematt.repValEval then 1->inxPut
	      if)
           // 10 (* putShort *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 2->putBW
	       // sematt.repValEval then 2->inxPut
	      if)
           // 31 (* putLong *) then
	      (if EV.evalKind
	       // sematt.simpleEval then 4->putBW
	       // sematt.repValEval then 4->inxPut
	      if)
           // 19 (* (pos,length)->R.%getBits    *)
           // 20 (* (pos,length)->getSignedBits *) then
	      (* address of R is in A *)
              (# dr: @mch.dataRegOperand; pos,length: @integer
              do dr.alloc; (A[],dr[])->mch.ldVal;
	         evl->AST.scanList
                 (# E: @AST.index;; i: @integer
                 do currentNode->E;
                    (if i+1->i
                     // 1 then (* pos *) E[]->getConst->(pos,V1[])
                     // 2 then (* length *) E[]->getConst->(length,V2[]);
                    if);
                 #) ;
	         (* V1[]=nil => pos is constant
	          * V2[]=nil => length is constant
	          *)                 
	         (if (V1[]<>none) or (V2[]<>none)  then
                     (V1[],pos)->const2Reg->pDr[];
                     (V2[],length)->const2Reg->wDr[];
                     (if opCode=19 then
                         (dr[],pDr[],wDr[])->mch.gGetBits
                      else
                         (dr[],pDr[],wDr[])->mch.gGetSignedBits
                     if)
                  else
	             (if opCode//19 then 
                         (dr[],pos,length,dr[],none)->mch.getBits
	              else (dr[],pos,length,dr[],none)->mch.getSignedBits
	         if)if);
	         (dr,false,false)->mkComputedEvval->V[];
	      #)
           // 21 (* (Val,pos,length)->R.%putbits *) then 
	      evl->AST.scanList
              (# E: @AST.index;; i: @integer
              do currentNode->E;
                 (if i+1->i
                  // 1 then (* val *) E[]->getConst->(val,V[])
                  // 2 then (* pos *) E[]->getConst->(pos,V1[])
                  // 3 then (* length *) E[]->getConst->(length,V2[])
                 if);
              #);
	      A.toReg2->ar; ar.mkIndirect;
              (V[],val)->const2Reg->lDr[];
              (if v1[]=none then (* pos is constant *)
                  (if v2[]=NONE then (* pos and width are constant *)
                      (* the current case of putBits *)
                      (lDr[],pos,length,ar[],none)->mch.putBits
                   else (* length is variable *)
                      (* general case *)
                      (V2[],pos)->const2Reg->pDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                  if)
               else 
                  V1.toDataReg->pDr[];
                  (if (v2[]=NONE) then
                      (V2[],length)->const2Reg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
                   else 
                      (* pos is variable *)
                      (* general case *)
                      V2.todataReg->wDr[];
                      (lDr[],pDr[],wDr[],ar[])->mch.gPutBits
              if)if);
              (lDr,false,false)->mkComputedEvval->V[];
              (* the following call is 'inherited' from the old primitive-code
               * from gen1body! It is a coincidence that it works,since ar 
               * is marked as indirect. This should generate set 0, [%ar].
               * It works since ar is transferred by value, which does NOT
               * transfer the inDirect flag!!!! Ugly:-(
               *)
              ar->ClrAndDeAlloc;
          if)
       #);
     pushCPar::<(#do 'ListPushCpar'->NotImpl #);
     FixBase:
       (# 
       do (if thisBaseAdr.regType//mch.thisO//mch.callO then
              INNER
           else
              pushThis; thisBaseAdr[]->toThis->thisBaseAdr[];
              INNER;
              popThis
       if)#);
     
     evl: ^AST.index; thisBaseAdr: ^mch.address;
     lChain: ^DH.SuperChain;
     (* evl must be evaluated relative to thisBaseAdr *)
  enter(evl[],thisBaseAdr[],lChain[])
  #);
ComputedEvVal: EvVal 
  (# thisVal::<
       (#V: @ComputedEvVal 
       do dr->V.dr; isAreg->V.isAreg; strucRef->V.strucRef; V[]->thisV[] #);
     display::<
       (#do 'ComV:'->xT; (if isAreg then ' a'->xT else ' d'->xT if);dr->xI#);
     reUse: 
       (#
       do (if isAreg then (# aR: @mch.adrRegOperand do dr->aR.reUse #)
           else dr->dr.reUse if)
       #);
     loadVal::<(#do this(ComputedEvVal)[]->V[] #);
     loadVal2::<(#do this(ComputedEvVal)[]->V[] #);
     thisReg:
       (# RA: @mch.adrRegOperand; op: ^mch.mOperand
       do (if isAreg then dr->RA; RA[]->op[] else dr[]->op[] if)
       exit op[]
       #);
     dr: @Mch.DataRegOperand; (* result in data register 'dr' *)
     isAreg: @boolean; (* result in address register 'dr' *)
     (* this is only possible for references to dynamic objects*)
     strucRef: @boolean; (* adr. register has a structureReference,dirty! *)
     release::<
       (#
       do (if isAreg then dr->mch.freeAdr else dr.deAlloc if)
       #);
     reAlloc::< (#do reUse #);
     toTmp::<
       (#
       do (if isAreg then 
              (if dr//mch.callO then
                  (* this(ComputedEvVal) is &T[] *)
                  (# aR1,aR2: @mch.adrRegOperand
                  do dr->aR1; aR2.alloc; (aR1[],aR2[])->mch.cpReg;
                     aR2->dr;
                     mch.decrCallReg
       #)if)if)#);
     toDataRegA::< (* OBS! is d0 always free here ?*)
       (#
       do (if dr//0 then else (dr[],mch.DataRegA[])->mch.cpReg; dr.deAlloc if)
       #);
     (*toDataRegB::< 
       (#
       do (if dr//1 then else (dr[],mch.DataRegB[])->mch.cpReg; dr.deAlloc if)
      #);*)
     toDataRegX::< 
       (#
       do (if dr=7 then else (dr[],mch.DataRegX[])->mch.cpReg; release if)
       #);
     toDataRegY::<
       (#
       do (if dr//6 then else (dr[],mch.DataRegY[])->Mch.CpReg; dr.deAlloc if)
       #);
     toRangeReg::< (* OBS! is d1 always free here ? *)  
       (#
       do (if dr//1 then 
           else (dr[],mch.dataRegB[](*1->mch.NewDataRegOp*))->Mch.CpReg;
	      (* dr.deAlloc*)
          if)
       #);
     toDataReg::<
       (#
       do dReg.deAlloc; (* this was introduced in order to free an otherwise
                         * unused dataregister, which may cause data reg overflow.
                         * The code in comments below was here before the LINUX 
                         * implementation - reuse cannot be used - hopefully
                         * this correction will work!
                         *)
          dr->dReg; dr.fn->dReg.fn; 
          (*dReg->mch.freeData; dr->dReg.reUse !!*) 
       #);
     toPrimDest::<
       (# 
       do (if primDest.isPrimRegOp then
              (mkReg,primDest[])->mch.cpReg
           else
              (mkReg,primDest[]) -> mch.stVal
          if)
       #);
     evType::<(#do (if strucRef then 4->type else 1->type if)#);
     mkReal::<
       (# W: @floatEvVal; FR: ^mch.floatRegOp
       do thisReg->mch.intReg2Float->FR[]; FR->W.FL; W[]->V[]; 
          release
       #);
     asgToAdr::<
       (#
       do (if StrucRef then (thisReg,false)->rA.asgRefReg
           else (if rA.size
                 // 1 then (thisReg,rA[])->mch.stByte
                 // 2 then (thisReg,rA[])->mch.stHalf
                 else (* 4 or undefined *)
                    (* OBS! Error here!
                     * struRef may be false if the reference is computed as 
                     * a result of a TOS call as in R.struc. This is bad 
                     * since a checkRefAsg will not be generated. Also stByte
                     * is generated instead of stVal.
                     *)
                    (thisReg,rA[])->mch.stVal
          if)if);
          rA.freeAdr; (*reUse;*) this(ComputedEvVal)[]->V[] 
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; EV: @AST.index
       do destEV.son->EV;(rAbase[],EV[],false,rChain[])->genAdr->rA[];
          (if strucRef then (thisReg,false)->rA.asgRefReg
           else (* only if TOS->ref as in struc: (#do TOS'ThisS'->R[]#)
                 * See comment above
                 * AND for a data-ref returned from C via getExitP:dataRefRes
                 *)
              (thisReg,rA[])->mch.stVal
          if);
          rA.freeAdr; this(ComputedEvVal)[]->V[]
       #);
     asgToRealAdr::<
       (# FR: ^mch.floatRegOp;
       do thisReg->mch.intReg2float->FR[];
          rA[]->FR.store; FR.deAlloc; rA.freeAdr;
          this(ComputedEvVal)[]->V[] ;
          release
       #);
     asgToItem::< 
       (* A -> rA *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan;
          this(ComputedEvVal)[]->nScan.AsgToNelm; 
          nScan.reset
       #);
     asgToDataReg::
       (#
       do (*312->trace(#do'computedEvVal:asgToDataReg:'->xT #);*)
          (dr[],destDR[])->mch.cpReg;
          (*release;
           (destDR,false,false)->mkComputedEvVal->V[]*)
          this(computedEvVal)[]->V[]
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[]->inx[];
          dr[]->inx.dataRegToN;
          (*inx.eval->V[]*)
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do release;
          (externalName,Desc[],extKind)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
          CP.call;
          CP.getExitP->V[];
          (* cp.endc *)
       #);
     asgToPrimitive::<
       (# CP: @primitiveCall
       do (1,T[])->CP;
          (3(* always long *),sematt.asmExt,0,0)->(*thisEvVal.*)pushCpar;
          CP.call->V[]
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do (*dr->dr.reUse; *) dr->D[1]; 
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     asgToNewPrim::<
       (# EV1,op: @AST.index;
	  rA: ^mch.address;
       do EV.son->EV1; EV1.son->EV1; EV1.brother->op;	  
          (baseAdr.copy,EV1[],false,rchain[])->genAdr->rA[];
          (if op[]->sematt.primitiveToNumber
           // 5 (* getByte *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 
                  (rA[],dr[],1,false)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],1,false)->primInxGet->V[]
	       else 'unknow evalKind:'->putLine
              if);
           // 6 (* getShort *) then 
	      (if EV.evalKind
	       // sematt.simpleEval then 
	          (rA[],dr[],2,false)->primGet2->V[]
	       // sematt.repValEval then 
	          (dr[],rA[],2,false)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 7 (* getSignedByte *) then
	      (if EV.evalKind
	       // sematt.simpleEval then 
                  (rA[],dr[],1,true)->primGet2->V[] 
	       // sematt.repValEval then 
		  (dr[],rA[],1,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 8 (* getSignedShort *) then
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (rA[],dr[],2,true)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],2,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
           // 13 (* getLong *) then
	      (if EV.evalKind
	       // sematt.simpleEval then
		  (rA[],dr[],4,true)->primGet2->V[]
	       // sematt.repValEval then 
		  (dr[],rA[],4,true)->primInxGet->V[]
	       else 'unknow evalKind'->putline
              if)
          if);
          (*rA.freeAdr - is cleared by primGet2 *)
       #);
     pushCpar::<
       (# V: ^evval
       do (if released then reAlloc if); (* necessary for I386 *)
          (if type
           // 1 then dr[]->mch.pushCbyte
           // 2 then dr[]->mch.pushCword
           // 3 (* long *)
           // 4 (* text: may be called from itemEvVal:pushCpar *)
              then mkReg->mch.pushClong
              (* may be called from scmp, with adr. reg. *)
           // 7 (* real *) then mkReal->V[]; (7,extKind,size,0)->V.pushCpar
           // 8 then (* c *)
              1->mch.initPrimCall;
              (if common.switch[61] or common.switch[64] then
                  (mkAreg,1->mch.getPrimReg) -> mch.cpReg
               else                      
                  mkAreg->mch.pushClong;  (* should be prim *)
              if);
              protectCallReg(# do 'CopyCPP'->mch.callprim #); 
              2->mch.getPrimRes
           // 9 then  (* pascal *)
	      (univProcInfo)->mch.initExternalParams;
              2 ->mch.initPrimCall;
              mkAreg->mch.pushClong; size[]->mch.pushClong;
              protectCallReg(#do 'CopyPPP'->mch.callprim #);
              2->mch.getPrimRes
           // 11 then (* std *)
              7 ->mch.initPrimCall;
              mkAreg->mch.pushClong; size[]->mch.pushClong;
              'CopySPP'->mch.callPrim;
              2->mch.getPrimRes
	      (* others not used *)
          if);
          release
       #);
     mkTrue::< (#do d1->dr; (1->mch.NewCstOp,dr[])->mch.ldCst #);
     relOp::<
       (#
       do (# Lab: @mch.localLab
          do Lab.new;
             (if op	      (* IF T1 cc R then goto L *)
              // gram.eqExp then Lab[]->mch.gBeq
              // gram.neExp then Lab[]->mch.gBne
              // gram.ltExp then Lab[]->mch.gBlt
              // gram.leExp then Lab[]->mch.gBle
              // gram.gtExp then Lab[]->mch.gBgt
              // gram.geExp then Lab[]->mch.gBge
             if);
             dr[]->mch.gClr;
             Lab.Def
       #)#);
     relRealOp::<
       (#
       do (# Lab: @mch.localLab
          do Lab.new;
             (if op	      (* IF T1 cc R then goto L *)
              // gram.eqExp then Lab[]->mch.fBeq
              // gram.neExp then Lab[]->mch.fBne
              // gram.ltExp then Lab[]->mch.fBlt
              // gram.leExp then Lab[]->mch.fBle
              // gram.gtExp then Lab[]->mch.fBgt
              // gram.geExp then Lab[]->mch.fBge
             if);
             dr[]->mch.gClr;
             Lab.Def
       #)#);
     unMinus::<
       (# W: @computedEvVal do dr->W.dr.reUse; (dr[],4)->mch.gNeg; W[]->res[]#);
     notEXP::<
       (# W: @computedEvVal do dr->W.dr.reUse; (dr[],4)->mch.gNot; W[]->res[]#);
     cmpBoolAndJmp::
       (#
       do (cond,dr[],4,lab[])->mch.cmpBoolAndJmp
       #);
     cmp::<(#do dr->Lv.regCmp->doCmp (*gCmp(#do dr->lV.regCmp #)*)#);
     cstCmp::< (* dr COMP rC *) 
       (#
       do (*(rC[],dr[],4)->mch.gCmp *)
          rC[]->op1[]; dr[]->op2[]; 4->size; (*deAllocOp2=false*)
       #);
     adrCmp::<(* dr COMP rA *)
       (# dn: @mch.dataRegOperand
       do dn.alloc; (rA[],dn[],rA.size)->Mch.ldVl;
          (*(dn[],dr[],4)->mch.gCmp; dn.deAlloc;*)
          dn[]->op1[]; dr[]->op2[]; 4->size; true->deAllocOp1
       #);
     regCmp::<(* dr COMP rReg *)
       (#do (*(rReg[],dr[],4)->mch.gCmp*)
          rReg[]->op1[]; dr[]->op2[]; 4->size; (*deAllocOp2=false*)
       #);
     add::< (#do dr->lV.regAdd->res[] #);
     adrAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; 
          rA[]->loadAdrOp(#do (op[],dr[],4)->mch.gAdd#); W[]->V[]
       #);
     cstAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gAdd; W[]->V[]#);
     regAdd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rReg[],dr[],4)->mch.gAdd;  W[]->V[] 
       #);
     sub::< (#do dr->lV.regSub->res[] #);
     adrSub::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; rA[]->loadAdrOp(#do (op[],dr[],4)->mch.gSub#); 
          W[]->V[]
       #);
     cstSub::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gSub; W[]->V[]
       #);
     regSub::<
       (# W1: @computedEvVal 
       do dr->W1.dr.reUse; (rReg[],dr[],4)->mch.gSub; W1[]->V[] 
       #);
     times::<(#do dr->lV.regTimes->res[] #);
     adrTimes::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse;
          (if rA.size//1 then
              (# dl: @mch.dataRegOperand
              do dl.alloc; dl[]->mch.gClr; (rA[],dl[])->mch.ldByte;
                 (dl[],W.dr[],4)->mch.gMult; dl.deAlloc
              #)
           else (* MC680x0 only accepts word and long for mult*)
              rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gMult#)
          if); 
          W[]->V[] 
       #);
     cstTimes::<
       (# W: @computedEvVal
       do dr->W.dr.reUse; 
          (* datpete 22/7/94: optimization *)
          (dr[], rN[], 4) -> cstMult;
          (* (rN->mch.NewCstOp,dr[],4)->mch.gMult; *)
          W[]->V[]
       #);
     regTimes::<
       (# W: @computedEvVal 
       do rReg->W.dr.reUse; (dr[],rReg[],4)->mch.gMult; W[]->V[]
       #);
     divMod::< (#do (dr,isDiv)->lV.regDivMod->res[] #);
     cstDivMod::<
       (* dataReg alloc is messy here and below:
        * ddr.dNo1 is allocated - ddr.dNo1 takes over from dr.
        * dr is allocated a new register to avoid release problems
        * of dr and ddr
        *)
       (# ddr: @mch.doubleDataRegOperand; drx: @mch.dataRegOperand;
          W: @ComputedEvVal
       do (* dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
           * ddr.dNo1.alloc; dr.alloc;
           * drx.alloc; (rN[],drx[])->mch.ldCst; 
           * (drx[],ddr[],isDiv)->mch.gDiv; 
           * (if isDiv then
           *     ddr.dNo2->W.dr; ddr.dNo1.deAlloc
           *  else ddr.dNo1->W.dr; ddr.dNo2.deAlloc
           * if);
           * drx.deAlloc;
           *)
          (dr[],rN[],4,isDiv)->cstDiv->W.dr;
          (* if isDiv then result is dr
           * else dr has been deAllocated.
           * Alloc new dr to avoid data reg negative
           *)
          dr.alloc;
          W[]->V[]
       #);
     adrDivMod::<
       (# drx: @mch.dataRegOperand
       do dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
          ddr.dNo1.alloc; dr.alloc;
          drx.alloc; (rA[],drx[],rA.size)->mch.ldVl; 
          (*dr->ddr.dNo2.reUse;*)
          (drx[],ddr[],isDiv)->mch.gDiv; (* dr div rA *)
       #);
     regDivMod::<
       (# 
       do dr->ddr.dNo2; dr.fn->ddr.dNo2.fn; 
          ddr.dNo1.alloc; dr.alloc;
          (* rReg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* dr div rReg *)
       #);
     orr::<(#do dr->lV.regOr->res[] #);
     adrOr::< (# W: @computedEvVal 
	      do dr->W.dr.reUse; (rA[],dr[],rA.size)->mch.gOr; W[]->V[]
	      #);
     cstOr::<  
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gOr; W[]->V[]
       #);
     regOr::< 
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (dr[],rReg[],4)->mch.gOr; W[]->V[]
       #);
     andd::<(#do dr->lV.regAnd->res[] #);
     adrAnd::< 
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rA[],dr[],rA.size)->mch.gAnd; W[]->V[]
       #);
     cstAnd::< 
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rN[],dr[],4)->mch.gAnd; W[]->V[]
       #);
     regAnd::<
       (# W: @computedEvVal 
       do dr->W.dr.reUse; (rReg[],dr[],4)->mch.gAnd; W[]->V[]
       #);
     ToDreg::<
       (* used when computing primitive address expressions like @@ch;
        * the address of ch is in A; mch.move A to the 'dr' data register
        *)
       (# aReg: @mch.adrRegOperand
       do aReg.alloc; (A[],aReg[])->mch.gLea;
	  dr.alloc; (aReg[],dr[])->mch.CpReg;
	  (*(0->mch.newCstOp,aReg[])->mch.ldCst;*) aReg[]->mch.gClr;
	  (* in order NOT to confuse garbage collection *)
	  aReg.deAlloc; A.freeAdr
       #);
     mkAreg: (# aR: @mch.adrRegOperand do dr->aR exit aR[] #);
     mkReg:
       (# R: ^mch.mOperand
       do (if isAreg then mkAreg->R[] else dr[]->R[] if)
       exit R[]
       #);
     
     scmp::<(#do doCmp(#do 2->toPrimDest#)#);
  #);
ComputedAdrVal: EvVal 
  (# thisVal::<
       (# V: @ComputedAdrVal 
       do dr[]->V.dr[]; strucRef->V.strucRef; V[]->thisV[] #);
     display::< (# t1:@text do 'CompAdrVal:'->xT; dr.display->t1; t1[]->xT #);
     reUse: (#do dr->dr.reUse #);
     loadVal::<(#do this(ComputedAdrVal)[]->V[] #);
     loadVal2::<(#do this(ComputedAdrVal)[]->V[] #);
     dr: ^mch.registerOperand;
     isAreg, (* to be eliminated*)
     strucRef: @boolean; (* adr. register has a structureReference,dirty! *)
     release::< (#do dr.deAlloc #);
     reAlloc::<(#do dr->dr.reUse #);
     toTmp::<
       (#
       do (if dr.isCallReg then
              (* this(ComputedEvVal) is &T[] *)
              (# aR: @mch.adrRegOperand
              do aR.alloc; (dr[],aR[])->mch.cpReg;
                 aR[]->dr[];
                 mch.decrCallReg
       #)if)#);
     toPrimDest::<
       (# 
       do (if primDest.isPrimRegOp then
              (dr[],primDest[])->mch.cpReg
           else
              (dr[],primDest[]) -> mch.stVal
          if)
       #);
     evType::<(#do (if strucRef then 4->type else 1->type if)#);
     (* type=1 is simple, 2 is ref, 3 is real, 4 is struc *)
     asgToAdr::<
       (#do (dr[],false)->rA.asgRefReg; rA.freeAdr;
          this(ComputedAdrVal)[]->V[] 
       #);
     asgToItem::< (* A -> rA *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan;
          this(ComputedAdrVal)[]->nScan.AsgToNelm; 
          nScan.reset
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do release;
          (externalName,Desc[],extKind)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
          CP.call;
          CP.getExitP->V[];
          (* cp.endc *)
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do dr->dr.reUse; dr->D[1]; 
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     pushCpar::<
       (# 
       do (if released then reAlloc if);
          (if type
           // 1 then dr[]->mch.pushCbyte
           // 2 then dr[]->mch.pushCword
           // 3 then dr[]->mch.pushClong
           // 8 then 
              1->mch.initPrimCall;
              (if common.switch[61] or common.switch[64] then
                  (dr[],1->mch.getPrimReg) -> mch.cpReg
               else                      
                  dr[]->mch.pushClong;  (* should be prim *)
              if);
              protectCallReg(# do 'CopyCPP'->mch.callprim #);
              2->mch.getPrimRes
           // 9 then 
	      (univProcInfo)->mch.initExternalParams;
              2 ->mch.initPrimCall;
              dr[]->mch.pushClong; size[]->mch.pushClong;
              protectCallReg(#do 'CopyPPP'->mch.callPrim#);
              2->mch.getPrimRes
           // 11 then  (* Std for Windows NT *)
              7 ->mch.initPrimCall;
              dr[]->mch.pushClong; size[]->mch.pushClong;
              'CopySPP'->mch.callPrim;
              2->mch.getPrimRes
              (* others not used *)
          if);
          release
       #);
     ToDreg::<
       (* used when computing primitive address expressions like @@ch;
        * the address of ch is in A; mch.move A to the 'dr' data register
        *)
       (# aReg: @mch.adrRegOperand
       do aReg.alloc; (A[],aReg[])->mch.gLea;
	  dr.alloc; (aReg[],dr[])->mch.CpReg;
	  (*(0->mch.newCstOp,aReg[])->mch.ldCst;*) aReg[]->mch.gClr;
	  (* in order NOT to confuse garbage collection *)
	  aReg.deAlloc; A.freeAdr
       #);
     scmp::<(#do doCmp(#do 2->toPrimDest #)#);
  #);
TxtCstVal: EvVal
  (# thisVal::<(#V: @TxtCstVal do T->V.T; evalKind->V.evalKind; V[]->thisV[]#);
     display::<(#do 'TxtCV:'->xT; ThisT->xT #); thisT: (#exit T[]#);
     release::(#do (if cTxt[] <> NONE then cTxt.deAlloc if)#);
     loadVal::<(#do this(TxtCstVal)[]->V[] #);
     loadVal2::<(#do this(TxtCstVal)[]->V[] #);
     toDataRegA::<(#do (thisChOp,mch.DataRegA[])->mch.ldCst#);
                     (* toDataRegB::<(#do (thisChOp,mch.DataRegB[])->mch.ldCst#);*)
     toDataRegX::<(#do (thisChOp,mch.DataRegX[])->mch.ldCst#);
     toDataRegY::<(#do (thisChOp,mch.DataRegY[])->mch.ldCst#);
     toRangeReg::<
       (#do (thisCh->mch.newCstOp,mch.dataRegB[](*1->mch.NewDataRegOp*))->mch.ldCst#);
     toDataReg::< (#do (thisCh->mch.newCstOp,dReg[])->mch.ldCst #);
     toPrimDest::
       (# 
       do (if primDest.isPrimRegOp then
              (thisCh->mch.newCstOp,primDest[])->mch.ldCst
           else
              (thisCh->mch.NewCstOp,primDest[],4) -> mch.stCst
          if)
       #);
     evType::<(#do 1->type (* if char?*)#);
     mkReal::< 
       (# T: @text; thisInt: @(# I: @integer do thisCh->I exit I #)
       do thisCh->T.putInt; '.0'->T.puttext; 
          (T[],thisInt) -> mch.floatConst->mkFloatEvVal->V[] 
       #);
     asgToAdr::<
       (# max: @integer; pop: @boolean
       do (if sourceIsRef//false then
              (thisChOp,rA[],rA.size)->mch.stCst;
              this(TxtCstVal)[]->V[];
              rA.freeAdr
           else
              rA[] -> loadtextConst;
              (rA[],false,none,EHchain[])->mkRefEvval->V[]
              (* do we ever come here? In this case chain is for the left-side,
               * NOT for the right-side - this may be a problem??
               * However, the constructed RefEvVal will have sourceEV=none
               * (here destEV here), chain will probably never be used?
               *)
          if);
          (*rA.freeAdr - see FEJL/text2ref.bet *)
       #);
     asgToRefAdr::<
       (# rA: ^mch.address; dEV,dDesc: @AST.index; mn,dKind,max: @integer;
          RC: ^DH.superChain; found,pop: @boolean
       do destEV.son->dEV;(rAbase[],dEV[],false,rChain[])->genAdr->rA[];
          (if not sourceIsRef then 
              (* why is this boolean necessary? why is it not always assumed
               * that source is ref?
               * Set to true in evval2 and itemevval
               *)
              cError(#do 'txtCstVal:asgToRefAdr'->xT #);
              this(TxtCstVal)[]->V[]
           else
              rA[] -> loadTextConst;
              (rChain[],dEV)->DH.theDesc->(dDesc,mn,RC[],dKind);
              (if RC.ptnForm >= sematt.virtualForm then 
                  (* virtual QUA-check is needed *)
                  (dEV[],dDesc[],raBase[],rchain[])
                    ->virtualQua
                  (# doAssign::
                       (# dest: @mch.adrRegOperand
                       do this(asgToRefAdr).rA[]->rAx[]; 
                          (*check why the rA of doAssign must be overwritten!*)
                          common.direct->rAx.access;
                          rAx.toReg2->dest;
                          dest[]->destX[]
                       #)
                  do
                   #)
               else
                  (*312->trace(#do 'txtcst:asgtorefadr'->xT; 
                   sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
                  (sematt.textDesc[],dDesc[])->sematt.chkQua->(mn,found);
                  (if not found then 
                      (* qua-check is needed, but should NEVER happen! *)
                      cError(#do 'text2ref:missing qua-check'->xT #);
              if)if);
              (rA[],false,sematt.textDesc[],rChain[])->mkRefEvval->V[]
          if);
          (*rA.freeAdr -- see FEJL/text2ref.bet *)
          (*312->trace(#do 'txtcst:asgtorefadr2'->xT; 
           sematt.textDesc[] -> xA; dDesc[] -> xA #);*)
       #);
     asgToRepAdr::<
       (# max: @integer
       do (if common.switch[61] then
              protectCallReg
              (# pDest: ^mch.mOperand; dr: @mch.DataRegOperand;
                 aR: @mch.adrRegOperand; A: @mch.RegAdr
              do release; (* we MUST dealloc cTxt before pushReg, since
                           * this will confuse callBack
                           * (Inconsistent stack frame size for CB entry)
                           *)
                 mch.pushReg -> max; (* 6.12.95 *)
                 4->mch.initPrimCall;
                 (if cTxt[] = NONE then
                     (T[],1)->gen.TextConst;
                     2 -> rA.pushRegAndOff;
                     (4,1)->mch.SPtoPrimReg;
                     'CopyT'->mch.callPrim;
                     0->mch.GetPrimRes; 
                  else
                     1 -> mch.getPrimReg -> pDest[];
                     (cTxt[],pDest[]) -> mch.cpReg;
                     2 -> rA.pushRegAndOff;
                     (if callBack then
                         4 -> mch.getPrimReg -> pDest[];
                         aR.alloc;
                         ('BetaStackTop' -> mch.newTextOp,aR[]) -> mch.gLea;
                         aR -> A.reg; 
                         (A[],pDest[]) -> mch.ldVal;
                         aR.deAlloc
                      else
                         (4,1) -> mch.SPtoPrimReg
                     if);
                     'CopyT'->mch.callPrim;
                     (if callBack then 
                         3->mch.GetPrimRes -> dr;
                         (dr[],mch.callRegOp[]) -> mch.cpReg;
                         (dr[],mch.thisRegOp[]) -> mch.cpReg
                      else 0->mch.GetPrimRes
                     if);
                 if); 
                 max->mch.popReg 
              #)
           else
              3 ->mch.initPrimCall;
              (T[],1)->gen.TextConst; 
              rA.pushRegAndOff;
              'CopyT'->mch.callPrim;
              0->mch.GetPrimRes; 
          if);
          this(TxtCstVal)[]->V[]; rA.freeAdr
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan;
          this(TxtCstVal)[]->nScan.AsgToNelm; nScan.reset
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[] -> inx[];
          thisCh -> inx.newConstToN;
          (*inx.eval->V[]*)
       #);

     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (externalName,Desc[],extKind)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
          CP.call;
          CP.getExitP->V[];
          (* cp.endc *)
       #);
     asgToInLinePrimitive::< (*!!!!!!!!! only CHAR not TEXT !!!!! *)
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal
       do mch.getData->D[1]; 
          (thisChOp,D[1]->mch.NewDataRegOp)->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes // D[1] then else D[1]->mch.freeData if)
       #);
     pushCpar::< 
       (#
       do  (if type
            // 1 then thisChOp->mch.pushCbyte
            // 2 then thisChOp->mch.pushCword
            // 3 then thisChOp->mch.pushClong
            // 4 then 
               (T[],-1) ->gen.TextConst;
               (* OBS! textConst is used BOTH for C-par and primitive arg;
                * -1 means external argument
                *)
               (if extKind // sematt.pascExt//semAtt.pascTrapExt then
                   0->mch.initPrimCall; 
                   protectCallReg(#do 'PpkCT'->mch.callPrim #); 
                   0->mch.getPrimRes
		   (*else 'PackConstTextToC'->mch.jsrT *)
           if)if);
       #);
     cmp::< (#do thisCh->lV.cstCmp->doCmp (*gCmp(#do thisCh->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (thisChOp,dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do  thisCh->lV.cstAdd->res[] #);
     cstAdd::< (#do rN+thisCh->mkCstEvVal->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
	  (thisChOp,W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; (thisChOp,rReg[],4)->mch.gAdd; W[]->V[] #);
     sub::<(#do thisCh->lV.cstSub->res[] #);
     cstSub::< (#do (thisCh-rN)->mkCstEvVal->V[] #);
     adrSub::< 
       (# W: @ComputedEvVal 
       do W.dr.alloc; (thisChOp,W.dr[])->mch.ldCst;
	  rA[]->loadAdrOp(#do (op[],W.dr[],4)->mch.gSub#); W[]->V[] 
       #);
     regSub::< (* thisCh-lReg->W *)
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (thisChOp,W1.dr[])->mch.ldCst;
	  (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do thisCh->lV.cstTimes->res[] #);
     adrTimes::< (# W: ^evVal do mkConstEv->W[]; rA[]->W.adrTimes->V[] #);
     cstTimes::< (#do (rN*thisCh)->mkCstEvVal->V[] #);
     regTimes::<
       (# W: @computedEvVal
       do rReg->W.dr.reUse; 
          (thisChOp,rReg[],4)->mch.gMult; (* datpete 22/7/94: cstMult here??? *)
          W[]->V[]
       #);
     divMod::< (#do (thisCh,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::< (* rA div C *)
       (#
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN//0 then
              ddr.alloc;
              dr.alloc;
              (thisCh->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then (thisCh div rN)->mkCstEvVal->V[]
               else (thisCh mod rN)->mkCstEvVal->V[]
              if)
          if);
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (thisChOp,ddr.dNo2[])->mch.ldCst;
          (*Reg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     
     thisCh:
       (# c: @Char
       do (if T.isBetaChar then T.scanBeta(#do ch->c #)
           else ' OOPS char expected here!'->bugstream.putline if)
       exit c
       #);
     mkConstEv:
       (# V: ^evVal
       do thisCh->mkCstEvVal->V[]
       exit V[]
       #);
     thisChOp: (# C: @mch.cstOperand do thisCh->C exit C[] #);
     loadTextConst:
       (# rA: ^mch.Address; max: @integer
       enter rA[]
       do (if common.switch[61] then
              protectCallReg
              (#
              do mch.pushReg->max;
                 4 -> mch.initPrimCall;
                 (T[],1) -> gen.textConst; (* FIX this one to primReg *)
                 2 -> rA.pushRegAndOff;
                 (4,1) -> mch.SPtoPrimReg;
                 'MkTO'->mch.callPrim;
                 0->mch.getPrimRes;
                 max->mch.popReg;
              #)
           else
              mch.pushReg->max;
              3 -> mch.initPrimCall;
              (T[],1)->gen.textConst; 
              rA.pushRegAndOff;
              'MkTO'->mch.callPrim;
              0->mch.getPrimRes;
              max->mch.popReg;
          if);
       #);
     T: @Text; evalKind: @integer; 
     cTxt: ^mch.dataRegOperand; (* if cTxt[] <> NONE then this(TxtCstVal)
                                   * represents a text returned from C.
                                   * cTxt is a register denotin the txt.
                                   * The txt may be a callback parameter or
                                   * the result of an external call.
                                   * callBack is true if callBack
                                   *)
     callback: @boolean;
  enter T
  #);
TxtVarVal: EvVal
  (# thisVal::<
       (# V: @TxtVarVal 
       do (baseAdr[],EV[],evalKind,slice)->V ; V[]->thisV[] #);
     display::<(# t1:@text do 'TxtVV:'->xT; thisA->t1; t1[]->xT #); 
     thisA: (#do exit baseAdr.display#);
     release::<
       (# delay: @boolean
       enter delay
       do baseAdr.freeAdr; 
          (if not delay then none->baseAdr[]; none->EV[] if)
       #);
     loadVal::<(#do cError(#do 'TxtVarVal:loadVal'->xT #)#);
     loadVal2::<(#do cError(#do 'TxtVarVal:loadVal2'->xT #)#);
     toTmp::<
	(#
	do (if baseAdr.useCallReg then
		 baseAdr.toTmp->baseAdr[];(*mch.decrCallReg*)if)
	#);
     elimReg::< (# do (elimThis,elimCall)->baseAdr.elimReg #);
     asgToRepAdr::< 
	(* rA is the address of a repetition;
	 * assign the repetition denoted by A to rA 
	 *)
	(# EV0,EV1,EV2: @AST.index; V1,V2: ^evVal; W: @computedEvVal;
	   A: ^mch.address; callRegOnStack,pop,old61: @boolean;
           dR1: ^mch.dataRegOperand; chain1: ^DH.SuperChain;
           pDest: ^mch.mOperand; p: @integer; c: @char; T: @text
	do EHchain[]->chain1[];
           (if baseAdr.regType // mch.thisO //mch.callO then else
	      AllocCallReg(*PushCall*)->callRegOnstack;
	      baseAdr.toCallReg->baseAdr[]
    	   if);
	   EV.son->EV0; 
           (* Note: in the computation of ev1,ev2 below, V1 and V2 may be 
            * addressed via callReg, which may be destroyed/released during
            * generation of genAdr. GenAdr has been moved to after if-imp
            *)
           6 -> mch.initPrimCall ;
           (if slice then
               EV0.brother->EV1; EV1.brother->EV2;  
	       (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
               V1.toDataReg->dR1[]; dR1->W.dr;
               (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];

               (if true or common.switch[61]  then
                   4->mch.getPrimReg->pDest[];
                   (if pDest.isPrimRegop then
                       (W.dr[],pDest[]) -> mch.cpReg
                    else
                       (W.dr[],pDest[]) -> mch.stval
                   if);
                   W.release;
                   5->V2.toPrimDest;
                   V2.release;
                   (* NOTE: toPrimDest should do the release, but this
                    * gives problems in dobody:if; see scmp in synthlib.bet
                    *)
                else
                   W.toDataRegX; V2.toDataRegY
               if);
               6->p
            else 4->p
           if);
           (baseAdr.copy,EV0[],false,chain1[])->genAdr->A[];
	   common.direct->A.access; 
           4->A.size; (* ugly, fix for SPARC *)
           (if true or common.switch[61] then
               1->mch.getPrimReg->pDest[];
               (if pDest.isPrimRegOp then
                   (A[],pDest[]) -> mch.ldVal
                else
                   (A[],pDest[]) -> mch.cpMem
               if);
               (if mch.callRegBusy (*rA.useCallReg*) then
                   (false,true) -> mch.pushThisOrCall;
                   true->pop
               if);
            else A[]->mch.pushClong
           if);
           common.switch[61] -> old61; true->common.switch[61];
           2 -> rA.pushRegAndOff; (* 2 - 3 *)
           old61 -> common.switch[61];
           
           (p,1) -> mch.SPtoPrimReg;
	   A.freeAdr; rA.freeAdr;

           EV0[] -> sematt.RepSize -> c; 
	   (if not slice then 
	      (if evalKind 
	       // sematt.repValEval then 'CopyVR'->T; c -> T.put; 
	       // sematt.repRefEval then 'CopyRR'->T; 
	      if)
	   else
              (if evalKind 
	       // sematt.repValEval then 'CopySVR'->T;c -> T.put; 
	       // sematt.repRefEval then 'CopySRR'->T;
	      if)
           if);
           T -> mch.callPrim;
           0->mch.getPrimRes;
           (* double CallReg push/pop may happen here: one for  A and one
            * for rA - should be cleaned up
            *)
           (if pop then (false,true) -> mch.popThisOrCall if);
	   callRegOnStack->PopCall;
	   this(TxtVarVal)[]->V[]; 
        #);
     asgToCproc::<
       (* 'A' cannot be an InxRegAdr! *)
       (# CP: @ExTernalCall
       do true->release; 
          (externalName,Desc[],extKind)->CP; (* init *)
          (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
          CP.call;
          CP.getExitP->V[];
          (* cp.endc *)  
       #);
     pushCpar::< (* type = 4 for text *)
     
       (# EV0,EV1,EV2: @AST.index; A: ^mch.address; V1,V2: ^evVal; 
          pReg: ^mch.mOperand; chain1: ^DH.SuperChain
       do EHchain[]->chain1[];
          (* common.cstInd->A.access; !!!!*)
          (if released then reAlloc if);
          EV.son->EV0;
	  (if slice then 
              EV0.brother->EV1; EV1.brother->EV2;
              (baseAdr.copy,Ev1[],false,chain1[])->ExpEval->V1[];
              (baseAdr.copy,Ev2[],false,chain1[])->ExpEval->V2[];
              (if common.switch[61] then 4->mch.initPrimCall 
               else 3->mch.initPrimCall
              if)
           else 
              (if common.switch[61] then 2->mch.initPrimCall
               else 1->mch.initPrimCall
              if)
	  if);
          EV.son->EV1; (baseAdr.copy,EV1[],false,chain1[])->genAdr->A[];
          4->A.size; (* ugly, fix for SPARC *)
          1->mch.getPrimReg->pReg[];
          (A[],pReg[])->mch.ldVal;
          (if not slice then
              (if common.switch[61] then (2,0) -> mch.SpToPrimReg if);
              protectCallReg
              (#do (if extKind//sematt.pascExt//semAtt.pascTrapExt then
                       'PpkVT'->mch.callPrim
	            else 'CpkVT'->mch.callprim 
              if)#)
           else (* OBS new primitive OPs to be called here *)
              (* Note: on some architectures (e.g. mips), primReg2 and
               * callreg is the same register; V2 may use callReg and
               * 2->V1.toPrimDest should therefore protect callReg.
               * See synthlib:EvVal:ProtectCallReg
               *)
              3->V2.toPrimDest;  
              ProtectCallReg
              (#
              do 2->V1.toPrimDest;
                 (* should V1, V2 be  released? Perhaps also in asgToRepAdr?*)
                 (if common.switch[61] then (4,0) -> mch.SpToPrimReg if);
	         (if extKind//sematt.pascExt//semAtt.pascTrapExt then
                     'PpkSVT'->mch.callPrim
	          else 'CpkSVT'->mch.callprim 
                 if)
              #)
          if);
          2->mch.getPrimRes;
          none->baseAdr[];
       #);
     toDataReg::<
	(# A: ^mch.address; EV1: @AST.index
	do EV.son->EV1; (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
	   common.cstInd->A.access; 
           4->A.size; (* ugly, fix for SPARC *)
           (A[],dReg[])->mch.ldVal; A.freeAdr; release; (*!!*)
	#);
     toPrimDest::<
       (# A: ^mch.address; EV1: @AST.index;
       do EV.son->EV1; (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
          common.cstInd->A.access; 
          4->A.size; (* ugly, fix for SPARC *)
          (if primDest.isPrimRegOp then
              (A[],primDest[])->mch.ldVal
           else
              (A[],primDest[]) -> mch.cpMem
          if);
          A.freeAdr
	#);
     asgToItem::<
        (* A -> EV.N1 *)
	(# nScan: @ | scanNadr
	do (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(TxtVarVal)[]->nScan.asgToNelm; nScan.reset
	#);
     asgToList::<(#do toListOne #);
     baseAdr: ^mch.address; 
     evalKind: @integer; (* repValEval or repRefEval *)
     EV: ^AST.index; slice: @ Boolean
  enter(baseAdr[],EV[],evalKind,slice)
  #);
DoubleEvVal: EvVal
  (# thisVal::<(#V: @DoubleEvVal do (drX,drY)->V; V[]->thisV[] #);
     display::<(#do 'DoubV:'->xT; ' d'->xT; drX->xI; drY->xI #);
     reUse: (# do drX->drX.reUse; drY->drY.reuse #);
     loadVal::<(#do this(DoubleEvVal)[]->V[] #);
     loadVal2::<(#do loadVal->V[] #);
     release::<(#do drX.deAlloc; drY.deAlloc #);
     evType::<(#do 3->type#);
     mkReal::<(# do this(DoubleEvVal)[]->V[] #);      
     loadFloat::<
	(# FR: @mch.floatRegOp
	do FR.alloc; drY[]->mch.pushClong; drX[]->mch.pushClong; release;
	   &mch.stackTopAdr[]->FR.load; 
           FR[]->res[]
	#);
     asgToRealAdr::<
	(#do (drX[],rA[])->mch.stVal; (drY[],4->rA.addOff)->mch.stVal;
	     rA.freeAdr; this(DoubleEvVal)[]->V[]
        #);
     rCmp::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; 
           (lV[],op,jmpCond,lab[])->FV.rCmp->res[]
	#);
     unMinus::<
       (# FR: ^mch.floatRegOp 
       do loadFloat->FR[]->mch.negFloat; FR[]->mkFloatEvVal->res[]
       #);
     rAdd::< (* lV + this(DoubleEvVal) *)
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rAdd->res[]
	#);
     rSub::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rSub->res[]
	#);
     rMult::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rMult->res[]
	#);
     rDiv::<
	(# FV: ^floatEvVal
	do loadFloat->mkFloatEvVal->FV[]; lV[]->FV.rDiv->res[]
	#);
     asgToItem::<
	(# W: @computedEvVal; A: ^mch.address; nScan: @ | scanNadr
	do (*352->trace(#do 'DoubleEvVal:asgToItem'->T #);*)
	   (if (rDesc->sematt.realDesc.equal) then
		rA.copy->A[];
               (*352->trace(#do 'ToRealDesc'->T #);*)
		12->A.addOff; drX->W.dr; A[]->W.asgToAdr;
		4->A.addOff; drY->W.dr; A[]->W.asgToAdr;
            else 
               (rDesc[],rA[],0,rChain[],true)->nScan;
               this(DoubleEvVal)[]->nScan.asgToNelm;
               nScan.reset
	   if)#);
      asgToList::<(#do toListOne #);
      asgToCproc::<
	(# CP: @ExTernalCall
        do release; (* see also pushCpar *)
	   (externalName,Desc[],extKind)->CP; (* init *)
	   (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
	   CP.call; CP.getExitP->V[]; (* cp.endc *)
	#);
      pushCpar::< 
	(#
	do (if released then reAlloc if);
           drY[]->mch.pushClong; drX[]->mch.pushClong;
	   release;(* may have been done by asgToCproc *)
	#);
	drX,drY: @mch.dataRegOperand;
   enter(drX,drY)
   #);
FloatEvVal: EvVal
  (# thisVal::<(# V: @FloatEvVal do FL->V; V[]->thisV[] #);
     display::< (#do 'Float: fr'->xT;  FL.rn->xI; ','->xT #);
     reUse: (# do  #);
     loadVal::<(#do this(FloatEvVal)[]->V[] #);
     loadVal2::<(#do this(FloatEvVal)[]->V[] #);
     release::<(#do FL.deAlloc #);
     reAlloc::<(#do FL.rN->FL.reUse #);
     evType::<(#do 3->type#);
     mkReal::<(# do this(FloatEvVal)[]->V[] #);      
     toDataRegA:: 
       (#
       do 'FloatEvVal:toDataRegA: BETA call-back cannot return a float'
            ->Cerror
       #);
     toDataRegX:: (#do (FL[],mch.dataRegX[]) -> mch.float2int #);
     toDataRegY:: (#do (FL[],mch.dataRegY[]) -> mch.float2int #);
     toRangeReg:: (#do (FL[],mch.dataRegB[]) -> mch.float2int #);
     toDataReg:: (#do (FL[],dReg[]) -> mch.float2int #);
     toPrimDest::
       (# 
       do (if primDest.isPrimRegOp then
              (FL[],primDest[]) -> mch.float2int 
           else
              (# dr: @mch.dataRegOperand
              do dr.alloc;
                 (FL[],dr[]) -> mch.float2int ;
                 (dr[],primDest[]) -> mch.stVal;
                 dr.deAlloc;
              #)
          if)
       #);
     asgToAdr::< 
       (# D: ^mch.dataRegOperand; 
       do rA[]->FL.store2Int->D[]; (D,false,false)->mkComputedEvVal->V[]
       #);
     asgToRealAdr::< 
       (#
       do rA[]->FL.store; 
          (if mch.floatStackUnit then 
              release; rA[]->mkRealEvVal->V[]
           else rA.freeAdr; this(FloatEvVal)[]->V[] 
          if)
       #);
     loadFloat::<(#do FL.reuse; FL[]->res[] #);
     getFloatArg::<(#do FL[]->F[]; true->inFreg #);
     rCmp::<
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand (*address*)
	do FL.storeTmp->A[]; (* when is A released *)
           (A[],lV.loadFloat,0,false,false)->doCmp
	#);
     unMinus::<
       (#do FL[]->mch.negFloat; FL.rN->FL.reUse; this(FloatEvVal)[]->res[] #);
     rAdd::< (* lV + this(DoubleEvVal) *)
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal;
          F: ^mch.mOperand; inFreg: @boolean
	do (* lV.loadFloat->LF[];
	    * FL.storeTmp->A[];
            * (LF[],A[],false)->mch.addFloat;
	    * LF->Fval; Fval[]->res[]*)
          lV.getFloatArg->(F[],inFreg);
          (FL[],F[],inFreg)->mch.addFloat;
          FL.rN->FL.reUse;  (* will this also work for Ix86?*)
          this(FloatEvVal)[]->res[]
          (* alternative:
           * true->releasaed; FL[]->mkFloatEvVal->res[]
           *)
	#);
     rSub::< (* lV + this(DoubleEvVal) *)
       (# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
	do lV.loadFloat->LF[];
	   FL.storeTmp->A[];
	   (LF[],A[],false)->mch.subFloat;
	   LF->Fval; Fval[]->res[]
          (* problem to do as for rAdd, since this will switch
           * the order of the arguments to subFloat
           *)
	#);
     rMult::<
	(# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
	do lV.loadFloat->LF[]; FL.storeTmp->A[];
	   (LF[],A[],false)->mch.mulFloat;
	   LF->Fval; Fval[]->res[]
	#);
     rDiv::<
	(# LF: ^mch.floatRegOp; A: ^mch.mOperand;  Fval: @ floatEvVal
	do lV.loadFloat->LF[]; FL.storeTmp->A[];
	   (LF[],A[],false)->mch.divFloat;
	   LF->Fval; Fval[]->res[]
	#);
     asgToItem::<
	(# nScan: @ | scanNadr
	do (*352->trace(#do 'FloatEvVal:asgToItem'->T #);*)
           (rDesc[],rA[],0,rChain[],true)->nScan; 
           this(FloatEvVal)[]->nScan.asgToNelm; 
           nScan.reset
	#);
     asgToList::<(#do toListOne #);
     asgToCproc::<
	(# CP: @ExTernalCall
        do release; (* see also pushCpar *)
	   (externalName,Desc[],extKind)->CP; (* init *)
	   (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
	   CP.call; CP.getExitP->V[]; (* cp.endc *)
	#);
     pushCpar::< 
	(# 
	do (if released then reAlloc if);
           FL[]->mch.pushCfloat; 
           release;(* may have been done by asgToCproc *)
	#);
     FL: @mch.floatRegOp
   enter FL
   #);
RealEvVal: EvVal
  (# thisVal::< (* NOTE: super thisVal has true->released! *)
       (# do A[]->mkRealEvVal->thisV[] #);
     display::<
       (# 
       do 'RealEvVal:'->xT; thisA->xT;
          (if released then 'R+'->xT else 'R-'->xT
       if)#); 
     thisA:(# T:@ text do A.display->T exit T[] #);
     evType::<(#do 3->type #);
     release::<
       (#do (*351->trace(#do 'ReavEvval:release'->T; display#);*) A.freeAdr #);
     (* reAlloc::< *)
     mkReal::<(# do this(RealEvVal)[]->V[] #);      
     loadVal::<(#do this(RealEvVal)[]->V[]#);
     loadVal2::<
       (# fVal: @floatEvVal; F: ^mch.floatRegOp
       do loadFloat->F[]; F->Fval; release; Fval[]->V[]
       #);
     toTmp::< (#do(if A.useCallReg then A.toTmp->A[] if)#);
     elimReg::< (# do (elimThis,elimCall)->A.elimReg #);
     toDataRegA:: 
       (#
       do 'FloatEvVal:toDataRegA: BETA call-back cannot return a float'
            ->Cerror
       #);
     toDataRegX:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegX[]) -> mch.float2int; FL.deAlloc
       #);
     toDataRegY:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegY[]) -> mch.float2int; FL.deAlloc
       #);
     toRangeReG:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],mch.dataRegB[]) -> mch.float2int; FL.deAlloc
       #);
     toDataReg:: 
       (# FL: @mch.floatRegOp
       do FL.alloc; A[]->FL.load; 
          (FL[],dReg[]) -> mch.float2int; FL.deAlloc
       #);
     toPrimDest::
       (# FL: @mch.floatRegOp; dr: @mch.dataRegOperand
       do FL.alloc; A[]->FL.load; 
          (if primDest.isPrimRegOp then
              (FL[],primDest[]) -> mch.float2int;
           else
              dr.alloc;
              (dr[],primDest[]) -> mch.stVal;
              (FL[],dr[]) -> mch.float2int;
              dr.deAlloc;               
          if);
          FL.deAlloc
       #);
     (* getRefEval::<; theAdr::<; adrVal::< *)
     asgToAdr::<
       (# FL: @ mch.floatRegOp;  D: ^mch.dataRegOperand
       do FL.alloc; A[]->FL.load; rA[]->FL.store2int->D[];
          Release; rA.freeAdr;
	  (D,false,false)->mkComputedEvVal->V[]
       #);
     asgToRealAdr::<
       (# A1,A2: ^mch.address; dr: ^mch.dataRegOperand
       do (A[],rA[])->mch.cpMem->dr[]; 
          (if dr[]<>none then dr.deAlloc if);
          A.copy->A1[]; rA.copy->A2[];
          (4->A1.addOff,4->A2.addOff)->mch.cpMem->dr[];
          (if dr[]<>none then dr.deAlloc if);
          rA.freeAdr; this(RealEvVal)[]->V[];
          (*351->trace(#do 'RealEvVal:asgToRealAdr'->T; V.display #)*)
       #);
     (* asgToRepAdr::< *)
     asgToItem::<
       (# W: @computedEvVal; A: ^mch.address; nScan: @ | scanNadr
       do (*352->trace(#do 'RealEvVal:asgToItem'->T #);*)
          (rDesc[],rA[],0,rChain[],true)->nScan; 
          this(RealEvVal)[]->nScan.asgToNelm; 
          nScan.reset
       #);
     asgToList::<(#do toListOne #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (if A.struc//mch.InxRegAdr## then
              (* The execution of CP will push all busy registers, including
               * the ones possibly used by A. If A is a repetition index, like
               * R[i], A will be an instance of InxRegAdr. If release is called
               * for A, the adr. register will be cleared. This happens
               * before A is pushed and will thus result in an error. In this
               * case A is move to a dataregister before the release.
               * It would be better to have a cleaner solution
               *)
              loadVal2->V[];
              (EV[],externalName[],desc[],extKind)->V.asgToCproc->V[]
           else              
              release; (* see also pushCpar *)
              (externalName,Desc[],extKind)->CP; (* init *)
              (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo)->(*thisEvVal.*)pushCpar;
              CP.call; CP.getExitP->V[]; (* cp.endc *)
          if)
       #);
     (* asgToPrimitive::< asgToInlinePrimitive::< *)
     pushCpar::< 
       (# 
       do (if released then reAlloc if);
          A[]->mch.pushCdoubleAdr;release;(*may have been done by asgToCproc*)
       #);
     rCmp::<
       (# LF: ^ mch.floatRegOp
       do (A[],lV.loadFloat,0,false,true)->doCmp
          (* Release?*)
       #);
     unMinus::<
       (# Fval: @floatEvVal; F: ^mch.floatRegOp
       do loadFloat->F[]->mch.negFloat; F->Fval; Release; Fval[]->res[] 
       #);
     (* they following operations are only there to avoid compiler chrash;
      * they do not give meaningful results!
      *)
     notExp::< (#do 1->mkCstEvval->res[] #);
     orr:: <(#do A[]->lV.adrOr->res[] #);
     adrOr::< (#do 1->mkCstEvval->V[] #);
     cstOr::< (#do 1->mkCstEvval->V[] #);
     regOr::< (#do 1->mkCstEvval->V[] #);
     andd::< (#do A[]->lV.adrAnd->res[] #);
     adrAnd::< (#do 1->mkCstEvval->V[] #);
     cstAnd::< (#do 1->mkCstEvval->V[] #);
     regAnd::< (#do 1->mkCstEvval->V[] #);
     
     rAdd::< (* lV + this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.addFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     rSub::< (* lV - this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.subFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     rMult::< (* lV * this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.mulFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     rDiv::< (* lV / this(RealVal) *)
       (# LF: ^ mch.floatRegOp; Fval: @ floatEvVal
       do lV.loadFloat->LF[]; (LF[],A[],false)->mch.divFloat;
          LF->Fval; Release; Fval[]->res[]
       #);
     loadFloat::< 
       (# FL: @ mch.floatRegOp 
       do FL.alloc; A[]->FL.load; Release; FL[]->res[] 
       #);
     getFloatArg::<(#do A[]->F[] #);
      A: ^mch.Address
  #)

