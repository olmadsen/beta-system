ORIGIN 'signature'
---bytecode_TODO_rep:descriptor---
(# R: [2] @boolean;
   top: @integer
#)
---bytecode_TODO:doPart---
do (if (1 <= n) and (n <= rep.R.range) then
       (if not rep.R[n] then
           '\nTODO: ' -> puttext;
           (* 1 & 2 should hav been fixed *)
           (if n
            // 1 then
               'NewInstance of "object" ' -> puttext;
               ' will probably not work' -> putline               
            // 2 then               
               'No call of do-method generated for "object"' -> putline
            else 'No message???' -> putline
           if);           
           true -> rep.R[n]
       if)
   if)
   

---descLocation:doPart---
do (# encDescHasSlots:
        (* follow origin to top of fragment *)
        (# desc,DX,D: ^ASTindex
        enter desc[]
        do &ASTindex[] -> DX[]; desc -> DX;
           (if not DX.isNull then
               L: (#
                  do (*311 -> trace(# 
                      do 'encDescHasSlots:'->xT;
                      DX[] -> xA
                      #);*)
                     DX.origin -> DX;
                     (if DX.label 
                      // gram.objectDescriptor then
                         (if DX[] -> hasSlots then 
                             DX[] -> D[]; 
                          else
                             restart L
                         if)
                      // gram.forImp 
                      // gram.repetitionDecl // gram.labelledImp then
                         restart L
                     if)
           #)if)
        exit D[]
        #);
      (* OBS Unify with the one in genlib_bytecode *)
      hasSlots: booleanValue
        (# desc: ^ASTindex; N: @ASTindex
        enter desc[]
        do 313->trace(#
                     do 'hasSlots: '->xT; desc[] -> xA 
                     #);
           (if desc.label = gram.objectDescriptor  then
               desc.son -> N; N.brother -> N;
               (if N.isSlot then
                   (* main part slot *)
                   true -> value
                else
                   N.son -> N;     (* att-part*)
                   N.brother -> N; (* action-part*)
                   (if not N.isNull then
                       N.son -> N;     (* enter-part*)
                       N.brother -> N; (* do-part *)
                       N.isSlot -> value
               if)if)
               (* else perhaps slots and nameApls should be considered?*)
           if)
        #);

      ED: ^ASTindex
   do 
      (if (desc[] <> none) and not desc.isNull then
          (desc[],true) -> EH.descName ->  S[];
       else
          'NoName!'->S[]
      if);
      316->trace(# 
                do 'location:'->xT; S[] -> xT;
                   xN; desc[] -> xA
                #);
      (if not desc.isNull then
          (if desc.label = gram.mainPart then
              desc[] -> sematt.MainPartDesc -> desc[]
          if);
          (if desc.label
           // gram.objectDescriptor then
              desc.descId -> (formId[],descNo);
              desc.son->N; N.brother->N;
              (if N.isSlot then 
                  (* desc has mainPart slot *)
                  desc[] -> slotLocation -> location[] (* is this what we want? *)
               else 
                  (* check if do-part is a slot *)
                  N.son->N;     (* att-part*)
                  N.brother->N; (* action-part*)
                  N.son->N;     (* enter-part*)
                  N.brother->N; (* do-part *)
                  (if N.isSlot then 
                      (* desc has do-part slot *)
                      desc[] -> slotLocation-> location[] (* is this what we want? *)
                   else
                      (if (desc[] -> encDescHasSlots -> ED[]) <> none then
                          (ED[],true) -> EH.descname -> location[];
                          (if not common.switch[188] then
                              '\ndescWithSlots:location:'->puttext;
                              location[] -> putline
                          if);
                       else
                          formId.makeUC;
                          (desc.frag[]).fullName -> location[];
                          (if desc.frag.category 
                           // gram.attributesForm then
                              location[] -> stripForm -> location[];
                           else
                              location[] -> stripFileAndForm -> location[];
                              desc.frag.root[] -> astAsAstIndex -> N;
                              316 -> trace(#
                                          do 'location:fragName:' -> xT;
                                             N[] -> xA
                                          #);
                              (N[],true)
                                -> EH.DescName 
                                -> location.append
                          if)
                      if)
                  if)
              if)
           // gram.unExpanded then
              desc[] -> slotLocation -> location[]
      if)if);
      (* imports at all other places should now be removed *)
      (if location[] <> none then location[] -> mch.import if);

      316->trace(#
                do 'is: ' -> xT;
                   (if location[] = none then
                       'unknown' -> xT
                    else 
                       (if location.length = 0 then 
                           'local' -> xT
                        else
                           location[] -> xT
                if)if)#)
   #)
   
---signature_getAttSig:dopart---
do (# referenceSignature: (* unify with dynamicItem case in do-part below*)
        (# EV: ^ASTindex;
           sig: ^Type
        enter EV[]
        do EV[] -> sematt.AttDesc -> nD[];
           301->trace(#do nD.display; chain #);
           (if nD.spec.label 
            // gram.dynamicItem // gram.staticItem then
               (chain[],nD.apl)
                 -> DH.theDesc
                 -> (desc,MN,EVchain[],isVirtual);
               (if desc.label = gram.objectDescriptor then
                   (if nD.isRep then '\nREP:'->putline;
                       desc[] -> reference -> array -> sig[]
                    else
                       desc[] -> reference -> sig[]
                   if)
                else 
                   ' ***??? not descriptor ' -> putline;
                   sematt.dataDesc[]->Reference -> sig[];
               if)
            else
               sematt.dataDesc[] ->Reference -> sig[];
           if);
        exit sig[]
        #);
      nD: ^sematt.AttDesc; EH: @EvalHandler;
      desc: @ASTindex; 
      MN,isVirtual: @integer;
      EVchain: ^DH.superChain;

   do 313->trace(#
                do 'getAttSig:'->xT;
                   EV[] -> xA;
                   ev.label -> xI;
                   ev.label -> sematt.evalClass -> xI
                #);
      L:
        (if EV.label
         // gram.insertedItem  then
            (# den,desc: @ASTindex; mn,isVirt: @integer
            do EV.son -> den;
               (if den.label = gram.objectDescriptor then 
                   (* just to get the corretc chain[] *)
                   (chain[],den)->DH.theDesc->(desc,MN,chain[],isVirt);
                   (if isEnter then
                       (den[],chain[]) -> scanNargs -> xSig[];
                    else
                       (den[],chain[]) -> scanXargs -> xSig[];
                   if);
                   313->trace(#do 'getAttSig:inserted:'->xT;  xSig.asText->xT#)
                else
                   sematt.dataDesc[] -> Reference -> xSig[]                
               if)
            #)
            (* // gram.objectDenotation then
             'LunknownObjectDenotation;'->sig[]*)
         // gram.objectReference 
         // gram.structureReference then
            (if ((EV.sonRef).sonRef).label = gram.thisObject then
                (EV.sonRef).sonRef -> EV[];
                restart L
             else           
                EV[] -> referenceSignature -> xSig[]
            if)
         // gram.thisObject then
            (# AD: @ASTindex
            do EV.son -> AD;
               AD.descRef -> AD;
               AD[] -> Reference -> xSig[]
               (* AD.dclRef -> AD;
                * AD.getText -> Reference -> xSig[]*)
            #)
         // gram.assignmentEvaluation then
            (* preliminary *)
            (# EV1: @ASTindex
            do EV.son -> EV1;
               (if not isEnter then EV1.brother -> EV1 if);
               (EV1[],theDesc[],isEnter,chain[]) -> getAttSig -> xSig[]
            #)
         // gram.evalList then
            (# lSig: ^ListSignature
            do ListSignature -> lSig[];
               Ev.son -> scanList
               (# E: @ASTindex
               do currentNode->E;
                  (E[],theDesc[],isEnter,chain[]) -> getAttSig -> lSig.append
               #);
               lSig[] -> xSig[]
            #)
         // gram.repetitionSlice then
            (# theRep: @ASTindex; size: @integer
            do EV.son -> theRep;
               (if EV.evalKind
                // sematt.repValEval then 
                   (if theRep[] -> sematt.repSize -> size 
                    // '1' then 
                       sematt.chardesc[] -> valuesignature -> array -> xSig[]
                    // '2' then 
                       sematt.int16desc[] -> valuesignature -> array -> xSig[]
                    // '4' then 
                       sematt.integerdesc[] -> valuesignature -> array -> xSig[]
                    // '8' then 
                       sematt.realdesc[] -> valuesignature -> array -> xSig[]
                    else
                       '\nOBS! getAttSig:repetitionSlice:size:'->puttext;
                       size -> putint; newline
                   if)
                // sematt.repRefEval then              
                   '\nOBS! getAttSig:repetitionSlice:repRefEval:'->puttext;
                else
                   '\nOBS! getAttSig:repetitionSlice:unknown:EvalKind:'->puttext;
               if)
            #)
         // gram.textConst then
            (* we should make a pattern for the following code and also
             * use it in e.g. referenceSignature
             *)
            (# T: ^text
            do EV.getText -> T[];
               (if T.length = 1 then
                   (* will not always work, since a '*' may be a text *)
                   sematt.charDesc[] -> valueSignature -> xSig[]
                else
                   sematt.textDesc[] -> reference -> xSig[];
               if);
            #)
            (*(sematt.textDesc[] ,true)
             -> EH.descName
             -> Reference 
             -> xSig[];  
             sematt.textDesc[] -> descLocation -> xSig.location[];*)
         // gram.integerConst 
         // gram.primitive
         // gram.primitiveExp then
            sematt.integerdesc[] -> valuesignature -> xSig[]
         else
            (* check what this else part covers;
             * it covers objectDenotation - but what else?
             *)
            (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
                int32Value -> xSig[]
             else
                EV[] -> sematt.AttDesc -> nD[];
                311->trace(#
                          do nD.display;
                          #);

                (if nD.kind
                 // sematt.standardKind then
                    (if nD.isRep then
                        nD.desc[] -> valueSignature -> Array -> xSig[]
                     else
                        nD.desc[] -> valueSignature -> xSig[]
                    if)
                 // sematt.generalKind 
                 // sematt.classKind 
                 // sematt.externalClassKind then
                    '\ngetAttSig:GO'->putline;
                    (* we assume object denotation here *)
                    (if nD.isRep then
                        '\ngetAttSig:IsRep'->putline;
                        nD.desc[] -> reference -> array -> xSig[];
                        xSig.asText -> putline;
                     else
                        '\ngetAttSig:IsNotRep'->putline;
                        (# desc: @ASTindex; MN,isVirt: @integer
                        do (chain[],nD.desc)
                             -> DH.theDesc
                             -> (desc,MN,chain[],isVirt);
                           311->trace(#
                                     do 'getAttSig:X:desc:'->xT; xN;
                                        nD.desc[] -> xA; 
                                        chain
                                     #);
                           (if isEnter then
                               (nD.desc[],chain[]) -> scanNargs -> xSig[]
                            else
                               (nD.desc[],chain[]) -> scanXargs -> xSig[]
                           if)
                    #)if)
                 else
                    (* so what is this case here? *)
                    (* don't work if virtual - we should get generalKind
                     * but ...
                     *)
                    (if true then
                        EV[] -> referenceSignature -> xSig[]
                     else
                        (if nD.spec.label = gram.dynamicItem then
                            (chain[],nD.apl)
                              -> DH.theDesc
                              -> (desc,MN,EVchain[],isVirtual);
                            (if desc.label = gram.objectDescriptor then
                                desc[] -> reference -> xsig[]
                             else 
                                ' ***??? not descriptor ' -> putline;
                                sematt.dataDesc[] ->Reference -> xSig[];
                            if)
                         else
                            ' ***??? not dynamic ' -> putline;
                            sematt.dataDesc[] ->Reference -> xSig[];
                        if);
                    if);
        if)if)if);
      313->trace(#do 'getAttSig:return:'->xT; xSig.asText -> xT #)   
   #)
   
---signature_newInstance:doPart---
do (# orgDesc: ^ASTindex; 
      class,orgName: ^text; 
      classKind: @integer;
      hasOrigin,local: @boolean;
   do 311->trace(#
                do 'newInstance: '->xT; desc[] -> xA
                #);
      desc -> sematt.descKind -> classKind;
      (if classKind = sematt.externalClassKind then
          desc[] -> getExternalClassName -> class[]
          (* do we come here? No we never create an instance
           * of a direct subclass of externalClass
           *)
       else 
          ('G',desc[]) -> mkEntryPoint -> (class[],local);
      if);
      (if (desc.label = gram.objectDescriptor)
          and (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          '-' -> orgName[];
       else
          (if true
           // 'java/lang/Object'-> class.equal
           // 'class [mscorlib]System.Object' -> class.equal 
           // 'BetaObject' -> class.equal 
           // 'object' -> class.equal then
              '-' -> orgName[];
              (*1 -> TODO; - should be ok now *)
           else
              true -> hasOrigin;
              (if desc.label = gram.unExpanded then
                  &ASTindex[] -> orgDesc[];
                  desc.slotOrigin -> orgDesc;
                  (desc[]-> sematt.encDesc,true)
                    -> EH.descName 
                    -> orgName[]
               else
                  desc[] -> sematt.descOrigin -> orgDesc[];
                  (if orgDesc.isNull then
                      (*'\n***OriginDesc is null (betaenv?)' -> putline;*)
                      (if common.switch[320] then
                          platFormSuperName -> orgName[]
                       else
                          defaultSuperName -> orgName[]
                      if)
                   else
                      (orgDesc[],true) -> EH.descName -> orgName[]
      if)if)if)if);
      313->trace(#
                do 'newInstance:originName:' -> xT; orgName[] -> xT; xN;
                   desc[] -> xA; xN;
                   'origin:'->xT; xN; orgDesc[] -> xA
                #);
      
      (if true 
       // common.targetMachineId = common.javabc then
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)
            ->mch.callAlloPrim;
       // common.targetMachineId = common.dotnet then
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)->mch.callAlloPrim;
       else
          'newInstance: unknown platform' -> thisTranslate.systemException
      if)
   #);
   
---signature_hasNoEnterAndExitThis:doPart---
do (if not isPtnClassMethod and (NNsig.top = 0) then
       (* no enter arguments *)
       (if not (isMultiValExit -> value) then
           (# NMpos: @integer; CN: ^text
           do (* '\nExitThis:' -> puttext;
              'method: "' -> puttext; method[]->puttext;
              '" XXsig: "'->puttext; XXsig.classname->puttext;
               '"\n   className: "'->puttext;
               *)
              XXsig.classname->CN[]; 
              CN.scanAll
              (# pos: @integer
              do pos+1->pos;
                 (if ch = common.nameManglingCh then
                     pos -> NMpos
                 if)
              #);
              (* '" exitNameSig: "' -> puttext;
              (NMpos+1,CN.length) -> CN.sub -> puttext; '"\n'->puttext;*)
              ((NMpos+1,CN.length) -> CN.sub -> method.equal) -> value
           #)
   if)if)
   
---signature_astext:doPart---
do (# addPossibleNameManglingCh:
        (#
        do (if hasNoEnterAndExitThis
               and not( 'exit'->method.equal)
               and not( 'do'->method.equal)
               and not( 'enter'->method.equal)
               then
               common.nameManglingCh -> T.put
           if)
        #)
   do (if isJava then
          (if receiver[] <> NONE then
              (* method call signature *)
              receiver.copy -> T[];
              '/' -> T.put
           else
              &text[] -> T[];
              (if isStatic then
                  'static ' -> T.append
              if)
          if);
          (if method[] <> none then
              method.copy -> T.append;
              addPossibleNameManglingCh;
           else
              '\n*** method is none ' -> putline
          if);
          noNsig-> enterSig -> T.append;
          noXsig -> exitSig -> T.append;
       else
          '' -> T[];
          (if isStatic then
              'static ' -> T.append
          if);
          noXsig -> exitSig -> T.append;
          ' '->T.append;
          (if receiver[] <> none then
              (* method call signature *)
              (receiver[],location[]) -> AddDotnetLocation  -> T.append;
              '::' -> T.append
          if);
          (if method[] <> none then
              '\'' -> T.put; (* Quote to avoid clash with IL 
                              * reserved words, e.g. add 
                              *)
              method.copy -> T.append;
              addPossibleNameManglingCh;
              '\'' -> T.put;
           else
              '\n*** method is none ' -> putline
          if);
          noNsig -> enterSig -> T.append
      if);
      187->ctrace(# 
                 do 'Signature:'  ->xT; T[] -> xT;
                    ' location:'->xT;
                    (if location[] = none then
                        'unknown' -> xT
                     else
                        location[] -> xT
                 if)#)
   #)
---signature_addEnter:doPart---      
do 313->trace(#
             do 'addEnter:'->xT; theDesc[] -> xA
             #);
   ListSignature -> NNsig[];
   (if thisChain[] = none then
       '\nOBS! signature:addEnter:thisChain is none! ' -> putline;
       thisSuperChain -> thisChain[]
   if);
   (if not (theDesc->thisMethodDesc.equal) then 
       (if not common.switch[188] then
           'addEnter:desc not equal'->putline
   if)if);
   313->trace(#
             do 'addEnter:theDesc(from enter):'->xT;
                theDesc[]->xA; xN;
                'thisMethodDesc( for setDesc): ' -> xT;
                thisMethodDesc[] -> xA;
                (if thisChain[] <> none then
                    thisChain
                if) 
             #);
   (if isStatic then (* should be origin of thisMethodDesc *)
       (# org: ^ASTindex
       do thisMethodDesc[] -> sematt.descOrigin -> org[];
          (if org.isNull then
              sematt.superObject[]  -> reference -> sig[]
           else
              org[]
                -> reference 
                -> sig[]
          if);
          org[] -> descLocation -> sig.location[];
          sig[] -> NNsig.append;
       #)
   if);              
   (thisMethodDesc[],gen.thisRegAdr,0,thisChain[],true) 
     -> nScan 
     -> more;
   
   Loop:
     (if more then 
         (nScan.thisEv[],thisMethodDesc[],true,nScan.thisChain[])
           -> getAttSig
           -> NNsig.append;
         313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
         nScan -> more;
         restart Loop
     if);
   313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);

---signature_addExit:doPart---   
do addExit:
     (#
     do 313->trace(#
                  do 'Signature:addExit:'->xT; xN;
                     thisMethodDesc[]->xA; xN;
                     (if thisChain[] <> none then
                         thisChain
                     if)
                  #);
        
        setVoidXsig;

        (if thisChain[] <> none then
            &ListSignature[] -> XXLsig[];
            (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
              -> xScan 
              -> more;
            (if not more then exitVoid; leave addExit if);
            loop:
              (if more then
                  (xScan.thisEv[]->exitVal[]
                  ,thisMethodDesc[],false,xScan.thisChain[]) 
                    -> getAttSig 
                    -> XXsig[]
                    -> XXLsig.append;
                  xScan -> more;
                  (if more or XXsig.isList then 
                      true -> isMultiValExit; 
                      restart loop
                  if);
              if);
            (if isMultiValExit then 
                (* we exit a reference to this object *)
                thisMethodDesc[] -> reference -> XXsig[]
            if)                
         else
            '\n***OBS. thisChain is none '->putline;
            (if (thisMethodDesc[]->theGen.scanXarg->exitVal[]) <> NONE then
                (exitVal[],thisMethodDesc[],false,thisChain[]) 
                  -> theGen.getAttSig 
                  -> XXsig[];
        if)if);
        (if true then
            XXsig.elmType -> exitID
         else            
            (if XXsig.isRef then
                2 -> exitId
             else
                1 -> exitId
        if)if);
     #)
