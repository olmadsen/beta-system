ORIGIN 'signature'
---bytecode_TODO_rep:descriptor---
(# R: [2] @boolean;
   top: @integer
#)
---bytecode_TODO:doPart---
do (if (1 <= n) and (n <= rep.R.range) then
       (if not rep.R[n] then
           '\nTODO: ' -> puttext;
           (* 1 & 2 should hav been fixed *)
           (if n
            // 1 then
               'NewInstance of "object" ' -> puttext;
               ' will probably not work' -> putline               
            // 2 then               
               'No call of do-method generated for "object"' -> putline
            else 'No message???' -> putline
           if);           
           true -> rep.R[n]
       if)
   if)
   

---descLocation:doPart---
do (if (desc[] <> none) and not desc.isNull then
       (desc[],true) -> EH.descName ->  S[];
    else
       'NoName!'->S[]
   if);
   316->trace(# 
             do 'location:'->xT; S[] -> xT;
                xN; desc[] -> xA
             #);
   (if not desc.isNull then
       (if desc.label = gram.mainPart then
           desc[] -> sematt.MainPartDesc -> desc[]
       if);
       (if desc.label
        // gram.objectDescriptor then
           desc.descId -> (formId[],descNo);
           desc.son->N; N.brother->N;
           (if N.isSlot then 
               (* desc has mainPart slot *)
               desc[] -> slotLocation -> location[] (* is this what we want? *)
            else 
               (* check if do-part is a slot *)
               N.son->N;     (* att-part*)
               N.brother->N; (* action-part*)
               N.son->N;     (* enter-part*)
               N.brother->N; (* do-part *)
               (if N.isSlot then 
                   (* desc has do-part slot *)
                   desc[] -> slotLocation-> location[] (* is this what we want? *)
                else
                   formId.makeUC;
                   (desc.frag[]).fullName -> location[];
                   (if desc.frag.category 
                    // gram.attributesForm then
                       location[] -> stripForm -> location[];
                    else
                       location[] -> stripFileAndForm -> location[];
                       desc.frag.root[] -> astAsAstIndex -> N;
                       316 -> trace(#
                                   do 'location:fragName:' -> xT;
                                      N[] -> xA
                                   #);
                       (N[],true)
                         -> EH.DescName 
                         -> location.append
                   if)
               if)
           if)
        // gram.unExpanded then
           desc[] -> slotLocation -> location[]
   if)if);
   316->trace(#
             do 'is: ' -> xT;
                (if location[] = none then
                    'unknown' -> xT
                 else 
                    (if location.length = 0 then 
                        'local' -> xT
                     else
                        location[] -> xT
             if)if)#)
   
---signature_getAttSig:dopart---
do 313->trace(#
             do 'getAttSig:'->xT;
                EV[] -> xA;
                ev.label -> xI;
                ev.label -> sematt.evalClass -> xI
             #);
   (if EV.label
    // gram.insertedItem  then
       (# den,desc: @ASTindex; mn,isVirt: @integer
       do EV.son -> den;
          (if den.label = gram.objectDescriptor then 
              (* just to get the corretc chain[] *)
              (chain[],den)->DH.theDesc->(desc,MN,chain[],isVirt);
              (if isEnter then
                  (den[],chain[]) -> scanNargs -> xSig[];
               else
                  (den[],chain[]) -> scanXargs -> xSig[];
              if);
              313->trace(#do 'getAttSig:inserted:'->xT;  xSig.asText->xT#)
           else
              sematt.dataDesc[] -> Reference -> xSig[]                
          if)
       #)
       (* // gram.objectDenotation then
        'LunknownObjectDenotation;'->sig[]*)
    // gram.objectReference 
    // gram.structureReference then
       EV[] -> referenceSignature -> xSig[];         
    // gram.thisObject then
       (# AD: @ASTindex
       do EV.son -> AD;
          AD.descRef -> AD;
          AD[] -> Reference -> xSig[]
          (* AD.dclRef -> AD;
           * AD.getText -> Reference -> xSig[]*)
       #)
    // gram.assignmentEvaluation then
       (* preliminary *)
       (# EV1: @ASTindex
       do EV.son -> EV1;
          (if not isEnter then EV1.brother -> EV1 if);
          (EV1[],theDesc[],isEnter,chain[]) -> getAttSig -> xSig[]
       #)
    // gram.evalList then
       (# lSig: ^ListSignature
       do ListSignature -> lSig[];
          Ev.son -> scanList
          (# E: @ASTindex
          do currentNode->E;
             (E[],theDesc[],isEnter,chain[]) -> getAttSig -> lSig.append
          #);
          lSig[] -> xSig[]
       #)
    // gram.repetitionSlice then
       '\nOBS! getAttSig:repetitionSlice'->putline;
       sematt.integerdesc[] -> valuesignature -> array -> xSig[]
    // gram.textConst then
       (* we should make a pattern for the following code and also
        * use it in e.g. referenceSignature
        *)
       sematt.textDesc[] -> reference -> xSig[];
       (*(sematt.textDesc[] ,true)
        -> EH.descName
        -> Reference 
        -> xSig[];  
        sematt.textDesc[] -> descLocation -> xSig.location[];*)
    // gram.integerConst 
    // gram.primitive
    // gram.primitiveExp then
       sematt.integerdesc[] -> valuesignature -> xSig[]
    else
       (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
           int32Value -> xSig[]
        else
           EV[] -> sematt.AttDesc -> nD[];
           311->trace(#
                     do nD.display;
                     #);

           (if nD.kind
            // sematt.standardKind then
               (if nD.isRep then
                   nD.desc[] -> valueSignature -> Array -> xSig[]
                else
                   nD.desc[] -> valueSignature -> xSig[]
               if)
            // sematt.generalKind 
            // sematt.classKind 
            // sematt.externalClassKind then
               (# desc: @ASTindex; MN,isVirt: @integer
               do (chain[],nD.desc)->DH.theDesc->(desc,MN,chain[],isVirt);
                  311->trace(#
                            do 'getAttSig:X:desc:'->xT; desc[] -> xA; 
                               chain
                            #);
                  (if isEnter then
                      (nD.desc[],chain[]) -> scanNargs -> xSig[]
                   else
                      (nD.desc[],chain[]) -> scanXargs -> xSig[]
                  if)
               #)
            else
               (* don't work if virtual - we should get generalKind
                * but ...
                *)
               (if nD.spec.label = gram.dynamicItem then
                   (chain[](*theDesc->DH.newSingle*),nD.apl)
                     -> DH.theDesc
                     -> (desc,MN,EVchain[],isVirtual);
                   (if desc.label = gram.objectDescriptor then
                       desc[] -> reference -> xsig[]
                       (*
                        (desc[],true)
                        -> EH.descName
                        -> Reference 
                        -> xsig[];
                        desc[] -> descLocation -> xsig.location[]*)
                    else 
                       ' ***??? not descriptor ' -> putline;
                       sematt.dataDesc[] ->Reference -> xSig[];
                   if)
                else
                   ' ***??? not dynamic ' -> putline;
                   sematt.dataDesc[] ->Reference -> xSig[];
               if);
   if)if)if);
   313->trace(#do 'getAttSig:return:'->xT; xSig.asText -> xT #)   

---signature_newInstance:doPart---
do (# orgDesc: ^ASTindex; 
      class,orgName: ^text; 
      classKind: @integer;
      hasOrigin,local: @boolean;
   do 311->trace(#
                do 'newInstance: '->xT; desc[] -> xA
                #);
      desc -> sematt.descKind -> classKind;
      (if classKind = sematt.externalClassKind then
          desc[] -> getExternalClassName -> class[]
          (* do we come here? No we never create an instance
           * of a direct subclass of externalClass
           *)
       else 
          ('G',desc[]) -> mkEntryPoint -> (class[],local);
      if);
      (if (desc.label = gram.objectDescriptor)
          and (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          '-' -> orgName[];
       else
          (if true
           // 'java/lang/Object'-> class.equal
           // 'class [mscorlib]System.Object' -> class.equal 
           // 'BetaObject' -> class.equal 
           // 'object' -> class.equal then
              '-' -> orgName[];
              (*1 -> TODO; - should be ok now *)
           else
              true -> hasOrigin;
              (if desc.label = gram.unExpanded then
                  &ASTindex[] -> orgDesc[];
                  desc.slotOrigin -> orgDesc;
                  (desc[]-> sematt.encDesc,true)
                    -> EH.descName 
                    -> orgName[]
               else
                  desc[] -> sematt.descOrigin -> orgDesc[];
                  (if orgDesc.isNull then
                      (*'\n***OriginDesc is null (betaenv?)' -> putline;*)
                      (if common.switch[320] then
                          platFormSuperName -> orgName[]
                       else
                          defaultSuperName -> orgName[]
                      if)
                   else
                      (orgDesc[],true) -> EH.descName -> orgName[]
      if)if)if)if);
      313->trace(#
                do 'newInstance:originName:' -> xT; orgName[] -> xT; xN;
                   desc[] -> xA; xN;
                   'origin:'->xT; xN; orgDesc[] -> xA
                #);
      
      (if true 
       // common.targetMachineId = common.javabc then
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)
            ->mch.callAlloPrim;
       // common.targetMachineId = common.dotnet then
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)->mch.callAlloPrim;
       else
          'newInstance: unknown platform' -> thisTranslate.systemException
      if)
   #);

---signature_addExit:doPart---   
do addExit:
     (#
     do 313->trace(#
                  do 'Signature:addExit:'->xT; xN;
                     thisMethodDesc[]->xA; xN;
                     (if thisChain[] <> none then
                         thisChain
                     if)
                  #);
        
        setVoidXsig;

        (if thisChain[] <> none then
            &ListSignature[] -> XXLsig[];
            (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
              -> xScan 
              -> more;
            (if not more then exitVoid; leave addExit if);
            loop:
              (if more then
                  (xScan.thisEv[]->exitVal[]
                  ,thisMethodDesc[],false,thisChain[]) 
                    -> getAttSig 
                    -> XXsig[]
                    -> XXLsig.append;
                  xScan -> more;
                  (if more or XXsig.isList then 
                      true -> isMultiValExit; 
                      restart loop
                  if);
              if);
            (if isMultiValExit then 
                (* we exit a reference to this object *)
                thisMethodDesc[] -> reference -> XXsig[]
            if)                
         else
            '\n***OBS. thisChain is none '->putline;
            (if (thisMethodDesc[]->theGen.scanXarg->exitVal[]) <> NONE then
                (exitVal[],thisMethodDesc[],false,thisChain[]) 
                  -> theGen.getAttSig 
                  -> XXsig[];
        if)if);
        (if XXsig.isRef then
            2 -> exitId
         else
            1 -> exitId
        if);
     #)
