ORIGIN 'signature'
---bytecode_TODO_rep:descriptor---
(# R: [2] @boolean;
   top: @integer
#)
---bytecode_TODO:doPart---
do (if (1 <= n) and (n <= rep.R.range) then
       (if not rep.R[n] then
           '\nTODO: ' -> puttext;
           (* 1 & 2 should hav been fixed *)
           (if n
            // 1 then
               'NewInstance of "object" ' -> puttext;
               ' will probably not work' -> putline               
            // 2 then               
               'No call of do-method generated for "object"' -> putline
            else 'No message???' -> putline
           if);           
           true -> rep.R[n]
       if)
   if)
   

---descLocation:doPart---
do (# encDescOrSlot:
        (* Return nearest enclosing descriptor or descriptor slot of D *)
        (# D: ^ASTindex; orgDesc: @ASTindex
        enter D[]
        do (if D.label
            // gram.objectDescriptor then
               D.origin -> orgDesc
            // gram.unexpanded then
               D.slotOrigin -> orgDesc
            // gram.descriptorForm // gram.attributesForm then
               D.xOrigin -> orgDesc
            // gram.doPart then
               (if D.descNo = 0 then (* no tmp. data *)
                   D.xOrigin -> orgDesc;
                   (* pass by the dopart slot *)
                   orgDesc.slotOrigin -> orgDesc;
                else
                   (if switch182 then 
                       313->trace
                       (#
                       do 'OBS! enclosingDesc: D.descNo<>0'->xT;
                          D[] -> xA
                       #)
                   if)
               if)
            // gram.mainPart then
               D.xOrigin -> orgDesc                     
            else
               (* unExpanded 
                *)
               313->trace(#do D[] -> xA #)
           if);
           L: (if orgDesc.label
               // gram.descriptorForm // gram.attributesForm then
                  orgDesc.xOrigin -> orgDesc;
                  (if not orgDesc.isNull then restart L if)
               // gram.doPart then
                  (if orgDesc.descNo = 0 then (* no tmp. data *)
                      orgDesc.xOrigin -> orgDesc;  
                      (* pass by the dopart slot *)
                      orgDesc.slotOrigin -> orgDesc;
                      restart L
                   else
                      (if switch182 then 
                          313->trace
                          (#
                          do 'OBS! enclosingDesc: D.descNo<>0'->xT;
                             orgDesc[] -> xA
                          #)
                      if)
                  if);
               // gram.forImp
               // gram.repetitionDecl
               // gram.labelledImp then
                  orgDesc.origin -> orgDesc;
                  restart L
                  (* else: unExpanded, ... *)
              if)   
        exit orgDesc[]
        #);        
      encDescHasSlots:
        (* follow origin to top of fragment *)
        (# desc,DX,D: ^ASTindex
        enter desc[]
        do &ASTindex[] -> DX[]; desc -> DX;
           (if not DX.isNull then
               L: (#
                  do 317 -> trace(# 
                                 do 'encDescHasSlots:'->xT;
                                    DX[] -> xA
                                 #);
                     (if true then
                         DX[] -> (*sematt.*)encDescOrSlot -> DX[];
                         (if not DX.isNull then
                             (if DX.label 
                              // gram.objectDescriptor then
                                 (if DX[] -> hasSlots then 
                                     DX[] -> D[]; 
                                  else
                                     restart L
                                 if)
                              // gram.unExpanded then
                              else
                                 '??????'->putline
                             if)
                         if)
                      else
                         DX.origin -> DX;
                         (if DX.label 
                          // gram.objectDescriptor then
                             (if DX[] -> hasSlots then 
                                 DX[] -> D[]; 
                              else
                                 restart L
                             if)
                          // gram.forImp 
                          // gram.repetitionDecl // gram.labelledImp then
                             restart L
                     if)if)
           #)if)
        exit D[]
        #);
      (* OBS Unify with the one in genlib_bytecode *)
      hasSlots: booleanValue
        (# desc: ^ASTindex; N: @ASTindex
        enter desc[]
        do 313->trace(#
                     do 'hasSlots: '->xT; desc[] -> xA 
                     #);
           (if desc.label = gram.objectDescriptor  then
               desc.son -> N; N.brother -> N;
               (if N.isSlot then
                   (* main part slot *)
                   true -> value
                else
                   N.son -> N;     (* att-part*)
                   N.brother -> N; (* action-part*)
                   (if not N.isNull then
                       N.son -> N;     (* enter-part*)
                       N.brother -> N; (* do-part *)
                       N.isSlot -> value
               if)if)
               (* else perhaps slots and nameApls should be considered?*)
           if)
        #);

      ED: ^ASTindex
   do 
      (if (desc[] <> none) and not desc.isNull then
          (desc[],true) -> EH.descName ->  S[];
       else
          'NoName!'->S[]
      if);
      316->trace(# 
                do 'location:'->xT; S[] -> xT;
                   xN; desc[] -> xA
                #);
      (if not desc.isNull then
          (if desc.label = gram.mainPart then
              desc[] -> sematt.MainPartDesc -> desc[]
          if);
          (if desc.label
           // gram.objectDescriptor then
              desc.descId -> (formId[],descNo);
              desc.son->N; N.brother->N;
              (if N.isSlot then 
                  (* desc has mainPart slot *)
                  desc[] -> slotLocation -> location[] (* is this what we want? *)
               else 
                  (* check if do-part is a slot *)
                  N.son->N;     (* att-part*)
                  N.brother->N; (* action-part*)
                  N.son->N;     (* enter-part*)
                  N.brother->N; (* do-part *)
                  (if N.isSlot then 
                      (* desc has do-part slot *)
                      desc[] -> slotLocation-> location[] (* is this what we want? *)
                   else
                      (if (desc[] -> encDescHasSlots -> ED[]) <> none then
                          (ED[],true) -> EH.descname -> location[];
                          (if not common.switch[188] then
                              '\ndescWithSlots:location:'->puttext;
                              location[] -> putline
                          if);
                       else
                          formId.makeUC;
                          (desc.frag[]).fullName -> location[];
                          (if desc.frag.category 
                           // gram.attributesForm then
                              location[] -> stripForm -> location[];
                           else
                              location[] -> stripFileAndForm -> location[];
                              desc.frag.root[] -> astAsAstIndex -> N;
                              316 -> trace(#
                                          do 'location:fragName:' -> xT;
                                             N[] -> xA
                                          #);
                              (N[],true)
                                -> EH.DescName 
                                -> location.append
                          if)
                      if)
                  if)
              if)
           // gram.unExpanded then
              desc[] -> slotLocation -> location[]
      if)if);
      (* imports at all other places should now be removed *)
      (if location[] <> none then location[] -> mch.import if);

      316->trace(#
                do 'is: ' -> xT;
                   (if location[] = none then
                       'unknown' -> xT
                    else 
                       (if location.length = 0 then 
                           'local' -> xT
                        else
                           location[] -> xT
                if)if)#)
   #)
   
---signature_constructorSignature:doPart---
do (if not (originDesc[] = none) and not originDesc.isNull then
       (if (originDesc -> sematt.descKind) = sematt.externalClassKind then
           originDesc[] -> getExternalClassName -> originName[]
        else 
           (if originName[] = none then
               (originDesc[],true) -> EH.descName -> originName[]
           if);           
       if);
       (if (originDesc[] -> descLocation -> location[]) <> none then
           location[] -> mch.import
       if);
    else
       (if originName[] = none then
           platFormSuperName -> originName[]
   if)if);
   (if not ('-' -> originName.equal) then
       (originDesc[] -> mkSig,none) -> sig.append
   if)
   
---signature_getAttSig:dopart---
do (# referenceSignature: (* unify with dynamicItem case in do-part below*)
        (# EV: ^ASTindex;
           sig,aplSig: ^Type
        enter EV[]
        do (EV[],chain[]) -> sematt.AttDesc -> nD[];
           301->trace(#do nD.display; chain #);
           (if true then
               (if nD.desc.label = gram.objectDescriptor then
                   (if nD.isRep then 
                       nD.desc[] -> reference -> array -> sig[]
                    else
                       nD.dclDesc[] -> reference -> sig[];
                       nD.desc[] -> reference -> aplSig[];
                   if)
                else 
                   '\nsignature:getAttSig:not descriptor ' -> putline;
                   sematt.dataDesc[]->Reference -> sig[];
               if)
            else
               (if nD.spec.label 
                // gram.dynamicItem // gram.staticItem then
                   (chain[],nD.apl)
                     -> DH.theDesc
                     -> (desc,MN,EVchain[],isVirtual);
                   (if not (desc -> nD.desc.equal) then
                       (* THE mismatch comes from the fact that AttDesc
                        * uses thisSuperChain and above we call DH.theDesc
                        * with the real chain[]. We should fix this and
                        * at the same time consider to compute both
                        * the original desc assocaited with the declaration
                        * and the known descriptor; as in                    
                        *    X: ^V;  V:<T
                        *    ...
                        *    V::< TT;  Xa
                        * at xA the decl desc is T and the known desc is TT.
                        * For methods, arguments and return types have to
                        * be the decl desc.
                        * BUT fixed now: attDesc get a chain!
                        *)
                       '\ngetAttSig:desc mismatch'->putline;
                       301 -> trace(#
                                   do 'descMismatch:'->xT; xN;
                                      desc[] -> xA; xN;
                                      nD.desc[] -> xA
                                   #)
                   if);
                   (if desc.label = gram.objectDescriptor then
                       (if nD.isRep then 
                           desc[] -> reference -> array -> sig[]
                        else
                           desc[] -> reference -> sig[]
                       if)
                    else 
                       ' ***??? not descriptor ' -> putline;
                       sematt.dataDesc[]->Reference -> sig[];
                   if)
                else
                   sematt.dataDesc[] ->Reference -> sig[];
           if)if)
        exit(sig[],aplSig[])
        #);
      nD: ^sematt.AttDesc; EH: @EvalHandler;
      desc: @ASTindex; 
      MN,isVirtual: @integer;
      EVchain: ^DH.superChain;

   do 313->trace(#
                do 'getAttSig:'->xT;
                   EV[] -> xA;
                   ev.label -> xI;
                   ev.label -> sematt.evalClass -> xI
                #);
      L:
        (if EV.label
         // gram.insertedItem  then
            (# den,desc: @ASTindex; mn,isVirt: @integer
            do EV.son -> den;
               (if den.label = gram.objectDescriptor then 
                   (* just to get the correct chain[] *)
                   (chain[],den)->DH.theDesc->(desc,MN,chain[],isVirt);
                   (if isEnter then
                       (den[],chain[]) -> scanNargs -> xSig[];
                    else
                       (den[],chain[]) -> scanXargs -> xSig[];
                   if);
                   313->trace(#
                             do 'getAttSig:inserted:'->xT; xSig.asText->xT
                             #)
                else
                   sematt.dataDesc[] -> Reference -> xSig[]                
               if)
            #)
            (* // gram.objectDenotation then
             'LunknownObjectDenotation;'->sig[]*)
         // gram.objectReference 
         // gram.structureReference then
            (if ((EV.sonRef).sonRef).label = gram.thisObject then
                (EV.sonRef).sonRef -> EV[];
                restart L
             else           
                EV[] -> referenceSignature -> (xSig[],aplSig[])
            if)
         // gram.thisObject then
            (# AD: @ASTindex
            do EV.son -> AD;
               AD.descRef -> AD;
               AD[] -> Reference -> xSig[]
               (* AD.dclRef -> AD;
                * AD.getText -> Reference -> xSig[]*)
            #)
         // gram.assignmentEvaluation then
            (* preliminary *)
            (# EV1: @ASTindex
            do EV.son -> EV1;
               (if not isEnter then EV1.brother -> EV1 if);
               (EV1[],theDesc[],isEnter,chain[]) 
                 -> getAttSig -> (xSig[],aplSig[])
            #)
         // gram.evalList then
            (# lSig: ^ListSignature
            do ListSignature -> lSig[];
               Ev.son -> scanList
               (# E: @ASTindex
               do currentNode->E;
                  (E[],theDesc[],isEnter,chain[]) -> getAttSig -> lSig.append
               #);
               lSig[] -> xSig[]
            #)
         // gram.repetitionSlice then
            (# theRep: @ASTindex; size: @integer
            do EV.son -> theRep;
               (if EV.evalKind
                // sematt.repValEval then 
                   (if theRep[] -> sematt.repSize -> size 
                    // '1' then 
                       sematt.chardesc[] -> valuesignature -> array -> xSig[]
                    // '2' then 
                       sematt.int16desc[] -> valuesignature -> array -> xSig[]
                    // '4' then 
                       sematt.integerdesc[] -> valuesignature -> array -> xSig[]
                    // '8' then 
                       sematt.realdesc[] -> valuesignature -> array -> xSig[]
                    else
                       '\nOBS! getAttSig:repetitionSlice:size:'->puttext;
                       size -> putint; newline
                   if)
                // sematt.repRefEval then              
                   '\nOBS! getAttSig:repetitionSlice:repRefEval:'->puttext;
                else
                   '\nOBS! getAttSig:repetitionSlice:unknown:EvalKind:'->puttext;
               if)
            #)
         // gram.textConst then
            (* we should make a pattern for the following code and also
             * use it in e.g. referenceSignature
             *)
            (# T: ^text
            do EV.getText -> T[];
               (if T.length = 1 then
                   (* will not always work, since a '*' may be a text *)
                   sematt.charDesc[] -> valueSignature -> xSig[]
                else
                   sematt.textDesc[] -> reference -> xSig[];
               if);
            #)
         // gram.integerConst 
         // gram.primitive
         // gram.primitiveExp then
            sematt.integerdesc[] -> valuesignature -> xSig[]
         else
            (* check what this else part covers;
             * it covers objectDenotation - but what else?
             *)
            (if (EV.label -> sematt.evalClass) = sematt.evalClass.binOp then
                int32Value -> xSig[]
             else
                (EV[],chain[]) -> sematt.AttDesc -> nD[];
                302->trace(#
                          do 'getAttSig:else: ' -> xT; nD.display;
                          #);

                (if nD.kind
                 // sematt.standardKind then
                    (if nD.isRep then
                        nD.desc[] -> valueSignature -> Array -> xSig[]
                     else
                        nD.desc[] -> valueSignature -> xSig[]
                    if)
                 // sematt.generalKind 
                 // sematt.classKind 
                 // sematt.externalClassKind then
                    313->trace(# do 'getAttSig:GO'->xT #);
                    (* we assume object denotation here *)
                    (if nD.isRep then
                        313->trace(# do 'getAttSig:IsRep'->xT;#);
                        nD.desc[] -> reference -> array -> xSig[];
                        (*xSig.asText -> putline;*)
                     else
                        313->trace(# do 'getAttSig:IsNotRep'->xT#);
                        (# desc: @ASTindex; MN,isVirt: @integer
                        do (*(chain[],nD.desc)
                             -> DH.theDesc
                             -> (desc,MN,chain[],isVirt);*)
                           301->trace(#
                                     do 'getAttSig:X:desc:'->xT; xN;
                                        nD.desc[] -> xA; 
                                        chain
                                     #);
                           (if isEnter then
                               (nD.desc[],nD.descChain[]) 
                                 -> scanNargs
                                 -> xSig[]
                            else
                               (nD.desc[],nD.descChain[])
                                 -> scanXargs 
                                 -> xSig[]
                           if)
                    #)if)
                 else
                    (* so what is this case here? *)
                    (* don't work if virtual - we should get generalKind
                     * but ...
                     *)
                    EV[] -> referenceSignature -> (xSig[],aplSig[])
        if)if)if);
      313->trace(#do 'getAttSig:return:'->xT; xSig.asText -> xT #)   
   #)
   
---signature_newInstance:doPart---
do (# EH: @evalHandler;
      orgDesc: ^ASTindex; 
      class,orgName: ^text; 
      classKind: @integer;
      local: @boolean;
   do 311->trace(#
                do 'newInstance: '->xT; desc[] -> xA
                #);
      desc -> sematt.descKind -> classKind;
      (if classKind = sematt.externalClassKind then
          desc[] -> getExternalClassName -> class[]
          (* do we come here? No we never create an instance
           * of a direct subclass of externalClass
           *)
       else 
          ('G',desc[]) -> mkEntryPoint -> (class[],local);
      if);
      (if (desc.label = gram.objectDescriptor)
          and (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          '-' -> orgName[];
       else
          (if true
           // 'java/lang/Object'-> class.equal
           // 'class [mscorlib]System.Object' -> class.equal 
           // 'BetaObject' -> class.equal 
           // 'object' -> class.equal then
              '-' -> orgName[];
              (*1 -> TODO; - should be ok now *)
           else
              true -> hasOrigin;
              (if true  then
                  desc[] -> sematt.enclosingDesc -> orgDesc[]
              if);

              (if desc.label = gram.unExpanded then
                  (if false then
                      &ASTindex[] -> orgDesc[];
                      desc.slotOrigin -> orgDesc;
                      (if (orgDesc.label = gram.labelledImp) then
                          orgDesc.origin -> orgDesc
                      if);
                  if);
                  (desc[]-> sematt.encDesc,true)
                    -> EH.descName 
                    -> orgName[]
               else
                  (if false then desc[] ->sematt.descOrigin -> orgDesc[] if);
                  (if orgDesc.isNull then
                      (*'\n***OriginDesc is null (betaenv?)' -> putline;*)
                      (if common.switch[320] then
                          platFormSuperName -> orgName[]
                       else
                          defaultSuperName -> orgName[]
                      if)
                   else
                      (*(if (orgDesc.label = gram.labelledImp) then
                          orgDesc.origin -> orgDesc
                      if);*)
                      (orgDesc[],true) -> EH.descName -> orgName[]
      if)if)if)if);
      313->trace(#
                do 'newInstance:originName:' -> xT; orgName[] -> xT; xN;
                   desc[] -> xA; xN;
                   'origin:'->xT; xN; orgDesc[] -> xA
                #);
      
      (orgDesc[],orgName[]) -> ConstructorSignature -> consSig[];
      
      (if true 
       // common.targetMachineId = common.javabc then
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          (if true(*hasOrigin*) then INNER newInstance; (* push origin *) if);
          ('init',consSig.asText) -> mch.callAlloPrim
       // common.targetMachineId = common.dotnet then
          (if true (*hasOrigin*) then INNER newInstance; (* push origin *) if);
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          313->trace(#do 'consSig: '->xT; conssig.astext->xT #);
          ('init',consSig.asText) -> mch.callAlloPrim
       else
          'newInstance: unknown platform' -> thisTranslate.systemException
      if)
   #);
   
---signature_hasNoEnterAndExitThis:doPart---
do (if not isPtnClassMethod and (NNsig.top = 0) then
       (* no enter arguments *)
       (if not (isMultiValExit -> value) then
           (# NMpos: @integer; CN: ^text
           do (* '\nExitThis:' -> puttext;
              'method: "' -> puttext; method[]->puttext;
              '" XXsig: "'->puttext; XXsig.classname->puttext;
               '"\n   className: "'->puttext;
               *)
              XXsig.classname->CN[]; 
              CN.scanAll
              (# pos: @integer
              do pos+1->pos;
                 (if ch = common.nameManglingCh then
                     pos -> NMpos
                 if)
              #);
              (* '" exitNameSig: "' -> puttext;
              (NMpos+1,CN.length) -> CN.sub -> puttext; '"\n'->puttext;*)
              ((NMpos+1,CN.length) -> CN.sub -> method.equal) -> value
           #)
   if)if)
   
---signature_astext:doPart---
do (# addPossibleNameManglingCh:
        (#
        do (if hasNoEnterAndExitThis
               and not( 'exit'->method.equal)
               and not( 'do'->method.equal)
               and not( 'enter'->method.equal)
               then
               common.nameManglingCh -> T.put
           if)
        #)
   do (if isJava then
          (if receiver[] <> NONE then
              (* method call signature *)
              receiver.copy -> T[];
              '/' -> T.put
           else
              &text[] -> T[];
              (if isStatic then
                  'static ' -> T.append
              if)
          if);
          (if method[] <> none then
              method.copy -> T.append;
              addPossibleNameManglingCh;
           else
              '\n*** method is none ' -> putline
          if);
          noNsig-> enterSig -> T.append;
          noXsig -> exitSig -> T.append;
       else
          '' -> T[];
          (if isStatic then
              'static ' -> T.append
          if);
          noXsig -> exitSig -> T.append;
          ' '->T.append;
          (if receiver[] <> none then
              (* method call signature *)
              (receiver[],location[]) -> AddDotnetLocation  -> T.append;
              '::' -> T.append
          if);
          (if method[] <> none then
              '\'' -> T.put; (* Quote to avoid clash with IL 
                              * reserved words, e.g. add 
                              *)
              method.copy -> T.append;
              addPossibleNameManglingCh;
              '\'' -> T.put;
           else
              '\n*** method is none ' -> putline
          if);
          noNsig -> enterSig -> T.append
      if);
      187->ctrace(# 
                 do 'Signature:'  ->xT; T[] -> xT;
                    ' location:'->xT;
                    (if location[] = none then
                        'unknown' -> xT
                     else
                        location[] -> xT
                 if)#)
   #)
---signature_addEnter:doPart---      
do 313->trace(#
             do 'addEnter:'->xT; theDesc[] -> xA
             #);
   ListSignature -> NNsig[];
   (if thisChain[] = none then
       '\nOBS! signature:addEnter:thisChain is none! ' -> putline;
       thisSuperChain -> thisChain[]
   if);
   (if not (theDesc->thisMethodDesc.equal) then 
       (if not common.switch[188] then
           'addEnter:desc not equal'->putline
   if)if);
   313->trace(#
             do 'addEnter:theDesc(from enter):'->xT;
                theDesc[]->xA; xN;
                'thisMethodDesc( for setDesc): ' -> xT;
                thisMethodDesc[] -> xA;
                (if thisChain[] <> none then
                    thisChain
                if) 
             #);
   (if isStatic then (* should be origin of thisMethodDesc *)
       (# org: ^ASTindex
       do thisMethodDesc[] -> sematt.descOrigin -> org[];
          (if org.isNull then
              sematt.superObject[]  -> reference -> sig[]
           else
              org[]
                -> reference 
                -> sig[]
          if);
          org[] -> descLocation -> sig.location[];
          (sig[],none) -> NNsig.append;
       #)
   if);              
   (thisMethodDesc[],gen.thisRegAdr,0,thisChain[],true) 
     -> nScan 
     -> more;
   
   Loop:
     (if more then 
         (nScan.thisEv[],thisMethodDesc[],true,nScan.thisChain[])
           -> getAttSig
           -> NNsig.append;
         313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
         nScan -> more;
         restart Loop
     if);
   313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);

---signature_addExit:doPart---   
do addExit:
     (# 
     do 313->trace(#
                  do 'Signature:addExit:'->xT; xN;
                     thisMethodDesc[]->xA; xN;
                     (if thisChain[] <> none then
                         thisChain
                     if)
                  #);
        
        setVoidXsig;

        (if thisChain[] <> none then
            &ListSignature[] -> XXLsig[];
            (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
              -> xScan 
              -> more;
            (if not more then exitVoid; leave addExit if);
            loop:
              (if more then
                  (xScan.thisEv[]->exitVal[]
                  ,thisMethodDesc[],false,xScan.thisChain[]) 
                    -> getAttSig 
                    -> (XXsig[],aplSig[]);
                  (XXsig[],aplSig[]) -> XXLsig.append;
                  xScan -> more;
                  (if more or XXsig.isList then 
                      true -> isMultiValExit; 
                      restart loop
                  if);
              if);
            (if isMultiValExit then 
                (* we exit a reference to this object *)
                thisMethodDesc[] -> reference -> XXsig[]
            if)                
         else
            '\n***OBS. thisChain is none '->putline;
            (if (thisMethodDesc[]->theGen.scanXarg->exitVal[]) <> NONE then
                (exitVal[],thisMethodDesc[],false,thisChain[]) 
                  -> theGen.getAttSig 
                  -> (XXsig[],aplSig[]);
        if)if);
        (if true then
            XXsig.elmType -> exitID
         else            
            (if XXsig.isRef then
                2 -> exitId
             else
                1 -> exitId
        if)if);
     #)
   
---signature_isBETAsubOfExternalClass:dopart---
do (# pref,preName,preDesc: @ASTindex;
      subLevel: @integer;
      EH: @evalHandler;
      class: ^text;
      extKind: @integer
   do desc.son -> pref;
      (if pref.label = gram.prefix then
          pref.son -> preName;
          313 -> ctrace(#
                       do 'isBetaSubOfExternalClass:super:' -> xT;
                          preName.gettext -> xT
                       #);
          preName -> sematt.descChain -> (preDesc,subLevel);
          subLevel > 0 -> value;
      if);
      (none,(desc[],true)->EH.descName,desc[],0) 
        -> sematt.cProcDecoder 
        -> (class[],extKind);
      313->trace(#
                do 'isBetaSub: ' -> xT; extKind -> xI;
                   class[] -> xT; xN;
                #);
      (class[] = none) -> value
   #)
 
---signature_getExternalClassName:doPart---
do (* We should optimize such that descname is only called when
    * no classname is specified in the externalClass
    *)
   (# C: ^text
   do (none,(desc[],true)->EH.descName->c[](*hack*),desc[],0) 
        -> sematt.cProcDecoder 
        -> (class[],extKind);
      (if class[] = none then c[] -> class[] if)
   #)

   
   
