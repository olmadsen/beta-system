ORIGIN 'signature'
---bytecode_TODO_rep:descriptor---
(# R: [2] @boolean;
   top: @integer
#)
---bytecode_TODO:doPart---
do (if (1 <= n) and (n <= rep.R.range) then
       (if not rep.R[n] then
           '\nTODO: ' -> puttext;
           (if n
            // 1 then
               'NewInstance of "object" ' -> puttext;
               ' will probably not work' -> putline               
            // 2 then               
               'No call of do-method generated for "object"' -> putline
            else 'No message???' -> putline
           if);           
           true -> rep.R[n]
       if)
   if)
   

---descLocation:doPart---
do (if (desc[] <> none) and not desc.isNull then
       (desc[],true) -> EH.descName ->  S[];
    else
       'NoName!'->S[]
   if);
   316->trace(# 
             do 'location:'->xT; S[] -> xT;
                xN; desc[] -> xA
             #);
   (if not desc.isNull then
       (if desc.label = gram.mainPart then
           desc[] -> sematt.MainPartDesc -> desc[]
       if);
       (if desc.label
        // gram.objectDescriptor then
           desc.descId -> (formId[],descNo);
           desc.son->N; N.brother->N;
           (if N.isSlot then 
               (* desc has mainPart slot *)
               desc[] -> slotLocation -> location[] (* is this what we want? *)
            else 
               (* check if do-part is a slot *)
               N.son->N;     (* att-part*)
               N.brother->N; (* action-part*)
               N.son->N;     (* enter-part*)
               N.brother->N; (* do-part *)
               (if N.isSlot then 
                   (* desc has do-part slot *)
                   desc[] -> slotLocation-> location[] (* is this what we want? *)
                else
                   formId.makeUC;
                   (desc.frag[]).fullName -> location[];
                   (if desc.frag.category 
                    // gram.attributesForm then
                       location[] -> stripForm -> location[];
                    else
                       location[] -> stripFileAndForm -> location[];
                       desc.frag.root[] -> astAsAstIndex -> N;
                       316 -> trace(#
                                   do 'location:fragName:' -> xT;
                                      N[] -> xA
                                   #);
                       (N[],true)
                         -> EH.DescName 
                         -> location.append
                   if)
               if)
           if)
        // gram.unExpanded then
           desc[] -> slotLocation -> location[]
   if)if);
   316->trace(#
             do 'is: ' -> xT;
                (if location[] = none then
                    'unknown' -> xT
                 else 
                    (if location.length = 0 then 
                        'local' -> xT
                     else
                        location[] -> xT
             if)if)#)
   
---auxlib_newInstance:doPart---
do (# orgDesc: ^ASTindex; 
      class,orgName: ^text; 
      classKind: @integer;
      hasOrigin,local: @boolean;
   do 311->trace(#
                do 'newInstance: '->xT; desc[] -> xA
                #);
      desc -> sematt.descKind -> classKind;
      (if classKind = sematt.externalClassKind then
          desc[] -> getExternalClassName -> class[]
          (* do we come here? No we never create an instance
           * of a direct subclass of externalClass
           *)
       else 
          ('G',desc[]) -> mkEntryPoint -> (class[],local);
      if);
      (if (desc.label = gram.objectDescriptor)
          and (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          '-' -> orgName[];
       else
          (if true
           // 'java/lang/Object'-> class.equal
           // 'class [mscorlib]System.Object' -> class.equal 
           // 'object' -> class.equal then
              '-' -> orgName[];
              1 -> TODO;
           else
              true -> hasOrigin;
              (if desc.label = gram.unExpanded then
                  &ASTindex[] -> orgDesc[];
                  desc.slotOrigin -> orgDesc;
                  (desc[]-> sematt.encDesc,true)
                    -> EH.descName 
                    -> orgName[]
               else
                  desc[] -> sematt.descOrigin -> orgDesc[];
                  (if orgDesc.isNull then
                      (*'\n***OriginDesc is null (betaenv?)' -> putline;*)
                      defaultSuperName -> orgName[]
                   else
                      (orgDesc[],true) -> EH.descName -> orgName[]
      if)if)if)if);
      313->trace(#
                do 'newInstance:originName:' -> xT; orgName[] -> xT; xN;
                   desc[] -> xA; xN;
                   'origin:'->xT; xN; orgDesc[] -> xA
                #);
      
      (if true 
       // common.targetMachineId = common.javabc then
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)
            ->mch.callAlloPrim;
       // common.targetMachineId = common.dotnet then
          (if hasOrigin then INNER newInstance; (* push origin *) if);
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          ('init',((orgDesc[],orgName[])->ClassSignature).asText)->mch.callAlloPrim;
       else
          'newInstance: unknown platform' -> thisTranslate.systemException
      if)
   #);

---signature_addExit:doPart---   
do addExit:
     (#
     do 313->trace(#
                  do 'Signature:addExit:'->xT; xN;
                     thisMethodDesc[]->xA; xN;
                     (if thisChain[] <> none then
                         thisChain
                     if)
                  #);
        
        setVoidXsig;

        (if thisChain[] <> none then
            (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
              -> xScan 
              -> more;
            (if not more then exitVoid; leave addExit if);
            loop:
              (if more then
                  (xScan.thisEv[]->exitVal[],thisMethodDesc[],false) 
                    -> getAttSig 
                    -> XXsig[];
                  xScan -> more;
                  (if more then 
                      true -> isMultiValExit; 
                      (* we exit a reference to this object *)
                      (thisMethodDesc[],true) 
                        -> EH.descname 
                        -> reference 
                        -> XXsig[]
                  if);
              if)
         else
            '\n***OBS. thisChain is none '->putline;
            (if (thisMethodDesc[]->theGen.scanXarg->exitVal[]) <> NONE then
                (exitVal[],thisMethodDesc[],false) 
                  -> theGen.getAttSig 
                  -> XXsig[];
        if)if);
        (if XXsig.isRef then
            2 -> exitId
         else
            1 -> exitId
        if);
     #)
