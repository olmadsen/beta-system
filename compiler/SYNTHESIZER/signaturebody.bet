ORIGIN 'signature'
---bytecode_TODO_rep:descriptor---
(# R: [2] @boolean;
   top: @integer
#)
---bytecode_TODO:doPart---
do (if (1 <= n) and (n <= rep.R.range) then
       (if not rep.R[n] then
           '\nTODO: ' -> puttext;
           (* 1 & 2 should hav been fixed *)
           (if n
            // 1 then
               'NewInstance of "object" ' -> puttext;
               ' will probably not work' -> putline               
            // 2 then               
               'No call of do-method generated for "object"' -> putline
            else 'No message???' -> putline
           if);           
           true -> rep.R[n]
       if)
   if)
   

---descLocation:doPart---
do (# encDescOrSlot:
        (* Return nearest enclosing descriptor or descriptor slot of D *)
        (# D: ^ASTindex; orgDesc: @ASTindex
        enter D[]
        do (if D.label
            // gram.objectDescriptor then
               D.origin -> orgDesc
            // gram.unexpanded then
               D.slotOrigin -> orgDesc
            // gram.descriptorForm // gram.attributesForm then
               D.xOrigin -> orgDesc
            // gram.doPart then
               (if not (D[]->sematt.doPartHasTmp) then 
                   D.xOrigin -> orgDesc;
                   (* pass by the dopart slot *)
                   orgDesc.slotOrigin -> orgDesc;
               if)
            // gram.mainPart then
               D.xOrigin -> orgDesc    (* consider sematt.mainPartDesc *)
            else
               (* unExpanded 
                *)
               313->trace(#do D[] -> xA #)
           if);
           L: (if orgDesc.label
               // gram.descriptorForm // gram.attributesForm then
                  orgDesc.xOrigin -> orgDesc;
                  (if not orgDesc.isNull then restart L if)
               // gram.doPart then
                  (if not (orgDesc[]->sematt.doPartHasTmp) then
                      orgDesc.xOrigin -> orgDesc;  
                      (* pass by the dopart slot *)
                      orgDesc.slotOrigin -> orgDesc;
                      restart L
                  if)
               // gram.forImp
               // gram.repetitionDecl
               // gram.labelledImp then
                  orgDesc.origin -> orgDesc;
                  restart L
                  (* else: unExpanded, ... *)
              if)   
        exit orgDesc[]
        #);        
      encDescHasSlots:
        (* follow origin to top of fragment *)
        (# desc,DX,D: ^ASTindex
        enter desc[]
        do &ASTindex[] -> DX[]; desc -> DX;
           (if not DX.isNull then
               L: (#
                  do 317 -> trace(# 
                                 do 'encDescHasSlots:'->xT;
                                    DX[] -> xA
                                 #);
                     (if true then
                         DX[] -> (*sematt.*)encDescOrSlot -> DX[];
                         (if not DX.isNull then
                             (if DX.label 
                              // gram.objectDescriptor then
                                 (if DX[] -> hasSlots then 
                                     DX[] -> D[]; 
                                  else
                                     restart L
                                 if)
                              // gram.unExpanded then
                              // gram.doPart (* ??? *)
                              // gram.mainPart then
                                 (* conside sematt.mainpartDesc *)
                                 &ASTindex[] -> D[];
                                 DX.xOrigin -> D; D.slotOrigin -> D;
                              else
                                 1->trace(#
                                         do 'encDescHasSlots: '->xT;
                                            DX[] -> xA
                                         #)
                             if)
                         if)
                      else
                         DX.origin -> DX;
                         (if DX.label 
                          // gram.objectDescriptor then
                             (if DX[] -> hasSlots then 
                                 DX[] -> D[]; 
                              else
                                 restart L
                             if)
                          // gram.forImp 
                          // gram.repetitionDecl // gram.labelledImp then
                             restart L
                     if)if)
           #)if)
        exit D[]
        #);
      (* OBS Unify with the one in genlib_bytecode *)
      hasSlots: booleanValue
        (# desc: ^ASTindex; N: @ASTindex
        enter desc[]
        do (*313->trace(#
                     do 'hasSlots: '->xT; desc[] -> xA 
                     #);*)
           (if desc.label = gram.objectDescriptor  then
               desc.son -> N; N.brother -> N;
               (if N.isSlot then
                   (* main part slot *)
                   true -> value
                else
                   N.son -> N;     (* att-part*)
                   N.brother -> N; (* action-part*)
                   (if not N.isNull then
                       N.son -> N;     (* enter-part*)
                       N.brother -> N; (* do-part *)
                       N.isSlot -> value
               if)if)
               (* else perhaps slots and nameApls should be considered?*)
           if)
        #);

      ED: ^ASTindex
   do 
      (if (desc[] <> none) and not desc.isNull then
          (desc[],true) -> EH.descName ->  S[];
       else
          'NoName!'->S[]
      if);
      316->trace(# 
                do 'location:'->xT; S[] -> xT;
                   xN; desc[] -> xA
                #);
      (if not desc.isNull then
          (if desc.label = gram.mainPart then
              desc[] -> sematt.MainPartDesc -> desc[]
          if);
          (if desc.label
           // gram.objectDescriptor then
              desc.descId -> (formId[],descNo);
              desc.son->N; N.brother->N;
              (if N.isSlot then 
                  (* desc has mainPart slot *)
                  desc[] -> slotLocation -> location[] (* is this what we want? *)
               else 
                  (* check if do-part is a slot *)
                  N.son->N;     (* att-part*)
                  N.brother->N; (* action-part*)
                  N.son->N;     (* enter-part*)
                  N.brother->N; (* do-part *)
                  (if N.isSlot then 
                      (* desc has do-part slot *)
                      desc[] -> slotLocation-> location[] (* is this what we want? *)
                   else
                      (if (desc[] -> encDescHasSlots -> ED[]) <> none then
                          (ED[],true) -> EH.descname -> location[];
                       else
                          formId.makeUC;
                          (desc.frag[]).fullName -> location[];
                          (if desc.frag.category 
                           // gram.attributesForm then
                              location[] -> stripForm -> location[];
                           else
                              location[] -> stripFileAndForm -> location[];
                              desc.frag.root[] -> astAsAstIndex -> N;
                              316 -> trace(#
                                          do 'location:fragName:' -> xT;
                                             N[] -> xA
                                          #);
                              (N[],true)
                                -> EH.DescName 
                                -> location.append
                          if)
                      if)
                  if)
              if)
           // gram.unExpanded then
              desc[] -> slotLocation -> location[]
      if)if);
      (* imports at all other places should now be removed *)
      (if location[] <> none then location[] -> mch.import if);

      316->trace(#
                do 'is: ' -> xT;
                   (if location[] = none then
                       'unknown' -> xT
                    else 
                       (if location.length = 0 then 
                           'local' -> xT
                        else
                           location[] -> xT
                if)if)#)
   #)
   
---signature_constructorSignature:doPart---
do (if not (originDesc[] = none) and not originDesc.isNull then
       (if (originDesc -> sematt.descKind) = sematt.externalClassKind then
           originDesc[] -> getExternalClassName -> originName[]
        else 
           (if originName[] = none then
               (originDesc[],true) -> EH.descName -> originName[]
           if);           
       if);
       (if (originDesc[] -> descLocation -> location[]) <> none then
           location[] -> mch.import
       if);
    else
       (if originName[] = none then
           platFormSuperName -> originName[]
   if)if);
   (if not ('-' -> originName.equal) then
       (originDesc[] -> mkSig,none) -> sig.append
   if)
   
---signature_getAttSig:dopart---
do (# referenceSignature: (* unify with dynamicItem case in do-part below*)
        (# EV: ^ASTindex;
           sig,aplSig: ^Type
        enter EV[]
        do (EV[],chain[]) -> sematt.AttDesc -> nD[];
           301->trace(#do nD.display; chain #);
           (if nD.desc.label = gram.objectDescriptor then
               (if nD.isRep then 
                   nD.desc[] -> reference -> array -> sig[]
                else
                   nD.dclDesc[] -> reference -> sig[];
                   nD.desc[] -> reference -> aplSig[];
               if)
            else 
               '\nsignature:getAttSig:not descriptor ' -> putline;
               sematt.dataDesc[] -> Reference -> sig[];
           if)
        exit(sig[],aplSig[])
        #);
      nD: ^sematt.AttDesc; EH: @EvalHandler;
      desc: @ASTindex; 
      EVchain: ^DH.superChain;

   do 313->trace(#
                do 'getAttSig:'->xT; 100 -> switchon;
                   EV[] -> xA; 100 -> switchoff;
                   ev.label -> xI;
                   ev.label -> sematt.evalClass -> xI
                #);
      L:
        (if EV.label
         // gram.insertedItem  then
            (# den,desc: @ASTindex; 
            do EV.son -> den;
               (if den.label = gram.objectDescriptor then 
                   (* just to get the correct chain[] *)
                   (chain[],den)->DH.theDesc->(desc,chain[]);
                   (if isEnter then
                       (den[],chain[]) -> scanNargs -> xSig[];
                    else
                       (den[],chain[]) -> scanXargs -> xSig[];
                   if);
                   313->trace(#
                             do 'getAttSig:inserted:'->xT; xSig.asText->xT
                             #)
                else
                   sematt.dataDesc[] -> Reference -> xSig[]                
               if)
            #)
            (* // gram.objectDenotation then
             'LunknownObjectDenotation;'->sig[]*)
         // gram.objectReference then
            (if ((EV.sonRef).sonRef).label = gram.thisObject then
                (EV.sonRef).sonRef -> EV[];
                restart L
             else    
                (# Srt: @ASTindex
                do 
                   (EV[],chain[]) -> sematt.AttDesc -> nD[];
                   nD.sort -> Srt;
                   (*1->trace(#
                           do 'Ref: ' -> xT;
                              100->switchon;
                              Srt[] -> xA; xN;
                              nD.apl[] -> xA; 

                    #);*)
                   (* Very messy: probably to hanlde ref2rep *)
                   (if (Srt.label = gram.repetitionDecl) 
                       and
                       ((nD.apl.label = gram.nameApl)
                       or
                       (nD.apl.label = gram.remote))
                       (* consider more AttDen's *)
                       then
                       (# N: @ASTindex;
                       do nD.node -> N; N.son -> N; 
                         (* 1->trace(# do N.sonref -> xA #);*)
                       (if (N.sonRef).label = gram.indexed then
                           (* R[i][] should NOT be array type *)
                           nD.desc[] -> reference -> xSig[]->aplSig[]
                        else
                           nD.desc[] -> mkArraySig -> xSig[] -> aplSig[]
                       if)
                       #)
                    else
                       EV[] -> referenceSignature -> (xSig[],aplSig[])
                   if)
                #)
            if)
         // gram.structureReference then
            StructureSignatureId -> specialSignature -> xSig[]
         // gram.thisObject then
            (# AD: @ASTindex
            do EV.son -> AD;
               AD.descRef -> AD;
               AD[] -> Reference -> xSig[]
            #)
         // gram.assignmentEvaluation then
            (* preliminary *)
            (# EV1: @ASTindex
            do EV.son -> EV1;
               (if not isEnter then EV1.brother -> EV1 if);
               (EV1[],theDesc[],isEnter,chain[]) 
                 -> getAttSig -> (xSig[],aplSig[])
            #)
         // gram.evalList then
            (# lSig: ^ListSignature
            do ListSignature -> lSig[];
               Ev.son -> scanList
               (# E: @ASTindex
               do currentNode->E;
                  (E[],theDesc[],isEnter,chain[]) -> getAttSig -> lSig.append
               #);
               lSig[] -> xSig[]
            #)
         // gram.repetitionSlice then
            (# theRep: @ASTindex; size: @integer
            do EV.son -> theRep;
               (if EV.evalKind
                // sematt.repValEval then 
                   (if theRep[] -> sematt.repSize -> size 
                    // '1' then 
                       sematt.chardesc[] -> valuesignature -> array -> xSig[]
                    // '2' then 
                       sematt.int16desc[] -> valuesignature -> array -> xSig[]
                    // '4' then 
                       sematt.integerdesc[] -> valuesignature -> array -> xSig[]
                    // '8' then 
                       sematt.realdesc[] -> valuesignature -> array -> xSig[]
                    else
                       '\nOBS! getAttSig:repetitionSlice:size:'->puttext;
                       size -> putint; newline
                   if)
                // sematt.repRefEval then              
                   '\nOBS! getAttSig:repetitionSlice:repRefEval:'->puttext;
                else
                   '\nOBS! getAttSig:repetitionSlice:unknown:EvalKind:'->puttext;
               if)
            #)
         // gram.textConst then
            (* we should make a pattern for the following code and also
             * use it in e.g. referenceSignature
             *)
            (# T: ^text
            do EV.getText -> T[];
               (if T.length = 1 then
                   (* will not always work, since a '*' may be a text *)
                   sematt.charDesc[] -> valueSignature -> xSig[]
                else
                   sematt.textDesc[] -> reference -> xSig[];
               if);
            #)
         // gram.integerConst then
            (# T: ^text
            do EV.getText->T[]; 0->T.setPos;
               T.getNumber
               (# integervalue:: 
                    (#do sematt.integerdesc[] -> valuesignature -> xSig[] #);
                  basedValue:: 
                    (#do sematt.integerdesc[] -> valuesignature -> xSig[] #);
                  realValue:: 
                    (# do sematt.realDesc[] -> valuesignature -> xSig[] #);
            #)#)
         // gram.noneExp then
            (* OBS! we may need a noneDesc to avoid superflous qua-checks *)
            sematt.superObject[] -> reference -> xSig[]
         // gram.primitive
         // gram.primitiveExp 
         // gram.address then
            int32Value -> xSig[]
         // gram.notExp then
            boolvalue -> xSig[]
         else
            (* check what this else part covers;
             * it covers objectDenotation - but what else?
             *)
            (if (EV.label -> sematt.evalClass) 
             // sematt.evalClass.binOp 
             // sematt.evalClass.unOp then
                (* unOp is plus or minus - not is covered above *)
                int32Value -> xSig[]
             else
                (EV[],chain[]) -> sematt.AttDesc -> nD[];
                301->trace(#
                          do 'getAttSig:else: ' -> xT; nD.display;
                          #);

                (if nD.kind
                 // sematt.standardKind then
                    (if nD.isRep then
                        nD.desc[] -> valueSignature -> Array -> xSig[]
                     else
                        nD.desc[] -> valueSignature -> xSig[]
                    if)
                 // sematt.generalKind 
                 // sematt.classKind 
                 // sematt.externalClassKind
                 // sematt.constKind then
                    313->trace(# do 'getAttSig:GO'->xT #);
                    (* we assume object denotation here *)
                    (if nD.isRep then
                        313->trace(# do 'getAttSig:IsRep'->xT;#);
                        nD.desc[] -> reference -> array -> xSig[];
                        (*xSig.asText -> putline;*)
                     else
                        313->trace(# 
                                  do 'getAttSig:IsNotRep:'->xT; xN;
                                     nD.desc[] -> xA; 
                                     chain
                                  #);
                        (if isEnter then
                            (nD.desc[],nD.descChain[]) 
                              -> scanNargs
                              -> xSig[]
                         else
                            (nD.desc[],nD.descChain[])
                              -> scanXargs 
                              -> xSig[]
                    if)if);
                    (if aplSig[] = none then
                        xSig[] -> aplSig[]
                    if)
                 else
                    (* so what is this case here? *)
                    (* don't work if virtual - we should get generalKind
                     * but ...
                     *)
                    EV[] -> referenceSignature -> (xSig[],aplSig[])
        if)if)if);
      313->trace(#do 'getAttSig:return:'->xT; xSig.asText -> xT #)   
   #)
   
---signature_newInstance:doPart---
do (# EH: @evalHandler;
      orgDesc: ^ASTindex; 
      class,orgName: ^text; 
      classKind: @integer;
      local: @boolean;
   do 311->trace(#
                do 'newInstance: '->xT; desc[] -> xA
                #);
      desc -> sematt.descKind -> classKind;
      (if (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          desc[] -> getExternalClassName -> class[]; 
          (* do we come here? No we never create an instance
           * of a direct subclass of externalClass;
           * yes we come here - at least used to come here
           * with a betaSubOfExternalClass
           *)
       else 
          ('G',desc[]) -> mkEntryPoint -> (class[],local);
      if);
      (*1->trace(#
              do 'ON: '->xT; classkind->xI; xN;
                 desc[]->xA; xN;
                 (if (classKind = sematt.externalClassKind) then
                     desc[] -> isBETAsubOfExternalClass -> xB
                 if)
              #);*)
      (if (desc.label = gram.objectDescriptor)
          and (classKind = sematt.externalClassKind)
          and not (desc[] -> isBETAsubOfExternalClass) then
          '-' -> orgName[];
         (* 1->trace(#
                  do 'ZZZ:'->xt;orgName[]->xT;
                  #)*)
       else
          (if true
           // 'java/lang/Object'-> class.equal
           // 'class [mscorlib]System.Object' -> class.equal 
           // common.BetaObjectClass -> class.equal then
              '-' -> orgName[];
           else
              true -> hasOrigin;
              desc[] -> sematt.enclosingDesc -> orgDesc[];
              (if desc.label = gram.unExpanded then
                  (desc[]-> sematt.encDesc,true)
                    -> EH.descName 
                    -> orgName[]
               else
                  (if orgDesc.isNull then
                      platFormSuperName -> orgName[]
                   else
                      (orgDesc[],true) -> EH.descName -> orgName[]
      if)if)if)if);
      (*1->trace(#do 'Y:'->xT; orgname[]->xT#);*)
      (orgDesc[],orgName[]) -> ConstructorSignature -> consSig[];
      
      (*1->trace(#do 'consSig: '->xT; consSig.asText -> xT #);*)
      
      (if true 
       // common.targetMachineId = common.jvm then
          (desc[],common.itemKind) -> doLoadProtoAndAlloc;
          INNER newInstance; (* push origin *)
          ('init',consSig.asText) -> mch.callAlloPrim;
       // common.targetMachineId = common.clr then
          INNER newInstance; (* push origin *) 
          (desc[],common.itemKind (*kind*)) -> doLoadProtoAndAlloc;
          313->trace(#do 'consSig: '->xT; conssig.astext->xT #);
          ('init',consSig.asText) -> mch.callAlloPrim
       else
          'newInstance: unknown platform' -> thisTranslate.systemException
      if);
      (if kind = common.compKind then
          ('AlloC',consSig.asText) -> mch.callAlloPrim
      if)
   #);
   
---signature_reference:doPart--
do (if (desc[] <> none) and (not desc.isNull) then
       (if (desc -> sematt.descKind) = sematt.externalClassKind then
           true -> isExternalClass;
           (if not (desc[] -> isBETAsubOfExternalClass) 
                 -> isOutsideExternalClass then
               desc[] -> getExternalClassName -> class[]
            else
               (desc[],true) -> EH.descName -> class[]
           if);
           true -> isExternalText; (* we should check that desc
                                    * is in fact an external text/string
                                    * like java/lang/String
                                    *)
           (if false then
               '(1)ExternalClass '->puttext; 
               (if isOutsideExternalClass then
                   'outside BETA: ' -> puttext;
                else
                   'specialization in BETA:' -> puttext;
               if);
               class[] -> putline;
           if);
        else
           (desc[],true) -> EH.descName -> class[]
       if);
       (if isOutsideExternalClass then
           NONE -> location[]; (* force default location to be 
                                * same as class name *)
        else
           desc[] -> descLocation -> location[];
           (if false then
               (if isExternalClass then
                   'Using location ' -> puttext; location[] -> putline;
               if)
           if);
       if);
       (if true
        // 'beta/BetaObject' -> class.equalNCS 
        // 'beta.BetaObject' -> class.equalNCS then
        // 'object' -> class.equalNCS 
        // 'Object' -> class.equalNCS then
           '\nReference:object'->putline;
           (if true
            // isJava then
               'java/lang/Object' -> class[]
            // isClr then
               'object' -> class[]
            else
               'Unknown_platform.Object' -> class[]
           if);
           (* // 'java/lang/String' -> class.equal then*)
           (* we should generalize this in a better way *)
           
       if);
    else
       platformSuperName -> class[]
   if);
   
-- SpecialSignatureTheDesc:dopart--
do (if sigId 
    // BetaTextSignatureId then
       sematt.textDesc[] -> desc[]
    // JavaStringSignatureId then
       sematt.externalClassDesc[] -> desc[]
    // StructureSignatureId then
       sematt.structureDesc[] -> desc[]
    // ComponentSignatureId then
       'specialSignature.theDesc: ComponentSignatureId??' 
         -> screen.putline;
    // RepetitionSignatureId then
       'specialSignature.theDesc: RepetitionSignatureId??' 
         -> screen.putline
    // RepetitionElementSignatureId then
       'specialSignature.theDesc: RepetitionElmSignatureId??' 
         -> screen.putline              
   if)
   
--SpecialSignatureAsText: dopart--
do (if isJava then
       (if sigId
        // BetaTextSignatureId then
           'text' 
             -> (common.BetaPackage).append 
             -> text2classRef 
             -> T[]
        // JavaStringSignatureId then
           'java/lang/String' -> text2classRef -> T[]
        // StructureSignatureId then
           'Structure' 
             -> (common.BetaPackage).append 
             -> text2classRef 
             -> T[]
        // ComponentSignatureId then
           (if True then
               common.ComponentClass 
                 -> text2classRef 
                 -> T[]
            else
               common.ComponentClass->text2signature -> T[];
           if)
        // RepetitionSignatureId then
           (* is package prefix needed here? *)
           'newRep$' -> text2classRef -> T[]
        // RepetitionElementSignatureId then
           (* is package prefix needed here? *)
           'repElmType$' -> text2classRef -> T[]
        else
           'UnknowSpecialSignature' -> T[]
       if)
    else
       (if sigId
        // BetaTextSignatureId then
           'text' -> T[]
        // JavaStringSignatureId then
           'string' -> T[]
        // StructureSignatureId then
           '' -> T[];
           'class [\'%s\']\'Structure\'' -> T.putformat(# do common.StructureLocation->s #);
        // ComponentSignatureId then
           '' -> T[];
           'class [\'%s\']\'%s\'' -> T.putformat(# do common.ComponentLocation->s; common.ComponentClass->s #);
        // RepetitionSignatureId then
           '' -> T[];
           'class [\'%s\']\'newRep$\'' -> T.putformat(# do common.betaenv.groupname->s #);
        // RepetitionElementSignatureId then
           '' -> T[];
           'class [\'%s\']\'repElmType$\'' -> T.putformat(# do common.betaenv.groupname->s #);
        else
           '>>>>>UnknowSpecialSignature' -> T[]
       if)
   if)
   
---signature_text2signature:doPart---
do 'Unintended call of text2signature' -> thisTranslate.systemException;
   (if isJava then
       'L' -> S[];
       T[] -> S.append;
       ';'->S.put
    else
       '\nsignature.text2signature: \'' -> puttext;
       T[] -> puttext; '\''->put; newline;
       'is not available for .NET - needs location (use specialSignature instead)!' -> putline;
       (T[], 'UnknownLocation') -> AddClrLocation -> S[]; 
   if)
---byteCode_setMethodDesc:doPart---
do 313->trace(#
             do 'signature:setMethodDesc:'->xT;
                EV[] -> xA; xN;
                chain
             #);
   (if chain[] = none then 
       '\nOBS! setMethodDesc:chain is none' -> putline;
       thisSuperChain -> c[] 
   if);
   (if EV.label 
    // gram.unExpanded then
       EV -> thisMethodDesc;
       chain[] -> c[] (* in case addToChain = true *)
    // gram.mainPart then
       EV -> thisMethodDesc;
       chain[] -> c[] (* in case addToChain = true *)
    else
       (chain[],EV) 
         -> DH.theDesc
         -> (thisMethodDesc,c[])
   if);
   (if thisMethodDesc.label = gram.mainPart then
       (* consider sematt.mainPartDesc *)
       (# D: @ASTindex
       do thisMethodDesc.xOrigin -> D;
          D.slotOrigin -> D;
          D -> thisMethodDesc
       #)
   if);

   (if addToChain then
       c[] -> thisChain[]
    else 
       chain[] -> thisChain[]
   if);
   313->trace(#
             do 'signature:setDesc: ' -> xT; 
                thisMethodDesc[] -> xA; xN;
                'ThisChain: ' -> xT; thisChain
             #);
   
---signature_hasNoEnterAndExitThis:doPart---
do (if not isPtnClassMethod and (NNsig.top = 0) then
       (* no enter arguments *)
       (if not (isMultiValExit -> value) then
           (# NMpos: @integer; CN: ^text
           do (* '\nExitThis:' -> puttext;
              'method: "' -> puttext; method[]->puttext;
              '" XXsig: "'->puttext; XXsig.classname->puttext;
               '"\n   className: "'->puttext;
               *)
              XXsig.classname->CN[]; 
              CN.scanAll
              (# pos: @integer
              do pos+1->pos;
                 (if ch = common.nameManglingCh then
                     pos -> NMpos
                 if)
              #);
              (* '" exitNameSig: "' -> puttext;
              (NMpos+1,CN.length) -> CN.sub -> puttext; '"\n'->puttext;*)
              ((NMpos+1,CN.length) -> CN.sub -> method.equal) -> value
           #)
       if)
   if)
   
---signature_astext:doPart---
do (# addPossibleNameManglingCh:
        (#
        do (if hasNoEnterAndExitThis
               and not( common.exitMethod->method.equal)
               and not( common.doMethod->method.equal)
               and not( common.enterMethod->method.equal)
               then
               common.nameManglingCh -> T.put
           if)
        #)
   do (if isJava then
          (if receiver[] <> NONE then
              (* method call signature *)
              receiver.copy -> T[];
              '/' -> T.put
           else
              &text[] -> T[];
              (if isStatic or isRealStatic then
                  'static ' -> T.append
              if)
          if);
          (if method[] <> none then
              (if true then
                  (if isPtnClassMethod then
                      'new$'-> T.append;
                  if);
                  method.copy -> T.append;
               else
                  method.copy -> T.append;
                  addPossibleNameManglingCh;
              if)
           else
              '\n*** method is none ' -> putline
          if);
          noNsig-> enterSig -> T.append;
          noXsig -> exitSig -> T.append;
       else
          '' -> T[];
          (if isStatic or isRealStatic then
              'static ' -> T.append
          if);
          noXsig -> exitSig -> T.append;
          ' '->T.append;
          (if receiver[] <> none then
              (* method call signature *)
              (receiver[],location[]) -> AddClrLocation  -> T.append;
              '::' -> T.append
          if);
          (if method[] <> none then
              '\'' -> T.put; (* Quote to avoid clash with IL 
                              * reserved words, e.g. add 
                              *)
              (if true then
                  (if isPtnClassMethod then
                      'new$'-> T.append;
                  if);
                  method.copy -> T.append;
               else
                  method.copy -> T.append;
                  addPossibleNameManglingCh;
              if);
              '\'' -> T.put;
           else
              '\n*** method is none ' -> putline
          if);
          noNsig -> enterSig -> T.append
      if);
      187->ctrace(# 
                 do 'Signature:'  ->xT; T[] -> xT;
                    ' location:'->xT;
                    (if location[] = none then
                        'unknown' -> xT
                     else
                        location[] -> xT
                 if)#)
   #)
---signature_addEnter:doPart---      
do 313->trace(#
           do 'addEnter:'->xT; theDesc[] -> xA; xN;
              'external:'->xT; isExternalClass->xB              
             #);
   isExternalClass -> common.inExternalClass; (* a hack *)
   ListSignature -> NNsig[];
   (if thisChain[] = none then
       '\nOBS! signature:addEnter:thisChain is none! ' -> putline;
       thisSuperChain -> thisChain[]
   if);
   (if (theDesc[]<>none) and not (theDesc->thisMethodDesc.equal) then 
       (* just an extra consistency check - might be eliminated *)
       (if not common.switch[188] then
           'addEnter:desc not equal'->putline
   if)if);
   313->trace(#
             do 'addEnter:theDesc(from enter):'->xT;
                theDesc[]->xA; xN;
                'thisMethodDesc( for setDesc): ' -> xT;
                thisMethodDesc[] -> xA;
                (if thisChain[] <> none then thisChain if) 
             #);
   (if isStatic then (* should be origin of thisMethodDesc *)
       (# org: ^ASTindex
       do thisMethodDesc[] -> sematt.descOrigin -> org[];
          (if org.isNull then
              sematt.superObject[]  -> reference -> sig[]
           else
              org[]
                -> reference 
                -> sig[]
          if);
          org[] -> descLocation -> sig.location[];
          (sig[],none) -> NNsig.append;
       #)
   if);     
   (if thisMethodDesc.label = gram.unExpanded then
       '\naddEnter:Unexpanded:'->putline
   if);
   (thisMethodDesc[],gen.thisRegAdr,0,thisChain[],true) 
     -> nScan 
     -> more;
   
   Loop:
     (if more then 
         (nScan.thisEv[],thisMethodDesc[],true,nScan.thisChain[])
           -> getAttSig
           -> NNsig.append;
         313->trace(#do 'Nsig: '->xt; NNsig.asText -> xT #);
         nScan -> more;
         restart Loop
     if);
   false -> common.inExternalClass; (* a hack *)
   313->trace(#do 'enterNsig: '->xT; NNsig.asText -> xT #);

---signature_exitRef:doPart---
do setVoidXsig;
   (if desc[] = none then thisMethodDesc[] -> desc[] if);
   desc[] -> Reference -> XXsig[];
   313->trace(#do 'exitRef: ' -> xT; (desc[],true) -> EH.descName -> xT; #);
   desc[] -> descLocation -> XXsig.location[];
   
---signature_addExit:doPart---   
do addExit:
     (# 
     do 313->trace(#
                  do 'Signature:addExit:'->xT; xN;
                     thisMethodDesc[]->xA; 
                     (if thisChain[] <> none then
                         thisChain
                     if)
                  #);
        
        setVoidXsig;

        (if thisChain[] <> none then
            &ListSignature[] -> XXLsig[];
            (thisMethodDesc[],gen.thisRegAdr,0,thisChain[]) 
              -> xScan 
              -> more;
            (if not more then exitVoid; leave addExit if);
            loop:
              (if more then
                  (xScan.thisEv[]->exitVal[]
                  ,thisMethodDesc[],false,xScan.thisChain[]) 
                    -> getAttSig 
                    -> (XXsig[],aplSig[]);
                  (XXsig[],aplSig[]) -> XXLsig.append;
                  xScan -> more;
                  (if more or XXsig.isList and (XXLsig.top > 0) then 
                      true -> isMultiValExit; 
                      restart loop
                  if);
              if);
            (if isMultiValExit then 
                (* we exit a reference to this object *)
                thisMethodDesc[] -> reference -> XXsig[]
            if)                
         else
            '\n***OBS. thisChain is none '->putline;
            (if (thisMethodDesc[]->theGen.scanXarg->exitVal[]) <> NONE then
                (exitVal[],thisMethodDesc[],false,thisChain[]) 
                  -> theGen.getAttSig 
                  -> (XXsig[],aplSig[]);
        if)if);
        (if (XXLsig.top = 0) then 
            (* exit V where V has no exit list *)
            setVoidXsig;
        if);
        XXsig.elmType -> exitID
     #)
   
---signature_isBETAsubOfExternalClass:dopart---
do (# pref,preName,preDesc: @ASTindex;
      subLevel: @integer;
      EH: @evalHandler;
      class: ^text;
      extKind: @integer
   do desc.son -> pref;
      (if pref.label = gram.prefix then
          pref.son -> preName;
          313 -> ctrace(#
                       do 'isBetaSubOfExternalClass:super:' -> xT;
                          preName.gettext -> xT
                       #);
          preName -> sematt.descChain -> (preDesc,subLevel);
          subLevel > 0 -> value;
      if);
      (none,(desc[],true)->EH.descName,desc[],0) 
        -> sematt.cProcDecoder 
        -> (class[],extKind);
      313->trace(#
                do 'isBetaSub: ' -> xT; extKind -> xI;
                   class[] -> xT; xN;
                #);
      (class[] = none) -> value
   #)
 
---signature_getExternalClassName:doPart---
do (* We should optimize such that descname is only called when
    * no classname is specified in the externalClass
    *)
   (# C: ^text
   do (none,(desc[],false)->EH.descName->c[](*hack*),desc[],0) 
        -> sematt.cProcDecoder 
        -> (class[],extKind);
      (if class[] = none then c[] -> class[] if)
   #)
---signature_isExternalString:dopart--
do (# N: ^text
   do (if (desc -> sematt.descKind)= sematt.externalClassKind then
          desc[] -> theGen.getExternalClassname -> N[];
          (if false then
              'isExternalString: ' ->puttext; N[] -> putline;
          if);
          (if isJava then
              ('java.lang.String' -> N.equal)
              or
              ('java/lang/String' -> N.equal)
                -> value
           else
              '[mscorlib]System.String' -> N.equal -> value
          if)
      if);
      (*(if value then ' isString'->putline else ' false'->putline if)*)
   #)
   
