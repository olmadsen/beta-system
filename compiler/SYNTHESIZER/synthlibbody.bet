ORIGIN 'synthlib';
LIB_ITEM 'betacodegen';
INCLUDE 'evlib';
INCLUDE '../GENERATOR/machine';
INCLUDE 'auxlib';
INCLUDE 'signature';
---SynthesizerBodyLib:attributes---
com:
  (# no: @integer; A: ^mch.address; T: @text
  enter(no,A[])
  do INNER;
     no -> T.putint; ' ' -> T.put;
     (if true then
         A.display -> T.append
      else
         ' :receiverType:"'->T.append;
         (if A.receiverType[] <> none then A.receiverType[] -> T.append if);
         '" :fieldName:' -> T.append;
         (if A.fieldName[] <> none then A.fieldName[] -> T.append if);
         '" :fieldType:'->T.append;
         (if A.fieldType[] <> none then A.fieldType[] -> T.append if);
         '"'->T.put
     if);
     T -> mch.comment;
         (*302 ->trace(#do T[] -> xT #)*)
  #); 

---SetSuperDesc:doPart---
do (# desc: @ASTindex; 
      D: ^ASTindex;
      noPrefix:
        (# ch: @char; lab: @integer; noPref: @boolean
        enter(ch,Lab)
        do (if desc.isNull or (desc.label <> lab) then	
               '\nFatal error "addOriginOff": Desc is wrong,'
                 ->bugstream.putText;
               ch->bugstream.put; pn->bugstream.putint; 
               bugstream.newline;
               (destA.bAdr.LocalDesc[],bugstream[],8)->thePP;
               true -> noPref
           if)
        exit noPref
        #);
   do
      (if destA.bAdr.LocalDesc[] = NONE then
          'Fatal error: LocalDesc is NONE'->bugstream.putline;
          0->thisA.addOff->A[]
       else
          destA.bAdr.LocalDesc->desc;
          (if desc.label = gram.mainPart then
              desc[] -> sematt.mainPartDesc -> D[];
              D -> desc
          if);
          L:
            (for i: pn repeat 
                 desc.son->desc; 
                 (if ('b',gram.prefix)-> noPrefix then
                     destA.bAdr.LocalDesc->desc; (* arbitrary choice *)
                     leave L
                 if);
                 desc.son->desc; 
                 desc->sematt.descrip-> desc;
            for);
          (if switch181 then
              thisA[] -> A[]
           else
              thisA.copy->A[]
          if);
          desc[]->A.bAdr.localDesc[]
   if)#)
   
--GenLocalAdr:descriptor--
(#
do (&gen.thisRegAdr,ad[],isOrigin,chain[])->GenAdr->A[]
#)
--GenAdr:descriptor---
(* think about deRef in old version *)
(# dcl,descRef,rDen,EV,N1: @ASTindex; N,spec,localDesc,D: ^ASTindex;
   EH: @EvalHandler;  V: ^EH.EvVal;
   descKind,size,
   baseOff: @integer; (* 0 if item, compHeadSize if component *)
   indexReg: ^mch.dataRegOperand;
   (********************************************************
    XvarAddress: mch.address
    (# xName: ^text;
    off: @integer;
    addOff::<(# do off+v->off #);
    putOp::<
    (#do xName->mch.BC.putT; '+'->mch.BC.putC; off->mch.BC.putI #);
    #);
    *)
   isData:
     (# N,desc: @ASTindex; isData: @boolean;(* XA: ^XvarAddress*)
     enter((*N[],*)desc)
     do (if (desc.label = gram.objectDescriptor)
            and 
            (((desc->sematt.descKInd) = semAtt.dataKInd) -> isData) then
            (* &XvarAddress[]->XA[];
             N.getText->XA.xName[]*)

        if)
     exit isData
     #);
   isD: @boolean;
   
   aCom: com(#do '!genAdr'->T #);
   rCom: com(#do '!remAdr'->T #);
   doGoOrigin:
     (# toOrgReg: @boolean; orgDesc: @ASTindex; on: @integer;
        D: ^ASTindex;
        doCom: com
          (#
          do '!doGoOrigin' -> T;
          #);
        sig: @theGen.signature;
        
     enter toOrgReg
     do (if switch182 then
            (if not A.noFieldInit then
                'doGoOrigin:fieldInit' -> mch.comment;
                (thisDesc[] 
                  -> theGen.fieldSignature).asText
                  -> A.receiverType[];
                'this_' -> A.fieldName[];
                (A.bAdr.localDesc[] 
                  -> theGen.fieldSignature).asText
                  -> A.fieldType[];
                false -> A.noFieldInit;
             else
                'doGoOrigin:noFieldInit' -> mch.comment;
                (* we may have been called recursively,
                 * e.g. in case final below in gram.remote
                 * here we switch as in goOrigin below
                 *)

                A.fieldType[] -> A.receiverType[];
                (A.bAdr.localDesc[] 
                  -> sematt.descOrigin
                  -> theGen.fieldSignature).asText
                  -> A.fieldType[];
                
                302->trace(#
                          do 'do:GoOrigin:fieldSignature: ' -> xT;
                             A.bAdr.localDesc[]  -> xA
                          #);
            if)
        if);
        (if (ad.on > 0) or inEnterDoExitMethod then 
            (if switch182 (* bytecode *) then
                ad.on -> on;
                (if inEnterDoExitMethod and not A.noFieldInit then 
                    on + 1 -> on 
                if);
                (if toOrgReg then
                    (1,A[]) -> doCom;
                    (A[],A.copy,on,false) -> GoOrigin -> A[];
                 else      
                    (2,A[]) -> doCom;
                    (A[],A.copy,on,toOrgReg) -> GoOrigin -> A[]
                if)
             else
                (A[],A.copy,ad.on,toOrgReg) -> GoOrigin -> A[] 
            if)
        if);
        302->trace(#
                  do 'doGoOrigin:after:' -> xT; A.bAdr.localDesc[] -> xA
                  #);
        (* A.fieldType = type of object referred by A *)
        (if switch182 then
            (if ad.pn > 0 then
                (A[],ad.pn,A[]) -> SetSuperDesc -> A[];
                (A.bAdr.localDesc[] -> theGen.fieldSignature).asText 
                  -> A.fieldType[];
                (if A.fieldType[] = none then
                    'doGoOrigin:'->putline;
                    'goOrigin' -> A.fieldName[]
            if)if);
        if);
        (* A denotes the object containing the field - ad - 
         * which address is being computed;
         * fieldClass and fieldType identifies the class
         * of the object conatining the field
         *)
        313 -> trace(#
                    do 'doGoOrigin:goPn: ' -> xT; ad[] -> xA;
                       ' pn:'->xT; ad.pn -> xI;
                       ' receiverType:' -> xT; A.receiverType[] -> xT;
                       ' fieldType: ' -> xT;
                       A.fieldType[] -> xT; xN;
                       A.bAdr.localDesc[] -> xA;
                    #);
        (3,A[]) -> doCom;
     #);
   isSimple: @boolean; isVirt,MN,access: @integer;
   nD: ^sematt.AttDesc;
   (* A is baseAdr *)
do (if stest then
       302->ctrace(#
                  do 'GenAdr: ad='->xT; ad[]->xA;
                     ' isOrigin='->xT; isOrigin->xB; xN;
                     ' A='->xT; A.display->xT; 
                     mch.dumpreg 
                  #)
   if);
   (ad[],chain[]) -> sematt.AttDesc -> nD[];
   (if ad.label
    // gram.nameApl then
       (if stest then
           302->ctrace
           (#do'GenAdr:nameApl: '->xT; ad[]->xA; ' on:'->xT; ad.on->xI; xN;
              nD.display;
              mch.dumpreg
           #)
       if);
       (if switch182 then
           (if true then
               nD.desc[] -> D[]; 
            else
               nD.dclDesc[] -> D[]; 
           if);
           D -> descRef
        else
           (chain[],ad) -> DH.theDesc -> (descRef,MN,chain[],isVirt);
       if);
       ad.dclRef->dcl;
       
       (* A refers to the start of the object that has 'ad' as attribute *)
       (if isOrigin then
           (* origin of ad is computed. 'ad' is a pattern *)
           dcl.sort->dcl;
           L:
             (if dcl.label = gram.finalDecl then
                 (* Consider  T: (#  X::B do ...; X; ... #).
                  * Note: the case where
                  *    B::C;
                  *    C::D;
                  *    etc
                  * is not tested
                  *)
                 'genAdr:nameApl:final1' -> mch.comment;
                 doGoOrigin;
                 dcl.son->dcl; dcl.brother->dcl; (* dcl = B *)
                 (if stest then
                     302->ctrace
                     (#
                     do 'GenAdr:isOrigin:Final:on='->xT; 
                        dcl.on->xI; dcl[]->xA;
                        A.bAdr.localDesc[]->xA
                 #)if);
                 (* chain starts with the "real" desc for X, i.e. desc for B;
                  * the chain to be used as argument for GenOrgAdr must
                  * be one corresponding to the descriptor T above;
                  * since we just need to "add" the origin for T, we can
                  * just pass a chain consisting of the descriptor for T
                  *)
                 (if stest then
                     302->ctrace(#
                                do 'genAdr:isOrigin:final:A='->xT; 
                                   A.display->xT 
                                #)
                 if);
                 (if dcl.label <> gram.objectDescriptor then
                     (# dclSort: @ASTindex
                     do dcl -> sematt.getSort -> dclSort;
                        (if dclSort.label
                         // gram.virtualDecl // gram.bindingDecl then
                            (if stest then
                                302 -> trace(#
                                            do 'GenAdrOrg:Final:virtual'->xT;
                                               dcl[]->xA; dclSort[] -> xA
                            #)if);
                            leave L
                 if)#)if);
                 dcl[]->sematt.encDesc->localDesc[];
                 (if switch182 (*and A.noFieldInit*) then
                     'origin' -> A.fieldName[];
                     'genAdr:nameApl:final2' -> mch.comment;
                     true -> A.noFieldInit;
                 if);
                 (A[],none,dcl[],localDesc->DH.newSingle)
                   -> &GenOrgAdrToOrgReg
                   -> A[];
                 'genAdr:nameApl:final3' -> mch.comment;
                 (if stest then
                     302 -> trace
                     (#
                     do 'genAdr:isOrigin:Final:end:A='->xT; A.display->xT 
                 #)if)
              else
                 toOrgReg -> doGoOrigin
             if);
           '!genAdr:loadorigin2' -> mch.comment;           

        else
           doGoOrigin;
           
           302 -> trace(#do 'adr:1'->xT; A.display->xT #);
           (0,A[]) -> aCom;  

           
           (if switch182 then
               (# RA: @mch.regAdr; dclName,sort: @ASTindex
               do dcl.off -> RA.off;
                  dcl.sort -> sort;
                  (if sort.label = gram.forImp then
                      'for_inx_' -> RA.fieldName[];
                      dcl.off -> RA.fieldName.putint
                   else
                      dcl.getText -> RA.fieldName[]
                  if);
                  302->trace(#
                            do 'genAdr:fieldName: ' -> xT;
                               dcl[] -> xA; 
                               dcl.gettext -> xT;
                               A.display -> xT; xN;
                               descRef[] -> xA; xN;
                               nD.display
                            #);
                  (1,RA[]) -> aCom;  
                  A.fieldType[] -> RA.receiverType[];
                  (* why not descName below:??*)
                  (if sort.label = gram.repetitionDecl then
                      (* do we need an arrayFieldSignature?*)
                      (descRef[] -> theGen.mkArraySig).asText
                        -> RA.fieldType[];
                   else
                      (nD.dclDesc[](*descRef[]*) -> theGen.fieldSignature).asText 
                        -> RA.fieldType[];
                  if);
                  
                  (if (ad.on > 0) or inEnterDoExitMethod then 
                      true -> RA.isField 
                   else
                      false -> RA.isField
                  if);
                  (* strange that the above if does not work,
                   * but the next one does
                   *)
                  A.isField -> RA.isField;
                  (* A.descRef  : object containing field referered by A;
                   * A.fieldType: type of field referred by A *
                   *)
                  (2,RA[]) -> aCom;
                  RA[] -> A[]
               #)
            else
               dcl.off -> A.addOff -> A[];               
           if);           

           descRef[] -> A.bAdr.localDesc[];
           (if (dcl.access->A.access) = common.direct then 
               descRef.size -> A.Size;
               descRef[] -> sematt.isSigned -> A.signed;
            else 
               (* includes for-index*) 4->A.size
           if);        
       if);
    // gram.remote then(* R.X *)
       A.bAdr.localDesc[] -> localDesc[];
       ad.son -> rDen; 
       302 -> trace(#
                   do 'genAdr:remote:rDen:'->xT; rDen[] ->xA; xN; 
                      'localDesc:'->xT; A.bAdr.localDesc[]->xA; xN;
                      A.display->xT 
                   #);
       (1,A[]) -> rCom;
       (A[],rDen[],false,chain[]) -> GenAdr -> A[];
       
       302->trace(#
                 do 'genAdr:remote:A:rDen:'->xT; rDen[] ->xA; Xn; 
                    'localDesc:'->xT; A.bAdr.localDesc[] -> xA; xN;
                    A.display->xT ;
                 #);
       (2,A[]) -> rCom;
       (if switch182 then
           (# attD: @sematt.AttDesc;
              D,aD: @ASTindex; DN,aDN: ^text; descKind: @integer;
              T: @text
           do (3,A[]) -> rCom;
              rDen -> D;
              L:
                (if D.label 
                 // gram.remote then 
                    302->trace(#
                              do 'remote!:'->xT; D[] -> xA
                              #);
                    D.son -> D;
                    (* must also cover other cases like indexed *)

                    302->trace(#
                              do 'remote?:'->xT; D[] -> xA
                              #);
                    D.brother -> D;
                    D.descRef -> D;
                    302->trace(#
                              do 'remote??:'->xT; D[] -> xA
                              #);
                    
                 // gram.indexed then
                    302->trace(#
                              do 'indexed?:'->xT; D[] -> xA
                              #);
                    
                    D.son -> D;
                    302->trace(#
                              do 'indexed??:'->xT; D[] -> xA
                              #);
                    
                    restart L 
                 // gram.thisObject then
                    302->trace(#
                              do 'thisObject?:'->xT; D[] -> xA
                              #);
                    
                    D.son -> D;
                    302->trace(#
                              do 'thisObject??:'->xT; D[] -> xA;
                                 ' on:'->xT; D.onForThis -> xI
                              #);
                    (if true then
                        (# Dx: ^ASTindex
                        do thisDesc[] -> Dx[];
                           (for i: D.onForThis-1 repeat
                                Dx[] -> sematt.descOrigin -> Dx[]
                           for);
                           Dx -> D;
                           302->trace(#do D[]-> xA #)
                        #)
                     else
                        restart L   
                    if)
                 // gram.computedRemote then
                    (# xchain: ^DH.superChain;
                       remEv,N,ref,receiverDesc: ^ASTindex;
                    do 302->trace(#
                                 do 'computedRemote?:'->xT; xN; D[] -> xA
                                 #);  
                       (if true then
                           D.son -> D;
                           D.brother -> D;
                           D.descRef -> D;
                        else
                           (D[],DH[],chain[])
                             -> sematt.chkComputedEval
                             -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
                           receiverDesc -> D;
                       if);
                       302->trace(#
                                 do 'computedRemote??:'->xT; xN; D[] -> xA
                                 #);
                    #)
                 else
                    D.descRef -> D;
                if);
              302 -> trace(#do 'remote:X:desc:'->xT; xN; D[] -> xA #);
              (if D.label 
               // gram.objectDescriptor then
                  (* superflous - is done below? *)
                  D[] -> theGen.mkSignature -> DN[]
               // gram.virtualDecl // gram.bindingDecl // gram.finalDecl then
                  (rDen[],thisSuperChain) -> attD;
                  313->trace(#do 'loadQref:'->xT; attD.display #);
                  (thisDesc[],rDen[]) -> GetActualDesc -> (aD,descKind);
                  aD[] -> theGen.mkSignature -> aDN[];
                  D.son -> D; D.brother -> D;
                  (* OK? thisDesc? ???*)
                  (thisDesc[],D[]) -> GetActualDesc -> (D,descKind);
              if);
              D[] -> theGen.mkSignature -> DN[];
              (* A.descName[] = name of descriptor where rDen is
               *                an attribute.
               * If ad = 'S.foo' then rDen = 'S' and if
               *    'fisk: (# ... S: ... #)'
               * then A.descName[] = 'fisk'
               *)
              302->trace(#
                        do 'basic: ' -> xT; DN[] -> xT;
                           ' actual: ' -> xT; aDN[] -> xT
                        #);
              (*true -> A.isField;*)
              302 -> trace(#
                          do 'genadr:remote!!!:A:' -> xT;
                             A.display->xT
                          #);
              (A[],DN[],aDN[]) -> mch.loadRef; (* DN is used as fieldType;
                                                * perhaps we should eliminate
                                                * DN and just use fieldType
                                                *)
              'remote:3'->mch.comment;
           #)
       if);
       (if rDen.label = gram.nameApl then
           rDen.descRef -> isData -> isD;
       if);
       rDen -> semAtt.GetNameAndKind -> (N[],spec[]);	

       rDen.brother->rDen; rDen.dclRef->dcl; 
       302->trace(#
                 do 'genAdr:remote:rDen:'->xT; rDen[] -> xA; 
                    'pn:'->xT; rDen.pn->xI
                 #);
       (if spec.label // gram.staticComponent // gram.dynamicComponent then
           common.compHeadSize*4 -> baseOff
       if);
       (* A denotes R *)
       (if isOrigin then 'isOrigin'->mch.comment;
           (if switch182 then
               (if baseOff <> 0 then
                   '***genAdr:remote:missing baseOff->A.addOff'
                     -> mch.comment
               if)
            else
               baseOff->A.addOff->A[];
           if);
           (if rDen.pn > 0 then 
               (A[],rDen.pn,A[]) -> SetSuperDesc -> A[] 
           if);
           dcl.sort->dcl;
           L:
             (if dcl.label = gram.finalDecl then
                 (* R.X where  e.g. R: @T; T: (#  X::B #).
                  * Note: the case where
                  *    B::C;
                  *    C::D;
                  *    etc
                  * is not tested
                  *)
                 '!isOrg:final1' -> mch.comment;
                 dcl.son->dcl; dcl.brother->dcl; (* dcl = B *)
                 302->trace(#do 'GenAdrOrg:Final1:'->xT; dcl[]->xA #);
                 (* B may be declared as one of
                  *    B: (# ... #)
                  *    B:< ...
                  *)
                 (if dcl.label <> gram.objectdescriptor then
                     '!isOrg:final2a' -> mch.comment;
                     (# dclSort: @ASTindex
                     do dcl -> sematt.getSort -> dclSort;
                        (if dclSort.label
                         // gram.virtualDecl // gram.bindingDecl then
                            302 -> trace(#do 'GenAdrOrg:Final:virtual'->xT; 
                                           dcl[]->xA; dclSort[] -> xA
                                        #);
                            '!isOrg:final3:leave' -> mch.comment;
                            (if not switch182 then leave L if)
                     if)#)
                  else
                     '!isOrg:final2b' -> mch.comment;
                 if);
                 302->trace(#do 'GenAdrOrg:Final2: '->xT; dcl[]->xA #);
                 dcl[] -> sematt.encDesc -> localDesc[];
                 'isOrg:final4' -> mch.comment;
                 true -> A.noFieldInit;
                 (A[],none,dcl[],localDesc->DH.newSingle) -> GenOrgAdr -> A[];
                 302->trace(#
                           do 'genAdr:remoteWWW:A:'->xT; A.display->xT; xN;
                              A.bAdr.localDesc[] -> xA
                           #);

                 'isOrg:final5' -> mch.comment;
             if);
        else '**not origin'->mch.comment;
           (chain[],ad)->DH.theDesc->(descRef,MN,chain[],isVirt);
           (if ((dcl.access->access) = common.direct) then                
               descRef.size->size;
               (* The following code is not used!
                * It is for the case
                *    R: [..] @ T; T: (# ... X: @S; ... #)
                * where the repetition was allocated inline.
                * (It is now allocated off-line, since this makes
                * it a lot easier to handle R[e][] -> S[]; v->R.extend.)
                * We have:
                * R[e].X
                * X.dcl.access = common.direct
                * R[e] is inxRegAdr = (ai, di, s, off)
                *  adr(R[e]) = ai + di*s +off
                * In general dcl.off cannot be added to off
                * and dcl.size cannot replace size of A
                * Note: due to a register overflow error in FEJL/list2list,
                * toReg2 has been replaced by toReg3 below, but this
                * has not been tested very much.
                * (if (A.access = common.direct) and
                *      A.isInxRegAdr and (A.size <> size) then 
                *     (# A1: @mch.RegAdr
                *     do A.toReg3->A1.reg;
                *        A.bAdr.localDesc[]->A1.bAdr.localDesc[];
                *        A1[]->A[];
                *     #)if)
                *)
            else 
               4->size
           if);

           (if stest then
               302 -> cTrace(# D: @ASTindex 
                            do 'genAdr:remote: isData= '->xT;
                               isD->xB; 
                               ' indirect='->xT; A.access=common.varInd->xB;xN;
                               A.display->xT
           #)if);
           (* we must handle S.c where
            *    S: ^myData; myData: data(# c: .... #)
            * A is address of S;
            * aReg in A is the addres of a real object
            * or A.isNotObjRef = true
            *    A.addOff 
            * below will load the address of
            * a myData object to a register which will then
            * be referring a data-object.
            * Note: S: @myData does not have this problem
            * since the offset is just added
            *)
           isD and (A.access <> common.direct) -> isD;
           (if switch182 then
               (# aR: @mch.RegAdr;
                  T: @text;
                  sort: @ASTindex;
               do 0 -> aR.ONlevel; 
                  true -> aR.isField ;
                  dcl.off+baseOff -> aR.off;
                  dcl.getText -> aR.fieldName[];
                  302 -> trace(#
                              do 'Genadr:remote:setSuper:'
                                 'before:isMainPart: ' -> xT;
                                 A.bAdr.localDesc.label = gram.mainPart -> xB;
                                 ' pn:'->xT; rDen.pn -> xI;
                                 dcl[] -> xA; dcl.gettext -> xt; xN;
                                 A.bAdr.localDesc[] -> xA;
                              #);
                  (if rDen.pn > 0 then 
                      (A[],rDen.pn,A[]) -> SetSuperDesc -> A[]; 
                  if);
                  302->trace(#
                            do 'GenAdr:SetSuper:after:isMainPart:' -> xT;
                               A.bAdr.localDesc.label = gram.mainPart -> xB;
                               a.badr.localdesc.label -> xI; xN;
                               A.bAdr.localDesc[] -> xA;
                            #);
                  (A.bAdr.localDesc[] -> theGen.fieldSignature).asText 
                    -> aR.receiverType[];

                  aR[] -> A[];
                  dcl.sort -> sort;
                  (if sort.label = gram.repetitionDecl then
                      (descRef[] -> theGen.mkArraySig).asText
                        -> A.fieldType[];
                   else
                      (nD.dclDesc[](*descRef[]*)
                        -> theGen.fieldSignature).asText 
                        -> A.fieldType[];
                  if);
                  '!loadField2: ' -> T; A.display->T.append;
                  T -> mch.comment;
                  311->trace(#
                            do 'genAdr.remote.loadField: ' -> xT;
                               nD.display
                            #);
               #)
            else
               dcl.off+baseOff -> A.addOff -> A[];           
           if);
           isD -> A.isNotObjRef;
           size -> A.Size;
           descRef[] -> sematt.isSigned -> A.signed;
           descRef[] -> A.bAdr.localDesc[];
           access -> A.access
       if)
    // gram.indexed then
       (if switch182 then           
           (# Ax: ^mch.address; T: @text; sig: ^theGen.type;
              AR: @mch.inxRegAdr
           do
              ad.son->rDen; rDen.brother->EV; 
              (* load array reference: *)
              '!loadArray1'->mch.comment;
              Rden -> SemAtt.getName -> N1; N1.dclRef -> dcl;
              (A.copy,rDen[],false,chain[]) -> GenAdr -> Ax[];
              Ax.bAdr.localDesc[]->localDesc[]
                -> theGen.mkArraySig
                -> sig[]; 
              (*   '! loadArry2: ' -> T;
               (localDesc[],true) -> EH.descName -> T.append; 
               ' descName:' -> T.append;
               Ax.descName[] -> T.append;*)
              T -> mch.comment;
              (* A.descName[] = descriptor where rDen is declared *)
              (Ax[],sig.asText,none) -> mch.loadRef;
              '!loadIndex1'->mch.comment;
              (A.copy,EV[],false,chain[])->&EH.ExpEval->V[]; 
              '!loadIndex2'->mch.comment; 
              -1 -> V.cstAdd -> V[];
              V.pushVal -> V[];
              (if true then
                  localDesc[]
                    -> theGen.mkSignature 
                    -> AR.fieldType[]; (* array element type *)
               else
                  (localDesc[]-> theGen.valueSignature).astext
                    -> AR.fieldType[]; (* array element type *)
              if);
              'index' -> AR.fieldName[];
              (*    '! inxReg: descName: ' -> T; AR.descName[] -> T.append;
               '! fieldType:' -> T; AR.fieldType[] -> T.append;
               T -> mch.comment;*)
              (chain[],ad)->DH.theDesc->(descRef,MN,chain[],isVirt);
              descRef[]->AR.bAdr.localDesc[];
              (if dcl.access
               // common.direct then
                  (if (descRef->sematt.descKind) = sematt.standardKind then
                      common.direct -> AR.access;
                   else
                      common.cstInd -> AR.access;
                  if)
               // common.varInd then
                  (* ref rep *)
                  common.varInd -> AR.access;
               else
                  common.varInd -> AR.access
              if);
              AR[] -> A[];
           #)
        else
           (if not A.frozenReg then
               (* this will happen when used as a super-pattern as in
                *    R[e].P(# ... #)
                * It is assumed that even if A is frozen, there will
                * be enough registers to compute R[e].P. If, however,
                * 'R[e]' is very complicated we may ran out of registers
                *)
               (*312->trace(#do '\nObs! Index-baseadr NOT frozen'->T #);*)
               A.freezeReg;
           if);
           A.bAdr.localDesc[]->localDesc[]; 
           (* compute @@R[inx] relative to localDesc ?? *)
           ad.son->rDen; rDen.brother->EV; 
           (A.copy,EV[],false,chain[])->&EH.ExpEval->V[]; 
           V.toDataReg->indexReg[]; (*V.release; !!*)
           Rden -> SemAtt.getName -> N1; N1.dclRef -> dcl;
           (A.copy,rDen[],false,chain[])->&GenAdr->A[];
           (chain[],ad)->DH.theDesc->(descRef,MN,chain[],isVirt);
           (if stest then
               179->ctrace
               (#
               do 'Indexed:'->xT; dcl.access->xI; dcl[]->xA; 
                  A.display->xT; mch.dumpreg
           #)if);
           (if (dcl.access->A.access) 
            // common.direct then
               (* S: [...] @ T where T is simple or non-virtual*)
               descRef.size->size;
               (if not ((descRef->sematt.descKind) = sematt.standardKind->isSimple)
                   then 
                   false->isSimple;
                   4->size;
                   common.cstInd->A.access;
                   (*
                    * ((size + 7), 7->TOS'%not') ->TOS'%and' -> size
                    *)
                   (* size must be 8 byte aligned *)
               if);
               (* component or item? *)
               (* (# spec: @ASTindex
                * do dcl.sort->spec; ( *sort* ) spec.son->spec; ( * nameList* )
                *    spec.brother->spec; ( * data spec or rep * ) spec.brother->spec;
                *    (if spec.label = gram.staticComponent then
                *    common.compHeadSize*4 + size -> size
                * if)#)
                *)
            // common.varInd then
               (* reference repetition *)
               4->size ;
               true->isSimple
            else (*// common.cstInd then  S: [...] @T T slot or virtual *)
               4->size
           if);
           (indexReg,isSimple,size)->A.index->A[];
           descRef[]->A.bAdr.localDesc[];
       if)
    // gram.thisObject then (* always this(P) *)
       (# thisObjDesc: @ASTindex; dk: @integer
       do ad.son->rDen; 
          (* 'on' is adjusted during checking to avoid (for ...for) etc.
           * Regarding onForThis, see comment in isEnclosing
           *)
          'synthlibBody:this1'->mch.comment;
          (# T: ^text do A.display->T[]; T -> mch.comment; #);
          (if switch182 then
              (if A.noFieldInit then
                  '\nOBS!synthlibbody:this:noFieldInit:FIXME'->putline
              if);
              301->trace(#
                        do 'thisObject: ON:'->xT; rDen.onForThis->xI; xN;
                           thisDesc[] -> xA; xN;
                           'A:'->xT; A.display->xT
                        #);
              (thisDesc[] -> theGen.fieldSignature).asText 
                -> A.receiverType[];
              
              (A.bAdr.localDesc[] 
                -> theGen.fieldSignature).asText
                -> A.fieldType[];
              'this_' -> A.fieldName[];
              false -> A.noFieldInit;
              301 -> trace(#
                          do 'thisObject:X:' -> xT; A.display -> xT 
                          #)
          if);
          (if rDen.onForThis > 1 then 
              'synthlibBody:this2'->mch.comment;
              (if switch182 then 
                  (A[],A.copy,rDen.onForThis-1, false) -> GoOrigin -> A[]
               else
                  (A[],A.copy,rDen.onForThis-1,toOrgReg) -> GoOrigin -> A[]
              if);
              302 -> trace(# F: @ASTindex;
                          do 'thisObjectY:'->xT; A.display->xT; xN;
                             A.bAdr.localDesc[] -> xA; xN;
                             A.bAdr.localDesc.father -> F; F[] -> xA
                          #);
              'origin' -> A.fieldName[];
              false -> A.isOrigin; (* although fieldName = 'origin'
                                    * we do not technically treat 
                                    * A as an origin adr; it also
                                    * shows that the special treatment
                                    * of loadOrigin properly could
                                    * be handled by just using
                                    * 'origin' as the fieldName
                                    *)
              (if switch182 then
                  'synthlibBody:this3'->mch.comment;
                  (* consider:
                   *   B: A(# do ... this(A) ... #)
                   * here we ge the dec of A bewlo was fiedltype;
                   * we should get B; so probably we should follow
                   * origin A.onForThis-1 number of times;
                   * see alos cas gram.thisObject in gram.remote above
                   *)
                  (thisDesc[],rDen[]) -> GetActualDesc -> (thisObjDesc,dk);
                  (thisObjDesc[]->theGen.fieldSignature).asText
                    -> A.fieldType[];
                  thisObjDesc[] -> A.bAdr.localDesc[]
              if)              
          if);
          
          302->trace(#
                    do 'genAdr:thisObject:'->xT;
                       A.display->xT
                    #)
          (* rDen.on > 0 always !*)
       #)
    // gram.computedRemote then
       (* ad = ( <evaluations> ).<nameApl> *)
       (# EV,N,descRef: @ASTindex; 
          EVdesc,remEv,Nx,ref: ^ASTindex;
          EH: @EvalHandler; isVirt: @integer;
          LV,V: ^EH.EvVal;
          xchain: ^DH.superChain
       do (if stest then
              301 ->ctrace(#
                          do 'genAdr:computedRemote: ad='->xT; ad[]->xA; 
                             ' A= '->xT; A.display->xT; mch.dumpreg 
          #)if);
          (if not A.frozenReg then 
              (* this will happen when used as a super-pattern as in
               *    (foo).P(# ... #)
               * It is assumed that even if A is frozen, there will
               * be enough registers to compute (foo).P. If, however,
               * 'foo' is very complicated we may ran out of registers
               *)
              (*193->trace(#do '\nObs! CompRem-baseadr NOT frozen'->T #);*)
              A.freezeReg;
              (* when do we unfreeze A? For now we don't bother, since
               * we rely on the new backend
               *)
          if);
          ad.son -> EV; EV.brother -> N;
              (*306->trace(#do ad[] -> A; N[] -> A #);(*!*)
          L: EV->scanList(#do currentNode -> EV; leave L #);
          (A.copy,EV[],true,chain[]) -> EH.expEval -> V[];
          (if stest then
              301 ->ctrace(#
                          do 'GenAdr:computedRemote:V:'->xH; 
                             V.display; xN;
                             mch.dumpreg 
          #)if);
          
          (if switch181 then
              V.getRefAdr -> A[]
           else
              V.getRefEval -> V[];           
              (if stest then
                  301 ->ctrace(#
                              do 'GenAdr:computedRemote:B:'->xH;
                                 V.display;mch.dumpreg
                              #)
              if);
              V.theAdr -> A[];
          if);
          (* A the address of EV in (EV).f *)
          (if stest then
              301->ctrace(#
                         do 'GenAdr:computedRemote:A:'->xH;
                            A.display->xT;
                            mch.dumpreg 
          #)if);
          (if switch182 then
              301->trace(#
                        do 'GenAdr:computedRemote:D:'->xH;
                           EV[] -> xA; xN;
                           EV.sonRef -> xA; xN;
                           (EV.sonRef).sonRef->xA;
                        #);
              (if true then
                  (ad[],DH[],chain[]) 
                    -> sematt.chkComputedEval 
                    -> (remEv[],Nx[],ref[],EVDesc[],xchain[])
               else
                  (chain[],EV(*(EV.sonRef).son*)) 
                    -> DH.theDesc 
                    -> (EVdesc,MN,xchain[],isVirt);
              if);
              301->trace(#
                        do 'GenAdr:computedRemote:EV:'->xH;
                           EV[] -> xA; xN;
                           'EVdesc:'->xT; EVdesc[] -> xA
                        #);
              (*(EVdesc[],true) -> EH.descName -> A.descName[];*)
              (EVdesc[]-> theGen.fieldSignature).asText 
                -> A.receiverType[];
              false -> A.noTmp; A.isCallReg;
          if);
          N.dclRef->dcl; 
          (if switch182 then
              true -> A.isField;
              dcl.getText -> A.fieldName[];
          if);
          (if isOrigin then 
              4->A.size; 
              (* switch182:bytecode: cases:
               * (&foo[]).go - &foo[] is loaded
               * (R[]).go    - R[] is not loaded - fix this 
               * (foo).go    - load exit elem of foo - fix?
               *             - also (EV.sonRef).son below
               *               and in evbody:mkBytecodeCall must be fixed
               *               to handle this
               *)
              EVdesc[] -> A.bAdr.localDesc[]; (*???*)
           else
              N.dclRef->dcl; 
              (if switch182 then
                  true -> A.isField;
                  dcl.getText -> A.fieldName[];
               else
                  dcl.off -> A.addOff -> A[];
              if);
              (chain[],ad) -> DH.theDesc -> (descRef,MN,chain[],isVirt);
              descRef[] -> A.bAdr.localDesc[];
              (if switch182 then
                  (nD.dclDesc[] (*descRef[]*)
                    -> theGen.fieldSignature).asText 
                    -> A.fieldType[];
                  (*  (A[],&mch.adrRegOperand[]) -> mch.ldVal*)
              if);
              (if (dcl.access->A.access) = common.direct then
                  descRef.size -> A.Size
               else 4->A.size
          if)if);
          'genAdr:computedRemote:D' -> mch.comment;
       #)
   if);
   (if stest then
       302 -> ctrace(#do 'GenAdr:exit: '->xT; ad[]->xA; xN; A.display->xT;
                       mch.dumpreg
                    #)
   if)
#)
--GenOrgAdr:descriptor--
(* enter(desc,ES)
 * where desc is the descriptor containing ES
 *)
(#
do (if stest then 
       302->ctrace(#do 'GenOrgAdr:'->xT; es[]->xA #)
   if);
   (if ES.label // gram.objectDescriptor // gram.unExpanded then
       baseAdr.copy->A[]
    else 
       (baseAdr.copy,ES[],true,chain[])->genAdr->A[]
   if);
#)
--GenOrgAdrToOrgReg:descriptor--
(* enter(desc,ES)
 * where desc is the descriptor containing ES
 *)
(# originDesc: ^ASTindex ;
   gA: @genAdr
do (if stest then
       302->ctrace(#do 'GenOrg:'->xT; es[]->xA; desc[]->xA #)
   if);
   (if ES.label // gram.objectDescriptor // gram.unExpanded then
       baseAdr.copy->A[];
       (if switch182 and not A.noFieldInit (* perhaps just a hack! *)then
           true -> A.isRef;
           'this' -> A.fieldName[];
           (A[],none) -> mch.ldVal
       if)
    else 
       true -> gA.toOrgReg; (* hack *)
       (baseAdr[],ES[],true,chain[])->gA->A[];
   if);
#)
--GenVirtOrgAdr:descriptor--
(* MUST be revised *)	
(*  V :< ES   or V ::< ES *)
(# originDesc: ^ASTindex; ar: @mch.adrRegOperand; A1: @mch.RegAdr
do (if ES.label = gram.objectDescriptor then
       desc[]->semAtt.descOrigin->originDesc[];
       (* no codegen here *)
    else
       (* this corresponds to virtuals defined like V:<A;
        * if A is global to V, origin code is generated here;
        * if A is at the same block level as V, then no code should be
        * generated, but some superflous code is actual generated;
        * may be possible to eliminate
        *)
       mch.getVirtualOriginStart
       (#
       do startA[]->A[];
          (*originOff->A.bAdr.originOff;*)
          LocalDesc[]->A.bAdr.localDesc[];
          (A[],ES[],true,chain[])->genAdr->A[]->startA[];
       #)
   if);
#)
---callEntry:descriptor---
(# T: ^text; local: @boolean
do call:
     (if switch182 then
         (# EH: @evalHandler; sig: @theGen.signature;
         do ((desc[],true) -> EH.descName,desc[]) -> sig.addReceiver;
            (desc[],chain,false) -> sig.setMethodDesc;
            (if L
             // 'M' then 
                'do'->sig.addMethod;
                sig.noEnter;
                sig.exitVoid;   
             // 'N' then 
                'enter'->sig.addMethod;
                desc[] -> sig.addEnter;
                sig.exitVoid
             // 'X' then 
                (# p,mp,att,n,doP,exitP: ^ASTindex
                do desc[]-> sematt.descSonsRef
                     ->(p[],mp[],att[],n[],doP[],exitP[]);  
                   (if exitP[] = none then
                       leave call
                   if);
                   'exit' -> sig.addMethod;
                   exitP[] -> sig.addExit;
                   sig.noEnter
                #)
             else
                '??callEntry??'->sig.addMethod
            if);          
            (sig.asText->mch.newTextOp,L,false(*?*),false) -> mch.gJsr
         #)
      else
         (L,desc[])->mkEntryPoint->(T[],local);
         (if not local then T[]->mch.import if);
         (T[]->mch.newTextOp,L,local,false)->mch.gJsr;
     if);
   (if false (* collect statistics on descriptor usage *) then
       (desc[],kind) -> dStat.new
   if);
#)
(* mkEntryPoint should probably be eliminated *)
---mkEntryPoint:descriptor--
(# N: @ASTindex; T,S: ^text; inx: @integer
do (if stest then
       312->trace(#do 'mkEntryPoint:'->xT; L->put; descno->xI; desc[] -> xA #)
   if);
   &text[]->EP[]; L->EP.put;
   (if desc.label = gram.mainPart then
       desc[] -> sematt.MainPartDesc -> desc[]
   if);
   (if desc.label
    // gram.objectDescriptor then
       desc.descId->(formId[],descNo);
       (if switch182 then
           (# id: ^text;
              idOfOrigin:
                (# desc: ^ASTindex; id,T: ^text; N,D,F: @ASTindex
                enter desc[]
                do (if desc.label = gram.objectDescriptor then
                       desc.origin -> D; D[] -> idOfOrigin -> id[];
                       desc.father -> F;
                       312->trace(#do desc[] -> xA; xN; F[] -> xA #);
                       (if F.label = gram.descriptorForm then
                           F.xOrigin -> F;
                           (if F.isNull then
                               common.betaenv.groupname->T[]
                            else
                               312->trace(#do F[] -> xA #);
                               F.theSlotName -> T[];
                           if)
                        else
                           L:
                             F.son -> scanList(# do currentNode -> N; leave L #);
                           N.getText -> T[];
                       if);
                       312->trace(# do T[]->xT #);
                       (if id[] = none then  
                           &text[] -> id[];
                           L -> id.put;;
                           '_' -> id.put;
                        else
                           '$'-> id.put
                       if);
                       T[] -> id.append
                   if)
                exit id[]
                #);
              EH: @evalHandler
           do (if false then
                  desc[] -> idOfOrigin -> id[];
                  '\n***mkEntryPoint: ' -> puttext;
                  id[] -> puttext;
                  ' '->put; formId[] -> puttext;  descNo -> putint; newline
               else
                  (desc[],true) -> EH.descName -> EP[]
              if);
              formId.makeUC (* used for testing locality below *)
           #)              
        else
           descNo->EP.putInt; 
           formId.makeUC; 
           formId[] -> EP.puttext;  
       if);
       desc.son->N; N.brother->N;
       (if N.isSlot then
           (* desc has mainPart slot *)
           N.theSlotName->S[]; 
           S.makeUC; 
           (S[]->formSet.isLocal)<>0 ->local;
           (if stest then 312->trace(#do 'MainPart: '->xT; S[] -> xT#)if)
        else
           (if L = 'M' then
               (* check if do-part is a slot *)
               N.son->N;     (* att-part*)
               N.brother->N; (* action-part*)
               N.son->N;     (* enter-part*)
               N.brother->N; (* do-part *)
               (if N.isSlot then
                   (* desc has do-part slot *)
                   N.theSlotName -> S[];
                   S.makeUC;
                   (S[]->formSet.isLocal) <> 0 -> local ;
                   (*312->trace(#do 'Slot:'->xT; N.theSlotName->xT #);*)
                else
                   (formId[]->formSet.isLocal) <> 0 -> local
               if)
            else
               (formId[]->formSet.isLocal) <> 0 -> local;
               (*'isLocal:'->puttext;
                (if local then 'yes'->putline else 'no' -> putline if)*)
       if)if)
    // gram.unExpanded then
       (if switch182 then
           (# EH: @EvalHandler
           do (desc[],true) -> EH.DescName -> EP[]
           #)
        else
           desc->semAtt.GetPostDesc-> formId[]; 1 -> descNo; (*OBS*)
           descNo->EP.putInt; 
           formId.makeUC; 
           formId[] -> EP.puttext;
           (if (((formId[] -> formSet.isLocal -> inx) <> 0) -> local) 
               and (L = 'M') then
               (* the form bound to the slot is also in this group;
                * check if the the form is a descriptor and if it has
                * a do-part slot; if do-part slot check if the do-part
                * form is local or not
                *)
               (# D: ^ ASTindex
               do formDescs[inx][] -> D[];
                  (*304 -> trace(#do 'mkEntryPoint:\n'->xT; Desc[]->xA; D[] -> xA #);*)
                  (if (D[] <> NONE) and (D.label = gram.DescriptorForm) then
                      D.son -> N; (* N= objectDescriptor *)
                      N.son -> N; 
                      N.brother -> N;
                      N.son -> N;
                      N.brother -> N;
                      N.son -> N;
                      N.brother -> N;
                      (if N.isSlot then 
                          N.theSlotName -> S[];
                          S.makeUC;
                          (S[]->formSet.isLocal) <> 0 -> local;
                      if)                      
                  if);
               #)
           if);
   if)if);
   (if stest then 312->trace(#do 'EP:'->xT; EP[]->xT; local->xB #)if)
#)
--doLoadProto:descriptor--
(# T: ^text; local: @boolean
do (if switch68 then
       ('V',desc[])->mkEntrypoint->(T[],local);
       T[] ->mch.import;
       (T[]->mch.newTextOp,mch.callRegOp[]) -> mch.gLea;
    else       
       ('T',desc[])->mkEntrypoint->(T[],local);
       (T[],local)->mch.importData;
       (if common.switch[61] then 
           (T[]->mch.NewTextToDataOp,2->mch.getPrimReg)->mch.gLea
        else
           (T[]->mch.NewTextToDataOp,mch.callRegOp[])->mch.gLea
   if)if);
#)
--doLoadProtoAndAlloc:descriptor--
(# T: ^text; local: @boolean
do (if switch68 then
       6->common.count;
       (if kind
        // common.itemKind // common.holderKind then 
           (* 
            * (T[]->mch.newTextOp,'V',local,false) -> mch.gJsr;
            *)
           ('V',desc[],1) -> CallEntry;
        // common.compKind then
           ('V',desc[])->mkEntrypoint->(T[],local);
           T[] ->mch.import;
           ('AlloC',T[]) -> mch.callAlloPrim
        // common.strucKind then
           ('V',desc[])->mkEntrypoint->(T[],local);
           T[] ->mch.import;
           ('AlloS',T[]) -> mch.callAlloPrim
        // common.comKind then ('AlloCOM',T[])->mch.callAlloPrim
       if)
    else  
       (if switch182 then
           ('G',desc[])->mkEntrypoint->(T[],local);
           (T[],local)->mch.importData;
           (if false then
               ('new',T[])->mch.callAlloPrim
            else
               ('new',((desc[],T[])->theGen.ClassSignature).asText)
                 ->mch.callAlloPrim
           if)
        else
           desc[] -> doLoadProto;
           (if kind
            // common.itemKind then ('AlloI',T[])->mch.callAlloPrim
            // common.compKind then ('AlloC',T[])->mch.callAlloPrim
            // common.strucKind then ('AlloS',T[])->mch.callAlloPrim
            // common.comKind    (* COM- objects and holder-objects *)
            // common.holderKind (* must be allocated in non-moving area *)
               then ('AlloCOM',T[])->mch.callAlloPrim
       if)if);
   if)
#)
---ProtectCallReg:dopart---
do (if mch.callRegInPrimReg2 and mch.callRegBusy then 
       (false,true) -> mch.pushThisOrCall;
       INNER ProtectCallReg;
       (false,true) -> mch.popThisOrCall;
    else
       INNER ProtectCallReg
   if)
---GoOrigin:doPart---
do (# EH: @evalHandler;
      nextReceiver: ^text;
      reg1: @mch.adrRegOperand; 
      D: @ASTindex;
      gCom: com(# do '!goOrigin' -> T #);
   do (* thisA = start address for goOrigin
       * A1    = at entry a copy of thisA 
       *         later used as tmp. var
       * A2    = resulting address after goOrigin
       * Perhaps A1 and A2 may be eliminated and 
       * replaced by thisA!
       *)
      (if thisA.bAdr.LocalDesc[] = NONE then
          'Fatal Error "goOrigin": LocalDesc is NONE' 
            -> thisTranslate.systemException
      if);
      (if stest then
          302->cTrace
          (#
          do 'goOrigin: on:'->xT; on->xI; 
             ' isOrigin:'-> xT; isOrigin->xB;
             ' inEnterDoExitMethod:'->xT; inEnterDoExitMethod->xB;
             xN;
             'thisA='->xT; thisA.display->xT; xN;
             'localDesc=' -> xT; xN;
             thisA.bAdr.localDesc[] -> xA;
          #)
      if);
      
      (if (thisA.bAdr.localDesc.label = gram.objectDescriptor) 
          and (thisA.bAdr.localDesc[] -> sematt.InlineNX) then 
          (* inlinenx may fail for non objectDesciptor;
           * see sematt:inlineNX
           *)
          on - 1 -> on
      if);
      &mch.RegAdr[] -> A2[];
      'goOriginX1:'->mch.comment;
      (if on > 0 then 
          'goOriginY1:'->mch.comment;
          (if not switch182 (*???*) then
          (if thisA.bAdr.localDesc.label = gram.doPart then
              (* name in dopart slot *)
              8->A1.addoff       
           else
              thisA.bAdr.LocalDesc.originOff->A1.addOff->A1[];
          if)if);
          (* ByteCode: isOrigin is ALWAYS false *)
          'goOriginY2:'->mch.comment;
          (if isOrigin and (on = 1) then
              'goOriginX2:'->mch.comment;
              1 -> mch.initPrimCall;
              1 -> A1.toPrimDest;
              'goOriginX3:'->mch.comment;
              0-> mch.getPrimRes;
              (if not A1.frozenReg then 
                  A1.reg.dealloc;
                  (if (A1.reg <> mch.thisO) and (A1.reg<>mch.callO) then
                      '\n*** WARNING: here has been a recent bug-fix'
                      ' (7/10/01)'
                      '\n*** please report to support@mjolner.dk if you'
                      '\n*** think your code does not work here!'
                      '\n*** use "beta --tracecode"  to locate the code'
                      '\n*** giving this warning'
                        -> putline;
                      313->ctrace(#
                                 do 'dont work: webvise problem'->xT;
                                    mch.dumpreg
                                 #);
                  if);
              if);
              -11 -> A2.reg; (* hack *)
           else
              thisA.bAdr.localDesc -> D;
              (if (D.label=gram.objectDescriptor) (* discovered while
                                                   * testing newindex
                                                   *)
                  and ((D -> sematt.descKind) = sematt.stateKind) then
                  (if stest then
                      302->ctrace(#Do 'StateDesc1:'-> xT #)
                  if);
                  A1[] -> A2[]
               else
                  (* allocate reg1 - reuse register in A1 *)
                  (if A1.frozenReg then
                      reg1.alloc
                   else
                      A1.theReg -> reg1
                  if);
                  (if switch182 then 
                      (1,A1[]) -> gCom;
                      true -> A1.isRef;
                      true -> A1.isOrigin;
                      (if not A1.noFieldInit then
                          (if not inEnterDoExitMethod then
                              A1.fieldType[] -> A1.receiverType[];
                              'origin' -> A1.fieldName[];
                              (thisA.bAdr.LocalDesc[] 
                                -> sematt.descOrigin
                                -> theGen.fieldSignature).astext
                                -> A1.fieldType[];
                              302->trace(#
                                        do 'origin:fieldType: ' -> xT; xN;
                                           A1.fieldType[] -> xT
                                        #)
                           else
                              (* just to assure that receiverType
                               * and fieldType are defined
                               *
                               'this' -> A1.receiverType[];
                               'this_origin' -> A1.fieldType[];*)
                      if)if);
                      (if A1.ONlevel > 0 then
                          '\nA1.ONlevel > 0' -> putline;
                          true -> A1.isField;
                          (*'\n***ONlevel: ' -> puttext;
                           A1.ONlevel -> putint; newline*)
                       else
                          (*false -> A1.isField;*)
                          (if A1.isField then 
                              (* somewhat of a hack; to handle
                               * final1 in tstvirt2
                               *)
                              1 -> A1.ONlevel 
                          if);
                  if)if);
                  (2,A1[]) -> gCom;
                  (A1[],reg1[]) -> mch.ldVal;                   
                  reg1->A2.reg; common.direct->A2.access;
                  (if switch182 then 
                      1 -> A2.ONlevel;
                      true -> A2.isField
                  if);
                  A1.receiverType[] -> A2.receiverType[];
                  A1.fieldName[] -> A2.fieldName[];
                  A1.fieldType[] -> A2.fieldType[];
              if)
          if);
          (if switch182 then
              (if inEnterDoExitMethod and not A1.noFieldInit then
                  thisA.bAdr.LocalDesc[] -> A2.bAdr.LocalDesc[];
                  302->trace(#
                          do 'origin: inNDX:'-> xT;
                             A2.bAdr.LocalDesc[] -> xA
                          #)
               else
                  thisA.bAdr.LocalDesc[]
                    -> sematt.descOrigin
                    -> A2.bAdr.LocalDesc[]
              if)
           else
              thisA.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[]
          if);
          (3,A2[]) -> gCom;
       else
          (if stest then
              302->ctrace(#do 'goOrigin3:'->xT; reg1.display-> xT; mch.dumpreg #)
          if);
          (* copy A1 to the object denoted by A2; A1[] -> A2[] won't do, 
           * since
           * A2 is a reference to an object in machine:regAdr:goOrigin
           * and that object MUST be changed directly
           *)
          A1.reg -> A2.reg; A1.access -> A2.access; 
          A1.frozenReg -> A2.frozenReg;
          A1.off -> A2.off; (* not necessary; will be set to zero later?*)
          A1[] -> A2.bAdr.copy; (* ? *)
          
          thisA.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[];
              (*195->trace(# S: @text do A2.display -> S; S[] ->xT #);*)
      if);
      
      (for i: on - 1 repeat (* use dbb loop *)
           (if A2.bAdr.localDesc.label = gram.doPart then
               8->A2.off
            else
               A2.bAdr.localDesc.originOff->A2.off
           if);
           (if isOrigin and (i = on-1) then 
               (7,A2[]) -> gCom;
               1 -> mch.initPrimCall;
               1 -> A2.toPrimDest;
               0-> mch.getPrimRes;
               A2.reg.dealloc;
               -11 -> A2.reg; (* hack *)
            else
               (if (A2.bAdr.localDesc.label = gram.objectDescriptor)
                   and
                   ((A2.bAdr.localDesc-> sematt.descKind) = sematt.stateKind)
                   then
                   (if stest then
                       302->ctrace(#Do 'StateDesc2:'->xT #)
                   if)
                else
                   true -> A2.isRef;
                   (if switch182 then
                       true->A2.isOrigin;
                       (*A2.fieldClass[] -> A2.descName[];*)
                       A2.fieldType[] -> A2.receiverType[];
                       (*(A2.bAdr.LocalDesc[]
                        -> sematt.descOrigin,true)
                        -> EH.descName 
                        -> A2.fieldClass[];*)
                       302->trace(#
                                 do 'goOrigin:fieldSignature' -> xT;
                                    A2.bAdr.localDesc[]  -> xA
                                 #);
                       (A2.bAdr.localDesc[] 
                         -> sematt.descOrigin
                         -> theGen.fieldSignature).asText
                         -> A2.fieldType[];
                       (4,A2[]) -> gCom;
                       302->trace(#
                                 do 'origin2:A2: ' -> xT; xN;
                                    A2.display->xT;
                                 #)
                   if);
                   (if false (*common.switch[121]*) then
                       reg1.alloc;
                       (A2[],reg1[])->mch.ldVal;
                       A2.reg.deAlloc;
                       reg1 -> A2.reg
                    else
                       (A2[],reg1[])->mch.ldVal;
                   if);
                   (if switch182 (*bytecode*) then
                       A2.ONlevel + 1 -> A2.ONlevel;
                   if);
               if)
           if);
           302->trace
           (#
           do 'gooriginXXX:A2:' -> xT; A2.display->xT
           #);
           A2.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[];
           302->trace
           (#
           do 'gooriginYYY:A2:' -> xT; A2.display->xT
           #);
           (5,A2[]) -> gCom;
      for);
      0 -> A2.off;
      thisA.size -> A2.size;
   #)
