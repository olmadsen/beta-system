ORIGIN 'synthlib';
LIB_ITEM 'betacodegen';
INCLUDE 'evlib';
INCLUDE '../GENERATOR/machine';
INCLUDE 'auxlib';
INCLUDE 'signature';
---SynthesizerBodyLib:attributes---
com:
  (# no: @integer; A: ^mch.address; T: @text
  enter(no,A[])
  do INNER;
     no -> T.putint;
     ':descName:'->T.append;
     (if A.descName[] <> none then A.descName[] -> T.append if);
     ':fieldType:'->T.append;
     (if A.fieldType[] <> none then A.fieldType[] -> T.append if);
     T -> mch.comment;
     (*T[] -> putline*)
  #);

--GenLocalAdr:descriptor--
(#
do (&gen.thisRegAdr,ad[],isOrigin,chain[])->GenAdr->A[]
#)
--GenAdr:descriptor---
(* think about deRef in old version *)
(# dcl,descRef,rDen,EV,N1: @ASTindex; N,spec,localDesc: ^ASTindex;
   EH: @EvalHandler;  V: ^EH.EvVal;
   descKind,size,
   baseOff: @integer; (* 0 if item, compHeadSize if component *)
   indexReg: ^mch.dataRegOperand;
   (********************************************************
   XvarAddress: mch.address
     (# xName: ^text;
        off: @integer;
        addOff::<(# do off+v->off #);
        putOp::<
          (#do xName->mch.BC.putT; '+'->mch.BC.putC; off->mch.BC.putI #);
    #);
    *)
   isData:
     (# N,desc: @ASTindex; isData: @boolean;(* XA: ^XvarAddress*)
     enter((*N[],*)desc)
     do (if (desc.label = gram.objectDescriptor)
            and 
            (((desc->sematt.descKInd) = semAtt.dataKInd) -> isData) then
           (* &XvarAddress[]->XA[];
            N.getText->XA.xName[]*)

        if)
     exit isData
     #);
   isD: @boolean;
   
   aCom: com(#do '!genAdr'->T #);
   rCom: com(#do '!remAdr'->T #);
   doGoOrigin:
     (# toOrgReg: @boolean; orgDesc: @ASTindex; on: @integer;
        D: ^ASTindex;
        doCom: com
          (#
          do '!doGoOrigin' -> T;
          #);
     enter toOrgReg
     do (if switch182 then
            thisDesc[] -> EH.descName -> A.descName[]; (* No need to
                                                        * initialize descName
                                                        *)
            A.bAdr.localDesc[] -> EH.descName -> A.fieldType[];
        if);
        (if (ad.on > 0) or inEnterDoExitMethod then 
            (if switch182 (* bytecode *) then
                ad.on -> on;
                (if inEnterDoExitMethod then on + 1 -> on if);
                (if toOrgReg then
                    (1,A[]) -> doCom;
                    (A[],A.copy,on,false) -> GoOrigin -> A[];
                 else      
                    (2,A[]) -> doCom;
                    (A[],A.copy,on,toOrgReg) -> GoOrigin -> A[]
                if)
             else
                (A[],A.copy,ad.on,toOrgReg) -> GoOrigin -> A[] 
            if)
        if);
        (* A.fieldType = type of object referred by A *)

        (3,A[]) -> doCom;
        (if false (*switch182*) then
            (if inEnterDoExitMethod and not A.isField then
                (* bytecode only *)
                313->trace(#
                          do 'doGoOrigin:goExtra: ONlevel:'->xT;
                             A.ONlevel -> xI;
                             A.descName[] -> xT
                          #);
                true -> A.isOrigin;
                true -> A.isField;
                A.fieldType[] -> A.descName[];
                A.bAdr.localDesc[] -> sematt.descOrigin -> D[];

                (4,A[]) -> doCom;

                (A[],none) -> mch.ldVal;
                (if D.isNull then
                    'object' -> A.fieldType[]
                 else
                    D[] -> EH.descName -> A.fieldType[];
                if);
        
                (5,A[]) -> doCom;
                A.ONlevel + 1 -> A.ONlevel
            if);
            (*(6,A[]) -> doCom;*)
            (* follow super to correct superDesc *)
            (if ad.pn > 0 then 
                (A[],ad.pn,A[]) -> SetSuperDesc -> A[] 
            if); (* check why we do this ? This imp and
                  * the next imp are probably superflous?
                  *)
            A.bAdr.localDesc[] -> theGen.mkSignature -> A.fieldType[];

            (3,A[]) -> doCom;
            (if ad.ON > 0 then true -> A.isField if);
            (* ad.ON = 0 : a local variable in a method *)
        if)
     #);
   isSimple: @boolean; isVirt,MN,access: @integer;
   (* A is baseAdr *)
do (if stest then
       301->ctrace(#
                  do 'GenAdr: ad='->xT; ad[]->xA;
                     ' isOrigin='->xT; isOrigin->xB; xN;
                     ' A='->xT; A.display->xT; 
                     mch.dumpreg 
                  #)
   if);
   (if ad.label
    // gram.nameApl then
       (if stest then
           301->ctrace
           (#do'GenAdr:nameApl: '->xT; ad[]->xA; ' on:'->xT; ad.on->xI;
              mch.dumpreg
           #)
       if);
       (chain[],ad) -> DH.theDesc -> (descRef,MN,chain[],isVirt);
       ad.dclRef->dcl;
       
       (* A refers to the start of the object that has 'ad' as attribute *)
       (if isOrigin then
           (* origin of ad is computed. 'ad' is a pattern *)
           dcl.sort->dcl;
           L:
             (if dcl.label = gram.finalDecl then
                 (* Consider  T: (#  X::B do ...; X; ... #).
                  * Note: the case where
                  *    B::C;
                  *    C::D;
                  *    etc
                  * is not tested
                  *)
                 doGoOrigin;
                 dcl.son->dcl; dcl.brother->dcl; (* dcl = B *)
                 (if stest then
                     301->ctrace
                     (#
                     do 'GenAdr:isOrigin:Final:on='->xT; 
                        dcl.on->xI; dcl[]->xA;
                        A.bAdr.localDesc[]->xA
                 #)if);
                 (* chain starts with the "real" desc for X, i.e. desc for B;
                  * the chain to be used as argument for GenOrgAdr must
                  * be one corresponding to the descriptor T above;
                  * since we just need to "add" the origin for T, we can
                  * just pass a chain consisting of the descriptor for T
                  *)
                 (if stest then
                     301->ctrace(#
                                do 'genAdr:isOrigin:final:A='->xT; 
                                   A.display->xT 
                                #)
                 if);
                 (if dcl.label <> gram.objectDescriptor then
                     (# dclSort: @ASTindex
                     do dcl -> sematt.getSort -> dclSort;
                        (if dclSort.label
                         // gram.virtualDecl // gram.bindingDecl then
                            (if stest then
                                301 -> trace(#
                                            do 'GenAdrOrg:Final:virtual'->xT;
                                               dcl[]->xA; dclSort[] -> xA
                            #)if);
                            leave L
                 if)#)if);
                 dcl[]->sematt.encDesc->localDesc[];
                 (A[],none,dcl[],localDesc->DH.newSingle)
                   -> &GenOrgAdrToOrgReg
                   -> A[];
                 (if stest then
                     301 -> trace
                     (#
                     do 'genAdr:isOrigin:Final:end:A='->xT; A.display->xT 
                 #)if)
              else
                 toOrgReg -> doGoOrigin
             if);
           '!genAdr:loadorigin2' -> mch.comment;
           
        else
           doGoOrigin;
           
           301 -> trace(#do 'adr:1'->xT; A.display->xT #);
           dcl.off -> A.addOff -> A[];
           
           (if switch182 then
               (1,A[]) -> aCom;               
               A.fieldType[] -> A.descName[];
               descRef[] -> theGen.mkSignature -> A.fieldType[];
               (if (ad.on > 0) or inEnterDoExitMethod then 
                   true -> A.isField 
                else
                   false -> A.isField
               if);
               (* A.descRef  : object containing field refereredd by A;
                * A.fieldType: type of field referred by A *
                *)
               (2,A[]) -> aCom;
           if);
           
           descRef[]->A.bAdr.localDesc[];
           (if (dcl.access->A.access) = common.direct then 
               descRef.size->A.Size;
               descRef[] -> sematt.isSigned -> A.signed;
            else (* includes for-index*) 4->A.size
           if);        
       if);
    // gram.remote then(* R.X *)
       A.bAdr.localDesc[] -> localDesc[];
       ad.son -> rDen; 
       301 -> trace(#do 'remote:1'->xT; A.display->xT #);
       'genadr:remote1:'->mch.comment;               
       (A[],rDen[],false,chain[]) -> GenAdr -> A[];
       301 -> trace(#do 'remote:2'->xT; A.display->xT #);
       (if switch182 then
           (# attD: @sematt.AttDesc;
              D,aD: @ASTindex; DN,aDN: ^text; descKind: @integer;
              T: @text
           do (1,A[]) -> rCom;
              rDen.descRef -> D;
              (if D.label 
               // gram.objectDescriptor then
                  D[] -> EH.DescName -> DN[]
               // gram.virtualDecl // gram.bindingDecl // gram.finalDecl then
                  rDen[] -> attD;
                  313->trace(#do 'loadQref:'->xT; attD.display #);
                  (thisDesc[],rDen[]) -> GetActualDesc -> (aD,descKind);
                  aD[] -> EH.DescName -> aDN[];
                  D.son -> D; D.brother -> D;
                  (* OK? thisDesc? ???*)
                  (thisDesc[],D[]) -> GetActualDesc -> (D,descKind);
              if);
              D[] -> EH.DescName -> DN[];
              (*
              (if rDen.pn > 0 then
                  (A[],rDen.pn,A[]) -> SetSuperDesc -> A[]; 
                  A.bAdr.localDesc[] -> EH.descName -> A.descName[]
               else
                  DN[] -> A.descName[];
               if);*)
              (* A.descName[] = name of descriptor where rDen is
               *                an attribute.
               * If ad = 'S.foo' then rDen = 'S' and if
               *    'fisk: (# ... S: ... #)'
               * then A.descName[] = 'fisk'
               *)
              'remote:loadRef: ' -> T; A.descName[] -> T.append;
              ' PN:'->T.append; rDen.pn -> T.putint;
              T -> mch.comment;
              313->trace(#
                        do 'basic: ' -> xT; DN[] -> xT;
                           ' actual: ' -> xT; aDN[] -> xT
                        #);

              (A[],DN[],aDN[]) -> mch.loadRef; 
              'remote:3'->mch.comment;
           #)
       if);
       (if rDen.label = gram.nameApl then
           rDen.descRef -> isData -> isD;
       if);
       rDen -> semAtt.GetNameAndKind -> (N[],spec[]);	

       rDen.brother->rDen; rDen.dclRef->dcl; 

       (if spec.label // gram.staticComponent // gram.dynamicComponent then
           common.compHeadSize*4 -> baseOff
       if);
       (* A denotes R *)
       (if isOrigin then 'isOrigin'->mch.comment;
           (if switch182 then
               (if baseOff <> 0 then
                   '***genAdr:remote:missing baseOff->A.addOff'
                     -> mch.comment
               if)
            else
               baseOff->A.addOff->A[];
           if);
           (if rDen.pn>0 then 
               (A[],rDen.pn,A[]) -> SetSuperDesc -> A[] 
           if);
           dcl.sort->dcl;
           L:
           (if dcl.label = gram.finalDecl then
               (* R.X where  e.g. R: @T; T: (#  X::B #).
                * Note: the case where
                *    B::C;
                *    C::D;
                *    etc
                * is not tested
                *)
               dcl.son->dcl; dcl.brother->dcl; (* dcl = B *)
               (* B may be declared as one of
                *    B: (# ... #)
                *    B:< ...
                *)
               (if dcl.label <> gram.objectdescriptor then
                   (# dclSort: @ASTindex
                   do dcl -> sematt.getSort -> dclSort;
                      (if dclSort.label
                       // gram.virtualDecl // gram.bindingDecl then
                          (*301 -> trace(#do 'GenAdrOrg:Final:virtual'->xT; 
                                         dcl[]->xA; dclSort[] -> xA
                           #);*)
                          leave L
                   if)#)if);
                   (*301->trace(#do 'GenAdrOrg:Final:'->xT; dcl[]->xA #);*)
               dcl[]->sematt.encDesc->localDesc[];
               (A[],none,dcl[],localDesc->DH.newSingle)->&GenOrgAdr->A[]
           if);
        else '**not origin'->mch.comment;
           (chain[],ad)->DH.theDesc->(descRef,MN,chain[],isVirt);
           (if ((dcl.access->access) = common.direct) then                
               descRef.size->size;
               (* The following code is not used!
                * It is for the case
                *    R: [..] @ T; T: (# ... X: @S; ... #)
                * where the repetition was allocated inline.
                * (It is now allocated off-line, since this makes
                * it a lot easier to handle R[e][] -> S[]; v->R.extend.)
                * We have:
                * R[e].X
                * X.dcl.access = common.direct
                * R[e] is inxRegAdr = (ai, di, s, off)
                *  adr(R[e]) = ai + di*s +off
                * In general dcl.off cannot be added to off
                * and dcl.size cannot replace size of A
                * Note: due to a register overflow error in FEJL/list2list,
                * toReg2 has been replaced by toReg3 below, but this
                * has not been tested very much.
                * (if (A.access = common.direct) and
                *      A.isInxRegAdr and (A.size <> size) then 
                *     (# A1: @mch.RegAdr
                *     do A.toReg3->A1.reg;
                *        A.bAdr.localDesc[]->A1.bAdr.localDesc[];
                *        A1[]->A[];
                *     #)if)
                *)
            else 
               4->size
           if);

           (if stest then
               301 -> cTrace(# D: @ASTindex 
                            do 'genAdr:remote: isData= '->xT;
                               isD->xB; 
                               ' indirect='->xT; A.access=common.varInd->xB;xN;
                               A.display->xT
           #)if);
           (* we must handle S.c where
            *    S: ^myData; myData: data(# c: .... #)
            * A is address of S;
            * aReg in A is the addres of a real object
            * or A.isNotObjRef = true
            *    A.addOff 
            * below will load the address of
            * a myData object to a register which will then
            * be referring a data-object.
            * Note: S: @myData does not have this problem
            * since the offset is just added
            *)
           isD and (A.access <> common.direct) -> isD;

           (if switch182 then
               (# aR: @mch.RegAdr;
                  T: @text
               do 0 -> aR.ONlevel; 
                  true -> aR.isField ;
                  dcl.off+baseOff -> aR.off;
                  
                  (if rDen.pn > 0 then 
                      (A[],rDen.pn,A[]) -> SetSuperDesc -> A[]; 
                      A.bAdr.localDesc[] -> EH.descName -> aR.descName[]
                   else
                      (* probably just do as before else *)
                      (if false then
                          A.descName[] -> aR.descName[];
                       else
                          A.bAdr.localDesc[] -> EH.descName -> aR.descName[]
                      if)
                  if);
                  aR[] -> A[];
                  'loadField: F' -> T; aR.off -> T.putint;
                  aR.descName[] -> T.append;
                  ' PN:' -> T.append; rDen.pn -> T.putint;
                  T -> mch.comment
               #)
            else
               dcl.off+baseOff -> A.addOff -> A[];           
           if);
           isD -> A.isNotObjRef;
           size -> A.Size;
           descRef[] -> sematt.isSigned -> A.signed;
           descRef[] -> A.bAdr.localDesc[];
           access -> A.access
       if)
    // gram.indexed then
       (if switch182 then           
           (# Ax: ^mch.address; T: @text; sig: ^theGen.type;
              AR: @mch.inxRegAdr
           do
              ad.son->rDen; rDen.brother->EV; 
              (* load array reference: *)
              '!loadArray1'->mch.comment;
              (A.copy,rDen[],false,chain[]) -> GenAdr -> Ax[];
              Ax.bAdr.localDesc[]->localDesc[]
                -> theGen.valueSignature 
                -> theGen.Array 
                -> sig[]; 
              '! loadArry2: ' -> T;
              localDesc[] -> EH.descName -> T.append; 
              ' descName:' -> T.append;
              Ax.descName[] -> T.append;
              T -> mch.comment;
              (* A.descName[] = descriptor where rDen is declared *)
              (Ax[],sig.asText,none) -> mch.loadRef;
              '!loadIndex1'->mch.comment;
              (A.copy,EV[],false,chain[])->&EH.ExpEval->V[]; 
              '!loadIndex2'->mch.comment; 
              
              (localDesc[]-> theGen.valueSignature).astext
                -> AR.fieldType[]; (* array element type *)
              '! inxReg: descName: ' -> T; AR.descName[] -> T.append;
              '! fieldType:' -> T; AR.fieldType[] -> T.append;
              T -> mch.comment;
              AR[] -> A[];
           #)
        else
           (if not A.frozenReg then
               (* this will happen when used as a super-pattern as in
                *    R[e].P(# ... #)
                * It is assumed that even if A is frozen, there will
                * be enough registers to compute R[e].P. If, however,
                * 'R[e]' is very complicated we may ran out of registers
                *)
               (*312->trace(#do '\nObs! Index-baseadr NOT frozen'->T #);*)
               A.freezeReg;
           if);
           A.bAdr.localDesc[]->localDesc[]; 
           (* compute @@R[inx] relative to localDesc ?? *)
           ad.son->rDen; rDen.brother->EV; 
           (A.copy,EV[],false,chain[])->&EH.ExpEval->V[]; 
           V.toDataReg->indexReg[]; (*V.release; !!*)
           Rden -> SemAtt.getName -> N1; N1.dclRef -> dcl;
           (A.copy,rDen[],false,chain[])->&GenAdr->A[];
           (chain[],ad)->DH.theDesc->(descRef,MN,chain[],isVirt);
           (if stest then
               179->ctrace
               (#
               do 'Indexed:'->xT; dcl.access->xI; dcl[]->xA; 
                  A.display->xT; mch.dumpreg
           #)if);
           (if (dcl.access->A.access) 
            // common.direct then
               (* S: [...] @ T where T is simple or non-virtual*)
               descRef.size->size;
               (if not ((descRef->sematt.descKind) = sematt.standardKind->isSimple)
                   then 
                   false->isSimple;
                   4->size;
                   common.cstInd->A.access;
                   (*
                    * ((size + 7), 7->TOS'%not') ->TOS'%and' -> size
                    *)
                   (* size must be 8 byte aligned *)
               if);
               (* component or item? *)
               (* (# spec: @ASTindex
                * do dcl.sort->spec; ( *sort* ) spec.son->spec; ( * nameList* )
                *    spec.brother->spec; ( * data spec or rep * ) spec.brother->spec;
                *    (if spec.label = gram.staticComponent then
                *    common.compHeadSize*4 + size -> size
                * if)#)
                *)
            // common.varInd then
               (* reference repetition *)
               4->size ;
               true->isSimple
            else (*// common.cstInd then  S: [...] @T T slot or virtual *)
               4->size
           if);
           (indexReg,isSimple,size)->A.index->A[];
           descRef[]->A.bAdr.localDesc[];
       if)
    // gram.thisObject then (* always this(P) *)
       ad.son->rDen; 
	   (* 'on' is adjusted during checking to avoid (for ...for) etc.
            * Regarding onForThis, see comment in isEnclosing
            *)
       (if rDen.onForThis > 1 then 
           (* (rDen.onForThis - 1,toOrgReg) -> A.goOrigin -> GoOrigin->A[]*)
           (A[],A.copy,rDen.onForThis - 1,toOrgReg) -> GoOrigin->A[]
       if);
       (* rDen.on > 0 always !*)
    // gram.computedRemote then
       (# EV,N,descRef: @ASTindex; 
          EH: @EvalHandler; isVirt: @integer;
          LV,V: ^EH.EvVal
       do (if stest then
              301->ctrace
              (#do 'genAdr:computedRemote: ad='->xT; ad[]->xA; 
                 ' A= '->xT; A.display->xT; mch.dumpreg #)
          if);
          (if not A.frozenReg then 
              (* this will happen when used as a super-pattern as in
               *    (foo).P(# ... #)
               * It is assumed that even if A is frozen, there will
               * be enough registers to compute (foo).P. If, however,
               * 'foo' is very complicated we may ran out of registers
               *)
              (*193->trace(#do '\nObs! CompRem-baseadr NOT frozen'->T #);*)
              A.freezeReg;
              (* when do we unfreeze A? For now we don't bother, since
               * we rely on the new backend
               *)
          if);
          ad.son -> EV; EV.brother -> N;
          (*306->trace(#do ad[] -> A; N[] -> A #);(*!*)
          L: EV->scanList(#do currentNode -> EV; leave L #);
          
          (A.copy,EV[],false(*?*),chain[]) -> EH.expEval -> V[];

          (if stest then
              301->ctrace
              (#do 'GenAdr:computedRemote:A:'->xH; V.display; mch.dumpreg #)
          if);
          
          (if switch181 then
              V.getRefAdr -> A[]
           else
              V.getRefEval -> V[];           
              (if stest then
                  301->ctrace
                  (#do'GenAdr:computedRemote:B:'->xH;V.display;mch.dumpreg#)
              if);
              V.theAdr -> A[];
          if);
          
          (if stest then
              301->ctrace
              (#do'GenAdr:computedRemote:C:'->xH;A.display->xT;mch.dumpreg #)
          if);
          
          (if isOrigin then 4->A.size; 
           else
              N.dclRef->dcl; dcl.off -> A.addOff -> A[];
              (chain[],ad) -> DH.theDesc -> (descRef,MN,chain[],isVirt);
              descRef[] -> A.bAdr.localDesc[];
              (if (dcl.access->A.access) = common.direct then
                  descRef.size -> A.Size
               else 4->A.size
          if)if);
       #)
   if);
   (if stest then
       301 -> ctrace(#do 'GenAdr:exit: '->xT; ad[]->xA; xN; A.display->xT;
                       mch.dumpreg
                    #)
   if)
#)
--GenOrgAdr:descriptor--
(* enter(desc,ES)
 * where desc is the descriptor containing ES
 *)
(# originDesc: ^ASTindex 
do (if stest then 
       301->ctrace(#do 'GenOrgAdr:'->xT; es[]->xA; desc[]->xA #)
   if);
   (if ES.label // gram.objectDescriptor // gram.unExpanded then
       baseAdr.copy->A[]
    else 
       (baseAdr.copy,ES[],true,chain[])->genAdr->A[]
   if);
#)
--GenOrgAdrToOrgReg:descriptor--
(* enter(desc,ES)
 * where desc is the descriptor containing ES
 *)
(# originDesc: ^ASTindex ;
   gA: @genAdr
do (if stest then
       301->ctrace(#do 'GenOrg:'->xT; es[]->xA; desc[]->xA #)
   if);
   (if ES.label // gram.objectDescriptor // gram.unExpanded then
       baseAdr.copy->A[];
       (if switch182 then
           true -> A.isRef;
           (A[],none) -> mch.ldVal
       if)
    else 
       true -> gA.toOrgReg; (* hack *)
       (baseAdr[],ES[],true,chain[])->gA->A[];
   if);
#)
--GenVirtOrgAdr:descriptor--
(* MUST be revised *)	
(*  V :< ES   or V ::< ES *)
(# originDesc: ^ASTindex; ar: @mch.adrRegOperand; A1: @mch.RegAdr
do (if ES.label = gram.objectDescriptor then
       desc[]->semAtt.descOrigin->originDesc[];
       (* no codegen here *)
    else
       (* this corresponds to virtuals defined like V:<A;
        * if A is global to V, origin code is generated here;
        * if A is at the same block level as V, then no code should be
        * generated, but some superflous code is actual generated;
        * may be possible to eliminate
        *)
       mch.getVirtualOriginStart
       (#
       do startA[]->A[];
          (*originOff->A.bAdr.originOff;*)
          LocalDesc[]->A.bAdr.localDesc[];
          (A[],ES[],true,chain[])->genAdr->A[]->startA[];
       #)
   if);
#)
---callEntry:descriptor---
(# T: ^text; local: @boolean
do call:
     (if switch182 then
       (# EH: @evalHandler; class: ^text; sig: @theGen.signature;
       do desc[] -> EH.descName -> sig.addReceiver;
          desc[] -> sig.setDesc;
          (if L
           // 'M' then 
              'do'->sig.addMethod;
              sig.noEnter;
              sig.exitVoid;   
           // 'N' then 
              'enter'->sig.addMethod;
              desc[] -> sig.addEnter;
              sig.exitVoid
           // 'X' then 
              (# p,mp,att,n,doP,exitP: ^ASTindex
              do desc[]-> sematt.descSonsRef
                   ->(p[],mp[],att[],n[],doP[],exitP[]);  
                 (if exitP[] = none then
                     leave call
                 if);
                 'exit' -> sig.addMethod;
                 exitP[] -> sig.addExit;
                 sig.noEnter
              #)
           else
              '??callEntry??'->sig.addMethod
          if);          
          sig -> class[];
          (class[]->mch.newTextOp,L,false(*?*),false) -> mch.gJsr
       #)
    else
       (L,desc[])->mkEntryPoint->(T[],local);
       (if not local then T[]->mch.import if);
       (T[]->mch.newTextOp,L,local,false)->mch.gJsr;
   if);
   (if false (* collect statistics on descriptor usage *) then
       (desc[],kind) -> dStat.new
   if);
#)
(* mkEntryPoint should probably be eliminated *)
---mkEntryPoint:descriptor--
(# N: @ASTindex; T,S: ^text; inx: @integer
do (if stest then
       312->trace(#do 'mkEntryPoint:'->xT; L->put; descno->xI; desc[] -> xA #)
   if);
   &text[]->EP[]; L->EP.put;
   (if desc.label = gram.mainPart then
       desc[] -> sematt.MainPartDesc -> desc[]
   if);
   (if desc.label
    // gram.objectDescriptor then
       desc.descId->(formId[],descNo);
       (if switch182 then
           (# id: ^text;
              idOfOrigin:
                (# desc: ^ASTindex; id,T: ^text; N,D,F: @ASTindex
                enter desc[]
                do (if desc.label = gram.objectDescriptor then
                       desc.origin -> D; D[] -> idOfOrigin -> id[];
                       desc.father -> F;
                       312->trace(#do desc[] -> xA; xN; F[] -> xA #);
                       (if F.label = gram.descriptorForm then
                           F.xOrigin -> F;
                           (if F.isNull then
                               'betaenv'->T[]
                            else
                               312->trace(#do F[] -> xA #);
                               F.theSlotName -> T[];
                           if)
                        else
                           L:
                             F.son -> scanList(# do currentNode -> N; leave L #);
                           N.getText -> T[];
                       if);
                       312->trace(# do T[]->xT #);
                       (if id[] = none then  
                           &text[] -> id[];
                           L -> id.put;;
                           '_' -> id.put;
                        else
                           '$'-> id.put
                       if);
                       T[] -> id.append
                   if)
                exit id[]
                #);
              EH: @evalHandler
           do (if false then
                  desc[] -> idOfOrigin -> id[];
                  '\n***mkEntryPoint: ' -> puttext;
                  id[] -> puttext;
                  ' '->put; formId[] -> puttext;  descNo -> putint; newline
               else
                  desc[] -> EH.descName -> EP[]
              if);
              formId.makeUC (* used for testing locality below *)
           #)              
        else
           descNo->EP.putInt; 
           formId.makeUC; 
           formId[] -> EP.puttext;  
       if);
       desc.son->N; N.brother->N;
       (if N.isSlot then
           (* desc has mainPart slot *)
           N.theSlotName->S[]; 
           S.makeUC; 
           (S[]->formSet.isLocal)<>0 ->local;
           (if stest then 312->trace(#do 'MainPart: '->xT; S[] -> xT#)if)
        else
           (if L = 'M' then
               (* check if do-part is a slot *)
               N.son->N;     (* att-part*)
               N.brother->N; (* action-part*)
               N.son->N;     (* enter-part*)
               N.brother->N; (* do-part *)
               (if N.isSlot then
                   (* desc has do-part slot *)
                   N.theSlotName -> S[];
                   S.makeUC;
                   (S[]->formSet.isLocal) <> 0 -> local ;
                   (*312->trace(#do 'Slot:'->xT; N.theSlotName->xT #);*)
                else
                   (formId[]->formSet.isLocal) <> 0 -> local
               if)
            else
               (formId[]->formSet.isLocal) <> 0 -> local;
               (*'isLocal:'->puttext;
               (if local then 'yes'->putline else 'no' -> putline if)*)
       if)if)
    // gram.unExpanded then
       (if switch182 then
           (# EH: @EvalHandler
           do desc[] -> EH.DescName -> EP[]
           #)
        else
           desc->semAtt.GetPostDesc-> formId[]; 1 -> descNo; (*OBS*)
           descNo->EP.putInt; 
           formId.makeUC; 
           formId[] -> EP.puttext;
           (if (((formId[] -> formSet.isLocal -> inx) <> 0) -> local) 
               and (L = 'M') then
               (* the form bound to the slot is also in this group;
                * check if the the form is a descriptor and if it has
                * a do-part slot; if do-part slot check if the do-part
                * form is local or not
                *)
               (# D: ^ ASTindex
               do formDescs[inx][] -> D[];
                  (*304 -> trace(#do 'mkEntryPoint:\n'->xT; Desc[]->xA; D[] -> xA #);*)
                  (if (D[] <> NONE) and (D.label = gram.DescriptorForm) then
                      D.son -> N; (* N= objectDescriptor *)
                      N.son -> N; 
                      N.brother -> N;
                      N.son -> N;
                      N.brother -> N;
                      N.son -> N;
                      N.brother -> N;
                      (if N.isSlot then 
                          N.theSlotName -> S[];
                          S.makeUC;
                          (S[]->formSet.isLocal) <> 0 -> local;
                      if)                      
                  if);
               #)
           if);
   if)if);
   (if stest then 312->trace(#do 'EP:'->xT; EP[]->xT; local->xB #)if)
#)
--doLoadProto:descriptor--
(# T: ^text; local: @boolean
do (if switch68 then
       ('V',desc[])->mkEntrypoint->(T[],local);
       T[] ->mch.import;
       (T[]->mch.newTextOp,mch.callRegOp[]) -> mch.gLea;
    else       
       ('T',desc[])->mkEntrypoint->(T[],local);
       (T[],local)->mch.importData;
       (if common.switch[61] then 
           (T[]->mch.NewTextToDataOp,2->mch.getPrimReg)->mch.gLea
        else
           (T[]->mch.NewTextToDataOp,mch.callRegOp[])->mch.gLea
   if)if);
#)
--doLoadProtoAndAlloc:descriptor--
(# T: ^text; local: @boolean
do (if switch68 then
       6->common.count;
       (if kind
        // common.itemKind // common.holderKind then 
           (* 
            * (T[]->mch.newTextOp,'V',local,false) -> mch.gJsr;
            *)
           ('V',desc[],1) -> CallEntry;
        // common.compKind then
           ('V',desc[])->mkEntrypoint->(T[],local);
           T[] ->mch.import;
           ('AlloC',T[]) -> mch.callAlloPrim
        // common.strucKind then
           ('V',desc[])->mkEntrypoint->(T[],local);
           T[] ->mch.import;
           ('AlloS',T[]) -> mch.callAlloPrim
        // common.comKind then ('AlloCOM',T[])->mch.callAlloPrim
       if)
    else  
       (if switch182 then
           ('G',desc[])->mkEntrypoint->(T[],local);
           (T[],local)->mch.importData;
           ('new',T[])->mch.callAlloPrim
        else
           desc[] -> doLoadProto;
           (if kind
            // common.itemKind then ('AlloI',T[])->mch.callAlloPrim
            // common.compKind then ('AlloC',T[])->mch.callAlloPrim
            // common.strucKind then ('AlloS',T[])->mch.callAlloPrim
            // common.comKind    (* COM- objects and holder-objects *)
            // common.holderKind (* must be allocated in non-moving area *)
               then ('AlloCOM',T[])->mch.callAlloPrim
       if)if);
   if)
#)
---ProtectCallReg:dopart---
do (if mch.callRegInPrimReg2 and mch.callRegBusy then 
       (false,true) -> mch.pushThisOrCall;
       INNER ProtectCallReg;
       (false,true) -> mch.popThisOrCall;
    else
       INNER ProtectCallReg
   if)
---GoOrigin:doPart---
do (# EH: @evalHandler;
      nextReceiver: ^text;
      reg1: @mch.adrRegOperand; 
      D: @ASTindex;
      gCom: com(# do '!goOrigin' -> T #);
   do (* thisA = start address for goOrigin
       * A1    = at entry a copy of thisA 
       *         later used as tmp. var
       * A2    = resulting address after goOrigin
       * Perhaps A1 and A2 may be eliminated and 
       * replaced by thisA!
       *)
      (if thisA.bAdr.LocalDesc[] = NONE then
          'Fatal Error "goOrigin": LocalDesc is NONE' 
            -> thisTranslate.systemException
      if);
      (if stest then
          301->cTrace
          (#
          do 'goOrigin: on='->xT; on->xI; 
             (if isOrigin then 'IsOrigin '-> xT if);
             xN;
             'thisA='->xT; thisA.display->xT; xN;
             'localDesc=' -> xT; xN;
             thisA.bAdr.localDesc[] -> xA;
          #)
      if);
      
      (if (thisA.bAdr.localDesc.label = gram.objectDescriptor) 
          and (thisA.bAdr.localDesc[] -> sematt.InlineNX) then 
          (* inlinenx may fail for non objectDesciptor;
           * see sematt:inlineNX
           *)
          on - 1 -> on
      if);
      &mch.RegAdr[] -> A2[];
      (if on > 0 then 
          (if thisA.bAdr.localDesc.label = gram.doPart then
              (* name in dopart slot *)
              8->A1.addoff       
           else
              thisA.bAdr.LocalDesc.originOff->A1.addOff->A1[];
          if);
          (* ByteCode: isOrigin is ALWAYS false *)
          (if isOrigin and (on = 1) then
              1 -> mch.initPrimCall;
              1 -> A1.toPrimDest;
              0-> mch.getPrimRes;
              (if not A1.frozenReg then 
                  A1.reg.dealloc;
                  (if (A1.reg <> mch.thisO) and (A1.reg<>mch.callO) then
                      '\n*** WARNING: here has been a recent bug-fix'
                      ' (7/10/01)'
                      '\n*** please report to support@mjolner.dk if you'
                      '\n*** think your code does not work here!'
                      '\n*** use "beta --tracecode"  to locate the code'
                      '\n*** giving this warning'
                      -> putline;
                      311->ctrace(#
                                 do 'dont work: webvise problem'->xT;
                                    mch.dumpreg
                                 #);
                  if);
              if);
              -11 -> A2.reg; (* hack *)
           else
              thisA.bAdr.localDesc -> D;
              (if (D.label=gram.objectDescriptor) (* discovered while
                                                   * testing newindex
                                                   *)
                  and ((D -> sematt.descKind) = sematt.stateKind) then
                  (if stest then
                      301->ctrace(#Do 'StateDesc1:'-> xT #)
                  if);
                  A1[] -> A2[]
               else
                  (* allocate reg1 - reuse register in A1 *)
                  (if A1.frozenReg then
                      reg1.alloc
                   else
                      A1.theReg -> reg1
                  if);
                  (if switch182 then
                      (1,A1[]) -> gCom;
                      true -> A1.isRef;
                      true -> A1.isOrigin;
                      (if not inEnterDoExitMethod then
                          A1.fieldType[] -> A1.descName[];
                          thisA.bAdr.LocalDesc[]
                            -> sematt.descOrigin 
                            -> EH.descName 
                            -> A1.fieldType[];
                      if);
                      (if A1.ONlevel > 0 then
                          '\n***ONlevel: ' -> puttext;
                          A1.ONlevel -> putint; newline
                       else
                          0 -> A1.ONlevel;
                  if)if);
                  (2,A1[]) -> gCom;
                  (A1[],reg1[]) -> mch.ldVal;                   
                  reg1->A2.reg; common.direct->A2.access;
                  (if switch182 then 1 -> A2.ONlevel if);
                  A1.fieldType[] -> A2.fieldType[];
                  A1.descName[] -> A2.descName[]
              if)
          if);
          (if switch182 then
              (if inEnterDoExitMethod then
                  thisA.bAdr.LocalDesc[] -> A2.bAdr.LocalDesc[]
               else
                  thisA.bAdr.LocalDesc[]
                    -> sematt.descOrigin
                    -> A2.bAdr.LocalDesc[]
              if)
           else
              thisA.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[]
          if);
          (3,A2[]) -> gCom;
       else
          (if stest then
              301->ctrace(#do 'goOrigin3:'->xT; reg1.display-> xT; mch.dumpreg #)
          if);
          (* copy A1 to the object denoted by A2; A1[] -> A2[] won't do, 
           * since
           * A2 is a reference to an object in machine:regAdr:goOrigin
           * and that object MUST be changed directly
           *)
          A1.reg -> A2.reg; A1.access -> A2.access; 
          A1.frozenReg -> A2.frozenReg;
          A1.off -> A2.off; (* not necessary; will be set to zero later?*)
          A1[] -> A2.bAdr.copy; (* ? *)
          
          thisA.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[];
              (*195->trace(# S: @text do A2.display -> S; S[] ->xT #);*)
      if);
      
      (for i: on - 1 repeat (* use dbb loop *)
           (if A2.bAdr.localDesc.label = gram.doPart then
               8->A2.off
            else
               A2.bAdr.localDesc.originOff->A2.off
           if);
           (if isOrigin and (i = on-1) then 
               (7,A2[]) -> gCom;
               1 -> mch.initPrimCall;
               1 -> A2.toPrimDest;
               0-> mch.getPrimRes;
               A2.reg.dealloc;
               -11 -> A2.reg; (* hack *)
            else
               (if (A2.bAdr.localDesc.label = gram.objectDescriptor)
                   and
                   ((A2.bAdr.localDesc-> sematt.descKind) = sematt.stateKind)
                   then
                   (if stest then
                       301->ctrace(#Do 'StateDesc2:'->xT #)
                   if)
                else
                   true -> A2.isRef;
                   (if switch182 then
                       true->A2.isOrigin;
                       A2.fieldType[] -> A2.descName[];
                       A2.bAdr.LocalDesc[]
                         -> sematt.descOrigin
                         -> EH.descName -> A2.fieldType[];
                       (4,A2[]) -> gCom;
                   if);
                   (if false (*common.switch[121]*) then
                       reg1.alloc;
                       (A2[],reg1[])->mch.ldVal;
                       A2.reg.deAlloc;
                       reg1 -> A2.reg
                    else
                       (A2[],reg1[])->mch.ldVal;
                   if);
                    (if switch182 (*bytecode*) then
                        A2.ONlevel + 1 -> A2.ONlevel;
                   if);
               if)
           if);
           A2.bAdr.LocalDesc[]->sematt.descOrigin->A2.bAdr.LocalDesc[];
           (5,A2[]) -> gCom;
      for);
      0 -> A2.off;
      thisA.size -> A2.size;
   #)
