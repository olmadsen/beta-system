ORIGIN 'genlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'signature';
include '../GENERATOR/asmlink';
BODY 'genlib_bytecode_body'
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     loadVal:: 
       (#do ((isMultiple,false,true,false,'',none)->eval).loadVal -> V[] #);
     loadVal2:: 
       (#do ((isMultiple,false,true,false,'',none)->eval).loadVal -> V[] #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          ((isMultiple,false,true,false,'',none)->eval).pushVal -> V[];
       #);
     mkReal::
       (#
       do ((isMultiple,false,true,false,'',none)->eval).mkReal -> V[];
       #);
     asgToAdr::
       (# EH: @evalHandler; isRepAdr: @boolean
       do 301->trace(#
                    do 'asgToAdr:'->display; 'rA: ' -> xT; rA.display-> xT
                    #);
          '!methodArgs:asgToAdr:'->mch.comment;
          (if isMultiple then
              'index'-> rA.fieldName.equal -> isRepAdr 
          if);
          (isMultiple,true,true,isRepAdr,'',none) -> eval -> V[];
          301->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display#);
          '!methodArgs:asgToAdr:before:V.pushVal'->mch.comment;
          '!methodArgs:asgToAdr:after:V.pushVal'->mch.comment;
          301->trace(#do 'methodArgs:asgToAdrY: '->xT; V.display#);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhpas be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          (if isMultiple and not isJava then mch.loadLocal if);
          301->trace(#
                    do 'methodArgs:asgToAdrZ: '->xT; 
                       (if V[] = none then
                           'V is None' -> xT
                        else
                           V.display
                       if)
                    #);
       #);
     asgToRefAdr::
       (# rA: ^mch.address; T: ^text
       do 301->trace(#do 'asgToRefAdr:'->display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2:'
            -> (rA.fieldType.copy).prepend -> T[];
            T -> mch.comment;
          (if destEv.label=gram.structureReference then
              'Structure'-> theGen.text2signature -> rA.fieldType[]
          if);
          (isMultiple,true,false,false,rA.fieldType[],rA.bAdr.localDesc[]) 
            -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          (*V.pushVal -> V[];*)
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (# T: ^text do rA.display->T[]; T -> mch.comment;#);
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
          '!methodArgs:asgToRefAdr5'->mch.comment;
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRealAdr::
       (#
       do 301 -> trace(#
                      do 'asgToRealAdr:'->display
                      #);
          rA[] 
            -> ((isMultiple,true,true,false,'',none) -> eval).asgToRealAdr
            -> V[];
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRepAdr::
       (#
       do 301->trace(#do 'asgToRepAdr:'->display; #);
          'methodArgs:asgToRepAdr1'->mch.comment;
          (isMultiple,false,false,false,'',sematt.repDesc[]) ->eval -> V[];
          'methodArgs:asgToRepAdr2'->mch.comment;
          (* V.pushVal -> V[];*)
          (rA[],rEV[],rChain[]) -> V.asgToRepAdr -> V[];
          'methodArgs:asgToRepAdr3'->mch.comment;
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToRepElm::
       (#
       do 301->trace(#
                    do 'asgToRepElm:'->display
                    #);
          (rA[],rEv[],rChain[])
          -> ((isMultiple,true,true,false,'',none)->eval).asgTorepElm
       #);
     asgToMethod::
       (# V: ^evVal
       do 301->trace(#do 'asgToMethod:'->display; #);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assignToList:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else          
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          301->trace(#do 'asgToMethod2:'->display;V.display #);
          (enterTypes,noOfArgs,next,rElm[],rChain[]) 
            -> V.asgToMethod
            -> next
       #);
     asgToList::
       (# A: ^mch.address
       do 301->trace(#do 'asgToList:'->display; #);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assignToList:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true,lChain[])
                -> ExpEval
                -> V[];
          if);
          (*V.loadVal -> V[];*)
          (*theGen.AllocAndstoreTmp -> A[];*)
          (BA[],EV[],rChain[]) -> V.asgToList
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 301->trace(#do 'asgToItem:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1,rDesc[],rChain[]) -> V.asgToMethod
          #)
       #);
     asgToExitArgs::
       (# V: ^evVal; xT: ^ExitTypes
       do (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (rDesc[],exitNo,originAdr[],rChain[]) 
            -> V.asgToExitArgs 
            -> (exitNo,xT[]);
          xT[] -> xTypes.concatenate -> xTypes[]
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePrimitive:opCode: ' -> xT; opCode->xI
                    #);
          (OpCode,I1,I2) -> (eval).asgToInlinePrimitive -> V[];
          301->trace(#
                    do 'asgToInlinePrimitive:after: '->xT;
                       V.display
                    #)
       #);
     asgToNewPrim::
       (#
       do 301->trace(#
                    do 'asgToNewPrim:'->display; ev[]->xA
                    #);
          (baseA[],ev[],rchain[]) -> (eval).asgToNewPrim -> V[]
       #);
     cmpBoolAndJmp:: (#do '\nOBS! cmpBoolAndJmp'->putline #);
     cmp:: (# do '\nOBS! cmp'->putline; #);
     adrCmp:: (# do '\nOBS! adrCmp'->putline; #);
     cstCmp:: (# do '\nOBS! cstCmp'->putline; #);
     regCmp:: (# do '\nOBS! regCmp'->putline; #);
     times:: (# do 301->trace(# do 'times'->display #) #);
     adrTimes:: (# do 301->trace(#do 'adrTimes'->display #) #);
     cstTimes:: (# do 301->trace(#do 'cstTimes'->display #) #);
     regTimes:: (# do 301->trace(# do 'regTimes'->display #) #);          
     eval: 
       (# dup,pushVal
          ,isSimpleVal
          ,isRepAdr: @boolean; (* this eval is assigned to R[e] and
                                * the address of R[e] is on the stack
                                *)
          V: ^evVal;
          rType: ^text;
          rDesc: ^ASTindex;
          isExternalString: @boolean
       enter(dup,pushVal,isSimpleVal,isRepAdr,rType[],rDesc[])
       do 301->trace(#
                    do 'eval:'->display; 
                       'dup: ' -> xT; dup->xB;
                       'pushVal:'->xT; pushVal->xB;
                       'isSimpleVal:' ->xT; isSimpleVal -> xB;
                       'isRepAdr:'->xT; isRepAdr -> xB;
                       'rType:'->xT; rType[] -> xT
                    #);
          'methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (if llEV[] <> none then
              (*1->trace(#
                      do 'eval:assign:'->xT; llEV.display; xN;
                         lEv[] -> xA
                      #);*)
	      (baseAdr[],llEv[],lEv[],true,lChain[])
                -> assignValToEval
                -> V[]
           else
              (baseAdr[],lEv[],true ,lChain[]) 
                -> ExpEval
                -> V[]
          if);
          (if (V.evType = 1 (* could be char*))
              and (rDesc[]<>none)
              and (sematt.repDesc->rDesc.equal) then
              (* could be 'a' -> R - in whihc case we should push 'a'
               * or R.foo -> R where foo returns a char literal and
               * here the value is already on the stack
               *)
             (* true -> pushVal -> isSimpleVal*)
          if);
          'methodArgs:eval:2'->mch.comment;
          (if V[] = none then '\nMethodArgs:eval:V is none ' -> putline if);
          301->trace(#do 'eval2:'->display; dup->xB; xN; V.display #);
          (if pushval then
              (* we need the rType here for text/const literals;
               * this is tricky and should be reconsidered;
               * also since dup_x1 does not exist on .NET
               *)
              (* reconsider structure of pushVal here and in txtcstval *)
              (rType[]<>none) 
              and ((isJava and ('java/lang/String' -> rType.equal)) 
                   or ('class [mscorlib]System.String'->rType.equal))
                -> isExternalString;
              (if isExternalString then
                  (* to avoid conversion to BETA text - clumsy *)
                  true -> V.pushVal -> V[]
               else
                  isSimpleVal -> V.pushVal -> V[]
              if);
              301->trace(#do 'eval3: V:'->display; V.display #);
              (if not isSimpleVal and not isExternalString then
                  V.mkBetatext; (* reconsider *)
              if)    
          if);
          (if dup then
              (if isJava then
                  (if isRepAdr then
                      (2,0) -> mch.duplicate
                   else
                      (if V.evType = 3 (* float *) then
                          (1,1) -> mch.duplicate
                       else
                          (1,0) -> mch.duplicate
                      if)
                  if)
               else
                  301->trace(#do 'eval4: V:'->display; V.display #);
                  (0,0) -> mch.duplicate;
                  V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
              if)
          if);
          (* FIXME: the following is very messsy *)
          (if (V.evType = 1 ) and false
              and (rDesc[]<>none) 
              and (sematt.repDesc->rDesc.equal) then
              'char2rep' -> mch.callPrim
           else
              (if not isSimpleVal
                  and (rType[]<>none) 
                  and (rType.length > 0) (* from asgToRep *)
                  and (V.evType<>4 (* strucref->Structure *))
                  and (rDesc[] <> none) and not (sematt.textDesc->rDesc.equal)
                  (* In X.get -> T[]
                   * get may return externalString
                   * and T may be a text;
                   * here we avoid a text-cast
                   * instead a coersion is made
                   * in textVarVal; but ugly
                   *)
                  and not (V.type -> theGen.mkSignature -> rType.equal) then
                  rType[] -> mch.checkCast
          if)if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex; (* isMultiple = true: lEv = EV1 -> EV2 -> ... *)
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean;
     llEV: ^evVal; (* llEV= none: do eval(lEv)
                    * llEV<>none: do lleV -> lEv
                    *)
  enter(baseAdr[],lEv[],lChain[],isMultiple,llEV[])
  exit this(methodArgs)[]
  #);
EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          'arg_' -> A.fieldName[];
          off -> A.fieldName.putint;
          (if class[] <> none then
              (if 'D' -> class.equal then
                  'D' -> A.fieldType[];
                  (A[],none) -> mch.ldVal;
                  (if isJava then
                      off+4 -> off -> A.off;
                  if);
               else
                  (A[],class[],none)->mch.loadRef
              if)
           else     
              'I' -> A.fieldType[];
              (A[],none) -> mch.ldVal
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRealAdr::
       (#
       do 'D' -> pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; RC: ^DH.superChain;
          rA,rAx: ^mch.address; destEval,dcl: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval;
          (if destEv.label = gram.structureReference then
              sematt.structureDesc -> dDesc;
           else
              (rChain[],destEval) 
                -> DH.theDesc 
                ->(dDesc,RC[]);
          if);
          dDesc[] 
            -> theGen.mkSignature 
            -> sourceClassName[] 
            -> destClassName[];
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          destEval.dclref -> dcl;
          dcl.gettext -> rA.fieldName[];
          &mch.RegAdr[] -> rAx[];
          (rAx[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          (if true then
              rA.fieldType[] 
                -> sourceClassName[] 
                -> destClassName[]
                -> pushNext; 
           else
              '[C' -> pushNext; 
              '[C' -> sourceClassName[] -> destClassName[];
          if);
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
     (*  insert::
      (#
      do '!enterArgs:insert:'->mch.comment;
      #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          301->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              (0,0) -> mch.duplicate; (* for execution of do-method *)
          if);
          (rDesc[],rChain[],false(*?*)) -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          'enter' -> sig.addMethod;  

          sig.scanEnter
          (# 
          do (if isRef then
                 'someClassOrArry' -> pushNext 
              else
                 pushNext
             if)
          #);
       #);
     asgToMethod::
       (#
       do '!enterArgs:asgToMethod:'->mch.comment;
          (for i: noOfArgs repeat
               (if enterTypes[next] 
                // 11 // 12 // 13 then
                   'SomeClass' -> pushNext
                // 6 (* real/double *) // 7 (* real32 *) then
                   'D' -> pushNext 
                else
                   pushNext 
               if);
               next + 1 -> next
          for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
          next + noOfArgs -> next 
       #);
     asgToList::
       (# 
       do EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(enterArgs)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
ExitMultiVal: evVal
  (# evId:: (# do 'ExitMultiVal:'->id[] #);
     asgToAdr::
       (# A: @mch.RegAdr;
       do (if tA[] = none then
              '\OBS! exitMultiVal:tA is none' -> putline;
              12 -> A.off;
              true -> A.isRef;
              (A[],&mch.adrRegOperand[]) -> mch.ldVal;
           else
              (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          if);
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;          
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;
       #);
     asgToRealAdr::
       (#
       do 301->trace(#
                    do 'asgToRealAdr'->display;
                    #);
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
          true -> rA.isField;
          (&mch.dataRegOperand[],rA[]) -> mch.stVal;          
       #);
     asgToRefAdr::
       (# A: @mch.RegAdr; aS,rA: ^mch.address; 
          destClass: ^text; withQua: @boolean;
       do (rAbase.copy,destEv.sonRef,false,rChain[])->genAdr->rA[];
          (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
          (mkA->aS[],&mch.adrRegOperand[]) -> mch.ldVal; 
          (*rAbase.copy -> rA[];*)
          
          true -> rA.isField;  
          true -> rA.isRef;
          (if destEv.label=gram.structureReference then
              'Structure'
                -> theGen.text2signature -> rA.fieldType[] -> destClass[]
           else
              rA.bAdr.localDesc[] 
                -> theGen.mkSignature -> rA.fieldType[] -> destClass[];
          if);
          (if (destClass[] <> none) and (aS.fieldType[] <> none) then
              not (destClass[] -> aS.fieldType.equal) -> withQua;
           else
              '\nOBS! destClass[]=none) or (aS.fieldType[]=none)'
                -> putline
          if);
          (&mch.adrRegOperand[],withQua,'???',destClass[])
            -> rA.asgRefReg
       #);
     asgToItem::
       (# EH: @EvalHandler;
          nScan: @ | EH.scanNadr; more: @boolean;
          A: @mch.RegAdr;
       do (*12 -> A.off;
          true -> A.isRef;*)
          (rDesc[],rA[],0,rChain[],true) 
               -> nScan -> more;
             L:
            (if more then
                (tA[],&mch.adrRegOperand[]) -> mch.ldVal;
                (mkA,&mch.dataRegOperand[]) -> mch.ldVal;
                nScan -> more;
                restart L
            if) 
       #);
     asgToList::
       (#
       do EV -> scanList
          (# E: @ASTindex
          do currentNode -> E;
             (BA[],this(exitMultiVal)[],E[],false,rChain[]) 
               -> AssignValToEval 
               -> V[];             
          #);
          (EV[],BA[],rChain[]) -> mkListVal -> V[]
       #);
     mkA: 
       (# T: @text; aD: @mch.RegAdr 
       do (*'XA:exitMultiVal:mkA:'->puttext;*)
          'exit_' -> T;
          exitNo -> T.putint;
          exitno + 1 -> exitNo;
          T[] -> aD.fieldName[];
          class[]
            -> aD.receiverType[];

          (if (elmDesc[] = none) or (elmDesc.isNull) then
              '\nOBS!ExitMultiVal: ElmDesc is none or null'->putline;
              (if common.switch[311] then
                  (failureTrace,'ExitMultiVal: ElmDesc is none or null')
                    -> stop;
              if);
              sematt.integerDesc[] -> theGen.mkSignature -> aD.fieldType[]
           else
              (if elmDesc.label <> gram.objectDescriptor then
                  '\nOBS!ExitMultiVal: ElmDesc is not descriptor'->putline
               else
                  elmDesc[] -> theGen.mkSignature -> aD.fieldType[];
          if)if);
          (*aD.fieldType[] -> puttext; ',' -> put;*)
          true -> aD.isField
       exit aD[]
       #);
     xA: @text;
     class: ^text;
     tA: ^mch.address; (* address tmp-var for object *)
     exitNo: @integer;
     elmDesc: ^ASTindex
  enter exitNo
  exit this(ExitMultiVal)[]
  #);

---theGenLib:attributes---
hasSlots: booleanValue
  (# desc: ^ASTindex; N: @ASTindex
  enter desc[]
  do 313->trace(#
               do 'hasSlots: '->xT; desc[] -> xA 
               #);
     (if desc.label = gram.objectDescriptor  then
         desc.son -> N; N.brother -> N;
         (if N.isSlot then
             (* main part slot *)
             true -> value
          else
             N.son -> N;     (* att-part*)
             N.brother -> N; (* action-part*)
             (if not N.isNull then
                 N.son -> N;     (* enter-part*)
                 N.brother -> N; (* do-part *)
                 N.isSlot -> value
         if)if)
         (* else perhaps slots and nameApls should be considered?*)
     if)
  #);
skipDesc: booleanValue
  (# desc: ^ASTindex
  enter desc[]
  do (if true
      // desc -> sematt.superObject.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.externalClassDesc.equal
      // desc -> sematt.procDesc.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.repDesc.equal
      // desc -> sematt.stateDesc.equal
      // desc -> sematt.dataDesc.equal
      // desc -> sematt.structureDesc.equal
         then (* skip *) true -> value
     if)
  #);   

initPtnGen:
  (# desc: ^ASTindex;
     R: ^ProtoType;
     isDoPartForm: @boolean
  enter(desc[],isDoPartForm)
  do &ProtoType[]->R[];
     ProtoHead[]->R.succ[];
     R[]->GS.thisPT[]->Protohead[];
     dynamicObj -> R.objKind; (* ??*)
     Desc->thisDesc; (* ugly *)
     (if not isDoPartForm then initGen if);
  #);
getNameAsText:
  (# den: ^ASTindex; D: @ASTindex; name: ^text
  enter den[]
  do (if den.label = gram.nameApl then
         den.getText -> name[]
      else
         den.son -> D;
         D[] -> getNameAsText -> name[];
         D.brother -> D;
         D.getText -> name.append
     if)
  exit name[]
  #);
descChain:
  (# desc: ^ASTindex; 
     pref: @ASTindex;
     superName: ^text;
     preName,superDesc: @ASTindex;
     subLevel: @integer
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         preName[] -> getNameAsText -> superName[];
         preName -> sematt.descChain -> (superDesc,subLevel); 
         (* One super : subLevel = 0
          * Two super : subLevel = 1
          * ...
          *)
         (if thisDesc->sematt.descKind
          // sematt.procKind 
          // sematt.classKind then
             (if subLevel = 0 then defaultSuperName -> superName[] if);
          // sematt.externalClassKind then
             (* level 0: externalClase : ( #  # )
              * level 1: foo: externalClass ( #   # )  - interface
              * level 2: bar: foo ( #   # )            - real
              * 
              * level 2 should be 0 (zero) since this is the
              * first real BETA subclass; subLevel fomr super
              * is 1; we thus always subtract 1
              *)
             subLevel - 1 -> subLevel
          else
             subLevel + 1 -> subLevel
         if);              
         313->trace(#
                   do 'superKind: ' -> xT; 
                      thisDesc->sematt.descKind -> sematt.kindAsText -> xT;
                      ' superName:'->xT; superName[] -> xT;
                      ' level:'->xT; subLevel -> xI; xN;
                   #)
      else
         defaultSuperName -> superName[];
         0 -> subLevel
     if);          
  exit(superName[],superDesc[],subLevel)
  #);
pushThis:
  (# thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  do true -> thisObj.isRef;      
     'this' 
       -> thisObj.fieldName[];
     (*  -> thisObj.descName[]  
      -> thisObj.receiverType[]; 
      true -> thisObj.isField;  *)   
     (thisObj[],ar[]) -> mch.ldVal
  #);
pushArg:
  (* Push arg1, arg2, ...
   * aNo in 1,2, ...
   * Use pushThis to push arg0 = this
   *)
  (# aNo: @integer;
     thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  enter aNo
  do true -> thisObj.isRef;  
     8 + aNo * 4 -> thisObj.off;
     'arg' 
       -> thisObj.fieldName[];
     (* -> thisObj.descName[] 
      -> thisObj.receiverType[]; 
      true -> thisObj.isField; *)
     aNo -> thisObj.fieldName.putint;
     (thisObj[],ar[]) -> mch.ldVal
  #);
AllocAndStoreTmp:
  (# type: ^ text; A: ^mch.RegAdr
  enter type[]
  do (if type[] = none then
         '\nOBS! AllocAnd StoreTmp: missing type' ->putline    
     if);     
     type[] -> mch.allocAndStoreLocal -> A[]
  exit A[]
  #);
newThisInstance: newInstance
  (#
  do pushThis;
  #);
newInstanceWithOrigin: 
  (# desc,objSpec,originDesc: ^ASTindex;
     nonLocal: @boolean;
     rA: ^mch.RegAdr
  enter(desc[],objSpec[],originDesc[],nonLocal)
  do (if not nonLocal then
         desc[] -> newThisInstance
      else
         desc[] -> newInstance
         (# OA: ^mch.address;
            EH: @evalHandler
         do (if hasOrigin then
                true -> inEnterDoExitMethod;
                originDesc -> thisDesc; (* ugly: thisDesc is used 
                                         * in genOrgAdrToOrgReg
                                         *)
                gen.thisRegAdr->rA[];
                (thisDesc[],true) -> EH.descName -> rA.fieldName[];
                (rA[],originDesc[],objSpec[]
                ,originDesc->DH.newSingle)
                  -> genOrgAdrToOrgReg 
                  -> OA[];
                desc -> thisDesc;
                false -> inEnterDoExitMethod;
            if)
         #)
     if)
  #);
virtualTopDesc:
  (# VD,topDesc: ^ASTindex; VN: @ASTindex; descKind: @integer
  enter VD[]
  <<SLOT genlib_virtualTopDesc:doPart>>
  exit topDesc[]
  #);
CallClassPtnMethod:
  (# OA: ^mch.address; VN,ES,topDesc: ^ASTindex; sig: @signature;
     EH: @evalHandler;
     sigT: ^text; sort: @ASTindex
  enter(VN[],OA[],ES[])
  <<SLOT genlib_CallClassPtnMethod:doPart>>
  exit sigT[]
  #);
LocalDescriptors:
  (* container used to collect nested patterns, etc.during GenAlloc *)
  (# methodList,classList,ptnList: [5] ^ASTindex; 
     mTop,cTop,pTop: @integer;
     
     addMethod:
       (# ES: ^ASTindex
       enter ES[]
       do (if (mTop+1->mTop) > methodList.range then
              methodList.range -> methodList.extend
          if);
          ES[] -> methodList[mTop][];
       #);
     addClass:
       (# ES: ^ASTindex
       enter ES[]
       do (if (cTop+1->cTop) > classList.range then
              classList.range -> classList.extend
          if);
          ES[] -> classList[cTop][];
       #);
     addPtn:
       (# ES: ^ASTindex
       enter ES[]
       do (if (pTop+1->pTop) > ptnList.range then
              ptnList.range -> ptnList.extend
          if);
          ES[] -> ptnList[pTop][];  
       #);
     save:
       (# E: ^ASTindex; ES: @ASTindex
       enter E[]
       do E -> ES;
          (if ES -> sematt.descKind
           // sematt.procKind then
              ES[] -> addMethod
           // sematt.classKind then
              ES[] -> addClass
           else
              ES[] -> addPtn;
              (if ES.label <> gram.nameApl then
                  ES[] -> addClass
          if)if)
       #);
     scanMethods:
       (# current: ^ASTindex
       do (for i: mTop repeat
               (* FIXME: foo*)
               methodList[i][] -> current[];
               313->trace(#do 'scanMethod:'->xT; current[]->xA#);
               (if current.label <> gram.nameApl then
                   INNER
                else
                   '\nShouldNotHappen: scanMethods:nameApl' -> putline
               if)
          for);
       #);
     scanPtns:
       (# current: ^ASTindex
       do (for i: pTop repeat
               (* FIXME: foo*)
               ptnList[i][] -> current[];
               (*313->trace(#do 'scanPtn:'->xT; current[]->xA#);*)
               INNER
          for);
       #);
     scanClasses:
       (# current: ^ASTindex
       do (for i: cTop repeat 
               (* FIXME: foo*)
               classList[i][] -> current[];
               313->trace(#do 'scanClass:'->xT; current[]->xA#);
               INNER
          for);
       #);
     
  #);
GenByteCodeAlloc: genAlloc
  (# saveLocalDesc:: (#do D[] -> locals.save#);
     locals: ^LocalDescriptors;
  enter locals[]
  #);


splitPathAndName:
  (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
  enter orgPath[]
  do orgPath.copy->path[];
     path.scanAll
     (# i: @integer 
     do i+1->i; 
        (if ch = '.' then i->dotPos 
         else 
            (if ch = thePathHandler.directoryChar then
                i -> slashPos
        if)if)
     #);
     (*'\nsplit1: ' -> puttext; path[] -> putline;*)
     
     (if dotPos > 0 then
         (dotPos,path.length)->path.delete
     if);
     (*'\nsplit2: ' -> puttext; path[] -> putline;*)
     (if slashPos > 0 then
         (slashPos+1,path.length)->path.sub -> FN[];
         (slashPos+1,path.length)->path.delete
     if);
     (*'\nsplit3: ' -> puttext; path[] -> putline;*)
  exit(path[],FN[])
  #);

scanFields:
  (# att: ^ASTindex; 
     dcl,N: @ASTindex;
     first: @boolean;
     end:< object;
  enter att[]
  do att -> scanList
     (# nameL: @ASTindex;        
     do currentNode -> dcl;
        (if not dcl.isSlot then
            dcl.son->nameL;
            true -> first;
            nameL->scanList
            (# 
            do currentNode -> N;
               INNER scanFields;
               false -> first
            #)
        if)
     #);
     end;
  #);
genFields: scanFields
  (# isMethodFields: @boolean; (* true: scanning fields of a method *)
  enter isMethodFields
  <<SLOT genlib_bytecode_genFields:doPart>>
  #);
declareFields:
  (# att,doP: ^ASTindex; isMethodFields: @boolean
  enter(att[],doP[],isMethodFields)
  <<SLOT genlib_bytecode_declareFields:doPart>>
  #);
InitGen:(* copy from gdbody - ugly *)
  (#
  do ThisDesc[]
       -> Sematt.descSonsRef
       -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
     ThisDesc.originOff -> ThisDescOrgOff;
     (pref.label = gram.prefix) -> hasPref; 
     ThisDesc.attSize -> attSize -> offCount;
     ThisDesc.descId -> (thisForm[],ThisDescNo);
     thisForm.makeUC;
     false -> GS.insSwitch -> returnSaved; 
     0 -> GS.insOff; 
     GS.insStack.init;
     NONE-> externalEntryLab[];
  #);
callNDX:
  (# desc: ^ASTindex;
     method: ^text;
     sig: ^Signature;
     class: ^text;
     noNsig,noXsig: @boolean;
     EH: @evalHandler
  enter(desc[],method[],sig[],noNsig,noXsig)
  do ((desc[],true) -> EH.descName,desc[]) -> sig.addReceiver;
     (* should be cleaned up with a nicer interface *)
     desc[] -> descLocation -> sig.location[];
     (if sig.location[] <> none then sig.location[] -> mch.import if);
     method[] -> sig.addMethod;
     (noNsig, noXsig) -> sig.asText -> class[];
     (class[]->mch.newTextOp,'M',true,false)->mch.gJsr;
  #);

methodAndInnerName:
  (# methodName,innerName: ^text; subLevel: @integer
  enter(methodName[],subLevel)
  do methodName.copy -> innerName[];     
     (if subLevel > 0 then
         '_' -> methodName.put;
         subLevel -> methodName.putInt
     if);
     '_' -> innerName.put;
     subLevel + 1 -> innerName.putInt
  exit(methodName[],innerName[])
  #);

genSuper:
  (* void  init(org)
   * 
   *    loadThis
   *    compute & push origin for super
   *    call init
   *    store origin for this
   *)
  (# pref,originDesc: ^ASTindex;
     subLevel: @integer;
     preDen: @ASTindex;
     preBase,A: ^mch.address;
     T: @text; EH: @evalHandler; 
     orgDescName: ^text;
     chain: ^DH.SuperChain;
     aR: @mch.adrRegOperand;
     preBAseX: @mch.RegAdr;
     isSpecial: @boolean; preDescOrg,realpre: ^ASTindex;
     constructorDesc: ^ASTindex;
     isDefaultConstructor: @boolean
  enter(pref[],subLevel)
  <<SLOT genSuper:doPart>>
  exit(constructorDesc[],isDefaultConstructor)
  #)




