ORIGIN 'genlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'signature';
include '../GENERATOR/asmlink';
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          (isMultiple->eval).pushVal -> V[];
       #);
     asgToAdr::
       (# EH: @evalHandler
       do 313->trace(#do display; #);
          '!methodArgs:asgToAdr:'->mch.comment;
          isMultiple -> eval -> V[];
          313->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display#);
          '!methodArgs:asgToAdr:before:V.pushVal'->mch.comment;
          true -> V.pushVal -> V[];
          '!methodArgs:asgToAdr:after:V.pushVal'->mch.comment;
          313->trace(#do 'methodArgs:asgToAdrY: '->xT; V.display#);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhpas be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          313->trace(#do 'methodArgs:asgToAdrZ: '->xT; V.display#);
       #);
     asgToRefAdr::
       (# rA: ^mch.address
       do 313->trace(#do 'asgToRefAdr:'->xT; display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2'->mch.comment;
          isMultiple -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          V.pushVal -> V[];
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr;
          '!methodArgs:asgToRefAdr5'->mch.comment;
       #);
     asgToRepAdr::
       (#
       do 313->trace(#do 'asgToRepAdr:'->xT; display; #);
          (rA[],rEV[],rChain[]) -> (eval).asgToRepAdr
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToMethod::
       (# V: ^evVal
       do 313->trace(#do 'asgToMethod:'->xT; display; #);
          (baseAdr[],lEv[],false,lChain[])
            -> ExpEval
            -> V[];
          (enterTypes,noOfArguments,next) -> V.asgToMethod
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 313->trace(#do 'asgToItem:'->xT; display; #);
          (baseAdr[],lEv[],false,lChain[])
            -> ExpEval
            -> V[];
          rDesc[] -> sig.setDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1) -> V.asgToMethod
          #)
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do (if not common.switch[188] then
              '\nOBS! methodArgs:asgToInlinePrimitive'->putline;
          if);
          this(methodArgs)[] -> V[] (*???*)
       #);
     asgToNewPrim::
       (#
       do eval -> V[];
          (baseA[],ev[],rchain[]) -> V.asgToNewPrim -> V[]
       #);
     eval: 
       (# dup: @boolean;
          V: ^evVal
       enter dup
       do '!methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (baseAdr[],lEv[],true ,lChain[]) 
            -> ExpEval
            -> V[];
          '!methodArgs:eval:2'->mch.comment;
          (if dup then
              1 -> mch.duplicate
          if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex;
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean
  enter(baseAdr[],lEv[],lChain[],isMultiple)
  exit this(methodArgs)[]
  #);
EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          (if class[] <> none then              
              (A[],class[],none)->mch.loadRef
           else              
              (A[],none) -> mch.ldVal
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; mn,dKind: @integer; RC: ^DH.superChain;
          rA: ^mch.address; destEval: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval; 
          (rChain[],destEval) 
            -> DH.theDesc 
            ->(dDesc,mn,RC[],dKind);
          (if true then
              dDesc[] -> theGen.mkSignature -> sourceClassName[] -> destClassName[];
           else
              (dDesc[],true) -> descName -> sourceClassName[] -> destClassName[];
          if);
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          '[C' -> pushNext; 
          '[C' -> sourceClassName[] -> destClassName[];
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
   (*  insert::
       (#
       do '!enterArgs:insert:'->mch.comment;
       #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          313->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              mch.duplicate; (* for execution of do-method *)
          if);
          rDesc[] -> sig.setDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          'enter' -> sig.addMethod;  

          sig.scanEnter(# do pushNext #);
          (if false then 
              (rDesc[],'enter',sig[],false,true) -> theGen.callNDX
          if)
       #);
     asgToMethod::
       (#
       do '!enterArgs:asgToMethod:'->mch.comment;
          (for i: noOfArgs repeat pushNext for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
---theGenLib:attributes---
skipDesc: booleanValue
  (# desc: ^ASTindex
  enter desc[]
  do (if true
      // desc -> sematt.superObject.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.externalClassDesc.equal
      // desc -> sematt.procDesc.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.repDesc.equal
         then (* skip *) true -> value
     if)
  #);   

initPtnGen:
  (# desc: ^ASTindex;
     R: ^ProtoType;
     isDoPartForm: @boolean
  enter(desc[],isDoPartForm)
  do &ProtoType[]->R[];
     ProtoHead[]->R.succ[];
     R[]->GS.thisPT[]->Protohead[];
     dynamicObj -> R.objKind; (* ??*)
     Desc->thisDesc; (* ugly *)
     (if not isDoPartForm then initGen if);
  #);
getNameAsText:
  (# den: ^ASTindex; D: @ASTindex; name: ^text
  enter den[]
  do (if den.label = gram.nameApl then
         den.getText -> name[]
      else
         den.son -> D;
         D[] -> getNameAsText -> name[];
         D.brother -> D;
         D.getText -> name.append
     if)
  exit name[]
  #);
defaultSuperName:
  (# superName: ^text
  do (if true
      // common.targetMachineId = common.javabc then
         'java/lang/Object'->supername[];
      // common.targetMachineId = common.dotnet then
         '[mscorlib]System.Object'->supername[]; (*'/*1*/'->supername.append;*)
         (*'object' -> supername[];*)
      else
         'Unknown_platform.Object' -> supername[];
     if);
  exit superName[]
  #);
descChain:
  (# desc: ^ASTindex; 
     pref: @ASTindex;
     superName: ^text;
     preName,superDesc: @ASTindex;
     subLevel: @integer
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         preName[] -> getNameAsText -> superName[];
         preName -> sematt.descChain -> (superDesc,subLevel); 
         (* One super : subLevel = 0
          * Two super : subLevel = 1
          * ...
          *)
         (if thisDesc->sematt.descKind
          // sematt.procKind 
          // sematt.classKind then
             (if subLevel = 0 then defaultSuperName -> superName[] if);
          // sematt.externalClassKind then
             (* level 0: externalClase : ( #  # )
              * level 1: foo: externalClass ( #   # )  - interface
              * level 2: bar: foo ( #   # )            - real
              * 
              * level 2 should be 0 (zero) since this is the
              * first real BETA subclass; subLevel fomr super
              * is 1; we thus always subtract 1
              *)
             subLevel - 1 -> subLevel
          else
             subLevel + 1 -> subLevel
         if);              
         313->trace(#
                   do 'superKind: ' -> xT; 
                      thisDesc->sematt.descKind -> sematt.kindAsText -> xT;
                      ' superName:'->xT; superName[] -> xT;
                      ' level:'->xT; subLevel -> xI; xN;
                   #)
      else
         defaultSuperName -> superName[];
         0 -> subLevel
     if);          
  exit(superName[],superDesc[],subLevel)
  #);
pushThis:
  (# thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  do true -> thisObj.isRef; (thisObj[],ar[]) -> mch.ldVal
  #);
pushArg:
  (* Push arg1, arg2, ...
   * aNo in 1,2, ...
   * Use pushThis to push arg0 = this
   *)
  (# aNo: @integer;
     thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  enter aNo
  do true -> thisObj.isRef;  
     8 + aNo * 4 -> thisObj.off;
     (thisObj[],ar[]) -> mch.ldVal
  #);
newInstance:
  (# desc,orgDesc: ^ASTindex; 
     class,orgName: ^text; 
     EH: @evalHandler;
     hasOrigin,local: @boolean;
  enter desc[]
  do ('G',desc[]) -> mkEntryPoint -> (class[],local);
     
     (if (desc.label = gram.objectDescriptor)
         and ((desc -> sematt.descKind) = sematt.externalClassKind)
             and
             not (desc[] -> isBETAsubOfExternalClass) then
         '-' -> orgName[];
      else
         (if true
          // 'java/lang/Object'-> class.equal
          // 'object' -> class.equal then
             '-' -> orgName[];
             '\nNewInstance: ' -> puttext; class[] -> puttext;
             ' will probably not work' -> putline
          else
             true -> hasOrigin;
             (if desc.label = gram.unExpanded then
                 (desc[]-> sematt.encDesc,true)
                   -> EH.descName 
                   -> orgName[]
              else
                 desc[] -> sematt.descOrigin -> orgDesc[];
                 (if orgDesc.isNull then
                     (*'\n***OriginDesc is null (betaenv?)' -> putline;*)
                     defaultSuperName -> orgName[]
                  else
                     (orgDesc[],true) -> EH.descName -> orgName[]
     if)if)if)if);
     313->trace(#
               do 'newInstance:originName:' -> xT; orgName[] -> xT; xN;
                  desc[] -> xA; xN;
                  'origin:'->xT; xN; orgDesc[] -> xA
               #);
     
     (if true 
      // common.targetMachineId = common.javabc then
         (desc[],common.itemKind) -> doLoadProtoAndAlloc;
         (if hasOrigin then INNER; (* push origin *) if);
         ('init',((orgDesc[],orgName[])->ClassSignature).asText)
           ->mch.callAlloPrim;
      // common.targetMachineId = common.dotnet then
         (if hasOrigin then INNER; (* push origin *) if);
         (desc[],common.itemKind) -> doLoadProtoAndAlloc;
         ('init',((orgDesc[],orgName[])->ClassSignature).asText)->mch.callAlloPrim;
      else
         'newInstance: unknown platform' -> thisTranslate.systemException
     if)
  #);
newThisInstance: newInstance
  (#
  do pushThis;
  #);
newInstanceWithOrigin: 
  (# desc,objSpec,originDesc: ^ASTindex;
     nonLocal: @boolean
  enter(desc[],objSpec[],originDesc[],nonLocal)
  do (if not nonLocal then
         desc[] -> newThisInstance
      else
         desc[] -> newInstance
         (# OA: ^mch.address
         do true -> inEnterDoExitMethod;
            originDesc -> thisDesc; (* ugly: thisDesc is used 
                                     * in genOrgAdrToOrgReg
                                     *)
            (gen.thisRegAdr,originDesc[],objSpec[]
            ,originDesc->DH.newSingle)
              -> genOrgAdrToOrgReg 
              -> OA[];
            desc -> thisDesc;
            false -> inEnterDoExitMethod;
         #)
     if)
  #);
LocalDescriptors:
  (* container used to collect nested patterns, etc.during GenAlloc *)
  (# methodList,classList,ptnList: [5] ^ASTindex; 
     mTop,cTop,pTop: @integer;
     
     addMethod:
       (# ES: ^ASTindex
       enter ES[]
       do (if (mTop+1->mTop) > methodList.range then
              methodList.range -> methodList.extend
          if);
          ES[] -> methodList[mTop][];
       #);
     addClass:
       (# ES: ^ASTindex
       enter ES[]
       do (if (cTop+1->cTop) > classList.range then
              classList.range -> classList.extend
          if);
          ES[] -> classList[cTop][];
       #);
     addPtn:
       (# ES: ^ASTindex
       enter ES[]
       do (if (pTop+1->pTop) > ptnList.range then
              ptnList.range -> ptnList.extend
          if);
          ES[] -> ptnList[pTop][];  
       #);
     save:
        (# E: ^ASTindex; ES: @ASTindex
        enter E[]
        do E -> ES;
           (if ES -> sematt.descKind
            // sematt.procKind then
               ES[] -> addMethod
            // sematt.classKind then
               ES[] -> addClass
            else
               ES[] -> addPtn;
               ES[] -> addClass
           if)
        #);
     scanMethods:
       (# current: ^ASTindex
       do (for i: mTop repeat
               (* FIXME: foo*)
               methodList[i][] -> current[];
               313->trace(#do 'scanMethod:'->xT; current[]->xA#);
               INNER
          for);
       #);
     scanPtns:
       (# current: ^ASTindex
       do (for i: pTop repeat
               (* FIXME: foo*)
               ptnList[i][] -> current[];
               (*313->trace(#do 'scanPtn:'->xT; current[]->xA#);*)
               INNER
          for);
       #);
     scanClasses:
        (# current: ^ASTindex
        do (for i: cTop repeat 
               (* FIXME: foo*)
               classList[i][] -> current[];
               313->trace(#do 'scanClass:'->xT; current[]->xA#);
               INNER
          for);
        #);
     
  #);
GenByteCodeAlloc: genAlloc
  (# saveLocalDesc:: (#do D[] -> locals.save#);
     locals: ^LocalDescriptors;
  enter locals[]
  #);
     

splitPathAndName:
  (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
  enter orgPath[]
  do orgPath.copy->path[];
     path.scanAll
     (# i: @integer 
     do i+1->i; 
        (if ch = '.' then i->dotPos 
         else 
            (if ch = thePathHandler.directoryChar then
                i -> slashPos
        if)if)
     #);
     (*'\nsplit1: ' -> puttext; path[] -> putline;*)
     
     (if dotPos > 0 then
         (dotPos,path.length)->path.delete
     if);
     (*'\nsplit2: ' -> puttext; path[] -> putline;*)
     (if slashPos > 0 then
         (slashPos+1,path.length)->path.sub -> FN[];
         (slashPos+1,path.length)->path.delete
     if);
     (*'\nsplit3: ' -> puttext; path[] -> putline;*)
  exit(path[],FN[])
  #);

scanFields:
  (# att: ^ASTindex; 
     dcl,N: @ASTindex;
     first: @boolean;
     end:<object;
  enter att[]
  do att -> scanList
     (# nameL: @ASTindex;
        
     do currentNode -> dcl;
        (if not dcl.isSlot then
            dcl.son->nameL;
            true -> first;
            nameL->scanList
            (# 
            do currentNode -> N;
               inner scanFields;
               false -> first
            #)
        if)
     #);
     end;
  #);
genFields: scanFields
  (# spec,desc,AD: @ASTindex; descKind: @integer; sig: ^text;
     EH: @EvalHandler;
     ftag: ^text;
     isMethodFields: @boolean; (* true: scanning fields of a method *)
     declareRef:
       (# desc: ^ASTindex
       enter desc[]
       do (if true then
              desc[] -> mkSignature -> sig[];
           else
              (desc[],true) -> EH.descName -> sig[];
          (if 'object'->sig.equalNCS then
              (if true
               // common.targetMachineId = common.javabc then
                  'java/lang/Object'->sig;
               // common.targetMachineId = common.dotnet then
                  '[mscorlib]System.Object'->sig; (*'/*2*/'->sig.append;*)
               else
                  'Unknown_platform.Object' -> sig;
              if);
          if);
          (if common.targetMachineId = common.javabc then
              'L'->sig.prepend; ';'->sig.append;
          if);
          if);
          (N.off,sig[],fTag[]) -> mch.emitCk (* hack *)
       #)
  enter isMethodFields
  do (if isMethodFields then 'm'->fTag[] else 'c' -> fTag[] if);
     (* fTag and emitCk should be replaced by a cleaner and
      * more efficient solution
      *)
     (if dcl.label
      // gram.simpleDecl then
         dcl.son -> spec;
         spec.brother -> spec;
         spec.son -> AD;
         (if AD.label = gram.objectDescriptor then
             (* we need to push here to get the descriptor
              * properly marked - however, if desName
              * returns static item name this may not
              * be needed
              *)
             (if first then (AD,0,1,N) -> DS.push if);
             AD -> desc
          else
             (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
         if);
         
         (if spec.label 
          // gram.dynamicItem then
             desc[] -> declareRef
          // gram.staticItem then
             desc->sematt.descKind->descKind; (* descKind from actualDesc
                                               * don't work? *)
             (if desc.label
              // gram.objectDescriptor then
                 (if descKind 
                  // sematt.standardKind then                     
                     (N.off,(desc[] -> valueSignature).asText,fTag[]) 
                       -> mch.emitCk (* hack *)
                  // sematt.generalKind 
                  // sematt.classKind then
                     (* part object: we need origin type and
                      * handle to generate origin code
                      *)
                     'p'-> fTag; (* part object *)
                     desc[] -> declareRef
                  else
                     (if not common.switch[188] then
                         '\n***GenAlloc: unsupported static data-item'->putline
                 if)if)
              else
                 (if not common.switch[188] then
                     '\n***GenAlloc: unsupported static data-itemX'->putline
             if)if)
          else
             (if not common.switch[188] then
                 '\n***GenAlloc:unsupported simple data-item'->putline
         if)if)
      // gram.repetitionDecl then
         (if not common.switch[188] then
             '\n***GenAlloc: repetitions are incomplete!'->putline;
         if);
         (* unify with simpleDecl *)
          dcl.son -> spec;
         spec.brother -> spec;
         spec.brother -> spec;
         spec.son -> AD;
         (if AD.label = gram.objectDescriptor then
             (* we need to push here to get the descriptor
              * properly marked - however, if desName
              * returns static item name this may not
              * be needed
              *)
             (if first then (AD,0,1,N) -> DS.push if);
             AD -> desc
          else
             (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
         if);
         
         (N.off,(desc[] -> valueSignature).asText,'[') 
           -> mch.emitCk 
     if)
  #);
declareFields:
  (# att,doP: ^ASTindex; isMethodFields: @boolean
  enter(att[],doP[],isMethodFields)
  do (att[],isMethodFields) -> genFields
      (# end::
           (# as: ^ast; exp: ^expanded; off: @integer
           do (* declare index and range from for-imps;
               * preliminary
               *)
              313->trace(#
                        do 'declareFields:for:'->xT; doP[] -> xA
                        #);
              (if true then
                  doP.asAst -> as[];
                  (if as## <= expanded## then
                      as[] -> exp[];
                      gram.forImp -> exp.suffixWalkForProd
                      (# thisFor: @ASTindex
                      do (*'got:for:' -> putText;*)
                         current[] -> astAsAstIndex -> thisFor;
                         (if thisFor.label = gram.forImp then
                             313->trace(#
                                       do 'imp:'->xT; thisFor[] -> xA; xN;
                                          1->thisFor.getAttribute->off;
                                          'off:'->xT; off -> xI
                                       #);
                             (1->thisFor.getAttribute->off,'I',fTag[]) 
                               -> mch.emitCk;
                             (off+4,'I',fTag[]) -> mch.emitCk
                         if);
                  #)if)
               else
                  doP->scanList
              (# imp: @ASTindex; off: @integer
              do currentNode -> imp;
                 (if imp.label = gram.forImp then
                     313->trace(#
                               do 'dclFields:for:'->xT;
                                  1->imp.getAttribute->xI
                               #);
                     (1->imp.getAttribute->off,'I',fTag[]) -> mch.emitCk;
                     (off+4,'I',fTag[]) -> mch.emitCk
                 if)
              #);
              if);
              (if isMethodFields then
                  (0,'','M') -> mch.emitCk
               else
                  (0,'','C') -> mch.emitCk
              if)
           #)
      #);
  #);
XXinitFields: scanFields (* not used anymore *)
  (# A: ^mch.regAdr
  do (if dcl.label
      // gram.simpleDecl then
         N.off -> gen.thisRegAdr -> A[]; (*true -> A.isField;*)
         (0->mch.newCstOp,A[],N.size) -> mch.stCst
     if)
  #); 
InitGen:(* copy from gdbody - ugly *)
  (#
  do ThisDesc[]
       -> Sematt.descSonsRef
       -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
     ThisDesc.originOff -> ThisDescOrgOff;
     (pref.label = gram.prefix) -> hasPref; 
     ThisDesc.attSize -> attSize -> offCount;
     ThisDesc.descId -> (thisForm[],ThisDescNo);
     thisForm.makeUC;
     false -> GS.insSwitch -> returnSaved; 
     0 -> GS.insOff; 
     GS.insStack.init;
     NONE-> externalEntryLab[];
  #);
callNDX:
  (# desc: ^ASTindex;
     method: ^text;
     sig: ^Signature;
     class: ^text;
     noNsig,noXsig: @boolean;
     EH: @evalHandler
  enter(desc[],method[],sig[],noNsig,noXsig)
  do (if desc-> sematt.superObject.equal then
         '\nNo call of: ' -> puttext;
         method[] -> puttext; 
         ' generated for "object"' -> putline
      else
         (desc[],true) -> EH.descName -> sig.addReceiver;
         method[] -> sig.addMethod;
         (noNsig, noXsig) -> sig.asText -> class[];
         (class[]->mch.newTextOp,'M',true,false)->mch.gJsr;
     if)
  #);

isBETAsubOfExternalClass: booleanValue
  (* test if desc is an interface to an external class
   * or a real BETA subclass of an externalclass.
   * if interface then no code should be generated;
   * if 'real' then code should be generated.
   * As a simple hack, a direct subclass of externalClass
   * is considered to be an interface.
   * Subclasses at level 2 and below are considerered 'real'.
   * A better means for specifying interface og real
   * should be invented
   *)
  (# desc: ^ASTindex;
     pref,preName,preDesc: @ASTindex;
     subLevel: @integer;
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         313 -> ctrace(#
                      do 'isBetaSubOfExternalClass:super:' -> xT;
                         preName.gettext -> xT
                      #);
         preName -> sematt.descChain -> (preDesc,subLevel);
         subLevel > 0 -> value;
     if)        
  #);
     
methodAndInnerName:
  (# methodName,innerName: ^text; subLevel: @integer
  enter(methodName[],subLevel)
  do methodName.copy -> innerName[];     
     (if subLevel > 0 then
         '_' -> methodName.append;
         subLevel -> methodName.putInt
     if);
     '_' -> innerName.append;
     subLevel + 1 -> innerName.putInt
  exit(methodName[],innerName[])
  #);

genSuper:
  (* void  init(org)
   * 
   *    loadThis
   *    compute & push origin for super
   *    call init
   *    store origin for this
   *)
  (# pref,originDesc: ^ASTindex;
     subLevel: @integer;
     preDen: @ASTindex;
     preBase,A: ^mch.address;
     T: @text; EH: @evalHandler; 
     orgName,orgDescName: ^text;
     chain: ^DH.SuperChain;
     aR: @mch.adrRegOperand;
     preBAseX: @mch.RegAdr;
     callInit:
       (# orgName: ^text
       enter orgName[]
       do 'call init/cons' -> mch.comment;
          PushThis;
          (if not ('-'->orgName.equal) then
              'origin for superQ1:'->mch.comment;
              1 -> PushArg; (* stack holds origin for this desc *)
              INNER callInit;
              (* we need to compute origin from arg1 *)
              
              (* datpete: 17/05/2002: *)
              ((originDesc[],orgName[])->ClassSignature).asText -> orgName[];
          if);
          ('initSuper',orgName[])->mch.callAlloPrim; 
       #);
     storeOrigin:
       (#
       do 'store origin' -> mch.comment;
          (* store origin for this;
           * origin is the argument of init/cons *)
          PushThis;
          1 -> PushArg;
         
          (*prefDesc.originOff->*) Gen.ThisRegAdr-> A[];
          1 -> A.ONlevel;
          true -> A.isOrigin;
          (thisDesc[],true) -> EH.descName -> A.descName[];
          true -> A.isField;
          (* common.cstInd -> preBase.access;*)
          'new storeorigin1'->mch.comment;
          (if (originDesc[] <> none) and not originDesc.isNull then
              (if true then
                  originDesc[] -> mkSignature -> orgDescName[]
               else
                  (originDesc[],true)
                    -> EH.descName 
                    -> orgDescName[];
              if)
           else
              (if true then
                  sematt.superObject[] -> mkSignature -> orgDescName[]
              else
                  defaultSuperNAme -> orgDescName[]
              if);
          if);
          313 -> trace(#
                      do 'storeOrigin:orgDescName:'->xT; 
                         orgDescName[] -> xT; xN;
                         'A.descName:'->xT; A.descName[] -> xT; xN;
                         originDesc[] -> xA
                      #);
          'orgDescName:'->mch.comment;
          orgDescname -> mch.comment;
          (none,false,'source',orgDescName[]) -> A.asgRefReg;
       #);
     genDefaultSuper:
       (# N: ^text
       do thisDesc[] -> sematt.descOrigin -> originDesc[]; 
          '-' -> callInit;
          313->trace(#
                    do 'genDefaultSuper:'->xT; xN;
                       thisDesc[] -> xA; xN;
                    #);
          storeOrigin
       #) 
  enter(pref[],subLevel)
  do 313->trace(#
               do 'genSuper:'->xT;
                  (if haspref then pref[] -> xA
                   else 'no super'->xT
                  if); 
                  xN;                  
               #);
     SaveReturn:
       (true,thisDesc.returnOff)->mch.SaveReturn;
     true -> ReturnSaved;
     
     (if hasPref and (subLevel > 0) then   
         (* hasPref and (sublevel = 0)
          * is a subclass of externalClass
          *)
         pref.son -> preDen -> SemAtt.descrip -> prefDesc;
         (if true 
          // prefDesc -> sematt.procDesc.equal
          // prefDesc -> sematt.classDesc.equal then
             genDefaultSuper;
             leave genSuper
         if);
         Gen.ThisRegAdr -> preBase[];
         12 -> preBase.addOff -> preBase[];
         thisDesc[]
           -> sematt.descOrigin
           -> originDesc[];
         
         (if false (* isSpecialVirtual *) then
          else
             (* overvej *)
             thisDesc[]
               -> sematt.descOrigin
               -> originDesc[]
               -> preBase.bAdr.LocalDesc[];
             thisSuperChain->chain[];
                chain[]->DH.ENC->chain[];
             (* NOTE: We enter the empty string '' as orgName,
              * and redefined orgName in the do-part below;
              * we need to reconsider the abstraction
              *)
             ''-> callInit
             (#
             do 311->trace(#
                          do 'genSuper:callInit: ' -> xT; preDen[] -> xA; xN;
                             'localDesc:' -> xT;
                             preBase.bAdr.localDesc[] -> xA
                          #);
                true -> preBase.isOrigin;
                2 -> prebase.ONlevel;
                (preBase[],originDesc[],preDen[],chain[])
                  -> genOrgAdr
                  -> preBase[];
                 (preBase.bAdr.localDesc[],true)
                  -> EH.descName 
                  -> orgName[];
                311->trace(#
                          do 'genSuper:callInit:2 ' -> xT; xN;
                             'localDesc:' -> xT;
                             preBase.bAdr.localDesc[] -> xA; xN;
                             'orgName: ' -> xT; orgName[] -> xT
                          #);
                
             #)
         if);
         storeOrigin;
      else
         genDefaultSuper
     if)
  #);
---genPtnMethod:doPart---
   (* Calling a general pattern as a method
    * 
    * Simple form
    *    .method foo(x1x2x3)y
    *       new foo
    *       push x1
    *       push x2
    *       push x3
    *       call foo/do(x1x2x3)y
    *       zreturn
    *  General form
    *       new foo
    *       store R
    *       load R
    *       push x1
    *       push x2
    *       push x3
    *       call foo/enter(x1,x2,x3)V
    *       call foo/do()V
    *       call foo/exit()y
    *       zreturn
    *)
do (# sig: @Signature;
      hasNcode,hasDoCode,hasXcode: @boolean;
      exitId: @integer;
      EH: @evalHandler;
      exitVal: ^ASTindex;
      EVL,EV: @ASTindex; V: ^EH.evVal;
      orgName: ^text;
      theDesc,objSpec,D,pref,topSuperName: @ASTindex;
      descKind,subLevel
      : @integer;
      nonLocal: @boolean
   do 311->trace(#
                do 'genPtnMethod: '->xT; patternName[] -> xT; xN;
                   'desc: ' -> xT; desc[] -> xA;
                   'topDesc:' -> xT; topDesc[] -> XA;
                #);
      desc -> objSpec;
      (if desc.label 
       // gram.objectDescriptor 
       // gram.unExpanded then
       else
          true -> nonLocal;
          (thisDesc[](*?*),desc[])
            -> GetActualDesc 
            -> (D,descKind);
          &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
          D -> desc;
          none -> topDesc[]
      if);
      (if topDesc[] = none then
          desc.son -> pref;
          &ASTindex[] -> topDesc[]; (* prevent aliasing *)
          (if pref.label = gram.prefix then
              pref.son -> topSuperName;
              topSuperName -> sematt.descChain -> (topDesc,subLevel)
           else
              desc -> topDesc;
      if)if);
      desc -> theDesc;
      (if desc.isSlot then 
          (*'\n*** OBS! Slots are not handled by genPtnMethod: '->puttext;
          patternName[] -> putline;*)
          sig.noEnter;
          sig.exitVoid;
          true -> hasDoCode
       else
          (desc[],false) -> initPtnGen;
          313->trace(#
                    do 'genPtnMethod:doPart: '->xT; patternName[]->xT; xN; 
                       doP[] -> xA
                    #);
          (* if we add a construtor possibility to BETA;
           * we must get the signature from the constructor
           * of the pattern
           *)
          enterP.label <> gram.empty -> hasNcode;
          exitP.label <> gram.empty -> hasXcode;
          
          thisDesc[] -> sig.setDesc;
          (if isStatic then sig.markStatic if);
          thisDesc[] -> sig.addEnter;
          exitP[] -> sig.addExit;
          topDesc[]  -> sematt.hasDo -> hasDoCode
      if);
      patternName[] -> sig.addMethod;
      sig.exitId -> exitId;
      sig.exitVal[] -> exitVal[];
      
      sig.exitVal[] <> none -> hasXcode; (* note we override hasXcode
                                          * above; exitP is only for
                                          * the mainpart; possible exitlist
                                          * in superpatterns are not
                                          * handled
                                          *)
      
      (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
        -> mch.initDo;       
          (* Consider
           *    foo:
           *      (# a,b,c: 2integer
           *      enter(a,b,c)
           *      do ...
           *      exit c
           *      #)
           * We here assume that enter & exit are on the form
           * of traditional method-parameters - general enter/exit
           * is not handled.
           * The following code is generated:
           *     return new foo(a,b,c).do
           *)
      (if isStatic then
          (* 1st argument should be origin - FIX this *)
          theDesc[] -> newThisInstance; (* note that this for this static
                                         * method is an explict argument
                                         * of type reference
                                         *)
          false -> sig.isStatic;
          thisDesc[] -> sig.addEnter;
       else
          (theDesc[],objSpec[],originDesc[],nonLocal) 
            -> newInstanceWithOrigin;
      if);

      (if hasNcode then
          313->trace(#
                    do 'pushEnter:'->xT;
                       enterP[] -> xA; xN;
                       'desc:'->xT;
                       thisDesc[] -> xA
                    #);
          (if hasDoCode or hasXcode then mch.duplicate if);
          (if not hasNcode then
              (* this then-part should probably be the same
                   * as the else-part
               *)
              '\nOBS! genPtnMethod: we should not come here!'->putline;
              enterP.son -> EVL;
              (if EVL.label = gram.evalList then EVL.son -> EVL if);
              EVL->scanList
              (# EV: @ASTindex
              do currentNode -> EV;
                 (gen.thisRegAdr,EV[],false,thisSuperChain)
                   -> EH.ExpEval
                   -> V[];
                 V.pushVal
              #);
           else
              (# A: @mch.RegAdr; off: @integer;
                 ar: @mch.adrRegOperand; 
                 dr: @mch.dataRegOperand
              do 8 -> off;
                 sig.scanEnter
                 (# 
                 do off + 4 -> off -> A.off;
                    (if isRef -> A.isRef then
                        (A[],ar[]) -> mch.ldVal
                     else
                        (A[],dr[]) -> mch.ldVal
                    if)
              #)#)
          if);
          (thisDesc[],'enter',sig[],false,true) -> callNDX
      if);

      (if hasDocode then
          (if hasXcode then mch.duplicate if);          
          (theDesc[],'do',sig[],true,true) -> callNDX
      if);
      (if hasXcode then
          (thisDesc[],'exit',sig[],true,false) -> callNDX
       else 
          0 -> exitID (* should perhaps be handled in Signature *)
      if);
      (false,exitId) -> mch.return 
   #)
   
---genPtnClass:doPart---
do (# sig: @Signature;
      objSpec,theDesc,D: @ASTindex;
      nonLocal: @boolean;
      descKind: @integer
   do 311->trace(#
                do 'genPtnClass: '->xT; patternName[] -> xT
                #);
      (if desc.isSlot then
          '\n*** OBS! Slots are not handled by genPtnClass: '->puttext;
          patternName[] -> putline;          
       else
          desc -> objSpec;
          (if desc.label 
           // gram.objectDescriptor 
           // gram.unExpanded then
           else
              true -> nonLocal;
              (thisDesc[](*?*),desc[])
                -> GetActualDesc 
                -> (D,descKind);
              &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
              D -> desc;
          if);
          desc -> theDesc;
          (desc[],false) -> initPtnGen;
          thisDesc[] -> sig.setDesc;
          sig.noEnter;
          thisDesc[] -> sig.exitRef;
          patternName[] -> sig.addMethod;
          (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (theDesc[],objSpec[],originDesc[],nonLocal)
            -> newInstanceWithOrigin;
          (false,2) -> mch.return 
      if)
   #)
   
---genExternalClass:doPart---
do (# jFile,c: ^text
   do 311->ctrace(#
                 do 'genExternalClass: '->xT; classname[] -> xT
                 #);
      (if desc[] -> isBETAsubOfExternalClass then
          313->ctrace(#do 'generate BETA subclass' -> xT; #);
          (path[],className[],desc[],0) -> genClass;
       else 
          313->ctrace(#do 'external interface: no codegeneration'->xT #);   
          path[] -> splitPathAndNAme -> (path[],c[]);
          className[] -> path.append;
          (* Add external class name to 'link' directive.
           * To ensure proper handling in the current
           * version of asmlink, we need to
           * append AsmExt and BinExt to the
           * classname; this should be cleaned up
           *)
          asmlink.BinExt
            -> (asmlink.asmExt->(path.copy).append).append 
            -> Jfile[];
          (Jfile[],asmlink.ObjKind,true,false) -> AsmLink.TX.insert; 
      if)
   #)

---genClass:doPart---
do (# genMain:
        (# betaenvDesc: ^ASTindex;
           sig: @signature;
        enter betaenvDesc[]
        do 'main' -> sig.addMethod; sig.noEnter; sig.exitVoid;
           (1,'main',false,sig.asText,1) -> mch.initDo; 
           betaenvDesc[] -> newThisInstance;
           (*betaenvDesc[] -> newInstance(# do pushNull #);*)
           (betaenvDesc[],'do',sig[],true,true) -> callNDX;
           (false,0) -> mch.return; 
        #);
      genText2BetaText:
        (# sig: @signature
        do 'Text2BetaText' -> sig.addmethod;
           JavaStringSignatureId 
             -> SpecialSignature 
             -> mkListSignature
             -> sig.setEnter;
           BetaTextSignatureId -> SpecialSignature -> sig.setExit;
           (1,'Text2BetaText',false,sig.asText,1) -> mch.initDo;     
           sematt.textDesc[] -> newThisInstance;
           (false,2) -> mch.return; (* return reference *)
        #);
      theDesc,topSuperName,topDesc: @ASTindex;
      subLevel: @integer;
      superName: ^text;
      
      R: ^ProtoType;
      c: ^text;
      orgDesc: ^AStindex;
      EH: @evalHandler;
      orgName: ^text;
      locals: @LocalDescriptors;
      isMain,isBetaenv: @boolean;
      hasEnterMethod,hasDoMethod,hasExitMethod,isDoPartForm,isOuter: @boolean
   do 311->trace(#
                do 'genClass: "' -> xT; className[] -> xT;
                   '" blockLevel ='->xT; blocklevel -> xI; 
                #);

      (if desc.isSlot then
          '\n*** OBS! Slots are not handled by genClass: '->puttext;
          className[] -> putline;          
       else
          formDesc.label = gram.doPart -> isDoPartForm;
          (* This is an indirect way of representing
           * that we are compiling a dopart-form.
           * formDesc is global and refers the original 
           * form. We should represent this more explicitly.
           * thisDesc refers the descriptor having the
           * dopart-slot. We don't need to do initPtnGen
           * since a dopart form is always compiled
           * via genByteCode, which is called for gdbody
           * where the proper initialization has been done.
           *)
          (* (if isDoPartForm then '\ndopart form'->putline if);*)
          (desc[],isDoPartForm) -> initPtnGen; (* thisDesc[] = desc[]
                                 * BUT: thisDesc[] is global and will
                                 * be redefined in case of nested
                                 * descriptors.
                                 * Below we should replace thisDesc
                                 * by desc!
                                 *)

          desc -> theDesc;
          path[] -> splitPathAndNAme -> (path[],c[]);
          313->trace(#
                    do 'Path: ' -> xT; path[] -> xT
                    #);
          (if not (common.switch[184] or common.switch[189]) then
              (# Jfile: ^text
              do className[]->path.append;
                 asmlink.asmext->(path.copy).append ->Jfile[];
                 (Jfile[],asmlink.byteCodeKind,true,false) 
                   -> AsmLink.TX.insert;
              #)
          if);
          
          (theGroup.origin=NONE) -> mch.initDataSeg;

          (**** G-part ****)
          (if pref.label = gram.prefix then
              pref.son -> topSuperName;
              topSuperName[] -> getNameAsText -> superName[];
              (* note: we need to do name manglig for the super name *)
              topSuperName -> sematt.quaDesc -> topDesc;
              (topDesc[],true) -> EH.descName -> superName[];
              
              topSuperName -> sematt.descChain -> (topDesc,subLevel); 
              (* One super : subLevel = 0
               * Two super : subLevel = 1
               * ...
               *)
              
              (if (thisDesc->sematt.descKind) 
               // sematt.classKind then
                  (if subLevel = 0 then defaultSuperName -> superName[] if);
                  313->trace(#
                            do 'classKind:subLevel:' ->xT; subLevel->xI; 
                               ' superName:'->xT; superName[] -> xT; xN;
                               thisDesc[] -> xA;
                            #)
               // sematt.externalClassKind then
                  (* level 0: externalClase : ( #  # )
                   * level 1: foo: externalClass ( #   # )  - interface
                   * level 2: bar: foo ( #   # )            - real
                   * 
                   * level 2 should be 0 (zero) since this is the
                   * first real BETA subclass; subLevel fomr super
                   * is 1; we thus always subtract 1
                   *)
                  subLevel - 1 -> subLevel
               else
                  313->trace(#do 'not classKind:externalClassKind' -> xT #);
                  subLevel + 1 -> subLevel
              if);              
              313->trace(#
                        do 'super: ' -> xT; subLevel -> xI;
                           superName[] -> xT; xN;
                           topDesc[] -> xA
                        #)
           else
              thisDesc -> topDesc;
              (if true
               // common.targetMachineId = common.javabc then
                  'java/lang/Object'->supername[];
               // common.targetMachineId = common.dotnet then
                  '[mscorlib]System.Object'->supername[];(*'/*3*/'->supername.append;*)
               else
                  'Unknown_platform.Object' -> supername[];
              if);
              0 -> subLevel
          if);
          (* Perhaps there should be an outer static method
           * also for patterns without a do-part, since they 
           * may be executed anyway - such calls are perhaps 
           * never generated by the compiler?
           *)
          (blockLevel = 0) and (topDesc[] -> sematt.hasDo) -> isOuter;
          
          thisDesc[] -> sematt.descOrigin -> orgDesc[];
          (if not orgDesc.isNull then
              orgDesc[] -> mkSignature -> orgName[]
                 (*
              (orgDesc[],true) -> EH.descName -> orgName[]*)
           else
              sematt.superObject[] -> mkSignature -> orgName[]
          if);
          
          313->trace(#do 'genClass:origin: ' -> xT; orgName[] -> xT #);
          
                       (*301 -> trace(# do 'descFather:'->xT; N[] ->xA #);*)
          (* For java: the call to initGen initiates a new BCmachine
           * for Jasmin code generation and a new file
           *)
          ((*thisDesc.nodeId div 2, - we reuse a field - BAD *)
          blockLevel,className[],false
          ,(superName[]->SuperSignature).asText,subLevel,orgName[])
            -> mch.initGen;
          (* 'DefClass: ' -> puttext; className[] -> putline; *)
          
          (att[],doP[],false) -> declareFields;
          (if true (*common.switch[185]*) then (* OBS! *)
              (pref[],subLevel) -> GenSuper
          if);

          
          (if not ReturnSaved then
              (true,thisDesc.returnOff)->mch.SaveReturn;
              true -> ReturnSaved
          if);
          ('tstenv'->className.equalNCS)
          or ('betaenv'->className.equalNCS)
                -> isBetaEnv;
          
          (if common.switch[186] then
              isBetaEnv -> isMain
           else
              'program'->className.equal -> isMain;
          if);
          (att,0,&RepList[],locals[])->GenByteCodeAlloc;
          
          (false,thisDesc.returnOff)->mch.return; 
          
          (if isOuter then (* hack *)
              (# ds: @ASTindex;
                 n,d,x: ^AStindex;
                 usPos: @integer
              do thisDesc -> ds;
                 enterP[] -> N[];
                 doP[] -> d[];
                 exitP[] -> x[];
                 className.scanAll
                 (# pos: @integer
                 do pos+1 -> pos;
                    (if ch = '_' then pos -> usPos if)
                 #);
                 (if usPos > 0 then 
                     (usPos+1,className.length) -> className.sub -> classname[]
                 if);
                 (className[],thisDesc[],true,theDesc[],topDesc[])
                   -> genPtnMethod;
                 x[] -> exitP[];
                 d[] -> doP[];
                 n[] -> enterP[];
                 ds -> thisDesc
              #)
          if);

          (if (not isMain) or common.switch[186] then
              enterP.label <> gram.empty -> hasEnterMethod;
              doP.label <> gram.empty -> hasDoMethod;
              exitP.label <> gram.empty -> hasExitMethod;
          if);
          true -> inEnterDoExitMethod;
          (if hasEnterMethod then
              (* extra isEnter arg needed *)
              ThisDesc[] -> genEnterMethod
          if);
          (if hasDoMethod then
              (ThisDesc[]
              , not hasEnterMethod, false (*not hasExitMethod*),subLevel) 
                -> genDoMethod
          if);
          (if hasExitMethod then
              (* extra isExit arg needed *)
              ThisDesc[] -> genExitMethod
          if);
          false -> inEnterDoExitMethod;
          handleNestedDescriptors
          (#
          do 
             (* this is currently a nested singular descriptor;
              * we don't know whether it is an item or an insertion;
              * currently we assume an insertion, which we
              * also assume should be a local anonymous method;
              * we should test that no this(..)[] or other reference
              * stuff to static objects are present
              *)
             (if not (currentDesc[] -> skipDesc) then
                 (*'\nnested: ' -> puttext; currentCons -> putint; newline;
                  (currentDesc[],screen[],500) -> thePP;
                 *)
                 (if currentCons
                  // 1 (* singular static item *) then
                     currentDesc[] -> locals.save
                  // 2 (* singular inserted procedure item *) then
                     currentDesc[] -> locals.addMethod
                  // 3 (* singular dynamic descriptor *) then
                     currentDesc[] -> locals.save
                  else
                     '\n*** Unknown descriptor cons not handled ' -> putline
             if)if)
          #);
          locals.scanMethods
          (#
          do (if not (current[] -> skipDesc) then
                 ((current[],false)->EH.descName,current[]) -> genMethod
             if)
          #);
          locals.scanPtns
          (# desc: @ASTindex; descKind: @integer
          do (if not (current[] -> skipDesc) then (* skip *)
                 (if current.label 
                  // gram.unExpanded then
                     (* '\n*** descriptor: ' -> puttext;
                      (current[],screen[],500) -> thePP;
                     *)
                     
                     (if common.switch[186] then
                         ((current[],false)->EH.descName
                         ,current[],false,theDesc[],none)
                           -> genPtnMethod;
                     if)
                  // gram.objectDescriptor then
                     (if current->sematt.descKind
                      // sematt.generalKind 
                      // sematt.classKind
                      // sematt.procKind then
                         (* see gdbody for patterns we ignore;
                          * do we have the right ones here ?
                          *)
                         ((current[],false)->EH.descName
                         ,current[],false,theDesc[],none)
                           -> genPtnMethod;
                         ((current[],false)->EH.descName
                         ,current[],theDesc[]) 
                           -> genPtnClass
                     if)
                  else
                     (* attributeDenotation as 'A' in 'V:<A' *)
                     ((current[],false)->EH.descName
                     ,current[],false,theDesc[],none)
                       -> genPtnMethod;
                     ((current[],false)->EH.descName
                     ,current[],theDesc[]) 
                       -> genPtnClass
             if)if)
          #);
          
          (if isMain then
              313->trace(#
                        do 'generate main:' -> xT; xN; theDesc[] -> xA 
                        #);
              (if common.switch[186] then
                  theDesc[] -> genMain;                 
               else
                  ('main',theDesc[]) -> genMethod;
              if)
          if);
          (if isBetaenv then
              genText2BetaText
          if);

          mch.endClass; (* for Java this will close the jasmin-file *)
         (* 'endclass' -> putline;*)
          
          (******** handle inner classes ***********)
          thisBlockLevel + 1 -> thisBlockLevel;
          locals.scanClasses
          (#
          do (if not (current[] -> skipDesc) then
                 (if current->sematt.descKind
                  // sematt.generalKind 
                  // sematt.classKind
                  // sematt.procKind then
                     (* see gdbody for patterns we ignore;
                      * do we have the right ones here ?
                      *)
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel) 
                       -> genClass
                  // sematt.externalClassKind then
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel) 
                       -> genExternalClass
             if)if)
          #);      
          thisBlockLevel - 1 -> thisBlockLevel;   
          (if false then
              (* should be moved up or eliminated??*)
              (pref[],att[])->BindVirtuals;
              (nameId[],singular)->genSymbTable;  
          if)
      if)
   #)
   
---genEnterMethod:doPart---
do (# sig: @Signature;
      EH: @EvalHandler;
      enterA: @EH.EnterArgs;
      EVL: @AStindex;

      off: @integer
   do 311->trace(#
                do 'GenEnterMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genEnterMethod'->putline;
          
       else
          (if formDesc.label <> gram.dopart then
              (desc[],false) -> initPtnGen;
          if);
          thisDesc[] -> sig.setDesc;
          thisDesc[] -> sig.addEnter;
          'enter'->sig.addMethod;
          sig.exitVoid;
          8 -> off;
          (enterP.nodeId,'enter',false,sig.asText,sig.noOfEnterArgs) -> mch.initDo;
          
          enterP.son -> EVL;
          (if EVL.label = gram.evalList then EVL.son -> EVL if);

          enterA.init;
          (# nScan: @ | EH.scanNadr; more: @boolean
          do (thisDesc[],gen.thisRegAdr(*not used*),0,thisSuperChain,true) 
               -> nScan -> more;
             L:
               (if more then
                   'genEnter:asgToNelm1'->mch.comment;
                   enterA[]-> nScan.asgToNelm;
                   nScan -> more;
                   restart L
               if)         
          #);
          
          (false,0) -> mch.return
      if)
   #)
   
---genDoMethod:doPart---
   (* generate a do-method for a general pattern;
    * simple: the enter- and exit-parts are simple
    * arguments and becomes arguments of do;
    * we should split simple into simpleEnter
    * and simpleExit
    *)
do (# sig: @Signature;
      exitVal: ^ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      methodName,innerName: ^text
   do 311->trace(#
                do 'GenDoMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genDoMethod'->putline
          
       else
          (if FormDesc.label = gram.doPart then
              (*'\ndopartform: do method'->putline*)
           else
              (desc[],false) -> initPtnGen;
          if);
          thisDesc[] -> sig.setDesc;
          (if simpleEnter then
              thisDesc[] -> sig.addEnter
           else
              sig.noEnter
          if);
          (if simpleExit then
              exitP[] -> sig.addExit;
              sig.exitId -> exitId;
              sig.exitVal[] -> exitVal[];
           else
              sig.exitVoid
          if);
          311 ->trace(# 
                     do 'genDoMethod:hasInner:sublevel:'->xT; 
                        subLevel -> xI
                     #);
          ('do',subLevel) 
            -> methodAndInnerName 
            -> (methodName[],innerName[]);
          (if false and (not (desc[] -> sematt.hasInner)) then
              (* we should later optimize when no inner *)
              'do' -> innerName[] (* se else-part *)
              (* a hack with methodName[] -> innername[];
               * see bytecodebackend:initDo
               *)
          if);
          methodName[] -> sig.addMethod;
          (doP.nodeId,innername[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (if (doP.label <> gram.empty) then doP -> (&GenDo[]).Scan if);
          (if simpleExit and (exitVal[] <> NONE ) then
              (gen.thisRegAdr,exitVal[],false,ThisSuperChain) 
                -> EH.ExpEval 
                -> V[];
              V.loadVal2;
          if);
          (false,exitId) -> mch.return
      if)
   #)
   
---genExitMethod:doPart---
do (# sig: @Signature;
      exitVal: ^ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal
   do 311->trace(#
                do 'GenExitMethod:'->xT; desc[]->xA
                #);      
      (if desc.isSlot then
          '\nOBS! Slots not handled by genExitMethod'->putline
       else
          (desc[],false) -> initPtnGen;
          sig.noEnter;
          thisDesc[]->sig.setDesc;
          exitP[] -> sig.addExit;
          'exit' -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          (exitP.nodeId,'exit',false,sig.asText,sig.noOfEnterArgs) -> mch.initDo;
          313->trace(#do 'genExitMethod:ExpEval: '->xT; exitVal[] -> xA #);
          (gen.thisRegAdr,exitVal[],false,ThisSuperChain) 
            -> EH.ExpEval 
            -> V[];
          V.pushVal; (*V.loadVal2;*)
          (false,exitId) -> mch.return 
      if)
   #)
   
---genMethod:doPart---
do (# sig: @Signature;
      exitVal: ^ASTindex;
      sort: @ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      superName,innerName: ^text;
      superDesc: ^ASTindex;
      subLevel: @integer
   do (if desc.isSlot then
          '\nOBS! Slots not handled by genMethod'->putline;
          
       else
          (desc[],false) -> initPtnGen;
          (* desc.father -> sort;
           '.method: ' -> puttext; 
           (if sort.label
           // gram.patternDecl then 'pattern ' -> puttext
           // gram.virtualDecl then 'virtual ' -> puttext;
           // gram.bindingDecl then 'binding ' -> puttext;
           // gram.finalDecl   then 'final ' -> puttext
           else 'other? ' ->puttext
           if);*)
          desc[] -> descChain -> (superName[],superDesc[],subLevel);
          
          methodName.copy -> innerName[];
          (if subLevel > 0 then          
              '_do_' -> methodName.append;
              subLevel -> methodName.putint;
          if);
          (if not ('main' -> methodName.equal) then
              (* Note! innernName is used for two purposes:
               * 1. the name of a possible inner method
               * 2. the name of method 'main'
               * if innerName = 'main' then there is no inner method
               *)
              '_do_' -> innerName.append;
              subLevel + 1 -> innerName.putint;
          if);

          (*methodName[] -> puttext;      
           ' super:' ->puttext; superName[] -> puttext; 
           ' level:'->puttext; subLevel -> putint; 
           ' inner:'->puttext; innerName[] -> putline;*)
          
          (* (pref,common.itemKind)->PrefixAlloc;*)
          thisDesc[] -> sig.setDesc;
          (if subLevel > 0 (*thisDesc[] -> sematt.hasNcode*) then
              sig.noEnter
           else
              thisDesc[] -> sig.addEnter
          if);
          exitP[] -> sig.addExit;
          methodName[] -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          313->trace(#
                    do 'genMethod: "' -> xT; methodName[] -> xT;
                       '" Signature: ' -> xT; sig.asText -> xT
                    #);
          (doP.nodeId,innerName[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          
          (if true or isDotNet then
              (* needed for .NET; not needed for Java *)
              (att[],doP[],true) -> declareFields;
          if);
          
          (if (doP.label <> gram.empty) then doP -> (&GenDo[]).Scan if);
          (if exitVal[] <> NONE  then 
              (gen.thisRegAdr,exitVal[],false,ThisSuperChain) 
                -> EH.ExpEval -> V[];
              V.loadVal2
              (* else call of foo/do leaves return value on stack *)
          if);
          (false,exitId) -> mch.return; 
          (pref[],att[])->BindVirtuals;
          (nameId[],singular)->genSymbTable;
      if)
   #)

---GenByteCode:doPart---
do (# className,path: ^text; EH: @evalHandler;
      SetFileName:
        (# className,path,c: ^text; isBetaEnv: @boolean
        enter(className[],isBetaEnv)
        do (if common.switch[189] and isNonAttributesSlot then
               (none (* hack to signal to bytecodemachine that 
                     * this call is for defining the fileName *)
               ,common[]
               ,className[]
               ,(this(AstInterface)[],theGroup[])->getGroupIDProperty
               ) -> mch.init;
               311->trace(#
                         do 'currentFrag: '->puttext;
                            (thisDesc.frag[]).fullName -> putline
                         #);
               (if not isBetaEnv then
                   BCname[] -> splitPathAndNAme -> (path[],c[]);
                   className[] -> path.append;
                   (* AsmExt is appended in BCasmlink; at other unknown 
                    * places, asmExt is not appended either, so doing 
                    * it here gives problems
                    *)
                   ((*asmlink.asmext->(path.copy).append*) 
                   path[]
                   ,asmlink.BetaKind
                   ,true
                   ,false) 
                     -> AsmLink.TX.insert;
           if)if);
        #);
   do 313->trace
      (#
      do (if isJava then 'Compiler for Java bytecode' -> xT if);
         (if isDotNet then 'Compiler for .NET bytecode' -> xT if);
         xN;
         'genlib_bytecode: ' -> xT; xN;
         thisDesc[] -> xA;
         thisDesc[] -> sematt.hasAcode -> xB;
         returnSaved -> xB;
         xN;
         'path : ' -> xT; path[] -> xT; xN;
         'class: ' -> xT; xN;
         (thisDesc[],true) -> EH.descName -> xT;
          (if 'program'->thisFormName.equalNCS then
              'Main' -> xT
          if)
      #);
      (if true
       // 'program'->thisFormName.equalNCS then
          (thisDesc[],true) -> EH.descName -> className[];
          (className[],false) -> SetFileName;
          (BCname[],className[],thisDesc[],0) -> genClass;
          (*mch.close;*) (* this close is needed for .NET to actually
                      * produce a file; for javabc, the close
                      * is in synthesizerboy: mkdataseg
                      *)

       // 'tstenv'->thisFormName.equalNCS 
       // 'betaenv'->thisFormName.equalNCS then
          (if common.switch[186] then
              (thisDesc[],true) -> EH.descName -> className[];
           else
              'tstenv'->className[]
          if);
          (className[],true) -> SetFileName;
          (if true (*common.targetMachineId = common.javabc*) then
              (BCname[],className[],thisDesc[],0) -> genClass;
              (*mch.close*)
           else
              '\n*** tstenv not yet handled' -> putline;
          if);          
       // thisDesc.label = gram.objectDescriptor then
          (* Note: all outer patterns are curently assumed
           * to be clases; we should reconsider this
           * problem with at least externalClassbelow
           *)

          (thisDesc[],true) -> EH.descName -> className[]; 
          (className[],false) -> SetFileName;
          (if ThisDesc -> sematt.descKind 
           // sematt.externalClassKind then
              (BCname.copy,className[],ThisDesc[],0) -> genExternalClass 
           else
              (BCname[],className[],thisDesc[],0) -> genClass;
          if)
       else 
          (* we never come here anymore?*)
          '\n**in else part' -> putline;
          (if not (thisDesc[] -> skipDesc) then
              (thisDesc[],true) -> EH.descName -> className[];
              (if ThisDesc -> sematt.descKind
               // sematt.generalKind
               // sematt.classKind
               // sematt.procKind then
                  (* check with gdbody to see what we ignore here *)
                  (* here we should test for class- or proc-subpatterns *)
                  (if ThisDesc[]->Sematt.hasDo then
                      ((thisDesc[],false)->EH.descName,thisDesc[]) -> genMethod
                   else
                      (BCname[],className[],thisDesc[],0) -> genClass;
                  if)
               // sematt.externalClassKind then
                  (BCname.copy,className[],ThisDesc[],0) 
                    -> genExternalClass
          if)if)
       if)
   #)
   

   
   
   
