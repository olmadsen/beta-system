ORIGIN 'genlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'signature';
include '../GENERATOR/asmlink';
BODY 'genlib_bytecode_body'

---theGenLib:attributes---
genMethod:
  (# methodName: ^text; desc: ^ASTindex;
     locals: ^localDescriptors
  enter(methodName[],desc[],locals[])
  <<SLOT genMethod:doPart>>
  #);

hasSlots: booleanValue
  (# desc: ^ASTindex; N: @ASTindex
  enter desc[]
  do 313->trace(#
               do 'hasSlots: '->xT; desc[] -> xA 
               #);
     (if desc.label = gram.objectDescriptor  then
         desc.son -> N; N.brother -> N;
         (if N.isSlot then
             (* main part slot *)
             true -> value
          else
             N.son -> N;     (* att-part*)
             N.brother -> N; (* action-part*)
             (if not N.isNull then
                 N.son -> N;     (* enter-part*)
                 N.brother -> N; (* do-part *)
                 N.isSlot -> value
         if)if)
         (* else perhaps slots and nameApls should be considered?*)
     if)
  #);
skipDesc: booleanValue
  (# desc: ^ASTindex
  enter desc[]
  do (if true
      // desc -> sematt.superObject.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.externalClassDesc.equal
      // desc -> sematt.procDesc.equal
      // desc -> sematt.staticProcDesc.equal
      // desc -> sematt.consDesc.equal
      // desc -> sematt.staticConsDesc.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.repDesc.equal
      // desc -> sematt.stateDesc.equal
      // desc -> sematt.dataDesc.equal
      // desc -> sematt.structureDesc.equal
         then (* skip *) true -> value
     if)
  #);   

initPtnGen:
  (# desc: ^ASTindex;
     R: ^ProtoType;
     isDoPartForm: @boolean
  enter(desc[],isDoPartForm)
  do &ProtoType[]->R[];
     ProtoHead[]->R.succ[];
     R[]->GS.thisPT[]->Protohead[];
     dynamicObj -> R.objKind; (* ??*)
     Desc->thisDesc; (* ugly *)
     (if not isDoPartForm then initGen if);
  #);
getNameAsText:
  (# den: ^ASTindex; D: @ASTindex; name: ^text
  enter den[]
  do (if den.label = gram.nameApl then
         den.getText -> name[]
      else
         den.son -> D;
         D[] -> getNameAsText -> name[];
         D.brother -> D;
         D.getText -> name.append
     if)
  exit name[]
  #);
descChain:
  (# desc: ^ASTindex; 
     pref: @ASTindex;
     superName: ^text;
     preName,superDesc: @ASTindex;
     subLevel: @integer
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         preName[] -> getNameAsText -> superName[];
         preName -> sematt.descChain -> (superDesc,subLevel); 
         (* One super : subLevel = 0
          * Two super : subLevel = 1
          * ...
          *)
         (if thisDesc->sematt.descKind
          // sematt.procKind 
          // sematt.classKind
          // sematt.consKind
          // sematt.staticProcKind 
          // sematt.staticConsKind then
             (if subLevel = 0 then defaultSuperName -> superName[] if);
          // sematt.externalClassKind then
             (* level 0: externalClase : ( #  # )
              * level 1: foo: externalClass ( #   # )  - interface
              * level 2: bar: foo ( #   # )            - real
              * 
              * level 2 should be 0 (zero) since this is the
              * first real BETA subclass; subLevel fomr super
              * is 1; we thus always subtract 1
              *)
             subLevel - 1 -> subLevel
          else
             subLevel + 1 -> subLevel
         if);              
         313->trace(#
                   do 'superKind: ' -> xT; 
                      thisDesc->sematt.descKind -> sematt.kindAsText -> xT;
                      ' superName:'->xT; superName[] -> xT;
                      ' level:'->xT; subLevel -> xI; xN;
                   #)
      else
         defaultSuperName -> superName[];
         0 -> subLevel
     if);          
  exit(superName[],superDesc[],subLevel)
  #);
pushThis:
  (# thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  do true -> thisObj.isRef;      
     'this' 
       -> thisObj.fieldName[];
     (*  -> thisObj.descName[]  
      -> thisObj.receiverType[]; 
      true -> thisObj.isField;  *)   
     (thisObj[],ar[]) -> mch.ldVal
  #);
pushArg:
  (* Push arg1, arg2, ...
   * aNo in 1,2, ...
   * Use pushThis to push arg0 = this
   *)
  (# aNo: @integer;
     thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  enter aNo
  do true -> thisObj.isRef;  
     8 + aNo * 4 -> thisObj.off;
     'arg' 
       -> thisObj.fieldName[];
     (* -> thisObj.descName[] 
      -> thisObj.receiverType[]; 
      true -> thisObj.isField; *)
     aNo -> thisObj.fieldName.putint;
     (thisObj[],ar[]) -> mch.ldVal
  #);
AllocAndStoreTmp:
  (# type: ^ text; A: ^mch.RegAdr
  enter type[]
  do (if type[] = none then
         '\nOBS! AllocAnd StoreTmp: missing type' ->putline    
     if);     
     type[] -> mch.allocAndStoreLocal -> A[]
  exit A[]
  #);
newThisInstance: newInstance
  (#
  do pushThis;
  #);
newInstanceWithOrigin: 
  (# desc,objSpec,originDesc: ^ASTindex;
     nonLocal: @boolean;
     kind: @integer;
     rA: ^mch.RegAdr
  enter(desc[],objSpec[],originDesc[],nonLocal)
  do common.itemKind -> kind;
     (if not nonLocal then
         (desc[],kind) -> newThisInstance
      else
        (desc[],kind) -> newInstance
         (# OA: ^mch.address;
            EH: @evalHandler
         do (if hasOrigin then
                true -> inEnterDoExitMethod;
                originDesc -> thisDesc; (* ugly: thisDesc is used 
                                         * in genOrgAdrToOrgReg
                                         *)
                gen.thisRegAdr->rA[];
                (thisDesc[],true) -> EH.descName -> rA.fieldName[];
                (rA[],originDesc[],objSpec[]
                ,originDesc->DH.newSingle)
                  -> genOrgAdrToOrgReg 
                  -> OA[];
                desc -> thisDesc;
                false -> inEnterDoExitMethod;
            if)
         #)
     if)
  #);
virtualTopDesc:
  (# VD,topDesc: ^ASTindex; VN: @ASTindex; descKind: @integer
  enter VD[]
  <<SLOT genlib_virtualTopDesc:doPart>>
  exit topDesc[]
  #);
CallClassPtnMethod:
  (# OA: ^mch.address; VN,ES,topDesc: ^ASTindex; 
     kind: @integer;
     EH: @evalHandler;
     sigT: ^text; sort: @ASTindex; sig: @signature;
  enter(VN[],OA[],ES[],kind)
  <<SLOT genlib_CallClassPtnMethod:doPart>>
  exit(sigT[],topDesc[])
  #);
CallExternal:
  (# EV,desc: ^ASTindex;
     EH: @evalHandler;
     V: ^EH.evVal;
     externalName: ^text;
     extKind: @integer;
     CP: @ EH.ExTernalCall;       
  enter(EV[],desc[],externalName[],extKind)
  <<SLOT bytecode_callExternal:doPart>>
  exit V[]
  #);
LocalDescriptors:
  (* container used to collect nested patterns, etc.during GenAlloc *)
  (# methodList,classList,ptnList: [5] ^ASTindex; 
     mTop,cTop,pTop: @integer;
     
     addMethod:
       (# ES: ^ASTindex
       enter ES[]
       do (if (mTop+1->mTop) > methodList.range then
              methodList.range -> methodList.extend
          if);
          ES[] -> methodList[mTop][];
       #);
     addClass:
       (# ES: ^ASTindex
       enter ES[]
       do (if (cTop+1->cTop) > classList.range then
              classList.range -> classList.extend
          if);
          ES[] -> classList[cTop][];
       #);
     addPtn:
       (# ES: ^ASTindex
       enter ES[]
       do (if (pTop+1->pTop) > ptnList.range then
              ptnList.range -> ptnList.extend
          if);
          ES[] -> ptnList[pTop][];  
       #);
     save:
       (# E: ^ASTindex; ES: @ASTindex
       enter E[]
       do E -> ES;
          (if ES -> sematt.descKind
           // sematt.procKind 
           // sematt.consKind 
           // sematt.staticProcKind 
           // sematt.staticConsKind then
              ES[] -> addMethod
           // sematt.classKind then
              ES[] -> addClass
           else
              ES[] -> addPtn;
              (if ES.label <> gram.nameApl then
                  ES[] -> addClass
          if)if)
       #);
     scanMethods:
       (# current: ^ASTindex
       do (for i: mTop repeat
               (* FIXME: foo*)
               methodList[i][] -> current[];
               313->trace(#do 'scanMethod:'->xT; current[]->xA#);
               (if current.label <> gram.nameApl then
                   INNER
                else
                   '\nShouldNotHappen: scanMethods:nameApl' -> putline
               if)
          for);
       #);
     scanPtns:
       (# current: ^ASTindex
       do (for i: pTop repeat
               (* FIXME: foo*)
               ptnList[i][] -> current[];
               (*313->trace(#do 'scanPtn:'->xT; current[]->xA#);*)
               INNER
          for);
       #);
     scanClasses:
       (# current: ^ASTindex
       do (for i: cTop repeat 
               (* FIXME: foo*)
               classList[i][] -> current[];
               313->trace(#do 'scanClass:'->xT; current[]->xA#);
               INNER
          for);
       #);
     
  #);
GenByteCodeAlloc: genAlloc
  (# saveLocalDesc:: (#do D[] -> locals.save#);
     locals: ^LocalDescriptors;
  enter locals[]
  #);


splitPathAndName:
  (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
  enter orgPath[]
  do orgPath.copy->path[];
     path.scanAll
     (# i: @integer 
     do i+1->i; 
        (if ch = '.' then i->dotPos 
         else 
            (if ch = thePathHandler.directoryChar then
                i -> slashPos
        if)if)
     #);
     (*'\nsplit1: ' -> puttext; path[] -> putline;*)
     
     (if dotPos > 0 then
         (dotPos,path.length)->path.delete
     if);
     (*'\nsplit2: ' -> puttext; path[] -> putline;*)
     (if slashPos > 0 then
         (slashPos+1,path.length)->path.sub -> FN[];
         (slashPos+1,path.length)->path.delete
     if);
     (*'\nsplit3: ' -> puttext; path[] -> putline;*)
  exit(path[],FN[])
  #);

scanFields:
  (# att: ^ASTindex; 
     dcl,N: @ASTindex;
     first: @boolean;
     end:< object;
  enter att[]
  do att -> scanList
     (# nameL: @ASTindex;        
     do currentNode -> dcl;
        (if not dcl.isSlot then
            dcl.son->nameL;
            true -> first;
            nameL->scanList
            (# 
            do currentNode -> N;
               INNER scanFields;
               false -> first
            #)
        if)
     #);
     end;
  #);
genFields: scanFields
  (# isMethodFields: @boolean; (* true: scanning fields of a method *)
     locals: ^localDescriptors
  enter(isMethodFields,locals[])
  <<SLOT genlib_bytecode_genFields:doPart>>
  #);
declareFields:
  (# att,doP: ^ASTindex; isMethodFields: @boolean;
     locals: ^localDescriptors
  enter(att[],doP[],isMethodFields,locals[])
  <<SLOT genlib_bytecode_declareFields:doPart>>
  #);
InitGen:(* copy from gdbody - ugly *)
  (#
  do ThisDesc[]
       -> Sematt.descSonsRef
       -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
     ThisDesc.originOff -> ThisDescOrgOff;
     (pref.label = gram.prefix) -> hasPref; 
     ThisDesc.attSize -> attSize -> offCount;
     ThisDesc.descId -> (thisForm[],ThisDescNo);
     thisForm.makeUC;
     false -> returnSaved; 
     NONE-> externalEntryLab[];
  #);
callNDX:
  (# desc: ^ASTindex;
     method: ^text;
     sig: ^Signature;
     class: ^text;
     noNsig,noXsig: @boolean;
     EH: @evalHandler
  enter(desc[],method[],sig[],noNsig,noXsig)
  do ((desc[],true) -> EH.descName,desc[]) -> sig.addReceiver;
     (* should be cleaned up with a nicer interface *)
     desc[] -> descLocation -> sig.location[];
     (if sig.location[] <> none then sig.location[] -> mch.import if);
     method[] -> sig.addMethod;
     (noNsig, noXsig) -> sig.asText -> class[];
     (class[]->mch.newTextOp,'M',true,false)->mch.gJsr;
  #);

methodAndInnerName:
  (# methodName,innerName: ^text; subLevel,type: @integer
  enter(methodName[],subLevel)
  do methodName.copy -> innerName[];     
     (if subLevel > 0 then
         '_' -> methodName.put;
         subLevel -> methodName.putInt;
      else
         2 -> type
     if);
     '_' -> innerName.put;
     subLevel + 1 -> innerName.putInt
  exit(methodName[],innerName[],type)
  #);

genSuper:
  (* void  init(org)
   * 
   *    loadThis
   *    compute & push origin for super
   *    call init
   *    store origin for this
   *)
  (# pref,originDesc: ^ASTindex;
     subLevel: @integer;
     preDen: @ASTindex;
     preBase,A: ^mch.address;
     T: @text; EH: @evalHandler; 
     orgDescName: ^text;
     chain: ^DH.SuperChain;
     aR: @mch.adrRegOperand;
     preBAseX: @mch.RegAdr;
     isSpecial: @boolean; preDescOrg,realpre: ^ASTindex;
     constructorDesc: ^ASTindex;
     isDefaultConstructor: @boolean
  enter(pref[],subLevel)
  <<SLOT genSuper:doPart>>
  exit(constructorDesc[],isDefaultConstructor)
  #)




