ORIGIN 'genlib';
INCLUDE 'auxlib';
INCLUDE 'evlib';
INCLUDE 'signature';
include '../GENERATOR/asmlink';
BODY 'genlib_bytecode_body'
---evalLib:attributes---
methodArgs: evVal
  (# inEnter: @boolean;
     evId:: (# do 'MethodArgs:'->id[] #);
     display::
       (#
       do lEV[]-> xA 
       #);
     pushVal::
       (#
       do '!methodArgs:pushVal:' -> mch.comment;
          (if false then
              (eval).pushVal -> V[];
           else
              ((isMultiple,false,false)->eval).pushVal -> V[];
          if)
       #);
     asgToAdr::
       (# EH: @evalHandler
       do 301->trace(#do 'asgToAdr:'->display; #);
          '!methodArgs:asgToAdr:'->mch.comment;
          (isMultiple,true,true) -> eval -> V[];
          313->trace(#do 'methodArgs:asgToAdrX: '->xT; V.display#);
          '!methodArgs:asgToAdr:before:V.pushVal'->mch.comment;
          (*true -> V.pushVal -> V[];*)
          '!methodArgs:asgToAdr:after:V.pushVal'->mch.comment;
          313->trace(#do 'methodArgs:asgToAdrY: '->xT; V.display#);
          (* fieldType is not always set: as in 'a' -> c;
           * should perhpas be ensured in genAdr?
           *)
          (if rA.bAdr.localDesc[] <> none then
              rA.bAdr.localDesc[] -> theGen.mkSignature -> rA.fieldType[]
          if);
          rA[] -> V.asgToAdr -> V[];
          (if isMultiple and not isJava then mch.loadLocal if);
          301->trace(#
                    do 'methodArgs:asgToAdrZ: '->xT; 
                       (if V[] = none then
                           'V is None' -> xT
                        else
                           V.display
                       if)
                    #);
       #);
     asgToRefAdr::
       (# rA: ^mch.address
       do 313->trace(#do 'asgToRefAdr:'->display; #);
          '!methodArgs:asgToRefAdr1'->mch.comment;
          (rAbase[],destEV.sonRef,false,rChain[]) -> genAdr -> rA[]; 
          '!methodArgs:asgToRefAdr2'->mch.comment;
          (isMultiple,true,false) -> eval -> V[];
          '!methodArgs:asgToRefAdr3'->mch.comment;
          (*V.pushVal -> V[];*)
          '!methodArgs:asgToRefAdr4'->mch.comment;
          (rA[],destEV[],rChain[]) -> V.asgToRefAdr -> V[];
          '!methodArgs:asgToRefAdr5'->mch.comment;
          (if isMultiple and not isjava then mch.loadLocal if);
       #);
     asgToRepAdr::
       (#
       do 313->trace(#do 'asgToRepAdr:'->display; #);
          (rA[],rEV[],rChain[]) -> (eval).asgToRepAdr
          (*((12),1,1) -> (eval).asgToMethod*)
       #);
     asgToMethod::
       (# V: ^evVal
       do 313->trace(#do 'asgToMethod:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          (enterTypes,noOfArguments,next) -> V.asgToMethod
       #);
     asgToList::
       (# A: @mch.RegAdr;
       do 313->trace(#do 'asgToList:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          12 -> A.off;
          true -> A.isRef;
          (if true then
              (none,false,'','???') -> A.asgRefReg;
           else
              (&mch.adrRegOperand[],A[]) -> mch.stVal;
          if);
          (BA[],EV[],rChain[]) -> V.asgToList
       #);
     asgToItem::
       (# V: ^evVal; sig: @theGen.signature;
       do 313->trace(#do 'asgToItem:'->display; #);
          (baseAdr[],lEv[],true,lChain[])
            -> ExpEval
            -> V[];
          rDesc[] -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          (# T: [sig.noOfEnterArgs] @integer;
             top: @integer
          do sig.scanEnter
             (#
             do current.elmType -> T[top+1 -> top]
             #);
             (T,top,1) -> V.asgToMethod
          #)
       #);
     asgToCproc::
       (#
       do (if stest then 301->ctrace
              (#
              do 'methodArgs:asgToCproc: '->xT; lEv[] -> xA 
          #)if);
          eval -> V[];
          (*V.pushVal -> V[];*)
          (EV[],externalName[],desc[],extKind) -> V.asgToCproc -> V[]
       #);
     asgToInlinePrimitive::
       (#
       do (if not common.switch[188] then
              '\nOBS! methodArgs:asgToInlinePrimitive'->putline;
          if);
          this(methodArgs)[] -> V[] (*???*)
       #);
     asgToNewPrim::
       (#
       do eval -> V[];
          (baseA[],ev[],rchain[]) -> V.asgToNewPrim -> V[]
       #);
     eval: 
       (# dup,pushVal,isSimpleVal: @boolean;
          V: ^evVal
       enter(dup,pushVal,isSimpleVal)
       do 301->trace(#
                    do 'eval:'->display; 
                       'dup: ' -> xT; dup->xB;
                       'pushVal:'->xT; pushVal->xB;
                       'isSimpleVal:' ->xT; isSimpleVal -> xB
                    #);
          'methodArgs:eval:1'->mch.comment;
          (if inEnter then
              false -> inEnterDoExitMethod
          if);
          (baseAdr[],lEv[],true ,lChain[]) 
            -> ExpEval
            -> V[];
          'methodArgs:eval:2'->mch.comment;
          (if V[] = none then '\nMethodCall:eval:V is none ' -> putline if);
          301->trace(#do 'eval2:'->display; dup->xB; xN; V.display #);
          (if pushval then
              (* we need the type here for text/const literals;
               * this is tricky and should be reconsidered;
               * also since dup_x1 does not exist on .NET
               *)
              (* reconsider structure of pushVal here and i txtcstval *)
              isSimpleVal -> V.pushVal -> V[];
              301->trace(#do 'eval3: V:'->display; V.display #);
              (if not isSimpleVal then
                  V.mkBetatext; (* reconsider *)
              if)    
          if);
          (if dup then
              (if (*false and*) isJava then
                  1 -> mch.duplicate
               else
                  301->trace(#do 'eval4: V:'->display; V.display #);
                  mch.duplicate;
                  V.type -> theGen.mkSignature ->  mch.allocAndStoreLocal
              if)
          if);
          (if inEnter then
              true -> inEnterDoExitMethod
          if)
       exit V[]
       #);
     lEv: ^ASTindex;
     baseAdr: ^mch.Address;
     lChain: ^DH.superChain;
     isMultiple: @boolean
  enter(baseAdr[],lEv[],lChain[],isMultiple)
  exit this(methodArgs)[]
  #);
EnterArgs: evVal
  (# off: @integer;
     pushNext:
       (# class: ^text;
          A: @mch.RegAdr; T: @text
       enter class[]
       do off+4 -> off -> A.off;
          '!enterArgs:pushNext: '->T; off -> T.putInt; T -> mch.comment;
          'arg_' 
            -> A.fieldName[];
          (*
           -> A.descName[] 
           -> A.receiverType[];
           true -> A.isField;
           *)
          off -> A.fieldName.putint;
          (if class[] <> none then              
              (A[],class[],none)->mch.loadRef
           else              
              (A[],none) -> mch.ldVal
          if)
       #);
     evId:: (# do 'EnterArgs:'->id[] #);
     display:: (# T: @text do 'off:'->T; off->T.putint; T[]->xT #);
     asgToAdr:: 
       (# 
       do '!enterArgs:asgToAdr:'->mch.comment;
          pushNext; (none,rA[]) -> mch.stVal 
       #);
     asgToRefAdr::
       (# sourceClassName,destClassName: ^text;
          dDesc: @ASTindex; mn,dKind: @integer; RC: ^DH.superChain;
          rA,rAx: ^mch.address; destEval,dcl: @ASTindex; 
       do '!EnterArgs:asgToRefAdr:'->mch.comment;
          destEv.son -> destEval; 
          (rChain[],destEval) 
            -> DH.theDesc 
            ->(dDesc,mn,RC[],dKind);
          (if true then
              dDesc[] -> theGen.mkSignature -> sourceClassName[] -> destClassName[];
           else
              (dDesc[],true) -> descName -> sourceClassName[] -> destClassName[];
          if);
          (rAbase.copy,destEval[],false,rChain[])->genAdr->rA[];
          sourceClassName[] -> pushNext;
          destEval.dclref -> dcl;
          dcl.gettext -> rA.fieldName[];
          &mch.RegAdr[] -> rAx[];
          (rAx[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr       
       #);
     asgToRepAdr::
       (# sourceClassName,destClassName: ^text
       do '!EnterArgs:asgToRepAdr' -> mch.comment;
          '[C' -> pushNext; 
          '[C' -> sourceClassName[] -> destClassName[];
          (*true -> rA.isField;
           'rep' -> rA.fieldType[] -> rA.descName[] -> rA.receiverType[];*)
          (&mch.RegAdr[],false,sourceClassName[],destClassName[])
            -> rA.asgRefAdr
       #);
     (*  insert::
      (#
      do '!enterArgs:insert:'->mch.comment;
      #);*)
     asgToItem::
       (# sig: @theGen.Signature;
          basicname,knownName: ^text
       do '!enterArgs:asgToItem:'->mch.comment;
          313->trace(#
                    do 'enterArgs:asgToItem:'->xT;
                       rDesc[] -> xA; xN;
                       'rA:'->xT; rA.display->xT; xN
                    #);
          true->rA.isRef;
          (rDesc[],true) -> descName -> basicName[] -> knownName[]; (* FIX possible virtual *)
          (if not rA.noTmp then
              (rA[],basicName[],none)->mch.loadRef; (* dup should be used *)
              true -> rA.noTmp;
              mch.duplicate; (* for execution of do-method *)
          if);
          rDesc[] -> sig.setMethodDesc;
          rDesc[] -> sig.addEnter;
          sig.exitVoid;
          'enter' -> sig.addMethod;  

          sig.scanEnter
          (# 
          do (if isRef then
                 'someClassOrArry' -> pushNext 
              else
                 pushNext
             if)
          #);
          (if false then 
              (rDesc[],'enter',sig[],false,true) -> theGen.callNDX
          if)
       #);
     asgToMethod::
       (#
       do '!enterArgs:asgToMethod:'->mch.comment;
          (for i: noOfArgs repeat pushNext for);
          (* OBS. check that moved 'inner' in mkByteCodeCall is OK
           * We need the descriptor - it may be singular -
           * it must be called as a a method; i.e. 
           * treated like an inner pattern with method-version
           * and new-version
           *)
       #);
     init:
       (#
       do 8 -> off
       #);
  exit this(enterArgs)[]
  #);
---theGenLib:attributes---
hasSlots: booleanValue
  (# desc: ^ASTindex; N: @ASTindex
  enter desc[]
  do 313->trace(#
               do 'hasSlots: '->xT; desc[] -> xA 
               #);
     (if desc.label = gram.objectDescriptor  then
         desc.son -> N; N.brother -> N;
         (if N.isSlot then
             (* main part slot *)
             true -> value
          else
             N.son -> N;     (* att-part*)
             N.brother -> N; (* action-part*)
             (if not N.isNull then
                 N.son -> N;     (* enter-part*)
                 N.brother -> N; (* do-part *)
                 N.isSlot -> value
         if)if)
         (* else perhaps slots and nameApls should be considered?*)
     if)
  #);
skipDesc: booleanValue
  (# desc: ^ASTindex
  enter desc[]
  do (if true
      // desc -> sematt.superObject.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.externalClassDesc.equal
      // desc -> sematt.procDesc.equal
      // desc -> sematt.classDesc.equal
      // desc -> sematt.repDesc.equal
      // desc -> sematt.stateDesc.equal
      // desc -> sematt.dataDesc.equal
         then (* skip *) true -> value
     if)
  #);   

initPtnGen:
  (# desc: ^ASTindex;
     R: ^ProtoType;
     isDoPartForm: @boolean
  enter(desc[],isDoPartForm)
  do &ProtoType[]->R[];
     ProtoHead[]->R.succ[];
     R[]->GS.thisPT[]->Protohead[];
     dynamicObj -> R.objKind; (* ??*)
     Desc->thisDesc; (* ugly *)
     (if not isDoPartForm then initGen if);
  #);
getNameAsText:
  (# den: ^ASTindex; D: @ASTindex; name: ^text
  enter den[]
  do (if den.label = gram.nameApl then
         den.getText -> name[]
      else
         den.son -> D;
         D[] -> getNameAsText -> name[];
         D.brother -> D;
         D.getText -> name.append
     if)
  exit name[]
  #);
descChain:
  (# desc: ^ASTindex; 
     pref: @ASTindex;
     superName: ^text;
     preName,superDesc: @ASTindex;
     subLevel: @integer
  enter desc[]
  do desc.son -> pref;
     (if pref.label = gram.prefix then
         pref.son -> preName;
         preName[] -> getNameAsText -> superName[];
         preName -> sematt.descChain -> (superDesc,subLevel); 
         (* One super : subLevel = 0
          * Two super : subLevel = 1
          * ...
          *)
         (if thisDesc->sematt.descKind
          // sematt.procKind 
          // sematt.classKind then
             (if subLevel = 0 then defaultSuperName -> superName[] if);
          // sematt.externalClassKind then
             (* level 0: externalClase : ( #  # )
              * level 1: foo: externalClass ( #   # )  - interface
              * level 2: bar: foo ( #   # )            - real
              * 
              * level 2 should be 0 (zero) since this is the
              * first real BETA subclass; subLevel fomr super
              * is 1; we thus always subtract 1
              *)
             subLevel - 1 -> subLevel
          else
             subLevel + 1 -> subLevel
         if);              
         313->trace(#
                   do 'superKind: ' -> xT; 
                      thisDesc->sematt.descKind -> sematt.kindAsText -> xT;
                      ' superName:'->xT; superName[] -> xT;
                      ' level:'->xT; subLevel -> xI; xN;
                   #)
      else
         defaultSuperName -> superName[];
         0 -> subLevel
     if);          
  exit(superName[],superDesc[],subLevel)
  #);
pushThis:
  (# thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  do true -> thisObj.isRef;      
     'this' 
       -> thisObj.fieldName[];
     (*  -> thisObj.descName[]  
      -> thisObj.receiverType[]; 
      true -> thisObj.isField;  *)   
     (thisObj[],ar[]) -> mch.ldVal
  #);
pushArg:
  (* Push arg1, arg2, ...
   * aNo in 1,2, ...
   * Use pushThis to push arg0 = this
   *)
  (# aNo: @integer;
     thisObj: @mch.RegAdr; ar: @mch.adrRegOperand
  enter aNo
  do true -> thisObj.isRef;  
     8 + aNo * 4 -> thisObj.off;
     'arg' 
       -> thisObj.fieldName[];
     (* -> thisObj.descName[] 
      -> thisObj.receiverType[]; 
      true -> thisObj.isField; *)
     aNo -> thisObj.fieldName.putint;
     (thisObj[],ar[]) -> mch.ldVal
  #);
newThisInstance: newInstance
  (#
  do pushThis;
  #);
newInstanceWithOrigin: 
  (# desc,objSpec,originDesc: ^ASTindex;
     nonLocal: @boolean;
     rA: ^mch.RegAdr
  enter(desc[],objSpec[],originDesc[],nonLocal)
  do (if not nonLocal then
         desc[] -> newThisInstance
      else
         desc[] -> newInstance
         (# OA: ^mch.address
         do true -> inEnterDoExitMethod;
            originDesc -> thisDesc; (* ugly: thisDesc is used 
                                     * in genOrgAdrToOrgReg
                                     *)
            gen.thisRegAdr->rA[];
            (thisDesc[],true) -> EH.descName -> rA.fieldName[];
            (rA[],originDesc[],objSpec[]
            ,originDesc->DH.newSingle)
              -> genOrgAdrToOrgReg 
              -> OA[];
            desc -> thisDesc;
            false -> inEnterDoExitMethod;
         #)
     if)
  #);
virtualTopDesc:
  (# VD,topDesc: ^ASTindex; VN: @ASTindex; descKind: @integer
  enter VD[]
  do (if VD.label // gram.bindingDecl // gram.finalDecl then
         VD.son -> sematt.singleName -> VN;
         L: (#
            do VN.virtDcl -> VN;
               VN.sort -> VD;
               313->trace(#
                         do 'genPtnClass:binding: ' -> xT;
                            VN[] -> xA;
                            VD[] -> xA
                         #);                        
               (if not (VD.label = gram.virtualDecl) then
                   restart L
               if)
            #);
         313->trace(#do VN[] -> xA #);
         VN.father -> VN;
         &ASTindex[] -> topDesc[];
         VN.brother -> topDesc;
         313->trace(#do topDesc[] -> xA #);
         (if not (topDesc.label = gram.objectDescriptor) then
             (thisDesc[](*?*),topDesc[])
               -> GetActualDesc 
               -> (topDesc,descKind)
         if);
         313->trace(#
                   do 'genPtnClass:topDesc: ' -> xT;
                      topDesc[] -> xA;
                   #);              
     if);          
  exit topDesc[]
  #);
CallClassPtnMethod:
  (# OA: ^mch.address; VN,ES,topDesc: ^ASTindex; sig: @signature;
     EH: @evalHandler;
     sigT: ^text; sort: @ASTindex
  enter(VN[],OA[],ES[])
  do ES[] -> sig.setMethodDesc;
     ((OA.bAdr.localDesc[],true) -> EH.descName,OA.bAdr.localDesc[])
       -> sig.addReceiver;
     VN.gettext -> sig.addMethod;
     sig.noEnter;
     VN.sort -> sort;
     (if (sort[] -> virtualTopDesc -> topDesc[]) <> none then
         topDesc[] -> sig.exitRef
      else
         sig.exitRef
     if);
     (sig.asText->mch.newTextOp,'M',false(*?*),false) -> mch.gJsr;
     sig.thisMethodDesc[] -> theGen.mkSignature -> sigT[]
  exit sigT[]
  #);
LocalDescriptors:
  (* container used to collect nested patterns, etc.during GenAlloc *)
  (# methodList,classList,ptnList: [5] ^ASTindex; 
     mTop,cTop,pTop: @integer;
     
     addMethod:
       (# ES: ^ASTindex
       enter ES[]
       do (if (mTop+1->mTop) > methodList.range then
              methodList.range -> methodList.extend
          if);
          ES[] -> methodList[mTop][];
       #);
     addClass:
       (# ES: ^ASTindex
       enter ES[]
       do (if (cTop+1->cTop) > classList.range then
              classList.range -> classList.extend
          if);
          ES[] -> classList[cTop][];
       #);
     addPtn:
       (# ES: ^ASTindex
       enter ES[]
       do (if (pTop+1->pTop) > ptnList.range then
              ptnList.range -> ptnList.extend
          if);
          ES[] -> ptnList[pTop][];  
       #);
     save:
       (# E: ^ASTindex; ES: @ASTindex
       enter E[]
       do E -> ES;
          (if ES -> sematt.descKind
           // sematt.procKind then
              ES[] -> addMethod
           // sematt.classKind then
              ES[] -> addClass
           else
              ES[] -> addPtn;
              (if ES.label <> gram.nameApl then
                  ES[] -> addClass
          if)if)
       #);
     scanMethods:
       (# current: ^ASTindex
       do (for i: mTop repeat
               (* FIXME: foo*)
               methodList[i][] -> current[];
               313->trace(#do 'scanMethod:'->xT; current[]->xA#);
               (if current.label <> gram.nameApl then
                   INNER
                else
                   '\nShouldNotHappen: scanMethods:nameApl' -> putline
               if)
          for);
       #);
     scanPtns:
       (# current: ^ASTindex
       do (for i: pTop repeat
               (* FIXME: foo*)
               ptnList[i][] -> current[];
               (*313->trace(#do 'scanPtn:'->xT; current[]->xA#);*)
               INNER
          for);
       #);
     scanClasses:
       (# current: ^ASTindex
       do (for i: cTop repeat 
               (* FIXME: foo*)
               classList[i][] -> current[];
               313->trace(#do 'scanClass:'->xT; current[]->xA#);
               INNER
          for);
       #);
     
  #);
GenByteCodeAlloc: genAlloc
  (# saveLocalDesc:: (#do D[] -> locals.save#);
     locals: ^LocalDescriptors;
  enter locals[]
  #);


splitPathAndName:
  (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
  enter orgPath[]
  do orgPath.copy->path[];
     path.scanAll
     (# i: @integer 
     do i+1->i; 
        (if ch = '.' then i->dotPos 
         else 
            (if ch = thePathHandler.directoryChar then
                i -> slashPos
        if)if)
     #);
     (*'\nsplit1: ' -> puttext; path[] -> putline;*)
     
     (if dotPos > 0 then
         (dotPos,path.length)->path.delete
     if);
     (*'\nsplit2: ' -> puttext; path[] -> putline;*)
     (if slashPos > 0 then
         (slashPos+1,path.length)->path.sub -> FN[];
         (slashPos+1,path.length)->path.delete
     if);
     (*'\nsplit3: ' -> puttext; path[] -> putline;*)
  exit(path[],FN[])
  #);

scanFields:
  (# att: ^ASTindex; 
     dcl,N: @ASTindex;
     first: @boolean;
     end:< object;
  enter att[]
  do att -> scanList
     (# nameL: @ASTindex;        
     do currentNode -> dcl;
        (if not dcl.isSlot then
            dcl.son->nameL;
            true -> first;
            nameL->scanList
            (# 
            do currentNode -> N;
               INNER scanFields;
               false -> first
            #)
        if)
     #);
     end;
  #);
genFields: scanFields
  (# spec,desc,AD: @ASTindex; descKind: @integer; sig: ^text;
     EH: @EvalHandler;
     ftag: @char;
     isMethodFields: @boolean; (* true: scanning fields of a method *)
     declareRef:
       (# desc: ^ASTindex
       enter desc[]
       do desc[] -> mkSignature -> sig[];
          (*(if common.targetMachineId = common.javabc then
           'L'->sig.prepend; ';'->sig.append;
           if);*)
          308->trace(#
                    do 'field: ' -> xT; N[] -> xA; sig[] -> xT
                    #);
          (N.off,N.getText,sig[],fTag) -> mch.declareField (* hack *)
       #)
  enter isMethodFields
  do (if isMethodFields then 'm'->fTag else 'c' -> fTag if);
     (* fTag and emitCk should be replaced by a cleaner and
      * more efficient solution
      *)
     (if dcl.label
      // gram.simpleDecl then
         dcl.son -> spec;
         spec.brother -> spec;
         spec.son -> AD;
         (if AD.label 
          // gram.objectDescriptor then
             (* we need to push here to get the descriptor
              * properly marked - however, if desName
              * returns static item name this may not
              * be needed
              *)
             (if first then (AD,0,1,N) -> DS.push if);
             AD -> desc;
          // gram.unExpanded then
             (* X: @ <<SLOT fool:descriptor>>
              * GetActualDesc will return object;
              * we need the class to have the correct type
              * of the field.
              *)
             AD -> desc;
          else
             (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
         if);
         
         (if spec.label 
          // gram.dynamicItem 
          // gram.dynamicComponent then
             desc[] -> declareRef
          // gram.staticItem 
          // gram.staticComponent then
             (if desc.label = gram.unExpanded then
                 sematt.generalKind -> descKind
              else
                 desc->sematt.descKind->descKind; (* descKind from actualDesc
                                                   * don't work? *)
             if);
             (if desc.label
              // gram.objectDescriptor 
              // gram.unExpanded then
                 (if descKind 
                  // sematt.standardKind then                     
                     (N.off,N.getText
                     ,(desc[] -> valueSignature).asText,fTag) 
                       -> mch.declareField (* hack *)
                  // sematt.generalKind 
                  // sematt.classKind then
                     (* part object: we need origin type and
                      * handle to generate origin code
                      *)
                     'p'-> fTag; (* part object *)
                     desc[] -> declareRef
                  else
                     (if not common.switch[188] then
                         '\n***GenAlloc: unsupported static data-item'->putline
                 if)if)
              else
                 (if not common.switch[188] then
                     '\n***GenAlloc: unsupported static data-itemX'->putline
             if)if)
          else
             (if not common.switch[188] then
                 '\n***GenAlloc:unsupported simple data-item'->putline
         if)if)
      // gram.repetitionDecl then
         (if not common.switch[188] then
             '\n***GenAlloc: repetitions are incomplete!'->putline;
         if);
         (* unify with simpleDecl *)
         dcl.son -> spec;
         spec.brother -> spec;
         spec.brother -> spec;
         spec.son -> AD;
         (if AD.label = gram.objectDescriptor then
             (* we need to push here to get the descriptor
              * properly marked - however, if desName
              * returns static item name this may not
              * be needed
              *)
             (if first then (AD,0,1,N) -> DS.push if);
             AD -> desc
          else
             (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
         if);
         
         (N.off,N.getText,(desc[] -> valueSignature).asText,'[') 
           -> mch.declareField 
     if)
  #);
declareFields:
  (# att,doP: ^ASTindex; isMethodFields: @boolean
  enter(att[],doP[],isMethodFields)
  do (att[],isMethodFields) -> genFields
     (# end::
          (# as: ^ast; exp: ^expanded; off: @integer
          do (* declare index and range from for-imps;
              * preliminary
              *)
             313->trace(#
                       do 'declareFields:for:'->xT; doP[] -> xA
                       #);
             doP.asAst -> as[];
             (if as## <= expanded## then
                 as[] -> exp[];
                 gram.forImp -> exp.suffixWalkForProd
                 (# thisFor: @ASTindex; inx,fRange: @text
                 do (*'got:for:' -> putText;*)
                    current[] -> astAsAstIndex -> thisFor;
                    (if thisFor.label = gram.forImp then
                        313->trace(#
                                  do 'imp:'->xT; thisFor[] -> xA; xN;
                                     1->thisFor.getAttribute->off;
                                     'off:'->xT; off -> xI
                                  #);
                        1->thisFor.getAttribute->off;
                        'for_inx_' -> inx;
                        off -> inx.putint;
                        'for_range_'->fRange;
                        off+4 -> fRange.putint;
                        (off,inx[],'I','c') 
                          -> mch.declareField;
                        (off+4,fRange[],'I','c') -> mch.declareField;
                    if);
             #)if);
             (if isMethodFields then
                 (0,'methodField?','','M') -> mch.declareField
              else
                 (0,'classField?','','C') -> mch.declareField
             if)
          #)
     #);
  #);
InitGen:(* copy from gdbody - ugly *)
  (#
  do ThisDesc[]
       -> Sematt.descSonsRef
       -> (pref[],mainP[],att[],enterP[],doP[],exitP[]);
     ThisDesc.originOff -> ThisDescOrgOff;
     (pref.label = gram.prefix) -> hasPref; 
     ThisDesc.attSize -> attSize -> offCount;
     ThisDesc.descId -> (thisForm[],ThisDescNo);
     thisForm.makeUC;
     false -> GS.insSwitch -> returnSaved; 
     0 -> GS.insOff; 
     GS.insStack.init;
     NONE-> externalEntryLab[];
  #);
callNDX:
  (# desc: ^ASTindex;
     method: ^text;
     sig: ^Signature;
     class: ^text;
     noNsig,noXsig: @boolean;
     EH: @evalHandler
  enter(desc[],method[],sig[],noNsig,noXsig)
  do (if desc-> sematt.superObject.equal then
         2 -> TODO
      else
         ((desc[],true) -> EH.descName,desc[]) -> sig.addReceiver;
         (* should be cleaned up with a nicer interface *)
         desc[] -> descLocation -> sig.location[];
         (if sig.location[] <> none then sig.location[] -> mch.import if);
         method[] -> sig.addMethod;
         (noNsig, noXsig) -> sig.asText -> class[];
         (class[]->mch.newTextOp,'M',true,false)->mch.gJsr;
     if)
  #);

methodAndInnerName:
  (# methodName,innerName: ^text; subLevel: @integer
  enter(methodName[],subLevel)
  do methodName.copy -> innerName[];     
     (if subLevel > 0 then
         '_' -> methodName.put;
         subLevel -> methodName.putInt
     if);
     '_' -> innerName.put;
     subLevel + 1 -> innerName.putInt
  exit(methodName[],innerName[])
  #);

genSuper:
  (* void  init(org)
   * 
   *    loadThis
   *    compute & push origin for super
   *    call init
   *    store origin for this
   *)
  (# pref,originDesc: ^ASTindex;
     subLevel: @integer;
     preDen: @ASTindex;
     preBase,A: ^mch.address;
     T: @text; EH: @evalHandler; 
     orgName,orgDescName: ^text;
     chain: ^DH.SuperChain;
     aR: @mch.adrRegOperand;
     preBAseX: @mch.RegAdr;
     callInit:
       (# orgName: ^text; superOriginDesc: ^ASTindex
       enter orgName[]
       do 'call init/cons' -> mch.comment;
          (*(if (thisDesc->sematt.descKind) = sematt.externalClassKind then
              '-' -> orgName
          if);*)
          PushThis;
          (if not ('-'->orgName.equal) then
              'origin for superQ1:'->mch.comment;
              1 -> PushArg; (* stack holds origin for this desc *)
              INNER callInit;
              (* we need to compute origin from arg1 *)
              
              (* datpete: 17/05/2002: *)
              311->trace
              (#
              do 'initSuper: ' -> xT; orgName[] -> xT; xN;
                 superOriginDesc[] -> xA
              #);
              ((superOriginDesc[],orgName[])->ClassSignature).asText 
                -> orgName[];
          if);
          ('initSuper',orgName[])->mch.callAlloPrim; 
       #);
     storeOrigin:
       (#
       do 'store origin' -> mch.comment;
          (* store origin for this;
           * origin is the argument of init/cons *)
          PushThis;
          1 -> PushArg;
          
          (*prefDesc.originOff->*) Gen.ThisRegAdr-> A[];
          1 -> A.ONlevel;
          true -> A.isOrigin;
          (thisDesc[],true) -> EH.descName -> A.descName[];
          thisDesc[] -> mkSignature -> A.receiverType[];
          true -> A.isField;
          (* common.cstInd -> preBase.access;*)
          'new storeorigin1'->mch.comment;
          (if (originDesc[] <> none) and not originDesc.isNull then
              originDesc[] -> mkSignature -> orgDescName[]
           else
              (if common.switch[320] then
                  platFormSuperSignature -> orgDescName[]
               else
                  sematt.superObject[] -> mkSignature -> orgDescName[]
              if) 
          if);
          313 -> trace(#
                      do 'storeOrigin:orgDescName:'->xT; 
                         orgDescName[] -> xT; xN;
                         'A.descName:'->xT; A.descName[] -> xT; xN;
                         originDesc[] -> xA
                      #);
          'orgDescName:'->mch.comment;
          orgDescname -> mch.comment;
          'origin' -> A.fieldName[];
          (none,false,'source',orgDescName[]) -> A.asgRefReg;
       #);
     genDefaultSuper:
       (# hasOrigin: @boolean; N: ^text
       enter hasOrigin
       do thisDesc[] -> sematt.descOrigin -> originDesc[]; 
          '-' -> callInit;
          313->trace(#
                    do 'genDefaultSuper:'->xT; xN;
                       thisDesc[] -> xA; xN;
                    #);
          (if hasOrigin then storeOrigin if)
       #) ;
     IsSpecialVirtual: (* see the same pattern in genlib.bet 
                        * we should unify the two patterns
                        *       V::< (# ... #);  
                        *)
       (# preDen: ^ASTindex;
          special,rem: @boolean;
          preName,preX,preSort,realPre,realPreN
          ,preDescOrg: @ASTindex;
          thisDescOrigin: ^ASTindex;
          chain: ^DH.SuperChain
       enter preDen[]
       do preDen -> sematt.getName -> preName;
          preName.dclRef -> preSort;
          preSort.sort -> preSort;
          (if preSort.label
           // gram.virtualDecl // gram.bindingDecl then
              (* thisDesc is V :: < (# ... #)                   
               * the super may then be  V :< (# ... #)
               *        no problems on generating origin
               * or                  V :< A
               *        special code for generating origin
               *        if A is not at the same level as V
               * or                   V:< R.A
               *        same as above
               *)
              preSort.son -> realPre;
              realPre.brother -> realPre;
              (if realPre.label
               // gram.objectDescriptor then
                  
               // gram.nameApl then (* V:< A *)
                  realPre -> sematt.getName -> realPreN;
                  (if (realPreN.on > 0) then true -> special if)
               // gram.remote then
                  true -> special
               else
                  'Unknown implicit super-pattern' 
                    -> thisTranslate.SystemException
              if);
              (if special then
                  thisDesc[] -> semAtt.DescOrigin -> thisDescOrigin[];
                  thisDescOrigin -> preDescOrg;
                  ThisSuperChain -> chain[];
                  chain[] -> DH.ENC -> chain[];
                  (for i: preName.pn repeat
                       preDescOrg.son -> preX;
                       preX.son -> sematt.Descrip -> preDescOrg;
                       chain[] -> DH.PRE -> chain[]
                  for);                  
              if)
          if)
       exit(special,realPre[],preDescOrg[],chain[])
       #);
     isSpecial: @boolean; preDescOrg,realpre: ^ASTindex
  enter(pref[],subLevel)
  do 313->trace(#
               do 'genSuper:'->xT;
                  (if haspref then pref[] -> xA
                   else 'no super'->xT
                  if); 
                  xN;                  
               #);
     SaveReturn:
       (true,thisDesc.returnOff)->mch.SaveReturn;
     true -> ReturnSaved;
     
     (if hasPref and (subLevel > 0) 
         (*and ((thisDesc->sematt.descKind) <> sematt.externalClassKind)*)
         then 
         (* hasPref and (sublevel = 0)
          * is a subclass of externalClass
          *)
         pref.son -> preDen -> SemAtt.descrip -> prefDesc;
         (if true 
          // prefDesc -> sematt.procDesc.equal
          // prefDesc -> sematt.classDesc.equal then
             true -> genDefaultSuper;
             leave genSuper
         if);
         Gen.ThisRegAdr -> preBase[];
         12 -> preBase.addOff -> preBase[];
         'origin' -> preBase.fieldName[];
         thisDesc[]
           -> sematt.descOrigin
           -> originDesc[];
         preDen[] -> isSpecialVirtual 
           -> (isSpecial,realPre[],preDescOrg[],chain[]);
         (if isSpecial then
             311->trace(#
                       do 'SpecialVirtual: realpre: '->xT; realPre[]->xA; xN;
                          'preDescOrg: ' -> xT; preDescOrg[] -> xA
                       #);
             preDescOrg[] -> preBase.bAdr.LocalDesc[];
             '' -> callInit
             (#
             do true -> preBase.isOrigin;
                2 -> prebase.ONlevel;
                true -> preBase.isField;
                (preBase[],none(*not used*),realPre[],chain[])
                  -> genOrgAdr
                  -> preBase[];
                'origin' -> preBase.fieldName[];
                (preBase.bAdr.localDesc[],true)
                  -> EH.descName 
                  -> orgName[];
                preBase.bAdr.localDesc[] 
                  -> sematt.descOrigin 
                  -> superOriginDesc[]
             #)
          else
             (* overvej *)
             thisDesc[]
               -> sematt.descOrigin
               -> originDesc[]
               -> preBase.bAdr.LocalDesc[];
             thisSuperChain->chain[];
             chain[]->DH.ENC->chain[];
             (* NOTE: We enter the empty string '' as orgName,
              * and redefined orgName in the do-part below;
              * we need to reconsider the abstraction
              *)
             ''-> callInit
             (#
             do 311->trace(#
                          do 'genSuper:callInit: ' -> xT; preDen[] -> xA; xN;
                             'localDesc:' -> xT;
                             preBase.bAdr.localDesc[] -> xA
                          #);
                true -> preBase.isOrigin;
                2 -> prebase.ONlevel;
                true -> preBase.isField;
                (preBase[],originDesc[],preDen[],chain[])
                  -> genOrgAdr
                  -> preBase[];
                'origin' -> preBase.fieldName[];
                (preBase.bAdr.localDesc[],true)
                  -> EH.descName 
                  -> orgName[];
                preBase.bAdr.localDesc[] 
                  -> sematt.descOrigin 
                  -> superOriginDesc[];

                311->trace(#
                          do 'genSuper:callInit:2 ' -> xT; xN;
                             'localDesc:' -> xT;
                             preBase.bAdr.localDesc[] -> xA; xN;
                             'orgName: ' -> xT; orgName[] -> xT
                          #);                
             #)
         if);
         storeOrigin;
      else
         (if (thisDesc->sematt.descKind) = sematt.externalClassKind then
             false -> genDefaultSuper
          else
             true -> genDefaultSuper
         if)
     if);
  exit prefDesc[]
  #);





