ORIGIN 'synthesizerbody';   
LIB_ITEM 'betacodegen';
INCLUDE 'synthlib';
BODY 'prototypebody'
---SynthesizerBodyLib:attributes---
ProtoType: ProtoObject
  (* store information for generation of prototype *)
  (# desc,prefDesc,pref,att: @ASTindex; (* the descriptor *)
     descId: ^text;	(* text identifying the descriptor *)
     objKind: @integer; (* generalKind,comKind, externalVirtualKind, ... *)
     singular,desc2Alias: @boolean; 
     formIndex,nodeId: @integer; (* id in AST *)
     formId,prefFormId,externalEntryLab: ^text;
     descNo,prefDescNo,size,orgOff,topMentryOff: @integer;
     mainLst: (# mDesc: @ASTindex; succ: ^mainLst #);
     mainHead: ^Mainlst;
     mainAdr:
       (# mDesc: ^ASTindex; R: ^mainLst
       enter mDesc[]
       do &mainLst[]->R[]; mDesc->R.mDesc;
          mainHead[]->R.succ[]; R[]->mainHead[];
       #);
     EmitMain: <<SLOT EmitMain:objectDescriptor>>;

     virtTable: [ThisDesc.virtSize] @ integer; 
     (* A label:
      * if non-zero, binding code is generated 
      * if zero, no binding code is generated, generate prefix binding
      *)
     virtTable2: [ThisDesc.virtSize] ^ASTindex;
     virtTable3: [ThisDesc.virtSize] ^mch.textOperand;
     markVirt:
       (# virtOff,lab: @integer
       enter(virtOff,lab)
       do (*312->trace
          (#do 'VirtMark:'->xT; virtTable.range->xI;
           virtOff->xI; lab->xI #);*)
          lab->virtTable[virtOff]
       #);
     markVirt2:
       (# virtOff: @integer; formId: ^text; descNo: @integer; desc: ^ASTindex
       enter(virtOff,desc[](*formId[],descNo*))
       do -1->virtTable[virtOff]; 
          desc[]->virtTable2[virtOff][];
          (*312->trace(#do 'virtMark2:'->xT; virtOff->xI; desc[] ->xA#)*)
       #);
     markInner:
       (# T: ^mch.textOperand; innerOff: @integer
       enter(T[],innerOff)          
       do -2 -> virtTable[innerOff];
          T[] -> virtTable3[innerOff][];
          (*312->trace(#do 'virtMark3:'->xT; innerOff->xI; T->xT#)*)
       #);
     isMarked: 
       (# vOff: @integer enter vOff 
      (* do 301-> trace
          (#do 'Voff: '->xT; Voff->xI; ' '->put;
             virtTable.range ->xI; xN
           #);*)
       exit virtTable[vOff]<>0 #);
     emitBindTable: (#do <<SLOT EmitBindTable:descriptor>>#);
     
     GC:  (* offsets for garbage collector *)
       (# Off: [8]@ integer; Top: @integer;
          Add: @
            (# N: @integer
            enter N
            do (if (Top+1->Top) > Off.range then Off.range->Off.extend if);
               N->Off[Top]
            #);
          dump:
            (# T: @text
            enter T
            do tracestream.newline; T[]->tracestream.putline;
               (for i: top repeat
                    i->tracestream.putint; ':'->tracestream.put; 
                    off[i]->tracestream.putint; tracestream.newline
            for)#)
       #);

     Dyn,longs,shorts,bytes,reals: @GC;
     
     objTmps: [5] ^ObjTmp; objTmpTop: @integer; (* static object templates *)
     ObjTmp:
       (# gOff,locOff: @integer; EP: ^text; local: @boolean;
          save:
            (#
            do (if (objTmpTop+1->objTmpTop) > objTmps.range  then
                   objTmps.range->objTmps.extend
               if);
               this(ObjTmp)[]->objTmps[objTmpTop][]
            #);
       #);
     
     EmitExport: <<SLOT emitExport:descriptor>>;
     EmitProtoType::< (#do  <<SLOT emitProtoType: descriptor>> #);
     ComputeObjectTemplate:
       (# desc,pref,att: ^ASTindex;
          descNo: @integer; formId: ^text; locationOff,OrgOff: @integer
       enter(desc[],pref[],att[],descNo,formId[],locationOff,OrgOff)
       do <<SLOT ComputeObjectTemplate:descriptor>>
       #);
     EmitObjectTemplate: <<SLOT EmitObjectTemplate:descriptor>>;

     succ: ^ProtoType
  <<SLOT protoTypeBody:doPart>>
  #); (* protoType *)
