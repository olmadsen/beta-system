ORIGIN 'genlib_bytecode'
---genPtnMethod:doPart---
   (* Calling a general pattern as a method
    * 
    * Simple form
    *    .method foo(x1x2x3)y
    *       new foo
    *       push x1
    *       push x2 
    *       push x3
    *       call foo/do(x1x2x3)y
    *       zreturn
    *  General form
    *       new foo
    *       store R
    *       load R
    *       push x1
    *       push x2
    *       push x3
    *       call foo/enter(x1,x2,x3)V
    *       call foo/do()V
    *       call foo/exit()y
    *       zreturn
    *)
do (# sig: @Signature;
      hasNcode,hasDoCode,hasXcode: @boolean;
      exitId: @integer;
      EH: @evalHandler;
      exitVal: ^ASTindex;
      EVL,EV: @ASTindex; V: ^EH.evVal;
      orgName: ^text;
      theDesc,objSpec,D,pref,topSuperName: @ASTindex;
      descKind,subLevel: @integer;
      nonLocal: @boolean;
      nScan: @sematt.nxScanner
   do 311->trace(#
                do 'genPtnMethod: '->xT; patternName[] -> xT; xN;
                   'desc: ' -> xT; desc[] -> xA;
                   'topDesc:' -> xT; topDesc[] -> XA;
                #);
      desc -> objSpec;
      (if desc.label 
       // gram.objectDescriptor 
       // gram.unExpanded then
       else
          true -> nonLocal;
          (thisDesc[](*?*),desc[])
            -> GetActualDesc 
            -> (D,descKind);
          &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
          D -> desc;
          none -> topDesc[]
      if);
      (if topDesc[] = none then
          desc.son -> pref;
          &ASTindex[] -> topDesc[]; (* prevent aliasing *)
          (if pref.label = gram.prefix then
              pref.son -> topSuperName;
              topSuperName -> sematt.descChain -> (topDesc,subLevel)
           else
              desc -> topDesc;
      if)if);
      desc -> theDesc;
      (if desc.isSlot then 
          (*'\n*** OBS! Slots are not handled by genPtnMethod: '->puttext;
           patternName[] -> putline;*)
          sig.noEnter;
          sig.exitVoid;
          true -> hasDoCode
       else
          (desc[],false) -> initPtnGen;
          313->trace(#
                    do 'genPtnMethod:doPart: '->xT; patternName[]->xT; xN; 
                       doP[] -> xA
                    #);
          (* if we add a constructor possibility to BETA;
           * we must get the signature from the constructor
           * of the pattern
           *)
          (if withN then
              (if not (enterP.label <> gram.empty -> hasNcode) then
                  (theDesc[],true,thisSuperChain) -> nScan;
                  nScan.length > 0 -> hasNcode
          if)if);
          (*withN and (enterP.label <> gram.empty) -> hasNcode;*)
          withX and (exitP.label <> gram.empty) -> hasXcode;
          
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;

          (if isStatic then sig.markStatic if);
          thisDesc[] -> sig.addEnter;
          exitP[] -> sig.addExit;

          topDesc[]  -> sematt.hasDo -> hasDoCode
      if);
      patternName[] -> sig.addMethod;
      sig.exitId -> exitId;
      sig.exitVal[] -> exitVal[];
      
      sig.exitVal[] <> none -> hasXcode; (* note we override hasXcode
                                          * above; exitP is only for
                                          * the mainpart; possible exitlist
                                          * in superpatterns are not
                                          * handled
                                          *)
      (if not inLine then
          (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;       
      if);
      (* Consider
       *    foo:
       *      (# a,b,c: 2integer
       *      enter(a,b,c)
       *      do ...
       *      exit c
       *      #)
       * We here assume that enter & exit are on the form
       * of traditional method-parameters - general enter/exit
       * is not handled.
       * The following code is generated:
       *     return new foo(a,b,c).do
       *)
      (if hasNcode or hasDoCode or hasXcode then
          (if isStatic then
              (* 1st argument should be origin - FIX this *)
              theDesc[] -> newThisInstance; (* note that this for this static
                                             * method is an explict argument
                                             * of type reference
                                             *)
              false -> sig.isStatic;
              thisDesc[] -> sig.addEnter;
           else
              (if inline then
                  theDesc[] -> newInstance
                  (#
                  do INNER genPtnMethod
                  #)
               else
                  (theDesc[],objSpec[],originDesc[],nonLocal) 
                    -> newInstanceWithOrigin;
          if)if);

          (if hasNcode then
              313->trace(#
                        do 'pushEnter:'->xT;
                           enterP[] -> xA; xN;
                           'desc:'->xT;
                           thisDesc[] -> xA
                        #);
              (if hasDoCode or hasXcode then mch.duplicate if);
              (if not hasNcode then
                  (* this then-part should probably be the same
                   * as the else-part
                   *)
                  '\nOBS! genPtnMethod: we should not come here!'->putline;
                  enterP.son -> EVL;
                  (if EVL.label = gram.evalList then EVL.son -> EVL if);
                  EVL->scanList
                  (# EV: @ASTindex
                  do currentNode -> EV;
                     (gen.thisRegAdr,EV[],false,thisSuperChain)
                       -> EH.ExpEval
                       -> V[];
                     V.pushVal
                  #);
               else
                  (# A: @mch.RegAdr; off: @integer;
                     ar: @mch.adrRegOperand; 
                     dr: @mch.dataRegOperand
                  do 8 -> off;
                     sig.scanEnter
                     (# 
                     do off + 4 -> off -> A.off;
                        'enter' -> A.fieldName[];
                        current.asText -> A.fieldType[];
                        (if isRef -> A.isRef then
                            (A[],ar[]) -> mch.ldVal
                         else
                            (A[],dr[]) -> mch.ldVal
                        if)
                  #)#)
              if);
              (theDesc[],'enter',sig[],false,true) -> callNDX
          if);

          (if hasDocode then
              (if hasXcode then mch.duplicate if);          
              (theDesc[],'do',sig[],true,true) -> callNDX
          if);
          (if hasXcode then
              (theDesc[],'exit',sig[],true,false) -> callNDX
           else 
              0 -> exitID (* should perhaps be handled in Signature *)
      if)if);
      (if not inline then
          (false,exitId) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genPtnClass:doPart---
do (# sig: @Signature;
      objSpec,theDesc,D,VN,VD: @ASTindex;
      topDesc: ^ASTindex;
      nonLocal: @boolean;
      descKind: @integer
   do 311->trace(#
                do 'genPtnClass: '->xT; patternName[] -> xT; xN;
                   'desc:' -> xT; desc[] -> xA; xN;                 
                   'thisDesc:' -> xT; thisDesc[] -> xA; 
                #);
      (if desc.isSlot then
          '\n*** OBS! Slots are not handled by genPtnClass: '->puttext;
          patternName[] -> putline;          
       else
          desc -> objSpec;
          desc.father -> VD;
          (if desc.label 
           // gram.objectDescriptor 
           // gram.unExpanded then
           else
              true -> nonLocal;
              (thisDesc[](*?*),desc[])
                -> GetActualDesc 
                -> (D,descKind);
              &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
              D -> desc;
          if);
          desc -> theDesc;
          (if (VD[] -> virtualTopDesc -> topDesc[]) = none then
              &ASTindex[] -> topDesc[];
              theDesc -> topDesc;
          if);
          (desc[],false) -> initPtnGen;
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          sig.noEnter;
          topDesc[] -> sig.exitRef;
          patternName[] -> sig.addMethod;
          sig.markAsPtnClassMethod;
          (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (theDesc[],objSpec[],originDesc[],nonLocal)
            -> newInstanceWithOrigin;
          (false,11) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genExternalClass:doPart---
do (# jFile,c: ^text
   do 311->ctrace(#
                 do 'genExternalClass: '->xT; classname[] -> xT
                 #);
      (if desc[] -> isBETAsubOfExternalClass then
          313->ctrace(#do 'generate BETA subclass' -> xT; #);
          (path[],className[],desc[],0) -> genClass;
       else 
          313->ctrace(#do 'external interface: no codegeneration'->xT #);   
          path[] -> splitPathAndNAme -> (path[],c[]);
          desc[] -> getExternalClassName -> path.append;
          (if false then
              (* Add external class name to 'link' directive.
               * To ensure proper handling in the current
               * version of asmlink, we need to
               * append AsmExt and BinExt to the
               * classname; this should be cleaned up
               *)
              asmlink.BinExt
                -> (asmlink.asmExt->(path.copy).append).append 
                -> Jfile[];
              (Jfile[],asmlink.ObjKind,true,false) -> AsmLink.TX.insert; 
          if)
      if)
   #)

---genSuper:doPart---
do genSuperDo:
     (# callInit:
          (# superOrgName: ^text; superOriginDesc: ^ASTindex
          enter superOrgName[]
          do 'call init/cons' -> mch.comment;
             PushThis;
             (if not ('-'->superOrgName.equal) then
                 'origin for superQ1:'->mch.comment;
                 1 -> PushArg; (* stack holds origin for this desc *)
                 INNER callInit;
                 (* we need to compute origin from arg1 *)
                 
                 (* datpete: 17/05/2002: *)
                 301->trace
                 (#
                 do 'initSuper: ' -> xT; superOrgName[] -> xT; xN;
                    superOriginDesc[] -> xA
                 #);
                 ((superOriginDesc[],superOrgName[])->ClassSignature).asText 
                   -> superOrgName[];
             if);
             ('initSuper',superOrgName[])->mch.callAlloPrim; 
          #);
        storeOrigin:
          (#
          do 'store origin' -> mch.comment;
             (* store origin for this;
              * origin is the argument of init/cons *)
             PushThis;
             1 -> PushArg;
             
             (*prefDesc.originOff->*) Gen.ThisRegAdr-> A[];
             1 -> A.ONlevel;
             true -> A.isOrigin;
             (thisDesc[],true) -> EH.descName -> A.descName[];
             thisDesc[] -> mkSignature -> A.receiverType[];
             true -> A.isField;
             (* common.cstInd -> preBase.access;*)
             'new storeorigin1'->mch.comment;
             (if (originDesc[] <> none) and not originDesc.isNull then
                 originDesc[] -> mkSignature -> orgDescName[]
              else
                 platFormSuperSignature -> orgDescName[]
             if);
             313 -> trace(#
                         do 'storeOrigin:orgDescName:'->xT; 
                            orgDescName[] -> xT; xN;
                            'A.descName:'->xT; A.descName[] -> xT; xN;
                            originDesc[] -> xA
                         #);
             'orgDescName:'->mch.comment;
             orgDescname -> mch.comment;
             'origin' -> A.fieldName[];
             (none,false,'source',orgDescName[]) -> A.asgRefReg;
          #);
        genDefaultSuper:
          (# hasOrigin: @boolean; N: ^text
          enter hasOrigin
          do thisDesc[] -> sematt.descOrigin -> originDesc[]; 
             '-' -> callInit;
             313->trace(#
                       do 'genDefaultSuper:'->xT; xN;
                          thisDesc[] -> xA; xN;
                       #);
             (if hasOrigin then storeOrigin if)
          #) ;
        IsSpecialVirtual: (* see the same pattern in genlib.bet 
                           * we should unify the two patterns
                           *       V::< (# ... #);  
                           *)
          (# preDen: ^ASTindex;
             special,rem: @boolean;
             preName,preX,preSort,realPre,realPreN
             ,preDescOrg: @ASTindex;
             thisDescOrigin: ^ASTindex;
             chain: ^DH.SuperChain
          enter preDen[]
          do preDen -> sematt.getName -> preName;
             preName.dclRef -> preSort;
             preSort.sort -> preSort;
             (if preSort.label
              // gram.virtualDecl // gram.bindingDecl then
                 (* thisDesc is V :: < (# ... #)                   
                  * the super may then be  V :< (# ... #)
                  *        no problems on generating origin
                  * or                  V :< A
                  *        special code for generating origin
                  *        if A is not at the same level as V
                  * or                   V:< R.A
                  *        same as above
                  *)
                 preSort.son -> realPre;
                 realPre.brother -> realPre;
                 (if realPre.label
                  // gram.objectDescriptor then
                     
                  // gram.nameApl then (* V:< A *)
                     realPre -> sematt.getName -> realPreN;
                     (if (realPreN.on > 0) then true -> special if)
                  // gram.remote then
                     true -> special
                  else
                     'Unknown implicit super-pattern' 
                       -> thisTranslate.SystemException
                 if);
                 (if special then
                     thisDesc[] -> semAtt.DescOrigin -> thisDescOrigin[];
                     thisDescOrigin -> preDescOrg;
                     ThisSuperChain -> chain[];
                     chain[] -> DH.ENC -> chain[];
                     (for i: preName.pn repeat
                          preDescOrg.son -> preX;
                          preX.son -> sematt.Descrip -> preDescOrg;
                          chain[] -> DH.PRE -> chain[]
                     for);                  
                 if)
             if)
          exit(special,realPre[],preDescOrg[],chain[])
          #);

     do 313->trace(#
                  do 'genSuper:'->xT;
                     (if haspref then pref[] -> xA
                      else 'noSuper' -> xT
                     if); 
                     ' level:' -> xT; subLevel -> xI;
                  #);

        thisDesc[] -> sematt.descOrigin -> originDesc[];
        (# sig: ^ConstructorSignature;               
           RC: ^DH.superChain;
        do 313->trace(#
                     do 'Super:constructorSignature:'->xT; xN;
                        originDesc[] -> xA
                     #);
           (originDesc[],none)
             -> constructorSignature 
             -> sig[];
           (thisDesc[],thisSuperChain) 
             -> sematt.findConstructor 
             -> (constructorDesc[],RC[]);
           (if constructorDesc[] <> none then
               (constructorDesc[],RC[]) -> sig.addConstructorDesc;
           if);
           313 -> trace(#do 'consSig: '->xT; sig.asText -> xT #);
           sig.asText -> mch.constructorDef;
           true -> ReturnSaved;
        #);

        (if hasPref 
            and (subLevel > 0) 
            (*or ((thisDesc->sematt.descKind) = sematt.externalClassKind))*)
            then 
            (* hasPref and (sublevel = 0)
             * is a subclass of externalClass
             *)
            pref.son -> preDen -> SemAtt.descrip -> prefDesc;
            (if true 
             // prefDesc -> sematt.procDesc.equal
             // prefDesc -> sematt.classDesc.equal then
                true -> genDefaultSuper;
                leave genSuperDo 
            if);
            Gen.ThisRegAdr -> preBase[];
            12 -> preBase.addOff -> preBase[];
            'origin' -> preBase.fieldName[];
            
            preDen[] 
              -> isSpecialVirtual 
              -> (isSpecial,realPre[],preDescOrg[],chain[]);
            (if isSpecial then
                301->trace(#
                          do 'SpecialVirtual: realpre: '->xT; realPre[]->xA; xN;
                             'preDescOrg: ' -> xT; preDescOrg[] -> xA
                          #);
                preDescOrg[] -> preBase.bAdr.LocalDesc[];
                '' -> callInit
                (#
                do true -> preBase.isOrigin;
                   2 -> prebase.ONlevel;
                   true -> preBase.isField;
                   (preBase[],none(*not used*),realPre[],chain[])
                     -> genOrgAdr
                     -> preBase[];
                   'origin' -> preBase.fieldName[];
                   (preBase.bAdr.localDesc[],true)
                     -> EH.descName 
                     -> superOrgName[];
                   preBase.bAdr.localDesc[] 
                   (*-> sematt.descOrigin *)
                     -> superOriginDesc[]
                #)
             else
                (* overvej *)
                (*thisDesc[]
                 -> sematt.descOrigin
                 -> *) originDesc[]
                  -> preBase.bAdr.LocalDesc[];
                thisSuperChain->chain[];
                chain[]->DH.ENC->chain[];
                (* NOTE: We enter the empty string '' as superOrgName,
                 * and redefined superOrgName in the do-part below;
                 * we need to reconsider the abstraction
                 *)
                ''-> callInit
                (#
                do 301->trace(#
                             do 'genSuper:callInit: ' -> xT; preDen[] -> xA; xN;
                                'localDesc:' -> xT;
                                preBase.bAdr.localDesc[] -> xA
                             #);
                   true -> preBase.isOrigin;
                   2 -> prebase.ONlevel;
                   true -> preBase.isField;
                   (preBase[],originDesc[],preDen[],chain[])
                     -> genOrgAdr
                     -> preBase[];
                   'origin' -> preBase.fieldName[];
                   301->trace(#
                             do 'genSuper:callInit:X:'->xH;
                                preBase.bAdr.localDesc[] -> xA
                             #);
                   (preBase.bAdr.localDesc[],true)
                     -> EH.descName 
                     -> superOrgName[];
                   301->trace(#
                             do 'genSuper:callInit:Y:'->xH;
                                superOrgName[] -> xT
                             #);
                   
                   preBase.bAdr.localDesc[] -> superOriginDesc[];

                   301->trace(#
                             do 'genSuper:callInit:2 ' -> xT; xN;
                                'localDesc:' -> xT;
                                preBase.bAdr.localDesc[] -> xA; xN;
                                'superOrgName: ' -> xT; superOrgName[] -> xT
                             #);                
                #)
            if);
            storeOrigin;
         else
            (if (thisDesc->sematt.descKind) = sematt.externalClassKind then
                false -> genDefaultSuper
             else
                true -> genDefaultSuper
            if)
        if);
     exit prefDesc[]
     #);
   
---genClass:doPart---
do (# findBetaenv:
        (# D,BO: ^ASTindex; BE: @ASTindex
        enter D[]
        do D -> BE;
           L:
             (#
             do BE[] -> sematt.descOrigin -> BO[];
                (if not BO.isNull then
                    BO -> BE;
                    restart L
                if)
             #);
        exit BE[]
        #);
      genMain:
        (# desc,betaenvDesc: ^ASTindex;
           sig: @signature;
        enter desc[]
        do desc[] -> findBetaEnv -> betaenvDesc[];
           'main' -> sig.addMethod; sig.noEnter; sig.exitVoid;
           (1,'main',false,sig.asText,1) -> mch.initDo; 
           betaenvDesc[] -> newThisInstance;
           (*betaenvDesc[] -> newInstance(# do pushNull #);*)
           (betaenvDesc[],'do',sig[],true,true) -> callNDX;
           (false,0) -> mch.return; 
           mch.endMethod           
        #);
      genText2BetaText:
        (# sig: @signature
        do 'Text2BetaText' -> sig.addmethod;
           JavaStringSignatureId 
             -> SpecialSignature 
             -> mkListSignature
             -> sig.setEnter;
           BetaTextSignatureId -> SpecialSignature -> sig.setExit;
           (1,'Text2BetaText_i',false,sig.asText,1) -> mch.initDo;     
           sematt.textDesc[] -> newThisInstance;
           (false,11) -> mch.return; (* return reference *)
           mch.endMethod
        #);
      genAttach:
        (# sig: @signature
        do 'attach' -> sig.addMethod; 
           (sematt.superObject[],thisSuperChain,false) -> sig.setMethodDesc; (* ???*)
           sematt.superObject[] -> sig.addEnter; 
           sig.exitVoid;
           (1,'attach_i',false,sig.asText,1) -> mch.initDo; 
           (false,0) -> mch.return;
           mch.endMethod
        #);
      theDesc,topSuperName,superDesc,topDesc: @ASTindex;
      subLevel: @integer;
      superName: ^text;
      
      R: ^ProtoType;
      c: ^text;
      orgDesc: ^AStindex;
      EH: @evalHandler;
      orgName: ^text;
      locals: @LocalDescriptors;
      isMain,isBetaenv: @boolean;
      hasEnterMethod,hasDoMethod,hasExitMethod,isDoPartForm,isOuter
      ,hasClass: @boolean;
      constructorDesc: ^ASTindex; (* descriptor for possible constructor *)
   do 311->trace(#
                do 'genClass: "' -> xT; className[] -> xT;
                   '" blockLevel ='->xT; blocklevel -> xI; 
                #);

      (if desc.isSlot then
          '\n*** OBS! Slots are not handled by genClass: '->puttext;
          className[] -> putline;          
       else
          (formDesc.label = gram.doPart)
          and (blockLevel = 0) 
            -> isDoPartForm;
          (* This is an indirect way of representing
           * that we are compiling a dopart-form.
           * formDesc is global and refers the original 
           * form. We should represent this more explicitly.
           * thisDesc refers the descriptor having the
           * dopart-slot. We don't need to do initPtnGen
           * since a dopart form is always compiled
           * via genByteCode, which is called for gdbody
           * where the proper initialization has been done.
           * A REAL HACK: formDesc is only well defined when
           * compiling the outer form; does not work for inner
           * descriptors; we try fixing by also testing blockLevel;
           * BUT CLEAN-UP
           *)
          (* (if isDoPartForm then '\ndopart form'->putline if);*)
          (desc[],isDoPartForm) -> initPtnGen; (* thisDesc[] = desc[]
                                                * BUT: thisDesc[] is global and will
                                                * be redefined in case of nested
                                                * descriptors.
                                                * Below we should replace thisDesc
                                                * by desc!
                                                *)

          desc -> theDesc;
          (*313->trace(#
           do 'desc:hasSlots: ' -> xT; desc[] -> hasSlots->xB;
           ' isDoPartForm:'->xT; isDoPartForm -> xB;
           (if isDoPartForm then
           xN; 'formDesc:'->xT; formDesc[] -> xA
           if);
           100->switchOn;
           xN;
           theDesc[] -> xA;
           100 -> switchOff
           #);*)
          (if not (desc[] -> hasSlots) or isDoPartForm then
              true -> hasClass;
              path[] -> splitPathAndNAme -> (path[],c[]);
              313->trace(#
                        do 'Path: ' -> xT; path[] -> xT
                        #);
              (if not (common.switch[184] or common.switch[189]) then
                  (# Jfile: ^text
                  do className[]->path.append;
                     asmlink.asmext->(path.copy).append ->Jfile[];
                     (Jfile[],asmlink.byteCodeKind,true,false) 
                       -> AsmLink.TX.insert;
                  #)
              if);
              
              (theGroup.origin=NONE) -> mch.initDataSeg;
              313->trace(#
                        do 'Super: ' -> xT; pref[] -> xA;
                           ' pref.label: '->xT; pref.label->xI
                        #);
              (**** G-part ****)
              (if pref.label = gram.prefix then
                  pref.son -> topSuperName;
                  topSuperName[] -> getNameAsText -> superName[];
                  (* note: we need to do name mangling for the super name *)
                  topSuperName -> sematt.quaDesc -> superDesc;
                  (superDesc[],true) -> EH.descName -> superName[];
                  
                  topSuperName -> sematt.descChain -> (topDesc,subLevel); 
                  (* One super : subLevel = 0
                   * Two super : subLevel = 1
                   * ...
                   *)
                  (if topDesc -> sematt.superObject.equal then
                      (* As in V:< object;
                       *       V::< (# ... #)
                       *)
                      subLevel - 1 -> sublevel
                  if);
                  
                  (if (theDesc->sematt.descKind) 
                   // sematt.classKind then
                      (if subLevel = 0 then defaultSuperName -> superName[] if);
                      313->trace(#
                                do 'classKind:subLevel:' ->xT; subLevel->xI; 
                                   ' superName:'->xT; superName[] -> xT; xN;
                                   theDesc[] -> xA;
                                #)
                   // sematt.externalClassKind then
                      (* level 0: externalClase : ( #  # )
                       * level 1: foo: externalClass ( #   # )  - interface
                       * level 2: bar: foo ( #   # )            - real
                       * 
                       * level 2 should be 0 (zero) since this is the
                       * first real BETA subclass; subLevel from super
                       * is 1; we thus always subtract 1
                       *)
                      (if subLevel = 1 then
                          superDesc[] -> getExternalClassName -> superName[];
                          301->trace(#
                                    do 'superName:externalClass:' -> xT;
                                       superName[] -> xT; xN;
                                       superDesc[] -> xA
                                    #)                      
                      if);
                      313->trace(#
                                do 'externalClassKind:subLevel' -> xT;
                                   subLevel -> xI
                                #);
                      subLevel - 1 -> subLevel;

                   else
                      313->trace(#
                                do 'theDesc:kind:' -> xT; 
                                   theDesc->sematt.descKind -> xI; 
                                #);
                      subLevel + 1 -> subLevel
                  if);              
                  313->trace(#
                            do 'super: ' -> xT; subLevel -> xI;
                               superName[] -> xT; xN;
                               topDesc[] -> xA
                            #)
               else
                  theDesc -> topDesc;
                  (if true then
                      defaultSuperName -> superName[]
                   else                      
                      (if true
                       // common.targetMachineId = common.javabc then
                          'java/lang/Object'->supername[];
                       // common.targetMachineId = common.dotnet then
                          '[mscorlib]System.Object'->supername[];(*'/*3*/'->supername.append;*)
                       else
                          'Unknown_platform.Object' -> supername[];
                      if);
                  if);
                  0 -> subLevel
              if);
              (* Perhaps there should be an outer static method
               * also for patterns without a do-part, since they 
               * may be executed anyway - such calls are perhaps 
               * never generated by the compiler?
               * It seems so: if just an exit part as in
               * isX: (# exit a or b #)
               *)
              (blockLevel = 0) (*and (topDesc[] -> sematt.hasDo)*) -> isOuter;
              
              theDesc[] -> sematt.descOrigin -> orgDesc[];
              (if ((theDesc->sematt.descKind) = sematt.externalClassKind)
                  and not (theDesc[]->isBetaSubOfExternalClass) then
                  '-' -> orgName[]
               else
                  (if not orgDesc.isNull then
                      orgDesc[] -> mkSignature -> orgName[]
                   else
                      platFormSuperSignature -> orgName[]
              if)if);
              
              313->trace(#
                        do 'genClass:origin: ' -> xT; orgName[] -> xT;xN;
                           orgDesc[] -> xA; xN;
                           'superName: ' -> xT; superName[] -> xT
                        #);
              
                           (*301 -> trace(# do 'descFather:'->xT; N[] ->xA #);*)
              (* For java: the call to initGen initiates a new BCmachine
               * for Jasmin code generation and a new file
               *)
              ((*theDesc.nodeId div 2, - we reuse a field - BAD *)
              blockLevel,className[],false
              ,((superDesc[],superName[])->SuperSignature).asText
              ,subLevel,orgName[])
                -> mch.initGen;
              (* 'DefClass: ' -> puttext; className[] -> putline; *)
              
              (att[],doP[],false) -> declareFields;

              (pref[],subLevel) -> GenSuper -> constructorDesc[];
              (if not ReturnSaved then
                  (if true then 
                      '\ngenClass:constructorSignature:calledInMain'->putline;
                      (# sig: ^ConstructorSignature
                      do (orgDesc[],orgName[])
                           -> constructorSignature 
                           -> sig[];
                         sig.asText -> mch.constructorDef
                      #)
                   else
                      (true,theDesc.returnOff)->mch.SaveReturn;
                  if);
                  true -> ReturnSaved
              if);
              ('tstenv'->className.equalNCS)
              or ('betaenv'->className.equalNCS)
                -> isBetaEnv;
              
              'program' -> className.equal -> isMain;

              (att,0,&RepList[],locals[])->GenByteCodeAlloc;
              (if constructorDesc[] <> none then
                  (# sig: @signature;
                     A: @mch.RegAdr; off: @integer;
                  do (constructorDesc[],constructorDesc->DH.newSingle,false) 
                       -> sig.setMethodDesc;
                     ((thisDesc[],true) -> EH.descName,thisDesc[]) 
                       -> sig.addReceiver;
                     '_init' -> sig.addMethod;
                     constructorDesc[] -> sig.addEnter;
                     sig.exitVoid;
                     pushThis;
                     12 -> off;
                     sig.scanEnter
                     (# 
                     do off + 4 -> off -> A.off;
                        'enter' -> A.fieldName[];
                        current.asText -> A.fieldType[];
                        (if isRef -> A.isRef then
                            (A[],&mch.adrRegOperand[]) -> mch.ldVal
                         else
                            (A[],&mch.dataRegOperand[]) -> mch.ldVal
                        if)
                     #);
                     (sig.asText->mch.newTextOp,'M',true,false)->mch.gJsr;
                  #)
              if);
              (false,theDesc.returnOff)->mch.return; 
              mch.endMethod
          if);
          (if isOuter then (* hack *)
              (# ds: @ASTindex;
                 n,d,x: ^AStindex;
                 usPos: @integer
              do theDesc -> ds;
                 enterP[] -> N[];
                 doP[] -> d[];
                 exitP[] -> x[];
                 className.scanAll
                 (# pos: @integer
                 do pos+1 -> pos;
                    (if ch = common.nameManglingCh then pos -> usPos if)
                 #);
                 (if usPos > 0 then 
                     (usPos+1,className.length) -> className.sub -> classname[]
                 if);
                 (className[],theDesc[],true,theDesc[],topDesc[]
                 ,false,true,true)
                   -> genPtnMethod;
                 x[] -> exitP[];
                 d[] -> doP[];
                 n[] -> enterP[];
                 ds -> theDesc
              #)
          if);
          (if hasClass then
              (if (not isMain) or common.switch[186] then
                  enterP.label <> gram.empty -> hasEnterMethod;
                  doP.label <> gram.empty -> hasDoMethod;
                  exitP.label <> gram.empty -> hasExitMethod;
              if);
              true -> inEnterDoExitMethod;
              (if hasEnterMethod then
                  (* extra isEnter arg needed *)
                  TheDesc[] -> genEnterMethod
              if);
              (if hasDoMethod then
                  (TheDesc[]
                  , false(*not hasEnterMethod*), false (*not hasExitMethod*),subLevel) 
                    -> genDoMethod
              if);
              (if hasExitMethod then
                  (* extra isExit arg needed *)
                  TheDesc[] -> genExitMethod
              if);
              false -> inEnterDoExitMethod;
          if);
          handleNestedDescriptors
          (# pref: @ASTindex
          do 
             (* this is currently a nested singular descriptor;
              * we don't know whether it is an item or an insertion;
              * currently we assume an insertion, which we
              * also assume should be a local anonymous method;
              * we should test that no this(..)[] or other reference
              * stuff to static objects are present
              *)
             (if not (currentDesc[] -> skipDesc) then
                 (*'\nnested: ' -> puttext; currentCons -> putint; newline;
                  (currentDesc[],screen[],500) -> thePP;
                  *)
                 (if currentCons
                  // 1 (* singular static item *) then
                     currentDesc[] -> locals.save
                  // 2 (* singular inserted procedure item *) then
                     currentDesc.son -> pref;
                     (if true (*pref.label = gram.prefix*) then
                         currentDesc[] -> locals.save
                      else
                         (* just generating a method is an
                          * insufficient optimization
                          *)
                         currentDesc[] -> locals.addMethod
                     if)
                  // 3 (* singular dynamic descriptor *) then
                     currentDesc[] -> locals.save
                  else
                     '\n*** Unknown descriptor cons not handled ' -> putline
             if)if)
          #);
          locals.scanMethods
          (#
          do (if not (current[] -> skipDesc) then
                 ((current[],false)->EH.descName,current[]) -> genMethod
             if)
          #);
          locals.scanPtns
          (# D: @ASTindex; descKind: @integer
          do theDesc -> D; (* ugly *)
             (if not (current[] -> skipDesc) then (* skip *)
                 (if current.label 
                  // gram.unExpanded then
                     (* '\n*** descriptor: ' -> puttext;
                      (current[],screen[],500) -> thePP;
                      *)
                     
                     (if common.switch[186] then
                         ((current[],false)->EH.descName
                         ,current[],false,theDesc[],none
                         ,false,true,true)
                           -> genPtnMethod;
                     if)
                  // gram.objectDescriptor then
                     (if current->sematt.descKind
                      // sematt.generalKind 
                      // sematt.classKind
                      // sematt.procKind then
                         (* see gdbody for patterns we ignore;
                          * do we have the right ones here ?
                          *)
                         ((current[],false)->EH.descName
                         ,current[],false,theDesc[],none,false,true,true)
                           -> genPtnMethod;
                         D -> theDesc -> thisDesc;
                         ((current[],false)->EH.descName
                         ,current[],theDesc[]) 
                           -> genPtnClass
                     if)
                  else
                     (* attributeDenotation as 'A' in 'V:<A' *)
                     ((current[],false)->EH.descName
                     ,current[],false,theDesc[],none,false,true,true)
                       -> genPtnMethod;
                     D -> thisDesc -> theDesc;
                     ((current[],false)->EH.descName
                     ,current[],theDesc[]) 
                       -> genPtnClass
             if)if);
             D -> thisDesc -> theDesc
          #);
          (if hasClass then
              (if isMain then
                  313->trace(#
                            do 'generate main:' -> xT; xN; theDesc[] -> xA 
                            #);
                  (if common.switch[186] then
                      theDesc[] -> genMain;                 
                   else
                      ('main',theDesc[]) -> genMethod;
                  if)
              if);
              (if isBetaenv then
                  genText2BetaText;
                  genAttach
              if);

              mch.endClass; (* for Java this will close the jasmin-file *)
              (* 'endclass' -> putline;*)
          if);
          (******** handle inner classes ***********)
          thisBlockLevel + 1 -> thisBlockLevel;
          locals.scanClasses
          (#
          do (if not (current[] -> skipDesc) then
                 (if current->sematt.descKind
                  // sematt.generalKind 
                  // sematt.classKind
                  // sematt.procKind then
                     (* see gdbody for patterns we ignore;
                      * do we have the right ones here ?
                      *)
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel) 
                       -> genClass
                  // sematt.externalClassKind then
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel) 
                       -> genExternalClass
             if)if)
          #);      
          thisBlockLevel - 1 -> thisBlockLevel;   
          (if false then
              (* should be moved up or eliminated??*)
              (pref[],att[])->BindVirtuals;
              (nameId[],singular)->genSymbTable;  
          if)
      if)
   #)
   
---genEnterMethod:doPart---
do (# sig: @Signature;
      EH: @EvalHandler;
      enterA: @EH.EnterArgs;
      EVL: @AStindex;

      off: @integer
   do 311->trace(#
                do 'GenEnterMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genEnterMethod'->putline;
          
       else
          (if formDesc.label <> gram.dopart then
              (desc[],false) -> initPtnGen;
          if);
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          thisDesc[] -> sig.addEnter;
          'enter'->sig.addMethod;
          sig.exitVoid;

          8 -> off;
          (enterP.nodeId,'enter',false,sig.asText,sig.noOfEnterArgs) -> mch.initDo;
          
          enterP.son -> EVL;
          (if EVL.label = gram.evalList then EVL.son -> EVL if);

          enterA.init;
          (# nScan: @ | EH.scanNadr; more: @boolean
          do (thisDesc[],gen.thisRegAdr(*not used*),0,thisSuperChain,true) 
               -> nScan -> more;
             L:
               (if more then
                   'genEnter:asgToNelm1'->mch.comment;
                   enterA[]-> nScan.asgToNelm;
                   nScan -> more;
                   restart L
               if)         
          #);
          
          (false,0) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genDoMethod:doPart---
   (* generate a do-method for a general pattern;
    * simple: the enter- and exit-parts are simple
    * arguments and becomes arguments of do;
    * we should split simple into simpleEnter
    * and simpleExit
    *)
do (# sig: @Signature;
      exitVal: ^ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      methodName,innerName: ^text
   do 311->trace(#
                do 'GenDoMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genDoMethod' -> putline          
       else
          (if FormDesc.label = gram.doPart then
             (* '\ndopartform: do method'->putline*)
           else
              (desc[],false) -> initPtnGen;
          if);
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          (if simpleEnter then
              thisDesc[] -> sig.addEnter
           else
              sig.noEnter
          if);
          (if simpleExit then
              exitP[] -> sig.addExit;
              sig.exitId -> exitId;
              sig.exitVal[] -> exitVal[];
           else
              sig.exitVoid
          if);
          301 ->trace(# 
                     do 'genDoMethod:hasInner:sublevel:'->xT; 
                        subLevel -> xI;
                        doP[] -> xA;
                     #);
          ('do',subLevel) 
            -> methodAndInnerName 
            -> (methodName[],innerName[]);
          (if false and (not (desc[] -> sematt.hasInner)) then
              (* we should later optimize when no inner *)
              'do' -> innerName[] (* se else-part *)
              (* a hack with methodName[] -> innername[];
               * see bytecodebackend:initDo
               *)
          if);
          methodName[] -> sig.addMethod;
          (doP.nodeId,innername[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (if (doP.label <> gram.empty) then 
              (# GD: @GenDo
              do GD.restartLab.new; 
                 GD.restartLab.def;                 
                 doP -> GD.Scan;
          #)if);
          (if simpleExit and (exitVal[] <> NONE ) then
              (# aR: ^mch.RegAdr
              do gen.thisRegAdr -> aR[];
                 'exitVal' -> aR.fieldName[];
                 (aR[],exitVal[],false,ThisSuperChain) 
                   -> EH.ExpEval 
                   -> V[];
                 V.loadVal2;
              #)
          if);
          (false,exitId) -> mch.return;
          mch.endMethod
      if)
   #)
   

---GenByteCode:doPart---
do (# className,path: ^text; EH: @evalHandler;
      SetFileName:
        (# className,path,c: ^text; isBetaEnv: @boolean
        enter(className[],isBetaEnv)
        do (if common.switch[189] and isNonAttributesSlot then
               (none (* hack to signal to bytecodemachine that 
                      * this call is for defining the fileName *)
               ,common[]
               ,className[]
               ,(this(AstInterface)[],theGroup[])->getGroupIDProperty
               ) -> mch.init;
               301->trace(#
                         do 'currentFrag: '->puttext;
                            (thisDesc.frag[]).fullName -> putline
                         #);
               (if not isBetaEnv then
                   BCname[] -> splitPathAndNAme -> (path[],c[]);
                   className[] -> path.append;
                   (* AsmExt is appended in BCasmlink; at other unknown 
                    * places, asmExt is not appended either, so doing 
                    * it here gives problems
                    *)
                   ((*asmlink.asmext->(path.copy).append*) 
                   path[]
                   ,asmlink.BetaKind
                   ,true
                   ,false) 
                     -> AsmLink.TX.insert;
           if)if);
        #);
      genBetaObject:
        (# path,c: ^text; sig: @signature;
        enter path[]
        do (0,BetaObject,false,platformSuperName,0,'-') -> mch.initGen;
           path[] -> splitPathAndNAme -> (path[],c[]);
           (if not common.switch[189] then
               betaObject -> path.append;
               (asmlink.asmext->(path.copy).append
               ,asmlink.byteCodeKind,true,false) 
                 -> AsmLink.TX.insert;
           if);
           (if true then
               ((none,'-') -> constructorSignature).asText 
                 -> mch.constructorDef
            else
               (true,0) -> mch.saveReturn; (* generates constructor *)
           if);
           pushThis;
           ('initSuper','-')->mch.callAlloPrim; 
           (false,0) -> mch.return; 
           mch.endMethod;
           
           'do' -> sig.addMethod; sig.noEnter; sig.exitVoid;
           (1,'do',false,sig.asText,1) -> mch.initDo; 
           (false,0) -> mch.return; 
           mch.endMethod;
           
           mch.endClass
        #);

   do 313->trace
      (#
      do (if isJava then 'Compiler for Java bytecode' -> xT if);
         (if isDotNet then 'Compiler for .NET bytecode' -> xT if);
         xN;
         'genlib_bytecode: ' -> xT; xN;
         thisDesc[] -> xA;
         thisDesc[] -> sematt.hasAcode -> xB;
         returnSaved -> xB;
         xN;
         'path : ' -> xT; path[] -> xT; xN;
         'class: ' -> xT; xN;
         (thisDesc[],true) -> EH.descName -> xT;
         (if 'program'->thisFormName.equalNCS then
             'Main' -> xT
         if)
      #);
      (if true
       // 'program'->thisFormName.equalNCS then
          (thisDesc[],true) -> EH.descName -> className[];
          (className[],false) -> SetFileName;
          (BCname[],className[],thisDesc[],0) -> genClass;
          (*mch.close;*) (* this close is needed for .NET to actually
                          * produce a file; for javabc, the close
                          * is in synthesizerboy: mkdataseg
                          *)

       // 'tstenv'->thisFormName.equalNCS 
       // 'betaenv'->thisFormName.equalNCS then
          (if common.switch[186] then
              (thisDesc[],true) -> EH.descName -> className[];
           else
              'tstenv'->className[]
          if);
          (className[],true) -> SetFileName;
          BCname[] -> genBetaObject;

          (if true (*common.targetMachineId = common.javabc*) then
              (BCname[],className[],thisDesc[],0) -> genClass;
              (*mch.close*)
           else
              '\n*** tstenv not yet handled' -> putline;
          if);          
       // thisDesc.label = gram.objectDescriptor then
          (* Note: all outer patterns are curently assumed
           * to be clases; we should reconsider this
           * problem with at least externalClassbelow
           *)

          (thisDesc[],true) -> EH.descName -> className[]; 
          (className[],false) -> SetFileName;
          (if ThisDesc -> sematt.descKind 
           // sematt.externalClassKind then
              (BCname.copy,className[],ThisDesc[],0) -> genExternalClass 
           else
              (BCname[],className[],thisDesc[],0) -> genClass;
          if)
       else 
          (* we never come here anymore?*)
          '\n**in else part' -> putline;
          (if not (thisDesc[] -> skipDesc) then
              (thisDesc[],true) -> EH.descName -> className[];
              (if ThisDesc -> sematt.descKind
               // sematt.generalKind
               // sematt.classKind
               // sematt.procKind then
                  (* check with gdbody to see what we ignore here *)
                  (* here we should test for class- or proc-subpatterns *)
                  (if ThisDesc[]->Sematt.hasDo then
                      ((thisDesc[],false)->EH.descName,thisDesc[]) -> genMethod
                   else
                      (BCname[],className[],thisDesc[],0) -> genClass;
                  if)
               // sematt.externalClassKind then
                  (BCname.copy,className[],ThisDesc[],0) 
                    -> genExternalClass
          if)if)
      if)
   #)

---genExitMethod:doPart---
do (# sig: @Signature;
      exitVal: ^ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      aR: ^mch.RegAdr;
      T: ^ASTindex;
      xScan: @ | EH.scanXadr; more: @boolean;
      aD,OA: @mch.RegAdr;
      destField: @text; xNo,xNo1: @integer;
      methodName: @text;
      xTypes: ^EH.ExitTypes;
      fields: @
        (# field:
             (# name,type: ^text; kind: @char
             enter(name[],type[],kind)
             exit this(field)[]
             #);
           add:
             (# name,type: ^text; kind: @char
             enter(name[],type[],kind)
             do (if (top+1->top) > F.range then
                    F.range -> F.extend
                if);
                (name[],type[],kind) -> Field -> F[top][]
             #);
           declare:
             (#
             do (for i: top repeat
                     (0,F[i].name[],F[i].type[],F[i].kind) 
                       -> mch.declareField;
                for)
             #);
           F: [3] ^field;
           top: @integer
        #)
   do 311->trace(#
                do 'GenExitMethod:'->xT; desc[]->xA
                #);      
      (if desc.isSlot then
          '\nOBS! Slots not handled by genExitMethod'->putline
       else
          (desc[],false) -> initPtnGen;
          sig.noEnter;
          (thisDesc[],thisSuperChain,false)->sig.setMethodDesc;
          exitP[] -> sig.addExit;

          'exit' -> methodName;
          methodName[] -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          (exitP.nodeId,methodName[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          313->trace(#do 'genExitMethod:ExpEval: '->xT; exitVal[] -> xA #);
          (if sig.isMultiValExit then
              (desc[],gen.thisRegAdr,0,thisSuperChain) 
                -> xScan 
                -> more;
              'exit_' -> destField;
              (desc[] -> fieldSignature).asText 
                -> aD.receiverType[]
                -> aD.descName[]; (* elim descName *)
              true -> OA.isOrigin;
              (*'\nExitTypes: ' -> puttext;*)
              loop:
                (if more then
                    (OA[],none) -> mch.ldVal;
                    gen.thisRegAdr->aR[];
                    'exit'->aR.fieldName[];
                    (aR[],xScan.thisEv[],true,ThisSuperChain) 
                      -> EH.ExpEval 
                      -> V[];
                    311 -> trace(#
                                do 'genExitMethod: ' -> xT;
                                   V.display; xN;
                                   'xNo: ' -> xT; xNo -> xI;
                                   ' xNo1: ' -> xT; xNo1 -> xI
                                #);

                    (desc[],xNo,OA[],ThisSuperChain)
                      -> V.asgToExitArgs  
                      -> (xNo1,xTypes[]);
                    
                    311->trace(#do 'xNo1:' -> xT; xNo1 -> xI #);
                    (if xNo = xNo1 then
                        (* OBS we assume a simpleVal but in txtCstVal
                         * this mau be converted to a textVal
                         *)
                        true -> V.pushVal; (*V.loadVal2;*)
                        (* pushval/mkBetatext should be cleaned up *)
                        V.type -> T[];
                        (if T -> sematt.textDesc.equal then V.mkBetaText if);
                        true -> aD.isField;
                        (if true then                            
                            (xNo+1->xNo->(destField.copy).putint
                            ,T[] -> mkSignature,'c') 
                              -> fields.add
                         else
                            (0,xNo+1->xNo->(destField.copy).putint
                            ,T[] -> mkSignature,'c') 
                              -> mch.declareField;
                        if);
                        xNo 
                          -> (destField.copy).putint 
                          -> aD.fieldName[];
                        T[]  -> theGen.mkSignature -> aD.fieldType[];
                        (&mch.adrRegOperand[],aD[]) -> mch.stVal;
                     else
                        xTypes.scan
                        (# 
                        do (*(current[] -> fieldSignature).asText -> puttext;
                            ',' ->put;*)
                           (if true then
                               (xNo+1->xNo->(destField.copy).putint
                               ,current[] -> mkSignature,'c') 
                                 -> fields.add
                            else
                               (0,xNo+1->xNo->(destField.copy).putint
                               ,current[] -> mkSignature,'c') 
                                 -> mch.declareField;
                           if)
                        #);  
                    if);
                    xScan -> more;
                    (if more then restart loop if)
                if);
              PushThis;
              (*newline;              *)
           else
              gen.thisRegAdr->aR[];
              'exit'->aR.fieldName[];
              (aR[],exitVal[],false,ThisSuperChain) 
                -> EH.ExpEval 
                -> V[];
              301 -> trace(#
                          do 'genExitMethod: ' -> xT;
                             V.display
                          #);
              (* OBS! see pushVal above regarding isSimpleVal 
               * enter argument 
               *)
              true -> V.pushVal; (*V.loadVal2;*)
              (* pushval/mkBetatext should be cleaned up *)
              V.type -> T[];
              (if T -> sematt.textDesc.equal then V.mkBetaText if);
          if);
          (false,exitId) -> mch.return;
          mch.endMethod
      if);
      fields.declare      
   #)
   
---genMethod:doPart---
do (# sig: @Signature;
      exitVal: ^ASTindex;
      sort: @ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      superName,innerName: ^text;
      superDesc: ^ASTindex;
      subLevel: @integer;
      aR: ^mch.regAdr
   do (if desc.isSlot then
          '\nOBS! Slots not handled by genMethod'->putline;
          
       else
          (desc[],false) -> initPtnGen;
          (* desc.father -> sort;
           '.method: ' -> puttext; 
           (if sort.label
           // gram.patternDecl then 'pattern ' -> puttext
           // gram.virtualDecl then 'virtual ' -> puttext;
           // gram.bindingDecl then 'binding ' -> puttext;
           // gram.finalDecl   then 'final ' -> puttext
           else 'other? ' ->puttext
           if);*)
          desc[] -> descChain -> (superName[],superDesc[],subLevel);
          (* is this waht we want? subLevel should not of thisDesc
           * but from enclosing desc?
           *)
          methodName.copy -> innerName[];
          (if subLevel > 0 then          
              '_do_' -> methodName.append;
              subLevel -> methodName.putint;
          if);
          (if not ('main' -> methodName.equal) then
              (* Note! innernName is used for two purposes:
               * 1. the name of a possible inner method
               * 2. the name of method 'main'
               * if innerName = 'main' then there is no inner method
               *)
              '_do_' -> innerName.append;
              subLevel + 1 -> innerName.putint;
          if);

          (*methodName[] -> puttext;      
           ' super:' ->puttext; superName[] -> puttext; 
           ' level:'->puttext; subLevel -> putint; 
           ' inner:'->puttext; innerName[] -> putline;*)
          
          (* (pref,common.itemKind)->PrefixAlloc;*)
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          (if subLevel > 0 (*thisDesc[] -> sematt.hasNcode*) then
              sig.noEnter
           else
              thisDesc[] -> sig.addEnter
          if);
          exitP[] -> sig.addExit;
          methodName[] -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          313->trace(#
                    do 'genMethod: "' -> xT; methodName[] -> xT;
                       '" Signature: ' -> xT; sig.asText -> xT
                    #);
          (doP.nodeId,innerName[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          
          (if true or isDotNet then
              (* needed for .NET; not needed for Java *)
              (att[],doP[],true) -> declareFields;
          if);
          
          (if (doP.label <> gram.empty) then 
              (# GD: @GenDo
              do GD.restartLab.new; 
                 GD.restartLab.def;                 
                 doP -> GD.Scan;
          #)if);

          (if exitVal[] <> NONE  then 
              gen.thisRegAdr->aR[];
              'exit_'->aR.fieldName[];
              (aR[],exitVal[],false,ThisSuperChain) 
                -> EH.ExpEval -> V[];
              V.loadVal2
              (* else call of foo/do leaves return value on stack *)
          if);
          (false,exitId) -> mch.return; 
          mch.endMethod
      if)
   #)
