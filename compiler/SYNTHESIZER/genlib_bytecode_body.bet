ORIGIN 'genlib_bytecode';
INCLUDE '~beta/basiclib/formatio';
---theGenlib:attributes---
getNameWithoutPackage:
  (* for name = 'foo/bar/fisk'
   * return 'fisk'
   *)
  (# name: ^text;
     slashPos: @integer
  enter name[]
  do name.scanAll
     (# pos: @integer 
     do pos+1 -> pos; (if ch = '/' then pos -> slashPos if)
     #);
     (if slashPos > 0 then
         (slashPos+1,name.length) -> name.sub -> name[]
     if);
  exit name[]
  #);
checkFinal2virt: booleanValue
  (# desc: ^ASTindex;
     sort,BD,BA,VN,VS: @ASTindex
  enter desc[]
  do desc.father -> sort;
     (if sort.label = gram.finalDecl then
         desc -> BA -> sematt.descrip -> BD;
         (if BD.label
          // gram.virtualDecl // gram.bindingDecl then
             (* W:: Va  where  Vd:< T
              * BA = Va
              * BD   = W:: Va
              * VN   = Vd
              * VS   = Vd:< T
              *)
             true -> value;
             desc -> sematt.GetName -> VN;
             VN.dclRef -> VN; VN.sort -> VS;
             (VS.sonRef).brother -> VS;
             301->trace(#
                     do 'final2virt: ' -> xT;
                        'BA: ' -> xT; BA[] -> xA; xN;
                        'BD: ' -> xT; BD[] -> xA; xN;
                        'VN: ' -> xT; VN[] -> xA; xN;
                        'VS: ' -> xT; VS[] -> xA; xN;
                        'thisDesc: ' -> xT; thisDesc[] -> xA
                     #)
         if)
     if);
  exit(VN[],BA[])
  #);
newBCstrucObject:
  (* don't confuse this one with the one ien evbpdy;
   * this one is used for the body of genVirtualStrucMethod 
   * below; perhaps they should be unified
   *)
  (# EV: ^ASTindex; EH: @evalHandler;
     chain1: ^DH.superChain;
     (* exit *)
     W: ^EH.evVal;                    
     
     ES,desc: @ASTindex; 
     EVchain: ^DH.superChain;
     OA: ^mch.address;
     N: ^text;
     sig: @theGen.signature;
     receiverDesc: ^ASTindex
  enter(EV[],chain1[]) 
  do (* handle externalClass
      *
      *)
     313->trace(#
               do 'genlib_bytecode:newBCStrucObject:'->xT; EV[] -> xA;
               #);
     (if EV.label = gram.structureReference then
         EV.son -> ES;
      else
         EV -> ES
     if);
     ES -> sematt.descrip -> desc;  
     true -> inEnterDoExitMethod;
     (gen.thisRegAdr,thisDesc[],ES[],chain1[])
       -> genOrgAdrToOrgReg
       -> OA[];
     false -> inEnterDoExitMethod;

     (if desc.label <> gram.objectDescriptor then 
         (* virtual, see newBCobject
          * we come here when called from genVirtStruc below
          * for a final2virt binding
          *)
         ES -> sematt.getName -> ES; ES.gettext -> N[];
         '$struc' -> N.append; 
         desc[] -> sematt.encDescOfNode -> receiverDesc[];
         ((receiverDesc[],true) -> EH.descName,receiverDesc[]) 
           -> sig.addReceiver;
         N[] -> sig.addMethod;
         sig.noEnter;
         theGen.StructureSignatureId->theGen.specialSignature->sig.setExit;
         (sig.asText-> mch.newTextOp,'M',false,false) -> mch.gJsr;  
      else
         313->trace(#do 'newBCstrucObject:actualDesc:'->xT; desc[] -> xA #);
         (chain1[],ES) -> DH.theDesc -> (desc,EVchain[]);
         (if isJava then (* FIXME *)
             ('AlloS',(desc[],true)->EH.descName) -> mch.callAlloPrim
          else
             ('AlloS',desc[]->theGen.mkSignature) -> mch.callAlloPrim
         if);
     if);  
     (mch.callO,true,ES[],chain1[])->EH.mkComputedRefEvVal->W[];
  exit W[]
  #);
genVirtualStrucMethod:
  (# name: ^ text; dcl: ^ASTindex;
     EH: @evalHandler;
     spec,desc: @ASTindex;
     sig: @Signature;
     descKind: @integer;
     strucMethodName: ^text
  enter(name[],dcl[])
  do 311 -> trace(#
                 do 'genVirtualStrucMethod:'->xT; name[] -> xT
                 #);
    (* (thisDesc[],spec[]) -> GetActualDesc -> (desc,descKind);*)
     sig.noEnter;
     StructureSignatureId 
       -> SpecialSignature 
       -> mkListSignature
       -> sig.setExit;
     '$struc' -> (name.copy).append -> strucMethodName[] -> sig.addMethod;

     (14,strucMethodName[], true,sig.asText,0) -> mch.initdo;
     
     (dcl.sonref).brother -> spec;
     (if dcl.label = gram.finalDecl then
         spec -> sematt.descrip -> desc;
         (if desc.label
          // gram.virtualDecl // gram.bindingDecl then
             (* a final 2 virtual binding - apparently it works,
              * but perhaps origin is not correct
              *)
         if)
     if);     
     
     (spec[],thisSuperChain) -> newBCstrucObject;
     
     (false,11) -> mch.return;
     
     mch.endMethod;
  #);
genPtnVarMethod:
  (# N,               (* name of pattern variable *)
     spec: ^ASTindex; (*  ## T *)
     desc,pref,topSuperName,receiver: @ASTindex;
     topDesc: ^ASTindex;
     sig: @signature;
     descKind,subLevel: @integer
  enter(N[],spec[])
  do 311 -> trace(#
                 do 'GenPtnVarMethod: '->xT; N[] -> xA; 
                    ':'->put; spec[] -> xA 
                 #);
     (thisDesc[],spec.sonRef) -> GetActualDesc -> (desc,descKind);
     thisDesc -> receiver;
     (N.gettext,desc[],false,true,none,none,false,true,true)
       -> genPtnMethod
     (# A: @mch.RegAdr;
     do 311 -> trace(#do 'GenPtnVarMethod:Inner:'->xT; N[] -> xA; #);
        theGen.pushThis;
        true -> A.isField;
        receiver[] -> theGen.mkSignature -> A.receiverType[];
        N.getText -> A.fieldName[];
        (theGen.StructureSignatureId->theGen.specialSignature).asText -> A.fieldType[];
        311->trace(#do A.display ->xT #);
        (A[],A.fieldType[],none) -> mch.loadRef;
        'AlloSI' -> mch.CallPrim; 
        desc[] -> theGen.mkSignature -> mch.checkCast
     #);
        
  #)
---synthesizerbody_handlepackage:doPart---
do (# DN: ^text;
      D: @directory;
      touch:
        (#
        do DN[] -> D.name;
           (if D.entry.exists then
               313->trace(#
                         do ' exists: '->puttext; 
                            DN[] -> putline;
                         #);
            else
               313->trace(#
                         do ' does not exist: '-> puttext;
                            DN[] -> putline;
                         #);
               D.touch
           if);           
        #);
      touchAll:
        (# S: ^text
        enter S[]
        do S.scanAll
           (#
           do (if ch 
               // '/'
               // '.' then 
                  touch;
                  '/' -> DN.put
               else
                  ch -> DN.put
              if)
           #);
           touch;
        #);
   do theGroup.diskFileName -> d.name;
      d.entry.path.head -> DN[]; (* Full path of directory of fragmentgroup *)
      
      theGroup.prop.scanprop
      (# doProp::
           (#
           do prop.makelc;
              (if 'package' -> prop.equal then
                  313->trace(#
                            do '\nPACKAGE: ' -> puttext;
                            #);
                  scanparameters
                  (# doString:: 
                       (#
                       do 313->trace(#
                                    do S[] -> putline;
                                    #);
                          (if isJava then
                              '/jvm/' -> DN.append;
                              touch; (* make sure 'jvm' exists *)
                           else
                              '\nOBS! No package implementation for .NET'
                                -> putline
                          if);
                          S[] -> touchAll;
                          S.copy -> thisPackagePath[];
                          '.' -> thisPackagePath.findAll(# do '/' -> thisPackagePath.T[inx] #);
                          '/' -> thisPackagePath.put;
                          thisPackagePath[] -> mch.setPackagePath;
                          thisPackagePath[] -> asmLink.setPackagePath;
                       #)
                  #)                  
              if)
           #)
      #);
      (if thisPackagePath[] = none then
          '/jvm/'-> DN.append; touch;
          common.BetaPackage -> touchAll;
          common.BetaPackage -> thisPackagePath[]; 
          thisPackagePath[] -> mch.setPackagePath;
          thisPackagePath[] -> asmLink.setPackagePath;
      if);
      (* formset.scan(#do current.formid [] -> puttext; ' id:' -> puttext;
                     current.index -> putint; newline
       #)*)
   #)
---genPtnMethod:doPart---
   (* Calling a general pattern as a method
    * 
    * Simple form
    *    .method foo(x1x2x3)y
    *       new foo
    *       push x1
    *       push x2 
    *       push x3
    *       call foo/do(x1x2x3)y
    *       zreturn
    *  General form
    *       new foo
    *       store R
    *       load R
    *       push x1
    *       push x2
    *       push x3
    *       call foo/enter(x1,x2,x3)V
    *       call foo/do()V
    *       call foo/exit()y
    *       zreturn
    *)
do (# sig: @Signature;
      hasNcode,hasDoCode,hasXcode: @boolean;
      exitId: @integer;
      EH: @evalHandler;
      exitVal: ^ASTindex;
      EVL,EV: @ASTindex; V: ^EH.evVal;
      orgName: ^text;
      theDesc,thisDescX,objSpec
      ,D,pref,topSuperName,sort,BA,BD,VN,VS: @ASTindex;
      descKind,subLevel,MN,isVirtual: @integer;
      nonLocal,isFinal2virt: @boolean;
      nScan: @sematt.nxScanner;
      OA: ^mch.address;
      chain: ^DH.SuperChain
   do 311->trace(#
                do 'genPtnMethod: '->xT; patternName[] -> xT; xN;
                   'desc: ' -> xT; desc[] -> xA;
                   'topDesc:' -> xT; topDesc[] -> XA;
                #);
      patternname[] -> getNameWithoutPackage -> patternname[];
      (* is objspec used below?*)
      desc -> objSpec;

      (if desc.label 
       // gram.objectDescriptor 
       // gram.unExpanded then
       else
          desc.father -> sort;
          (if sort.label = gram.finalDecl then
              desc -> BA -> sematt.descrip -> BD;
              (if BD.label
               // gram.virtualDecl // gram.bindingDecl then
                  (* W:: Va  where  Vd:< T
                   * BA = Va
                   * BD   = W:: Va
                   * VN   = Vd
                   * VS   = Vd:< T
                   *)
                  true -> isFinal2virt;
                  desc -> sematt.GetName -> VN;
                  VN.dclRef -> VN; VN.sort -> VS;
                  (VS.sonRef).brother -> VS;
                  301->trace(#
                          do 'final2virt: ' -> xT;
                             'BA: ' -> xT; BA[] -> xA; xN;
                             'BD: ' -> xT; BD[] -> xA; xN;
                             'VN: ' -> xT; VN[] -> xA; xN;
                             'VS: ' -> xT; VS[] -> xA; xN;
                             'thisDesc: ' -> xT; thisDesc[] -> xA
                          #)
              if)
          if);
          true -> nonLocal;
          thisDesc -> thisDescX;
          (thisDesc[](*?*),desc[])
            -> GetActualDesc 
            -> (D,descKind);
          301->trace(#
                  do 'desc: ' -> xT; D[] -> xA; xn;
                     'thisDesc: ' -> xT; thisDesc[] -> xA
                  #);
          &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
          D -> desc;
          none -> topDesc[]
      if);
      (if topDesc[] = none then
          desc.son -> pref;
          &ASTindex[] -> topDesc[]; (* prevent aliasing *)
          (if pref.label = gram.prefix then
              pref.son -> topSuperName;
              topSuperName -> sematt.descChain -> (topDesc,subLevel)
           else
              desc -> topDesc;
      if)if);
      desc -> theDesc;
      (if desc.isSlot then 
          (if false then
              '\n*** OBS! Slots are not handled by genPtnMethod: '->puttext;
              patternName[] -> putline;
          if);
          sig.noEnter;
          sig.exitVoid;
          true -> hasDoCode
       else
          (desc[],false) -> initPtnGen;
          313->trace(#
                    do 'genPtnMethod: '->xT; patternName[]->xT; xN; 
                       'doPart: ' -> xT; doP[] -> xA
                    #);
          (* if we add a constructor possibility to BETA;
           * we must get the signature from the constructor
           * of the pattern
           *)
          (if withN then
              (if not (enterP.label <> gram.empty -> hasNcode) then
                  (theDesc[],true,thisSuperChain) -> nScan;
                  nScan.length > 0 -> hasNcode
          if)if);
          (*withN and (enterP.label <> gram.empty) -> hasNcode;*)
          withX and (exitP.label <> gram.empty) -> hasXcode;
          
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;

          (if isStatic then sig.markStatic if);
          thisDesc[] -> sig.addEnter;
          exitP[] -> sig.addExit;

          topDesc[]  -> sematt.hasDo -> hasDoCode
      if);
      patternName[] -> sig.addMethod;
      sig.exitId -> exitId;
      sig.exitVal[] -> exitVal[];
      
      sig.exitVal[] <> none -> hasXcode; (* note we override hasXcode
                                          * above; exitP is only for
                                          * the mainpart; possible exitlist
                                          * in superpatterns are not
                                          * handled
                                          *)
      (if not inLine then
          (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;       
      if);
      (* Consider
       *    foo:
       *      (# a,b,c: 2integer
       *      enter(a,b,c)
       *      do ...
       *      exit c
       *      #)
       * We here assume that enter & exit are on the form
       * of traditional method-parameters - general enter/exit
       * is not handled.
       * The following code is generated:
       *     return new foo(a,b,c).do
       *)
      (if hasNcode or hasDoCode or hasXcode then
          (if isVarPtn then
              INNER genPtnMethod
           else
              (if isStatic then
                  (* 1st argument should be origin - FIX this *)
                  (theDesc[],common.itemKind) -> newThisInstance; (* note that this for this 
                                                 * static method is an 
                                                 * explict argument
                                                 * of type reference
                                                 *)
                  false -> sig.isStatic;
                  thisDesc[] -> sig.addEnter;
               else
                  (if isFinal2virt then
                      true -> inEnterDoExitMethod;
                      301->trace(# F: @ASTindex;
                              do 'before:genOrigin: '-> xT; BA[] -> xA;
                                 BA.father -> F; F[] -> xA; 
                                 'BA.on: ' -> xT; BA.on -> xI; xN;
                                 'thisDescX: ' -> xT; thisDescX[] -> xA
                              #);
                      gen.thisRegAdr->OA[];
                      thisDescX[] -> OA.bAdr.localDesc[];
                      (OA.copy,thisDescX[],BA[],thisDescX->DH.newSIngle)
                        -> genOrgAdrToOrgReg
                        -> OA[];
                      false -> inEnterDoExitMethod;
                      (*(thisSuperChain,BA) 
                        -> DH.theDesc 
                       -> (desc,MN,chain[],isVirtual);*)
                      301->trace(# F: @ASTindex
                              do 'methodName: VN:'->xT; VN.getText-> xT; xN;
                                 'receiver: ' ->xT;
                                 (OA.bAdr.localDesc[],true)
                                   -> EH.descName -> xT;
                                 xN;
                                 'receiverDesc: ' -> xT;
                                 OA.bAdr.localDesc[] -> xA; xN;
                                 'theDesc: ' -> xT;
                                 (theDesc[],true) -> EH.descName -> xT; xN;
                                 theDesc[] -> xA; xN;
                                 theDesc.father -> F;
                                 'father: '-> xT; xN; F[] -> xA; xN;
                                 'topDesc: ' -> xT; xN;
                                 topDesc[] -> xA; xN;
                                 topDesc.father -> F;
                                 'topDesc:father:'->xT; xN;
                                 F[] -> xA
                              #);
                      (VN[],OA[],theDesc[],common.itemKind)
                        -> theGen.CallClassPtnMethod
                   else
                      (if inline then
                          (theDesc[] ,common.itemKind)-> newInstance
                          (#
                          do (if hasOrigin then INNER genPtnMethod if)
                          #)
                       else
                          (theDesc[],objSpec[],originDesc[],nonLocal) 
                            -> newInstanceWithOrigin
          if)if)if)if);

          (if hasNcode then
              313->trace(#
                        do 'pushEnter:'->xT;
                           enterP[] -> xA; xN;
                           'desc:'->xT;
                           thisDesc[] -> xA
                        #);
              (if hasDoCode or hasXcode then mch.duplicate if);
              (if not hasNcode then
                  (* this then-part should probably be the same
                   * as the else-part
                   *)
                  '\nOBS! genPtnMethod: we should not come here!'->putline;
                  enterP.son -> EVL;
                  (if EVL.label = gram.evalList then EVL.son -> EVL if);
                  EVL->scanList
                  (# EV: @ASTindex
                  do currentNode -> EV;
                     (gen.thisRegAdr,EV[],false,thisSuperChain)
                       -> EH.ExpEval
                       -> V[];
                     V.pushVal
                  #);
               else
                  (# A: @mch.RegAdr; off: @integer;
                     ar: @mch.adrRegOperand; 
                     dr: @mch.dataRegOperand
                  do 8 -> off;
                     sig.scanEnter
                     (# 
                     do off + 4 -> off -> A.off;
                        common.enterMethod -> A.fieldName[];
                        current.asText -> A.fieldType[];
                        (if isRef -> A.isRef then
                            (A[],ar[]) -> mch.ldVal
                         else
                            (A[],dr[]) -> mch.ldVal
                        if);
                        (if current.elmType = 6 (* double *) then
                            (if isJava then
                                off + 4 -> off -> A.off;
                            if);
                        if);                        
                  #)#)
              if);
              (theDesc[],common.enterMethod,sig[],false,true) -> callNDX
          if);

          (if hasDocode then
              (if hasXcode then mch.duplicate if);          
              (topDesc[],common.doMethod,sig[],true,true) -> callNDX
          if);
          (if hasXcode then
              (theDesc[],common.exitMethod,sig[],true,false) -> callNDX
           else 
              0 -> exitID (* should perhaps be handled in Signature *)
      if)if);
      (if not inline then
          (false,exitId) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genPtnClass:doPart---
do (# sig: @Signature;
      objSpec,theDesc,D,VD,thisDescX: @ASTindex;
      topDesc,VN,BA: ^ASTindex;
      nonLocal,isFinal2virt: @boolean;
      descKind: @integer;
      OA: ^mch.address
   do 311->trace(#
                do 'genPtnClass: '->xT; patternName[] -> xT; xN;
                   'desc:' -> xT; desc[] -> xA; xN;                 
                   'thisDesc:' -> xT; thisDesc[] -> xA; 
                #);
      (if false (*desc.isSlot*) then
          '\n*** OBS! Slots are not handled by genPtnClass: '->puttext;
          patternName[] -> putline;          
       else
          desc -> objSpec;
          desc.father -> VD;
          (if desc.label 
           // gram.objectDescriptor 
           // gram.unExpanded then
           else
              desc[] -> checkFinal2virt -> (isFinal2virt,VN[],BA[]);
              true -> nonLocal;
              (thisDesc[](*?*),desc[])
                -> GetActualDesc 
                -> (D,descKind);
              &ASTindex[] -> desc[]; (* to prevent aliasing; ugly! *)
              D -> desc;
          if);
          thisDesc -> thisDescX;
          desc -> theDesc;
          (if desc.label = gram.unExpanded then
              &ASTindex[] -> topDesc[];
              desc -> thisDesc;
              desc[] -> topDesc[];
           else
              (if (VD[] -> virtualTopDesc -> topDesc[]) = none then
                  &ASTindex[] -> topDesc[];
                  theDesc -> topDesc;
              if);
              (desc[],false) -> initPtnGen;
          if);
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          sig.noEnter;
          topDesc[] -> sig.exitRef;
          patternName[] -> sig.addMethod;
          sig.markAsPtnClassMethod;
          (doP.nodeId,patternName[],true,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (if isFinal2virt then
              true -> inEnterDoExitMethod;
              301->trace(# F: @ASTindex;
                      do 'before:genOrigin: '-> xT; BA[] -> xA;
                         BA.father -> F; F[] -> xA; 
                         'BA.on: ' -> xT; BA.on -> xI; xN;
                         'thisDescX: ' -> xT; thisDescX[] -> xA
                      #);
              gen.thisRegAdr->OA[];
              thisDescX[] -> OA.bAdr.localDesc[];
              (OA.copy,thisDescX[],BA[],thisDescX->DH.newSIngle)
                -> genOrgAdrToOrgReg
                -> OA[];
              false -> inEnterDoExitMethod;
              (VN[],OA[],theDesc[],common.itemKind)
                -> theGen.CallClassPtnMethod
           else
              (theDesc[],objSpec[],originDesc[],nonLocal)
                -> newInstanceWithOrigin
          if);
          (false,11) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genExternalClass:doPart---
do (# jFile,c: ^text
   do 311->ctrace(#
                 do 'genExternalClass: '->xT; classname[] -> xT
                 #);
      (if desc[] -> isBETAsubOfExternalClass then
          313->ctrace(#do 'generate BETA subclass' -> xT; #);
          (if false then
          theGroup.prop.scanprop
          (# doProp::
               (# trace: (# exit false #);
               do prop.makelc;
                  (if 'package' -> prop.equal then
                      (if trace then
                          '\nPATH: ' -> puttext; path[] -> puttext;
                          '\nPACKAGE: ' -> puttext;
                      if);
                      scanparameters
                      (# doString:: 
                           (# T: @text
                           do (if trace then
                                  S[] -> putline;
                              if);
                              (if false then
                                  S.scanAll
                                  (#
                                  do (if ch = '.' then 
                                         '/' ->T.put
                                      else
                                         ch -> T.put
                                     if)
                                  #);
                                  '/' -> T.put;
                                  T[] -> className.prepend;
                               else
                                  '.' -> S.put;
                                  S[] -> className.prepend
                              if);
                              (if trace then
                                  classname[] -> putline
                              if);
                           #)
                      #)
                  if)
               #);
          #)if);
          (path[],className[],desc[],0,false) -> genClass;
       else 
          313->ctrace(#do 'external interface: no codegeneration'->xT #);   
          path[] -> splitPathAndNAme -> (path[],c[]);
          desc[] -> getExternalClassName -> path.append;
      if)
   #)
   
---genlib_virtualTopDesc:doPart--
do (if VD.label // gram.bindingDecl // gram.finalDecl then
       VD.son -> sematt.singleName -> VN;
       L: (#
          do VN.virtDcl -> VN;
             VN.sort -> VD;
             313->trace(#
                       do 'genPtnClass:binding: ' -> xT;
                          VN[] -> xA;
                          VD[] -> xA
                       #);                        
             (if not (VD.label = gram.virtualDecl) then
                 restart L
             if)
          #);
    else
       VD.son -> sematt.singleName -> VN         
   if);
   (if VD.label = gram.virtualDecl then
       313->trace(#do VN[] -> xA #);
       VN.father -> VN;
       &ASTindex[] -> topDesc[];
       VN.brother -> topDesc;
       313->trace(#do topDesc[] -> xA #);
       (if not (topDesc.label = gram.objectDescriptor) then
           (thisDesc[](*?*),topDesc[])
             -> GetActualDesc 
             -> (topDesc,descKind)
       if);
       313->trace(#
                 do 'genPtnClass:topDesc: ' -> xT;
                    topDesc[] -> xA;
                 #);              
    else
       none -> topDesc[];(*
       1->trace(#
               do 'virtualTopDesc:did not find virtualDecl:' -> xT;
                  VD[] -> xA
               #)*)
   if)
   
---genlib_CallClassPtnMethod:doPart---
do (ES[],thisSuperChain(*?*),true(*?*)) -> sig.setMethodDesc;
   ((OA.bAdr.localDesc[],true) -> EH.descName,OA.bAdr.localDesc[])
     -> sig.addReceiver;
   VN.gettext -> sig.addMethod;
   sig.markAsPtnClassMethod;
   sig.noEnter;
   VN.sort -> sort;
   313->trace(#
           do 
              'callClassPtn: ' -> xT; VN.gettext -> xT;
             ' sort: '->xT;  sort[] -> xA
           #);
   (if (sort[] -> virtualTopDesc -> topDesc[]) <> none then
       (* 1->trace(#do topdesc[] -> xA #);*)
       topDesc[] -> sig.exitRef
    else
       sig.exitRef
   if);
   313->trace(#do 'CallClassPtn: ' -> puttext; sig.asText -> putline #);
   
   (sig.asText->mch.newTextOp,'M',false(*?*),false) -> mch.gJsr;
   (if kind = common.compKind then
       ('AlloC','') -> mch.callAlloPrim
   if);

   sig.thisMethodDesc[] -> theGen.mkSignature -> sigT[]
   
---genlib_bytecode_genFields:doPart---
do (# spec,desc,AD: @ASTindex; descKind: @integer; sig: ^text;
      EH: @EvalHandler;
      ftag: @char;
      declareRef:
        (# desc: ^ASTindex
        enter desc[]
        do desc[] -> mkSignature -> sig[];
           308->trace(#
                     do 'field: ' -> xT; N[] -> xA; sig[] -> xT
                     #);
           (N.off,N.getText,sig[],fTag) -> mch.declareField (* hack *)
        #);
      nD: ^sematt.AttDesc; 
   do
      (if isMethodFields then 'm'->fTag else 'c' -> fTag if);
      (* fTag and emitCk should be replaced by a cleaner and
       * more efficient solution
       *)
      (if dcl.label
       // gram.simpleDecl then
          dcl.son -> spec;
          spec.brother -> spec;
          spec.son -> AD;
          (if AD.label 
           // gram.objectDescriptor then
              (* we need to push here to get the descriptor
               * properly marked - however, if desName
               * returns static item name this may not
               * be needed
               *)
              (if first then (AD,0,1,N) -> DS.push if);
              AD -> desc;
           // gram.unExpanded then
              (* X: @ <<SLOT fool:descriptor>>
               * GetActualDesc will return object;
               * we need the class to have the correct type
               * of the field.
               *)
              AD -> desc;
           else
              (if true then
                  (AD[],thisSuperChain) -> sematt.AttDesc -> nD[];
                  nD.dclDesc -> desc;
               else                  
                  (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
              if)
          if);
          (*1->trace(#
                  do 'dclField: '->xT; dcl[] -> xA;xN; desc[] -> xA; xN;
                     nD.display
                  #);*)
          (if spec.label 
           // gram.dynamicItem 
           // gram.dynamicComponent then
              desc[] -> declareRef
           // gram.staticItem 
           // gram.staticComponent then
              (if desc.label = gram.unExpanded then
                  sematt.generalKind -> descKind
               else
                  desc->sematt.descKind->descKind; (* descKind from actualDesc
                                                    * don't work? *)
              if);
              (if desc.label
               // gram.objectDescriptor 
               // gram.unExpanded then
                  (if descKind 
                   // sematt.standardKind then                     
                      (N.off,N.getText
                      ,(desc[] -> valueSignature).asText,fTag) 
                        -> mch.declareField (* hack *)
                   // sematt.generalKind 
                   // sematt.classKind then
                      (* part object: we need origin type and
                       * handle to generate origin code
                       *)
                      'p'-> fTag; (* part object *)
                      desc[] -> declareRef
                   else
                      (if not common.switch[188] then
                          '\n***GenAlloc: unsupported static data-item'->putline
                  if)if)
               else
                  (if not common.switch[188] then
                      '\n***GenAlloc: unsupported static data-itemX'->putline
              if)if)
           // gram.variablePattern  then
              (if true then
                  (N.off,N.getText,(theGen.StructureSignatureId->theGen.specialSignature).asText,'c') 
                    -> mch.declareField 
               else
                  (if isJava then
                      (N.off, N.getText, common.StructureClass->text2signature, 'c') 
                        -> mch.declareField (* hack *)          
                   else
                      (# sig: ^text;
                      do &text[]->sig[];
                         'class [%s]\'Structure\'' -> sig.putformat(# do common.betaenv.groupname->s #);
                         (N.off,N.getText,sig[],'c') -> mch.declareField (* hack *) 
                      #)
              if)if);
           else
              (if not common.switch[188] then
                  '\n***GenAlloc:unsupported simple data-item'->putline
          if)if)
       // gram.repetitionDecl then
          (* unify with simpleDecl *)
          dcl.son -> spec;
          spec.brother -> spec;
          spec.brother -> spec;
          spec.son -> AD;
          (if AD.label = gram.objectDescriptor then
              (* we need to push here to get the descriptor
               * properly marked - however, if desName
               * returns static item name this may not
               * be needed
               *)
              (if first then (AD,0,1,N) -> DS.push if);
              AD -> desc
           else
              (thisDesc[],AD[]) -> GetActualDesc -> (desc,descKind)
          if);
          
          (N.off,N.getText,desc[] -> mkSignature,'[') -> mch.declareField 
      if)
   #)
---genlib_bytecode_declareFields:doPart---
do (att[],isMethodFields) -> genFields
   (# end::
        (# as: ^ast; exp: ^expanded; off: @integer
        do (* declare index and range from for-imps;
            * preliminary
            *)
           313->trace(#
                     do 'declareFields:for:'->xT; doP[] -> xA
                     #);
           doP.asAst -> as[];
           (if (as## <= expanded##) then
               as[] -> exp[];
               gram.forImp -> exp.suffixWalkForProd
               (# cutIf::
                    (# 
                    do prod = gram.objectDescriptor -> toCut
                    #);
                  thisFor: @ASTindex; inx,fRange: @text
               do (*'got:for:' -> putText;*)
                  current[] -> astAsAstIndex -> thisFor;
                  (if thisFor.label = gram.forImp then
                      313->trace(#
                                do 'imp:'->xT; thisFor[] -> xA; xN;
                                   1->thisFor.getAttribute->off;
                                   'off:'->xT; off -> xI
                                #);
                      1->thisFor.getAttribute->off;
                      'for_inx_' -> inx;
                      off -> inx.putint;
                      'for_range_'->fRange;
                      off+4 -> fRange.putint;
                      (off,inx[],'I','c') 
                        -> mch.declareField;
                      (off+4,fRange[],'I','c') -> mch.declareField;
                  if);
           #)if);
           (if isMethodFields then
               (0,'methodField?','','M') -> mch.declareField
            else
               (0,'classField?','','C') -> mch.declareField
           if)
        #)
   #);   
---genSuper:doPart---
do genSuperDo:
     (# callInit:
          (# superOrgName: ^text; superOriginDesc: ^ASTindex
          enter superOrgName[]
          do 'call init/cons' -> mch.comment;
             PushThis;
             (if not ('-'->superOrgName.equal) then
                 'origin for superQ1:'->mch.comment;
                 1 -> PushArg; (* stack holds origin for this desc *)
                 INNER callInit;
                 (* we need to compute origin from arg1 *)
                 
                 (* datpete: 17/05/2002: *)
                 301->trace
                 (#
                 do 'initSuper: ' -> xT; superOrgName[] -> xT; xN;
                    superOriginDesc[] -> xA
                 #);
                 ((superOriginDesc[],superOrgName[])->ClassSignature).asText 
                   -> superOrgName[];
             if);
             ('initSuper',superOrgName[])->mch.callAlloPrim; 
          #);
        storeOrigin:
          (#
          do 'store origin' -> mch.comment;
             (* store origin for this;
              * origin is the argument of init/cons *)
             PushThis;
             1 -> PushArg;
             
             Gen.ThisRegAdr-> A[];
             1 -> A.ONlevel;
             true -> A.isOrigin;
             thisDesc[] -> mkSignature -> A.receiverType[];
             true -> A.isField;
             (* common.cstInd -> preBase.access;*)
             'new storeorigin1'->mch.comment;
             (if (originDesc[] <> none) and not originDesc.isNull then
                 originDesc[] -> mkSignature -> orgDescName[]
              else
                 platFormSuperSignature -> orgDescName[]
             if);
             313 -> trace(#
                         do 'storeOrigin:orgDescName:'->xT; 
                            orgDescName[] -> xT; xN;
                            (*'A.descName:'->xT; A.descName[] -> xT; xN;*)
                            originDesc[] -> xA
                         #);
             'orgDescName:'->mch.comment;
             orgDescname -> mch.comment;
             'origin' -> A.fieldName[];
             (none,false,'source',orgDescName[]) -> A.asgRefReg;
          #);
        genDefaultSuper:
          (# hasOrigin: @boolean; N: ^text
          enter hasOrigin
          do thisDesc[] -> sematt.descOrigin -> originDesc[]; 
             '-' -> callInit;
             313->trace(#
                       do 'genDefaultSuper:'->xT; xN;
                          thisDesc[] -> xA; xN;
                       #);
             (if hasOrigin then storeOrigin if)
          #) ;
        IsSpecialVirtual: (* see the same pattern in genlib.bet 
                           * we should unify the two patterns
                           *       V::< (# ... #);  
                           *)
          (# preDen: ^ASTindex;
             special,rem: @boolean;
             preName,preX,preSort,realPre,realPreN
             ,preDescOrg: @ASTindex;
             thisDescOrigin: ^ASTindex;
             chain: ^DH.SuperChain
          enter preDen[]
          do preDen -> sematt.getName -> preName;
             preName.dclRef -> preSort;
             preSort.sort -> preSort;
             (if preSort.label
              // gram.virtualDecl // gram.bindingDecl then
                 (* thisDesc is V :: < (# ... #)                   
                  * the super may then be  V :< (# ... #)
                  *        no problems on generating origin
                  * or                  V :< A
                  *        special code for generating origin
                  *        if A is not at the same level as V
                  * or                   V:< R.A
                  *        same as above
                  *)
                 preSort.son -> realPre;
                 realPre.brother -> realPre;
                 (if realPre.label
                  // gram.objectDescriptor then
                     
                  // gram.nameApl then (* V:< A *)
                     realPre -> sematt.getName -> realPreN;
                     (if (realPreN.on > 0) then true -> special if)
                  // gram.remote then
                     true -> special
                  else
                     'Unknown implicit super-pattern' 
                       -> thisTranslate.SystemException
                 if);
                 (if special then
                     thisDesc[] -> semAtt.DescOrigin -> thisDescOrigin[];
                     thisDescOrigin -> preDescOrg;
                     ThisSuperChain -> chain[];
                     chain[] -> DH.ENC -> chain[];
                     (for i: preName.pn repeat
                          preDescOrg.son -> preX;
                          preX.son -> sematt.Descrip -> preDescOrg;
                          chain[] -> DH.PRE -> chain[]
                     for);                  
                 if)
             if)
          exit(special,realPre[],preDescOrg[],chain[])
          #);

     do 313->trace(#
                  do 'genSuper:'->xT;
                     (if haspref then pref[] -> xA
                      else 'noSuper' -> xT
                     if); 
                     ' level:' -> xT; subLevel -> xI;
                  #);

        thisDesc[] -> sematt.descOrigin -> originDesc[];
        (# sig: ^ConstructorSignature;               
           RC: ^DH.superChain;
        do 313->trace(#
                     do 'Super:constructorSignature:'->xT; xN;
                        originDesc[] -> xA
                     #);
           (originDesc[],none)
             -> constructorSignature 
             -> sig[];
           (thisDesc[],thisSuperChain) 
             -> sematt.findConstructor 
             -> (constructorDesc[],isDefaultConstructor,RC[]);
           (if constructorDesc[] <> none then
               (constructorDesc[],isDefaultConstructor,RC[]) 
                 -> sig.addConstructorDesc;
           if);
           313 -> trace(#do 'consSig: '->xT; sig.asText -> xT #);
           sig.asText -> mch.constructorDef;
           true -> ReturnSaved;
        #);

        (if hasPref and (subLevel > 0) then 
            (* hasPref and (sublevel = 0)
             * is a subclass of externalClass
             *)
            pref.son -> preDen -> SemAtt.descrip -> prefDesc;
            (if true 
             // prefDesc -> sematt.procDesc.equal
             // prefDesc -> sematt.classDesc.equal then
                true -> genDefaultSuper;
                leave genSuperDo 
             // ((prefDesc->sematt.descKind)=sematt.externalClasskind)
                and not (prefDesc[] -> isBetaSubOfExternalClass) then
                true -> genDefaultSuper;
                leave genSuperDo 
            if);
            Gen.ThisRegAdr -> preBase[];
            12 -> preBase.addOff -> preBase[];
            'origin' -> preBase.fieldName[];
            preDen[] 
              -> isSpecialVirtual 
              -> (isSpecial,realPre[],preDescOrg[],chain[]);
            (if isSpecial then
                301->trace(#
                          do 'SpecialVirtual:realpre: '->xT; realPre[]->xA; xN;
                             'preDescOrg: ' -> xT; preDescOrg[] -> xA
                          #);
                preDescOrg[] -> preBase.bAdr.LocalDesc[];
                '' -> callInit
                (#
                do true -> preBase.isOrigin;
                   2 -> prebase.ONlevel;
                   true -> preBase.isField;
                   (preBase[],none(*not used*),realPre[],chain[])
                     -> genOrgAdr
                     -> preBase[];
                   'origin' -> preBase.fieldName[];
                   (preBase.bAdr.localDesc[],true)
                     -> EH.descName 
                     -> superOrgName[];
                   preBase.bAdr.localDesc[] -> superOriginDesc[]
                #)
             else
                (* overvej *)
                (* Consider
                 *    X: (# B: A (# #) #)
                 * We generate super for A(# ... #)
                 * Origin for init for A(# #) is X
                 * We have loaded this origin using loadArg1
                 * in callInit.
                 * Thus localDesc below is initialized to X
                 * In addition we set ONlevel to 2
                 * to signal to BCxxxBody that first level
                 * origin has been loaded
                 *)
                originDesc[] -> preBase.bAdr.LocalDesc[];
                thisSuperChain -> DH.ENC -> chain[];
                (* NOTE: We enter the empty string '' as superOrgName,
                 * and redefined superOrgName in the do-part below;
                 * we need to reconsider the abstraction
                 *)
                ''-> callInit
                (#
                do 301->trace(#
                             do 'genSuper:callInit: '->xT; preDen[]->xA; xN;
                                'localDesc:' -> xT;
                                preBase.bAdr.localDesc[] -> xA
                             #);
                   true -> preBase.isOrigin;
                   2 -> prebase.ONlevel;
                   true -> preBase.isField;
                   (thisDesc[]->theGen.fieldSignature).asText
                     -> preBase.fieldType[];
                   (preBase[],originDesc[],preDen[],chain[])
                     -> genOrgAdr
                     -> preBase[];
                   301->trace(#
                             do 'genSuper:callInit:X:'->xH;
                                preBase.bAdr.localDesc[] -> xA
                             #);
                   (preBase.bAdr.localDesc[],true)
                     -> EH.descName 
                     -> superOrgName[];
                   301->trace(#
                             do 'genSuper:callInit:Y:'->xH;
                                superOrgName[] -> xT
                             #);
                   
                   preBase.bAdr.localDesc[] -> superOriginDesc[];

                   301->trace(#
                             do 'genSuper:callInit:2 ' -> xT; xN;
                                'localDesc:' -> xT;
                                preBase.bAdr.localDesc[] -> xA; xN;
                                'superOrgName: ' -> xT; superOrgName[] -> xT
                             #);                
                #)
            if);
            storeOrigin;
         else
            (if false then
                1->trace(#
                        do 'GenSuperDo:else:'-> xT;  xN;
                           thisDesc[] -> xAF; xN;
                           'isExternal: ' -> xT;
                           (thisDesc->sematt.descKind) 
                           = sematt.externalClassKind -> xB;
                           ' isDefaultCons:'->xT;
                           isDefaultConstructor -> xB
            #)if);
            (if (thisDesc->sematt.descKind) = sematt.externalClassKind then
                (if true then
                    (* Consider an externalClass X
                     * There are (at least) three situations
                     * 1:  Y1: X (# ... #)                   - no constructor
                     * 2:  Y2: X (# _init: (# ... #); ... #) - constructor
                     * 3:  Y3: X (# __init: (# .. #); ... #) - default cons
                     * 
                     * In case 3: isDefaultConstructor = true
                     * and we assume no betaenv-origin
                     * For case 1 & 2, we assume betaenv-origin
                     * A possible betaenv-origin is generated by
                     * genDefaultSuper if hasOrigin-enter=true
                     * OBS! We should be sure that the above is correct!
                     *)
                    not isDefaultConstructor -> genDefaultSuper
                 else
                    false -> genDefaultSuper
                if)
             else
                (if true then
                    not isDefaultConstructor -> genDefaultSuper
                 else
                    true -> genDefaultSuper
                if)
            if)
        if);
     exit prefDesc[]
     #);
   
---genClass:doPart---
do (# findBetaenv:
        (# D,BO: ^ASTindex; BE: @ASTindex;
        enter D[]
        do D -> BE;
           L:
             (#
             do BE[] -> sematt.descOrigin -> BO[];
                (if not BO.isNull then
                    BO -> BE;
                    restart L
                if)
             #);
        exit BE[]
        #);
      genMain:
        (# desc,betaenvDesc: ^ASTindex;
           sig: @signature;
        enter desc[]
        do desc[] -> findBetaEnv -> betaenvDesc[];
           'main' -> sig.addMethod; sig.noEnter; sig.exitVoid;
           (1,'main',false,sig.asText,1) -> mch.initDo; 
           (betaenvDesc[],common.itemKind) -> newThisInstance;
           (betaenvDesc[],common.doMethod,sig[],true,true) -> callNDX;
           (false,0) -> mch.return; 
           mch.endMethod           
        #);
      genText2BetaText:
        (# sig: @signature
        do 'Text2BetaText' -> sig.addmethod;
           JavaStringSignatureId 
             -> SpecialSignature 
             -> mkListSignature
             -> sig.setEnter;
           BetaTextSignatureId -> SpecialSignature -> sig.setExit;
           (1,'Text2BetaText_i',false,sig.asText,1) -> mch.initDo;     
           (sematt.textDesc[],common.itemKind) -> newThisInstance;
           (false,11) -> mch.return; (* return reference *)
           mch.endMethod
        #);
      genAttach:
        (# sig: @signature
        do 'attach' -> sig.addMethod; 
           (sematt.superObject[],thisSuperChain,false) -> sig.setMethodDesc; (* ???*)
           sematt.superObject[] -> sig.addEnter; 
           sig.exitVoid;
           (1,'attach_i',false,sig.asText,1) -> mch.initDo; 
           (false,0) -> mch.return;
           mch.endMethod
        #);
      theDesc,topSuperName,superDesc,topDesc: @ASTindex;
      subLevel: @integer;
      superName: ^text;
      
      R: ^ProtoType;
      c: ^text;
      orgDesc: ^AStindex;
      EH: @evalHandler;
      orgName: ^text;
      locals: @LocalDescriptors;
      isMain,isBetaenv: @boolean;
      hasEnterMethod,hasDoMethod,hasExitMethod,xIsDoPartForm,isOuter
      ,hasClass: @boolean;
      constructorDesc: ^ASTindex; (* descriptor for possible constructor *)
      isDefaultConstructor: @boolean
   do 311->trace(#
                do 'genClass: "' -> xT; className[] -> xT;
                   '" blockLevel ='->xT; blocklevel -> xI; 
                #);

      (if desc.isSlot then
          '\n*** OBS! Slots are not handled by genClass: '->puttext;
          className[] -> putline;          
       else
          ((formDesc.label = gram.doPart)
          or
          (formDesc.label = gram.mainPart))
          and (blockLevel = 0) 
            -> xIsDoPartForm;
          (* This is an indirect way of representing
           * that we are compiling a dopart-form.
           * formDesc is global and refers the original 
           * form. We should represent this more explicitly.
           * thisDesc refers the descriptor having the
           * dopart-slot. We don't need to do initPtnGen
           * since a dopart form is always compiled
           * via genByteCode, which is called for gdbody
           * where the proper initialization has been done.
           * A REAL HACK: formDesc is only well defined when
           * compiling the outer form; does not work for inner
           * descriptors; we try fixing by also testing blockLevel;
           * BUT CLEAN-UP
           *)
          (* (if xIsDoPartForm then '\ndopart form'->putline if);*)
          (desc[],xIsDoPartForm) -> initPtnGen; (* thisDesc[] = desc[]
                                                * BUT: thisDesc[] is global and will
                                                * be redefined in case of nested
                                                * descriptors.
                                                * Below we should replace thisDesc
                                                * by desc!
                                                *)

          desc -> theDesc;
          (*313->trace(#
           do 'desc:hasSlots: ' -> xT; desc[] -> hasSlots->xB;
           ' xIsDoPartForm:'->xT; xIsDoPartForm -> xB;
           (if xIsDoPartForm then
           xN; 'formDesc:'->xT; formDesc[] -> xA
           if);
           100->switchOn;
           xN;
           theDesc[] -> xA;
           100 -> switchOff
           #);*)
          (if not (desc[] -> hasSlots) or xIsDoPartForm then
              true -> hasClass;
              path[] -> splitPathAndNAme -> (path[],c[]);
              313->trace(#
                        do 'Path: ' -> xT; path[] -> xT; xN;
                        #);
              (# Jfile: ^text; lastDot: @integer
              do (if (thisPackagePath[] <> none) then
                     313->trace(#
                               do 'PATH:asmLink:A: '-> puttext;
                                  path[] -> putline;
                               #);
                     (*thisPackagePath[] -> path.append;*)
                     className[]->path.append;
                     313->trace(#
                               do 'PATH:asmLink: ' -> puttext;
                                  path[] -> putline;
                               #);
                  else
                     className[]->path.append;
                 if);
                 asmlink.asmext->(path.copy).append ->Jfile[];
                 (Jfile[],asmlink.byteCodeKind,true,false) 
                   -> AsmLink.TX.insert;
              #);
              
              (theGroup.origin=NONE) -> mch.initDataSeg;
              313->trace(#
                        do 'Super: ' -> xT; pref[] -> xA;
                           ' pref.label: '->xT; pref.label->xI
                        #);
              (**** G-part ****)
              (if pref.label = gram.prefix then
                  pref.son -> topSuperName;
                  topSuperName[] -> getNameAsText -> superName[];
                  (* note: we need to do name mangling for the super name *)
                  topSuperName -> sematt.quaDesc -> superDesc;
                  (superDesc[],true) -> EH.descName -> superName[];
                  
                  topSuperName -> sematt.descChain -> (topDesc,subLevel); 
                  (* One super : subLevel = 0
                   * Two super : subLevel = 1
                   * ...
                   *)
                  (if topDesc -> sematt.superObject.equal then
                      (* As in V:< object;
                       *       V::< (# ... #)
                       *)
                      subLevel - 1 -> sublevel
                  if);
                  
                  (if (theDesc->sematt.descKind) 
                   // sematt.classKind then
                      (if subLevel = 0 then defaultSuperName -> superName[] if);
                      313->trace(#
                                do 'classKind:subLevel:' ->xT; subLevel->xI; 
                                   ' superName:'->xT; superName[] -> xT; xN;
                                   theDesc[] -> xA;
                                #)
                   // sematt.externalClassKind then
                      (* level 0: externalClase : ( #  # )
                       * level 1: foo: externalClass ( #   # )  - interface
                       * level 2: bar: foo ( #   # )            - real
                       * 
                       * level 2 should be 0 (zero) since this is the
                       * first real BETA subclass; subLevel from super
                       * is 1; we thus always subtract 1
                       *)
                      (if not (superDesc[]->isBetaSubofExternalClass)
                          (*subLevel = 1*) then
                          superDesc[] -> getExternalClassName -> superName[];
                          301->trace(#
                                    do 'superName:externalClass:' -> xT;
                                       superName[] -> xT; xN;
                                       superDesc[] -> xA
                                    #)                      
                      if);
                      313->trace(#
                                do 'externalClassKind:subLevel' -> xT;
                                   subLevel -> xI
                                #);
                      subLevel - 1 -> subLevel;
                   else
                      313->trace(#
                                do 'theDesc:kind:' -> xT; 
                                   theDesc->sematt.descKind -> xI; 
                                #);
                      subLevel + 1 -> subLevel
                  if);              
                  313->trace(#
                            do 'super: ' -> xT; subLevel -> xI;
                               superName[] -> xT; xN;
                               topDesc[] -> xA
                            #)
               else
                  theDesc -> topDesc;
                  defaultSuperName -> superName[];
                  0 -> subLevel
              if);
              (* Perhaps there should be an outer static method
               * also for patterns without a do-part, since they 
               * may be executed anyway - such calls are perhaps 
               * never generated by the compiler?
               * It seems so: if just an exit part as in
               * isX: (# exit a or b #)
               *)
              (blockLevel = 0) (*and (topDesc[]->sematt.hasDo)*) -> isOuter;
              (if true then
                  theDesc[] -> sematt.enclosingDesc -> orgDesc[]
               else
                  theDesc[] -> sematt.descOrigin -> orgDesc[]
              if);
              313->trace(#
                        do 'genClass:originDesc: ' -> xT;
                           orgDesc[] -> xA
                        #);
              (if ((theDesc->sematt.descKind) = sematt.externalClassKind)
                  and not (theDesc[]->isBetaSubOfExternalClass) then
                  '-' -> orgName[]
               else
                  (if not orgDesc.isNull then
                      orgDesc[] -> mkSignature -> orgName[]
                   else
                      platFormSuperSignature -> orgName[]
              if)if);
              
              313->trace(#
                        do 'genClass:origin: ' -> xT; orgName[] -> xT;xN;
                           orgDesc[] -> xA; xN;
                           'superName: ' -> xT; superName[] -> xT
                        #);
              
              (* For java: the call to initGen initiates a new BCmachine
               * for Jasmin code generation and a new file
               *)
              ((*theDesc.nodeId div 2, - we reuse a field - BAD *)
              blockLevel,className[],false
              ,((superDesc[],superName[])->SuperSignature).asText
              ,subLevel,orgName[])
                -> mch.initGen;
              (* 'DefClass: ' -> puttext; className[] -> putline; *)
              
              (att[],doP[],false) -> declareFields;

              (pref[],subLevel) 
                -> GenSuper 
                -> (constructorDesc[],isDefaultConstructor);
              (if not ReturnSaved then
                  '\ngenClass:constructorSignature:calledInMain' -> putline;
                  ((orgDesc[],orgName[]) -> constructorSignature).asText
                    -> mch.constructorDef;
                  true -> ReturnSaved
              if);
              
              common.betaenv.packagename -> className.equalNCS 
                -> isBetaEnv;
              
              ('program' -> (common.BetaPackage).append -> className.equal)
                -> isMain;

              (att,0,&RepList[],locals[])->GenByteCodeAlloc;
              (if constructorDesc[] <> none then
                  (# sig: @signature;
                     A: @mch.RegAdr; off: @integer;
                  do (constructorDesc[],constructorDesc->DH.newSingle,false) 
                       -> sig.setMethodDesc;
                     ((thisDesc[],true) -> EH.descName,thisDesc[]) 
                       -> sig.addReceiver;
                     (if isDefaultConstructor then
                         '__init' -> sig.addMethod
                      else
                         '_init' -> sig.addMethod
                     if);
                     constructorDesc[] -> sig.addEnter;
                     sig.exitVoid;
                     pushThis;
                     12 -> off;
                     sig.scanEnter
                     (# 
                     do off + 4 -> off -> A.off;
                        common.enterMethod -> A.fieldName[];
                        current.asText -> A.fieldType[];
                        (if isRef -> A.isRef then
                            (A[],&mch.adrRegOperand[]) -> mch.ldVal
                         else
                            (A[],&mch.dataRegOperand[]) -> mch.ldVal
                        if);
                        (if current.elmType = 6 then
                            (if isJava then
                                off + 4 -> off -> A.off;
                            if);
                        if)
                     #);
                     (sig.asText->mch.newTextOp,'M',true,false)->mch.gJsr;
                  #)
              if);
              (false,0(*theDesc.returnOff*))->mch.return; 
              mch.endMethod
          if);
          (if isOuter then (* hack *)
              (# ds: @ASTindex;
                 n,d,x: ^AStindex;
                 usPos: @integer
              do theDesc -> ds;
                 enterP[] -> N[];
                 doP[] -> d[];
                 exitP[] -> x[];
                 className.scanAll
                 (# pos: @integer
                 do pos+1 -> pos;
                    (if ch = common.nameManglingCh then pos -> usPos if)
                 #);
                 (if usPos > 0 then 
                     (usPos+1,className.length) -> className.sub -> classname[]
                 if);
                 (className[],theDesc[],true,false,theDesc[],topDesc[]
                 ,false,true,true)
                   -> genPtnMethod;
                 x[] -> exitP[];
                 d[] -> doP[];
                 n[] -> enterP[];
                 ds -> theDesc
              #)
          if);
          (if hasClass then
              enterP.label <> gram.empty -> hasEnterMethod;
              doP.label <> gram.empty -> hasDoMethod;
              true or (exitP.label <> gram.empty) -> hasExitMethod;
              true -> inEnterDoExitMethod;
              (if hasEnterMethod then
                  (* extra isEnter arg needed *)
                  TheDesc[] -> genEnterMethod
              if);
              (if hasDoMethod then
                  (TheDesc[],isDoPartForm,false,false,subLevel) 
                    -> genDoMethod
              if);
              (if hasExitMethod then
                  (* extra isExit arg needed *)
                  (TheDesc[],superDesc[]) -> genExitMethod
              if);
              false -> inEnterDoExitMethod;
          if);
          handleNestedDescriptors
          (# pref: @ASTindex
          do 
             (* this is currently a nested singular descriptor;
              * we don't know whether it is an item or an insertion;
              * currently we assume an insertion, which we
              * also assume should be a local anonymous method;
              * we should test that no this(..)[] or other reference
              * stuff to static objects are present
              *)
             (if not (currentDesc[] -> skipDesc) then
                 (*'\nnested: ' -> puttext; currentCons -> putint; newline;
                  (currentDesc[],screen[],500) -> thePP;
                  *)
                 (if currentCons
                  // 1 (* singular static item *) then
                     currentDesc[] -> locals.save
                  // 2 (* singular inserted procedure item *) then
                     currentDesc.son -> pref;
                     (if true (*pref.label = gram.prefix*) then
                         currentDesc[] -> locals.save
                      else
                         (* just generating a method is an
                          * insufficient optimization
                          *)
                         currentDesc[] -> locals.addMethod
                     if)
                  // 3 (* singular dynamic descriptor *) then
                     currentDesc[] -> locals.save
                  else
                     '\n*** Unknown descriptor cons not handled ' -> putline
             if)if)
          #);
          locals.scanMethods
          (#
          do (if not (current[] -> skipDesc) then
                 ((current[],false)->EH.descName,current[]) -> genMethod
             if)
          #);
          locals.scanPtns
          (# D,N: @ASTindex; name: ^text; descKind: @integer
          do theDesc -> D; (* ugly *)
             (if not (current[] -> skipDesc) then (* skip *)
                 313->trace(#
                           do 'scanLocalPtns: '->xT; current[] -> xA
                           #);
                 (if current.label 
                  // gram.unExpanded then
                     (* '\n*** descriptor: ' -> puttext;
                      (current[],screen[],500) -> thePP;
                      *)
                     
                     ((current[],false) -> EH.descName  -> name[]
                     ,current[],false,false,theDesc[],none
                     ,false,true,true)
                       -> genPtnMethod;
                     D -> theDesc -> thisDesc;
                     (name[],current[],theDesc[]) -> genPtnClass;

                  // gram.objectDescriptor then
                     (if current->sematt.descKind
                      // sematt.generalKind 
                      // sematt.classKind
                      // sematt.procKind then
                         (* see gdbody for patterns we ignore;
                          * do we have the right ones here ?
                          *)
                         (current[],false) -> EH.descName -> name[];
                         (name[]
                         ,current[],false,false,theDesc[],none,false,true,true)
                           -> genPtnMethod;
                         D -> theDesc -> thisDesc;
                         (name[]
                         ,current[],theDesc[]) 
                           -> genPtnClass;
                         current.father -> N;
                         (if N.label
                          // gram.virtualDecl
                          // gram.bindingDecl
                          // gram.finalDecl then
                             D -> thisDesc -> theDesc;
                             (name[],N[]) -> genVirtualStrucMethod
                         if)
                     if)
                  else
                     (* attributeDenotation as 'A' in 'V:<A' 
                      * or variablePattern as  'F' in 'F: ## T'
                      *)
                     current.father -> N; 
                     (if N.label
                      // gram.virtualDecl
                      // gram.bindingDecl
                      // gram.finalDecl then
                         (current[],false) -> EH.descName -> name[];
                         (name[]
                         ,current[],false,false,theDesc[],none,false,true,true)
                           -> genPtnMethod;
                         D -> thisDesc -> theDesc;
                         (name[]
                         ,current[],theDesc[]) 
                           -> genPtnClass;
                         D -> thisDesc -> theDesc;
                         (name[],N[]) -> genVirtualStrucMethod
                      else
                         N.father->N;
                         (N.sonref).brother -> N;
                         (if N.label = gram.variablePattern then
                             D -> thisDesc; (* ugly *)
                             (current[],N[]) -> genPtnVarMethod
                          else
                             '\ngenClass:scanPatterns:no match'->putline
                         if)
                     if)
             if)if);
             D -> thisDesc -> theDesc
          #);
          (if hasClass then
              (if isMain then
                  313->trace(#
                            do 'generate main:' -> xT; xN; theDesc[] -> xA 
                            #);
                  theDesc[] -> genMain;                 
              if);
              (if isBetaenv then
                  genText2BetaText;
                  genAttach
              if);

              mch.endClass; (* for Java this will close the jasmin-file *)
              (* 'endclass' -> putline;*)
          if);
          (******** handle inner classes ***********)
          thisBlockLevel + 1 -> thisBlockLevel;
          locals.scanClasses
          (#
          do (if not (current[] -> skipDesc) then
                 (if current->sematt.descKind
                  // sematt.generalKind 
                  // sematt.classKind
                  // sematt.procKind then
                     (* see gdbody for patterns we ignore;
                      * do we have the right ones here ?
                      *)
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel,false) 
                       -> genClass
                  // sematt.externalClassKind then
                     (BCname.copy,(current[],true)->EH.descName,current[],thisBlockLevel) 
                       -> genExternalClass
             if)if)
          #);      
          thisBlockLevel - 1 -> thisBlockLevel;   
          (if false then
              (* should be moved up or eliminated??*)
              (pref[],att[])->BindVirtuals;
              (nameId[],singular)->genSymbTable;  
          if)
      if)
   #)
   
---genEnterMethod:doPart---
do (# sig: @Signature;
      EH: @EvalHandler;
      enterA: @EH.EnterArgs;
      EVL: @AStindex;

      off: @integer
   do 311->trace(#
                do 'GenEnterMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genEnterMethod'->putline;
          
       else
          (if formDesc.label 
           // gram.dopart // gram.mainPart then
           else
              (desc[],false) -> initPtnGen;
          if);
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          thisDesc[] -> sig.addEnter;
          common.enterMethod->sig.addMethod;
          sig.exitVoid;

          8 -> off;
          (enterP.nodeId
          ,common.enterMethod,false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          
          enterP.son -> EVL;
          (if EVL.label = gram.evalList then EVL.son -> EVL if);

          enterA.init;
          (# nScan: @ | EH.scanNadr; more: @boolean
          do (thisDesc[],gen.thisRegAdr(*not used*),0,thisSuperChain,true) 
               -> nScan -> more;
             L:
               (if more then
                   'genEnter:asgToNelm1'->mch.comment;
                   enterA[]-> nScan.asgToNelm;
                   nScan -> more;
                   restart L
               if)         
          #);
          
          (false,0) -> mch.return;
          mch.endMethod
      if)
   #)
   
---genDoMethod:doPart---
   (* generate a do-method for a general pattern;
    * simple: the enter- and exit-parts are simple
    * arguments and becomes arguments of do;
    * we should split simple into simpleEnter
    * and simpleExit
    *)
do (# sig: @Signature;
      exitVal: ^ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      methodName,innerName: ^text;
      xIsDoPartForm: @boolean
   do 311->trace(#
                do 'GenDoMethod:'->xT; desc[]->xA
                #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genDoMethod' -> putline          
       else
          (if FormDesc.label 
           // gram.doPart then
              (* Compiling a descriptor D: (# <<SLOT xD:doPart>> #)
               * where the do-part is a form.
               * Probably:
               *   isDoPartForm <==> FormDesc.label = gram.doPart
               *)
              (if isDoPartForm then
                  (if FormDesc[] -> sematt.doPartHasTmp then
                      301->trace(#do 'doPartHAsTmp:'->xT #);
                      true -> xIsDoPartForm;
                      formDesc -> thisDesc
              if)if);
              301->trace(#
                      do 'doPart:'->xT; formDesc[] -> xA
                      #)
           // gram.mainPart then
              (* '\ndopartform: do method'->putline*)
           else
              (desc[],false) -> initPtnGen;
          if);
          (if true then
              (desc[],thisSuperChain,false) -> sig.setMethodDesc;
           else
              (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          if);
          (if simpleEnter then
              thisDesc[] -> sig.addEnter
           else
              sig.noEnter
          if);
          (if simpleExit then
              exitP[] -> sig.addExit;
              sig.exitId -> exitId;
              sig.exitVal[] -> exitVal[];
           else
              sig.exitVoid
          if);
          301 ->trace(# 
                     do 'genDoMethod:hasInner:sublevel:'->xT; 
                        subLevel -> xI;
                        doP[] -> xA;
                     #);
          (common.doMethod,subLevel) 
            -> methodAndInnerName 
            -> (methodName[],innerName[]);
          (if false and (not (desc[] -> sematt.hasInner)) then
              (* we should later optimize when no inner *)
              common.doMethod-> innerName[] (* se else-part *)
              (* a hack with methodName[] -> innername[];
               * see bytecodebackend:initDo
               *)
          if);
          methodName[] -> sig.addMethod;
          (doP.nodeId,innername[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          (if (doP.label <> gram.empty) then 
              (# GD: @GenDo
              do GD.restartLab.new; 
                 GD.restartLab.def;
                 xIsDoPartForm -> (*inDoPartWithTmp ->*) GD.isDoPartForm;
                 doP -> GD.Scan;
                 false -> inDoPartWithTmp
          #)if);
          (if simpleExit and (exitVal[] <> NONE ) then
              (# aR: ^mch.RegAdr
              do gen.thisRegAdr -> aR[];
                 'exitVal' -> aR.fieldName[];
                 (aR[],exitVal[],false,ThisSuperChain) 
                   -> EH.ExpEval 
                   -> V[];
                 V.loadVal2;
              #)
          if);
          (false,exitId) -> mch.return;
          mch.endMethod;
          (if xisDoPartForm then
              theRealDesc -> thisDesc
          if)
      if)
   #)
   
---genExitMethod:doPart---
do genExit:
     (# sig: @Signature;
        exitVal: ^ASTindex;
        exitId: @integer;
        EH: @EvalHandler;
        V: ^EH.evVal;
        aR: ^mch.RegAdr;
        T: ^ASTindex;
        xScan: @ | EH.scanXadr; more: @boolean;
        aD,OA: @mch.RegAdr;
        destField: @text; xNo,xNo1: @integer;
        methodName: ^text;
        xTypes: ^EH.ExitTypes;
        fields: @
          (# field:
               (# name,type: ^text; kind: @char
               enter(name[],type[],kind)
               exit this(field)[]
               #);
             add:
               (# name,type: ^text; kind: @char
               enter(name[],type[],kind)
               do (if (top+1->top) > F.range then
                      F.range -> F.extend
                if);
                (name[],type[],kind) -> Field -> F[top][]
             #);
           declare:
             (#
             do (for i: top repeat
                     (0,F[i].name[],F[i].type[],F[i].kind) 
                       -> mch.declareField;
                for)
             #);
           F: [3] ^field;
           top: @integer
          #);
        exitMethodNeeded: booleanValue
          (* If exitP.label <> gram.empty then
           * the mian-part of thisDesc has an exit-part
           * and we should generate an exit-method.
           * 
           * If no exit-part in main-part; we should only generate
           * an exit-method if som exit-element in a super-part
           * exits a virtual pattern with a binding in thisDesc
           * and the bindindg extends the exit-part
           * 
           * Example:
           * 
           *    A: (# V:< T ... exit V #);
           *    AA: A(# V::< TT ... #);
           *    T: (# ... exit aChar #);
           *    TT: T(# .. exit aChar #)
           * 
           * AA's main-part has no exit-part.
           * A has an exit-part that exits a virtual (V)
           * and AA has a binding of V (TT) and the binding(TT)
           * extends the exit-part of its super (T). 
           * An exit-method must thus be generated for AA.
           * 
           * If the main-part of thisDesc has no  virtual bindings,
           * we could leave genExitMethod immediately. However,
           * this test is nt yet included.
           * 
           * A simple test for the need pf regenerating the
           * exit-method is to compare the signature of
           * the exit.method of super with a possible exit-method
           * of thisDesc. If they are equal, no regeneration of
           * the exit-method is necessary. If they differe we
           * should regenerate the exit-method.
           *)
          (# superSig: @signature;
          do (if exitP.label <> gram.empty then
                 true -> value
              else
                 superSig.noEnter;
                 (superDesc[],superDesc->DH.newSingle,false) 
                   -> superSig.setMethodDesc;
                 common.exitMethod -> superSig.addMethod;
                 superSig.addExit;
                 not (superSig.asText->(sig.asText).equal) -> value;
                 (if false (*value*) then
                     301->trace(#
                             do 'exitMethodNeeded:super: ' -> xT;
                                superSig.astext -> xT;
                                ' thisDesc: ' -> xT;
                                sig.asText -> xT
                             #);
                 if)
             if)
          #);
   do 311->trace(#
                do 'GenExitMethod:'->xT; desc[]->xA
                #);   
      (if desc.isSlot then
          '\nOBS! Slots not handled by genExitMethod'->putline
       else
          (desc[],false) -> initPtnGen;
          sig.noEnter;
          (thisDesc[],thisSuperChain,false)->sig.setMethodDesc;
          exitP[] -> sig.addExit;
          
          (if sig.XXsig.elmType = 10 then
              (* void: no exit part in any super chain *)
              LEAVE genExit
          if);
          
          common.exitMethod -> methodName[] -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          
          (if not exitMethodNeeded then LEAVE genExit if);
          
          (exitP.nodeId,methodName[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          313->trace(#do 'genExitMethod:ExpEval: '->xT; exitVal[] -> xA #);
          

          (desc[],gen.thisRegAdr,0,thisSuperChain) 
            -> xScan 
            -> more;
          
          (if sig.isMultiValExit then
              'exit_' -> destField;
              (desc[] -> fieldSignature).asText -> aD.receiverType[];
              true -> OA.isOrigin;
              loop:
                (if more then
                    (OA[],none) -> mch.ldVal;
                    gen.thisRegAdr->aR[];
                    common.exitMethod->aR.fieldName[];
                    (aR[],xScan.thisEv[],true,xScan.thisChain[](*ThisSuperChain*)) 
                      -> EH.ExpEval 
                      -> V[];
                    311 -> trace(#
                                do 'genExitMethod: ' -> xT;
                                   V.display; xN;
                                   'xNo: ' -> xT; xNo -> xI;
                                   ' xNo1: ' -> xT; xNo1 -> xI
                                #);

                    (desc[],xNo,OA[],ThisSuperChain)
                      -> V.asgToExitArgs  
                      -> (xNo1,xTypes[]);
                    
                    311->trace(#
                              do 'xNo1:' -> xT; xNo1 -> xI; xN;
                                 V.display
                              #);
                    (if xNo = xNo1 then
                        (* OBS we assume a simpleVal but in txtCstVal
                         * this mau be converted to a textVal
                         *)
                        true -> V.pushVal; (*V.loadVal2;*)
                        (* pushval/mkBetatext should be cleaned up *)
                        V.type -> T[];
                        (*1 -> trace(#
                                    do 'V.type: ' -> xT; T[] -> xA; 
                                    #);*)
                        (if T -> sematt.textDesc.equal then V.mkBetaText if);
                        true -> aD.isField;
                        (xNo+1->xNo->(destField.copy).putint
                        ,T[] -> mkSignature,
                        'c') 
                          -> fields.add;
                        xNo 
                          -> (destField.copy).putint 
                          -> aD.fieldName[];
                        T[]  -> theGen.mkSignature -> aD.fieldType[];
                        (*1->trace(#
                                do 'fieldType: ' -> xT;aD.display->xT
                                #);*)
                        (&mch.adrRegOperand[],aD[]) -> mch.stVal;
                     else
                        xTypes.scan
                        (# 
                        do (*
                            * (current[] -> fieldSignature).asText -> puttext;
                            * ',' ->put;
                            *)
                           (xNo+1->xNo->(destField.copy).putint
                           ,current[] -> mkSignature
                           ,'c') 
                             -> fields.add
                        #);  
                    if);
                    xScan -> more;
                    (if more then restart loop if)
                if);
              PushThis;
           else
              gen.thisRegAdr->aR[];
              common.exitMethod->aR.fieldName[];
              (if false then
                  (aR[],exitVal[],true,ThisSuperChain) 
                    -> EH.ExpEval 
                    -> V[]
               else
                  (*1->trace(#
                          do 'genExit:chain:'->xT; xScan.thisEv[] -> xA; xN;
                             xScan.thisChain
                          #);*)
                  (aR[],xScan.thisEv[],true,xScan.thisChain[])
                    -> EH.ExpEval 
                    -> V[]
              if);
              301 -> trace(#
                          do 'genExitMethod: ' -> xT;
                             V.display
                          #);
              (* OBS! see pushVal above regarding isSimpleVal 
               * enter argument 
               *)
              true -> V.pushVal; (*V.loadVal2;*)
              (* pushval/mkBetatext should be cleaned up *)
              (*1->trace(#
                      do 'afterpushval'->xT
                      #);*)
              V.type -> T[]; (* if V is array/rep then T may be none 
                              * - FIXME *)
              (* 1->trace(#
                      do (if T[] <> none then T[] -> xA 
                          else 'T is none' -> xT if); xN;
                         'V: ' -> xT; V.display
                      #);*)
              (if (T[]<>none) and (T -> sematt.textDesc.equal) then
                  V.mkBetaText 
              if);
          if);
          (false,exitId) -> mch.return;
          mch.endMethod
      if);
      fields.declare      
   #)
   
---genMethod:doPart---
do (# sig: @Signature;
      exitVal: ^ASTindex;
      sort: @ASTindex;
      exitId: @integer;
      EH: @EvalHandler;
      V: ^EH.evVal;
      superName,innerName: ^text;
      superDesc: ^ASTindex;
      subLevel: @integer;
      aR: ^mch.regAdr;
   do 311-> trace(#
                 do 'genMethod: ' -> xT; methodName[] -> xT; xN;
                    desc[] -> xA 
                 #);
      (if desc.isSlot then
          '\nOBS! Slots not handled by genMethod'->putline          
       else
          (desc[],false) -> initPtnGen;
          (if false then
              desc.father -> sort;
              '.method: ' -> puttext; 
              (if sort.label
               // gram.patternDecl then 'pattern ' -> puttext
               // gram.virtualDecl then 'virtual ' -> puttext;
               // gram.bindingDecl then 'binding ' -> puttext;
               // gram.finalDecl   then 'final ' -> puttext
               else 'other? ' ->puttext
              if);
          if);
          desc[] -> descChain -> (superName[],superDesc[],subLevel);
          (* is this waht we want? subLevel should not of thisDesc
           * but from enclosing desc?
           *)
          methodName.copy -> innerName[];
          (if subLevel > 0 then          
              '_do_' -> methodName.append;
              subLevel -> methodName.putint;
          if);
          (if not ('main' -> methodName.equal) then
              (* Note! innernName is used for two purposes:
               * 1. the name of a possible inner method
               * 2. the name of method 'main'
               * if innerName = 'main' then there is no inner method
               *)
              '_do_' -> innerName.append;
              subLevel + 1 -> innerName.putint;
          if);

          (*methodName[] -> puttext;      
           ' super:' ->puttext; superName[] -> puttext; 
           ' level:'->puttext; subLevel -> putint; 
           ' inner:'->puttext; innerName[] -> putline;*)
          
          (* (pref,common.itemKind)->PrefixAlloc;*)
          (thisDesc[],thisSuperChain,false) -> sig.setMethodDesc;
          (if subLevel > 0 (*thisDesc[] -> sematt.hasNcode*) then
              sig.noEnter
           else
              thisDesc[] -> sig.addEnter
          if);
          exitP[] -> sig.addExit;
          methodName[] -> sig.addMethod;
          sig.exitId -> exitId;
          sig.exitVal[] -> exitVal[];
          313->trace(#
                    do 'genMethod: "' -> xT; methodName[] -> xT;
                       '" Signature: ' -> xT; sig.asText -> xT
                    #);
          (doP.nodeId,innerName[],false,sig.asText,sig.noOfEnterArgs) 
            -> mch.initDo;
          
          (if true or isClr then
              (* needed for .NET; not needed for Java *)
              (att[],doP[],true) -> declareFields;
          if);
          
          (if (doP.label <> gram.empty) then 
              (# GD: @GenDo
              do GD.restartLab.new; 
                 GD.restartLab.def;  
                 doP -> GD.Scan;
          #)if);

          (if exitVal[] <> NONE  then 
              gen.thisRegAdr->aR[];
              'exit_'->aR.fieldName[];
              (aR[],exitVal[],false,ThisSuperChain) 
                -> EH.ExpEval -> V[];
              V.loadVal2
              (* else call of foo/do leaves return value on stack *)
          if);
          (false,exitId) -> mch.return; 
          mch.endMethod
      if)
   #)

---GenByteCode:doPart---
do (# className,path: ^text; EH: @evalHandler;
      SetFileName:
        (# className,path,c: ^text; isBetaEnv: @boolean
        enter(className[],isBetaEnv)
        do (if common.switch[189] and isNonAttributesSlot then
               (none (* hack to signal to bytecodemachine that 
                      * this call is for defining the fileName *)
               ,common[]
               ,className[]
               ,(this(AstInterface)[],theGroup[])->getGroupIDProperty
               ) -> mch.init;
               301->trace(#
                         do 'currentFrag: '->puttext;
                            (thisDesc.frag[]).fullName -> putline
                         #);
               (if not isBetaEnv then
                   BCname[] -> splitPathAndNAme -> (path[],c[]);
                   className[] -> path.append;
                   (* AsmExt is appended in BCasmlink; at other unknown 
                    * places, asmExt is not appended either, so doing 
                    * it here gives problems
                    *)
                   ((*asmlink.asmext->(path.copy).append*) 
                   path[]
                   ,asmlink.BetaKind
                   ,true
                   ,false) 
                     -> AsmLink.TX.insert;
               if)
           if);
        #);
      genBetaObject:
        (# path,c: ^text; sig: @signature;
        enter path[]
        do (0,common.BetaObjectClass,false,platformSuperName,0,'-') -> mch.initGen;
           (if isJava then
               (0,'comp$',(theGen.ComponentSignatureId->theGen.specialSignature).asText,'c') 
                 -> mch.declareField;
            else
               (0,'_comp',(theGen.ComponentSignatureId->theGen.specialSignature).asText,'c') 
                 -> mch.declareField;
           if);
           path[] -> splitPathAndNAme -> (path[],c[]);
           (if not common.switch[189] then
               common.BetaObjectClass -> path.append;
               (asmlink.asmext->(path.copy).append
               ,asmlink.byteCodeKind,true,false) 
                 -> AsmLink.TX.insert;
           if);
           (if true then
               ((none,'-') -> constructorSignature).asText 
                 -> mch.constructorDef
            else
               (true,0) -> mch.saveReturn; (* generates constructor *)
           if);
           pushThis;
           ('initSuper','-')->mch.callAlloPrim; 
           (false,0) -> mch.return; 
           mch.endMethod;
           
           common.doMethod -> sig.addMethod; sig.noEnter; sig.exitVoid;
           (1,'_1'->(common.doMethod).append,false,sig.asText,1) 
             -> mch.initDo; 
           (false,0) -> mch.return; 
           mch.endMethod;
           
           mch.endClass
        #);

   do 311->trace
      (#
      do (if isJava then 'Compiler for Java bytecode' -> xT if);
         (if isClr then 'Compiler for .NET bytecode' -> xT if);
         xN;
         'genlib_bytecode: ' -> xT; xN;
         thisDesc[] -> xA;
         thisDesc[] -> sematt.hasAcode -> xB;
         returnSaved -> xB;
         xN;
         'path : ' -> xT; path[] -> xT; xN;
         'class: ' -> xT; xN;
         (thisDesc[],true) -> EH.descName -> xT;
         (if 'program'->thisFormName.equalNCS then
             'Main' -> xT
         if)
      #);
    (*  (if not common.switch[323] then false -> isDoPartForm if);*)
      (if true
       // 'program'->thisFormName.equalNCS then
          (thisDesc[],true) -> EH.descName -> className[];
          (className[],false) -> SetFileName;
          (BCname[],className[],thisDesc[],0,isDoPartForm) -> genClass;
       // 'tstenv'->thisFormName.equalNCS 
       // 'betaenv'->thisFormName.equalNCS then
          (thisDesc[],true) -> EH.descName -> className[];
          (className[],true) -> SetFileName;
          BCname[] -> genBetaObject;
          (BCname[],className[],thisDesc[],0,isDoPartForm) -> genClass;
          (*mch.close*)
       // thisDesc.label = gram.objectDescriptor then
          (* Note: all outer patterns are curently assumed
           * to be clases; we should reconsider this
           * problem with at least externalClassbelow
           *)

          (thisDesc[],true) -> EH.descName -> className[]; 
          (className[],false) -> SetFileName;
          (if ThisDesc -> sematt.descKind 
           // sematt.externalClassKind then
              (BCname.copy,className[],ThisDesc[],0) -> genExternalClass 
           else
              (BCname[],className[],thisDesc[],0,isDoPartForm) -> genClass;
          if)
       else 
          (* we never come here anymore?*)
          '\n**in else part' -> putline;
          (if not (thisDesc[] -> skipDesc) then
              (thisDesc[],true) -> EH.descName -> className[];
              (if ThisDesc -> sematt.descKind
               // sematt.generalKind
               // sematt.classKind
               // sematt.procKind then
                  (* check with gdbody to see what we ignore here *)
                  (* here we should test for class- or proc-subpatterns *)
                  (if ThisDesc[]->Sematt.hasDo then
                      ((thisDesc[],false)->EH.descName,thisDesc[]) -> genMethod
                   else
                      (BCname[],className[],thisDesc[],0,isDoPartForm)
                        -> genClass;
                  if)
               // sematt.externalClassKind then
                  (BCname.copy,className[],ThisDesc[],0) 
                    -> genExternalClass
          if)if)
      if)
   #)

