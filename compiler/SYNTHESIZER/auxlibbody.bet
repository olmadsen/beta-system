ORIGIN 'auxlib';
LIB_ITEM 'betacodegen';
INCLUDE 'signature'
---asgToNewRep:doPart---
do (rA[],false,isValueRep,true,size,isBoolRep,true) -> gen.newRep
   (# genRange::
        (#
        do (if switch182 then
                (theRange->mch.newCstOp,&mch.dataRegOperand[]) -> mch.ldCst
            else
               3 -> (theRange -> mch.newCstOp).toPrimDest;
           if)
        #)
   #);
   (if not switch182 then
       aR.alloc; 
       aR -> rAelm.reg; size -> rAelm.size; rAelm.freezeReg;
       (rA[],aR[]) -> mch.ldVal;
       (if rA[] -> gen.useTmpReg then 
           rA.theReg -> RR; 
           (rA[],RR[]) -> mch.gLea;
           RR[] -> mch.push; true -> restore_rA;
           RR.deAlloc 
       if);
    else
       (* just to make sure that stuff is defined *)
       'newRep$' -> theGen.text2signature -> rAelm.receiverType[];
       'repElm$' -> rAelm.fieldName[];
       'repElmRtpe$' -> theGen.text2signature -> rAelm.fieldType[];
       (* FIXME *)
       sematt.integerDesc[] -> rAelm.bAdr.localDesc[];
   if);

   (* Generate elements in INNER;
    * NextElmAdr gives address of next element
    *)
   INNER; 
   (if not switch182 then
       (if restore_rA then
           (# AA: @mch.RegAdr
           do AA.reg.alloc;
              AA.reg[] -> mch.pop;
              AA[] -> rA[]
           #)
       if);
   if);
   (if rA[] <> none (* can be none if bytecode and list2rep *) then
       (aR[],rA[]) -> mch.stVal; (* someone might have manipulated the
                                  * repetition during evaluation of INNER
                                  *)
   if);
   (if not switch182 then
       false -> rAelm.frozenReg;
       aR.deAlloc;
   if);
---auxlib_primGet:doPart---
do T0.alloc;
   I1->A.addOff; signed -> A.signed; 

   (if size
    // 1 then 
       (A[],T0[])->mch.ldByte;
       (I1,1,signed) -> selectPart
    // 2 then
       (A[],T0[])->mch.ldHalf;
       (I1,2,signed) -> selectPart
    // 4 then (A[],T0[])->mch.ldVal
   if);
   (* rest not in use for bytecode/switch182 *)
   (if true
    // common.targetMachineId = common.sun4s
    // common.isIntel then
       (* sign extension is done in XXXmachine for ldByte etc. *)
    else
       (if signed then
           (if size
            // 1 then T0[]->mch.SignExtByte
            // 2 then T0[]->mch.SignExtWord
           if)
       if)
   if);
   (T0,false,false,false)->mkComputedEvVal->V[];
   (* A.aReg should denote a real object - no clear needed! *)
   
---auxlib_primInxGet:doPart---
do common.switch[14]->oldS14; common.switch[15]->oldS15;
   true->common.switch[14]->common.switch[15];
   (if switch182 then
       (# tA: ^mch.address; IA: @mch.InxRegAdr
       do (&theGen.int32value[]).asText-> mch.allocAndStoreLocal -> tA[];
          INNER primInxGet;
          (rA[],mch.dataTop[])->mch.ldVal;
          (tA[],mch.dataTop[]) -> mch.ldVal;
          (* stack = [ ... rep,index *)
          (if size > 1 then
              (size -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
          if);
          mch.duplicate;
          (rA.size->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
          (mch.dataTop[],&mch.doubleDataRegOperand[],false(*mod*)) 
            -> mch.gDiv;
          (8->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
          (mch.dataTop[],mch.dataTop[],4) -> mch.gMult;

          (* store in tmp *)
          (&theGen.int32value[]).asText
            -> mch.allocAndStoreLocal
            -> tA[];
          (rA.size->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
          (mch.dataTop[],&mch.doubleDataRegOperand[],true(*div*)) 
            -> mch.gDiv;

          'this_'->IA.receiverType[];
          'index_'->IA.fieldName[];
          (&theGen.int32value[]).asText -> IA.fieldType[];
          (IA[],mch.dataTop[]) -> mch.ldVal;
          (if size
           // 1 then (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
           // 2 then (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
          if);
          (tA[],mch.dataTop[]) -> mch.ldVal;
          (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
          (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftRight;
          (0xFF->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
          (mch.dataTop[],mch.dataTop[],4) -> mch.gAnd
       #)
    else
       val.alloc; 
       (if size
        // 1 then 
           (dr,true,1)->rA.index->rA[];
           1->rA.addOff->rA[];
           (*val[]->mch.gClr; *)
           signed -> rA.signed;
           (rA[],val[])->mch.ldByte
        // 2 then 
           (dr,true,2)->rA.index->rA[];
           2->rA.addOff->rA[];
           (*val[]->mch.gClr; *)
           signed -> rA.signed;
           (rA[],val[])->mch.ldHalf
        // 4 then 
           (dr,true,4)->rA.index->rA[];
           4->rA.addOff->rA[];
           signed -> rA.signed;
           (rA[],val[])->mch.ldVal
       if);
       (if true
        // common.targetMachineId = common.sun4s
        // common.isIntel then
           (* sign extension is done in XXXmachine for ldByte etc *)
        else
           (if signed then
               (if size
                // 1 then val[]->mch.SignExtByte
                // 2 then val[]->mch.SignExtWord
               if)
           if)
       if);
       (* rA.aReg does NOT denote a real object - release *)
       rA.freeAdr; (* cleared if inxRegAdr which it is! *)
   if);
   (val,false,false,false)->mkComputedEvVal->V[];
   oldS14->common.switch[14]; oldS15->common.switch[15]
   
---auxlib_selectPart:doPart---   
do (if switch182 then
       (if size
        // 1 (* byte *) then
           (if offSet = 0 then
               (if isSigned then
                  (&mch.dataRegOperand[],24->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (&mch.dataRegOperand[],24->mch.newCstOp) 
                     -> mch.logicalShiftRight
               if) 
            else
               (if offSet
                // 1 then
                   (&mch.dataRegOperand[],0xFF0000->mch.newCstOp,4) 
                     -> mch.gAnd;
                // 2 then
                   (&mch.dataRegOperand[],0xFF00->mch.newCstOp,4) 
                     -> mch.gAnd;
                // 3 then
                   (&mch.dataRegOperand[],0xFF->mch.newCstOp,4) 
                     -> mch.gAnd
               if);
               (if isSigned then
                   (&mch.dataRegOperand[],offSet*8->mch.newCstOp) 
                     -> mch.logicalShiftLeft;
                   (&mch.dataRegOperand[],offSet*8->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (if offSet < 3 then
                    (&mch.dataRegOperand[],(3-offSet)*8->mch.newCstOp) 
                         -> mch.logicalShiftRight   
               if)if)
           if)
        // 2 (* short *) then
           (if offset = 0 then
               (if isSigned then
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.logicalShiftRight
               if)
            else
               (&mch.dataRegOperand[],0xFFFF->mch.newCstOp,4) -> mch.gAnd;
               (if isSigned then
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.logicalShiftLeft;
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.arithShiftRight
               if)
       if)if)
   if)
   
---GenCOMdispatch:doPart---
do (# C: @mch.cstOperand;
      A: ^mch.address; A1: @mch.RegAdr;
      dr: @mch.dataRegOperand;
      D: @ASTindex; msgName: ^text;
      more: @boolean;
      EH: @EvalHandler;
      (*nScan: @ | EH.scanNAdr;*)
      max,dummyMax: @integer; 
      argReg: @mch.dataRegOperand;
      callC:
        (# entry: ^text; noOfArgs: @integer;
           max,dummyMax: @integer; 
           dr: @mch.dataRegOperand
        enter(entry[],noOfArgs)
        do (sematt.cExt,noOfArgs) -> mch.initExternalCall;
           mch.getRegForXres->(max,dummyMax);
           mch.saveHeapTop;
           INNER;
           (if entry[] <> none then
               (entry,sematt.cExt,noOfArgs,0) -> mch.CallCproc;
           if);
           (sematt.cExt,common.longXpar,noOfArgs,0,max,dummyMax) 
             -> mch.getSimpleXres 
             -> dr; (* args *)
        exit dr
        #);
      pushObj:
        (# objReg: @mch.adrRegOperand;
        do (gen.thisRegAdr,Desc[],EV[],thisSuperChain)
             -> genOrgAdr->A[];
           4 -> A.size; (* ???*)
           objReg.alloc;
           (A[],objReg[]) -> mch.gLea;
           objReg[] -> mch.pushClong;
           A.freeAdr;
           objReg.deAlloc;
           
        #);
      pushMsgName:
        (#
        do (*EV.son -> EV;*)
           EV -> sematt.getName -> D; D.dclRef -> D;
           D.gettext -> msgName[];
           (*'\nname= '->puttext; msgName[] -> putline;*)
           (common.wtextXpar,sematt.cExt,1,0) 
             -> (msgName -> mkTxtCstEvVal).pushCpar
        #);
      pushTypes:
        (# T: @text
        do (if false then
               (for i: C.C repeat
                    forward -> CP.getenterP -> mch.newCstOp -> mch.pushCLong;
               for) 
            else
               (for i: C.C repeat
                    (if true -> CP.getenterP (* always forward *)
                     // common.longXpar then
                        'I' -> T.put
                     // common.textXpar then
                        'x' -> T.put
                     // common.COMobjectXpar then
                        'U' -> T.put
                     // common.BSTRXpar then
                        's' -> T.put
                     // common.holderXpar then
                        (* here we need to find out about
                         * the holder element type
                         *)
                        '&' -> T.put; 'I' -> T.put
                     else
                    if);
               for);
               (*'\ntypes: ' -> puttext; T[] ->putline;*)
               (common.textXpar,sematt.cExt,1,0) 
                 -> (T -> mkTxtCstEvVal).pushCpar
           if)
        #);
      push_Extra:
        (# C: @mch.cstOperand
        do (* extra arguments currently not in use.
            * Transfer in forward order:
            * push_wFlags;
            * push_pvRet;
            * push_pexcepinfo;
            * push_pnArgErr
            *)
           0 -> C;
           (for i: 4 repeat C[] -> mch.pushClong for);
        #);
      
   do sematt.dispatchExt -> mch.xParForward -> forward;
      externalName -> CP.externalName;
      Desc[] -> CP.desc[];
      sematt.dispatchExt -> CP.extType;
      EV.son -> CP.theES;
      CP.initPL;
      CP.top -> C.C; 
      
      EV.son -> EV;
      ('BETA_Invoke',CP.top+7) 
        -> CallC  
      (#
      do (if forward then
             pushObj;
             push_Extra;            
             pushMsgName;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushTypes;
         if);
         INNER GenCOMdispatch;
         (if not forward then 
             pushTypes;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushMsgName;
             push_Extra;
             pushObj
         if)
      #) -> dr;
      (dr,false,false,false) -> mkComputedEvVal -> V[]
   #)

---descName:doPart---
do (# N,F,FO: @ASTindex;
      FF: ^FragmentForm;
      getFirstnameDecl:
        (# F: @ASTindex; name: ^text
        enter F
        do L: F.son -> scanList(# do currentNode -> F; leave L #);
           F.getText -> name[];
        exit name[]
        #);
      originId:
        (# desc,origin: ^ASTindex; id: ^text
        enter desc[]
        do 317->trace(#do xU; 'OriginId:'->xT; desc[] -> xA; xD#);
           (if not (desc.isNull(* or (desc.label = gram.unExpanded)*)) then
               desc[] -> sematt.enclosingDesc -> origin[];
               (origin[],true) -> descName -> id[];
               (if true
                // 'tstenv' -> id.equal
                // 'betaenv' -> id.equal
                // 'BetaObject' -> id.equal
                // 'java/lang/Object'-> id.equal 
                // 'object'-> id.equal           
                // 'class [mscorlib]System.Object' -> id.equal
                    then none -> id[] 
               if);
           if)
        exit id[]
        #);
      catIdAndName:
        (# id,name: ^text
        enter(id[],name[])
        do (if id[] <> none then
               common.nameManglingCh -> id.put; 
               name[] -> id.append -> name[];
           if)
        exit name[]
        #);
      betaenvname:
        (# F: ^ASTindex; name: ^text
        enter F[]
        do F.theFragmentForm -> FF[];
           (FF.name).copy -> name[];
           (if true
            // 'tstenv' -> name.equalNCS
            // 'betaenv' -> name.equalNCS 
               then
               common.betaenv.groupname -> name[]
           if)
        exit name[]
        #);
      slotName:
        (# N,T: ^text
        enter N[]
        do 'slot' -> T[];
           common.nameManglingCh -> T.put;
           N[] -> T.append
        exit T[]
        #);
      isDescriptorForm: @boolean;
      lastDesc: @ASTindex;
      id: ^text
   do (if not switch182 then
          (dumpStack,'Descname Called with switch182 = false') -> stop
      if);
      (if desc.isNull then (* perhaps we should avoid calling with null?*)
          'object' -> name[];
       else
          317->trace(# do 'DescName:Begin: '->xT; xN; desc[] -> xA;#);
          desc -> F;
          L:
            (if F.label
             // gram.doPart 
             // gram.mainPart then 
                317 -> trace(# 
                            do 'descName:do/MainPartForm:'->xT; F[] -> xA 
                            #);
                F.xOrigin -> F;
                restart L
             // gram.descriptorForm then
                317 -> trace(# 
                            do 'descName:descriptorForm:'->xT; F[] -> xA 
                            #);
                F.xOrigin -> FO;
                F.son -> lastDesc;
                (if FO.isNull then
                    F.theFragmentForm -> FF[];
                    (FF.name).copy -> name[];
                    (if true
                     // 'tstenv' -> name.equalNCS
                     // 'betaenv' -> name.equalNCS 
                        then
                        common.betaenv.groupname -> name[] 
                    if)
                 else 
                    FO -> F;
                    restart L
                if)
             // gram.unExpanded then
                (# un: ^unExpanded
                do 317 -> trace(# do 'descName:unExpanded: '->xT; F[] -> xA #);
                   true -> isDescriptorForm;
                   F -> FO;
                   (if ((F.asAST->un[]).theSlot).category
                    // gram.objectDescriptor then
                       F -> lastDesc;
                       F.father -> F;
                       317 -> trace(# 
                                   do 'descName:unExpanded:desc: '->xT; 
                                      F[] -> xA 
                                   #);
                    else
                       F.slotOrigin -> F;
                       317 -> trace(# 
                                   do 'descName:unExpanded:other'->xT; 
                                      F[] -> xA 
                                   #);
                   if);
                   restart L;
                #)
             // gram.objectDescriptor then
                317 -> trace(# do 'descName:descriptor:'->xT; F[] -> xA #);
                F -> lastDesc;
                F.father -> F;
                restart L
             // gram.patternDecl
             // gram.virtualDecl then
                317 -> trace(#
                            do 'descName:ptn/virt:'->xT;
                               F[] -> xA 
                            #);
                F -> getFirstNameDecl -> name[];
                
             // gram.bindingDecl
             // gram.finalDecl then
                317 -> trace(#
                            do 'descName:bind/final:'->xT;
                               F[] -> xA 
                            #);
                
                (* we must use the name at the virtual
                 * declaration to ge the correct case
                 *)
                (# N: @ASTindex
                do F.son -> sematt.singleName -> N;
                   L: (#
                      do
                         N.virtDcl -> N;
                         N.sort -> F;
                         (if F.label <> gram.virtualDecl then
                             restart L
                      if)#);
                   317 -> trace(#
                               do F[] -> xA; N[] -> xA
                               #);
                   N.gettext -> name[];
                #)                       
             // gram.staticItem // gram.staticComponent then
                317 -> trace(# do 'descName:static:'->xT; F[] -> xA #);
                F.father (* gram.simpleDecl *) 
                  -> getFirstNameDecl
                  -> name[];
                (*(id[],name[]) -> catIdAndName -> name[]*)
             // gram.variablePattern then
                'FIXME_variablePattern' -> putline;
                'FIXME_variablePattern' -> NAME[];
                F.father (* gram.simpleDecl *) 
                  -> getFirstNameDecl
                  -> name[];
                
             // gram.nameApl then
                (* as A in 'V:< A' *)
                F.father -> F;
                (if F.label
                 // gram.virtualDecl
                 // gram.bindingDecl
                 // gram.finalDecl then
                    restart L
                 else
                    (* Some F where F: ##T *)
                    F.gettext -> name[]
                if)
             // gram.remote then
                (* as R.F.foo in V:: R.F.foo *)
                F.father -> F;
                (if F.label
                 // gram.virtualDecl
                 // gram.bindingDecl
                 // gram.finalDecl then
                    restart L
                 else
                    (* Some F where F: ##R.f.foo ??? *)
                    F.gettext -> name[]
                if)
             else
                313 -> trace(# do 'descName:Singular:'->xT; F[] -> xA #);
                (if true 
                 // isDescriptorForm then
                    (* 'descName:singularDescriptorForm: '->puttext;*)
                    FO.theSlotName -> slotName -> name[];(*
                                                          'slot'-> (FO.theSlotName).prepend -> name[];
                                                          common.nameManglingCh -> name.put;*)
                    false -> addOriginId (* hmm! *)
                 else
                    singular:
                      (if F.label 
                       // gram.insertedItem
                       // gram.dynamicItemGeneration 
                       // gram.dynamicComponentGeneration then
                          F.son -> F;
                          restart singular
                       // gram.objectDescriptor then
                          'singular_' -> name[];
                          F.descNo -> name.putint
                       // gram.unExpanded then
                          '\ShouldNotHappen:descName:unExpanded:' -> puttext;
                          desc.theSlotName -> slotName -> name[];
                          (*
                           'slot'-> (desc.theSlotName).prepend -> name[];
                           common.nameManglingCh -> name.put;*)
                          false -> addOriginId (* hmm! *)
                       else
                          (* innerDescs can be eliminated *)
                          '\nOOPS! DescName:calling innerDescs.getId:'
                          'label:'
                            ->puttext;
                          F.label -> putint; newline;
                          lastDesc -> DS.innerDescs.getId ->name[]
                if)if)
            if);
          (if addOriginId then
              (if not lastDesc.isNull then
                  lastDesc[] -> originId -> id[]
               else
                  '\nDescName:LastDesc is null; called with  desc:' 
                    -> putline;
                  (desc[],screen[],500) -> thePP                      
              if);
              317->trace(#
                        do 'Got:OriginId: '->xt; id[] -> xT
                        #)
          if);              
          (id[],name[]) -> catIdAndName -> name[]
      if);
      (if 'object' -> name.equalNCS then
          'BetaObject' -> name
      if);
      317->trace(# do 'DescName:found: ' -> xT; name[]->xT #);
   #)
