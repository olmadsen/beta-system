ORIGIN 'auxlib';
LIB_ITEM 'betacodegen';
INCLUDE 'signature'
---asgToNewRep:doPart---
do (rA[],false,isValueRep,true,size,isBoolRep) -> gen.newRep
   (# genRange::
        (#
        do (if switch182 then
                (theRange->mch.newCstOp,&mch.dataRegOperand[]) -> mch.ldCst
            else
               3 -> (theRange -> mch.newCstOp).toPrimDest;
           if)
        #)
   #);
   (if not switch182 then
       aR.alloc; 
       aR -> rAelm.reg; size -> rAelm.size; rAelm.freezeReg;
       (rA[],aR[]) -> mch.ldVal;
       (if rA[] -> gen.useTmpReg then 
           rA.theReg -> RR; 
           (rA[],RR[]) -> mch.gLea;
           RR[] -> mch.push; true -> restore_rA;
           RR.deAlloc 
       if);
    else
       (* just to make sure that stuff is defined *)
       'newRep$' -> theGen.text2signature -> rAelm.receiverType[];
       'repElm$' -> rAelm.fieldName[];
       'repElmRtpe$' -> theGen.text2signature -> rAelm.fieldType[];
       (* FIXME *)
       sematt.integerDesc[] (*rA.bAdr.localDesc[]*) -> rAelm.bAdr.localDesc[]
   if);

   (* Generate elements in INNER;
    * NextElmAdr gives address of next element
    *)
   INNER; 
   (if not switch182 then
       (if restore_rA then
           (# AA: @mch.RegAdr
           do AA.reg.alloc;
              AA.reg[] -> mch.pop;
              AA[] -> rA[]
           #)
       if);
   if);
   (if rA[] <> none (* can eb none if bytecode and list2rep *) then
       (aR[],rA[]) -> mch.stVal; (* someone might have manipulated the
                                  * repetition during evaluation of INNER
                                  *)
   if);
   (if not switch182 then
       false -> rAelm.frozenREg;
       aR.deAlloc;
   if);
   
---GenCOMdispatch:doPart---
do (# C: @mch.cstOperand;
      A: ^mch.address; A1: @mch.RegAdr;
      dr: @mch.dataRegOperand;
      D: @ASTindex; msgName: ^text;
      more: @boolean;
      EH: @EvalHandler;
      (*nScan: @ | EH.scanNAdr;*)
      max,dummyMax: @integer; 
      argReg: @mch.dataRegOperand;
      callC:
        (# entry: ^text; noOfArgs: @integer;
           max,dummyMax: @integer; 
           dr: @mch.dataRegOperand
        enter(entry[],noOfArgs)
        do (sematt.cExt,noOfArgs) -> mch.initExternalCall;
           mch.getRegForXres->(max,dummyMax);
           mch.saveHeapTop;
           INNER;
           (if entry[] <> none then
               (entry,sematt.cExt,noOfArgs,0) -> mch.CallCproc;
           if);
           (sematt.cExt,common.longXpar,noOfArgs,0,max,dummyMax) 
             -> mch.getSimpleXres 
             -> dr; (* args *)
        exit dr
        #);
      pushObj:
        (# objReg: @mch.adrRegOperand;
        do (gen.thisRegAdr,Desc[],EV[],thisSuperChain)
             -> genOrgAdr->A[];
           4 -> A.size; (* ???*)
           objReg.alloc;
           (A[],objReg[]) -> mch.gLea;
           objReg[] -> mch.pushClong;
           A.freeAdr;
           objReg.deAlloc;
           
        #);
      pushMsgName:
        (#
        do (*EV.son -> EV;*)
           EV -> sematt.getName -> D; D.dclRef -> D;
           D.gettext -> msgName[];
           (*'\nname= '->puttext; msgName[] -> putline;*)
           (common.wtextXpar,sematt.cExt,1,0) 
             -> (msgName -> mkTxtCstEvVal).pushCpar
        #);
      pushTypes:
        (# T: @text
        do (if false then
               (for i: C.C repeat
                    forward -> CP.getenterP -> mch.newCstOp -> mch.pushCLong;
               for) 
            else
               (for i: C.C repeat
                    (if true -> CP.getenterP (* always forward *)
                     // common.longXpar then
                        'I' -> T.put
                     // common.textXpar then
                        'x' -> T.put
                     // common.COMobjectXpar then
                        'U' -> T.put
                     // common.BSTRXpar then
                        's' -> T.put
                     // common.holderXpar then
                        (* here we need to find out about
                         * the holder element type
                         *)
                        '&' -> T.put; 'I' -> T.put
                     else
                    if);
               for);
               (*'\ntypes: ' -> puttext; T[] ->putline;*)
               (common.textXpar,sematt.cExt,1,0) 
                 -> (T -> mkTxtCstEvVal).pushCpar
           if)
        #);
      push_Extra:
        (# C: @mch.cstOperand
        do (* extra arguments currently not in use.
            * Transfer in forward order:
            * push_wFlags;
            * push_pvRet;
            * push_pexcepinfo;
            * push_pnArgErr
            *)
           0 -> C;
           (for i: 4 repeat C[] -> mch.pushClong for);
        #);
      
   do sematt.dispatchExt -> mch.xParForward -> forward;
      externalName -> CP.externalName;
      Desc[] -> CP.desc[];
      sematt.dispatchExt -> CP.extType;
      EV.son -> CP.theES;
      CP.initPL;
      CP.top -> C.C; 
      
      EV.son -> EV;
      ('BETA_Invoke',CP.top+7) 
        -> CallC  
      (#
      do (if forward then
             pushObj;
             push_Extra;            
             pushMsgName;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushTypes;
         if);
         INNER GenCOMdispatch;
         (if not forward then 
             pushTypes;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushMsgName;
             push_Extra;
             pushObj
         if)
      #) -> dr;
      (dr,false,false,false) -> mkComputedEvVal -> V[]
   #)

---descName:doPart---
do (# N,F,FO: @ASTindex;
      FF: ^FragmentForm;
      getFirstnameDecl:
        (# F: @ASTindex; name: ^text
        enter F
        do L: F.son -> scanList(# do currentNode -> F; leave L #);
           F.getText -> name[];
        exit name[]
        #);
      originId:
        (# desc,origin: ^ASTindex; id: ^text
        enter desc[]
        do 317->trace(#do xU; 'OriginId:'->xT; desc[] -> xA; xD#);
           (if not (desc.isNull(* or (desc.label = gram.unExpanded)*)) then
               desc[] -> sematt.enclosingDesc -> origin[];
               (origin[],true) -> descName -> id[];
               (if true
                // 'tstenv' -> id.equal
                // 'betaenv' -> id.equal
                // 'BetaObject' -> id.equal
                // 'java/lang/Object'-> id.equal 
                // 'object'-> id.equal           
                // 'class [mscorlib]System.Object' -> id.equal
                    then none -> id[] 
               if);
           if)
        exit id[]
        #);
      catIdAndName:
        (# id,name: ^text
        enter(id[],name[])
        do (if id[] <> none then
               common.nameManglingCh -> id.put; 
               name[] -> id.append -> name[];
           if)
        exit name[]
        #);
      betaenvname:
        (# F: ^ASTindex; name: ^text
        enter F[]
        do F.theFragmentForm -> FF[];
           (FF.name).copy -> name[];
           (if true
            // 'tstenv' -> name.equalNCS
            // 'betaenv' -> name.equalNCS 
               then
               common.betaenv.groupname -> name[]
           if)
        exit name[]
        #);
      slotName:
        (# N,T: ^text
        enter N[]
        do 'slot' -> T[];
           common.nameManglingCh -> T.put;
           N[] -> T.append
        exit T[]
        #);
      isDescriptorForm: @boolean;
      lastDesc: @ASTindex;
      id: ^text
   do (if not switch182 then
          (dumpStack,'Descname Called with switch182 = false') -> stop
      if);
      (if desc.isNull then (* perhaps we should avoid calling with null?*)
          'object' -> name[];
       else
          317->trace(# do 'DescName:Begin: '->xT; xN; desc[] -> xA;#);
          desc -> F;
          L:
            (if F.label
             // gram.doPart 
             // gram.mainPart then 
                317 -> trace(# 
                            do 'descName:do/MainPartForm:'->xT; F[] -> xA 
                            #);
                F.xOrigin -> F;
                restart L
             // gram.descriptorForm then
                317 -> trace(# 
                            do 'descName:descriptorForm:'->xT; F[] -> xA 
                            #);
                F.xOrigin -> FO;
                F.son -> lastDesc;
                (if FO.isNull then
                    F.theFragmentForm -> FF[];
                    (FF.name).copy -> name[];
                    (if true
                     // 'tstenv' -> name.equalNCS
                     // 'betaenv' -> name.equalNCS 
                        then
                        common.betaenv.groupname -> name[] 
                    if)
                 else 
                    FO -> F;
                    restart L
                if)
             // gram.unExpanded then
                (# un: ^unExpanded
                do 317 -> trace(# do 'descName:unExpanded: '->xT; F[] -> xA #);
                   true -> isDescriptorForm;
                   F -> FO;
                   (if ((F.asAST->un[]).theSlot).category
                    // gram.objectDescriptor then
                       F -> lastDesc;
                       F.father -> F;
                       317 -> trace(# 
                                   do 'descName:unExpanded:desc: '->xT; 
                                      F[] -> xA 
                                   #);
                    else
                       F.slotOrigin -> F;
                       317 -> trace(# 
                                   do 'descName:unExpanded:other'->xT; 
                                      F[] -> xA 
                                   #);
                   if);
                   restart L;
                #)
             // gram.objectDescriptor then
                317 -> trace(# do 'descName:descriptor:'->xT; F[] -> xA #);
                F -> lastDesc;
                F.father -> F;
                restart L
             // gram.patternDecl
             // gram.virtualDecl then
                317 -> trace(#
                            do 'descName:ptn/virt:'->xT;
                               F[] -> xA 
                            #);
                F -> getFirstNameDecl -> name[];
                
             // gram.bindingDecl
             // gram.finalDecl then
                317 -> trace(#
                            do 'descName:bind/final:'->xT;
                               F[] -> xA 
                            #);
                
                (* we must use the name at the virtual
                 * declaration to ge the correct case
                 *)
                (# N: @ASTindex
                do F.son -> sematt.singleName -> N;
                   L: (#
                      do
                         N.virtDcl -> N;
                         N.sort -> F;
                         (if F.label <> gram.virtualDecl then
                             restart L
                      if)#);
                   317 -> trace(#
                               do F[] -> xA; N[] -> xA
                               #);
                   N.gettext -> name[];
                #)                       
             // gram.staticItem // gram.staticComponent then
                317 -> trace(# do 'descName:static:'->xT; F[] -> xA #);
                F.father (* gram.simpleDecl *) 
                  -> getFirstNameDecl
                  -> name[];
                (*(id[],name[]) -> catIdAndName -> name[]*)
             // gram.variablePattern then
                'FIXME_variablePattern' -> putline;
                'FIXME_variablePattern' -> NAME[];
                F.father (* gram.simpleDecl *) 
                  -> getFirstNameDecl
                  -> name[];
                
             // gram.nameApl then
                (* as A in 'V:< A' *)
                F.father -> F;
                (if F.label
                 // gram.virtualDecl
                 // gram.bindingDecl
                 // gram.finalDecl then
                    restart L
                 else
                    (* Some F where F: ##T *)
                    F.gettext -> name[]
                if)
             // gram.remote then
                (* as R.F.foo in V:: R.F.foo *)
                F.father -> F;
                (if F.label
                 // gram.virtualDecl
                 // gram.bindingDecl
                 // gram.finalDecl then
                    restart L
                 else
                    (* Some F where F: ##R.f.foo ??? *)
                    F.gettext -> name[]
                if)
             else
                313 -> trace(# do 'descName:Singular:'->xT; F[] -> xA #);
                (if true 
                 // isDescriptorForm then
                    (* 'descName:singularDescriptorForm: '->puttext;*)
                    FO.theSlotName -> slotName -> name[];(*
                                                          'slot'-> (FO.theSlotName).prepend -> name[];
                                                          common.nameManglingCh -> name.put;*)
                    false -> addOriginId (* hmm! *)
                 else
                    singular:
                      (if F.label 
                       // gram.insertedItem
                       // gram.dynamicItemGeneration 
                       // gram.dynamicComponentGeneration then
                          F.son -> F;
                          restart singular
                       // gram.objectDescriptor then
                          'singular_' -> name[];
                          F.descNo -> name.putint
                       // gram.unExpanded then
                          '\ShouldNotHappen:descName:unExpanded:' -> puttext;
                          desc.theSlotName -> slotName -> name[];
                          (*
                           'slot'-> (desc.theSlotName).prepend -> name[];
                           common.nameManglingCh -> name.put;*)
                          false -> addOriginId (* hmm! *)
                       else
                          (* innerDescs can be eliminated *)
                          '\nOOPS! DescName:calling innerDescs.getId:'
                          'label:'
                            ->puttext;
                          F.label -> putint; newline;
                          lastDesc -> DS.innerDescs.getId ->name[]
                if)if)
            if);
          (if addOriginId then
              (if not lastDesc.isNull then
                  lastDesc[] -> originId -> id[]
               else
                  '\nDescName:LastDesc is null; called with  desc:' 
                    -> putline;
                  (desc[],screen[],500) -> thePP                      
              if);
              317->trace(#
                        do 'Got:OriginId: '->xt; id[] -> xT
                        #)
          if);              
          (id[],name[]) -> catIdAndName -> name[]
      if);
      (if 'object' -> name.equalNCS then
          'BetaObject' -> name
      if);
      317->trace(# do 'DescName:found: ' -> xT; name[]->xT #);
   #)
