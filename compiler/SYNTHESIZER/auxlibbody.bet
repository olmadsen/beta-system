ORIGIN 'auxlib';
LIB_ITEM 'betacodegen';
INCLUDE 'signature'
---evalLib:attributes---
setByteIndex:
  (# size: @integer; dr: ^mch.dataRegOperand
  enter(size,dr[])
  do 
     (if size=2 then
         (1->mch.newCstOp,dr[]) ->mch.logicalShiftLeft
     if);
     (0x3->mch.newcstOp,dr[],4)->mch.gAnd; (* dr mod 4 -> dr *)
  #)
---asgToNewRep:doPart---
do (* we pass true to newRep.isList2Rep signalling that
    * newRep should not store the repetition in rA
    *)
   (elmDesc[],rA[],false,isValueRep,true,size,isBoolRep,true) -> gen.newRep
   (# genRange::
        (#
        do (if switch182 then
                (theRange->mch.newCstOp,&mch.dataRegOperand[]) -> mch.ldCst
            else
               3 -> (theRange -> mch.newCstOp).toPrimDest;
           if)
        #)
   #);
   (if not switch182 then
       aR.alloc; 
       aR -> rAelm.reg; size -> rAelm.size; rAelm.freezeReg;
       (rA[],aR[]) -> mch.ldVal;
       (if rA[] -> gen.useTmpReg then 
           rA.theReg -> RR; 
           (rA[],RR[]) -> mch.gLea;
           RR[] -> mch.push; true -> restore_rA;
           RR.deAlloc 
       if);
    else
       (* just to make sure that stuff is defined *)
       (if true then
           (theGen.RepetitionSignatureId 
             -> theGen.specialSignature).asText 
             -> rAelm.receiverType[]
        else
           'newRep$' -> theGen.text2signature -> rAelm.receiverType[]
       if);
       'repElm$' -> rAelm.fieldName[];
       (if true then
           (theGen.RepetitionElementSignatureId
             -> theGen.specialSignature).asText
             -> rAelm.fieldType[];
        else
           'repElmtype$' -> theGen.text2signature -> rAelm.fieldType[];
       if);
       (* FIXME *)
       sematt.integerDesc[] -> rAelm.bAdr.localDesc[];
   if);

   (* Generate elements in INNER;
    * NextElmAdr gives address of next element
    *)
   INNER; 
   (if not switch182 then
       (if restore_rA then
           (# AA: @mch.RegAdr
           do AA.reg.alloc;
              AA.reg[] -> mch.pop;
              AA[] -> rA[]
           #)
       if);
   if);
   (if not noStore (*rA[] <> none (* can be none if bytecode and list2rep *) then
       (aR[],rA[]) -> mch.stVal; (* someone might have manipulated the
                                  * repetition during evaluation of INNER
                                  *)
   if);
   (if not switch182 then
       false -> rAelm.frozenReg;
       aR.deAlloc;
   if);
---auxlib_primindex:doPart---
  (* used for implementing
   *    (val,e)->X.%putByte, etc where X is a simple integer, etc.
   * A  is the address of X and dr has the value of e.
   * primIndex returns an inxRegAdr denoting the byte, etc.
   *)
   
do (if size=4 then leave primIndex if);
   (size,dr[]) -> setByteIndex;
   (if A.access = common.direct then
       (if A## = mch.regAdr## then
           A[]->RA[];
           RA.reg->IA.aReg; RA.off->IA.off
        else 
           A.toReg2->IA.aReg
       if)
    else
       '\n***Indirect in primIndex: never tested!'->putLine;
       A.toReg2->IA.aReg; 
   if);
   dr->IA.dReg; A.frozenReg->IA.frozenReg; 
   (if size // 1 // 2 then
       1->IA.size; (* Note we set the size to 1 here!
                    * (x.%getByte) (x.%getShort)
                    * Note that we set size to 1 for byte AND short.
                    * The reason is that IA is a byte address,
                    * but the index HAS been multiplied by the size.
                    * Only Intel uses the size.
                    * This is ugly.
                    * This may be a problem elsewhere
                    *)
   if);
   IA[]->A[]
   
---auxlib_primGet2:doPart---
   (* get mem[A + (dr mod 4 )]  *)
do (# tA: ^mch.address;
   do val.alloc;
      (if switch182 then
          (&theGen.int32value[]).asText-> mch.allocAndStoreLocal -> tA[];
          INNER primGet2;
          (A[],val[])->mch.ldVal;
          (if size
           // 1 then (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
           // 2 then (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
          if);
          (tA[],mch.dataTop[]) -> mch.ldVal;
          (* stack = [ ...,A,24/16,byteInx ] *)
          (if size 
           // 1 then
              (8 -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
           // 2 then
              (16 -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
          if);
          (* NOTE! size=1 NOT tested ! *)
          (* stack = [ ...,A,24/16,byteInx*b ] where b = 16, if size = 2
           *                                         b = 8 , if size = 1
           *)
          (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
          (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftRight;
          (if size
           // 1 then
              (0xFF->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
           // 2 then
              (0xFFFF->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
          if);
          (mch.dataTop[],mch.dataTop[],4) -> mch.gAnd
       else
          (A[],dr[],size) -> primIndex -> A[];
          signed -> A.signed;
          (if size
           // 1 then (*val[]->mch.gClr;*) (A[],val[])->mch.ldByte
           // 2 then (*val[]->mch.gClr;*) (A[],val[])->mch.ldHalf
           // 4 then (A[],val[])->mch.ldVal
          if);
          (if true
           // common.targetMachineId = common.sun4s
           // common.isIntel then
              (* sign extension is done in XXXmachine.LdByte etc. *)
           else
              (if signed then
                  (if size
                   // 1 then val[]->mch.SignExtByte
                   // 2 then val[]->mch.SignExtWord
                  if)
              if)
          if);
          (*A is NOT referring an object - must be cleared upon release *)
      if);
      A.freeAdr; (* is cleared if InxRegAdr - no clear needed for RegAdr *)
      (val,false,false,false)->mkComputedEvVal->V[]
   #)
---auxlib_primGet:doPart---
do T0.alloc;
   I1->A.addOff; signed -> A.signed; 

   (if size
    // 1 then 
       (A[],T0[])->mch.ldByte;
       (I1,1,signed) -> selectPart
    // 2 then
       (A[],T0[])->mch.ldHalf;
       (I1,2,signed) -> selectPart
    // 4 then (A[],T0[])->mch.ldVal
   if);
   (* rest not in use for bytecode/switch182 *)
   (if true
    // common.targetMachineId = common.sun4s
    // common.isIntel then
       (* sign extension is done in XXXmachine for ldByte etc. *)
    else
       (if signed then
           (if size
            // 1 then T0[]->mch.SignExtByte
            // 2 then T0[]->mch.SignExtWord
           if)
       if)
   if);
   (T0,false,false,false)->mkComputedEvVal->V[];
   (* A.aReg should denote a real object - no clear needed! *)
   
---auxlib_primInxGet:doPart---
do common.switch[14]->oldS14; common.switch[15]->oldS15;
   true->common.switch[14]->common.switch[15];
   (if switch182 then
       (# tA: ^mch.address; IA: @mch.InxRegAdr
       do (* stack = ..., IX  where IX is the byteindex in repetition *)
          (&theGen.int32value[]).asText-> mch.allocAndStoreLocal -> tA[];
          (* IX is stored in tmp_1 *)
          INNER primInxGet;
          (rA[],mch.dataTop[])->mch.ldVal;   (* push rep. element *)
          (tA[],mch.dataTop[]) -> mch.ldVal; (* push IX from tmp_1 *)
          (* stack = [ ... rep,index *)
          (if size <> rA.size then
              (* size = rA.size: a standard index into a repetition *)
              (if size > 1 then
                  (size -> mch.newCstOp,mch.dataTop[],4) -> mch.gMult
                  (* stack = ... rep,IX*size,   *)
              if);
              mch.duplicate;  (* stack = ... rep,IX,IX   *)
              (rA.size->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
              (mch.dataTop[],&mch.doubleDataRegOperand[],false(*mod*)) 
                -> mch.gDiv;
              (8->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
              (mch.dataTop[],mch.dataTop[],4) -> mch.gMult;
              (* stack = ... repElm, IX, (IX mod Rsize)*8 
               * where Rsize often is 4 since we often store in  an int rep
               *)              
              (&theGen.int32value[]).asText
                -> mch.allocAndStoreLocal
                -> tA[];
              (* stack = ... rep, IX, 
               * tmp_2 = (IX mod Rsize)*8 
               *)              
              (rA.size->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
              (mch.dataTop[],&mch.doubleDataRegOperand[],true(*div*)) 
                -> mch.gDiv;
              (* stack = ... rep, IX div 4 *)
          if);
          'this_'->IA.receiverType[];
          'index_'->IA.fieldName[];
          (if rA.size
           // 1 then 
              (if rA.bAdr.localDesc->sematt.charDesc.equal then
                  (&theGen.charValue[]).asText -> IA.fieldType[]
               else
                  (&theGen.int8value[]).asText -> IA.fieldType[]
              if)
           // 2 then
              (&theGen.int16value[]).asText -> IA.fieldType[]
           // 4 then
              (&theGen.int32value[]).asText -> IA.fieldType[]
          if);
          (IA[],mch.dataTop[]) -> mch.ldVal;
          (* stack = ... repElm   *)
          (if size <> rA.size then
              (* size = rA.size: just a standard index into a repetition *)
              (if true then
                  (tA[],mch.dataTop[]) -> mch.ldVal; 
                  (* tmp_2 = (IX mod Rsize)*8 
                   * bytepos: 0,4, 8,...:  0
                   *          1,5, 9,...:  8
                   *          2,6,10,...: 16
                   *          3,7,11,...: 24
                   *)
                  (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftLeft;
                  
                  (if size
                   // 1 then (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
                   // 2 then (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
                  if);
                  (if signed then
                      (mch.dataTop[],mch.dataTop[]) -> mch.arithShiftRight;
                   else
                      (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftRight;
                  if);                  
               else
                  (if size
                   // 1 then (24->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
                   // 2 then (16->mch.newCstOp,mch.dataTop[]) -> mch.ldCst
                  if);
                  (tA[],mch.dataTop[]) -> mch.ldVal; (* tmp_2 = (IX mod Rsize)*8 *)
                  (mch.dataTop[],mch.dataTop[],4) -> mch.gSub;
                  (* stack = ... Relm,24/16 - (IX mod Rsize)*8
                   * 24/16- (IX mod Rsize)*8 is the amount to rightShift
                   * the field to be extracted
                   *)
                  (if signed then
                      (mch.dataTop[],mch.dataTop[]) -> mch.arithShiftRight;
                   else
                      (mch.dataTop[],mch.dataTop[]) -> mch.logicalShiftRight;
                  if);
                  (if false then
                      (if size
                       // 1 then
                          (0xFF->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                       // 2 then
                          (0xFFFF->mch.newCstOp,mch.dataTop[]) -> mch.ldCst;
                      if);
                      (mch.dataTop[],mch.dataTop[],4) -> mch.gAnd
                  if)
              if)
          if)
       #)
    else
       val.alloc; 
       (if size
        // 1 then 
           (dr,true,1)->rA.index->rA[];
           1->rA.addOff->rA[];
           (*val[]->mch.gClr; *)
           signed -> rA.signed;
           (rA[],val[])->mch.ldByte
        // 2 then 
           (dr,true,2)->rA.index->rA[];
           2->rA.addOff->rA[];
           (*val[]->mch.gClr; *)
           signed -> rA.signed;
           (rA[],val[])->mch.ldHalf
        // 4 then 
           (dr,true,4)->rA.index->rA[];
           4->rA.addOff->rA[];
           signed -> rA.signed;
           (rA[],val[])->mch.ldVal
       if);
       (if true
        // common.targetMachineId = common.sun4s
        // common.isIntel then
           (* sign extension is done in XXXmachine for ldByte etc *)
        else
           (if signed then
               (if size
                // 1 then val[]->mch.SignExtByte
                // 2 then val[]->mch.SignExtWord
               if)
           if)
       if);
       (* rA.aReg does NOT denote a real object - release *)
       rA.freeAdr; (* cleared if inxRegAdr which it is! *)
   if);
   (val,false,false,false)->mkComputedEvVal->V[];
   oldS14->common.switch[14]; oldS15->common.switch[15]
   
---auxlib_selectPart:doPart---   
do (if switch182 then
       (if size
        // 1 (* byte *) then
           (if offSet = 0 then
               (if isSigned then
                  (&mch.dataRegOperand[],24->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (&mch.dataRegOperand[],24->mch.newCstOp) 
                     -> mch.logicalShiftRight
               if) 
            else
               (if offSet
                // 1 then
                   (&mch.dataRegOperand[],0xFF0000->mch.newCstOp,4) 
                     -> mch.gAnd;
                // 2 then
                   (&mch.dataRegOperand[],0xFF00->mch.newCstOp,4) 
                     -> mch.gAnd;
                // 3 then
                   (&mch.dataRegOperand[],0xFF->mch.newCstOp,4) 
                     -> mch.gAnd
               if);
               (if isSigned then
                   (&mch.dataRegOperand[],offSet*8->mch.newCstOp) 
                     -> mch.logicalShiftLeft;
                   (&mch.dataRegOperand[],24->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (if offSet < 3 then
                    (&mch.dataRegOperand[],(3-offSet)*8->mch.newCstOp) 
                         -> mch.logicalShiftRight   
               if)if)
           if)
        // 2 (* short *) then
           (if offset = 0 then
               (if isSigned then
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.arithShiftRight
                else
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.logicalShiftRight
               if)
            else
               (&mch.dataRegOperand[],0xFFFF->mch.newCstOp,4) -> mch.gAnd;
               (if isSigned then
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.logicalShiftLeft;
                   (&mch.dataRegOperand[],16->mch.newCstOp) 
                     -> mch.arithShiftRight
               if)
       if)if)
   if)
   
---GenCOMdispatch:doPart---
do (# C: @mch.cstOperand;
      A: ^mch.address; A1: @mch.RegAdr;
      dr: @mch.dataRegOperand;
      D: @ASTindex; msgName: ^text;
      more: @boolean;
      EH: @EvalHandler;
      max,dummyMax: @integer; 
      argReg: @mch.dataRegOperand;
      callC:
        (# entry: ^text; noOfArgs: @integer;
           max,dummyMax: @integer; 
           dr: @mch.dataRegOperand
        enter(entry[],noOfArgs)
        do (sematt.cExt,noOfArgs) -> mch.initExternalCall;
           mch.getRegForXres->(max,dummyMax);
           mch.saveHeapTop;
           INNER;
           (if entry[] <> none then
               (entry,sematt.cExt,noOfArgs,0) -> mch.CallCproc;
           if);
           (sematt.cExt,common.longXpar,noOfArgs,0,max,dummyMax) 
             -> mch.getSimpleXres 
             -> dr; (* args *)
        exit dr
        #);
      pushObj:
        (# objReg: @mch.adrRegOperand;
        do (gen.thisRegAdr,Desc[],EV[],thisSuperChain)
             -> genOrgAdr->A[];
           4 -> A.size; (* ???*)
           objReg.alloc;
           (A[],objReg[]) -> mch.gLea;
           objReg[] -> mch.pushClong;
           A.freeAdr;
           objReg.deAlloc;
           
        #);
      pushMsgName:
        (#
        do (*EV.son -> EV;*)
           EV -> sematt.getName -> D; D.dclRef -> D;
           D.gettext -> msgName[];
           (*'\nname= '->puttext; msgName[] -> putline;*)
           (common.wtextXpar,sematt.cExt,1,0) 
             -> (msgName -> mkTxtCstEvVal).pushCpar
        #);
      pushTypes:
        (# T: @text
        do (if false then
               (for i: C.C repeat
                    forward -> CP.getenterP -> mch.newCstOp -> mch.pushCLong;
               for) 
            else
               (for i: C.C repeat
                    (if true -> CP.getenterP (* always forward *)
                     // common.longXpar then
                        'I' -> T.put
                     // common.textXpar then
                        'x' -> T.put
                     // common.COMobjectXpar then
                        'U' -> T.put
                     // common.BSTRXpar then
                        's' -> T.put
                     // common.holderXpar then
                        (* here we need to find out about
                         * the holder element type
                         *)
                        '&' -> T.put; 'I' -> T.put
                     else
                    if);
               for);
               (*'\ntypes: ' -> puttext; T[] ->putline;*)
               (common.textXpar,sematt.cExt,1,0) 
                 -> (T -> mkTxtCstEvVal).pushCpar
           if)
        #);
      push_Extra:
        (# C: @mch.cstOperand
        do (* extra arguments currently not in use.
            * Transfer in forward order:
            * push_wFlags;
            * push_pvRet;
            * push_pexcepinfo;
            * push_pnArgErr
            *)
           0 -> C;
           (for i: 4 repeat C[] -> mch.pushClong for);
        #);
      
   do sematt.dispatchExt -> mch.xParForward -> forward;
      externalName -> CP.externalName;
      Desc[] -> CP.desc[];
      sematt.dispatchExt -> CP.extType;
      EV.son -> CP.theES;
      CP.initPL;
      CP.top -> C.C; 
      
      EV.son -> EV;
      ('BETA_Invoke',CP.top+7) 
        -> CallC  
      (#
      do (if forward then
             pushObj;
             push_Extra;            
             pushMsgName;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushTypes;
         if);
         INNER GenCOMdispatch;
         (if not forward then 
             pushTypes;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushMsgName;
             push_Extra;
             pushObj
         if)
      #) -> dr;
      (dr,false,false,false) -> mkComputedEvVal -> V[]
   #)

---descName:doPart---
do (# isLocal: booleanValue
        (# desc: ^ASTindex; formId: ^text; 
           descNo: @integer
        enter desc[]
        do (*1->trace(# do 'isLocal: ' -> xT; desc[] -> xA #);*)
           (if (not desc.isNull)
               and (desc.label = gram.objectDescriptor) then
                   desc.descId -> (formId[],descNo);
                   formid.makeUC;
                   (** see synthlibbody::mkEntryPoint
                    * for more elaborate version
                    *)
                   (*1->trace(#
                    do 'isLocal: ' -> xT;
                    formId[]->xT;
                    ' local: '->xT;
                    formId[]->formSet.isLocal -> xI; xN;
                    desc[] -> xA
                    #);*)
                   (formId[]->formSet.isLocal) <> 0 -> value
                   
           if)     
        #);
      fragPackage:
        (# desc: ^ASTindex; P: ^text; FF: ^fragmentForm
        enter desc[]
        do (if not common.switch[323] then
               desc.theFragmentForm -> FF[];
               (* FIXME: assuming other package is always default package.
                * Should instead find package name from FF.
                *)
               common.BetaPackage -> p[]; 
           if)
        exit P[]
        #);
      getDescName:
        (# N,F,FO: @ASTindex;
           FF: ^FragmentForm;
           getFirstnameDecl:
             (# F: @ASTindex; name: ^text
             enter F
             do L: F.son -> scanList(# do currentNode -> F; leave L #);
                F.getText -> name[];
             exit name[]
             #);
           originId:
             (# desc,origin: ^ASTindex; id: ^text
             enter desc[]
             do 317->trace(#do xU; 'OriginId:'->xT; desc[] -> xA; xD#);
                (if not desc.isNull then
                    (if desc.label = gram.objectDescriptor then
                        desc[] -> sematt.enclosingDesc -> origin[]
                     else
                        (* virtual, final, etc.
                         * This could probably be simpler
                         *)
                        desc[] -> sematt.encDescOfNode -> origin[]
                    if);
                    (origin[],true) -> getDescName -> id[];
                    (if false (*id[] <> none*) then
                        (if true
                         // 'tstenv' -> id.equal 
                         // 'betaenv' -> id.equal
                         // 'BetaObject' -> id.equal (* FIXME: needed? *)
                         // common.BetaObjectClass -> id.equal
                         // 'java/lang/Object'-> id.equal 
                         // 'object'-> id.equal           
                         // 'class [mscorlib]System.Object' -> id.equal
                            then 
                            1->trace(#
                                    do 'descName: ' -> xT; id[]->xT
                                    #);
                            none -> id[] 
                    if)if);
                if)
             exit id[]
             #);
           catIdAndName:
             (# id,name: ^text
             enter(id[],name[])
             do (if id[] <> none then
                    common.nameManglingCh -> id.put; 
                    name[] -> id.append -> name[];
                if)
             exit name[]
             #);
           slotName:
             (# N,T: ^text
             enter N[]
             do 'slot' -> T[];
                common.nameManglingCh -> T.put;
                N[] -> T.append
             exit T[]
             #);
           isDescriptorForm: @boolean;
           lastDesc: @ASTindex; (* the desc we are computing descName for;
                                 * is used to store desc while we are
                                 * going via father-ref to find enclosing
                                 * construct defining the name; e.g.
                                 * when descname is called with a desc
                                 * we need the enclosing decl, like
                                 * patternDecl, virtualDecl, etc. to
                                 * find the name, e.g.pattern name
                                 *)
           id: ^text;
           desc: ^ASTindex;
           addOriginId: @boolean;
           name: ^text
        enter(desc[],addOriginId)
        do (if true
            // (desc[] = none) then
               common.descNameStat[1] + 1 -> common.descNameStat[1] 
            // desc.isNull then
               common.descNameStat[2] + 1 -> common.descNameStat[2] 
            // desc.label < -10 then
               common.descNameStat[3] + 1 -> common.descNameStat[3] 
            // desc.label > 118 then
               common.descNameStat[4] + 1 -> common.descNameStat[4] 
            else
               common.descNameStat[5 + desc.label + 9] + 1 
                 -> common.descNameStat[5 + desc.label + 9] 
           if);
           (if desc.isNull then 
               (* perhaps we should avoid calling with null?*)
               none -> name[]
            else
               317->trace(# 
                         do 'DescName:Begin:level: '->xT; xN; 
                            desc[] -> xA
                         #);
               desc -> F;
               (* onlye some of the cases below may happen with an
                * initail call of descName; others may happen from 
                * restart to L
                *)
               L:
                 (if F.label
                  // gram.doPart 
                  // gram.mainPart then 
                     317 -> trace(# 
                                 do 'descName:do:MainPartForm:'->xT; F[] -> xA 
                                 #);
                     F.xOrigin -> F;
                     restart L
                  // gram.descriptorForm then
                     317 -> trace(# 
                                 do 'descName:descriptorForm:'->xT; F[] -> xA 
                                 #);
                     F.xOrigin -> FO;
                     F.son -> lastDesc;
                     (if FO.isNull then
                         F.theFragmentForm -> FF[];
                         (FF.name).copy -> name[];
                         (if true
                          // 'tstenv' -> name.equalNCS
                          // 'betaenv' -> name.equalNCS 
                             then
                             (if true then
                                 none -> name[]
                              else
                                 common.betaenv.groupname -> name[] 
                             if)
                          else
                             1->trace(#
                                     do 'xOrigin.isNull:not betaenv: '->xT;
                                        name[] -> xT
                                     #)
                         if)
                      else 
                         FO -> F;
                         restart L
                     if)
                  // gram.unExpanded then
                     (# un: ^unExpanded
                     do 313->trace(# 
                                  do 'descName:unExpanded: '->xT; F[] -> xA 
                                  #);
                        F -> FO;
                        (if ((F.asAST->un[]).theSlot).category
                         // gram.objectDescriptor then
                            true -> isDescriptorForm;
                            F -> lastDesc;
                            F.father -> F;
                            313-> trace(# 
                                       do 'descName:unExpanded:desc: '->xT; 
                                          F[] -> xA 
                                       #);
                         else
                            F.slotOrigin -> F;
                            313-> trace(# 
                                       do 'descName:unExpanded:other'->xT; 
                                          F[] -> xA 
                                       #);
                        if);
                        restart L;
                     #)
                  // gram.objectDescriptor then
                     317 -> trace(#do 'descName:descriptor:'->xT; F[]->xA#);
                     F -> lastDesc;
                     F.father -> F;
                     restart L
                  // gram.patternDecl
                  // gram.virtualDecl then
                     (* never come here via an initial call
                      * to descName; but only via a restart L.
                      * SO lastDesc should never be null
                      *)
                     313-> trace(#
                                do 'descName:ptn/virt:'->xT;
                                   F[] -> xA 
                                #);
                     F -> getFirstNameDecl -> name[];

                     (if addOriginId and lastDesc.isNull then
                         (* not understood *)
                         F -> lastDesc;
                         1 -> trace(#
                                   do 'OBS! DescName:ptn/virtual:' 
                                      'lastDesc was null!'
                                        -> xH;
                                      F[] -> xA; N[] -> xA; xN;
                                      'lastDesc: ' -> xT;
                                      lastDesc[] -> xA;
                                   #);                         
                     if)                     
                  // gram.bindingDecl
                  // gram.finalDecl then
                     (* never via initial call - as for virtual case above *)
                     317 -> trace(#
                                 do 'descName:bind/final:'->xT;
                                    F[] -> xA 
                                 #);
                     (* we must use the name at the virtual
                      * declaration to ge the correct case
                      *)
                     (# N: @ASTindex
                     do F.son -> sematt.singleName -> N;
                        (if addOriginId and lastDesc.isNull then
                            F -> lastDesc;
                            1 -> trace(#
                                      do 'OBS! DescName:bind/final:' 
                                         'lastDesc was null!'
                                           -> xT; xN;
                                         F[] -> xA; N[] -> xA; xN;
                                         'lastDesc: ' -> xT;
                                         lastDesc[] -> xA;
                                      #);
                            
                        if);
                        
                        L: (#
                           do N.virtDcl -> N;
                              N.sort -> F;
                              (if F.label <> gram.virtualDecl then
                                  restart L
                           if)#);
                        N.gettext -> name[];
                     #)                       
                  // gram.staticItem // gram.staticComponent then
                     317 -> trace(# do 'descName:static:'->xT; F[] -> xA #);
                     F.father (* gram.simpleDecl *) 
                       -> getFirstNameDecl
                       -> name[];
                     (*(id[],name[]) -> catIdAndName -> name[]*)
                  // gram.variablePattern then
                     'FIXME_variablePattern' -> putline;
                     'FIXME_variablePattern' -> NAME[];
                     F.father (* gram.simpleDecl *) 
                       -> getFirstNameDecl
                       -> name[];
                     
                  // gram.nameApl then
                     (* as A in 'V:< A' *)
                     F.father -> F;
                     (if F.label
                      // gram.virtualDecl
                      // gram.bindingDecl
                      // gram.finalDecl then
                         (if addOriginId and lastDesc.isNull then
                             1->trace(#
                                     do 'OBS! DescName:nameApl:'
                                        'lastDesc is null:'
                                          ->xT;
                                        F[] -> xA
                                     #);
                         if);
                         restart L
                      else
                         (* Some F where F: ##T *)
                         F.gettext -> name[]
                     if)
                  // gram.remote then
                     (* as R.F.foo in V:: R.F.foo *)
                     F.father -> F;
                     (if F.label
                      // gram.virtualDecl
                      // gram.bindingDecl
                      // gram.finalDecl then
                         restart L
                      else
                         (* Some F where F: ##R.f.foo ??? *)
                         F.gettext -> name[]
                     if)
                  else
                     313 -> trace(# do 'descName:Singular:'->xT; F[] -> xA #);
                     (if isDescriptorForm then
                         (* 'descName:singularDescriptorForm: '->puttext;*)
                         FO.theSlotName -> slotName -> name[];
                         false -> addOriginId (* hmm! *)
                      else
                         singular:
                           (if F.label 
                            // gram.insertedItem
                            // gram.dynamicItemGeneration 
                            // gram.dynamicComponentGeneration then
                               F.son -> F;
                               restart singular
                            // gram.objectDescriptor then
                               'singular_' -> name[];
                               (# D: ^ASTindex; PL: @integer
                               do F[] -> sematt.enclosingDesc -> D[];
                                  D -> sematt.descChain -> (D,PL);
                                  PL -> name.putint;
                                  '_' -> name.put
                               #);
                               F.descNo -> name.putint;
                            // gram.unExpanded then
                               '\ShouldNotHappen:descName:unExpanded:' -> puttext;
                               desc.theSlotName -> slotName -> name[];
                               false -> addOriginId (* hmm! *)
                            else
                               (* innerDescs can be eliminated *)
                               '\nOOPS! DescName:calling innerDescs.getId:'
                               'label:'
                                 ->puttext;
                               F.label -> putint; newline;
                               lastDesc -> DS.innerDescs.getId ->name[]
                     if)if)
                 if);
               (if addOriginId then
                   (if not lastDesc.isNull then
                       lastDesc[] -> originId -> id[]
                    else
                       1->trace(#
                               do 'DescName:LastDesc is null;'
                                  'called with desc:' -> xT; xN;
                                  desc[] -> xA; xN;
                                  'name: ' -> xT; name[] -> xT; xN;
                                  'addOriginId: ' -> xT; addOriginId -> xB;
                               #)
                   if);
                   317->trace(#
                             do 'Got:OriginId: '->xt; id[] -> xT
                             #)
               if);    
               (id[],name[]) -> catIdAndName -> name[];
           if);
           (if name[] <> none then
               (if 'object' -> name.equalNCS then
                   common.BetaObjectClass -> name[];
                   (if isJava then
                       (* Strip package path 'beta/'*)
                       (6,name.length) -> name.sub -> name[]
                   if)
           if)if)
        exit name[]
        #);
      newGetDescName:
        (# N,F,FO: @ASTindex;
           FF: ^FragmentForm;
           getFirstnameDecl:
             (# F: @ASTindex; name: ^text
             enter F
             do L: F.son -> scanList(# do currentNode -> F; leave L #);
                F.getText -> name[];
             exit name[]
             #);
           originId:
             (# desc,origin: ^ASTindex; id: ^text
             enter desc[]
             do 317->trace(#do xU; 'OriginId:'->xT; desc[] -> xA; xD#);
                (if not desc.isNull then
                    (if desc.label = gram.objectDescriptor then
                        desc[] -> sematt.enclosingDesc -> origin[]
                     else
                        (* virtual, final, etc.
                         * This could probably be simpler
                         *)
                        desc[] -> sematt.encDescOfNode -> origin[]
                    if);
                    (origin[],true) -> getDescName -> id[];
                if)
             exit id[]
             #);
           catIdAndName:
             (# id,name: ^text
             enter(id[],name[])
             do (if id[] <> none then
                    common.nameManglingCh -> id.put; 
                    name[] -> id.append -> name[];
                if)
             exit name[]
             #);
           slotName:
             (# N,T: ^text
             enter N[]
             do 'slot' -> T[];
                common.nameManglingCh -> T.put;
                N[] -> T.append
             exit T[]
             #);
           getDclName:
             (# spec: ^ASTindex; F: @ASTindex
             enter spec[]
             do spec.father -> F;
                L: (#
                   do 317 ->trace(#do 'getDclName: '->xT; F[] -> xA #);
                      (if F.label
                       // gram.patternDecl
                       // gram.virtualDecl then
                          F -> getFirstNameDecl -> name[];
                       // gram.bindingDecl
                       // gram.finalDecl then
                          (# N: @ASTindex
                          do F.son -> sematt.singleName -> N;
                             (* We must use the name at the virtual
                              * declaration to get the correct case
                              *)
                             L: (#
                                do N.virtDcl -> N;
                                   N.sort -> F;
                                   (if F.label <> gram.virtualDecl then
                                       restart L
                                if)#);
                             N.gettext -> name[];
                          #)                       
                       // gram.staticItem // gram.staticComponent then
                          F.father (* gram.simpleDecl *) 
                            -> getFirstNameDecl
                            -> name[];
                       // gram.variablePattern then
                          'FIXME_variablePattern' -> putline;
                          'FIXME_variablePattern' -> NAME[];
                          F.father (* gram.simpleDecl *) 
                            -> getFirstNameDecl
                            -> name[];
                       // gram.descriptorForm then
                          (* In cases like
                           *    ---xxx:objectDescriptor---
                           *    (# ... #)
                           * DescName for this descriptor will have 
                           * descriptorForm as father
                           *)
                          F.xOrigin -> FO;
                          F.son -> lastDesc;
                          (if FO.isNull then
                              none -> name[]
                           else 
                              FO -> F;
                              (# un: ^unExpanded
                              do F -> FO;
                                 (if ((F.asAST->un[]).theSlot).category
                                  // gram.objectDescriptor then
                                     true -> isDescriptorSlot;
                                     F -> lastDesc;
                                     F.father -> F;
                                  else
                                     F.slotOrigin -> F;
                                 if);
                                 restart L;
                              #)                          
                          if)
                       // gram.insertedItem
                       // gram.dynamicItemGeneration 
                       // gram.dynamicComponentGeneration then
                          (* Singular descriptor in do-part *)
                          (if isDescriptorSlot then
                              (* We should eliminate isDescriptorSlot *)
                              FO.theSlotName -> slotName -> name[];
                              false -> addOriginId (* hmm! *)
                           else
                              (if spec.label                              
                               // gram.objectDescriptor then
                                  'singular_' -> name[];
                                  (# D: ^ASTindex; PL: @integer
                                  do spec[] -> sematt.enclosingDesc -> D[];
                                     D -> sematt.descChain -> (D,PL);
                                     PL -> name.putint;
                                     '_' -> name.put
                                  #);
                                  spec.descNo -> name.putint;
                               // gram.unExpanded then
                                  (* Currently we do probably never com here.
                                   * But we may if isDescriptorSlot is
                                   * eliminated - would be nicer
                                   *)
                                  FO.theSlotName -> slotName -> name[];
                                  false -> addOriginId (* hmm! *)
                               else
                                  '\nSingular case not handled: ' -> puttext;
                                  spec.label -> putint; newline
                          if)if)
                       else
                          '\nShould not come here: ' -> puttext;
                          F.label -> putint; newline
                      if)
                   #)
             #);
           isDescriptorSlot: @boolean;
           lastDesc: @ASTindex; (* the desc we are computing descName for;
                                 * is used to store desc while we are
                                 * going via father-ref to find enclosing
                                 * construct defining the name; e.g.
                                 * when descname is called with a desc
                                 * we need the enclosing decl, like
                                 * patternDecl, virtualDecl, etc. to
                                 * find the name, e.g.pattern name
                                 *)
           id: ^text;
           desc: ^ASTindex;
           addOriginId: @boolean;
           name: ^text
        enter(desc[],addOriginId)
        do (if true
            // (desc[] = none) then
               common.descNameStat[1] + 1 -> common.descNameStat[1] 
            // desc.isNull then
               common.descNameStat[2] + 1 -> common.descNameStat[2] 
            // desc.label < -10 then
               common.descNameStat[3] + 1 -> common.descNameStat[3] 
            // desc.label > 118 then
               common.descNameStat[4] + 1 -> common.descNameStat[4] 
            else
               common.descNameStat[5 + desc.label + 9] + 1 
                 -> common.descNameStat[5 + desc.label + 9] 
           if);
           (if desc.isNull then 
               (* Perhaps we should avoid calling with null? *)
               none -> name[]
            else
               317->trace(# 
                         do 'DescName: '->xT; xN; desc[] -> xA
                         #);
               desc -> F;
               L:
                 (if F.label
                  // gram.objectDescriptor then
                     F -> lastDesc;
                     F[] -> getDclName
                  // gram.doPart 
                  // gram.mainPart then 
                     F.xOrigin -> F;
                     restart L
                  // gram.descriptorForm then
                     (* Perhaps we can/should avoid calling 
                      * with descriptorForm? *)
                     F.sonRef -> getDclName
                  // gram.unExpanded then
                     (# un: ^unExpanded
                     do (if ((F.asAST->un[]).theSlot).category
                         = gram.objectDescriptor then
                            true -> isDescriptorSlot;
                            F -> FO;
                            F -> lastDesc;
                            F[] -> getDclName;
                         else
                            (* doPart, mainPart *)
                            F.slotOrigin -> F;
                            restart L;
                        if);
                     #)
                  // gram.nameApl then
                     (* As 'A' in 'V:< A' *)
                     F[] -> getDclName                     
                  // gram.remote then
                     (* As 'R.F.foo' in 'V:: R.F.foo' *)
                     F[] -> getDclName
                  else
                     '\nMissing case:'->puttext; F.label->putint; newline
                 if);
               (if addOriginId then lastDesc[] -> originId -> id[] if);    
               (id[],name[]) -> catIdAndName -> name[];
           if);
           (if name[] <> none then
               (if 'object' -> name.equalNCS then
                   common.BetaObjectClass -> name[];
                   (if isJava then
                       (* Strip package path 'beta/'*)
                       (6,name.length) -> name.sub -> name[]
                   if)
           if)if)
        exit name[]
        #);
      p: ^text;
   do (desc[],addOriginId) -> newGetDescName -> name[];
      (if name[] = none then
          common.betaenv.groupname -> name[] 
      if);
      (if isJava then
          (* Add package name *)
          (if addOriginId then
              (if common.BetaObjectClass->name.equal then
                  (* default package already there *)
               else
                  (if (desc[] -> isLocal) then
                      thisPackagePath[] -> name.prepend;
                   else
                      (* in another fragment that may have a package *)
                      (if (desc[] -> fragPackage -> p[]) <> none then
                          p[] -> name.prepend
                      if)
                  if)
              if)
          if);
      if);
      313->trace(# do 'DescName:found: ' -> xT; name[]->xT #);
   #)
---auxlib_getElmDesc:doPart---
do (# D: ^ASTindex;
      chain1: ^DH.superChain;
      nScan: @ | scanNadr;
      getDescOfEv:
        (# EV,desc,sort: @ASTindex; chain: ^DH.superChain; D: ^ASTindex
        enter(EV,chain[])
        do (if EV.label = gram.objectDescriptor then                   
               (chain[],EV)
                 -> DH.theDesc
                 -> (desc,chain1[]);
               (EV[],chain1[],rA[])
                 -> getElmDesc
                 -> D[];
               D -> desc
            else
               EV -> sematt.getSort -> sort;
               301->trace(#
                       do 'getDescofEv: ' -> xT; EV[] -> xA;
                          sort[] -> xA
                       #);
               (if sort.label <> gram.repetitionDecl then
                   (if sort.label 
                    // gram.simpleDecl then
                       (sort.sonRef).brother -> sort;
                       sort.son -> sort
                    // gram.patternDecl then
                       (sort.sonRef).brother -> sort
                    else
                       1->trace(#do 'getDescOfEv:case not covered' -> xT #);
                       (sort.sonRef).brother -> sort
                   if);
                   (chain[],sort)
                     -> DH.theDesc
                     -> (desc,chain1[]);                       
                   (desc[],chain1[],rA[])
                     -> getElmDesc
                     -> D[];
                   D -> desc
                else
                   (chain[],EV)
                     -> DH.theDesc
                     -> (desc,chain1[])                       
               if)
           if)
        exit desc[]
        #);
      more: @boolean
   do 301->trace(#
                do 'getElmDesc:'->xT; rElm[] -> xA;
                #);
      (if rElm.label = gram.objectDescriptor then  
          (* there should be exactly one enter element *)
          (rElm[],rA[],0,rChain[],true) -> nScan -> more; 
          301->trace(#
                  do 'getElmDesc: '->xT;
                     'nScan.thisEv: ' -> xT; nScan.thisEv[]->xA ;
                     nScan.thisChain
                  #);
          (nScan.thisEv.son,nScan.thisChain[]) -> getDescOfEv -> D[];
          D -> desc;
          L: (if more then nScan -> more; restart L if)
       else
          (rElm.son,rChain[]) -> getDescOfEv -> D[]; D -> desc
      if)
   #);
   
---auxlib_getVirtDcl:doPart---
do (# F: @ASTindex;
   do &ASTindex[] -> VD[];
      VN.sort -> F;
      VN -> VD;
      L:
        (if F.label <> gram.virtualDecl then         
         VD.virtDcl -> VD;
            VD.sort -> F;
            restart L
        if);
   #)
 
