ORIGIN 'auxlib';
LIB_ITEM 'betacodegen';
---asgToNewRep:doPart---
do (rA[],false,isValueRep,true,size) -> gen.newRep
   (# genRange::
        (#
        do 3 -> (theRange -> mch.newCstOp).toPrimDest 
        #)
   #);
   aR.alloc; 
   aR -> rAelm.reg; size -> rAelm.size; rAelm.freezeReg;
   (rA[],aR[]) -> mch.ldVal;
   (if rA[] -> gen.useTmpReg then 
       rA.theReg -> RR; 
       (rA[],RR[]) -> mch.gLea;
       RR[] -> mch.push; true -> restore_rA;
       RR.deAlloc 
   if);
   (* Generate elements in INNER;
    * NextElmAdr gives address of next element
    *)
   INNER; 
   (if restore_rA then
       (# AA: @mch.RegAdr
       do AA.reg.alloc;
          AA.reg[] -> mch.pop;
          AA[] -> rA[]
       #)
   if);
   (aR[],rA[]) -> mch.stVal; (* someone might have manipulated the
                              * repetition during evaluation of INNER
                              *)
   false -> rAelm.frozenREg;
   aR.deAlloc;
   
---GenCOMdispatch:doPart---
do (# C: @mch.cstOperand;
      A: ^mch.address; A1: @mch.RegAdr;
      dr: @mch.dataRegOperand;
      D: @ASTindex; msgName: ^text;
      more: @boolean;
      EH: @EvalHandler;
      (*nScan: @ | EH.scanNAdr;*)
      max,dummyMax: @integer; 
      argReg: @mch.dataRegOperand;
      callC:
        (# entry: ^text; noOfArgs: @integer;
           max,dummyMax: @integer; 
           dr: @mch.dataRegOperand
        enter(entry[],noOfArgs)
        do (sematt.cExt,noOfArgs) -> mch.initExternalCall;
           mch.getRegForXres->(max,dummyMax);
           mch.saveHeapTop;
           INNER;
           (if entry[] <> none then
               (entry,sematt.cExt,noOfArgs,0) -> mch.CallCproc;
           if);
           (sematt.cExt,common.longXpar,noOfArgs,0,max,dummyMax) 
             -> mch.getSimpleXres 
             -> dr; (* args *)
        exit dr
        #);
      pushObj:
        (# objReg: @mch.adrRegOperand;
        do (gen.thisRegAdr,Desc[],EV[],thisSuperChain)
             -> genOrgAdr->A[];
           4 -> A.size; (* ???*)
           objReg.alloc;
           (A[],objReg[]) -> mch.gLea;
           objReg[] -> mch.pushClong;
           A.freeAdr;
           objReg.deAlloc;
           
        #);
      pushMsgName:
        (#
        do (*EV.son -> EV;*)
           EV -> sematt.getName -> D; D.dclRef -> D;
           D.gettext -> msgName[];
           (*'\nname= '->puttext; msgName[] -> putline;*)
           (common.wtextXpar,sematt.cExt,1,0) 
             -> (msgName -> mkTxtCstEvVal).pushCpar
        #);
      pushTypes:
        (# T: @text
        do (if false then
               (for i: C.C repeat
                    forward -> CP.getenterP -> mch.newCstOp -> mch.pushCLong;
               for) 
            else
               (for i: C.C repeat
                    (if true -> CP.getenterP (* always forward *)
                     // common.longXpar then
                        'I' -> T.put
                     // common.textXpar then
                        'x' -> T.put
                     // common.COMobjectXpar then
                        'U' -> T.put
                     // common.BSTRXpar then
                        's' -> T.put
                     // common.holderXpar then
                        (* here we need to find out about
                         * the holder element type
                         *)
                        '&' -> T.put; 'I' -> T.put
                     else
                    if);
               for);
               (*'\ntypes: ' -> puttext; T[] ->putline;*)
               (common.textXpar,sematt.cExt,1,0) 
                 -> (T -> mkTxtCstEvVal).pushCpar
           if)
        #);
      push_Extra:
        (# C: @mch.cstOperand
        do (* extra arguments currently not in use.
            * Transfer in forward order:
            * push_wFlags;
            * push_pvRet;
            * push_pexcepinfo;
            * push_pnArgErr
            *)
           0 -> C;
           (for i: 4 repeat C[] -> mch.pushClong for);
        #);
      
   do sematt.dispatchExt -> mch.xParForward -> forward;
      externalName -> CP.externalName;
      Desc[] -> CP.desc[];
      sematt.dispatchExt -> CP.extType;
      EV.son -> CP.theES;
      CP.initPL;
      CP.top -> C.C; 
      
      EV.son -> EV;
      ('BETA_Invoke',CP.top+7) 
        -> CallC  
      (#
      do (if forward then
             pushObj;
             push_Extra;            
             pushMsgName;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushTypes;
         if);
         INNER GenCOMdispatch;
         (if not forward then 
             pushTypes;
             (*C[] -> mch.pushClong; (* noOfArgs*) 
             pushMsgName;
             push_Extra;
             pushObj
         if)
      #) -> dr;
      (dr,false,false,false) -> mkComputedEvVal -> V[]
   #)

---descName:doPart---
do (# N,F,FO: @ASTindex;
      FF: ^FragmentForm;
      getFirstnameDecl:
        (# F: @ASTindex; name: ^text
        enter F
        do L: F.son -> scanList(# do currentNode -> F; leave L #);
           F.getText -> name[];
        exit name[]
        #);
      originId:
        (# desc,origin: ^ASTindex; id: ^text
        enter desc[]
        do 317->trace(#do xU; 'OriginId:'->xT; desc[] -> xA; xD#);
           (if not (desc.isNull(* or (desc.label = gram.unExpanded)*)) then
               (if true then
                   desc[] -> sematt.enclosingDesc -> origin[]
                   (*
                   desc[] -> sematt.descOrigin -> origin[];
                   (if not (origin.isNull) and 
                       (origin.label = gram.labelledImp) then
                       origin.origin -> origin
                   if);*)
                else
                   desc[] -> sematt.descOrigin -> origin[];
               if);
               (origin[],true) -> descName -> id[];
               (if true
                // 'tstenv' -> id.equal
                // 'BetaObject' -> id.equal
                // 'java/lang/Object'-> id.equal (* not switch 186 *)
                // 'object'-> id.equal           (* not switch 186 *)
                // 'class [mscorlib]System.Object' -> id.equal (* not switch 186*)
                    then none -> id[] 
               if);
           if)
        exit id[]
        #);
      catIdAndName:
        (# id,name: ^text
        enter(id[],name[])
        do (if id[] <> none then
               common.nameManglingCh -> id.put; 
               name[] -> id.append -> name[];
           if)
        exit name[]
        #);
      betaenvname:
        (# F: ^ASTindex; name: ^text
        enter F[]
        do  F.theFragmentForm -> FF[];
           (FF.name).copy -> name[];
           (if true
            // 'tstenv' -> name.equalNCS
            // 'betaenv' -> name.equalNCS then
               (* 'DescName: tstenv' -> putline; *)
               'tstenv' -> name[]
               (* should be changed to BetaEnv' *)
           if)
        exit name[]
        #);
      slotName:
        (# N,T: ^text
        enter N[]
        do 'slot' -> T[];
           common.nameManglingCh -> T.put;
           N[] -> T.append
        exit T[]
        #);
      isDescriptorForm: @boolean;
      lastDesc: @ASTindex;
      id: ^text
   do (if not switch182 then
          (dumpStack,'Descname Called with switch182 = false') -> stop
      if);
      (if desc.isNull then (* prhaps we should avoid calling with null?*)
          'object' -> name[];
       else
          317->trace(#
                    do 'DescName:Begin: '->xT; xN; desc[] -> xA;#);
          (if true then
              desc -> F;
              L:
              (if F.label
               // gram.doPart 
               // gram.mainPart then 
                  317 -> trace(# 
                              do 'descName:do/MainPartForm:'->xT; F[] -> xA 
                              #);
                  F.xOrigin -> F;
                  restart L
               // gram.descriptorForm then
                  317 -> trace(# 
                              do 'descName:descriptorForm:'->xT; F[] -> xA 
                              #);
                  F.xOrigin -> FO;
                  F.son -> lastDesc;
                  (if FO.isNull then
                      (if common.switch[186] then
                          F.theFragmentForm -> FF[];
                          (FF.name).copy -> name[];
                          (if true
                           // 'tstenv' -> name.equalNCS
                           // 'betaenv' -> name.equalNCS then
                              (* 'DescName: tstenv' -> putline; *)
                              'tstenv' -> name[]
                              (* should be changed to BetaEnv' *)
                          if)
                       else
                          (if true
                           // common.targetMachineId = common.javabc then
                              'java/lang/Object'->name[];
                           // common.targetMachineId = common.dotnet then
                              'object'->name[];
                           else
                              'Unknown_platform.Object' -> name[];
                          if);
                      if)
                   else 
                      FO -> F;
                      restart L
                  if)
               // gram.unExpanded then
                  (# un: ^unExpanded
                  do 317 -> trace(# do 'descName:unExpanded: '->xT; F[] -> xA #);
                     true -> isDescriptorForm;
                     F -> FO;
                     (if ((F.asAST->un[]).theSlot).category
                      // gram.objectDescriptor then
                         F -> lastDesc;
                         F.father -> F;
                         317 -> trace(# 
                                     do 'descName:unExpanded:desc: '->xT; 
                                        F[] -> xA 
                                     #);
                      else
                         F.slotOrigin -> F;
                         317 -> trace(# 
                                     do 'descName:unExpanded:other'->xT; 
                                        F[] -> xA 
                                     #);
                     if);
                     restart L;
                  #)
               // gram.objectDescriptor then
                  317 -> trace(# do 'descName:descriptor:'->xT; F[] -> xA #);
                  F -> lastDesc;
                  F.father -> F;
                  restart L
               // gram.patternDecl
               // gram.virtualDecl
               // gram.bindingDecl
               // gram.finalDecl then
                  317 -> trace(#
                              do 'descName:ptn/virt/bind/final:'->xT;
                                 F[] -> xA 
                              #);
                  F -> getFirstNameDecl -> name[];
                  (*(id[],name[]) -> catIdAndName -> name[]*)
               // gram.staticItem // gram.staticComponent then
                  317 -> trace(# do 'descName:static:'->xT; F[] -> xA #);
                  F.father (* gram.simpleDecl *) 
                    -> getFirstNameDecl
                    -> name[];
                  (*(id[],name[]) -> catIdAndName -> name[]*)
               // gram.variablePattern then
                  'FIXME_variablePattern' -> NAME[]
                  
               // gram.nameApl then
                  (* as A in 'V:< A' *)
                  F.father -> F;
                  restart L
               else
                  313 -> trace(# do 'descName:Singular:'->xT; F[] -> xA #);
                  (if true 
                   // isDescriptorForm then
                      (* 'descName:singularDescriptorForm: '->puttext;*)
                      FO.theSlotName -> slotName -> name[];(*
                      'slot'-> (FO.theSlotName).prepend -> name[];
                      common.nameManglingCh -> name.put;*)
                      false -> addOriginId (* hmm! *)
                   else
                      singular:
                        (if F.label 
                         // gram.insertedItem
                         // gram.dynamicItemGeneration 
                         // gram.dynamicComponentGeneration then
                            F.son -> F;
                            restart singular
                         // gram.objectDescriptor then
                            'singular_' -> name[];
                            F.descNo -> name.putint
                         // gram.unExpanded then
                            '\ShouldNotHappen:descName:unExpanded:' -> puttext;
                            desc.theSlotName -> slotName -> name[];
                            (*
                             'slot'-> (desc.theSlotName).prepend -> name[];
                             common.nameManglingCh -> name.put;*)
                            false -> addOriginId (* hmm! *)
                         else
                            (* innerDescs can be eliminated *)
                            '\nOOPS! DescName:calling innerDescs.getId:'
                            'label:'
                              ->puttext;
                            F.label -> putint; newline;
                            lastDesc -> DS.innerDescs.getId ->name[]
                  if)if)
              if);
              (if addOriginId then
                  (if not lastDesc.isNull then
                      lastDesc[] -> originId -> id[]
                   else
                      '\nDescName:LastDesc is null; called with  desc:' 
                        -> putline;
                        (desc[],screen[],500) -> thePP                      
                  if);
                  317->trace(#
                            do 'Got:OriginId: '->xt; id[] -> xT
                            #)
              if);              
              (id[],name[]) -> catIdAndName -> name[]
           else
              desc.father -> F;
              317->trace(#
                        do 'DescName:f:' -> xT; F[] -> xA
                        #);
          (if F.isNull then
              desc[] -> BetaEnvName -> name[]
           else
          (if addOriginId  then
              desc[] -> originId -> id[]
          if);
          L:
            (if F.label 
             // gram.descriptorForm
             // gram.doPart
             // gram.mainPart then
                F.xOrigin -> FO;
                (if FO.isNull then
                    (if common.switch[186] then
                        F.theFragmentForm -> FF[];
                        (FF.name).copy -> name[];
                        (if true
                         // 'tstenv' -> name.equalNCS
                         // 'betaenv' -> name.equalNCS then
                            (* 'DescName: tstenv' -> putline; *)
                            'tstenv' -> name[]
                            (* should be changed to BetaEnv' *)
                        if)
                     else
                        (if true
                         // common.targetMachineId = common.javabc then
                            'java/lang/Object'->name[];
                         // common.targetMachineId = common.dotnet then
                            'object'->name[];
                         else
                            'Unknown_platform.Object' -> name[];
                        if);
                    if)
                 else
                    (* F0 is a slot <<<SLOT xxx:...>> *)
                    (* FO -> desc; (* OBS! is this safe? NO???
                                    * We do this to have desc be a slot
                                    * in the else-part below
                                    *)
                    true -> isDescriptorForm;
                    FO.father -> F;
                    restart L;
                if)
             else
                (if F.label
                 // gram.patternDecl
                 // gram.virtualDecl
                 // gram.bindingDecl
                 // gram.finalDecl then
                    F -> getFirstNameDecl -> name[];
                    (id[],name[]) -> catIdAndName -> name[]
                 // gram.staticItem // gram.staticComponent then
                    F.father (* gram.simpleDecl *) 
                      -> getFirstNameDecl
                      -> name[];
                    (id[],name[]) -> catIdAndName -> name[]
                 else
                    (if true 
                     // isDescriptorForm then
                        (* 'descName:singularDescriptorForm: '->puttext;*)
                        FO.theSlotName -> slotName -> name[];(*
                        'slot'-> (FO.theSlotName).prepend -> name[] ;
                        common.nameManglingCh -> name.put*)
                     // desc.label = gram.unExpanded then
                        (* 'descName:unExpanded:' -> puttext;*)
                        desc.theSlotName -> slotName -> name[];(*
                        'slot'-> (desc.theSlotName).prepend -> name[];
                        common.nameManglingCh -> name.put*)
                     else
                        desc -> DS.innerDescs.getId ->name[]
                    if)
                if)
          if)if);
      if)if);
      (if 'object' -> name.equalNCS then
          (if common.switch[320] then
              'BetaObject' -> name
           else              
              (if true
               // common.targetMachineId = common.javabc then
                  'java/lang/Object'->name;
               // common.targetMachineId = common.dotnet then
                  'class [mscorlib]System.Object'->name; (*'/*4*/'->name.append;*)
               else
                  'Unknown_platform.Object' -> name;
              if);
          if)
      if);
      317->trace(# do 'DescName:found: ' -> xT; name[]->xT #);
   #)
