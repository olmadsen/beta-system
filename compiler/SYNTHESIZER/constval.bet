ORIGIN 'evlib';
LIB_ITEM 'betacodegen';
INCLUDE 'auxlib';
INCLUDE 'inlinNXitem';
INCLUDE 'computedval'
---mkConstVal:descriptor--
(# CV: ^ConstVal
do &Constval[]->CV[]->V[]; C->CV.C
#)
---EvalLib:attributes------
ConstVal: EvVal
  (# thisVal::<(# V: @ConstVal do C->V.C; V[]->thisV[] #);
     evId:: (# do 'CstVal:'->id[] #);
     display::< (#do 'CstV:'->xT; C->xI #);
     needExtraAreg:: (# do false -> value #);
     loadVal::< (#do this(ConstVal)[]->V[] #);
     loadVal2::< 
       (# dr: @mch.dataRegOperand
       do (if true (*not common.switch[129]*) then
              this(ConstVal)[]->V[] 
           else
              dr.alloc;
              (C[],dr[]) -> mch.ldCst;
              dr -> asComputedEvVal -> V[]
          if)
       #);
     pushVal::
        (# dr: @mch.dataRegOperand
        do dr.alloc;
           (C[],dr[]) -> mch.ldCst;
           dr -> asComputedEvVal -> V[]
       #);
     toDataRegA::< (#do (C[],mch.DataRegA[])->mch.ldCst #);
     toDataRegX::< (#do (C[],mch.DataRegX[])->mch.ldCst #);
     toDataRegY::< (#do (C[],mch.DataRegY[])->mch.ldCst #);
     toRangeReg::< (#do (C[],mch.DataRegB[])->mch.ldCst #);
     toDataReg::<(#do (C[],dReg[])->mch.ldCst #); 
     toPrimDest::<
       (# (* pNo -> C.toPrimDest, possible, but check firs getPrimReg in
           * super of this(toPrimDest)
           *)
       do pNo->C.toPrimDest
          (*(if primDest.isPrimRegOp then
              (C[],primDest[])->mch.ldCst 
           else
              (C[],primDest[],4) -> mch.stCst 
          if)*)
       #);
     evType::<(#do 1->type #);

     mkReal::< 
       (# T: ^text 
       do ''->T[]; C->T.putInt; '.0'->T.puttext; 
          ((T[],C)->mch.floatConst,sematt.realDesc[])
            -> mkFloatEvVal
            -> V[] 
       #);
     asgToSimpleEv::
       (#
       do (if stest then
              301->ctrace(#do 'cstVal:asgToSimpleEv:'->xH;
                           rBaseAdr.display->xT; xN;
                           rEv[] -> xA;
                           mch.dumpreg;
                        #);
          if);
          rEvAdr -> asgToAdr -> V[]
       #);
     asgToAdr::< 
       (#
       do (* we assume that C is a 32 bit constant*)
          (if rA.size = 8 then
              (0->mch.newCstOp,rA[],4) -> mch.stCst;
              4 -> rA.addOff -> rA[];
              4 -> rA.size
          if);
          (C[],rA[],rA.size)->mch.stCst; 
          rA.isNotObjRef -> rA.freeAdr; 
          this(ConstVal)[]->V[] 
       #);
     asgToRepAdr::<
       (#
       do (if stest then
              301->trace(#do 'cstVal:asgToRepAdr:'->xT; C -> xI #)
          if);
          (* WE don't know the size - 4 is assumed, but we will have
           * to check the repetition
           *)
          (elmDesc[],true,false(*FIXME boolRep*),repSize,1,rA[],false) 
            -> asgToNewRep
          (# 
          do (if switch182 then
                 (rEV[],rChain[],rA[]) -> asgToSingleElmArray(*asgToSingleElmBytecodeArray*)
                 (#
                 do AI.bAdr.localDesc[]
                      -> theGen.mkSignature 
                      -> AI.fieldType[];
                 #)
              else
                 NextElmAdr -> asgToAdr
             if)
          #);
          rA.freeAdr;
          this(ConstVal)[] -> V[]
       #);
     AsgToRepElm::
       (#
       do 301->trace(#
                    do 'asgToRepElm: ' -> display;
                       'size: ' -> xT; rA.size -> xI
                    #);
          (if rA.size = 8 then
              rA[] -> AsgToRealAdr -> V[]
           else
              rA[] -> AsgToAdr -> V[]
          if);
       #);
     asgToRefAdr::< (* NONE -> R[]/F## *)
       (# rA: ^mch.address; EV: @ASTindex
       do (if C <> 0 then
              (* This may be  
               *    T: (# exit 'q' #);
               *    R: ^text
               * do T -> R[]
               *)
              (# T: @ text
              do C -> T.put;
                 T -> mkTxtCstEvVal->V[]; true->V.sourceIsref;
                 (rAbase[],destEV[],rChain[],false) ->  V.asgToRefAdr->V[]
              #)
           else
              destEv.son->EV; 
              (rABase.copy,EV[],false,rChain[])->genAdr->rA[];
              (C[],rA[],rA.size)->mch.stCst; rA.freeAdr; 
              this(ConstVal)[]->V[]
          if)
       #);
     asgToRealAdr::<
       (# FL : ^mch.floatRegOp; T: ^text
       do ''->T[]; C->T.putInt; '.0'->T.puttext; 
          (T[],C)->mch.floatConst->FL[]; 
          rA[]->FL.store; rA.freeAdr;
          Fl.deAlloc; this(ConstVal)[]->V[]
       #);
     asgToItem::<
       (* C -> EV.N1 *)
       (# nScan: @ | scanNadr
       do (rDesc[],rA[],0,rChain[],true)->nScan; 
          '!constVal:asgToItem'->mch.comment;
          this(ConstVal)[]->nScan.AsgToNelm -> rAx[];
          nScan (* terminate *)
       #);
     asgVal2Rep:
       (# elmDesc,rEv: ^ASTindex; rChain: ^DH.superChain; 
          rA: ^mch.address;  noStore: @boolean;
          tA: ^mch.address;
          V: ^evVal
       enter(elmDesc[],rEV[],rChain[],rA[],noStore)
       do (* val -> aRep *)
          (*  stack = [... Val ] *)
          (elmDesc[],true,false,rA.size,1,rA[],noStore) -> asgToNewRep
          (#
          do (if switch182 then
                 (rEV[],rChain[],rA[]) -> asgToSingleElmArray
                 (#
                 do AI.bAdr.localDesc[]
                      -> theGen.mkSignature 
                      -> AI.fieldType[];
                 #)
              else
                 NextElmAdr -> asgToAdr -> V[]
             if)
          #);
       exit V[]
       #);     
     asgToMethod::
       (# desc: ^ASTindex; rA: ^mch.address
       do (if stest then
              301->trace(#
                        do 'asgToMethod:'->display;
                           'enterType[next]: ' -> xT;
                           next->xI; ':'->put; enterTypes[next] -> xI
          #)if);
          (if enterTypes[next]
           // 6 (* real /double *) then
              C[] -> mch.pushClong; 
              mch.int2float
           // 7 (* real32/float *) then
              C[] -> mch.pushClong; 
              mch.int2float;
              mch.real64toReal32 (* bad:-( we need int2real32 *)
           // 8 (* int64 *) then
              C[] -> mch.pushClong; 
              mch.int32toInt64
           // 12 (* repetition *) then
              baseAdr.copy -> rA[];
              (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
              301->trace(#do rElm[]->xA; xN; desc[]->xA; desc.size -> xI #);
              desc.size -> rA.size;
              desc[] -> rA.bAdr.localDesc[];
              (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep    
           else
              C[] -> mch.pushClong
          if);
          next +1 -> next 
       #);
     asgToExitArgs::
       (#
       do
          (sematt.integerDesc[],false) -> xTypes.add
       #);
     asgToNXoffSets::
       (# off: @integer; A: ^mch.address
       do NX.getNext -> off;
          off -> (rA.copy).addOff -> A[];
          NX.getSize-> A.size;
          (if stest then
              179->trace(#do 'cstVal:asgToNx:'->xT; off->xI; A.size->xI #)
          if);
          (C[],A[],A.size) -> mch.stCst; 
          A.freeAdr
       #);
     asgToInlineItem::
       (# inx: ^inlineNXitem
       do inlNX[]->inx[];
          C->inx.newConstToN;
          (*inx.eval->V[]*)
       #);
     asgToList::< (#do toListOne #);
     asgToDispatch::
       (#
       do (if stest then
              301 -> cTrace
              (#
              do 'simpleVal:asgToDispatch:'->xT; EV[]->xA
          #)if);
          (EV[],externalName[],desc[],extKind)
            -> GenCOMdispatch
          (#
          do (*(forward->CP.getEnterP,0,4,0) -> pushCpar*)
             this(ConstVal)[] -> PushDispatchPar
          #) -> V[]
       #);
     asgToCproc::<
       (# CP: @ExTernalCall
       do (if switch182 then
              (EV[],desc[],externalName[],extKind) -> theGen.callExternal
              (#
              do (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo) 
                   -> pushCpar
              #) -> V[]
           else
              (externalName[],Desc[],extKind,EV.son)->CP; (* init *)
              (CP.getEnterP,extKind,CP.getEnterP.size,CP.pascExtProcInfo) 
                -> pushCpar;
              CP.call;
              CP.getExitP->V[];
          if)
       #);
     asgToInLinePrimitive::<
       (# D: [1]@integer; dRes: @integer;
          W: @ComputedEvVal;
          dr: @mch.dataRegOperand;
       do dr.alloc; dr -> D[1]; (* mch.getData->D[1]; *)
          (C[],dr[] (*D[1]->mch.NewDataRegOp*))->mch.ldCst;
          (opCode,I1,I2,D)->gen.inLinePrimitive->dRes->W.dr;
          W[]->V[];
          (if dRes <> D[1] then D[1] -> dr; dr.deAlloc (* D[1]->mch.freeData*) if)
       #);
     asgToNewPrim::<
       (# EV1,op: @ASTindex; A: ^mch.address; opcode: @integer;
          evalAdr:
            (#
            do (baseAdr.copy,EV1[],false,rchain[])->genAdr->A[];
            #)
          
       do(if stest then
              301->trace
              (#do 'asgtoNewPrim: '->display; EV[] -> xA; xN;
                 'evalKind: ' -> xT; EV.evalKind -> xI; xN;
                 baseA.display-> xT;
              #)
          if);
          
          EV.son->EV1; EV1.son->EV1; EV1.brother->op;
          (if not switch182 then evalAdr if);
          (if op[]->sematt.primitiveToNumber->opCode
           // 5 (* getByte *) then 
	      (if EV.evalKind = sematt.repValEval then 
		  (toDataReg,A[],1,false)->primInxGet
                    (#
                    do (if switch182 then 
                           evalAdr;
                           this(asgToNewPrim).A[] -> rA[] (* ugly *)
                       if)
                    #)
                    ->V[]
	       else
                  (if switch182 then evalAdr if);
                  (A[],C,1,false)->primGet->V[]
              if)
           // 6 (* getShort *) then 
	      (if EV.evalKind = sematt.repValEval then 
	          (toDataReg,A[],2,false)->primInxGet
                    (#
                    do (if switch182 then 
                           evalAdr;
                           this(asgToNewPrim).A[] -> rA[] (* ugly *)
                       if)
                    #)
                    ->V[]
	       else 
                  (if switch182 then evalAdr if);
	          (A[],C*2,2,false)->primGet->V[]
              if)
           // 7 (* getSignedByte *) then
	      (if EV.evalKind = sematt.repValEval then 
		  (toDataReg,A[],1,true)->primInxGet->V[]
	       else 
                  (if switch182 then evalAdr if);
                  (A[],C,1,true)->primGet->V[] 
              if)
           // 8 (* getSignedShort *) then
	      (if EV.evalKind = sematt.repValEval then 
		  (toDataReg,A[],2,true)->primInxGet->V[]
               else
                  (if switch182 then evalAdr if);
		  (A[],C*2,2,true)->primGet->V[]
              if)
	   // 13 (* getLong *) then 
	      (if EV.evalKind = sematt.repValEval then 
		  (toDataReg,A[],4,true)->primInxGet->V[]
	       else (* // sematt.simpleEval  // realEval ...*)
                  (if switch182 then evalAdr if);
                  (A[],0,4,true)->primGet->V[]
              if)
	  if);
          A.freeAdr
       #);
     pushCpar::<
       (# V: ^evVal
       do (if type
           // common.byteXpar then C[]->mch.pushCByte
           // common.shortXpar then C[]->mch.pushCword
           // common.longXpar 
           // common.cStructXpar
           // common.varPtnCXpar  (* the rest only for NONE (C = 0) *)
           // common.varPtnPascalXpar
           // common.dataXpar
           // common.varPtnStdXpar
           // common.COMobjectXpar
           // common.holderXpar
           // common.wtextXpar then  
              C[] -> mch.pushClong
           // common.doubleXpar then 
              mkReal->V[]; (7,extKind,size,0)->V.pushCpar
           // common.int64Xpar then
              0 -> mch.NewCstOp -> mch.pushClong;
              C[] -> mch.pushClong
           else 
              'ConstVal:pushCpar:Illegal type'
                -> thisTranslate.systemException        
          if)
       #);
     unMinus::< (# W: @ConstVal do -C->W.C; W[]->res[] #);
     notExp::< (# W: @ConstVal do (C+1 ) mod 2 -> W.C; W[]->res[] #);
     cmp::< (#do C->lV.cstCmp->doCmp (*gCmp(#do C->lV.cstCmp #)*)#);
     cstCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rC[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rC[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     adrCmp::<
       (# dn: @mch.dataRegOperand;
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rA[],dn[],rA.size)->mch.gCmp; dn.deAlloc*)
          rA[]->op1[];dn[]->op2[];rA.size->size;true->deAllocOp2
       #);
     regCmp::<
       (# dn: @mch.dataRegOperand
       do dn.alloc; (C[],dn[])->mch.ldCst;
          (*(rReg[],dn[],4)->mch.gCmp; dn.deAlloc*)
          rReg[]->op1[];dn[]->op2[];4->size;true->deAllocOp2
       #);
     add::< (# do C->lV.cstAdd->res[] #);
     cstAdd::< (# W: @ConstVal do C+rN->W.C; W[]->V[] #);
     adrAdd::< 
       (# W: @ComputedEvVal
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
          (C[],W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     regAdd::<
       (# W: @computedEvVal 
       do rReg->W.dr.reUse; (C[],W.dr[],4)->mch.gAdd; W[]->V[]
       #);
     sub::<(#do C->lV.cstSub->res[] #);
     cstSub::< (# W: @ConstVal do C-rN->W.C; W[]->V[] #);
     asComputedEvVal:
       (# dr: @Mch.DataRegOperand; V: ^ evVal
       enter dr
       do (dr,false,false,false,sematt.integerDesc[])
            -> mkComputedEvVal2
            -> V[];
       exit V[]
       #);
     adrSub::<
       (# dr: @mch.dataRegOperand
       do dr.alloc;
          (C[],dr[])->mch.ldCst;
          rA[]->loadAdrOp(#do (op[],dr[],4)->mch.gSub#); 
          dr -> asComputedEvVal -> V[]
       #);
     regSub::< 
       (# W1: @ComputedEvVal
       do W1.dr.alloc; (C[],W1.dr[])->mch.ldCst;
          (rReg[],W1.dr[],4)->mch.gSub; W1[]->V[]
       #);
     times::< (#do C->lV.cstTimes->res[] #);
     adrTimes::<
       (# dr: @mch.dataRegOperand; W: @computedEvVal;
       do W.dr.alloc; (rA[],W.dr[],rA.size)->mch.ldVl;
          (* Datpete 22/7/94: optimization of known constants *)
          (W.dr[], C[], 4) -> cstMult;
          (* (C->mch.newCstOp,W.dr[],4)->mch.gMult; *)
          W[]->V[]
       #);
     cstTimes::< (# W: @ConstVal do rN*C->W.C; W[]->V[] #);
     regTimes::<
       (# W: @computedEvVal; 
       do rReg->W.dr.reUse; 
          (* Datpete 22/7/94: optimization of known constants *)
          (rReg[], C[], 4) -> cstMult;
          (* (C[],rReg[],4)->mch.gMult; *)
          W[]->V[]
       #);
     divMod::< (#do (C,isDiv)->lV.cstDivMod->res[] #);
     adrDivMod::<
       (#(* A div C *)
       do ddr.alloc; (C[],ddr.dNo2[])->mch.ldCst;
          (if rA.size//4 then (rA[],ddr[],isDiv)->mch.gDiv;
           else(* MC680x0 only accepts long for div*)
              (# dl: @mch.dataRegOperand
              do dl.alloc; (rA[],dl[],rA.size)->mch.ldVl;
                 (dl[],ddr[],isDiv)->mch.gDiv; dl.deAlloc
       #)if)#);
     cstDivMod::<
       (# W: @ConstVal;
          ddr: @mch.doubleDataRegOperand;
          dr: @mch.dataRegOperand;
       do (* kjm: fixed if rN is 0 *)
          (if rN=0 then
              ddr.alloc;
              dr.alloc;
              (C->mch.newCstOp,ddr.dNo2[])->mch.ldCst;
              (0->mch.newCstOp,dr[])->mch.ldCst;
              (dr[],ddr[],isDiv)->mch.gDiv;
              dr.dealloc;
           else
              (if isDiv then C div rN -> W.C else C mod rN -> W.C if);
          if);
          W[]->V[]
       #);
     regDivMod::<
       (# 
       do ddr.alloc; (C[],ddr.dNo2[])->mch.ldCst;
          (*rReg->ddr.dNo1.reUse;*)
          (rReg[],ddr[],isDiv)->mch.gDiv; (* C div rReg *)
       #);
     orr::< (#do C->lV.cstOr->res[] #);
     adrOr::< 
       (#do 
          (if C=1 then 1->mkConstVal->V[]
           else rA[]->mkSimpleVal->V[]
       if)#);
     cstOr::< 
       (#
       do (* bootstrap problem here: C or rN is not implemeted
           * by previous compier version
           *)
          (if C=1 then 1->mkConstVal->V[]
           else (if rN=1 then 1->mkConstVal->V[]
                 else 0->mkConstVal->V[]
       if)if)#); 
     regOr::<
       (#
       do (if C=1 then 1->mkConstVal->V[]
           else rReg->rReg.reUse;
              (rReg,false,false,false)->mkComputedEvVal->V[]
       if)#);
     andd::< (#do C->lV.cstAnd->res[] #);
     adrAnd::< 
       (#do 
          (if C=0 then 0->mkConstVal->V[]
           else rA[]->mkSimpleVal->V[]
       if)#);
     cstAnd::< 
       (#
       do (if C=0 then 0->mkConstVal->V[]
           else (if rN=0 then 0->mkConstVal->V[]
                 else 1->mkConstVal->V[]
       if)if)#);
     regAnd::< 
       (#
       do (if C=0 then 0->mkConstVal->V[]
           else 
              rReg->rReg.reUse;
              (rReg,false,false,false)->mkComputedEvVal->V[]
       if)#);
     
     C: @mch.cstOperand
  #);


