ORIGIN '../CHECKER/sematt'
---semattlib:attributes---
xGetNXlength: integerValue
  (# desc: ^ASTindex;
     isEnter: @boolean;
     chain: ^BV.superChain
  enter(desc[],isEnter,chain[])
  do (*desc->BV.newSingle -> chain[];*)
     (* (desc[],isEnter,chain[]) -> getGeneralDescLength -> value;*)
     178->trace 
     (#
     do (if isEnter then 'SetNOffSets:\n'->xT else 'SetXoffSets:\n'->xT if);
        desc[]->xA; (*dump *)
     #)
  #);
getNXlength:
  (# 
     getGeneralDescLength: integerValue
       (# NXscan: @NXscanner;
          
          GetSuperNXlength: @ integerValue
            (* perhaps tricky - see docheck:GetPreDesc *)
            (# preDesc: @ASTindex; 
            do (if pref.label = gram.prefix then
                   chain[] -> BV.ENC -> chain1[];
                   (*(pref.son,chain1[]) -> GetTheDesc -> (preDesc,chain1[]);*)

                   pref.son -> sematt.descrip -> preDesc;
                   
                   chain[] -> BV.PRE -> chain1[];
                   
                   (preDesc[],isN,chain1[]) -> getGeneralDescLength -> value
               if)
            #);
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          desc,EV: ^ASTindex; E1: @ASTindex;
          isN: @boolean;
          chain,chain1: ^BV.superChain;
          PL,superLength: @integer;
          gNXl: ^ |getNXlength; more: @boolean
       enter(desc[],isN,chain[])
       do 179->trace(#do 'GeneralDesc:'->xT; desc[] -> xA; (*chain.print*) #);
          (if desc->sematt.descKind
           // sematt.standardKind // sematt.constKind then
              1 -> value;
              sematt.integerDesc[] -> elmDesc[];
              SUSPEND
           else
              desc[]
                -> DescSonsRef
                -> (pref[],mainP[],att[],entP[],doP[],exitP[]);
              GetSuperNXlength -> superLength;
              &|getNXlength[] -> gNXl[];
              (if isN then
                  (if entP.label <> gram.empty then
                      entP.son -> E1;
                      (E1[],true,desc[],chain[]) -> gNXl -> more;
                      L: (if more then
                             gNXl.elmDesc[] -> elmDesc[];
                             gNXL.thisEV[] -> thisEV[];
                             SUSPEND;
                             gNXL -> more;
                             restart L
                         if)                        
                  if)
               else
                  (if exitP.label <> gram.empty then
                      exitP.son -> E1;
                      (E1[],false,desc[],chain[]) -> gNXl -> more;
                      L: (if more then
                             gNXl.elmDesc[] -> elmDesc[];
                             gNXl.thisEV[] -> thisEV[];
                             SUSPEND;
                             gNXL -> more;
                             restart L
                         if)                        
              if)if);
              superLength + value -> value
          if)
       #);

     EV,encDesc: ^ASTindex; EVx: @ASTindex; isN: @boolean;
     xAllocForObj: integerValue
       (# E: ^ASTindex;
          E1,desc: @ASTindex;  MN: @integer; isV: @integer;
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          chain1: ^BV.superChain
       enter E[]
       do 179->trace(#do 'AllocForObj:'-> xT; E[]->xA #);
          E.son -> E1;
          (if E1.label = gram.remotePrimitive then
              1 -> value
           else
              (*(encDesc,E1) -> ActualDesc -> (desc,MN);*)
              (chain[],E1) -> BV.theDesc -> (desc,MN,chain1[],isV);
              (if (E1->sematt.SimpleOrRep)
               // gram.dynamicItem // gram.dynamicComponent
               // gram.variablePattern
               // gram.staticItem //gram.staticComponent then 
                  179->trace(#do 'IsRep:'-> xT; E1[]-> xA #);
                  1 -> value; 
                  xxx -> elmDesc[]; 
                  SUSPEND
               else
                  L:
                    (if (desc -> sematt.descKind) 
                     // sematt.standardKind // sematt.constKind then
                        1 -> value;
                        desc[] -> elmDesc[]; 
                        SUSPEND                        
                     else
                        (desc[],isN,chain1[]) 
                          -> getGeneralDescLength
                          -> value
          if)if)if)
       #);
     chain: ^BV.superChain;
     thisEV,
     elmDesc: ^ASTindex;
     value: @integer;
     more: @boolean;
     xxx: (#exit sematt.integerDesc[] #);
     mn,kind: @integer; LC: ^BV.superChain; 
  enter(EV[],isN,encDesc[],chain[])
  do 179->trace(#do 'AllocNXtmp:'-> xT; EV[]-> xA; (*chain.print*) #);
     true -> more;
     EV[] -> thisEV[];
     L:
       (if EV.label 
        // gram.assignmentEvaluation then
           (* allocate simple value or list of simple values??*)
           EV.son -> EV;
           (if not isN then EV.brother -> EV if);
           (*(EVx[],true,encDesc[],chain[]) -> AllocNXtmp*)
           179->trace(#do 'AllocNXtmp2:'-> xT; EV[]-> xA;#);           
           restart L
        // gram.insertedItem 
        // gram.objectDenotation 
        // gram.dynamicItemGeneration 
        // gram.dynamicComponentGeneration then
           (* where do we store the list of offsets?
            * the following call will override in object EV
            * and not in the object with the enter/exit element.
            * We probably have to enumerate whenever being used
            *)
           EV[] -> xAllocForObj -> value
        // gram.computedObjectEvaluation then 
           'AllocNXtmp:ComputedEv'->putline
        // gram.objectReference 
        // gram.structureReference then
           1 -> value;
           &ASTindex[] -> elmDesc[];
           311 -> trace(#
                       do 'nxlength:EV:'->xT; EV[] -> xA
                       #);
           (chain[],(EV.sonRef).son)->BV.theDesc->(elmDesc,mn,LC[],kind);
           311 -> trace(#
                       do 'nxlength:elmDesc:'->xT; elmDesc[] -> xA
                       #);
           SUSPEND
        // gram.evalList then 
           EV.son -> EVx; 
           EVx -> scanList
           (# E: ^ASTindex ; V: @integer; 
              gNXl: ^| getNXlength; more: @boolean
           do &ASTindex[] -> E[]; currentNode-> E;
              &|getNXlength[] -> gNXl[];
              (E[],isN,encDesc[],chain[]) -> gNXl -> more;
              L:
                (if more then
                    gNXl.elmDesc[] -> elmDesc[];
                    gNXL.thisEV[] -> thisEV[];
                    SUSPEND;
                    gNXL->more;
                    restart L
                if);
              value + V -> value;
              179->trace(#do 'List:'->xT; (*chain.print*) #)
           #)
        // gram.integerConst // gram.noneExp then 
           (* skip if outer level - no attribute space reserved.
            * Check this for other categories as well
            *)
           1 -> value;
           sematt.integerDesc[] -> elmDesc[];
           SUSPEND
        // gram.textConst then
           1 -> value;
           sematt.charDesc[] -> elmDesc[];
           SUSPEND;
        // gram.repetitionSlice then
           1 -> value;
           XXX -> elmDesc[];
           SUSPEND
        // gram.notExp (* perhaps just alloc a boolean *)
        // gram.unaryMinusExp // gram.unaryPlusExp 
        // gram.unaryPrimitiveExp 
        // gram.primitive then
           1 -> value;
           sematt.integerDesc[] -> elmDesc[];
           SUSPEND
        else
           (if (EV.label -> EvalClass) = EvalClass.binOp then
               1 -> value;
               sematt.integerDesc[] -> elmDesc[];
               SUSPEND               
            else 
               'NXtmp NOT found' -> putline
           if)
       if);
     false -> more;
  exit more
  #)

