ORIGIN '../CHECKER/sematt'
---semattlib:attributes---
xGetNXlength: integerValue
  (# desc: ^ASTindex;
     isEnter: @boolean;
     chain: ^BV.superChain
  enter(desc[],isEnter,chain[])
  do (*desc->BV.newSingle -> chain[];*)
     (* (desc[],isEnter,chain[]) -> getGeneralDescLength -> value;*)
     178->trace 
     (#
     do (if isEnter then 'SetNOffSets:\n'->xT else 'SetXoffSets:\n'->xT if);
        desc[]->xA; (*dump *)
     #)
  #);
getNXlength:
  (# 
     getGeneralDescLength: integerValue
       (# NXscan: @NXscanner;
          
          GetSuperNXlength: @ integerValue
            (* perhaps tricky - see docheck:GetPreDesc *)
            (# preDesc: @ASTindex; 
            do (if pref.label = gram.prefix then
                   chain[] -> BV.ENC -> chain1[];
                   (*(pref.son,chain1[]) -> GetTheDesc -> (preDesc,chain1[]);*)

                   pref.son -> sematt.descrip -> preDesc;
                   
                   chain[] -> BV.PRE -> chain1[];
                   
                   (preDesc[],isN,chain1[]) -> getGeneralDescLength -> value
               if)
            #);
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          desc,EV: ^ASTindex; E1: @ASTindex;
          isN: @boolean;
          chain,chain1: ^BV.superChain;
          superLength: @integer;
          gNXl: ^ |getNXlength; more: @boolean
       enter(desc[],isN,chain[])
       do 179->trace(#
                    do 'GeneralDesc:'->xT; desc[] -> xA;
                       'isN: ' -> xT; isN -> xB;
                       (*chain.print*)
                    #);
          (if desc->sematt.descKind
           // sematt.standardKind // sematt.constKind then
              1 -> value;
              sematt.integerDesc[] -> elmDesc[];
              SUSPEND
           else
              desc[]
                -> DescSonsRef
                -> (pref[],mainP[],att[],entP[],doP[],exitP[]);
              GetSuperNXlength -> superLength;
              &|getNXlength[] -> gNXl[];
              (if isN then
                  (if entP.label <> gram.empty then
                      entP.son -> E1;
                      (E1[],true,chain[]) -> gNXl -> more;
                      L: (if more then
                             gNXl.elmDesc[] -> elmDesc[];
                             gNXL.thisEV[] -> thisEV[];
                             gNXL.thisChain[] -> thisChain[];
                             gNXL.isRep -> isRep;
                             gNXL.isStruc -> isStruc;
                             SUSPEND;
                             false -> isRep -> isStruc;
                             gNXL -> more;
                             restart L
                         if)   
                  if)
               else
                  (if exitP.label <> gram.empty then
                      exitP.son -> E1;
                      179->trace(#
                                do 'gdlA:'->xT; E1[] -> xA;
                                   'isN: ' -> xT; isN -> xB;
                                #);
                      (E1[],false,chain[]) -> gNXl -> more;
                      L: (if more then
                             179->trace(#
                                       do 'gdl:'->xT; gNXl.thisEV[] ->xA;
                                          gNXl.elmDesc[] -> xAF;
                                          'isN: ' -> xT; isN -> xB;
                                       #);
                             gNXl.elmDesc[] -> elmDesc[];
                             gNXl.thisEV[] -> thisEV[];
                             gNXL.thisChain[] -> thisChain[];
                             gNXL.isRep -> isRep;
                             gNXL.isStruc -> isStruc;
                             SUSPEND;
                             false -> isRep -> isStruc;
                             gNXL -> more;
                             restart L
                         if);
                      179->trace(#do 'gdl:end:'->xT; 'isN: ' -> xT; isN -> xB;#);
              if)if);
              superLength + value -> value
          if)
       #);

     EV: ^ASTindex; isN: @boolean;
     xAllocForObj: integerValue
       (# E: ^ASTindex;
          E1,desc: @ASTindex;  
          pref,mainP,att,entP,doP,exitP: ^ASTindex;
          chain1: ^BV.superChain
       enter E[]
       do 179->trace(#do 'AllocForObj:'->xT; E[]->xA; 'isN:'->xT; isN->xB #);
          E.son -> E1;
          (if E1.label = gram.remotePrimitive then
              1 -> value
           else
              (chain[],E1) -> BV.theDesc -> (desc,chain1[]);
              (if (E1->sematt.SimpleOrRep)
               // gram.dynamicItem // gram.dynamicComponent
               // gram.variablePattern
               // gram.staticItem //gram.staticComponent then 
                  179->trace(#do 'IsRep:'-> xT; E1[]-> xA #);
                  1 -> value; 
                  &ASTindex[] -> elmDesc[];
                  desc -> elmDesc;
                  true -> isRep;
                  SUSPEND;
                  false -> isRep;
               else
                  L:
                    (if (desc -> sematt.descKind) 
                     // sematt.standardKind // sematt.constKind then
                        1 -> value;
                        desc[] -> elmDesc[];
                        179->trace(#
                                  do 'AllocForObj:simple:'->xT;
                                     elmDesc[] -> xAF;
                                     'isN: ' -> xT; isN -> xB;
                                  #);
                        SUSPEND;
                        179->trace(#
                                  do 'AllocForObj:simpleCont'->xT;
                                     'isN: ' -> xT; isN -> xB;
                                  #)
                     else
                        (desc[],isN,chain1[]) 
                          -> getGeneralDescLength
                          -> value
          if)if)if)
       #);
     thisChain,chain,chain1: ^BV.superChain;
     thisEV,
     elmDesc: ^ASTindex;
     value: @integer;
     isRep,isNone,isStruc,more: @boolean;
     LC: ^BV.superChain; 
     EVa: @ASTindex
  enter(EV[],isN,chain[])
  do 179->trace(#
               do 'AllocNXtmp:'-> xT; EV[]-> xA;
                  'isN: ' -> xT; isN -> xB;
                  EV.label -> xI
                  (*chain.print*) 
               #);
     (* default values that may be overwritten *)
     true -> more;
     EV -> EVa;
     EV[] -> thisEV[];
     chain[] -> thisChain[];
     L:
       (if EVa.label 
        // gram.assignmentEvaluation then
           (* allocate simple value or list of simple values??*)
           EVa.son -> EVa;
           (if not isN then EVa.brother -> EVa if);
           restart L
        // gram.insertedItem 
        // gram.objectDenotation 
        // gram.dynamicItemGeneration 
        // gram.dynamicComponentGeneration then
           (* where do we store the list of offsets?
            * the following call will override in object EVa
            * and not in the object with the enter/exit element.
            * We probably have to enumerate whenever being used
            *)
           EVa[] -> xAllocForObj -> value;
           179->trace(#do 'after:AllocForObj:'->xT;'isN: ' -> xT; isN -> xB; #)
        // gram.computedObjectEvaluation then 
           'AllocNXtmp:ComputedEv'->putline
        // gram.objectReference then
           1 -> value;
           &ASTindex[] -> elmDesc[];
           301 -> trace(#
                       do 'nxlength:EVa:'->xT; EVa[] -> xA;
                       #);
           (chain[],(EVa.sonRef).son)->BV.theDesc->(elmDesc,LC[]);
           
           301 -> trace(#
                       do 'nxlength:elmDesc:'->xT; elmDesc[] -> xA
                       #);
           SUSPEND
        // gram.structureReference then
           1 -> value;
           &ASTindex[] -> elmDesc[];
           301 -> trace(#
                       do 'nxlength:EVa:strucRef:'->xT; EVa[] -> xA;
                       #);
           (chain[],EVa.son) -> BV.theDesc -> (elmDesc,LC[]);
           
           301 -> trace(#
                       do 'nxlength:StrucRef:elmDesc:'->xT; elmDesc[] -> xA
                       #);
           true -> isStruc;
           SUSPEND
        // gram.evalList then 
           (# EVx: @ASTindex
           do 179->trace(#
                     do 'List:'->xT; EVa[] -> xA;'isN: ' -> xT; isN -> xB;
                     #);
              EVa.son -> EVx; 
              EVx -> scanList
              (# E: ^ASTindex ; V: @integer; 
                 gNXl: ^| getNXlength; more: @boolean
              do &ASTindex[] -> E[]; currentNode-> E;
                 179->trace(#
                           do 'listElm:A:'->xT; E[] -> xA;'isN: ' -> xT; isN -> xB;
                           #);
                 &|getNXlength[] -> gNXl[];
                 (E[],isN,chain[]) -> gNXl -> more;
                 L:
                   (if more then
                       179->trace(#
                                 do 'listElm:B:'->xT; 
                                    gNXL.thisEV[] -> xA;
                                    gNXl.elmDesc[] -> xAF;
                                    'isN: ' -> xT; isN -> xB;
                                 #);
                       gNXl.elmDesc[] -> elmDesc[];
                       gNXL.thisEV[] -> thisEV[];
                       gNXL.isRep -> isRep;
                       gNXL.isStruc -> isStruc;
                       SUSPEND;
                       false -> isRep -> isStruc;
                       gNXL->more;
                       restart L
                   if);
                 value + V -> value;
                 179->trace(#do 'EndList:'->xT;
                              'isN: ' -> xT; isN -> xB; (*chain.print*) 
                           #)
           #)#)
        // gram.integerConst then 
           (* skip if outer level - no attribute space reserved.
            * Check this for other categories as well
            *)
           1 -> value;
           sematt.integerDesc[] -> elmDesc[];
           SUSPEND
        // gram.noneExp then 
           1 -> value;
           sematt.superObject[] -> elmDesc[];
           true -> isNone;
           SUSPEND;
           false -> isNone;
        // gram.textConst then
           1 -> value;
           sematt.charDesc[] -> elmDesc[];
           SUSPEND;
        // gram.repetitionSlice then
           (* EVa = <AttDen> '[' <eval> ':' <eval> ']' *)
           1 -> value;
           &ASTindex[] -> elmDesc[];
           (chain[],EVa.son) -> BV.theDesc -> (elmDesc,chain1[]);
           true -> isRep;
           SUSPEND;
           false -> isRep
        // gram.notExp (* perhaps just alloc a boolean *)
        // gram.unaryMinusExp // gram.unaryPlusExp 
        // gram.unaryPrimitiveExp 
        // gram.primitive then
           1 -> value;
           sematt.integerDesc[] -> elmDesc[];
           SUSPEND
        else
           (if (EVa.label -> EvalClass) = EvalClass.binOp then
               1 -> value;
               sematt.integerDesc[] -> elmDesc[];
               SUSPEND               
            else 
               'NXtmp NOT found' -> putline
           if)
       if);
     false -> more;
     179->trace(#do 'end:getNXlength:'->xT;'isN: ' -> xT; isN -> xB; #);
  exit more
  #)

