ORIGIN 'synthlib'; 
LIB_ITEM 'betacodegen';
INCLUDE 'genlib';
include 'genlib_bytecode';
INCLUDE 'evlib';
INCLUDE 'signature';
INCLUDE 'inlinNXitem';
INCLUDE 'asgtoitem';
INCLUDE 'nxlength';
INCLUDE '../GENERATOR/registerContent';
INCLUDE '~beta/basiclib/formatio';
INCLUDE 'signature'
------evalLib:attributes-------
findReceiver:
  (# EV,rD,mD: ^ASTindex; (* EV = (remote <R> <foo>) 
                           * rD = possible receiver desc
                           * mD = methodDesc 
                           *)
     D: @ASTindex;
     R: ^ASTindex;
     descKind: @integer
  enter(EV[],rD[],mD[])
  do (if EV.label 
      // gram.remote then
         EV.sonRef -> R[];
         (thisDesc[],R[]) 
           -> GetActualDesc 
           -> (D,descKind);
         301->trace(#
                 do 'findReceiver:' -> xT; R[] -> xA; xN;
                    D[] -> xA; xN; rD[] -> xA
                 #);
         (if R.label = gram.thisObject then
             (* is this always correct?*)
             D[] ->rD[]
          else
             (if not (D->rD.equal) then
                 D -> sematt.descChain
                 (* scan super patterns *)
                 (#
                 do (if desc->rD.equal then
                        (if not common.switch[188] then
                            'Receiver: Got it'->putline;
                        if);
                        D[] -> rD[]
                    if)
                 #)
         if)if)
      // gram.nameApl then
         (* added to handle call from gram.virtual case *)
         EV.dclRef -> D;
         D.sort -> D;
         (if D.label
          // gram.virtualDecl
          // gram.bindingDecl
          // gram.finalDecl then
             (*1->trace(#do 'findReceiver: ' -> xT; D[] -> xA #);*)
             D[] -> sematt.EncDescOfNode -> R[]
          else
             (*1->trace(#
                     do 'findReceiver:case not covered:  ' -> xT; D[] -> xA
                     #);*)
             D[] -> sematt.EncDescOfNode -> R[]
         if);
         (if not (R->rD.equal) then
             rD -> sematt.descChain
             (#
             do (if desc->R.equal then
                   (* 1->trace(#
                            do 'finReceiver:gotIt: ' -> xT;
                               rD[] -> xA
                            #);*)
         if)#)if);
         (* so basically we just check consistency of enter arg rD
          * which should be the receiver - so we may skip this
          * call
          *)
      // gram.thisObject then
         '\nfindReceiver:ThisObject'->puttext
     if)
  exit rD[]
  #);
newBCstrucObject:
  (# EV: ^ASTindex;
     chain1: ^DH.superChain;
     (* exit *)
     W: ^evVal;                    
     
     ES,desc: @ASTindex; 
     receiverDesc: ^ASTindex;
     MN: @integer;
     EVchain: ^DH.superChain;
     isVirtual: @integer;
     OA: ^mch.address;
     N: ^text;
     sig: @theGen.signature
  enter(EV[],chain1[]) 
  do (* handle externalClass
      *
      *)
     313->trace(#
               do 'newBCstrucObject:'->xT;
                  100 -> switchon;
                  EV[] -> xA;
                  100 -> switchoff
               #);
     EV.son -> ES;
     ES -> sematt.descrip -> desc;         
     (baseAdr.copy,thisDesc[],ES[],chain1[])
       -> genOrgAdrToOrgReg
       -> OA[];
     (if desc.label <> gram.objectDescriptor then 
         (* virtual ... *)
         (* see newBCobject *)
         ES -> sematt.getName -> ES; ES.gettext -> N[];
         '$struc' -> N.append; 
         desc[] -> sematt.encDescOfNode -> receiverDesc[];
         ((receiverDesc[],true) -> descName,receiverDesc[]) 
           -> sig.addReceiver;
         N[] -> sig.addMethod;
         sig.noEnter;
         theGen.StructureSignatureId->theGen.specialSignature->sig.setExit;
         (sig.asText-> mch.newTextOp,'M',false,false) -> mch.gJsr;  
      else
         313->trace(#do 'newBCstrucObject:actualDesc:'->xT; desc[] -> xA #);
         (chain1[],ES) -> DH.theDescForm -> (desc,MN,EVchain[],isVirtual);
         (if isJava then (* FIXME *)
             ('AlloS',(desc[],true)->descName) -> mch.callAlloPrim
          else
             ('AlloS',desc[]->theGen.mkSignature) -> mch.callAlloPrim
         if);
     if);  
     (mch.callO,true,ES[],chain1[])->mkComputedRefEvVal->W[];
  exit W[]
  #);
newBCobject:
  (# (* enter *)
     EV: ^ASTindex;            
     chain1: ^DH.superChain;
     (* exit *)
     W: ^evVal;                    
     
     ES,desc,sort,VN: @ASTindex; 
     T: ^text; 
     local: @boolean;
     OA: ^mch.address;

     MN: @integer;
     EVchain: ^DH.superChain;
     isVirtual: @integer;
     orgName: ^text;
     constructorDesc: ^ASTindex; 
     hasConstructor:< booleanValue
  enter(EV[],chain1[]) 
  do 313->trace(#do'newBCobject:' -> xT; EV[] -> xA; #);
     'newBCobject1'->mch.comment;
     EV.son -> ES;
     (if ES.label = gram.objectDescriptor then
         (ES,0,3,null) -> DS.push;
         ES -> desc;         
      else
         ES -> sematt.descrip -> desc;         
     if);
     (if desc.label 
      // gram.objectDescriptor then
         (chain1[],ES) -> DH.theDescForm -> (desc,MN,EVchain[],isVirtual);
         313->trace(#do 'newBCobject:actualDesc:'->xT; desc[] -> xA #);
         desc[] -> theGen.newInstance
         (# RC: ^DH.superChain;
            isDefaultConstructor: @boolean 
         do (if hasOrigin then
                '!newBCobject:genOrg1'->mch.comment;
                (baseAdr.copy,thisDesc[],ES[],chain1[])
                  -> genOrgAdrToOrgReg
                  -> OA[];
                '!newBCobject:genOrg2'->mch.comment;
                (* this part often changes ...
                 * We may have 
                 * 1.   R.foo
                 *      R is loaded in remote part of GenOrgAdrToOrgReg
                 * 2.   foo
                 *      ???
                 * 3.   &(# ... #)[]
                 *      Origin loaded in genOrgAdrToOrgReg
                 *)
                (if ES.label 
                 // gram.nameApl then
                    '!newBCobject:genOrg3'->mch.comment;
                    true -> OA.isRef;
                    (*(OA[],none,4) -> mch.ldVl*)
                 // gram.remote then 
                    (* FIX remote case in genAdr: has a loadRef *)
                    (*OA.toOriginReg;*)
                if);
                '!newBCobject:genOrg4'->mch.comment;
            if);
            (if hasConstructor then 
                (if not common.switch[188] then
                    '\nHasCons'->putline;
                if);
                '' -> consSig.originName[]; (* ??? *)
                (desc[],thisSuperChain) 
                  -> sematt.findConstructor 
                  -> (constructorDesc[],isDefaultConstructor,RC[]);
                (if constructorDesc[] = none then
                    '\nOBS! evbody:newBCobject:did not find constructor'
                      ->putline;
                if);
                (constructorDesc[],isDefaultConstructor,RC[]) 
                  -> consSig.addConstructorDesc;
                (if not common.switch[188] then
                    consSig.asText -> putline;
                if);
                INNER newBCobject; (* push arguments to constructor *)
            if);
         #)
      // gram.variablePattern then
         (# A: ^ mch.address; T: @text;
         do (for i:2 repeat mch.nop for);
            (baseAdr.copy,ES[],false,chain1[])->genAdr->A[];
            'Structure' -> theGen.text2signature -> A.fieldType[];
            (A[],&mch.AdrRegOperand[]) -> mch.ldval;
            'AlloSI' -> mch.callPrim;
            (chain1[],ES) -> DH.theDescForm -> (desc,MN,EVchain[],isVirtual);
            desc[] -> theGen.mkSignature -> mch.checkCast 
         #)
      else
         (* virtual ... *)
         desc.son ->sematt.singleName->VN;
         313->trace(#
                   do 'newBCobject:classPtn: '->xT; VN[] -> xA; xN; 
                      desc[]->xA
                   #);
         (baseAdr.copy,thisDesc[],ES[],chain1[])->genOrgAdrToOrgReg->OA[];
         (VN[],OA[],ES[]) -> theGen.CallClassPtnMethod
     if);
     (mch.callO,false,ES[],chain1[])->mkComputedRefEvVal->W[];
     'newBCobject2'->mch.comment
  exit W[]
  #);
     
methodCall: evVal
  (# evId:: (#do 'MethodCall:'->id[] #);
     display:: (# do sig.asText -> xT #);
     loadVal:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal' -> xT #);
          (*this(methodCall)[] -> V[]; (* ???*) 
          thisExitVal -> V[]
       #);
     evType:: 
       (#
       do (if not sig.isMultiValExit and (sig.XXsig.isRef) then
              2 -> type
           else 
              (if exitValIsReal then 
                  3 -> type 
               else
                  1 -> type 
              if)
          if)
       #);
     type::
       (#
       do (if (sig[]<>none) and (sig.XXsig[] <> none) then
              sig.XXsig.theDesc -> desc[] 
           else
              '\nmethodCall:type:sig.XXsig is none'->putline
          if)
       #);
     toDataReg:: 
       (# 
       do 301->trace(#do 'methodCall:toDataReg' -> xT #);
       #);
     loadVal2:: 
       (# 
       do 301->trace(#do 'methodCall:loadVal2' -> xT #);
          thisExitVal -> V[]
       #);
     pushVal::
       (# dr: @mch.dataRegOperand
       do 301->trace(#do 'methodCall:pushVal' -> xT #);
          '!methodCall:pushVal' -> mch.comment;
          (* (dr,false,false,false) -> mkComputedEvVal -> V[];*)
          (* the result of the methodcall is on the stack *)
          (* this(methodCall)[] -> V[]*)
          thisExitVal -> V[]
       #);
     mkReal::
       (#
       do &mch.floatRegOp[] -> mkFloatEvVal -> V[]
       #);
     loadFloat :: (# do &mch.floatRegOp[] -> res[] #);
     getRefEval::
       (#
       do this(methodCall)[] -> V[]
       #);
     theAdr:: 
       (# A: @mch.RegAdr; D: ^ASTindex
       do (if sig.aplSig[] <> none then
              sig.XXsig.theDesc -> D[];
              (if not (D -> (sig.aplSig.theDesc).equal) then
                  '\generate cast' -> putline;
                  'cast' -> mch.comment;
                  sig.aplSig.asText -> mch.checkCast
          if)if);
          A[] -> AV[]
       #);
     asgToAdr::
       (# dr: @mch.dataRegOperand
       do (* we assume a value on top of the stack *)
          dr.alloc;
          301->trace(#do 'asgToAdr: '->display; rA.display->xT #);
          (dr[],rA[]) -> mch.stVal; (* no handling of size *)
          (dr,false,false,false) -> mkComputedEvVal -> V[];
       #);
     asgToRefAdr::
       (# EV: @ASTindex
       do 301 -> trace(#
                      do 'asgToRefAdr: '->display;
                         100 -> switchon;
                         sig.exitVal[] -> xA;
                         100 -> switchOff
                      #);
          sig.exitVal[]->sematt.evCase
          (# objRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[]
               #);
             dynItemRef::
               (#
               do (0,false,EV.sonRef,chain[]) 
                    -> mkComputedRefEvVal
                    -> V[]
               #);
             txtCst::
               (# T: ^text 
               do EV.gettext->T[]; T->mkTxtCstEvVal->V[]
               #)
          #);
          (rAbase[],destEV[],rChain[]) -> V.asgToRefAdr;
          (0,false,destEv[],rChain[])->mkComputedRefEvVal->V[];
       #);
     asgToRealAdr::
       (#
       do rA[] -> (&mch.floatRegOp[] -> mkFloatEvVal).asgToRealAdr -> V[]
       #);
     asgToRepAdr::
       (#
       do 301 -> trace(#
                      do 'methodCall:asgToRepAdr: '->xT;
                         sig.exitVal[] -> xA
                      #);
          (if sig.isMultiValExit then
              1->trace(#
                      do 'asgToRepAdr:'->display;
                         'method returning a list to be assigned to '
                         'a repetition is NOT implemented'
                         -> xT
                      #)
           else
              (if sig.XXsig.elmType = 12 (* array *) then
                  (* method has returned an array: store it in rA *)
                  (&mch.dataRegOperand[],rA[]) -> mch.stVal
               else
                  (* method has returned a value (simple or ref)
                   * that should be coerced into a repetition
                   *)
                  (rA[],rEV[],rChain[]) 
                    -> ((0,false,false,false)->mkComputedEvVal).asgToRepAdr 
                    -> V[]
          if)if)
       #);
     asgToRepElm::
       (#
       do 301->trace(#do 'asgToRepElm:'->display #);
          (rA[],rEv[],rChain[])
            -> ((0,false,false,false)->mkComputedEvVal).asgToRepElm
            -> V[]
       #);
     asgToItem::
       (#
       do '\nMethodCall:asgToItem' -> putline
          
       #);
     asgVal2Rep: (* duplicate  form computedval *)
       (# elmDesc,rEv: ^ASTindex; rChain: ^DH.superChain; 
          rA: ^mch.address;  noStore: @boolean;
          tA: ^mch.address;
          V: ^evVal
       enter(elmDesc[],rEV[],rChain[],rA[],noStore)
       do (* val -> aRep *)
          (*  stack = [... Val ] *)
          (if switch182 then
              sematt.integerDesc[] 
                -> theGen.mkSignature 
                -> theGen.allocAndStoreTmp 
                -> tA[]
          if);
          (elmDesc[],true,false,rA.size,1,rA[],noStore) -> asgToNewRep
          (#
          do (if switch182 then
                 (rEV[],rChain[],rA[]) -> asgToSingleElmArray
                 (#
                 do AI.bAdr.localDesc[]
                      -> theGen.mkSignature 
                      -> AI.fieldType[];
                    (tA[],mch.dataTop[]) -> mch.ldVal
                 #)
              else
                 NextElmAdr -> asgToAdr -> V[]
             if)
          #);
       exit V[]
       #);     

     asgToMethod::
       (* Assign m1 to m2 as in the following forsm
        *    m1 -> m2
        * or
        *    (e1,e2,...,m1,...en) -> m2
        * where m1 = this(methodCall)
        * and m2 is described by arguments to asgToMethod;
        * Push return value(s) from m1 as arguments to m2.
        * Note: m1 determines how many values to push;
        * m2 cannot be used to determine this, since
        * there may be other arguments to m2 than m1 as shown
        * by the 2. fomr above
        *)
       (# A: ^mch.address; aS: @mch.RegAdr; srcField: @text; xNo: @integer;
          gNXl: ^|sematt.getNXlength; 
          rA: ^mch.address; desc: ^ASTindex;
          checkText2ExternalString:
            (# d: ^ASTindex;
            enter d[]
            do (if (d[]<>none) then
                   (if true
                    // (d->sematt.textDesc.equal) 
                         and (enterTypes[next] = 13 (* external *)) then
                       'BetaText2ExternalString' -> mch.callprim 
                    // ((d->sematt.descKind) = sematt.externalClassKind)
                       and (enterTypes[next] = 14 (* textDesc *) ) then
                       'ExternalString2BetaText' -> mch.callprim
                    // (d->sematt.textDesc.equal) 
                       and  (enterTypes[next] = 12 (* array *)) then
                       'text2char' -> mch.comment;
                       'BetaText2BetaCharArray' -> mch.callPrim
                    else
                       (if (enterTypes[next] = 12 (* array *)) then
                           baseAdr.copy -> rA[];
                           (rElm[],rChain[],rA[]) -> getElmDesc -> desc[];
                           301->trace(#
                                     do rElm[]->xA; xN; 
                                        desc[]->xA; desc.size -> xI 
                                     #);
                           desc.size -> rA.size;
                           desc[] -> rA.bAdr.localDesc[];
                           (desc[],rElm[],rChain[],rA[],true) -> asgVal2Rep
                       if)
               if)if)
            #)
            
       do 301->trace(#
                    do 'MethodCall:asgToMethod: ' -> xT;
                       sig.asText -> xT; ' ' -> put;
                       noOfArgs -> xI; ':' -> put;
                       (for i: (noOfArgs,entertypes.range) -> min repeat
                            entertypes[i] -> xI; ' ' -> put;
                       for);
                    #);
          (if sig.isMultiValExit then
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              'exit_' -> srcField;
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
                (*-> aS.descName[]; (* elim descName *)
              true -> aS.isField;
              sig.scanExit
              (# desc: ^ASTindex
              do (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 xNo + 1 
                   -> xNo   
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 current.theDesc 
                   -> desc[] 
                   -> theGen.mkSignature 
                   -> aS.fieldType[];
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 desc[] -> checkText2ExternalString;
                 next + 1 -> next;                
              #)
           else
              sig.XXsig.theDesc -> checkText2ExternalString;
              next+1 -> next;              
          if)
       #);
     asgToExitArgs::
       (* Assign
        *    this(methodCall) -> (exit_exitNo, exit_exitNo+1, ...)
        * rDesc    : the receiver object with fields exit_exitNo, ...
        * exitNo   : next exit-field to be assigned
        * originAdr: address of origin of ...
        * rChain   : superChain 
        *)
       (# A: ^mch.address; aS,aD: @mch.RegAdr; 
          srcField,destField: @text; xNo: @integer;
          xScan: @ | scanXadr; notFirst,more: @boolean;
          rSig: @thegen.signature;
       do (*'MethodCall:asgToExitArgs:'->puttext;*)
          (if sig.isMultiValExit then
              (* this(methodCall) returns a list of values *)
              sig.XXsig.asText -> theGen.AllocAndStoreTmp -> A[];
              (* we need to get the right values instead of
               * gen.thisRegAdr and thisSuperChain
               * from the place where methodCall is instantiated
               *)
              (sig.thisMethodDesc[],gen.thisRegAdr,0(*??nOff*),chain[]) 
                -> xScan -> more;
              'exit_' -> destField;
              'exit_' -> srcField;
              (sig.thisMethodDesc[] -> theGen.fieldSignature).asText 
                -> aS.receiverType[];
              (rDesc[] -> theGen.fieldSignature).asText 
                -> aD.receiverType[];
              (*'scanExit:'->puttext;*)
              sig.scanExit
              (#
              do (if notFirst then
                     (originAdr[],none) -> mch.ldVal
                 if);
                 true -> notFirst;
                 (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                 true -> aS.isField;
                 true -> aD.isField;
                 xNo + 1 
                   -> xNo 
                   -> (srcField.copy).putint 
                   -> aS.fieldName[];
                 current.theDesc 
                   -> theGen.mkSignature 
                   -> aS.fieldType[]
                   -> aD.fieldType[](* -> puttext;*);
                 (aS[],&mch.dataRegOperand[]) -> mch.ldVal;
                 exitNo + 1 
                   -> exitNo
                   -> (destField.copy).putint 
                   -> aD.fieldName[];
                 current.theDesc -> xTypes.append;
                 (&mch.dataRegOperand[],aD[]) -> mch.stVal;
              #);
          if)
       #);
     asgToList::
       (* Assign
        *    M -> (E1,E2,...En)
        * where M  = this(methodCall)
        * and   EV = (E1,E2,...,En)
        *)
       (# lEV: @ExitMultiVal; exitNo: @integer;
          nextEVlistElm: @|
            (# E: @ASTindex
            do EV -> scanList
               (#
               do currentNode -> E;
                  SUSPEND
               #)
            exit E[]
            #);
          E: ^ASTindex
               
       do 301->trace(#do 'asgToList:'->display #);
          
          sig.XXsig.asText 
            -> lEV.class[]
            -> theGen.AllocAndStoreTmp 
            -> lEV.tA[];
          (* here we should probably use sig.scanExit
           * to get the correct type of the exit-elements;
           * we should use gNXL on each element Ei in EV
           * to enumerate the enter-elements of Ei;
           * this should fix the type problem in tstnxoff
           * - which does not run with sun-java but is ok
           * with gij
           *)
          sig.scanExit
          (# more: @boolean; 
             xNo: @integer;
             gNXL: ^| sematt.getNXlength
          do (if (xNo+1 -> xNo) = (exitNo+1) then
                 nextEVListElm -> E[];
                 &|sematt.getNXlength[] -> gNXL[];
                 (E[],true,thisDesc[],rChain[]) -> gNXL -> more; 
                 L: (if more then 
                        exitNo+1 -> exitNo -> lEV;
                        (*1->trace(# F: @ASTindex
                                do 'exitNo: ' -> xT; exitNo->putInt; 
                                   ' left:'->puttext;
                                   current.asText -> puttext;
                                   ' right:'->puttext;
                                   current.theDesc->xA; xN;
                                   (current.theDesc).father -> F;
                                   F[]->xA
                                #);*)
                        current.theDesc -> lEV.elmDesc[];
                        (BA[],lEV[],E[],false,rChain[]) 
                          -> AssignValToEval 
                          -> V[];
                        C: (if (gNXL -> more) then
                               exitNo+1 -> exitNo;
                               restart C
                           if)
                    if);
             if)
          #)
       #);
     asgToCproc::
       (#
       do '\nOBS! MethodCall:asgToCproc:notImplemented'->putline;
          this(methodCall)[] -> V[]; (* just a hack - doesn't work *)
       #);
     pushCpar::
       (# D: ^ASTindex
       do sig.XXsig.theDesc -> D[];
          (if (D -> sematt.textDesc.equal) 
              and (type = common.externalStringXpar) then
              'BetaText2ExternalString' -> mch.callprim 
          if);
       #);
     asgToInlinePrimitive::
       (#
       do 301->trace(#
                    do 'asgToInlinePirmitive: ' ->display;
                    #);
          (OpCode,I1,I2) ->  (asComputedVal).asgToInlinePrimitive -> V[]
          (*(0,false,false,false) -> mkComputedEvVal -> V[]*)
       #);
     unMinus::<
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNeg;
          (dr,false,false,false) -> mkComputedEvVal -> res[];          
       #);
     notExp::< 
       (# dr: @mch.dataRegOperand
       do (dr[],4)->mch.gNot;
          (dr,false,false,false) -> mkComputedEvVal -> res[]; 
       #);
     cmpBoolAndJmp::<
       (#
       do (if not common.switch[188] then
              '\nOBS! methodCall:cmpBoolAndJmp' -> putline;
          if)
       #);
     cmp::< 
       (# dr: @mch.dataRegOperand
       do dr->lV.regCmp->doCmp; 
       #);
     adrCmp::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:AdrCmp'->putline 
          if);
          (evType=2) -> isRef
       #);
     cstCmp::< 
       (* this(methodCall) CMP rC *)
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstCmp'->putline
          if);
          rC[] -> op1[]; &mch.dataRegOperand[]->op2[]; 
          (evType=2) -> isRef
          (* op2 is top of stack (methodCall), so
           * showuld we do a swap of reverse CMP-operator?
           *)          
       #);
     regCmp::<(* this(methodCall) COMP rReg *)
       (#
       do 'methodCall:regCmp' -> mch.comment;
          &mch.dataRegOperand[] -> op1[];
          rreg[] -> op2[];
          false -> deAllocOp1 -> deAllocOp2;
          (evType=2) -> isRef
       #);
     
     add::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:add'->putline 
          if);
          lv[] -> (asComputedVal).add -> res[]
       #);
               
     adrAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAdd'->putline
          if);
          rA[] -> (asComputedVal).adrAdd -> V[]
       #);
     cstAdd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAdd'->putline;
          if);
          rN -> (asComputedVal).cstAdd -> V[]
       #);
     regAdd::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regAdd'->putline 
          if);
          rReg -> (asComputedVal).regAdd -> V[]
       #); 
     sub::< 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:sub'->putline 
          if);
          lv[] -> (asComputedVal).sub -> res[]
       #);
               
     adrSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrSub'->putline
          if);
          rA[] -> (asComputedVal).adrSub -> V[]
       #);
     cstSub::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstSub'->putline;
          if);
          rN -> (asComputedVal).cstSub -> V[]
       #);
     regSub::<
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regSub'->putline 
          if);
          rReg -> (asComputedVal).regSub -> V[]
       #); 
          
     times::
       (#
       do 301->trace(#
                    do 'times:' -> display
                    #);
          lv[] -> (asComputedVal).times -> res[]          
       #);
     adrTimes::
       (#
       do 301->trace(#
                    do 'adrTimes:' -> display
                    #);
          rA[] -> (asComputedVal).adrTimes -> V[]          
       #);
     cstTimes::
       (#
       do 301->trace(#
                    do 'cstTimes:' -> display
                    #);
          rN -> (asComputedVal).cstTimes -> V[]          
       #);
     regTimes::
       (#
       do 301->trace(#
                    do 'regTimes:' -> display
                    #);
          rReg -> (asComputedVal).regTimes -> V[]          
       #);
     divMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:divMod:' -> putline
          if);
          (lV[],isDiv) -> (asComputedVal).divMod -> res[]
       #);
     adrDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:adrDivMod:' -> putline 
          if);
          (rA[],isDiv) -> (asComputedVal).adrDivMod -> W[];
       #);
     cstDivMod:: 
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstDivMod:' -> putline;
          if);
          (rN,isDiv) -> (asComputedVal).cstDivMod -> V[]
       #);
     regDivMod:: 
       (# 
       do (if not common.switch[188] then
                 '\nOBS! methodCall:regDivMod:' -> putline;
          if);
          (rReg,isDiv) -> (asComputedVal).regDivMod -> W[]
       #);
     orr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:orr'->putline 
       if)#);
     adrOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrOr'->putline
          if)
       #);
     cstOr::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstOr'->putline; 
          if);
          this(methodCall)[] -> V[] 
       #);
     regOr::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regOr'->putline
       if)#);
     andd::< 
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:andd'->putline
       if)#);
     adrAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:adrAnd'->putline
          if)
       #);
     cstAnd::<
       (# 
       do (if not common.switch[188] then
              '\nOBS! methodCall:cstAnd'->putline;
          if);
          this(methodCall)[] -> V[] 
       #);
     regAnd::<
       (# do (if not common.switch[188] then
                 '\nOBS! methodCall:regAnd'->putline
       if)#); 
     rMult:: (# do   this(methodCall)[] -> res[] #);
     asComputedVal:
       (# EH: @evalHandler
       exit (0,false,false,false)->EH.mkComputedEvVal
       #);
     exitValIsReal: booleanValue
       (#
       do (sig.XXsig.elmType = 6) (* real *) -> value
       #);
     thisExitVal:
       (# V: ^evVal
       do (if exitValIsReal then
              mkReal -> V[]
           else
              (if sig.XXsig.isRef then
                  this(methodCall)[] -> V[]; (* not logical, but
                                              * we don't have thisEV
                                              * in the next one below
                                              *)
                  (*(0,false,EV[],chain[]) -> mkComputedRefEvVal -> V[]*)
               else
                  (0,evType=2,false,false) -> mkComputedEvVal -> V[]
          if) if)
       exit V[]
       #); 

     (* class: ^text*)
     sig: ^theGen.signature;
     chain: ^DH.superChain
  enter(sig[],chain[])
  exit this(methodCall)[]
  #);
CoerceTypes:
  (# lv,rv: ^EvVal; binType: @integer
  enter(lv[],rv[])
  do (if stest then
         301 ->cTrace(#
                     do 'Coerce: ' -> xH;
                        'lEv='->xT; lv.display; xN;
                        'rEv='->xT; rv.display
                     #)
     if);
     (if lv.evType->binType
      // 1 // 2 (*simple or ref*) then 
         CoerceType2:
           (if rv.evType
            // 3 (*real*) then lv.mkReal -> lv[]; 3 ->binType 
            // -1 (* object *) then
               rv.loadVal -> rv[];
               restart CoerceType2
           if)
      // 3 (*real*) then rv.mkReal->rv[];
         (if rV[] = none then '\ncoerce:mkReal rV is none'->putline if)
      // 4 (*struc*) then 
         CoerceType2:
           (if rv.evType
            // 1 then (*NONE*) 
               (if switch182 then
                   2 -> binType (* reference: should also be made 
                                 * if not bytecode?
                                 *)
                else
                   1 -> binType 
               if)
            // -1 (* object *) then
               rv.loadVal -> rv[];
               restart CoerceType2
           if)
      // -1 (* object *) then 
         lv.loadVal -> lv[];
         restart CoerceTypes
      else 1 -> binType;
         cError(#do 'Coerce: left-op illegal evType'->xT; (*EV[]->A*) #)
     if);
     301->cTrace(#
                do 'Coerce:exit:binType:'->xT; binType->xI; xN;
                   lv.display; xN; 
                   rv.display 
                #);
  exit(lv[],rv[],binType)
  #);
putValAt:
  (# lDr,rDr: ^mch.dataregOperand; rEv: ^ASTindex; size: @integer;
     lv,rv: ^evVal;  ar: @mch.RegAdr;
     EH: @evalHandler;
  enter(lv[],rEV[],size)
  do (baseadr.copy,rEv[],false,ThisSuperChain)->EH.ExpEval->rv[];
     (*NOTE: baseAdr.copy because operations like addOff kas a side-effect
      * on an address and a baseadr MUST not be modified. addOff, etc., 
      * should NOT have a side effect
      *)
     lv.loadVal2->lv[]; lv.toDataReg->lDr[];
     rv.loadVal2->rv[]; rv.toDataReg->rDr[];
     ar.reg.alloc; (rDr[],ar.reg[])->mch.cpReg; (*ar.mkIndirect;*)
     (if size
      //1 then (lDr[],ar[])->mch.stByte
      //2 then (lDr[],ar[])->mch.stHalf
      //4 then (lDr[],ar[])->mch.stVal
     if);
     rDr.deAlloc; ar.reg.deAlloc; (*and clear *)(*false->ar.ind;*) ar.reg[]->mch.gClr
  exit lDr[]
  #);
getValAt:
  (# lDr: ^ mch.dataRegOperand; size: @integer; signed: @boolean;
     (*aR: @mch.adrRegOperand; *) aR: @mch.regAdr
  enter(lDr[],size,signed)
  do ar.reg.alloc; (lDr[],ar.reg[])->mch.cpReg; (*ar.mkIndirect;*)
     signed -> ar.signed;
     (ar[],lDr[],size)->mch.ldVl;
     (* (if signed then (ar[],lDr[],size)->mch.ldSignedVl
      * else (ar[],lDr[],size)->mch.ldVl
      * if);
      *)
     ar.reg[]->mch.gClr;
     ar.reg.deAlloc
  #);
mkByteCodeCall: 
  (* incredibly ugly - FIXME *)
  (# EV: @ASTindex;
     OA: ^mch.address; 
     descId,class: ^text;
     descNo: @integer; local: @boolean;
     VN,receiver,method,finalMethod: @ASTindex;
     receiverDesc: ^ASTindex;
     W: ^evVal;
     sigTxt: ^text;
     sig: @theGen.Signature;
     descKind: @integer;
     isStatic,isSingular,isFinal,isRemote
     ,isVarPtn
     ,hasArguments       (* true : if arguments to EV: A -> EV 
                          * false: if no arguments: ;EV;
                          *)
     ,hasExit: @boolean; (* true : if a the return value is used
                          * false: if not; then a possible return
                          *        value should be popped
                          *)
     theThisDesc: @ASTindex; (* aliasing:-(*)
     chain: ^DH.superChain;
     A: ^mch.address
  enter(EV,hasArguments,hasExit,chain[])
  do EV.son -> VN;
     '!mkByteCodeCall:'->mch.comment;
     301->trace(# 
               do 'mkBytecodeCall: ' -> xT; EV[] -> xA; VN[] -> xA;
                  EV.sonRef -> xA
               #);
     thisDesc -> theThisDesc;
     (if VN.label = gram.objectDescriptor then
         (* make sure that innerdesc.getID is defined *)
         (VN,common.itemKind,2,null)->DS.push;
     if);
     (EV.sonRef,chain[],true) -> sig.setMethodDesc; 
     &ASTindex[] -> receiverDesc[]; 
     301->trace(# do 'mkBytecodeCall:label:'->xT;
                  VN.label -> xI
               #);
     (if VN.label 
      // gram.remote then
         (# md: @ASTindex; mdo: ^ASTindex
         do (* VN = R.foo *) 
            VN.son -> receiver;
            receiver.brother -> method;
            (if receiver.label = gram.thisObject then
               (* receiver.son -> receiver;*)
                301->trace(#do
                             'mkByteCodecall.this(foo).m:receiver: '->xT;
                             receiver[] -> xA
                          #);

             else
                (* OBS receiver is NOT used anymore *)
                receiver -> sematt.getName -> receiver; 
                (* receiver = R, method = foo *)  
                (if false then
                    receiver.descRef -> receiverDesc;
                    301->trace(#
                              do 'mkBytecodecall:remote:X'->xT; 
                                 EV[] -> xA
                              #);
                    (thisDesc[],receiver[]) 
                      -> GetActualDesc 
                      -> (receiverDesc,descKind);
                if);
                (* NOTE! below is an alternative - and correct - method
                 * for computing the desc of the receiver; we just use
                 * the origin of the method desc. In most cases this is the
                 * same as above, but for virtual methods bound to global
                 * patterns, this is not the same; the above code should
                 * be removed
                 *)
            if);
            (* EV = R.foo 
             * NOTE: EV is reference or similar, and then
             *       EV.sonRef = (remote <R> <foo> )
             *)
            301->trace(#
                      do 'mkBytecodecall:remote:'->xT; 
                         EV[] -> xA
                      #);
            (thisDesc[],EV.sonRef) 
              -> GetActualDesc 
              -> (md,descKind);
            (* Problem with
             *   T: (# foo: (# ... #) #)
             *   TT: T(# #);
             *   R: ^TT
             *   R.foo
             * method:  (# ... #) i.e. desc of foo
             * receiver: origin(method) = T
             * it should be TT
             *   T: (# V:< A #);
             *   TT: T(# V:: AA #);
             *   TTT: TT (# #)
             *   S1: ^TT;
             *   S2: ^TTT
             *   S1.V;  - is reciever origin of AA or the most specific
             *   S2.V   - subpattern of origin of AA? 
             *            then it is complicated
             *)
            md[] -> sematt.descOrigin -> mdo[];
            301->trace(#
                    do 'mkByteCall:remote:mdo:'->xH; mdo[] -> xA; xN;
                       md[] -> xA
                    #);
            (EV.sonRef,mdo[],md[]) -> findReceiver -> mdo[];
            mdo -> receiverDesc;
            true -> isRemote;

            301 -> trace(# 
                        do 'mkByteCodeCall:remote:2: ' -> xH;
                           'method: ' -> xT; md[] -> xA; xN;
                           'receiver: '->xT; receiverDesc[] -> xA;
                        #)
         #)
      // gram.nameApl then
         (* VN = foo 
          * means: originN....origin2.origin1.foo
          * N >= 0
          *)
         VN -> method;
         testLibLevel: (* is this a pattern at the outermost
                        * lib level*)
           (# org: @ASTindex
           do sig.thisMethodDesc.origin -> org;
              (* dont work if virtual?*)
              (if org.label
               // gram.attributesForm then
                  301->trace(#
                          do'Pattern: ' -> xT;
                             VN[] -> xA;
                             ' is at the outermost lib level' -> putline
                            #);
                  'invoke static ' -> mch.comment;
                  true -> isStatic;
               else
                  (* to find originN, go origin meth.N times *)
                  thisDesc -> receiverDesc;
                  (for i: method.on repeat
                       receiverDesc[] -> sematt.descOrigin -> receiverDesc[]
                  for);
                  (if false then
                      (* ok for calling V declared as V:: T
                       * not ok for     V declared as V:< T
                       *)
                  (# md: @AStindex; mdo: ^AStindex
                  do (thisDesc[],EV.sonRef) 
                       -> GetActualDesc 
                       -> (md,descKind);
                     md[] -> sematt.descOrigin -> mdo[];
                     mdo -> receiverDesc;                  
                  #)if)
              if);
           #)
      // gram.objectDescriptor then
        301->trace(#
                   do 'objectdescriptor: ' -> xT;
                      VN[] -> xA;
                   #);
         VN -> method; (* NOTE: VN IS AN OBJECTDESCRIPTOR *)
         method -> receiverDesc;
         (* Here we need to find the right origin of the method *)
         (if true then
             receiverDesc[] -> sematt.descOrigin -> receiverDesc[];
             (if receiverDesc.label 
              // gram.descriptorForm (*then
                 receiverdesc.xorigin -> receiverdesc;*)
              // gram.doPart then
                 receiverdesc.xorigin -> receiverdesc;
                 receiverdesc.slotOrigin -> receiverdesc;
             if)
          else
             receiverDesc.origin -> receiverDesc;
         if);
         (* (receiverDesc[],screen[],500) -> thePP;*)
         true -> isSingular;
         (*(VN,common.itemKind,2,null)->DS.push;*)
         301->trace(# do 'mkBytecodeCall3: VN:' -> xT; VN[] -> xA #);
      // gram.unExpanded then
         301->trace(#
                   do 'MkByteCodeCall:DescriptorSlot: ' -> xT; VN[] -> xA 
                   #);
         VN[] -> sematt.enclosingDesc -> receiverDesc[];
                      
         receiverDesc[] -> theGen.descLocation -> sig.location[];
         301->trace(#
                   do 'mkByteCodeCall:unExpanded:receiverLocation: "' -> xT;
                      (if sig.location[] = none then 
                          'none' -> xT
                       else 
                          sig.location[] -> xT
                      if);
                      '"' -> put
                   #);
         VN -> method;
         (VN,common.itemKind,3,VN) -> DS.push;
         true -> isSingular (* hack *)
      // gram.computedRemote then
         (# MN,isVirt: @integer; xchain: ^DH.superChain;
            remEv,N,ref,refDesc: ^ASTindex;
         (* (E).method 
          * DOES NOT WORK
          *)
         do VN.son -> receiver;
            receiver.brother -> method;
            L: receiver->scanList(#do currentNode->receiver; leave L #);
            (if true then
                301->trace(#
                          do 'mkByteCodeCallX: ' -> xT;
                             VN[] -> xA
                          #);
                (VN[],DH[],chain[]) 
                  -> sematt.chkComputedEval 
                  -> (remEv[],N[],ref[],receiverDesc[],xchain[]);
                301->trace(#
                          do 'mkByteCodeCallY: ' -> xT;
                             receiverDesc[] -> xA
                          #);
                
             else
                (chain[],(receiver.sonRef).son)  
                  -> DH.theDescForm 
                  -> (receiverDesc,MN,xchain[],isVirt);
            if)
         #)
      else
         '\n**** insert is NOT remote or nameApl'->putline
     if);
     (if not isStatic then
         ('G',receiverDesc[]) -> mkEntryPoint -> (class[],local);
         301->trace(#
                   do 'mkByteCodeCall:receiver: ' -> xT; class[] -> xT; xN;
                      receiverDesc[] -> xA
                   #);
         (class[],receiverDesc[]) -> sig.addReceiver;
     if);
     L:
     (if not isSingular then
         method.dclRef -> finalMethod;
         finalMethod.sort -> finalMethod;
         301 -> trace(#
                     do 'mkBytecodeCall:method.dclRef: ' -> xT;
                        finalMethod[] -> xA
                     #);

         (if finalMethod.label = gram.finalDecl then
             true -> isFinal;
             method.dclRef -> finalMethod;
             (if not isRemote then
                 (# md: @AStindex; mdo: ^AStindex
                 do (thisDesc[],EV.sonRef) 
                      -> GetActualDesc 
                      -> (md,descKind);
                    md[] -> sematt.descOrigin -> mdo[];
                    mdo -> receiverDesc;                  
                    ((receiverDesc[],true) -> descName,receiverDesc[]) 
                      -> sig.addReceiver
         #)if)if);         
         method.descRef -> method;
         301 -> trace(#
                     do 'mkBytecodeCall:method.descref: ' -> xT;
                        method[] -> xA
                     #);
         LL: 
           (if method.label 
            // gram.objectDescriptor 
            // gram.unExpanded then
               method -> receiverDesc
            // gram.finalDecl then (** ??? **)'FINAL'->putline;
            // gram.bindingDecl then

               method.son -> method;
               L:
                 method -> scanList
               (# do currentNode -> method; leave L #);
               method.virtDcl -> method;
               method.sort -> method;
               restart LL
               
            // gram.virtualDecl then
               method.son -> method;
               method.brother -> method; (* assume desc here *)
               false -> isStatic; (* V:< T never be in an attributes form *)
               (* perhaps we should explicitly set the receiver? *)
               (if (EV.sonRef).label = gram.nameApl then
                   (* are we sure the other cases are covered? *)
                   (*1->trace(#
                           do 'mkByteCodeCall:virtual: ' -> xT; EV[] -> xA; 
                              ' on:'->xT; (EV.sonRef).on -> xI; xN;
                              thisDesc[] -> xA
                    #);*)
                   thisDesc -> receiverDesc;
                   (for i: (EV.sonRef).on repeat 
                        receiverDesc[] -> sematt.DescOrigin -> receiverDesc[]
                   for);
                   (EV.sonRef,receiverDesc[],none) 
                     -> findReceiver -> receiverDesc[];
                   ((receiverDesc[],true)->descName,receiverDesc[]) 
                     -> sig.addReceiver;
               if)
            // gram.variablePattern then
               (* R: (# F: ##T
                *    do ... F
                * receiverDesc: R
                * methodName  : F
                * methodDesc  : T
                *)
               301->trace(#
                         do 'mkByteCodeCall:varPtn: ' -> xT;
                            EV[] -> xA;
                         #);
               true -> isVarPtn;
               false -> isStatic;
               method[] -> sematt.EncDescOfNode -> receiverDesc[];
               ((receiverDesc[],true)->descName,receiverDesc[]) 
                 -> sig.addReceiver;
               sig.thisMethodDesc -> method;
               301->trace(#
                         do 'mkByteCodeCall:varPtn:X: ' -> xH;
                            'receiver: '->xT; receiverDesc[] -> xA; xN;
                            'methodName: ' -> xT; VN.gettext -> xT; xN;
                            'methodDesc: ' -> xT; method[]->xA
                         #);
           if);
         301 -> trace(# 
                     do 'call2:receiver:'->xH;
                        receiverDesc[] -> xA; xN; 
                        'method: '->xT; method[] -> xA; 
                     #);
2         
     if);

     (if isStatic then
         ((method[],true) -> descName,method[]) -> sig.addReceiver;
         sig.markStatic
     if);
     (* set the name of the method *)
     (if isVarPtn then
         VN.gettext -> sig.addMethod;
      else
         (method[],false) -> descName -> sig.addMethod;
     if);
     (* the following should be generalised? *)
     (if method.isSlot then
         sig.noEnter
      else
         method[] -> sig.addEnter
     if);
     
     (if method.isSlot then
         sig.setVoidXSig
      else
         (# p,mp,att,n,doP,exitP,EV: ^ASTindex; S: ^text
         do sig.thisMethodDesc[] (* descriptor for method *)
              -> sematt.descSonsRef
              -> (p[],mp[],att[],n[],doP[],exitP[]);
        
            (if exitP[] <> none then
                exitP[] -> sig.addExit
             else
                sig.setVoidXSig
            if)
     #)if);
     sig.asText -> class[];
     301 ->trace(#do 'class: ' -> xT;  class[] -> xT #);
     (if not hasArguments 
         and (((sig.NNsig.top > 0) and not isStatic)
              or ((sig.NNsig.top > 1) and isStatic)) then
         (* is receiverDesc the right originDesc here?
          * is it ok with topDesc = none
          *)
         (# xD: @AStindex; ba: ^mch.address;
            oldReturnSaved: @boolean
         do thisDesc->xD;
            theThisDesc -> thisDesc;
            baseAdr.copy -> ba[];
            theGen.returnSaved -> oldReturnSaved;            
            (* instaed of this clumsy save of global state,
             * we should make a new instance of theGen
             *)
            301 ->trace(#
                      do 'xnx1:'->xT; baseAdr.bAdr.localDesc[] -> xA; xN;
                         baseadr.display->xT; xN;
                         thisDesc[] -> xA
                      #);
            
            ('inline',sig.thisMethodDesc[],false,false,receiverDesc[],none(*?*)
            ,true,false,true)
              -> theGen.genPtnMethod
            (# 
            do xD -> thisDesc;
               (baseAdr.copy,theThisDesc[],VN[],EHchain[])
                 -> genOrgAdrToOrgReg
                 -> OA[];
               xD -> thisDesc;
               ba[] -> baseAdr[];
            #);
            xD -> thisDesc;
            ba[] -> baseAdr[];
            301 ->trace(#
                      do 'xnx2:'->xT; baseAdr.bAdr.localDesc[] -> xA; xN;
                         baseadr.display->xT; xN;
                         thisDesc[] -> xA
                      #);
            (thisDesc[],false) -> theGen.initPtnGen;
            oldReturnSaved -> theGen.returnSaved; (* is set to false
                                                   * in initPtnGen
                                                   *)
         #)
      else
         (baseAdr.copy,theThisDesc[],VN[],EHchain[])
           -> genOrgAdrToOrgReg
           -> OA[];
         INNER;         
         (class[]->mch.newTextOp,'M',local,isStatic)->mch.gJsr;  
       (*  (if sig.XXsig.castNeeded then

         if)*)
     if);
     (if not hasExit and (sig.XXsig.elmType <> 10 (*void*)) then
         (if sig.XXsig.elmType = 6 (* realo/double *) then
             true -> mch.popStack
          else
             mch.popStack
     if)if);
     (sig[],sig.thisChain[]) -> methodCall -> W[]
  exit W[]
  #)
----- EvalBody: descriptor ---- 
(# V: ^evVal;
do (if stest then
       302->cTrace(#
                  do 'EvalBody: '->xT; Eval[]->xA;
                     mch.dumpreg; (*EHchain[]->printChain*)
                  #)
   if);
   Eval[]->Sematt.evCase
   (# (* simple, realEv and repetition should not appear *)
      itemEv::<
        (# 
        do (if switch181 then
               (baseAdr[],EV[],false,EHchain[])->doItem->V[] 
            else
               (baseAdr.copy,EV[],false,EHchain[])->doItem->V[] 
           if)
        #);
      compEv::<
        (#
        do (if switch181 then
               (baseAdr[],EV[],false,EHchain[])->doComp->V[] 
            else
               (baseAdr.copy,EV[],false,EHchain[])->doComp->V[] 
           if)
        #);
      sysEv::< (#do 'Simple System Evaluation'->notImpl#);
      insert::<
        (# callRegOnStack: @boolean; OA: ^mch.address;
           p,mp,att,n,doP,x: ^ASTindex;
           EVx: @ASTindex;
           chain: ^DH.superChain;
           D: @ASTindex; MN: @integer; isV: @integer
        do (if desc.label = gram.objectDescriptor then
               (if desc[]->sematt.inlineDO then
                   'InlineDO'->mch.comment;
                   pushThis;
                   EV.son->EVx;
                   (baseAdr.copy,thisDesc[],EVx[],EHchain[])
                     -> genOrgAdr
                     -> OA[];
                   (OA[],mch.thisRegOp[])->mch.gLea;

                   desc[]->semAtt.descSonsRef->(p[],mp[],att[],n[],doP[],x[]);
                   (* genDo should probably get OA as its baseAdr? NO?
                    * GenDo evaluates starting from gen.thisReg, but it
                    * should get isOrigin set to true;
                    * The global ThisDesc should be stacked and temporarily
                    * be replaced by desc and popped afterwards;
                    * EHchain[] should also be fixed to reflect the
                    * situation
                    *)
                   (0,doP[],desc->DH.newSingle,true,false,none,none)
                     -> &theGen.genDo;
                   popThis;
                   leave insert
           if)if);
           (if switch181 then
               (baseAdr[],EV[],false,EHchain[],false) -> doGenItem -> V[] 
            else
               (if switch182 then
                   (EV,false,false,EHchain[]) -> mkByteCodeCall -> V[]                    
                else
                   (baseAdr.copy,EV[],false,EHchain[],false)->doGenItem->V[] 
           if)if)
        #);
      computedObj::< (#do 'Single Computed Obj'->notImpl #);
      dynItem::<
        (#
        do (if switch181 then
               (baseAdr[],EV[],false,EHchain[],true) -> doGenItem -> V[] 
            else
               (baseAdr.copy,EV[],false,EHchain[],true) -> doGenItem -> V[] 
           if)
        #);
      dynComp::< 
        (#
        do (if switch181 then
               (baseAdr[],EV[],false,EHchain[],true) 
                 -> doGenComp
                 -> V[] 
            else
               (baseAdr.copy,EV[],false,EHchain[],true) 
                 -> doGenComp
                 -> V[] 
           if)
           #);
      repOp::<(# do 'Single RepOp has no meaning'->bugstream.putline #);
      cProcDesc::<
        (# CP: @ExternalCall; V: ^evVal
        do (callId,desc[],extKind,EV.son)->CP; CP.call; CP.getExitP->V[]
           (* necessary to get possible exit result to deallocate
            * possible call stack area, at least necessary for SPARC
            *)
        #);
      externalVirtual::
        (# CP: @ExternalCall; V: ^evVal
        do (*301->cTrace(#do 'Calling external virtual: '->xT; callId[]->xT #);*)
           (':VDT:',desc[],sematt.virtExt->extKind,EV.son)->CP; 
           CP.call; 
           CP.getExitP->V[]
        #);
      primitive::<
        (# PC: @primitiveCall 
        do EV->SemAtt.ParsePrimitive 
           (# ExternalOp::<
                (#
                do (if not OpTxt.empty then (0,OpTxt[])->PC; PC.call if)
                #);
              InLineOp::<
                (#do (*(OpCode,I1,I2)->V.asgToInLinePrimitive->V[]*)
                   'SingleInline'->notImpl  #)
        #)#);(* primitive*)
      newBinaryPrim::
        (# EV1,EV2,op: @ASTindex; lv: ^evVal; 
	   lDr: ^mch.dataRegOperand;
	   EH: @EvalHandler;
        do EV.son->EV1; EV1.brother ->op; op.brother->EV2;
	   (baseadr.copy,EV1[],false,EHchain[])->EH.ExpEval->lv[];
           (if op[]->sematt.primitiveToNumber 
	    // 34 (* Val %putByteAt Adr *) then (lv[],EV2[],1)->putValAt
            // 35 (* Val %putShortAt Adr *) then (lv[],EV2[],2)->putValAt
            // 36 (* Val %putLongAt Adr *) then (lv[],EV2[],4)->putValAt
           if);
        #);
      newRemotePrim::
        (# EV1,op: @ASTindex; A: ^mch.address; ar: @mch.adrRegOperand;
           primOp: @integer
        do (*312 -> cTrace(#do 'NewRemotePrim: '->xT; EV[]->xA #);*)
           EV.son->EV1; EV1.son -> EV1; EV1.brother->op;
           (baseAdr.copy,EV1[],false,EHchain[])->genAdr->A[];
           op[]->sematt.primitiveToNumber -> primOp;
           (if switch182 then 
               (if primOp
                // 32 // 33 then mch.duplicate 
               if);
               (A[],&mch.adrRegOperand[]) -> mch.ldVal
            else
               A.toReg2->ar;
           if);
           (if primOp
            // 32 (* R.%byteSwapShort *) then
               (ar,false)->mch.byteSwap;
               (if switch182 then 
                   (&mch.dataRegOperand[],A[])-> mch.stVal
               if)
            // 33 (* R.%byteSwapLong *) then  
               (ar,true)->mch.byteSwap;
               (if switch182 then 
                   (&mch.dataRegOperand[],A[])-> mch.stHalf
               if)
            // 39 (* R.%lock *) then
               (* currently ONLY available for sparc *)
               ar->mch.lock;
            // 40 (* R.%lock *) then
               (* currently ONLY available for sparc *)
               ar->mch.unlock;
            // 41 (* R.%enablePreemption *) then
               (* currently ONLY available for sparc *)
               ar->mch.enablepreemption;
            // 42 (* R.%disablePreemption *) then
               (* currently ONLY available for sparc *)
               ar->mch.disablepreemption;
            // 44 (* R.%suspend *) then
               (# pDest: ^mch.mOperand
               do (if common.switch[61] then
                   else
                      1 -> mch.initPrimCall;
                      1 -> ar.toPrimDest;
                      'SuspX' -> mch.callPrim;
                      0 -> mch.getPrimRes
               if)#)
            // 45 (* R.%break *) then
               mch.SetBreak
           if); 
           ar[]->mch.gClr; 
        #);
      assign::<
        (# EH: @EvalHandler; chain1: ^DH.SuperChain (* see comment at 
                                                     * assign::< below
                                                     *)
        do (if stest then
               302->ctrace(#
                          do 'EvalBody:assign:A: EV1:'->xT;
                             EV1[] -> xA; 
                             ' EV2:' -> xT; EV2[] -> xA; xN;
                             baseAdr.display->xT
           #)if);         
           (* EV  = E1 -> E2 -> ... -> En-1 -> En
            * EV1 = E1 -> E2 -> ... -> En-1 
            * EV2 = En
            *)
           (if switch182 then
               '!EvalBody:assign:make:methodArgs'->mch.comment;
               (baseAdr.copy,EV1[],EHchain[]->chain1[],false,none) 
                 -> EH.methodArgs 
                 -> V[]
            else              
               (if switch181 then
                   (baseAdr[],EV1[],false,EHchain[]->chain1[])
                     -> EH.ExpEval
                     -> V[];
                else
                   (baseAdr.copy,EV1[],false,EHchain[]->chain1[])
                     -> EH.ExpEval
                     -> V[];
               if);
           if);
           (if stest then
               302->ctrace(#
                          do 'EvalBody:assign:B'->xH;
                             (if V[] = none then
                                 'V is none' -> putline
                              else
                                 V.display; xN;
                             if);
                             EV2[] -> xA; xN;
                             baseAdr.display->xT
           #)if);                  
           (if switch181 then
               (baseAdr[],V[],EV2[],false,chain1[])
                 -> EH.assignValToEval
                 -> V[];
            else
               (baseAdr.copy,V[],EV2[],false,chain1[])
                 -> EH.assignValToEval
                 -> V[];
           if);
           (if stest then
               302->ctrace(#
                          do 'EvalBody:assign:C'->xH;
                             (if V[] = none then 'V is none'->xT
                              else 
                                 V.display
                             if);
                             xN;
                             baseAdr.display->xT
           #)if);                  

           (* check if this is ok - assignments may be embedded *)
        #);
      evalList::
        (# EH: @EvalHandler
        do (*312->cTrace(#do EV[] ->xA #); *)
           EV.son -> scanList
           (# E: @ASTindex 
           do currentNode -> E; (*312->cTrace(#do E[] ->xA #); *)
              (baseAdr.copy,E[],way,EHchain[]) -> EH.GenEval
           #)
        #);
      unMinus::(#do (baseAdr.copy,EV[],false,EHchain[]) -> ExpEval -> V[] #);
      unPlus::(#do (baseAdr.copy,EV[],false,EHchain[]) -> ExpEval -> V[] #);
      notExp::(#do (baseAdr.copy,EV[],false,EHchain[]) -> ExpEval -> V[] #);
      binOp::(#do (baseAdr.copy,EV[],false,EHchain[]) -> ExpEval -> V[] #);
      (* all others should not appear *)
   #);
   (if V[] <> NONE then V.release if);
   none->eval[]; none->baseAdr[]; none->EHChain[]; none->V[];
#)
---ExpEval:descriptor---
(# newObject: (* integrate with exeObj *)
     (# EV,ES: @ASTindex; kind: @integer; W: ^EvVal; 
        descKind,MN,isVirtual: @integer; desc,sort: @ASTindex;
        D: ^ASTindex; callRegOnStack: @boolean;
        A: ^mch.address; EVchain: ^DH.superChain
     enter(EV,kind)
     do EV.son->ES;
        (if ES.label = (gram.objectDescriptor->descKind) then
            (ES,common.itemKind,3,null)->DS.push; ES->desc;
            (* kind,cons are not correct *)
         else 
            ES->sematt.getSort->sort;
            (* OBS variablePattern is not a sort, but an
             * ObjectSpecification
             *)
            (if sort.label <> (gram.variablePattern->descKind) then
                baseAdr.bAdr.localDesc[]->D[];
                (*306->cTrace
                 (#do 'NewObj1:'->T; ES[]->A; 
                 (if chain[] = NONE then 'chain is none'->T
                 else chain
                 if)#);*)
                ES->sematt.descrip-> desc;
                desc.label->descKind;
                (chain1[],ES)->DH.theDescForm->(desc,MN,EVchain[],isVirtual);
                (*306->cTrace
                 (#do 'NewObj2:'->T; ES[]->A; desc[]->A;
                 (if EVchain[] = NONE then 'EVchain is none'->T
                 else EVchain
                 if)#);*)
        if)if);
        (baseAdr.copy,ES[],desc[],kind,descKind,chain1[]) 
          -> GenerateObject 
          -> (A[],callRegOnStack);
        (if callRegOnStack then 
            (# aR: @mch.adrRegOperand 
            do aR.alloc; 
               (aR,true,ES[],chain1[])->mkComputedRefEvVal->W[];
               (mch.callRegOp[],aR[])->mch.cpReg;
               true->PopCall
            #)
         else 
            (* Why true here and in the call above?
             * true means struc ref??? Should be false?
             * For computedRefEvval, strucRef is only used in pushCpar,
             * i.e. only for COMobject (&myCom[] -> somExternal)
             * does it matter, and this is why the problem was discovered.
             * We should change to false, but NOT just before a freeze 
             * of r4.1!
             *)
            (if common.switch[125] then 
                (# A1: ^mch.RegAdr
                do A[] -> A1[];
                   (A.reg1,true,ES[],chain1[])->mkComputedRefEvVal->W[]
                #)
             else
                (mch.callO,true,ES[],chain1[])->mkComputedRefEvVal->W[]
            if)
        if) 
     exit W[]
     #);
   singleList: (# enter EV[] #); 
   V: ^evVal; EH: @EvalHandler; EVx: @ASTindex;
   chain1: ^DH.SuperChain (* the following calls assign chain to
                           * the global variable i EH. This means
                           * that chain may have changed during
                           * execution of EH.ExpEval. Therefore
                           * the original value is saved in chain1
                           * for the call EH.assignValToEval.
                           * Should have been more clean
                           *)
do (if stest then
       301->cTrace(#
                  do 'ExpEval:'->xT; EV[]->xA; xN;
                     'baseAdr='->xT; baseAdr.display->xT;
                     mch.dumpreg; (*EHchain[]->printChain*) 
   #)if);
   EHchain[]->chain1[];    
  
   EvalCase:
     EV[]-> sematt.evCase
   (# assign::<
        (# 
        do (if stest then
               301->ctrace(#
                          do 'ExpEval:assign:A EV1:'->xT; EV1[] -> xA; 
                             ' EV2:' -> xT; EV2[] -> xA; xN;
                             baseAdr.display->xT
           #)if); 
           (* EV  = E1 -> E2 -> ... -> En-1 -> En
            * EV1 = E1 -> E2 -> ... -> En-1 
            * EV2 = En
            *)
           (if switch182 then
               '!expEval:Assign' -> mch.comment;               
               (baseAdr.copy,EV1[],EHchain[]->chain1[],true,none)
                 -> EH.methodArgs
                 -> V[]
            else              
               (if switch181 then
                   (baseAdr[],EV1[],false,chain1[])->EH.ExpEval->V[];
                else
                   (baseAdr.copy,EV1[],false,chain1[])->EH.ExpEval->V[];
           if)if);
           (if stest then
               302->ctrace(#
                          do 'ExpEval:assign:B V:'->xH;
                             V.display; xN;
                             ' EV2:'->xT; EV2[] -> xA; xN;
                             'multipleAssign: ' -> xT; doExit -> xB; xN;
                             baseAdr.display->xT
           #)if);

           (if switch181 then
               (baseAdr[],V[],EV2[],doExit,chain1[])
                 -> EH.assignValToEval
                 -> V[];
            else
               (baseAdr.copy,V[],EV2[],doExit,chain1[])
                 -> EH.assignValToEval
                 -> V[];
           if);
           (if stest then
               302->ctrace(#
                          do 'ExpEval:assign:C'->xH;
                             (if V[] = none then 'V is none' -> xT 
                              else
                      V.display; xN;
                             if);
                             baseAdr.display->xT
           #)if)
        #);
      simple::<
        (# A: ^mch.address
        do EV.son->EVx; 
           (if common.switch[211] then
               (if ((EV[]->theGen.RegCont.inReg->V[]) <> NONE) then
                   leave simple
           if)if);
           (baseAdr.copy,EVx[],false,chain1[])->genAdr-> A[];
           (if A.isNotObjRef or switch182 then
               (# dr: @mch.dataRegOperand
               do dr.alloc;
                  (A[],dr[],A.size) -> mch.ldVl;
                  (dr,false,false,false,a.bAdr.localDesc[])
                    -> mkComputedEvVal2 
                    -> V[];
                  true -> A.freeAdr;
               #)
            else 
               A[] -> mkSImpleVal->V[]
           if);
        #);
      realEv::<
        (#
        do EV.son->EVx;         
           (baseAdr.copy,EVx[],false,chain1[])->genAdr->mkRealEvVal->V[];
           (if switch182 then
               V.pushVal -> V[]
           if)
        #);
      repetition::<
        (# slice: @boolean
        do NOT (EV1[]=NONE)->slice;
           (baseAdr.copy,EV[],evalKind,slice)->mkTxtVarEvVal->V[];
           (if false (*switch182*) then
               (if not common.switch[188] then 'OLSEN'->putline; if);
               V.pushVal -> V[]
           if)
        #);
      inlineNX::
        (# W: ^inlineNXitem; chain2: ^DH.SuperChain;
           D: @ASTindex; MN: @integer; isV: @integer
        do (*195->cTrace(#do 'No-do-X:'->T; EV[]->A #);*)
           mch.InlineNX
           (# Failed::
                (#
                do '\nInlining failed 1!' -> screen.putline
                #)
           do (chain1[],EV.son)->DH.theDescForm->(D,MN,chain2[],isV);
              (EV[],desc[],baseAdr.copy,chain2[],thisDesc[])
                -> mkInlineItemEval
                -> W[];
              chain1[] -> W.eval -> V[]
           #);
        #);
      insert::<
        (# D: @ASTindex
        do (if desc.label = gram.objectDescriptor then
               desc->sematt.TopDesc->D;
               (*213->cTrace(#do desc[]->A; D[]->A; #);*)
               (if D[]->sematt.hasOnlyNX then
                   (*213->cTrace(#do 'NoDoX:'->T; EV[]->A #);*)
                   (* just get the exit part -
                    * OBS MUST have NO attributes
                    *)
                   (# D: @ASTindex; MN: @integer; isV: @integer;
                      chain2: ^DH.SuperChain;
                      XS: @| sematt.NXScanner
                   do (chain1[],EV.son)->DH.theDescForm->(D,MN,chain2[],isV);
                      (desc[],true,chain2[])->XS;
                      (if XS.length = 1 then
                          (* XS.getNXelm->(ev[],pl,chain3[]);*)
                          
                      if)
                   #)
           if)if);
           (if switch181 then
               (baseAdr[],EV[],doExit,chain1[],false)->doGenItem->V[] 
            else
               (if switch182 then
                   (EV,false,true,chain1[]) -> mkByteCodeCall -> V[]
                else
                   (baseAdr.copy,EV[],doExit,chain1[],false)->doGenItem->V[] 
               if)
           if)
        #);
      itemEv::< 
        (# 
        do (if switch182 then
               'expEval:doItem1:' -> mch.comment;
               (baseAdr[],EV[],true,chain1[])->doItem->V[];
               'expEval:doItem2:' -> mch.comment;
            else
               (if switch181 then
                   (baseAdr[],EV[],doExit,chain1[])->doItem->V[] 
                else
                   (baseAdr.copy,EV[],doExit,chain1[])->doItem->V[] 
           if)if)
        #);
      compEv::< 
        (# 
        do (if switch181 then
               (baseAdr[],EV[],doExit,chain1[])->doComp->V[] 
            else
               (baseAdr.copy,EV[],doExit,chain1[])->doComp->V[] 
           if)
        #);
      sysEv::< (#do 'Exit System Eval'->notImpl #);
      dynItem::<
        (#
        do (if switch181 then
               (baseAdr[],EV[],doExit,chain1[],true)->doGenItem->V[] 
            else
               (if switch182 then
                   (EV,false,true,chain1[]) -> mkByteCodeCall -> V[]
                else
                   (baseAdr.copy,EV[],doExit,chain1[],true)->doGenItem->V[] 
               if)
           if)
        #);
      dynComp::<
        (#
        do (if switch181 then
               (baseAdr[],EV[],doExit,chain1[],true)->doGenComp->V[] 
            else
               (if switch182 then
                   '\nOBS Dynamic component - may not work' -> putline
               if);
               (baseAdr.copy,EV[],doExit,chain1[],true)->doGenComp->V[] 
           if)
        #);
      computedObj::< (#do 'Exit Computed Object'->notImpl #);
      dynItemRef::< 
        (#
        do (if switch182 then
               (EV[],chain1[]) -> newBCobject ->V[]
            else
               (EV,common.itemKind)->newObject->V[]
           if)
        #);
      dynCompRef::< (#do (EV,common.compKind)->newObject->V[] #);
      objRef::< 
        (# sDesc: @ASTindex; mn: @integer;
           LC: ^DH.superChain;
           sKind: @integer;
           A: ^mch.address;
           sClass: ^text;
           aR: @mch.adrRegOperand;
        do EV.son->EVx;
           ((baseAdr.copy,EVx[],false,chain1[])
             -> genAdr,false,EVx[],chain1[])
             -> mkRefEvVal
             -> V[]
        #);
      strucRef::<
        (# ObjStruc:
             (* R##, where R is an object-reference *)
             (# onStack: @boolean; pReg: ^mch.mOperand;
                ar: @mch.adrRegOperand; dr: @mch.dataRegOperand;
                isComponent,pop: @boolean
             enter isComponent
             do (baseAdr.copy,EVx[],false,chain1[])->genAdr->A[];
                (if switch182 then
                    (* Call Structure.ObjS(object o), which use reflection to 
                     * find o.origin.
                     *)
                    (if false (*isJava*) then
                        'L' -> A.fieldType.prePend;
                        ';' -> A.fieldType.put
                    if);
                    (A[],&mch.adrRegOperand[]) -> mch.ldVal;
                    'ObjS'->mch.callPrim;
                 else                    
                    (* test if item or component and adjust A *)
                    (if isComponent then common.compHeadSize*4->A.addOff->A[] if);
                    (if mch.CallRegInPrimReg2 
                        (*mch.callRegBusy and common.switch[61]*) then
                        (false,true) -> mch.pushThisOrCall;
                        true -> pop
                    if);
                    2->mch.initPrimCall;
                    1->mch.getPrimReg->pReg[];
                    (if A.access = common.direct then
                        ar.alloc;
                        (A[],ar[])->mch.gLea;
                        A.freeAdr
                     else
                        (* make sure that a none test is generated here!
                         * also nee
                         * 
                         * ded to handle possible dangling persistent
                         * ref to pstore
                         *)
                        A.toReg3->ar; (* used to be: toReg2, which makes freeAdr,
                                       * and a reUse of the register;
                                       * i.e. A.freeAdr must be executed again.
                                       * Instead toReg3 is used which makes
                                       * use of a possible register in A;
                                       * see comment in machine:toReg(# 2,3,4#)
                                       *)
                    if);
                    (if pReg.isPrimRegOp then
                        (ar[],pReg[])->mch.cpReg
                     else
                        (ar[],pReg[])->mch.stVal
                    if);
                    ar.dealloc;
                    (if common.switch[61] then (2,1) -> mch.SPtoPrimReg if);
                    'ObjS'->mch.callPrim;
                    3->mch.getPrimRes->dr; ar.alloc; (dr[],ar[])->mch.cpReg;
                    dr.deAlloc;
                    (if pop then (false,true) -> mch.popThisOrCall if);
                if);
                (ar,true,EVx[],chain1[])->mkComputedRefEvVal->V[]
             #);
           varPtn:
             (#
             do (baseAdr.copy,EVx[],false,chain1[])->genAdr->A[];
                (if switch182 then
                    'Structure' -> theGen.text2signature -> A.fieldType[];
                    301->trace(#
                              do 'varPtn:'->xT; A.display -> xT
                              #);
                if);
                (A[],true,EVx[],chain1[])->mkRefEvVal->V[]
             #);
           sort: @ASTindex; A: ^mch.address; lab: @integer
        do (if stest then
               301->ctrace(#
                          do 'assignValToVal:strucRef:'->xT; EV[] -> xA
                          #);
           if);
           EV.son->EVx;
           (if EVx.label = gram.thisObject then ObjStruc
            else
               EVx->semAtt.getSort->sort;
               (if sort.label->lab 
                // gram.simpleDecl// gram.repetitionDecl then
                   sort.son->sort; sort.brother->sort;
                   (if lab=gram.repetitionDecl then
                       sort.brother->sort
                   if);
                   (if sort.label
                    //gram.variablePattern then varPtn
                    //gram.staticItem// gram.dynamicItem then false->ObjStruc
                    else (* component *) true->ObjStruc
                   if)
                else 
                   (if switch182 then
                       (EV[],chain1[]) -> newBCstrucObject ->V[]
                    else
                       (EV,common.strucKind)->newObject->V[]
                   if)
        if)if)#);
      evalList::< 
        (# E: @ASTindex; N: @Integer 
        do EV.son -> EVx;
           Elim:             
             EVx -> ScanList
           (#
           do currentNode->E; N+1->N;
              (if N = 2 then leave Elim if);
              (* more than one elm in list *)
           #);
           (if N = 1 then 
               E[]->singleList; 
               restart EvalCase 
           if);
           301->trace(# do EVx[]->xA #);
           (EVx[],baseAdr.copy,chain1[])->mkListVal->V[];
        #);
      RepOp::<
        (# RN,RN1: @ASTindex; A: ^mch.address
        do (*350->cTrace(#do 'RepOp'->t #);*)
           EV.son -> RN; (* RN = R.x *) RN.son -> RN1;
           '!evbody:repOp' -> mch.comment;
           (baseAdr.copy,RN1[],false,chain1[]) -> genAdr -> A[];
           (if (RN[]->semAtt.repAttId) = 1 (* range *) then 
               (#                   
               do (if switch182 then
                      '!evbody:repOp:range' -> mch.comment;
                      A.bAdr.localDesc[] 
                        -> theGen.mkArraySignature 
                        -> A.fieldType[];
                      (A[],none) -> mch.ldVal;
                      mch.loadRange;
                      (* currently we allocate index 0
                       * in arrays - must be fixed
                       *)
                      (*
                      (1->mch.newCstOp,&mch.dataRegOperand[]) -> mch.ldCst;
                      (&mch.dataRegOperand[],&mch.dataRegOperand[],4) 
                        -> mch.gSub; *)
                      mkComputedEvVal -> V[]
                   else
                      common.cstInd -> A.access; 4 -> A.size;
                      common.rangeOff*4 -> A.addOff -> mkSimpleVal -> V[]
                  if)
               #)
            else 
               'Illegal RepOp in RepOp->E' ->bugstream.putline
           if);
        #);
      cProcDesc::<
        (# CP: @ExternalCall
        do (callId,desc[],extKind,EV.son)->CP;
           CP.call; CP.getExitP->V[];
        #);
      externalVirtual::
        (# CP: @ExternalCall
        do (*301->cTrace(#do 'Calling external virtual: '->xT; callId[]->xT #);*)
           (':VDT:',desc[],sematt.virtExt->extKind,EV.son)->CP; 
           CP.call; 
           CP.getExitP->V[]
        #);
      newBinaryPrim::
        (# EV1,EV2,op: @ASTindex; 
	   LogOp:
             (# rv: ^evVal; lDr: ^mch.dataRegOperand; 
             do (baseadr.copy,EV2[],false,chain1[])->EH.ExpEval->rv[];
	        lv.loadVal2->lv[]; lv.toDataReg->lDr[]; 
	        rv.loadVal2->rv[]; rv.toDataReg->dr[];
	        (*dr->dr.reUse;*)
	        INNER;
                lDr.deAlloc
             #);
	   shift:
             (# shiftBy: ^mch.mOperand; T: ^text; rv: ^evVal;
             do lv.loadVal2->lv[]; lv.toDataReg->dr[];
	        (if EV2.label = gram.integerConst then 
		    EV2.getText->T[]; 0->T.setPos;
	    	    T.getInt->mch.NewCstOp->shiftBy[];
		    (* in the 'old' prim version it was tested if the
	  	     * constant was < 8
		     *)
		 else 
	            (baseadr.copy,EV2[],false,chain1[])->EH.ExpEval->rv[];
	            rv.loadVal2->rv[]; rv.toDataReg->shiftBy[];
                if);
                INNER;
             #);
	   lv: ^evVal; dr: ^mch.dataRegOperand
             (***** We need to consider alloc/dealloc of registers! *)
        do EV.son->EV1; EV1.brother ->op; op.brother->EV2;
	   (baseadr.copy,EV1[],false,chain1[])->EH.ExpEval->lv[];
           (if op[]->sematt.primitiveToNumber 
            // 2 (* band *) then LogOp(#do (lDr[],dr[],4)->mch.gAnd #)
            // 3 (* bor  *) then LogOp(#do (lDr[],dr[],4)->mch.gOr #)
            // 4 (* bxor *) then LogOp(#do (lDr[],dr[],4)->mch.gXor #)
            // 22 (* srl *) then 
	       Shift(#do (shiftBy[],dr[])->mch.logicalShiftRight #)
            // 23 (* sll *) then 
	       Shift(#do (shiftBy[],dr[])->mch.logicalShiftLeft #)
            // 24 (* sra *) then 
	       Shift(#do (shiftBy[],dr[])->mch.arithShiftRight #)
            // 25 (* sla*) then
	       Shift(#do (shiftBy[],dr[])->mch.arithShiftLeft #)
            // 37 (* rol *) then 
	       Shift(#do (shiftBy[],dr[])->mch.rotateLeft #)
            // 38 (* ror *) then
	       Shift(#do (shiftBy[],dr[])->mch.rotateRight #)
	    // 34 (* Val %putByteAt Adr *) then (lv[],EV2[],1)->putValAt->dr[]
            // 35 (* Val %putShortAt Adr *) then (lv[],EV2[],2)->putValAt->dr[]
            // 36 (* Val %putLongAt Adr *) then (lv[],EV2[],4)->putValAt->dr[]
           if);
 	   (dr,false,false,false)->mkComputedEvVal->V[]
        #);
      newUnaryPrim:: (* %thiss object - many changes *)
        (# EV1,op: @ASTindex; lv: ^evVal;
	   lDr: ^mch.dataRegOperand; 
           primNo: @integer
        do EV.son->op; 
           (if (op[]->sematt.primitiveToNumber -> primNo) 
               = 43 (* %thiss object *) then
               (mch.thisRegOp,false,none,chain1[]) -> mkComputedRefEvVal -> V[]
            else
               op.brother->EV1;
	       (baseadr.copy,EV1[],false,chain1[])->EH.ExpEval->lv[];
               lv.loadVal2->lv[]; lv.toDataReg->lDr[];
               (if primNo
                // 1 (* not *) then (lDr[],4)->mch.logNot
                // 26 (* %getByteAt Adr *) then (lDr[],1,false)->getValAt
                // 27 (* %getShortAt Adr *) then (lDr[],2,false)->getValAt
                // 28 (* %getSignedByteAt Adr *) then (lDr[],1,true)->getValAt
                // 29 (* %getSignedShortAt Adr *) then (lDr[],2,true)->getValAt
                // 30 (* %getLongAt Adr *) then (lDr[],4,false)->getValAt
               if);
 	       (lDr,false,false,false)->mkComputedEvVal->V[]
           if)
        #);
      primitive::<
        (# PC: @primitiveCall 
        do EV->SemAtt.ParsePrimitive
           (# ExternalOp::<
                (#
                do (if not OpTxt.empty then (0,OpTxt[])->PC; PC.call->V[] if)
                #);
              InLineOp::<
                (#do(* (OpCode,I1,I2)->V.asgToInLinePrimitive->V[]  *)
                   'ExitInlinePrimitive'->notImpl #)
        #)#);(* primitive*)
      address::< 
        (# 
        do EV.son->EVx; 
           mkComputedEvVal->V[];
           (baseAdr.copy,EVx[],false,chain1[])->genAdr->V.toDreg
        #);
      constDesc::<(#do val->mkConstVal->V[] #);
      intCst::<
        (# T: ^text; F: @ASTindex
        do EV.getText -> T[];
           EV.father -> F;
           (if F.label = gram.unaryMinusExp then
               (* To be able to handle 
                *    -2147483648 = minInt
                * we must prepend the '-' sign before
                * calling getNumber to avoid number overflow;
                * see also chkevalbody: call of getNumber
                *)
               '-' -> T.prepend
           if);
           0->T.setPos;
           T.getNumber 
           (# integerValue::< (#do value->mkConstVal->V[] #);
              basedValue::< (#do value->mkConstVal->V[] #);
              realValue::<
                (#do (T[],value)->mch.floatConst->mkFloatEvVal->V[] #)
           #);
        #);
      txtCst::< 
        (# T: ^text do EV.gettext->T[]; T->mkTxtCstEvVal->V[] #);
      noneExp::< 
        (#
        do (if switch182 then 
               mch.ldNone;
               (0,true,false,false) -> mkComputedEvVal -> V[];
               (*(mch.callO,false,EV[],thisSuperChain)
                 -> mkComputedRefEvVal
                 -> V[];*)
            else
               common.noneVal -> mkConstVal -> V[] 
           if)
        #);
      unMinus::<
        (# V1: ^evval
        do EV.son->EVx; 
           (baseAdr.copy,EVx[],false,chain1[]) -> &EH.ExpEval -> V1[];
           (if EVx.label <> gram.integerConst then
               (* see intCst above *)
               V1.unMinus -> V[];
               V1.release
            else V1[] -> V[]
           if);
        #);
      unPlus::<
        (#
        do EV.son->EVx; (baseAdr.copy,EVx[],false,chain1[])->&EH.ExpEval->V[]
        #);
      notExp::<
        (# V1: ^evval
        do EV.son->EVx; (baseAdr.copy,EVx[],false,chain1[])->&EH.ExpEval->V1[];
           V1.notExp->V[]; V1.release 
        #);
      binOp::< 
        (# lv,rV: ^evVal; lNo,rNo,evNo,freeReg,binType: @integer;
           L,Lx: @mch.localLab; dr: ^mch.dataRegOperand;
           isRef: @boolean;
           mkComputedVal:
             (# dr: ^mch.dataRegOperand;
                ev: ^EvVal
             enter dr[]
             do (dr,false,false,false)->mkComputedEvVal->ev[]
             exit ev[]
             #);
        do (if stest then 
               301->ctrace(#
                          do 'expVal:binOp:' -> xT; EV[] -> xA
           #)if);
           (if switch182 then true -> doExit if);
           (if ev.label
            // gram.andExp then
               (*     <EV1>
                *     jmpFalse L
                *     <EV2>
                *     jmp Lx - not the smartest code here
                * L:  0->dr
                * Lx: ...
                *)
               L.new;
               (baseAdr.copy,EV1[],doExit,EHChain[],L[],false)
                 ->BoolExpEval->lv[];
               (baseAdr.copy,EV2[],doExit,EHChain[])->ExpEval->Rv[];
               rv.loadVal2->rv[]; rv.toDataReg->dr[];
               Lx.new; 
               Lx[]->mch.gJmp;
               L.def;
               (if switch182 then
                   (0->mch.NewCstOp,dr[]) -> mch.ldCst
                else
                   dr[]->mch.gClr;
               if);
               Lx.def;
               lv.release; 
               (dr,false,false,false)->mkComputedEvVal->V[];
               leave binOp
            // gram.orExp then
               (*     <EV1>
                *     jmpTrue L
                *     <EV2>
                *     jmp Lx - not the smartest code here
                * L:  1->dr
                * Lx: ...
                *)
               L.new;
               (baseAdr.copy,EV1[],doExit,EHChain[],L[],True)
                 ->BoolExpEval->lv[];
               (baseAdr.copy,EV2[],doExit,EHChain[])->ExpEval->Rv[];
               rv.loadVal2->rv[]; rv.toDataReg->dr[];
               Lx.new; 
               Lx[]->mch.gJmp;
               L.def;
               (1->mch.newCstOp,dr[])->mch.ldCst;
               Lx.def;
               (dr,false,false,false)->mkComputedEvVal->V[];
               lv.release; 
               leave binOp

           if);
           (if switch182 then
               1->ev.getAttribute->lNo; 
               2->ev.getAttribute->rNo;
            else               
               1 -> ev.getAttribute -> lNo; 
               1 -> lNo.%getShort -> rNo;
               0 -> lNo.%getShort -> lNo; 
               2 -> ev.getAttribute -> evNo;
           if);
           mch.dataRegMax->freeReg;
           (*307->cTrace
            (#do EV[]->A; lNo->I; rNo->I; evNo->I; 
            ' MaxReg:'->T; freeReg->I;
            ' FreeReg:'->T; mch.noOfFreeDataReg->I 
            #);*)
           (if switch181 then
               (baseAdr[],ev1[],false,chain1[])->&EH.ExpEval->lv[];
               (if stest then
                   301 -> ctrace(#
                                do 'expEval:binOp:before:loadVal:' -> xH;
                                   'baseAdr=' -> xT; baseAdr.display->xT; xN;
                                   lv.display; 
               #)if);
               (* here we may temporarily free baseadr if it does
                * not use the same a-reg as lv;
                * lv.loadVal may imply an exit-part like 'exit A+1'
                * where A is an object to be recursively evaluated
                * and use more a-registers
                *)
               (* switch181: perhaps save baseAdr before loadVal?*)
               lv.loadVal->lv[];
               (if stest then
                   301 -> ctrace(#
                                do 'expEval:binOp:after:loadVal:' -> xH;
                                   'baseAdr=' -> xT; baseAdr.display->xT; xN;
                                   lv.display; 
               #)if);

               (if lv.theReg = mch.callO then
                   (* possible for T##values *)
                   lv.toTmp
               if);
               (baseAdr[],ev2[],false,chain1[])->&EH.ExpEval->rv[];
               rv.toDataReg->mkComputedVal->rv[]
            else
               (if true
                // (rNo=0) or common.switch[129] then 
                   (* switch 129 is byte code compiler: always evaluate 
                    * from left to right *)
                   (baseAdr.copy,ev1[],doExit,chain1[])->&EH.ExpEval->lv[];
                   302 -> ctrace(#
                                do 'expVal:binOp:beforeLoadVal:'->xT;
                                   lv.display
                                #);
                                   
                   lv.loadVal->lv[];
                   (if switch182 then 
                       (* '\nBinOp:Type: ' -> puttext; 
                        *  lNo -> putint; ' ' -> put; rNo -> putint; 
                        *)
                       true -> lv.pushVal -> lv[];
                       (if (((lNo mod 16) = sematt.valType) 
                           and ((rNo mod 16) = sematt.realType)) 
                           or
                           (ev.label = gram.realDivExp) then
                           lv.mkReal -> lv[]
                       if)
                   if);
                   (baseAdr.copy,ev2[],doExit,chain1[])->&EH.ExpEval->rv[];
                   (if switch182 then
                       (if ev.label = gram.realDivExp then
                           rv.mkReal->rv[]; 
                           3->binType;
                   if)if)                           
                // (0<=lNo) and (lNo<=rNo) and (lNo<freeReg) then
                   (baseAdr.copy,ev2[],doExit,chain1[])->&EH.ExpEval->rv[];
                   rv.loadVal->rv[];
                   (baseAdr.copy,ev1[],doExit,chain1[])->&EH.ExpEval->lv[];
                // (1<=rNo) and (rNo<=lNo) and (rNo<freeReg) then
                   (baseAdr.copy,ev1[],doExit,chain1[])->&EH.ExpEval->lv[];
                   lv.loadVal->lv[];
                   (baseAdr.copy,ev2[],doExit,chain1[])->&EH.ExpEval->rv[];
                // (freeReg<=lNo) and (freeReg<=rNo) then
                   cError(#do 'BinOp: out of data registers'->xT; EV[]->xA #);
                   (baseAdr.copy,ev2[],doExit,chain1[])->&EH.ExpEval->rv[];
                   rv.loadVal->rv[];
                   (* rv to tmp *)
                   (baseAdr.copy,ev1[],doExit,chain1[])->&EH.ExpEval->lv[];
                   (* tmp to reg *)
                else cError(#do 'Binop: missing case'->xT #);
                   (baseAdr.copy,ev1[],doExit,chain1[])->&EH.ExpEval->lv[];
                   lv.loadVal->lv[];
                   (baseAdr.copy,ev2[],doExit,chain1[])->&EH.ExpEval->rv[];
               if);
           if);
           (lv[],rv[]) -> CoerceTypes -> (lv[],rv[],binType);
           
           (if not switch182 then
               (* perhaps this can juts be covered by switch182 above 
                * in the general case also!
                *)
               (if ev.label = gram.realDivExp then
               lv.mkReal->lv[]; 
               rv.mkReal->rv[]; 3->binType;

           if)if);
           (if binType
            // 1 // 2 then (* simple values *)
               (binType=2) -> isRef;
               (if ev.label
                // gram.plusExp then lv[]->rv.add->V[]
                // gram.minusExp then lv[]->rv.sub->V[]
                // gram.orExp then 
                   '\V.orr called' -> putline;
                   lv[]->rv.orr->V[]
                // gram.timesExp then lv[]->rv.times->V[]
                // gram.intDivExp then (lv[],true)->rv.divMod->V[]
                // gram.modExp then (lv[],false)->rv.divMod->V[]
                // gram.andExp then 
                   lv[]->rv.andd->V[]
                // gram.eqExp then 
                   (lv[],gram.eqExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.neExp then 
                   (lv[],gram.neExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.ltExp then
                   (lv[],gram.ltExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.leExp then 
                   (lv[],gram.leExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.gtExp then
                   (lv[],gram.gtExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.geExp then 
                   (lv[],gram.geExp,isRef,0,NONE)->rv.cmp->V[]
                // gram.xorExp then
                   (* fast solution:
                    * loadVal2 ensures that lv/rv are in registers;
                    * toDataReg gets the registers;
                    * lv.release, rv.release freesthe registers below.
                    * toDataReg does NOT reuse the registers???
                    *)
                   (# lDr,rDr: ^mch.dataRegOperand
                   do lv.loadVal2->lv[]; lv.toDataReg->lDr[]; 
                      rv.loadVal2->rv[]; rv.toDataReg->rDr[];
                      rDr->rDr.reUse;
                      (lDr[],rDr[],4)->mch.gXor;
                      (rDr,false,false,false)->mkComputedEvVal->V[]
                   #)
               if)
            // 3 then (* real *)
               (if ev.label
                // gram.plusExp then lv[]->rv.rAdd->V[]
                // gram.minusExp then lv[]->rv.rSub->V[]
                // gram.orExp then (*lv[]->rv.orr->V[]*)
                // gram.timesExp then lv[]->rv.rMult->V[]
                // gram.realDivExp then lv[]->rv.rDiv->V[]
                // gram.intDivExp then lv[]->rv.rDiv->V[]
                // gram.modExp then (*(lv[],false)->rv.divMod->V[]*)
                // gram.andExp then (*lv[]->rv.andd->V[]*)
                // gram.eqExp then (lv[],gram.eqExp,false,0,NONE)->rv.rCmp->V[]
                // gram.neExp then (lv[],gram.neExp,false,0,NONE)->rv.rCmp->V[]
                // gram.ltExp then (lv[],gram.ltExp,false,0,NONE)->rv.rCmp->V[]
                // gram.leExp then (lv[],gram.leExp,false,0,NONE)->rv.rCmp->V[]
                // gram.gtExp then (lv[],gram.gtExp,false,0,NONE)->rv.rCmp->V[]
                // gram.geExp then (lv[],gram.geExp,false,0,NONE)->rv.rCmp->V[]
               if)
            // 4 then
               (if ev.label
                // gram.plusExp then (*lv[]->rv.rAdd->V[]*)
                // gram.minusExp then (*lv[]->rv.rSub->V[]*)
                // gram.orExp then (*lv[]->rv.orr->V[]*)
                // gram.timesExp then (*lv[]->rv.times->V[]*)
                // gram.intDivExp then (*(lv[],true)->rv.divMod->V[]*)
                // gram.realDivExp then (*(lv[],true)->rv.divMod->V[]*)
                // gram.modExp then (*(lv[],false)->rv.divMod->V[]*)
                // gram.andExp then (*lv[]->rv.andd->V[]*)
                // gram.eqExp then (lv[],gram.eqExp,true)->rv.sCmp->V[]
                // gram.neExp then (lv[],gram.neExp,true)->rv.sCmp->V[]
                // gram.ltExp then (lv[],gram.ltExp,true)->rv.sCmp->V[]
                // gram.leExp then (lv[],gram.leExp,true)->rv.sCmp->V[]
                // gram.gtExp then (lv[],gram.gtExp,true)->rv.sCmp->V[]
                // gram.geExp then (lv[],gram.geExp,true)->rv.sCmp->V[]
               if)
               
           if);
           lV.release; 
           rV.release;
        #)
   #);
   V[]->RV[];
   (*'endExpEval'->mch.comment;*)
#)
---AssignValToEval:descriptor---
(* assign the value V[] (form an exit list) to the evaluation EV *)
(* Consider if doExit must be included!!!!!!!! *)
(# EH: @EvalHandler;
   SimpleAdr:
     (# EV: ^ASTindex; xES: @ASTindex; A1: ^Mch.Address
     enter EV[]
     do EV.son->xES; baseAdr.copy->A1[]; (* A1.freezeReg; *)
        (*'assignTo:simpleAdr:2'->mch.comment;*)
        (A1[],xES[],false,chain1[])->genAdr->A1[];
        (*'assignTo:simpleAdr:3'->mch.comment;*)
     exit A1[]
     #); 
   singleList: (# enter EV[] #); 
   lEV1,V: ^evVal;
   chain1: ^DH.SuperChain;
   noEval: @boolean; 
do lEV[]->lEV1[]; 
   (if stest then
       301->cTrace(# 
                  do 'AsgValToEval: '->xT; xN;
                     'lEV1='->xT; lEV1.display; 
                     'assignTo: ' -> xT; EV[]->xA ; xN;
                     'baseAdr='->xT; baseAdr.display->xT; xN;
                     (*EHchain[]->printChain*)
   #)if);
   EHchain[]->chain1[];
   '!assignValToEval:'->mch.comment;
   EvalCase:
     EV[]->sematt.evCase
   (# simple::<
        (# rA: ^mch.address;
        do (if common.switch[213] then
               (if ((EV[]->theGen.RegCont.inReg->V[]) <> none) then
                   (* indirect way of getting the dataReg of V: instance
                    * of computedEvVal
                    *)
                   V.toDataReg->lEV1.asgToDataReg->V[];
                   leave simple
           if)if);
           (if switch181 then
               (baseAdr[],EV[],chain1[]) -> lEV1.asgToSImpleEv -> V[]
            else
               '!assignTo:simpleAdr:1'->mch.comment;
               EV[] -> SimpleAdr -> lEV1.asgToAdr -> V[];
               '!assignTo:simpleAdr:4'->mch.comment;
           if)
        #);
      realEv::<
        (#
        do EV[]->simpleAdr->lEV1.asgToRealAdr->V[]
        #);
      repetition::<
        (# 
        do (* We might just as well only pass EV[]
            * and evaluate the address when needed
            *)
           (EV[]->SimpleAdr,EV[],chain1[]) ->lEV1.asgToRepAdr->V[]
        #);
      itemEV::<
        (#
        do (* Here it seems that we must copy baseAdr, since it is
            * modified in exeObj - the super of doEnterItem;
            * in most other places copy should not be necessary
            * since we assign to the same baseAdr-variable in EvalHandler
            *)
           (if switch181 then
               (baseAdr[],Ev[],doExit,chain1[],lEV1[])->doEnterItem->V[]
            else
               (baseAdr.copy,Ev[],doExit,chain1[],lEV1[])->doEnterItem->V[]
           if);
       #);
      compEv::<
        (#
        do (if switch181 then
               (baseAdr[],Ev[],false,chain1[],lEV1[])->doEnterComp->V[];
            else
               (baseAdr.copy,Ev[],false,chain1[],lEV1[])->doEnterComp->V[];
           if);
        #);
      sysEv::<(#do 'Assign to System Eval'->notImpl #);
      inlineNX::
        (* EV denotes a (inserted?) pattern P with descriptor desc;
         * P has only an enter or an exit lists, and these may be inlined.
         *)
        (# W: ^inlineNXitem; chain2: ^DH.SuperChain;
           D: @ASTindex; MN: @integer; isV: @integer
        do (* needed to compute chain2; D = desc, I think! *)
           mch.InlineNX
           (# Failed::
                (#
                do '\nInlining failed 2!' -> screen.putline
                #)
           do (chain1[],EV.son)->DH.theDescForm->(D,MN,chain2[],isV);
              (if stest then
                  195->cTrace(#do 'No-do:'->xT; EV[]->xA; desc[]->xA; D[]->xA#)
              if);
              (EV[],desc[],baseAdr.copy,chain2[],thisDesc[])
                ->mkInlineItemEval
                ->W[];
              (desc[],W[],chain1[])->lEV1.asgToInlineItem->V[];
              chain1[]->W.eval->V[]
           #)
        #);
      insert::<
        (# D: @ASTindex
        do (if desc.label = gram.objectDescriptor then
               desc->sematt.TopDesc->D;
               (if D[]->sematt.hasOnlyNX then
                   (*195->cTrace(#do 'NoDoN:'->T; EV[]->A #);*)
                   (*(chain1[],EV.son)->DH.theDescForm->(D,MN,chain2[],isV);*)
           if)if);
           (if switch181 then
               (baseAdr[],EV[],false,chain1[],false,lEV1[])
                 -> doEnterGenItem
                 -> V[]
            else
               (if switch182 then                   
                   (EV,true,doExit,chain1[]) -> mkBytecodeCall
                   (# 
                   do '!assignValToEval:insert:asgToMethod'->mch.comment;
                      (# T: [sig.noOfEnterArgs] @integer;
                         top,firstArg: @integer
                      do sig.scanEnter
                         (# R: ^thegen.Reference
                         do current.elmType -> T[top+1 -> top];
                            (if false (*current## <= theGen.reference##*) then
                                current[] -> R[];
                                (*'\nElmType: ' -> puttext;
                                R.class[] -> putline; *)
                                (if 'java/lang/String' -> R.class.equal then
                                    13 -> T[top]
                                if)
                            if)
                         #);
                         (if isStatic then
                             (* arg 1 is origin/this *)
                             2 -> firstArg 
                          else 
                             1 -> firstArg
                         if);
                         (T,top,firstArg,sig.thisMethodDesc[],sig.thisChain[])
                           -> lEV1.asgToMethod 
                      #)
                   #)-> V[]
                else
                   (baseAdr.copy,EV[],false,chain1[],false,lEV1[])
                     ->doEnterGenItem
                     ->V[]
               if)
           if);
        #);
      dynItem::< 
        (#
        do (if switch181 then
               (baseAdr[],Ev[],false,chain1[],true,lEV1[])
                 -> doEnterGenItem
                 -> V[];
            else
               (if switch182 then
                   (EV,true,doExit,chain1[]) -> mkByteCodeCall
                   (# 
                   do (# T: [sig.noOfEnterArgs] @integer;
                         top,firstArg: @integer
                      do sig.scanEnter
                         (#
                         do current.elmType -> T[top+1 -> top];
                         #);
                         (if isStatic then
                             (* arg 1 is origin/this *)
                             2 -> firstArg 
                          else 
                             1 -> firstArg
                         if);
                         (* is chain1 ok here? *)
                         (T,top,firstArg,sig.thisMethodDesc[],sig.thisChain[])
                           -> lEV1.asgToMethod 
                      #)
                   #)-> V[]
                else
                   (baseAdr.copy,Ev[],false,chain1[],true,lEV1[])
                     -> doEnterGenItem
                     -> V[];
           if)if)
        #);
      dynComp::<
        (#
        do (if switch181 then
               (baseAdr[],Ev[],false,chain1[],true,lEV1[])
                 ->doEnterGenComp->V[];
            else
               (baseAdr.copy,Ev[],false,chain1[],true,lEV1[])
                 ->doEnterGenComp->V[];
           if);
        #); 
      dynItemRef::
        (* we come here when a constructor is in use as in
         * E -> &foo[] -> S[]
         *)
        (#
        do 301->trace(#
                     do 'assignValToEval:dynItemRef: ' -> xT; EV[] -> xA
                     #);
           (if switch182 then
               (EV[],chain1[]) 
                 -> newBCobject
               (# hasConstructor:: TrueValue;
                  sig: @theGen.signature
               do 
                  (constructorDesc[],constructorDesc->DH.newSingle,false)
                    -> sig.setMethodDesc;
                  constructorDesc[] -> sig.addEnter;
                  (# T: [sig.noOfEnterArgs] @integer;
                     top,firstArg: @integer;                  
                  do (* OBS! no arguments given here;
                      * we should probably fix this??
                      *)
                     (* true -> hasConstructor;*)
                     sig.scanEnter
                     (# R: ^thegen.Reference
                     do current.elmType -> T[top+1 -> top];
                        (*'\nElmType: ' -> puttext;
                        current.elmType->putint; newline;*)
                        (if false (*current## <= theGen.reference##*) then
                            current[] -> R[];
                            R.class[] -> putline;
                            (if 'java/lang/String' -> R.class.equal then
                                    13 -> T[top]
                            if)
                        if)
                     #);
                     (* we may have a problem with a non externalClass
                      * where we perhaps should have a betaenv or
                      * similar origin argument - we know that
                      * the current solution woprks for externalClassKind
                      *)
                     (if false (* isStatic *) then
                         (* arg 1 is origin/this *)
                         2 -> firstArg 
                      else 
                         1 -> firstArg
                     if);
                     301->trace(#
                               do 'constructor'->xT; constructordesc[] -> xA
                               #);
                     (T,top,firstArg,constructorDesc[],chain1[]) 
                       -> lEV1.asgToMethod
                  #)
               #)
                 -> V[]
            else
               '\nOBS! Constructors not implemented ' -> putline;
               (*
                (EV,common.itemKind)->newObject->V[]
                *)
           if)
        #);
      evalList::<
        (# EVx,E: @ASTindex; N: @integer
        do (* strip evalList *)
           (*350->cTrace(#do 'assign To :'->T; EV[]->A #);*)
           EV.son->EVx;
           Elim:
             EVx->ScanList
           (#
           do currentNode->E; N+1->N;
              (if N = 2 then leave Elim if);
              (* more than one elm in list *)
           #); 
           (if N = 1 then 
               E[]->singleList; 
               restart EvalCase 
           if);
           EV.son->EVx; 
           (if switch181 then
               (baseAdr[],EVx[],chain1[])->lEV1.asgToList->V[]; 
            else
               (baseAdr.copy,EVx[],chain1[])->lEV1.asgToList->V[]; 
           if);
           (*(if isExitEval  then
            ' ...->(e1,e2,...)->...' ->NotImpl
            if)*)
        #);
      objRef::<
        (# 
        do 301->trace(#
                     do 'assignValToEval: lEV1:'->xT; lEV1.display;
                        ' -> EV: ' -> xT; EV[] -> xA
                     #);
           true->lEV1.sourceIsRef;
           'asgToRef1'->mch.comment;
           (baseAdr.copy,EV[],chain1[])->lEV1.asgToRefAdr->V[];
           'asgToRef2'->mch.comment;
        #);
      strucRef::<  
        (# 
        do (if stest then
               301->ctrace(#
                          do 'assignValToVal:strucRef:'->xT; EV[] -> xA
                          #);
           if);
           (baseAdr.copy,EV[],chain1[])->lEV1.asgToRefAdr->V[] 
        #);
      computedObj::< (#do 'Assign to Computed Obj'->notImpl #); 
      repOp::<
        (# isExtend,isValueRep,isStaticItem,isBoolRep: @boolean;
           size: @integer;
           RN,RN1,sort,ElmDesc: @ASTindex; A: ^mch.address; pop: @boolean  ;
           c: @char; T: @text; MN,isVirt,evalK: @integer; old61: @boolean
        do (if stest then 301->cTrace(#do 'AsgToRepOp: '->xT; EV[]->xA#)if);
           EV.son->RN; RN.son->RN1;  
           (baseAdr.copy,RN1[],false,chain1[])->GenAdr->A[];
           (if (RN[]->semAtt.repAttId)
            // 2 (* new *) then  
            // 3 (* extend *) then  true -> isExtend
            else 'Illegal RepOp in E->repOp' -> bugstream.putline
           if);
           RN1 -> sematt.SimpleOrRepA -> sort;
           (if sort.label -> EvalK
            // gram.dynamicItem
            // gram.dynamicComponent
            // gram.variablePattern then
               false -> isValueRep
            // gram.staticItem then
               true -> isValueRep;
               true -> isStaticItem;
               sort.son -> RN1; (*  R: [..] @ RN1 *)
               RN1 -> sematt.descrip -> RN1;
               RN1.size -> size;  
               (if RN1.label = gram.objectDescriptor then
                   (sematt.boolDesc -> RN1.equal) -> isBoolRep
               if)
            // gram.staticComponent then
               true -> isValueRep;
           if);
           (chain1[],RN1) -> DH.theDescForm -> (elmDesc,MN,chain1[],isVirt);
           (elmDesc[],A[],isExtend,isValueRep,isStaticItem,size,isBoolRep,false)
             -> gen.NewRep
           (# genRange:: 
                (# V: ^evVal
                do (if switch182 then
                       lEV1.pushVal -> V[];
                       (if V.evType = 3 (* real *) then
                           (&mch.floatRegOp[],&mch.dataRegOperand[]) 
                             -> mch.float2int
                       if)
                    else
                       3 -> lEV1.toPrimDest
                   if)
                #)
           #)
        #);             
      cProcDesc::<
        (#
        do (EV[],CallId[],desc[],extKind)->lEV1.asgToCproc->V[]
        #);
      externalVirtual::
        (# isInCOM: booleanValue
             (# E: @ASTindex; T: ^text
             enter E
             do E.son -> E;
                (if E.label = gram.remote then
                    E -> sematt.getname -> E;
                    E.gettext -> T[];
                    (if true
                     // 'queryInterface' -> T.equalNCS 
                     // 'addRef' -> T.equalNCS 
                     // 'deleteRef' -> T.equalNCS 
                     // 'getIdsOfNames' -> T.equalNCS  
                     // 'invoke' -> T.equalNCS  then
                        true -> value
                     else
                        false -> value
                    if)
                 else
                    true -> value
             if)#);
        do (if stest then
               301->cTrace(#do 'AssignTo externalVkind:'->XT #)
           if);
           (if (extKind = sematt.dispatchVirtualKind)
               and not(EV -> isInCOM) then
               (EV[],'::DISPATCH::',desc[],extKind) -> lEV1.asgToDispatch -> V[]
            else
               sematt.virtExt -> extKind;           
               (EV[],'::VDT::',desc[],extKind)->lEV1.asgToCproc->V[]
           if)
        #);
      newRemotePrim::
        (#
        do (if stest then 301->cTrace(#do 'newRemotePrim: '-> xT#) if);
           (baseAdr.copy,EV[],chain1[])->lEV1.asgToNewPrim->V[] ;
           (if stest then
               301->cTrace(#
                          do 'newRemotePrim:2 '-> xT; 
                             (if V[]=none then
                                 'Prim: NONE ' -> xt;
                             if)
           #)if);
        #);
      primitive::<
        (#
        do (if stest then
               301->cTrace(#do 'primitive:'->xT; EV[]->xA #)
           if);
           EV->SemAtt.ParsePrimitive
           (# ExternalOp::<
                (#
                do (if OpTxt.empty//false then OpTxt[]->lEV1.asgToPrimitive->V[] if)
                #);
              InLineOp::<
                (#
                do (if stest then
                       301->ctrace(#do 'InlineOp:'->xT; lEV1.display #)
                   if);
                   (OpCode,I1,I2)->lEV1.asgToInLinePrimitive->V[] 
                #)
        #)#);(* primitive*)
      assign::<
        (# 
        do (if stest then
               302->ctrace(#
                          do 'assignValToEval:assign:A'->xH;
                             lEV1.display; xN;
                             EV1[] -> xA; xN;
                             baseAdr.display->xT
           #)if);
           '!assignValToEval:assign:'->mch.comment;
           (* EV  = E1 -> E2 -> ... -> En-1 -> En
            * EV1 = E1 -> E2 -> ... -> En-1 
            * EV2 = En
            *)
           (if switch182 then
               (* we only come here fra genEnterMethod through
                * asgToNelm
                *)
               (baseAdr.copy,EV1[],chain1[],false,lEV1[]) 
                 -> EH.methodArgs 
                 -> V[]
            else
               (if switch181 then
                   (baseAdr[],lEV1[],EV1[],doExit,chain1[])
                     -> EH.AssignValToEval
                     -> V[];
                else
                   (baseAdr.copy,lEV1[],EV1[],true(*doExit*),chain1[])
                     -> EH.AssignValToEval
                     -> V[];
           if)if);
           (if stest then
               302->ctrace(#
                          do 'assignValToEval:assign:B'->xH;
                             V.display; xN;
                             EV2[] -> xA; xN;
                             baseAdr.display->xT
           #)if); 

           (if switch181 then
               (baseAdr[],V[],EV2[],doExit,chain1[])
                 -> EH.AssignValToEval
                 -> V[]
            else
               (baseAdr.copy,V[],EV2[],doExit,chain1[])
                 -> EH.AssignValToEval
                 -> V[]
           if);
           (if stest then
               302->ctrace(#
                          do 'assignValToEval:assign:C'->xH; 
                             (if V[] =none then 'V is none'->xT;
                              else
                                 V.display
                             if);
                             xN;
                             baseAdr.display->xT
           #)if);
        #)
   #);
   V[]->RV[];
   (if stest then
       302->ctrace(#
                  do 'assignValToEval:exitEval:'->xH; 
                     (if RV[]=none then 'RV is none' -> xT 
                      else
                         RV.display
                     if);
                     xN;
                     'baseAdr:'->xT; baseAdr.display->xT;
   #)if)
                    
#)
---boolExpEval:doPart---
   (* (if EV is true then
    *     (if jmpCond then goto lab else continue if)
    * else 
    *     (if jmpCond then continue else goto lab if)
    * if)
    *)
do (if stest then
       301->cTrace(#do 'BoolExp:'->xT; EV[]-> xA#)
   if);
   (# lv,rv: ^evVal; dr,dr1,dr2: ^ mch.dataRegOperand; EV1,EV2: @ASTindex;
      cond,binType: @integer;
      cmpAndJmp:
        (#
        do select:
             (if V.evType//-1 then 
                 (* V is itemEval, exit elm must be computed *)
                 V.loadVal->V[];
                 restart select
              // 0 then
                 'OBS evtype is zero'->bugstream.putline
             if);
           V.toDataReg->dr[];
           (dr,false,false,false)->mkComputedEvVal->V[];
           (if jmpCond then
               (lab[],common.cond_ne)->V.cmpBoolAndJmp
            else
               (lab[],common.cond_eq)->V.cmpBoolAndJmp
           if)

        #);
      E: @ASTindex;
      xLab: @mch.localLab;
      theCond:
        (#
        do (if jmpCond then
               (if ev.label
                // gram.eqExp then 1->cond
                // gram.neExp then 2->cond
                // gram.ltExp then 3->cond
                // gram.leExp then 4->cond
                // gram.gtExp then 5->cond
                // gram.geExp then 6->cond
               if)
            else
               (if ev.label
                // gram.eqExp then 2->cond
                // gram.neExp then 1->cond
                // gram.ltExp then 6->cond
                // gram.leExp then 5->cond
                // gram.gtExp then 4->cond
                // gram.geExp then 3->cond
           if)if);
        #);
      nilTst:
        (# c: @char
        enter C
        do (*306->cTrace
            (#do C->put;
            (if lv[]=none then 'lv is nil'->T else 'lv is NOT nil'->T if);
            (if rv[]=none then 'rv is nil'->T else 'rv is NOT nil'->T if)
            #)*)
        #);
      lx: ^EvVal
   do (if switch182 then true -> doExit if);
      EvCase:
        (if EV.label
         // gram.evalList then
            elim: EV.son->scanList
            (# N: @integer
            do currentNode->E; N+1->N;
               (if N=2 then 
                   (baseAdr.copy,EV[],doExit,EHchain[])->ExpEval->V[];
                   cmpAndJmp;
                   leave EvCase

            if)#);
            E[]->EV[];
            restart EvCase
         // gram.andExp then
            EV.son->EV1; EV1.brother->EV2;
            (if jmpCond then
                (*     <EV1>
                 *     jmpFalse Lx
                 *     <EV2>
                 *     jmpTrue L
                 * Lx: ...
                 * L:  ...
                 *)
                xLab.new;
                (baseAdr.copy,EV1[],doExit,EHChain[],xLab[],false)
                  ->BoolExpEval->lv[];
                lv.release;
                'X'->nilTst;
                (baseAdr.copy,EV2[],doExit,EHChain[],lab[],true)
                  ->BoolExpEval->Rv[];
                'Y'->nilTst;
                xLab.def
             else
                (*     <EV1>
                 *     jmpFalse L
                 *     <EV2>
                 *     jmpFalse L
                 *     ...
                 * L:  ...
                 *)
                (baseAdr.copy,EV1[],doExit,EHChain[],lab[],false)
                  ->BoolExpEval->lv[];
                lv.release;
                'Z'->nilTst;
                (baseAdr.copy,EV2[],doExit,EHChain[],lab[],false)
                  ->BoolExpEval->Rv[];
                'V'->nilTst;
            if);

            rv[]->V[] (*??*)
         // gram.orExp then
            EV.son->EV1; EV1.brother->EV2;
            (if jmpCond then
                (*     <EV1>
                 *     jmpTrue L
                 *     <EV2>
                 *     jmpTrue L
                 *     ...
                 * L:  ...
                 *)

                (baseAdr.copy,EV1[],doExit,EHChain[],lab[],true)
                  ->BoolExpEval->lv[];
                lv.release;
                (baseAdr.copy,EV2[],doExit,EHChain[],lab[],true)
                  ->BoolExpEval->Rv[];
             else
                (*     <EV1>
                 *     jmpTrue Lx
                 *     <EV2>
                 *     jmpFalse L
                 * Lx: ...
                 * L:  ...
                 *)
                xLab.new;
                (baseAdr.copy,EV1[],doExit,EHChain[],xLab[],true)
                  ->BoolExpEval->lv[];
                lv.release;
                (baseAdr.copy,EV2[],doExit,EHChain[],lab[],false)
                  ->BoolExpEval->Rv[];
                xLab.def;
            if);

            rv[]->V[] (*??*)
         // gram.notExp then
            EV.son->EV1;
            (baseAdr.copy,EV1[],doExit,EHChain[],lab[],not jmpCond)
              ->BoolExpEval->V[]
         // gram.eqExp 
         // gram.neExp 
         // gram.ltExp 
         // gram.leExp
         // gram.gtExp
         // gram.geExp then
            EV.son->EV1; EV1.brother->EV2;
            (baseAdr.copy,EV1[],doExit,EHChain[])->ExpEval->lv[];
            (if switch182 then true -> lv.pushVal -> lv[] if);
            
            (* 16.7.98: FIX for 
             *   (if (c1->ascii.lowCase) <> (c2 -> ascii.lowCase)
             *)
            (if lv.evType = -1 then
                (* This makes part of coerceType superflous *)
                lv[] -> lx[];
                lv.loadVal -> lv[] (* remember the itemEv
                                    * for possible release*) 
            if);
            (if lv.evType = 1 then
                lv.loadVal2 -> lv[];
                (if lx[] <> NONE then lx.release if)
            if);
            (* end fix *)
            (baseAdr.copy,EV2[],doExit,EHChain[])->ExpEval->Rv[];
            (lv[],Rv[])->CoerceTypes->(lv[],rv[],binType);
            (if binType
             // 1 (*simple types*) // 2 (* ref *) then
                theCond;
                lv.loadVal2->lv[]; 
                lv.toDataReg->dr1[];
                rv.loadVal2->Rv[]; 
                Rv.toDataReg->dr2[];
                (* confusing order of dr1,dr2!*)
                (cond,dr2[],dr1[],4,lab[],(binType=2))->mch.cmpAndJmp;
                (* lv.release; - done in toDataReg! 
                 * rv.release; - done in toDataReg! 
                 * OBS! rv[] should not be used aymore *)
                dr1.deAlloc; dr2.deAlloc;
                true->lv.released->rv.released; 
                (* ugly, but a subsequent V.release will create a dataReg 
                 * negative since we have already deallocated dr2.
                 * We could return a computedEvVal with dr2
                 *)
                rv[]->V[];
             // -2 (*ref*) then
                (if ev.label
                 // gram.plusExp then lv[]->rv.add->V[]
                 // gram.minusExp then lv[]->rv.sub->V[]
                 // gram.orExp then lv[]->rv.orr->V[]
                 // gram.timesExp then lv[]->rv.times->V[]
                 // gram.intDivExp then (lv[],true)->rv.divMod->V[]
                 // gram.modExp then (lv[],false)->rv.divMod->V[]
                 // gram.andExp then lv[]->rv.andd->V[]
                 // gram.eqExp then (lv[],gram.eqExp,true,0,NONE)->rv.cmp->V[]
                 // gram.neExp then (lv[],gram.neExp,true,0,NONE)->rv.cmp->V[]
                 // gram.ltExp then (lv[],gram.ltExp,true,0,NONE)->rv.cmp->V[]
                 // gram.leExp then (lv[],gram.leExp,true,0,NONE)->rv.cmp->V[]
                 // gram.gtExp then (lv[],gram.gtExp,true,0,NONE)->rv.cmp->V[]
                 // gram.geExp then (lv[],gram.geExp,true,0,NONE)->rv.cmp->V[]
                 // gram.xorExp then
                    (* fast solution:
                     * loadVal2 ensures that lv/rv are in registers;
                     * toDataReg gets the registers;
                     * lv.release, rv.release freesthe registers below.
                     * toDataReg does NOT reuse the registers???
                     *)
                    (# lDr,rDr: ^mch.dataRegOperand
                    do lv.loadVal2->lv[]; lv.toDataReg->lDr[]; 
                       rv.loadVal2->rv[]; rv.toDataReg->rDr[];
                       rDr->rDr.reUse;
                       (lDr[],rDr[],4)->mch.gXor;
                       (rDr,false,false,false)->mkComputedEvVal->V[]
                    #)
                if);
                rv.release; lv.release;
                cmpAndJmp
             // 3 (* real *)  then
                (# fr1,fr2: ^mch.floatRegOp
                do theCond;
                   lv.loadFloat->fr1[]; (* op2 *)
                   rv.loadFloat->fr2[]; (* op1 *)
                   (cond,fr2[],fr1[],lab[],true)->mch.cmpAndJmpFloat;
                   (* In SUN4, MC68  (op2[],op1[])->cmpFloat is called
                    * On MC68, cmpFloat generates
                    *       fcmp.d  op2, op1
                    * and op1 can NOT be a floatRegisterOperand, but MUST
                    * be a memory location - at least the HP assembler 
                    * requires this
                    *)
                   lv.release; rv.release; 
                   fr1.deAlloc; fr2.deAlloc; (* 27/12/95*)
                   rv[]->V[] (* is it meaningful to return rv[] here? *)
                #)
             // 4 (* struc *) then
                (if ev.label
                 // gram.plusExp then (*lv[]->rv.rAdd->V[]*)
                 // gram.minusExp then (*lv[]->rv.rSub->V[]*)
                 // gram.orExp then (*lv[]->rv.orr->V[]*)
                 // gram.timesExp then (*lv[]->rv.times->V[]*)
                 // gram.intDivExp then (*(lv[],true)->rv.divMod->V[]*)
                 // gram.realDivExp then (*(lv[],true)->rv.divMod->V[]*)
                 // gram.modExp then (*(lv[],false)->rv.divMod->V[]*)
                 // gram.andExp then (*lv[]->rv.andd->V[]*)
                 // gram.eqExp then (lv[],gram.eqExp,true)->rv.sCmp->V[]
                 // gram.neExp then (lv[],gram.neExp,true)->rv.sCmp->V[]
                 // gram.ltExp then (lv[],gram.ltExp,true)->rv.sCmp->V[]
                 // gram.leExp then (lv[],gram.leExp,true)->rv.sCmp->V[]
                 // gram.gtExp then (lv[],gram.gtExp,true)->rv.sCmp->V[]
                 // gram.geExp then (lv[],gram.geExp,true)->rv.sCmp->V[]
                if);
                lv.release;rv.release;
                cmpAndJmp
            if)
         else
            (baseAdr.copy,EV[],doExit,EHchain[])->ExpEval->V[];
            cmpAndJmp
        if)
   #)
   
