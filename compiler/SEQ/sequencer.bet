origin '~beta/guienv/guienv';
include '~beta/sysutils/objinterface';
include 'boxes';
BUILD ppcmac  ':$$:objtrace.obj' 'objtrace.c'  'mrc -w 35 -o $0 $1'
      nti     '$$/objtrace.obj'  'objtrace.c'  'betacc $0 $1'
      default '$$/objtrace.o'    'objtrace.c'  '\$CC -c -o $0 $1'
---lib:attributes---
MetaObject:
  (# obj, 
     origin: ^object;
     ptnId: ^text;
     proto: @prototype;
  enter obj[]
  do obj[] -> getProtoType -> proto;
     obj[] -> getOrigin -> origin[];
     proto.labId -> ptnId[];
  exit this(MetaObject)[]
  #);
CallSequence:
  (# inittrace: external
       (# call: ##bCall; return: ##bReturn
       enter(call##,return##)
       #);
     bCall: external
       (# objAdr: @integer;
          obj: ^object
       enter objAdr
       do cExternalEntry;
          (objAdr) %putLongAt (@@obj);
          (*'bCall: ' -> puttext; objadr -> putint; newline ;*)
          obj[] -> call
       #);
     bReturn: external
       (# objAdr: @integer;
          obj: ^object
       enter objAdr
       do cExternalEntry;
          (objAdr) %putLongAt (@@obj);
          (*'bReturn: ' -> puttext; objadr -> putint; newline ;*)
          obj[] -> return
       #);     
     trace: external
       (# on: @boolean
       enter on  
       #);
     traceCall: external (* calls generated by compiler *)
       (# objAdr: @integer
       enter objAdr
       #);  
     traceReturn: external (* calls generated by compiler *)
       (# objAdr: @integer
       enter objAdr
       #);

     stack: [10] ^object; top: @integer;
     call:
       (# opr: ^object; 
       enter opr[]
       do (if (top+1 -> top) > stack.range then
              stack.range -> stack.extend
          if);
          opr[] -> stack[top][];
          (if (sTop+1->sTop) > sequence.range then
              sequence.range -> sequence.extend
          if);
          (opr[],stack[top-1][]->getOrigin,opr[]->GetCallSeq) 
            -> CallElm
            -> sequence[sTop][]
       #);
     return:
       (# opr: ^object
       enter opr[]
       do (if (sTop+1->sTop) > sequence.range then
              sequence.range -> sequence.extend
          if);
          opr[] -> ReturnCall -> sequence[sTop][];
          top - 1 -> top
       #);
     sequence: [10]^aCallElm; sTop: @integer;
     display:
       (#
       do 'Sequence:'->putline;
          (for i: sTop repeat
               sequence[i].display
          for)
       #);
     scan:
       (# current: ^ aCallElm;
          whenClass:<
            (# current: ^callElm
            enter current[]
            do inner
            #);
          whenReturn:<
            (# current: ^ ReturnCall
            enter current[]
            do
               inner
            #);
       do (for i: sTop repeat
               sequence[i][] -> current[];
               (if current##
                // CallElm## then
                   current[] -> whenClass
                // ReturnCall## then
                   current[] -> whenReturn
               if);
               inner
          for)
       #);
     init:<
       (# main: ^object
       enter main[]
       do main[] -> stack[1->top][];
          (bCall##,bReturn##) -> inittrace;
       #)
     
  #);
aCallelm:
  (# opr: ^object;
     oprMeta,fromMeta: @MetaObject;
     display:< (# do inner #);
  enter opr[]
  do opr[]-> oprMeta;
     opr[]->getOrigin -> fromMeta;
     inner
  exit this(aCallElm)[]
  #);
CallElm: aCallElm
  (# from,to: ^object;
     fromMeta,toMeta: @MetaObject;
     display::<
       (# 
       do 'Call by\t' -> puttext;
          fromMeta.ptnId[] -> puttext;
          '\tusing:\t' -> puttext; oprMeta.ptnId[] -> puttext;
          '\tto\t'->puttext; tometa.ptnId[]->putline
       #)
  enter(from[],to[])
  do from[] -> frommeta;
     to[] -> toMeta;          
  #);
ReturnCall: aCallElm
  (# display::<
       (# 
       do 'Return:\t' -> puttext;
          oprMeta.ptnId[] -> puttext;
          newline
       #);
  #);
GetCallSeq:
  (# obj: ^object;
     objMeta,originMeta: @MetaObject
  enter obj[]
  do obj[] -> objMeta;
     objMeta.origin[] -> originMeta;
     'Call:\t'->puttext;
     originMeta.ptnId[] -> puttext; '.' -> put;
     objMeta.ptnId[] -> puttext; newline;
  exit objMeta.origin[]
  #);
---guienvlib:attributes---
sequenceWindow: window
  (# showCall:
       (# current: ^CallElm; B1,B2: ^BoxWithText;
       enter current[]
       do current.fromMeta[] -> ShowClass -> B1[];
          current.toMeta[] -> ShowClass -> B2[];
          (B1[],B2[],current.oprMeta.ptnId[]) -> AddConn;
       #);
     showReturn:
       (# current: ^ReturnCall
       enter current[]
       do current.fromMeta[] 
            -> ShowClass
            -> AddCOnn.endCall;
       #);
     seq: @CallSequence;
     AddBox: @ NewBox;
     AddConn: @ NewConn;
     open::<
       (# 
       do (100, 100)->position;
          (600, 300)->size;
          'Sequence diagram'->title;
          AddBox.init;
          AddConn.init;
          INNER;
       #);
     eventhandler:: 
       (# onAboutToClose:: (# do terminate #); #);

     shown: [10] ^metaobject; top: @integer;
     box: [10] ^ BoxWithText;
     ShowClass: 
       (# objMeta: ^metaObject;
          B: ^ BoxWithtext;
       enter objMeta[]
       do L: (#
             do (for i: top repeat 
                     (if objMeta.obj[] = shown[i].obj[] then
                         box[i][] -> B[];
                         leave L
                     if);
                for);
                (if (top+1->top) > shown.range then
                    shown.range -> shown.extend
                if);
                objmeta[] -> shown[top][];
                objMeta.ptnId[] -> AddBox -> B[];
                B[] -> box[top][]
             #)
       exit B[]
       #);

  #);
SequenceCall:
  (# W: @SequenceWindow
       (# open::
            (#
            do seq.scan
               (# whenClass::
                    (# 
                    do current[] -> showCall
                    #);
                  whenReturn::
                    (# 
                    do current[] -> showReturn
                    #);
               #)
               
            #)
       #);
     call: ^object
  enter call[]
  do 'Executing:' -> putline;
     this(sequenceCall)[] -> W.seq.init;
     true -> W.Seq.trace;
     call;
     false -> W.Seq.trace;
     W.seq.display;
     W.open
  #)

