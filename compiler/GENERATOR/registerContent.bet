ORIGIN '../SYNTHESIZER/synthesizerbody';
LIB_ITEM 'betacodegen';
INCLUDE '../SYNTHESIZER/evlib';
---registerContentsRep:descriptor---
(# var:   [8] ^ASTindex; (* ref to nameDcl in dataReg[i] *)
   isConst: [8] @boolean;   (* const or register *)
   const: [8] @integer;
   reg:   [8] ^mch.dataRegOperand;
   top: @integer
#)
---registerContents:attributes---
assign: 
  (# ev: ^ASTindex; ND: @ASTindex; 
     R: @integer
  enter ev[]
  do (if (Rep.top+1 -> Rep.top) > Rep.var.range then
         Rep.var.range->R->Rep.var.extend;
         Rep.isConst.range->R->Rep.isConst.extend;
         Rep.const.range->R->Rep.const.extend;
         Rep.reg.range->R->Rep.reg.extend;
     if);
     EV.son->ND; ND.dclRef->ND;
     ND[]->Rep.var[Rep.top][];
     INNER;
     195->trace(#do 'assign:isConst='->xT; rep.isConst[rep.top]->xB; ND[]->xA#)
  #);
assignAsReg: assign
  (# dr: ^mch.dataRegOperand; 
  enter dr[]
  do dr[] -> Rep.reg[Rep.top][];
     false -> rep.isConst[rep.top]
  #);
assignAsConst: assign
  (# C: @integer
  enter C
  do C->rep.const[rep.top];
     true->rep.isConst[rep.top]
  #);
inReg:
  (# EV: ^ASTindex; ND: @ASTindex; EH: @Evalhandler; V: ^EH.EvVal;
     S: @text
  enter EV[]
  do 195->trace(#do 'InReg1:'->xT; rep.top->xI; ' '->put; EV[]->xA; #);
     EV.son->sematt.getName->ND; ND.dclRef->ND;
     L:
     (for i: Rep.top repeat
          (if ND->Rep.var[i].equal then 
              (if rep.isConst[i] then
                  rep.const[i]->EH.mkConstVal->V[];
                  'yes:isConst:'->S;
               else
                  (rep.reg[i],false,false,false)->EH.mkComputedEvVal->V[];
                  'yes:Reg:'->S;
              if);;
              leave  L
          if)
     for);
     195->trace(#do 'InReg2:'->xT; S[]->xT; ND[]->xA #);
  exit V[]
  #);
release: 
  (#
  do (for i: rep.top repeat false -> rep.isConst[i] for);
     0->rep.top 
  #);
     

         
