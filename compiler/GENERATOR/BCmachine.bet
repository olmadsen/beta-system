ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/sysutils/binarystream';
BODY 'BCmachineBody'
---lib:attributes---
BCmachine:
  (# thisO: (# exit 1 #);
     callO: (# exit 2 #);
     
     pushCst: (# exit 1 #);
     pushVal: (# exit 2 #);
     pushReg: (# exit 3 #);
     stVal: (# exit 4 #);
     index:(# exit 5 #);
     
     cmpAndJmp: (# exit 6 #);
     call: (# exit 7 #);
     return: (# exit 8 #);
     labelDef: (# exit 9 #);
     label: (# exit 10 #);
     callPrim: (# exit 11 #);
     
     entry: (# exit 12 #);
     end: (# exit 13 #);
     
     pushText: (# exit 14 #);
     pushAdr: (# exit 15 #);
     storeRef: (# exit 16 #);
     storeQref: (# exit 17 #);
     jmp: (# exit 18 #);
     
     func: (# exit 50 #);
     add: (# exit 51 #);
     sub: (# exit 52 #);
     orr: (#exit 53 #);
     andd: (# exit 54 #);
     xorr: (# exit 55 #);
     cmp: (# exit 56 #);
     mult: (# exit 57 #);
     divv: (# exit 58 #);
     modd: (# exit 59 #);
     nott: (# exit 60 #);
     logNot: (# exit 61 #); 
     neg: (# exit 62 #);


     astext:
       (# opCode: @integer; T : @text 
       enter opCode
       do (if opCode
           // pushCst then 'pushCst'->T
           // pushVal then 'pushVal' -> T
           // pushReg then 'pushReg' -> T
           // stVal then 'stVal' -> T
           // index then 'index'->T
           // cmpAndJmp then 'cmpAndJmp' -> T
           // call then 'call'->T
           // return then 'return\n'->T
           // label then 'L'->T
           // callPrim then 'callPrim' -> T
           // end then 'end'->T
           // pushText then 'pushText'->T
           // pushAdr then 'pushAdr'->T
           // storeRef then 'storeRef'->T
           // storeQref then 'storeQref'->T
           // jmp then 'jmp'->T
              
           // func then 'FUNC'->T
           // add then 'add' -> T
           // sub then 'sub' -> T
           // orr then 'or'->T
           // andd then 'and'->T
           // xorr then 'xor'->T
           // cmp then 'cmp'->T
           // mult then 'mult'->T
           // divv then 'div'->T
           // modd then 'mod'->T
           // nott then 'not'->T
           // logNot then 'logNot' -> T
           // neg then 'neg' -> T
           else
              '?'->T; opCode->T.putint; '?'->T.put
          if)
       exit T[]
       #);
     
     dump:
       (# dumpReg:
            (#
            do '%'->put;
               (if BC.get
                // thisO then 'this' ->puttext
                // callO then 'call'->puttext
                else 
                   'top'->puttext
               if);
            #);
          dumpAdr:
            (#
            do dumpReg;
               '('->put; BC.get -> putint; ')s='->puttext;
               BC.get -> putint
                   
            #);
          opCode: @integer
       do read:
            (if opCode <> end then
                BC.get -> opCode;
                (if opCode 
                 // entry then
                    BC.gettext->puttext; ':'->put;
                 // labelDef then 
                    'L'->put;
                 else
                    '\t'->put ;
                    opCode -> asText ->puttext; 
                    '\t' ->put;
                if);
                (if opCode 
                 // labelDef then BC.get->putint; ':'->put; '\t'->put
                 // pushCst then BC.get -> putint
                 // pushAdr
                 // pushVal then dumpAdr
                 // pushReg then dumpReg
                 // stVal then dumpAdr
                 // pushText
                 // call then BC.gettext -> puttext
                 // callPrim then BC.getText -> puttext
                 // jmp 
                 // cmpAndJmp then BC.get->asText->puttext; BC.get->putint;
                 // func then BC.get -> asText -> puttext

                if);
                newline;
                restart read
            if)
       #);
     
     emitDotNet: (# <<SLOT emitDotNet:doPart>> #);
     
     save:
       (# name: ^text
       enter name[]
       do name[]->BC.save
       #);
     
     restore:
       (# name: ^text
       enter name[]
       do name[]->BC.restore
       #);
     
     
     BC: @BinaryStream
  #)
