ORIGIN '~beta/basiclib/betaenv';

--LIB:attributes--

(*
 * sparc.bet:
 *   Patterns used to model the sparc registers and instructions.
 *   The comments refer to sections in "The SPARC Architecture Manual,
 *   Version 8", SPARC International Inc, Prentice Hall 1992, 
 *   ISBN 0-13-825001-4.
 *)


(* Chapter 4: Register numbers *)

g0: (* %g0 *) (# exit 0 #);
g1: (* %g1 *) (# exit 1 #);
g2: (* %g2 *) (# exit 2 #);
g3: (* %g3 *) (# exit 3 #);
g4: (* %g4 *) (# exit 4 #);
g5: (* %g5 *) (# exit 5 #);
g6: (* %g6 *) (# exit 6 #);
g7: (* %g7 *) (# exit 7 #);

l0: (* %l0 *) (# exit 16 #);
l1: (* %l1 *) (# exit 17 #);
l2: (* %l2 *) (# exit 18 #);
l3: (* %l3 *) (# exit 19 #); 
l4: (* %l4 *) (# exit 20 #);
l5: (* %l5 *) (# exit 21 #);
l6: (* %l6 *) (# exit 22 #);
l7: (* %l7 *) (# exit 23 #);

o0: (* %o0 *) (# exit 8 #);
o1: (* %o1 *) (# exit 9 #);
o2: (* %o2 *) (# exit 10 #);
o3: (* %o3 *) (# exit 11 #);
o4: (* %o4 *) (# exit 12 #);
o5: (* %o5 *) (# exit 13 #);
o6: (* %o6 *) (# exit 14 #);
sp: (* %sp *) (# exit O6 #);
o7: (* %07 *) (# exit 15 #);

i0: (* %i0 *) (# exit 24 #);
i1: (* %i1 *) (# exit 25 #);
i2: (* %i2 *) (# exit 26 #);
i3: (* %i3 *) (# exit 27 #);
i4: (* %i4 *) (# exit 28 #);
i5: (* %i5 *) (# exit 29 #);
fp: (* %fp (frame pointer) *) (# exit 30 #);
i7: (* %i7 (return address) *) (# exit 31 #);

(* 4.3 FPU registers *)

f0 : (* %f0  *) (# exit 0  #);
f1 : (* %f1  *) (# exit 1  #);
f2 : (* %f2  *) (# exit 2  #);
f3 : (* %f3  *) (# exit 3  #);
f4 : (* %f4  *) (# exit 4  #);
f5 : (* %f5  *) (# exit 5  #);
f6 : (* %f6  *) (# exit 6  #);
f7 : (* %f7  *) (# exit 7  #);
f8 : (* %f8  *) (# exit 8  #);
f9 : (* %f9  *) (# exit 9  #);
f10: (* %f10 *) (# exit 10 #);
f11: (* %f11 *) (# exit 11 #);
f12: (* %f12 *) (# exit 12 #);
f13: (* %f13 *) (# exit 13 #);
f14: (* %f14 *) (# exit 14 #);
f15: (* %f15 *) (# exit 15 #);
f16: (* %f16 *) (# exit 16 #);
f17: (* %f17 *) (# exit 17 #);
f18: (* %f18 *) (# exit 18 #);
f19: (* %f19 *) (# exit 19 #);
f20: (* %f20 *) (# exit 20 #);
f21: (* %f21 *) (# exit 21 #);
f22: (* %f22 *) (# exit 22 #);
f23: (* %f23 *) (# exit 23 #);
f24: (* %f24 *) (# exit 24 #);
f25: (* %f25 *) (# exit 25 #);
f26: (* %f26 *) (# exit 26 #);
f27: (* %f27 *) (# exit 27 #);
f28: (* %f28 *) (# exit 28 #);
f29: (* %f29 *) (# exit 29 #);
f30: (* %f30 *) (# exit 30 #);
f31: (* %f31 *) (# exit 31 #);

(* Section 5.2: Instruction Formats *)

format1: 
  (* Call *)
  (# imm30: @integer
  enter imm30
  #);

format2:
  (* sethi  and  branches *)
  (# rd, imm22: @integer;
  enter (rd, imm22)
  #);

format3:
  (* Remaining instructions *)
  (# rd, rs1, rs2: @integer;
  enter (rs1, rs2, rd)
  #);

format3i:
  (* Remaining instructions, immediate operand *)
  (# rd, rs1, imm13: @integer;
  enter (rs1, imm13, rd)
     (* do (if ((imm13 %band 0xfffff000)<>0) and
      *          ((imm13 %band 0xfffff000)<>0xfffff000) then 
      *          'Illegal 13 bit constant: '->screen.puttext; 
      *          imm13 -> screen.putint;
      *          screen.newline;
      *      if)
      *)
  #);


(* Appendix B: Instruction definitions *)


(* B.1 Load integer instructions *)

ld: format3	
  (# exit  0xc0000000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ld_i: format3i	
  (# exit  0xc0002000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
ldub: format3	
  (# exit  0xc0080000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldub_i: format3i	
  (# exit  0xc0082000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
ldsb: format3	
  (# exit  0xc0480000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldsb_i: format3i	
  (# exit  0xc0482000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
lduh: format3	
  (# exit  0xc0100000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
lduh_i: format3i	
  (# exit  0xc0102000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
ldsh: format3	
  (# exit  0xc0500000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldsh_i: format3i	
  (# exit  0xc0502000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
ldd: format3	
  (# exit  0xc0180000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldd_i: format3i	
  (# exit  0xc0182000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.2 Load floating point instructions *)
ldf: format3	
  (# exit  0xc1000000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldf_i: format3i	
  (# exit  0xc1002000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
lddf: format3	
  (# exit  0xc1180000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
lddf_i: format3i	
  (# exit  0xc1182000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.3 Load Coprocessor instructions *)


(* B.4 store integer instructions *)

st: format3	
  (# exit  0xc0200000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
st_i: format3i	
  (# exit  0xc0202000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
stb: format3	
  (# exit  0xc0280000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
stb_i: format3i	
  (# exit  0xc0282000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
sth: format3	
  (# exit  0xc0300000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
sth_i: format3i	
  (# exit  0xc0302000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
std: format3	
  (# exit  0xc0380000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
std_i: format3i	
  (# exit  0xc0382000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.5 Store Floating Point instructions *)
stf: format3 
  (# exit  0xc1200000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
stf_i: format3 
  (# exit  0xc1202000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
stdf: format3	
  (# exit  0xc1380000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
stdf_i: format3i	
  (# exit  0xc1382000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.6 Store Coprocessor Instructions *)


(* B.7 Atomic Load-Store Unsigned Byte Instructions *)
ldstub: format3	
  (# exit  0xc0680000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
ldstub_i: format3i	
  (# exit  0xc0682000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);

(* B.8 Swap register with memory instruction *)
swap: format3	
  (# exit  0xc0780000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
swap_i: format3i	
  (# exit  0xc0782000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.9 sethi instruction *)

hi: 
  (* extract high part of operand *)
  (# word: @integer enter word exit (word %srl 10) #);
lo: 
  (* extract low part of operand *)
  (# word: @integer enter word exit (word %band 0x3ff) #);
sethi: format2
  (# exit 0x01000000 %bor (rd %sll 25) %bor imm22 #);


(* B.10 nop instruction *)

xnop: format2
  (# exit 0x01000000 #);


(* B.11 logical instructions *)

sparc_and: format3	 
  (# exit  0x80080000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
and_i: format3i	 
  (# exit  0x80082000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
andcc: format3  
  (# exit  0x80880000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
andcc_i: format3i	 
  (# exit  0x80882000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
andn: format3	 
  (# exit  0x80280000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
andn_i: format3i	 
  (# exit  0x80282000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
andncc: format3 
  (# exit  0x80a80000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
andncc_i: format3i 
  (# exit  0x80a82000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
sparc_or: format3	 
  (# exit  0x80100000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
or_i: format3i	 
  (# exit  0x80102000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
orcc: format3	 
  (# exit  0x80900000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
orcc_i: format3i	 
  (# exit  0x80902000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
sparc_xor: format3	 
  (# exit  0x80180000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
xor_i: format3i	 
  (# exit  0x80182000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
xorcc: format3	 
  (# exit  0x80980000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
xorcc_i: format3i	 
  (# exit  0x80982000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
xnor: format3	 
  (# exit  0x80380000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
xnor_i: format3i	 
  (# exit  0x80382000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
xnorcc: format3 
  (# exit  0x80b80000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
xnorcc_i: format3i 
  (# exit  0x80b82000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.12 shift instructions *)

sll: format3	
  (# exit  0x81280000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
sll_i: format3i	
  (# exit  0x81282000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
srl: format3	
  (# exit  0x81300000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
srl_i: format3i	
  (# exit  0x81302000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
sra: format3	
  (# exit  0x81380000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
sra_i: format3i	
  (# exit  0x81382000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.13 add instructions *)

add: format3	
  (# exit  0x80000000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
add_i: format3i	
  (# exit  0x80002000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
addcc: format3	
  (# exit  0x80800000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
addcc_i: format3i	
  (# exit  0x80802000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
addx: format3	
  (# exit  0x80400000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
addx_i: format3i	
  (# exit  0x80402000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
addxcc: format3 
  (# exit 0x80c00000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
addxcc_i: format3i 
  (# exit 0x80c02000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.14 Tagged add instructions *)
taddcc: format3	
  (# exit  0x81000000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
taddcc_i: format3i	
  (# exit  0x81002000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
taddcctv: format3	
  (# exit  0x81100000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
taddcctv_i: format3i	
  (# exit  0x81102000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.15 subtract instructions *)

sub: format3	
  (# exit  0x80200000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
sub_i: format3i	
  (# exit  0x80202000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
subcc: format3	
  (# exit  0x80a00000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
subcc_i: format3i	
  (# exit  0x80a02000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
subx: format3	
  (# exit  0x80600000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
subx_i: format3i	
  (# exit  0x80602000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.16 Tagged subtract instructions *)
tsubcc: format3	
  (# exit  0x81080000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
tsubcc_i: format3i	
  (# exit  0x81082000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
tsubcctv: format3	
  (# exit  0x81180000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
tsubcctv_i: format3i	
  (# exit  0x81182000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.17 Multiply step instruction *)


(* B.18 Multiply instructions - sparc v8 only! *)

umul: format3 	
  (# exit 0x80500000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
umul_i: format3i 	
  (# exit 0x80502000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
smul: format3 	
  (# exit 0x80580000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
smul_i: format3i 	
  (# exit 0x80582000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.19 Divide instructions - sparc v8 only! *)

udiv: format3 	
  (# exit 0x80700000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
udiv_i: format3i 	
  (# exit 0x80702000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
sdiv: format3 	
  (# exit 0x80780000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
sdiv_i: format3i 	
  (# exit 0x80782000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.20 Save and restore instructions *)

save: format3	  
  (# exit  0x81e00000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
save_i: format3i	  
  (# exit  0x81e02000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);
restore: format3 
  (# exit  0x81e80000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
restore_i: format3i 
  (# exit  0x81e80200 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.21 branch on integer condition codes instructions *)

bicc: format2
  (# exit  0x00800000 %bor (rd %sll 25) %bor (imm22 %band 0x3fffff) #);
bicc_a: format2	
  (# exit  0x20800000 %bor (rd %sll 25) %bor (imm22 %band 0x3fffff) #);

(* condition constants *)
sparc_cond_always: (# exit 8 #);
sparc_cond_never: (# exit 0 #);
sparc_cond_ne: (# exit 9 #);
sparc_cond_eq: (# exit 1 #);
sparc_cond_gt: (# exit 10 #);
sparc_cond_le: (# exit 2 #);
sparc_cond_ge: (# exit 11 #);
sparc_cond_lt: (# exit 3 #);
sparc_cond_gtu: (# exit 12 #);
sparc_cond_leu: (# exit 4 #);
sparc_cond_geu: (# exit 13 #);
sparc_cond_ltu: (# exit 5 #);
sparc_cond_pos: (# exit 14 #);
sparc_cond_neg: (# exit 6 #);
sparc_cond_vc: (# exit 15 (* overflow clear *) #);
sparc_cond_vs: (# exit 7  (* overflow set *) #);

branch_alias: 
  (# imm22: @integer (* distance to branch *)
  enter imm22
  #);
     
ba:     branch_alias(# exit (sparc_cond_always, imm22) -> bicc #);
bn:     branch_alias(# exit (sparc_cond_never, imm22) -> bicc #);
bne:    branch_alias(# exit (sparc_cond_ne, imm22) -> bicc #);
be:     branch_alias(# exit (sparc_cond_eq, imm22) -> bicc #);
bgt:    branch_alias(# exit (sparc_cond_gt, imm22) -> bicc #);
ble:    branch_alias(# exit (sparc_cond_le, imm22) -> bicc #);
bge:    branch_alias(# exit (sparc_cond_ge, imm22) -> bicc #);
blt:    branch_alias(# exit (sparc_cond_lt, imm22) -> bicc #);
bgtu:   branch_alias(# exit (sparc_cond_gtu, imm22) -> bicc #);
bleu:   branch_alias(# exit (sparc_cond_leu, imm22) -> bicc #);
bgeu:   branch_alias(# exit (sparc_cond_geu, imm22) -> bicc #);
bcc:    branch_alias(# exit (sparc_cond_geu, imm22) -> bicc #);
bltu:   branch_alias(# exit (sparc_cond_ltu, imm22) -> bicc #);
bcs:    branch_alias(# exit (sparc_cond_ltu, imm22) -> bicc #);
bpos:   branch_alias(# exit (sparc_cond_pos, imm22) -> bicc #);
bneg:   branch_alias(# exit (sparc_cond_neg, imm22) -> bicc #);
bvc:    branch_alias(# exit (sparc_cond_vc, imm22) -> bicc #);
bvs:    branch_alias(# exit (sparc_cond_vs, imm22) -> bicc #);
ba_a:   branch_alias(# exit (sparc_cond_always, imm22) -> bicc_a #);
bn_a:   branch_alias(# exit (sparc_cond_never, imm22) -> bicc_a #);
bne_a:  branch_alias(# exit (sparc_cond_ne, imm22) -> bicc_a #);
be_a:   branch_alias(# exit (sparc_cond_eq, imm22) -> bicc_a #);
bgt_a:  branch_alias(# exit (sparc_cond_gt, imm22) -> bicc_a #);
ble_a:  branch_alias(# exit (sparc_cond_le, imm22) -> bicc_a #);
bge_a:  branch_alias(# exit (sparc_cond_ge, imm22) -> bicc_a #);
blt_a:  branch_alias(# exit (sparc_cond_lt, imm22) -> bicc_a #);
bgtu_a: branch_alias(# exit (sparc_cond_gtu, imm22) -> bicc_a #);
bleu_a: branch_alias(# exit (sparc_cond_leu, imm22) -> bicc_a #);
bgeu_a: branch_alias(# exit (sparc_cond_geu, imm22) -> bicc_a #);
bcc_a:  branch_alias(# exit (sparc_cond_geu, imm22) -> bicc_a #);
bltu_a: branch_alias(# exit (sparc_cond_ltu, imm22) -> bicc_a #);
bcs_a:  branch_alias(# exit (sparc_cond_ltu, imm22) -> bicc_a #);
bpos_a: branch_alias(# exit (sparc_cond_pos, imm22) -> bicc_a #);
bneg_a: branch_alias(# exit (sparc_cond_neg, imm22) -> bicc_a #);
bvc_a:  branch_alias(# exit (sparc_cond_vc, imm22) -> bicc_a #);
bvs_a:  branch_alias(# exit (sparc_cond_vs, imm22) -> bicc_a #);


(* B.22 Branch on floating point condition codes instructions *)

bfcc: format2
  (# exit  0x01800000 %bor (rd %sll 25) %bor (imm22 %band 0x3fffff) #);
bfcc_a: format2
  (# exit  0x21800000 %bor (rd %sll 25) %bor (imm22 %band 0x3fffff) #);

(* float specific condition constants *)
f_always: (# exit 8 #);
f_never: (# exit 0 #);
f_uo: (# exit 7 #);
f_gt: (# exit 6 #);
f_ug: (# exit 5 #);
f_lt: (# exit 4 #);
f_ul: (# exit 3 #);
f_lg: (# exit 2 #);
f_ne: (# exit 1 #);
f_eq: (# exit 9 #);
f_ue: (# exit 10 #);
f_ge: (# exit 11 #);
f_uge: (# exit 12 #);
f_le: (# exit 13 #);
f_ule: (# exit 14 #);
f_o: (# exit 15 #);

fba:      branch_alias(# exit (f_always, imm22) -> bfcc #);
fbn:      branch_alias(# exit (f_never, imm22) -> bfcc #);
fbu:      branch_alias(# exit (f_uo, imm22) -> bfcc #);
fbg:      branch_alias(# exit (f_gt, imm22) -> bfcc #);
fbug:     branch_alias(# exit (f_ug, imm22) -> bfcc #);
fbl:      branch_alias(# exit (f_lt, imm22) -> bfcc #);
fbul:     branch_alias(# exit (f_ul, imm22) -> bfcc #);
fblg:     branch_alias(# exit (f_lg, imm22) -> bfcc #);
xfbne:     branch_alias(# exit (f_ne, imm22) -> bfcc #);
fbe:      branch_alias(# exit (f_eq, imm22) -> bfcc #);
fbue:     branch_alias(# exit (f_ue, imm22) -> bfcc #);
xfbge:     branch_alias(# exit (f_ge, imm22) -> bfcc #);
fbuge:    branch_alias(# exit (f_uge, imm22) -> bfcc #);
xfble:     branch_alias(# exit (f_le, imm22) -> bfcc #);
fbule:    branch_alias(# exit (f_ule, imm22) -> bfcc #);
fbo:      branch_alias(# exit (f_o, imm22) -> bfcc #);

(* B.23 Branch on coprocessor condition codes instructions *)


(* B.24 call and link instruction *)

host_pc: 
  (* must exit the current location in the output buffer.
   * used to calculate relative address for call.
   *)
  (# exit 0 #);
call: format1
  (# exit 0x40000000 %bor ((imm30-host_pc) %srl 2) #);


(* B.25 jump and link instruction *)

jmpl: format3	
  (# exit  0x81c00000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
jmpl_i: format3i	
  (# exit  0x81c02000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.26 Return from trap instruction *)


(* B.27 trap on integer condition codes instructions *)

ticc_i: format3i	
  (# exit  0x81d02000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);

trap_alias:
  (# imm13: @integer enter imm13 #);

tle_i:  trap_alias(# exit (g0, imm13, sparc_cond_le) -> ticc_i #);
tge_i:  trap_alias(# exit (g0, imm13, sparc_cond_ge) -> ticc_i #);
(* other trap aliases like the one above could be made if needed *);


(* B.28 read state register *)

rdy: format3 
  (# exit 0x81400000 %bor (rd %sll 25) #);


(* B.29 write state register *)

wry: format3
  (# exit 0x81800000 %bor (rs1 %sll 14) %bor rs2  #);

wry_i: format3i 
  (# exit 0x81802000 %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);


(* B.30 stbar instruction *)
stbar: (# exit 0x8143c000 #);

(* B.31 unimplemented instruction *)

unimp: format2		
  (# exit imm22 %band 0x3fffff #);


(* B.32 Flush Instruction Memory *)
iflush: format3 
  (# exit  0x81d80000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
iflush_i: format3i 
  (# exit  0x81d82000 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor (imm13 %band 0x1fff)  #);

(* B.33 Floating Point Operate instructions *)

(* Convert Integer to Floating Point instructions *)
fitod: format3
  (# exit 0x81a01900 %bor (rd %sll 25) %bor rs2  #);

(* Convert floating point to integer instructions *)
fdtoi: format3
  (# exit 0x81a01a40 %bor (rd %sll 25) %bor rs2  #);

(* Floating point move instructions *)
fmovs: format3 
  (# exit 0x81a00020 %bor (rd %sll 25) %bor rs2  #);
fnegs: format3 
  (# exit 0x81a000a0 %bor (rd %sll 25) %bor rs2  #);

(* Floating point add and subtract instructions *)
faddd: format3
  (# exit 0x81a00840 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
fsubd: format3
  (# exit 0x81a008c0 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);

(* Floating point multiply and divide instructions *)
fmuld: format3
  (# exit 0x81a00940 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);
fdivd: format3
  (# exit 0x81a009c0 %bor (rd %sll 25) %bor (rs1 %sll 14) %bor rs2  #);

(* Floating point compare instructions *)
fcmpd: format3
  (# exit 0x81a80a40 %bor (rs1 %sll 14) %bor rs2  #);

(* B.34 Coprocessor Operate instructions *)




(* Pseudo Instructions *)

clr:
  (* clear register *)
  (# rd: @integer
  enter rd
  exit (0,rd) -> MOV_I
  #);
cmp:  
  (# rs1, rs2: @integer;
  enter (rs1, rs2)
  exit (rs1, rs2, g0) -> subcc
  #);
xcmp: 
  (# rs1, rs2: @integer;
  enter (rs1, rs2)
  exit (rs1, rs2, g0) -> subcc
  #);
cmp_i: 
  (# rs1, imm13: @integer;
  enter (rs1, imm13)
  exit (rs1, imm13, g0) -> subcc_i
  #);
mov:  
  (# rs1, rd: @integer;
  enter (rs1, rd)
  exit (g0, rs1, rd) -> sparc_or
  #);
mov_i: 
  (# rd, imm13: @integer;
  enter (imm13,rd)
  exit (g0, imm13, rd) -> or_i
  #);
tst: 
  (# rs1: @integer;
  enter rs1	
     (* exit (rs1, g0, g0) -> subcc *)
  exit (g0, rs1, g0) -> orcc (* datpete 19-9-95 *)
  #);
jmp: 
  (# rs1: @integer;
  enter rs1	
  exit (g0, rs1, g0) -> jmpl
  #);
sparc_not: 
  (# rs1, rd: @integer;
  enter (rs1, rd)
  exit (g0, rs1, rd) -> xnor
  #);
not_i: 
  (# imm13, rd: @integer;
  enter (imm13, rd)
  exit (g0, imm13, rd) -> xnor_i
  #);
notcc: 
  (# rs1, rd: @integer;
  enter (rs1, rd)
  exit (g0, rs1, rd) -> xnorcc
  #);
notcc_i: 
  (# imm13, rd: @integer;
  enter (imm13, rd)
  exit (g0, imm13, rd) -> xnorcc_i
  #);
ret: 
  (# exit (i7,8,g0) -> jmpl_i #);
retl:
  (# exit (o7,8,g0) -> jmpl_i #);
btst: 
  (* bit test *)
  (# rs1, mask: @integer;
  enter (rs1, mask)
  exit (rs1, mask, g0) -> andcc_i
  #);

(* set instruction: notice that it may be one or two instructions.
 * be carefull with branches.
 *)

set: 
  (# imm, rd: @integer;
     output: ^stream;
  enter (imm, rd, output[])
  do (if (imm %band 0x3ff)=0 then
         (* low 10 bits are 0 *)
         (imm-> hi, rd) -> sethi -> output.putint;;
      else
         (if ( (-4096 <= imm) and (imm <= 4095) ) then
             (* only low 13 bits used *)
             (imm, rd) -> mov_i -> output.putint; 
          else
             (imm-> hi, rd) -> sethi -> output.putint;
             (rd, imm-> lo, rd) -> or_i -> output.putint;
         if)
     if)
  #);

is_cti:
  (* test is instr is a control transfer instruction, including
   * Bicc, call, jmpl (includes call_register, jmp, ret, retl)
   *)
  (# instr: @integer;
     op:  (# exit (instr %srl 30) %Band 2x11 #);
     op2: (# exit (instr %srl 22) %Band 2x111 #);
     op3: (# exit (instr %srl 19) %Band 2x111111 #);
     res: @boolean;
  enter instr
  do (if op=2x01 then (* call *) 
         true->res;
     if);
     (if (op=2x10) and (op3=2x111000) then (* jmpl *) 
         true->res; 
     if);
     (if (op=2x00) and (op2=2x010) then (* Bicc *)
         (* FIXME: should test that it is NOT ba,a, which does
          * not execute delay slot, and is thus alowed to have
          * a CTI immediately following it.
          *)
         true->res;
     if);
  exit res
  #);
