ORIGIN 'machine';
INCLUDE '~beta/basiclib/textUtils'; 
INCLUDE '~beta/basiclib/formatio';
-- lib: Attributes --
IMtrace: (# exit true #); (* olm *)
isIntel: (# exit false #); (* olm *)
OriginReg: (#  exit 3 #);   
b2d:
  (# b:@boolean; d:@integer;
  enter b
  do (if b then 1->d if)
  exit d
  #);

---machineFactory:doPart---
do &ByteCodemachine[] -> mch[];
   
-- MachineFactoryLIB: Attributes --
ByteCodeMachine: abstractMachine
  (#
     <<SLOT ByteCodeMachinelib:attributes >>;
          regCount: @integer;
     FIXME: @
       (# init:
            (#
            do 'notUsed' -> msg[1][];
               'notUsed' -> msg[2][];
               'notUsed' -> msg[3][]; 
               'ChkIndex: size,isISmple,repAdr,toReg,index' -> msg[4][]; 
               'StackAlloPrim: stackCount,size,proto,s,t' -> msg[5][];
               '' -> msg[6][];
               'warn adrreg inuse called' -> msg[7][];
               'ChkIndex' -> msg[8][];
               'Endlabel (not used for sparc, but needed for MIPS)'
                 -> msg[9][];
            #);
          reported: [10] @boolean;
          msg: [10] ^text;
          no: @integer
       enter no
       do (if (1 <= no) and (no <= reported.range) then
              (if not reported[no] then 
                  '\n*** FIXME: ' -> puttext;              
                  msg[no][] -> putline 
              if);
              true-> reported[no];              
          if)
       #);
     
     lpl: logfile.putline (# #);
     logfile,optfile:@file;
     NewCtextOp::  (# S: @text do T[]->S.puttext; S[]->op #);
     CstOperand::  
       (# out::  (#  do 'C'->amc.put; C->amc.putint #);  
          loadOp:: (# do THIS(CstOperand)[]->op[] #);
          loadToReg:: (# do (THIS(cstOperand)[],R[])->ldCst; R[]->res[] #)
       #);
     TextOperand::  
       (# out::  (#  do T[]->amc.puttext #); #);
     DataRegOperand:: 
       (# out::  (#  do '%'->amc.put; 'D'->amc.put; rn->amc.putint #);
          loadOp:: (# do THIS(dataRegOperand)[]->op[] #);
          alloc::  
            (#  
            do (* regalloc*)
               regCount+1->regCount->rN;
               'DataRegOperand.alloc: %d\n'->lpf(# do RegCount->d#);
            #);
          reg1::  (#  do rn->value #); 
          dealloc::(# do 'Warn dealloc called'->lpl; (* alloc *) #);
          reUse::(# do 'Warn DataRegOperand.reuse called'->lpl; (*alloc*) #);
          inuse::(# do 'warn datareg inuse called'->putline #);
       #);
     doubleDataRegOperand::
       (# 
          out::(# do '%DD['->amc.puttext; dno1.out;dno2.out;']'->amc.put #);
       #);
     AdrRegOperand:: 
       (# out::  
            (#  
            do '%'->amc.put; 
               (if rn 
                // thisO then
                   'this'->amc.puttext
                // callO then
                   'call'->amc.puttext
                else                   
                   'top'->amc.puttext;
                   (*'A'->amc.put; rn->amc.putint *)
               if)
            #);
          alloc::  
            (#  
            do regCount+1->regCount->rN;
               'AdrRegOperand.alloc: %d\n'->lpf(# do regCount->d#);
            #); 
          reg1::  (#  do rn->value #);  
          loadOp::<  (#  do THIS(adrRegOperand)[]->op[] #);
          loadAdrOp::<  
            (#  
            do 'AdrRegOperand.loadAdrOp'->lpl;
               THIS(adrRegOperand)[]->op[] 
            #);
          inuse::
            (# 
            do 7 -> FIXME;
               true->value
            #);
          isCallReg::(# do (rn=2)->value #);
       #);
     FloatRegOp::  
       (# out:: (# do '%'->amc.put; 'F'->amc.put;  rN->amc.putint #); 
          loadOp:: (# do THIS(floatRegOp)[]->op[] #);   
          loadFloatOp::  (#  do THIS(floatRegOp)[]->op[] #);
          load::
            (# 
               dr: @dataRegOperand;
            do (if IMtrace then 
                       ('loadFloat',A[],this(floatRegOp)[])->amc.emit2
               if)
            #);
          store::
            (#
               dr: @dataRegOperand;
            do 
                   (if IMtrace then 
                       ('storeFloat',A[],this(floatRegOp)[]) -> amc.emit2
                   if);

            #);
          loadInt:
            (# A: ^address;
               dr: @dataRegOperand;
            enter A[]
            do 
                   (if IMtrace then 
                       ('loadInt2float',A[],this(floatRegOp)[])->amc.emit2
                   if);

            #);               
          storeTmp:: (# do THIS(floatRegOp)[]->A[] #);
          store2Int:: 
            (# op: ^address;
               F: @floatRegOp; 
            do 
                   (if IMtrace then
                       ('storeFloat2int',A[],this(floatRegOp)[])->amc.emit2
                   if);

            #);
          alloc::  
            (#  
            do (* regalloc*)
               regCount+1->regCount->rN;
               'FloatRegOp.alloc: %d\n'->lpf(# do RegCount->d#);
            #);
          reg1::  (#  do rn->value #); 
          dealloc::(# do 'Warn dealloc called'->lpl; (* alloc *) #);
          reUse::(# do 'Warn DataRegOperand.reuse called'->lpl; (*alloc*) #);
          inuse::(# do 'warn datareg inuse called'->putline #);
       #);
     LocalLab:: 
       (#
          def:: 
            (# 
            do (if IMtrace then 
                   out;
                   ':'->amc.put;
                   type->amc.putint;
                   ':'->amc.put;
                   betalabel->b2d->amc.putint;
                   ' '->amc.put;
                   (* amc.newline  *)
               if);
               
            #);
          VirtLabDef::
            (# 
            do (if IMtrace then  
                   out;
                   'V:'->amc.puttext;
                   ' '->amc.put;
                   (* amc.newline *)
               if);
            #);
          out::  (#  do 'L'->amc.put; labNo->amc.putint #);
          AsText:: 
            (# 
            do &text[]->localLabText[];
               (if type = interFragment then
                   descId[]->localLabText.puttext; 
                   labNo->localLabText.putInt; 
                else
                   (* OBS! Gives 'L7' on ALL platforms;
                    * for sparc we may need '.L7';
                    * Clean up
                    *)
                   'L'->localLabText.put;
                   labNO->localLabText.putint
               if)
            #)
       #);
     RegAdr:: 
       (# loadAdrOp::<  
            (#  
            do 'RegAdr.loadAdrOp'->lpl;
               THIS(RegAdr)[]->op[] 
            #);
          loadFloatOp::
            (#
            do &floatRegOp[]->op[];
               op.alloc;
               (if IMtrace then
                   '\tloadFloatOp\t'->amc.puttext;
                   out;
                   amc.ptab;
                   op.out;
                   amc.newline
               if);
            #);
          loadOp::
            (# D: @dataRegOperand
            do D.alloc;
               D[] -> op[];                
               (thisOp,op[],size)->ldVl;
            #);
          out:: 
            (# 
            do
               reg.out;
               '('->amc.put;
               off->amc.putint;
               ')'->amc.put;
               size->amc.putint;
               ':'->amc.put;
               access->amc.putint;
               ':'->amc.put;
               (if signed then 'S'->amc.put if);
               
            #);
          (*
            constIndex::
            (# aR:@RegAdr;
            do
               aR.reg.alloc;
               (THIS(RegAdr)[],aR.reg[])->ldVal;
               size->aR.size;
               access->aR.access;
               aR[]->a[];
               (c,size,isSimple,aR[],true)->chkConstIndex;
               (if size
                // 1 then
                   c+15->aR.off
                // 2 then
                   c*2+14->aR.off
                // 4 then
                   c*4+12->aR.off
                // 8 then
                   c*8+8->aR.off
               if)
           #);
           *)
          index::< 
            (#
               aR: @adrRegOperand; IA: @InxRegAdr; toReg:@InxRegAdr;
            do reAlloc->aR;
               (if IMtrace then
                   '\tindex:'->amc.puttext;
                   size ->amc.putint;
                   '\t'->amc.put;
                   aR.out;
                   '\t'->amc.put;
                   this(RegAdr).out;
                   '+'->amc.put;
                   dReg.out;
                   '\t{'->amc.puttext;
                   amc.newline
               if);

               (THIS(RegAdr)[],aR[])->ldVal;
               access->toReg.access;
               aR->toReg.aReg;
               dReg->toReg.dReg;
               size->toReg.size;
               (if isSimple then
                   (if size
                    // 1 then
                       15->toReg.off
                    // 2 then
                       14->toReg.off 
                    // 4 then
                       12->toReg.off
                    // 8 then
                       8->toReg.off
                   if)
                else
                    24-size->toReg.off;
               if);
               (if IMtrace then
                   '\t}'->amc.putline
               if);
               
               (*(aR[],dReg[],size,toReg[],isSimple)->chkIndex;*)
               (* I assume that the following is done here (olm):
                * - checkIndexBound aR[8], aR[12];
                * - dReg ->adjustIndex -> dReg
                * - return toReg = (aR,dR,size)
                *)
            #);
          toTmp::
            (# A1: @regAdr; aR: @AdrRegOperand
            do 'regadr totmp'->amc.putline;
               (if access 
                // common.cstInd // common.varInd then
                   0->addOff->A[]; (if A.useCallReg then A.toTmp->A[] if)
                else 
                   aR.alloc; aR->A1.reg; 
                   this(RegAdr).off -> A1.off;
                   (this(RegAdr).reg[],aR[]) -> cpReg;
                   A1[]->A[]
               if);
               A[]->bAdr.copy   
            #);
          toOriginReg::< 
            (# A: ^address;
               oReg:@AdrRegOperand;
            do (if reg <> -11 (* hack *) then
                   (if access // common.cstInd // common.varInd then
                       0->addOff->A[]; A.toOriginReg
                    else
                       (if off = 0 then 
                           (if true then
                               (* to handle primReg1 (origin) 
                                * in register or memory *)
                               1->reg.toPrimDest
                            else
                               primreg1->oReg; 
                               (reg[],oReg[] (* reg=off=0*) )->cpReg;
                           if)
                        else
                           'WARNING: toOriginreg nonzero'->lpl;
                           primreg1->oReg;
                           (this(RegAdr)[],oreg[])->glea
                       if)
                   if)
               if)
            #);
       #);
     InxRegAdr::
       (# isInxRegAdr:: TrueValue;
          out:: 
            (# do  '('->amc.put; areg.out;'+'->amc.put; dreg.out; 
               '+'->amc.put; off->amc.putint;
               ')'->amc.put;
            #);

          loadAdr::
            (# do 'InxRegAdr.loadAdr'->amc.putline #);
          loadOp::
            (# dr: @dataRegOperand
            do dr.alloc;
               (this(InxRegAdr)[],dr[],size)->ldVlImpl;
               dr[]->op[]
            #);
          loadAdrOp::
            (# IX: @inxRegAdr
            do (if IMtrace then
                   '\tPseudo:loadAdrOp'->amc.putline
               if);
               
            #);
          loadFloatOp::
            (# tmp: ^inxRegAdr
            do (if IMtrace then
                   '\tPseudo:loadFlotOp'->amc.putline
               if);
               &floatRegOp[]->op[];
               op.alloc; (* dest *)
               loadAdrOp -> tmp[];
               tmp[]->op.load
            #);
          toTmp::
            (# A1: @inxRegAdr; aR: @adrRegOperand 
            do (* only tested in case common.varInd !! *)
               (if access
                // common.cstInd // common.varInd then 
                   0->addOff->A[]; 
                   (if A.useCallReg then
                       A.toTmp->A[] 
                   if)
                else
                   reAlloc -> aR -> A1.aReg; 
                   this(inxRegAdr).dReg -> A1.dReg;
                   this(inxRegAdr).off -> A1.off;
                   (this(InxRegAdr).aReg[],aR[]) ->  cpReg;
                   A1[]->A[]; 
                   (* NO: freeAdr; since dReg is still in use *)
               if);
               A[]->bAdr.copy;
            #);
          pushRegAndOff::
            (* pushRegAndOff for RegAdr is in machine - clean up*)
            (#
            do (off->newCstOp,dReg[],4)->gAdd;
               (2->newCstOp,dReg[])->arithShiftRight;
               aReg[]->pushClong;
               dReg[]->pushClong
            #)
       #);
     PrimRegOperand: registerOperand
       (# isPrimRegOp:: trueValue;
          primRegIsReg:: trueValue;
          primRegIsRegAdr::
            (#
            do 
            #);
          asText:: (* currently INTEL/LINUX specific: FIX '_' for WIN32 *)
            (# 
            do 'pReg'->T; (*primRegs[rN]->T.putInt; *)
            #);
          out::  
            (# 
            do '%'->amc.put; 'P'->amc.put; rn->amc.putint; 
               ','->amc.put; (*primregs[rn]->amc.putint*)
            #);
          reg1::(#do rn -> value #);
          loadOp:: (#  do THIS(PrimRegOperand)[]->op[] #);
       #);
     
     (* register operations *)
     nop:: 
       (#
       do
          (if IMtrace then
              '\tNop'->amc.putline;
          if);

       #);
     
     ldCst:: 
       (# 
       do (if IMtrace then
              ('ldCst',C[])->amc.emit1
          if);              
       #);
     
     stCst:: 
       (# tmp: @dataRegOperand
       do tmp.alloc;
          (C[],tmp[])->ldCst;
          (tmp[],A[]) -> stVal
       #);
     
     ldvlImpl:
       (# 
          IA: ^inxregadr;
          A: ^address; R: ^registerOperand; size: @integer
       enter (A[], R[], size)
       do (if IMtrace then 
              ('ldVl', A[]) -> amc.emit1 (* fix size *)
          if);
       #);
     
     ldByte:: 
       (# 
       do (op1[], op2[], 1)->ldvlImpl
       #);
     ldHalf:: 
       (# 
       do (op1[], op2[], 2)->ldvlImpl
       #);
     ldVal:: 
       (# 
       do (A[], R[], 4)->ldvlImpl
       #);
     ldVl:: 
       (# 
       do (A[], R[], size)->ldvlImpl
       #);
     
     ldvalFromLab:: 
       (# 
       do (failureTrace,'ldvalFromLab NOT supported')->stop
       #);
     
     stByte:: 
       (# 
       do (op1[], op2[], 1)->stValImpl
       #);
     stHalf:: 
       (# 
       do (op1[], op2[], 2)->stValImpl
       #);
     stVal::
       (# 
       do (R[], A[], 4)->stValImpl
       #);
     
     stValImpl:
       (#
          A: ^address; R: ^registerOperand; size: @integer
       enter (R[], A[], size)
       do (if IMtrace then 
              ('stVal',A[])->amc.emit1; (* size *)
          if);
          
       #);
     
     stValInLab:: 
       (# 
       do (failureTrace,'stValInLab')->stop
       #);
     
     cpReg:: 
       (# ; 
       do (if IMtrace then 
              ('cpReg',R1[],R2[])->amc.emit2
          if);
       #);
     
     cpByteMem:: 
       (# ; 
       do &dataregOperand[]->dr[];
          dr.alloc;
          (* no current machine can copy mem to mem *)
          (a1[],dr[])->ldByte;
          (dr[],a2[])->stByte;
       #);
     cpHalfMem:: 
       (# ; 
       do &dataregOperand[]->dr[];
          dr.alloc;
          (if IMtrace then 
              ('cpHalfMem',A1[],A2[]) -> amc.emit2
          if);
          (a1[],dr[])->ldHalf;
          (dr[],a2[])->stHalf;
       #);
     cpMem:: 
       (# ; 
       do &dataregOperand[]->dr[];
          dr.alloc; (* use the one returned by cpMem *)
          (A1[],dr[])->ldVal;
          (dr[],A2[])->stVal   
       #);
     
     stValInText:: 
       (# ; 
       do (if IMtrace then 
              ('stValInText',op[],l[]) -> amc.emit2
          if);
       #);
     
     addMem::
       (# R1: @dataRegoperand
       do R1.alloc;
          &dataRegOperand[]->R[];
          R.alloc;
          (if op1.isCstOp then
              (op1[],R1[])->ldCst;
           else
              (op1[],R1[],4)->ldVl;
          if);
          (op2[],R[],4)->ldVl;
          (R1[],R[],4)-> gAdd;
          (R[],op2[])->stVal
       #);
     gNot:: 
       (# 
       do (if IMtrace then 'not'->callFunc if);
       #);
     logNot:: 
       (# 
       do (if IMtrace then 'logNot'->callFunc if);
       #);
     gNeg:: 
       (# 
       do (if IMtrace then 'neg'->callFunc if);
       #);
     gAdd:: 
       (#
       do (if IMtrace then 'add'->callFunc if);
       #);
     gSub:: 
       (# 
       do (if IMtrace then 'sub'->callFunc if);
       #);
     gOr:: 
       (# 
       do (if IMtrace then 'or'->callFunc if);
       #);
     gAnd:: 
       (# 
       do (if IMtrace then 'and'->callFunc if);
       #);
     gXor:: 
       (# 
       do (if IMtrace then 'xor'->callFunc if);
       #);
     gCmp:: 
       (# 
       do (if IMtrace then 'cmo'->callFunc if);
       #);
     gMult:: 
       (# 
       do (if IMtrace then 'mult'->callFunc if);
       #);
     gDIV:: 
       (# 
       do (if IMtrace then 
              (if isDiv then
                  'div'->callFunc
               else
                  'mod'->callFunc
          if)if)
       #);
     (* Bit operations *)
     SignExtByte:: 
       (# ; 
       do (if IMtrace then 
              '\tSignExtByte\t'->amc.puttext;
              op.out;
              amc.newline
          if);
          
       #);
     SignExtWord:: 
       (# ; 
       do (if IMtrace then 
              '\tSignExtWord\t'->amc.puttext;
              op.out;
              amc.newline
          if);
          
       #);
     getBitsImpl:
       (# ; 
          op1,op2,drF,op: ^mOperand;
          pos,length:@Integer;
       enter (op1[],pos,length,op2[],drF[])
       do (if IMtrace then 
              '\tGetBitsImpl\t'->amc.puttext;
              op1.out;
              amc.ptab;
              pos->amc.putint;
              amc.ptab;
              length->amc.putint;
              amc.ptab;
              op2.out;
              amc.ptab;
              (* drF.out; *)
              amc.newline
          if);
       #);
     getBits:: 
       (# 
       do (op1[],pos,length,op2[],drF[])->getBitsImpl;
       #);
     GetSignedBits:: 
       (# 
       do (op1[],pos,length,op2[],drF[])
            ->getBitsImpl
       #);
     
     gGetBits:: 
       (# 
       do (if IMtrace then '\getBits'->amc.puttext if)
       #);
     gGetSignedBits:: 
       (# 
       do (if IMtrace then '\gGetBits'->amc.puttext if)
       #);     
     putBits:: 
       (#
       do 
          (if IMtrace then 
              '\tPutBits\t'->amc.puttext;
              op1.out;
              amc.ptab;
              pos->amc.putint;
              amc.ptab;
              length->amc.putint;
              amc.ptab;
              op2.out;
              amc.ptab; drf.out;
              amc.newline
          if);
       #);
     gPutBits:: 
       (# ; 
       do (if IMtrace then 
              '\tgPutBits\t'->amc.puttext;
              dr.out;
              amc.ptab;
              pdr.out;
              amc.ptab;
              ldr.out;
              amc.ptab;
              ar.out;
              amc.ptab;
              amc.newline
          if);
       #);
     ByteSwap:: 
       (# 
       do (if IMtrace then 
              '\tByteSwap\t'->amc.puttext;
              ar.out;
              amc.ptab;
              long->amc.putboolean;
              amc.newline
          if);
       #);
     doAsgRefAdr:: 
       (# 
       do 
          (if IMtrace then
              'doAsgRefAdr'->lpl;
              '\tdoAsgRefAdr\t'->amc.puttext;
              thisAdr.out;
              '\t'->amc.put;
              A.out; 
              amc.ptab;
              withQua->b2d->amc.putint;
              amc.newline
          if);           
          &adrRegOperand[]->dest[];
          dest.alloc;
       #);
     doAsgRefReg:: 
       (# ; 
       do (if IMtrace then 
              '\tstRefReg\t'->amc.puttext;
              A.out;
              (* a register *)
              '\t'->amc.put;
              thisAdr.out;
              amc.newline
          if); 
          (* just to avoid ref is none error *)
          &adrRegOperand[]->dest[];
          dest.alloc;
       #);
     ChkHeap:: 
       (# ; 
       do (if IMtrace then 
              '\tChkHeap\t'->amc.puttext;
              (if op[] <> NONE then op.out if) ;
              amc.newline
          if);
          (* the code is generated in asgRefAdr/asgRegAdr *)
       #);
     (* Arithmetic *)
     gGetDataByte:: 
       (#
       do (if IMtrace then 
              '\tgGetDataByte\t'->amc.puttext;
              op1.out;
              amc.ptab;
              byteNo->amc.putint;
              amc.newline
          if);
       #);
     gGetDataWord:: 
       (# ; 
       do (if IMtrace then 
              '\tgGetDataWord\t'->amc.puttext;
              op1.out;
              amc.ptab;
              WordNo->amc.putint;
              amc.newline
          if);
       #);
     arithShiftLeft:: 
       (# ; 
       do (if IMtrace then 
              '\tarithShiftLeft\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);
       #);
     logicalShiftLeft:: 
       (# ; 
       do (if IMtrace then 
              '\tlogicalShiftLeft\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);
          #);
     arithShiftright:: 
       (#
       do (if IMtrace then 
              '\tarithShiftright\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);
       #);
     logicalShiftRight:: 
       (#
       do (if IMtrace then 
              '\tlogicalShiftRight\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);
       #);
     rotateLeft:: 
       (# ; 
          tmp,tmp2: @DataRegOperand;
          CO: @cstOperand;
       do (if IMtrace then 
              '\trotateLeft\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);

       #);
     rotateRight:: 
       (# 
       do (if IMtrace then 
              '\trotateRight\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              amc.newline
          if);
       #);
     
     (* Control Flow operations *)
     jumpIfTrue:: 
       (# ; 
       do (if IMtrace then 
              '\tjumpIfTrue\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     tstNone:: 
       (# ; 
       do (if IMtrace then 
              '\ttstNone\t'->amc.puttext;
              A.out;
              amc.ptab;
              R.out;
              amc.newline
          if);
       #);
     gBeq:: 
       (# ; 
       do (if IMtrace then 
              ('gBeq',op[]) -> amc.emit1
          if);
       #);
     gBne:: 
       (# ; 
       do (if IMtrace then 
              ('gBne',op[]) -> amc.emit1             
          if);
       #);
     gBge:: 
       (# ; 
       do (if IMtrace then 
              ('gBge',op[]) -> amc.emit1
          if);
       #);
     gBae:: 
       (# ; 
       do (if IMtrace then 
              ('gBae',op[]) -> amc.emit1
          if);
       #);
     gBle:: 
       (# ; 
       do (if IMtrace then 
              ('gBle',op[]) -> amc.emit1
          if);
       #);
     gBbe:: 
       (# ; 
       do (if IMtrace then 
              ('gBbe',op[]) -> amc.emit1
          if);
       #);
     gBgt:: 
       (# ; 
       do (if IMtrace then 
              ('gBgt',op[]) -> amc.emit1
          if);
       #);
     gBab:: 
       (# ; 
       do (if IMtrace then 
              ('gBab',op[]) -> amc.emit1
          if);
       #);
     gBlt:: 
       (# ; 
       do (if IMtrace then 
              ('gBlt',op[]) -> amc.emit1
          if);
       #);
     gBbl:: 
       (# ; 
       do (if IMtrace then 
              ('gBbl',op[]) -> amc.emit1
          if);
       #);
     trap:: 
       (# ; 
       do (if IMtrace then 
              '\tTrap\t'->amc.puttext;
              cond->amc.putint;
              amc.newline
          if);
       #);
     jsrTable:: 
       (# ; 
       do (if IMtrace then 
              '\tjsrTable\t'->amc.puttext;
              A.out;
              amc.ptab;
              newVirt->amc.putboolean;
              amc.newline
          if);
       #);
     
     (* this is only for testing class tests in synthesizer, 
      * note virtdecl, not binding! *)
     jsrTableTest:<
       (# 
          ; 
       do (if IMtrace then 
              '\tjsrTableTest\t'->amc.puttext;
              (*A.out; not declared *)
              amc.ptab;
              (*newVirt->amc.putboolean; *)
              amc.ptab;
              (*proto[]->amc.putline              *)
          if);
          (* only used to test classtest based jumps ! *)
       #);
     jmpTlong:: 
       (# ; 
       do (if IMtrace then 
              '\tjmpTlong\t'->amc.puttext;
              t[]->amc.puttext;
              amc.ptab;
              labArg[]->puttext;
              amc.newline
          if);
       #);
     jmpT:: 
       (# ; 
       do (if IMtrace then 
              '\tjmpT\t'->amc.puttext;
              t[]->amc.putline;
              
          if);
       #);
     jsrT:: 
       (# ; 
       do (if IMtrace then 
              '\tjsrT\t'->amc.puttext;
              t[]->amc.putline;
              
          if);
       #);
     jsrReg:: 
       (# ; 
       do (if IMtrace then 
              '\tJSRreg\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     jmpReg:: 
       (# ; 
       do (if IMtrace then 
              '\tJMPreg\t'->amc.puttext;
              op.out;amc.ptab;iscase->b2d->amc.putint;
              amc.newline
          if);
       #);
     gJmp:: 
       (# 
       do (if IMtrace then 
              ('JMP',op[])->amc.emit1
          if);
       #);
     gJsr:: 
       (# ; 
       do (if IMtrace then 
              ('JSR',op[])->amc.emit1
          if);
       #);
     BeginLabel:: 
       (# ; 
       do 
          (if IMtrace then 
              '\tBeginLabel ++++ NOT IMPL'->amc.putline;
          if)
          (*
       #);
     Break:: 
       (# ; 
          T: @textOperand;
       do (if IMtrace then  
              '\tBreak\t'->amc.puttext;
              off->amc.putint;
              amc.ptab;
              jmpAdr.out;
              amc.ptab;
              isLeave->amc.putboolean;
              amc.newline
          if);
       #);
     FreeLabel:: 
       (# ; 
       do (* NOT used anymore ! *)
       #);
     EndLabel:: 
       (# ; 
       do (* USED in MIPSmachine and perhaps other ones *)
          (if IMtrace then              
              ('EndLabel',none,none) -> amc.emit2
          if);
       #);
     saveInnerReturn:: 
       (# ; 
       do (if IMtrace then 
              '\tSaveInnerReturn\trtoff:'->amc.puttext;
              RToff->amc.putint;
              amc.newline
          if);
       #);
     returnInner:: 
       (# ; 
       do (if IMtrace then 
              '\treturnInner\trtoff:'->amc.puttext;
              RToff->amc.putint;
              isLeavePtn->amc.putboolean;
              amc.newline
          if);
       #);
     EmitTextConst:: 
       (# ; 
          lab: @ localLab; pDest: ^mOperand
       do (if IMtrace then 
              '\tEmitTextconst\t\''->amc.puttext;
              s[]->amc.puttext;'\''->amc.put;
              amc.ptab;
              pNo->amc.putint;
              amc.ptab;amc.newline
          if);
       #);
     
     rts::
       (# 
       do (if IMtrace then 
              '\trts'->amc.putline              
          if);

       #);
     glea:: 
       (# 
       do (if IMtrace then 
              '\tglea\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.newline
          if);
       #);
     gleaLabel:: 
       (#
       do (if IMtrace then 
              '\tgleaLabel\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.newline
          if);
       #);
     leaToPrimReg:: 
       (# 
       do (if IMtrace then 
              '\tleaToPrimReg\t'->amc.puttext;
              op1.out;
              amc.ptab;
              op2.out;
              amc.newline
          if);
       #);
     gClr:: 
       (# ; 
       do (if IMtrace then 
              ('gClr',op[],none)->amc.emit2;
          if);
       #);
     pushAdr:: 
       (# ; 
       do (if IMtrace then 
              ('PushAdr',op[],none)->amc.emit2
          if);
       #);
     Push:: 
       (# ; 
       do (if IMtrace then 
              '\tPush\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     Pop:: 
       (# ; 
       do (if IMtrace then 
              '\tPop\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     PushThisOrCall:: 
       (# ; 
       do (if IMtrace then 
              '\tPushThisOrCall\t'->amc.puttext;
              pushTh->amc.putboolean;
              amc.ptab;
              pushca->amc.putboolean;
              amc.newline
          if);
       #);
     popThisOrCall:: 
       (# ; 
       do (if IMtrace then 
              '\tPopThisOrCall\t'->amc.puttext;
              popth->amc.putboolean;
              amc.ptab;
              popca->amc.putboolean;
              amc.newline
          if);
       #);
     setTop:: 
       (# ; 
       do (if IMtrace then 
              '\tsetTop\t'->amc.puttext;
              off->amc.putint;
              amc.newline
          if);
       #);
     ChkCase:: 
       (# ; 
       do (if IMtrace then 
              '\tChkCase\t'->amc.puttext;
              min->amc.putint;
              amc.ptab;
              max->amc.putint;
              amc.ptab;
              inx.out;
              amc.ptab;
              elseLab.out;
              amc.newline
          if);
       #);
     ChkIndex:: 
       (# ; 
          size: @integer;
          isSimple: @boolean;
          repAdr: ^mOperand;
          toReg: ^inxRegAdr
       do 4 -> FIXME;
          (if IMtrace then 
              '\tChkIndex\t'->amc.puttext;
              repadr.out;
              '+'->amc.put;
              (*index.out;*)
              '*%d -> '->amc.putformat(# do (*size->d *) #);
              toreg.out;
              (if isSimple then '\tsimple'->amc.puttext if);
              amc.newline
          if);
       #);
     (* for using const rep. lookup in synthesizer, note not binding ! *)
     chkConstIndex:<
       (#
          isSimple: @boolean;
          index,size: @integer;
       do (if IMtrace then  '\tChkConstIndex\t'->amc.puttext;
              (*toReg.out;*)
              '['->amc.put;
              index->amc.putint;
              '*'->amc.put; 
              size->amc.putint;
              ']'->amc.put;
              amc.newline
          if);
       #);
     cmpToBool:: 
       (#
       do (if IMtrace then 
              '\tcmpToBool:'->amc.puttext;
              cond->cond2text->amc.puttext;
              ':'->amc.put;
              size->amc.putint;
              '\t'->amc.put;
              op1.out;
              '\t'->amc.put;
              op2.out;
              '\t'->amc.put;
              op3.out;
              amc.newline
          if);
       #);
     cmpAndJmp:: 
       (#
       do (if IMtrace then 
              op1.loadToReg;
              op2.loadToReg;
              (cond->cond2text)->CallFunc;
              ('cmpAndJmp',lab[])->amc.emit1; (* size *)
          if);
       #);
     cmpBoolAndJmp:: 
       (# ; 
       do (if IMtrace then 
              '\tcmpBoolAndJmp:'->amc.puttext;
              cond->cond2text->amc.puttext;
              ':'->amc.put;
              size->amc.putint;
              '\t'->amc.put;
              op.out;
              '\t'->amc.put;
              lab.out;
              '\t'->amc.put;
              amc.newline
          if);
       #);
     (* Floating point operations *)
     floatConst:: 
       (# ; 
       do FR.alloc;
          (if IMtrace then 
              '\tfloatconst\t'->amc.puttext;
              value -> amc.putreal; 
              amc.ptab;
              T[] -> amc.puttext;
              amc.ptab;
              FR.out;
              amc.newline
          if);
       #);
     int2float:: 
       (# ; 
          F: @floatRegOp
       do (if IMtrace then 
              '\tint2float\t'->amc.puttext;
              a.out;
              amc.newline
          if);
       #);
     intReg2float:: 
       (# ; 
          fTmp: @floatRegOp
       do FR.alloc;
          fTmp.alloc;
          (if IMtrace then 
              ('intReg2float',A[],fTmp[],FR[]) -> amc.emit3
          if);
       #);
     float2int:: 
       (# ; 
       do (if IMtrace then 
              '\tfloat2int\t'->amc.puttext;
              Fr.out;
              amc.ptab;
              Dr.out;
              amc.newline
          if);
       #);
     cmpToBoolFloat:: 
       (# ; 
       do (op2[],op1[])->cmpFloat;
          (if IMtrace then 
              '\tcmpToBoolFloat\t'->amc.puttext;
              cond->amc.putint;
              amc.ptab;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              op3.out;
              amc.newline
          if);
       #);
     cmpAndJmpFloat:: 
       (# ; 
       do 
          (if IMtrace then 
              '\tcmpAndJmpFloat\t'->amc.puttext;
              cond->amc.putint;
              amc.ptab;
              op1.out;
              amc.ptab;
              op2.out;
              amc.ptab;
              lab.out;
              amc.ptab;
              pop->amc.putboolean;
              amc.newline
          if);          
       #);
     popFStack:: 
       (# ; 
       do (if IMtrace then 
              '\tpopFStack'->amc.putline;
          if);
       #);
     cmpFloat:: 
       (# ;  
          op: ^floatRegOp
       do (if IMtrace then 
              ('cmpFloat',LF[],A[]) -> amc.emit2
          if);
       #);
     fBeq:: 
       (# ; 
       do (if IMtrace then 
              '\tfBeq\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     fBge:: 
       (# ; 
       do (if IMtrace then 
              '\tfBge\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     fBle:: 
       (# ; 
       do (if IMtrace then 
              '\tfBle\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     fBne:: 
       (# ; 
       do (if IMtrace then 
              '\tfBne\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     fBgt:: 
       (# ; 
       do (if IMtrace then 
              '\tfBgt\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     fBlt:: 
       (# ; 
       do (if IMtrace then 
              '\tfBlt\t'->amc.puttext;
              op.out;
              amc.newline
          if);
       #);
     addFloat:: 
       (# 
       do 
       #);
     subFloat:: 
       (# 
       do 
       #);
     mulFloat:: 
       (# 
       do 
       #);
     divFloat:: 
       (# 
       do 
       #);
     negFloat:: 
       (# ; 
       do (if IMtrace then 
              '\tnegFloat\t'->amc.puttext;
              f.out;
              amc.newline
          if);
       #);
     FreeData::  (#  #);
     ReleaseReg:: (# do 'treleasereg'->lpl; 0->callRegCount #);
     thisO::  
       (#  
       do 
              1->rNO 

       #);
     callO::  
       (#  
       do 2->rNO
       #);
     primReg1: (# exit 3 #);
     callRegCount:@integer;
     CallRegBusy::
       (# do 'callregBusy: %d\n'->
          lpf(# do callRegCount->d #);
                (* 'callregBusy: %d\n'->amc.putformat(# do callRegCount->d #);  *)
          (callregCount>0)->value
       #);
     DecrCallReg::  
       (# ;
       do 'DecrCallReg'->lpl;
          callRegCount-1->callRegCount;
          (*'deccallreg: %d\n'->amc.putformat(# do callRegCount->d #);  *)
          (*           &Backinstruction[]->i[];
           *           iDecrCallReg->i.type;
           *           i[]->Intermediategraf.Irin
           *)
       #);
     GetCallReg::  
       (# 
       do 
          'GetCallReg'->lpl;
          callRegCount+1->callRegCount;
          (* 'getcallreg: %d\n'->amc.putformat(# do callRegCount->d #);  *)
          (*           &Backinstruction[]->i[];
           *           iGetCallReg->i.type;
           *           i[]->Intermediategraf.Irin
           *)
       #);
     FreeCallReg::  (#  do 'FreeCallReg not impl'->amc.putline #);
     CallRegInPrimReg2:: 
       (#  
       do 'CallRegInPrimReg2 not impl'->amc.putline;
          'CallRegInPrimReg2 not impl'->lpl
       #);
     GetOriginReg::  
       (# do 'getoriginreg not impl'->amc.putline;
          'getoriginreg'->lpl;
       #);
     FreeOriginReg::  (#  #);
     DataRegMax::  (#  do 5->val #);
     NoOfFreeDataReg::  (#  do 'NoOfFreeDataReg not impl'->amc.putline #);
     DumpReg:: (# #);
     PushReg:: (# #);
     PopReg:: (##);
     PushDataReg:: 
       (#
       do (if IMtrace then 
              '\tPushDataReg\t'->amc.putline;              
          if);
       #);
     PopDataReg:: 
       (# ; 
       do (if IMtrace then 
              '\tPopDataReg\t'->amc.putline;              
          if);
       #);
     PushFloatReg:: 
       (# ; 
       do (if IMtrace then 
              '\tPushFloatReg\t'->amc.putline              
          if);
       #);
     PopFloatReg:: 
       (# ; 
       do (if IMtrace then 
              '\tPopFloatReg\t'->amc.putline;
          if);
       #);
     (* external not working *)
     InitExternalCall::
       (# 
       do (if IMtrace then 'InitExternalCall'->amc.emit if);
       #);

     
     PushClong::
       (# ; 
          dr: @dataRegOperand;
       do (if IMtrace then  '\tPushClong\t'->amc.puttext; 
              op.out; amc.newline
          if);
       #);
     PushCword::< (# do op[] -> PushClong #);
     PushCbyte::< (# do op[] -> PushClong #);
     PushCdoubleAdr::<
       (# ; 
       do (if IMtrace then 
              '\pushCdouble:\t'->amc.puttext;
              A.out;
              amc.newline
          if);
       #);
     PushCfloat::<
       (# ; 
       do (if IMtrace then 
              '\tpushCfloat:\t'->amc.puttext;
              F.out;
              amc.newline
          if);
       #);
     PushCtext::<(# do 'PushCtext'->putline #);
     CallCproc::
       (#
       do (if IMtrace then  
              '\tCallCproc\t'->amc.puttext; 
              t[]->amc.puttext; amc.ptab;
              extType->amc.putint; amc.ptab;
              noOfParam->amc.putint; amc.ptab;
              exitType->amc.putint; 
              amc.putline
          if);
       #);
     SaveReg::
       (#  ; 
       do (if IMtrace then 'SaveReg'->amc.emit if);
       #);
     RestoreReg::
       (# 
       do (if IMtrace then 'RestoreReg'->amc.emit if);
       #);
     
     externalDispatch::
       (# ;
       do (if IMtrace then
              ('externalDispatch',reg[],none)->amc.emit2
          if);
       #);
     noXres::
       (# ;
       do (if IMtrace then 'noXres'->amc.emit if);
       #);
     getSimpleXres::
       (# ; 
       do (if IMtrace then 'getSimpleXres'->amc.emit if);
       #);
     getTextXres::
       (# ; 
       do (if IMtrace then 'getTextXres'->amc.emit if);
       #);
     realXresIsDouble::
       (# 
       do
       #);
     getDoubleXres::
       (# ; 
       do (if IMtrace then
              ('getDoubleXres',drA[],drB[])->amc.emit2
          if);
       #);
     getFloatXres::
       (# ; 
       do fp.alloc;
          (if IMtrace then
              ('getFloatXres',fp[],none)->amc.emit2
          if);
       #);
     getDataRefXres::
       (# ; 
       do (if IMtrace then
              '\ngetDataRefXres'->amc.putline
          if);
       #);
     getDataPartXres::
       (# 
       do (if IMtrace then
              '\ngetDataPartXres'->amc.putline
          if);
       #);
     SaveHeapTop::
       (# ; 
       do (if IMtrace then
              '\tsaveHeapTop'->amc.putline
          if);
       #);
     PopCallStack::
       (# 
       do '\n**** Not Implemented: PopCallStack' -> putline
       #);
     AllocExternalResult::
       (# 
       do 
       #);
     PascalTrap::
       (* Only meaningful on  Macintosh *)
       (# 
       do '\n**** Not Implemented: PascalTrap' -> putline
       #);
     
   xParForward:: (# #);
     
   (* BETA run-time routines *)
     GetPrimReg::  
       (# pR: @primRegOperand;  
          prn:@integer;
       do 'getPrimReg called, pno=%d prn=%d\n'->lpf
          (# do pno->d; regcount+1->d #);
          (* primreg1 is preAllocated in register 3 *)
          (if pno<>1 then
              regCount+1->regCount->prn;
           else
              primreg1->prn
           if);
          prn->pR; pR[]->primReg[];
       #);
     initPrimCall::
       (# ;
       do (if IMtrace then  
              '\tInitPrimCall\t'->amc.puttext; noOfPar->amc.putint; 
              amc.newline
          if);
       #);
     CallPrim::  
       (# ; 
       do (if IMtrace then  
              '\tCallPRIM\t'->amc.puttext; T[]->amc.putline              
          if);
       #);
     CallAlloPrim:: 
       (# p:@PrimRegOperand;
       do (if IMtrace then 
              (if proto[] <> none then                  
                  ('Call','AlloI'->newTextOp) -> amc.emit1
               else
                  ('Call','AlloI'->newTextOp,proto[]->newTextOp) -> amc.emit2
          if)if)
       #);
     StackAlloPrim:
       (# p:@PrimRegOperand;
          ;
          proto,t,s: ^text;
          stackCount,size: @integer
       do 5 -> FIXME;
          (if IMtrace then  
              '\tStackAlloPrim %s %d\n'
                ->amc.putformat(# do (* t[]->s;  size->d*)  #);
               (*'\tStackAlloPrim %s %d\n'->opf(# do t[]->s; size->d #);*)
          if);
       #);
     InlineAlloiNGNP:
       (# ;
          p:@PrimRegOperand;
          size,orgOff: @integer;
          proto: ^text;
       do '\n*** InlineAlloiNGNP: size,orgOff,proto' -> putline;
          (if IMtrace then  
              '\ InlineAlloiNGNP %d,%s\n'
                ->amc.putformat(# do(* size->d; proto[]->s *)#);

          if);
       #);
     deAllocIOA:
       (# 
       do (if IMtrace then  
              '\tdeAllocIOA %d\n'->amc.putformat(# do (*size->d *)#);
          if);
       #);
     GetPrimRes:: 
       (# ; 
          o:^primRegOperand;
       do (if IMtrace then  
              '\tGetPrimRes\t'->amc.puttext; res->amc.putint; amc.newline
          if);
       #);
     
     SPtoPrimReg::
       (# 
       do 'WARN  SPtoPrimReg pNo: %d, pushthis:%d\n'->logfile.putformat
          (# do pNo->d; pushthis->d #)
       #);
     LabelDef:: 
       (* is ONLY called for M-part labels in COM virtuals *)
       (#
       do (if IMtrace then
              'ENTRY\t'->amc.puttext; 
              T[]->amc.putline;
          if);
       #);
     GlobalLabelDef:: 
       (#
       do 
       #);
     (* entry point / return *)
     Export::   
       (#  
       do 'Export Called: %s\n'->lpf(# do lab[]->s #);
       #);
     Import:: 
       (#  
       do 
          'Import Called: %s\n'->lpf(# do lab[]->s #);
       #);
     ImportData::
       (#  
       do 'ImportData: %s,%d\n'->lpf(# do lab[]->s;local->b2d->d #);
       #);
     switchToData::
       (#  
       do 'switchToData'->logfile.putline;
       #);
     switchToCode::
       (# 
       do 'switchToCode'->logfile.putline;  
       #);
     declareAddress:: 
       (# 
       do
       #);
     declareLong::  
       (#  
       do 'declareLong: %d\n'->lpf(# do this(declareLong).n->d #);
       #);
     declareWord::  
       (#  
       do 'declareWord: %d\n'->lpf(# do this(declareWord).n->d #);
       #);
     dclWord::
       (# 
       do 'dclWord: %d\n'->lpf(# do this(dclWord).n->d #);
       #);
     emitByte::
       (# 
       do 'emitbyte: %d\n'->lpf(# do this(emitByte).b->d#);
       #);
     asciiText::
       (# 
       do 'asciiText: %s\n'->lpf(# do t[]->s#);
       #);
     DefineMainLabel1::
       (# 
       do 'DefineMainLabel1'->lpl; 
       #);
     doFinal2VirtJump::
       (# do 'WARNING doFinal2VirtJump'->lpl #);
     GetVirtualOriginStart1:: 
       (# A1: @RegAdr; aR: @adrRegOperand
       do (if IMtrace then
              'GetVirtualOriginStart1'->amc.emit
          if);
          OriginReg->aR->A1.reg; A1[]->startA[]
       #);
     GetVirtualOriginStart2:: 
       (#  
       do (if IMtrace then 'GetVirtualOriginStart2'->amc.emit if);
          startA.toOriginReg
       #);
     AllocObj::
       (# 
       do (if IMtrace then
              ('AllocObj',none)->amc.emit1(#do Tentry[]->amc.puttext #);
          if);
       #);
     allocDoPartObject::
       (# ar: @adrRegOperand
       do (if IMtrace then
              '\tAllocDoPartObject' -> amc.putline
          if);
          (if common.switch[61] then
               3->initPrimCall;
              (size->newCstOp,1->getPrimReg) -> ldCst;
              (thisRegOp[],2->getPrimReg) -> cpReg;
              (3,1) -> SPtoPrimReg
           else
              1->initPrimCall;
              (size->newCstOp,1->getPrimReg)->ldCst;
          if);
          'AlloDO'->callPrim;
          (if common.switch[61] then
              3 -> getPrimRes -> ar;
              (ar[],thisRegOp[]) -> cpReg
           else
              0->getPrimRes
          if)
       #);
     deAllocDoPartObject::
       (# A: @RegAdr
       do (if IMtrace then
              '\tdeAllocDoPartObject' -> amc.putline
          if);
          (* before return, thisReg must be defined to be the object 
           * containing the dopart. This object is the origin of the 
           * dopart object
           *)
          thisO->A.reg; 8->A.addOff;
          (A[],thisRegOp[])->ldVal
       #);
     SaveReturn::
       (#
       do (if IMtrace then 
              'SaveReturn'->amc.emit
          if);
       #);
     Return:: 
       (#
       do (if IMtrace then 
              'RETURN'->amc.emit; amc.newline
          if);
       #);
     ReturnVirtualCom::
       (#
       do (if IMtrace then
              ('ReturnVirtualCOM',none,none)->amc.emit2
          if);
       #);
     ExternalEntry::
       (#
       do 
          (if IMtrace then
              '\tEXTERNALENTRY\t'->amc.puttext;
              entryID[] -> amc.puttext;
              ':' ->amc.put;
              noOfEnterPar->amc.putint;
              amc.newline
          if);
       #);
     ExternalMark::
       (#
       do '++++++++++ Missing ExternalMark' -> putline
       #);
     ExternalReturn::
       (# ; 
       do (if IMtrace then
              '\tEXTERNALRETURN'->amc.puttext;
          if);
       #);
     initXpar::
       (# ;
          dr: @dataRegOperand
            (*enter (extKind,BC,SC,LC)*)
       do (if IMtrace then
              '\tinitXpar\t'->amc.puttext;
              BC+SC+LC->amc.putint;
              amc.newline
          if);
       #);
     xPar: @
       (# top,no: @integer;
          D: [3] @integer;
          init: (# do 0->top->no #);
          put:
            (# dr: @integer
            enter dr
            do (if (top+1->top) > D.range then
                   D.range->D.extend
               if);
               dr->D[top]
            #);
          newReg: (# exit no >= (top-1) #);
          getPre:
            (# reg: @integer
            do no+1->no;
               (if no < top then
                   D[no]->reg
                else 
                   '\nERROR: getPre call'->putline
               if)
            exit reg
            #);
          getNew:
            (# rReg,wReg: @integer; dr: @dataRegOperand
            do dr.alloc;
               dr.reg1->wReg;
               D[top]->rReg;
            exit(rReg,wReg)
            #)
       #);
     getXlong::
       (# 
       do 
          (if IMtrace then 
              '\tgetXlong\t%D'->amc.puttext;
              amc.newline
          if)          
       #);
     getXword::
       (# 
            (*enter dr[]*)
       do (if IMtrace then
              '\tgetXword'->amc.puttext;
          if);
       #);
     getXbyte::
       (# 
            (*enter dr[]*)
       do (if IMtrace then
              '\tgetXbyte'->amc.puttext;
          if);
       #);
     toXres:: (* NO longer in use - can be eliminated *)
       (# 
            (*enter rNo*)
       do (if IMtrace then
              '\ttoXres'->amc.puttext;
          if);
       #);
     GetRegForXres:: (* allocate register(s) for result of external call *)
       (#
       do (if IMtrace then 'GetRegForXres'->amc.emit if);
          (*exit (max,dummyMax)*)
       #);
     endX:<
       (# 
            (*enter (extType,exitType,BC,SC,LC,max,dummyMax)*)
       do  (if IMtrace then
              '\tendX'->amc.puttext;
          if);          
       #);
     GetComPar::
       (# 
       do (if IMtrace then
              ('GetCOMpar',none,none)->amc.emit2
          if);
       #);
     doHead::< (*FIXME*) 
       (# 
       do '\tDOHEAD'->amc.putline;
          1->thisRegOp;
          2->callRegOp;
          (if true (* sun4s - FIX THIS *) then
              thisRegOp[]->dataRegA[]
           else
              &dataRegOperand[]->dataRegA[];
              24->DataRegA;
          if);
          &dataRegOperand[]->dataRegB[];
          25->DataRegB;
          &dataRegOperand[]->dataRegX[];
          &dataRegOperand[]->dataRegY[];
          7->dataRegX;
          6->dataRegY;
          (* we start after this and callee*) 
          2->regCount;
          (* next from 2 *)           
          
       #);

     InitDataSeg::
       (# 
       do 
          'InitDataSeg called, isbetaenv:%d\n'
            -> lpf(# do initialBetaEnv->b2d->d#);
          doHead; (* moved from SPARCmachine *)
       #);
     newFragment::< 
       (# ;
       do 'NewFragment: %s %d\n'->lpf (#  do fn[]->s; astLabel->d #);
       #);
     newProto::
       (# ;
       do 
       #);
     newImp::
       (# ;
       do releaseReg; 
          (if false then
              '---newImp: '->amc.emit
              (#do astRef->amc.putint#)
          if);
       #);
     newEval::
       (# ;
       do
       #); 
     openDbgInf::
       (# ;
       do
       #);
     saveDbgInf::
       (# 
       do 
       #);
     initGen:: (*FIXME*)
       (# 
       do true->inGpart;
          'INITGEN, gpart-name: %s\n'->lpf (#  do EP[]->s #);
          (if IMtrace then
              'INITGEN, gpart-name: %s\n'->amc.putformat(#  do EP[]->s #);
          if);
       #);
     initDo:: (*FIXME*)
       (# 
       do 'INITDO: %s\n'->lpf (#  do EP[]->s #);
          'INITDO: %s\n'->amc.putformat (#  do EP[]->s #);

          (EP[],data)->GlobalLabelDef;
       #);
     EndCodeSeg:: (*FIXME*)
       (# 
       do 'EndcodeSeg called'->lpl;
       #);
     
     (********** handling of prototypes ********)
     
     InitEmitProtoIndexTable:: 
       (# 
       do 
       #);
     EmitProtoIndex:: 
       (# 
       do 
       #);
     EndEmitProtoIndexTable:: 
       (# 
       do 
       #);
     EmitProto:: 
       (# 
       do 
       #);
     EmitInnerTable:: 
       (# 
       do 
       #);
     InnerEntry:: 
       (# 
       do 
       #);
     EmitVirtAdr:: 
       (# 
       do 
       #); 
     EmitObjTableOff:: 
       (# 
       do 
       #);
     EmitText:: 
       (# 
       do 
       #);
     EmitRefTableOff::
       (# 
       do 
       #);


     init:: (*FIXME*)
       (# FN,T,t2: ^text
       do FIXME.init;
          BCname.copy->FN[];

          (if FN.length >= 5 then
              (FN.length-5,FN.length)->FN.sub->T[];
              (if '-BETA-'->T.equal then
                  (FN.length-5,FN.length)->FN.delete;
               else
                  'OOPS:'->puttext; FN[]->putline
              if)
           else
              'OOPS:'->puttext; FN[]->putline
          if);
          FN.copy->t[];
          FN.copy->t2[];
          '.amc'->FN.append;
          &amcFile[]->amc[];
          FN[]->amc.name;
          '.log'->t.append;
          t[]->logfile.name;
          '.opt'->t2.append;
          t2[]->optfile.name;
          optfile.openWrite;
          logfile.openWrite;
          'Opening .amc file: %s\n'->lpf (#  do fn[]->s #);
          amc.openWrite;
          
          1->ThisRegOp;
          2->CallRegOp;
          'Init called: Created real machine'->lpl
       #);
     close:: (*FIXME*)
       (# 
       do amc.close;
          'Closed amc-file'->logfile.putline;
          'Instructions:'->logfile.putline;
          (* IFragmentSet.printgraphs; *)
          (* (if not common.switch[250] then IFragmentSet.dumpvcg if); *)
          (* dumpObjectCode; *)

          'Closed RealMachine'->lpl;

          logfile.close;
          optfile.close;
       #);
     
     initCreateDataFile::
       (# 
       do 
       #);
     
     NextGroup::
       (#
       do 
       #);
     
     endCreateDataFile:: 
       (# 
       do 
       #);
     
     callFunc:
       (# op: ^text
       enter op[]
       do ('FUNC',op[]->newTextOp)->amc.emit1
       #);
     amc: ^amcFile;
     amcFile: file
       (# ptab: (* put tab *) (#  do '\t'->put;  #);
          emit:
            (# opr: ^text
            enter opr[]
            do ptab;
               opr[] ->puttext;
               ptab;
               INNER;
               amc.newline
            #);
          emit1: emit
            (# op1: ^moperand
            enter op1[]
            do (if op1[]<>none then
                   op1.out;
                   ptab;
               if);
               INNER;
            #);
          emit2: emit1
            (# op2: ^moperand
            enter op2[]
            do (if op2[]<>none then 
                   op2.out;
                   ptab;
               if);
               INNER;
            #);
          emit3: emit2
            (# op3: ^moperand
            enter op3[]
            do (if op3[]<>none then 
                   op3.out;
                   ptab;
               if);
               INNER;
            #);
       #);

     (* experiment for writing abstract machine code *)
     (* set by init in machine *)
     lpf: logfile.putformat(# do inner #);
  #)  

