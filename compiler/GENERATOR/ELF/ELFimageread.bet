ORIGIN '../imagereadbody';
LIB_ITEM 'imageread';
INCLUDE 'elfread';
MDBODY sun4s '../SUN4S/SUN4Simageread'
       linux '../LINUX/LINUXimageread'
       x86sol'../X86SOL/X86SOLimageread'
       sgi   '../SGI/SGIimageread';

(* Read ELF file segment into the two images
 * data_image and text_image.
 *)

--readDataAndTextImagesBody: descriptor--
(# f: @elfReader;
   gs: @f.getString;
   ep: ^EntryPointInfo;
   numsym: @integer;
   
   mapoffset: @
     (# off: @integer;
     enter off
     <<SLOT ImageReadMapOffset: dopart>>
     exit off
     #);
   
   mapsym: @
     (* Transform an ELF symbol into an EntryPointInfo.
      * If sym is a special symbol, not used internally in BETA
      * (e.g. a SECTION), NONE is returned.
      *)
     (# sym: ^Elf32_Sym;
        binding, type, defsec: @integer;
        ep: ^EntryPointInfo;
     enter sym[]
     do sym.st_info -> ELF32_ST_BIND -> binding;
        sym.st_info -> ELF32_ST_TYPE -> type;
        (if type=STT_SECTION then 
            NONE -> ep[];
            leave mapsym;            
         else
            sym.st_shndx -> defsec;
            &EntryPointInfo[] -> ep[];
            (if defsec=0 then
                false -> ep.local;
                false -> ep.export;
             else
                true -> ep.local;
                (if binding=STB_GLOBAL then
                    true -> ep.export;
             else
                    false -> ep.export;
                if)
            if);
            (f.cache.symtab_hdr.sh_link, sym.st_name) 
              -> gs -> ep.T[];
            (type=STT_OBJECT) -> ep.data;
            sym.st_value -> ep.LIP;
        if);
     exit ep[]
     #);
   
   mapreltype: @
     (# reltype, map: @integer;
     enter reltype
     <<SLOT ImageReadMapRelType: dopart>>
     exit map
     #);
   
do fname[] -> f.name;
   f.openread;
   &image[] -> data_image[];
   &image[] -> text_image[];
   
   (* 1. read buffers *)
   f.getData -> (data_image.buffer_ptr, data_image.buffer_size);
   data_image.buffer_size -> data_image.LIP;
   f.getText -> (text_image.buffer_ptr, text_image.buffer_size);
   text_image.buffer_size -> text_image.LIP;
   
   (* 2. Read symbol table into marks *)
   f.scanSymtabEnts;
   f.cache.symtab.range -> numsym;
   (* Cannot tell which symbols belong to which sections,
    * so set aside room for all symbols in both images.
    *)
   (if numsym > data_image.marks.range then
       numsym -> data_image.marks.new;
       numsym -> data_image.types.new;
       numsym -> data_image.epElm.new;
       0 -> data_image.marktop;
   if);
   (if numsym > text_image.marks.range then
       numsym -> text_image.marks.new;
       numsym -> text_image.types.new;
       numsym -> text_image.epElm.new;
       0 -> text_image.marktop;
   if);
   (* Now there is space enough. Now start copying all local 
    * symbols (corresponding to the entryDefMarks) into the 3 
    * arrays of both images.
    *)
   (for i:f.cache.symtab.range repeat
        f.cache.symtab[i][] -> mapsym -> ep[];
        (if (ep[]<>NONE) and ep.local then
            (if ep.data then
                data_image.marktop+1 -> data_image.marktop;
                ep.LIP -> mapoffset -> data_image.marks[data_image.marktop];
                entryDefMark -> data_image.types[data_image.marktop];
                ep[] -> data_image.epElm[data_image.marktop][];
             else
                text_image.marktop+1 -> text_image.marktop;
                ep.LIP -> mapoffset -> text_image.marks[text_image.marktop];
                entryDefMark -> text_image.types[text_image.marktop];
                ep[] -> text_image.epElm[text_image.marktop][];
            if);
        if);
   for);
   
   (* 3. Read relocation *)
   <<SLOT ImageReadRelocation: descriptor>>;
   
   f.close;
#)
