ORIGIN '~beta/basiclib/external';
LIB_DEF 'elf' '../../../lib';
(* elf.bet:
 *   Patterns for minipulating ELF objects.
 *   Describes the machine independent ELF definitions.
 *   See 'man a.out', /usr/include/sys/elf.h.
 * 
 *   $Id: elf.bet,v 1.5 2002-03-15 13:30:45 corry Exp $
 *)


--LIB: attributes--

(* From sys/elf.h *)

ELF32_FSZ_ADDR:    (# exit 4 #);
ELF32_FSZ_HALF:    (# exit 2 #);
ELF32_FSZ_OFF:     (# exit 4 #);
ELF32_FSZ_SWORD:   (# exit 4 #);
ELF32_FSZ_WORD:    (# exit 4 #);

(*
 *	ELF header
 *)

EI_NIDENT: (# exit 16 #);

Elf32_Ehdr: 
  (# 
     (* ident bytes *)
     (* Actually e_ident: [EI_NIDENT]@char *)
     e_ident0: @char;	
     e_ident1: @char;	
     e_ident2: @char;	
     e_ident3: @char;	
     e_ident4: @char;	
     e_ident5: @char;	
     e_ident6: @char;	
     e_ident7: @char;	
     e_ident8: @char;	
     e_ident9: @char;	
     e_ident10: @char;	
     e_ident11: @char;	
     e_ident12: @char;	
     e_ident13: @char;	
     e_ident14: @char;	
     e_ident115: @char;	
     
     e_type: @int16u (*Elf32_Half*);	     (* file type *)
     e_machine: @int16u (*Elf32_Half*);      (* target machine *)
     e_version: @integer (* Elf32_Word *);   (* file version *)
     e_entry: @integer (* Elf32_Addr *);     (* start address *)
     e_phoff: @integer (* Elf32_Off *);	     (* phdr file offset *)
     e_shoff: @integer (* Elf32_Off *);	     (* shdr file offset *)
     e_flags: @integer (* Elf32_Word *);     (* file flags *)
     e_ehsize: @int16u (*Elf32_Half*);	     (* sizeof ehdr *)
     e_phentsize: @int16u (*Elf32_Half*);    (* sizeof phdr *)
     e_phnum: @int16u (*Elf32_Half*);	     (* number phdrs *)
     e_shentsize: @int16u (*Elf32_Half*);    (* sizeof shdr *)
     e_shnum: @int16u (*Elf32_Half*);	     (* number shdrs *)
     e_shstrndx: @int16u (*Elf32_Half*);     (* shdr string index *)
  #);

EI_MAG0:     (# exit 0 #);		(* e_ident[] indexes *)
EI_MAG1:     (# exit 1 #);
EI_MAG2:     (# exit 2 #);
EI_MAG3:     (# exit 3 #);
EI_CLASS:    (# exit 4 #);
EI_DATA:     (# exit 5 #);
EI_VERSION:  (# exit 6 #);
EI_PAD:      (# exit 7 #);

ELFMAG0:      (# exit 0x7f #);		(* EI_MAG *)
ELFMAG1:      (# exit 'E' #);
ELFMAG2:      (# exit 'L' #);
ELFMAG3:      (# exit 'F' #);
(* ELFMAG:    (# exit '\177ELF' #); *)
ELFMAG:       (# 
              exit (ELFMAG0 %sll 24) %bor (ELFMAG1 %sll 16) 
                 %bor (ELFMAG2 %sll 8) %bor ELFMAG3
              #);

SELFMAG:      (# exit 4 #);

ELFCLASSNONE: (# exit 0 #);		(* EI_CLASS *)
ELFCLASS32:   (# exit 1 #);
ELFCLASS64:   (# exit 2 #);
ELFCLASSNUM:  (# exit 3 #);

ELFDATANONE:  (# exit 0 #);		(* EI_DATA *)
ELFDATA2LSB:  (# exit 1 #);
ELFDATA2MSB:  (# exit 2 #);
ELFDATANUM:   (# exit 3 #);

ET_NONE:  (# exit 0 #);		(* e_type *)
ET_REL:   (# exit 1 #);
ET_EXEC:  (# exit 2 #);
ET_DYN:   (# exit 3 #);
ET_CORE:  (# exit 4 #);
ET_NUM:   (# exit 5 #);

ET_LOPROC: (# exit 0xff00 #);   (* processor specific range *)
ET_HIPROC: (# exit 0xffff #);

EM_NONE:  (# exit 0 #);		(* e_machine *)
EM_M32:   (# exit 1 #);		(* AT&T WE 32100 *)
EM_SPARC: (# exit 2 #);		(* Sun SPARC *)
EM_386:   (# exit 3 #);		(* Intel 80386 *)
EM_68K:   (# exit 4 #);		(* Motorola 68000 *)
EM_88K:   (# exit 5 #);		(* Motorola 88000 *)
EM_486:   (# exit 6 #);		(* Intel 80486 *)
EM_860:   (# exit 7 #);		(* Intel i860 *)
EM_MIPS:  (# exit 8 #);
EM_PPC:   (# exit 20 #);        (* PowerPc - IBM OS/2 WARP *)
EM_NUM:   (# exit 10 #);

EV_NONE:    (# exit 0 #);	(* e_version, EI_VERSION *)
EV_CURRENT: (# exit 1 #);
EV_NUM:     (# exit 2 #);


(*
 *	Program header
 *)

Elf32_Phdr: 
  (#
     p_type: @integer (* Elf32_Word *);	    (* entry type *)
     p_offset: @integer (* Elf32_Off *);    (* file offset *)
     p_vaddr: @integer (* Elf32_Addr *);    (* virtual address *)
     p_paddr: @integer (* Elf32_Addr *);    (* physical address *)
     p_filesz: @integer (* Elf32_Word *);   (* file size *)
     p_memsz: @integer (* Elf32_Word *);    (* memory size *)
     p_flags: @integer (* Elf32_Word *);    (* entry flags *)
     p_align: @integer (* Elf32_Word *);    (* memory/file alignment *)
  #);

PT_NULL: (# exit 0 #);		(* p_type *)
PT_LOAD: (# exit 1 #);
PT_DYNAMIC: (# exit 2 #);
PT_INTERP: (# exit 3 #);
PT_NOTE: (# exit 4 #);
PT_SHLIB: (# exit 5 #);
PT_PHDR: (# exit 6 #);
PT_NUM: (# exit 7 #);

PT_LOPROC: (# exit 0x70000000 #);	(* processor specific range *)
PT_HIPROC: (# exit 0x7fffffff #);

PF_R: (# exit 0x4 #);		        (* p_flags *)
PF_W: (# exit 0x2 #);
PF_X: (# exit 0x1 #);

PF_MASKPROC: (# exit 0xf0000000 #);	(* processor specific values *)


(*
 *	Section header
 *)

Elf32_Shdr: 
  (#
     sh_name: @integer (* Elf32_Word *);	(* section name *)
     sh_type: @integer (* Elf32_Word *);	(* SHT_... *)
     sh_flags: @integer (* Elf32_Word *);	(* SHF_... *)
     sh_addr: @integer (* Elf32_Addr *);	(* virtual address *)
     sh_offset: @integer (* Elf32_Off *);	(* file offset *)
     sh_size: @integer (* Elf32_Word *);	(* section size *)
     sh_link: @integer (* Elf32_Word *);	(* link to another section *)
     sh_info: @integer (* Elf32_Word *);	(* misc info *)
     sh_addralign: @integer (* Elf32_Word *);	(* memory alignment *)
     sh_entsize: @integer (* Elf32_Word *);	(* entry size if table *)
  #);

SHT_NULL: (# exit 0 #);		(* sh_type *)
SHT_PROGBITS: (# exit 1 #);
SHT_SYMTAB: (# exit 2 #);
SHT_STRTAB: (# exit 3 #);
SHT_RELA: (# exit 4 #);
SHT_HASH: (# exit 5 #);
SHT_DYNAMIC: (# exit 6 #);
SHT_NOTE: (# exit 7 #);
SHT_NOBITS: (# exit 8 #);
SHT_REL: (# exit 9 #);
SHT_SHLIB: (# exit 10 #);
SHT_DYNSYM: (# exit 11 #);
SHT_NUM: (# exit 12 #);
SHT_LOUSER: (# exit 0x80000000 #);
SHT_HIUSER: (# exit 0xffffffff #);

SHT_LOPROC: (# exit 0x70000000 #);	(* processor specific range *)
SHT_HIPROC: (# exit 0x7fffffff #);

SHF_WRITE: (# exit 0x1 #);		(* sh_flags *)
SHF_ALLOC: (# exit 0x2 #);
SHF_EXECINSTR: (# exit 0x4 #);

SHF_MASKPROC: (# exit 0xf0000000 #);	(* processor specific values *)

SHN_UNDEF: (# exit 0 #);		(* special section numbers *)
SHN_LORESERVE: (# exit 0xff00 #);
SHN_ABS: (# exit 0xfff1 #);
SHN_COMMON: (# exit 0xfff2 #);
SHN_HIRESERVE: (# exit 0xffff #);

SHN_LOPROC: (# exit 0xff00 #);		(* processor specific range *)
SHN_HIPROC: (# exit 0xff1f #);


(*
 *	Symbol table
 *)

Elf32_Sym: 
  (#
     st_name: @integer (* Elf32_Word *);
     st_value: @integer (* Elf32_Addr *);
     st_size: @integer (* Elf32_Word *);
     st_info: @char;	                (* bind, type: ELF_32_ST_... *)
     st_other: @char;
     st_shndx: @int16u(*Elf32_Half*);	(* SHN_... *)
  #);

STN_UNDEF: (# exit 0 #);

(*
 *	The macros compose and decompose values for S.st_info
 *
 *	bind = ELF32_ST_BIND(S.st_info)
 *	type = ELF32_ST_TYPE(S.st_info)
 *	S.st_info = ELF32_ST_INFO(bind, type)
 *)

ELF32_ST_BIND:
  (# info: @char
  enter (info)		
  exit (info %srl 4)
  #);
ELF32_ST_TYPE:
  (# info: @char
  enter (info)		
  exit (info %band 0xf)
  #);
ELF32_ST_INFO:
  (# bind, type: @char
  enter (bind, type)		
  exit ((bind %sll 4)+(type %band 0xf))
  #);

STB_LOCAL:  (# exit 0 #);		(* BIND *)
STB_GLOBAL: (# exit 1 #);
STB_WEAK:   (# exit 2 #);
STB_NUM:    (# exit 3 #);

STB_LOPROC: (# exit 13 #);		(* processor specific range *)
STB_HIPROC: (# exit 15 #);

STT_NOTYPE:  (# exit 0 #);		(* TYPE *)
STT_OBJECT:  (# exit 1 #);
STT_FUNC:    (# exit 2 #);
STT_SECTION: (# exit 3 #);
STT_FILE:    (# exit 4 #);
STT_NUM:     (# exit 5 #);

STT_LOPROC: (# exit 13 #);		(* processor specific range *)
STT_HIPROC: (# exit 15 #);


(*
 *	Relocation
 *)

Elf32_Rel: 
  (#
     r_offset: @integer (* Elf32_Addr *);
     r_info: @integer (* Elf32_Word *);	 (* sym, type: ELF32_R_... *)
  #);

Elf32_Rela: 
  (#
     r_offset: @integer (* Elf32_Addr *);
     r_info: @integer (* Elf32_Word *);	   (* sym, type: ELF32_R_... *)
     r_addend: @integer (* Elf32_Sword *);
  #);

(*
 *	The macros compose and decompose values for 
 *      Rel.r_info, Rela.f_info
 *
 *	sym = ELF32_R_SYM(R.r_info)
 *	type = ELF32_R_TYPE(R.r_info)
 *	R.r_info = ELF32_R_INFO(sym, type)
 * 
 *      In C:
 *        #define	ELF32_R_SYM(info)	((info)>>8)
 *        #define	ELF32_R_TYPE(info)	((unsigned char)(info))
 *        #define	ELF32_R_INFO(sym, type)	(((sym)<<8)+(unsigned char)(type))
 *)

ELF32_R_SYM:
  (# info: @integer
  enter info
  exit  (info %srl 8)
  #);
ELF32_R_TYPE:
  (# info: @integer
  enter info 
  exit info %Band 0xf
  #);
ELF32_R_INFO:
  (# sym, type: @integer
  enter (sym, type)
  exit ((sym %sll 8) + (type %Band 0xf))
  #);

(*
 *	Note entry header
 *)

Elf32_Nhdr: 
  (#
    n_namesz: @integer (* Elf32_Word *);  (* length of note's name *)
    n_descsz: @integer (* Elf32_Word *);  (* length of note's "desc" *)
    n_type: @integer (* Elf32_Word *);	  (* type of note *)
  #);

(*
 *	Known values for note entry types (e_type == ET_CORE)
 *)

NT_PRSTATUS: (# exit 1 #);
NT_PRFPREG: (# exit 2 #);
NT_PRPSINFO: (# exit 3 #);

(* Header sizes *)
elfheadersize: (# exit 52 #);
sectionheadersize: (# exit 40 #);
symentsize: (# exit 16 #);
relsize: (# exit 8 #);
relasize: (# exit 12 #);
