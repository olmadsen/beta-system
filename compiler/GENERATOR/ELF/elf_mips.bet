ORIGIN 'elf';
LIB_ITEM 'elf';
(* elf_mips.bet:
 *    MIPS dependent ELF definitions.
 *
 *    $Id: elf_mips.bet,v 1.3 2002-03-05 15:14:28 corry Exp $
 *) 

--LIB: attributes--

(* From sys/elf.h *)

(* 
 * Random constants
 *)

_TEXT_ALIGN : (# exit 0x10000 #);
_DATA_ALIGN : (# exit 0x10000 #);
ELF_MIPS_MAXPGSZ: (# exit (64*1024) #);
ELF_MIPS_MINPGSZ: (# exit (0x1000) #);

(* ====================================================================
 *
 * Program header
 *
 * ====================================================================
 *)

(*
 * e_flags
 *)

EF_MIPS_NOREORDER:	(# exit 0x00000001 #);
EF_MIPS_OPSEX:		(# exit EF_MIPS_NOREORDER #);
EF_MIPS_PIC:		(# exit 0x00000002 #);
EF_MIPS_CPIC:		(# exit 0x00000004 #);
EF_MIPS_UGEN_ALLOC:	(# exit 0x00000008 #);
EF_MIPS_UGEN_RESERVED:	(# exit 0x00000010 #); (* reserved for future use *)
EF_MIPS_ABI2:		(# exit 0x00000020 #); 
EF_MIPS_ARCH:		(# exit 0xf0000000 #);
EF_MIPS_ARCH_1:		(# exit 0x00000000 #);
EF_MIPS_ARCH_2:         (# exit 0x10000000 #);
EF_MIPS_ARCH_3:         (# exit 0x20000000 #);
EF_MIPS_ARCH_4:         (# exit 0x30000000 #);


(* 
 * special Program header types
 *)

PT_MIPS_REGINFO: (# exit (PT_LOPROC + 0) #);
PT_MIPS_RTPROC:  (# exit (PT_LOPROC + 1) #); (* runtime procedure table *)
PT_MIPS_OPTIONS: (# exit (PT_LOPROC + 2) #);


(* 
 * special p_flags
 *)

PF_MIPS_LOCAL:		(# exit 0x10000000 #);


(* ====================================================================
 *
 * Section Headers
 *
 * ====================================================================
 *)

(* 
 * Special mips section indices
 *)

SHN_MIPS_ACOMMON:	(# exit (SHN_LOPROC + 0) #);
SHN_MIPS_TEXT:		(# exit (SHN_LOPROC + 1) #);
SHN_MIPS_DATA:		(# exit (SHN_LOPROC + 2) #);
SHN_MIPS_SCOMMON:	(# exit (SHN_LOPROC + 3) #);
SHN_MIPS_SUNDEFINED:	(# exit (SHN_LOPROC + 4) #);


(*
 * sh_type
 *)

SHT_MIPS_LIBLIST:	(# exit (SHT_LOPROC + 0) #);
SHT_MIPS_MSYM:		(# exit (SHT_LOPROC + 1) #);
SHT_MIPS_CONFLICT:	(# exit (SHT_LOPROC + 2) #);
SHT_MIPS_GPTAB:		(# exit (SHT_LOPROC + 3) #);
SHT_MIPS_UCODE:		(# exit (SHT_LOPROC + 4) #);
SHT_MIPS_DEBUG:         (# exit (SHT_LOPROC + 5) #);
SHT_MIPS_REGINFO:       (# exit (SHT_LOPROC + 6) #);
SHT_MIPS_PACKAGE:       (# exit (SHT_LOPROC + 7) #);
SHT_MIPS_PACKSYM:       (# exit (SHT_LOPROC + 8) #);

SHT_MIPS_RELD:		(# exit (SHT_LOPROC + 9) #);
SHT_MIPS_DONTUSE:	(# exit (SHT_LOPROC + 10) #);
(* Don't use 10 until after the ragnarok beta *)
SHT_MIPS_IFACE:		(# exit (SHT_LOPROC + 11) #);
SHT_MIPS_CONTENT:	(# exit (SHT_LOPROC + 12) #);
SHT_MIPS_OPTIONS:	(# exit (SHT_LOPROC + 13) #);

SHT_MIPS_SHDR:		(# exit (SHT_LOPROC + 16) #);
SHT_MIPS_FDESC:		(# exit (SHT_LOPROC + 17) #);
SHT_MIPS_EXTSYM:	(# exit (SHT_LOPROC + 18) #);
SHT_MIPS_DENSE:		(# exit (SHT_LOPROC + 19) #);
SHT_MIPS_PDESC:		(# exit (SHT_LOPROC + 20) #);
SHT_MIPS_LOCSYM:	(# exit (SHT_LOPROC + 21) #);
SHT_MIPS_AUXSYM:	(# exit (SHT_LOPROC + 22) #);
SHT_MIPS_OPTSYM:	(# exit (SHT_LOPROC + 23) #);
SHT_MIPS_LOCSTR:	(# exit (SHT_LOPROC + 24) #);
SHT_MIPS_LINE:		(# exit (SHT_LOPROC + 25) #);
SHT_MIPS_RFDESC:	(# exit (SHT_LOPROC + 26) #);

SHT_MIPS_DELTASYM:	(# exit (SHT_LOPROC + 27) #);
SHT_MIPS_DELTAINST:	(# exit (SHT_LOPROC + 28) #);
SHT_MIPS_DELTACLASS:	(# exit (SHT_LOPROC + 29) #);

SHT_MIPS_DWARF:		(# exit (SHT_LOPROC + 30) #);
SHT_MIPS_DELTADECL:	(# exit (SHT_LOPROC + 31) #);
SHT_MIPS_SYMBOL_LIB:	(# exit (SHT_LOPROC + 32) #);
SHT_MIPS_EVENTS:        (# exit (SHT_LOPROC + 33) #);
SHT_MIPS_TRANSLATE:     (# exit (SHT_LOPROC + 34) #);
SHT_MIPS_PIXIE:     	(# exit (SHT_LOPROC + 35) #);
SHT_MIPS_XLATE:		(# exit (SHT_LOPROC + 36) #);
SHT_MIPS_XLATE_DEBUG:	(# exit (SHT_LOPROC + 37) #);

SHT_MIPS_NUM:		(# exit 37 #);

(*
 * sh_flags
 *)

SHF_MIPS_GPREL:		(# exit 0x10000000 #);
SHF_MIPS_MERGE:		(# exit 0x20000000 #);	
SHF_MIPS_ADDR:		(# exit 0x40000000 #);
SHF_MIPS_STRINGS:	(# exit 0x80000000 #);
SHF_MIPS_NOSTRIP: 	(# exit 0x08000000 #);
SHF_MIPS_LOCAL:		(# exit 0x04000000 #);
SHF_MIPS_NAMES:		(# exit 0x02000000 #);


(*
 * special section names
 *)

MIPS_SDATA:		(# exit '.sdata' #);
MIPS_REL_SDATA:		(# exit '.rel.sdata' #);
MIPS_SBSS:		(# exit '.sbss' #);
MIPS_LIT4:		(# exit '.lit4' #);
MIPS_LIT8:		(# exit '.lit8' #);
MIPS_REGINFO:		(# exit '.reginfo' #);
MIPS_LIBLIST:		(# exit '.liblist' #);
MIPS_MSYM:		(# exit '.msym' #);
MIPS_RHEADER:		(# exit '.rheader' #);
MIPS_CONFLICT:		(# exit '.conflict' #);
MIPS_GPTAB_SDATA:	(# exit '.gptab.sdata' #);
MIPS_GPTAB_DATA:	(# exit '.gptab.data' #);
MIPS_GPTAB_BSS:		(# exit '.gptab.bss' #);
MIPS_GPTAB_SBSS:	(# exit '.gptab.sbss' #);
MIPS_LBSS:		(# exit '.lbss' #);
MIPS_UCODE:		(# exit '.ucode' #);
MIPS_MDEBUG:		(# exit '.mdebug' #);
MIPS_COMPACT_RELOC:	(# exit '.compact_rel' #);
MIPS_PACKAGE:		(# exit '.package' #);
MIPS_PACKSYM:		(# exit '.packsym' #);
MIPS_CONTENT:		(# exit '.MIPS.content' #);
MIPS_EVENTS:		(# exit '.MIPS.events' #);
MIPS_INTERFACES:	(# exit '.MIPS.interfaces' #);
MIPS_OPTIONS:		(# exit '.MIPS.options' #);
MIPS_DELTACLASS:	(# exit '.MIPS.dclass' #);
MIPS_DELTASYM:		(# exit '.MIPS.dsym' #);
MIPS_DELTAINST:		(# exit '.MIPS.dinst' #);
MIPS_DELTADECL:		(# exit '.MIPS.ddecl' #);
MIPS_REL_DELTA:		(# exit '.rel.delta' #);
MIPS_SYMBOL_LIB:	(# exit '.MIPS.symlib' #);
MIPS_DEBUG_INFO:	(# exit '.debug_info' #);
MIPS_DEBUG_LINE:	(# exit '.debug_line' #);
MIPS_DEBUG_ABBREV:	(# exit '.debug_abbrev' #);
MIPS_DEBUG_FRAME:	(# exit '.debug_frame' #);
MIPS_DEBUG_ARANGES:	(# exit '.debug_aranges' #);
MIPS_DEBUG_PUBNAMES:	(# exit '.debug_pubnames' #);
MIPS_DEBUG_STR:		(# exit '.debug_str' #);
MIPS_DEBUG_FUNCNAMES:	(# exit '.debug_funcnames' #);
MIPS_DEBUG_TYPENAMES:	(# exit '.debug_typenames' #);
MIPS_DEBUG_VARNAMES:	(# exit '.debug_varnames' #);
MIPS_DEBUG_WEAKNAMES:	(# exit '.debug_weaknames' #);
MIPS_XLATE:		(# exit '.MIPS.Xlate' #);
MIPS_XLATE_DEBUG:	(# exit '.MIPS.Xlate_debug' #);


(* ====================================================================
 *
 * Symbol table
 *
 * ====================================================================
 *)

(*
 * Special mips st_other
 *)
STO_DEFAULT:		(# exit 0x0 #);
STO_INTERNAL:		(# exit 0x1 #);
STO_HIDDEN:		(# exit 0x2 #);
STO_PROTECTED:		(# exit 0x3 #);


(* ====================================================================
 *
 * .gptab Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef union
 * {
 * 	struct
 * 	{
 * 		Elf32_Word	gt_current_g_value;
 * 		Elf32_Word	gt_unused;
 * 	} gt_header;
 * 	struct
 * 	{
 * 		Elf32_Word	gt_g_value;
 * 		Elf32_Word	gt_bytes;
 * 	} gt_entry;
 * } Elf32_Gptab;
 * #endif
 *)


(* ====================================================================
 *
 * .reginfo Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 * 	Elf32_Word	ri_gprmask;
 * 	Elf32_Word	ri_cprmask[4];
 * 	Elf32_Sword	ri_gp_value;
 * } Elf32_RegInfo;
 * #endif
 *)


(* ====================================================================
 *
 * .options Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 * 	Elf32_Byte	kind;		{* determines interpretation of the *}
 * 					{* variable part of descriptor	    *}
 * 	Elf32_Byte	size;		{* size of descriptor, incl. header *}
 * 	Elf32_Section	section;	{* section header index of section  *}
 * 					{* affected, 0 for global options   *}
 * 	Elf32_Word	info;		{* Kind-specific information	    *}
 * } Elf_Options;
 * #endif
 *)

(*
 * Options descriptor kinds
 *)

ODK_NULL:	(# exit 0 #);	(* Undefined *)
ODK_REGINFO:	(# exit 1 #);	(* Register usage information *)
ODK_EXCEPTIONS:	(# exit 2 #);	(* Exception processing options  *)
ODK_PAD:	(# exit 3 #);	(* Section padding options *)
ODK_HWPATCH:    (# exit 4 #);       (* Hardware workarounds performed *)
ODK_FILL:	(# exit 5 #);	(* record the fill value used by the linker *)
ODK_TAGS:	(# exit 6 #);	(* reserve space for desktop tools to write *)

(* Masks for the info word of an ODK_EXCEPTIONS descriptor: *)
OEX_FPU_MIN:    (# exit 0x1f #);    (* FPE's which MUST be enabled *)
OEX_FPU_MAX:    (# exit 0x1f00 #);  (* FPE's which MAY be enabled *)
OEX_PAGE0:      (# exit 0x10000 #); (* page zero must be mapped *)
OEX_SMM:	(# exit 0x20000 #); (* Force sequential memory mode? *)
OEX_FPDBUG:     (# exit 0x40000 #); (* Force floating point debug mode? *)
OEX_PRECISEFP:  (# exit OEX_FPDBUG #);
OEX_DISMISS:	(# exit 0x80000 #); (* Dismiss invalid address faults? *)

OEX_FPU_INVAL:	(# exit 0x10 #);
OEX_FPU_DIV0:	(# exit 0x08 #);
OEX_FPU_OFLO:	(# exit 0x04 #);
OEX_FPU_UFLO:	(# exit 0x02 #);
OEX_FPU_INEX:	(# exit 0x01 #);

(* Masks for the info word of an ODK_HWPATCH descriptor: *)
OHW_R4KEOP:     (# exit 0x1 #);	(* R4000 end-of-page patch *)

OPAD_PREFIX:	(# exit 0x1 #);
OPAD_POSTFIX:	(# exit 0x2 #);
OPAD_SYMBOL:	(# exit 0x4 #);

(* ====================================================================
 *
 * .rel, .rela Section
 *
 * ====================================================================
 *)

(*
 * relocation types
 *)

R_MIPS_NONE:		(# exit 0 #);
R_MIPS_16:		(# exit 1 #);
R_MIPS_32:		(# exit 2 #);
R_MIPS_ADD:		(# exit R_MIPS_32 #);
R_MIPS_REL:		(# exit 3 #);
R_MIPS_REL32:		(# exit R_MIPS_REL #);
R_MIPS_26:		(# exit 4 #);
R_MIPS_HI16:		(# exit 5 #);
R_MIPS_LO16:		(# exit 6 #);
R_MIPS_GPREL:		(# exit 7 #);
R_MIPS_GPREL16:		(# exit R_MIPS_GPREL #);
R_MIPS_LITERAL:		(# exit 8 #);
R_MIPS_GOT:		(# exit 9 #);
R_MIPS_GOT16:		(# exit R_MIPS_GOT #);
R_MIPS_PC16:		(# exit 10 #);
R_MIPS_CALL:		(# exit 11 #);
R_MIPS_CALL16:		(# exit R_MIPS_CALL #);
R_MIPS_GPREL32:		(# exit 12 #);

R_MIPS_SHIFT5:		(# exit 16 #);
R_MIPS_SHIFT6:		(# exit 17 #);
R_MIPS_64:		(# exit 18 #);
R_MIPS_GOT_DISP:	(# exit 19 #);
R_MIPS_GOT_PAGE:	(# exit 20 #);
R_MIPS_GOT_OFST:	(# exit 21 #);
R_MIPS_GOT_HI16:	(# exit 22 #);
R_MIPS_GOT_LO16:	(# exit 23 #);
R_MIPS_SUB:		(# exit 24 #);
R_MIPS_INSERT_A:	(# exit 25 #);
R_MIPS_INSERT_B:	(# exit 26 #);
R_MIPS_DELETE:		(# exit 27 #);
R_MIPS_HIGHER:		(# exit 28 #);
R_MIPS_HIGHEST:		(# exit 29 #);
R_MIPS_CALL_HI16:	(# exit 30 #);
R_MIPS_CALL_LO16:	(# exit 31 #);
R_MIPS_SCN_DISP:	(# exit 32 #);
R_MIPS_REL16:           (# exit	33 #);
R_MIPS_ADD_IMMEDIATE:   (# exit 34 #);

_R_MIPS_COUNT_:		(# exit 35 #);	(* Number of relocations *)

R_MIPS_LOVENDER:	(# exit 100 #); (* Vendor specific relocations *)
R_MIPS_HIVENDOR:	(# exit 127 #);

(* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% *)
		(*
		 * !!! WARNING !!!
		 * 
		 * The format of both the .contents sections
		 * and .events sections are changing and the
		 * following macros are probably WRONG! They
		 * are here to prevent possible build breaks
		 * in case some of the tools used the macros
		 * following the original specification.
		 *)
(* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% *)

(* ====================================================================
 *
 * .content Section
 *
 * sh_type:	SHT_MIPS_CONTENT
 * sh_link:	section header index of section classified
 * sh_info:	0
 * attributes:	SHF_ALLOC, SHF_MIPS_NOSTRIP
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef union {
 *     struct {				{* Normal descriptor *}
 * 	Elf32_Word	con_info;
 * 	Elf32_Word	con_start;
 *     } con_y;
 *     Elf32_Word	con_xval;		{* Extension descriptor *}
 * } Elf32_Content;
 * 
 * {* con_info masks: *}
 * __CON32_EMASK:	(# exit 0x80000000 #);
 * __CON32_ESHIFT:	(# exit 31 #);
 * __CON32_KMASK:	(# exit 0x7f000000 #);
 * __CON32_KSHIFT:	(# exit 24 #);
 * __CON32_LMASK:	(# exit 0x00ffffff #);
 * __CON32_VMASK:	(# exit 0x7fffffff #);
 * 
 * {* Access macros: *}
 * #define ELF32_CON_EXTN(c) \
 * 	(((c).con_y.con_info & __CON32_EMASK)>>__CON32_ESHIFT)
 * #define ELF32_CON_KIND(c) \
 * 	(((c).con_y.con_info & __CON32_KMASK)>>__CON32_KSHIFT)
 * #define Set_ELF32_CON_KIND(c,v) \
 * 	((c).con_y.con_info = ((c).con_y.con_info & ~__CON32_KMASK) | (v<<__CON32_KSHIFT))
 * #define ELF32_CON_LENGTH(c)	((c).con_y.con_info & __CON32_LMASK)
 * #define Set_ELF32_CON_LENGTH(c,v) \
 * 	((c).con_y.con_info = ((c).con_y.con_info & ~__CON32_LMASK) | (v&__CON32_LMASK))
 * #define ELF32_CON_XVAL(c)	((c).con_xval & __CON32_VMASK)
 * 
 * {* Content kind -- valid for ELF-32 and ELF-64: *}
 * typedef enum {
 *     CK_NULL	= 0,	    {* Invalid, same as EK_NULL *}
 *     CK_DEFAULT	= 0x30,	    {* Default type of data for section *}
 *     CK_ALIGN	= 0x31,	    {* Alignment for described range *}
 *     CK_INSTR	= 0x32,	    {* Instructions *}
 *     CK_DATA	= 0x33,	    {* Non-address data *}
 *     CK_SADDR_32	= 0x34,	    {* Simple 32-bit addresses *}
 *     CK_GADDR_32	= 0x35,	    {* GP-relative 32-bit addresses *}
 *     CK_CADDR_32	= 0x36,	    {* Complex 32-bit addresses *}
 *     CK_SADDR_64	= 0x37,	    {* Simple 64-bit addresses *}
 *     CK_GADDR_64	= 0x38,	    {* GP-relative 64-bit addresses *}
 *     CK_CADDR_64	= 0x39,	    {* Complex 64-bit addresses *}
 *     CK_NO_XFORM	= 0x3a,	    {* No transformations allowed in this range *}
 *     CK_NO_REORDER = 0x3b    {* No reordering allowed in this range *}
 * } Elf_Content_Kind;
 * 
 * 
 * #endif
 *)


(* ====================================================================
 *
 * .events Section
 *
 * sh_type:	SHT_MIPS_EVENTS
 * sh_link:	section header index of section whose events tracked
 * sh_info:	section header index of associated interface section
 * attributes:	SHF_ALLOC, SHF_MIPS_NOSTRIP
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * {* Event kind -- valid for ELF-32 and ELF-64: *}
 * typedef enum {
 *     EK_NULL = 0x00,	    {* No valid information *}
 *     EK_ADDR_RESET = 0x01,   {* Reset offset into associated text section *}
 *     EK_INCR_LOC_EXT = 0x02, {* Increment offset into associated text section *}
 *     EK_ENTRY = 0x03,	    {* Subprogram entrypoint *}
 *     EK_IF_ENTRY = 0x04,	    {* Subprogram entrypoint with associated interface offset *}
 *     EK_EXIT = 0x05,	    {* Subprogram exit *}
 *     EK_PEND = 0x06,	    {* Subprogram end (last instruction) *}
 * 
 *     EK_SWITCH_32 = 0x7,	    {* jr for switch stmt, table entries are 32bit *}
 *     EK_SWITCH_64 = 0x8,	    {* jr for switch stmt, table entries are 64bit *}
 *     EK_DUMMY = 0x09,	    {* empty slot *}
 * 
 *     EK_BB_START = 0x0a,	    {* Basic block beginning *}
 *     EK_INCR_LOC_UNALIGNED = 0x0b,    {* Increment unaligned byte offset *}
 *     EK_GP_PROLOG_HI = 0x0c, {* Establish high 16bits of GP *}
 *     EK_GP_PROLOG_LO = 0x0d, {* Establish low 16bits of GP *}
 *     EK_GOT_PAGE = 0x0e,	    {* Compact relocation: GOT page pointer *}
 *     EK_GOT_OFST = 0x0f,     {* Compact relocation: GOT page offset *}
 *     EK_HI = 0x10,	    {* Compact relocation: high 16bits of abs. addr *}
 *     EK_LO = 0x11,	    {* Compact relocation: low 16bits of abs. addr *}
 *     EK_64_HIGHEST = 0x12,   {* Compact relocation: most significant 16 bits
 * 			       of a 64bit absolute address *}
 *     EK_64_HIGHER = 0x13,    {* Compact relocation: second most significant
 * 			       16 bits of a 64bit absolute address *}
 *     EK_64_HIGH = 0x14,	    {* Compact relocation: third most significant
 * 			       16 bits of a 64bit absolute address *}
 *     EK_64_LOW = 0x15,       {* Compact relocation: least significant 16 bits
 * 			       of a 64bit absolute address *}
 *     EK_GPREL = 0x16,        {* Compact relocation: GP relative reference *}
 * 
 *     EK_DEF = 0x17,	    {* Define new event kind format *}
 * 
 *     EK_FCALL_LOCAL = 0x18,	{* point-of-call (jalr) to a local procedure *}
 *     EK_FCALL_EXTERN = 0x19,	{* jalr to extern procedure (small got case) *}
 *     EK_FCALL_EXTERN_BIG = 0x1a,	{* jalr to extern procedure (large got case) *}
 *     EK_FCALL_MULT = 0x1b,	{* jalr to more than one procedure *}
 *     EK_FCALL_MULT_PARTIAL = 0x1c, {* jalr to multiple + unknown procedures *}
 * 
 *     EK_INCR_LOC = 0x80	    {* Increment offset into associated text section *}
 * } Elf_Event_Kind;
 * 
 * {* The following defines list the various types of operands that are 
 *  * supported with the EK_DEF event kind.
 *  *}
 * #define EK_DEF_UCHAR	(1)	    {* unsigned char (8 bits) *}
 * #define EK_DEF_USHORT	(2)	    {* unsigned short (16 bits) *}
 * #define EK_DEF_UINT	(3)	    {* unsigned int (32 bits) *}
 * #define EK_DEF_ULONG	(4)	    {* unsigned long (64 bits) *}
 * #define EK_DEF_ULEB128	(5)	    {* unsigned LEB128 encoded number *}
 * #define EK_DEF_CHAR	(6)	    {* signed char (8 bits) *}
 * #define EK_DEF_SHORT	(7)	    {* signed short (16 bits) *}
 * #define EK_DEF_INT	(8)	    {* signed int (32 bits) *}
 * #define EK_DEF_LONG	(9)	    {* signed long (64 bits) *}
 * #define EK_DEF_LEB128	(10)	    {* signed LEB128 encoded number *}
 * #define EK_DEF_STRING	(11)	    {* null terminated string *}
 * #define EK_DEF_VAR	(12)	    {* variable length field: the first 2
 * 				       bytes is an unsigned short
 * 				       specifying the total number of bytes
 * 				       of this field including the first 2
 * 				       bytes *}
 * CK_DEF: (# exit EK_DEF #);    
 * 
 * #endif
 *)

(* ====================================================================
 *
 * .interfaces Section
 *
 * sh_type:	SHT_MIPS_IFACE
 * sh_link:	section header index of associated symbol table
 * sh_info:	0
 * attributes:	SHF_ALLOC, SHF_MIPS_NOSTRIP
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * 
 * typedef struct {
 *     Elf64_Word symbol;		{* symbol table index of subprogram, or 0 *}
 *     Elf64_Half attrs;		{* Attributes: See list below *}
 *     Elf64_Byte pcnt;		{* Parameter count *}
 *     Elf64_Byte fpmask;		{* bit on indicates an FP parameter register *}
 * } Elf_Interface_Descriptor;
 * 
 * 
 * {* Flags that can be set in the 'attrs' field of Elf_Interface_Descriptor *}
 * SA_PROTOTYPED:	(# exit 0x8000 #);	{* Does def or ref have prototype ? *}
 * SA_VARARGS:	(# exit 0x4000 #);	{* Is this a varargs subprogram ? *}
 * SA_PIC:		(# exit 0x2000 #);	{* Are memory references PIC? *}
 * SA_DSO_ENTRY:	(# exit 0x1000 #);	{* Is subprogram valid DSO entry? *}
 * SA_ADDRESSED:	(# exit 0x0800 #);	{* Is subprogram address taken? *}
 * SA_FUNCTION:	(# exit 0x0400 #);	{* Does subprogram return a result? *}
 * SA_NESTED:	(# exit 0x0200 #);	{* Is subprogram nested? *}
 * SA_DEFINITION:	(# exit 0x0080 #);	{* Is this a definition (no just call)? *}
 * SA_AT_FREE:	(# exit 0x0040 #);	{* Is the at register free at all branches? *}
 * SA_FREE_REGS:	(# exit 0x0020 #);	{* Free register mask precedes parm profile *}
 * SA_PARAMETERS:	(# exit 0x0010 #);	{* Parameter profile follows descriptor? *}
 * SA_ALTINTERFACE: (# exit 0x0008 #);	{* Alternate descriptor follows? *}
 * 
 * {* Parameter descriptor masks *}
 * PDM_TYPE:	(# exit 0x00ff #);	{* Fundamental type of parameter *}
 * PDM_REFERENCE:	(# exit 0x4000 #);	{* Reference parameter ? *}
 * PDM_SIZE:	(# exit 0x2000 #);	{* Followed by explicit 32-bit byte count? *}
 * PDM_Qualifiers:	(# exit 0x0f00 #);	{* Count of type qualifiers << 8 *}
 * 
 * #endif
 *)

(* ====================================================================
 *
 * .liblist Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 * 	Elf32_Word	l_name;
 * 	Elf32_Word	l_time_stamp;
 * 	Elf32_Word	l_checksum;
 * 	Elf32_Word	l_version;
 * 	Elf32_Word	l_flags;
 * } Elf32_Lib;
 * #endif
 *)


(*
 * l_flags
 *)

LL_NONE:		(# exit 0 #);
LL_EXACT_MATCH:		(# exit 0x1 #);
LL_IGNORE_INT_VER:	(# exit 0x2 #);
LL_REQUIRE_MINOR:	(# exit 0x4 #);
LL_EXPORTS:		(# exit 0x8 #);
LL_DELAY_LOAD:		(# exit 0x10 #);

LL_DELTA:               (# exit 0x20 #);

(* ====================================================================
 *
 * .conflict Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef Elf32_Addr Elf32_Conflict;
 * #endif
 * 
 * #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * extern Elf32_Conflict	_ConflictList [];
 * #endif
 *)

RLD_VERSION:            (# exit 1 #);


(* ====================================================================
 *
 * .got Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 * 	Elf32_Addr	g_index;
 * } Elf32_Got;
 * 
 * 
 * typedef struct
 * {
 * 	Elf64_Addr	g_index;
 * } Elf64_Got;
 * 
 * extern Elf32_Got	_GlobalOffsetTable [];
 * 
 * extern Elf64_Got	_GlobalOffsetTable64 [];
 * 
 * #endif
 * 
 *)

(* ====================================================================
 *
 * .package Section
 *
 * Multiple package entries for the same package are allowed
 * in order to express out of order symbols in a package.
 *
 * ====================================================================
 *)

(* #ifdef __osf__
 * 
 * #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	Elf32_Word	pkg_name;	{* index into String Space of name *}
 * 	Elf32_Word	pkg_version;	{* index into String Space of version string *}
 * 	Elf32_Half	pkg_flags;	{* package flags *}
 * } Elf32_Package;
 * #endif
 * 
 * #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * extern Elf32_Package	_PackageList [];
 * #endif
 * 
 * 
 * {*
 *  * pkg_name --
 *  * index of a string that identifies the name of this package
 *  * implementation, which cannot be the null string; the offset is in
 *  * bytes of a zero terminated string from the start of the .dynstr section
 *  * pkg_version --
 *  * index of a string that identifies the version of this package
 *  * implementation, which may be the null string; the offset is in
 *  * bytes of a zero terminated string from the start of the .dynstr section
 *  * pkg_flags --
 *  * export flag means package is exported, import flag means package is imported,
 *  * both flags must be set if a package is exported and is also used by other
 *  * packages within the shared library.  continuance flag means that this
 *  * package entry defines additional symbols for a previously defined
 *  * package.  continuance entries must exactly match the original entry in each
 *  * field, except for the pkg_start, pkg_count, and continuance flag in the pkg_flags.
 *  * The conflict flag is a possibility for future support for symbol preemption.
 *  *}
 * 
 * {*
 *  * pkg_flags
 *  *}
 * 
 * PKGF_EXPORT:	(# exit 0x1 #);
 * PKGF_IMPORT:	(# exit 0x2 #);
 * {* PKGF_CONFLICT:	(# exit 0x8 #); *}
 * 
 * #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef Elf32_Word Elf32_Package_Symbol;
 * #endif
 * 
 * #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * #define	PACKSYM_NULL_INDEX	((Elf32_Word) 0)
 * #endif
 * 
 * #endif {* __osf__ *}
 *)


(* ====================================================================
 *
 * .dynamic Section
 *
 * ====================================================================
 *)

DT_MIPS_RLD_VERSION:     (# exit 0x70000001 #);
DT_MIPS_TIME_STAMP:      (# exit 0x70000002 #);
DT_MIPS_ICHECKSUM:       (# exit 0x70000003 #);
DT_MIPS_IVERSION:        (# exit 0x70000004 #);
DT_MIPS_FLAGS:           (# exit 0x70000005 #);
DT_MIPS_BASE_ADDRESS:    (# exit 0x70000006 #);
DT_MIPS_MSYM:            (# exit 0x70000007 #);
DT_MIPS_CONFLICT:        (# exit 0x70000008 #);
DT_MIPS_LIBLIST:         (# exit 0x70000009 #);
DT_MIPS_LOCAL_GOTNO:     (# exit 0x7000000A #);
DT_MIPS_CONFLICTNO:      (# exit 0x7000000B #);
DT_MIPS_LIBLISTNO:       (# exit 0x70000010 #);
DT_MIPS_SYMTABNO:        (# exit 0x70000011 #);
DT_MIPS_UNREFEXTNO:      (# exit 0x70000012 #);
DT_MIPS_GOTSYM:          (# exit 0x70000013 #);
DT_MIPS_HIPAGENO:        (# exit 0x70000014 #);
(* 0x70000015 is skipped *)
DT_MIPS_RLD_MAP:         (# exit 0x70000016 #);
DT_MIPS_DELTA_CLASS: 	(# exit 0x70000017 #);	(* contains Delta C++ class definition *)
DT_MIPS_DELTA_CLASS_NO: 	(# exit 0x70000018 #);	(* the number of entries in DT_MIPS_DELTA_CLASS *)
DT_MIPS_DELTA_INSTANCE:	(# exit 0x70000019 #);	(* contains Delta C++ class instances *)
DT_MIPS_DELTA_INSTANCE_NO:	(# exit 0x7000001A #);	(* the number of entries in DT_MIPS_DELTA_INSTANCE *)
DT_MIPS_DELTA_RELOC:	(# exit 0x7000001B #);	(* contains Delta relocations *)
DT_MIPS_DELTA_RELOC_NO:	(# exit 0x7000001C #);	(* the number of entries in DT_M
IPS_DELTA_RELOC *)
DT_MIPS_DELTA_SYM:	(# exit 0x7000001D #);	(* contains Delta symbols that Delta relocations refer to *)
DT_MIPS_DELTA_SYM_NO:	(# exit 0x7000001E #);	(* the number of entries in DT_M
IPS_DELTA_SYM *)
DT_MIPS_DELTA_CLASSSYM:	(# exit 0x70000020 #);	(* contains Delta symbols that hold the class declaration *)
DT_MIPS_DELTA_CLASSSYM_NO:	(# exit 0x70000021 #);	(* the number of entries in DT_MIPS_DELTA_CLASSSYM *)
DT_MIPS_CXX_FLAGS:	(# exit 0x70000022 #); (* Flags indicating information about C++ flavor *)
DT_MIPS_PIXIE_INIT:	(# exit 0x70000023 #); (* Flags indicating information about C++ flavor *)
DT_MIPS_SYMBOL_LIB:	(# exit 0x70000024 #);
DT_MIPS_LOCALPAGE_GOTIDX:	(# exit 0x70000025 #);
DT_MIPS_LOCAL_GOTIDX:	(# exit 0x70000026 #);
DT_MIPS_HIDDEN_GOTIDX:	(# exit 0x70000027 #);
DT_MIPS_PROTECTED_GOTIDX:	(# exit 0x70000028 #);
DT_MIPS_OPTIONS:		(# exit 0x70000029 #);	(* Address of .options *)
DT_MIPS_INTERFACE:	(# exit 0x7000002a #);	(* Address of .interface *)
DT_MIPS_DYNSTR_ALIGN:	(# exit 0x7000002b #);
DT_MIPS_INTERFACE_SIZE:	(# exit 0x7000002c #);	(* size of the .interface sec. *)
DT_MIPS_RLD_TEXT_RESOLVE_ADDR:	(# exit 0x7000002d #);     (* Address of rld_text_rsolve function stored in the got *)

RHF_NONE:                    (# exit 0x00000000 #);
RHF_QUICKSTART:              (# exit 0x00000001 #);
RHF_NOTPOT:                  (# exit 0x00000002 #);
RHF_NO_LIBRARY_REPLACEMENT:  (# exit 0x00000004 #);
RHF_NO_MOVE:                 (# exit 0x00000008 #);
RHF_SGI_ONLY:                (# exit 0x00000010 #);
RHF_GUARANTEE_INIT:	    (# exit 0x00000020 #);
RHF_DELTA_C_PLUS_PLUS:	    (# exit 0x00000040 #);
RHF_GUARANTEE_START_INIT:    (# exit 0x00000080 #);
RHF_PIXIE:    		    (# exit 0x00000100 #);
RHF_DEFAULT_DELAY_LOAD:    		    (# exit 	    0x00000200 #);
RHF_REQUICKSTART:    		    (# exit 	    0x00000400 #);
RHF_REQUICKSTARTED:    		    (# exit           0x00000800 #);
RHF_CORD:                    (# exit 0x00001000 #);


(* ====================================================================
 * ====================================================================
 *
 * 64-bit declarations
 *
 * ====================================================================
 * ====================================================================
 *)

ELF64_FSZ_ADDR:		(# exit 8 #);
ELF64_FSZ_HALF:		(# exit 2 #);
ELF64_FSZ_OFF:		(# exit 8 #);
ELF64_FSZ_SWORD:	(# exit 4 #);
ELF64_FSZ_WORD:		(# exit 4 #);
ELF64_FSZ_SXWORD:	(# exit 8 #);
ELF64_FSZ_XWORD:	(# exit 8 #);


(* ====================================================================
 *
 * ELF header
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	unsigned char	e_ident[EI_NIDENT];	{* ident bytes *}
 * 	Elf64_Half	e_type;			{* file type *}
 * 	Elf64_Half	e_machine;		{* target machine *}
 * 	Elf64_Word	e_version;		{* file version *}
 * 	Elf64_Addr	e_entry;		{* start address *}
 * 	Elf64_Off	e_phoff;		{* phdr file offset *}
 * 	Elf64_Off	e_shoff;		{* shdr file offset *}
 * 	Elf64_Word	e_flags;		{* file flags *}
 * 	Elf64_Half	e_ehsize;		{* sizeof ehdr *}
 * 	Elf64_Half	e_phentsize;		{* sizeof phdr *}
 * 	Elf64_Half	e_phnum;		{* number phdrs *}
 * 	Elf64_Half	e_shentsize;		{* sizeof shdr *}
 * 	Elf64_Half	e_shnum;		{* number shdrs *}
 * 	Elf64_Half	e_shstrndx;		{* shdr string index *}
 * } Elf64_Ehdr;
 * #endif
 * 
 *)

(* ====================================================================
 *
 * Program header
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	Elf64_Word	p_type;		{* entry type *}
 * 	Elf64_Word	p_flags;	{* entry flags *}
 * 	Elf64_Off	p_offset;	{* file offset *}
 * 	Elf64_Addr	p_vaddr;	{* virtual address *}
 * 	Elf64_Addr	p_paddr;	{* physical address *}
 * 	Elf64_Xword	p_filesz;	{* file size *}
 * 	Elf64_Xword	p_memsz;	{* memory size *}
 * 	Elf64_Xword	p_align;	{* memory/file alignment *}
 * } Elf64_Phdr;
 * #endif
 * 
 *)

(* ====================================================================
 *
 * Section Headers
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	Elf64_Word	sh_name;	{* section name *}
 * 	Elf64_Word	sh_type;	{* SHT_... *}
 * 	Elf64_Xword	sh_flags;	{* SHF_... *}
 * 	Elf64_Addr	sh_addr;	{* virtual address *}
 * 	Elf64_Off	sh_offset;	{* file offset *}
 * 	Elf64_Xword	sh_size;	{* section size *}
 * 	Elf64_Word	sh_link;	{* misc info *}
 * 	Elf64_Word	sh_info;	{* misc info *}
 * 	Elf64_Xword	sh_addralign;	{* memory alignment *}
 * 	Elf64_Xword	sh_entsize;	{* entry size if table *}
 * } Elf64_Shdr;
 * #endif
 * 
 *)

(* ====================================================================
 *
 * .symtab Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	Elf64_Word	st_name;
 * 	unsigned char	st_info;	{* bind, type: ELF_64_ST_... *}
 * 	unsigned char	st_other;
 * 	Elf64_Half	st_shndx;	{* SHN_... *}
 * 	Elf64_Addr	st_value;
 * 	Elf64_Xword	st_size;
 * } Elf64_Sym;
 * #endif
 *)


(*	The macros compose and decompose values for S.st_info
 *
 *	bind = ELF64_ST_BIND(S.st_info)
 *	type = ELF64_ST_TYPE(S.st_info)
 *	S.st_info = ELF64_ST_INFO(bind, type)
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * #define ELF64_ST_BIND(info)		((info) >> 4)
 * #define ELF64_ST_TYPE(info)		((info) & 0xf)
 * #define ELF64_ST_INFO(bind,type)	(((bind)<<4)+((type)&0xf))
 * #endif
 *)


(* ====================================================================
 *
 * .rel, .rela Section
 *
 * WARNING:  The Elf64_Rel and Elf64_Rela structures must be identical
 * except for the r_addend field.
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * 
 * typedef struct {
 * 	Elf64_Addr	r_offset;
 * 	Elf64_Word	r_sym;		{* Symbol index *}
 * 	Elf64_Byte	r_ssym;		{* Special symbol *}
 * 	Elf64_Byte	r_type3;	{* 3rd relocation op type *}
 * 	Elf64_Byte	r_type2;	{* 2nd relocation op type *}
 * 	Elf64_Byte	r_type;		{* 1st relocation op type *}
 * } Elf64_Rel;
 * 
 * typedef struct {
 * 	Elf64_Addr	r_offset;
 * 	Elf64_Word	r_sym;		{* Symbol index *}
 * 	Elf64_Byte	r_ssym;		{* Special symbol *}
 * 	Elf64_Byte	r_type3;	{* 3rd relocation op type *}
 * 	Elf64_Byte	r_type2;	{* 2nd relocation op type *}
 * 	Elf64_Byte	r_type;		{* 1st relocation op type *}
 * 	Elf64_Sxword	r_addend;
 * } Elf64_Rela;
 * 
 * {* Values for the r_ssym field: *}
 * typedef enum {
 *     RSS_UNDEF	= 0,	{* Undefined *}
 *     RSS_GP	= 1,	{* Context pointer (gp) value *}
 *     RSS_GP0	= 2,	{* gp value used to create object being relocated *}
 *     RSS_LOC	= 3	{* Address of location being relocated *}
 * } Elf64_Rel_Ssym;
 * 
 * #endif
 *)

(*	The macros compose and decompose values for Rel.r_info, Rela.f_info
 *
 *	sym = ELF64_R_SYM(R.r_info)
 *	type = ELF64_R_TYPE(R.r_info)
 *	R.r_info = ELF64_R_INFO(sym, type)
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * #define ELF64_R_SYM(info)	((info)>>8)
 * #define ELF64_R_TYPE(info)	((unsigned char)(info))
 * #define ELF64_R_INFO(sym,type)	(((sym)<<8)+(unsigned char)(type))
 * #endif
 *)


(* ====================================================================
 *
 * .conflict Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef Elf64_Addr Elf64_Conflict;
 * 
 * extern Elf64_Conflict   _ConflictList64 [];
 * #endif
 *)


(* ====================================================================
 *
 * .reginfo Section
 *
 * now the tail part of an .options ODK_REGINFO structure 
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 *         Elf64_Word      ri_gprmask;	{* mask of general regs used *}
 *         Elf64_Word      ri_pad;		{* for alignment *}
 *         Elf64_Word      ri_cprmask[4];	{* mask of cop regs used *}
 *         Elf64_Addr      ri_gp_value;	{* initial value of gp *}
 * } Elf64_RegInfo;
 * #endif
 *)


(* ====================================================================
 *
 * .content Section
 *
 * sh_type:	SHT_MIPS_CONTENT
 * sh_link:	section header index of section classified
 * sh_info:	0
 * attributes:	SHF_ALLOC, SHF_MIPS_NOSTRIP
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef union {
 *     struct {				{* Normal descriptor *}
 * 	Elf64_Word	con_info;
 * 	Elf64_Word	con_start;
 *     } con_y;
 *     Elf64_Xword	con_xval;		{* Extension descriptor *}
 * } Elf64_Content;
 * 
 * {* con_info masks: *}
 * __CON64_EMASK:	(# exit 0x80000000 #);
 * __CON64_ESHIFT:	(# exit 31 #);
 * __CON64_KMASK:	(# exit 0x7f000000 #);
 * __CON64_KSHIFT:	(# exit 24 #);
 * __CON64_LMASK:	(# exit 0x00ffffff #);
 * __CON64_VMASK:	(# exit 0x7fffffffffffffffll #);
 * 
 * {* Access macros: *}
 * #define ELF64_CON_EXTN(c) \
 * 	(((c).con_y.con_info & __CON64_EMASK)>>__CON64_ESHIFT)
 * #define ELF64_CON_KIND(c) \
 * 	(((c).con_y.con_info & __CON64_KMASK)>>__CON64_KSHIFT)
 * #define ELF64_CON_LENGTH(c)	((c).con_y.con_info & __CON64_LMASK)
 * #define ELF64_CON_XVAL(c)	((c).con_xval & __CON64_VMASK)
 * 
 * #endif
 *)


(* ====================================================================
 *
 * .dynamic Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct {
 * 	Elf64_Xword	d_tag;
 * 	union {
 * 		Elf64_Xword	d_val;
 * 		Elf64_Addr	d_ptr;
 * 	} d_un;
 * } Elf64_Dyn;
 * #endif
 * 
 *)

(* ====================================================================
 *
 * .liblist Section
 *
 * ====================================================================
 *)

(* #if (defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS))
 * typedef struct
 * {
 *         Elf64_Word      l_name;
 *         Elf64_Word      l_time_stamp;
 *         Elf64_Word      l_checksum;
 *         Elf64_Word      l_version;
 *         Elf64_Word      l_flags;
 * } Elf64_Lib;
 * #endif
 *)

