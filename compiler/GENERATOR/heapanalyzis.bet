ORIGIN 'controlbody';
INCLUDE 'itemevval';
INCLUDE 'docheck';
INCLUDE 'check';
INCLUDE 'sematt';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE '~beta/sysutils/scanobjects';
INCLUDE 'machinebody'

---analyzeHeap:descriptor--
(#   
   EmptyHeaps:
     (* execution of this pattern will trigger a number
      * of IOA,AOA and LVAR garbage collections. This
      * implies that all live objects before this call
      * will be moved to AOA, just as all dead objects will
      * be removed from AOA/IOA/LVRA
      *)
     (# AbeKat: 
          (# q,w,e,r,t,y,u,i,o,p,a,s,d,f,g,h,j,k: @real; 
             next: ^AbeKat;
             new:
               (# n: @integer; 
               enter n
               do (if n>0 then
                      &Abekat[]->next[];
                      n-1->next.new
               if)#);
          #);
        Hest: (# Fisk: [50000] @integer #);
        head: ^abeKat
     do '\n\n*******Empty heaps:'->putLine;
        (for i: 10 repeat
             &AbeKat[]->head[];
             5000->head.new;
             &Hest
        for);
     #);
   GetLoc: 
     (* returns a reference to the location of obj.
      * Location is defined for part objects and none for
      * other objects. In
      *    A: (# ...; X: @T  ... #)
      *    X[]->GetLoc->s[]
      * will return the address of the enclosing A-object
      *)
     (# obj,loc: ^object;
        adrToObj: @addressToObject;
        adr,gcf: @integer;
        getGCF: @getGCfield;
     enter obj[]
     do none->loc[];
        (if obj[]->isComponent then 'isComponent'->putline 
         else
            obj[]->getGCF->gcf; (*the gc-field=location offset*)
            (if gcf < 0 (* ? *) then
                gcf*4->gcf;     (* convert to byte-offset *)
                (0->obj.%getLong)->adr; (*adr of object referred by obj*)
                (* Above line tos_converted from: @@obj->tos'%AdrGetLong'->adr; *)
                adr+gcf -> adrToObj->loc[];  (*location of obj*)
        if)if)
     exit loc[]
     #);
   PrintThisAndLocs:
     (* exit ref to top loc *)
     (# obj,loc: ^object
     enter obj[]
     do obj[]->loc[];
        L:
          (if loc[]<>none then
              loc[]->obj[];
              (obj[],none)->printObject;
              obj[]->getLoc->loc[];
              restart L
          if)
     exit obj[]
     #);
   Collector:
     (#
        collect:
          (# f: ##object
          enter F##
          do scanaoa
             (# callback::
                  (#
                  do (if (XXtop+1->XXtop) <=XX.range then 
                         obj[]->XX[XXtop][]
                      else
                         'XX overflow' -> putLine
                  if)#)
             do F##->root##
          #)#);
        XX: [1000] ^object; XXtop: @integer;
        printCollect:
          (#
          do scanaoa
             (# callBack::
                  (#
                  do (for i: XXtop repeat
                          (XX[i][],obj[])->hasRefToObject;
          for)#)#)#);
     #);
   col: @collector;
   HasRefToObject:
     (# obj,s,ref: ^object;
        P: @prototype;
        GP: @getProtoType;
        putT: @screen.puttext;
        putI: @screen.putInt;
        a2r: @addressToObject;
        _tos: @integer;
     enter(obj[],s[])
     do 
        (if s[]<>none then
            s[]->GP->P;
            P.scanRefs
            (#
            do (if not isStatic then
                   (%getLongAt(((0->s.%getLong))+thisOffset))->a2r->ref[];
                   (* Above line manually converted from: 
                    *   (@@s->TOS'%AdrGetLong')+thisOffset ->TOS'%AdrGetLong'->a2r->ref[]; 
                    *)
                   (if ref[]=obj[] then
                       '++++++++++++++++'->putLine;
                       (obj[],none)->printObject;
                       (if obj## = ASTindex## then
                           (obj[],screen[],12)->thePP;
                       if);
                       'Ref at: '->putT; thisOffSet->putI; 
                       ' in: '->putT; 
                       (s[],none)->printObject;
                       s[]->save2[save2top+1->save2top][]
                   if)
               if)
        #)if)
     #);
   save2: [1000] ^object; save2Top: @integer
     
do (if switch[291] then EmptyHeaps if);
   (if switch[292] then 
       '\n\n********Heap content:\n'->putline;
       scanAOA(#do true->printVisited->printSize->printOrigin; #);
       (* ---not implemented 
        * scanLVRA(#do true->printVisited->printSize->printOrigin #);
        *)
   if);
   (if switch[293] then
       '\n\n*****Print selected objects'->putline;
       (if true then
           scanaoa
           (# callBack::<
                (# t: ^ trueObject
                do obj[]->t[];
                   t;
                #);
           do trueObject##->root##;
           #);
       if);

       ASTindex##->col.collect;
       'SuperChain'->putline;
       sematt.BV.superChain##->col.collect;
       col.printCollect
   if)
#)
