ORIGIN 'BCmachineBody';
INCLUDE 'BCjavaSupport'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/basiclib/streamPosition'; 

--BCmachineLib: attributes--

generateDebugInfo:
  (# exit common.switch[41] #);
trace_opcodes: 
  (# exit common.switch[190] #);

splitSignature:
  (# signature: ^text;
     name: ^text;
     isStatic: @boolean;
  enter signature[]
  do (* Signature e.g.: java/lang/String/endsWith(Ljava/lang/String;)Z *)
     signature.copy -> signature[];
     &text[] -> name[];
     (if 'static ' -> ((1,7) -> signature.sub).equal then
         true -> isStatic;
         (1,7) -> signature.delete;
     if);
     scan:
       (for i:signature.lgth repeat
            (if signature.T[i]='(' then
                (1,i-1) -> signature.sub -> name[];
                (1,i-1) -> signature.delete;
                leave scan;
            if);
       for);
     INNER;
     (* name:      java/lang/String/endsWith *)
     (* signature: (Ljava/lang/String;)Z     *)
  exit (name[], signature[], isStatic)
  #);
splitClassSignature: SplitSignature
  (# lastSlash: @integer;
     method: ^text;
  do (* name e.g.: java/lang/String/endsWith *)
     &text[] -> method[];
     scan:
       (for i:name.lgth repeat
            (if name.T[i]='(' then leave scan if);
            (if name.T[i]='/' then i->lastSlash if)
       for);
     (if lastSlash>0 then
         (1, lastSlash-1) -> name.sub -> method[];
         (1, lastSlash) -> name.delete;
     if);
  exit method[]
  #);

noArgsInSignature:
  (# nargs: @int16;
     T: ^text;
  enter T[]
  do 0 -> nargs;
     T.reset;
     (for i:T.lgth repeat
          (if T.T[i]
           // '(' then
              (* start of parameter list *)
           // ')' then
              (* end of parameter list *)
              leave noArgsInSignature;
           // 'B' // 'C' // 'D' // 'F' // 'I' // 'J' // 'S' // 'Z' then
              (* BaseType *)
              nargs+1 -> nargs;
           // 'L' then
              (* ObjectType *)
              i+1 -> i;
              scanToSemiColon:
                (if T.T[i]<>';' then i+1 -> i; restart scanToSemiColon if);
              nargs+1 -> nargs;
           // '[' then
              (* ArrayType *)
              i+1 -> i;
              scanToNonBrace:
                (if t.t[i]='[' then i+1 -> i; restart scanToNonBrace if);
              nargs+1 -> nargs;
           else
              'noArgsInSignature: unknown character \''->screen.puttext;
              t.t[i] -> screen.put;
              '\' in signature \'' -> screen.puttext;
              t[] -> screen.puttext;
              '\'' -> screen.putline;
          if);
     for);
  exit nargs
  #);

jvmFIXME:  (* Bytecode compiler cannot handle patterns with the
            * same name in different files for the same attributes slot;
            * there is a conflivting FIXME in BCdotnetBody
            *)
  (# T: ^text
  enter T[]
  do (if not common.switch[188] then
         'FIXME: ' -> (T.copy).prepend -> T[];
         '***** ' -> screen.puttext; T[] -> screen.putline;
         (* Possibly generate an IOcall with T[] too *)         
     if);
  #);

trace_opcode:
  (# opcode: @integer;
  enter opcode
  do (if trace_opcodes then
         (if opcode
          // comment then
          // position then
          else
             'Opcode %d: %s ' -> screen.putformat(# do opCode -> d;  opCode->asText->s; #);
             (if (32<=opcode) and (opcode<=126) then
                 '\'%c\' ' -> screen.putformat(# do opcode->c #);
             if);
             screen.newline;
         if)
     if)
  #);

allocLocal:
  (* Meaning of values in BCstate.fields.LocalVariables:
   * 0: free, -1: unknown, 1: integertype, 2: referencetype, 3: double
   *)
  (# name, type: ^text;
     slot: @integer;
  enter (name[], type[])
  do 0 -> slot;
     findSlot:
       (for i:BCstate.fields.LocalVariables.range repeat
            (if BCstate.fields.LocalVariables[i] = 0 then
                i -> slot;
                leave findSlot;
            if);
       for);
     (if slot=0 then
         (* Get a new slot *)
         BCstate.fields.LocalVariables.range+1 -> slot;
         BCstate.fields.LocalVariables.range (* at least 1 *)
           -> BCstate.fields.LocalVariables.extend;         
     if);
     -1 -> BCstate.fields.LocalVariables[slot];
     (if generateDebugInfo and (name[]<>NONE) and (type[]<>NONE) then
         (65535, 0, name[], type[]) -> jcf.emitLocalVariableDefinition;
     if);
     (if false then
         'allocLocal: allocated slot '->puttext; 
         slot-> putint; 
         ', LIP=' -> puttext;
         jcf.currentmethod.LIP -> putint;
         newline;
     if);
  exit slot
  #);
allocLocalDouble:
  (# name: ^text;
     slot: @integer;
  enter (name[])
  do 0 -> slot;
     find2Slots:
       (for i:BCstate.fields.LocalVariables.range-1 repeat
            (if (BCstate.fields.LocalVariables[i] = 0) and
                (BCstate.fields.LocalVariables[i+1] = 0) then
                i -> slot;
                leave find2Slots;
            if);
       for);
     (if slot=0 then
         (* Get a new slot *)
         BCstate.fields.LocalVariables.range+2 -> slot;
         BCstate.fields.LocalVariables.range+1 (* at least 2 *)
           -> BCstate.fields.LocalVariables.extend;         
     if);
     -1 -> BCstate.fields.LocalVariables[slot];
     -1 -> BCstate.fields.LocalVariables[slot+1];
     (if generateDebugInfo and (name[]<>NONE) then
         (65535, 0, name[], 'D') -> jcf.emitLocalVariableDefinition;
     if);
     (if false then
         'allocLocal: allocated double slot '->puttext; 
         slot-> putint; 
         ', LIP=' -> puttext;
         jcf.currentmethod.LIP -> putint;
         newline;
     if);
  exit slot
  #);

releaseLocal:
  (# slot: @integer
  enter slot
  do (if BCstate.fields.LocalVariables[slot] = 3 (* double *) then
         0 -> BCstate.fields.LocalVariables[slot];
         0 -> BCstate.fields.LocalVariables[slot+1]
      else
         0 -> BCstate.fields.LocalVariables[slot]
     if);
  #);

--FieldsNewJasmin:descriptor--
(# name_index, descriptor_index: @integer;
do (if methodClassTag 
    // 'c' 
    // 'p' 
    // '[' then
       (if methodClassTag = '[' then '[' -> T.prepend if);
       (FN[], T[]) -> jcf.emitFieldDef;
    // 'm' then
       (*'FieldsNewJasmin.m: '->screen.puttext; FN[] -> screen.putline;*)
       (FN[], T[]) -> allocLocal;
    // 'M' // 'C' then (* ???*)
    else
       '\nField.add: ' -> puttext;
       FN[] -> puttext; ' : "' -> puttext; T[] -> puttext; '"'->put;
       methodclassTag -> put; newline;
       (failureTrace,'fields.new:Unknown methodClassTag') -> stop
   if);
#)

--FieldsEmitInitItemJasmin:descriptor--
(# class: ^ text
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       aload_0 -> jcf.emit;
       (if true
        // 'I' -> currentType.equal 
        // 'C' -> currentType.equal
        // 'Z' -> currentType.equal (* boolean *)
        // 'B' -> currentType.equal (* byte *) 
        // 'S' -> currentType.equal (* short *) 
           then
           bipush -> jcf.emit;
           0  -> jcf.emit;
        // 'D' -> currentType.equal (* double/real *) then
           dconst_0 -> jcf.emit
        // 'F' -> currentType.equal (* real32/float *) then
           fconst_0 -> jcf.emit
        else
           aconst_null -> jcf.emit;
       if);
       putfield -> jcf.emit;
       (if currentTag = '[' then '[' -> currenttype.prepend if);       
       (thisClassName[], currentFieldName[], currentType[]) -> jcf.emitFieldRef; 
   if)     
#)

-- emitJasmin: DoPart --
do (# commentstream: @stream (* maybe something more useful *);
      
      thisClassName                (* name of current class           *)
      ,thisOrgName                 (* name of current origin class    *)
      ,thisSuperName               (* name of current super           *)
      ,thisSuperOrgName            (* nameof origin of current super  *)
      ,thisSignature               (* signature of current method     *)
      ,thisInnerMethodName: ^text; (* name of a possible inner method;
                                    * or the name of method 'main'
                                    *)
      thisBlockLevel,
      subLevel: @integer; (* current subpattern level *)
      class: ^text;       (* name of class being called - 
                           * used by subsequent init - ugly
                           *)
      isMainMethod: @boolean; (* true if generating code for main method *)
      
      betafile: @file(# initialized: @boolean; pc: @positionConverter #);
      betafilename: ^text;
      line, column: @integer;
      
      
      
      init:
        (# BCmch: ^ByteCodeMachine;
           PH: @pathhandler;
           trace_name: (# exit false #);
           classdir: ^text;
           numdirs: @integer;
        do (* Construct source file path relative to current working dir *)
           (* Start with full path of directory of class file *)
           (# dum: @char do
              (mch[]->BCmch[]).mstate.thisFullPath.copy -> betafilename[];
           #);
           (# dum: @char do
              (* Strip 'jvm/<package path>' *)
              'jvm/' -> classdir[];
           #);
           (# dum: @char do
              (mch[]->BCmch[]).mstate.thisPackagePath[] -> classdir.append;
           #);
           (# dum: @char do
              '/' -> classdir.findAll(# do numdirs+1->numdirs #);
           #);
           (# dum: @char do
              classdir[] -> betafilename.deletePathSuffix;
           #);
           (if (mch[]->BCmch[]).mstate.thisSourceFileName[] = none then
               '\nSource none'->putline;
           if);
           (# dum: @char do
              (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename.append;
           #);
           (# dum: @char do
              '.bet' -> betafilename.append;
           #);
           (# dum: @char do
           
           (if trace_name then
               '\n\nbetafilename: ' -> puttext; 
               betafilename[] -> putline;
               'packagepath: ' -> puttext;
               (mch[]->BCmch[]).mstate.thisPackagePath[] -> putline;
               'numdirs: ' -> puttext;
               numdirs -> putint; newline;
           if);
           #);
           (# dum: @char do
              (if common.hostIsWindows then
                  betafilename[] -> SlashToBackslash -> betafilename[];
              if);
           #);
           (# dum: @char do
              betafilename[] -> betafile.name;
           #);
           (# dum: @char do
              (if generateDebugInfo then
                  (# dum: @char do
                     betafilename[] -> betafile.name;
                  #);
               (if betafile.entry.exists then
                   
                   (* Open source file in order to map positions to line numbers *)
                   betafile.openRead;
                   betafile.pc.update;
                   betafile.close;
                   true -> betafile.initialized;
                   
                   (* Set SourceFile attribute of class file *)
                   '' -> betafilename[];
                   (if true then
                       (* The source is always numdirs above the directory the class file is 
                        * placed in. Numdirs = (number of directories in package path plus one
                        * for the jvm directory).
                        *)
                       (for numdirs repeat 
                            '../' -> betafilename.prepend;
                       for);
                   if);
                   (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename.append;
                   '.bet' -> betafilename.append;
                   betafilename[] -> jcf.SourceFile;
                   (if trace_name then
                       'Source file: ' -> puttext;
                       betafilename[] -> screen.putline;
                   if);
                else
                   'Error: cannot open source file: '->screen.puttext;
                   betafilename[] -> screen.putline;
                   'Will not generate line number info' -> screen.putline;
               if);
              if);
           #)
        #);
      emitImports:
        (#
        do (if false then
               '\nImportJava:'->putline;
               jcf.cf.name -> putline;
               imports.scan
               (#
               do 'import: ' -> commentstream.puttext;
                  current[] -> commentstream.putText; 
                  commentstream.newline;
               #);
           if)
        #);
      markAsInnerIfInnerClass:
        (# className,name,outer: ^text;
           lastSlashPos,lastDollarPos: @integer;
           decode: @
             (# pos: @integer
             do className.scanAll
                (# 
                do pos+1 -> pos;
                   (if ch 
                    // '$' then pos -> lastDollarPos
                    // '/' then pos -> lastSlashPos
                   if)
                #);
                
             #)
        enter className[]
        do decode;
           (if lastDollarPos > 0 then
               (* we have a nested class *)
               (lastDollarPos+1,className.length) -> className.sub -> name[];
               (1,lastDollarPos-1) -> className.sub -> outer[];
               (*1->trace(#
                       do 'markAsInner: ' -> xT; className[] -> xT; 
                          ' ' -> put; name[] -> xT;
                          ' outer: ' -> xT; outer[] -> xT;
                       #);*)
               (className[],outer[],name[],ACC_PUBLIC) -> jcf.emitInnerClassRef
           if);
        #);
      emitMemOp:
        (# op, op0: @integer; varNo: @integer;
        enter(op, op0, varNo)
        do (if varNo > 0 then
               (* currently we assume that local variables have
                * addresses: 0,12,16,20,... that are 
                * mapped to: 0, 1, 2, 3,...
                * address 0 represents this
                *)
               (varNo div 4) - 2 -> varNo;
           if);
           (op, op0, varNo) -> MemoryOperation;
        #);
      MemoryOperation:
        (# op, op0: @integer; argNo: @integer;
        enter(op, op0, argNo (* argNo: 0, 1, 2, 3, ...*))
        do (if generateDebugInfo then
               argNo -> jcf.emitLocalVariableUse;
           if);
           
           (if argNo <= 3 then 
               op0 + argNo -> jcf.emit;
            else
               op -> jcf.emit;
               argNo -> jcf.emit;
           if);
        #);
      
      opLocal:
        (# op, op0, locNo: @integer;
        enter locNo (* local number, NOT offset *)
        do INNER;
           (op, op0, locNo) -> MemoryOperation;
        #);
      aOpLocal: opLocal
        (# msg: ^text;
        do (if BCstate.fields.LocalVariables[locNo] 
               // 1 (* integertype *) 
               // 3 (* double *) then
               'aOpLocal: Using local variable of integertype/double with reference instruction'->msg[];
               msg[] -> jvmFIXME;
            else
               2 (* referencetype *) -> BCstate.fields.LocalVariables[locNo]
           if);
           INNER;
        #);
      dOpLocal: opLocal
        (# msg: ^text;
        do (if BCstate.fields.LocalVariables[locNo] 
               // 1 (* integertype *) 
               // 2 (* referencetype *) then
               'dOpLocal: Using local variable of integertype/referencetype with double instruction'->msg[];
               msg[] -> jvmFIXME;
            else
               3 (* double *) -> BCstate.fields.LocalVariables[locNo]
           if);
           INNER;
        #);
      iOpLocal: opLocal
        (# msg: ^text;
        do (if BCstate.fields.LocalVariables[locNo] 
            // 2 (* referencetype *) 
            // 3 (* double *) 
               then
               'iOpLocal: Using local variable of double/referencetype with integer instruction'->msg[];
               msg[] -> jvmFIXME;
            else
               1 (* integertype *) -> BCstate.fields.LocalVariables[locNo]
           if);
           INNER;
        #);
      astoreLocal: 
        aOpLocal(# do astore->op; astore_0->op0 #);
      aloadLocal: 
        aOpLocal(# do aload->op; aload_0->op0 #);
      dstoreLocal: 
        dOpLocal(# do dstore->op; dstore_0->op0 #);
      dloadLocal: 
        dOpLocal(# do dload->op; dload_0->op0 #);
      storeLocal: 
        iOpLocal(# do istore->op; istore_0->op0 #);
      loadLocal: 
        iOpLocal(# do iload->op; iload_0->op0 #);
      
      MappedLocals: [1]@integer;
      lastMappedLocal: @integer;
      allocMappedLocal:
        (# num: @integer;
           locnum: @integer;
           double: @boolean;
        enter (num)
        do -num -> num;
           (if num>MappedLocals.range then
               (MappedLocals.range, num-MappedLocals.range)
                 -> max
                 -> MappedLocals.extend;
           if);
           (if MappedLocals[num]=0 then
               (if double then
                   (allocLocalDouble -> locnum) + 1 -> MappedLocals[num];
                else
                   (allocLocal -> locnum) + 1 -> MappedLocals[num];
               if);
               (* adding 1 to distingguish local 0 from unassigned *)
               num -> lastMappedLocal; 
               (if false then
                   'allocMappedLocal: offset='->puttext; 
                   num->putint; 
                   ' mapped to slot '->puttext; 
                   locnum-> putint; 
                   ', LIP=' -> puttext;
                   jcf.currentmethod.LIP -> putint;
                   newline;
               if);
            else
               MappedLocals[num]- 1 -> locnum;
               num -> lastMappedLocal; (* needed? *)
               (if false then
                   'allocMappedLocal: offset='->puttext; 
                   num->putint; 
                   ' looked-up to slot '->puttext; 
                   locnum-> putint; 
                   ', LIP=' -> puttext;
                   jcf.currentmethod.LIP -> putint;
                   newline;
               if);
           if);
        exit locnum
        #);

      dumpReg:
        (# 
        do 'assume register on stack: regno=' -> commentstream.puttext;
           BC.get -> commentstream.putint           
        #);
      getReg: (#  exit BC.get #);
      Address:
        (#
           reg,off,size,isField,ONlevel: @integer; 
           fieldName,descName,fieldType: ^text;
           get: 
             (# hasFieldName: @integer
             do getReg->reg; 
                (if (BC.get -> hasFieldName) = 1 then
                    BC.gettext -> fieldName[]
                if);
                
                (*BC.get->off;*)
                (# c: @int16 (* CAREFULL: char is unsigned! *);
                do BC.getShort->c;
                   c -> off(* sign extend *);
                #);
                BC.get->size; 
                BC.get->ONlevel; 
                (if ONlevel > 0 then
                    (failureTrace,'ONlevel>0') -> stop 
                if);
                BC.get -> isField; 
                (if isField = 1 then
                    BC.getText -> descName[]
                 else
                    none -> descName[]
                if);
                (if BC.get = 1 then
                    BC.getText -> fieldType[]
                 else
                    none -> fieldType[]
                if);
             #);
           emitFieldAndType:
             (# isOrigin: @boolean;
                ClassName, TheFieldName, TheFieldType: ^text;
             enter isOrigin
             do INNER;
                (if isField = 1 then
                    descName[] -> ClassName[];
                 else 
                    (* this part should be eliminated *)
                    ONlevel -> BCstate.blocks.class -> ClassName[];
                if);
                (if isOrigin then
                    'origin' -> TheFieldName[]
                 else
                    fieldName[] -> TheFieldName[]
                if);
                (if TheFieldType[]=NONE (* May have been set in INNER *) then
                    (if fieldType[] <> none then
                        (if (fieldType.length <= 2) or
                            ((fieldType.length -> fieldType.inxGet) = ';') then
                            fieldType.copy -> TheFieldType[];
                            (if isField=2 then '[' -> TheFieldType.prepend; if);
                         else
                            (* we do come here, but we should perhaps fix this *)
                            (if fieldtype[] = none then
                                (failureTrace,'makeSig-1') -> stop;
                            if);
                            fieldType[] (*-> makeSignature*) -> TheFieldType[];
                        if)
                     else
                        'I' -> TheFieldType[];
                        'OBS! missing type info (fieldType)' -> jvmFIXME;
                    if);
                if);
                (ClassName[], TheFieldName[], TheFieldType[]) -> jcf.emitFieldRef; 
             #);
           load:
             (#
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            iaload -> jcf.emit;
                         // 'C' -> fieldType.equal then
                            caload -> jcf.emit;
                         // 'Z' -> fieldType.equal 
                         // 'B' -> fieldType.equal then
                            baload -> jcf.emit;  
                         // 'S' -> fieldType.equal then
                            saload -> jcf.emit
                         // 'D' -> fieldType.equal then
                            daload -> jcf.emit
                         // 'J' -> fieldType.equal then
                            laload -> jcf.emit;
                         else
                            aaload -> jcf.emit;
                            (* well now we assume reference type,
                             * i.e. NOT wrong
                            (if not common.switch[188] then
                                'wrong fieldType'  -> commentstream.puttext;
                             if)
                             *)
                        if)
                     else
                        iaload -> jcf.emit;
                        (if not common.switch[188] then
                            'missing fieldType'  -> commentstream.puttext;
                        if);
                    if)
                 else
                    (if ONlevel > 0 then
                        getfield  -> jcf.emit;
                        emitFieldAndType;
                     else
                        (if isField=1 then
                            getfield  -> jcf.emit;
                            emitFieldAndType;
                         else
                            (* method field *)
                            (* clean up*)
                            (if (fieldType[] <> none) then
                                (if true
                                 // 'D' -> fieldType.equal 
                                    (* double/real *)
                                    then
                                    (if off < 0 then
                                        (off) -> allocMappedLocal 
                                          -> dloadLocal
                                     else
                                        (dload, dload_0, off) -> emitMemOp
                                    if);
                                 // 'F' -> fieldType.equal 
                                    (* float/real32 *)
                                    then
                                    (if off < 0 then
                                        1->trace(#
                                                do 'BCjavaBody:load: ' -> xT; 
                                                   'missing floadlocal' -> xT
                                                #)
                                     else
                                        (fload, fload_0, off) -> emitMemOp
                                    if);
                                    
                                 // 'J' -> fieldType.equal then
                                    (if off < 0 then
                                        (off) -> allocMappedLocal 
                                          -> dloadLocal
                                     else
                                        (lload, lload_0, off) -> emitMemOp
                                    if);
                                 else
                                    (if off<0 then
                                        (off) -> allocMappedLocal -> loadLocal
                                     else
                                        (iload, iload_0, off) -> emitMemOp
                                    if)                                    
                                if)                                    
                             else 
                                (if off<0 then
                                    (off) -> allocMappedLocal -> loadLocal
                                 else
                                    (iload, iload_0, off) -> emitMemOp
                                if)
                            if)
                        if)
                    if);
                if)
             #);
           store:
             (# 
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            iastore -> jcf.emit;
                         // 'C' -> fieldType.equal then
                            castore -> jcf.emit;
                         // 'Z' -> fieldType.equal
                         // 'B' -> fieldType.equal then
                            bastore -> jcf.emit;
                         // 'S' -> fieldType.equal then
                            sastore -> jcf.emit
                         // 'D' -> fieldType.equal then
                            dastore -> jcf.emit
                         else
                            (if fieldType.length > 2 then
                                aastore -> jcf.emit
                             else
                                (if not common.switch[188] then
                                    'unknown fieldType: ' -> puttext;
                                if);
                                fieldType[] -> putline;
                                iastore -> jcf.emit;
                            if)
                        if)
                     else
                        iastore -> jcf.emit;
                        (if not common.switch[188] then
                            'missing fieldType'  ->putline
                        if);
                    if)
                 else
                    (if ONlevel > 0 then
                        putfield  -> jcf.emit;
                        emitFieldAndType;
                     else
                        (if isField=1 then
                            putfield  -> jcf.emit;
                            emitFieldAndType;
                         else
                            (* FIXME: datpete: 
                             * I think stuf is missing here for other types than int AND for mapped locals. 
                             * See Load above 
                             *)
                            (istore, istore_0, off) -> emitMemOp
                        if)
                if)if)
             #);
           storeRef:
             (# withQua,isOrigin,isRef: @boolean; 
                class: ^text;
             enter(withQua,isOrigin)
             do BC.gettext -> class[];
                ((class.lgth>=1) and ((class.T[1] = 'L') or (class.T[1]='['))) -> isRef;
                (if withQua then
                    checkcast  -> jcf.emit;
                    (if true then
                        class[] -> emitCheckCast
                     else
                        class.copy -> classRefTotext -> jcf.emitClassRef;
                    if)
                if);
                (if ONlevel > 0 then
                    putfield  -> jcf.emit; 
                    isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
                 else 
                    (if isField = 1 then
                        putfield  -> jcf.emit; 
                        isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
                     else
                        (if isField = 2 then
                            aastore -> jcf.emit;
                         else                       
                            (if off<0 then
                                (if false then
                                    '\nstoreref: negative off: '->puttext; 
                                    off->putint; ' class: ' -> puttext; 
                                    class[] -> puttext; 
                                    ', isRef: '->puttext; 
                                    isRef->putboolean; 
                                    ', LIP='->puttext; 
                                    jcf.currentmethod.LIP->putint; 
                                    newline;
                                if);
                                (if true 
                                 // isRef then
                                    (off) -> allocMappedLocal -> astoreLocal;
                                 // (fieldType[] <> none) 
                                    and ('D' -> fieldType.equal) 
                                    (* double/real *) then 
                                    (off) -> allocMappedLocal -> dstoreLocal;
                                 else
                                    (off) -> allocMappedLocal -> storeLocal;
                                if);
                             else
                                (astore, astore_0, off) -> emitMemOp
                            if);
                        if)
                    if)
                if);
             #);
           loadRef:
             (# withQua,isRef: @boolean;
                sig: ^text
             enter withQua
             do BC.gettext -> sig[];
                ((sig.lgth>=1) and ((sig.T[1] = 'L') or (sig.T[1]='['))) -> isRef;
                (if ONlevel > 0 then
                    getfield  -> jcf.emit;
                    emitFieldAndType(# do sig.copy -> TheFieldType[] #);
                 else 
                    (if isField = 1 then
                        getfield  -> jcf.emit; 
                        emitFieldAndType(# do sig.copy -> TheFieldType[] #);
                     else
                        (if isField = 2 then
                            aaload -> jcf.emit;
                         else 
                            (if off<0 then
                                (if false then
                                    '\nloadref: negative off: '->puttext; 
                                    off->putint; ' sig: ' -> puttext; 
                                    sig[] -> puttext; 
                                    ', isRef: '->puttext; 
                                    isRef->putboolean; 
                                    ', LIP='->puttext; 
                                    jcf.currentmethod.LIP->putint; 
                                    newline;
                                if);
                                (if isRef then
                                    (off) -> allocMappedLocal -> aloadLocal;
                                 else
                                    (off) -> allocMappedLocal -> loadLocal;
                                if);
                             else
                                (aload, aload_0, off) -> emitMemOp
                            if);
                        if)
                    if)
                if); 
                (if withQua then
                    (*sig[] -> puttext;*)
                    checkcast  -> jcf.emit;
                    (if true then
                        BC.gettext -> emitCheckCast
                     else
                        BC.gettext -> sig[];
                        class.copy -> classRefTotext -> jcf.emitClassRef
                    if)
                if);
             #);
           pushAdr:
             (#
             do (if off = 0 then
                    (if reg
                     // thisO then
                        aload_0 -> jcf.emit;
                     // callO then
                        (* skip: register on stack *)
                     else
                        'Warning: pushAdr:register not this'->jvmFIXME;
                         _nop -> jcf.emit;
                    if)
                 else
                    'Warning: pushAdr:registeroff <>0\n\t' -> jvmFIXME;
                    load;
                if)
             #);
           dump:
             (# 
             do
                (if size = 0 then 4->commentstream.putint else size->commentstream.putint if);
                '.'->commentstream.put;
                (if reg
                 // thisO then  
                 // callO then 
                    '%call.'->commentstream.puttext
                 else
                    '%top.'->commentstream.puttext
                if);
                off->commentstream.putint
             #);
           display:
             (# 
             do ' reg:'-> puttext; reg -> putint;
                ' off:'-> puttext; off-> putint;
                ' size:'->puttext; size -> putint; 
                ' ONlevel:'->puttext; ONlevel -> putint;
                ' isField:'->puttext; isField -> putint;
                (if isField = 1 then
                    descName[] -> puttext
                if)
             #);
        #);
      makeSignature:
        (# sig: ^text
        enter sig[]
        do (if (1->sig.inxGet) = '[' then
               (* this should really be handled at a higher level *)
            else
               sig[] -> textToClassref -> sig[];
           if)
        exit sig[]
        #);
      emitNewArray:
        (# type: @integer
        enter type
        do newarray  -> jcf.emit; 
           type -> jcf.emit;
        #);
      emitAnewArray:
        (# type: ^text
        enter type[]
        do anewarray  -> jcf.emit;
           type[] ->  jcf.emitClassRef;
        #);
      emitCheckCast:
        (# class: ^text
        enter class[]
        do (if (1 -> class.InxGet) = '[' then
               (* '[Lfoo;' - ugly *)
               (if true then
                   class[] -> jcf.emitClassRef
                else
                   '[' -> ((3,class.length-1) -> class.sub).prepend
                     -> jcf.emitClassRef
               if)
            else
               class.copy -> classRefTotext -> jcf.emitClassRef
           if)
        #);
      emitCmpJmp:
        (# cond,L,lab,isRef: @integer; (* isRef=1: reference comparison;
                                        * should only happen for = and <>
                                        *)
        enter(cond,L,lab,isRef)
        do (if cond
            // 1 (* =  *) then
               (if isRef = 1 then
                   if_acmpeq -> jcf.emit
                else
                   if_icmpeq -> jcf.emit
               if)
            // 2 (* <> *) then
               (if isRef = 1 then
                   if_acmpne -> jcf.emit
                else
                   if_icmpne -> jcf.emit
               if)
            // 3 (* <  *) then
               if_icmplt -> jcf.emit;
            // 4 (* <= *) then
               if_icmple -> jcf.emit;
            // 5 (* >  *) then
               if_icmpgt -> jcf.emit;
            // 6 (* >= *) then
               if_icmpge -> jcf.emit;
           if);
           lab -> jcf.labs.off -> jcf.emitShort;
        #);
      emitCmpToBool:
        (* 0:      if_xxx L1
         * 3:      bipush 0
         * 5:      goto L2
         * 8:  L1: bipush 1
         * 10: L2:
         *)          
        (# L1,L2: @integer;
        do 8-0 -> L1;
           10-5 -> L2;
           (*L1 -> jcf.emitShort; (* L1 *)
           bipush -> jcf.emit; 0 -> jcf.emit;
           goto -> jcf.emit;           
           L2 -> jcf.emitShort; (* L2 *)
           bipush -> jcf.emit; 1 -> jcf.emit;           
        #);
      emitCmpBoolJmp:
        (# cond,L,lab: @integer
        enter(cond,L,lab)
        do (if cond
            // 1 (* =  *) then
               ifeq -> jcf.emit;
            // 2 (* <> *) then
               ifne -> jcf.emit;
            // 3 (* <  *) then
               iflt -> jcf.emit;
            // 4 (* <= *) then
               ifle -> jcf.emit;
            // 5 (* >  *) then
               ifgt -> jcf.emit;
            // 6 (* >= *) then
               ifge -> jcf.emit;
           if);
           lab -> jcf.labs.off -> jcf.emitShort;
        #);
      negCond:
        (# cond: @integer
        enter cond
        do (if cond
            // 1 (* =  *) then
               2 -> cond
            // 2 (* <> *) then
               1 -> cond
            // 3 (* <  *) then
               6 -> cond
            // 4 (* <= *) then
               5 -> cond
            // 5 (* >  *) then
               4 -> cond
            // 6 (* >= *) then
               3 -> cond
           if);
        exit cond
        #);
      loadBetaenv:
        (# 
        do getstatic -> jcf.emit;
           (common.betaenv.packagename,'betaenvRef',common.betaenv.packagename->makeSignature)
             -> jcf.emitFieldRef
        #);
      newBetaEnv:
        (#
        do (if false then
               loadBetaenv;
           if);
           new -> jcf.emit;
           common.betaenv.packagename -> jcf.emitClassRef;
           _dup -> jcf.emit;
           _dup -> jcf.emit;
           aconst_null -> jcf.emit; (* origin: null *)
           invokespecial -> jcf.emit; 
           (common.betaenv.packagename,'<init>','(Ljava/lang/Object;)V')
             -> jcf.emitMethodRef;
           
           invokevirtual -> jcf.emit; 
           (common.betaenv.packagename,'init','()V') -> jcf.emitMethodRef;
           
           (* save in betaenvref *)
           _dup -> jcf.emit;
           putstatic -> jcf.emit;
           (common.betaenv.packagename
           ,'betaenvRef'
           ,common.betaenv.packagename->makeSignature)
             -> jcf.emitFieldRef;
        #);
      opCode,arg1: @integer; 
      A: @Address;
      lastLocalAllocated:
        (* used by allocAndStoreLocal and just for testing .NET stuff *)
        @integer;
      T: ^text;
      index, index2: @integer;
      theL: @char
   do init;
      emitImports;
      read:
        (if opCode <> end then
            BC.get->opCode  -> trace_opcode;
            (if opCode
             // classDef then
                false -> isMainMethod;
                BC.gettext
                  -> thisClassName[]
                  -> jcf.constant_pool.classes.addtext
                  -> jcf.thisClassIndex;
                BC.get -> thisBlockLevel;
                (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
                BC.getText 
                  -> thisSuperName[] 
                  -> jcf.constant_pool.classes.addtext 
                  -> jcf.superClassIndex;
                
                'java/lang/Object'->thisSuperOrgName[];
                BC.get -> subLevel; 
                BC.gettext -> thisOrgName[];
                (if (subLevel = 0) and (common.betaenv.packagename->thisClassName.equalNCS) then
                    ('betaenvRef', thisClassName.copy->makeSignature)
                      -> jcf.fields.addText_static;

                if);
                (if not ('-'->thisOrgName.equal) then
                    (if true then
                        ('origin', thisOrgName[]) 
                          -> jcf.emitPublicFinalSyntheticFieldDef
                     else
                        ('origin', thisOrgName[]) -> jcf.emitFieldDef;
                    if)
                    
                if);
                thisClassName[] -> markAsInnerIfInnerClass;
                313->ctrace(# do '%%%class: "'->xT;
                              thisClassName[] -> xT;
                              '" blocklevel: ' -> xT;
                              thisBlockLevel -> xI; xN;
                              'super: "'->xT;
                              thisSuperName[] -> xT; 
                              '" sublevel: ' -> xT;
                              subLevel -> xI
                           #);
                
                BCstate.fields.init
             // markNested then
                (# nestedMangled,nested: ^text
                do BC.getText -> nestedMangled[];
                   BC.getText -> nested[];
                   (*1->trace(#
                           do 'markNested:' -> xT; thisClassName[] -> xT;
                              ' ' -> put; nestedMangled[] -> xT; 
                              ' '->put; nested[] -> xT
                           #);*)
                   (nestedMangled[],thisClassName[],nested[],ACC_PUBLIC)
                   -> jcf.emitInnerClassRef
                #)
             // endClass then 
   
             // methodDef then
                (# aux,noOfEnterArgs: @integer; (* 0 or 1 *)
                   methodname: ^text;
                   isStatic: @boolean;
                   access: @integer;
                   argn: ^text;
                do 1 -> BCstate.fields.LocalVariables.new;
                   1 -> MappedLocals.new;
                   
                   BC.gettext -> thisInnerMethodName[];  
                   BC.gettext -> thisSignature[];
                   BC.get -> noOfEnterArgs -> BCstate.fields.numArguments;
                   BC.get -> aux;
                   (if false then
                       '\nMethodDef: ' -> puttext;
                       thisSignature[] -> putline;
                       ' noOfArgs: ' -> puttext;
                       noOfEnterArgs -> putint;
                       ' Signature:'->puttext;
                       ' InnerName;' -> puttext;
                       thisInnerMethodName[] -> puttext;
                   if);
                   
                   (if 'main' -> thisInnerMethodName.equal then
                       (ACC_PUBLIC %Bor ACC_STATIC, 'main', '([Ljava/lang/String;)V', 8, 8)
                         -> jcf.currentmethod.new;
                       (if generateDebugInfo then
                           (0, 65535, 'args', 'Ljava/lang/String;') 
                             -> jcf.emitlocalVariableDefinition;
                       if);
                       true -> isMainMethod
                    else
                       false -> isMainMethod;
                       (if aux = 0 then
                           (* newline;
                            * thismethodname[] -> puttext;
                            * ' has inner'->putline;
                            *)
                           (0 (*%Bor ACC_PUBLIC*), thisInnerMethodName[], '()V', 1, 1)
                             -> jcf.currentmethod.new;
                           (if generateDebugInfo then
                               (if thisClassName[] = none then
                                   (failureTrace,'makeSig-2') -> stop;
                               if);
                               (0, 65535, 'this', thisClassName.copy
                                 -> makeSignature) 
                                 -> jcf.emitLocalVariableDefinition;
                           if);
                           _return -> jcf.emit;
                       if);
                       thisSignature[] 
                         -> splitSignature 
                         -> (methodname[], thisSignature[], isStatic);
                       (if isStatic then
                           (*ACC_PUBLIC %Bor*) ACC_STATIC -> access;
                        else
                           ACC_PUBLIC -> access;
                       if);
                       (if aux = 4 then
                           ACC_NATIVE %Bor access -> access
                       if);

                       (access, methodname[], thisSignature[], 100, 100)
                         -> jcf.currentmethod.new;
                       (if generateDebugInfo and (not isStatic) then
                           (0, 65535, 'this', thisClassName.copy->makeSignature) 
                             -> jcf.emitLocalVariableDefinition;
                       if);
                   if);  
                   jcf.labs.clear;
                   (if true then
                       (* enter parameters are declared as variables too.
                        * Thus no need for this!
                        * Well yes - apparently sometimes!!!!! FIXME!???
                        * Example: program.program() has a parameter of
                        * class tstenv/betaenv, but does NOT call 
                        * fields.new with tag 'm'
                        *)
                       (if generateDebugInfo then
                           (for i:noOfEnterArgs repeat
	                        'arg' -> argn[];
	                        i-1 -> argn.putint; (* FIXME: argument name *)
	                        (0, 65535, argn[], 'I' (* FIXME: argument type *))
	                          -> jcf.emitlocalvariabledefinition;
                           for);
                       if);
                   if);
                #);
             // initCons then
                (# sig: ^text
                do BC.gettext -> sig[]; 
                   (if ('-' -> thisOrgName.equal) then
                       (ACC_PUBLIC, '<init>', '()V', 8, 3) 
                         -> jcf.currentmethod.new;
                    else
                       (ACC_PUBLIC, '<init>', sig[], 8, 30)
                         -> jcf.currentmethod.new;
                   if);
                   (if generateDebugInfo then
                       (0, 65535, 'this', thisClassName.copy->makeSignature) 
                         -> jcf.emitLocalVariableDefinition;
                       (65535, 0, 'origin', 'Ljava/lang/Object;' 
                       (* FIXME: argument type *))
                         -> jcf.emitlocalvariabledefinition;
                if)#)
             // field then
                (# F: ^text
                do 'F' -> F[]; BC.get->F.putInt; (* datpete: Fnn field???? *)
                   (if BC.get = 1 then
                       (F[],BC.gettext,BC.gettext,BC.get) 
                         -> BCstate.fields.new
                    else
                       (F[],'???',BC.gettext,BC.get) 
                         -> BCstate.fields.new
                   if)
                #)
             // labelDef then
                BC.getShort->jcf.labs.def; 
             // callPrim then
                (# prim,arg: ^text;
                   index: @integer;
                   sig: ^text;
                do BC.gettext -> prim[];
                   BC.getText -> arg[];
                   (if trace_opcodes then
                       '  callprim: %s(%s)\n'->screen.putformat(# do prim[]->s; arg[]->s #);
                   if);
                   (if true 
                    // 'new' -> prim.equal then
                       new -> jcf.emit;
                       (* class name*)
                       arg[] -> jcf.emitClassRef;
                       _dup -> jcf.emit;
                       arg[] -> class[]; (* ugly *)  
                    // 'initSuper' -> prim.equal then
                       '(' -> sig[];
                       (if not ('-'->arg.equal) then
                           (if arg[] = none then
                                (failureTrace,'makeSig-3') -> stop;
                            if);

                           arg[] -> makeSignature -> sig.append;
                       if);
                       ')V' -> sig.append;
                       invokespecial -> jcf.emit;
                       (thisSuperName[],'<init>',sig[]) -> jcf.emitMethodRef;
                       (*BCstate.fields.emitInit;*)
                       (if (subLevel = 0) 
                           and 
                           (common.betaenv.packagename
                             ->thisClassName.equalNCS) then
                           aload_0 -> jcf.emit; (* this(betaenv)[] *)
                           putstatic -> jcf.emit;
                           (common.betaenv.packagename
                           ,'betaenvRef'
                           ,common.betaenv.packagename->makeSignature)
                             -> jcf.emitFieldRef;
                       if)
                    // 'init' -> prim.equal  then
                       invokespecial -> jcf.emit;
                       (class[], '<init>', arg[]) -> jcf.emitMethodRef;
                    // 'AlloS' -> prim.equal then
                       arg[] -> slashTodot -> jcf.emitLoadString;
                       invokestatic -> jcf.emit;
                       ('java/lang/Class' ,'forName', '(Ljava/lang/String;)Ljava/lang/Class;') 
                         -> jcf.emitMethodRef;
                       invokestatic -> jcf.emit;
                       (common.StructureClass, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)'->structureReturnSig) 
                         -> jcf.emitMethodRef;
                    // 'ObjS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass, 'ObjS', '(Ljava/lang/Object;)'->structureReturnSig)
                         -> jcf.emitMethodRef;
                    // 'AlloSI' -> prim.equal then
                       (* Stack: Structure *)
                       (* Call Structure.AlloSI which use reflection to set origin *)
                       invokevirtual -> jcf.emit; 
                       (common.StructureClass, 'AlloSI', '()Ljava/lang/Object;') 
                         -> jcf.emitMethodRef;
                    // 'AlloVR4' -> prim.equal 
                       
                       
                    // 'NewVR4' -> prim.equal then
                       T_INT -> emitNewArray
                    // 'AlloVR2' -> prim.equal 
                    // 'NewVR2' -> prim.equal then
                       T_SHORT -> emitNewArray  
                    // 'AlloVR1' -> prim.equal 
                    // 'NewVR1' -> prim.equal then
                       T_CHAR -> emitNewArray  
                    // 'AlloVRZ' -> prim.equal 
                    // 'NewVRZ' -> prim.equal then 
                       T_BOOLEAN -> emitNewArray  
                    // 'AlloVRB' -> prim.equal 
                    // 'NewVRB' -> prim.Equal then 
                       T_BYTE -> emitNewArray  
                    // 'AlloVR8' -> prim.equal 
                    // 'NewVR8' -> prim.equal then
                       T_DOUBLE-> emitNewArray  
                    // 'NewRR' -> prim.equal
                    // 'AlloRR' -> prim.equal then
                       (* arg = '[Ltype;' 
                        * extract: 'type'
                        *)
                       (3,arg.length-1) -> arg.sub -> emitAnewArray;
                       
                    // 'ExtVR1' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVR1', '([CI)[C') -> jcf.emitMethodRef; 
                    // 'ExtVRB' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVRB', '([BI)[B') -> jcf.emitMethodRef; 
                    // 'CopyVR1' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopyVR1', '([C)[C') -> jcf.emitMethodRef; 
                    // 'CopySVR1' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopySVR1', '(II[C)[C') -> jcf.emitMethodRef; 
                       
                    // 'ExtVRZ' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVRZ', '([ZI)[Z') -> jcf.emitMethodRef; 
                    // 'CopyVRZ' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopyVRZ', '([Z)[Z') -> jcf.emitMethodRef; 
                    // 'CopySVRZ' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopySVRZ', '(II[Z)[Z') -> jcf.emitMethodRef; 
                       

                    // 'ExtVR2' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVR2', '([SI)[S') -> jcf.emitMethodRef; 
                    // 'CopyVR2' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopyVR2', '([S)[S') -> jcf.emitMethodRef; 
                    // 'CopySVR2' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopySVR2', '(II[S)[S') -> jcf.emitMethodRef; 
                       
                    // 'ExtVR4' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVR4', '([II)[I') -> jcf.emitMethodRef; 
                    // 'CopyVR4' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopyVR4', '([I)[I') -> jcf.emitMethodRef; 
                    // 'CopySVR4' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopySVR4', '(II[I)[I') -> jcf.emitMethodRef; 

                    // 'ExtVR8' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'ExtVR8', '([DI)[D') -> jcf.emitMethodRef; 
                    // 'CopyVR8' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopyVR8', '([D)[D') -> jcf.emitMethodRef; 
                    // 'CopySVR8' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.BetaArrayClass, 'CopySVR8', '(II[D)[D') -> jcf.emitMethodRef; 
                       
                       
                    // 'ExtRR' -> prim.equal then
                       (* FIXME: possibly use local variables instead of stack, see CopySRR *)
                       (* arg: [Ltype;  - Convert to type: *)
                       (3,arg.length-1) -> arg.sub -> arg[];
                       (* stack: oldrep, add *)
                       (* int copysize = array.length;
                        * int newsize  = copysize + add;
                        * if (newsize<0) newsize = 0;
                        * if (copysize>newsize) copysize = newsize;
                        *)
                       swap              -> jcf.emit;
                       dup_x1            -> jcf.emit;
                       (* stack: oldrep, add, oldrep *)
                       arraylength       -> jcf.emit;
                       (* stack: oldrep, add, copysize *)
                       dup_x1            -> jcf.emit;
                       iadd              -> jcf.emit;
                       (* stack: oldrep, copysize, newsize *)
                       _dup              -> jcf.emit;
                       (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
                       (* 3: *) _pop     -> jcf.emit;
                       (* 4: *) iconst_0 -> jcf.emit;
                       (* 5: *)
                       (* stack: oldrep, copysize, newsize *)
                       dup2              -> jcf.emit;
                       (* stack: oldrep, copysize, newsize, copysize, newsize *)
                       (* 0: *) if_icmple-> jcf.emit; 6 -> jcf.emitShort;    
                       (* stack: oldrep, copysize, newsize; use copysize=newsize *)
                       (* 3: *) swap     -> jcf.emit;
                       (* 4: *) _pop     -> jcf.emit;
                       (* 5: *) _dup     -> jcf.emit;
                       (* 6: *)
                       (* stack: oldrep, copysize, newsize *)
                       anewarray    -> jcf.emit; arg[] -> jcf.emitClassRef;
                       dup_x2       -> jcf.emit;
                       swap         -> jcf.emit;
                       (* Stack: newrep, oldrep, newrep, copysize *)
                       iconst_0     -> jcf.emit;
                       dup_x2       -> jcf.emit;
                       swap         -> jcf.emit;
                       (* Stack: newrep, oldrep, 0, newrep, 0, copysize *)
                       invokestatic -> jcf.emit;
                       ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
                       (* Stack: newrep *)
                       
                    // 'CopyRR' -> prim.equal then
                       (* arg: [Ltype;  - Convert to type: *)
                       (3,arg.length-1) -> arg.sub -> arg[];
                       (# loc_oldrep, loc_size, loc_newrep: @integer;
                       do (* int size = array.length;
	                   * if (size<0) size = 0;
                           *)
                          allocLocal -> loc_oldrep;
                          allocLocal -> loc_size;
                          allocLocal -> loc_newrep;
                          _dup       -> jcf.emit;
                          loc_oldrep -> astoreLocal;
                          arraylength-> jcf.emit;
                          loc_size   -> storeLocal;
                          loc_size   -> loadLocal;
                          anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
                          loc_newrep -> astoreLocal;
                          loc_oldrep -> aloadLocal;
                          iconst_0   -> jcf.emit;
                          loc_newrep -> aloadLocal;
                          iconst_0   -> jcf.emit;
                          loc_size   -> loadLocal;
                          (* Stack: oldrep, 0, newrep, 0, size *)
                          invokestatic -> jcf.emit;
                          ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
                          loc_newrep -> aloadLocal; (* push result *)
                          loc_oldrep -> releaseLocal;
                          loc_newrep -> releaseLocal;
                          loc_size -> releaseLocal;
                       #);
                       
                    // 'CopySRR' -> prim.equal then
                       (* arg: [Ltype;  - Convert to type: *)
                       (3,arg.length-1) -> arg.sub -> arg[];
                       (* Stack: low, high, oldrep *)
                       (# loc_low, loc_high, loc_oldrep, loc_newsize, loc_newrep: @integer;
                       do allocLocal -> loc_low;
                          allocLocal -> loc_high;
                          allocLocal -> loc_oldrep;
                          loc_oldrep -> astoreLocal;
                          loc_high   -> storeLocal;
                          loc_low    -> storeLocal;
                          (* CkSR(low, high, oldrep.length); *)
                          loc_low    -> loadLocal;
                          loc_high   -> loadLocal;
                          loc_oldrep -> aloadLocal;
                          arraylength-> jcf.emit;
                          invokestatic -> jcf.emit; (common.BetaArrayClass, 'CkSR', '(III)V') -> jcf.emitMethodRef;
                          (* int newsize = high - (low-1);
	                   * if (newsize<0) newsize = 0;
                           *)
                          loc_high -> loadLocal;
                          loc_low  -> loadLocal;
                          iconst_1 -> jcf.emit;
                          isub     -> jcf.emit;
                          _dup     -> jcf.emit;
                          loc_low  -> storeLocal; (* loc_low = low-1 *)
                          isub     -> jcf.emit;
                          _dup     -> jcf.emit;
                          (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
                          (* 3: *) _pop     -> jcf.emit; 
                          (* 4: *) iconst_0 -> jcf.emit;
                          (* 5: *)
                          allocLocal -> loc_newsize -> storeLocal;
                          loc_newsize -> loadLocal;
                          anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
                          allocLocal -> loc_newrep -> astoreLocal;
                          loc_oldrep -> aloadLocal;
                          loc_low    -> loadLocal;
                          loc_newrep -> aloadLocal;
                          iconst_0   -> jcf.emit;
                          loc_newsize-> loadLocal;
                          (* stack: oldrep, low-1, newrep, 0, newsize *)
                          invokestatic -> jcf.emit;
                          ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
                            -> jcf.emitMethodRef;
                          loc_newrep -> aloadLocal; (* push result *)
                          loc_newrep -> releaseLocal;
                          loc_oldrep -> releaseLocal;
                          loc_high   -> releaseLocal;
                          loc_low    -> releaseLocal;
                          loc_newsize-> releaseLocal;
                       #);
                       
                    // 'Text2CharArray' -> prim.equal then
                       invokevirtual -> jcf.emit;
                       ('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
                    // 'CharArray2String' -> prim.equal then
                       new -> jcf.emit;
                       'java/lang/String' -> jcf.emitClassRef;
                       dup_x1 -> jcf.emit;
                       swap -> jcf.emit;
                       invokespecial -> jcf.emit;
                       ('java/lang/String', '<init>', '([C)V') -> jcf.emitMethodRef;
                    // 'ExternalString2BetaText' -> prim.equal then
                       (* Note! Hardcoding of pattern 'text'
                        * including case, etc. Should be handled
                        * more generally
                        *)
                       (# sig: ^text;
                       do ''->sig[];
                          '(L%s;)V' -> sig.putformat(# do common.betaenv.packagename->s #);
                          (* Stack: String or null *)
                          _dup -> jcf.emit;
                          (*  0: *)ifnull -> jcf.emit; 23-0 -> jcf.emitShort;
                          (*  3: *)invokevirtual -> jcf.emit;
                          (*  4: *)('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
                          (*  6: *)new -> jcf.emit;
                          (*  7: *)'text'->(common.BetaPackage).append -> jcf.emitClassRef;
                          (*  9: *)dup_x1 -> jcf.emit;
                          (* 10: *)dup_x1 -> jcf.emit;
                          (* 11: *)loadbetaenv;
                          (* 14: *)invokespecial -> jcf.emit; 
                          (* 15: *)('text'->(common.BetaPackage).append, '<init>', sig[]) -> jcf.emitMethodRef;
                          (* 17: *)invokevirtual -> jcf.emit; 
                          (* 18: *)('text'->(common.BetaPackage).append, 'enter', '([C)V') -> jcf.emitMethodRef; 
                          (* 20: *)goto -> jcf.emit; 25-20 -> jcf.emitshort;
                          (* 23: *)_pop -> jcf.emit; (* FIXME: pop *String*  null to satisfy verifier *)
                          (* 24: *)aconst_null -> jcf.emit; (* Push *beta.Text* null *)
                          (* 25: *)(* Stack: beta.Text or null *)
                       #);
                    // 'BetaText2ExternalString' -> prim.equal then
                       (* Stack: text *)
                       new -> jcf.emit;
                       'java/lang/String' -> jcf.emitClassRef; (* Stack: text, String *)
                       dup_x1 -> jcf.emit; (* Stack: String, text, String *)
                       swap -> jcf.emit; (* Stack: String, String, text *)
                       _dup -> jcf.emit; (* Stack: String, String, text, text *)
                       getfield  -> jcf.emit; 
                       ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef;
                       swap -> jcf.emit; (* Stack: String, String, T, text *)
                       bipush -> jcf.emit; 0 -> jcf.emit; 
                       swap -> jcf.emit; (* Stack: String, String, T, 0, text *)
                       getfield  -> jcf.emit; 
                       ('text'->(common.BetaPackage).append,'lgth', 'I') -> jcf.emitFieldRef; 
                       (* Stack: String, String, T, 0, T.lgth *)
                       invokespecial -> jcf.emit;
                       ('java/lang/String', '<init>', '([CII)V') 
                         -> jcf.emitMethodRef;
                       (* Stack: String *)
                    // 'BetaText2BetaCharArray' -> prim.equal then
                       getfield  -> jcf.emit; 
                       ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef; 
                       
                    // 'char2rep' -> prim.equal then
                       (* a single char is on the stack;
                        * create a new char array of length 1
                        * and store the char in the array;
                        * and return the array;
                        * Before: ... ch
                        * After : ... array,array,index(0),ch
                        *)
                       bipush -> jcf.emit; 1 -> jcf.emit; 
                       T_CHAR -> emitNewArray;
                       dup_x1 -> jcf.emit;    
                       swap -> jcf.emit;                 (* ... array,array,ch *)
                       bipush -> jcf.emit; 0 -> jcf.emit;
                       swap -> jcf.emit;                 (* ... array,array,0,ch *)
                       castore -> jcf.emit;
                    // 'eqS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'eqS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'neS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'neS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'ltS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'ltS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'leS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'leS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'gtS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'gtS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'geS' -> prim.equal then
                       invokestatic -> jcf.emit;
                       (common.StructureClass ,'geS', structureCompareSig) -> jcf.emitMethodRef;
                    // 'Att' -> prim.equal then
                       getfield  -> jcf.emit; 
                       (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
                         -> jcf.emitFieldRef; 
                       
                       invokevirtual -> jcf.emit;
                       (Common.ComponentClass ,'swap', '()V') 
                         -> jcf.emitMethodRef;
                       
                    // 'Susp' -> prim.equal then
                       getstatic -> jcf.emit;
                       (Common.ComponentClass, 'current', common.ComponentClass->makeSignature)
                         -> jcf.emitFieldRef;
                       invokevirtual -> jcf.emit;
                       (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
                       
                    // 'SuspX' -> prim.equal then
                       getfield  -> jcf.emit; 
                       (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
                         -> jcf.emitFieldRef; 
                       invokevirtual -> jcf.emit;
                       (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
                       
                    // 'AlloC' -> prim.equal then
                       (* Generate new Comp-object - constructor takes care of se4tup *)
                       (# sig: ^text;
                       do &text[] -> sig[];
                          (if true then
                              'AlloC'           -> jcf.emitLoadString;
                              _pop              -> jcf.emit;
                          if);
                          _dup                  -> jcf.emit;
                          new                   -> jcf.emit;
                          common.ComponentClass -> jcf.emitClassRef;
                          swap                  -> jcf.emit;
                          invokespecial         -> jcf.emit;
                          '(L%s;)V'-> sig.putformat(# do common.BetaObjectClass -> s #);
                          (common.ComponentClass, '<init>', sig[]) 
                            -> jcf.emitMethodRef; 
                       #);
                    // 'setup' -> prim.equal then;
                       aload_0 -> jcf.emit;                       
                       getfield  -> jcf.emit;
                       (thisClassName[]
                       , 'origin'
                       , arg.copy->makeSignature)
                         -> jcf.emitFieldRef; 
                       
                       newBetaEnv;
                       
                       putfield  -> jcf.emit;
                       (arg[], 'origin'
                       , common.betaenv.packagename->makeSignature)
                         -> jcf.emitFieldRef; 
                    // 'initArgs' -> prim.equal then
                       (# BCmch: ^ByteCodeMachine;
                          program_name, sig: ^text;
                          trace: (# exit false #);
                       do (* Find program name *)
                          (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> program_name[];
                          (* Generate signature for SetArgValues, 
                           * which is declared in betaenv_jvmbody
                           *)
                          ''->sig[];
                          '(L%s;Ljava/lang/String;[Ljava/lang/String;)V' 
                            -> sig.putformat(# do common.betaenv.packagename->s #);
                          (* First argument (betanev instance) loaded by dup in genMain *)
                          (* load program name *)
                          program_name[] -> jcf.emitLoadString;
                          (if trace then
                              'Trace(main): Number of Arguments: ' -> jcf.emitLoadString;
                              getstatic -> jcf.emit;
                              ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                              swap -> jcf.emit;
                              invokevirtual -> jcf.emit;
                              ('java/io/PrintStream', 'print', '(Ljava/lang/String;)V') 
                                -> jcf.emitMethodRef;
                              aload_0 -> jcf.emit; 
                              arraylength -> jcf.emit;
                              getstatic -> jcf.emit;
                              ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                              swap -> jcf.emit;
                              invokevirtual -> jcf.emit;
                              ('java/io/PrintStream', 'println', '(I)V') 
                                -> jcf.emitMethodRef;
                          if);
                          (* load args[] of main() *)
                          aload_0 -> jcf.emit; 
                          (* Call SetArgValues, which copies main.args to betaenv.ArgVector 
                           * with conversion String->Text of each element
                           *)
                          invokestatic -> jcf.emit;
                          ('SetArgValues'->(common.BetaPackage).append, 'SetArgValues', sig[]) 
                            -> jcf.emitMethodRef
                       #);
                    else
                       'Primitive: '->commentstream.puttext; 
                       prim[] -> commentstream.puttext; 
                       ' ' ->commentstream.put;
                       arg[] -> commentstream.puttext;
                       '\nUnknown primitive:'->puttext;
                       prim[] -> puttext; ' proto: '->puttext;
                       arg[] -> putline
                   if);
                #)
             // callExternal then
                (# prim, n, d, m: ^text; s: @boolean;
                do BC.getText -> prim[];
                   prim[] ->splitClassSignature->(n[], d[], s, m[]);
                   (if true 
                    // ('java/io/PrintStream'-> ((1,19)->prim.sub).equal) then
                       (* FIXME: hardcoded 
                        * Assuming that operation is on the static instance of 
                        * PrintStream in java/lang/System.out.
                        * We must load this first.
                        *)
                       getstatic -> jcf.emit;
                       ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                       swap -> jcf.emit;
                       invokevirtual -> jcf.emit; 
                       (m[], n[], d[]) -> jcf.emitMethodRef;
                    // ('java/io/InputStream'-> ((1,19)->prim.sub).equal) then
                       (* FIXME: hardcoded 
                        * Assuming that operation is on the static instance of 
                        * InputStream in java/lang/System.in.
                        * We must load this first.
                        *)
                       getstatic -> jcf.emit;
                       ('java/lang/System', 'in', 'Ljava/io/InputStream;')->jcf.emitFieldRef;
                      (* swap -> jcf.emit;*)
                       invokevirtual -> jcf.emit; 
                       (m[], n[], d[]) -> jcf.emitMethodRef;
                    else
                       'callExternal' -> jvmFIXME;
                       (if s then
                           invokestatic -> jcf.emit;
                        else
                           invokevirtual -> jcf.emit;
                       if);
                       (m[], n[], d[]) -> jcf.emitMethodRef; 
                   if);
                #)
             // callInner then
                aload_0 -> jcf.emit;
                invokevirtual -> jcf.emit;
                (* NOT in accordance with design - FIX *)
                (if false then
                    '_do_'-> thisInnerMethodName.append;
                    subLevel+1 -> thisInnerMethodName.putint;
                if);
                (thisClassName[], thisInnerMethodName[], '()V') 
                  -> jcf.emitMethodRef; 
             // comment then
                (# T: ^text
                do BC.gettext -> T[];
                   (if common.switch[319]
                       and 
                       (T.length > 0)
                       and 
                       ((T.length > 0) and ((1 -> T.inxget) <> '!') or common.switch[185])  
                       then
                       T[] -> jcf.emitComment;
                    else
                       restart read (* skip newline *)
                   if)
                #)
             // position then
                BC.getShort -> line;
                (if generateDebugInfo then
                    (if betafile.initialized then
                        line -> betafile.pc.posToLineCol -> (line, column);
                        line -> jcf.emitLinenumber;
                    if);
                if);
             // pushVal then 
                A.get; 
                (if false then
                    '\npushVal: '->puttext; A.display;
                    ', LIP=' -> puttext; jcf.currentmethod.LIP->putint; newline;
                if);
                A.load; 
             // stVal then
                A.get; 
                (if false then
                    '\nstVal: '->puttext; A.display; 
                    ', LIP=' -> puttext; jcf.currentmethod.LIP->putint; newline;
                if);
                A.store
             // loadRef then
                A.get; A.loadRef
             // loadQRef then
                A.get; true->A.loadRef
             // pushAdr then
                A.get; A.pushAdr
             // storeRef then
                A.get; A.storeRef
             // storeQref then 
                A.get; (true,false) -> A.storeRef
             // storeOrigin then
                A.get; (false,true) -> A.storeRef
             // loadOrigin then
                (# ONlevel,ctag,ftag: @integer; 
                   className,fieldType: ^text;
                   TheClassName, TheFieldName, TheFieldType: ^text;
                do BC.get -> ONlevel;
                   (*ONlevel -> putint; ' ' ->put;*)
                   BC.get -> ctag; 
                   (*ctag -> putint; ' ' ->put;*)
                   (if ctag = 1 then
                       BC.getText -> className[];
                       'loadOrigin:tag=1: '->commentstream.puttext;
                       className[] -> commentstream.puttext;
                       commentstream.newline;
                   if);
                   BC.get -> ftag;
                   (*ftag -> putint; ' ' ->put;*)
                   (if ftag = 1 then
                       BC.gettext -> fieldType[];
                       (*fieldType[] -> puttext; ' '->put*)
                   if);
                   (if isMainMethod then
                       (* reconsider for main/program-slot;
                        * in Java:main, we cannot access class fields;
                        * but we may do in BETA
                        *)
                       aconst_null -> jcf.emit;
                    else
                       (if ONlevel = 0 then
                           aload_0 -> jcf.emit;
                        else
                           getfield  -> jcf.emit;
                           (if ctag = 0 then
                               ONlevel 
                                 -> BCstate.blocks.class 
                                 -> TheClassName[];
                            else
                               className[] -> TheClassName[]
                           if);
                           'origin' -> TheFieldName[];
                           (if ftag = 0 then
                               '\nOBS shouldnot come here'->putline;
                               ONlevel 
                                 -> BCstate.blocks.orgClass
                                 (*-> makeSignature*)
                                 -> TheFieldType[];
                            else
                               (if fieldtype[] = none then
                                   '\nftag:'->puttext; ftag->putint; newline;
                                   (failureTrace,'makeSig-5') -> stop;
                               if);
                               
                               fieldType[] 
                                 (*-> makeSignature*)
                                 -> TheFieldType[];
                           if);
                           (TheClassName[], TheFieldName[], TheFieldType[])
                             -> jcf.emitFieldRef;
                       if);
                   if)
                #)
             // cast then
                (# class: ^text
                do checkcast  -> jcf.emit;
                   BC.gettext -> emitCheckCast
                #)
             // call then 
                (# n, d, m: ^text; 
                   calltype: @integer;
                   s, isValueType, isInterfaceMethod, isStatic: @boolean;
                   nargs: @int16;
                do BC.get -> calltype;
                   callType %Band 1 = 1 -> isStatic;
                   callType %Band 2 = 2 -> isValueType;
                   callType %Band 4 = 4 -> isInterfaceMethod;
                   BC.getText->T[];
                   T[]->splitClassSignature->(n[], d[], s, m[]);
                   (if isInterfaceMethod then
                       invokeinterface -> jcf.emit;
                       (m[], n[], d[]) -> jcf.emitInterfaceMethodRef;
                       d[] -> noArgsInSignature -> nargs;
                       nargs + 1 (* interface pointer counts for one *) -> jcf.emit;
                       0 -> jcf.emit;
                    else
                       (if isStatic then
                           invokestatic  -> jcf.emit;
                        else
                           invokevirtual -> jcf.emit;
                       if);
                       (m[], n[], d[]) -> jcf.emitMethodRef; 
                   if);
                #);
                313->trace(#do '%%%call: '->xT; T[]->xT #)
             // return then
                (if BC.get 
                 // 0 // 10 then 
                    _return -> jcf.emit;
                 // 1 // 2 // 3 // 4 // 5 then 
                    ireturn -> jcf.emit;
                 // 6 (* real *) then 
                    dreturn -> jcf.emit;
                 // 7 (* real32 *) then 
                    freturn -> jcf.emit;                    
                 // 8 (* long=int64 *) then
                    lreturn -> jcf.emit
                 // 11 // 12 // 13 // 14 then 
                    areturn -> jcf.emit;
                 else 
                    'xreturn' -> jvmFIXME;
                if);
             // beginLab then
                (# restartLabno: @integer;
                   leaveLabno: @integer;
                do BC.getLong -> restartlabno;
                   BC.getLong -> leavelabno;
                #);
                (* Lleave: *)
             // endLab then
                (* stack: ExoException object *)
                (# restartLabno: @integer;
                   leaveLabno: @integer;
                   handler_pc: @integer;
                   restart_pc: @integer;
                   loc: @integer; (* Save exception object into this local *)
                   rethrowOff: integerValue
                     (* Calculate offset to rethrow label from current PC.
                      * Code between the two labels:
                      *   loc -> aloadLocal;  (1 or 2 bytes)
                      *   athrow-> jcf.emit;  (1 byte)
                      *)
                     (# 
                     do (if loc<=3 then
                            (leavelabno -> jcf.labs.off)-2 -> value
                         else
                            (leavelabno -> jcf.labs.off)-3 -> value
                        if)                            
                     #);
                do BC.getLong -> restartlabno;
                   BC.getLong -> leavelabno;
                   (* End try clause by jumping over handler *)
                   goto -> jcf.emit; leavelabno -> jcf.labs.off -> jcf.emitShort;
                   (* Start handler:
                    * if (e.exitobj == this){
		    *   if (e.labno == restartlabno){
                    *      // We have a restart in this Object
                    *      continue Lrestart;
                    *   } else if (e.labno==leavelabno){
                    *     // We have a leave in this Object
                    *     break Lleave;
                    *   }
		    * }
		    * /* Not leave/restart for this Object - propagate further */
		    * throw e;
                    *)
                   jcf.currentmethod.LIP -> handler_pc;
                   allocLocal -> loc -> astoreLocal;
                   loc -> aloadLocal; 
                   getfield  -> jcf.emit; ('ExOException'->(common.BetaPackage).append, 'exitobj', 'Ljava/lang/Object;') -> jcf.emitfieldref;
                   aload_0   -> jcf.emit; 
                   if_acmpne -> jcf.emit; rethrowOff -> jcf.emitShort; (* Lrethrow*)
                   (* Ltestrestart: *)
                   loc -> aloadLocal; 
                   getfield  -> jcf.emit; ('ExOException'->(common.BetaPackage).append, 'labno', 'I') -> jcf.emitfieldref;
                   restartlabno -> jcf.emitLoadIntegerConstant;
                   if_icmpne -> jcf.emit; 6 -> jcf.emitShort; (* Ltestleave *)
                   (* We have a restart in this Object *)
                   goto      -> jcf.emit; restartlabno -> jcf.labs.off -> jcf.emitShort; (* Lrestart *)
                   (* Ltestleave: *)
                   loc -> aloadLocal; 
                   getfield  -> jcf.emit; ('ExOException'->(common.BetaPackage).append, 'labno', 'I') -> jcf.emitfieldref;
                   leavelabno -> jcf.emitLoadIntegerConstant;
                   if_icmpne -> jcf.emit; rethrowOff -> jcf.emitShort; (* Lrethrow *)
                   (* We have a restart in this Object *)
                   goto      -> jcf.emit; leavelabno -> jcf.labs.off -> jcf.emitShort; (* Lleave *)
                   (* Lrethrow: *)

                   (* Not the right label in this Object - propagate further *)
                   loc -> aloadLocal; 
                   athrow-> jcf.emit; 
                   (* Lleave: *)
                   
                   (* Set up try-catch info *)
                   RestartLabNo -> jcf.labs.off -> restart_pc;
                   (if restart_pc=0 then
                       'endLab: error: Restartlabel not yet defined?' -> jvmFIXME;
                   if);
                   (if false then
                       'endlab: L' -> screen.puttext;
                       restartlabno->screen.putint;
                       ': restart offset: ' -> screen.puttext;
                       restart_pc -> screen.putint;
                       ' at PC ' -> screen.puttext;
                       jcf.currentmethod.LIP -> screen.putint;
                       screen.newline;
                   if);
                   (jcf.currentmethod.LIP + restart_pc - 1) -> restart_pc;
                   (restart_pc (*start_pc*), handler_pc (*end_pc*), handler_pc (*handler_pc*), 'ExOException'->(common.BetaPackage).append) 
                     -> jcf.emitExceptionHandlerDef;
                   loc -> releaseLocal;
                #);
             // break then
                (# labno: @integer;
                   re_start: @integer;
                do BC.getLong -> labno;
                   BC.get -> re_start;
                   (* exitObj already pushed *)
                   new           -> jcf.emit; 'ExOException'->(common.BetaPackage).append -> jcf.emitClassRef;
                   (* stack: ExOException; exitObj *)
                   dup_x1        -> jcf.emit;
                   (* stack: ExOException; exitObj, ExOException *)
                   swap          -> jcf.emit;
                   (* stack: exitObj, ExOException; ExOException *)
                   labno         -> jcf.emitLoadIntegerConstant; (* potentially 32 bit constant *)
                   (* stack: labno, exitObj, ExOException; ExOException *)
                   invokespecial -> jcf.emit; ('ExOException'->(common.BetaPackage).append, '<init>', '(Ljava/lang/Object;I)V') -> jcf.emitMethodRef;
                   athrow        -> jcf.emit;
                 #)
             // cmpToBool then
                'cmpToBool' -> commentstream.puttext;
                (* 0:      if_xxx L1
                 * 3:      bipush 0
                 * 5:      goto L2
                 * 8:  L1: bipush 1
                 * 10: L2:
                 *)
                (if BC.get
                 // 1 (* =  *) then
                    if_icmpeq -> jcf.emit;
                 // 2 (* <> *) then
                    if_icmpne -> jcf.emit;
                 // 3 (* <  *) then
                    if_icmplt -> jcf.emit;
                 // 4 (* <= *) then
                    if_icmple -> jcf.emit;
                 // 5 (* >  *) then
                    if_icmpgt -> jcf.emit;
                 // 6 (* >= *) then
                    if_icmpge -> jcf.emit;
                if);
                8-0 -> jcf.emitShort; (* L1 *)
                bipush -> jcf.emit; 0 -> jcf.emit;
                goto -> jcf.emit;
                10-5 -> jcf.emitShort; (* L2 *)
                bipush -> jcf.emit; 1 -> jcf.emit;

             // cmpToBoolRef then
                'cmpToBoolRef' -> commentstream.puttext;
                (* 0:      if_xxx L1
                 * 3:      bipush 0 or 1
                 * 5:      goto L2
                 * 8:  L1: bipush 1 or 1
                 * 10: L2:
                 *)
                (# cond: @integer
                do BC.get -> cond; 
                   (if cond = 1 (* =  *) then
                       if_acmpeq -> jcf.emit;
                       (*if_acmpne -> jcf.emit;*)
                    else (* cond = 2  <> *) 
                       if_acmpeq -> jcf.emit;
                   if);
                   8-0 -> jcf.emitShort; (* L1 *)
                   bipush -> jcf.emit; 
                   (if cond = 1 (* = *) then 
                       0 -> jcf.emit
                    else
                       1 -> jcf.emit
                   if);
                   goto -> jcf.emit;
                   10-5 -> jcf.emitShort; (* L2 *)
                   bipush -> jcf.emit; 
                   (if cond = 1 then 
                       1 -> jcf.emit;
                    else
                       0 -> jcf.emit;
                if)#)
             // cmpAndJmp then
                'cmpAndJmp' -> commentstream.puttext;
                (BC.get,BC.get,BC.getShort,BC.get) -> emitCmpJmp 
             // cmpBoolAndJmp then
                'cmpBoolAndJmp' -> commentstream.puttext;
                (BC.get,BC.get,BC.getShort) -> emitCmpBoolJmp
             // cmp then
                cmp -> jcf.emit;
             // cmpAndJmpFloat then
                dcmpg -> jcf.emit;
                (BC.get,BC.get,BC.getShort) -> emitCmpBoolJmp
             // cmpToBoolFloat then
                dcmpg -> jcf.emit;
                (if BC.get
                 // 1 (* =  *) then ifeq -> jcf.emit
                 // 2 (* <> *) then ifne -> jcf.emit
                 // 3 (* <  *) then iflt -> jcf.emit
                 // 4 (* <= *) then ifle -> jcf.emit
                 // 5 (* >  *) then ifgt -> jcf.emit
                 // 6 (* >= *) then ifge -> jcf.emit
                if);
                8-0 -> jcf.emitShort; (* L1 *)
                bipush -> jcf.emit; 0 -> jcf.emit;
                goto -> jcf.emit;
                10-5 -> jcf.emitShort; (* L2 *)
                bipush -> jcf.emit; 1 -> jcf.emit;
                
             // pushReg then
                dumpReg
             // pushNone then
                aconst_null -> jcf.emit;
             // dup then
                BC.get -> arg1;
                (if BC.get = 0 then
                    (if arg1
                     // 0 then _dup -> jcf.emit;
                     // 1 then dup_x1 -> jcf.emit;
                     // 2 then dup_x2 -> jcf.emit;
                    if)
                 else (* 1: dup real64/double; 2: dup two int32 *)
                    (if arg1
                     // 0 then dup2 -> jcf.emit;
                     // 1 then dup2_x1 -> jcf.emit;
                     // 2 then dup2_x2 -> jcf.emit;
                if)if)
             // pop then
                _pop -> jcf.emit;
             // pop2 then
                _pop2 -> jcf.emit;
             // _loadLocal then (* compiler dies if this is without the underscore!! *)
                (if BCstate.fields.LocalVariables[lastLocalAllocated]
                 // -1 then
                    'opcode loadlocal: using unknown local variable type' -> JVMFIXME;
                 // 0 then
                    'opcode loadlocal: using unassigned local variable' -> JVMFIXME;
                 // 1 then
                    lastLocalAllocated -> loadLocal
                 // 2 then
                    lastLocalAllocated -> aloadLocal
                 else
                    'opcode loadlocal: using local variable of unknown kind' -> JVMFIXME;
                if)
             // pushCst_s8 then
                bipush -> jcf.emit;
                BC.get -> jcf.emit; 
             // pushCst_s16 then
                sipush -> jcf.emit;
                BC.getShort -> jcf.emitShort  
             // pushCst_s32 then
                BC.getLong -> jcf.emitLoadIntegerConstant; 
             // pushRealCst then
                ldc2_w  -> jcf.emit;
                (BC.getLong, BC.getLong) -> jcf.emitDoubleConstant;
             // return then
                _return -> jcf.emit;
             // nop then
                _nop -> jcf.emit;
             // end then
                (if (thisClassName[]<>NONE) and (common.BetaObjectClass->thisClassName.equal) then
                    (* Just finished generating BetaObject (in betaenv). *)
                    GenerateJvmClassExOException;
                    GenerateJvmClassStructure;
                    GenerateJvmClassBetaArray;
                    (if not common.ComponentDotCJ then
                        GenerateJvmClassComponent;
                    if);
                if);
             // index then
                Unused1 -> jcf.emit; 'bytecode index' -> jvmFIXME;
             // newVirt then 
                Unused1 -> jcf.emit; 'bytecode newvirt' -> jvmFIXME;
             // return then
                _return -> jcf.emit;
             // endMethod then
                jcf.labs.check_all_relocated;
             // label then
                Unused1 (*L*) -> jcf.emit; 'bytecode label' -> jvmFIXME;
                'LIP=' -> puttext;
                jcf.currentmethod.LIP -> putint; newline;
             // end then
                Unused1 (*L*) -> jcf.emit; 'bytecode end' -> jvmFIXME;
             // pushText then
                BC.getText -> jcf.emitLoadString;
             // dup then 
                _dup -> jcf.emit;
             // pop  then 
                _pop -> jcf.emit;
             // loadRange then 
                arraylength -> jcf.emit;
             // jmp then
                (# labno: @integer
                do 
                   goto -> jcf.emit;
                   BC.get -> theL (* opcode label *); 
                   BC.getShort -> labno;
                   (if labno = 0 then
                       '\nOOPS opcode jmp: use of strange label L0'->putline;
                       1 -> labno;
                   if);
                   labno -> jcf.labs.off -> jcf.emitShort;
                #)
             // jmpt then (* arguments here is a text;
                           * so does the code below work? *)
                (# off: @integer 
                do goto -> jcf.emit;
                   BC.get (* opcode label *); 
                   BC.get -> off;
                   (if off = 0 then
                       '\nOBS! jmpt:off=0'->putline;
                       1 -> off
                   if);
                   off -> jcf.labs.off -> jcf.emitShort;
                #)
             // r64toR32 then
                d2f -> jcf.emit
             // r32toR64 then
                f2d -> jcf.emit                
             // r64add then
                dadd -> jcf.emit
             // r64sub then
                dsub -> jcf.emit
             // r64mul then
                dmul -> jcf.emit
             // r64div then
                ddiv -> jcf.emit 
             // r64neg then
                dneg -> jcf.emit
             // int2double then
                i2d -> jcf.emit
             // double2int then
                d2i -> jcf.emit
             // int64ToInt32 then
                l2i -> jcf.emit
             // int32ToInt64 then
                i2l -> jcf.emit
             // func then
                (# func: @integer;
                do BC.get->func;
                   (if func
                    // add then
                       iadd -> jcf.emit;
                    // sub then
                       isub -> jcf.emit;
                    // nott then
                       (* 0:     ifne L1
                        * 3:     iconst_1
                        * 4:     goto L2
                        * 7: L1: iconst_0
                        * 8: L2:
                        *)
                       ifne -> jcf.emit;
                       7-0 -> jcf.emitShort;
                       iconst_1 -> jcf.emit;
                       goto -> jcf.emit;
                       8-4 -> jcf.emitShort;
                       iconst_0 -> jcf.emit;
                    // mult then
                       imul -> jcf.emit;
                    // divv then
                       idiv -> jcf.emit;
                    // modd then
                       irem -> jcf.emit;
                    // xorr then
                       ixor -> jcf.emit;
                    // logNot then
                       (* bit not *)
                       iconst_m1 -> jcf.emit;
                       ixor -> jcf.emit;
                    // neg then
                       ineg -> jcf.emit;
                    // orr then
                       ior -> jcf.emit;
                    // andd then
                       iand -> jcf.emit;
                    // logicalShiftLeft then
                       ishl -> jcf.emit;
                    // logicalShiftRight then
                       iushr -> jcf.emit;
                    // arithShiftLeft then   
                       ishl -> jcf.emit;
                    // arithShiftRight then
                       ishr -> jcf.emit;
                    // rotateLeft then
                       (* Perform i %rol r *)
                       (* Implemented as:
                        *   (i << r) | ((i & ((1<<r)-1) >> (32-r))
                        *)
                       (* initial stack: r, i *)
                       (if false then
                           swap     -> jcf.emit; (* stack: i, r *)
                           dup_x2   -> jcf.emit; (* stack: i, r, i *)
                           swap     -> jcf.emit; (* stack: r, i, i *)
                           dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
                        else
                           dup2     -> jcf.emit; (* stack: r, i, r, i *)
                       if);
                       dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
                       iconst_1 -> jcf.emit; 
                       swap     -> jcf.emit; 
                       (* stack: r, 1, i, r, r, i *)
                       ishl     -> jcf.emit; 
                       iconst_1 -> jcf.emit; 
                       isub     -> jcf.emit; 
                       (* stack: (1<<r)-1, i, r, r, i *)
                       iand     -> jcf.emit; 
                       (* stack: i&(1<<r)-1, r, r, i *)
                       swap     -> jcf.emit; 
                       bipush   -> jcf.emit; 32 -> jcf.emit;
                       swap     -> jcf.emit; 
                       isub     -> jcf.emit; 
                       ishr     -> jcf.emit; 
                       (* stack: (i&(1<<r)-1)>>(32-r), r, i*)
                       dup_x2   -> jcf.emit; 
                       _pop     -> jcf.emit; 
                       (* stack: r, i, (i&(1<<r)-1)>>(32-r) *)
                       ishl     -> jcf.emit; 
                       ior      -> jcf.emit; 
                       (* stack: (i<<r) | (i&(1<<r)-1)>>(32-r) *)
                    // rotateRight then
                       (* Perform i %ror r *)
                       (* Implemented as:
                        *   (i >> r) | ((i & ((1<<r)-1) << (32-r))
                        *)
                       (* initial stack: r, i *)
                       (if false then
                           swap     -> jcf.emit; (* stack: i, r *)
                           dup_x2   -> jcf.emit; (* stack: i, r, i *)
                           swap     -> jcf.emit; (* stack: r, i, i *)
                           dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
                        else
                           dup2     -> jcf.emit; (* stack: r, i, r, i *)
                       if);
                       dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
                       iconst_1 -> jcf.emit; 
                       swap     -> jcf.emit; 
                       (* stack: r, 1, i, r, r, i *)
                       ishl     -> jcf.emit; 
                       iconst_1 -> jcf.emit; 
                       isub     -> jcf.emit; 
                       (* stack: (1<<r)-1, i, r, r, i *)
                       iand     -> jcf.emit; 
                       (* stack: i&(1<<r)-1, r, r, i *)
                       swap     -> jcf.emit; 
                       bipush   -> jcf.emit; 32 -> jcf.emit;
                       swap     -> jcf.emit; 
                       isub     -> jcf.emit; 
                       ishl     -> jcf.emit; 
                       (* stack: (i&(1<<r)-1)<<(32-r), r, i*)
                       dup_x2   -> jcf.emit; 
                       _pop     -> jcf.emit; 
                       (* stack: r, i, (i&(1<<r)-1)<<(32-r) *)
                       ishr     -> jcf.emit; 
                       ior      -> jcf.emit; 
                       (* stack: (i>>r) | (i&(1<<r)-1)<<(32-r) *)
                    // byteswapShort then
                       (* Implemented as 
                        *   (x & 0xffff0000)
                        *   |
                        *   (((x>>8) & 0xff) | ((x<<8) & 0xff00)) 
                        * OBS! Is this a little-endian implementation only?
                        * For
                        *    x = 0xabcdefghi
                        * we get
                        *    x = 0xabcdhifg
                        * on big endian we should get
                        *    x = 0xcdabfghi
                        * ???
                        *)
                       (* stack: x *)
                       _dup      -> jcf.emit;
                       0xffff0000 -> jcf.emitLoadIntegerConstant;
                       iand      -> jcf.emit;
                       swap      -> jcf.emit;
                       (* stack: x, (x & 0xffff0000) *)
                       _dup      -> jcf.emit;
                       (* stack: x, x, (x & 0xffff0000) *)
                       bipush    -> jcf.emit; 8 -> jcf.emit;
                       ishr      -> jcf.emit;
                       0xff -> jcf.emitLoadIntegerConstant;
                       iand      -> jcf.emit;
                       swap      -> jcf.emit;
                       (* stack: (x, (x>>8) & 0xff), (x & 0xffff0000) *)
                       bipush    -> jcf.emit; 8 -> jcf.emit;
                       ishl      -> jcf.emit;
                       0xff00 -> jcf.emitLoadIntegerConstant;
                       iand      -> jcf.emit;
                       (* stack: 
                        *((x<<8) & 0xff00)), ((x>>8) & 0xff), (x & 0xffff0000)
                        *)
                       ior       -> jcf.emit;
                       (*i2s       -> jcf.emit;*)
                       ior -> jcf.emit
                    // byteswapLong then
                       (* Implemented as
                        *   short h = (short)(x>>16);
	                *   short l = (short)(x & 0xffff);
	                *   short nl = (short)((h>>8) | ((h<<8) & 0xff00));
	                *   short nh = (short)((l>>8) | ((l<<8) & 0xff00));
	                *   int result = (nh << 16) | nl;
                        *)
                       (* stack: x *)
                       _dup    -> jcf.emit; 
                       _dup    -> jcf.emit; 
                       (* stack: x, x, x, ... *)
                       0xffff -> jcf.emitLoadIntegerConstant;
                       iand    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishr    -> jcf.emit;
                       (* stack: (l>>8), x, x, ... *)
                       swap    -> jcf.emit; 
                       0xffff -> jcf.emitLoadIntegerConstant;
                       iand    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishl    -> jcf.emit;
                       0xff00 -> jcf.emitLoadIntegerConstant;
                       iand    -> jcf.emit;
                       ior     -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 16 -> jcf.emit;
                       ishl    -> jcf.emit;
                       (* stack: (nh<<16), x, ... *)
                       swap    -> jcf.emit; 
                       _dup    -> jcf.emit;
                       (* stack: x, x, (nh<<16), ... *)
                       bipush  -> jcf.emit; 16 -> jcf.emit;
                       ishr    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishr    -> jcf.emit; 
                       (* stack: (h<<8), x, (nh<<16), ... *)
                       swap    -> jcf.emit; 
                       (* stack: x, (h<<8), (nh<<16), ... *)
                       bipush  -> jcf.emit; 16 -> jcf.emit; 
                       ishr    -> jcf.emit; 
                       i2s     -> jcf.emit; 
                       bipush  -> jcf.emit; 8 -> jcf.emit; 
                       ishl    -> jcf.emit; 
                       0xff00 -> jcf.emitLoadIntegerConstant;
                       iand    -> jcf.emit; 
                       ior     -> jcf.emit; 
                       i2s     -> jcf.emit; 
                       ior     -> jcf.emit; 
                    else
                       'Unhandled bytecode func.' -> (func -> asText).prepend -> jvmFIXME;
                       'Unhandled bytecode func.' -> (func -> asText).prepend -> jcf.emitComment;
                   if)
                #);
             else
                'Unhandled bytecode ' -> (opcode -> asText).prepend -> jvmFIXME;
                'Unhandled bytecode ' -> (opcode -> asText).prepend -> jcf.emitComment;
            if);
            restart read
        if);
      jcf.EmitToFile;
   #)  
   
--textlib: attributes--
deletePathSuffix:
  (# suffix: ^text;
     mylength, suffixlength: @integer;
  enter suffix[]
  do suffix.copy -> BackslashToSlash -> suffix[];
     suffix.length -> suffixlength;
     length -> mylength;
     (if (mylength-suffixlength+1, mylength) -> sub -> BackslashToSlash -> suffix.equal then
         (mylength-suffixlength+1, mylength) -> delete;
      else
         'text.deletePathSuffix: warning: ' -> screen.puttext;
         suffix[] -> screen.puttext;
         ' is not a suffix of ' -> screen.puttext;
         this(text)[] -> screen.putline;
     if)
  #);
