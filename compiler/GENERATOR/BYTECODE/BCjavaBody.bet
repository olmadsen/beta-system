ORIGIN 'BCmachineBody';
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/basiclib/streamPosition'; 

--BCmachineLib: attributes--

generateDebugInfo:
  (# exit common.switch[41] #);

splitSignature:
  (# signature: ^text;
     name: ^text;
     isStatic: @boolean;
  enter signature[]
  do signature.copy -> signature[];
     &text[] -> name[];
     (if 'static ' -> ((1,7) -> signature.sub).equal then
         true -> isStatic;
         (1,7) -> signature.delete;
     if);
     scan:
       (for i:signature.lgth repeat
            (if signature.T[i]='(' then
                (1,i-1) -> signature.sub -> name[];
                (1,i-1) -> signature.delete;
                leave scan;
            if);
       for);
     INNER;
  exit (name[], signature[], isStatic)
  #);
SplitClassSignature: SplitSignature
  (# lastSlash: @integer;
     method: ^text;
  do &text[] -> method[];
     scan:
       (for i:name.lgth repeat
            (if name.T[i]='(' then leave scan if);
            (if name.T[i]='/' then i->lastSlash if)
       for);
     (if lastSlash>0 then
         (1, lastSlash-1) -> name.sub -> method[];
         (1, lastSlash) -> name.delete;
     if);
  exit method[]
  #);

FIXME: 
  (# T: ^text
  enter T[]
  do (if not common.switch[188] then
         'FIXME: ' -> (T.copy).prepend -> T[];
         '***** ' -> screen.puttext; T[] -> screen.putline;
         (* Possibly generate an IOcall with T[] too *)         
     if);
  #);

GenerateClassExOException:
  (* Called when BetaObject has just been generated.
   * Generate ExOException.class in the same directory.
   *)
  (# exo: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> exo[];
     not common.switch[188] -> exo.traceClassFileName;
     common.switch[190] -> exo.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'ExOException.class' -> fn.append;
     fn[] -> exo.init;
     (* Class file ready to start emitting to *)
     
     'ExOException'
       -> exo.constant_pool.classes.addtext
       -> exo.thisClassIndex;
     'java/lang/Exception'
       -> exo.constant_pool.classes.addtext 
       -> exo.superClassIndex;
     
     ('exitobj', 'Ljava/lang/Object;') -> exo.emitFieldDef;
     ('labno', 'I')                    -> exo.emitFieldDef;
     ('restart', 'Z')                  -> exo.emitFieldDef;
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;IZ)V', 2,  4) -> exo.currentmethod.new;
     aload_0       -> exo.emit;
     invokespecial -> exo.emit; ('java/lang/Exception', '<init>', '()V') -> exo.emitMethodRef;
     aload_0       -> exo.emit;
     aload_1       -> exo.emit;
     putfield      -> exo.emit; ('ExOException', 'exitobj', 'Ljava/lang/Object;') -> exo.emitFieldRef;
     aload_0       -> exo.emit;
     iload_2       -> exo.emit;
     putfield      -> exo.emit; ('ExOException', 'labno', 'I') -> exo.emitFieldRef;
     aload_0       -> exo.emit;
     iload_3       -> exo.emit;
     putfield      -> exo.emit; ('ExOException', 'restart', 'Z') -> exo.emitFieldRef;
     _return       -> exo.emit;
     
     exo.emitToFile;
     
     (*(fn[],false,asmLink.objKind,false) -> putInJobFile;*)
  #);

--FieldsNewJasmin:descriptor--
(# name_index, descriptor_index: @integer;
do (if methodClassTag 
    // 'c' 
    // 'p' 
    // '[' then
       (if methodClassTag = '[' then '[' -> T.prepend if);
       (FN[], T[]) -> jcf.emitFieldDef;
    // 'm' then
       (*'FieldsNewJasmin.m: '->screen.puttext;
       FN[] -> screen.putline;*)
       (if generateDebugInfo then
           (65535, 0, FN[], T[]) -> jcf.emitLocalVariableDefinition;
       if);
   if);
#)

--FieldsEmitInitItemJasmin:descriptor--
(# class: ^ text
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       aload_0 -> jcf.emit;
       (if true
        // 'I' -> currentType.equal 
        // 'C' -> currentType.equal
        // 'Z' -> currentType.equal (* boolean *)
        // 'B' -> currentType.equal (* byte *) 
        // 'S' -> currentType.equal (* short *) 
           then
           bipush -> jcf.emit;
           0  -> jcf.emit;
        // 'D' -> currentType.equal (* double/real *) then
           dconst_0 -> jcf.emit
        // 'F' -> currentType.equal (* real32/float *) then
           fconst_0 -> jcf.emit
        else
          aconst_null -> jcf.emit;
       if);
       putfield -> jcf.emit;
       (if currentTag = '[' then '[' -> currenttype.prepend if);       
       (thisClassName[], currentFieldName[], currentType[]) -> jcf.emitFieldRef; 
   if)     
#)

-- emitJasmin: DoPart --
do (# commentstream: @stream (* maybe something more useful *);
      
      thisClassName                (* name of current class           *)
      ,thisOrgName                 (* name of current origin class    *)
      ,thisSuperName               (* name of current super           *)
      ,thisSuperOrgName            (* nameof origin of current super  *)
      ,thisSignature               (* signature of current method     *)
      ,thisInnerMethodName: ^text; (* name of a possible inner method;
                                    * or the name of method 'main'
                                    *)
      thisBlockLevel,
      subLevel: @integer; (* current subpattern level *)
      class: ^text;       (* name of class being called - 
                           * used by subsequent init - ugly
                           *)
      isMainMethod: @boolean; (* true if generating code for main method *)
      
      betafile: @file(# pc: @positionConverter #);
      betafilename: ^text;
      line, column: @integer;
      
      init:
        (# BCmch: ^ByteCodeMachine;
        do (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename[];
           '.bet' -> betafilename.append;
           (if generateDebugInfo then
               betafilename[] -> jcf.SourceFile;
               betafilename[] -> betafile.name;
               betafile.openRead;
               betafile.pc.update;
               betafile.close;
           if);
        #);
      emitImports:
        (#
        do (if false then
               '\nImportJava:'->putline;
               jcf.cf.name -> putline;
               imports.scan
               (#
               do 'import: ' -> commentstream.puttext;
                  current[] -> commentstream.putText; 
                  commentstream.newline;
               #);
           if)
        #);
      emitMemOp:
        (# op, op0: @integer; varNo: @integer;
        enter(op, op0, varNo)
        do (if varNo > 0 then
               (* currently we assume that local variables have
                * addresses: 0,12,16,20,... that are 
                * mapped to: 0, 1, 2, 3,...
                * address 0 represents this
                *)
               (varNo div 4) - 2 -> varNo;
           if);
           
           (if generateDebugInfo then
               varNo -> jcf.emitLocalVariableUse;
           if);
           
           (if varNo <= 3 then 
               op0 + varNo -> jcf.emit;
            else
               op -> jcf.emit;
               varNo -> jcf.emit;
           if);
           
        #);
      dumpReg:
        (# 
        do 'assume register on stack: regno=' -> commentstream.puttext;
           BC.get -> commentstream.putint           
        #);
      getReg: (#  exit BC.get #);
      Address:
        (#
           reg,off,size,isField,ONlevel: @integer; 
           fieldName,descName,fieldType: ^text;
           get: 
             (# hasFieldName: @integer
             do getReg->reg; 
                (if (BC.get -> hasFieldName) = 1 then
                    BC.gettext -> fieldName[]
                if);
                
                BC.get->off; BC.get->size; 
                BC.get->ONlevel; 
                (if ONlevel > 0 then
                    (failureTrace,'ONlevel>0') -> stop 
                if);
                BC.get -> isField; 
                (if isField = 1 then
                    BC.getText -> descName[]
                 else
                    none -> descName[]
                if);
                (if BC.get = 1 then
                    BC.getText -> fieldType[]
                 else
                    none -> fieldType[]
                if);
                (if false (*isMainMethod*) then 
                    (* to prevent variables in main to be
                     * interpreted as fields in the object;
                     * main has no this, so main varaibles must
                     * be local variables in main; this is perhaps
                     * only a problem when not using switch 186
                     *)
                    0 -> isField 
                if)
             #);
           emitFieldAndType:
             (# isOrigin: @boolean;
                ClassName, TheFieldName, TheFieldType: ^text;
             enter isOrigin
             do INNER;
                (if isField = 1 then
                    descName[] -> ClassName[];
                 else 
                    (* this part should be eliminated *)
                    ONlevel -> BCstate.blocks.class -> ClassName[];
                if);
                (if isOrigin then
                    'origin' -> TheFieldName[]
                 else
                    fieldName[] -> TheFieldName[]
                if);
                (if TheFieldType[]=NONE (* May have been set in INNER *) then
                    (if fieldType[] <> none then
                        (if (fieldType.length <= 2) or
                            ((fieldType.length -> fieldType.inxGet) = ';') then
                            fieldType.copy -> TheFieldType[];
                            (if isField=2 then '[' -> TheFieldType.prepend; if);
                         else
                            (* we do come here, but we should perhaps fix this *)
                            (if fieldtype[] = none then
                                (failureTrace,'makeSig-1') -> stop;
                            if);
                            fieldType[] -> makeSignature -> TheFieldType[];
                        if)
                     else
                        'I' -> TheFieldType[];
                        'OBS! missing type info (fieldType)' -> fixme;
                    if);
                if);
                (ClassName[], TheFieldName[], TheFieldType[]) -> jcf.emitFieldRef; 
             #);
           load:
             (#
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            iaload -> jcf.emit;
                         // 'C' -> fieldType.equal then
                            caload -> jcf.emit;
                         // 'Z' -> fieldType.equal 
                         // 'B' -> fieldType.equal then
                            baload -> jcf.emit;                            
                         else
                            iaload -> jcf.emit;
                            'wrong fieldType'  -> commentstream.puttext;
                        if)
                     else
                        iaload -> jcf.emit;
                        'missing fieldType'  -> commentstream.puttext;
                   if)
                 else
                    (if ONlevel > 0 then
                        getfield  -> jcf.emit;
                        emitFieldAndType;
                     else
                        (if isField=1 then
                            getfield  -> jcf.emit;
                            emitFieldAndType;
                         else
                            (* method field *)
                            (if fieldType[] <> none then
                               (if true
                                // 'I' -> fieldType.equal 
                                // 'C' -> fieldType.equal then
                                   (iload, iload_0, off) -> emitMemOp
                                // 'D' -> fieldType.equal (* double/real *)then
                                   (dload, dload_0, off) -> emitMemOp
                                else 
                                   (iload, iload_0, off) -> emitMemOp
                               if)
                             else
                                (iload, iload_0, off) -> emitMemOp
                            if)
                        if)
                if)if)
             #);
           store:
             (# 
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            iastore -> jcf.emit;
                         // 'C' -> fieldType.equal then
                            castore -> jcf.emit;
                         else
                            iastore -> jcf.emit;
                            'unknown fieldType'  -> commentstream.puttext;
                        if)
                     else
                        iastore -> jcf.emit;
                        'missing fieldType'  -> commentstream.puttext;
                    if)
                 else
                    (if ONlevel > 0 then
                        putfield  -> jcf.emit;
                        emitFieldAndType;
                     else
                        (if isField=1 then
                            putfield  -> jcf.emit;
                            emitFieldAndType;
                         else
                            (* FIXME: datpete: I think stuf is missing here for other types than int. See Load above *)
                            (istore, istore_0, off) -> emitMemOp
                        if)
                if)if)
             #);
           storeRef:
             (# withQua,isOrigin: @boolean; class: ^text
             enter(withQua,isOrigin)
             do BC.gettext -> class[];
                (if withQua then
                    checkcast  -> jcf.emit;
                    (* remove enclosing 'L...;' *)
                    (2,class.length-1) -> class.sub -> jcf.emitClassRef;
                if);
                (if ONlevel > 0 then
                    putfield  -> jcf.emit; 
                    isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
                 else 
                    (if isField = 1 then
                        putfield  -> jcf.emit; 
                        isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
                     else
                        (if isField = 2 then
                            aastore -> jcf.emit;
                         else                       
                            (astore, astore_0, off) -> emitMemOp
                    if)if)
                if);
             #);
           loadRef:
             (# withQua: @boolean; sig: ^text
             enter withQua
             do BC.gettext -> sig[];
                (if ONlevel > 0 then
                    getfield  -> jcf.emit;
                    emitFieldAndType(# do sig.copy -> TheFieldType[] #);
                 else 
                     (if isField = 1 then
                         getfield  -> jcf.emit; 
                         emitFieldAndType(# do sig.copy -> TheFieldType[] #);
                      else
                         (if isField = 2 then
                             aaload -> jcf.emit;
                          else 
                             (aload, aload_0, off) -> emitMemOp
                     if)if)
                if); 
                (if withQua then
                    (*sig[] -> puttext;*)
                    checkcast  -> jcf.emit;
                    BC.gettext -> sig[]; 
                    (* remove enclosing 'L...;' *)
                    (2,sig.length-1) -> sig.sub -> jcf.emitClassRef;
                if);
             #);
           pushAdr:
             (#
             do (if off = 0 then
                    (if reg
                     // thisO then
                        aload_0 -> jcf.emit;
                     else
                        'Warning: pushAdr:register not this'->fixme
                    if)
                 else
                    'Warning: pushAdr:registeroff <>0\n\t' -> fixme;
                    load;
                if)
             #);
           dump:
             (# 
             do
                (if size = 0 then 4->commentstream.putint else size->commentstream.putint if);
                '.'->commentstream.put;
                (if reg
                 // thisO then  
                 // callO then 
                    '%call.'->commentstream.puttext
                 else
                    '%top.'->commentstream.puttext
                if);
                off->commentstream.putint
             #);
           display:
              (# 
              do ' reg:'-> puttext; reg -> putint;
                 ' off:'-> puttext; off-> putint;
                 ' size:'->puttext; size -> putint; 
                 ' ONlevel:'->puttext; ONlevel -> putint;
                 ' isField:'->puttext; isField -> putint;
                 (if isField = 1 then
                     descName[] -> puttext
                 if)
             #);
        #);
      makeSignature:
        (# sig: ^text
        enter sig[]
        do (if (1->sig.inxGet) = '[' then
               (* this should really be handled at a higher level *)
            else
               'L' -> sig.prepend; ';' -> sig.append;
           if)
        exit sig[]
        #);
      emitNewArray:
        (# type: @integer
        enter type
        do (* java arrays are 0:range-1;
            * we add one to BETA range; 
            * this gives an extra index 0
            * which will not give rise to index errors
            * must be fixed in some way
            *)
           newarray  -> jcf.emit; 
           type -> jcf.emit;
        #);
      emitAnewArray:
        (# type: ^text
        enter type[]
        do (* java arrays are 0:range-1;
            * we add one to BETA range; 
            * this gives an extra index 0
            * which will not give rise to index errors
            * must be fixed in some way
            *)
           anewarray  -> jcf.emit;
           type[] -> jcf.emitClassRef;
        #);
      emitCmpJmp:
        (# cond,L,lab,isRef: @integer; (* isRef=1: reference comparison;
                                        * should only happen for = and <>
                                        *)
        enter(cond,L,lab,isRef)
        do (if cond
            // 1 (* =  *) then
               (if isRef = 1 then
                   if_acmpeq -> jcf.emit
                else
                   if_icmpeq -> jcf.emit
               if)
            // 2 (* <> *) then
               (if isRef = 1 then
                   if_acmpne -> jcf.emit
                else
                   if_icmpne -> jcf.emit
               if)
            // 3 (* <  *) then
               if_icmplt -> jcf.emit;
            // 4 (* <= *) then
               if_icmple -> jcf.emit;
            // 5 (* >  *) then
               if_icmpgt -> jcf.emit;
            // 6 (* >= *) then
               if_icmpge -> jcf.emit;
           if);
           lab -> jcf.labs.off -> jcf.emitShort;
        #);
      emitCmpBoolJmp:
        (# cond,L,lab: @integer
        enter(cond,L,lab)
        do (if cond
            // 1 (* =  *) then
               ifeq -> jcf.emit;
            // 2 (* <> *) then
               ifne -> jcf.emit;
            // 3 (* <  *) then
               iflt -> jcf.emit;
            // 4 (* <= *) then
               ifle -> jcf.emit;
            // 5 (* >  *) then
               ifgt -> jcf.emit;
            // 6 (* >= *) then
               ifge -> jcf.emit;
           if);
           lab -> jcf.labs.off -> jcf.emitShort;
        #);
      opCode,arg1: @integer; 
      A: @Address;
      lastLocalType, (* used by allocAndStoreLocal;
                      * and just for testing .NET stuff
                      *)
      T: ^text;
      index, index2: @integer;
      theL: @char
   do init;
      emitImports;
      read:
        (if opCode <> end then
            BC.get->opCode; 
            (*newline; opCode -> putint; ' '->put;*)
            (* opCode:'->puttext; opCode -> putint; ' ' -> put;*)
            (if opCode
             // classDef then
                false -> isMainMethod;
                BC.gettext
                  -> thisClassName[]
                  -> jcf.constant_pool.classes.addtext
                  -> jcf.thisClassIndex;
                BC.get -> thisBlockLevel;
                (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
                BC.getText 
                  -> thisSuperName[] 
                  -> jcf.constant_pool.classes.addtext 
                  -> jcf.superClassIndex;
                
                'java/lang/Object'->thisSuperOrgName[];
                BC.get -> subLevel; 
                BC.gettext -> thisOrgName[];
                (if not ('-'->thisOrgName.equal) then
                    ('origin', thisOrgName[]) -> jcf.emitFieldDef;
                if);
                
                313->ctrace(# do '%%%class: "'->xT;
                              thisClassName[] -> xT;
                              '" blocklevel: ' -> xT;
                              thisBlockLevel -> xI; xN;
                              'super: "'->xT;
                              thisSuperName[] -> xT; 
                              '" sublevel: ' -> xT;
                              subLevel -> xI
                           #);
                
                BCstate.fields.init
                
             // endClass then 
   
             // methodDef then
                (# aux,noOfEnterArgs: @integer; (* 0 or 1 *)
                   methodname: ^text;
                   isStatic: @boolean;
                   access: @integer;
                   argn: ^text;
                do jcf.labs.clear;
                   BC.gettext -> thisInnerMethodName[];  
                   BC.gettext -> thisSignature[];
                   0                       -> BCstate.fields.numLocals;
                   BC.get -> noOfEnterArgs -> BCstate.fields.numArguments;
                   BC.get -> aux;
                   (if false then
                       '\nMethodDef: ' -> puttext;
                       thisSignature[] -> putline;
                       ' noOfArgs: ' -> puttext;
                       noOfEnterArgs -> putint;
                       ' Signature:'->puttext;
                       ' InnerName;' -> puttext;
                       thisInnerMethodName[] -> puttext;
                   if);
                   
                   (if 'main' -> thisInnerMethodName.equal then
                       (ACC_PUBLIC %Bor ACC_STATIC, 'main', '([Ljava/lang/String;)V', 8, 8)
                         -> jcf.currentmethod.new;
                       (if generateDebugInfo then
                           (0, 65535, 'args', 'Ljava/lang/String;') 
                             -> jcf.emitlocalVariableDefinition;
                       if);
                       true -> isMainMethod
                    else
                       false -> isMainMethod;
                       (if aux = 0 then
                           (* newline;
                            * thismethodname[] -> puttext;
                            * ' has inner'->putline;
                            *)
                           (0 (*%Bor ACC_PUBLIC*), thisInnerMethodName[], '()V', 1, 1)
                             -> jcf.currentmethod.new;
                           (if generateDebugInfo then
                               (if thisClassName[] = none then
                                (failureTrace,'makeSig-2') -> stop;
                            if);

                               (0, 65535, 'this', thisClassName.copy->makeSignature) 
                                 -> jcf.emitLocalVariableDefinition;
                           if);
                           _return -> jcf.emit;
                       if);
                       thisSignature[] 
                         -> splitSignature 
                         -> (methodname[], thisSignature[], isStatic);
                       (if isStatic then
                           (*ACC_PUBLIC %Bor*) ACC_STATIC -> access;
                        else
                           ACC_PUBLIC -> access;
                       if);
                       (access, methodname[], thisSignature[], 100, 100)
                         -> jcf.currentmethod.new;
                       (if generateDebugInfo and (not isStatic) then
                           (0, 65535, 'this', thisClassName.copy->makeSignature) 
                             -> jcf.emitLocalVariableDefinition;
                       if);
                   if);    
                   (if true then
                       (* enter parameters are declared as variables too.
                        * Thus no need for this!
                        * Well yes - apparently sometimes!!!!! FIXME!???
                        * Example: program.program() has a parameter of
                        * class tstenv, but does NOT call fields.new with tag 'm'
                        *)
                       (if generateDebugInfo then
                           (for i:noOfEnterArgs repeat
	                        'arg' -> argn[];
	                        i-1 -> argn.putint; (* FIXME: argument name *)
	                        (0, 65535, argn[], 'I' (* FIXME: argument type *))
	                          -> jcf.emitlocalvariabledefinition;
                           for);
                       if);
                   if);
                #);
             // initCons then
                (# sig: ^text
                do BC.gettext -> sig[]; 
                   (if ('-' -> thisOrgName.equal) then
                       (ACC_PUBLIC, '<init>', '()V', 8, 3) 
                         -> jcf.currentmethod.new;
                    else
                       (if true then
                           (ACC_PUBLIC, '<init>', sig[], 8, 30)
                             -> jcf.currentmethod.new;
                        else
                           (ACC_PUBLIC, '<init>'
                           , '('->(')V'->(thisOrgName.copy).append).prepend
                           , 8, 3)
                             -> jcf.currentmethod.new;
                       if)
                   if);
                   (if generateDebugInfo then
                       (0, 65535, 'this', thisClassName.copy->makeSignature) 
                         -> jcf.emitLocalVariableDefinition;
                       (65535, 0, 'origin', 'Ljava/lang/Object;' 
                       (* FIXME: argument type *))
                         -> jcf.emitlocalvariabledefinition;
                if)#)
             // field then
                (# F: @text
                do 'F' -> F; BC.get->F.putInt; (* datpete: Fnn field???? *)
                   (if BC.get = 1 then
                       (F[],BC.gettext,BC.gettext,BC.get) 
                         -> BCstate.fields.new
                    else
                       (F[],'???',BC.gettext,BC.get) 
                         -> BCstate.fields.new
                   if)
                #)
             // labelDef then
                BC.getShort->jcf.labs.def; 
             // callPrim then
                (# prim,arg: ^text;
                   index: @integer;
                   sig: ^text;
                do BC.gettext -> prim[];
                   BC.getText -> arg[];
                   (if true 
                    // 'new' -> prim.equal then
                       new -> jcf.emit;
                       (* class name*)
                       arg[] -> jcf.emitClassRef;
                       _dup -> jcf.emit;
                       arg[] -> class[]; (* ugly *)                       
                    // 'initSuper' -> prim.equal then                       
                       '(' -> sig[];
                       (if not ('-'->arg.equal) then
                           (if arg[] = none then
                                (failureTrace,'makeSig-3') -> stop;
                            if);

                           arg[] -> makeSignature -> sig.append;
                       if);
                       ')V' -> sig.append;
                       invokespecial -> jcf.emit;
                       (thisSuperName[], '<init>', sig[]) -> jcf.emitMethodRef; 
                       BCstate.fields.emitInit;
                    // 'init' -> prim.equal  then
                       (if true then
                           invokespecial -> jcf.emit;
                           (class[], '<init>', arg[]) -> jcf.emitMethodRef;
                        else
                           '(' -> sig[];
                           (if not ('-'->arg.equal) then
                               (if arg[] = none then
                                   (failureTrace,'makeSig-4') -> stop;
                               if);
                               
                               arg[] -> makeSignature -> sig.append;
                           if);
                           ')V' -> sig.append;
                           invokespecial -> jcf.emit;
                           (class[], '<init>', sig[]) -> jcf.emitMethodRef; 
                       if)
                    // 'AlloVR4' -> prim.equal then
                       T_INT -> emitNewArray
                    // 'AlloVR2' -> prim.equal then
                       T_SHORT -> emitNewArray  
                    // 'AlloVR1' -> prim.equal then
                       T_CHAR -> emitNewArray  
                    // 'AlloVR1bool' -> prim.equal then
                       T_BOOLEAN -> emitNewArray  
                    // 'AlloVR8' -> prim.equal then
                       T_DOUBLE-> emitNewArray  
                    // 'AlloRR' -> prim.equal then
                       (* arg = '[Ltype;' 
                        * extract: 'type'
                        *)
                       (3,arg.length-1) -> arg.sub -> arg[];
                       arg[] -> emitAnewArray;
                    // 'Text2CharArray' -> prim.equal then
                       invokevirtual -> jcf.emit;
                       ('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
                    // 'CharArray2String' -> prim.equal then
                       new -> jcf.emit;
                       'java/lang/String' -> jcf.emitClassRef;
                       dup_x1 -> jcf.emit;
                       swap -> jcf.emit;
                       invokespecial -> jcf.emit;
                       ('java/lang/String', '<init>', '([C)V') -> jcf.emitMethodRef;
                    // 'ExternalString2BetaText' -> prim.equal then
                       (* Note! Hardcoding of pattern 'text'
                        * including case, etc. Should be handled
                        * more generally
                        *)
                       invokevirtual -> jcf.emit;
                       ('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
                       new -> jcf.emit;
                       'text' -> jcf.emitClassRef;
                       dup_x1 -> jcf.emit;
                       dup_x1 -> jcf.emit;
                       aconst_null -> jcf.emit;
                       invokespecial -> jcf.emit; 
                       ('text', '<init>', '(Ltstenv;)V') -> jcf.emitMethodRef;  
                       invokevirtual -> jcf.emit; 
                       ('text', 'enter', '([C)V') -> jcf.emitMethodRef; 
                    // 'BetaText2ExternalString' -> prim.equal then
                       getfield  -> jcf.emit; 
                       ('text','T', '[C') -> jcf.emitFieldRef; 
                       new -> jcf.emit;
                       'java/lang/String' -> jcf.emitClassRef;
                       dup_x1 -> jcf.emit;
                       swap -> jcf.emit;
                       invokespecial -> jcf.emit;
                       ('java/lang/String', '<init>', '([C)V') 
                         -> jcf.emitMethodRef;
                    // 'BetaText2BetaCharArray' -> prim.equal then
                       getfield  -> jcf.emit; 
                       ('text','T', '[C') -> jcf.emitFieldRef; 
                       
                    // 'Att' -> prim.equal then
                       (* missing call of attach here
                        * we pop the stack to avoid overflow
                        *)
                       _pop -> jcf.emit;
                    else
                       'Primitive: '->commentstream.puttext; 
                       prim[] -> commentstream.puttext; 
                       ' ' ->commentstream.put;
                       arg[] -> commentstream.puttext;
                   if);
                #)
             // callExternal then
                (# prim, n, d, m: ^text; s: @boolean;
                do BC.getText -> prim[];
                   prim[] ->splitClassSignature->(n[], d[], s, m[]);
                   (if true 
                    // ('java/io/PrintStream'-> ((1,19)->prim.sub).equal) then
                       (* FIXME: hardcoded 
                        * Assuming that operation is on the static instance of 
                        * PrintStream in java.lang.System.out.
                        * We must load this first.
                        *)
                       getstatic -> jcf.emit;
                       ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                       swap -> jcf.emit;
                       invokevirtual -> jcf.emit; 
                       (m[], n[], d[]) -> jcf.emitMethodRef;
                    // ('java/io/InputStream'-> ((1,19)->prim.sub).equal) then
                       (* FIXME: hardcoded 
                        * Assuming that operation is on the static instance of 
                        * InputStream in java.lang.System.in.
                        * We must load this first.
                        *)
                       getstatic -> jcf.emit;
                       ('java/lang/System', 'in', 'Ljava/io/InputStream;')->jcf.emitFieldRef;
                      (* swap -> jcf.emit;*)
                       invokevirtual -> jcf.emit; 
                       (m[], n[], d[]) -> jcf.emitMethodRef;
                    else
                       'callExternal' -> FIXME;
                       invokevirtual -> jcf.emit;
                       (m[], n[], d[]) -> jcf.emitMethodRef; 
                   if);
                #)
             // callInner then
                aload_0 -> jcf.emit;
                invokevirtual -> jcf.emit;
                (* NOT in accordance with design - FIX *)
                (if false then
                    '_do_'-> thisInnerMethodName.append;
                    subLevel+1 -> thisInnerMethodName.putint;
                if);
                (thisClassName[], thisInnerMethodName[], '()V') 
                  -> jcf.emitMethodRef; 
             // comment then
                (# T: ^text
                do BC.gettext -> T[];
                   (if common.switch[319]
                       and 
                       ((T.length > 0) and ((1 -> T.inxget) <> '!') 
                       or common.switch[185])  then
                       T[] -> jcf.emitComment;
                    else
                       restart read (* skip newline *)
                   if)
                #)
             // position then
                BC.getShort -> line;
                (if generateDebugInfo then
                    line -> betafile.pc.posToLineCol -> (line, column);
                    line -> jcf.emitLinenumber;
                if);
             // pushVal then 
                A.get; 
                (*'\nload: '->puttext; A.display;*)
                A.load; 
             // stVal then
                A.get; 
                (*'\nload: '->puttext; A.display;*)
                A.store
             // loadRef then
                A.get; A.loadRef
             // loadQRef then
                A.get; true->A.loadRef
             // pushAdr then
                A.get; A.pushAdr
             // storeRef then
                A.get; A.storeRef
             // storeQref then 
                A.get; (true,false) -> A.storeRef
             // storeOrigin then
                A.get; (false,true) -> A.storeRef
             // loadOrigin then
                (# ONlevel,ctag,ftag: @integer; 
                   className,fieldType: ^text;
                   TheClassName, TheFieldName, TheFieldType: ^text;
                do BC.get -> ONlevel;
                   (*ONlevel -> putint; ' ' ->put;*)
                   BC.get -> ctag; 
                   (*ctag -> putint; ' ' ->put;*)
                   (if ctag = 1 then
                       BC.getText -> className[];
                       'loadOrigin:tag=1: '->commentstream.puttext;
                       className[] -> commentstream.puttext;
                       commentstream.newline;
                   if);
                   BC.get -> ftag;
                   (*ftag -> putint; ' ' ->put;*)
                   (if ftag = 1 then
                       BC.gettext -> fieldType[];
                       (*fieldType[] -> puttext; ' '->put*)
                   if);
                   (if isMainMethod then
                       (* reconsider for main/program-slot;
                        * in Java:main, we cannot access class fields;
                        * but we may do in BETA
                        *)
                       aconst_null -> jcf.emit;
                    else
                       (if ONlevel = 0 then
                           aload_0 -> jcf.emit;
                        else
                           getfield  -> jcf.emit;
                           (if ctag = 0 then
                               ONlevel 
                                 -> BCstate.blocks.class 
                                 -> TheClassName[];
                            else
                               className[] -> TheClassName[]
                           if);
                           'origin' -> TheFieldName[];
                           (if ftag = 0 then
                               '\nOBS shouldnot come here'->putline;
                               ONlevel 
                                 -> BCstate.blocks.orgClass
                                 -> makeSignature
                                 -> TheFieldType[];
                            else
                               (if fieldtype[] = none then
                                   '\nftag:'->puttext; ftag->putint; newline;
                                   (failureTrace,'makeSig-5') -> stop;
                               if);
                               
                               fieldType[] 
                                 -> makeSignature
                                 -> TheFieldType[];
                           if);
                           (TheClassName[], TheFieldName[], TheFieldType[])
                             -> jcf.emitFieldRef;
                       if);
                   if)
                #)
             // cast then
                (# sig: ^text
                do checkcast  -> jcf.emit;
                   BC.gettext -> sig[]; 
                   (* remove enclosing 'L...;' *)
                   (2,sig.length-1) -> sig.sub -> jcf.emitClassRef;
                #)
             // call then 
                (if BC.get = 1 then
                    invokestatic  -> jcf.emit;
                 else
                    invokevirtual -> jcf.emit;
                if);
                (# n, d, m: ^text; s: @boolean;
                do BC.getText->T[]->splitClassSignature->(n[], d[], s, m[]);
                   (m[], n[], d[]) -> jcf.emitMethodRef; 
                #);
                313->trace(#do '%%%call: '->xT; T[]->xT #)
             // return then
                (if BC.get 
                 // 0 then _return -> jcf.emit;
                 // 1 // 2 // 3 // 4 // 5 then ireturn -> jcf.emit;
                 // 6 (* real *) then dreturn -> jcf.emit;
                 // 11 // 12 // 13 then areturn -> jcf.emit;
                 else 
                    'xreturn' -> fixme;
                if);
             // beginLab then
                (# restartLabno: @integer;
                   leaveLabno: @integer;
                   try_pc: @integer;
                do BC.getLong -> restartlabno;
                   BC.getLong -> leavelabno;
                #);
             // endLab then
                (# restartLabno: @integer;
                   leaveLabno: @integer;
                   handler_pc: @integer;
                   restart_pc: @integer;
                do BC.getLong -> restartlabno;
                   BC.getLong -> leavelabno;
                   (* End try clause by jumping over handler *)
                   goto -> jcf.emit;
                   leavelabno -> jcf.labs.off -> jcf.emitShort;
                   (* Start handler.
                    * Test (e.exitobj == this) && (e.labno==restartlabno)
                    *)
                   jcf.currentmethod.LIP -> handler_pc;
                   (* FIXME: Using local variable 1 hardcoded *)
                   astore_1  -> jcf.emit; 
                   aload_1   -> jcf.emit; 
                   getfield  -> jcf.emit; ('ExOException', 'exitobj', 'Ljava/lang/Object;') -> jcf.emitfieldref;
                   aload_0   -> jcf.emit; 
                   if_acmpne -> jcf.emit; (leavelabno -> jcf.labs.off)-2 -> jcf.emitShort; (* RethrowLab *)

                   aload_1   -> jcf.emit; 
                   getfield  -> jcf.emit; ('ExOException', 'labno', 'I') -> jcf.emitfieldref;
                   ldc       -> jcf.emit; restartlabno -> jcf.emitIntegerConstant;
                   if_icmpne -> jcf.emit; (leavelabno -> jcf.labs.off)-2 -> jcf.emitShort; (* RethrowLab *)
                   (* We have a leave/restart of L1 in this Object. Test whether it is leave or restart *)
                   aload_1   -> jcf.emit; 
                   getfield  -> jcf.emit; ('ExOException', 'restart', 'Z') -> jcf.emitfieldref;
                   ifeq      -> jcf.emit; (leavelabno -> jcf.labs.off) -> jcf.emitShort; (* LeaveLab *)
                   (* Restart *)
                   goto      -> jcf.emit; (restartlabno -> jcf.labs.off) -> jcf.emitShort; (* RestartLab *)
                   (* RethrowLab: *)
                   (* Not the right label in this Object - propagate further *)
                   aload_1-> jcf.emit; 
                   athrow-> jcf.emit; 
                   (* LeaveLab: *)
                   (* Set up try-catch info *)
                   RestartLabNo -> jcf.labs.off -> restart_pc;
                   (if restart_pc=0 then
                       'endLab: error: Restartlabel not yet defined?' -> fixme;
                   if);
                   (if false then
                       'endlab: L' -> screen.puttext;
                       restartlabno->screen.putint;
                       ': restart offset: ' -> screen.puttext;
                       restart_pc -> screen.putint;
                       ' at PC ' -> screen.puttext;
                       jcf.currentmethod.LIP -> screen.putint;
                       screen.newline;
                   if);
                   (jcf.currentmethod.LIP + restart_pc - 1) -> restart_pc;
                   (restart_pc (*start_pc*), handler_pc (*end_pc*), handler_pc (*handler_pc*), 'ExOException') 
                     -> jcf.emitExceptionHandlerDef;
                #);
             // break then
                (# labno: @integer;
                   re_start: @integer;
                do BC.getLong -> labno;
                   BC.get -> re_start;
                   (* exitObj already pushed *)
                   new           -> jcf.emit; 'ExOException' -> jcf.emitClassRef;
                   (* stack: ExOException; exitObj *)
                   dup_x1        -> jcf.emit;
                   (* stack: ExOException; exitObj, ExOException *)
                   swap          -> jcf.emit;
                   (* stack: exitObj, ExOException; ExOException *)
                   ldc           -> jcf.emit;
                   labno         -> jcf.emitIntegerConstant; (* potentially 32 bit constant *)
                   (* stack: labno, exitObj, ExOException; ExOException *)
                   bipush        -> jcf.emit; 
                   re_start      -> jcf.emit; (* 8 bit constant *)
                   (* stack: restart, labno, exitObj, ExOException; ExOException *)
                   invokespecial -> jcf.emit; ('ExOException', '<init>', '(Ljava/lang/Object;IZ)V') -> jcf.emitMethodRef;
                   athrow        -> jcf.emit;
                 #)
             // cmpToBool then
                'cmpToBool' -> commentstream.puttext;
                (* 0:      if_xxx L1
                 * 3:      bipush 0
                 * 5:      goto L2
                 * 8:  L1: bipush 1
                 * 10: L2:
                 *)
                (if BC.get
                 // 1 (* =  *) then
                    if_icmpeq -> jcf.emit;
                 // 2 (* <> *) then
                    if_icmpne -> jcf.emit;
                 // 3 (* <  *) then
                    if_icmplt -> jcf.emit;
                 // 4 (* <= *) then
                    if_icmple -> jcf.emit;
                 // 5 (* >  *) then
                    if_icmpgt -> jcf.emit;
                 // 6 (* >= *) then
                    if_icmpge -> jcf.emit;
                if);
                8-0 -> jcf.emitShort; (* L1 *)
                bipush -> jcf.emit; 0 -> jcf.emit;
                goto -> jcf.emit;
                10-5 -> jcf.emitShort; (* L2 *)
                bipush -> jcf.emit; 1 -> jcf.emit;
             // cmpToBoolRef then
                'cmpToBoolRef' -> commentstream.puttext;
                (* 0:      if_xxx L1
                 * 3:      bipush 0 or 1
                 * 5:      goto L2
                 * 8:  L1: bipush 1 or 1
                 * 10: L2:
                 *)
                (# cond: @integer
                do BC.get -> cond; 
                   (if cond = 1 (* =  *) then
                       if_acmpeq -> jcf.emit;
                    else (* cond = 2  <> *) 
                       if_acmpne -> jcf.emit
                   if);
                   8-0 -> jcf.emitShort; (* L1 *)
                   bipush -> jcf.emit; 
                   (if cond = 1 (* = *) then 
                       0 -> jcf.emit
                    else
                       1 -> jcf.emit
                   if);
                   goto -> jcf.emit;
                   10-5 -> jcf.emitShort; (* L2 *)
                   bipush -> jcf.emit; 
                   (if cond = 1 then 
                       1 -> jcf.emit;
                    else
                       0 -> jcf.emit;
                if)#)
             // cmpAndJmp then
                'cmpAndJmp' -> commentstream.puttext;
                (BC.get,BC.get,BC.getShort,BC.get) -> emitCmpJmp 
             // cmpBoolAndJmp then
                'cmpBoolAndJmp' -> commentstream.puttext;
                (BC.get,BC.get,BC.getShort) -> emitCmpBoolJmp
             // cmp then
                cmp -> jcf.emit;
             // pushReg then
                dumpReg
             // pushNone then
                aconst_null -> jcf.emit;
             // dup then
                BC.get -> arg1;
                (if arg1
                 // 0 then _dup -> jcf.emit;
                 // 1 then dup_x1 -> jcf.emit;
                 // 2 then dup_x2 -> jcf.emit;
                if);
             // pop then
                _pop -> jcf.emit;
             // allocAndStoreLocal then
                BC.getText -> lastLocalType[];
                (if 'I' -> lastLocalType.equal then
                    (istore,istore_0,16) -> emitMemOp;
                 else
                    (astore,astore_0,16) -> emitMemOp;
                if)
             // loadLocal then
                (if 'I' -> lastLocalType.equal then
                    (iload,iload_0,16) -> emitMemOp;
                 else
                    (aload,aload_0,16) -> emitMemOp;
                if)
             // pushCst_s8 then
                bipush -> jcf.emit;
                BC.get -> jcf.emit; 
             // pushCst_s16 then
                sipush -> jcf.emit;
                BC.getShort -> jcf.emitShort  
             // pushCst_s32 then
                ldc  -> jcf.emit;
                BC.getLong -> jcf.emitIntegerConstant; 
             // pushRealCst then
                ldc2_w  -> jcf.emit;
                (BC.getLong, BC.getLong) -> jcf.emitDoubleConstant;
             // return then
                _return -> jcf.emit;
             // nop then
                _nop -> jcf.emit;
             // end then
                (if (thisClassName[]<>NONE) and ('BetaObject' -> thisClassName.equal) then
                    (* Just finished generating BetaObject (in betaenv). *)
                    GenerateClassExOException;
                if);
             // index then
                Unused1 -> jcf.emit; 'bytecode index' -> fixme;
             // newVirt then 
                Unused1 -> jcf.emit; 'bytecode newvirt' -> fixme;
             // return then
                _return -> jcf.emit;
             // endMethod then
                (* skip *)
             // label then
                Unused1 (*L*) -> jcf.emit; 'bytecode label' -> fixme;
                'LIP=' -> puttext;
                jcf.currentmethod.LIP -> putint; newline;
             // end then
                Unused1 (*L*) -> jcf.emit; 'bytecode end' -> fixme;
             // pushText then
                ldc -> jcf.emit;
                BC.getText -> jcf.emitString;
             // dup then 
                _dup -> jcf.emit;
             // pop  then 
                _pop -> jcf.emit;
             // loadRange then 
                arraylength -> jcf.emit;
             // jmp then
                (# labno: @integer
                do 
                   goto -> jcf.emit;
                   BC.get -> theL (* opcode label *); 
                   BC.getShort -> labno;
                   (if labno = 0 then
                       '\nOOPS opcode jmp: use of strange label L0'->putline;
                       1 -> labno;
                   if);
                   labno -> jcf.labs.off -> jcf.emitShort;
                #)
             // jmpt then (* arguments here is a text;
                           * so does the code below work? *)
                (# off: @integer 
                do goto -> jcf.emit;
                   BC.get (* opcode label *); 
                   BC.get -> off;
                   (if off = 0 then
                       '\nOBS! jmpt:off=0'->putline;
                       1 -> off
                   if);
                   off -> jcf.labs.off -> jcf.emitShort;
                #)
             // r64toR32 then
                d2f -> jcf.emit
             // r64add then
                dadd -> jcf.emit
             // func then
                (# func: @integer;
                do BC.get->func;
                   (if func
                    // add then
                       iadd -> jcf.emit;
                    // sub then
                       isub -> jcf.emit;
                    // nott then
                       (* 0:     ifne L1
                        * 3:     iconst_1
                        * 4:     goto L2
                        * 7: L1: iconst_0
                        * 8: L2:
                        *)
                       ifne -> jcf.emit;
                       7-0 -> jcf.emitShort;
                       iconst_1 -> jcf.emit;
                       goto -> jcf.emit;
                       8-4 -> jcf.emitShort;
                       iconst_0 -> jcf.emit;
                    // mult then
                       imul -> jcf.emit;
                    // divv then
                       idiv -> jcf.emit;
                    // modd then
                       irem -> jcf.emit;
                    // xorr then
                       ixor -> jcf.emit;
                    // logNot then
                       (* bit not *)
                       iconst_m1 -> jcf.emit;
                       ixor -> jcf.emit;
                    // neg then
                       ineg -> jcf.emit;
                    // orr then
                       ior -> jcf.emit;
                    // andd then
                       iand -> jcf.emit;
                    // logicalShiftLeft then
                       ishl -> jcf.emit;
                    // logicalShiftRight then
                       iushr -> jcf.emit;
                    // arithShiftLeft then   
                       ishl -> jcf.emit;
                    // arithShiftRight then
                       ishr -> jcf.emit;
                    // rotateLeft then
                       (* Perform i %rol r *)
                       (* Implemented as:
                        *   (i << r) | ((i & ((1<<r)-1) >> (32-r))
                        *)
                       (* initial stack: r, i *)
                       (if false then
                           swap     -> jcf.emit; (* stack: i, r *)
                           dup_x2   -> jcf.emit; (* stack: i, r, i *)
                           swap     -> jcf.emit; (* stack: r, i, i *)
                           dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
                        else
                           dup2     -> jcf.emit; (* stack: r, i, r, i *)
                       if);
                       dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
                       iconst_1 -> jcf.emit; 
                       swap     -> jcf.emit; 
                       (* stack: r, 1, i, r, r, i *)
                       ishl     -> jcf.emit; 
                       iconst_1 -> jcf.emit; 
                       isub     -> jcf.emit; 
                       (* stack: (1<<r)-1, i, r, r, i *)
                       iand     -> jcf.emit; 
                       (* stack: i&(1<<r)-1, r, r, i *)
                       swap     -> jcf.emit; 
                       bipush   -> jcf.emit; 32 -> jcf.emit;
                       swap     -> jcf.emit; 
                       isub     -> jcf.emit; 
                       ishr     -> jcf.emit; 
                       (* stack: (i&(1<<r)-1)>>(32-r), r, i*)
                       dup_x2   -> jcf.emit; 
                       _pop     -> jcf.emit; 
                       (* stack: r, i, (i&(1<<r)-1)>>(32-r) *)
                       ishl     -> jcf.emit; 
                       ior      -> jcf.emit; 
                       (* stack: (i<<r) | (i&(1<<r)-1)>>(32-r) *)
                    // rotateRight then
                       (* Perform i %ror r *)
                       (* Implemented as:
                        *   (i >> r) | ((i & ((1<<r)-1) << (32-r))
                        *)
                       (* initial stack: r, i *)
                       (if false then
                           swap     -> jcf.emit; (* stack: i, r *)
                           dup_x2   -> jcf.emit; (* stack: i, r, i *)
                           swap     -> jcf.emit; (* stack: r, i, i *)
                           dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
                        else
                           dup2     -> jcf.emit; (* stack: r, i, r, i *)
                       if);
                       dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
                       iconst_1 -> jcf.emit; 
                       swap     -> jcf.emit; 
                       (* stack: r, 1, i, r, r, i *)
                       ishl     -> jcf.emit; 
                       iconst_1 -> jcf.emit; 
                       isub     -> jcf.emit; 
                       (* stack: (1<<r)-1, i, r, r, i *)
                       iand     -> jcf.emit; 
                       (* stack: i&(1<<r)-1, r, r, i *)
                       swap     -> jcf.emit; 
                       bipush   -> jcf.emit; 32 -> jcf.emit;
                       swap     -> jcf.emit; 
                       isub     -> jcf.emit; 
                       ishl     -> jcf.emit; 
                       (* stack: (i&(1<<r)-1)<<(32-r), r, i*)
                       dup_x2   -> jcf.emit; 
                       _pop     -> jcf.emit; 
                       (* stack: r, i, (i&(1<<r)-1)<<(32-r) *)
                       ishr     -> jcf.emit; 
                       ior      -> jcf.emit; 
                       (* stack: (i>>r) | (i&(1<<r)-1)<<(32-r) *)
                    // byteswapShort then
                       (* Implemented as (short)((x>>8) | ((x<<8) & 0xff00)) *)
                       (* stack: x *)
                       _dup      -> jcf.emit;
                       (* stack: x, x *)
                       bipush    -> jcf.emit; 8 -> jcf.emit;
                       ishr      -> jcf.emit;
                       (* stack: (x>>8), x *)
                       swap      -> jcf.emit;
                       bipush    -> jcf.emit; 8 -> jcf.emit;
                       ishl      -> jcf.emit;
                       ldc       -> jcf.emit;
                       0xff00 -> jcf.emitIntegerConstant;
                       iand      -> jcf.emit;
                       (* stack: ((x<<8) & 0xff00)), (x>>8) *)
                       ior       -> jcf.emit;
                       i2s       -> jcf.emit;
                    // byteswapLong then
                       (* Implemented as
                        *   short h = (short)(x>>16);
	                *   short l = (short)(x & 0xffff);
	                *   short nl = (short)((h>>8) | ((h<<8) & 0xff00));
	                *   short nh = (short)((l>>8) | ((l<<8) & 0xff00));
	                *   int result = (nh << 16) | nl;
                        *)
                       (* stack: x *)
                       _dup    -> jcf.emit; 
                       _dup    -> jcf.emit; 
                       (* stack: x, x, x *)
                       ldc     -> jcf.emit; 0xffff -> jcf.emitIntegerConstant;
                       iand    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishr    -> jcf.emit;
                       (* stack: (l>>8), x, x *)
                       swap    -> jcf.emit; 
                       ldc     -> jcf.emit; 0xffff -> jcf.emitIntegerConstant;
                       iand    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishl    -> jcf.emit;
                       ldc     -> jcf.emit; 0xff00 -> jcf.emitIntegerConstant;
                       iand    -> jcf.emit;
                       ior     -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 16 -> jcf.emit;
                       ishl    -> jcf.emit;
                       (* stack: (nh<<16), x *)
                       swap    -> jcf.emit; 
                       _dup    -> jcf.emit;
                       (* stack: x, x, (nh<<16) *)
                       bipush  -> jcf.emit; 16 -> jcf.emit;
                       ishr    -> jcf.emit;
                       i2s     -> jcf.emit;
                       bipush  -> jcf.emit; 8 -> jcf.emit;
                       ishr    -> jcf.emit; 
                       (* stack: (h<<8), x, (nh<<16) *)
                       swap    -> jcf.emit; 
                       (* stack: x, (h<<8), (nh<<16) *)
                       bipush  -> jcf.emit; 16 -> jcf.emit; 
                       ishr    -> jcf.emit; 
                       i2s     -> jcf.emit; 
                       bipush  -> jcf.emit; 8 -> jcf.emit; 
                       ishl    -> jcf.emit; 
                       ldc     -> jcf.emit; 0xff00 -> jcf.emitIntegerConstant;
                       iand    -> jcf.emit; 
                       ior     -> jcf.emit; 
                       i2s     -> jcf.emit; 
                       ior     -> jcf.emit; 
                    else
                       'Unhandled bytecode func.' -> (func -> asText).prepend -> fixme;
                       'Unhandled bytecode func.' -> (func -> asText).prepend -> jcf.emitComment;
                   if)
                #);
             else
                'Unhandled bytecode ' -> (opcode -> asText).prepend -> fixme;
                'Unhandled bytecode ' -> (opcode -> asText).prepend -> jcf.emitComment;
            if);
            restart read
        if);
      jcf.EmitToFile;
   #)  
