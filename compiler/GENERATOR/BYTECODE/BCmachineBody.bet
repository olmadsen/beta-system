ORIGIN 'BCmachine';
BODY 'BCjavaBody';
BODY 'BCdotnetBody';
---BCstate:descriptor---
(# ObjectName:
     (# superName: ^text
     do (if true
         // common.targetMachineId = common.jvm then
            'java/lang/Object'->supername[];
         // common.targetMachineId = common.clr then
            'object'->supername[];
         else
            'Unknown_platform.Object' -> supername[];
        if);
     exit superName[]
     #);

   fields: @
     (# Field,FieldName: [5] ^text; Type: [5] ^text; Tag: [5] @char;
        top: @integer;
        init: (# do 0 -> top #);
        numLocals, numCells, numArguments: @integer;
        LocalVariables: [1]@integer;
        new:
          (# F,FN,T: ^text; methodClassTag: @char; 
          enter(F[],FN[],T[],methodClassTag)
          do (if (top+1->top) > Field.range then
                 Field.range -> Field.extend;
                 FieldName.range -> FieldName.extend;
                 Type.range -> Type.extend;
                 Tag.range -> Tag.extend
             if);
             F[] -> Field[top][];
             FN[] -> FieldName[top][];
             T[] -> Type[top][];
             methodClassTag -> Tag[top];
             (if true
              // common.targetMachineId = common.jvm then
                 <<SLOT FieldsNewJasmin:descriptor>>
              // common.targetMachineId = common.clr then
                 <<SLOT FieldsNewClr:descriptor>>
              else
                 'fields.init: unknown platform' -> screen.putline;
             if);
          #);
        scan:
          (# currentField,currentFieldName,currentType: ^text;
             currentTag: @char
          do (for i: top repeat
                  Field[i][] -> currentField[];
                  FieldName[i][] -> currentFieldName[];
                  Type[i][] -> currentType[];
                  Tag[i] -> currentTag;
                  INNER scan
             for)
          #);
        emitInit:
          (# 
          do scan
             (#
             do (if currentType.length>0 then
                    (if true
                     // common.targetMachineId = common.jvm then
                        <<SLOT FieldsEmitInitItemJasmin:descriptor>>
                     // common.targetMachineId = common.clr then
                        <<SLOT FieldsEmitInitItemClr:descriptor>>
                     else
                        'fields.emitInit: unknown platform' -> screen.putline;
                    if);
                if)
             #)
          #)
     #);
   thisClassName, thisModuleName: ^text;
   blocks: @
     (# D: [5] ^blockDescriptor;
        level: @integer; (* the class level of this block
                          * starting with 0 (zero) at the
                          * outermost level;  currently we only
                          * count class levels; methods in
                          * classes are not counted; for methods
                          * containing classes we should reconsider
                          * the counting of levels
                          *)
        blockDescriptor:
          (# name: ^text
          #);
        mark:
          (# L: @integer; N: ^text
          enter(L,N[])
          do N[] -> thisClassName[];
             (if true            (* check that the new class to be handled
                                  * is on one of the following levels: *)
              // L = level       (* the same level *)
              // L = (level + 1) (* a level down *)
              // L = (level - 1) (* a level up   *)then
              else
                 (if not common.switch[188] then
                     '\n%%%inconsistent block levels: ' -> puttext;
                     level -> putint; ' '->put; L -> putint;
                     newline
                 if)
             if);
             E: (if L > D.range then D.range -> D.extend; restart E if);
             (if (0 <= L) and (L < D.range) then
                 &blockDescriptor[] -> D[L+1][];
                 N[] -> D[L+1].name[];
              else
                 (if not common.switch[188] then
                     '\n%%%block level out of range: ' -> puttext;
                     L -> putint; ' range: '->putText; D.range -> putint;
                     newline
                 if)
             if);
             L -> level
          #);
        pop: (# do level - 1 -> level #);
        (* When accessing fields we need the className
         * and possibly the names of enclosing classes;
         *  level:   the level of the current class;
         *           counting from 0 (zero), 1, ... from the outermost level
         *  ONlevel: no of origin levels to access a field;
         *           0: variable in method in which case we do not come here
         *           1: field in this class
         *           2: field in enclosing class of this class
         *           3: ...
         * Invariant: (0 <= ONlevel) and (ONlevel <= (level+1))
         * D[level+1]              : this class
         * D[level - (ONlevel-1)+1]: class at ONlevel from method in this class
         *                           ONlevel=1 ===> this class
         * D[level - (ONlevel-1)]  : enclosing class at ONlevel
         *                           ONlevel=1 ===> origin of this class
         *)
        class:
          (# ONlevel: @integer; CN : ^text
          enter ONlevel
          do ONlevel->check
             (# inx: @integer
             do level-(ONlevel-1)+1 -> inx;
                (if (0 < inx) and (inx <= D.range) then
                    (if D[inx][] = none then
                        'NoneClass: ' -> putline
                     else
                        D[inx].name[] -> CN[];
                    if);
                 else
                    'UndefinedOuterClass' -> CN[];
                if)
             #);
             (if CN[] = none then 'unKnownClass' -> CN[] if);
          exit CN[]
          #);
        orgClass: 
          (# ONlevel: @integer; CN : ^text
          enter ONlevel
          do 313->trace(#
                       do 'orgClass: level:' -> xT; level -> xI; 
                          ' ONlevel:'->xT; ONlevel -> Xi
                       #);
             ONlevel->check
             (# inx: @integer
             do (if ONlevel > level then
                    ObjectName ->  CN[]
                 else
                    level-(ONlevel-1) -> inx;
                    (if (0 < inx) and (inx <=D.range) then
                        D[inx].name[] -> CN[] 
                     else
                        '\n%%%orgClass: range error:' -> puttext;
                        inx ->putint; newline
                    if)
                if)
             #);
             (if CN[] = none then 'unKnownOriginClass' -> CN[] if)
          exit CN[]
          #);
        check:
          (* *)
          (# ONlevel: @integer
          enter ONlevel
          do (if (0 <= ONlevel) and (ONlevel <= (level+1)) then
                 inner
              else
                 (if not common.switch[188] then
                     '\n%%%blocks:check: inconsistent level: ' -> puttext;
                     ONlevel -> putint; ' '->put; level -> putint;
                     newline
                 if)
             if);
          #)
     #);
     
   
#)


---byteCode_dump:doPart---
do (#          
      dumpReg:
        (# 
        do
           '%'->put;
           (if BC.get
            // thisO then 'this'->puttext // callO then 'call'->puttext
            else
               'top'->puttext
           if);
           
        #);
      dumpAdr:
        (# 
        do
           dumpReg; '('->put; BC.get->putint; ')s='->puttext; BC.get->putint
        #);
      opCode: @integer
   do
      read:
        (if opCode <> end then
            BC.get->opCode;
            (if opCode
             // classDef // methodDef (* FIXME *) then
                BC.gettext->puttext; ':'->put; 
             // labelDef then
                'L'->put; 
             else
                '\t'->put; opCode->asText->puttext; '\t'->put; 
            if);
            (if opCode
             // labelDef then
                BC.get->putint; ':'->put; '\t'->put
             // pushCst_s8 then
                BC.get->putint
             // pushAdr // pushVal then
                dumpAdr
             // pushReg then
                dumpReg
             // stVal then
                dumpAdr
             // pushText // call // callPrim then
                ' '->put; BC.getText->puttext
             // jmp // cmpAndJmp then
                BC.get->asText->puttext; BC.get->putint; 
             // func then
                BC.get->asText->puttext
            if);
            newline;
            restart read
        if)
   #)
   
