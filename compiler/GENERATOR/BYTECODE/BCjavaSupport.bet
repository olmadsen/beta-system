ORIGIN 'BCmachineBody';
INCLUDE '~beta/basiclib/formatio'; 

(* Support classes needed by the generated Java code.
 * Generated as part of compiling basic BETA environment.
 *)


--BCmachineLib: attributes--

structureCompareSig:
  (# sig: ^text;
  do &text[] -> sig[];
     '(L%sStructure;L%sStructure;)Z' 
       -> sig.putformat(# do common.BetaPackage->s; common.BetaPackage->s #);
  exit sig[]
  #);
structureReturnSig:
  (# sig: ^text
  enter sig[]
  do 'L' -> sig.append;
     common.BetaPackage -> sig.append;
     'Structure' -> sig.append;
     ';' -> sig.append;
  exit sig[]
  #);

GenerateJvmClassExOException:
  (* Called when BetaObject has just been generated.
   * Generate ExOException.class in the same directory.
   *)
  (# 
     (* package beta;
      * public class ExOException extends Exception
      * {
      *     public Object exitobj;
      *     public int labno;
      *     
      *     // Constructor used for Object checking
      *     public ExOException (Object e, int l) 
      *     {
      *         super();
      *         exitobj = e;
      *         labno = l;
      *     }
      * }
      *)
     exo: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> exo[];
     jcf.traceClassFileName -> exo.traceClassFileName;
     jcf.traceClassFile -> exo.traceClassFile;
     jcf.cf.name -> e.path; (* betaenv.class full path *)
     e.path.head -> fn[]; (* directory of betaenv.class full path *)
     DirectoryChar -> fn.put;
     'ExOException.class' -> fn.append;
     fn[] -> exo.init;
     (* Class file ready to start emitting to *)
     
     'ExOException'->(common.BetaPackage).append
       -> exo.constant_pool.classes.addtext
       -> exo.thisClassIndex;
     'java/lang/Exception'
       -> exo.constant_pool.classes.addtext 
       -> exo.superClassIndex;
     
     ('exitobj', 'Ljava/lang/Object;') -> exo.emitFieldDef;
     ('labno', 'I')                    -> exo.emitFieldDef;
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;I)V', 2,  4) -> exo.currentmethod.new;
     aload_0       -> exo.emit;
     invokespecial -> exo.emit; ('java/lang/Exception', '<init>', '()V') -> exo.emitMethodRef;
     aload_0       -> exo.emit;
     aload_1       -> exo.emit;
     putfield      -> exo.emit; ('ExOException'->(common.BetaPackage).append, 'exitobj', 'Ljava/lang/Object;') -> exo.emitFieldRef;
     aload_0       -> exo.emit;
     iload_2       -> exo.emit;
     putfield      -> exo.emit; ('ExOException'->(common.BetaPackage).append, 'labno', 'I') -> exo.emitFieldRef;
     _return       -> exo.emit;
     
     exo.emitToFile;
     
  #);

GenerateJvmClassStructure:
  (# 
     (*
      * package beta;
      * import java.lang.reflect.*;
      * 
      * public class Structure {
      * 
      *     public Object iOrigin;
      *     public Class iProto;
      *     private Constructor iConstructor;
      * 
      *     static{
      * 	System.out.println("\nUSING Structure.java!\n");
      *     }
      *   
      *     Structure(Object o, Class p){
      * 	iOrigin = o;
      * 	iProto = p;
      * 	iConstructor = null;
      *     }
      * 
      *     public static Structure AlloS(Object o, Class p) {
      * 	return new Structure(o, p);
      *     }
      * 
      *     public static Structure ObjS(Object o)
      * 	throws Exception
      *     {
      * 	Class proto = o.getClass();
      * 	Field origin_field;
      * 	Object origin;
      * 	origin_field = proto.getDeclaredField("origin");
      * 	origin = origin_field.get(o);
      * 	return new Structure(origin, proto);
      *     }
      * 
      *     public Object AlloSI() throws Exception
      *     {
      * 	Constructor[] constructors = iProto.getDeclaredConstructors();
      * 	if (iConstructor == null){
      * 	    search:
      * 	    for (int i = 0; i < constructors.length; i++) {
      * 		Class[] parameterTypes = constructors[i].getParameterTypes();
      * 		if (parameterTypes.length == 1){
      * 		    if (parameterTypes[0].isAssignableFrom(iOrigin.getClass())){
      * 			iConstructor = constructors[i];
      * 			break search;
      * 		    }
      * 		}
      * 	    }
      * 	}
      * 	if (iConstructor==null){
      * 	    System.out.println("AlloSI:\tNo constructor with parameter type (origin)\n\t'" + iOrigin.getClass().getName() + "' found in class '" + iProto.getName() + "'!");
      * 	}
      * 	return iConstructor.newInstance(new Object[]{iOrigin});
      *     }
      * 
      *     public static boolean eqS(Structure arg1, Structure arg2)
      *     {
      * 	if (arg1==null) {
      * 	    if (arg2==null)
      * 		return true;
      * 	    return false;
      * 	}
      * 	if (arg2==null)
      * 	    return false;
      * 	if (arg1.iProto != arg2.iProto)
      * 	    return false;
      * 	if (arg1.iOrigin != arg2.iOrigin)
      * 	    return false;
      * 	return true;
      *     }
      * 
      *     public static boolean neS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	return !eqS(arg1, arg2);
      *     }
      * 
      *     public static boolean leS(Structure arg1, Structure arg2)
      *     throws Exception
      *     { 
      * 	return (eqS(arg1, arg2) || ltS(arg1, arg2));
      *     }
      * 
      *     public static boolean geS(Structure arg1, Structure arg2)
      *     throws Exception
      *     { 
      * 	return (eqS(arg1, arg2) || gtS(arg1, arg2));
      *     }
      * 
      *     public static boolean gtS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	return ltS(arg2, arg1);
      *     }
      * 
      *     public static boolean ltS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	if (arg1==null) return false;
      * 	if (arg2==null) return false;
      * 	Class proto1 = arg1.iProto;
      * 	Class proto2 = arg2.iProto;
      * 	if (proto1 == proto2) return false;
      * 	/* Prefix of proto1 is the first try */
      * 	for (proto1 = proto1.getSuperclass();
      * 	     proto1 != null; /* proto1 != Object## */
      * 	     proto1 = proto1.getSuperclass()) {
      * 	    if (proto1 == proto2) {
      * 		if (false /*identical originoff's*/){
      * 		    return arg1.iOrigin == arg2.iOrigin;
      * 		}
      * 		Object newObject = arg1.AlloSI();
      * 		Field origin_field = proto1.getDeclaredField("origin");
      * 		return origin_field.get(newObject) == arg2.iOrigin;
      * 	    }
      * 	}
      * 	return false; 
      *     }
      * 
      * }
      *)
     struc: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> struc[];
     jcf.traceClassFileName -> struc.traceClassFileName;
     jcf.traceClassFile -> struc.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'Structure.class' -> fn.append;
     fn[] -> struc.init;
     (* Class file ready to start emitting to *)
     
     (if not common.switch[188] then
         'FIXME: Structures need an OriginOff argument' -> screen.putline;
     if);
     
     common.StructureClass
       -> struc.constant_pool.classes.addtext
       -> struc.thisClassIndex;
     'java/lang/Object'
       -> struc.constant_pool.classes.addtext 
       -> struc.superClassIndex;
     
     ('iOrigin', 'Ljava/lang/Object;')                    -> struc.emitPrivateFieldDef;
     ('iProto', 'Ljava/lang/Class;')                      -> struc.emitPrivateFieldDef;
     ('iConstructor', 'Ljava/lang/reflect/Constructor;')  -> struc.emitPrivateFieldDef; 
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V', 2,  3) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokespecial -> struc.emit; ('java/lang/Object', '<init>', '()V') -> struc.emitMethodRef;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aload_2       -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aconst_null   -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     _return       -> struc.emit;
     
     (* Method: AlloS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)'->structureReturnSig, 4,  2) -> struc.currentmethod.new;
     new           -> struc.emit; common.StructureClass -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; (common.StructureClass, '<init>',  '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;

     (* Method: ObjS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'ObjS', '(Ljava/lang/Object;)'->structureReturnSig, 4,  5) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     astore_1      -> struc.emit;
     aload_1       -> struc.emit;
     'origin'      -> struc.emitLoadString;
     invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef;
     astore_2      -> struc.emit;
     aload_2       -> struc.emit;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     astore_3      -> struc.emit;
     new           -> struc.emit; common.StructureClass -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_3       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; (common.StructureClass, '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;
     
     (* Method: AlloSI *)
     (ACC_PUBLIC, 'AlloSI', '()Ljava/lang/Object;', 5,  4) -> struc.currentmethod.new;
     (*  0:*) aload_0       -> struc.emit;
     (*  1:*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (*  4:*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredConstructors', '()[Ljava/lang/reflect/Constructor;') -> struc.emitMethodRef;
     (*  7:*) astore_1      -> struc.emit;
     (*  8:*) aload_0       -> struc.emit;
     (*  9:*) getfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 12:*) ifnonnull     -> struc.emit; 68-12 -> struc.emitShort;
     (* 15:*) iconst_0      -> struc.emit;
     (* 16:*) istore_2      -> struc.emit;
     (* 17:*) goto          -> struc.emit; 62-17 -> struc.emitShort;
     (* 20:*) aload_1       -> struc.emit;
     (* 21:*) iload_2       -> struc.emit;
     (* 22:*) aaload        -> struc.emit;
     (* 23:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'getParameterTypes', '()[Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 26:*) astore_3      -> struc.emit;
     (* 27:*) aload_3       -> struc.emit;
     (* 28:*) arraylength   -> struc.emit;
     (* 29:*) iconst_1      -> struc.emit;
     (* 30:*) if_icmpne     -> struc.emit; 59-30 -> struc.emitShort;
     (* 33:*) aload_3       -> struc.emit;
     (* 34:*) iconst_0      -> struc.emit;
     (* 35:*) aaload        -> struc.emit;
     (* 36:*) aload_0       -> struc.emit;
     (* 37:*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 40:*) invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 43:*) invokevirtual -> struc.emit; ('java/lang/Class', 'isAssignableFrom', '(Ljava/lang/Class;)Z') -> struc.emitMethodRef;
     (* 46:*) ifeq          -> struc.emit; 59-46 -> struc.emitShort;
     (* 49:*) aload_0       -> struc.emit;
     (* 50:*) aload_1       -> struc.emit;
     (* 51:*) iload_2       -> struc.emit;
     (* 52:*) aaload        -> struc.emit;
     (* 53:*) putfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 56:*) goto          -> struc.emit; 68-56 -> struc.emitShort;
     (* 59:*) iinc          -> struc.emit; 2 -> struc.emit; 1-> struc.emit; 
     (* 62:*) iload_2       -> struc.emit;
     (* 63:*) aload_1       -> struc.emit;
     (* 64:*) arraylength   -> struc.emit;
     (* 65:*) if_icmplt     -> struc.emit; 20-65 -> struc.emitShort;
     (* 68:*) aload_0       -> struc.emit;
     (* 69:*) getfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 72:*) iconst_1      -> struc.emit;
     (* 73:*) anewarray     -> struc.emit; 'java/lang/Object' -> struc.emitClassRef;
     (* 76:*) _dup          -> struc.emit;
     (* 77:*) iconst_0      -> struc.emit;
     (* 78:*) aload_0       -> struc.emit;
     (* 79:*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 82:*) aastore       -> struc.emit;
     (* 83:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'newInstance', '([Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     (* 86:*) areturn       -> struc.emit;
     
     (* Method: eqS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'eqS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0: *) aload_0   -> struc.emit;
     (* 1: *) ifnonnull -> struc.emit; 12-1 -> struc.emitShort;
     (* 4: *) aload_1   -> struc.emit;
     (* 5: *) ifnonnull -> struc.emit; 10-5 -> struc.emitShort;
     (* 8: *) iconst_1  -> struc.emit;
     (* 9: *) ireturn   -> struc.emit;
     (* 10:*) iconst_0  -> struc.emit;
     (* 11:*) ireturn   -> struc.emit;
     (* 12:*) aload_1   -> struc.emit;
     (* 13:*) ifnonnull -> struc.emit; 18-13 -> struc.emitShort;
     (* 16:*) iconst_0  -> struc.emit;
     (* 17:*) ireturn   -> struc.emit;
     (* 18:*) aload_0   -> struc.emit;
     (* 19:*) getfield  -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 22:*) aload_1   -> struc.emit;
     (* 23:*) getfield  -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 26:*) if_acmpeq -> struc.emit; 31-26 -> struc.emitShort;
     (* 29:*) iconst_0  -> struc.emit;
     (* 30:*) ireturn   -> struc.emit;
     (* 31:*) aload_0   -> struc.emit;
     (* 32:*) getfield  -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 35:*) aload_1   -> struc.emit;
     (* 36:*) getfield  -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 39:*) if_acmpeq -> struc.emit; 44-39 -> struc.emitShort;
     (* 42:*) iconst_0  -> struc.emit;
     (* 43:*) ireturn   -> struc.emit;
     (* 44:*) iconst_1  -> struc.emit;
     (* 45:*) ireturn   -> struc.emit;
     
     (* Method: neS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'neS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 12-5 -> struc.emitShort;
     (* 8:*) iconst_1     -> struc.emit; 
     (* 9:*) goto         -> struc.emit; 13-9 -> struc.emitShort;
     (*12:*) iconst_0     -> struc.emit; 
     (*13:*) ireturn      -> struc.emit; 
     
     (* Method: leS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'leS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; (common.StructureClass, 'ltS', structureCompareSig) -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort;
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: geS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'geS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; (common.StructureClass, 'gtS', structureCompareSig) -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort; 
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: gtS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'gtS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (*0:*) aload_1       -> struc.emit; 
     (*1:*) aload_0       -> struc.emit; 
     (*2:*) invokestatic  -> struc.emit; (common.StructureClass, 'ltS', structureCompareSig) -> struc.emitMethodRef;
     (*5:*) ireturn       -> struc.emit; 
     
     (* Method: ltS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'ltS', structureCompareSig, 2,  6) -> struc.currentmethod.new;
     (* 0*) aload_0       -> struc.emit; 
     (* 1*) ifnonnull     -> struc.emit; 6-1 -> struc.emitShort;
     (* 4*) iconst_0      -> struc.emit; 
     (* 5*) ireturn       -> struc.emit; 
     (* 6*) aload_1       -> struc.emit; 
     (* 7*) ifnonnull     -> struc.emit; 12-7 -> struc.emitShort;
     (*10*) iconst_0      -> struc.emit; 
     (*11*) ireturn       -> struc.emit; 
     (*12*) aload_0       -> struc.emit; 
     (*13*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*16*) astore_2      -> struc.emit; 
     (*17*) aload_1       -> struc.emit; 
     (*18*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*21*) astore_3      -> struc.emit; 
     (*22*) aload_2       -> struc.emit; 
     (*23*) aload_3       -> struc.emit; 
     (*24*) if_acmpne     -> struc.emit; 29-24 -> struc.emitShort; 
     (*27*) iconst_0      -> struc.emit; 
     (*28*) ireturn       -> struc.emit; 
     (*29*) aload_2       -> struc.emit; 
     (*30*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*33*) astore_2      -> struc.emit; 
     (*34*) goto          -> struc.emit; 81-34 -> struc.emitShort; 
     (*37*) aload_2       -> struc.emit; 
     (*38*) aload_3       -> struc.emit; 
     (*39*) if_acmpne     -> struc.emit; 76-39 -> struc.emitShort; 
     (*42*) aload_0       -> struc.emit; 
     (*43*) invokevirtual -> struc.emit; (common.StructureClass, 'AlloSI', '()Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*46*) astore        -> struc.emit; 4 -> struc.emit; 
     (*48*) aload_2       -> struc.emit; 
     (*49*) 'origin'      -> struc.emitLoadString;
     (*51*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef; 
     (*54*) astore        -> struc.emit; 5 -> struc.emit;
     (*56*) aload         -> struc.emit; 5 -> struc.emit;
     (*58*) aload         -> struc.emit; 4 -> struc.emit;
     (*60*) invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*63*) aload_1       -> struc.emit; 
     (*64*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef; 
     (*67*) if_acmpne     -> struc.emit; 74-67 -> struc.emitShort; 
     (*70*) iconst_1      -> struc.emit; 
     (*71*) goto          -> struc.emit; 75-71 -> struc.emitShort; 
     (*74*) iconst_0      -> struc.emit; 
     (*75*) ireturn       -> struc.emit; 
     (*76*) aload_2       -> struc.emit; 
     (*77*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*80*) astore_2      -> struc.emit; 
     (*81*) aload_2       -> struc.emit; 
     (*82*) ifnonnull     -> struc.emit; 37-82 -> struc.emitShort; 
     (*85*) iconst_0      -> struc.emit; 
     (*86*) ireturn       -> struc.emit;     

     struc.emitToFile;
     
  #);


GenerateJvmClassBetaArray:
  (* Called when BetaObject has just been generated.
   * Generate BetaArray.class in the same directory.
   *)
  (# 
     (*
      * package beta;
      * public abstract class BetaArray {
      * 
      *     static{
      * 	System.out.println("\nUSING BetaArray.java!\n");
      *     }
      *   
      *     public static char[] ExtVR1(char[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	char[] newArray = new char[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopyVR1(char[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	char[] newArray = new char[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopySVR1(int low, int high,char[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	char[] newArray = new char[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] ExtVRZ(boolean[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	boolean[] newArray = new boolean[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] CopyVRZ(boolean[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	boolean[] newArray = new boolean[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] CopySVRZ(int low, int high,boolean[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	boolean[] newArray = new boolean[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] ExtVR2(short[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	short[] newArray = new short[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopyVR2(short[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	short[] newArray = new short[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopySVR2(int low, int high,short[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	short[] newArray = new short[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] ExtVR4(int[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	int[] newArray = new int[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopyVR4(int[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	int[] newArray = new int[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopySVR4(int low, int high,int[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	int[] newArray = new int[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] ExtVR8(double[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	double[] newArray = new double[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopyVR8(double[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	double[] newArray = new double[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopySVR8(int low, int high,double[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	double[] newArray = new double[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static void CkSR(int low, int high, int range) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	// Check that low and high are usable. 
      * 	if (low<1) 
      * 	    throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (low): " 
      * 						     + low 
      * 						     + "<1");
      * 	if (range<high) 
      * 	    throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (high): "
      * 						     + high
      * 						     + ">"
      * 						     + range
      * 						     );
      *     }
      * 
      * }
      *)

     ba: ^JavaImage;
     e: @diskentry;
     fn: ^text;
     emitExtVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '([%cI)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          aload_0          -> ba.emit;
          arraylength      -> ba.emit;
          istore_2         -> ba.emit;
          iload_2          -> ba.emit;
          iload_1          -> ba.emit;
          iadd             -> ba.emit;
          istore_3         -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) ifge      -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0  -> ba.emit;
          (*4:*) istore_3  -> ba.emit;
          (*5:*) iload_2   -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) if_icmple -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iload_3   -> ba.emit;
          (*4:*) istore_2  -> ba.emit;
          (*5:*) iload_3   -> ba.emit;
          newarray         -> ba.emit; type -> ba.emit;
          astore           -> ba.emit; 4 -> ba.emit;
          aload_0          -> ba.emit;
          iconst_0         -> ba.emit;
          aload            -> ba.emit; 4 -> ba.emit;
          iconst_0         -> ba.emit;
          iload_2          -> ba.emit;
          invokestatic     -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload            -> ba.emit; 4 -> ba.emit;
          areturn          -> ba.emit;
       #);
     
     emitCopyVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '([%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 3) -> ba.currentmethod.new;
          aload_0         -> ba.emit;
          arraylength     -> ba.emit;
          istore_1        -> ba.emit;
          iload_1         -> ba.emit;
          newarray        -> ba.emit; type -> ba.emit;
          astore_2        -> ba.emit;
          aload_0         -> ba.emit;
          iconst_0        -> ba.emit;
          aload_2         -> ba.emit;
          iconst_0        -> ba.emit;
          iload_1         -> ba.emit;
          invokestatic    -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload_2         -> ba.emit;
          areturn         -> ba.emit;          
       #);

     emitCopySVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '(II[%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          iload_0              -> ba.emit; 
          iload_1              -> ba.emit; 
          aload_2              -> ba.emit; 
          arraylength          -> ba.emit; 
          invokestatic         -> ba.emit; (common.BetaArrayClass, 'CkSR', '(III)V') -> ba.emitMethodRef;
          iload_1              -> ba.emit; 
          iload_0              -> ba.emit; 
          isub                 -> ba.emit; 
          iconst_1             -> ba.emit; 
          iadd                 -> ba.emit; 
          istore_3             -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*) ifge          -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0      -> ba.emit; 
          (*4:*) istore_3      -> ba.emit; 
          (*5:*) iload_3       -> ba.emit; 
          newarray             -> ba.emit; type -> ba.emit;
          astore               -> ba.emit; 4 -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*)  ifle         -> ba.emit; 14 -> ba.emitshort; 
          (*3:*)  aload_2      -> ba.emit; 
          (*4:*)  iload_0      -> ba.emit; 
          (*5:*)  iconst_1     -> ba.emit; 
          (*6:*)  isub         -> ba.emit; 
          (*7:*)  aload        -> ba.emit; 4 -> ba.emit; 
          (*9:*)  iconst_0     -> ba.emit; 
          (*10:*) iload_3      -> ba.emit; 
          (*11:*) invokestatic -> ba.emit; ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> ba.emitMethodRef;
          (*14:*) aload -> ba.emit; 4 -> ba.emit; 
          areturn -> ba.emit; 
       #);
     
  do &JavaImage[] -> ba[];
     jcf.traceClassFileName -> ba.traceClassFileName;
     jcf.traceClassFile -> ba.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'BetaArray.class' -> fn.append;
     fn[] -> ba.init;
     (* Class file ready to start emitting to *)
     
     common.BetaArrayClass 
       -> ba.constant_pool.classes.addtext
       -> ba.thisClassIndex;
     'java/lang/Object'
       -> ba.constant_pool.classes.addtext 
       -> ba.superClassIndex;
     
     (* No fields *)
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '()V', 1,  1) -> ba.currentmethod.new;
     aload_0       -> ba.emit;
     invokespecial -> ba.emit; ('java/lang/Object', '<init>', '()V') -> ba.emitMethodRef;
     _return       -> ba.emit;
     
     ('ExtVRZ', 'Z', T_BOOLEAN)  -> emitExtVR;
     ('ExtVRB', 'B', T_BYTE)  -> emitExtVR;
     ('ExtVR1', 'C', T_CHAR)     -> emitExtVR;
     ('ExtVR2', 'S', T_SHORT)    -> emitExtVR;
     ('ExtVR4', 'I', T_INT)      -> emitExtVR;
     ('ExtVR8', 'D', T_DOUBLE)   -> emitExtVR;
     
     ('CopyVRZ', 'Z', T_BOOLEAN) -> emitCopyVR;
     ('CopyVRB', 'B', T_BYTE)    -> emitCopyVR;
     ('CopyVR1', 'C', T_CHAR)    -> emitCopyVR;
     ('CopyVR2', 'S', T_SHORT)   -> emitCopyVR;
     ('CopyVR4', 'I', T_INT)     -> emitCopyVR;
     ('CopyVR8', 'D', T_DOUBLE)  -> emitCopyVR;
     
     ('CopySVRZ', 'Z', T_BOOLEAN) -> emitCopySVR;
     ('CopySVRB', 'B', T_BYTE)    -> emitCopySVR;
     ('CopySVR1', 'C', T_CHAR)    -> emitCopySVR;
     ('CopySVR2', 'S', T_SHORT)   -> emitCopySVR;
     ('CopySVR4', 'I', T_INT)     -> emitCopySVR;
     ('CopySVR8', 'D', T_DOUBLE)  -> emitCopySVR;
     
     (* Method: CkSR *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'CkSR', '(III)V', 4,  3) -> ba.currentmethod.new;
     (*0:*)  iload_0       -> ba.emit;
     (*1:*)  iconst_1      -> ba.emit;
     (*2:*)  if_icmpge     -> ba.emit; 37-2 -> ba.emitShort;
     (*5:*)  new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*8:*)  _dup          -> ba.emit;
     (*9:*)  new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*12:*) _dup          -> ba.emit;
     (*13:*) invokespecial -> ba.emit; 
     (*14:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*16:*) 'Repetition subrange out of bounds (low): ' -> ba.emitLoadString;
     (*18:*) invokevirtual -> ba.emit; 
     (*19:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*21:*) iload_0 -> ba.emit;
     (*22:*) invokevirtual -> ba.emit; 
     (*23:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*25:*) '<1' -> ba.emitLoadString;
     (*27:*) invokevirtual -> ba.emit; 
     (*28:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*30:*) invokevirtual -> ba.emit; 
     (*31:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*33:*) invokespecial -> ba.emit; 
     (*34:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*36:*) athrow        -> ba.emit;
     (*37:*) iload_2       -> ba.emit;
     (*38:*) iload_1       -> ba.emit;
     (*39:*) if_icmpge     -> ba.emit; 78-39 -> ba.emitShort;
     (*42:*) new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*45:*) _dup          -> ba.emit;
     (*46:*) new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*49:*) _dup          -> ba.emit;
     (*50:*) invokespecial -> ba.emit; 
     (*51:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*53:*) 'Repetition subrange out of bounds (high): ' -> ba.emitLoadString;
     (*55:*) invokevirtual -> ba.emit; 
     (*56:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*58:*) iload_1       -> ba.emit;
     (*59:*) invokevirtual -> ba.emit; 
     (*60:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*62:*) '>' -> ba.emitLoadString;
     (*64:*) invokevirtual -> ba.emit; 
     (*65:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*67:*) iload_2       -> ba.emit;
     (*68:*) invokevirtual -> ba.emit; 
     (*69:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*71:*) invokevirtual -> ba.emit; 
     (*72:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*74:*) invokespecial -> ba.emit; 
     (*75:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*77:*) athrow        -> ba.emit;
     (*78:*) _return       -> ba.emit;
     
     ba.emitToFile(# access_flags::(# do value %Bor ACC_ABSTRACT -> value #)#);
     
  #);

GenerateJvmClassComponent:
  (* Called when BetaObject has just been generated.
   * Generate Component.class in the same directory.
   *)
  (# 
     (*
      * package beta;
      * 
      * public class Component extends Thread
      * { static Component current;
      *     Component caller;
      *     BetaObject body;
      * 
      *     Component(BetaObject b) { 
      * 	body = b; 
      * 	setDaemon(true); 
      * 	b.comp$ = this; 
      *         caller = this;
      *     }
      * 
      *     synchronized public void swap()
      *     { 
      * 	trace("Component:swap");
      * 	Component X;
      * 	X = current;
      * 	current = caller;
      * 	caller = X;
      * 	if (!isAlive()) start(); // only relevant if attach
      * 	else notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     }
      *     synchronized void att()
      *     { 
      * 	trace("Component:att");
      * 	caller = current;
      * 	current = this;
      * 	if (!isAlive()) start();
      * 	else notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     }
      *     
      *     synchronized void susp()
      *     { 
      * 	trace("Component:susp");
      * 	current = caller;
      * 	notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     } 
      * 
      *     public void run() 
      *     { 
      * 	trace("Component:run");
      * 	body.xdo();
      * 	trace("Component:terminated");
      * 	synchronized(this) { notify();};
      *     }
      *     public void trace(String T)
      *     { 
      * 	if (false) System.out.println(T);
      *     }
      * }
      *)
     
     comp: ^JavaImage;
     e: @diskentry;
     fn: ^text;
     sig: ^text;
  do &JavaImage[] -> comp[];
     jcf.traceClassFileName -> comp.traceClassFileName;
     jcf.traceClassFile -> comp.traceClassFile;
     jcf.cf.name -> e.path; (* betaenv.class full path *)
     e.path.head -> fn[]; (* directory of betaenv.class full path *)
     DirectoryChar -> fn.put;
     'Component.class' -> fn.append;
     fn[] -> comp.init;
     (* Class file ready to start emitting to *)
     
     common.ComponentClass
       -> comp.constant_pool.classes.addtext
       -> comp.thisClassIndex;
     'java/lang/Thread'
       -> comp.constant_pool.classes.addtext 
       -> comp.superClassIndex;
     
     ('current', common.ComponentClass->textToClassRef)  -> comp.fields.addtext_static;
     ('caller',  common.ComponentClass->textToClassRef)  -> comp.emitFieldDef;
     ('body',    common.BetaObjectClass->textToClassRef) -> comp.emitFieldDef;
     
     '' -> sig[];
     '(L%s;)V' -> sig.putformat(# do common.BetaObjectClass->s #);
     (ACC_PUBLIC, '<init>', sig[], 2,  4) -> comp.currentmethod.new;
     aload_0       -> comp.emit;
     invokespecial -> comp.emit; ('java/lang/Thread', '<init>', '()V') -> comp.emitMethodRef;
     aload_0       -> comp.emit;
     aload_1       -> comp.emit;
     putfield      -> comp.emit; (common.ComponentClass, 'body', common.BetaObjectClass->textToClassRef) -> comp.emitFieldRef;
     aload_0       -> comp.emit;
     iconst_1      -> comp.emit;
     invokevirtual -> comp.emit; (common.ComponentClass, 'setDaemon', '(Z)V') -> comp.emitMethodRef;
     aload_1       -> comp.emit;
     aload_0       -> comp.emit;
     putfield      -> comp.emit; (common.BetaObjectClass, 'comp$', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     aload_0       -> comp.emit;
     aload_0       -> comp.emit;
     putfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     _return       -> comp.emit;
     
     (ACC_PUBLIC %Bor ACC_SYNCHRONIZED, 'swap', '()V', 2,  3) -> comp.currentmethod.new;
     (* 0:*) getstatic     -> comp.emit; (common.ComponentClass, 'current', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (* 3:*) astore_1      -> comp.emit;
     (* 4:*) aload_0       -> comp.emit;
     (* 5:*) getfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (* 8:*) putstatic     -> comp.emit; (common.ComponentClass, 'current', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (*11:*) aload_0       -> comp.emit;
     (*12:*) aload_1       -> comp.emit; 
     (*13:*) putfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (*16:*) aload_0       -> comp.emit; 
     (*17:*) invokevirtual -> comp.emit; (common.ComponentClass, 'isAlive', '()Z') -> comp.emitMethodRef;
     (*20:*) ifne          -> comp.emit; 30-20 -> comp.emitShort; 
     (*23:*) aload_0       -> comp.emit; 
     (*24:*) invokevirtual -> comp.emit; (common.ComponentClass, 'start', '()V') -> comp.emitMethodRef;
     (*27:*) goto          -> comp.emit; 34-27 -> comp.emitShort; 
     (*30:*) aload_0       -> comp.emit; 
     (*31:*) invokevirtual -> comp.emit; ('java/lang/Object', 'notify', '()V') -> comp.emitMethodRef;
     (*34:*) aload_0       -> comp.emit; 
     (*35:*) invokevirtual -> comp.emit; ('java/lang/Object', 'wait', '()V') -> comp.emitMethodRef;
     (*38:*) goto          -> comp.emit; 42-38 -> comp.emitShort;
     (*41:*) astore_2      -> comp.emit; 
     (*42:*) _return       -> comp.emit; 
     
     (34 (*start_pc*), 38 (*end_pc*), 41 (*handler_pc*), 'java/lang/InterruptedException') 
       -> comp.emitExceptionHandlerDef;
     
     (ACC_PUBLIC, 'run', '()V', 2,  3) -> comp.currentmethod.new;
     (* 0:*) aload_0       -> comp.emit; 
     (* 1:*) getfield      -> comp.emit; (common.ComponentClass, 'body', common.BetaObjectClass->textToClassRef) -> comp.emitFieldRef;
     (* 4:*) invokevirtual -> comp.emit; (common.BetaObjectClass, 'do', '()V') -> comp.emitMethodRef;
     (* 7:*) aload_0       -> comp.emit; 
     (* 8:*) astore_1      -> comp.emit; 
     (* 9:*) aload_1       -> comp.emit; 
     (*10:*) monitorenter  -> comp.emit; 
     (*11:*) aload_0       -> comp.emit; 
     (*12:*) invokevirtual -> comp.emit; ('java/lang/Object', 'notify', '()V') -> comp.emitMethodRef;
     (*15:*) aload_1       -> comp.emit; 
     (*16:*) monitorexit   -> comp.emit; 
     (*17:*) goto          -> comp.emit; 25-17 -> comp.emitShort;
     (*20:*) astore_2      -> comp.emit; 
     (*21:*) aload_1       -> comp.emit; 
     (*22:*) monitorexit   -> comp.emit; 
     (*23:*) aload_2       -> comp.emit; 
     (*24:*) athrow        -> comp.emit; 
     (*25:*) _return       -> comp.emit; 
     
     (11 (*start_pc*), 17 (*end_pc*), 20 (*handler_pc*), NONE (*finally*)) 
       -> comp.emitExceptionHandlerDef;
     (20 (*start_pc*), 23 (*end_pc*), 20 (*handler_pc*), NONE (*finally*)) 
       -> comp.emitExceptionHandlerDef;
     
     comp.emitToFile;
     
  #);

