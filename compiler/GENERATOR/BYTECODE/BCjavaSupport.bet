ORIGIN 'BCjvmMstate';
INCLUDE '~beta/basiclib/formatio'; 

(* Support classes needed by the generated Java code.
 * Generated as part of compiling basic BETA environment.
 *)


--bytecode_mstateLib: attributes--

structureCompareSig:
  (# sig: ^text;
  do &text[] -> sig[];
     '(L%sStructure;L%sStructure;)Z' 
       -> sig.putformat(# do common.BetaPackage->s; common.BetaPackage->s #);
  exit sig[]
  #);
structureReturnSig:
  (# sig: ^text
  enter sig[]
  do 'L' -> sig.append;
     common.BetaPackage -> sig.append;
     'Structure' -> sig.append;
     ';' -> sig.append;
  exit sig[]
  #);

GenerateJvmClasses:
  (#
  do GenerateJvmClassExOException;
     GenerateJvmClassStructure;
     GenerateJvmClassBetaArray;
     (if not common.ComponentDotCJ then
         GenerateJvmClassComponent
     if);
  #);

GenerateJvmClassExOException:
  (* Called when BetaObject has just been generated.
   * Generate ExOException.class in the same directory.
   *)
  (# 
     (* package beta;
      * public class ExOException extends Exception
      * {
      *     public Object exitobj;
      *     public int labno;
      *     
      *     // Constructor used for Object checking
      *     public ExOException (Object e, int l) 
      *     {
      *         super();
      *         exitobj = e;
      *         labno = l;
      *     }
      * }
      *)
     exo: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> exo[];
     jcf.traceClassFileName -> exo.traceClassFileName;
     jcf.traceClassFile -> exo.traceClassFile;
     jcf.cf.name -> e.path; (* betaenv.class full path *)
     e.path.head -> fn[]; (* directory of betaenv.class full path *)
     DirectoryChar -> fn.put;
     'ExOException.class' -> fn.append;
     fn[] -> exo.init;
     (* Class file ready to start emitting to *)
     
     'ExOException'->(common.BetaPackage).append
       -> exo.constant_pool.classes.addtext
       -> exo.thisClassIndex;
     'java/lang/Exception'
       -> exo.constant_pool.classes.addtext 
       -> exo.superClassIndex;
     
     ('exitobj', 'Ljava/lang/Object;') -> exo.emitFieldDef;
     ('labno', 'I')                    -> exo.emitFieldDef;
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;I)V', 2,  4) -> exo.currentmethod.new;
     aload_0       -> exo.emit;
     invokespecial -> exo.emit; ('java/lang/Exception', '<init>', '()V') -> exo.emitMethodRef;
     aload_0       -> exo.emit;
     aload_1       -> exo.emit;
     putfield      -> exo.emit; ('ExOException'->(common.BetaPackage).append, 'exitobj', 'Ljava/lang/Object;') -> exo.emitFieldRef;
     aload_0       -> exo.emit;
     iload_2       -> exo.emit;
     putfield      -> exo.emit; ('ExOException'->(common.BetaPackage).append, 'labno', 'I') -> exo.emitFieldRef;
     _return       -> exo.emit;
     
     exo.emitToFile;
     
  #);

GenerateJvmClassStructure:
  (# 
     (*
      * package beta;
      * import java.lang.reflect.*;
      * 
      * public class Structure {
      * 
      *     public Object iOrigin;
      *     public Class iProto;
      *     private Constructor iConstructor;
      * 
      *     static{
      * 	System.out.println("\nUSING Structure.java!\n");
      *     }
      *   
      *     Structure(Object o, Class p){
      * 	iOrigin = o;
      * 	iProto = p;
      * 	iConstructor = null;
      *     }
      * 
      *     public static Structure AlloS(Object o, Class p) {
      * 	return new Structure(o, p);
      *     }
      * 
      *     public static Structure ObjS(Object o)
      * 	throws Exception
      *     {
      * 	Class proto = o.getClass();
      * 	Field origin_field;
      * 	Object origin;
      * 	origin_field = proto.getDeclaredField("origin");
      * 	origin = origin_field.get(o);
      * 	return new Structure(origin, proto);
      *     }
      * 
      *     public Object AlloSI() throws Exception
      *     {
      * 	Constructor[] constructors = iProto.getDeclaredConstructors();
      * 	if (iConstructor == null){
      * 	    search:
      * 	    for (int i = 0; i < constructors.length; i++) {
      * 		Class[] parameterTypes = constructors[i].getParameterTypes();
      * 		if (parameterTypes.length == 1){
      * 		    if (parameterTypes[0].isAssignableFrom(iOrigin.getClass())){
      * 			iConstructor = constructors[i];
      * 			break search;
      * 		    }
      * 		}
      * 	    }
      * 	}
      * 	if (iConstructor==null){
      * 	    System.out.println("AlloSI:\tNo constructor with parameter type (origin)\n\t'" + iOrigin.getClass().getName() + "' found in class '" + iProto.getName() + "'!");
      * 	}
      * 	return iConstructor.newInstance(new Object[]{iOrigin});
      *     }
      * 
      *     public static boolean eqS(Structure arg1, Structure arg2)
      *     {
      * 	if (arg1==null) {
      * 	    if (arg2==null)
      * 		return true;
      * 	    return false;
      * 	}
      * 	if (arg2==null)
      * 	    return false;
      * 	if (arg1.iProto != arg2.iProto)
      * 	    return false;
      * 	if (arg1.iOrigin != arg2.iOrigin)
      * 	    return false;
      * 	return true;
      *     }
      * 
      *     public static boolean neS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	return !eqS(arg1, arg2);
      *     }
      * 
      *     public static boolean leS(Structure arg1, Structure arg2)
      *     throws Exception
      *     { 
      * 	return (eqS(arg1, arg2) || ltS(arg1, arg2));
      *     }
      * 
      *     public static boolean geS(Structure arg1, Structure arg2)
      *     throws Exception
      *     { 
      * 	return (eqS(arg1, arg2) || gtS(arg1, arg2));
      *     }
      * 
      *     public static boolean gtS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	return ltS(arg2, arg1);
      *     }
      * 
      *     public static boolean ltS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	if (arg1==null) return false;
      * 	if (arg2==null) return false;
      * 	Class proto1 = arg1.iProto;
      * 	Class proto2 = arg2.iProto;
      * 	if (proto1 == proto2) return false;
      * 	/* Prefix of proto1 is the first try */
      * 	for (proto1 = proto1.getSuperclass();
      * 	     proto1 != null; /* proto1 != Object## */
      * 	     proto1 = proto1.getSuperclass()) {
      * 	    if (proto1 == proto2) {
      * 		if (false /*identical originoff's*/){
      * 		    return arg1.iOrigin == arg2.iOrigin;
      * 		}
      * 		Object newObject = arg1.AlloSI();
      * 		Field origin_field = proto1.getDeclaredField("origin");
      * 		return origin_field.get(newObject) == arg2.iOrigin;
      * 	    }
      * 	}
      * 	return false; 
      *     }
      * 
      * }
      *)
     struc: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> struc[];
     jcf.traceClassFileName -> struc.traceClassFileName;
     jcf.traceClassFile -> struc.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'Structure.class' -> fn.append;
     fn[] -> struc.init;
     (* Class file ready to start emitting to *)
     
     (if not common.switch[188] then
         'FIXME: Structures need an OriginOff argument' -> screen.putline;
     if);
     
     common.StructureClass
       -> struc.constant_pool.classes.addtext
       -> struc.thisClassIndex;
     'java/lang/Object'
       -> struc.constant_pool.classes.addtext 
       -> struc.superClassIndex;
     
     ('iOrigin', 'Ljava/lang/Object;')                    -> struc.emitPrivateFieldDef;
     ('iProto', 'Ljava/lang/Class;')                      -> struc.emitPrivateFieldDef;
     ('iConstructor', 'Ljava/lang/reflect/Constructor;')  -> struc.emitPrivateFieldDef; 
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V', 2,  3) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokespecial -> struc.emit; ('java/lang/Object', '<init>', '()V') -> struc.emitMethodRef;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aload_2       -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aconst_null   -> struc.emit;
     putfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     _return       -> struc.emit;
     
     (* Method: AlloS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)'->structureReturnSig, 4,  2) -> struc.currentmethod.new;
     new           -> struc.emit; common.StructureClass -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; (common.StructureClass, '<init>',  '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;

     (* Method: ObjS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'ObjS', '(Ljava/lang/Object;)'->structureReturnSig, 4,  5) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     astore_1      -> struc.emit;
     aload_1       -> struc.emit;
     'origin'      -> struc.emitLoadString;
     invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef;
     astore_2      -> struc.emit;
     aload_2       -> struc.emit;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     astore_3      -> struc.emit;
     new           -> struc.emit; common.StructureClass -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_3       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; (common.StructureClass, '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;
     
     (* Method: AlloSI *)
     (ACC_PUBLIC, 'AlloSI', '()Ljava/lang/Object;', 5,  4) -> struc.currentmethod.new;
     (*  0:*) aload_0       -> struc.emit;
     (*  1:*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (*  4:*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredConstructors', '()[Ljava/lang/reflect/Constructor;') -> struc.emitMethodRef;
     (*  7:*) astore_1      -> struc.emit;
     (*  8:*) aload_0       -> struc.emit;
     (*  9:*) getfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 12:*) ifnonnull     -> struc.emit; 68-12 -> struc.emitShort;
     (* 15:*) iconst_0      -> struc.emit;
     (* 16:*) istore_2      -> struc.emit;
     (* 17:*) goto          -> struc.emit; 62-17 -> struc.emitShort;
     (* 20:*) aload_1       -> struc.emit;
     (* 21:*) iload_2       -> struc.emit;
     (* 22:*) aaload        -> struc.emit;
     (* 23:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'getParameterTypes', '()[Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 26:*) astore_3      -> struc.emit;
     (* 27:*) aload_3       -> struc.emit;
     (* 28:*) arraylength   -> struc.emit;
     (* 29:*) iconst_1      -> struc.emit;
     (* 30:*) if_icmpne     -> struc.emit; 59-30 -> struc.emitShort;
     (* 33:*) aload_3       -> struc.emit;
     (* 34:*) iconst_0      -> struc.emit;
     (* 35:*) aaload        -> struc.emit;
     (* 36:*) aload_0       -> struc.emit;
     (* 37:*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 40:*) invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 43:*) invokevirtual -> struc.emit; ('java/lang/Class', 'isAssignableFrom', '(Ljava/lang/Class;)Z') -> struc.emitMethodRef;
     (* 46:*) ifeq          -> struc.emit; 59-46 -> struc.emitShort;
     (* 49:*) aload_0       -> struc.emit;
     (* 50:*) aload_1       -> struc.emit;
     (* 51:*) iload_2       -> struc.emit;
     (* 52:*) aaload        -> struc.emit;
     (* 53:*) putfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 56:*) goto          -> struc.emit; 68-56 -> struc.emitShort;
     (* 59:*) iinc          -> struc.emit; 2 -> struc.emit; 1-> struc.emit; 
     (* 62:*) iload_2       -> struc.emit;
     (* 63:*) aload_1       -> struc.emit;
     (* 64:*) arraylength   -> struc.emit;
     (* 65:*) if_icmplt     -> struc.emit; 20-65 -> struc.emitShort;
     (* 68:*) aload_0       -> struc.emit;
     (* 69:*) getfield      -> struc.emit; (common.StructureClass, 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 72:*) iconst_1      -> struc.emit;
     (* 73:*) anewarray     -> struc.emit; 'java/lang/Object' -> struc.emitClassRef;
     (* 76:*) _dup          -> struc.emit;
     (* 77:*) iconst_0      -> struc.emit;
     (* 78:*) aload_0       -> struc.emit;
     (* 79:*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 82:*) aastore       -> struc.emit;
     (* 83:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'newInstance', '([Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     (* 86:*) areturn       -> struc.emit;
     
     (* Method: eqS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'eqS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0: *) aload_0   -> struc.emit;
     (* 1: *) ifnonnull -> struc.emit; 12-1 -> struc.emitShort;
     (* 4: *) aload_1   -> struc.emit;
     (* 5: *) ifnonnull -> struc.emit; 10-5 -> struc.emitShort;
     (* 8: *) iconst_1  -> struc.emit;
     (* 9: *) ireturn   -> struc.emit;
     (* 10:*) iconst_0  -> struc.emit;
     (* 11:*) ireturn   -> struc.emit;
     (* 12:*) aload_1   -> struc.emit;
     (* 13:*) ifnonnull -> struc.emit; 18-13 -> struc.emitShort;
     (* 16:*) iconst_0  -> struc.emit;
     (* 17:*) ireturn   -> struc.emit;
     (* 18:*) aload_0   -> struc.emit;
     (* 19:*) getfield  -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 22:*) aload_1   -> struc.emit;
     (* 23:*) getfield  -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 26:*) if_acmpeq -> struc.emit; 31-26 -> struc.emitShort;
     (* 29:*) iconst_0  -> struc.emit;
     (* 30:*) ireturn   -> struc.emit;
     (* 31:*) aload_0   -> struc.emit;
     (* 32:*) getfield  -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 35:*) aload_1   -> struc.emit;
     (* 36:*) getfield  -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 39:*) if_acmpeq -> struc.emit; 44-39 -> struc.emitShort;
     (* 42:*) iconst_0  -> struc.emit;
     (* 43:*) ireturn   -> struc.emit;
     (* 44:*) iconst_1  -> struc.emit;
     (* 45:*) ireturn   -> struc.emit;
     
     (* Method: neS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'neS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 12-5 -> struc.emitShort;
     (* 8:*) iconst_1     -> struc.emit; 
     (* 9:*) goto         -> struc.emit; 13-9 -> struc.emitShort;
     (*12:*) iconst_0     -> struc.emit; 
     (*13:*) ireturn      -> struc.emit; 
     
     (* Method: leS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'leS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; (common.StructureClass, 'ltS', structureCompareSig) -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort;
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: geS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'geS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; (common.StructureClass, 'eqS', structureCompareSig) -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; (common.StructureClass, 'gtS', structureCompareSig) -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort; 
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: gtS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'gtS', structureCompareSig, 2,  2) -> struc.currentmethod.new;
     (*0:*) aload_1       -> struc.emit; 
     (*1:*) aload_0       -> struc.emit; 
     (*2:*) invokestatic  -> struc.emit; (common.StructureClass, 'ltS', structureCompareSig) -> struc.emitMethodRef;
     (*5:*) ireturn       -> struc.emit; 
     
     (* Method: ltS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'ltS', structureCompareSig, 2,  6) -> struc.currentmethod.new;
     (* 0*) aload_0       -> struc.emit; 
     (* 1*) ifnonnull     -> struc.emit; 6-1 -> struc.emitShort;
     (* 4*) iconst_0      -> struc.emit; 
     (* 5*) ireturn       -> struc.emit; 
     (* 6*) aload_1       -> struc.emit; 
     (* 7*) ifnonnull     -> struc.emit; 12-7 -> struc.emitShort;
     (*10*) iconst_0      -> struc.emit; 
     (*11*) ireturn       -> struc.emit; 
     (*12*) aload_0       -> struc.emit; 
     (*13*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*16*) astore_2      -> struc.emit; 
     (*17*) aload_1       -> struc.emit; 
     (*18*) getfield      -> struc.emit; (common.StructureClass, 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*21*) astore_3      -> struc.emit; 
     (*22*) aload_2       -> struc.emit; 
     (*23*) aload_3       -> struc.emit; 
     (*24*) if_acmpne     -> struc.emit; 29-24 -> struc.emitShort; 
     (*27*) iconst_0      -> struc.emit; 
     (*28*) ireturn       -> struc.emit; 
     (*29*) aload_2       -> struc.emit; 
     (*30*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*33*) astore_2      -> struc.emit; 
     (*34*) goto          -> struc.emit; 81-34 -> struc.emitShort; 
     (*37*) aload_2       -> struc.emit; 
     (*38*) aload_3       -> struc.emit; 
     (*39*) if_acmpne     -> struc.emit; 76-39 -> struc.emitShort; 
     (*42*) aload_0       -> struc.emit; 
     (*43*) invokevirtual -> struc.emit; (common.StructureClass, 'AlloSI', '()Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*46*) astore        -> struc.emit; 4 -> struc.emit; 
     (*48*) aload_2       -> struc.emit; 
     (*49*) 'origin'      -> struc.emitLoadString;
     (*51*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef; 
     (*54*) astore        -> struc.emit; 5 -> struc.emit;
     (*56*) aload         -> struc.emit; 5 -> struc.emit;
     (*58*) aload         -> struc.emit; 4 -> struc.emit;
     (*60*) invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*63*) aload_1       -> struc.emit; 
     (*64*) getfield      -> struc.emit; (common.StructureClass, 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef; 
     (*67*) if_acmpne     -> struc.emit; 74-67 -> struc.emitShort; 
     (*70*) iconst_1      -> struc.emit; 
     (*71*) goto          -> struc.emit; 75-71 -> struc.emitShort; 
     (*74*) iconst_0      -> struc.emit; 
     (*75*) ireturn       -> struc.emit; 
     (*76*) aload_2       -> struc.emit; 
     (*77*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*80*) astore_2      -> struc.emit; 
     (*81*) aload_2       -> struc.emit; 
     (*82*) ifnonnull     -> struc.emit; 37-82 -> struc.emitShort; 
     (*85*) iconst_0      -> struc.emit; 
     (*86*) ireturn       -> struc.emit;     

     struc.emitToFile;
     
  #);


GenerateJvmClassBetaArray:
  (* Called when BetaObject has just been generated.
   * Generate BetaArray.class in the same directory.
   *)
  (# 
     (*
      * package beta;
      * public abstract class BetaArray {
      * 
      *     static{
      * 	System.out.println("\nUSING BetaArray.java!\n");
      *     }
      *   
      *     public static char[] ExtVR1(char[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	char[] newArray = new char[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopyVR1(char[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	char[] newArray = new char[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopySVR1(int low, int high,char[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	char[] newArray = new char[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] ExtVRZ(boolean[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	boolean[] newArray = new boolean[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] CopyVRZ(boolean[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	boolean[] newArray = new boolean[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static boolean[] CopySVRZ(int low, int high,boolean[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	boolean[] newArray = new boolean[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] ExtVR2(short[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	short[] newArray = new short[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopyVR2(short[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	short[] newArray = new short[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopySVR2(int low, int high,short[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	short[] newArray = new short[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] ExtVR4(int[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	int[] newArray = new int[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopyVR4(int[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	int[] newArray = new int[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopySVR4(int low, int high,int[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	int[] newArray = new int[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] ExtVR8(double[] array, int add) {
      * 	int copysize = array.length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	double[] newArray = new double[newsize];
      * 	System.arraycopy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopyVR8(double[] array) {
      * 	int size = array.length;
      * 	if (size<0) size = 0;
      * 	double[] newArray = new double[size];
      * 	System.arraycopy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopySVR8(int low, int high,double[] array) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	CkSR(low, high, array.length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	double[] newArray = new double[newsize];
      * 	if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static void CkSR(int low, int high, int range) 
      * 	throws ArrayIndexOutOfBoundsException
      *     {
      * 
      * 	// Check that low and high are usable. 
      * 	if (low<1) 
      * 	    throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (low): " 
      * 						     + low 
      * 						     + "<1");
      * 	if (range<high) 
      * 	    throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (high): "
      * 						     + high
      * 						     + ">"
      * 						     + range
      * 						     );
      *     }
      * 
      * }
      *)

     ba: ^JavaImage;
     e: @diskentry;
     fn: ^text;
     emitExtVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '([%cI)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          aload_0          -> ba.emit;
          arraylength      -> ba.emit;
          istore_2         -> ba.emit;
          iload_2          -> ba.emit;
          iload_1          -> ba.emit;
          iadd             -> ba.emit;
          istore_3         -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) ifge      -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0  -> ba.emit;
          (*4:*) istore_3  -> ba.emit;
          (*5:*) iload_2   -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) if_icmple -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iload_3   -> ba.emit;
          (*4:*) istore_2  -> ba.emit;
          (*5:*) iload_3   -> ba.emit;
          newarray         -> ba.emit; type -> ba.emit;
          astore           -> ba.emit; 4 -> ba.emit;
          aload_0          -> ba.emit;
          iconst_0         -> ba.emit;
          aload            -> ba.emit; 4 -> ba.emit;
          iconst_0         -> ba.emit;
          iload_2          -> ba.emit;
          invokestatic     -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload            -> ba.emit; 4 -> ba.emit;
          areturn          -> ba.emit;
       #);
     
     emitCopyVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '([%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 3) -> ba.currentmethod.new;
          aload_0         -> ba.emit;
          arraylength     -> ba.emit;
          istore_1        -> ba.emit;
          iload_1         -> ba.emit;
          newarray        -> ba.emit; type -> ba.emit;
          astore_2        -> ba.emit;
          aload_0         -> ba.emit;
          iconst_0        -> ba.emit;
          aload_2         -> ba.emit;
          iconst_0        -> ba.emit;
          iload_1         -> ba.emit;
          invokestatic    -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload_2         -> ba.emit;
          areturn         -> ba.emit;          
       #);

     emitCopySVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do &text[] -> signature[];
          '(II[%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          iload_0              -> ba.emit; 
          iload_1              -> ba.emit; 
          aload_2              -> ba.emit; 
          arraylength          -> ba.emit; 
          invokestatic         -> ba.emit; (common.BetaArrayClass, 'CkSR', '(III)V') -> ba.emitMethodRef;
          iload_1              -> ba.emit; 
          iload_0              -> ba.emit; 
          isub                 -> ba.emit; 
          iconst_1             -> ba.emit; 
          iadd                 -> ba.emit; 
          istore_3             -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*) ifge          -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0      -> ba.emit; 
          (*4:*) istore_3      -> ba.emit; 
          (*5:*) iload_3       -> ba.emit; 
          newarray             -> ba.emit; type -> ba.emit;
          astore               -> ba.emit; 4 -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*)  ifle         -> ba.emit; 14 -> ba.emitshort; 
          (*3:*)  aload_2      -> ba.emit; 
          (*4:*)  iload_0      -> ba.emit; 
          (*5:*)  iconst_1     -> ba.emit; 
          (*6:*)  isub         -> ba.emit; 
          (*7:*)  aload        -> ba.emit; 4 -> ba.emit; 
          (*9:*)  iconst_0     -> ba.emit; 
          (*10:*) iload_3      -> ba.emit; 
          (*11:*) invokestatic -> ba.emit; ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> ba.emitMethodRef;
          (*14:*) aload -> ba.emit; 4 -> ba.emit; 
          areturn -> ba.emit; 
       #);
     
  do &JavaImage[] -> ba[];
     jcf.traceClassFileName -> ba.traceClassFileName;
     jcf.traceClassFile -> ba.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'BetaArray.class' -> fn.append;
     fn[] -> ba.init;
     (* Class file ready to start emitting to *)
     
     common.BetaArrayClass 
       -> ba.constant_pool.classes.addtext
       -> ba.thisClassIndex;
     'java/lang/Object'
       -> ba.constant_pool.classes.addtext 
       -> ba.superClassIndex;
     
     (* No fields *)
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '()V', 1,  1) -> ba.currentmethod.new;
     aload_0       -> ba.emit;
     invokespecial -> ba.emit; ('java/lang/Object', '<init>', '()V') -> ba.emitMethodRef;
     _return       -> ba.emit;
     
     ('ExtVRZ', 'Z', T_BOOLEAN)  -> emitExtVR;
     ('ExtVRB', 'B', T_BYTE)  -> emitExtVR;
     ('ExtVR1', 'C', T_CHAR)     -> emitExtVR;
     ('ExtVR2', 'S', T_SHORT)    -> emitExtVR;
     ('ExtVR4', 'I', T_INT)      -> emitExtVR;
     ('ExtVR8', 'D', T_DOUBLE)   -> emitExtVR;
     
     ('CopyVRZ', 'Z', T_BOOLEAN) -> emitCopyVR;
     ('CopyVRB', 'B', T_BYTE)    -> emitCopyVR;
     ('CopyVR1', 'C', T_CHAR)    -> emitCopyVR;
     ('CopyVR2', 'S', T_SHORT)   -> emitCopyVR;
     ('CopyVR4', 'I', T_INT)     -> emitCopyVR;
     ('CopyVR8', 'D', T_DOUBLE)  -> emitCopyVR;
     
     ('CopySVRZ', 'Z', T_BOOLEAN) -> emitCopySVR;
     ('CopySVRB', 'B', T_BYTE)    -> emitCopySVR;
     ('CopySVR1', 'C', T_CHAR)    -> emitCopySVR;
     ('CopySVR2', 'S', T_SHORT)   -> emitCopySVR;
     ('CopySVR4', 'I', T_INT)     -> emitCopySVR;
     ('CopySVR8', 'D', T_DOUBLE)  -> emitCopySVR;
     
     (* Method: CkSR *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'CkSR', '(III)V', 4,  3) -> ba.currentmethod.new;
     (*0:*)  iload_0       -> ba.emit;
     (*1:*)  iconst_1      -> ba.emit;
     (*2:*)  if_icmpge     -> ba.emit; 37-2 -> ba.emitShort;
     (*5:*)  new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*8:*)  _dup          -> ba.emit;
     (*9:*)  new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*12:*) _dup          -> ba.emit;
     (*13:*) invokespecial -> ba.emit; 
     (*14:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*16:*) 'Repetition subrange out of bounds (low): ' -> ba.emitLoadString;
     (*18:*) invokevirtual -> ba.emit; 
     (*19:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*21:*) iload_0 -> ba.emit;
     (*22:*) invokevirtual -> ba.emit; 
     (*23:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*25:*) '<1' -> ba.emitLoadString;
     (*27:*) invokevirtual -> ba.emit; 
     (*28:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*30:*) invokevirtual -> ba.emit; 
     (*31:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*33:*) invokespecial -> ba.emit; 
     (*34:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*36:*) athrow        -> ba.emit;
     (*37:*) iload_2       -> ba.emit;
     (*38:*) iload_1       -> ba.emit;
     (*39:*) if_icmpge     -> ba.emit; 78-39 -> ba.emitShort;
     (*42:*) new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*45:*) _dup          -> ba.emit;
     (*46:*) new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*49:*) _dup          -> ba.emit;
     (*50:*) invokespecial -> ba.emit; 
     (*51:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*53:*) 'Repetition subrange out of bounds (high): ' -> ba.emitLoadString;
     (*55:*) invokevirtual -> ba.emit; 
     (*56:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*58:*) iload_1       -> ba.emit;
     (*59:*) invokevirtual -> ba.emit; 
     (*60:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*62:*) '>' -> ba.emitLoadString;
     (*64:*) invokevirtual -> ba.emit; 
     (*65:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*67:*) iload_2       -> ba.emit;
     (*68:*) invokevirtual -> ba.emit; 
     (*69:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*71:*) invokevirtual -> ba.emit; 
     (*72:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*74:*) invokespecial -> ba.emit; 
     (*75:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*77:*) athrow        -> ba.emit;
     (*78:*) _return       -> ba.emit;
     
     ba.emitToFile(# access_flags::(# do value %Bor ACC_ABSTRACT -> value #)#);
     
  #);

GenerateJvmClassComponent:
  (* Called when BetaObject has just been generated.
   * Generate Component.class in the same directory.
   *)
  (# 
     (*
      * package beta;
      * 
      * public class Component extends Thread
      * { static Component current;
      *     Component caller;
      *     BetaObject body;
      * 
      *     Component(BetaObject b) { 
      * 	body = b; 
      * 	setDaemon(true); 
      * 	b.comp$ = this; 
      *         caller = this;
      *     }
      * 
      *     synchronized public void swap()
      *     { 
      * 	trace("Component:swap");
      * 	Component X;
      * 	X = current;
      * 	current = caller;
      * 	caller = X;
      * 	if (!isAlive()) start(); // only relevant if attach
      * 	else notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     }
      *     synchronized void att()
      *     { 
      * 	trace("Component:att");
      * 	caller = current;
      * 	current = this;
      * 	if (!isAlive()) start();
      * 	else notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     }
      *     
      *     synchronized void susp()
      *     { 
      * 	trace("Component:susp");
      * 	current = caller;
      * 	notify();
      * 	try{ wait(); } catch (InterruptedException e){}
      *     } 
      * 
      *     public void run() 
      *     { 
      * 	trace("Component:run");
      * 	body.xdo();
      * 	trace("Component:terminated");
      * 	synchronized(this) { notify();};
      *     }
      *     public void trace(String T)
      *     { 
      * 	if (false) System.out.println(T);
      *     }
      * }
      *)
     
     comp: ^JavaImage;
     e: @diskentry;
     fn: ^text;
     sig: ^text;
  do &JavaImage[] -> comp[];
     jcf.traceClassFileName -> comp.traceClassFileName;
     jcf.traceClassFile -> comp.traceClassFile;
     jcf.cf.name -> e.path; (* betaenv.class full path *)
     e.path.head -> fn[]; (* directory of betaenv.class full path *)
     DirectoryChar -> fn.put;
     'Component.class' -> fn.append;
     fn[] -> comp.init;
     (* Class file ready to start emitting to *)
     
     common.ComponentClass
       -> comp.constant_pool.classes.addtext
       -> comp.thisClassIndex;
     'java/lang/Thread'
       -> comp.constant_pool.classes.addtext 
       -> comp.superClassIndex;
     
     ('current', common.ComponentClass->textToClassRef)  -> comp.fields.addtext_static;
     ('caller',  common.ComponentClass->textToClassRef)  -> comp.emitFieldDef;
     ('body',    common.BetaObjectClass->textToClassRef) -> comp.emitFieldDef;
     
     '' -> sig[];
     '(L%s;)V' -> sig.putformat(# do common.BetaObjectClass->s #);
     (ACC_PUBLIC, '<init>', sig[], 2,  4) -> comp.currentmethod.new;
     aload_0       -> comp.emit;
     invokespecial -> comp.emit; ('java/lang/Thread', '<init>', '()V') -> comp.emitMethodRef;
     aload_0       -> comp.emit;
     aload_1       -> comp.emit;
     putfield      -> comp.emit; (common.ComponentClass, 'body', common.BetaObjectClass->textToClassRef) -> comp.emitFieldRef;
     aload_0       -> comp.emit;
     iconst_1      -> comp.emit;
     invokevirtual -> comp.emit; (common.ComponentClass, 'setDaemon', '(Z)V') -> comp.emitMethodRef;
     aload_1       -> comp.emit;
     aload_0       -> comp.emit;
     putfield      -> comp.emit; (common.BetaObjectClass, 'comp$', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     aload_0       -> comp.emit;
     aload_0       -> comp.emit;
     putfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     _return       -> comp.emit;
     
     (ACC_PUBLIC %Bor ACC_SYNCHRONIZED, 'swap', '()V', 2,  3) -> comp.currentmethod.new;
     (* 0:*) getstatic     -> comp.emit; (common.ComponentClass, 'current', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (* 3:*) astore_1      -> comp.emit;
     (* 4:*) aload_0       -> comp.emit;
     (* 5:*) getfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (* 8:*) putstatic     -> comp.emit; (common.ComponentClass, 'current', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (*11:*) aload_0       -> comp.emit;
     (*12:*) aload_1       -> comp.emit; 
     (*13:*) putfield      -> comp.emit; (common.ComponentClass, 'caller', common.ComponentClass->textToClassRef) -> comp.emitFieldRef;
     (*16:*) aload_0       -> comp.emit; 
     (*17:*) invokevirtual -> comp.emit; (common.ComponentClass, 'isAlive', '()Z') -> comp.emitMethodRef;
     (*20:*) ifne          -> comp.emit; 30-20 -> comp.emitShort; 
     (*23:*) aload_0       -> comp.emit; 
     (*24:*) invokevirtual -> comp.emit; (common.ComponentClass, 'start', '()V') -> comp.emitMethodRef;
     (*27:*) goto          -> comp.emit; 34-27 -> comp.emitShort; 
     (*30:*) aload_0       -> comp.emit; 
     (*31:*) invokevirtual -> comp.emit; ('java/lang/Object', 'notify', '()V') -> comp.emitMethodRef;
     (*34:*) aload_0       -> comp.emit; 
     (*35:*) invokevirtual -> comp.emit; ('java/lang/Object', 'wait', '()V') -> comp.emitMethodRef;
     (*38:*) goto          -> comp.emit; 42-38 -> comp.emitShort;
     (*41:*) astore_2      -> comp.emit; 
     (*42:*) _return       -> comp.emit; 
     
     (34 (*start_pc*), 38 (*end_pc*), 41 (*handler_pc*), 'java/lang/InterruptedException') 
       -> comp.emitExceptionHandlerDef;
     
     (ACC_PUBLIC, 'run', '()V', 2,  3) -> comp.currentmethod.new;
     (* 0:*) aload_0       -> comp.emit; 
     (* 1:*) getfield      -> comp.emit; (common.ComponentClass, 'body', common.BetaObjectClass->textToClassRef) -> comp.emitFieldRef;
     (* 4:*) invokevirtual -> comp.emit; (common.BetaObjectClass, 'do', '()V') -> comp.emitMethodRef;
     (* 7:*) aload_0       -> comp.emit; 
     (* 8:*) astore_1      -> comp.emit; 
     (* 9:*) aload_1       -> comp.emit; 
     (*10:*) monitorenter  -> comp.emit; 
     (*11:*) aload_0       -> comp.emit; 
     (*12:*) invokevirtual -> comp.emit; ('java/lang/Object', 'notify', '()V') -> comp.emitMethodRef;
     (*15:*) aload_1       -> comp.emit; 
     (*16:*) monitorexit   -> comp.emit; 
     (*17:*) goto          -> comp.emit; 25-17 -> comp.emitShort;
     (*20:*) astore_2      -> comp.emit; 
     (*21:*) aload_1       -> comp.emit; 
     (*22:*) monitorexit   -> comp.emit; 
     (*23:*) aload_2       -> comp.emit; 
     (*24:*) athrow        -> comp.emit; 
     (*25:*) _return       -> comp.emit; 
     
     (11 (*start_pc*), 17 (*end_pc*), 20 (*handler_pc*), NONE (*finally*)) 
       -> comp.emitExceptionHandlerDef;
     (20 (*start_pc*), 23 (*end_pc*), 20 (*handler_pc*), NONE (*finally*)) 
       -> comp.emitExceptionHandlerDef;
     
     comp.emitToFile;
     
  #);

   emitPrim:
     (# prim,arg: ^text;
        index: @integer;
        sig: ^text;
     enter(prim[],arg[])
     do (if trace_opcodes then
            '  callprim: %s(%s)\n'->screen.putformat(# do prim[]->s; arg[]->s #);
        if);
        (if true 
         // 'new' -> prim.equal then
            new -> jcf.emit;
            (* class name*)
            arg[] -> jcf.emitClassRef;
            _dup -> jcf.emit;
            arg[] -> mstate.class[]; (* ugly *)  
         // 'initSuper' -> prim.equal then
            '(' -> sig[];
            (if not ('-'->arg.equal) then
                (if arg[] = none then
                    (failureTrace,'makeSig-3') -> stop;
                if);
                
                arg[] -> makeSignature -> sig.append;
            if);
            ')V' -> sig.append;
            invokespecial -> jcf.emit;
            (thisSuperName[],'<init>',sig[]) -> jcf.emitMethodRef;
            (*BCstate.fields.emitInit;*)
            (if (subLevel = 0) 
                and 
                (common.betaenv.packagename
                  ->thisClassName.equalNCS) then
                aload_0 -> jcf.emit; (* this(betaenv)[] *)
                putstatic -> jcf.emit;
                (common.betaenv.packagename
                ,'betaenvRef'
                ,common.betaenv.packagename->makeSignature)
                  -> jcf.emitFieldRef;
            if)
         // 'setClass'-> prim.equal then
            arg[] -> mstate.class[]
         // 'init' -> prim.equal  then
            invokespecial -> jcf.emit;
            (mstate.class[], '<init>', arg[]) -> jcf.emitMethodRef;
         // 'AlloS' -> prim.equal then
            arg[] -> slashTodot -> jcf.emitLoadString;
            invokestatic -> jcf.emit;
            ('java/lang/Class' ,'forName', '(Ljava/lang/String;)Ljava/lang/Class;') 
              -> jcf.emitMethodRef;
            invokestatic -> jcf.emit;
            (common.StructureClass, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)'->structureReturnSig) 
              -> jcf.emitMethodRef;
         // 'ObjS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass, 'ObjS', '(Ljava/lang/Object;)'->structureReturnSig)
              -> jcf.emitMethodRef;
         // 'AlloSI' -> prim.equal then
            (* Stack: Structure *)
            (* Call Structure.AlloSI which use reflection to set origin *)
            invokevirtual -> jcf.emit; 
            (common.StructureClass, 'AlloSI', '()Ljava/lang/Object;') 
              -> jcf.emitMethodRef;
         // 'AlloVR4' -> prim.equal 
            
            
         // 'NewVR4' -> prim.equal then
            T_INT -> emitNewArray
         // 'AlloVR2' -> prim.equal 
         // 'NewVR2' -> prim.equal then
            T_SHORT -> emitNewArray  
         // 'AlloVR1' -> prim.equal 
         // 'NewVR1' -> prim.equal then
            T_CHAR -> emitNewArray  
         // 'AlloVRZ' -> prim.equal 
         // 'NewVRZ' -> prim.equal then 
            T_BOOLEAN -> emitNewArray  
         // 'AlloVRB' -> prim.equal 
         // 'NewVRB' -> prim.Equal then 
            T_BYTE -> emitNewArray  
         // 'AlloVR8' -> prim.equal 
         // 'NewVR8' -> prim.equal then
            T_DOUBLE-> emitNewArray  
         // 'NewRR' -> prim.equal
         // 'AlloRR' -> prim.equal then
            (* arg = '[Ltype;' 
             * extract: 'type'
             *)
            (3,arg.length-1) -> arg.sub -> emitAnewArray;
            
         // 'ExtVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR1', '([CI)[C') -> jcf.emitMethodRef; 
         // 'ExtVRB' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVRB', '([BI)[B') -> jcf.emitMethodRef; 
         // 'CopyVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR1', '([C)[C') -> jcf.emitMethodRef; 
         // 'CopySVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR1', '(II[C)[C') 
              -> jcf.emitMethodRef;             
         // 'ExtVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVRZ', '([ZI)[Z') -> jcf.emitMethodRef; 
         // 'CopyVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVRZ', '([Z)[Z') -> jcf.emitMethodRef; 
         // 'CopySVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVRZ', '(II[Z)[Z') 
              -> jcf.emitMethodRef;                         
         // 'ExtVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR2', '([SI)[S') -> jcf.emitMethodRef; 
         // 'CopyVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR2', '([S)[S') -> jcf.emitMethodRef; 
         // 'CopySVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR2', '(II[S)[S') 
              -> jcf.emitMethodRef;             
         // 'ExtVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR4', '([II)[I') -> jcf.emitMethodRef; 
         // 'CopyVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR4', '([I)[I') -> jcf.emitMethodRef; 
         // 'CopySVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR4', '(II[I)[I')
              -> jcf.emitMethodRef;             
         // 'ExtVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR8', '([DI)[D') -> jcf.emitMethodRef; 
         // 'CopyVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR8', '([D)[D') -> jcf.emitMethodRef; 
         // 'CopySVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR8', '(II[D)[D') 
              -> jcf.emitMethodRef; 
         // 'ExtRR' -> prim.equal then
            (* FIXME: possibly use local variables instead of stack, see CopySRR *)
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (* stack: oldrep, add *)
            (* int copysize = array.length;
             * int newsize  = copysize + add;
             * if (newsize<0) newsize = 0;
             * if (copysize>newsize) copysize = newsize;
             *)
            swap              -> jcf.emit;
            dup_x1            -> jcf.emit;
            (* stack: oldrep, add, oldrep *)
            arraylength       -> jcf.emit;
            (* stack: oldrep, add, copysize *)
            dup_x1            -> jcf.emit;
            iadd              -> jcf.emit;
            (* stack: oldrep, copysize, newsize *)
            _dup              -> jcf.emit;
            (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
            (* 3: *) _pop     -> jcf.emit;
            (* 4: *) iconst_0 -> jcf.emit;
            (* 5: *)
            (* stack: oldrep, copysize, newsize *)
            dup2              -> jcf.emit;
            (* stack: oldrep, copysize, newsize, copysize, newsize *)
            (* 0: *) if_icmple-> jcf.emit; 6 -> jcf.emitShort;    
            (* stack: oldrep, copysize, newsize; use copysize=newsize *)
            (* 3: *) swap     -> jcf.emit;
            (* 4: *) _pop     -> jcf.emit;
            (* 5: *) _dup     -> jcf.emit;
            (* 6: *)
            (* stack: oldrep, copysize, newsize *)
            anewarray    -> jcf.emit; arg[] -> jcf.emitClassRef;
            dup_x2       -> jcf.emit;
            swap         -> jcf.emit;
            (* Stack: newrep, oldrep, newrep, copysize *)
            iconst_0     -> jcf.emit;
            dup_x2       -> jcf.emit;
            swap         -> jcf.emit;
            (* Stack: newrep, oldrep, 0, newrep, 0, copysize *)
            invokestatic -> jcf.emit;
            ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
            (* Stack: newrep *)
            
         // 'CopyRR' -> prim.equal then
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (# loc_oldrep, loc_size, loc_newrep: @integer;
            do (* int size = array.length;
                * if (size<0) size = 0;
                *)
               allocLocal -> loc_oldrep;
               allocLocal -> loc_size;
               allocLocal -> loc_newrep;
               _dup       -> jcf.emit;
               loc_oldrep -> astoreLocal;
               arraylength-> jcf.emit;
               loc_size   -> storeLocal;
               loc_size   -> loadLocal;
               anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
               loc_newrep -> astoreLocal;
               loc_oldrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_newrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_size   -> loadLocal;
               (* Stack: oldrep, 0, newrep, 0, size *)
               invokestatic -> jcf.emit;
               ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
               loc_newrep -> aloadLocal; (* push result *)
               loc_oldrep -> releaseLocal;
               loc_newrep -> releaseLocal;
               loc_size -> releaseLocal;
            #);
            
         // 'CopySRR' -> prim.equal then
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (* Stack: low, high, oldrep *)
            (# loc_low, loc_high, loc_oldrep, loc_newsize, loc_newrep: @integer;
            do allocLocal -> loc_low;
               allocLocal -> loc_high;
               allocLocal -> loc_oldrep;
               loc_oldrep -> astoreLocal;
               loc_high   -> storeLocal;
               loc_low    -> storeLocal;
               (* CkSR(low, high, oldrep.length); *)
               loc_low    -> loadLocal;
               loc_high   -> loadLocal;
               loc_oldrep -> aloadLocal;
               arraylength-> jcf.emit;
               invokestatic -> jcf.emit; (common.BetaArrayClass, 'CkSR', '(III)V') -> jcf.emitMethodRef;
               (* int newsize = high - (low-1);
                * if (newsize<0) newsize = 0;
                *)
               loc_high -> loadLocal;
               loc_low  -> loadLocal;
               iconst_1 -> jcf.emit;
               isub     -> jcf.emit;
               _dup     -> jcf.emit;
               loc_low  -> storeLocal; (* loc_low = low-1 *)
               isub     -> jcf.emit;
               _dup     -> jcf.emit;
               (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
               (* 3: *) _pop     -> jcf.emit; 
               (* 4: *) iconst_0 -> jcf.emit;
               (* 5: *)
               allocLocal -> loc_newsize -> storeLocal;
               loc_newsize -> loadLocal;
               anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
               allocLocal -> loc_newrep -> astoreLocal;
               loc_oldrep -> aloadLocal;
               loc_low    -> loadLocal;
               loc_newrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_newsize-> loadLocal;
               (* stack: oldrep, low-1, newrep, 0, newsize *)
               invokestatic -> jcf.emit;
               ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
                 -> jcf.emitMethodRef;
               loc_newrep -> aloadLocal; (* push result *)
               loc_newrep -> releaseLocal;
               loc_oldrep -> releaseLocal;
               loc_high   -> releaseLocal;
               loc_low    -> releaseLocal;
               loc_newsize-> releaseLocal;
            #);
            
         // 'Text2CharArray' -> prim.equal then
            invokevirtual -> jcf.emit;
            ('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
         // 'CharArray2String' -> prim.equal then
            new -> jcf.emit;
            'java/lang/String' -> jcf.emitClassRef;
            dup_x1 -> jcf.emit;
            swap -> jcf.emit;
            invokespecial -> jcf.emit;
            ('java/lang/String', '<init>', '([C)V') -> jcf.emitMethodRef;
         // 'ExternalString2BetaText' -> prim.equal then
            (* Note! Hardcoding of pattern 'text'
             * including case, etc. Should be handled
             * more generally
             *)
            (# sig: ^text;
            do ''->sig[];
               '(L%s;)V' -> sig.putformat(# do common.betaenv.packagename->s #);
               (* Stack: String or null *)
               _dup -> jcf.emit;
               (*  0: *)ifnull -> jcf.emit; 23-0 -> jcf.emitShort;
               (*  3: *)invokevirtual -> jcf.emit;
               (*  4: *)('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
               (*  6: *)new -> jcf.emit;
               (*  7: *)'text'->(common.BetaPackage).append -> jcf.emitClassRef;
               (*  9: *)dup_x1 -> jcf.emit;
               (* 10: *)dup_x1 -> jcf.emit;
               (* 11: *)loadbetaenv;
               (* 14: *)invokespecial -> jcf.emit; 
               (* 15: *)('text'->(common.BetaPackage).append, '<init>', sig[]) -> jcf.emitMethodRef;
               (* 17: *)invokevirtual -> jcf.emit; 
               (* 18: *)('text'->(common.BetaPackage).append, common.enterMethod, '([C)V') -> jcf.emitMethodRef; 
               (* 20: *)goto -> jcf.emit; 25-20 -> jcf.emitshort;
               (* 23: *)_pop -> jcf.emit; (* FIXME: pop *String*  null to satisfy verifier *)
               (* 24: *)aconst_null -> jcf.emit; (* Push *beta.Text* null *)
               (* 25: *)(* Stack: beta.Text or null *)
            #);
         // 'BetaText2ExternalString' -> prim.equal then
            (* Stack: text *)
            new -> jcf.emit;
            'java/lang/String' -> jcf.emitClassRef; (* Stack: text, String *)
            dup_x1 -> jcf.emit; (* Stack: String, text, String *)
            swap -> jcf.emit; (* Stack: String, String, text *)
            _dup -> jcf.emit; (* Stack: String, String, text, text *)
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef;
            swap -> jcf.emit; (* Stack: String, String, T, text *)
            bipush -> jcf.emit; 0 -> jcf.emit; 
            swap -> jcf.emit; (* Stack: String, String, T, 0, text *)
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'lgth', 'I') -> jcf.emitFieldRef; 
            (* Stack: String, String, T, 0, T.lgth *)
            invokespecial -> jcf.emit;
            ('java/lang/String', '<init>', '([CII)V') 
              -> jcf.emitMethodRef;
            (* Stack: String *)
         // 'BetaText2BetaCharArray' -> prim.equal then
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef; 
            
         // 'char2rep' -> prim.equal then
            (* a single char is on the stack;
             * create a new char array of length 1
             * and store the char in the array;
             * and return the array;
             * Before: ... ch
             * After : ... array,array,index(0),ch
             *)
            bipush -> jcf.emit; 1 -> jcf.emit; 
            T_CHAR -> emitNewArray;
            dup_x1 -> jcf.emit;    
            swap -> jcf.emit;                 (* ... array,array,ch *)
            bipush -> jcf.emit; 0 -> jcf.emit;
            swap -> jcf.emit;                 (* ... array,array,0,ch *)
            castore -> jcf.emit;
         // 'eqS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'eqS', structureCompareSig) -> jcf.emitMethodRef;
         // 'neS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'neS', structureCompareSig) -> jcf.emitMethodRef;
         // 'ltS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'ltS', structureCompareSig) -> jcf.emitMethodRef;
         // 'leS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'leS', structureCompareSig) -> jcf.emitMethodRef;
         // 'gtS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'gtS', structureCompareSig) -> jcf.emitMethodRef;
         // 'geS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'geS', structureCompareSig) -> jcf.emitMethodRef;
         // 'Att' -> prim.equal then
            getfield  -> jcf.emit; 
            (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
              -> jcf.emitFieldRef; 
            
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') 
              -> jcf.emitMethodRef;
            
         // 'Susp' -> prim.equal then
            getstatic -> jcf.emit;
            (Common.ComponentClass, 'current', common.ComponentClass->makeSignature)
              -> jcf.emitFieldRef;
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
            
         // 'SuspX' -> prim.equal then
            getfield  -> jcf.emit; 
            (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
              -> jcf.emitFieldRef; 
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
            
         // 'AlloC' -> prim.equal then
            (* Generate new Comp-object - constructor takes care of se4tup *)
            (# sig: ^text;
            do &text[] -> sig[];
               (if true then
                   'AlloC'           -> jcf.emitLoadString;
                   _pop              -> jcf.emit;
               if);
               _dup                  -> jcf.emit;
               new                   -> jcf.emit;
               common.ComponentClass -> jcf.emitClassRef;
               swap                  -> jcf.emit;
               invokespecial         -> jcf.emit;
               '(L%s;)V'-> sig.putformat(# do common.BetaObjectClass -> s #);
               (common.ComponentClass, '<init>', sig[]) 
                 -> jcf.emitMethodRef; 
            #);
         // 'setup' -> prim.equal then;
            aload_0 -> jcf.emit;                       
            getfield  -> jcf.emit;
            (thisClassName[]
            , 'origin'
            , arg.copy->makeSignature)
              -> jcf.emitFieldRef; 
            
            newBetaEnv;
            
            putfield  -> jcf.emit;
            (arg[], 'origin'
            , common.betaenv.packagename->makeSignature)
              -> jcf.emitFieldRef; 
         // 'initArgs' -> prim.equal then
            (# BCmch: ^ByteCodeMachine;
               program_name, sig: ^text;
               trace: (# exit false #);
            do (* Find program name *)
               (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> program_name[];
               (* Generate signature for SetArgValues, 
                * which is declared in betaenv_jvmbody
                *)
               ''->sig[];
               '(L%s;Ljava/lang/String;[Ljava/lang/String;)V' 
                 -> sig.putformat(# do common.betaenv.packagename->s #);
               (* First argument (betanev instance) loaded by dup in genMain *)
               (* load program name *)
               program_name[] -> jcf.emitLoadString;
               (if trace then
                   'Trace(main): Number of Arguments: ' -> jcf.emitLoadString;
                   getstatic -> jcf.emit;
                   ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                   swap -> jcf.emit;
                   invokevirtual -> jcf.emit;
                   ('java/io/PrintStream', 'print', '(Ljava/lang/String;)V') 
                     -> jcf.emitMethodRef;
                   aload_0 -> jcf.emit; 
                   arraylength -> jcf.emit;
                   getstatic -> jcf.emit;
                   ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                   swap -> jcf.emit;
                   invokevirtual -> jcf.emit;
                   ('java/io/PrintStream', 'println', '(I)V') 
                     -> jcf.emitMethodRef;
               if);
               (* load args[] of main() *)
               aload_0 -> jcf.emit; 
               (* Call SetArgValues, which copies main.args to betaenv.ArgVector 
                * with conversion String->Text of each element
                *)
               invokestatic -> jcf.emit;
               ('SetArgValues'->(common.BetaPackage).append, 'SetArgValues', sig[]) 
                 -> jcf.emitMethodRef
            #);
         // 'NotImplemented' -> prim.equal then
            getstatic -> jcf.emit;
            ('java/lang/System', 'out', 'Ljava/io/PrintStream;')
              ->jcf.emitFieldRef;            
            '\n\n'-> ('\n\n*** ERROR: ' -> arg.prepend).append 
              -> mstate.jcf.emitLoadString;
            invokevirtual -> jcf.emit; 
            (* not sure if this works *)
            ('java/io/PrintStream','print','(Ljava/lang/String;)V')
              -> jcf.emitMethodRef;
         else
            'Primitive: '->commentstream.puttext; 
            prim[] -> commentstream.puttext; 
            ' ' ->commentstream.put;
            arg[] -> commentstream.puttext;
            '\nUnknown primitive:'->puttext;
            prim[] -> puttext; ' proto: '->puttext;
            arg[] -> putline
        if);
     #);

