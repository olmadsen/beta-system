ORIGIN 'BCmachineBody';
INCLUDE '~beta/basiclib/formatio'; 

(* Support classes needed by the generated Java code.
 * Generated as part of compiling basic BETA environment.
 *)

--BCmachineLib: attributes--

GenerateClassExOException:
  (* Called when BetaObject has just been generated.
   * Generate ExOException.class in the same directory.
   *)
  (# exo: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> exo[];
     jcf.traceClassFileName -> exo.traceClassFileName;
     jcf.traceClassFile -> exo.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'ExOException.class' -> fn.append;
     fn[] -> exo.init;
     (* Class file ready to start emitting to *)
     
     'ExOException'
       -> exo.constant_pool.classes.addtext
       -> exo.thisClassIndex;
     'java/lang/Exception'
       -> exo.constant_pool.classes.addtext 
       -> exo.superClassIndex;
     
     ('exitobj', 'Ljava/lang/Object;') -> exo.emitFieldDef;
     ('labno', 'I')                    -> exo.emitFieldDef;
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;I)V', 2,  4) -> exo.currentmethod.new;
     aload_0       -> exo.emit;
     invokespecial -> exo.emit; ('java/lang/Exception', '<init>', '()V') -> exo.emitMethodRef;
     aload_0       -> exo.emit;
     aload_1       -> exo.emit;
     putfield      -> exo.emit; ('ExOException', 'exitobj', 'Ljava/lang/Object;') -> exo.emitFieldRef;
     aload_0       -> exo.emit;
     iload_2       -> exo.emit;
     putfield      -> exo.emit; ('ExOException', 'labno', 'I') -> exo.emitFieldRef;
     _return       -> exo.emit;
     
     exo.emitToFile;
     
     (*(fn[],false,asmLink.objKind,false) -> putInJobFile;*)
  #);

GenerateClassStructure:
  (# struc: ^JavaImage;
     e: @diskentry;
     fn: ^text;
  do &JavaImage[] -> struc[];
     jcf.traceClassFileName -> struc.traceClassFileName;
     jcf.traceClassFile -> struc.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'Structure.class' -> fn.append;
     fn[] -> struc.init;
     (* Class file ready to start emitting to *)
     
     'FIXME: Structures need an OriginOff argument' -> screen.putline;
     
     'Structure'
       -> struc.constant_pool.classes.addtext
       -> struc.thisClassIndex;
     'java/lang/Object'
       -> struc.constant_pool.classes.addtext 
       -> struc.superClassIndex;
     
     ('iOrigin', 'Ljava/lang/Object;')                    -> struc.emitPrivateFieldDef;
     ('iProto', 'Ljava/lang/Class;')                      -> struc.emitPrivateFieldDef;
     ('iConstructor', 'Ljava/lang/reflect/Constructor;')  -> struc.emitPrivateFieldDef; 
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V', 2,  3) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokespecial -> struc.emit; ('java/lang/Object', '<init>', '()V') -> struc.emitMethodRef;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     putfield      -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aload_2       -> struc.emit;
     putfield      -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     aload_0       -> struc.emit;
     aconst_null   -> struc.emit;
     putfield      -> struc.emit; ('Structure', 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     _return       -> struc.emit;
     
     (* Method: AlloS *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)LStructure;', 4,  2) -> struc.currentmethod.new;
     new           -> struc.emit; 'Structure' -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_0       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; ('Structure', '<init>',  '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;

     (* Method: ObjS *)
     (*     public static Structure ObjS(Object o)
      * 	throws Exception
      *     {
      * 	Class proto = o.getClass();
      * 	Field origin_field;
      * 	Object origin;
      * 	origin_field = proto.getDeclaredField("origin");
      * 	origin = origin_field.get(o);
      * 	return new Structure(origin, proto);
      *     }
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'ObjS', '(Ljava/lang/Object;)LStructure;', 4,  5) -> struc.currentmethod.new;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     astore_1      -> struc.emit;
     aload_1       -> struc.emit;
     'origin'      -> struc.emitLoadString;
     invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef;
     astore_2      -> struc.emit;
     aload_2       -> struc.emit;
     aload_0       -> struc.emit;
     invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     astore_3      -> struc.emit;
     new           -> struc.emit; 'Structure' -> struc.emitClassRef;
     _dup          -> struc.emit;
     aload_3       -> struc.emit;
     aload_1       -> struc.emit;
     invokespecial -> struc.emit; ('Structure', '<init>', '(Ljava/lang/Object;Ljava/lang/Class;)V') -> struc.emitMethodRef;
     areturn       -> struc.emit;
     
     (* Method: AlloSI *)
     (*     public Object AlloSI() throws Exception
      *     {
      * 	Constructor[] constructors = iProto.getDeclaredConstructors();
      * 	if (iConstructor == null){
      * 	    search:
      * 	    for (int i = 0; i < constructors.length; i++) {
      * 		Class[] parameterTypes = constructors[i].getParameterTypes();
      * 		if (parameterTypes.length == 1){
      * 		    if (parameterTypes[0].isAssignableFrom(iOrigin.getClass())){
      * 			iConstructor = constructors[i];
      * 			break search;
      * 		    }
      * 		}
      * 	    }
      * 	}
      * 	return iConstructor.newInstance(new Object[]{iOrigin});
      *     }
      *)
     (ACC_PUBLIC, 'AlloSI', '()Ljava/lang/Object;', 5,  4) -> struc.currentmethod.new;
     (*  0:*) aload_0       -> struc.emit;
     (*  1:*) getfield      -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (*  4:*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredConstructors', '()[Ljava/lang/reflect/Constructor;') -> struc.emitMethodRef;
     (*  7:*) astore_1      -> struc.emit;
     (*  8:*) aload_0       -> struc.emit;
     (*  9:*) getfield      -> struc.emit; ('Structure', 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 12:*) ifnonnull     -> struc.emit; 68-12 -> struc.emitShort;
     (* 15:*) iconst_0      -> struc.emit;
     (* 16:*) istore_2      -> struc.emit;
     (* 17:*) goto          -> struc.emit; 62-17 -> struc.emitShort;
     (* 20:*) aload_1       -> struc.emit;
     (* 21:*) iload_2       -> struc.emit;
     (* 22:*) aaload        -> struc.emit;
     (* 23:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'getParameterTypes', '()[Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 26:*) astore_3      -> struc.emit;
     (* 27:*) aload_3       -> struc.emit;
     (* 28:*) arraylength   -> struc.emit;
     (* 29:*) iconst_1      -> struc.emit;
     (* 30:*) if_icmpne     -> struc.emit; 59-30 -> struc.emitShort;
     (* 33:*) aload_3       -> struc.emit;
     (* 34:*) iconst_0      -> struc.emit;
     (* 35:*) aaload        -> struc.emit;
     (* 36:*) aload_0       -> struc.emit;
     (* 37:*) getfield      -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 40:*) invokevirtual -> struc.emit; ('java/lang/Object', 'getClass', '()Ljava/lang/Class;') -> struc.emitMethodRef;
     (* 43:*) invokevirtual -> struc.emit; ('java/lang/Class', 'isAssignableFrom', '(Ljava/lang/Class;)Z') -> struc.emitMethodRef;
     (* 46:*) ifeq          -> struc.emit; 59-46 -> struc.emitShort;
     (* 49:*) aload_0       -> struc.emit;
     (* 50:*) aload_1       -> struc.emit;
     (* 51:*) iload_2       -> struc.emit;
     (* 52:*) aaload        -> struc.emit;
     (* 53:*) putfield      -> struc.emit; ('Structure', 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 56:*) goto          -> struc.emit; 68-56 -> struc.emitShort;
     (* 59:*) iinc          -> struc.emit; 2 -> struc.emit; 1-> struc.emit; 
     (* 62:*) iload_2       -> struc.emit;
     (* 63:*) aload_1       -> struc.emit;
     (* 64:*) arraylength   -> struc.emit;
     (* 65:*) if_icmplt     -> struc.emit; 20-65 -> struc.emitShort;
     (* 68:*) aload_0       -> struc.emit;
     (* 69:*) getfield      -> struc.emit; ('Structure', 'iConstructor', 'Ljava/lang/reflect/Constructor;') -> struc.emitFieldRef;
     (* 72:*) iconst_1      -> struc.emit;
     (* 73:*) anewarray     -> struc.emit; 'java/lang/Object' -> struc.emitClassRef;
     (* 76:*) _dup          -> struc.emit;
     (* 77:*) iconst_0      -> struc.emit;
     (* 78:*) aload_0       -> struc.emit;
     (* 79:*) getfield      -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 82:*) aastore       -> struc.emit;
     (* 83:*) invokevirtual -> struc.emit; ('java/lang/reflect/Constructor', 'newInstance', '([Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef;
     (* 86:*) areturn       -> struc.emit;
     
     (* Method: eqS *)
     (*     public static boolean eqS(Structure arg1, Structure arg2)
      *     {
      * 	if (arg1==null) {
      * 	    if (arg2==null)
      * 		return true;
      * 	    return false;
      * 	}
      * 	if (arg2==null)
      * 	    return false;
      * 	if (arg1.iProto != arg2.iProto)
      * 	    return false;
      * 	if (arg1.iOrigin != arg2.iOrigin)
      * 	    return false;
      * 	return true;
      *     }
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'eqS', '(LStructure;LStructure;)Z', 2,  2) -> struc.currentmethod.new;
     (* 0: *) aload_0   -> struc.emit;
     (* 1: *) ifnonnull -> struc.emit; 12-1 -> struc.emitShort;
     (* 4: *) aload_1   -> struc.emit;
     (* 5: *) ifnonnull -> struc.emit; 10-5 -> struc.emitShort;
     (* 8: *) iconst_1  -> struc.emit;
     (* 9: *) ireturn   -> struc.emit;
     (* 10:*) iconst_0  -> struc.emit;
     (* 11:*) ireturn   -> struc.emit;
     (* 12:*) aload_1   -> struc.emit;
     (* 13:*) ifnonnull -> struc.emit; 18-13 -> struc.emitShort;
     (* 16:*) iconst_0  -> struc.emit;
     (* 17:*) ireturn   -> struc.emit;
     (* 18:*) aload_0   -> struc.emit;
     (* 19:*) getfield  -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 22:*) aload_1   -> struc.emit;
     (* 23:*) getfield  -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef;
     (* 26:*) if_acmpeq -> struc.emit; 31-26 -> struc.emitShort;
     (* 29:*) iconst_0  -> struc.emit;
     (* 30:*) ireturn   -> struc.emit;
     (* 31:*) aload_0   -> struc.emit;
     (* 32:*) getfield  -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 35:*) aload_1   -> struc.emit;
     (* 36:*) getfield  -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef;
     (* 39:*) if_acmpeq -> struc.emit; 44-39 -> struc.emitShort;
     (* 42:*) iconst_0  -> struc.emit;
     (* 43:*) ireturn   -> struc.emit;
     (* 44:*) iconst_1  -> struc.emit;
     (* 45:*) ireturn   -> struc.emit;
     
     (* Method: neS *)
     (*     public static boolean neS(Structure arg1, Structure arg2)
      *     {
      * 	return !eqS(arg1, arg2);
      *     }
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'neS', '(LStructure;LStructure;)Z', 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; ('Structure', 'eqS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 12-5 -> struc.emitShort;
     (* 8:*) iconst_1     -> struc.emit; 
     (* 9:*) goto         -> struc.emit; 13-9 -> struc.emitShort;
     (*12:*) iconst_0     -> struc.emit; 
     (*13:*) ireturn      -> struc.emit; 
     
     (* Method: leS *)
     (*     public static boolean leS(Structure arg1, Structure arg2)
      *     { 
      * 	return (eqS(arg1, arg2) || ltS(arg1, arg2));
      *     }
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'leS', '(LStructure;LStructure;)Z', 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; ('Structure', 'eqS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; ('Structure', 'ltS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort;
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: geS *)
     (*     public static boolean geS(Structure arg1, Structure arg2)
      *     { 
      * 	return (eqS(arg1, arg2) || gtS(arg1, arg2));
      *     }     
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'geS', '(LStructure;LStructure;)Z', 2,  2) -> struc.currentmethod.new;
     (* 0:*) aload_0      -> struc.emit; 
     (* 1:*) aload_1      -> struc.emit; 
     (* 2:*) invokestatic -> struc.emit; ('Structure', 'eqS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (* 5:*) ifne         -> struc.emit; 16-5 -> struc.emitShort;
     (* 8:*) aload_0      -> struc.emit; 
     (* 9:*) aload_1      -> struc.emit; 
     (*10:*) invokestatic -> struc.emit; ('Structure', 'gtS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (*13:*) ifeq         -> struc.emit; 20-13 -> struc.emitShort; 
     (*16:*) iconst_1     -> struc.emit; 
     (*17:*) goto         -> struc.emit; 21-17 -> struc.emitShort;
     (*20:*) iconst_0     -> struc.emit; 
     (*21:*) ireturn      -> struc.emit; 
     
     (* Method: gtS *)
     (*     public static boolean gtS(Structure arg1, Structure arg2)
      *     {
      * 	return ltS(arg2, arg1);
      *     }
      *)
     (ACC_PUBLIC %Bor ACC_STATIC, 'gtS', '(LStructure;LStructure;)Z', 2,  2) -> struc.currentmethod.new;
     (*0:*) aload_1       -> struc.emit; 
     (*1:*) aload_0       -> struc.emit; 
     (*2:*) invokestatic  -> struc.emit; ('Structure', 'ltS', '(LStructure;LStructure;)Z') -> struc.emitMethodRef;
     (*5:*) ireturn       -> struc.emit; 
     
     (* Method: ltS *)
     (*     public static boolean ltS(Structure arg1, Structure arg2)
      *     throws Exception
      *     {
      * 	if (arg1==null) return false;
      * 	if (arg2==null) return false;
      * 	Class proto1 = arg1.iProto;
      * 	Class proto2 = arg2.iProto;
      * 	if (proto1 == proto2) return false;
      * 	/* Prefix of proto1 is the first try */
      * 	for (proto1 = proto1.getSuperclass();
      * 	     proto1 != null; /* proto1 != Object## */
      * 	     proto1 = proto1.getSuperclass()) {
      * 	    if (proto1 == proto2) {
      * 		if (false /*identical originoff's*/){
      * 		    return arg1.iOrigin == arg2.iOrigin;
      * 		}
      * 		Object newObject = arg1.AlloSI();
      * 		Field origin_field = proto1.getDeclaredField("origin");
      * 		return origin_field.get(newObject) == arg2.iOrigin;
      * 	    }
      * 	}
      * 	return false; 
      *     }
      *)     
     (ACC_PUBLIC %Bor ACC_STATIC, 'ltS', '(LStructure;LStructure;)Z', 2,  6) -> struc.currentmethod.new;
     (* 0*) aload_0       -> struc.emit; 
     (* 1*) ifnonnull     -> struc.emit; 6-1 -> struc.emitShort;
     (* 4*) iconst_0      -> struc.emit; 
     (* 5*) ireturn       -> struc.emit; 
     (* 6*) aload_1       -> struc.emit; 
     (* 7*) ifnonnull     -> struc.emit; 12-7 -> struc.emitShort;
     (*10*) iconst_0      -> struc.emit; 
     (*11*) ireturn       -> struc.emit; 
     (*12*) aload_0       -> struc.emit; 
     (*13*) getfield      -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*16*) astore_2      -> struc.emit; 
     (*17*) aload_1       -> struc.emit; 
     (*18*) getfield      -> struc.emit; ('Structure', 'iProto', 'Ljava/lang/Class;') -> struc.emitFieldRef; 
     (*21*) astore_3      -> struc.emit; 
     (*22*) aload_2       -> struc.emit; 
     (*23*) aload_3       -> struc.emit; 
     (*24*) if_acmpne     -> struc.emit; 29-24 -> struc.emitShort; 
     (*27*) iconst_0      -> struc.emit; 
     (*28*) ireturn       -> struc.emit; 
     (*29*) aload_2       -> struc.emit; 
     (*30*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*33*) astore_2      -> struc.emit; 
     (*34*) goto          -> struc.emit; 81-34 -> struc.emitShort; 
     (*37*) aload_2       -> struc.emit; 
     (*38*) aload_3       -> struc.emit; 
     (*39*) if_acmpne     -> struc.emit; 76-39 -> struc.emitShort; 
     (*42*) aload_0       -> struc.emit; 
     (*43*) invokevirtual -> struc.emit; ('Structure', 'AlloSI', '()Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*46*) astore        -> struc.emit; 4 -> struc.emit; 
     (*48*) aload_2       -> struc.emit; 
     (*49*) 'origin'      -> struc.emitLoadString;
     (*51*) invokevirtual -> struc.emit; ('java/lang/Class', 'getDeclaredField', '(Ljava/lang/String;)Ljava/lang/reflect/Field;') -> struc.emitMethodRef; 
     (*54*) astore        -> struc.emit; 5 -> struc.emit;
     (*56*) aload         -> struc.emit; 5 -> struc.emit;
     (*58*) aload         -> struc.emit; 4 -> struc.emit;
     (*60*) invokevirtual -> struc.emit; ('java/lang/reflect/Field', 'get', '(Ljava/lang/Object;)Ljava/lang/Object;') -> struc.emitMethodRef; 
     (*63*) aload_1       -> struc.emit; 
     (*64*) getfield      -> struc.emit; ('Structure', 'iOrigin', 'Ljava/lang/Object;') -> struc.emitFieldRef; 
     (*67*) if_acmpne     -> struc.emit; 74-67 -> struc.emitShort; 
     (*70*) iconst_1      -> struc.emit; 
     (*71*) goto          -> struc.emit; 75-71 -> struc.emitShort; 
     (*74*) iconst_0      -> struc.emit; 
     (*75*) ireturn       -> struc.emit; 
     (*76*) aload_2       -> struc.emit; 
     (*77*) invokevirtual -> struc.emit; ('java/lang/Class', 'getSuperclass', '()Ljava/lang/Class;') -> struc.emitMethodRef; 
     (*80*) astore_2      -> struc.emit; 
     (*81*) aload_2       -> struc.emit; 
     (*82*) ifnonnull     -> struc.emit; 37-82 -> struc.emitShort; 
     (*85*) iconst_0      -> struc.emit; 
     (*86*) ireturn       -> struc.emit;     

     struc.emitToFile;
     
     (*(fn[],false,asmLink.objKind,false) -> putInJobFile;*)
  #);


GenerateClassBetaArray:
  (* Called when BetaObject has just been generated.
   * Generate BetaArray.class in the same directory.
   *)
  (# ba: ^JavaImage;
     e: @diskentry;
     fn: ^text;
     emitExtVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do (*  public static char[] ExtVR1(char[] array, int add) {
           * 	int copysize = array.length;
           * 	int newsize  = copysize + add;
           * 	if (newsize<0) newsize = 0;
           * 	if (copysize>newsize) copysize = newsize;
           * 	char[] newArray = new char[newsize];
           * 	System.arraycopy(array, 0, newArray, 0, copysize);
           * 	return newArray;
           *  }
           *)
          &text[] -> signature[];
          '([%cI)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          aload_0          -> ba.emit;
          arraylength      -> ba.emit;
          istore_2         -> ba.emit;
          iload_2          -> ba.emit;
          iload_1          -> ba.emit;
          iadd             -> ba.emit;
          istore_3         -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) ifge      -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0  -> ba.emit;
          (*4:*) istore_3  -> ba.emit;
          (*5:*) iload_2   -> ba.emit;
          iload_3          -> ba.emit;
          (*0:*) if_icmple -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iload_3   -> ba.emit;
          (*4:*) istore_2  -> ba.emit;
          (*5:*) iload_3   -> ba.emit;
          newarray         -> ba.emit; type -> ba.emit;
          astore           -> ba.emit; 4 -> ba.emit;
          aload_0          -> ba.emit;
          iconst_0         -> ba.emit;
          aload            -> ba.emit; 4 -> ba.emit;
          iconst_0         -> ba.emit;
          iload_2          -> ba.emit;
          invokestatic     -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload            -> ba.emit; 4 -> ba.emit;
          areturn          -> ba.emit;
       #);
     
     emitCopyVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do (* public static char[] CopyVR1(char[] array) {
           *   int size = array.length;
           *   if (size<0) size = 0;
           *   char[] newArray = new char[size];
           *   System.arraycopy(array, 0, newArray, 0, size);
           *   return newArray;
           * }
           *)
          &text[] -> signature[];
          '([%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 3) -> ba.currentmethod.new;
          aload_0         -> ba.emit;
          arraylength     -> ba.emit;
          istore_1        -> ba.emit;
          iload_1         -> ba.emit;
          (*0:*) ifge     -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0 -> ba.emit;
          (*4:*) istore_1 -> ba.emit;
          (*5:*) iload_1  -> ba.emit;
          newarray        -> ba.emit; type -> ba.emit;
          astore_2        -> ba.emit;
          aload_0         -> ba.emit;
          iconst_0        -> ba.emit;
          aload_2         -> ba.emit;
          iconst_0        -> ba.emit;
          iload_1         -> ba.emit;
          invokestatic    -> ba.emit; 
          ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
            -> ba.emitMethodRef;
          aload_2         -> ba.emit;
          areturn         -> ba.emit;          
       #);

     emitCopySVR:
       (# name, signature: ^text;
          descriptor: @char;
          type: @integer;
       enter (name[], descriptor, type)
       do (* public static char[] CopySVR1(int low, int high, char[] array) 
           *     throws ArrayIndexOutOfBoundsException
           * {
           *     CkSR(low, high, array.length);
           *     int newsize = high - low + 1;
           *     if (newsize<0) newsize = 0;
           *     char[] newArray = new char[newsize];
           *     if (newsize>0) System.arraycopy(array, low-1, newArray, 0, newsize);
           *     return newArray;
           * }
           *)          
          &text[] -> signature[];
          '(II[%c)[%c' -> signature.putformat(# do descriptor->c; descriptor->c #);
          (ACC_PUBLIC %Bor ACC_STATIC, name[], signature[], 5, 5) -> ba.currentmethod.new;
          iload_0              -> ba.emit; 
          iload_1              -> ba.emit; 
          aload_2              -> ba.emit; 
          arraylength          -> ba.emit; 
          invokestatic         -> ba.emit; ('BetaArray', 'CkSR', '(III)V') -> ba.emitMethodRef;
          iload_1              -> ba.emit; 
          iload_0              -> ba.emit; 
          isub                 -> ba.emit; 
          iconst_1             -> ba.emit; 
          iadd                 -> ba.emit; 
          istore_3             -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*) ifge          -> ba.emit; 5 -> ba.emitShort;
          (*3:*) iconst_0      -> ba.emit; 
          (*4:*) istore_3      -> ba.emit; 
          (*5:*) iload_3       -> ba.emit; 
          newarray             -> ba.emit; type -> ba.emit;
          astore               -> ba.emit; 4 -> ba.emit; 
          iload_3              -> ba.emit; 
          (*0:*)  ifle         -> ba.emit; 14 -> ba.emitshort; 
          (*3:*)  aload_2      -> ba.emit; 
          (*4:*)  iload_0      -> ba.emit; 
          (*5:*)  iconst_1     -> ba.emit; 
          (*6:*)  isub         -> ba.emit; 
          (*7:*)  aload        -> ba.emit; 4 -> ba.emit; 
          (*9:*)  iconst_0     -> ba.emit; 
          (*10:*) iload_3      -> ba.emit; 
          (*11:*) invokestatic -> ba.emit; ('java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> ba.emitMethodRef;
          (*14:*) aload -> ba.emit; 4 -> ba.emit; 
          areturn -> ba.emit; 
       #);
     
  do &JavaImage[] -> ba[];
     jcf.traceClassFileName -> ba.traceClassFileName;
     jcf.traceClassFile -> ba.traceClassFile;
     jcf.cf.name -> e.path;
     e.path.head -> fn[];
     DirectoryChar -> fn.put;
     'BetaArray.class' -> fn.append;
     fn[] -> ba.init;
     (* Class file ready to start emitting to *)
     
     'BetaArray'
       -> ba.constant_pool.classes.addtext
       -> ba.thisClassIndex;
     'java/lang/Object'
       -> ba.constant_pool.classes.addtext 
       -> ba.superClassIndex;
     
     (* No fields *)
     
     (* Method: <init> *)
     (ACC_PUBLIC, '<init>', '()V', 1,  1) -> ba.currentmethod.new;
     aload_0       -> ba.emit;
     invokespecial -> ba.emit; ('java/lang/Object', '<init>', '()V') -> ba.emitMethodRef;
     _return       -> ba.emit;
     
     ('ExtVRZ', 'Z', T_BOOLEAN)  -> emitExtVR;
     ('ExtVR1', 'C', T_CHAR)     -> emitExtVR;
     ('ExtVR2', 'S', T_SHORT)    -> emitExtVR;
     ('ExtVR4', 'I', T_INT)      -> emitExtVR;
     ('ExtVR8', 'D', T_DOUBLE)   -> emitExtVR;
     
     ('CopyVRZ', 'Z', T_BOOLEAN) -> emitCopyVR;
     ('CopyVR1', 'C', T_CHAR)    -> emitCopyVR;
     ('CopyVR2', 'S', T_SHORT)   -> emitCopyVR;
     ('CopyVR4', 'I', T_INT)     -> emitCopyVR;
     ('CopyVR8', 'D', T_DOUBLE)  -> emitCopyVR;
     
     ('CopySVRZ', 'Z', T_BOOLEAN) -> emitCopySVR;
     ('CopySVR1', 'C', T_CHAR)    -> emitCopySVR;
     ('CopySVR2', 'S', T_SHORT)   -> emitCopySVR;
     ('CopySVR4', 'I', T_INT)     -> emitCopySVR;
     ('CopySVR8', 'D', T_DOUBLE)  -> emitCopySVR;
     
     (* Method: CkSR *)

     (ACC_PUBLIC %Bor ACC_STATIC, 'CkSR', '(III)V', 4,  3) -> ba.currentmethod.new;
     (* public static void CkSR(int low, int high, int range) 
      *     throws ArrayIndexOutOfBoundsException
      * {
      *   // Check that low and high are usable. 
      *   if (low<1) 
      *      throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (low): "
      *                                                + low 
      *                                                + "<1");
      *   if (range<high) 
      *      throw new ArrayIndexOutOfBoundsException("Repetition subrange out of bounds (high): "
      *                                                + high
      *                                                + ">"
      *                                                + range
      *                                                );
      * }
      *) 
     (*0:*)  iload_0       -> ba.emit;
     (*1:*)  iconst_1      -> ba.emit;
     (*2:*)  if_icmpge     -> ba.emit; 37-2 -> ba.emitShort;
     (*5:*)  new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*8:*)  _dup          -> ba.emit;
     (*9:*)  new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*12:*) _dup          -> ba.emit;
     (*13:*) invokespecial -> ba.emit; 
     (*14:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*16:*) 'Repetition subrange out of bounds (low): ' -> ba.emitLoadString;
     (*18:*) invokevirtual -> ba.emit; 
     (*19:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*21:*) iload_0 -> ba.emit;
     (*22:*) invokevirtual -> ba.emit; 
     (*23:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*25:*) '<1' -> ba.emitLoadString;
     (*27:*) invokevirtual -> ba.emit; 
     (*28:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*30:*) invokevirtual -> ba.emit; 
     (*31:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*33:*) invokespecial -> ba.emit; 
     (*34:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*36:*) athrow        -> ba.emit;
     (*37:*) iload_2       -> ba.emit;
     (*38:*) iload_1       -> ba.emit;
     (*39:*) if_icmpge     -> ba.emit; 78-39 -> ba.emitShort;
     (*42:*) new           -> ba.emit; 'java/lang/ArrayIndexOutOfBoundsException' -> ba.emitClassRef;
     (*45:*) _dup          -> ba.emit;
     (*46:*) new           -> ba.emit; 'java/lang/StringBuffer' -> ba.emitClassRef;
     (*49:*) _dup          -> ba.emit;
     (*50:*) invokespecial -> ba.emit; 
     (*51:*) ('java/lang/StringBuffer', '<init>', '()V') -> ba.emitMethodRef;
     (*53:*) 'Repetition subrange out of bounds (high): ' -> ba.emitLoadString;
     (*55:*) invokevirtual -> ba.emit; 
     (*56:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*58:*) iload_1       -> ba.emit;
     (*59:*) invokevirtual -> ba.emit; 
     (*60:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*62:*) '>' -> ba.emitLoadString;
     (*64:*) invokevirtual -> ba.emit; 
     (*65:*) ('java/lang/StringBuffer', 'append', '(Ljava/lang/String;)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*67:*) iload_2       -> ba.emit;
     (*68:*) invokevirtual -> ba.emit; 
     (*69:*) ('java/lang/StringBuffer', 'append', '(I)Ljava/lang/StringBuffer;') -> ba.emitMethodRef;
     (*71:*) invokevirtual -> ba.emit; 
     (*72:*) ('java/lang/StringBuffer', 'toString', '()Ljava/lang/String;') -> ba.emitMethodRef;
     (*74:*) invokespecial -> ba.emit; 
     (*75:*) ('java/lang/ArrayIndexOutOfBoundsException', '<init>', '(Ljava/lang/String;)V') -> ba.emitMethodRef;
     (*77:*) athrow        -> ba.emit;
     (*78:*) _return       -> ba.emit;
     
     ba.emitToFile(# access_flags::(# do value %Bor ACC_ABSTRACT -> value #)#);
     
     (*(fn[],false,asmLink.objKind,false) -> putInJobFile;*)
  #);
