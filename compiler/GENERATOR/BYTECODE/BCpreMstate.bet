ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/toollibs/utils/fileExtensions';

-- machinefactorylib: Attributes --
generateDebugInfo:  (# exit common.switch[41] #);
trace_opcodes: (# exit common.switch[190] #); 

--LIB:attributes--
trace_init_close: (# exit false #);
_checkcast: (# exit 192 #);

makeSignature:
  (# sig: ^text
  enter sig[]
  do (if (1->sig.inxGet) = '[' then
         (* this should really be handled at a higher level *)
      else
         sig[] -> textToClassref -> sig[];
     if)
  exit sig[]
  #);

splitSignature:
  (# signature: ^text;
     name: ^text;
     isStatic: @boolean;
  enter signature[]
  do (* Signature e.g.: java/lang/String/endsWith(Ljava/lang/String;)Z *)
     signature.copy -> signature[];
     &text[] -> name[];
     (if 'static ' -> ((1,7) -> signature.sub).equal then
         true -> isStatic;
         (1,7) -> signature.delete;
     if);
     scan:
       (for i:signature.lgth repeat
            (if signature.T[i]='(' then
                (1,i-1) -> signature.sub -> name[];
                (1,i-1) -> signature.delete;
                leave scan;
            if);
       for);
     INNER;
     (* name:      java/lang/String/endsWith *)
     (* signature: (Ljava/lang/String;)Z     *)
  exit (name[], signature[], isStatic)
  #);
splitClassSignature: SplitSignature
  (# lastSlash: @integer;
     method: ^text;
  do (* name e.g.: java/lang/String/endsWith *)
     &text[] -> method[];
     scan:
       (for i:name.lgth repeat
            (if name.T[i]='(' then leave scan if);
            (if name.T[i]='/' then i->lastSlash if)
       for);
     (if lastSlash>0 then
         (1, lastSlash-1) -> name.sub -> method[];
         (1, lastSlash) -> name.delete;
     if);
  exit method[]
  #);

---byteCode_mstate:descriptor---
(# <<SLOT bytecode_mstatelib:attributes>>;
   
   splitPathAndName:
     (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
        e: @diskentry
     enter orgPath[]
     do orgPath[] -> e.path;
        e.path.head -> path[]; directorychar -> path.put;
        e.path.name.prefix -> FN[];
     exit(path[],FN[])
     #);
   
   mkDepFile:
     (# dep: @file;
     do (* Touch the dep file *)
        '.dep'
          -> (thisSourceFileName[]->(thisFullSourcePath.copy).append).append 
          -> dep.name;
        (*'touching file ' -> screen.puttext; dep.name ->screen.putline;*)
        dep.touch;
     #);
   
   mkClassListFile:
     (# basename: ^text;
        F: @file;
     do thisFullPath.copy -> basename[];
        thisSourceFileName[]->basename.append;
        '.clst'
          -> (basename.copy).append
          -> F.name;
        (if false then
            '\nClassFileName: ' -> screen.puttext; 
            F.name -> screen.puttext; 
            ', Path: '->screen.puttext; 
            ThisFullPath[] -> screen.putline;
        if);
        F.openWrite;
        (* 'opened for write: ' -> screen.puttext; F.name -> screen.putline; *)
        classes.scan
        (# 
        do startPos -> F.putint; 
           ' ' -> F.put;
           endPos -> F.putint;
           ' ' -> F.put;
           current[] (* No extension *) 
             -> (thisFullSourcePath.copy).append 
             -> F.putline;
           (* current[] -> putline *)
        #);
        F.close;
     #);
   
   thisFirstClass,       (* The first class defined will be the main class *)
   
   thisPackagePath,      (* package path *)
   thisFullPath,         (* full path of directory for for 
                          * current object/class file.
                          * On JVM this include package path.
                          *)
   thisFullSourcePath,   (* Full path of directory of current source file *)
   thisSourceFileName,   (* name of current source file *)
   thisFileName,         (* name of current object file  *)
   thisClassName: ^text; (* name of current class 
                          * for java: currentFile = currentClass
                          * for .NET: they may differ
                          *)
   thisSuperName: ^text;
   thisInnerMethodName: ^text;
   thisOrgName, 
   thisSuperOrgName,
   thisModuleName: ^text;
   subLevel: @integer;
   blockLevel: @integer; (* Level of nested Smalltalk blocks used
                          * in leave/restart
                          *)
   methodType: @integer;
   class: ^text;       (* name of class being called - 
                        * used by subsequent init - ugly
                        *)
   isMainMethod: @boolean;
   thisSignature: ^text;
   definingStaticMethod: @boolean; (*true if a static method is being defined*)
   commentStream: ^stream;
   jasmin: @file;
   jasminIsOpen: @boolean;
   lastLocalAllocated:
     (* used by allocAndStoreLocal and just for testing .NET stuff 
      * And never assigned a value here?
      *)
     @integer;
   numTempLocals: @integer;
   
   xLab: @
     (# labno: @integer; lab: ^text
     do 'X' -> lab[];
        labNo + 1 -> labNo -> lab.putint;
     exit lab[]
     #);

   notClosed:  @boolean; 
   
   preF: ^PreCodeBuffer;
   
   PreCodeBuffer: text
     (# emitcomment:
          (# txt: ^Text
          enter txt[]
          do ' ;' -> puttext; 
             txt[] -> puttext;
          #);
        emitsymbol:
          (# sym: ^text
          enter sym[]
          do '#"' -> puttext;
             sym[] -> puttext;
             '"'->put;
          #);
        emitOp:
          (# op: ^text
          enter op[]
          do '\t' -> put;
             op[] -> putline
          #);
        emitsend:
          (# sym: ^text
          enter sym[]
          do '\tsend '->puttext;
             sym[] -> emitsymbol;
             newline;
          #);
        emitsupersend:
          (# sym: ^text
          enter sym[]
          do '\tsend.super '->puttext;
             sym[] -> emitsymbol;
             newline;
          #);
        emitPushThis:
          (#
          do '\tpush.argument 0 ' -> preF.puttext;
             blockLevel -> preF.putint;
             '\n' -> preF.put
          #);
        emitpushfield:
          (# sym: ^text
          enter sym[]
          do '\tpush.field '->puttext;
             sym[] -> emitsymbol;
             newline;
          #);
        emitpopfield:
          (# sym: ^text
          enter sym[]
          do '\tpop.field '->puttext;
             sym[] -> emitsymbol;
             newline;
          #);
        emitpushglobal:
          (# sym: ^text
          enter sym[]
          do '\tpush.global '->puttext;
             sym[] -> emitsymbol;
             newline;
          #);
        emitPushFromComponent:
          (# comp,sym: ^text
          enter(comp[],sym[])
          do '\tpush.global '->puttext;
             comp[] -> emitsymbol;
             newline;
             '\tpush.constant '->puttext;
             sym[] -> emitsymbol;
             newline;
             'global:' -> emitSend
          #);
        emitToFile:
          (# F: @file; fn: ^text;
             emitMetaInfo:
               (# key: ^Text;
                  value: ^Text;
                  hasExt: @boolean
               enter (key[], value[],hasExt)
               do '.metainfo ' -> F.puttext;
                  '#"' -> F.puttext;
                  key[] -> F.puttext;
                  '"' -> F.puttext;
                  (* HACK: currently hasExt=true implies that key='.requires'
                  (if hasExt then
                      ' #"comp_' -> F.puttext
                   else
                      ' #"' -> F.puttext
                   if);*)
                  ' #"' -> F.puttext;
                  value[] -> F.puttext;                  
                  (*(if hasExt then 
                      ':' -> F.put;
                      value[] -> F.puttext;
                      '.prc' -> F.puttext 
                  if);*)
                  '"' -> F.putline;
                  (*(if hasExt then

                      '.metainfo ' -> F.puttext;
                      '#"import"' -> F.puttext;
                      ' #"' -> F.puttext;
                      value[] -> F.puttext;
                      '.prc' -> F.puttext ;
                      ':' -> F.put;
                      value[] -> F.puttext;
                      '"' -> F.putline;
                  if);*)
               #);
             
          do (if notClosed then
                 (* This boolean is probably needed because there
                  * are too many mch.close in synthesizerbody
                  *)
                 thisFileName[] -> (thisFullPath.copy).append -> fn[];
                 '.pra' -> (fn.copy).AppendExtension -> F.name;
                 F.openWrite; 
                 '.metainfo #"import" #"BetaStructure.prc:BetaStructure"'
                 -> F.putline;
                 '.metainfo #"import" #"BetaComponent.prc:BetaComponent"'
                 -> F.putline;
	         imports.scan
                 (# e: @diskEntry;
                    S: @text
                 do current[] -> e.path; 
                    (* '\nRequires:'->screen.puttext;
                     current[] -> screen.putline;*)
                    (if not (e.path.name -> classes.has) then
                        'comp_' -> S;
                        e.path.name -> S.append;
                        ':' -> S.put;
                        e.path.name -> S.append;
                        '.prc'-> S.append;
                        ('requires', S[],true) -> emitMetaInfo;
                    if)
                 #);
                 imports.scanCC
                 (# e: @diskEntry;
                    S: ^text
                 do (*'\nScanCC: ' -> screen.puttext;
                    currentComp[]-> screen.putline;*)
                    currentComp[] -> e.path; 
                    (*e.path.name->  screen.putline;*)
                    (if not (e.path.name -> classes.has) then
                        e.path.name -> S[];
                        '.prc' -> S.append;
                        ':'->S.put;
                        currentClass[] -> S.append;
                        ('import', S[],true) -> emitMetaInfo
                    if)
                 #);
                 ('service.main_class', thisFirstClass[],false) -> emitMetaInfo;
                 F.newline;
                 preF[] -> F.puttext;
                 F.close;
	         preF.clear;
                 false -> notClosed
             if)
          #)
     #);

   
   fields: @
     (# Field,FieldName: [5] ^text; Type: [5] ^text; Tag: [5] @char;
        top: @integer;
        init: (# do 0 -> top #);
        numLocals, numCells, numArguments: @integer;
        LocalVariables: [1]@integer;
        new:
          (# F,FN,T: ^text; methodClassTag: @char; 
          enter(F[],FN[],T[],methodClassTag)
          do (if (top+1->top) > Field.range then
                 Field.range -> Field.extend;
                 FieldName.range -> FieldName.extend;
                 Type.range -> Type.extend;
                 Tag.range -> Tag.extend
             if);
             F[] -> Field[top][];
             FN[] -> FieldName[top][];
             T[] -> Type[top][];
             methodClassTag -> Tag[top];
             (# name_index, descriptor_index: @integer;
             do (if methodClassTag 
                 // 'c' 
                 // 'p' 
                 // '[' then
                    (if methodClassTag = '[' then '[' -> T.prepend if);

                 // 's' then (* synthetic field, like 'comp$' *)

                 // 'm' then
                    (FN[], T[]) -> mstate.allocLocal;
                 // 'M' // 'C' then (* ???*)
                 else
                    '\nField.add: ' -> puttext;
                    FN[] -> puttext; 
                    ' : "' -> puttext; T[] -> puttext; '"'->put;
                    methodclassTag -> put; newline;
                    (failureTrace,'fields.new:Unknown methodClassTag') -> stop
                if);
             #)

          #);
        scan:
          (# currentField,currentFieldName,currentType: ^text;
             currentTag: @char
          do (for i: top repeat
                  Field[i][] -> currentField[];
                  FieldName[i][] -> currentFieldName[];
                  Type[i][] -> currentType[];
                  Tag[i] -> currentTag;
                  INNER scan
             for)
          #);
        emitInit: 
          (# 
          do scan
             (# 
             do (if currentTag 
                 // 'p' (* part object*) 
                 // '[' then (* skip *)
                 // 'M' then (* skip *)
                 // 'C' then (* skip *)
                 else        
                    (if true
                     // 'I' ->  currentType.equal
                     // 'C' ->  currentType.equal
                     // 'Z' ->  currentType.equal
                     // 'B' ->  currentType.equal
                     // 'S' ->  currentType.equal
                     // 'D' ->  currentType.equal
                     // 'J' ->  currentType.equal then
                        '\tpush.constant 0\n'
                        '\tpop.field ' -> preF.puttext;
                        currentFieldName[] -> preF.emitSymbol;
                        pref.newline
                     else
                        (* Reference - is initial NIL.
                         * Other BETA implementations use 0 (zero)
                         * to repreent none - in PRE NIL is used
                         *)
                    if);
                if) 
             #);

          #);
     #);
   emitInitArrayBlock:
     (#
     do '\n  .instance_method #"$init_array:"\n'
        '  {\t.locals 0\n'
        '   \t.maxstacksize 3\n\n'         -> pref.puttext ;       
        
        '\t.method #"$block_method"\n'
        '\t{\t.locals 0\n'
        '\t \t.maxstacksize 3\n'
        '\t \tpush.constant 0\n'
        '\t \treturn.local\n'
        '\t}\n\n'
          -> pref.puttext; 
        
        '\tpush.argument 1 0\n'
        '\tpush.block #"$block_method"\n' -> pref.puttext;
        'putAll:' -> pref.emitSend;
        '\treturn.local\n'
        '  }\n'
          -> pref.puttext ;       
        

        
     #);
   noArgsInSignature:
     (# nargs: @int16;
        T: ^text;
     enter T[]
     do 0 -> nargs;
        T.reset;
        (for i:T.lgth repeat
             (if T.T[i]
              // '(' then
                 (* start of parameter list *)
              // ')' then
                 (* end of parameter list *)
                 leave noArgsInSignature;
              // 'B' // 'C' // 'D' // 'F' // 'I' // 'J' // 'S' // 'Z' then
                 (* BaseType *)
                 nargs+1 -> nargs;
              // 'L' then
                 (* ObjectType *)
                 i+1 -> i;
                 scanToSemiColon:
                   (if T.T[i]<>';' then i+1 -> i; restart scanToSemiColon if);
                 nargs+1 -> nargs;
              // '[' then
                 (* ArrayType *)
                 (*i+1 -> i;*)
                 (*    no need to skip! The form is always:
                  * [C or [Ltext;
                  scanToNonBrace: 
                  (if t.t[i+1]='[' then i+1 -> i; restart scanToNonBrace if);
                  * *)
                 (*nargs+1 -> nargs; don't count since we count for the
                  *                   element type *)
              else
                 'noArgsInSignature: unknown character \''->screen.puttext;
                 t.t[i] -> screen.put;
                 '\' in signature \'' -> screen.puttext;
                 t[] -> screen.puttext;
                 '\'' -> screen.putline;
             if);
        for);
     exit nargs
     #);
   
   jvmFIXME:  (* Bytecode compiler cannot handle patterns with the
               * same name in different files for the same attributes slot;
               * there is a conflivting FIXME in BCdotnetBody
               *)
     (# T: ^text
     enter T[]
     do (if not common.switch[188] then
            'FIXME: ' -> (T.copy).prepend -> T[];
            '***** ' -> screen.puttext; T[] -> screen.putline;
            (* Possibly generate an IOcall with T[] too *)         
        if);
     #);

   trace_opcode:
     (# opcode: @integer;
     enter opcode
     do(* (if trace_opcodes then
        (if opcode
        // comment then
        // position then
        else
        'Opcode %d: %s ' -> screen.putformat(# do opCode -> d;  opCode->asText->s; #);
        (if (32<=opcode) and (opcode<=126) then
        '\'%c\' ' -> screen.putformat(# do opcode->c #);
        if);
        screen.newline;
        if)
        if)*)
     #);

   unTick:
     (# t: ^text;
     enter t[]
     do (if ((1 -> t.inxGet) = '\'') AND ((t.length -> t.inxGet) = '\'') then
            (2, t.length - 1) -> t.sub -> t[];
        if);
     exit t[]
     #);

   imports: @
     (* As of now, there is some redundancy;
      * originally we just imported modules/components;
      * now we import classes FROM components;
      * this should be unified and a more efficient
      * representation should be made
      *)
     (# L: [100] ^text; top: @integer;
        classes,comps: [100] ^text; ctop: @integer;
        clear: (#do 0 -> top -> cTop #);
        has: booleanValue
          (# id: ^text
          enter id[]
          do (for i: top repeat
                  (if id[] -> L[i].equal then                       
                      true -> value; 
                      leave has 
          if)for)#);
        add:
          (# id: ^text
          enter id[]
          do (if not (id[] -> untick -> has) then
                 (*id[]->putline;*)
                 (if (top+1->top) > L.range then L.range -> L.extend if);
                 id[] -> L[top][];
             if)
          #);
        hasCC: booleanValue
          (# class,comp: ^text
          enter(class[],comp[])
          do(* '\nhasCC: ' -> puttext; class[] -> puttext; ' '->put;
             comp[] -> puttext;*)
             (for i: ctop repeat
                  (if class[] -> classes[i].equalNCS then 
                      (if comp[] -> comps[i].equalNCS then
                          true -> value;
                          leave hasCC
                  if)if)
             for)
          #);
        addClassFromComponent:
          (# class,comp: ^text
          enter(class[],comp[])
          do comp[] -> add;
             (*'\naddCC: ' -> puttext; class[] -> puttext; ' '->put;
             comp[] -> puttext;*)
             (if not ((class[],comp[])->hasCC) then(* ' add'->putline;*)
                 (if (ctop+1->ctop) > comps.range then 
                     comps.range -> comps.extend;
                     classes.range -> classes.extend
                 if);
                 class[] -> classes[ctop][];
                 comp[] -> comps[ctop][]
              (*else
                 ' no add '->putline*)
             if)
          #);
        scanCC:
          (# currentClass, currentComp: ^text
          do (for i: ctop repeat
                  classes[i][] -> currentClass[];
                  comps[i][] -> currentComp[];
                  inner
             for)
          #);
        scan:
          (# current: ^text
          do (for i: top repeat
                  L[i][] -> current[];
                  inner;
             for)
          #);
     #);

   allocLocal:
     (* Meaning of values in fields.LocalVariables:
      * 0: free, -1: unknown, 1: integertype, 2: referencetype, 3: double
      *)
     (# name, type: ^text;
        slot: @integer;
     enter (name[], type[])
     do 0 -> slot;
        (if false then
            1->trace(#
                    do 'local: ' -> xT;
                       name[] -> xT; ' ' -> put; type[] -> xT
        #)if);
        findSlot:
          (for i:fields.LocalVariables.range repeat
               (if fields.LocalVariables[i] = 0 then
                   i -> slot;
                   leave findSlot;
               if);
          for);
        (if slot=0 then
            (* Get a new slot *)
            fields.LocalVariables.range+1 -> slot;
            fields.LocalVariables.range (* at least 1 *)
              -> fields.LocalVariables.extend;         
        if);
        -1 -> fields.LocalVariables[slot];
        (if generateDebugInfo and (name[]<>NONE) and (type[]<>NONE) then

        if);
        (if false then
            'allocLocal: allocated slot '->puttext; 
            slot-> putint; 
            ', LIP=' -> puttext;

            newline;
        if);
     exit slot
     #);
   allocLocalDouble:
     (# name: ^text;
        slot: @integer;
     enter (name[])
     do 0 -> slot;
        find2Slots:
          (for i:fields.LocalVariables.range-1 repeat
               (if (fields.LocalVariables[i] = 0) and
                   (fields.LocalVariables[i+1] = 0) then
                   i -> slot;
                   leave find2Slots;
               if);
          for);
        (if slot=0 then
            (* Get a new slot *)
            fields.LocalVariables.range+2 -> slot;
            fields.LocalVariables.range+1 (* at least 2 *)
              -> fields.LocalVariables.extend;         
        if);
        -1 -> fields.LocalVariables[slot];
        -1 -> fields.LocalVariables[slot+1];
        (if generateDebugInfo and (name[]<>NONE) then

        if);
        (if false then
            'allocLocal: allocated double slot '->puttext; 
            slot-> putint; 
            ', LIP=' -> puttext;

            newline;
        if);
     exit slot
     #);

   releaseLocal:
     (# slot: @integer
     enter slot
     do (if fields.LocalVariables[slot] = 3 (* double *) then
            0 -> fields.LocalVariables[slot];
            0 -> fields.LocalVariables[slot+1]
         else
            0 -> fields.LocalVariables[slot]
        if);
     #);
   
   textOperandArg: ^text; (* ugly *)
   localLabArg: @integer; (* ugly *)
   
   A: @Address;
   
   Address:
     (# reg,off,size,isField,ONlevel: @integer; 
        inThisObj: @boolean;
        receiverType,fieldName,fieldType: ^text;
        load:
          (# isSimple: @boolean
          do (* local field - object/method ??*)
             (if fieldtype[] = none then
              else
                 fieldType.length = 1 -> isSimple;
             if);
             (if isField 
              // 0 then
                 loadValue
              // 1 then
                 (if inThisObj then
                     fieldName[] -> mstate.preF.emitPushField
                  else
                     fieldName[] -> mstate.preF.emitSend
                 if);
              // 2 then
                 (* array *)
                 
                 (if isSimple then
                     (if 1 -> fieldType.inxGet
                      // 'I' then
                      // 'C' then
                      // 'Z' 
                      // 'B' then
                      // 'S' then
                      // 'D' then
                      // 'J' then
                      else
                         '\nFieldType not handled: ' -> puttext;
                         fieldType[] -> putline
                     if)
                  else
                     (* Reference type *)
                 if);
                 'at:' -> preF.emitsend;
             if)
          #);
        loadValue:
          (# V: @integer
          do (if off < 0 then 
                 '\tpush.local ' -> preF.puttext; 
                 -off -> preF.putint; ' 0\n' -> preF.puttext
              else
                 (if off > 0 then 
	 	     (off div 4) - 2 -> V;
                 if);
                 (if definingStaticMethod then V + 1 -> V if);
                 (if V <= fields.numArguments then
                     '\tpush.argument ' -> preF.puttext; 
                     V -> preF.putint;
                     (*' 0 ; '-> preF.puttext;*)
                     ' ' -> preF.put;
                     blockLevel -> preF.putint;
                     ';' -> preF.put;
                     fieldName[] -> preF.putline;
                  else
                     '\tpush.local ' -> preF.puttext;  
                     V -> preF.putint; ' 0\n' -> preF.puttext
             if)if)

          #);
        store:
          (# isSimple: @boolean
          do (* local field - object/method ??*)
             fieldType.length = 1 -> isSimple;
            (* '\nStore: ' -> puttext;
             A.fieldName[] -> puttext; ' ' -> put;
             A.ONlevel -> putint;  ' ' -> put;
             A.isField -> putint;
             newline;*)
             (if isField 
              // 0 (* method field *) then
                 '\tpop.local ' -> preF.puttext;
                 (off div 4) - 2 -> pref.putint;
                 ' ' -> preF.put;
                 blockLevel -> preF.putInt;
                 '\n' -> preF.put;
              // 1 (* object field *) then
                 (if inThisObj then
                     A.fieldName[] -> preF.emitPopField
                  else
                     ':'->(A.fieldName.copy).append -> preF.emitsend;
                     '\tpop\n' -> preF.puttext
                 if)
              // 2 then
                 (* array *)
                 (if inThisObj then
                     ';OBS inThisObj = true???' -> preF.putline;
                 if);
                 'at:put:' -> preF.emitsend;
                 '\tpop\n' -> preF.puttext
             if)
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; 
             class: ^text;
          enter(withQua,isOrigin,class[])
          do (if withQua then
		 '\t; missing qua-check - not implemented!\n' -> preF.puttext;
             if);
             (if isField 
              // 1 then
              // 2 then

              else                       
                 (if off < 0 then
                     (off) -> allocMappedLocal -> astoreLocal;
                  else

             if)if)
          #);
        loadRef:
          (# withQua,isRef: @boolean;
             sig,knownSig: ^text
          enter(withQua,sig[],knownSig[])
          do (if isField 
              // 1 then


              // 2 then

              else 
                 (if off < 0 then
                     (off) -> allocMappedLocal -> aloadLocal;
                  else

             if)if); 
             (if withQua then

                 knownSig[] -> emitCheckCast
             if)
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     '\tpush.argument 0 0 // pushAdr\n' -> preF.puttext
                  // callO then
                     (* skip: register on stack *)
                  else
                     'Warning: pushAdr:register not this'->jvmFIXME
                 if)
              else
                 '\t;Warning: pushAdr:registeroff <>0\n' -> preF.puttext;
                 load;
             if)
          #);
        dump:
          (# 
          do (if size = 0 then 
                 4->commentstream.putint 
              else 
                 size->commentstream.putint 
             if);
             '.'->commentstream.put;
             (if reg
              // thisO then  
              // callO then 
                 '%call.'->commentstream.puttext
              else
                 '%top.'->commentstream.puttext
             if);
             off->commentstream.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
             ' isField:'->puttext; isField -> putint; ' ' -> put;
             ' inThisObj:'->puttext; 
             (if inThisObj then
                 'T'-> put
              else
                 'F'->put
             if)
             ; ' ' -> put;
             receiverType[] -> puttext; ' '->put;
             fieldName[] -> puttext; ' '->put;
             fieldType[] -> putline;
          #);
     #);
   loadOrigin:
     (# ONlevel: @integer; 
        className,fieldType,ORG: ^text
     enter(ONlevel,className[],fieldType[])
     do (if isMainMethod then
            (* reconsider for main/program-slot;
             * in Java:main, we cannot access class fields;
             * but we may do in BETA
             *)

         else
            (if ONlevel = 0 then
                (* we are in a method activation;
                 * we currently always push this
                 *)
                (*'\tpush.argument 0 0\n' -> mstate.preF.puttext;*)
                preF.emitPushThis
             else
                (if true then
                    'origin$' -> ORG[];
                    (2,className.length-1) -> className.sub -> ORG.append;
                    ORG[] -> mstate.preF.emitsend;
                 else
                    'origin' -> mstate.preF.emitsend;
                if)
            if);
        if)
     #);
   (* OBS. Code duplicated from bytecodeback end - ugly *)
   add: (# exit 51 #);
   sub:(# exit 52 #);
   orr: (#exit 53 #);
   andd: (# exit 54 #);
   xorr: (# exit 55 #);
   cmp: (# exit 56 #);
   mult: (# exit 57 #);
   divv: (# exit 58 #);
   modd: (# exit 59 #);
   nott: (# exit 60 #);
   logNot: (# exit 61 #); 
   neg: (# exit 62 #);
   arithShiftLeft: (# exit 63 #);
   logicalShiftLeft: (# exit 64 #);
   arithShiftRight: (# exit 65 #);
   logicalShiftRight: (# exit 66 #);
   rotateLeft: (# exit 67 #);
   rotateRight: (# exit 68 #);
   byteSwapLong: (# exit 69 #);
   byteSwapShort: (# exit 70 #);
   
   emitFunc:
     (# func: @integer;
     enter func
     do (if func
         // add then
            '+:' -> preF.emitsend;
         // sub then
            '-:' -> preF.emitsend;
         // nott then
            (* 0:     ifne L1
             * 3:     iconst_1
             * 4:     goto L2
             * 7: L1: iconst_0
             * 8: L2:
             *)
	    '\tpush.constant 1\n' -> preF.puttext;
            '+:' -> preF.emitsend;
	    '\tpush.constant 2\n' -> preF.puttext;
            '%:' -> preF.emitSend
         // mult then
            '*:' -> preF.emitsend;
         // divv then
            '/:' -> preF.emitsend;
         // modd then
            '%:' -> preF.emitsend;
         // xorr then
            ';\txor NOT implemented\n' -> preF.puttext;
            '+:' -> preF.emitsend;
         // logNot then
            (* bit not *)
            ';\tlogNot NOT implemented\n' 
	    '\tpush.constant 0' -> preF.putline;
            '+:' -> preF.emitsend;
         // neg then
	    '\tpush.constant 0\n\tswap\n' -> preF.puttext;
            '-:' -> preF.emitsend;
         // orr then
            '||:' -> preF.emitsend;
         // andd then
            '&&:' -> preF.emitsend;
            
         // cmp then
            '=:' -> preF.emitSend
         // logicalShiftLeft then

         // logicalShiftRight then

         // arithShiftLeft then   

         // arithShiftRight then

         // rotateLeft then
         // rotateRight then
         // byteswapShort then
         // byteswapLong then

         else
            'Unhandled bytecode func.'  -> jvmFIXME;
        if);
     #);
   loadBetaenv:
     (# 
     do 
     #);
   newBetaEnv:
     (#
     do 
     #);
   
   emitImports:
     (#
     do 
     #);
   emitNewArray:
     (# type: @integer
     enter type
     do 
        
     #);
   emitAnewArray:
     (# type: ^text
     enter type[]
     do 
        
     #);
   emitCheckCast:
     (# class: ^text
     enter class[]
     do 
     #);
   emitCmpJmp:
     (# cond,L,lab,isRef: @integer; (* isRef=1: reference comparison;
                                     * should only happen for = and <>
                                     *)
        pushTrue: @boolean;
        L1,L2: ^text
     enter(cond,L,lab,isRef,pushTrue)
     do (if cond
         // 1 (* =  *) then
            '=:' -> preF.emitsend;
         // 2 (* <> *) then
            '<>:' -> preF.emitsend;
         // 3 (* <  *) then
            '<:' -> preF.emitsend;
         // 4 (* <= *) then
            '<=:' -> preF.emitsend;
         // 5 (* >  *) then
            '>:' -> preF.emitsend;
         // 6 (* >= *) then
            '>=:' -> preF.emitsend;
        if);
        (if pushTrue then
            xlab -> L1[];
            xlab -> L2[];
            '\t; The following code is a preliminary hack\n'
            '\t; it is needed since "=:", etc on F##, etc\n'
            '\t; returns 0 or 1 and not true or false.\n'
            '\t; An expression "F##  =: nil" returns true\n'
            '\t; if F## is nil, otherwise 1 is returned.\n'
            '\t; the code below checks if top stack element\n'
            '\t; is a boolean or an integer; integer 0 or 1 \n'
            '\t; is converted to false or true\n'
            '\tdup\n' -> preF.puttext;
            '\tpush.constant 0\n' -> preF.puttext;
            '<>:' -> preF.emitSend;
	    '\tpush.global #"true"\n' 
	    '\tbranch.identical ' -> preF.puttext;
            L1[] -> preF.putline;
	    '\tpush.global #"false"\n'
            '\tswap\n'
            '\tpop\n'
	    '\tbranch ' -> preF.puttext;
            L2[] -> preF.putline;
            L1[] -> pref.puttext;
            ':\n' 
            '\tdup\n' -> preF.puttext;
            '\tpush.constant 1\n' -> preF.puttext;
            '<>:' -> preF.emitSend;
	    '\tpush.global #"true"\n' 
	    '\tbranch.identical ' -> preF.puttext;
            L2[] -> preF.putline;
            
	    '\tpush.global #"true"\n' 
            '\tswap\n' -> preF.puttext;
            '\tpop\n' -> preF.puttext;
            L2[] -> preF.puttext;
	    ':' -> preF.put
        if);
        '\n\tpush.global #"true"' -> preF.puttext;
        '\n\tbranch.identical L' -> preF.puttext;
        lab -> mstate.preF.putint;
        mstate.preF.newline
     #);
   emitCmpToBool:
     (* 0:      if_xxx L1
      * 3:      bipush 0
      * 5:      goto L2
      * 8:  L1: bipush 1
      * 10: L2:
      *)          
     (# cond: @integer; Lx,Ly: ^text
     enter cond
     do '\t; cmpToBool ' -> preF.putline;
        (if cond
         // 1 (* =  *) then
            '=:' -> preF.emitsend;
         // 2 (* <> *) then
            '<>:' -> preF.emitsend;
         // 3 (* <  *) then
            '<:' -> preF.emitsend;
         // 4 (* <= *) then
            '<=:' -> preF.emitsend;
         // 5 (* >  *) then
            '>:' -> preF.emitsend;
         // 6 (* >= *) then
            '>=:' -> preF.emitsend;
        if);
	xLab -> Lx[];
	xLab -> Ly[];
        '\n\tpush.global #"true"' -> preF.puttext;
        '\n\tbranch.identical ' -> preF.puttext; Lx[] -> preF.putline;
        '\tpush.constant 0\n' -> preF.puttext;
        '\tbranch ' -> preF.puttext; Ly[] -> preF.putline;
	' ' -> preF.put; Lx[] -> preF.puttext;
        ': push.constant 1\n' -> preF.puttext;
	' ' -> preF.put; Ly[] -> preF.puttext;
        ': \n' -> preF.puttext
     #);
   emitCmpBoolJmp:
     (# cond,L,lab: @integer
     enter(cond,L,lab)
     do '\tpush.constant 0\n' -> preF.puttext;
        (if cond
         // 1 (* =  *) then
            '=:' -> preF.emitsend;
         // 2 (* <> *) then
            '<>:' -> preF.emitsend;
         // 3 (* <  *) then
            '<:' -> preF.emitsend;
         // 4 (* <= *) then
            '<=:' -> preF.emitsend;
         // 5 (* >  *) then
            '>:' -> preF.emitsend;
         // 6 (* >= *) then
            '>=:' -> preF.emitsend;
        if);
        '\n\tpush.global #"true"' -> preF.puttext;
        '\n\tbranch.identical L' -> preF.puttext;
        lab -> mstate.preF.putint;
        mstate.preF.newline
     #);
   negCond:
     (# cond: @integer
     enter cond
     do (if cond
         // 1 (* =  *) then

         // 2 (* <> *) then

         // 3 (* <  *) then

         // 4 (* <= *) then
            '<=?' -> preF.emitsend;
         // 5 (* >  *) then
            '>?' -> preF.emitsend;
         // 6 (* >= *) then

        if);
        mstate.preF.newline
     exit cond
     #);

   markAsInnerIfInnerClass:
     (# className,name,outer: ^text;
        lastSlashPos,lastDollarPos: @integer;
        decode: @
          (# pos: @integer
          do className.scanAll
             (# 
             do pos+1 -> pos;
                (if ch 
                 // '$' then pos -> lastDollarPos
                 // '/' then pos -> lastSlashPos
                if)
             #);
             
          #)
     enter className[]
     do decode;
        (if lastDollarPos > 0 then
            (* we have a nested class *)
            (lastDollarPos+1,className.length) -> className.sub -> name[];
            (1,lastDollarPos-1) -> className.sub -> outer[];
            (*1->trace(#
             do 'markAsInner: ' -> xT; className[] -> xT; 
             ' ' -> put; name[] -> xT;
             ' outer: ' -> xT; outer[] -> xT;
             #);*)

        if);
     #);
   emitMemOp:
     (# op, op0: @integer; varNo: @integer;
     enter(op, op0, varNo)
     do (if varNo > 0 then
            (* currently we assume that local variables have
             * addresses: 0,12,16,20,... that are 
             * mapped to: 0, 1, 2, 3,...
             * address 0 represents this
             *)
            (varNo div 4) - 2 -> varNo;
        if);
        (op, op0, varNo) -> MemoryOperation;
     #);
   MemoryOperation:
     (# op, op0: @integer; argNo: @integer;
     enter(op, op0, argNo (* argNo: 0, 1, 2, 3, ...*))
     do (if generateDebugInfo then

        if);
        
        (if argNo <= 3 then 

         else

        if);
     #);
   
   opLocal:
     (# op, op0, locNo: @integer;
     enter locNo (* local number, NOT offset *)
     do INNER;
        (op, op0, locNo) -> MemoryOperation;
     #);
   aOpLocal: opLocal
     (# msg: ^text;
     do (if fields.LocalVariables[locNo] 
         // 1 (* integertype *) 
         // 3 (* double *) then
            'aOpLocal: Using local variable of integertype/double with reference instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            2 (* referencetype *) -> fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   dOpLocal: opLocal
     (# msg: ^text;
     do (if fields.LocalVariables[locNo] 
         // 1 (* integertype *) 
         // 2 (* referencetype *) then
            'dOpLocal: Using local variable of integertype/referencetype with double instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            3 (* double *) -> fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   iOpLocal: opLocal
     (# msg: ^text;
     do (if fields.LocalVariables[locNo] 
         // 2 (* referencetype *) 
         // 3 (* double *) 
            then
            'iOpLocal: Using local variable of double/referencetype with integer instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            1 (* integertype *) -> fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   astoreLocal: 
     aOpLocal(# do #);
   aloadLocal: 
     aOpLocal(# do #);
   dstoreLocal: 
     dOpLocal(# do #);
   dloadLocal: 
     dOpLocal(# do #);
   storeLocal: 
     iOpLocal(# do #);
   loadLocal: 
     iOpLocal(# do #);
   
   MappedLocals: [1]@integer;
   lastMappedLocal: @integer;
   allocMappedLocal:
     (# num: @integer;
        locnum: @integer;
        double: @boolean;
     enter (num)
     do -num -> num;
        (if num>MappedLocals.range then
            (MappedLocals.range, num-MappedLocals.range)
              -> max
              -> MappedLocals.extend;
        if);
        (if MappedLocals[num]=0 then
            (if double then
                (allocLocalDouble -> locnum) + 1 -> MappedLocals[num];
             else
                (allocLocal -> locnum) + 1 -> MappedLocals[num];
            if);
            (* adding 1 to distingguish local 0 from unassigned *)
            num -> lastMappedLocal; 
            (if false then
                'allocMappedLocal: offset='->puttext; 
                num->putint; 
                ' mapped to slot '->puttext; 
                locnum-> putint; 
                ', LIP=' -> puttext;

                newline;
            if);
         else
            MappedLocals[num]- 1 -> locnum;
            num -> lastMappedLocal; (* needed? *)
            (if false then
                'allocMappedLocal: offset='->puttext; 
                num->putint; 
                ' looked-up to slot '->puttext; 
                locnum-> putint; 
                ', LIP=' -> puttext;

                newline;
            if);
        if);
     exit locnum
     #);

   emitEndLabel:
     (* stack: ExoException object *)
     (# restartLabno: @integer;
        leaveLabno: @integer;
        handler_pc: @integer;
        restart_pc: @integer;
        loc: @integer; (* Save exception object into this local *)
        rethrowOff: integerValue
          (* Calculate offset to rethrow label from current PC.
           * Code between the two labels:
           *   loc -> aloadLocal;  (1 or 2 bytes)
           *   athrow-> jcf.emit;  (1 byte)
           *)
          (# 
          do (if loc<=3 then

              else

             if)                            
          #);
        isLocal: @boolean
     enter(restartLabNo,leaveLabNo,isLocal)
     do 
     #);
   emitBreak:
     (# labno: @integer;
        isLeave: @boolean (* not used?*)
     enter(labNo,isLeave)
     do 
     #);
   emitCallExternal:
     (# prim, n, d, m: ^text; s: @boolean;
     enter prim[]
     do (if true 
	 // '%primitive:isString' -> prim.equal then
	    'class' -> preF.emitSend;
	    'asString' -> preF.emitSend;	
            '\tpush.constant "String"\n' -> preF.puttext;
            '=:' -> preF.emitSend;
	    '\tpush.global #"true"\n' -> preF.puttext;
	    '\tbranch.identical B1\n' 
	    '\tpush.constant 0\n' 
	    '\tbranch B2\n ' 
	    'B1:\tpush.constant 1\n' 
	    'B2: \n' -> preF.puttext;
            
         // '%primitive:put'->prim.equal then
            'asChar' ->preF.emitsend;
            'print' ->preF.emitsend;
         // '%primitive:get'->prim.equal then
	    '\tpush.global #"system"\n' -> preF.puttext;
            'getChar' ->preF.emitsend;   
         // '%sem:signal' -> prim.equal then
            '\t; signal\n' -> pref.puttext
         // '%sem:wait' -> prim.equal then
            '\t; wait\n' -> pref.puttext
         // '%primitive:setClockInterruptHandler' -> prim.equal then
            (* OBS. This code only works if it is called at a specific 
             * place in tstenv/minienv*)
            '\tpush.global #"service"\n' -> pref.puttext;
            (if false then
                '\tpush.global #"main_program$bSys$InterruptHandler"\n'
                '\tpush.argument 0 0\n' 
                '\tsend  #"origin"\n' -> pref.puttext;
                'new:' -> pref.emitSend;
             else
                '\tswap\n' -> preF.puttext;
            if);
            'setInterruptHandler:' -> preF.emitSend;
            '\tpush.global #"service"\n' 
            '\tpush.constant 10\n' -> preF.puttext;
            'setInterruptInterval:' -> preF.emitSend;
            '\tpop\n' -> preF.puttext;
         // '%primitive:setClockInterruptInterval' -> prim.equal then
            '\tpush.global #"service"\n'
            '\tswap\n' -> preF.puttext;
            'setInterruptInterval:' -> preF.emitSend;
            '\tpop\n' -> preF.puttext;
         // '%primitive:className' -> prim.equal then
            'id'->putline;
            '\tpush.argument 0 0\n' ->  pref.puttext;
            'class' -> pref.emitSend;
            'asString' -> pref.emitSend;
            (common.ExternalString2BetaText,none) -> emitPrimNo
         else
            'callExternal' -> jvmFIXME;
        if)
     #);
   

   classes: @
     (# L: [4] ^text; 
        start,end: [4] @integer;
        top: @integer;
        init: (# do 0 -> top #);
        has: booleanValue
          (* NOTE! We currently use equalNCS, since 'id' may be in
           * different case. This is the case for a file
           * Counter.bet containing lib:attributes--- Counter: (# ... #)...
           * compiled using   pbeta counter NOTE: small 'c'
           * import will be called with C:/.../counter
           * This may result in .requires counter in file Counter.pra
           * containing class Counter.
           * Apparently not a problem for nbeta since more files
           * are generated than for pbeta - should be investigated
           *)      
          (# C: ^text
          enter C[]
          do search:
               (for i: top repeat
                    (if C[] -> L[i].equalNCS then
                        true -> value;
                        leave search
               if)for)
          #);
        add:
          (# cn: ^text;
             startPos,endPos: @integer
          enter(cn[],startPos,endPos)
          do (if (top+1->top) > L.range then
                 L.range -> L.extend;
                 start.range -> start.extend;
                 end.range -> end.extend
             if);
             cn[] -> L[top][];
             startPos -> start[top];
             endPos -> end[top];
          #);
        scan:
          (# current: ^text;
             startPos,endPos: @integer
          do (for i: top repeat
                  L[i][] -> current[];
                  start[i] -> startPos;
                  end[i] -> endPos;
                  inner
          for)#)
     #);
   emitPrimNo:
     (# primNo: @integer; arg: ^text;
     enter(primNo,arg[])
     do (if false then
            '\t// %prim: ' -> preF.puttext;            
            primno -> preF.putint; ' '->pref.put;
            (if arg[] = none then
                pref.newline
             else
                arg[] -> preF.putline;
            if);
        if);
        (if primNo 
         // - 1 then (* terrible hack *)
            arg[] -> preF.emitpushglobal;
         // common.new then
            (* Here we push the class name; 
             * 'send new' is generated later, see below.
             * We need origin to be pushed in between
             *)
            arg[] -> preF.emitpushglobal;
         // common.initSuper then
            (if not ('-'->arg.equal) then
                'CONSTRUCTOR:'-> preF.emitSuperSend
            if);
            fields.emitInit;
            
         // common.setClass then
            arg[] -> class[]
         // common.init_Prim then
            (if arg.length = 0 then
                'new' -> preF.emitsend;
             else
                'new:' -> preF.emitsend;
            if)
         // common.ExternalString2BetaText then
            '\tpush.global #"text"\n'
            '\tpush.argument 0 0\n'
            '\tsend #"new:"\n'
            '\tswap\n' -> preF.putText;
	    'asArray' -> preF.emitSend;
	    ':' -> (common.enterMethod).append -> preF.emitSend
         // common.BetaText2ExternalString then
            '\t;BetaText2ExternalString\n' -> pref.puttext;
            '\tsend #"T"\n' -> preF.putText
         // common.text2charArray then
            '\t;text2charArray' -> preF.putline;
    	    'asArray' -> preF.emitSend;
         // common.BetaText2BetaCharArray then
            'T' -> preF.emitSend
         else
            '\t; ??primitive not handled: ' -> preF.puttext;
            primno -> preF.putint;
            preF.newline;
        if);
        
     #);
   emitPrim:
     (# prim,arg: ^text;
        index: @integer;
        sig: ^text;
     enter(prim[],arg[])
     do (if true 
         // 'initArrays' -> prim.equal then
            emitInitArrayBlock;
         // 'AlloRR' -> prim.equal 
         // 'NewRR' -> prim.equal then
            'Array'-> preF.emitpushglobal; 
            '\tswap\n' -> preF.puttext;
            'new:' -> preF.emitsend; 
            
         // 'AlloVR1' -> prim.equal
         // 'AlloVR2' -> prim.equal
         // 'AlloVR4' -> prim.equal 
         // 'AlloVR8' -> prim.equal 
         // 'AlloVRZ' -> prim.equal 
         // 'AlloVRB' -> prim.equal 	
         // 'NewVR1' -> prim.equal 
         // 'NewVR2' -> prim.equal 
         // 'NewVR4' -> prim.equal 
         // 'NewVR8' -> prim.equal 
         // 'NewVRB' -> prim.equal then
            'Array'-> preF.emitpushglobal; 
            '\tswap\n' -> preF.puttext;
            'new:' -> preF.emitsend; 
            '\tdup\n' -> preF.puttext;
            '\tpush.argument 0 0\n' -> preF.puttext;
            '\tswap\n' -> preF.puttext;
            '$init_array:' -> pref.emitSend;
            'pop' -> preF.emitOp;
         // 'CopyVR1' -> prim.equal
         // 'CopyVR2' -> prim.equal
         // 'CopyVR4' -> prim.equal
         // 'CopyVR8' -> prim.equal
         // 'CopyVRZ' -> prim.equal
         // 'CopyRR' -> prim.equal then
            'copy' -> preF.emitSend
         // 'CopySVR1' -> prim.equal
         // 'CopySVR2' -> prim.equal
         // 'CopySVR4' -> prim.equal
         // 'CopySVR8' -> prim.equal
         // 'CopySVRZ' -> prim.equal
         // 'CopySRR' -> prim.equal
         // 'CopyRSR' -> prim.equal then
            'copySliceFrom:to:' -> preF.emitSend
         // 'ExtVR1' -> prim.equal
         // 'ExtVR2' -> prim.equal
         // 'ExtVR4' -> prim.equal
         // 'ExtVR8' -> prim.equal
         // 'ExtVRZ' -> prim.equal
         // 'ExtVRB' -> prim.equal
         // 'ExtRR' -> prim.equal then
            'extend:' -> preF.emitSend
         // 'CinitT' -> prim.equal then		
 	    (* skip *)
         // 'CONSTRUCTOR:' -> prim.equal then
            'CONSTRUCTOR:' -> preF.emitsend; 
         // 'AlloC' -> prim.equal then
	    '\t;AlloC\n' -> preF.puttext;      
	    (* assume object to be part of component is on top of stack *)
	    '\tdup\t;the "real" object is stored\n' -> preF.puttext;
            'BetaComponent'-> preF.emitpushglobal;
            '\tswap\n' -> preF.puttext;
            'new:' -> preF.emitsend; 
	    '\tpop\n' -> preF.puttext;
         // 'Att' -> prim.equal then
	    '\t;Attach current\n' -> preF.puttext;
           (* '\tdup ; needed if exit-part is executed after attach\n' 
              -> preF.puttext;*)
	    'comp' -> preF.emitSend;
            'attach' -> preF.emitSend;
            '\tpop\n' -> preF.puttext;
         // 'Susp' -> prim.equal then
	    '\t;Suspend  current\n' -> preF.puttext;
            'Coroutine'-> preF.emitpushglobal;
            'suspend' -> preF.emitSend
         // 'SuspX' -> prim.equal then
            '\t;Suspend component on top of stack\n' -> preF.puttext;
	    'comp' -> preF.emitSend;
            'suspend' -> preF.emitSend	   
         // 'AlloS' -> prim.equal then
            '\t; AlloS\n' -> preF.puttext;
            'BetaStructure' -> preF.emitPushGlobal;
            '\tswap\n' -> preF.puttext;
            (2,arg.length-1) -> arg.sub -> preF.emitPushGlobal;
            'new:class:' -> preF.emitSend
         // 'AlloSI' -> prim.equal then
            '\t; AlloSI\n' -> preF.puttext;
            'create' -> preF.emitSend
         // 'ObjS' -> prim.equal then
            '\t; ObjS\n' -> preF.puttext;
            'BetaStructure' -> preF.emitPushGlobal;
            '\tswap\n' -> preF.puttext;
            'dup' -> preF.emitOp;
            'class' -> preF.emitSend;
            'swap' -> preF.emitOp;
            'origin' -> preF.emitSend;
            'new:origin:' -> preF.emitSend
         // 'eqS' -> prim.equal then
            '=:' -> preF.emitSend
         // 'neS' -> prim.equal then
            '<>:' -> preF.emitSend
         // 'leS' -> prim.equal then
            '<=:' -> preF.emitSend
         // 'ltS' -> prim.equal then
            '<:' -> preF.emitSend
         // 'geS' -> prim.equal then
            '>=:' -> preF.emitSend
         // 'gtS' -> prim.equal then
            '>:' -> preF.emitSend
         else
            '\t; ?primitive not handled: ' -> preF.puttext;
            prim[] -> preF.puttext; ' ' ->preF.put;
            arg[] -> preF.putline;            
        if)
     #)
#)


