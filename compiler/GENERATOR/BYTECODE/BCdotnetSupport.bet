ORIGIN 'BCmachineBody'; 
INCLUDE '~beta/basiclib/formatio'; 

(* Support classes needed by the generated .NET code.
 * Generated as part of compiling basic BETA environment.
 *)


--BCmachineLib: attributes--

sigStructure:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'Structure\'' -> T.putformat(# do common.StructureLocation->s #);
  exit T[]
  #);

sigBetaArray:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'BetaArray\'' -> T.putformat(# do common.BetaArrayLocation->s #);
  exit T[]
  #);

sigBetaObject:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'BetaObject\'' -> T.putformat(# do common.BetaObjectLocation->s #);
  exit T[]
  #);

sigComponent:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'%s\'' -> T.putformat(# do common.ComponentLocation->s; common.ComponentClass->s #);
  exit T[]
  #);


GenerateClassExOException:
  (# 
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: ExOException\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit ExOException\n'
     '       extends [mscorlib]System.Exception\n'
     '{' -> out.putln;
     '.field public object exitobj' -> out.putln;
     '.field public int32 labno' -> out.putln;
     out.putln;
     '.method public hidebysig specialname rtspecialname '
     'instance void  .ctor(object e, int32 l) cil managed'
       -> out.putln;
     out.indent.inc;
     '{' -> out.putln;
     '.maxstack  2' -> out.putln;
     'ldarg.0' -> out.putln;
     'call  instance void [mscorlib]System.Exception::.ctor()' -> out.putln;
     'ldarg.0' -> out.putln;
     'ldarg.1' -> out.putln;
     'stfld  object ExOException::exitobj' -> out.putln;
     'ldarg.0' -> out.putln;
     'ldarg.2' -> out.putln;
     'stfld  int32 ExOException::labno' -> out.putln;
     'ret' -> out.putline;
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);

GenerateClassStructure:
  (# 
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: Structure\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit Structure\n'
     '  extends [mscorlib]System.Object\n'
     '{' -> out.putln;
     '.field public class [mscorlib]System.Object iOrigin' -> out.putln;
     '.field public class [mscorlib]System.Type iProto' -> out.putln;
     '.field private class [mscorlib]System.Reflection.ConstructorInfo iConstructor' -> out.putln;
     out.nl;
     
     '.method public hidebysig specialname rtspecialname instance void .ctor(class [mscorlib]System.Object, class [mscorlib]System.Type) cil managed' 
       -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call instance void [mscorlib]System.Object::.ctor()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  stfld  object Structure::iOrigin' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.2' -> out.putln;
     '  stfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldnull' -> out.putln;
     '  stfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  ret' -> out.putln;
     '} ' -> out.putln;
     out.nl;
     
     '.method public hidebysig static class Structure AlloS(class [mscorlib]System.Object o, class [mscorlib]System.Type p) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  3' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  newobj  instance void Structure::.ctor(object, class [mscorlib]System.Type)' -> out.putln;
     '  ret' -> out.putln;
     '  } ' -> out.putln;
     out.nl;
     
     '.method public hidebysig static class Structure '
     'ObjS(class [mscorlib]System.Object o) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  3' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Type proto,' -> out.putln;
     '  [1] class [mscorlib]System.Reflection.FieldInfo origin_field,' -> out.putln;
     '  [2] class [mscorlib]System.Object origin)' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldstr  "origin"' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(class [mscorlib]System.String)' -> out.putln;
     '  stloc.1' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Object [mscorlib]System.Reflection.FieldInfo::GetValue(class [mscorlib]System.Object)' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.2' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  newobj  instance void Structure::.ctor(class [mscorlib]System.Object,' -> out.putln;
     '  class [mscorlib]System.Type)' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig instance class [mscorlib]System.Object AlloSI() cil managed' -> out.putln;
     '  {' -> out.putln;
     '  .maxstack  4' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Reflection.ConstructorInfo[],' -> out.putln;
     '  [1] int32,' -> out.putln;
     '  [2] class [mscorlib]System.Reflection.ParameterInfo[],' -> out.putln;
     '  [3] class [mscorlib]System.Object[])' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.ConstructorInfo[] [mscorlib]System.Type::GetConstructors()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  stloc.1' -> out.putln;
     '  br.s  L2' -> out.putln;
     
     'L4:' -> out.putln;  '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  callvirt   instance class [mscorlib]System.Reflection.ParameterInfo[] [mscorlib]System.Reflection.MethodBase::GetParameters()' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.2' -> out.putln;
     '  ldlen' -> out.putln;
     '  conv.i4' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  bne.un.s  L3' -> out.putln;
     
     '  ldloc.2' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Reflection.ParameterInfo::get_ParameterType()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()' -> out.putln;
     '  callvirt  instance bool [mscorlib]System.Type::IsAssignableFrom(class [mscorlib]System.Type)' -> out.putln;
     '  brfalse.s  L3' -> out.putln;
     
     '  ldarg.0' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  stfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  br.s  L1' -> out.putln;
     
     'L3:' -> out.putln;  '  ldloc.1' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  add' -> out.putln;
     '  stloc.1' -> out.putln;
     'L2:' -> out.putln;  '  ldloc.1' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldlen' -> out.putln;
     '  conv.i4' -> out.putln;
     '  blt.s  L4' -> out.putln;
     
     'L1:' -> out.putln; '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  newarr  [mscorlib]System.Object' -> out.putln;
     '  stloc.3' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  stelem.ref' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  callvirt   instance object [mscorlib]System.Reflection.ConstructorInfo::Invoke(object[])' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool eqS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  brtrue.s  L2' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     'L2:' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  brtrue.s  L3' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L3:' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  beq.s  L4' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L4:' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  beq.s  L5' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L5:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  neS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ceq' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  leS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::ltS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     
     '.method public hidebysig static bool  geS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::gtS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  gtS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call  bool Structure::ltS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  ltS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Type proto1,' -> out.putln;
     '  [1] class [mscorlib]System.Type proto2,' -> out.putln;
     '  [2] class [mscorlib]System.Object newObject,' -> out.putln;
     '  [3] class [mscorlib]System.Reflection.FieldInfo origin_field)' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L1:' -> out.putln; '  ldarg.1' -> out.putln;
     '  brtrue.s  L2' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L2:' -> out.putln; '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  stloc.1' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  bne.un.s  L3' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L3:' -> out.putln; '  ldloc.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Type::get_BaseType()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  br.s  L4' -> out.putln;
     
     'L6:' -> out.putln;'  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  bne.un.s  L5' -> out.putln;
     
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Object Structure::AlloSI()' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldstr  "origin"' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(class [mscorlib]System.String)' -> out.putln;
     '  stloc.3' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  ldloc.2' -> out.putln;
    '   callvirt   instance class [mscorlib]System.Object [mscorlib]System.Reflection.FieldInfo::GetValue(object)' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  ceq' -> out.putln;
     '  ret' -> out.putln;
     
     'L5:' -> out.putln; '  ldloc.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Type::get_BaseType()' -> out.putln;
     '  stloc.0' -> out.putln;
     'L4:' -> out.putln; '  ldloc.0' -> out.putln;
     '  brtrue.s  L6' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);


GenerateClassBetaArray:
  (# 
     emitExtVR:
       (# name, type: ^text;
       enter (name[], type[])
       do (* public static char[] ExtVR1(char[] array, int add) {
           *     int copysize = array.Length;
           *     int newsize  = copysize + add;
           *     if (newsize<0) newsize = 0;
           *     if (copysize>newsize) copysize = newsize;
           *     char[] newArray = new char[newsize];
           *     System.Array.Copy(array, 0, newArray, 0, copysize);
           *     return newArray;
           * }
           *)         
          '  .method public hidebysig static %s[] %s(%s[] \'array\', int32 \'add\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #);
          '  {' -> out.putln;
          '    .maxstack  5' -> out.putln;
          '    .locals init ([0] int32 copysize,' -> out.putln;
          '                  [1] int32 newsize,' -> out.putln;
          '                  [2] %s[] newArray)' -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'   -> out.putln;
          '    ldlen'     -> out.putln;
          '    conv.i4'   -> out.putln;
          '    stloc.0'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    add'       -> out.putln;
          '    stloc.1'   -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    bge.s  L1' -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    stloc.1'   -> out.putln;
          '  L1:'         -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ble.s  L2' -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    stloc.0'   -> out.putln;
          '    L2:'       -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    newarr  %s' -> out.putformat(# do type[]->s #); out.nl;
          '    stloc.2'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.2'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
          '    ldloc.2'   -> out.putln;
          '    ret'       -> out.putln;
          '  }'           -> out.putln;
          out.nl;
       #);
   
     emitCopyVR:
       (# name, type: ^text;
       enter (name[], type[])
       do          
          (* public static char[] CopyVR1(char[] array) {
           *     int size = array.Length;
           *     char[] newArray = new char[size];
           *     System.Array.Copy(array, 0, newArray, 0, size);
           *     return newArray;
           * }
           *)
          '  .method public hidebysig static %s[] %s(%s[] \'array\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #); out.nl;
          '  {'            -> out.putln;
          '    .maxstack 5'-> out.putln;
          '    .locals init ([0] int32 size,'  -> out.putln;
          '                  [1] %s[] newArray)'  -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'    -> out.putln;
          '    ldlen'      -> out.putln;
          '    conv.i4'    -> out.putln;
          '    stloc.0'    -> out.putln;
          '    ldloc.0'    -> out.putln;
          '    newarr  %s' -> out.putformat(# do type[]->s #); out.nl;
          '    stloc.1'    -> out.putln;
          '    ldarg.0'    -> out.putln;
          '    ldc.i4.0'   -> out.putln;
          '    ldloc.1'    -> out.putln;
          '    ldc.i4.0'   -> out.putln;
          '    ldloc.0'    -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)'     -> out.putln;
          '    ldloc.1'    -> out.putln;
          '    ret'        -> out.putln;
          '  }'            -> out.putln;
          out.nl;
       #);
     
     emitCopySVR:
       (# name, type: ^text;
       enter (name[], type[])
       do          
          (* public static char[] CopySVR1(int low, int high, char[] array) 
           * {
           *     CkSR(low, high, array.Length);
           *     int newsize = high - low + 1;
           *     if (newsize<0) newsize = 0;
           *     char[] newArray = new char[newsize];
           *     if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
           *     return newArray;
           * }
           *)
          '  .method public hidebysig static %s[] %s(int32 low, int32 high, %s[] \'array\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #); out.nl;
          '  {' -> out.putln;
          '    .maxstack  5' -> out.putln;
          '    .locals init ([0] int32 newsize,' -> out.putln;
          '                  [1] %s[] newArray)' -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'   -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    ldarg.2'   -> out.putln;
          '    ldlen'     -> out.putln;
          '    conv.i4'   -> out.putln;
          '    call  void BetaArray::CkSR(int32,int32,int32)' -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    sub'       -> out.putln;
          '    ldc.i4.1'  -> out.putln;
          '    add'       -> out.putln;
          '    stloc.0'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    bge.s  L1' -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    stloc.0'   -> out.putln;
          '  L1:'         -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    newarr  %s' -> out.putformat(# do type[]->s #); out.nl;
          '    stloc.1'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ble.s  L2' -> out.putln;
          '    ldarg.2'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    ldc.i4.1'  -> out.putln;
          '    sub'       -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)'    -> out.putln;
          '  L2:'         -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ret'       -> out.putln;
          '  }'           -> out.putln;
          out.nl;
       #);
    
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: BetaArray\n'
     '//********************************************\n'
     '.class public auto ansi BetaArray\n'
     '  extends [mscorlib]System.Object\n'
     '{' -> out.putln;
     out.nl;
          
     ('ExtVRZ', 'bool'   )   -> emitExtVR;
     ('ExtVR1', 'char'   )   -> emitExtVR;
     ('ExtVR2', 'int16'  )   -> emitExtVR;
     ('ExtVR4', 'int32'  )   -> emitExtVR;
     ('ExtVR8', 'float64')   -> emitExtVR;
     
     ('CopyVRZ', 'bool'   )  -> emitCopyVR;
     ('CopyVR1', 'char'   )  -> emitCopyVR;
     ('CopyVR2', 'int16'  )  -> emitCopyVR;
     ('CopyVR4', 'int32'  )  -> emitCopyVR;
     ('CopyVR8', 'float64')  -> emitCopyVR;
     
     ('CopySVRZ', 'bool'   ) -> emitCopySVR;
     ('CopySVR1', 'char'   ) -> emitCopySVR;
     ('CopySVR2', 'int16'  ) -> emitCopySVR;
     ('CopySVR4', 'int32'  ) -> emitCopySVR;
     ('CopySVR8', 'float64') -> emitCopySVR;
    
     (* Method: CkSR:
      *   public static void CkSR(int low, int high, int range) 
      *   {
      *       // Check that low and high are usable. 
      *       if (low<1) 
      *           throw new System.IndexOutOfRangeException("Repetition subrange out of bounds (low): " 
      *                                                      + low 
      *                                                      + "<1");
      *       if (range<high) 
      *           throw new System.IndexOutOfRangeException("Repetition subrange out of bounds (high): "
      *                                                      + high
      *                                                      + ">"
      *                                                      + range);
      *   }
      *)
     '  .method public hidebysig static void  CkSR(int32 low,int32 high,int32 range) cil managed'  -> out.putln;
     '  {'  -> out.putln;
     '    .maxstack  3'-> out.putln;
     '    .locals init ([0] object[])'  -> out.putln;
     '    ldarg.0'     -> out.putln;
     '    ldc.i4.1'    -> out.putln;
     '    bge.s  L1'   -> out.putln;
     '    ldstr  "Repetition subrange out of bounds (low): "'  -> out.putln;
     '    ldarg.0'     -> out.putln;
     '    box  [mscorlib]System.Int32' -> out.putln;
     '    ldstr  "<1"' -> out.putln;
     '    call  string [mscorlib]System.String::Concat(object,object,object)'  -> out.putln;
     '    newobj  instance void [mscorlib]System.IndexOutOfRangeException::.ctor(string)'  -> out.putln;
     '    throw'       -> out.putln;
     '  L1:'           -> out.putln;
     '    ldarg.2'     -> out.putln;
     '    ldarg.1'     -> out.putln;
     '    bge.s  L2'   -> out.putln;
     '    ldc.i4.4'    -> out.putln;
     '    newarr  [mscorlib]System.Object'  -> out.putln;
     '    stloc.0'     -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.0'    -> out.putln;
     '    ldstr  "Repetition subrange out of bounds (high): "'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.1'    -> out.putln;
     '    ldarg.1'  -> out.putln;
     '    box  [mscorlib]System.Int32'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.2'    -> out.putln;
     '    ldstr  ">"'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.3'    -> out.putln;
     '    ldarg.2'     -> out.putln;
     '    box  [mscorlib]System.Int32'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    call  string [mscorlib]System.String::Concat(object[])'  -> out.putln;
     '    newobj  instance void [mscorlib]System.IndexOutOfRangeException::.ctor(string)'  -> out.putln;
     '    throw'       -> out.putln;
     '  L2:'           -> out.putln;
     '    ret'         -> out.putln;
     '  }'             -> out.putln;
     
     out.nl;
     
     '  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed'  -> out.putln;
     '  {'  -> out.putln;
     '    .maxstack  1'  -> out.putln;
     '    ldarg.0'  -> out.putln;
     '    call  instance void [mscorlib]System.Object::.ctor()'  -> out.putln;
     '    ret'  -> out.putln;
     '  } '  -> out.putln;
     
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);

GenerateClassComponent:
  (# 
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: Component\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit Component extends [mscorlib]System.Object' -> out.putln;
     '{' -> out.putln;
     '  .field public static class Component current' -> out.putln;
     '  .field private class Component caller' -> out.putln;
     '  .field private %s body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  .field private class [mscorlib]System.Threading.Thread thread' -> out.putln;
     
     (*   Component(BetaObject b) { 
      *     body = b; 
      *     thread = new System.Threading.Thread(new System.Threading.ThreadStart(run));
      *     thread.IsBackground = true;
      *     b._comp = this;
      *     caller = this;
      *   }
      *)
     out.nl;
     '  .method public hidebysig specialname rtspecialname instance void  .ctor(%s b) cil managed' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  {' -> out.putln;
     '  .maxstack  4' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call       instance void [mscorlib]System.Object::.ctor()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  stfld      %s Component::body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  ldarg.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldftn      instance void Component::run()' -> out.putln;
     '  newobj     instance void [mscorlib]System.Threading.ThreadStart::.ctor(object,native int)' -> out.putln;
     '  newobj     instance void [mscorlib]System.Threading.Thread::.ctor(class [mscorlib]System.Threading.ThreadStart)' -> out.putln;
     '  stfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  callvirt   instance void [mscorlib]System.Threading.Thread::set_IsBackground(bool)' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  stfld      %s %s::_comp' -> out.putformat(# do sigComponent->s; sigBetaObject->s #); out.nl;
     '  ldarg.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  stfld      class Component Component::caller' -> out.putln;
     '  ret' -> out.putline;
     '  } ' -> out.putln;
     
     (*   private void run() 
      *     { 
      *       body.@do();
      *       lock(this) { 
      * 	System.Threading.Monitor.Pulse(this);
      *       }
      *     }
      *)
     out.nl;
     '  .method private hidebysig instance void run() cil managed' -> out.putln;
     '  {' -> out.putln;
     '    .maxstack  2' -> out.putln;
     '    .locals init ([0] class Component)' -> out.putln;
     '    ldarg.0' -> out.putln;
     '    ldfld      %s Component::body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '    callvirt   instance void %s::do()' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '    ldarg.0' -> out.putln;
     '    dup' -> out.putln;
     '    stloc.0' -> out.putln;
     '    call       void [mscorlib]System.Threading.Monitor::Enter(object)' -> out.putln;
     '    .try' -> out.putln;
     '    {' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Pulse(object)' -> out.putln;
     '      leave.s    L1' -> out.putln;
     '    } ' -> out.putln;
     '    finally' -> out.putln;
     '    {' -> out.putln;
     '      ldloc.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Exit(object)' -> out.putln;
     '      endfinally' -> out.putln;
     '    } ' -> out.putln;
     '  L1:' -> out.putln;
     '    ret' -> out.putln;
     '  } ' -> out.putln;
     
     (*   public void swap()
      *     { 
      *       lock (this){
      * 	Component next = current;
      * 	current = caller;
      * 	caller = next;
      * 	if (!thread.IsAlive) {
      * 	  thread.Start(); // only relevant if attach
      * 	} else { 
      * 	  System.Threading.Monitor.Pulse(this);
      * 	}
      * 	System.Threading.Monitor.Wait(this);
      *       }
      *     }
      *)
     out.nl;
     '  .method public hidebysig instance void swap() cil managed' -> out.putln;
     '  {' -> out.putln;
     '    .maxstack  2' -> out.putln;
     '    .locals init ([0] class Component next,' -> out.putln;
     '                  [1] class Component )' -> out.putln;
     '    ldarg.0' -> out.putln;
     '    dup' -> out.putln;
     '    stloc.1' -> out.putln;
     '    call       void [mscorlib]System.Threading.Monitor::Enter(object)' -> out.putln;
     '    .try' -> out.putln;
     '    {' -> out.putln;
     '      ldsfld     class Component Component::current' -> out.putln;
     '      stloc.0' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class Component Component::caller' -> out.putln;
     '      stsfld     class Component Component::current' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldloc.0' -> out.putln;
     '      stfld      class Component Component::caller' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '      callvirt   instance bool [mscorlib]System.Threading.Thread::get_IsAlive()' -> out.putln;
     '      brtrue.s   L1' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '      callvirt   instance void [mscorlib]System.Threading.Thread::Start()' -> out.putln;
     '      br.s       L2' -> out.putln;
     '    L1:' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Pulse(object)' -> out.putln;
     '    L2:' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       bool [mscorlib]System.Threading.Monitor::Wait(object)' -> out.putln;
     '      pop' -> out.putln;
     '      leave.s    L3' -> out.putln;
     '    }  ' -> out.putln;
     '    finally' -> out.putln;
     '    {' -> out.putln;
     '      ldloc.1' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Exit(object)' -> out.putln;
     '      endfinally' -> out.putln;
     '    } ' -> out.putln;
     '  L3:' -> out.putln;
     '    ret' -> out.putln;
     '  }' -> out.putln;
     '}' -> out.putln;
     out.indent.restore;
  #);
