ORIGIN 'BCmachineBody'; 
INCLUDE '~beta/basiclib/formatio'; 

(* Support classes needed by the generated .NET code.
 * Generated as part of compiling basic BETA environment.
 *)


--BCmachineLib: attributes--

newArray:
  (# type: ^text
  enter type[]
  do out.nl;
     'newarr ' -> out.puttext; 
     type[] -> out.puttext;
  #);

sigStructure:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'Structure\'' -> T.putformat(# do common.StructureLocation->s #);
  exit T[]
  #);

sigBetaArray:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'BetaArray\'' -> T.putformat(# do common.BetaArrayLocation->s #);
  exit T[]
  #);

sigBetaObject:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'BetaObject\'' -> T.putformat(# do common.BetaObjectLocation->s #);
  exit T[]
  #);

sigComponent:
  (# T: ^Text;
  do &Text[] -> T[];
     'class [\'%s\']\'%s\'' -> T.putformat(# do common.ComponentLocation->s; common.ComponentClass->s #);
  exit T[]
  #);


GenerateClassExOException:
  (# 
     (*
      * using System;
      * 
      * public class ExOException : Exception
      * {
      * 
      *   public object exitobj;
      *   public int labno;
      *   
      *   // Constructor used for object checking
      *   public ExOException (object e, int l) 
      *     {
      *       exitobj = e;
      *       labno = l;
      *     }
      * }
      *)
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: ExOException\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit ExOException\n'
     '       extends [mscorlib]System.Exception\n'
     '{' -> out.putln;
     '.field public object exitobj' -> out.putln;
     '.field public int32 labno' -> out.putln;
     out.putln;
     '.method public hidebysig specialname rtspecialname '
     'instance void  .ctor(object e, int32 l) cil managed'
       -> out.putln;
     out.indent.inc;
     '{' -> out.putln;
     '.maxstack  2' -> out.putln;
     'ldarg.0' -> out.putln;
     'call  instance void [mscorlib]System.Exception::.ctor()' -> out.putln;
     'ldarg.0' -> out.putln;
     'ldarg.1' -> out.putln;
     'stfld  object ExOException::exitobj' -> out.putln;
     'ldarg.0' -> out.putln;
     'ldarg.2' -> out.putln;
     'stfld  int32 ExOException::labno' -> out.putln;
     'ret' -> out.putline;
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);

GenerateClassStructure:
  (# 
     (*
      * public class Structure {
      * 
      *     private System.Object iOrigin;
      *     private System.Type iProto;
      *     private System.Reflection.ConstructorInfo iConstructor;
      * 
      *     static Structure(){
      * 	System.Console.WriteLine("\nUSING Structure.cs!\n");
      *     }
      * 
      *     public Structure(System.Object o, System.Type p){
      * 	iOrigin = o;
      * 	iProto = p;
      * 	iConstructor = null;
      *     }
      *   
      *     public static Structure AlloS(System.Object o, System.Type p) {
      * 	return new Structure(o, p);
      *     }
      *   
      *     public static Structure ObjS(System.Object o){
      * 	System.Type proto = o.GetType();
      * 	System.Reflection.FieldInfo origin_field = proto.GetField("origin");
      * 	System.Object origin = origin_field.GetValue(o);
      * 	return new Structure(origin, proto);
      *     }
      * 
      *     public System.Object AlloSI(){
      * 	System.Reflection.ConstructorInfo[] constructors = iProto.GetConstructors();
      * 	if (iConstructor == null){
      * 	  for (int i = 0; i < constructors.Length; i++) {
      * 	    //System.Console.WriteLine("AlloSI: constructor: " + constructors[i].Name);
      * 	    System.Reflection.ParameterInfo[] parameters = constructors[i].GetParameters();
      * 	    if (parameters.Length == 1){
      * 	      //System.Console.WriteLine("Has one parameter of type: " + parameters[0].ParameterType.FullName);
      * 	      if (parameters[0].ParameterType.IsAssignableFrom(iOrigin.GetType())){
      * 		iConstructor = constructors[i];
      * 		break;
      * 	      }
      * 	    }
      * 	  }
      * 	}
      * #if false
      * 	if (iConstructor==null){
      * 	    System.Console.WriteLine("AlloSI:\tNo constructor with parameter type (origin)\n\t'" + iOrigin.GetType().FullName + "' found in class '" + iProto.FullName + "'!");
      * 	}
      * #endif
      * 	return iConstructor.Invoke(new System.Object[]{iOrigin});
      *     }
      *   
      *     public static bool eqS(Structure arg1, Structure arg2) {
      * 	if (arg1==null) {
      * 	    if (arg2==null)
      * 		return true;
      * 	    return false;
      * 	}
      * 	if (arg2==null)
      * 	    return false;
      * 	if (arg1.iProto != arg2.iProto)
      * 	    return false;
      * 	if (arg1.iOrigin != arg2.iOrigin)
      * 	    return false;
      * 	return true;
      *     }
      * 
      *     public static bool neS(Structure arg1, Structure arg2) {
      * 	return !eqS(arg1, arg2);
      *     }
      * 
      *     public static bool leS(Structure arg1, Structure arg2) { 
      * 	return (eqS(arg1, arg2) || ltS(arg1, arg2));
      *     }
      * 
      *     public static bool geS(Structure arg1, Structure arg2) { 
      * 	return (eqS(arg1, arg2) || gtS(arg1, arg2));
      *     }
      * 
      *     public static bool gtS(Structure arg1, Structure arg2){
      * 	return ltS(arg2, arg1);
      *     }
      *   
      *     public static bool ltS(Structure arg1, Structure arg2){
      * 	System.Type proto1;
      * 	System.Type proto2;
      * 	if (arg1==null) return false;
      * 	if (arg2==null) return false;
      * 	proto1 = arg1.iProto;
      * 	proto2 = arg2.iProto;
      * 	if (proto1 == proto2) return false;
      * 	  
      * 	for (proto1 = proto1.BaseType;
      * 	     proto1 != null;
      * 	     proto1 = proto1.BaseType) {
      * 	    if (proto1 == proto2) {
      * 		if (false){
      * 		  //return arg1.iOrigin == arg2.iOrigin;
      * 		} else {
      * 		    System.Object newObject = arg1.AlloSI();
      * 		    System.Reflection.FieldInfo origin_field = proto1.GetField("origin");
      * 		    return origin_field.GetValue(newObject) == arg2.iOrigin;
      * 		}
      * 	    }
      * 	}
      * 	return false; 
      *     }
      * }
      *)
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: Structure\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit Structure\n'
     '  extends [mscorlib]System.Object\n'
     '{' -> out.putln;
     '.field public class [mscorlib]System.Object iOrigin' -> out.putln;
     '.field public class [mscorlib]System.Type iProto' -> out.putln;
     '.field private class [mscorlib]System.Reflection.ConstructorInfo iConstructor' -> out.putln;
     out.nl;
     
     '.method public hidebysig specialname rtspecialname instance void .ctor(class [mscorlib]System.Object, class [mscorlib]System.Type) cil managed' 
       -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call instance void [mscorlib]System.Object::.ctor()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  stfld  object Structure::iOrigin' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.2' -> out.putln;
     '  stfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldnull' -> out.putln;
     '  stfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  ret' -> out.putln;
     '} ' -> out.putln;
     out.nl;
     
     '.method public hidebysig static class Structure AlloS(class [mscorlib]System.Object o, class [mscorlib]System.Type p) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  3' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  newobj  instance void Structure::.ctor(object, class [mscorlib]System.Type)' -> out.putln;
     '  ret' -> out.putln;
     '  } ' -> out.putln;
     out.nl;
     
     '.method public hidebysig static class Structure '
     'ObjS(class [mscorlib]System.Object o) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  3' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Type proto,' -> out.putln;
     '  [1] class [mscorlib]System.Reflection.FieldInfo origin_field,' -> out.putln;
     '  [2] class [mscorlib]System.Object origin)' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldstr  "origin"' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(class [mscorlib]System.String)' -> out.putln;
     '  stloc.1' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Object [mscorlib]System.Reflection.FieldInfo::GetValue(class [mscorlib]System.Object)' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.2' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  newobj  instance void Structure::.ctor(class [mscorlib]System.Object,' -> out.putln;
     '  class [mscorlib]System.Type)' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig instance class [mscorlib]System.Object AlloSI() cil managed' -> out.putln;
     '  {' -> out.putln;
     '  .maxstack  4' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Reflection.ConstructorInfo[],' -> out.putln;
     '  [1] int32,' -> out.putln;
     '  [2] class [mscorlib]System.Reflection.ParameterInfo[],' -> out.putln;
     '  [3] class [mscorlib]System.Object[])' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.ConstructorInfo[] [mscorlib]System.Type::GetConstructors()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  stloc.1' -> out.putln;
     '  br.s  L2' -> out.putln;
     
     'L4:' -> out.putln;  '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  callvirt   instance class [mscorlib]System.Reflection.ParameterInfo[] [mscorlib]System.Reflection.MethodBase::GetParameters()' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.2' -> out.putln;
     '  ldlen' -> out.putln;
     '  conv.i4' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  bne.un.s  L3' -> out.putln;
     
     '  ldloc.2' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Reflection.ParameterInfo::get_ParameterType()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()' -> out.putln;
     '  callvirt  instance bool [mscorlib]System.Type::IsAssignableFrom(class [mscorlib]System.Type)' -> out.putln;
     '  brfalse.s  L3' -> out.putln;
     
     '  ldarg.0' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  ldelem.ref' -> out.putln;
     '  stfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  br.s  L1' -> out.putln;
     
     'L3:' -> out.putln;  '  ldloc.1' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  add' -> out.putln;
     '  stloc.1' -> out.putln;
     'L2:' -> out.putln;  '  ldloc.1' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldlen' -> out.putln;
     '  conv.i4' -> out.putln;
     '  blt.s  L4' -> out.putln;
     
     'L1:' -> out.putln; '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Reflection.ConstructorInfo Structure::iConstructor' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  newarr  [mscorlib]System.Object' -> out.putln;
     '  stloc.3' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  stelem.ref' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  callvirt   instance object [mscorlib]System.Reflection.ConstructorInfo::Invoke(object[])' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool eqS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  brtrue.s  L2' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     'L2:' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  brtrue.s  L3' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L3:' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  beq.s  L4' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L4:' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  beq.s  L5' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     'L5:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  neS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  ldc.i4.0' -> out.putln;
     '  ceq' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  leS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::ltS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     
     '.method public hidebysig static bool  geS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::eqS(class Structure, class Structure)' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  call  bool Structure::gtS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     'L1:' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  gtS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call  bool Structure::ltS(class Structure, class Structure)' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     out.nl;
     
     '.method public hidebysig static bool  ltS(class Structure arg1, class Structure arg2) cil managed' -> out.putln;
     '{' -> out.putln;
     '  .maxstack  2' -> out.putln;
     '  .locals init ([0] class [mscorlib]System.Type proto1,' -> out.putln;
     '  [1] class [mscorlib]System.Type proto2,' -> out.putln;
     '  [2] class [mscorlib]System.Object newObject,' -> out.putln;
     '  [3] class [mscorlib]System.Reflection.FieldInfo origin_field)' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  brtrue.s  L1' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L1:' -> out.putln; '  ldarg.1' -> out.putln;
     '  brtrue.s  L2' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L2:' -> out.putln; '  ldarg.0' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  stloc.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Type Structure::iProto' -> out.putln;
     '  stloc.1' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  bne.un.s  L3' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     
     'L3:' -> out.putln; '  ldloc.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Type::get_BaseType()' -> out.putln;
     '  stloc.0' -> out.putln;
     '  br.s  L4' -> out.putln;
     
     'L6:' -> out.putln;'  ldloc.0' -> out.putln;
     '  ldloc.1' -> out.putln;
     '  bne.un.s  L5' -> out.putln;
     
     '  ldarg.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Object Structure::AlloSI()' -> out.putln;
     '  stloc.2' -> out.putln;
     '  ldloc.0' -> out.putln;
     '  ldstr  "origin"' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(class [mscorlib]System.String)' -> out.putln;
     '  stloc.3' -> out.putln;
     '  ldloc.3' -> out.putln;
     '  ldloc.2' -> out.putln;
    '   callvirt   instance class [mscorlib]System.Object [mscorlib]System.Reflection.FieldInfo::GetValue(object)' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldfld  class [mscorlib]System.Object Structure::iOrigin' -> out.putln;
     '  ceq' -> out.putln;
     '  ret' -> out.putln;
     
     'L5:' -> out.putln; '  ldloc.0' -> out.putln;
     '  callvirt  instance class [mscorlib]System.Type [mscorlib]System.Type::get_BaseType()' -> out.putln;
     '  stloc.0' -> out.putln;
     'L4:' -> out.putln; '  ldloc.0' -> out.putln;
     '  brtrue.s  L6' -> out.putln;
     
     '  ldc.i4.0' -> out.putln;
     '  ret' -> out.putln;
     '}' -> out.putln;
     
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);


GenerateClassBetaArray:
  (# 
     (*
      * public class BetaArray {
      * 
      *     static BetaArray(){
      * 	System.Console.WriteLine("\nUSING BetaArray.cs!\n");
      *     }
      *   
      *     public static char[] ExtVR1(char[] array, int add) {
      * 	int copysize = array.Length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	char[] newArray = new char[newsize];
      * 	System.Array.Copy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopyVR1(char[] array) {
      * 	int size = array.Length;
      * 	// cannot happen: if (size<0) size = 0;
      * 	char[] newArray = new char[size];
      * 	System.Array.Copy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static char[] CopySVR1(int low, int high, char[] array) 
      *     {
      * 
      * 	CkSR(low, high, array.Length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	char[] newArray = new char[newsize];
      * 	if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static bool[] ExtVRZ(bool[] array, int add) {
      * 	int copysize = array.Length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	bool[] newArray = new bool[newsize];
      * 	System.Array.Copy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static bool[] CopyVRZ(bool[] array) {
      * 	int size = array.Length;
      * 	// cannot happen: if (size<0) size = 0;
      * 	bool[] newArray = new bool[size];
      * 	System.Array.Copy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static bool[] CopySVRZ(int low, int high,bool[] array) 
      *     {
      * 
      * 	CkSR(low, high, array.Length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	bool[] newArray = new bool[newsize];
      * 	if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] ExtVR2(short[] array, int add) {
      * 	int copysize = array.Length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	short[] newArray = new short[newsize];
      * 	System.Array.Copy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopyVR2(short[] array) {
      * 	int size = array.Length;
      * 	// cannot happen: if (size<0) size = 0;
      * 	short[] newArray = new short[size];
      * 	System.Array.Copy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static short[] CopySVR2(int low, int high,short[] array) 
      *     {
      * 
      * 	CkSR(low, high, array.Length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	short[] newArray = new short[newsize];
      * 	if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] ExtVR4(int[] array, int add) {
      * 	int copysize = array.Length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	int[] newArray = new int[newsize];
      * 	System.Array.Copy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopyVR4(int[] array) {
      * 	int size = array.Length;
      * 	// cannot happen: if (size<0) size = 0;
      * 	int[] newArray = new int[size];
      * 	System.Array.Copy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static int[] CopySVR4(int low, int high,int[] array) 
      *     {
      * 
      * 	CkSR(low, high, array.Length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	int[] newArray = new int[newsize];
      * 	if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] ExtVR8(double[] array, int add) {
      * 	int copysize = array.Length;
      * 	int newsize  = copysize + add;
      * 	if (newsize<0) newsize = 0;
      * 	if (copysize>newsize) copysize = newsize;
      * 	double[] newArray = new double[newsize];
      * 	System.Array.Copy(array, 0, newArray, 0, copysize);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopyVR8(double[] array) {
      * 	int size = array.Length;
      * 	// cannot happen: if (size<0) size = 0;
      * 	double[] newArray = new double[size];
      * 	System.Array.Copy(array, 0, newArray, 0, size);
      * 	return newArray;
      *     }
      * 
      *     public static double[] CopySVR8(int low, int high,double[] array) 
      *     {
      * 
      * 	CkSR(low, high, array.Length);
      *       
      * 	int newsize = high - low + 1;
      * 	if (newsize<0) newsize = 0;
      * 	double[] newArray = new double[newsize];
      * 	if (newsize>0) System.Array.Copy(array, low-1, newArray, 0, newsize);
      * 	return newArray;
      *     }
      * 
      * 
      *     public static void CkSR(int low, int high, int range) 
      *     {
      * 	// Check that low and high are usable. 
      * 	if (low<1) 
      * 	    throw new System.IndexOutOfRangeException("Repetition subrange out of bounds (low): " 
      * 						       + low 
      * 						       + "<1");
      * 	if (range<high) 
      * 	    throw new System.IndexOutOfRangeException("Repetition subrange out of bounds (high): "
      * 						       + high
      * 						       + ">"
      * 						       + range);
      *     }
      * 
      * }
      *)
     
     emitExtVR:
       (# name, type: ^text;
       enter (name[], type[])
       do '  .method public hidebysig static %s[] %s(%s[] \'array\', int32 \'add\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #);
          '  {' -> out.putln;
          '    .maxstack  5' -> out.putln;
          '    .locals init ([0] int32 copysize,' -> out.putln;
          '                  [1] int32 newsize,' -> out.putln;
          '                  [2] %s[] newArray)' -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'   -> out.putln;
          '    ldlen'     -> out.putln;
          '    conv.i4'   -> out.putln;
          '    stloc.0'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    add'       -> out.putln;
          '    stloc.1'   -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    bge.s  L1' -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    stloc.1'   -> out.putln;
          '  L1:'         -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ble.s  L2' -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    stloc.0'   -> out.putln;
          '    L2:'       -> out.putln;
          '    ldloc.1'   -> out.putln;
          type[] -> newArray;
          '    stloc.2'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.2'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
          '    ldloc.2'   -> out.putln;
          '    ret'       -> out.putln;
          '  }'           -> out.putln;
          out.nl;
       #);
   
     emitCopyVR:
       (# name, type: ^text;
       enter (name[], type[])
       do '  .method public hidebysig static %s[] %s(%s[] \'array\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #); out.nl;
          '  {'            -> out.putln;
          '    .maxstack 5'-> out.putln;
          '    .locals init ([0] int32 size,'  -> out.putln;
          '                  [1] %s[] newArray)'  -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'    -> out.putln;
          '    ldlen'      -> out.putln;
          '    conv.i4'    -> out.putln;
          '    stloc.0'    -> out.putln;
          '    ldloc.0'    -> out.putln;
          '    newarr  %s' -> out.putformat(# do type[]->s #); out.nl;
          '    stloc.1'    -> out.putln;
          '    ldarg.0'    -> out.putln;
          '    ldc.i4.0'   -> out.putln;
          '    ldloc.1'    -> out.putln;
          '    ldc.i4.0'   -> out.putln;
          '    ldloc.0'    -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)'     -> out.putln;
          '    ldloc.1'    -> out.putln;
          '    ret'        -> out.putln;
          '  }'            -> out.putln;
          out.nl;
       #);
     
     emitCopySVR:
       (# name, type: ^text;
       enter (name[], type[])
       do '  .method public hidebysig static %s[] %s(int32 low, int32 high, %s[] \'array\') cil managed' 
            -> out.putformat(# do type[]->s; name[]->s; type[]->s; #); out.nl;
          '  {' -> out.putln;
          '    .maxstack  5' -> out.putln;
          '    .locals init ([0] int32 newsize,' -> out.putln;
          '                  [1] %s[] newArray)' -> out.putformat(# do type[]->s #); out.nl;
          '    ldarg.0'   -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    ldarg.2'   -> out.putln;
          '    ldlen'     -> out.putln;
          '    conv.i4'   -> out.putln;
          '    call  void BetaArray::CkSR(int32,int32,int32)' -> out.putln;
          '    ldarg.1'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    sub'       -> out.putln;
          '    ldc.i4.1'  -> out.putln;
          '    add'       -> out.putln;
          '    stloc.0'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    bge.s  L1' -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    stloc.0'   -> out.putln;
          '  L1:'         -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    newarr  %s' -> out.putformat(# do type[]->s #); out.nl;
          '    stloc.1'   -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ble.s  L2' -> out.putln;
          '    ldarg.2'   -> out.putln;
          '    ldarg.0'   -> out.putln;
          '    ldc.i4.1'  -> out.putln;
          '    sub'       -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ldc.i4.0'  -> out.putln;
          '    ldloc.0'   -> out.putln;
          '    call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)'    -> out.putln;
          '  L2:'         -> out.putln;
          '    ldloc.1'   -> out.putln;
          '    ret'       -> out.putln;
          '  }'           -> out.putln;
          out.nl;
       #);
    
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: BetaArray\n'
     '//********************************************\n'
     '.class public auto ansi BetaArray\n'
     '  extends [mscorlib]System.Object\n'
     '{' -> out.putln;
     out.nl;
          
     ('ExtVRZ', 'bool'   )   -> emitExtVR;
     ('ExtVR1', 'char'   )   -> emitExtVR;
     ('ExtVRB', 'int8'   )   -> emitExtVR;
     ('ExtVR2', 'int16'  )   -> emitExtVR;
     ('ExtVR4', 'int32'  )   -> emitExtVR;
     ('ExtVR8', 'float64')   -> emitExtVR;
     
     ('CopyVRZ', 'bool'   )  -> emitCopyVR;
     ('CopyVR1', 'char'   )  -> emitCopyVR;
     ('CopyVRB', 'int8'   )  -> emitCopyVR;
     ('CopyVR2', 'int16'  )  -> emitCopyVR;
     ('CopyVR4', 'int32'  )  -> emitCopyVR;
     ('CopyVR8', 'float64')  -> emitCopyVR;
     
     ('CopySVRZ', 'bool'   ) -> emitCopySVR;
     ('CopySVR1', 'char'   ) -> emitCopySVR;
     ('CopySVRB', 'int8'   ) -> emitCopySVR;
     ('CopySVR2', 'int16'  ) -> emitCopySVR;
     ('CopySVR4', 'int32'  ) -> emitCopySVR;
     ('CopySVR8', 'float64') -> emitCopySVR;
    
     (* Method: CkSR: *)
     '  .method public hidebysig static void  CkSR(int32 low,int32 high,int32 range) cil managed'  -> out.putln;
     '  {'  -> out.putln;
     '    .maxstack  3'-> out.putln;
     '    .locals init ([0] object[])'  -> out.putln;
     '    ldarg.0'     -> out.putln;
     '    ldc.i4.1'    -> out.putln;
     '    bge.s  L1'   -> out.putln;
     '    ldstr  "Repetition subrange out of bounds (low): "'  -> out.putln;
     '    ldarg.0'     -> out.putln;
     '    box  [mscorlib]System.Int32' -> out.putln;
     '    ldstr  "<1"' -> out.putln;
     '    call  string [mscorlib]System.String::Concat(object,object,object)'  -> out.putln;
     '    newobj  instance void [mscorlib]System.IndexOutOfRangeException::.ctor(string)'  -> out.putln;
     '    throw'       -> out.putln;
     '  L1:'           -> out.putln;
     '    ldarg.2'     -> out.putln;
     '    ldarg.1'     -> out.putln;
     '    bge.s  L2'   -> out.putln;
     '    ldc.i4.4'    -> out.putln;
     '    newarr  [mscorlib]System.Object'  -> out.putln;
     '    stloc.0'     -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.0'    -> out.putln;
     '    ldstr  "Repetition subrange out of bounds (high): "'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.1'    -> out.putln;
     '    ldarg.1'  -> out.putln;
     '    box  [mscorlib]System.Int32'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.2'    -> out.putln;
     '    ldstr  ">"'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    ldc.i4.3'    -> out.putln;
     '    ldarg.2'     -> out.putln;
     '    box  [mscorlib]System.Int32'  -> out.putln;
     '    stelem.ref'  -> out.putln;
     '    ldloc.0'     -> out.putln;
     '    call  string [mscorlib]System.String::Concat(object[])'  -> out.putln;
     '    newobj  instance void [mscorlib]System.IndexOutOfRangeException::.ctor(string)'  -> out.putln;
     '    throw'       -> out.putln;
     '  L2:'           -> out.putln;
     '    ret'         -> out.putln;
     '  }'             -> out.putln;
     
     out.nl;
     
     '  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed'  -> out.putln;
     '  {'  -> out.putln;
     '    .maxstack  1'  -> out.putln;
     '    ldarg.0'  -> out.putln;
     '    call  instance void [mscorlib]System.Object::.ctor()'  -> out.putln;
     '    ret'  -> out.putln;
     '  } '  -> out.putln;
     
     out.indent.dec;
     out.indent;
     '}' -> out.putline;
     out.indent.restore;
  #);

GenerateClassComponent:
  (# 
     (*
      * // nbeta tstenv
      * // csc -t:library -r:clr/tstenv.dll Component.cs
      * 
      * public class Component
      * { public static Component current;
      *   private Component caller;
      *   private BetaObject body;
      *   private System.Threading.Thread thread;
      * 
      *   Component(BetaObject b) { 
      *     body = b; 
      *     thread = new System.Threading.Thread(new System.Threading.ThreadStart(run));
      *     thread.IsBackground = true;
      *     b._comp = this;
      *     caller = this;
      *   }
      * 
      *   private void run() 
      *     { 
      *       body.xdo();
      *       lock(this) { 
      * 	System.Threading.Monitor.Pulse(this);
      *       }
      *     }
      * 
      *   public void swap()
      *     { 
      *       lock (this){
      * 	Component X = current;
      * 	current = caller;
      * 	caller = X;
      * 	if (!thread.IsAlive) {
      * 	  thread.Start(); // only relevant if attach
      * 	} else { 
      * 	  System.Threading.Monitor.Pulse(this);
      * 	}
      * 	System.Threading.Monitor.Wait(this);
      *       }
      *     }
      * 
      * #if ATT_NEEDED
      *   public void att()
      *     { 
      *       lock (this){
      * 	caller = current;
      * 	current = this;
      * 	if (!thread.IsAlive){
      * 	  thread.Start();
      * 	} else {
      * 	  System.Threading.Monitor.Pulse(this);
      * 	}
      * 	System.Threading.Monitor.Wait(this);
      *       }
      *     }
      * #endif
      * 
      * #if SUSP_NEEDED
      *   public void susp()
      *     { 
      *       lock (this){
      * 	current = caller;
      * 	System.Threading.Monitor.Pulse(this);
      * 	System.Threading.Monitor.Wait(this);
      *       } 
      *     }
      * #endif
      * 
      * }
      *)
     
  do out.indent.save;
     0 -> out.indent.set;
     out.indent.inc;
     '\n'
     '//********************************************\n'
     '//*       Class: Component\n'
     '//********************************************\n'
     '.class public auto ansi beforefieldinit Component extends [mscorlib]System.Object' -> out.putln;
     '{' -> out.putln;
     '  .field public static class Component current' -> out.putln;
     '  .field private class Component caller' -> out.putln;
     '  .field private %s body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  .field private class [mscorlib]System.Threading.Thread thread' -> out.putln;
     
     (* Method: Component(BetaObject b): *)
     out.nl;
     '  .method public hidebysig specialname rtspecialname instance void  .ctor(%s b) cil managed' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  {' -> out.putln;
     '  .maxstack  4' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  call       instance void [mscorlib]System.Object::.ctor()' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  stfld      %s Component::body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '  ldarg.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldftn      instance void Component::run()' -> out.putln;
     '  newobj     instance void [mscorlib]System.Threading.ThreadStart::.ctor(object,native int)' -> out.putln;
     '  newobj     instance void [mscorlib]System.Threading.Thread::.ctor(class [mscorlib]System.Threading.ThreadStart)' -> out.putln;
     '  stfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '  ldc.i4.1' -> out.putln;
     '  callvirt   instance void [mscorlib]System.Threading.Thread::set_IsBackground(bool)' -> out.putln;
     '  ldarg.1' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  stfld      %s %s::_comp' -> out.putformat(# do sigComponent->s; sigBetaObject->s #); out.nl;
     '  ldarg.0' -> out.putln;
     '  ldarg.0' -> out.putln;
     '  stfld      class Component Component::caller' -> out.putln;
     '  ret' -> out.putline;
     '  } ' -> out.putln;
     
     out.nl;
     '  .method private hidebysig instance void run() cil managed' -> out.putln;
     '  {' -> out.putln;
     '    .maxstack  2' -> out.putln;
     '    .locals init ([0] class Component)' -> out.putln;
     '    ldarg.0' -> out.putln;
     '    ldfld      %s Component::body' -> out.putformat(# do sigBetaObject->s #); out.nl;
     '    callvirt   instance void %s::%s()' -> out.putformat(# do sigBetaObject->s; common.doMethod->s #); out.nl;
     '    ldarg.0' -> out.putln;
     '    dup' -> out.putln;
     '    stloc.0' -> out.putln;
     '    call       void [mscorlib]System.Threading.Monitor::Enter(object)' -> out.putln;
     '    .try' -> out.putln;
     '    {' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Pulse(object)' -> out.putln;
     '      leave.s    L1' -> out.putln;
     '    } ' -> out.putln;
     '    finally' -> out.putln;
     '    {' -> out.putln;
     '      ldloc.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Exit(object)' -> out.putln;
     '      endfinally' -> out.putln;
     '    } ' -> out.putln;
     '  L1:' -> out.putln;
     '    ret' -> out.putln;
     '  } ' -> out.putln;
     
     out.nl;
     '  .method public hidebysig instance void swap() cil managed' -> out.putln;
     '  {' -> out.putln;
     '    .maxstack  2' -> out.putln;
     '    .locals init ([0] class Component next,' -> out.putln;
     '                  [1] class Component )' -> out.putln;
     '    ldarg.0' -> out.putln;
     '    dup' -> out.putln;
     '    stloc.1' -> out.putln;
     '    call       void [mscorlib]System.Threading.Monitor::Enter(object)' -> out.putln;
     '    .try' -> out.putln;
     '    {' -> out.putln;
     '      ldsfld     class Component Component::current' -> out.putln;
     '      stloc.0' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class Component Component::caller' -> out.putln;
     '      stsfld     class Component Component::current' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldloc.0' -> out.putln;
     '      stfld      class Component Component::caller' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '      callvirt   instance bool [mscorlib]System.Threading.Thread::get_IsAlive()' -> out.putln;
     '      brtrue.s   L1' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      ldfld      class [mscorlib]System.Threading.Thread Component::thread' -> out.putln;
     '      callvirt   instance void [mscorlib]System.Threading.Thread::Start()' -> out.putln;
     '      br.s       L2' -> out.putln;
     '    L1:' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Pulse(object)' -> out.putln;
     '    L2:' -> out.putln;
     '      ldarg.0' -> out.putln;
     '      call       bool [mscorlib]System.Threading.Monitor::Wait(object)' -> out.putln;
     '      pop' -> out.putln;
     '      leave.s    L3' -> out.putln;
     '    }  ' -> out.putln;
     '    finally' -> out.putln;
     '    {' -> out.putln;
     '      ldloc.1' -> out.putln;
     '      call       void [mscorlib]System.Threading.Monitor::Exit(object)' -> out.putln;
     '      endfinally' -> out.putln;
     '    } ' -> out.putln;
     '  L3:' -> out.putln;
     '    ret' -> out.putln;
     '  }' -> out.putln;
     '}' -> out.putln;
     out.indent.restore;
  #);
