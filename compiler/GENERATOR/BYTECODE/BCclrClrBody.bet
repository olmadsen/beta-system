ORIGIN 'BCclrMstate';
INCLUDE '~beta/dotnetlib/System/Reflection/Assembly';
INCLUDE '~beta/dotnetlib/System/Reflection/AssemblyName';
INCLUDE '~beta/dotnetlib/System/Version';
INCLUDE '~beta/dotnetlib/beta_helpers';

--ImportAssemblyVersion: descriptor--
(# 
do mstate.out.indent.inc;
   ' {' -> mstate.out.puttext;
   (if is_external then
       (# version, publickeytoken: ^text;
       do assemblyname[]
            -> lookupAssemblyVersion 
            -> (version[], publickeytoken[]);
          mstate.out.nl;
          '.ver %s'
            -> mstate.out.putformat(# do version[]->s; #);
          mstate.out.nl;
          '.publickeytoken = (%s)'
            -> mstate.out.putformat(# do publickeytoken[]->s #);
          mstate.out.newline;
       #)
    else
       mstate.out.nl;
       '.ver %s'
         -> mstate.out.putformat(# do defaultversion->s; #);
       mstate.out.newline;                       
   if);
   mstate.out.indent.dec;
   '}' -> mstate.out.putln;
#)

--GacUtil: descriptor--
(# as: ^Assembly;
   an: ^AssemblyName;
   vs: ^Version;
   pk: [0]@int8u;
   i: @integer;
do assname[] -> Assembly.LoadWithPartialName_string -> as[];
   (if as[]<>NONE then
       as.GetName -> an[];
       (if an[]<>NONE then
           an.get_Version -> vs[];
           (if vs[]<>NONE then
               vs.ToString -> assvers[];
           if);
           (if false then
               (* problems with int8u arrays *)
               an.GetPublickeyToken -> pk[];
               &text[]->publickeytoken[];
               (for i:pk.range repeat
                    pk[i]->publickeytoken.put;
               for)
            else
               an[] -> BetaHelpers.AssemblyNameGetPublicKeyToken -> publickeytoken[];
           if)
       if)
   if)   
#)

