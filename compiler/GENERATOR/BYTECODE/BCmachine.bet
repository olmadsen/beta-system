ORIGIN '../machine';
INCLUDE '~beta/sysutils/binarystream';
INCLUDE '~beta/basiclib/file';
INCLUDE '../asmlink';
INCLUDE '../../compiler';
INCLUDE '../JAVA/javaimage';
BODY 'BCmachineBody';
-- machinefactorylib: Attributes --
isJava:  (# exit common.targetMachineId = common.jvm #);
isIL:    (# exit common.targetMachineId = common.clr #);
BCmachine:
  (#
     <<SLOT BCmachineLib: attributes>>;
     betaenv_name: 
       (# exit common.betaenv.groupname #); 
     thisO: (#  exit 1 #);
     callO: (#  exit 2 #);
     
     pushCst_s8: (#  exit 1 #);
     pushVal: (#  exit 2 #);
     pushReg: (#  exit 3 #);
     stVal: (#  exit 4 #);
     index: (#  exit 5 #);
     cmpAndJmp: (#  exit 6 #);
     call: (#  exit 7 #);
     return: (#  exit 8 #);
     labelDef: (#  exit 9 #);
     label: (#  exit 10 #);
     callPrim: (#  exit 11 #);

     end: (#  exit 13 #);
     pushText: (#  exit 14 #);
     pushAdr: (#  exit 15 #);
     loadRef: (# exit 16 #);
     storeRef: (#  exit 17 #);
     storeQref: (#  exit 18 #);
     loadOrigin: (# exit 19 #);
     loadQref: (# exit 20 #);
     storeOrigin: (# exit 21 #);
     
     cmpToBool: (# exit 22 #);
     pushCst_s16: (#  exit 23 #);
     pushCst_s32: (#  exit 24 #);
     
     classDef: (# exit 25 #);
     methodDef: (# exit 26 #);
     endClass: (# exit 27 #);
     cmpBoolAndJmp: (# exit 28 #);
     cmpToBoolRef: (#exit 29 #);
     
     jmp: (#  exit 30 #);
     callInner: (# exit 31 #);
     newVirt: (# exit 32 #);
     pushNone: (# exit 33 #);
     jmpt: (# exit 34 #); (* like jmp, but with text argument *)
     initCons: (# exit 40 #);
     field: (# exit 41 #);
     callExternal: (# exit 42 #);
     dup: (#exit 43 #);
     loadRange: (#exit 44 #);
     pop: (# exit 45 #);
     loadLocal: (# exit 47 #);
     _loadLocal: (# exit loadLocal #);
     pushRealCst: (# exit 48 #);
     pop2: (# exit 49 #);
     func: (#  exit 50 #);
     add: (#  exit 51 #);
     sub: (#  exit 52 #);
     orr: (#  exit 53 #);
     andd: (#  exit 54 #);
     xorr: (#  exit 55 #);
     cmp: (#  exit 56 #);
     mult: (#  exit 57 #);
     divv: (#  exit 58 #);
     modd: (#  exit 59 #);
     nott: (#  exit 60 #);
     logNot: (#  exit 61 #);
     neg: (#  exit 62 #);
     arithShiftLeft: (# exit 63 #);
     logicalShiftLeft: (# exit 64 #);
     arithShiftRight: (# exit 65 #);
     logicalShiftRight: (# exit 66 #);
     rotateLeft: (# exit 67 #);
     rotateRight: (# exit 68 #);
     byteSwapLong: (# exit 69 #);
     byteSwapShort: (# exit 70 #);
     
     r64tor32: (# exit 71 #);
     r64Add: (# exit 72 #);
     r64Sub: (# exit 73 #);
     r64Mul: (# exit 74 #);
     r64Div: (# exit 75 #);
     r64Neg: (# exit 76 #);
     int2double: (# exit 77 #);
     double2int: (# exit 78 #);
     
     cmpAndJmpFloat: (# exit 79 #);
     cmpToBoolFloat: (# exit 80 #);
     beginLab: (# exit 91 #);
     break: (# exit 92 #);
     endLab: (# exit 93 #);
     cast: (# exit 94 #);
     endMethod: (# exit 95 #);
     (* NOTE: 
      * when adding new opcodes, remember to add them
      * to the asText method below too
      *)
     
     comment: (# exit 100 #);
     nop: (# exit 101 #);
     position: (# exit 102 #);
     
     astext:
       (# opCode: @integer; T: @text
       enter opCode
       do
          (if opCode
           // pushCst_s8 then 'pushCst_s8' (*1*) -> T;
           // pushVal then 'pushVal' (*2*) -> T;
           // pushReg then 'pushReg' (*3*) -> T;
           // stVal then 'stVal' (*4*) -> T;
           // index then 'index' (*5*) -> T;
           // cmpAndJmp then 'cmpAndJmp' (*6*) -> T;
           // call then 'call' (*7*) -> T;
           // return then 'return' (*8*) -> T;
           // labelDef then 'labelDef' (*9*) -> T;
           // label then 'label' (*10*) -> T;
           // callPrim then 'callPrim' (*11*) -> T;
           // end then 'end' (*13*) -> T;
           // pushText then 'pushText' (*14*) -> T;
           // pushAdr then 'pushAdr' (*15*) -> T;
           // loadRef then 'loadRef' (*16*) -> T;
           // storeRef then 'storeRef' (*17*) -> T;
           // storeQref then 'storeQref' (*18*) -> T;
           // loadOrigin then 'loadOrigin' (*19*) -> T;
           // loadQref then 'loadQref' (*20*) -> T;
           // storeOrigin then 'storeOrigin' (*21*) -> T;
           // cmpToBool then 'cmpToBool' (*22*) -> T;
           // pushCst_s16 then 'pushCst_s16' (*23*) -> T;
           // pushCst_s32 then 'pushCst_s32' (*24*) -> T;
           // classDef then 'classDef' (*25*) -> T;
           // methodDef then 'methodDef' (*26*) -> T;
           // endClass then 'endClass' (*27*) -> T;
           // cmpBoolAndJmp then 'cmpBoolAndJmp' (*28*) -> T;
           // cmpToBoolRef then 'cmpToBoolRef' (*29*) -> T;
           // jmp then 'jmp' (*30*) -> T;
           // callInner then 'callInner' (*31*) -> T;
           // newVirt then 'newVirt' (*32*) -> T;
           // pushNone then 'pushNone' (*33*) -> T;
           // initCons then 'initCons' (*40*) -> T;
           // field then 'field' (*41*) -> T;
           // callExternal then 'callExternal' (*42*) -> T;
           // dup then 'dup' (*43*) -> T;
           // loadRange then 'loadRange' (*44*) -> T;
           // pop then 'pop' (*45*) -> T;
           // loadLocal then 'loadLocal' (*47*) -> T;
           // pop2 then 'pop2' (*49*) -> T;
           // func then 'func' (*50*) -> T;
           // add then 'add' (*51*) -> T;
           // sub then 'sub' (*52*) -> T;
           // orr then 'orr' (*53*) -> T;
           // andd then 'andd' (*54*) -> T;
           // xorr then 'xorr' (*55*) -> T;
           // cmp then 'cmp' (*56*) -> T;
           // mult then 'mult' (*57*) -> T;
           // divv then 'divv' (*58*) -> T;
           // modd then 'modd' (*59*) -> T;
           // nott then 'nott' (*60*) -> T;
           // logNot then 'logNot' (*61*) -> T;
           // neg then 'neg' (*62*) -> T;
           // arithShiftLeft then 'arithShiftLeft' (*63*) -> T;
           // logicalShiftLeft then 'logicalShiftLeft' (*64*) -> T;
           // arithShiftRight then 'arithShiftRight' (*65*) -> T;
           // logicalShiftRight then 'logicalShiftRight' (*66*) -> T;
           // rotateLeft then 'rotateLeft' (*67*) -> T;
           // rotateRight then 'rotateRight' (*68*) -> T;
           // byteSwapLong then 'byteSwapLong' (*69*) -> T;
           // byteSwapShort then 'byteSwapShort' (*70*) -> T;
           // r64sub then 'r64sub' (*73*) -> T;
           // r64mul then 'r64mul' (*74*) -> T;
           // r64div then 'r64div' (*75*) -> T;
           // r64neg then 'r64neg' (*76*) -> T;
           // int2double then 'int2double' (*77*) -> T;
           // double2int then 'double2int' (*78*) -> T;
           // cmpAndJmpFloat then 'cmpAndJmpFloat' (*79*) -> T;
           // cmpToBoolFloat then 'cmpToBoolFloat' (*80*) -> T;
           // beginLab then 'beginLab' (*91*) -> T;
           // break then 'break' (*92*) -> T;
           // endLab then 'endLab' (*93*) -> T;
           // cast then 'cast' (*94*) -> T
           // endMethod then 'endMethod' (*95*) -> T
           // comment then 'comment' (*100*) -> T;
           // nop then 'nop' (*101*) -> T;
           // position then 'position' (*102*) -> T;
           else
              '<' -> T;
              '?'->T.put; opCode->T.putint; '?'->T.put;
              '>' -> T.put;
          if)
       exit T[]
       #);
     imports: @
       (# L: [100] ^text; top: @integer;
          clear: (#do 0 -> top #);
          has: booleanValue
            (# id: ^text
            enter id[]
            do (for i: top repeat
                    (if id[] -> L[i].equal then 
                        true -> value; 
                        leave has 
            if)for)#);
          add:
            (# id: ^text
            enter id[]
            do (if not (id[] -> has) then
                   (if (top+1->top) > L.range then L.range -> L.extend if);
                   id[] -> L[top][];
               if)
            #);
          scan:
            (# current: ^text
            do (for i: top repeat
                    L[i][] -> current[];
                    inner;
               for)
            #)
       #);

     dump:
       (# <<SLOT byteCode_dump:dopart>>
       #);
     emitClr: <<SLOT emitClr:Descriptor>>;
     emitJasmin:
       (#  <<SLOT emitJasmin:DoPart>> #);
     save:
       (# name: ^text
       enter name[]
       do name[]->BC.save
       #);
     restore:
       (# name: ^text
       enter name[]
       do (*'restore '->screen.puttext; name[] -> screen.putline;*)
          name[]->BC.restore;
          (name.length-3,name.length) -> name.delete;
          (if (not common.switch[184]) or common.switch[189] then
              (*FIXME: THIS(InteractiveCompiler).comp.trans.asmlink.asmExt -> name.append *)
              (if true
               // common.targetMachineId = common.jvm then
                  (*'.J' -> name.append;*)
               // common.targetMachineId = common.clr then
                  '.il' -> name.append;
               else
                  'restore: unknown platform' -> screen.putline;
              if);
          if);
          name[] -> openOut;
       #);
     OutFile: File
       (# indent: @
            (# i: @integer;
               inc: 
                 (# x:@integer 
                 enter x 
                 do (if trace then '/*indent.inc:'->puttext; x->putint; if);
                    (if x=0 then default->x if); 
                    i+x->i;
                    (if trace then '=>'->puttext; i->putint; '*/'->puttext if);
                 #);
               dec: 
                 (# x:@integer 
                 enter x 
                 do (if trace then '/*indent.dec:'->puttext; x->putint; if);
                    (if x=0 then default->x if); 
                    (if x>i then
                        0 -> i;
                        (if trace then '=>'->puttext; i->putint; '!!*/'->puttext if);
                     else
                        i-x->i;
                        (if trace then '=>'->puttext; i->putint; '*/'->puttext if);
                    if);
                 #);
               set:
                 (# enter i #);
               save:
                 (# do i -> saved_i #);
               restore:
                 (# do saved_i -> i #);
               saved_i: @integer;
               default: (# exit 4 #);
               trace: @boolean;
               p: @put;
            do (if i>0 then (for i repeat ' '->p for); if);
            #);
          nl: @
            (# n: @newline;
            do n; indent #);
          putln: 
            (# p: @putline; T: ^text enter T[] do T[]->p; indent #);
          
       #);
     openOut:
       (# fn: ^text;
          e: @diskentry;
       enter fn[]
       do (if isIL then
              &OutFile[] -> out[];
              fn[] -> out.name;
              (if not common.switch[188] then
                  '\n'
                  ' [' -> screen.puttext;
                  fn[] -> e.path;
                  e.path.name -> screen.puttext;
                  ']' -> screen.puttext;
              if);
              out.openWrite;
           else
              &JavaImage[] -> jcf[];
              not common.switch[188]
                -> jcf.display_warnings;
              (common.verboselevel<=common.verboselevel.verbose)
                -> jcf.traceClassFileName;
              common.switch[190] 
                -> jcf.traceClassFile;
              true
                -> jcf.local_variables_always_live_until_exit;
              false
                -> jcf.report_undefined_local_variable_use;
              
              '.J' -> fn.stripExtension;
              '.class' -> fn.AppendExtension;
              (if false then
                  (* Strip /jvm/ from class file path *)
                  (# e: @diskentry;
                     f: ^text;
                  do fn[] -> e.path;
                     e.path.name -> f[];
                     e.path.head -> e.path;
                     e.path.head -> fn[];
                     directorychar -> fn.put;
                     f[] -> fn.append;
                  #);
              if);
              fn[] -> jcf.init;
              
          if);
       #);
     init:< (# do BC.init; INNER #);
     BCstate: @ <<SLOT BCstate:descriptor>>;
     
     BC: @BinaryStream;
     out: ^OutFile;
     jcf: ^JavaImage;
     trace:
       (# xT:
            (# T: ^text
            enter T[]
            do T[]->screen.putText
            #);
          xI:
            (# n: @integer
            enter n
            do
               ' '->xC;
               n->screen.putInt;
               ' '->xC
            #);
          xC:
            (# ch: @char
            enter ch
            do ch->screen.put
            #);
          xB:
            (# b: @boolean
            enter b
            do
               (if b then
                   ' true '->xT
                else
                   ' false '->xT
               if)
            #);
          xN:
            (# 
            do screen.newline
            #);
          N: @integer;
          
       enter N
       do
          (if common.switch[N] then
              xN;
              '%'->xC;
              N->screen.putInt;
              ':'->xC;
              ' '->xC;
              INNER
          if)
       #);
     cTrace: trace (#  do INNER #);

  #)  

