ORIGIN '../machine';
INCLUDE '~beta/sysutils/binarystream';
INCLUDE '~beta/basiclib/file';
INCLUDE '../asmlink';
INCLUDE '../../compiler';
INCLUDE '../JAVA/javaimage';
BODY 'BCmachineBody';
-- machinefactorylib: Attributes --
isJava:  (# exit common.targetMachineId = common.javabc #);
isIL:    (# exit common.targetMachineId = common.dotnet #);
BCmachine:
  (#
     <<SLOT BCmachineLib: attributes>>;
     betaenv: (# exit 'tstenv' #); (*  preliminary *)
     thisO: (#  exit 1 #);
     callO: (#  exit 2 #);
     
     pushCst_s8: (#  exit 1 #);
     pushVal: (#  exit 2 #);
     pushReg: (#  exit 3 #);
     stVal: (#  exit 4 #);
     index: (#  exit 5 #);
     cmpAndJmp: (#  exit 6 #);
     call: (#  exit 7 #);
     return: (#  exit 8 #);
     labelDef: (#  exit 9 #);
     label: (#  exit 10 #);
     callPrim: (#  exit 11 #);

     end: (#  exit 13 #);
     pushText: (#  exit 14 #);
     pushAdr: (#  exit 15 #);
     loadRef: (# exit 16 #);
     storeRef: (#  exit 17 #);
     storeQref: (#  exit 18 #);
     loadOrigin: (# exit 19 #);
     loadQref: (# exit 20 #);
     storeOrigin: (# exit 21 #);
     
     cmpToBool: (# exit 22 #);
     pushCst_s16: (#  exit 23 #);
     pushCst_s32: (#  exit 24 #);
     
     classDef: (# exit 25 #);
     methodDef: (# exit 26 #);
     endClass: (# exit 27 #);
     cmpBoolAndJmp: (# exit 28 #);
     
     jmp: (#  exit 30 #);
     callInner: (# exit 31 #);
     newVirt: (# exit 32 #);
     pushNone: (# exit 33 #);
     
     initCons: (# exit 40 #);
     field: (# exit 41 #);
     callExternal: (# exit 42 #);
     dup: (#exit 43 #);
     loadRange: (#exit 44 #);
     pop: (# exit 45 #);
     allocAndStoreLocal: (# exit 46 #);
     loadLocal: (# exit 47 #);
     _loadLocal: (# exit loadLocal #);
     
     func: (#  exit 50 #);
     add: (#  exit 51 #);
     sub: (#  exit 52 #);
     orr: (#  exit 53 #);
     andd: (#  exit 54 #);
     xorr: (#  exit 55 #);
     cmp: (#  exit 56 #);
     mult: (#  exit 57 #);
     divv: (#  exit 58 #);
     modd: (#  exit 59 #);
     nott: (#  exit 60 #);
     logNot: (#  exit 61 #);
     neg: (#  exit 62 #);
     arithShiftLeft: (# exit 63 #);
     logicalShiftLeft: (# exit 64 #);
     arithShiftRight: (# exit 65 #);
     logicalShiftRight: (# exit 66 #);
     rotateLeft: (# exit 67 #);
     rotateRight: (# exit 68 #);
     
     comment: (# exit 100 #);
     nop: (# exit 101 #);
     position: (# exit 102 #);
     
     astext:
       (# opCode: @integer; T: @text
       enter opCode
       do
          (if opCode
           // pushCst_s8 then
              'pushCst_s8'->T
           // pushVal then
              'pushVal'->T
           // pushReg then
              'pushReg'->T
           // stVal then
              'stVal'->T
           // index then
              'index'->T
           // cmpAndJmp then
              'cmpAndJmp'->T
           // call then
              'call'->T
           // return then
              'return\n'->T
           // label then
              'L'->T
           // callPrim then
              'callPrim'->T
           // end then
              'end'->T
           // pushText then
              'pushText'->T
           // pushAdr then
              'pushAdr'->T
           // loadRef then 'loadRef'->T
           // storeRef then
              'storeRef'->T
           // storeQref then
              'storeQref'->T
           // jmp then
              'jmp'->T
           // func then
              'FUNC'->T
           // add then
              'add'->T
           // sub then
              'sub'->T
           // orr then
              'or'->T
           // andd then
              'and'->T
           // xorr then
              'xor'->T
           // cmp then
              'cmp'->T
           // mult then
              'mult'->T
           // divv then
              'div'->T
           // modd then
              'mod'->T
           // nott then
              'not'->T
           // logNot then
              'logNot'->T
           // neg then
              'neg'->T
           // arithShiftLeft then
              'arithShiftLeft'->T
           // logicalShiftLeft then
              'logicalShiftLeft'->T
           // arithShiftRight then
              'arithShiftRight'->T
           // logicalShiftRight then
              'logicalShiftRight'->T
           // rotateLeft then
              'rotateLeft'->T
           // rotateRight then
              'rotateRight'->T
           // comment then
              'comment'->T
           // nop then
              'nop'->T
           // position then
              'position'->T
           else
              '<' -> T;
              '?'->T.put; opCode->T.putint; '?'->T.put;
              '>' -> T.put;
          if)
       exit T[]
       #);
     imports: @
       (# L: [100] ^text; top: @integer;
          clear: (#do 0 -> top #);
          has: booleanValue
            (# id: ^text
            enter id[]
            do (for i: top repeat
                    (if id[] -> L[i].equal then 
                        true -> value; 
                        leave has 
            if)for)#);
          add:
            (# id: ^text
            enter id[]
            do (if not (id[] -> has) then
                   (if (top+1->top) > L.range then L.range -> L.extend if);
                   id[] -> L[top][];
               if)
            #);
          scan:
            (# current: ^text
            do (for i: top repeat
                    L[i][] -> current[];
                    inner;
               for)
            #)
       #);

     dump:
       (# <<SLOT byteCode_dump:dopart>>
       #);
     emitDotNet: <<SLOT emitDotNet:Descriptor>>;
     emitJasmin:
       (#  <<SLOT emitJasmin:DoPart>> #);
     save:
       (# name: ^text
       enter name[]
       do name[]->BC.save
       #);
     restore:
       (# name: ^text
       enter name[]
       do (*'restore '->screen.puttext; name[] -> screen.putline;*)
          name[]->BC.restore;
          (name.length-3,name.length) -> name.delete;
          (if (not common.switch[184]) or common.switch[189] then
              (*FIXME: THIS(InteractiveCompiler).comp.trans.asmlink.asmExt -> name.append *)
              (if true
               // common.targetMachineId = common.javabc then
                  (*'.J' -> name.append;*)
               // common.targetMachineId = common.dotnet then
                  '.il' -> name.append;
               else
                  'restore: unknown platform' -> screen.putline;
              if);
          if);
          name[] -> openOut;
       #);
     openOut:
       (# fn: ^text;
          e: @diskentry;
       enter fn[]
       do (if isIL then
              &file[] -> out[];
              fn[] -> out.name;
              (if not common.switch[188] then
                  '\n'
                  ' [' -> screen.puttext;
                  fn[] -> e.path;
                  e.path.name -> screen.puttext;
                  ']' -> screen.puttext;
              if);
              out.openWrite;
           else
              &JavaImage[] -> jcf[];
              not common.switch[188] -> jcf.traceClassFileName;
              common.switch[190] -> jcf.traceClassFile;
              '.J' -> fn.stripExtension;
              '.class' -> fn.AppendExtension;
              (if false then
                  (* Strip /javabc/ from class file path *)
                  (# e: @diskentry;
                     f: ^text;
                  do fn[] -> e.path;
                     e.path.name -> f[];
                     e.path.head -> e.path;
                     e.path.head -> fn[];
                     directorychar -> fn.put;
                     f[] -> fn.append;
                  #);
              if);
              fn[] -> jcf.init;
              
          if);
       #);
     init:< (# do BC.init; INNER #);
     BCstate: @ <<SLOT BCstate:descriptor>>;
     
     BC: @BinaryStream;
     out: ^file;
     jcf: ^JavaImage;
     trace:
       (# xT:
            (# T: ^text
            enter T[]
            do T[]->screen.putText
            #);
          xI:
            (# n: @integer
            enter n
            do
               ' '->xC;
               n->screen.putInt;
               ' '->xC
            #);
          xC:
            (# ch: @char
            enter ch
            do ch->screen.put
            #);
          xB:
            (# b: @boolean
            enter b
            do
               (if b then
                   ' true '->xT
                else
                   ' false '->xT
               if)
            #);
          xN:
            (# 
            do screen.newline
            #);
          N: @integer;
          
       enter N
       do
          (if common.switch[N] then
              xN;
              '%'->xC;
              N->screen.putInt;
              ':'->xC;
              ' '->xC;
              INNER
          if)
       #);
     cTrace: trace (#  do INNER #);

  #)  

