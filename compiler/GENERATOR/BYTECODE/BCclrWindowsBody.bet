ORIGIN 'BCclrMstate';
INCLUDE '~beta/basiclib/pcre'; 

--ImportAssemblyVersion: descriptor--
(# 
do mstate.out.indent.inc;
   ' {' -> mstate.out.puttext;
   (if is_external then
       (# version, publickeytoken: ^text;
       do assemblyname[]
            -> lookupAssemblyVersion 
            -> (version[], publickeytoken[]);
          mstate.out.nl;
          '.ver %s'
            -> mstate.out.putformat(# do version[]->s; #);
          mstate.out.nl;
          '.publickeytoken = (%s)'
            -> mstate.out.putformat(# do publickeytoken[]->s #);
          mstate.out.newline;
       #)
    else
       mstate.out.nl;
       '.ver %s'
         -> mstate.out.putformat(# do defaultversion->s; #);
       mstate.out.newline;                       
   if);
   mstate.out.indent.dec;
   '}' -> mstate.out.putln;
#)

--GacUtil: descriptor--
(# gac, gacline: ^text;
   cmd: ^text;
   gacutil_output: @file;
   gacutil_found: @boolean;
   system: external
     (# cmd: [0]@char
     enter cmd
     #);
   regexp: @pcre;
   (* FIXME: 
    * could call gacutil -l and match "assemblyname, version=xxxx", 
    * or use IMetaDataAssemblyImport from unmanaged API 
    *)
do (* Special cases: The following siz basic libraries have 
    * version 1:0:3300:0 in ROTOR and 1:0:5000:0 in .Net 1.1
    * meaning that code using them compiled on ROTOR will work on .NET 
    * (global redirection?) but not the other way around. 
    * So we answer the ROTOR version
    *)
   
   (if true
    // 'mscorlib' -> assname.equal 
    // 'System' -> assname.equal 
    // 'System.Data' -> assname.equal 
    // 'System.Runtime.Remoting' -> assname.equal 
    // 'System.Windows.Forms' -> assname.equal 
    // 'System.Xml' -> assname.equal then
       '1:0:3300:0' -> assvers[];
       'b77a5c561934e089' -> publickeytoken[] (* The so-called ECMA key *)
    else
       '0:0:0:0' -> assvers[]; (* default *)
       'gacutil.exe' -> gac[];
       lookForGacUtil: scanSearchPath
         (# e: @diskentry;
         do path.length->path.setpos;
            DirectoryChar -> path.put;
            gac[] -> (path.copy).append -> e.path;
            (if e.exists then true->gacutil_found; leave lookForGacUtil if);
         #);
       (if not gacutil_found then
           '\n*** gacutil not found. Using default version for '->puttext;
           assname[]->putline;
        else
           (if false then
               (* Calling execReadText apparently hangs in general in windows,
                * if output is more than one line (:-(  
                *)
               ('gacutil','-l') -> (GetSystemenv).execReadText -> gac[];
            else
               &text[] -> cmd[];
               'gacutil -l %s' -> cmd.putformat(# do assname[]->s #);
               (*'\n' -> (cmd.copy).prepend -> screen.putline;*)
               ' > gacutil.out' -> cmd.append;
               cmd -> system;
               'gacutil.out' -> gacutil_output.name;
               gacutil_output.openread;
               &text[] -> gac[];
               read:
                 (if not gacutil_output.eos then
                     gacutil_output.getline -> gac.putline;
                     restart read;
                 if);
               gacutil_output.close;
               gacutil_output.delete;  
               (* find last line of gacutil output matching assemblyname *)
               ', Version=(\\d+)\\.(\\d+)\\.(\\d+)\.(\\d+), Culture=.*, PublicKeyToken=(.*),' 
                 -> (assname.copy).append 
                 -> regexp;
               gac.reset;
               match:
                 (if not gac.eos then
                     gac.getline 
                       -> gacline[];
                     (*gacline[] -> screen.putline;*)
                     gacline[]
                       -> regexp.match(# 
                                      do (*'match of version in GAC'->screen.putline;*)
                                         &text[] -> assvers[];
                                         '%d:%d:%d:%d'
                                           -> assvers.putformat(# sub: ^text;
                                                               do sub1 -> sub[];
                                                                  sub.reset; sub.getint->d;
                                                                  sub2 -> sub[];
                                                                  sub.reset; sub.getint->d;
                                                                  sub3 -> sub[];
                                                                  sub.reset; sub.getint->d;
                                                                  sub4 -> sub[];
                                                                  sub.reset; sub.getint->d;
                                                               #);
                                         sub5 -> publickeytoken[];
                                      #);
                     restart match;
                 if);
           if)
       if)
   if)
#)
