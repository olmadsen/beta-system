ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/toollibs/utils/fileExtensions';

INCLUDE 'BCpreMstate'
--ByteCodeMachinelib: attributes--
oneFile: (# exit true #);

---bytecode_newImp:doPart---
do (if (astRef <> 65535) and (astRef >= 0) then

   if)
   
---byteCode_textOperand_out:doPart---
do T[] -> mstate.textOperandArg[];
   
---byteCode_dataRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_LocalLab_def:doPart---
do (*labNo -> mstate.jcf.labs.def;    *)
   '   L' -> mstate.preF.puttext;
   labNo -> mstate.preF.putint; ':' -> mstate.preF.put;
  (* ' push.argument 0 0\n\tpop'->mstate.preF.puttext;*)
   mstate.preF.newline
  
---byteCode_LocalLab_out:doPart--- (* unused? *)
do labNo -> mstate.localLabArg
   
---byteCode_RegAdr_out:doPart---   
do (if true then
       fieldName[] -> mstate.A.fieldName[];
       fieldType[] -> mstate.A.fieldType[];
       off -> mstate.A.off;
       (if isField then
           1 -> mstate.A.isField;
        else 
           (* A method variable and this should be ok so no error here *)
           0 -> mstate.A.isField
       if);
    else
       fieldName[] -> mstate.preF.puttext;
       ' ' -> mstate.preF.put;
       off -> mstate.preF.putint;    
       ' ' -> mstate.preF.put;
       mstate.fields.numArguments -> mstate.preF.putInt;
   if)
   
---byteCode_RegAdr_index:doPart---
do '\nOBS! RegADr:index:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do fieldName[] -> mstate.A.fieldName[];
   fieldType[] -> mstate.A.fieldType[];
   off -> mstate.A.off;
   2 -> mstate.A.isField; (* isField = 2 signals array *)

---byteCode_nop:doPart---
do '\t; nop\n'->mstate.preF.puttext
   
---byteCode_ldCst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext; 
   C -> mstate.preF.putint;
   mstate.preF.newline;
   
---byteCode_ldNone:doPart---
do  '\tpush.constant 0 ; none' -> mstate.preF.putline;
   
---byteCode_ldValImpl:doPart---
do 
   (if A[] = none then
       'NO_field_defined'->puttext
    else
       (if A.isOrigin then
           (A.ONlevel,A.receiverType[],A.fieldType[]) -> mstate.loadOrigin
        else
           A.out;
           (if A.isField then
               (if mstate.A.isField 
		// 0 then
		   mstate.A.load
		// 2 then
                   'at:' -> mstate.preF.emitsend
                else
                   mstate.A.fieldName[] -> mstate.preF.emitsend;
               if);
            else
               mstate.A.load; 
           if);
       if)
   if)
   
---byteCode_ByteSwap:doPart---
do  '\tswap '->mstate.preF.putline
   
---byteCode_loadRef:doPart---
do A.out;
(if mstate.A.isfield = 0 then mstate.A.loadValue
else
   mstate.A.fieldName[] -> mstate.preF.emitSend(*emitpushfield;*)
if)

---byteCode_stValImpl:doPart---
do A.out;
   (* '\tpop.field ' -> mstate.preF.puttext;*)
   (if mstate.A.isField 
    // 0 then 
(*mstate.A.DISPLAY; ';LOAD'->MSTATE.PREf.PUTLINE;mstate.A.load*)
       mstate.A.store
    // 2 then
       'at:put:' -> mstate.preF.emitsend;
       '\tpop\n' -> mstate.preF.puttext
    else
       ':'->(mstate.A.fieldName.copy).append -> mstate.preF.emitsend;
       '\tpop\n' -> mstate.preF.puttext
   if);


---byteCode_cpReg:doPart---
do (* called from synthesizer, but no code generated *)
      
---byteCode_gLea:doPart---
do '\t; gLea' -> mstate.preF.putline;
   op1.out;
   (if true 
    // op1.isRegAdr then
       mstate.A.pushAdr
    // op1.isInxRegAdr then
       mstate.A.pushAdr
    // op1.isTextOp then
       '\tpush.constant \n' -> mstate.preF.puttext; 
       mstate.textOperandArg[] -> mstate.preF.putline
    else
       '\nglea: operand type not handled'->putline
   if)
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
---bytecode_int64ToInt32:doPart---
do '\t; int64ToInt32\n' -> mstate.preF.puttext
   
---bytecode_int32ToInt64:doPart---
do '\t; int32ToInt64\n' -> mstate.preF.puttext
   
--bytecode_loadRange:doPart--
do 'length' -> mstate.preF.emitsend;
   
---byteCode_duplicate:doPart---
do '\tdup\n' -> mstate.preF.puttext;
  (if type
    // 0 then
       (if pos
        // 0 then
           
        else
           '\t; pos:' -> mstate.preF.puttext;
	   pos -> mstate.preF.putint;
           mstate.preF.newline
       if);
    // 1 then
           '\t; pos:' -> mstate.preF.puttext;
	   pos -> mstate.preF.putint;
           ' type: ' -> mstate.preF.puttext;
           type -> mstate.preF.putint;
           mstate.preF.newline
    // 2 then
           '\t; pos:' -> mstate.preF.puttext;
	   pos -> mstate.preF.putint;
           ' type: ' -> mstate.preF.puttext;
           type -> mstate.preF.putint;
           mstate.preF.newline
   if)
   
---byteCode_allocAndStoreLocal:doPart---
do '; allocandStoreLocal ' -> mstate.preF.putline;
   '\tpop.local 9 0\n' -> mstate.preF.puttext;
   
---byteCode_loadLocal:doPart---
do '; loadLocal ' -> mstate.preF.putline;
   '\tpush.local 9 0\n' -> mstate.preF.puttext;
   
--byteCode_popStack:doPart---
do '\tpop\n' -> mstate.preF.puttext
   
--bytecode_declareField:doPart---
   (* to replace emitCk  *)
do (# F: ^text
   do 'F' -> F[]; off -> F.putInt; (* is F used? *)
      (F[],fieldName[],fieldSig[],fieldKind)
        -> mstate.fields.new;
#);
   (if fieldKind
    // 'c' 
    // 'p' 
    // '['
    // 's' (* synthetic field, like 'comp$' *)
       then
       (* '.field ' -> mstate.preF.puttext;*)
       '  .property ' -> mstate.preF.puttext;
       fieldName[] -> mstate.preF.putline
    // 'm' then
       (if mstate.fields.numCells > mstate.fields.numArguments then
           '\t  .local ' -> mstate.preF.puttext;
           fieldName[] -> mstate.preF.putline
       if);
       mstate.fields.numCells + 1 -> mstate.fields.numCells
    // 'M' // 'C' then (* ???*)
    else

       (failureTrace,'fields.new:Unknown methodClassTag') -> stop
   if);
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do 
   
---byteCode_constructorDef:doPart---
do 1 -> mstate.fields.numArguments;
   '  .instance_method '-> mstate.preF.puttext;
   'CONSTRUCTOR:' -> mstate.preF.emitsymbol;
   ' ; origin is to be supplied as argument' -> mstate.preF.puttext;
   '\n  {\n'-> mstate.preF.puttext;
   '\t.locals 10' -> mstate.preF.putline; (* temporary solution *)
   '\t.maxstacksize 100' -> mstate.preF.putline;
   
---byteCode_tstNone:doPart---
do (* not used *)
   
---byteCode_doAsgRefAdr:doPart---
do thisAdr.out;
   ':' -> (mstate.A.fieldName.copy).append -> mstate.preF.emitsend;
'\t;asgRefAdr\n' -> mstate.preF.puttext


---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   thisAdr.out;
   ':' -> (mstate.A.fieldName.copy).append -> mstate.preF.emitsend;
   '\t;asgRegAdr\n' -> mstate.preF.puttext


---bytecode_checkCast:doPart---
do '\tpush.constant ' -> mstate.preF.puttext;
   type[] -> mstate.preF.putline;
   'checkcast' -> mstate.preF.emitsend;
   
---byteCode_jmpTlong:doPart---
do (* not used *)
   
---byteCode_jmplong:doPart---
do (* not used *)
   
---byteCode_jsrT:doPart---
do (* not used *)
   
--byteCode_gJmp:doPart---
do op.out;
   '\tbranch L' -> mstate.preF.puttext;
   mstate.localLabArg -> mstate.preF.putint;
   mstate.preF.newline
   
--byteCode_gJsr:doPart---
do 
   (# T, class, sig, method: ^text; 
      b: @boolean;
      nargs: @int16;
   do op.out;
      mstate.textOperandArg[] -> T[];
      (if T[] = none then
          '::no_method::'->method[];
       else
          T[]->splitClassSignature->(method[], sig[], b, class[]);
          (* NOTE: 'static' is not encoded in the signature,
           * but the argument 'isStatic' can be used.
           * 'b' is ALWYAS false - should be eliminated
           *)
          (if isStatic then
              (*'\tpush.global ' -> mstate.preF.puttext;
              class[] -> mstate.preF.putline;*)
           else
          if);
      if);
      (* a hack to check if zero or one argument;
       * must parse signature to count noOfArgs
       *)
      (if '()' -> ((1,2)->sig.sub).equal then
       else
          ':'-> method.put
      if);
      method[] -> mstate.preF.emitsend;
   #);
   
---bytecode_beginLabel:doPart---
do (* no code needed here?*)
   
---bytecode_endLabel:doPart---
do '; END label' -> mstate.preF.putline
   
---bytecode_break:doPart---
do  '; BREAK' -> mstate.preF.putline
   
---bytecode_breaksimple:doPart---
do  ';  BREALSIMPLE' -> mstate.preF.putline
   
---byteCode_cmpToBool:doPart--   
do  '; cmpToBool' -> mstate.preF.putline
   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   lab.out;
   (cond,'L',mstate.localLabArg,isRef %band 1) -> mstate.emitCmpJmp    
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   lab.out;  
   (cond,'L',mstate.localLabArg) -> mstate.emitCmpBoolJmp   
   
---byteCode_floatConst:doPart---
do '; Float const' -> mstate.preF.putline
   
---byteCode_saveReturn:doPart---
do (* no code needed here *)
   
---byteCode_return:doPart---
do (if RToff
    // 0 // 10 then (* PRE always return a value *)
       '\tpush.argument 0 0\n' -> mstate.preF.puttext;
    // 1 // 2 // 3 // 4 // 5 then 

    // 6 (* real *) then 

    // 7 (* real32 *) then 

    // 8 (* long=int64 *) then

    // 11 // 12 // 13 // 14 then 

    else 
       'xreturn' -> mstate.jvmFIXME;
   if);
   '\treturn.local\n' -> mstate.preF.puttext;
   
---bytecode_endMethod:doPart---
do '  }\n' -> mstate.preF.puttext
   
---byteCode_callPrim:doPart--
do (T[],'Unknown') -> mstate.emitPrim
   
--byteCode_callAlloPrim:doPart--
do (if proto[] = none then 'UnknownProto' -> proto[] if);
   (T[],proto[]) -> mstate.emitPrim
   
--byteCode_callPrimNo:doPart--
do (if arg[] = none then 'UnknownProto' -> arg[] if);
   (primNo,arg.copy) -> mstate.emitPrimNo
   
---bytecode_import:doPart---
do (if trace_opcodes then 
       (# msg: ^text;
       do 
          '\nimport: '->msg[];
          lab[] -> msg.append;
          msg[]->putline
       #);
   if);
   (if (Lab[] <> none) and ( Lab.length > 0) then
       Lab.copy -> mstate.imports.add 
   if);

---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   opCode -> mstate.emitFunc
   
---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   opCode -> mstate.emitFunc   
   
--byteCode_classDef:doPart--
do (# lastDot: @integer; 
      realClassName,fn: ^text
   do (if mstate.thisFirstClass[] = NONE then
          classname[] -> mstate.thisFirstClass[];
      if);
      className.scanAll
      (# pos: @integer
      do pos+1 -> pos;
         (if ch //  '.' // '\/' then pos -> lastDot if)
      #);          
      (lastDot+1,className.length)
        -> className.sub
        -> realClassName[];
       (* -> mstate.thisFileName[];*)
      (className[],startPos,endPos) -> mstate.classes.add;

(if not oneFile then
     (* mstate.thisFileName[] -> (mstate.thisFullPath.copy).append -> fn[];
      '.pra' -> (fn.copy).AppendExtension -> mstate.preF.name;
      mstate.preF.openWrite;*)
      (*'.bet' 
       -> (mstate.thisSourceFileName.copy).AppendExtension 
       -> mstate.preF.SourceFile;*)
    if);  
      false -> mstate.isMainMethod;
       mstate.fields.init;

      '.class ' -> mstate.preF.puttext;
      className[] -> mstate.preF.putline;
      '.super ' -> mstate.preF.puttext;
      superName[] -> mstate.preF.putline;
      '{'->mstate.preF.putline;
      (* '.instance_side{\n' -> mstate.preF.putline;*)
      (* '.field origin\n'-> mstate.preF.puttext; *)
      '  .property origin\n'-> mstate.preF.puttext;
   #)
   
--byteCode_marknested:doPart---
do 

--byteCode_endClass:doPart---
do (* '\n}\n' -> mstate.preF.puttext;
    * '.class_side { \n'
    *)
   '\n  .class_method ' -> mstate.preF.puttext;
   'new:' -> mstate.preF.emitsymbol;
   ' ; origin is to be supplied as argument' -> mstate.preF.puttext;
   mstate.preF.newline;
   '  {' -> mstate.preF.putLine;
   '\t.locals 10\n\t.maxstacksize 100' -> mstate.preF.putline;
   '\tpush.argument 0 0 ; self' -> mstate.preF.putline;
   'new' -> mstate.preF.emitsupersend;
   '\tpush.argument 1 0 ; origin' -> mstate.preF.putline;
   'CONSTRUCTOR:' -> mstate.preF.emitsend; 
   '\treturn.local\n'
   '  }\n'
   '}\n'
     -> mstate.preF.puttext; 
  (if not oneFile then mstate.preF.emitToFile(*close*) if);

--byteCode_endCodeSeg:doPart---
do 
   
--byteCode_methodDef:doPart--
do (# 
      isStatic: @boolean;
   do methodname[] -> mstate.thisInnerMethodName[];  
      signature[] -> mstate.thisSignature[];
      noOfEnterArgs -> mstate.fields.numArguments;

      0 -> mstate.fields.numCells;
      mstate.thisSignature[] 
        -> splitSignature 
        -> (methodname[], mstate.thisSignature[], isStatic);
      (if isStatic then
          '\n  .class_method ' -> mstate.preF.puttext;       
       else
          '\n  .instance_method ' -> mstate.preF.puttext
      if);
      (for i: noOfEnterArgs repeat ':' -> methodname.put for);
      methodName[] -> mstate.preF.emitsymbol;
      '\n  {\n\t.locals 10\n\t.maxstacksize 100\n'-> mstate.preF.puttext;
   #)
   
--byteCode_emitTextConst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext;
   '"'-> mstate.preF.put; 
   S.scanAll
   (#
   do (if ch < 32 then
          (if ch
           // 10 // 12 then
              '\\n' -> mstate.preF.puttext
           else
              '\?' -> mstate.preF.puttext
          if)
       else
          ch -> mstate.preF.put
      if)
   #);
   '"'-> mstate.preF.put;
   mstate.preF.newline;
      
---byteCode_close:doPart---
do (if oneFile then mstate.preF.emitToFile(*close*) if);

   mstate.mkClassListFile;
   mstate.imports.clear;

---bytecode_real64toReal32:doPart---
do 
   
---bytecode_real32toReal64:doPart---
do 
   
---byteCode_cmpToBoolFloat:doPart--
do 
   
---byteCode_cmpAndJmpFloat:doPart--
do 
---byteCode_addFloat:doPart---
do 
   
---byteCode_subFloat:doPart---
do 
   
---byteCode_mulFloat:doPart---
do 
   
---byteCode_divFloat:doPart---
do 
   
---bytecode_negFloat:doPart---
do 
   
---byteCode_int2float:dopart---
do 
   
---byteCode_intReg2float:dopart---
do 
   
---byteCode_float2int:doPart---
do 
   
---byteCode_CallCproc:doPart---
do T[] -> mstate.emitCallExternal
   
---byteCode_jsrTable:doPart---
do 
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of the assembly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do  (if localFilePath[] = none then
        (* A new pra-file is opened for a form in mstate.thisFileName,
         * i.e. the code of this form is in a seperate file
         * we should make sure that mstate.thisFileName is imported
         * but apparently the synthesizer does this! Otherwise
         * we may import it here.
         * The if-test above is a hack to signal that we are
         * starting on a new file and BCname is the currentFileName  *)
        1->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
        BCname[] -> mstate.thisFileName[]; 
        none -> mstate.thisFirstClass[];
        mstate.classes.init; 
    else
       1 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       mstate.classes.init; (* still ? *)   
       BCname[] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[],mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       (if mstate.thisSourceFileName[] = NONE then
           1->trace(#
                   do 'bytecode_init: '->xT;
                      'mstate.thisSourceFileName is none'->xT
                   #)
       if);

       mstate.thisFullPath.copy -> mstate.thisFullSourcePath[];
       &stream[] -> mstate.commentStream[];
       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);       
   if);
   true -> mstate.notClosed;

---bytecode_setPackagePath:doPart---
do 
   
---bytecode_comment:doPart--
do 
