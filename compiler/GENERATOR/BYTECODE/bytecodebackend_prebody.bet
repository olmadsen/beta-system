ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/toollibs/utils/fileExtensions';

INCLUDE 'BCpreMstate'

---bytecode_newImp:doPart---
do (if (astRef <> 65535) and (astRef >= 0) then

   if)
   
---byteCode_textOperand_out:doPart---
do T[] -> mstate.textOperandArg[];
   
---byteCode_dataRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_LocalLab_def:doPart---
do (*labNo -> mstate.jcf.labs.def;    *)
   '   L' -> mstate.preF.puttext;
   labNo -> mstate.preF.putint; ':' -> mstate.preF.put;
   mstate.preF.newline
  
---byteCode_LocalLab_out:doPart--- (* unused? *)
do labNo -> mstate.localLabArg
   
---byteCode_RegAdr_out:doPart---   
do (if true then
       fieldName[] -> mstate.A.fieldName[];
       fieldType[] -> mstate.A.fieldType[];
       off -> mstate.A.off;
    else
       fieldName[] -> mstate.preF.puttext;
       ' ' -> mstate.preF.put;
       off -> mstate.preF.putint;    
       ' ' -> mstate.preF.put;
       mstate.fields.numArguments -> mstate.preF.putInt;
   if)
   
---byteCode_RegAdr_index:doPart---
do '\nOBS! RegADr:index:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do        fieldName[] -> mstate.A.fieldName[];
       fieldType[] -> mstate.A.fieldType[];
       off -> mstate.A.off;
   2 -> mstate.A.isField; (* isField = 2 signals array *)


---byteCode_nop:doPart---
do 
   
---byteCode_ldCst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext; 
   C -> mstate.preF.putint;
   mstate.preF.newline;
   
---byteCode_ldNone:doPart---
do 
   
---byteCode_ldValImpl:doPart---
do 
   (if A[] = none then
       'NO_field_defined'->puttext
    else
       (if A.isOrigin then
           (A.ONlevel,A.receiverType[],A.fieldType[]) -> mstate.loadOrigin
        else
           A.out;
           (if A.isField then
               '\tpush.field ' -> mstate.preF.puttext;        
               mstate.A.fieldName[] -> mstate.preF.puttext;
               mstate.preF.newline
            else
               mstate.A.load; (*
               '\tpush.local ' -> mstate.preF.puttext;        *)
           if);
       if)
   if)
   
---byteCode_ByteSwap:doPart---
do 
---byteCode_loadRef:doPart---
do A.out;
   '\tpush.field ' -> mstate.preF.puttext;        
   mstate.A.fieldName[] -> mstate.preF.puttext;
   mstate.preF.newline

---byteCode_stValImpl:doPart---
do A.out;
   '\tpop.field ' -> mstate.preF.puttext;
   mstate.A.fieldName[] -> mstate.preF.puttext;
   mstate.preF.newline
   
---byteCode_cpReg:doPart---
do (* called from synthesizer, but no code generated *)
      
---byteCode_gLea:doPart---
do 
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
---bytecode_int64ToInt32:doPart---
do 
   
---bytecode_int32ToInt64:doPart---
do 
   
--bytecode_loadRange:doPart--
do 
   
---byteCode_duplicate:doPart---
do '\tdup\n' -> mstate.preF.puttext
   
---byteCode_allocAndStoreLocal:doPart---
do 
   
---byteCode_loadLocal:doPart---
do 
   
--byteCode_popStack:doPart---
do 
   
--bytecode_declareField:doPart---
   (* to replace emitCk  *)
do (if fieldKind
    // 'c' 
    // 'p' 
    // '['
    // 's' (* synthetic field, like 'comp$' *)
       then
       '.field ' -> mstate.preF.puttext;
       fieldName[] -> mstate.preF.putline
    // 'm' then
       (if mstate.fields.numCells > mstate.fields.numArguments then
           '\t.local ' -> mstate.preF.puttext;
           fieldName[] -> mstate.preF.putline
       if);
       mstate.fields.numCells + 1 -> mstate.fields.numCells
    // 'M' // 'C' then (* ???*)
    else

       (failureTrace,'fields.new:Unknown methodClassTag') -> stop
   if);
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do 
   
---byteCode_constructorDef:doPart---
do '.method CONSTRUCTOR: '
   '// origin is to be supplied as argument' -> mstate.preF.puttext;
   '\n{\n'-> mstate.preF.puttext;
   
---byteCode_tstNone:doPart---
do 
   
---byteCode_doAsgRefAdr:doPart---
do thisAdr.out;
   '\tpop.field ' -> mstate.preF.puttext;
   mstate.A.fieldName[] -> mstate.preF.puttext;
   mstate.preF.newline

---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   thisAdr.out;
   '\tpop.field ' -> mstate.preF.puttext;
   mstate.A.fieldName[] -> mstate.preF.puttext;
   mstate.preF.newline

---bytecode_checkCast:doPart---
do 
   
---byteCode_jmpTlong:doPart---
do 
   
---byteCode_jmplong:doPart---
do 
   
---byteCode_jsrT:doPart---
do 
   
--byteCode_gJmp:doPart---
do op.out;
   '\tjmp L' -> mstate.preF.puttext;
   mstate.localLabArg -> mstate.preF.putint;
   mstate.preF.newline
   
--byteCode_gJsr:doPart---
do 
   (# T, n, d, m: ^text; 
      s: @boolean;
      nargs: @int16;
   do op.out;
      mstate.textOperandArg[] -> T[];
      (if T[] = none then
          '::no_method::'->n[];
       else
          T[]->splitClassSignature->(n[], d[], s, m[]);
          (if isStatic then
              '\tsendstatic ' -> mstate.preF.puttext;
           else
              '\tsend ' -> mstate.preF.puttext;
          if);
      if);
      n[] -> mstate.preF.puttext;
      (* a hack to check if zero or one argument;
       * must parse signature to count noOfArgs
       *)
      (if '()' -> ((1,2)->d.sub).equal then
       else
          ':'-> mstate.preF.put
      if);
      mstate.preF.newline
   #);
   
---bytecode_beginLabel:doPart---
do (* no code needed here?*)
   
---bytecode_endLabel:doPart---
do 
   
---bytecode_break:doPart---
do 
   
---bytecode_breaksimple:doPart---
do 
   
---byteCode_cmpToBool:doPart--   
do 
   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   lab.out;
   (cond,'L',mstate.localLabArg,isRef %band 1) -> mstate.emitCmpJmp    
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   lab.out;  
   (cond,'L',mstate.localLabArg) -> mstate.emitCmpBoolJmp   
   
---byteCode_floatConst:doPart---
do 
   
---byteCode_saveReturn:doPart---
do 
   
---byteCode_return:doPart---
do (if RToff
    // 0 // 10 then (* PRE always return a value *)
       '\tpush.argument 0 0\n' -> mstate.preF.puttext;
    // 1 // 2 // 3 // 4 // 5 then 

    // 6 (* real *) then 

    // 7 (* real32 *) then 

    // 8 (* long=int64 *) then

    // 11 // 12 // 13 // 14 then 

    else 
       'xreturn' -> mstate.jvmFIXME;
   if);
   '\treturn.local\n' -> mstate.preF.puttext;
   
---bytecode_endMethod:doPart---
do '\n}\n' -> mstate.preF.puttext
   
---byteCode_callPrim:doPart--
do 
   
--byteCode_callAlloPrim:doPart--
do 
   
--byteCode_callPrimNo:doPart--
do (if arg[] = none then 'UnknownProto' -> arg[] if);
   (primNo,arg.copy) -> mstate.emitPrimNo
   
---bytecode_import:doPart---
do 
   
---byteCode_callUnFunc:doPart---   
do 
   
---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   opCode -> mstate.emitFunc   
   
--byteCode_classDef:doPart--
do (# lastDot: @integer; 
      realClassName,fn: ^text
   do className.scanAll
      (# pos: @integer
      do pos+1 -> pos;
         (if ch //  '.' // '\/' then pos -> lastDot if)
      #);          
      (lastDot+1,className.length)
        -> className.sub
        -> realClassName[]
        -> mstate.thisFileName[];
      
      mstate.thisFileName[] -> (mstate.thisFullPath.copy).append -> fn[];
      '.class' -> (fn.copy).AppendExtension -> mstate.preF.name;
      mstate.preF.openWrite;
      (*'.bet' 
       -> (mstate.thisSourceFileName.copy).AppendExtension 
       -> mstate.preF.SourceFile;*)
      
      false -> mstate.isMainMethod;
      
      '.class ' -> mstate.preF.puttext;
      className[] -> mstate.preF.putline;
      '.super ' -> mstate.preF.puttext;
      superName[] -> mstate.preF.putline;
      '.instance_side' -> mstate.preF.putline;
      '{\n.field origin\n'-> mstate.preF.puttext;
   #)
   
--byteCode_marknested:doPart---
do 

--byteCode_endClass:doPart---
do '\n}\n' -> mstate.preF.puttext;
   '.class_side { \n'
   '\t.method new: // origin is to be supplied as argument\n'
   '\t{ super new\n'
   '\t  push.argument 0 0 // origin\n'
   '\t  send CONSTRUCTOR:\n'
   '\t  return.local\n'
   '\t}\n'
   '}\n' -> mstate.preF.puttext;
   
--byteCode_endCodeSeg:doPart---
do 
   
--byteCode_methodDef:doPart--
do (# 
      isStatic: @boolean;
   do methodname[] -> mstate.thisInnerMethodName[];  
      signature[] -> mstate.thisSignature[];
      noOfEnterArgs -> mstate.fields.numArguments;
      0 -> mstate.fields.numCells;
      
      mstate.thisSignature[] 
        -> splitSignature 
        -> (methodname[], mstate.thisSignature[], isStatic);
      
      '\n.method ' -> mstate.preF.puttext;
      methodName[] -> mstate.preF.puttext;
      (for i: noOfEnterArgs repeat ':' -> mstate.preF.put for);
      '\n{\n\t.maxstacksize 3\n'-> mstate.preF.puttext;
   #)
   
--byteCode_emitTextConst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext;
   '"'-> mstate.preF.put; 
   S.scanAll
   (#
   do (if ch < 32 then
          (if ch
           // 10 // 12 then
              '\\n' -> mstate.preF.puttext
           else
              '\?' -> mstate.preF.puttext
          if)
       else
          ch -> mstate.preF.put
      if)
   #);
   '"'-> mstate.preF.put;
   mstate.preF.newline;
      
---byteCode_close:doPart---
do mstate.preF.close
   
---bytecode_real64toReal32:doPart---
do 
   
---bytecode_real32toReal64:doPart---
do 
   
---byteCode_cmpToBoolFloat:doPart--
do 
   
---byteCode_cmpAndJmpFloat:doPart--
do 
---byteCode_addFloat:doPart---
do 
   
---byteCode_subFloat:doPart---
do 
   
---byteCode_mulFloat:doPart---
do 
   
---byteCode_divFloat:doPart---
do 
   
---bytecode_negFloat:doPart---
do 
   
---byteCode_int2float:dopart---
do 
   
---byteCode_intReg2float:dopart---
do 
   
---byteCode_float2int:doPart---
do 
   
---byteCode_CallCproc:doPart---
do T[] -> mstate.emitCallExternal
   
---byteCode_jsrTable:doPart---
do 
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of the assembly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do  (if localFilePath[] = none then
       (* hack to signal that BCname is the currentFileName  *)
       183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
       BCname[] -> mstate.thisFileName[];
    else
       183 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       mstate.classes.init; (* still ? *)   
       BCname [] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[],mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       (if mstate.thisSourceFileName[] = NONE then
           1->trace(#
                   do 'bytecode_init: '->xT;
                      'mstate.thisSourceFileName is none'->xT
                   #)
       if);

       mstate.thisFullPath.copy -> mstate.thisFullSourcePath[];
       &stream[] -> mstate.commentStream[];
       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);
       
   if);
---bytecode_setPackagePath:doPart---
do 
   
---bytecode_comment:doPart--
do 
