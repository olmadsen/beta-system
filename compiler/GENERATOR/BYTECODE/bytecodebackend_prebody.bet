ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/toollibs/utils/fileExtensions';

INCLUDE 'BCpreMstate'
--ByteCodeMachinelib: attributes--
oneFile: (# exit true #);

---bytecode_newImp:doPart---
do (if (astRef <> 65535) and (astRef >= 0) then

   if)
   
---byteCode_textOperand_out:doPart---
do T[] -> mstate.textOperandArg[];
   
---byteCode_dataRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_LocalLab_def:doPart---
do (*labNo -> mstate.jcf.labs.def;    *)
   '   L' -> mstate.preF.puttext;
   labNo -> mstate.preF.putint; ':' -> mstate.preF.put;
   mstate.preF.newline
   
---byteCode_LocalLab_out:doPart--- (* unused? *)
do labNo -> mstate.localLabArg
   
---byteCode_RegAdr_out:doPart---   
do (if true then
       fieldName[] -> mstate.A.fieldName[];
       fieldType[] -> mstate.A.fieldType[];
       off -> mstate.A.off;
       inThisObj -> mstate.A.inThisObj;
       (if isField then
           1 -> mstate.A.isField;
        else 
           (* A method variable and this should be ok so no error here *)
           0 -> mstate.A.isField
       if);
       (if isComponent then
           3 -> mstate.A.isField;
           true -> isField;
       if);
    else
       fieldName[] -> mstate.preF.puttext;
       ' ' -> mstate.preF.put;
       off -> mstate.preF.putint;    
       ' ' -> mstate.preF.put;
       mstate.fields.numArguments -> mstate.preF.putInt;
   if)
   
---byteCode_RegAdr_index:doPart---
do '\nOBS! RegADr:index:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do '\t; byteCode_InxRegAdr_out:doPart\n' -> mstate.pref.puttext;
   fieldName[] -> mstate.A.fieldName[];
   fieldType[] -> mstate.A.fieldType[];
   off -> mstate.A.off;
   2 -> mstate.A.isField; (* isField = 2 signals array *)
   inThisObj -> mstate.A.inThisObj;
   
---byteCode_nop:doPart---
do '\t; nop '->mstate.preF.puttext;
   (if n > 0 then n -> mstate.preF.putint if);
   mstate.pref.newline
   
---byteCode_ldCst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext; 
   C -> mstate.preF.putint;
   mstate.preF.newline;
   
---byteCode_ldNone:doPart---
do '\tpush.global #"nil" ; none' -> mstate.preF.putline;
   
---byteCode_ldValImpl:doPart---
do (if A[] = none then
       'NO_field_defined'->puttext
    else
       (if A.isOrigin then 
           (A.ONlevel,A.receiverType[],A.fieldType[]) -> mstate.loadOrigin
        else
           A.out;
           (if A.isField then 
               (if mstate.A.isField 
		// 0 then
		   mstate.A.load
		// 2 then
                   'at:' -> mstate.preF.emitsend
                // 3 then (* component *)
                   '; load component ' -> mstate.preF.puttext;
                   mstate.A.fieldName[] -> mstate.preF.putline;
                else
                   (if A.inThisObj then
                       mstate.A.fieldName[] -> mstate.preF.emitPushField
                    else
                       mstate.A.fieldName[] -> mstate.preF.emitsend
                   if)
               if);
            else
               mstate.A.load; 
           if);
       if)
   if);
   
---byteCode_ByteSwap:doPart---
do  '\tswap '->mstate.preF.putline
   
---byteCode_loadRef:doPart---
do A.out; 
   (if mstate.A.isfield 
    // 0 then 
       mstate.A.loadValue
    // 1 then
       (if mstate.A.inThisObj then
           mstate.A.fieldName[] -> mstate.preF.emitpushfield 
        else
           mstate.A.fieldName[] -> mstate.preF.emitSend(*emitpushfield;*)
       if)
    // 2 then 
       'at:' -> mstate.preF.emitSend
    // 3 then 
       '; load component ' -> mstate.preF.puttext;
       mstate.A.fieldName[] -> mstate.preF.putline;
       'comp_' -> mstate.A.fieldName.prepend -> mstate.preF.emitPushGlobal
   if)

---byteCode_stValImpl:doPart---
do A.out;
   mstate.A.store

---byteCode_cpReg:doPart---
do (* called from synthesizer, but no code generated *)
   
---byteCode_gLea:doPart---
do '\t; gLea' -> mstate.preF.putline;
   op1.out;
   (if true 
    // op1.isRegAdr then
       mstate.A.pushAdr
    // op1.isInxRegAdr then
       mstate.A.pushAdr
    // op1.isTextOp then
       '\tpush.constant \n' -> mstate.preF.puttext; 
       mstate.textOperandArg[] -> mstate.preF.putline
    else
       '\nglea: operand type not handled'->putline
   if)
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
---bytecode_int64ToInt32:doPart---
do '\t; int64ToInt32\n' -> mstate.preF.puttext
   
---bytecode_int32ToInt64:doPart---
do '\t; int32ToInt64\n' -> mstate.preF.puttext
   
--bytecode_loadRange:doPart--
do 'length' -> mstate.preF.emitsend;
   
---byteCode_duplicate:doPart---
do (# A1,A2: ^regAdr
   do (if type
       // 0 then
          (if pos
           // 0 then
              '\tdup\n' -> mstate.preF.puttext;
           // 1 then
              '\t; Simulate dup_x1\n' -> mstate.preF.puttext;
              AllocAndStoreLocal -> A1[];
              AllocAndStoreLocal -> A2[];
              (A1[],dataTop[]) -> ldVal;
              (A2[],dataTop[]) -> ldVal;
              (A1[],dataTop[]) -> ldVal;           
           // 2 then
              '\t; duplicate:pos:2 - not implemented \n' -> mstate.preF.puttext;
          if);
       // 1 then
          '\t; pos:' -> mstate.preF.puttext;
          pos -> mstate.preF.putint;
          ' type: ' -> mstate.preF.puttext;
          type -> mstate.preF.putint;
          mstate.preF.newline
       // 2 then
          '\t; pos:' -> mstate.preF.puttext;
          pos -> mstate.preF.putint;
          ' type: ' -> mstate.preF.puttext;
          type -> mstate.preF.putint;
          mstate.preF.newline
      if)
   #)
---byteCode_allocAndStoreLocal:doPart---
do (# RA: ^mch.RegAdr;
   do '; allocandStoreLocal ' -> mstate.preF.putline;
      &mch.RegAdr[] -> RA[];
      mstate.numTempLocals + 1 -> mstate.numTempLocals;
      -mstate.numTempLocals -> RA.off;
      '\tpop.local ' -> mstate.preF.puttext;
      mstate.numTempLocals -> mstate.preF.putint;
      ' 0\n' -> mstate.preF.puttext;
      RA[] -> A[]
   #)
   
---byteCode_loadLocal:doPart---
do '; loadLocal ' -> mstate.preF.putline;
   '\tpush.local ' -> mstate.preF.puttext;
   mstate.numTempLocals -> mstate.preF.putint; (* last allocated local -
                                                * a bit shaky!
                                                *)
   ' 0\n' -> mstate.preF.puttext;
   
--byteCode_popStack:doPart---
do 'pop' -> mstate.preF.emitOp
   
--bytecode_declareField:doPart---
   (* to replace emitCk  *)
do (# F: ^text
   do 'F' -> F[]; off -> F.putInt; (* is F used? *)
      (F[],fieldName[],fieldSig[],fieldKind)
        -> mstate.fields.new;
   #);
   (if fieldKind
    // 'c' 
    // 'p' 
    // '['
    // 's' (* synthetic field, like 'comp$' *)
       then
       (* '.field ' -> mstate.preF.puttext;*)
       '  .property ' -> mstate.preF.puttext;
       fieldName[] -> mstate.preF.putline
    // 'm' then
       (if mstate.fields.numCells > mstate.fields.numArguments then
           '\t  .local ' -> mstate.preF.puttext;
           fieldName[] -> mstate.preF.putline
       if);
       mstate.fields.numCells + 1 -> mstate.fields.numCells
    // 'M' // 'C' then (* ???*)
    else

       (failureTrace,'fields.new:Unknown methodClassTag') -> stop
   if);
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do 
   
---byteCode_constructorDef:doPart---
do 1 -> mstate.fields.numArguments;
   false -> mstate.definingStaticMethod;     
   '  .instance_method '-> mstate.preF.puttext;
   'CONSTRUCTOR:' -> mstate.preF.emitsymbol;
   ' ; origin is to be supplied as argument' -> mstate.preF.puttext;
   '\n  {\n'-> mstate.preF.puttext;
   '\t.locals 20' -> mstate.preF.putline; (* temporary solution *)
   '\t.maxstacksize 100' -> mstate.preF.putline;

---byteCode_tstNone:doPart---
do (* not used *) 
   
---byteCode_doAsgRefAdr:doPart---
do thisAdr.out;
   (if mstate.A.isField
    // 0 then
       mstate.A.store
    // 1 (* field *) then
       (if mstate.A.inThisObj then
           mstate.A.fieldName[] -> mstate.preF.emitPopField
        else
           ':' -> (mstate.A.fieldName.copy).append -> mstate.preF.emitsend;
           '\tpop\n' -> mstate.preF.puttext;
       if)
    // 2 (* array *) then   
       'at:put:' -> mstate.preF.emitSend;
       '\tpop\n' -> mstate.preF.puttext;
   if);

   '\t;asgRefAdr:' -> mstate.preF.puttext;
   sourceClassName[] -> mstate.pref.putline;

---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   (# ON: ^text
   do thisAdr.out;
      (if mstate.A.isField
       // 0 then 
          mstate.A.store
       // 1 then 
          mstate.A.fieldName.copy -> ON[];
          (if mstate.A.inThisObj then
              ON[] -> mstate.preF.emitPopField
           else
              (if 'origin' -> mstate.A.fieldName.equal then
	          (* should be optimized by in genlib_bytecode_body:storeOrigin
                   * by using mch.storeOrigin *)
                  '$' -> ON.put;  
                  (2,sourceClassName.length-1) -> sourceClassName.sub -> ON.puttext;
              if);
              ':' -> ON.append;
              ON[] -> mstate.preF.emitSend;
              '\tpop\n' -> mstate.preF.puttext;
          if);
       // 2 then
          'at:put:' -> mstate.preF.emitSend;
          '\tpop\n' -> mstate.preF.puttext;
       else
      if);

   #);
   '\t;asgRegAdr \n' -> mstate.preF.puttext;

---bytecode_checkCast:doPart---
do '\tpush.constant "' -> mstate.pref.puttext;
   (2,type.length-1) -> type.sub -> mstate.preF.puttext;
   '"\n' -> mstate.preF.puttext;
   '\t; checkcast not implemented\n' -> mstate.preF.puttext;
   '\tpop\n' -> mstate.preF.puttext
   
---byteCode_jmpTlong:doPart---
do (* not used *)
   
---byteCode_jmplong:doPart---
do (* not used *)
   
---byteCode_jsrT:doPart---
do (* not used *)
   
--byteCode_gJmp:doPart---
do op.out;
   '\tbranch L' -> mstate.preF.puttext;
   mstate.localLabArg -> mstate.preF.putint;
   mstate.preF.newline
   
--byteCode_gJsr:doPart---
do 
   (# T, class, sig, method: ^text; 
      b: @boolean;
      nargs: @int16;
   do op.out;
      mstate.textOperandArg[] -> T[];
      (if T[] = none then
          '::no_method::'->method[];
       else
          T[]->splitClassSignature->(method[], sig[], b, class[]);
          (* NOTE: 'static' is not encoded in the signature,
           * but the argument 'isStatic' can be used.
           * 'b' is ALWAYS false - should be eliminated
           *)
          (if isStatic then
              (*'\tpush.global ' -> mstate.preF.puttext;
               class[] -> mstate.preF.putline;*)
           else
          if);
      if);
      (* a hack to check if zero or one argument;
       * must parse signature to count noOfArgs
       *)
      (for i: sig[] ->  mstate.noArgsInSignature repeat
           ':'-> method.put
      for);
      method[] -> mstate.preF.emitsend;
   #);
   
---bytecode_beginLabel:doPart---
do '; BEGIN label: ' -> mstate.pref.puttext;
   restartlab -> mstate.pref.putint; mstate.pref.newline;
   (if hasCalls or hasSlots then
       '\tpush.global #"Label"\n' -> mstate.preF.puttext;   
       (if false then mstate.preF.emitPushThis; if);
       '\tpush.block #"block$' ->  mstate.preF.puttext;
       labelName[] -> mstate.preF.puttext;
       '_' -> mstate.preF.put;
       restartLab -> mstate.preF.putint;
       '"\n' -> mstate.pref.puttext;
       'dup' -> mstate.preF.emitOp;
       'dup' -> mstate.preF.emitOp;
       mstate.preF.emitPushThis;
       'swap' -> mstate.preF.emitOp;
       off -> mstate.A.off; 
       1 -> mstate.A.isField; 
       false -> mstate.A.inThisObj;
       'I' -> mstate.A.fieldType[];
       off -> common.breakName -> mstate.A.fieldName[];
       mState.A.store;
       'for:do:' -> mstate.preF.emitSend;
   if)
   
---bytecode_endLabel:doPart---
do '; END label' -> mstate.preF.putline
   
---bytecode_break:doPart---
do  '; BREAK' -> mstate.preF.putline;
   off -> mstate.A.off; 
   1 -> mstate.A.isField;
   false -> mstate.A.inThisObj;
   'I' -> mstate.A.fieldType[];
   off -> common.breakName -> mstate.A.fieldName[];
   mState.A.load;
   '\tpush.global #"Label"\n' -> mstate.preF.puttext;   
   'swap' -> mstate.preF.emitOp;
   (if isLeave then
       'leave:' -> mstate.preF.emitSend
    else
       'restart:' -> mstate.preF.emitSend
   if)
   
---bytecode_breaksimple:doPart---
do (# inx: @text
   do '; BREALSIMPLE' -> mstate.preF.putline;
      '\tpush.global #"Label"\n' -> mstate.preF.puttext;   
      mstate.preF.emitPushThis;
      off -> mstate.A.off; 
      1 -> mstate.A.isField;
      false -> mstate.A.inThisObj;
      'I' -> mstate.A.fieldType[];
      'break_' -> inx;
      off -> inx.putint;
      inx[] -> mstate.A.fieldName[];
      mState.A.load;

      (if isLeave then
          'leave:' -> mstate.preF.emitSend
       else
          'restart:' -> mstate.preF.emitSend
      if)
   #)
   
---byteCode_cmpToBool:doPart--   
do '\t;cmpToBool' -> mstate.preF.putline;
   op1.loadToReg;
   op2.loadToReg;
   cond -> mstate.emitCmpToBool
   
---byteCode_cmpAndJmp:doPart---
do '\t;cmpAndJmp' -> mstate.preF.putline;
   (if op1[] = none then
       (* terrible hack: dobody:genif:
        *  (if F## // none then ... if)
        *)
       mch.nop
    else
       op1.loadToReg; op2.loadToReg;
   if);
   lab.out;
   (cond,'L',mstate.localLabArg,isRef %band 1,op1[]=none) -> mstate.emitCmpJmp 
   
---byteCode_cmpBoolAndJmp:doPart--
do '\t;cmpBoolAndJmp\n' -> mstate.preF.puttext;
   op.loadToReg;
   lab.out;  
   (cond,'L',mstate.localLabArg) -> mstate.emitCmpBoolJmp   
   
---byteCode_floatConst:doPart---
do '; Float const' -> mstate.preF.putline;
   '\tpush.constant &' -> mstate.pref.puttext;
   T[] -> mstate.pref.putline
   
---byteCode_saveReturn:doPart---
do (* no code needed here *)
   
---byteCode_return:doPart---
do (if RToff
    // 0 // 10 then (* PRE always return a value *)
       mstate.preF.emitPushThis;
    // 1 // 2 // 3 // 4 // 5 then 

    // 6 (* real *) then 

    // 7 (* real32 *) then 

    // 8 (* long=int64 *) then

    // 11 // 12 // 13 // 14 then 

    else 
       'xreturn' -> mstate.jvmFIXME;
   if);
   '\treturn.local\n' -> mstate.preF.puttext;
   
---bytecode_endMethod:doPart---
do '  }\n' -> mstate.preF.puttext;
   (if mstate.methodType = 5 then
       (if (mstate.blockLevel - 1 -> mstate.blockLevel) = 0 then
           (* ending a series of nested blocks *)
          0 -> mstate.methodType
   if)if)
   
---byteCode_callPrim:doPart--
do (T[],'Unknown') -> mstate.emitPrim
   
--byteCode_callAlloPrim:doPart--
do (if proto[] = none then 'UnknownProto' -> proto[] if);
   (T[],proto[]) -> mstate.emitPrim
   
--byteCode_callPrimNo:doPart--
do (if arg[] = none then 'UnknownProto' -> arg[] if);
   (primNo,arg.copy) -> mstate.emitPrimNo
   
---bytecode_import:doPart---
do (if trace_opcodes then 
       (# msg: ^text;
       do 'import: '->msg[];
          lab[] -> msg.append;
          msg[]->putline;
          (if 'minienv' -> lab.equal then
              (failuretrace,'minienv') -> stop
          if)
       #);
   if);
   (if not common.switch[135] then
       (if (Lab[] <> none) and ( Lab.length > 0) then
           Lab.copy -> mstate.imports.add 
   if)if);
   
---bytecode_importdata:doPart---
do (if trace_opcodes then 
       (# msg: ^text;
       do 'import: '->msg[];
          lab[] -> msg.append;
          msg[]->putline;
          (if 'minienv' -> lab.equal then
              (failuretrace,'minienv') -> stop
          if)
       #);
   if);
   (if common.switch[135] then
       (if (Lab[] <> none) and ( Lab.length > 0) then
           (if false then 'IMPORT: ' -> puttext; lab[] -> putline if);
           Lab.copy -> mstate.imports.add 
   if)if);
   
--bytecode_importClassFromComponent:doPart--
do (if false then
       'importClassFromComponent: ' -> puttext;
       class[] -> puttext;
       ':'->put; ' ' -> put;
       component[] -> putline;
   if);
   (if not common.switch[135] then
       (class[],component[]) -> mstate.imports.addClassFromComponent
   if)
   
---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   opCode -> mstate.emitFunc
   
---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   opCode -> mstate.emitFunc   
   
--byteCode_classDef:doPart--
do (# lastDot: @integer; 
      realClassName,fn: ^text
   do (if mstate.thisFirstClass[] = NONE then
          classname[] -> mstate.thisFirstClass[];
      if);
      className.scanAll
      (# pos: @integer
      do pos+1 -> pos;
         (if ch //  '.' // '\/' then pos -> lastDot if)
      #);          
      (lastDot+1,className.length)
        -> className.sub
        -> realClassName[];

      (className[],startPos,endPos) -> mstate.classes.add;

      (if not oneFile then
          (* mstate.thisFileName[] -> (mstate.thisFullPath.copy).append -> fn[];
           '.pra' -> (fn.copy).AppendExtension -> mstate.preF.name;
           mstate.preF.openWrite;*)
          (*'.bet' 
           -> (mstate.thisSourceFileName.copy).AppendExtension 
           -> mstate.preF.SourceFile;*)
      if);  
      false -> mstate.isMainMethod;
      mstate.fields.init;

      '.class ' -> mstate.preF.puttext;
      className[] -> mstate.preF.putline;
      
      '.super ' -> mstate.preF.puttext;
      superName[] -> mstate.preF.putline;
      '{'->mstate.preF.putline;

      '  .property origin$'-> mstate.preF.puttext;
      className[] -> mstate.pref.putline;      
      '  .instance_method #"origin"\n' -> mstate.preF.puttext;      
      '  { \t.locals 3\n'
      '    \t.maxstacksize 3\n'   
      '    \tpush.field ' -> mstate.pref.puttext;      
      'origin$' -> (className.copy).prePend -> mstate.pref.emitSymbol;      
      '\n    \treturn.local\n  }\n' -> mstate.pref.puttext;      
   #)
   
--byteCode_marknested:doPart---
do 

--byteCode_endClass:doPart---
do (* '\n}\n' -> mstate.preF.puttext;
    * '.class_side { \n'
    *)
   
   '\n  .class_method ' -> mstate.preF.puttext;
   'new:' -> mstate.preF.emitsymbol;
   ' ; origin is to be supplied as argument' -> mstate.preF.puttext;
   mstate.preF.newline;
   '  {' -> mstate.preF.putLine;
   '\t.locals 20\n\t.maxstacksize 100' -> mstate.preF.putline;
   mstate.preF.emitPushThis;
   'new' -> mstate.preF.emitsupersend;
   '\tpush.argument 1 0 ; origin' -> mstate.preF.putline;
   'CONSTRUCTOR:' -> mstate.preF.emitsend; 
   '\treturn.local\n'
   '  }\n'
   '}\n'
     -> mstate.preF.puttext; 
   (if not oneFile then mstate.preF.emitToFile(*close*) if);

--byteCode_endCodeSeg:doPart---
do 
   
--byteCode_methodDef:doPart--
do (# 
      isStatic: @boolean;
   do 
      methodname[] -> mstate.thisInnerMethodName[];  
      signature[] -> mstate.thisSignature[];
      type -> mstate.methodType;
      noOfEnterArgs -> mstate.fields.numArguments;
      (if (mstate.thisInnerMethodName[]<>NONE) 
          and (type = 0) 
          and not ('run' -> mstate.thisInnerMethodName.equal) 
          then
          '\n  .instance_method ' -> mstate.preF.puttext;
          mstate.thisInnerMethodName[] -> mstate.preF.emitSymbol;
          '\n  { \t.locals 20\n\t.maxstacksize 100\n'
	  '\n\tpush.argument 0 0'
	  '\n\treturn.local\n  }\n' -> mstate.preF.puttext;
      if);


      0 -> mstate.fields.numCells;
      8 -> mstate.numTempLocals; (* 8 is just preliminary *)
      mstate.thisSignature[] 
        -> splitSignature 
        -> (methodname[], mstate.thisSignature[], isStatic);
      (if isStatic then
          '\n  .class_method ' -> mstate.preF.puttext;  
          true -> mstate.definingStaticMethod;     
       else
          (if type = 5 then
              (* block *)
              mstate.blockLevel + 1 -> mstate.blockLevel;
              '\n  .method ' -> mstate.preF.puttext;
           else
              '\n  .instance_method ' -> mstate.preF.puttext;
          if);
          false -> mstate.definingStaticMethod;     
      if);
      (for i: noOfEnterArgs repeat ':' -> methodname.put for);
      methodName[] -> mstate.preF.emitsymbol;
      '\n  {\n\t.locals 20\n\t.maxstacksize 100\n'-> mstate.preF.puttext;
   #)
   
--byteCode_emitTextConst:doPart---
do '\tpush.constant ' -> mstate.preF.puttext;
   '"'-> mstate.preF.put; 
   S.scanAll
   (#
   do (if ch < 32 then
          (if ch
           // 10 // 12 then
              '\\n' -> mstate.preF.puttext
           else
              '\?' -> mstate.preF.puttext
          if)
       else
          ch -> mstate.preF.put
      if)
   #);
   '"'-> mstate.preF.put;
   mstate.preF.newline;  
   
---byteCode_close:doPart---
do (if oneFile then mstate.preF.emitToFile(*close*) if);
   mstate.mkClassListFile;
   mstate.imports.clear;

---bytecode_real64toReal32:doPart---
do '\t;r64tor32:' -> mstate.pref.putline;
   
   
---bytecode_real32toReal64:doPart---
do '\t;r32tor64:' -> mstate.pref.putline;

   
---byteCode_cmpToBoolFloat:doPart--
do '\t;cmptoboolfloat:' -> mstate.pref.putline;
   op1.loadToReg; 
   op2.loadToReg;
   cond -> mstate.emitCmpToBool
   
---byteCode_cmpAndJmpFloat:doPart--
do '\t;cmpAndJmpFloat:' -> mstate.pref.putline;
   op1.loadToReg; op2.loadToReg;
   lab.out;
   (cond,'L',mstate.localLabArg,0,false) -> mstate.emitCmpJmp 
   
---byteCode_addFloat:doPart---
do '+:' -> mstate.pref.emitsend
   
---byteCode_subFloat:doPart---
do '-:' -> mstate.pref.emitsend
   
---byteCode_mulFloat:doPart---
do '*:' -> mstate.pref.emitsend
   
---byteCode_divFloat:doPart---
do '/:' -> mstate.pref.emitsend
   
---bytecode_negFloat:doPart---
do '\t;neg float:' -> mstate.pref.putline;
   
---byteCode_int2float:dopart---
do '\t; int2float' -> mstate.pref.putline;
   'asReal' -> mstate.preF.emitSend
   
---byteCode_intReg2float:dopart---
do  '\t; intreg2float' -> mstate.pref.putline;
   'asReal' -> mstate.preF.emitSend
   
---byteCode_float2int:doPart---
do  '\t; float2int' -> mstate.pref.putline;
   'floor' -> mstate.preF.emitSend
   
---byteCode_CallCproc:doPart---
do T[] -> mstate.emitCallExternal
   
---byteCode_jsrTable:doPart---
do 
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of the assembly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do &mstate.PreCodeBuffer[] -> mstate.pref[];
   (if localFilePath[] = none then
        (* A new pra-file is opened for a form in mstate.thisFileName,
         * i.e. the code of this form is in a seperate file
         * we should make sure that mstate.thisFileName is imported
         * but apparently the synthesizer does this! Otherwise
         * we may import it here.
         * The if-test above is a hack to signal that we are
         * starting on a new file and BCname is the currentFileName  *)
        183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
        BCname[] -> mstate.thisFileName[]; 
        none -> mstate.thisFirstClass[];
        mstate.classes.init; 
     else
        183-> trace
        (#
        do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
           '     localFilepath: ' -> xT; localFilePath[] -> xT;
        #);
        mstate.classes.init; (* still ? *)   
        BCname[] -> mstate.thisFullPath[];
        BCname[] 
          -> mstate.splitPathAndName 
          -> (mstate.thisFullPath[],mstate.thisFileName[]->mstate.thisSourceFileName[]);  
        (if mstate.thisSourceFileName[] = NONE then
            183->trace(#
                    do 'bytecode_init: '->xT;
                       'mstate.thisSourceFileName is none'->xT
                    #)
        if);

        mstate.thisFullPath.copy -> mstate.thisFullSourcePath[];
        &stream[] -> mstate.commentStream[];
        183 -> trace
        (#
        do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
        #);       
    if);
   true -> mstate.notClosed;

---bytecode_setPackagePath:doPart---
do 
   
---bytecode_comment:doPart--
do (if common.switch[319]
       and 
       (T.length > 0)
       and 
       ((T.length > 0) and ((1 -> T.inxget) <> '!') or common.switch[185])  
       then
       ';'->mstate.preF.put; T[] -> mstate.pref.putline 
   if)
