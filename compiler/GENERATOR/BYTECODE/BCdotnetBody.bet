ORIGIN 'BCmachineBody'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/process/activate'; 
INCLUDE '~beta/basiclib/basicsystemenv'; 
INCLUDE '~beta/basiclib/formatio'; 
INCLUDE '~beta/basiclib/pcre'; 
INCLUDE '~beta/basiclib/streamPosition'; 
INCLUDE '~beta/toollibs/utils/fileExtensions';
INCLUDE '~beta/basiclib/texthash';
INCLUDE 'BCdotnetSupport';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit common.switch[190] #);
trace_mem:
  (# exit false #);
trace_locals:
  (# exit false #);
trace_sig:
  (# exit false #);
trace_n:
  (# exit false #);
trace_comments:
  (# exit false #);
trace_compares:
  (# exit false #);
trace_textop:
  (# exit false #);
trace_class:
  (# exit false #);
trace_convert:
  (# exit false #);

allow_nop_emit:
  (# exit false #);

compute_stack_height:
  (# exit false #);
check_stack: (* only relevant if compute_stack_height is true *)
  (# exit false #);
trace_stack: (* only relevant if compute_stack_height is true *)
  (# exit true #);

use_reflection:
  (# exit false #);
use_betarun:
  (# exit false #);
use_modules:
  (# exit false #);
generateLineNumbers:
  (# exit common.switch[41] #);
notifyFIXME:
  (# exit true (* not common.switch[188] *) #);
fixme_is_comment:
  (# exit true #);

hostIsWindows: booleanValue
  (# 
  do ('nti'->((1,3)->(machine_type).sub).equal) -> value;
  #);

reversecond:
  (# cond: @integer
  enter cond
  do (if cond
      // common.cond_lt then common.cond_gt -> cond
      // common.cond_le then common.cond_ge -> cond
      // common.cond_gt then common.cond_lt -> cond
      // common.cond_ge then common.cond_le -> cond
     if);
  exit cond
  #);

emitcomment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
_n:
  (# n: @integer;
  enter n
  do (if trace_n then
         ' /*'->out.puttext;
         n->out.putint;
         '*/'->out.puttext;
     if);
  #);

FIXME: 
  (# T: ^text
  enter T[]
  do 'FIXME: ' -> (T.copy).prepend -> T[];
     (if notifyFIXME then
         '\n***** ' -> screen.puttext; T[] -> screen.putline;
     if);
     (if fixme_is_comment then
         T[] -> emitcomment;
      else
         out.nl;
         'ldstr "'->out.puttext; 
         T[]->out.puttext; 
         '"' -> out.putln;
         'call void [mscorlib]System.Console::WriteLine(string)' -> out.putln;
     if)
  #);
ConvertType:
  (# T: ^text
  enter T[]
  do (if trace_convert then
         '/*ConvertType('->out.puttext;
         T[]->out.puttext;
         ')*/' ->out.puttext;
     if);
     (if true 
      // T[]=NONE then
         (DumpStack, 'ConvertType: T[] is none') -> Stop;
      // 'I' -> T.equal then
         'int32' -> T[];   (if trace_convert then  ' /*I*/' -> T.append if);
      // '[I' -> T.equal then
         'int32[]' -> T[]; (if trace_convert then  ' /*[I*/' -> T.append if);
      // 'C' -> T.equal then
         'char' -> T[];    (if trace_convert then  ' /*C*/' -> T.append if);
      // '[C' -> T.equal then
         'char[]' -> T[];  (if trace_convert then  ' /*[C*/' -> T.append if);
      // 'D' -> T.equal then
         'float64' -> T[]; (if trace_convert then  ' /*D*/' -> T.append if);
      // '[D' -> T.equal then
         'float64[]' -> T[];  (if trace_convert then ' /*[D*/' -> T.append if);
      // 'Z' -> T.equal then
         'bool' -> T[]; (if trace_convert then  ' /*Z*/' -> T.append if);
      // '[Z' -> T.equal then
         'bool[]' -> T[];  (if trace_convert then ' /*[Z*/' -> T.append if);
     if);
     INNER;
  exit T[]
  #);
RemoveClass:
  (# type: ^text
  enter type[]
  do (if 'class ' -> ((1,6)->type.sub).equal then
         (1,6) -> type.delete;
     if);
  exit type[]
  #);

AddClass: ConvertType
  (# isStatic: @boolean;
     location: ^text;
     static:< object;
     nonstatic:< object;
     omitstatic: @boolean;
  do (if 'static '  -> ((1,7)->T.sub).equal then
         true -> isStatic;
         (1,7)->T.delete;
         static;
      else
         nonstatic;
     if);
     (if true 
      // T.length=0
      // 'bool'     -> T.equal 
      // 'bool '    -> ((1,5)->T.sub).equal
      // 'bool,'    -> ((1,5)->T.sub).equal
      // 'bool[]'   -> ((1,6)->T.sub).equal
      // 'char'     -> T.equal 
      // 'char '    -> ((1,5)->T.sub).equal
      // 'char,'    -> ((1,5)->T.sub).equal
      // 'char[]'   -> ((1,6)->T.sub).equal
      // 'float64'  -> T.equal 
      // 'float64 ' -> ((1,8)->T.sub).equal
      // 'float64,' -> ((1,8)->T.sub).equal
      // 'float64[]'-> ((1,9)->T.sub).equal
      // 'float32'  -> T.equal 
      // 'float32'  -> T.equal 
      // 'float32,' -> ((1,8)->T.sub).equal
      // 'float32[]'-> ((1,9)->T.sub).equal
      // 'int8'     -> T.equal 
      // 'int8 '    -> ((1,5)->T.sub).equal
      // 'int8,'    -> ((1,5)->T.sub).equal
      // 'int8[]'   -> ((1,6)->T.sub).equal
      // 'int16'    -> T.equal 
      // 'int16 '   -> ((1,6)->T.sub).equal
      // 'int16,'   -> ((1,6)->T.sub).equal
      // 'int16[]'  -> ((1,7)->T.sub).equal
      // 'int32'    -> T.equal 
      // 'int32 '   -> ((1,6)->T.sub).equal
      // 'int32,'   -> ((1,6)->T.sub).equal
      // 'int32[]'  -> ((1,7)->T.sub).equal
      // 'void '    -> ((1,5)->T.sub).equal
      // 'valuetype '-> ((1,10)->T.sub).equal
         then
         (* nothing *)
      else
         (* Local reference. Add class keyword but no location *)
         (if trace_class then 'AddClass' -> emitcomment if);
         (if not ('class '  -> ((1,6)->T.sub).equal) then
             (*T[] -> quote -> T[];*)
             'class ' -> T.prepend;
         if)
     if);
     (if isStatic and (not omitstatic) then
         'static ' -> T.prepend;
     if);
  #);

parseNumberOfArguments: 
  (# numInputs, numOutputs: @integer;
     signature: ^text;
     start: @integer;
     trace: (# exit false #);
  enter signature[]
  do (if trace then
         'parseNumberOfArguments: ' -> screen.puttext;
         signature[] -> screen.puttext;
     if);
     (if 'void ' -> ((1,5)->signature.sub).equal then
         0 -> numOutputs;
      else
         1 -> numOutputs;
     if);
     '(' -> signature.findall(# do inx->start #);
     (start+1, signature.length-1) -> signature.sub -> signature[];
     (if true 
      // signature.length=0 then
         (* no parameters *)
         0 -> numInputs;
      // 'void' -> signature.equal then
         0 -> numInputs;
      else
         1 -> numInputs;
         ',' -> signature.findall(# do numInputs+1->numInputs #);
     if);
     (if trace then
         (if false then
             '. Arguments: "'->screen.puttext;
             signature[] -> screen.puttext;
             '"' -> screen.put;
         if);
         '. NoOfInputs: '->screen.puttext;
         numInputs -> screen.putint; 
         '. NoOfOutputs: '->screen.puttext;
         numOutputs -> screen.putint; 
         screen.newline;
     if);
  exit (numInputs, numOutputs)
  #);

function_stack_delta:
  (# signature: ^text;
     in, out: @integer;
  enter signature[]
  do signature[] -> parseNumberOfArguments -> (in, out);
  exit out-in
  #);

twolongs2real:
  (# l1, l2: @integer;
     r: @real;
  enter (l1, l2)
  do (if isBigEndian then
         l1 %putlongAt(@@r);
         l2 %putlongAt(@@r+4);
      else
         l1 %putlongAt(@@r+4);
         l2 %putlongAt(@@r);
     if);
  exit r
  #);

--FieldsNewClr:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       out.nl;
       '.field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
    // '[' then
       out.nl;
       '.field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' [] ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
    // 'm' then
       (if numCells>=numArguments then
           (if numCells=numArguments then 
               out.nl;
               '.locals init   (' -> out.puttext;
            else 
               ',' ->out.putln;
               '                ' -> out.puttext 
           if);
           '[' -> out.puttext;
           numLocals -> out.putint;
           '] ' -> out.puttext;
           T[] -> AddClass -> out.puttext;
           (if false then
               ' V_' -> out.puttext; 
               numLocals -> out.putint;
            else
               ' '->out.put;
               FN[] -> out.puttext; (* local variable name *)
           if);
           numLocals+1 -> numLocals;    
       if);
       numCells+1 -> numCells;
    // 'M' then
       (* end method locals *)
       (if numCells>numArguments then
           ')' -> out.putln;
       if);
    // 'C' then
       (* end class fields *)
    else
       'FieldsNewClr: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemClr:descriptor--
(# 
do (if trace_opcodes then '/* emitInit */' -> out.puttext; if);
   (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else  
       out.nl;
       'ldarg.0' -> out.puttext; 2->_n; 
       (* 1 -> stack_delta; not here (:-( *)
       out.nl;
       (if true
        // 'bool' -> currentType.equal 
        // 'Z' -> currentType.equal 
           then
           'ldc.i4.0' -> out.puttext; (* NOT ldc.i4.0! *)
        // 'char' -> currentType.equal 
        // 'C' -> currentType.equal 
        // 'int8' -> currentType.equal 
        // 'int16' -> currentType.equal 
        // 'int32' -> currentType.equal 
        // 'I' -> currentType.equal
           then
           'ldc.i4.0' -> out.puttext;
        // 'float64' -> currentType.equal 
        // 'D' -> currentType.equal (* double/real *) then
           'ldc.r8 0' -> out.puttext; 
        else
           'ldnull' -> out.puttext
       if);
       out.nl;
       (* 1 -> stack_delta; not here (:-( *)
       'stfld  ' -> out.puttext; 1->_n; 
       currentType[] -> ConvertType -> out.puttext;
       ' ' -> out.puttext;
       thisClassName[] -> quote -> out.puttext;
       '::' -> out.puttext;
       currentFieldName[] -> quote -> out.puttext;
       (* -2 -> stack_delta; not here (:-( *)
       (if trace_opcodes then '/* emitInit done */' -> out.puttext; if)
   if)
#)

-- emitclr: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   hasMainMethod: @boolean; (* true if generating code for module with main method *)
   hasFields: @boolean; (* true if generating code for a method that has any fields *)
   previousWasJmp: @boolean;
   
   betafile: @file(# initialized: @boolean; pc: @positionConverter #);
   betafilename: ^text;
   line, column: @integer;
   
   numBackendLocals: @integer;
   backendLocalLab:
     (# labno: @integer;
        def:
          (# 
          do 2 -> out.indent.dec;
             'Lb' -> out.puttext; labno -> out.putint; ':' -> out.put;
             2 -> out.indent.inc;
             out.nl;
          #);
        new:
          (# 
          do numBackendLocals+1->numBackendLocals->labno;
          #);
        astext:
          (# t: ^text;
          do ' Lb' -> t[]; labno->t.putint;
          exit t[]
          #);
     exit astext
     #);
   
   stack_height: @integer;
   max_stack_height: @integer;
   stack_delta:
     (# delta: @integer;
     enter delta 
     do (if compute_stack_height then
            delta+stack_height->stack_height;
            (if stack_height>max_stack_height then
                stack_height->max_stack_height;
            if);
            (if trace_stack then
                ' /* stack height: ' -> out.puttext;
                stack_height -> out.putint;
                ' */ ' -> out.puttext;
            if);
            (if (stack_height<0) and (stack_height-delta>=0) then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    '::' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                    'Stack underflow' -> fixme;
                 else
                    'Stack Underflow!' -> emitcomment;
                if)
            if);
        if)
     #);
   check_stack_height:
     (# predicted_height: @integer;
        msg: ^text;
     enter predicted_height
     do (if compute_stack_height then
            (if stack_height<>predicted_height then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    ':: ' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                if);
                'Unexpected stack height ' -> msg[];
                stack_height -> msg.putint;
                ' (' -> msg.puttext;
                predicted_height -> msg.putint;
                ' expected)' -> msg.puttext;
                (if check_stack then
                    msg[] -> fixme;
                 else
                    msg[] -> emitcomment;
                    out.nl;
                if);
            if);
        if)
     #);
   
   labs: @
     (#
        stack_heights: [500] ^IntegerObject;
        clear:
          (# 
          do (for i:stack_heights.range repeat
                  NONE->stack_heights[i][]
             for);
          #);
        def: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             'L'->out.puttext; l->out.putint; 
             ': '->out.puttext;
             (if compute_stack_height then
                 (* stack height book-keeping *)
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Use stack height defined by branch to here *)
                     stack_heights[l] -> stack_height;
                     (if trace_stack then
                         '/* Stack height (from previous branches to here): ' -> out.puttext;
                         stack_height -> out.putint;
                         ' */' -> out.puttext;
                     if);
                  else
                     (if previousWasJmp then
                         (* Cannot use current stack height, since we never
                          * fall through to here
                          *)
                         (if false then
                             'At definition of L' -> msg[];
                             l-> msg.putint;
                             ': Cannot determine stack height' -> msg.puttext;
                             msg[] -> fixme;
                         if);
                         (* According to OLM: stack height should be 0 here *)
                         &IntegerObject[] -> stack_heights[l][];
                         (if trace_stack then
                             '/* Stack height (assumed): ' -> out.puttext;
                             stack_height -> out.putint;
                             ' */' -> out.puttext;
                         if);
                      else
                         &IntegerObject[] -> stack_heights[l][];
                         stack_height -> stack_heights[l];
                         (if trace_stack then
                             '/* Stack height (fall through from above): ' -> out.puttext;
                             stack_height -> out.putint;
                         if);
                     if);
                 if);
             if);
             (*out.newline;*)
          #);
        use: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             '  L'->out.puttext;
             l -> out.putint;
             (if l<=0 then
                 (# msg: ^text;
                 do 'Use of strange label L'->msg[];
                    l-> msg.putint;
                    msg[] -> fixme;
                 #)
             if);
             (if compute_stack_height then
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Other branches to L. Check consistency *)
                     (if stack_height<>stack_heights[l] then
                         out.entry.path.name -> msg[];
                         ': Stack inconsistency: current stack height '
                           -> msg.puttext;
                         stack_height -> msg.putint;
                         ' at branch target L' -> msg.puttext;
                         l -> msg.putint;
                         ' differs from previous value ' -> msg.puttext;
                         stack_heights[l] -> msg.putint;
                         msg[] -> fixme;
                     if);
                  else
                     &IntegerObject[] -> stack_heights[l][];
                     stack_height -> stack_heights[l];
                 if);
             if);
          #);
     #);
   
   
   init:
     (# BCmch: ^ByteCodeMachine;
        PH: @pathhandler;
        trace_name: (# exit false #);
     do ObjectPool.get(# type::assemblyinfohashtable #)
          -> lookedup_assemblies[];
        out.entry.path.name -> thisModuleName[];
        (if generateLineNumbers then
            (* Construct source file path relative to current working dir *)
            (mch[]->BCmch[]).mstate.thisFullPath.copy -> betafilename[];
            (if (betafilename.length->betafilename.inxGet) = DirectoryChar then
                (betafilename.length,betafilename.length) -> betafilename.delete;
            if);
            (if trace_name then
                'betafilename1: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            betafilename[] -> betafile.name;
            betafile.entry.path.head -> betafilename[] (* strip trailing /clr *);
            (if trace_name then
                'betafilename2: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            directorychar -> betafilename.put;
            (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename.append;
            '.bet' -> betafilename.append;
            (if trace_name then
                'betafilename3: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            (if trace_name then
                'currentdirectory: '->screen.puttext;
                currentdirectory -> screen.putline;
            if);
            
            (betafilename[]->BackslashToSlash, currentdirectory->BackslashToSlash) 
              -> PH.localpath 
              -> SlashToBackslash
              -> betafilename[];
            (if trace_name then
                'betafilename4: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            
            betafilename[] -> betafile.name;
            (if betafile.entry.exists and betafile.entry.isfile then
                betafile.openRead;
                betafile.pc.update;
                betafile.close;
                true -> betafile.initialized;
             else
                'Error: cannot open source file: '->screen.puttext;
                betafilename[] -> screen.putline;
                'Will not generate line number info' -> screen.putline;
            if)
        if);
        '.il' -> thisModuleName.stripExtension;
        thisModuleName.copy -> BCstate.thisModuleName[];
        (if use_betarun then
            emitModuleHeader;
         else
            emitAssemblyHeader;
        if);
     #);
   allocLocal:
     (# type: ^text;
     enter type[]
     do '.locals init ([%d] %s)'
          -> out.putformat(# do BCstate.fields.numLocals -> d; type[] -> s #);
        out.nl;
        BCstate.fields.numLocals+1 -> BCstate.fields.numLocals;
     exit numLastLocal
     #);
   releaseLocal:
     (# locNum: @integer
     enter locNum
     do (* Currently not used.
         * Could recycle locNum by remembering the index and the current type of that index.
         * A subsequent allocLocal could then reuse this local if it's the same type.
         *)
     #);
   MappedLocals: [1]@integer;
   lastMappedLocal: @integer;
   allocMappedLocal:
     (# num: @integer;
        type: ^text;
        locnum: @integer;
     enter (num, type[])
     do -num -> num;
        (if num>MappedLocals.range then
            (MappedLocals.range, num-MappedLocals.range)
              -> max
              -> MappedLocals.extend;
        if);
        (if MappedLocals[num]=0 then
            (type[] -> allocLocal -> locnum) + 1 -> MappedLocals[num];
            (* adding 1 to distingguish local 0 from unassigned *)
            (if trace_locals then
                '/*Mapped and allocated local %d to %d (noOfArguments=%d)*/'
                  -> out.putformat(# do -num->d; 
                                     MappedLocals[num]->d; 
                                     noOfArguments->d;
                                  #);
                out.nl;
            if);
            num -> lastMappedLocal; 
         else
            MappedLocals[num]- 1 -> locnum;
            num -> lastMappedLocal; (* needed? *)
            (if trace_locals then
                '/*Mapped and used local %d to %d*/'
                  -> out.putformat(# do -num->d; locnum->d; #);
                out.nl;
            if);
        if);
     exit locnum
     #);
   loc2off:
     (# locnum, off: @integer
     enter locnum
     do (locnum+BCstate.fields.numArguments)*4 + 12 -> off;
     exit off
     #);
   opLocal:
     (# num: @integer;
        delta: @integer;
     enter num (* local number, NOT offset *)
     do (if trace_locals then
            '/*opLocal(num=' ->out.puttext; 
            num->out.putint; 
            ')*/' -> out.puttext;
        if);
        INNER;
        'loc' -> out.puttext;
        (if true
         // num<0 then
            'Negative opLocal' -> screen.putline;
            'Negative opLocal' -> emitcomment;
            (*(dumpstack, 'Negative opLocal') -> stop*)
         // num <= 3 
            then '.' -> out.put
         // num <= 255 
            then '.s ' -> out.puttext
         else
            ' ' -> out.put 
        if);
        num -> out.putint; 
        delta-> stack_delta; 
        out.nl;
     #);
   storeLocal: 
     opLocal(# do 'st' -> out.puttext; -1->delta; #);
   loadLocal: 
     opLocal(# do 'ld' -> out.puttext; 1->delta; #);
   numLastLocal (* Real number of last local *):
     (# exit BCstate.fields.numLocals-1 #);
   
   emitSystemAssemblyReferences:
     (# 
     do '/* Assembly references. */' -> out.putline;
        'mscorlib' -> importAssembly;
        (if use_betarun then
            out.indent;
            '.assembly extern%s betarun {}\n'
              -> out.putformat(# 
                              do (if common.switch[186] then 
                                     ' retargetable'->s 
                                  else 
                                     ''->s
                                 if)
                              #);
        if);
     #);
   emitBETAAssemblyReferences:
     (# 
     do imports.scan
        (# e: @diskentry;
           assemblyname: ^text;
        do current[] -> e.path;
           e.path.name -> assemblyname[];
           (if assemblyname[] -> thisModuleName.equal then
               (*thisModuleName[]->emitcomment; out.newline *)
            else
               assemblyName[] -> importAssembly;
           if);
        #);
     #);
   
   imported_assemblies: @texthashtable;
   
   lookedup_assemblies: ^assemblyinfohashtable;
   
   importAssembly:
     (# assemblyname: ^text;
        is_external: booleanValue
          (* Only call gacutil for non-beta assemblies.
           * Ideally imports should contain a flag indicating this,
           * but it does not currenlty.
           * So instead we test for the Microsoft .NET famework libraries.
           * Will fail for third-party assemblies, though 
           * (but they are probably not in GAC anyway.
           *)
          (# 
          do (if true
              // 'mscorlib'  -> ((1,8)->assemblyname.sub).equal
              // 'System'    -> ((1,6)->assemblyname.sub).equal
              // 'Microsoft' -> ((1,9)->assemblyname.sub).equal
                 then
                 true -> value;
             if);
          #);
     enter assemblyname[]
     do
        (if assemblyname[] -> imported_assemblies.add then
            out.indent;
            '.assembly extern%s ' 
              -> out.putformat(# 
                              do (if common.switch[186] then 
                                     ' retargetable'->s 
                                  else 
                                     ''->s
                                 if)
                              #);
            assemblyname[] -> quote -> out.puttext;
            (if hostIsWindows then
                out.indent.inc;
                ' {' -> out.puttext;
                (if is_external then
                    (# version, publickeytoken: ^text;
                    do assemblyname[]
                         -> lookupAssemblyVersion 
                         -> (version[], publickeytoken[]);
                       out.nl;
                       '.ver %s'
                         -> out.putformat(# do version[]->s; #);
                       out.nl;
                       '.publickeytoken = (%s)'
                         -> out.putformat(# do publickeytoken[]->s #);
                       out.newline;
                    #);
                if);
                out.indent.dec;
                '}' -> out.putln;
             else
                ' {}' -> out.putline;
            if);
        if)
     #);
   
   lookupAssemblyVersion:
     (# assemblyname: ^text;
        version, publickeytoken: ^text;
        
        gacutil: 
          (# gac, gacline: ^text;
             cmd: ^text;
             gacutil_output: @file;
             system: external
               (# cmd: [0]@char
               enter cmd
               #);
             regexp: @pcre;
          do (if false then
                 (* Calling execReadText apparently hangs in general in windows,
                  * if output is more than one line (:-(  
                  *)
                 ('gacutil','-l') -> (GetSystemenv).execReadText -> gac[];
              else
                 &text[] -> cmd[];
                 'gacutil -l %s' -> cmd.putformat(# do assemblyname[]->s #);
                 (*'\n' -> (cmd.copy).prepend -> screen.putline;*)
                 ' > gacutil.out' -> cmd.append;
                 cmd -> system;
                 'gacutil.out' -> gacutil_output.name;
                 gacutil_output.openread;
                 &text[] -> gac[];
                 read:
                   (if not gacutil_output.eos then
                       gacutil_output.getline -> gac.putline;
                       restart read;
                   if);
                 gacutil_output.close;
                 gacutil_output.delete;  
             if);
             (* find last line of gacutil output matching assemblyname *)
             ', Version=(\\d+)\\.(\\d+)\\.(\\d+)\.(\\d+), Culture=.*, PublicKeyToken=(.*),' 
               -> (assemblyname.copy).append 
               -> regexp;
             gac.reset;
             match:
               (if not gac.eos then
                   gac.getline 
                     -> gacline[];
                   (*gacline[] -> screen.putline;*)
                   gacline[]
                     -> regexp.match(# 
                                    do (*'match of version in GAC'->screen.putline;*)
                                       &text[] -> version[];
                                       '%d:%d:%d:%d'
                                         -> version.putformat(# sub: ^text;
                                                             do sub1 -> sub[];
                                                                sub.reset; sub.getint->d;
                                                                sub2 -> sub[];
                                                                sub.reset; sub.getint->d;
                                                                sub3 -> sub[];
                                                                sub.reset; sub.getint->d;
                                                                sub4 -> sub[];
                                                                sub.reset; sub.getint->d;
                                                             #);
                                       sub5 -> publickeytoken[];
                                    #);
                   restart match;
               if);
             
          #);
        was_there: @boolean;
     enter assemblyname[]
     do '1:0:0:0' -> version[];
        (* FIXME: 
         * could call gacutil -l and match "assemblyname, version=xxxx", 
         * or use IMetaDataAssemblyImport from unmanaged API 
         *)
        assemblyname[] 
          -> lookedup_assemblies.get
          -> (was_there, version[], publickeytoken[]);
        (if not was_there then
            gacutil;
            (assemblyname[], version[], publickeytoken[])
              -> lookedup_assemblies.add;
        if);
     exit (version[], publickeytoken[])
     #);
   
   emitFileReferences:
     (# 
     do '\n/* File references */\n'
          -> out.puttext;
        imports.scan
        (#
        do '.file ' -> out.puttext;
           current[] -> out.puttext;
           (if use_modules then
               '.netmodule\n' -> out.puttext;
            else
               '.dll\n' -> out.puttext;
           if);
        #);
     #);

   emitModuleReferences:
     (# 
     do '/* Module references */\n'
          -> out.puttext;
        (if use_betarun then
            '.module extern betarun_v.dll' -> out.putline;
        if);
        imports.scan
        (#
        do (if use_modules then
               '.module extern ' -> out.puttext;
            else
               out.indent;
               '.assembly extern%s '
                 -> out.putformat(# 
                                 do (if common.switch[186] then 
                                        ' retargetable'->s 
                                     else 
                                        ''->s
                                    if);
                                 #);
                                    
           if);
           current[] -> quote -> out.puttext;
           (if use_modules then
               '.netmodule\n' -> out.puttext;
            else
               ' {}\n' -> out.puttext;
           if);
        #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '//********************************************\n'
             '//*       Information about the assembly     *\n'
             '//********************************************\n'
             '\n'
             '/* Assembly declaration. */' -> out.putln;
             '.assembly%s \'%s\' {'
               -> out.putformat(# 
                               do (if common.switch[186] then 
                                      ' retargetable'->s 
                                   else 
                                      ''->s
                                  if);
                                  thisModuleName[]->s
                               #);
             out.indent.inc; out.putln;
             '.hash algorithm 32772	// selected algorithm is SHA1' -> out.putln;
             '.ver 1:0:0:0		// version 1.0' -> out.putline;
             out.indent.dec;
             out.indent;
             '}' -> out.putline;
             '.module \'%s.dll\'\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do 
        emitAssemblyInfo;
        emitSystemAssemblyReferences;
        emitBETAAssemblyReferences;
     #);
   emitModuleHeader:
     (# emitModuleInfo:
          (# 
          do '//********************************************\n'
             '//*       Information about this module      *\n'
             '//********************************************\n'
             '\n'
             '/* Module declaration. */\n'
             '.module %s.netmodule\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do emitModuleInfo;
        emitSystemAssemblyReferences;
        emitModuleReferences;
        emitFileReferences;
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo, origVarNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same?
         * No: local number 0 has address 12+BCstate.fields.numArguments*4.
         *)
        varNo -> origVarNo;
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint;
        (if varNo<0 then
            'Negative location/argument number' -> fixme;
            origVarNo->('mem:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            'Negative memory offset' -> putline;
        if);
        (if 'ld'->op.equal then
            (* ldarg/ldloc *)
            1 -> stack_delta;
         else
            (* starg/stloc *)
            -1 -> stack_delta;
        if);

     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg:
     (#  exit BC.get #);
   pushCst:
     (# i: @integer;
     do 'ldc.i4'->out.puttext;
        INNER; (* get constant into i with correct sign *)
        (if true
         // (i=-1) then '.m1' -> out.puttext;
         // (0<=i) and (i<=8) then
            '.'->out.put; i->out.putint;
         // (-128<=i) and (i<=127) then
            '.s '->out.puttext; i->out.putint;
         else
            ' '->out.puttext; i->out.putint;
        if);
        (if (32<=i) and (i<=126) then
            ' // \'%c\'' -> out.putformat(# do THIS(pushCst).i->c #);
        if);
        1 -> stack_delta;
     #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        fieldName,descName,fieldType: ^text;
        get: 
          (# hasFieldName: @integer 
          do getReg->reg; 
             (if (BC.get -> hasFieldName) = 1 then
                 BC.gettext -> fieldName[]
             if);
             (# c: @int8 (* CAREFULL: char is unsigned! *);
             do BC.get->c;
                c -> off(* sign extend *);
             #);
             (if (off>0) and (off<12) then
                 (# msg: ^text;
                 do 'Address.get: strange offset: '-> msg[];
                    off -> msg.putint; 
                    (if hasFieldName=1 then
                        '. Field name: '-> msg.puttext;
                        fieldname[] -> msg.puttext;
                    if);
                    msg[] -> fixme;
                 #);
             if);
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
              else
                 none -> descName[]
             if);
             (if BC.get = 1 then
                 BC.getText -> fieldType[];
              else
                 none -> fieldType[];
             if)
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> quote -> out.putText; 1->_n;
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> quote -> out.puttext; 
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext; 2->_n;
              else
                 '::' -> out.puttext;
                 fieldName[]-> quote -> out.puttext;
                 ' ' -> out.put;
             if)
          #);
        emitType:
          (#
          do (if fieldType[] <> none then
                 fieldType[] -> out.puttext
              else
                 'int32' -> out.puttext;
                 'OBS! missing type info (fieldType)' -> emitcomment
             if);
             ' ' -> out.put;
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                      // 'int8' -> fieldType.equal 
                         then
                         'ldelem.i1' -> out.puttext
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'ldelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal 
                      // 'char' -> fieldType.equal 
                      // 'int16u' -> fieldType.equal 
                         then
                         'ldelem.u2' -> out.puttext
                      // 'int16' -> fieldType.equal
                         then
                         'ldelem.i2' -> out.puttext
                      // 'F' -> fieldType.equal 
                      // 'float32' -> fieldType.equal 
                         then
                         'ldelem.r4' -> out.puttext
                      // 'D' -> fieldType.equal 
                      // 'float64' -> fieldType.equal 
                         then
                         'ldelem.r8' -> out.puttext
                      else
                         'ldelem.i4' -> out.puttext;
                         (# msg: ^text;
                         do 'load: wrong fieldType: ' -> msg[];
                            fieldType[] -> msg.append;
                            msg[] -> FIXME;
                         #)
                     if)
                  else
                     'load: missing fieldType' -> FIXME;
                 if);
                 -1 -> stack_delta (* pops object, field name; pushes field value *);
              else
                 (if ONlevel > 0 then
                     'ldfld  ' -> out.puttext; 1->_n;
                     emitType;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *);
                  else
                     (if isField=1 then
                         'ldfld  ' -> out.puttext; 2->_n;
                         emitType;
                         emitField; 
                         0 -> stack_delta (* pops object; pushes field value *);
                      else
                         (* method field (local variable/argument?)*)
                         ('ld',off) -> emitMemOp; 
                     if);
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                      // 'int8' -> fieldType.equal 
                         then
                         'stelem.i1' -> out.puttext
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'stelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal
                      // 'char' -> fieldType.equal
                      // 'int16' -> fieldType.equal 
                         then
                         'stelem.i2' -> out.puttext (* no unsigned store *)
                      // 'F' -> fieldType.equal
                      // 'float32' -> fieldType.equal then
                         'stelem.r4' -> out.puttext
                      // 'D' -> fieldType.equal
                      // 'float64' -> fieldType.equal then
                         'stelem.r8' -> out.puttext
                      else
                         'stelem.i4' -> out.puttext;
                         (# msg: ^text;
                         do 'store: wrong fieldType: ' -> msg[];
                            fieldType[] -> msg.append;
                            msg[] -> FIXME;
                         #)
                     if);
                  else
                     'store: missing fieldType' -> FIXME;
                 if);
                 -2 -> stack_delta (* pops object, field name; *)
              else
                 (if ONlevel > 0 then
                     'stfld  ' -> out.puttext; 2->_n;
                     emitType;
                     emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     (if isField=1 then
                         'stfld  ' -> out.puttext; 3->_n;
                         emitType;
                         emitField;
                         -2 -> stack_delta (* pops object, field name; *)
                      else
                         ('st',off) -> emitMemOp; 
                     if)
                 if);
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; sig: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> sig[];
             (if withQua then
                 'castclass  ' -> out.puttext;
                 sig[] -> out.putln;
                 (* stack neutral *)
             if);
             (if ONlevel > 0 then
                 'stfld  ' -> out.puttext; 4->_n;
                 (*emittype; *) sig[]->AddClass->out.puttext; ' '->out.put;
                 isOrigin -> emitField;
                 -2 -> stack_delta (* pops object, field name; *)
              else           
                 (if isField = 1 then
                     'stfld  ' -> out.puttext; 5->_n;
                     (*emittype;*) sig[]->AddClass->out.puttext; ' '->out.put;
                     isOrigin -> emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     (if isField = 2 then
                         'stelem.ref' -> out.puttext;
                         -3 -> stack_delta;
                      else 
                         (if trace_locals or trace_mem then
                             '/*storeref: off: '-> out.puttext;
                             off->out.putint;
                             '*/' -> out.puttext;
                         if);
                         (if off<0 then
                             (off, sig[]) -> allocMappedLocal -> loc2off -> off;
                         if);
                         ('st',off) -> emitMemOp;  
                     if);
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 'ldfld  ' -> out.puttext; 3->_n;
                 (*emittype;*) sig[]->AddClass->out.puttext; ' ' -> out.put;
                 emitField;
                 0 -> stack_delta (* pops object; pushes field value *)
              else 
                 (if isField = 1 then
                     'ldfld  ' -> out.puttext; 4->_n;
                     (*emittype;*)sig[]->AddClass->out.puttext;' ' -> out.put;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *)
                  else
                     (if isField = 2 then
                         'ldelem.ref' -> out.puttext;
                         1 -> stack_delta;
                      else
                         (if trace_locals or trace_mem then
                             '/*loadref: off: '-> out.puttext;
                             off->out.putint;
                             '*/' -> out.puttext;
                         if);
                         (if off<0 then
                             (off, sig[]) -> allocMappedLocal -> loc2off -> off;
                         if);
                         ('ld',off) -> emitMemOp;  
                     if);
                 if);
             if); 
             (if withQua then
                 out.nl;
                 'castclass  ' -> out.puttext;
                 BC.gettext -> sig[]; 
                 sig[] -> out.puttext;
                 (* stack nutral *)
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0' -> out.puttext; 3->_n;
                     1 -> stack_delta;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.putline;
                 load
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   allocStack:
     (#
     do (if not compute_stack_height then
            '.maxstack 1000' -> out.puttext;
        if);
     #);
   emitCmpJmp:
     (* Compare two top elements and jump conditionally *)
     (# cond,L,lab,isRef: @integer (* oLM: isRef=1: reference cmp *)
     enter(cond,L,lab,isRef)
     do (if trace_compares then
            'emitCmpJmp' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        -2 -> stack_delta;
        lab -> labs.use;
     #);
   emitCmpToBool:
     (* Compare two top elements and push result *)
     (# cond: @integer
     enter cond
     do (if trace_compares then
            'emitCmpToBool' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'ceq' -> out.puttext;
         // 2 (* <> *) then
            'ceq' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
         // 3 (* <  *) then
            'clt' -> out.puttext 
         // 4 (* <= *) then
            'cgt' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
         // 5 (* >  *) then
            'cgt' -> out.puttext 
         // 6 (* >= *) then
            'clt' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
        if);
        -1 -> stack_delta;
     #);
   emitCmpBoolJmp:
     (* Compare top with 0 and jump conditionally *)
     (# cond,L,lab: @integer
     enter (cond,L,lab)
     do (if trace_compares then
            'emitCmpBoolJmp' -> emitcomment;
        if);
        'ldc.i4.0' -> out.putln;
        1 -> stack_delta;
        (cond->reversecond,L,lab,0) -> emitCmpJmp;
     #);
   
   emitString:
     (* See Partition II Metadata, section 5.2 Terminals of the CIL spec *)
     (# T: ^text; 
     enter T[]
     do '"'->out.put; 
        T.scanAll
        (# escape:
             (# ch: @char
             enter ch
             do '\\'->out.put; ch->out.put
             #);
        do (if ch
            // ascii.newline then 'n' -> escape;
            // ascii.ht      then 't' -> escape
            // '"'           then '"' -> escape
            (*// '\\'        then  '\\'-> escape *)
            else 
               (if ch < ' ' then
                   '\\'-> out.put;
                   '0' + (ch div 64) -> out.put;
                   ch mod 64 -> ch;
                   '0' + (ch div 8) -> out.put;
                   ch mod 8 -> ch;
                   '0' + ch -> out.put
                else                  
                   (if ch > 255 then
                       ' ' -> out.put;
                    else
                       ch->out.put 
                   if);
               if)
           if)
        #);
        '"'->out.put; 
     #);   
   
   newArray:
     (# type: ^text
     enter type[]
     do out.nl;
        'newarr ' -> out.puttext; type[] -> out.puttext;
        0 -> stack_delta;
     #);
   
   opCode, arg1, arg2: @integer;
   A: @Address;
   T: ^text;
   
do init;
   read:
     (if opCode <> end then
         BC.get->opCode; 
         (if trace_opcodes then
             '/* Opcode %d: %s ' -> out.putformat(# do opCode -> d;  opCode->asText->s; #);
             (if (32<=opcode) and (opcode<=126) then
                 '\'%c\' ' -> out.putformat(# do opcode->c #);
             if);
             '*/' -> out.puttext;
         if);
         (if opCode
          // classDef then
             (* true -> out.indent.trace; *)
             false -> isMainMethod;
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '//********************************************\n'
             '//*       Class: %s:\n'
             '//********************************************\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi ' -> out.puttext;
             thisClassName[] -> quote -> out.putText;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> RemoveClass -> out.putln;
             out.indent.inc;
             '{' -> out.putln;
             'object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             
             (if (subLevel = 0) and (common.betaenv.groupname ->thisClassName.equalNCS) then
                 '.field public static ' -> out.puttext;
                 'class [\'%s\']\'%s\'' -> out.putformat(# do common.betaenv.groupname->s; common.betaenv.groupname->s; #);
                 ' betaenvRef'-> out.putln;
             if);
             
             (if not ('-'->thisOrgName.equal) then
                 '.field public ' -> out.puttext;
                 thisOrgName[] -> AddClass -> out.puttext;
                 ' origin'-> out.puttext;
             if);
             BCstate.fields.init;
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
          // endclass then
             out.indent.dec;
             (*out.putln;*)
             '}'->out.putln;

             (if (thisClassName[]<>NONE) and ('BetaObject' -> thisClassName.equal) then
                 (* Just finished generating BetaObject (in betaenv). *)
                 GenerateClassExOException;
                 GenerateClassStructure;
                 GenerateClassBetaArray;
             if);
             
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do (* labs.clear; *)
                BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numCells;
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                1                       -> MappedLocals.new;
                false                   -> hasFields;
                BC.get -> aux;
                (if 'main' -> thisInnerMethodName.equal then
                    out.putln;
                    'static void \'main\'(string[] args)' -> thisSignature[];
                    '.method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] -> out.puttext;
                    ' cil managed' -> out.putln;
                    out.indent.inc;
                    '{' -> out.putln;
                    (if use_modules then
                        (* entrypoint defined by al.exe *)
                     else
                        (if common.switch[6] then
                            'NOT generating .entrypoint (nbeta -x)'->putline;
                         else
                            '.entrypoint' -> out.putln;
                        if)
                    if);
                    true -> isMainMethod;
                    true -> hasMainMethod;
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        out.putln;
                        '.method public virtual void ' -> out.puttext;
                        0 -> stack_height -> max_stack_height;
                        thisInnerMethodName[]
                          -> quote 
                        (* -> thisSignature[] *)
                          -> out.puttext;
                        '() cil managed'
                          -> out.putln;
                        out.indent.inc;
                        '{' -> out.putln;
                        out.indent.dec;
                        'ret' -> out.putln;
                        '}' -> out.putln;
                    if);
                    out.putln;
                    '.method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] 
                      -> AddClass(# nonstatic::(# do 'virtual '->out.puttext #)#)
                      -> out.puttext; (* AddClass fixes return type, but not arguments *)
                    ' cil managed' -> out.putln;
                    out.indent.inc;
                    '{' -> out.putln;
                if);    
                allocStack;
             #);
          // endMethod then 
             (if compute_stack_height then
                 '.maxstack ' -> out.puttext;
                 max_stack_height -> out.putint;
             if);
             out.indent.dec;
             out.putln;
             '}'->out.putline;
             
          // initCons then
             (# sig: ^text
             do BC.gettext -> sig[]; 
                'rtspecialname specialname hidebysig instance void .ctor('
                  -> thisSignature[];
                (if not ('-' -> thisOrgname.equal) then
                    sig[] -> AddClass -> thisSignature.puttext;
                if);
                ')' -> thisSignature.put;
                (if hasfields then
                    out.putln;
                    out.putln;
                if);
                '/* instance constructor */' -> out.putln;
                '.method public ' -> out.puttext;
                0 -> stack_height -> max_stack_height;
                thisSignature[] -> out.putln;
                out.indent.inc;
                '{' -> out.putln;
                allocStack;
             #) 
          // field then
             (# F: @text
             do true -> hasfields;
                'F' -> F; BC.get->F.putInt;
                (if BC.get = 1 then
                    (F[],BC.gettext,BC.gettext,BC.get) 
                      -> BCstate.fields.new
                 else
                    (F[],'???',BC.gettext,BC.get) 
                      -> BCstate.fields.new;
                if)
             #)
          // labelDef then
             2 -> out.indent.dec; 
             out.nl; 
             BC.getShort -> labs.def;
             2 -> out.indent.inc;
          // callPrim then
             (# prim,arg: ^text;
                delta: @integer;
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if true 
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (* Rest is done in subsequent init *)
                 // 'initSuper' -> prim.equal then
                    out.nl;
                    'call  instance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if ('-'->arg.equal) then
                        (* no arguments *)
                        -1 -> delta;
                     else
                        (if false then
                            '/*arg:'->out.puttext; arg[]->out.puttext;'*/'->out.puttext;
                        if);
                        arg[] -> AddClass -> out.puttext;
                        -2 -> delta;
                    if);
                    ')' -> out.puttext;
                    (if (subLevel = 0) and (common.betaenv.groupname ->thisClassName.equalNCS) then
                        out.nl;
                        'ldarg.0' -> out.putln; (* this(betaenv)[] *)
                        'stsfld  class [\'%s\']\'%s\' [\'%s\']\'%s\'::betaenvRef' 
                          -> out.putformat(# 
                                          do common.betaenv.groupname->s; 
                                             common.betaenv.groupname->s; 
                                             common.betaenv.groupname->s; 
                                             common.betaenv.groupname->s; 
                                          #);
                    if);
                    delta -> stack_delta;
                    (*BCstate.fields.emitInit don't: No need to initialize to default values *)
                 // 'init' -> prim.equal then
                    (# ctor_signature: ^text;
                    do 'void ' -> ctor_signature[];
                       class[] (* class name *) -> AddClass -> ctor_signature.puttext;
                       '::.ctor(' -> ctor_signature.puttext;
                       (if false then
                           '/*arg:'->out.puttext; arg[]->out.puttext;'*/'->out.puttext;
                       if);
                       (if ('-'->arg.equal) then
                           (* no arguments *)
                        else
                           arg[] (* origin name *) -> AddClass -> ctor_signature.puttext;
                       if);
                       ')' -> ctor_signature.puttext;
                       out.nl;
                       'newobj  instance '-> out.puttext;
                       ctor_signature[] -> out.puttext;
                       1+(ctor_signature[]->function_stack_delta) -> stack_delta
                    #);
                 // 'NewVR1' -> prim.equal
                 // 'AlloVR1' -> prim.equal then
                    'char' -> newArray  
                 // 'NewVRZ' -> prim.equal
                 // 'AlloVRZ' -> prim.equal then
                    (* the following are no longer used 
                 // 'NewVR1bool' -> prim.equal
                 // 'AlloVR1bool' -> prim.equal then*)
                    'bool' -> newArray  
                 // 'NewVRB' -> prim.equal
                 // 'AlloVRB' -> prim.equal then
                    (* allocate byte array OLM??? *)
                    'int8' -> newArray                    
                 // 'NewVR2' -> prim.equal
                 // 'AlloVR2' -> prim.equal then
                    'int16' -> newArray  
                 // 'NewVR4' -> prim.equal
                 // 'AlloVR4' -> prim.equal then
                    'int32' -> newArray
                 // 'NewVR8' -> prim.equal
                 // 'AlloVR8' -> prim.equal then
                    'float64'-> newArray  
                 // 'NewRR' -> prim.equal
                 // 'AlloRR' -> prim.equal then
                    (* argument: type[] - extract type *)
                    (arg.length-1, arg.length) -> arg.delete;
                    arg[] -> newArray;
                    
                    
                 // 'ExtVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::ExtVR1(char[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::CopyVR1(char[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::CopySVR1(int32,int32,char[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::ExtVRZ(bool[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::CopyVRZ(bool[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::CopySVRZ(int32,int32,bool[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::ExtVR2(int16[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::CopyVR2(int16[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::CopySVR2(int32,int32,int16[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::ExtVR4(int32[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::CopyVR4(int32[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::CopySVR4(int32,int32,int32[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::ExtVR8(float64[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::CopyVR8(float64[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::CopySVR8(int32,int32,float64[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                    
                 (* ... *)
                    
                 // 'ExtRR' -> prim.equal then
                    (* Functionally equivalent to
                     * 
                     * public static char[] ExtVR1(char[] oldrep, int add) {
                     *     int copysize = oldrep.Length;
                     *     int newsize  = copysize + add;
                     *     if (newsize<0) newsize = 0;
                     *     if (copysize>newsize) copysize = newsize;
                     *     char[] newrep = new char[newsize];
                     *     System.Array.Copy(oldrep, 0, newrep, 0, copysize);
                     *     return newrep;
                     * }
                     *)
                    (# loc_oldrep, loc_add, loc_copysize, loc_newsize, loc_newrep: @integer;
                       lab1, lab2: @backendLocalLab;
                    do out.nl;
                       'ExtRR' -> emitComment;
                       (* 'ldstr "ExtRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[] -> allocLocal -> loc_oldrep;
                       'int32' -> allocLocal -> loc_add;
                       'int32'  -> allocLocal -> loc_copysize;
                       'int32'  -> allocLocal -> loc_newsize;
                       arg[] -> allocLocal -> loc_newrep;
                       (* stack: oldrep, add *)
                       loc_add -> storeLocal;
                       loc_oldrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen' -> out.putln;
                       'conv.i4' -> out.putln;
                       loc_copysize -> storeLocal;
                       loc_copysize -> loadLocal;
                       loc_add -> loadLocal;
                       'add' -> out.putln;
                       loc_newsize -> storeLocal;
                       loc_newsize -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab1.new;
                       'bge.s ' -> out.puttext; lab1->out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize -> storeLocal;
                       lab1.def; 
                       loc_copysize -> loadLocal;
                       loc_newsize -> loadLocal;
                       lab2.new;
                       'ble.s' -> out.puttext; lab2-> out.putln;
                       loc_newsize -> loadLocal;
                       loc_copysize -> storeLocal;
                       lab2.def; 
                       loc_newsize -> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_copysize -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array, int32, class [mscorlib]System.Array, int32, int32)' -> out.putln;
                       loc_newrep -> loadLocal;
                       loc_oldrep -> releaseLocal;
                       loc_add -> releaseLocal;
                       loc_copysize -> releaseLocal;
                       loc_newsize -> releaseLocal;
                       loc_newrep -> releaseLocal;
                    #);
                 // 'CopyRR' -> prim.equal then
                    (* Functionally equivalent to
                     *   public static char[] CopyVR1(char[] oldrep) {
                     *     int size = oldrep.Length;
                     *     char[] newrep = new char[size];
                     *     System.Array.Copy(oldrep, 0, newrep, 0, size);
                     *     return newrep;
                     *   }
                     *)
                    (# loc_oldrep, loc_size, loc_newrep: @integer;
                    do out.nl;
                       'CopyRR' -> emitComment;
                       (* 'ldstr "CopyRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[]    -> allocLocal -> loc_oldrep;
                       'int32'  -> allocLocal -> loc_size;
                       arg[]    -> allocLocal -> loc_newrep;
                       (* stack: oldrep *)
                       loc_oldrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen' -> out.putln;
                       'conv.i4' -> out.putln;
                       loc_size -> storeLocal;
                       loc_size -> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_size -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
                       loc_newrep -> loadLocal;
                       loc_oldrep -> releaseLocal;
                       loc_size   -> releaseLocal;
                       loc_newrep -> releaseLocal;
                    #);
                 // 'CopySRR' -> prim.equal then
                    (* Functionally equivalent to:
                     *  public static char[] CopySVR1(int low, int high, char[] oldrep) 
                     *  {
                     *      CkSR(low, high, oldrep.Length);
                     *      int newsize = high - low + 1;
                     *      if (newsize<0) newsize = 0;
                     *      char[] newrep = new char[newsize];
                     *      if (newsize>0) System.Array.Copy(oldrep,low-1,newrep,0,newsize);
                     *      return newrep;
                     *  }
                     *)
                    (# loc_oldrep, loc_low, loc_high, loc_newsize, loc_newrep: @integer;
                       lab1, lab2: @backendLocalLab;
                    do out.nl;
                       'CopySRR' -> emitComment;
                       (*'ldstr "CopySRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[]    -> allocLocal -> loc_oldrep;
                       'int32'  -> allocLocal -> loc_low;
                       'int32'  -> allocLocal -> loc_high;
                       'int32'  -> allocLocal -> loc_newsize;
                       arg[]    -> allocLocal -> loc_newrep;
                       (* stack: low, high, oldrep *)
                       loc_oldrep -> storeLocal;
                       loc_high   -> storeLocal;
                       loc_low    -> storeLocal;
                       loc_low    -> loadLocal;
                       loc_high   -> loadLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen'    -> out.putln;
                       'conv.i4'  -> out.putln;
                       'call  void %s::CkSR(int32,int32,int32)' 
                         -> out.putformat(# do sigBetaArray->s #); out.nl;
                       loc_high   -> loadLocal;
                       loc_low    -> loadLocal;
                       'sub'      -> out.putln;
                       'ldc.i4.1' -> out.putln;
                       'add'      -> out.putln;
                       loc_newsize-> storeLocal;
                       loc_newsize-> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab1.new;
                       'bge.s ' ->out.puttext; lab1-> out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize-> storeLocal;
                       lab1.def;
                       loc_newsize-> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_newsize-> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab2.new;
                       'ble.s ' -> out.puttext; lab2 -> out.putln;
                       loc_oldrep -> loadLocal;
                       loc_low    -> loadLocal;
                       'ldc.i4.1' -> out.putln;
                       'sub'      -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
                       lab2.def;
                       loc_newrep -> loadLocal;
                       loc_newrep -> releaseLocal;
                       loc_oldrep -> releaseLocal;
                       loc_high   -> releaseLocal;
                       loc_low    -> releaseLocal;
                       loc_newsize-> releaseLocal;
                    #)
                 // 'CinitT' -> prim.equal then
                    (* Nothing *)
                 // 'Text2CharArray' -> prim.equal then
                    (if trace_textop then
                        'Text2CharArray:'->emitcomment;
                        out.nl;
                    if);
                    out.nl;
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                 // 'CharArray2String' -> prim.equal then
                    (if trace_textop then
                        'CharArray2String:'->emitcomment;
                        out.nl;
                    if);
                    out.nl;
                    'newobj  instance void class [mscorlib]System.String::.ctor(char[])' -> out.puttext;
                    0 -> stack_delta;
                 // 'char2rep' -> prim.equal then
                    (* a single char is on the stack;
                     * create a new char array of length 1
                     * and store the char in the array;
                     * and return the array on the stack.
                     *)
                    (# loc_ch: @integer;
                    do out.nl;
                       'char' -> allocLocal -> loc_ch -> storeLocal;
                       -1 -> stack_delta;
                       'ldc.i4.1' -> out.putln;
                       'newarr  char' -> out.putln;
                       'dup' -> out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_ch -> loadLocal;
                       4 -> stack_delta;
                       'stelem.i2' -> out.puttext;
                       -3 -> stack_delta;
                       loc_ch -> releaseLocal;
                    #);
                 // 'ExternalString2BetaText' -> prim.equal then
                    (* Note! Hardcoding of pattern 'text'
                     * including case, etc. Should be handled
                     * more generally
                     *)
                    (if trace_textop then
                        'ExternalString2BetaText:'->emitcomment;
                        out.nl;
                    if);  
                    out.nl;
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                    out.nl;
                    'char []' -> allocLocal -> storeLocal;
                    'ldsfld  class [\'%s\']\'%s\' [\'%s\']\'%s\'::betaenvRef' 
                      -> out.putformat(# 
                                      do common.betaenv.groupname->s; 
                                         common.betaenv.groupname->s; 
                                         common.betaenv.groupname->s; 
                                         common.betaenv.groupname->s; 
                                      #);
                    1 -> stack_delta;
                    out.nl;
                    'newobj  instance void class [%s]text::.ctor(class [%s]%s)' -> out.putformat(# do betaenv_name->s; betaenv_name->s; betaenv_name->s; #);
                    0 -> stack_delta;
                    out.nl;
                    'dup' -> out.puttext;
                    1 -> stack_delta;
                    out.nl;
                    numLastLocal -> loadLocal;
                    numLastLocal -> releaseLocal;
                    'callvirt instance void class [%s]text::\'enter\'(char[])'
                      -> out.putformat(# do betaenv_name->s; #);
                    -2 -> stack_delta;
                 // 'BetaText2BetaCharArray' -> prim.equal then
                    out.nl;
                    'ldfld  char[] [\'%s\']text::T' -> out.putformat(# do betaenv_name->s; #);

                 // 'BetaText2ExternalString' -> prim.equal then
                    (if trace_textop then
                        'BetaText2ExternalString:'->emitcomment;
                        out.nl;
                    if);
                    out.nl;
                    'ldfld  char[] [\'%s\']text::T' -> out.putformat(# do betaenv_name->s; #);
                    out.nl;
                    'newobj  instance void class [mscorlib]System.String::.ctor(char[])' -> out.puttext;
                    0 -> stack_delta;
                 // 'AlloS' -> prim.equal then
                    out.nl;
                    'ldtoken  ' -> out.puttext; 
                    arg[] -> out.putln;
                    'call  class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)' -> out.putln;
                    'call  %s %s::AlloS(class [mscorlib]System.Object, class [mscorlib]System.Type)' -> out.putformat(# do sigStructure->s; sigStructure->s; #); out.putln;
                 // 'ObjS' -> prim.equal then
                    out.nl;
                    'call %s %s::ObjS(class [mscorlib]System.Object)' -> out.putformat(# do sigStructure->s; sigStructure->s; #); 
                    out.nl;
                 // 'eqS' -> prim.equal then
                    out.nl;
                    'call bool %s::eqS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'neS' -> prim.equal then
                    out.nl;
                    'call bool %s::neS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'ltS' -> prim.equal then
                    out.nl;
                    'call bool %s::ltS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'leS' -> prim.equal then
                    out.nl;
                    'call bool %s::leS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'gtS' -> prim.equal then
                    out.nl;
                    'call bool %s::gtS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'geS' -> prim.equal then
                    out.nl;
                    'call bool %s::geS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                 // 'AlloSI' -> prim.equal then
                    out.nl;
                    'callvirt class [mscorlib]System.Object %s::AlloSI()' -> out.putformat(# do sigStructure->s; #);
                    out.nl;
                 // 'Att' -> prim.equal then
                    'missing call of attach here' -> emitcomment;
                    'we pop the stack to avoid overflow' -> emitcomment;
                    out.nl;
                    'pop' -> out.puttext;
                    -1 -> stack_delta;
                 else
                    'Primitive NYI: ' -> (prim[] -> ('(' -> (')' -> (arg.copy).append).prepend).prepend).prepend -> fixme;
                if);
             #);
          // callExternal then
             (# prim: ^text;
                pinvoke: @boolean;
                msg: ^text;
             do BC.getText -> prim[];
                (*'CallExternal: '->puttext; prim[] -> putline;*)
                true -> pinvoke;
                find: 
                  (# 
                  do '['->prim.findall(# do false->pinvoke; leave find #)
                  #);
                (if pinvoke then
                    (* platform invoke *)
                    &text[]->msg[];
                    'PInvoke of %s NYI'->msg.putformat(# do prim[]->s #);
                    msg[] -> FIXME;
                    &text[]->msg[];
                    out.nl;
                    '// .method public hidebysig static pinvokeimpl("xxx.dll" cdecl) <returntype> %s(<arguments>) cil managed preservesig {}' 
                      -> msg.putformat(# do prim[]->s #);
                    msg[] -> out.putline;;
                    &text[]->msg[];
                    '  '-> out.puttext;
                    '// call <returntype> [\'yyy\']\'yyy\'::%s(<arguments>'
                      -> msg.putformat(# do prim[]->s #);
                    msg[] -> out.putline;
                 else
                    (* Normal clr call *)
                    out.nl;
                    'call  ' -> out.puttext;  
                    prim[] -> out.puttext;
                    prim[] -> function_stack_delta -> stack_delta;
                if);
             #)
          // comment then
             (# T: ^text
             do BC.gettext -> T[];
                (if trace_comments then
                    out.nl;
                    '/* ' -> out.puttext; 
                    (*T[] -> putline;*) T[] -> out.puttext;
                    ' */ ' -> out.putline;
                if)
             #)
          // position then
             BC.getShort -> line;
             (if generateLineNumbers then
                 (if betafile.initialized then
                     out.nl;
                     '.line  ' -> out.puttext; 
                     line -> betafile.pc.posToLineCol -> (line, column);
                     line -> out.putint;
                     ':' -> out.put;
                     column+1 -> out.putint;
                     ' ' -> out.puttext;
                     betafilename[] -> quote -> out.puttext;
                 if);
             if);
          // nop then
             (if allow_nop_emit then
                 out.nl;
                 'nop'->out.putln;
             if);
          else
             (* Opcodes all needing a tab for indentation *)
             out.nl;
             (if opCode
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 A.get; A.loadRef
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,ctag,ftag: @integer; 
                    className, fieldType: ^text;
                 do BC.get -> ONlevel;
                    BC.get -> ctag;
                    (if ctag = 1 then
                        BC.getText -> className[]
                    if);
                    BC.get -> ftag;
                    (if ftag = 1 then
                        BC.gettext -> fieldType[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                        1 -> stack_delta;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0' -> out.puttext; 1->_n;
                            1 -> stack_delta;
                         else
                            'ldfld  ' -> out.puttext; 5->_n;
                            (if ftag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> out.puttext; 
                             else
                                fieldType[] -> AddClass -> out.puttext
                            if);
                            ' ' ->out.put;
                            (if ctag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.class
                                  -> quote 
                                  -> out.puttext
                             else
                                className[] -> quote -> AddClass -> out.puttext
                            if);
                            '::origin ' -> out.puttext; 3->_n;
                            0 -> stack_delta;
                        if);
                    if)
                 #)
              // cast then
                 'castclass  ' -> out.puttext;
                 BC.gettext -> out.putln;
                 (* stack neutral *)
              // callInner then
                 'ldarg.0' -> out.puttext; 4->_n;
                 out.nl;
                 1 -> stack_delta;
                 'callvirt ' -> out.puttext;
                 (* NOT in accordance with design - FIX *)
                 'instance void ' -> out.puttext;
                 thisClassName[] -> out.puttext;
                 '::'->out.puttext;
                 thisInnerMethodName[]->out.puttext;
                 '()'->out.puttext;
                 -1 -> stack_delta;
              // call then 
                 (# calltype: @integer;
                    delta: @integer;
                 do BC.get -> calltype;
                    BC.getText->T[];
                    (*'// call: ' -> out.puttext; T[]->out.putline;*)
                    T[] -> function_stack_delta -> delta;
                    (if calltype = 1 then
                        'call' -> out.puttext 
                     else
                        'callvirt' -> out.puttext;
                    if);
                    ' '->out.put;
                    2->_n;
                    T[] -> AddClass(# static::(# do true->omitstatic; #);
                                      nonstatic::(# do 'instance '->out.puttext; delta-1->delta #)
                                   #) ->out.puttext;
                    delta -> stack_delta;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 #)
              // return then
                 (# returncode: @integer;
                    msg: ^text;
                 do (if BC.get->returncode
                     // 0 // 10 then 
                        0 -> check_stack_height;
                        'ret' -> out.puttext;
                        0 -> stack_delta;
                     // 1 // 2 // 3 // 4 // 5 // 6 // 11 // 12 // 13 // 14 
                        then
                        1 -> check_stack_height;
                        'ret' -> out.puttext;
                        -1 -> stack_delta;
                     else (* error *) 
                        'xreturn: ' -> msg[];
                        returncode -> msg.putint;
                        msg[] -> FIXME;
                    if);
                 #)
              // beginLab then
                 (# restartLabno: @integer;
                    leaveLabno: @integer;
                 do BC.getLong -> restartlabno;
                    BC.getLong -> leavelabno;
                    '.try {' -> out.puttext;
                    out.indent.inc;
                 #);
              // endLab then
                 (# restartLabno: @integer;
                    leaveLabno: @integer;
                    exoclass: ^text;
                    loc: @integer;
                 do BC.getLong -> restartlabno;
                    BC.getLong -> leavelabno;
                    (if false then
                        '/*endlab: restart='->out.puttext;
                        restartlabno->out.putint;
                        ', leavelabno='->out.puttext;
                        leavelabno->out.putint; '*/' -> out.putln;
                    if);
                    (* End try clause by jumping over handler *)
                    'leave  L' -> out.puttext; leavelabno -> out.putint; 
                    out.indent.dec;
                    out.nl;
                    '} // end .try L' -> out.puttext;
                    restartlabno->out.putint;
                    
                    (* Handler:
                     * if (e.exitobj == this){
                     *	    if (e.labno==restartlabno){
                     *	      /* We have a restart in this object */
                     *              goto Lrestart;
                     *            } else if (e.labno==leavelabno){
                     *	      /* We have a leave in this object */
                     *              goto Lleave;
                     *	    }
                     *	  }
                     * 	  /* Not leave/restart in this object - propagate */
                     * 	  throw;
                     *)
                    out.nl;
                    'catch [\'%s\']ExOException {' 
                      -> out.putformat(# do betaenv_name->s #);
                    out.indent.inc;
                    out.nl;
                    
                    &text[] -> exoclass[];
                    '[\'%s\']ExOException'
                      -> exoclass.putformat(# do betaenv_name->s #);
                    'class ' -> (exoclass.copy).prepend -> allocLocal -> loc;
                    
                    (* Save exception object e in local cell *)
                    loc -> storeLocal;
                    (* Test this[] = e.exitObj *)
                    loc -> loadLocal;
                    'ldfld  object %s::exitobj'
                      -> out.putformat(# do exoclass[]->s #);;
                    out.nl;
                    'ldarg.0' -> out.putln;
                    'bne.un  L%d_rethrow' 
                      -> out.putformat(# do restartlabno->d #);;
                    out.nl;
                    
                    (* Test e.labno=restartlabno *)
                    loc -> loadLocal;
                    'ldfld  int32 %s::labno'
                      -> out.putformat(# do exoclass[]->s #);;
                    out.nl;
                    pushCst(# do restartlabno->i #); out.nl;
                    'bne.un  L%d_testleave' 
                      -> out.putformat(# do restartlabno->d #);;
                    out.nl;
                    'leave  L%d'
                      -> out.putformat(# do restartlabno->d #);;
                    out.nl;
                    
                    'L%d_testleave:'
                      -> out.putformat(# do restartlabno->d #);;
                    out.nl;
                    (* Test e.labno=leavelabno *)
                    loc -> loadLocal;
                    'ldfld  int32 %s::labno'
                      -> out.putformat(# do exoclass[]->s #);;
                    out.nl;
                    pushCst(# do leavelabno->i #); out.nl;
                    'bne.un  L%d_rethrow' 
                      -> out.putformat(# do restartlabno->d #);;
                    out.nl;
                    'leave  L%d'
                      -> out.putformat(# do leavelabno->d #);;
                    
                    (* retrow to outer handler *)
                    2 -> out.indent.dec;
                    out.nl;
                    'L%d_rethrow:' 
                      -> out.putformat(# do restartlabno->d #);
                    2 -> out.indent.inc;
                    out.nl;
                    'rethrow' -> out.puttext;
                    loc -> releaseLocal;
                    out.indent.dec;
                    out.nl;
                    '} // end catch L' -> out.puttext;
                    restartlabno->out.putint;
                 #);
              // break then
                 (# labno: @integer;
                    re_start: @integer;
                 do BC.getLong -> labno;
                    BC.get -> re_start;
                    (* exitObj already pushed *)
                    pushCst(# do labno -> i #); 
                    out.nl;
                    'newobj  instance void [\'%s\']ExOException::.ctor(object,int32)' -> out.Putformat(# do betaenv_name->s #);
                    out.nl;
                    'throw' -> out.puttext;
                 #)
              // cmpToBool
              // cmpToBoolFloat then
                 (if trace_compares then
                     'cmpToBool' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpToBoolRef then
                 (if trace_compares then
                     'cmpToBoolRef' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpAndJmp then
                 (if trace_compares then
                     'cmpAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.getShort,BC.get) -> emitCmpJmp
              // cmpAndJmpFloat then
                 (BC.get,BC.get,BC.getShort,0) -> emitCmpJmp
              // cmpBoolAndJmp then
                 (if trace_compares then
                     'cmpBoolAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.getShort) -> emitCmpBoolJmp
              // pushCst_s8 then
                 pushCst(# c: @int8 (* CAREFULL: char is unsigned! *);
                        do BC.get->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s16 then
                 pushCst(# c: @int16;
                        do BC.getshort->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s32 then
                 pushCst(# 
                        do BC.getlong->i;
                        #);
              // pushRealCst then
                 'ldc.r8  '  -> out.puttext;
                 (BC.getLong, BC.getLong) -> twolongs2real -> out.putreal;
              // pushVal then
                 'pushVal'->out.puttext
              // pushNone then
                 'ldnull' -> out.puttext;
                 1 -> stack_delta;
              // dup then
                 BC.get -> arg1; (* pos *)
                 BC.get -> arg2; (* type *)
                 (if arg2
                  // 0 (* duplicate int32 *)
                  // 1 (* duplicate double *) then 
                     (if arg1
                      // 0 then 
                         'dup' -> out.puttext;
                         1 -> stack_delta;
                      // 1 then 
                         'IL has no dup_x1 instruction' -> FIXME;
                      // 2 then 
                         'IL has no dup_x2 instruction' -> FIXME;
                     if)
                  // 2 (* duplicate 2 int32 *) then
                     (if arg1
                      // 0 then 
                         'Warning: using naive dup2 implementation - may fail' -> FIXME;
                         (* Will ONLY work if two top elements are really int32! *)
                         (# loc1, loc2: @integer;
                         do 'int32' -> allocLocal -> loc1;
                            'int32' -> allocLocal -> loc2;
                            loc1 -> storeLocal;
                            loc2 -> storeLocal; 
                            loc2 -> loadLocal;
                            loc1 -> loadLocal;
                            loc2 -> loadLocal;
                            loc1 -> loadLocal;
                            loc1 -> releaseLocal;
                            loc2 -> releaseLocal;
                         #);
                      // 1 then
                         'IL has no dup2_x1 instruction' -> FIXME;
                      // 2 then
                         'IL has no dup2_x2 instruction' -> FIXME;
                     if)
                 if)
              // pop then
                 'pop' -> out.puttext;
                 -1 -> stack_delta;
              // pop2 then
                 'pop' -> out.puttext;
                 -1 -> stack_delta;
              // _loadLocal then
                 (* 'BCdotnetBody: bytecode LoadLocal' -> screen.putline;*)
                 MappedLocals[lastMappedLocal]-1 -> loadLocal;
              // loadRange then 
                 'ldlen' -> out.puttext;
                 0 -> stack_delta;
              // pushReg then
                 '// pushReg '->out.puttext;
                 dumpReg
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' '->out.put; 
                 BC.getText->emitString;
                 1 -> stack_delta;
              // jmp then
                 'br'->out.puttext;
                 BC.get (* opcode label *); 
                 BC.getshort -> labs.use;
                 0 -> stack_delta;
              // jmpt then
                 BC.get (* opcode label *); 
                 BC.gettext (* Entry to go to *);
                 'Opcode JmpT' -> FIXME;
              // cmp then
                 'cmp'->out.puttext
              // r64toR32 then
                 'conv.r4'->out.puttext;
              // r64add then
                 'add'->out.puttext;
                 -2 -> stack_delta;
              // r64Sub then
                 'sub'->out.puttext;
                 -2 -> stack_delta;
              // r64Mul then
                 'mul'->out.puttext;
                 -2 -> stack_delta;
              // r64Div then
                 'div'->out.puttext;
                 -2 -> stack_delta;
              // r64Neg then
                 'neg'->out.puttext;
              // int2double then
                 'conv.r8'->out.puttext;
                 1 -> stack_delta;
              // double2int then
                 'conv.i4'->out.puttext;
                 -1 -> stack_delta;
              // func then
                 (# f: @integer;
                    delta: @integer;
                 do BC.get->f;
                    (if f
                     // add then
                        'add'->out.puttext; 1->_n;
                        -1 -> delta;
                     // sub then
                        'sub'->out.puttext;
                        -1 -> delta;
                     // orr then
                        'or'->out.puttext;
                        -1 -> delta;
                     // andd then
                        'and'->out.puttext;
                        -1 -> delta;
                     // xorr then
                        'xor'->out.puttext;
                        -1 -> delta;
                     // nott then
                        (* boolean not *)
                        'ldc.i4.0\n' -> out.putln;
                        'ceq' -> out.puttext;
                        0 -> delta;
                        out.newline;
                     // mult then
                        'mul'->out.puttext;
                        -1 -> delta;
                     // divv then
                        'div'->out.puttext;
                        -1 -> delta;
                     // modd then
                        -1 -> delta;
                        'rem'->out.puttext;
                     // logNot then
                        (* bit not *)
                        'not'->out.puttext;
                        0 -> delta;
                     // neg then
                        'neg'->out.puttext;
                        0 -> delta;
                     // logicalShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // arithShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // logicalShiftRight then 
                        'shr.un'->out.puttext;
                        -1 -> delta;
                     // arithShiftRight then 
                        'shr'->out.puttext;
                        -1 -> delta;
                     // rotateLeft then
                        (* Perform i %rol r *)
                        (* Implemented as:
                         *   (i << r) | ((i & ((1<<r)-1)) >> (32-r))
                         *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           out.nl;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           loc_i -> loadLocal;
                           'ldc.i4.1' -> out.putln;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           'ldc.i4.1' -> out.putln;
                           'sub' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4.s   32' -> out.putln;
                           loc_r -> loadLocal;
                           'sub' -> out.putln;
                           '\shr' -> out.putln;
                           'or' -> out.putln;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #)
                     // rotateRight then
                        (* Perform i %ror r *)
                        (* Implemented as:
                         *   (i >> r) | ((i & ((1<<r)-1)) << (32-r))
                         *)
                        (* initial stack: r, i *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           out.nl;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           'shr' -> out.putln;
                           loc_i -> loadLocal;
                           'ldc.i4.1' -> out.putln;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           'ldc.i4.1' -> out.putln;
                           'and' -> out.putln;
                           'sub' -> out.putln;
                           'ldc.i4.s  32' -> out.putln;
                           loc_r -> loadLocal;
                           'sub' -> out.putln;
                           'shl' -> out.putln;
                           'or' -> out.putln;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #);
                     // byteswapshort then
                        (* Implemented as ((x>>8) | ((x<<8) & 0xff00)) *)
                        (* stack: x *)
                        (# loc_x: @integer;
                        do (* initial stack: x *)
                           'int32' -> allocLocal -> loc_x;
                           'conv.i4' -> out.putln;
                           'dup' -> out.putln;
                           loc_x -> storeLocal;
                           'ldc.i4.8' -> out.putln;
                           'shr' -> out.putln;
                           loc_x -> loadLocal;
                           'ldc.i4.8' -> out.putln;
                           'shl' -> out.putln;
                           'ldc.i4 0xff00' -> out.putln;
                           'and' -> out.putln;
                           'or' -> out.putln;
                           loc_x -> releaseLocal;
                        #);
                     // byteswaplong then
                        (* Implemented as
                        *   short h = (short)(x>>16);
	                *   short l = (short)(x & 0xffff);
	                *   short nl = (short)((h>>8) | ((h<<8) & 0xff00));
	                *   short nh = (short)((l>>8) | ((l<<8) & 0xff00));
	                *   int result = (nh << 16) | nl;
                        *)
                        (# loc_swap1, loc_swap2: @integer;
                           (* stack: x, ... *)
                           swap:
                             (* swap two topmost stack elements of type int32 *)
                             (# 
                             do loc_swap1 -> StoreLocal;
                                loc_swap2 -> StoreLocal;
                                loc_swap1 -> LoadLocal;
                                loc_swap2 -> LoadLocal;
                             #);
                        do 'int32' -> AllocLocal -> loc_swap1;
                           'int32' -> AllocLocal -> loc_swap2;
                           'dup'            -> out.putln;
                           'dup'            -> out.putln;
                           (* stack: x, x, x, ... *)
                           'ldc.i4  0xffff' -> out.putln;
                           'and'            -> out.putln;
                           'ldc.i4.8'       -> out.putln;
                           'shr'            -> out.putln;
                           (* stack: (l>>8), x, x, ... *)
                           swap;
                           (* stack: x, (l>>8), x, ... *)
                           'ldc.i4  0xffff' -> out.putln;
                           'and'            -> out.putln;
                           'ldc.i4.8'       -> out.putln;
                           'shl'            -> out.putln;
                           'ldc.i4  0xff00' -> out.putln;
                           'and'            -> out.putln;
                           'or'             -> out.putln;
                           'ldc.i4  16'     -> out.putln;
                           'shl'            -> out.putln;
                           (* stack: (nh<<16), x, ... *)
                           swap;
                           (* stack: x, (nh<<16), ... *)
                           'dup'            -> out.putln;
                           (* stack: x, x, (nh<<16), ... *)
                           'ldc.i4  16'     -> out.putln;
                           'shr'            -> out.putln;
                           'ldc.i4.8'       -> out.putln;
                           'shr'            -> out.putln;
                           (* stack: (h<<8), x, (nh<<16), ... *)
                           swap;
                           (* stack: x, (h<<8), (nh<<16), ... *)
                           'ldc.i4  16'     -> out.putln;
                           'shr'            -> out.putln;
                           'ldc.i4.8'       -> out.putln;
                           'shl'            -> out.putln;
                           'ldc.i4  0xff00' -> out.putln;
                           'and'            -> out.putln;
                           'or'             -> out.putln;
                           'or'             -> out.putln;
                           loc_swap1 -> releaseLocal;
                           loc_swap2 -> releaseLocal;
                        #);
                     else
                        (# msg: ^text;
                           _f: @integer;
                        do 'Unhandled bytecode' -> msg[];
                           (if (32<=f) and (f<=126) then
                               f -> _f;
                               ' \'%c\'' -> msg.putformat(# do _f->c #);
                           if);
                           ' func.' -> msg.append;
                           f -> asText -> msg.append;
                           ' ('->msg.append;
                           f->msg.putint;
                           ')' -> msg.put;
                           msg[] -> fixme;
                        #);
                    if);
                    delta -> stack_delta;
                    99->_n;
                    out.newline;
                 #)
              else
                 (# msg: ^text;
                 do 'Unhandled bytecode ' -> msg[];
                    (if (32<=opcode) and (opcode<=126) then
                        '\'%c\' ' -> msg.putformat(# do opcode->c #);
                    if);
                    opcode -> asText -> msg.append;
                    ' ('->msg.append;
                    opcode->msg.putint;
                    ')' -> msg.put;
                    msg[] -> fixme;
                 #);
             if);
         if);
         (opcode = jmp)  -> previousWasJmp;
         restart read;
     if);
   out.close
#)  

-- LIB:attributes--
SlashToBackslash: 
  (# T: ^Text;
  enter T[]
  do (for i:T.lgth repeat
          (if T.T[i] = '/' then '\\' -> T.T[i] if)
     for);
  exit T[]
  #);
BackslashToSlash: 
  (# T: ^Text;
  enter T[]
  do (for i:T.lgth repeat
          (if T.T[i] = '\\' then '/' -> T.T[i] if)
     for);
  exit T[]
  #);
quote:
  (# T: ^text;
  enter T[]
  do (if T.lgth>0 then
         (if (not (('class [')->((1,7)->T.sub).equal)) and 
             (not (T.T[1]='[')) and 
             (not (T.T[1]='\'')) and 
             (not (T.T[T.lgth]='\'')) then 
             T.copy -> T[];
             '\''->T.prepend;
             '\''->T.append; 
         if);
     if)
  exit T[]
  #);
unQuote:
  (# t: ^text;
  enter t[]
  do (if ((1 -> t.inxGet) = '"') AND ((t.length -> t.inxGet) = '"') then
         (2, t.length - 1) -> t.sub -> t[];
     if);
  exit t[]
  #);

unTick:
  (# t: ^text;
  enter t[]
  do (if ((1 -> t.inxGet) = '\'') AND ((t.length -> t.inxGet) = '\'') then
         (2, t.length - 1) -> t.sub -> t[];
     if);
  exit t[]
  #);

textHashTable: hashTable
  (# element::<(# T: ^text #);
     honeyM: @honeyMan;
     initialized: @boolean;
     init::< (# do honeyM.init; INNER; true -> initialized; #);
     hashFunction::<(# do e.t[]-> honeyM.hash -> value; INNER #);
     equal::< (# do left.t[]->right.t.equal->value; INNER #);
     get:<
       (# T: ^text;
          E: ^element;
          was_there: @boolean;
       enter T[]
       do T[] -> unTick -> unQuote -> unTick -> T[];
          (if not initialized then init if);
          &element[] -> e[];
          T[] -> e.T[];
          e[]->hashfunction->findIndexed
          (# predicate:: (# do (T[]->current.t.equal)->value; #);
          do current[]->e[];
             true->was_there;
          #);
          INNER;
       exit was_there
       #);
     add:<
       (* Returns true if T was not already here *)
       (# T: ^text;
          E: ^element;
          was_inserted: @boolean;
       enter T[]
       do T[] -> unTick -> unQuote -> unTick -> T[];
          (if not initialized then init if);
          &element[] -> e[];
          T[] -> e.T[];
          INNER;
          e[]->hashfunction->findIndexed
          (# predicate:: (# do (T[]->current.t.equal)->value; #);
             notFound:: (# do e[] -> insert; true -> was_inserted #)
          do current[]->e[] (* Only when found *)
          #);
       exit was_inserted
       #);
  #);

assemblyinfohashtable: texthashtable
  (# element::< (# version, publickeytoken: ^text; #);
     get::< (# version, publickeytoken: ^text;
            do E.version[] -> version[];
               E.publickeytoken[] -> publickeytoken[];
            exit (version[], publickeytoken[])
            #);
     add::< (# version, publickeytoken: ^text;
            enter (version[], publickeytoken[])
            do version[] -> E.version[];
               publickeytoken[] -> E.publickeytoken[];
            #);
  #);
