ORIGIN 'BCmachineBody'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/basiclib/formatio'; 
INCLUDE '~beta/basiclib/pcre'; 
INCLUDE '~beta/basiclib/streamPosition'; 
INCLUDE '~beta/toollibs/utils/fileExtensions';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit false #);
trace_class:
  (# exit false #);
trace_convert:
  (# exit false #);
trace_mem:
  (# exit false #);
trace_sig:
  (# exit false #);
trace_n:
  (# exit false #);
trace_comments:
  (# exit false #);
trace_compares:
  (# exit false #);
trace_textop:
  (# exit false #);

compute_stack_height:
  (# exit false #);
check_stack: (* only relevant if compute_stack_height is true *)
  (# exit false #);
trace_stack: (* only relevant if compute_stack_height is true *)
  (# exit true #);

use_reflection:
  (# exit false #);
use_betarun:
  (# exit false #);
use_modules:
  (# exit false #);
generateLineNumbers:
  (# exit common.switch[41] #);
fixme_is_comment:
  (# exit false #);

reversecond:
  (# cond: @integer
  enter cond
  do (if cond
      // common.cond_lt then common.cond_gt -> cond
      // common.cond_le then common.cond_ge -> cond
      // common.cond_gt then common.cond_lt -> cond
      // common.cond_ge then common.cond_le -> cond
     if);
  exit cond
  #);

emitcomment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
_n:
  (# n: @integer;
  enter n
  do (if trace_n then
         ' /*'->out.puttext;
         n->out.putint;
         '*/'->out.puttext;
     if);
  #);
quote:
  (# T: ^text;
  enter T[]
  do (if T.lgth>0 then
         (if (not (('class [')->((1,7)->T.sub).equal)) and 
             (not (T.T[1]='[')) and 
             (not (T.T[1]='\'')) and 
             (not (T.T[T.lgth]='\'')) then 
             T.copy -> T[];
             '\''->T.prepend;
             '\''->T.append; 
         if);
     if)
  exit T[]
  #);

FIXME: 
  (# T: ^text
  enter T[]
  do 'FIXME: ' -> (T.copy).prepend -> T[];
     '\n***** ' -> screen.puttext; T[] -> screen.putline;
     (if fixme_is_comment then
         T[] -> emitcomment;
      else
         '\n\tldstr "'->out.puttext; 
         T[]->out.puttext; 
         '"' -> out.putline;
         '\tcall void [mscorlib]System.Console::WriteLine(string)\n\t' -> out.puttext;
     if)
  #);
ConvertType:
  (# T: ^text
  enter T[]
  do (if trace_convert then
         '/*ConvertType('->out.puttext;
         T[]->out.puttext;
         ')*/' ->out.puttext;
     if);
     (if true 
      // T[]=NONE then
         (DumpStack, 'ConvertType: T[] is none') -> Stop;
      // 'I' -> T.equal then
         'int32 /*I*/' -> T[];
      // 'C' -> T.equal then
         'char /*C*/' -> T[];
      // '[I' -> T.equal then
         'int32[] /*I*/' -> T[];
      // '[C' -> T.equal then
         'char[] /*C*/' -> T[];
     if);
     INNER;
  exit T[]
  #);
RemoveClass:
  (# type: ^text
  enter type[]
  do (if 'class ' -> ((1,6)->type.sub).equal then
         (1,6) -> type.delete;
     if);
  exit type[]
  #);
     
AddClass: ConvertType
  (# isStatic: @boolean;
     location: ^text;
     static:< object;
     nonstatic:< object;
     omitstatic: @boolean;
  do (if 'static '  -> ((1,7)->T.sub).equal then
         true -> isStatic;
         (1,7)->T.delete;
         static;
      else
         nonstatic;
     if);
     (if true 
      // 'int32'   -> T.equal 
      // 'bool'    -> T.equal 
      // 'char'    -> T.equal 
      // 'void '   -> ((1,5)->T.sub).equal
      // 'int32 '  -> ((1,6)->T.sub).equal
      // 'bool '   -> ((1,5)->T.sub).equal
      // 'char '   -> ((1,5)->T.sub).equal
      // 'char[]'  -> ((1,6)->T.sub).equal
      // 'int32[]' -> ((1,7)->T.sub).equal
      // 'bool[]'  -> ((1,6)->T.sub).equal
         then
         (* nothing *)
      else
         (* Local reference. Add class keyword but no location *)
         (if trace_class then 'AddClass' -> emitcomment if);
         (if not ('class '  -> ((1,6)->T.sub).equal) then
             (*T[] -> quote -> T[];*)
             'class ' -> T.prepend;
         if)
     if);
     (if isStatic and (not omitstatic) then
         'static ' -> T.prepend;
     if);
  #);

parseNumberOfArguments: 
  (# numInputs, numOutputs: @integer;
     signature: ^text;
     start: @integer;
     trace: (# exit false #);
  enter signature[]
  do (if trace then
         'parseNumberOfArguments: ' -> screen.puttext;
         signature[] -> screen.puttext;
     if);
     (if 'void ' -> ((1,5)->signature.sub).equal then
         0 -> numOutputs;
      else
         1 -> numOutputs;
     if);
     '(' -> signature.findall(# do inx->start #);
     (start+1, signature.length-1) -> signature.sub -> signature[];
     (if true 
      // signature.length=0 then
         (* no parameters *)
         0 -> numInputs;
      // 'void' -> signature.equal then
         0 -> numInputs;
      else
         1 -> numInputs;
         ',' -> signature.findall(# do numInputs+1->numInputs #);
     if);
     (if trace then
         (if false then
             '. Arguments: "'->screen.puttext;
             signature[] -> screen.puttext;
             '"' -> screen.put;
         if);
         '. NoOfInputs: '->screen.puttext;
         numInputs -> screen.putint; 
         '. NoOfOutputs: '->screen.puttext;
         numOutputs -> screen.putint; 
         screen.newline;
     if);
  exit (numInputs, numOutputs)
  #);

function_stack_delta:
  (# signature: ^text;
     in, out: @integer;
  enter signature[]
  do signature[] -> parseNumberOfArguments -> (in, out);
  exit out-in
  #);
  
--FieldsNewDotnet:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
       out.newline;
    // '[' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' [] ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
       out.newline;
    // 'm' then
       (if numLocals>=numArguments then
           (if numLocals>numArguments then 
               ',\n\t\t\t' -> out.puttext 
            else 
               '\t.locals init   (' -> out.puttext;
           if);
           '[' -> out.puttext;
           numLocals-numArguments -> out.putint;
           '] ' -> out.puttext;
           T[] -> AddClass -> out.puttext;
           (if false then
               ' V_' -> out.puttext; 
               numLocals-numArguments -> out.putint;
            else
               ' '->out.put;
               FN[] -> out.puttext; (* local variable name *)
           if);
       if);
       numLocals+1 -> numLocals;
    // 'M' then
       (* end method locals *)
       (if numLocals>numArguments then
           ')\n' -> out.puttext;
       if);
    // 'C' then
       (* end class fields *)
       '\n' -> out.puttext;
    else
       'FieldsNewDotnet: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemDotnet:descriptor--
(# 
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       '\tldarg.0' -> out.puttext; 2->_n;
       out.newline;
       (if true
        // 'char' -> currentType.equal 
        // 'C' -> currentType.equal 
        // 'int32' -> currentType.equal 
        // 'I' -> currentType.equal
        // 'bool' -> currentType.equal 
        // 'Z' -> currentType.equal 
           then
           '\tldc.i4.0\n' -> out.puttext;
        else
           '\tldnull \n' -> out.puttext
       if);
       '\tstfld\t' -> out.puttext; 1->_n; 
       currentType[] -> ConvertType -> out.puttext;
       ' ' -> out.puttext;
       thisClassName[] -> out.puttext;
       '::' -> out.puttext;
       currentFieldName[] -> quote -> out.puttext;
       out.newline;
   if)
#)

-- emitdotNet: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   localLabNo: @integer; (* counter for local labels as generated by
                          * e.g. cmpToBool
                          *)
   previousWasJmp: @boolean;
   
   betafile: @file(# pc: @positionConverter #);
   betafilename: ^text;
   line, column: @integer;
   
   stack_height: @integer;
   max_stack_height: @integer;
   stack_delta:
     (# delta: @integer;
     enter delta 
     do (if compute_stack_height then
            delta+stack_height->stack_height;
            (if stack_height>max_stack_height then
                stack_height->max_stack_height;
            if);
            (if trace_stack then
                ' /* stack height: ' -> out.puttext;
                stack_height -> out.putint;
                ' */ ' -> out.puttext;
            if);
            (if (stack_height<0) and (stack_height-delta>=0) then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    '::' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                    'Stack underflow' -> fixme;
                 else
                    'Stack Underflow!' -> emitcomment;
                if)
            if);
        if)
     #);
   check_stack_height:
     (# predicted_height: @integer;
        msg: ^text;
     enter predicted_height
     do (if compute_stack_height then
            (if stack_height<>predicted_height then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    ':: ' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                if);
                'Unexpected stack height ' -> msg[];
                stack_height -> msg.putint;
                ' (' -> msg.puttext;
                predicted_height -> msg.putint;
                ' expected)' -> msg.puttext;
                (if check_stack then
                    msg[] -> fixme;
                 else
                    msg[] -> emitcomment;
                    '\n\t' -> out.puttext;
                if);
            if);
        if)
     #);
   
   labs: @
     (#
        stack_heights: [500] ^IntegerObject;
        clear:
          (# 
          do (for i:stack_heights.range repeat
                  NONE->stack_heights[i][]
             for);
          #);
        def: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             '  L'->out.puttext; l->out.putint; 
             ': '->out.puttext;
             (if compute_stack_height then
                 (* stack height book-keeping *)
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Use stack height defined by branch to here *)
                     stack_heights[l] -> stack_height;
                     (if trace_stack then
                         '/* Stack height (from previous branches to here): ' -> out.puttext;
                         stack_height -> out.putint;
                         ' */' -> out.puttext;
                     if);
                  else
                     (if previousWasJmp then
                         (* Cannot use current stack height, since we never
                          * fall through to here
                          *)
                         (if false then
                             'At definition of L' -> msg[];
                             l-> msg.putint;
                             ': Cannot determine stack height' -> msg.puttext;
                             msg[] -> fixme;
                         if);
                         (* According to OLM: stack height should be 0 here *)
                         &IntegerObject[] -> stack_heights[l][];
                         (if trace_stack then
                             '/* Stack height (assumed): ' -> out.puttext;
                             stack_height -> out.putint;
                             ' */' -> out.puttext;
                         if);
                      else
                         &IntegerObject[] -> stack_heights[l][];
                         stack_height -> stack_heights[l];
                         (if trace_stack then
                             '/* Stack height (fall through from above): ' -> out.puttext;
                             stack_height -> out.putint;
                         if);
                     if);
                 if);
             if);
             out.newline;
          #);
        use: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             '\tL'->out.puttext;
             l -> out.putint;
             (if compute_stack_height then
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Other branches to L. Check consistency *)
                     (if stack_height<>stack_heights[l] then
                         out.entry.path.name -> msg[];
                         ': Stack inconsistency: current stack height '
                           -> msg.puttext;
                         stack_height -> msg.putint;
                         ' at branch target L' -> msg.puttext;
                         l -> msg.putint;
                         ' differs from previous value ' -> msg.puttext;
                         stack_heights[l] -> msg.putint;
                         msg[] -> fixme;
                     if);
                  else
                     &IntegerObject[] -> stack_heights[l][];
                     stack_height -> stack_heights[l];
                 if);
             if);
          #);
     #);
 
   
   init:
     (# BCmch: ^ByteCodeMachine;
     do out.entry.path.name -> thisModuleName[];
        (if generateLineNumbers then
            (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename[];
            '.bet' -> betafilename.append;
            betafilename[] -> betafile.name;
            betafile.openRead;
            betafile.pc.update;
            betafile.close;
        if);
        '.il' -> thisModuleName.stripExtension;
        thisModuleName.copy -> BCstate.thisModuleName[];
        (if use_betarun then
            emitModuleHeader;
         else
            emitAssemblyHeader;
        if);
     #);
   allocLocal:
     (# type: ^text;
     enter type[]
     do '.locals init ([%d] %s)\n'
          -> out.putformat(# num: @integer;
                          do BCstate.fields.numLocals 
                             - BCstate.fields.numArguments -> num;
                             num -> d;
                             type[] -> s
                          #);
        BCstate.fields.numLocals+1 -> BCstate.fields.numLocals;
     exit BCstate.fields.numLocals-1-BCstate.fields.numArguments
     #);
   releaseLocal:
     (# locNum: @integer
     enter locNum
     do (* Currently not used.
         * Could recycle locNum by remembering the index and the current type of that index.
         * A subsequent allocLocal could then reuse this local if it's the same type.
         *)
     #);
   opLocal:
     (# num: @integer;
        delta: @integer;
     enter num
     do '\t' -> out.puttext;
        INNER;
        'loc' -> out.puttext;
        (if true
         // num <= 3 
            then '.' -> out.put
         // num <= 255 
            then '.s ' -> out.puttext
         else
            ' ' -> out.put 
        if);
        num -> out.putint; 
        delta-> stack_delta; 
        out.newline;
     #);
   storeLocal: 
     opLocal(# do 'st' -> out.puttext; -1->delta; #);
   loadLocal: 
     opLocal(# do 'ld' -> out.puttext; 1->delta; #);
   numLocals:
     (# exit BCstate.fields.numLocals-1-BCstate.fields.numArguments #);
  
   emitSystemAssemblyReferences:
     (# 
     do '/* Assembly references. */\n'
        '.assembly extern mscorlib {}\n'
          ->out.puttext;
        (if use_betarun then
            '.assembly extern betarun {}\n'
              -> out.puttext;
        if);
        (if false then
            '// FIXME: hardcoded:\n'
            '.assembly extern System.Windows.Forms {\n'
            '  .publickeytoken = (B7 7A 5C 56 19 34 E0 89)\n'
            '  .ver 1:0:3300:0\n'
            '}\n'
              ->out.puttext;
        if)
     #);
   emitBETAAssemblyReferences:
     (# 
     do imports.scan
        (# e: @diskentry;
           assemblyname: ^text;
        do current[] -> e.path;
           e.path.name -> assemblyname[];
           (if assemblyname[] -> thisModuleName.equal then
               (*thisModuleName[]->emitcomment; out.newline *)
            else
               '.assembly extern ' -> out.puttext;
               assemblyname[] -> quote -> out.puttext;
               ' {\n'
               '  .ver 1:0:0:0\n'
               '}\n' -> out.puttext;
           if);
        #);
     #);
   
   emitFileReferences:
     (# 
     do '\n/* File references */\n'
          -> out.puttext;
        imports.scan
        (#
        do '.file ' -> out.puttext;
           current[] -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
                '.dll\n' -> out.puttext;
            if);
        #);
     #);

   emitModuleReferences:
     (# 
     do '/* Module references */\n'
          -> out.puttext;
        (if use_betarun then
            '.module extern betarun_v.dll' -> out.putline;
        if);
        imports.scan
        (#
        do (if use_modules then
                '.module extern ' -> out.puttext;
             else
                '.assembly extern ' -> out.puttext;
           if);
           current[] -> quote -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
               ' {}\n' -> out.puttext;
            if);
        #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about the assembly     */\n'
             '/********************************************/\n'
             '\n'
             '/* Assembly declaration. */\n'
             '.assembly \'%s\' {\n'
             '	.hash algorithm 32772	// selected algorithm is SHA1\n'
             '	.ver 1:0:0:0		// version 1.0\n'
             '}\n' 
               -> out.putFormat(# do thisModuleName[]->s #);
             '.module \'%s.dll\'\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do 
        emitAssemblyInfo;
        emitSystemAssemblyReferences;
        emitBETAAssemblyReferences;
     #);
   emitModuleHeader:
     (# emitModuleInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about this module      */\n'
             '/********************************************/\n'
             '\n'
             '/* Module declaration. */\n'
             '.module %s.netmodule\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do emitModuleInfo;
        emitSystemAssemblyReferences;
        emitModuleReferences;
        emitFileReferences;
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo, origVarNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same???
         *)
        varNo -> origVarNo;
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint;
        (if varNo<0 then
            'Negative location/argument number' -> fixme;
            origVarNo->('mem:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            (dumpstack, 'Negative memory offset') -> stop;
        if);
        (if 'ld'->op.equal then
            (* ldarg/ldloc *)
            1 -> stack_delta;
         else
            (* starg/stloc *)
            -1 -> stack_delta;
        if);

     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg:
     (#  exit BC.get #);
   pushCst:
     (# i: @integer;
     do 'ldc.i4'->out.puttext;
        INNER; (* get constant into i with correct sign *)
        (if true
         // (i=-1) then '.m1' -> out.puttext;
         // (0<=i) and (i<=8) then
            '.'->out.put; i->out.putint;
         // (-128<=i) and (i<=127) then
            '.s '->out.puttext; i->out.putint;
         else
            ' '->out.puttext; i->out.putint;
        if);
        (if (32<=i) and (i<=126) then
            ' // \'%c\'' -> out.putformat(# do THIS(pushCst).i->c #);
        if);
        1 -> stack_delta;
     #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        fieldName,descName,fieldType: ^text;
        get: 
          (# hasFieldName: @integer 
          do getReg->reg; 
             (if (BC.get -> hasFieldName) = 1 then
                    BC.gettext -> fieldName[]
             if);
             BC.get->off; 
             (if (off<12) and (off<>0) then
                 '\n*** Address.get: strange offset: '->screen.puttext;
                 off -> screen.putint; 
                 (if hasFieldName=1 then
                     '. Field name: '-> screen.puttext;
                     fieldname[] -> screen.puttext;
                 if);
                 screen.newline;
             if);
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
             else
                 none -> descName[]
             if);
             (if BC.get = 1 then
                 BC.getText -> fieldType[];
              else
                 none -> fieldType[];
             if)
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> quote -> out.putText; 1->_n;
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> quote -> out.puttext; 
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext; 2->_n;
              else
                 '::' -> out.puttext;
                 fieldName[]-> quote -> out.puttext;
                 ' ' -> out.put;
             if)
          #);
        emitType:
          (#
          do (if fieldType[] <> none then
                 fieldType[] -> out.puttext
              else
                 'int32' -> out.puttext;
                 'OBS! missing type info (fieldType)' -> emitcomment
             if);
             ' ' -> out.put;
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                         then
                         'ldelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal 
                      // 'char' -> fieldType.equal 
                         then
                         'ldelem.u2' -> out.puttext
                      else
                         'ldelem.i4' -> out.puttext;
                         'wrong fieldType: ' 
                           -> (fieldType.copy).prepend
                           -> emitcomment;
                     if)
                  else
                     'ldelem.i4' -> out.puttext;
                     'missing fieldType' -> emitcomment;
                 if);
                 -1 -> stack_delta (* pops object, field name; pushes field value *);
              else
                 (if ONlevel > 0 then
                     'ldfld\t' -> out.puttext; 1->_n;
                     emitType;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *);
                  else
                     (if isField=1 then
                         'ldfld\t' -> out.puttext; 2->_n;
                         emitType;
                         emitField; 
                         0 -> stack_delta (* pops object; pushes field value *);
                      else
                         (* method field (local variable/argument?)*)
                         ('ld',off) -> emitMemOp; 
                     if);
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                         then
                         'stelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal
                      // 'char' -> fieldType.equal then
                         'stelem.i2' -> out.puttext (* no unsigned store *)
                      else
                         'stelem.i4' -> out.puttext;
                         'wrong fieldType: ' 
                           -> (fieldType.copy).prepend
                           -> emitcomment;
                     if);
                  else
                     'iastore' -> out.puttext;
                     'missing fieldType' -> emitcomment
                 if);
                 -2 -> stack_delta (* pops object, field name; *)
              else
                 (if ONlevel > 0 then
                     'stfld\t' -> out.puttext; 2->_n;
                     emitType;
                     emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     (if isField=1 then
                         'stfld\t' -> out.puttext; 3->_n;
                         emitType;
                         emitField;
                         -2 -> stack_delta (* pops object, field name; *)
                      else
                         ('st',off) -> emitMemOp; 
                     if)
                 if);
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; sig: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> sig[];
             (if withQua then
                 'castclass\t' -> out.puttext;
                 sig[] -> out.puttext;
                 '\n\t'->out.puttext;
                 (* stack neutral *)
             if);
             (if ONlevel > 0 then
                 'stfld\t' -> out.puttext; 4->_n;
                 (*emittype; *) sig[]->AddClass->out.puttext; ' '->out.put;
                 isOrigin -> emitField;
                 -2 -> stack_delta (* pops object, field name; *)
              else           
                 (if isField = 1 then
                     'stfld\t' -> out.puttext; 5->_n;
                     (*emittype;*) sig[]->AddClass->out.puttext; ' '->out.put;
                     isOrigin -> emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     ('st',off) -> emitMemOp;  
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 'ldfld\t' -> out.puttext; 3->_n;
                 (*emittype;*) sig[]->AddClass->out.puttext; ' ' -> out.put;
                 emitField;
                 0 -> stack_delta (* pops object; pushes field value *)
              else 
                 (if isField = 1 then
                     'ldfld\t' -> out.puttext; 4->_n;
                     (*emittype;*)sig[]->AddClass->out.puttext;' ' -> out.put;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *)
                  else
                     ('ld',off) -> emitMemOp;  
                 if);
             if); 
             (if withQua then
                 '\n\tcastclass\t' -> out.puttext;
                 BC.gettext -> sig[]; 
                 sig[] -> out.puttext;
                 (* stack nutral *)
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0' -> out.puttext; 3->_n;
                     1 -> stack_delta;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.putline;
                 load
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   emitLocals:
     (#
     do (if not compute_stack_height then
            '\t.maxstack 1000\n' -> out.puttext;                        
        if);
     #);
   emitCmpJmp:
     (* Compare two top elements and jump conditionally *)
     (# cond,L,lab,isRef: @integer (* oLM: isRef=1: reference cmp *)
     enter(cond,L,lab,isRef)
     do (if trace_compares then
            'emitCmpJmp' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        -2 -> stack_delta;
        lab -> labs.use;
     #);
   emitCmpToBool:
     (* Compare two top elements and push result *)
     (# cond: @integer
     enter cond
     do (if trace_compares then
            'emitCmpToBool' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'ceq' -> out.puttext;
         // 2 (* <> *) then
            'ceq\n'
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
         // 3 (* <  *) then
            'clt' -> out.puttext 
         // 4 (* <= *) then
            'cgt\n'
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
         // 5 (* >  *) then
            'cgt' -> out.puttext 
         // 6 (* >= *) then
            'clt\n' 
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
        if);
        -1 -> stack_delta;
     #);
   emitCmpBoolJmp:
     (* Compare top with 0 and jump conditionally *)
     (# cond,L,lab: @integer
     enter (cond,L,lab)
     do (if trace_compares then
            'emitCmpBoolJmp' -> emitcomment;
        if);
        'ldc.i4.0\n\t' -> out.puttext;
        1 -> stack_delta;
        (cond->reversecond,L,lab,0) -> emitCmpJmp;
     #);
   
   newArray:
     (# type: ^text
     enter type[]
     do '\tnewarr ' -> out.puttext; type[] -> out.puttext;
        0 -> stack_delta;
     #);
   
   opCode, arg1: @integer;
   A: @Address;
   T: ^text;
   
do init;
   read:
     (if opCode <> end then
         BC.get->opCode; 
         (if trace_opcodes then
             '/* %d */\n' -> out.putformat(# do opCode -> d #);
         if);
         (if opCode
          // classDef then
             false -> isMainMethod;
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '/********************************************/\n'
             '/*       Class: %22s      */\n'
             '/********************************************/\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi ' -> out.puttext;
             thisClassName[] -> quote -> out.putText;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> RemoveClass -> out.puttext;
             '{' -> out.putline;
             'object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             (if not ('-'->thisOrgName.equal) then
                 '  .field public ' -> out.puttext;
                 thisOrgName[] -> AddClass -> out.puttext;
                 ' origin'-> out.putline;
             if);
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
             BCstate.fields.init;
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do (* labs.clear; *)
                BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                BC.get -> aux;
                (if 'main' -> thisInnerMethodName.equal then
                    'static void \'main\'(string[] args)' -> thisSignature[];
                    '\n  .method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] -> out.puttext;
                    ' cil managed\n  {' -> out.putline;
                    (if use_modules then
                        (* entrypoint defined by al.exe *)
                     else
                        (if common.switch[6] then
                            'NOT generating .entrypoint (nbeta -x)'->putline;
                         else
                            '\t.entrypoint' -> out.putline;
                        if)
                    if);
                    true -> isMainMethod
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        '\n  .method public virtual void ' -> out.puttext;
                        0 -> stack_height -> max_stack_height;
                        thisInnerMethodName[]
                          -> quote 
                          (* -> thisSignature[] *)
                          -> out.puttext;
                        '() cil managed\n  {\n'
                        '\tret\n'
                        '  }\n' -> out.puttext;
                    if);
                    '\n  .method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] 
                      -> AddClass(# nonstatic::(# do 'virtual '->out.puttext #)#)
                      -> out.puttext; (* AddClass fixes return type, but not arguments *)
                    ' cil managed \n  {' -> out.putline
                if);    
                emitLocals;
             #);
          // initCons then
             'rtspecialname specialname hidebysig instance void .ctor('
               -> thisSignature[];
             (if not ('-' -> thisOrgname.equal) then
                 thisOrgName[] (*-> AddClass*) -> thisSignature.puttext;
             if);
             ')' -> thisSignature.put;
             '  /* instance constructor */\n'
             '  .method public ' -> out.puttext;
             0 -> stack_height -> max_stack_height;
             thisSignature[] -> out.puttext;
             '\n  {' -> out.putline;
          // field then
             (# F: @text
             do 'F' -> F; BC.get->F.putInt;
                (if BC.get = 1 then
                    (F[],BC.gettext,BC.gettext,BC.get) 
                      -> BCstate.fields.new
                 else
                    (F[],'???',BC.gettext,BC.get) 
                    -> BCstate.fields.new;
                if)
             #)
          // labelDef then
             BC.get -> labs.def;
          // callPrim then
             (# prim,arg: ^text;
                delta: @integer;
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if true 
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (* Rest is done in subsequent init *)
                 // 'initSuper' -> prim.equal then
                    '\tcall\tinstance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if ('-'->arg.equal) then
                        (* no arguments *)
                        -1 -> delta;
                     else
                        arg[] -> AddClass -> out.puttext;
                        -2 -> delta;
                    if);
                    ')' -> out.puttext;
                    delta -> stack_delta;
                    out.newline;
                    BCstate.fields.emitInit
                 // 'init' -> prim.equal then
                    (# ctor_signature: ^text;
                    do 'void ' -> ctor_signature[];
                       class[] (* class name *) -> AddClass -> ctor_signature.puttext;
                       '::.ctor(' -> ctor_signature.puttext;
                       (if ('-'->arg.equal) then
                           (* no arguments *)
                        else
                           arg[] (* origin name *) -> AddClass -> ctor_signature.puttext;
                       if);
                       ')' -> ctor_signature.puttext;
                       '\tnewobj\tinstance '-> out.puttext;
                       ctor_signature[] -> out.puttext;
                       1+(ctor_signature[]->function_stack_delta) -> stack_delta
                    #);
                 // 'AlloVR4' -> prim.equal then
                    'int32' -> newArray
                 // 'AlloVR1' -> prim.equal then
                    'char' -> newArray  
                 // 'Text2CharArray' -> prim.equal then
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'Text2CharArray:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                 // 'CharArray2String' -> prim.equal then
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'CharArray2String:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'newobj [mscorlib]System.String(char[])' -> out.puttext;
                    0 -> stack_delta;
                 // 'ExternalString2BetaText' -> prim.equal then
                    (* Note! Hardcoding of pattern 'text'
                     * including case, etc. Should be handled
                     * more generally
                     *)
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'ExternalString2BetaText:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                    '\n\t' -> out.puttext;
                    'char []' -> allocLocal -> storeLocal;
                    '\tldnull' -> out.puttext;
                    1 -> stack_delta;
                    '\n\tnewobj\tinstance void class [tstenv]text::.ctor(class [tstenv]tstenv)' -> out.puttext;
                    0 -> stack_delta;
                    '\n\tdup' -> out.puttext;
                    1 -> stack_delta;
                    out.newline;
                    numLocals -> loadLocal;
                    numLocals -> releaseLocal;
                    '\tcallvirt instance void class [tstenv]text::\'enter\'(char[])'
                      -> out.puttext;
                    -2 -> stack_delta;
                 // 'BetaText2ExternalString' -> prim.equal then
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'BetaText2ExternalString:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'ldfld\tchar[] [\'tstenv\']text::T' -> out.puttext;
                    '\n\tnewobj\tinstance void class [mscorlib]System.String::.ctor(char[])' -> out.puttext;
                    0 -> stack_delta;
                 // 'Att' -> prim.equal then
                    'missing call of attach here' -> emitcomment;
                    'we pop the stack to avoid overflow' -> emitcomment;
                    '\tpop' -> out.puttext;
                    -1 -> stack_delta;
                 else
                    'Primitive NYI: ' -> (prim[] -> ('(' -> (')' -> (arg.copy).append).prepend).prepend).prepend -> fixme;
                if);
             #);
             out.newline;
          // callExternal then
             (# prim: ^text
             do BC.getText -> prim[];
                '\tcall\t' -> out.puttext;  
                prim[] -> out.puttext;
                out.newline;
                prim[] -> function_stack_delta -> stack_delta;
             #)
          // callInner then
             '\tldarg.0' -> out.puttext; 4->_n; out.newline;
             '\tcallvirt ' -> out.puttext;
             (* NOT in accordance with design - FIX *)
             'instance void ' -> out.puttext;
             thisClassName[] -> out.puttext;
             '::'->out.puttext;
             thisInnerMethodName[]->out.puttext;
             '()'->out.puttext;
             0 -> stack_delta;
             out.newline;
          // comment then
             (# T: ^text
             do BC.gettext -> T[];
                (if trace_comments then
                    '\t/* ' -> out.puttext; 
                    (*T[] -> putline;*) T[] -> out.puttext;
                    ' */ ' -> out.putline;
                if)
             #)
          // position then
             BC.getShort -> line;
             (if generateLineNumbers then
                 '\t.line\t' -> out.puttext; 
                 line -> betafile.pc.posToLineCol -> (line, column);
                 line -> out.putint;
                 ':' -> out.put;
                 column+1 -> out.putint;
                 ' ' -> out.puttext;
                 betafilename[] -> quote -> out.puttext;
                 '' -> out.putline;
             if);
          else
             (* Opcodes all needing a tab for indentation *)
             '\t' -> out.put; 
             (if opCode
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 A.get; A.loadRef
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,ctag,ftag: @integer; 
                    className, fieldType: ^text;
                 do BC.get -> ONlevel;
                    BC.get -> ctag;
                    (if ctag = 1 then
                        BC.getText -> className[]
                    if);
                    BC.get -> ftag;
                    (if ftag = 1 then
                        BC.gettext -> fieldType[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                        1 -> stack_delta;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0' -> out.puttext; 1->_n;
                            1 -> stack_delta;
                         else
                            'ldfld\t' -> out.puttext; 5->_n;
                            (if ftag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> out.puttext; 
                             else
                                fieldType[] -> AddClass -> out.puttext
                            if);
                            ' ' ->out.put;
                            (if ctag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.class
                                  -> quote 
                                  -> out.puttext
                             else
                                className[] -> quote -> AddClass -> out.puttext
                            if);
                            '::origin ' -> out.puttext; 3->_n;
                            0 -> stack_delta;
                        if);
                    if)
                 #)
              // call then 
                 (# calltype: @integer;
                    delta: @integer;
                 do BC.get -> calltype;
                    BC.getText->T[];
                    (*'// call: ' -> out.puttext; T[]->out.putline;*)
                    T[] -> function_stack_delta -> delta;
                    (if calltype = 1 then
                        'call' -> out.puttext 
                     else
                        'callvirt' -> out.puttext;
                    if);
                    ' '->out.put;
                    2->_n;
                    T[] -> AddClass(# static::(# do true->omitstatic; #);
                                      nonstatic::(# do 'instance '->out.puttext; delta-1->delta #)
                                   #) ->out.puttext;
                    delta -> stack_delta;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 #)
              // return then
                 (if BC.get 
                  // 0 then 
                     0 -> check_stack_height;
                     'ret' -> out.puttext;
                     0 -> stack_delta;
                  // 1
                  // 2 then
                     1 -> check_stack_height;
                     'ret' -> out.puttext;
                     -1 -> stack_delta;
                  else (* error *) 
                     'xreturn' -> FIXME;
                 if);
                 '\n'->out.puttext;
                 (if compute_stack_height then
                     '\t.maxstack ' -> out.puttext;
                     max_stack_height -> out.putint;
                 if);
                 '\n  }'->out.puttext
              // cmpToBool then
                 (if trace_compares then
                     'cmpToBool' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpToBoolRef then
                 (if trace_compares then
                     'cmpToBoolRef' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpAndJmp then
                 (if trace_compares then
                     'cmpAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.get,BC.get) -> emitCmpJmp  
              // cmpBoolAndJmp then
                 (if trace_compares then
                     'cmpBoolAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.get) -> emitCmpBoolJmp
              // pushCst_s8 then
                 pushCst(# c: @int8 (* CAREFULL: char is unsigned! *);
                        do BC.get->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s16 then
                 pushCst(# c: @int16;
                        do BC.getshort->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s32 then
                 pushCst(# 
                        do BC.getlong->i;
                        #);
              // pushVal then
                 'pushVal'->out.puttext
              // pushNone then
                 'ldnull' -> out.puttext;
                 1 -> stack_delta;
              // dup then
                 BC.get -> arg1;
                 'dup' -> out.puttext;
                 1 -> stack_delta;
                 (if arg1 > 0 then 
                     'IL has no dup_x1/dup_x2 instructions' -> FIXME;
                 if)     
              // pop then
                 'pop' -> out.puttext;
                 -1 -> stack_delta;
              // allocAndStoreLocal then
                 BC.getText -> allocLocal -> storeLocal;
              // _loadLocal then
                 numLocals -> loadLocal;
              // loadRange then 
                 'ldlen' -> out.puttext;
                 0 -> stack_delta;
              // pushReg then
                 '// pushReg '->out.puttext;
                 dumpReg
              // stVal then
                 'stVal'->out.puttext
              // index then
                 'index'->out.puttext
              // cmpAndJmp then
                 'cmpAndJmp'->out.puttext
              // newVirt then 
                 'newVirt' ->out.puttext
              // label then
                 'opcode label' -> fixme;
              // callPrim then
                 'callPrim'->out.puttext
              // endclass then
                 '\n}' -> out.putline;
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' "'->out.puttext; BC.getText->out.puttext; '"'->out.put;
                 1 -> stack_delta;
              // jmp then
                 'br'->out.puttext;
                 BC.get (* opcode label *); 
                 BC.get -> labs.use;
                 0 -> stack_delta;
              // cmp then
                 'cmp'->out.puttext
              // nop then
                 'nop'->out.puttext;
              // func then
                 (# f: @integer;
                    delta: @integer;
                 do BC.get->f;
                    (if f
                     // add then
                        'add'->out.puttext; 1->_n;
                        -1 -> delta;
                     // sub then
                        'sub'->out.puttext;
                        -1 -> delta;
                     // orr then
                        'or'->out.puttext;
                        -1 -> delta;
                     // andd then
                        'and'->out.puttext;
                        -1 -> delta;
                     // xorr then
                        'xor'->out.puttext;
                        -1 -> delta;
                     // nott then
                        (* boolean not *)
                        '\tldc.i4.0\n' -> out.putline;
                        '\tceq' -> out.puttext;
                        0 -> delta;
                        out.newline;
                     // mult then
                        'mul'->out.puttext;
                        -1 -> delta;
                     // divv then
                        'div'->out.puttext;
                        -1 -> delta;
                     // modd then
                        -1 -> delta;
                        'rem'->out.puttext;
                     // logNot then
                        (* bit not *)
                        'not'->out.puttext;
                        0 -> delta;
                     // neg then
                        'neg'->out.puttext;
                        0 -> delta;
                     // logicalShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // arithShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // logicalShiftRight then 
                        'shr.un'->out.puttext;
                        -1 -> delta;
                     // arithShiftRight then 
                        'shr'->out.puttext;
                        -1 -> delta;
                     // rotateLeft then
                        (* Perform i %rol r *)
                        (* Implemented as:
                         *   (i << r) | ((i & ((1<<r)-1)) >> (32-r))
                         *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           '\t' -> out.put;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           '\tshl' -> out.putline;
                           loc_i -> loadLocal;
                           '\tldc.i4.1' -> out.putline;
                           loc_r -> loadLocal;
                           '\tshl' -> out.putline;
                           'ldc.i4.1' -> out.putline;
                           '\tsub' -> out.putline;
                           '\tand' -> out.putline;
                           'ldc.i4.s   32' -> out.putline;
                           loc_r -> loadLocal;
                           '\tsub' -> out.putline;
                           '\tshr' -> out.putline;
                           '\tor' -> out.putline;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #)
                     // rotateRight then
                        (* Perform i %ror r *)
                        (* Implemented as:
                         *   (i >> r) | ((i & ((1<<r)-1)) << (32-r))
                         *)
                        (* initial stack: r, i *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           '\t' -> out.put;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           '\tshr' -> out.putline;
                           loc_i -> loadLocal;
                           '\tldc.i4.1' -> out.putline;
                           loc_r -> loadLocal;
                           '\tshl' -> out.putline;
                           '\tldc.i4.1' -> out.putline;
                           '\tand' -> out.putline;
                           '\tsub' -> out.putline;
                           '\tldc.i4.s   32' -> out.putline;
                           loc_r -> loadLocal;
                           '\tsub' -> out.putline;
                           '\tshl' -> out.putline;
                           '\tor' -> out.putline;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #);
                     else
                        (# msg: ^text;
                        do 'Unhandled bytecode func.' -> msg[];
                           f -> asText -> msg.append;
                           ' ('->msg.append;
                           f->msg.putint;
                           ')' -> msg.put;
                           msg[] -> fixme;
                        #);
                    if);
                    delta -> stack_delta;
                    99->_n;
                    out.newline;
                 #)
              else
                 (# msg: ^text;
                 do 'Unhandled bytecode ' -> msg[];
                    opcode -> asText -> msg.append;
                    ' ('->msg.append;
                    opcode->msg.putint;
                    ')' -> msg.put;
                    msg[] -> fixme;
                 #);
             if);
             out.newline;
         if);
         (opcode = jmp)  -> previousWasJmp;
         restart read;
     if);
   out.close
#)  
