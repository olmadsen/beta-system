ORIGIN 'BCmachineBody'; INCLUDE '~beta/basiclib/formatio'; INCLUDE
'~beta/basiclib/pcre'; INCLUDE '~beta/toollibs/utils/fileExtensions';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit false #);
trace_class:
  (# exit false #);
trace_mem:
  (# exit false #);
trace_sig:
  (# exit false #);
comment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
emitcomment: (# enter comment #);
fixme: comment
  (# 
  do 'FIXME:' -> out.puttext;
  #);
ConvertFromJavaType:
  (# T: ^text;
     type: ^text;
  enter T[]
  do (if true 
      // 'I' -> T.equal then
         'int32/*FIXME:ConvertFromJavaType*/' -> type[];
      // '[mscorlib]System.Object' -> T.equal then
         '' -> type[];
         INNER;
         '[mscorlib]System.Object' -> type.append;
      else
         '' -> type[];
         INNER;
         (if not common.switch[184] then
             '[.module ' -> type.puttext;
             (*BCstate.thisModulename[]*) T.copy -> type.puttext;
             '.dll' -> type.puttext;
             ']' -> type.puttext;
         if);
         T.copy -> type.puttext;
         type[] -> T[];
     if)
  exit type[]
  #);
ClassConvertFromJavaType: ConvertFromJavaType
  (# 
  do (if trace_class then
         'class/*ClassConvertFromJavaType*/ ' -> type.puttext;
      else
         'class ' -> type.puttext;
     if);
  #);
ReplaceJavaSlash:
  (# regexp: @pcre;
     ok: @boolean;
     T: ^text;
  enter T[]
  do (if trace_sig then
         'ReplaceJavaSlash:'->(T.copy).prepend -> emitcomment;
     if);
     '^(\\w+)/([^\']*) (.*)$' -> regexp;
     (T[], '') -> regExp.replace
     (# rep::
          (# 
          do (if not common.switch[184] then
                 '[.module ' -> value[];
                 sub1->value.puttext;
                 '.dll]' -> value.puttext;
             if);
             sub2->value.puttext; (* return-type *)
             ' '->value.put;
             sub1->value.puttext; (* class *)
             '::' -> value.puttext;
             sub3->value.puttext;
             (if false then
                 '/*$1=%s$2=%s$3=%s*/' 
                   -> value.putformat(# do sub1->s; sub2->s; sub3->s #);
             if);
          #)
     #) -> (ok,T[]);
  exit T[]
  #);

--FieldsNewDotnet:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       '  .field public '->out.puttext;
       T[] -> ClassConvertFromJavaType -> out.puttext;
       ' ' -> out.puttext; F[] -> out.putline;
    // 'm' then
       (if numLocals>=numArguments then
           (if numLocals>numArguments then 
               ',\n\t\t\t' -> out.puttext 
            else 
               '\t.locals init   (' -> out.puttext;
           if);
           '[' -> out.puttext;
           numLocals-numArguments -> out.putint;
           '] ' -> out.puttext;
           T[] -> ClassConvertFromJavaType -> out.puttext;
           ' V_' -> out.puttext;
           numLocals-numArguments -> out.putint;
       if);
       numLocals+1 -> numLocals;
    // 'M' then
       (* end method locals *)
       (if numLocals>numArguments then
           ')\n' -> out.puttext;
       if);
    // 'C' then
       (* end class fields *)
       '\n' -> out.puttext;
    else
       'FieldsNewDotnet: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemDotnet:descriptor--
(# 
do '\tldarg.0\n' -> out.puttext;
   (if 'I' -> currentType.equal then
       '\tldc.i4.0\n' -> out.puttext;
    else
       '\tldnull \n' -> out.puttext
   if);
   '\tstfld\t' -> out.puttext;
   currentType[] -> ClassConvertFromJavaType -> out.puttext;
   ' ' -> out.puttext;
   thisClassName[] -> out.puttext;
   '::' -> out.puttext;
   currentField[] -> out.putline;
#)

-- emitdotNet: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName
   ,thisExeName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   isMainModule: @boolean; (* true if generating code for module containing main method *)
   init:
     (# 
     do 
        '/*FIXME*/Main' -> thisExeName[]; (* FIXME *)
        out.entry.path.name -> thisModuleName[];
        '.il' -> thisModuleName.stripExtension;
        thisModuleName.copy -> BCstate.thisModuleName[];
        'Main' -> thisModuleName.equal -> isMainModule;
        (if isMainModule or common.switch[184] then
            emitAssemblyHeader;
         else
            emitModuleHeader;
        if);
     #);
   swap:
     (# st0, st1: ^text;
     enter (st0[], st1[])
     do '/* swap */\n'
        '\t.locals init ([%d] %s,\n'
        '\t              [%d] %s)\n'
        '\tstloc.%d\n'
        '\tstloc.%d\n'
        '\tldloc.%d\n'
        '\tldloc.%d\n' 
          -> out.putformat(# num: @integer;
                          do BCstate.fields.numLocals 
                             - BCstate.fields.numArguments -> num;
                             (if st0[]<>NONE then
                                 st0[] -> s;
                              else
                                 '/*FIXME:*/int32' -> s;
                             if);
                             BCstate.fields.numLocals+1->d;
                             (if st1[]<>NONE then
                                 st1[] -> s;
                              else
                                 '/*FIXME:*/int32' -> s;
                             if);
                             num  ->d;
                             num+1->d;
                             num  ->d;
                             num+1->d;
                             BCstate.fields.numLocals+2 
                               -> BCstate.fields.numLocals;
                          #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about the assembly     */\n'
             '/********************************************/\n'
             '\n'
             '/* The assembly declaration. */\n'
             '.assembly %s {\n'
             '	.hash algorithm 32772	// selected algorithm is SHA1\n'
             '	.ver 1:0:0:0		// version 1.0\n'
             '}\n\n' 
               -> out.putFormat(# do thisExeName[]->s #);
          #);
        emitAssemblyReferences:
          (# 
          do '/* The assembly references. */\n'
             '.assembly extern mscorlib {\n'
             '}\n'
               ->out.puttext;
             '.assembly extern System.Windows.Forms {\n'
             '  .publickeytoken = (B7 7A 5C 56 19 34 E0 89)\n'
             '  .ver 1:0:3300:0\n'
             '}\n'
               ->out.puttext;
             out.newline;
          #);
        
        emitFileReferences:
          (# 
          do '/* Files referenced by the assembly, all DLLs need to appear here.\n'
             ' * All references by modules need to be listed here, too.\n'
             ' */\n'
               -> out.puttext;
             '// FIXME: hardcoded:\n'
             '//.file Bmini0.dll\n'
               -> out.puttext;
             out.newline;
          #);

        emitModuleDeclaration:
          (# 
          do '/********************************************/\n'
             '/*       Information about this module      */\n'
             '/********************************************/\n'
             '\n'
             '/* The module declaration. */\n'
             '.module %s.exe\n\n'
               ->  out.putFormat(# do thisExeName[]->s #);
          #);
        
        emitModuleReferences:
          (# 
          do '/* The module references.\n'
             ' * All these modules become part of this assembly.\n'
             ' */\n'
               -> out.puttext;
             '// FIXME: hardcoded:\n'
             '//.module extern Bmini0.dll\n'
               -> out.puttext;
          #);
     do 
        emitAssemblyInfo;
        emitAssemblyReferences;
        emitFileReferences;
        emitModuleDeclaration;
        emitModuleReferences;
     #);
   emitModuleHeader:
     (# 
     do '/* This module does not declare an assembly.\n'
        ' * As a consequence, it must be referenced by another assembly to\n'
        ' * be usable. This module does not have an entrypoint\n'
        ' */\n'
        '\n'
        '/********************************************/\n'
        '/*       Information about this module      */\n'
        '/********************************************/\n'
        '\n'
        '/* Module declaration, compiles into a dll. */\n'
        '.module %s.dll\n'
        '\n'
        '/* The assembly references. */\n'
        '.assembly extern mscorlib {\n'
        '  .publickeytoken = (03 68 91 16 D3 A4 AE 33)\n'
        '}\n\n' -> out.putFormat(# do thisModuleName[]->s #);
        
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same???
         *)
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint               
     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg: (#  exit BC.get #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        descName: ^text;
        get: 
          (#  
          do getReg->reg; 
             BC.get->off; 
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
             if);
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> out.putText
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> out.puttext;
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext
              else
                 '::F' -> out.puttext;  
                 off -> out.putint;
                 ' ' -> out.put;
             if)
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if ONlevel > 0 then
                 'ldfld\t' -> out.puttext;
                 'int32 ' -> out.puttext;
                 emitField;
              else
                 (if isField=1 then
                     'ldfld\t' -> out.puttext;
                     'int32 ' -> out.puttext;
                     emitField; 
                  else
                     (* method field (local variable/argument?)*)
                     ('ld',off) -> emitMemOp;
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if ONlevel > 0 then
                 (*(NONE, 'int32') -> swap;*)
                 'stfld\t' -> out.puttext;
                 'int32 ' -> out.puttext;
                 emitField;
              else
                 (if isField=1 then
                     (*(NONE, 'int32') -> swap;*)
                     'stfld\t' -> out.puttext;
                     'int32 ' -> out.puttext;
                     emitField;
                  else
                     ('st',off) -> emitMemOp
                 if)
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; class: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> class[];
             (if withQua then
                 'castclass\t' -> out.puttext;
                 class[] -> out.puttext;
                 '\n\t'->out.puttext
             if);
             (if ONlevel > 0 then
                 (*(NONE, class[]) -> swap;*)
                 'stfld\t' -> out.puttext;
                 class[] -> emitSignature;
                 ' '->out.put;
                 isOrigin -> emitField;
              else           
                 (if isField = 1 then
                     'stfld\t' -> out.puttext;
                     class[] -> emitSignature;
                     ' '->out.put;
                     isOrigin -> emitField;
                  else
                     ('st',off) -> emitMemOp
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 'ldfld\t' -> out.puttext;
                 sig[] -> emitSignature;
                 ' '->out.put;
                 emitField;
              else 
                 (if isField = 1 then
                     'ldfld\t' -> out.puttext;
                     class[] -> emitSignature;
                     ' '->out.put;
                     emitField;
                  else
                     ('ld',off) -> emitMemOp
                 if);
             if); 
             (if withQua then
                 sig[] -> puttext;
                 '\n\tcastclass\t' -> out.puttext;
                 BC.gettext -> sig[]; 
                 sig[] -> out.puttext
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0' -> out.puttext;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.puttext
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   emitLocals:
     (#
     do '\t.maxstack 8\n' -> out.puttext;                        
     #);
   emitSignature:
     (# sig: ^text
     enter sig[]
     do (if false then 'emitsignature' -> emitcomment; if);
        (if (sig[]=NONE) or (sig.length=0) then
            'class [mscorlib]System.Object' -> out.puttext;
         else
            'class ' -> out.puttext;
            sig[] -> out.puttext; 
        if);
     #);
   emitCmpJmp:
     (# cond,L,lab: @integer
     enter(cond,L,lab)
     do (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        '\tL'->out.puttext;
        lab -> out.putint
     #);
   opCode: @integer;
   A: @Address;
   T: ^text
do init;
   read:
     (if opCode <> end then
         BC.get->opCode; 
         (if trace_opcodes then
             '/* %d */\n' -> out.putformat(# do opCode -> d #);
         if);
         (if opCode
          // classDef then
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '/********************************************/\n'
             '/*        Class %22s      */\n'
             '/********************************************/\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi \'' -> out.puttext;
             thisClassName[] -> out.putText;
             '\'' -> out.puttext;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> out.puttext;
             '{' -> out.putline;
             'class [mscorlib]System.Object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             '  .field public class ' -> out.puttext;
             thisOrgName[] -> out.puttext;
             ' origin'-> out.putline;
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
             BCstate.fields.init;
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                BC.get -> aux;
                (if 'main' -> thisInnerMethodName.equal then
                    '\n  .method public static void \'main\'() cil managed\n  {' 
                      -> out.putline;
                    '\t.entrypoint' -> out.putline;
                    true -> isMainMethod
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        '\n  .method public virtual void \'' -> out.puttext;
                        thisInnerMethodName[]-> out.puttext;
                        '\'() cil managed\n  {\n'
                        '\tret\n'
                        '  }\n' -> out.puttext;
                    if);
                    '\n  .method public virtual ' -> out.puttext;
                    thisSignature[] -> out.puttext; 
                    ' cil managed \n  {' -> out.putline
                if);    
                emitLocals;
             #);
          // initCons then
             '  /* instance constructor */\n'
             '  .method public rtspecialname specialname hidebysig instance void .ctor('
               -> out.puttext;
             (if thisOrgname[]<>NONE then
                 'class ' -> out.puttext;
                 thisOrgName[] -> out.puttext;
             if);
             ')\n  {' -> out.putline;
             (if false then (* not callprim.initsuper *)
                 '\tldarg.0\n' -> out.puttext;
                 (if subLevel > 0 then
                     '\tldarg.1\n' -> out.puttext
                 if);
                 '\tcall\tinstance void '->out.puttext;
                 thisSuperName[] -> out.puttext;
                 '::.ctor(' -> out.puttext;
                 (if subLevel > 0 then
                     thisSuperOrgName[] -> out.puttext;
                 if);
                 ')\n' -> out.puttext;
                 (* initialize origin *)
                 '\tldarg.0\n'
                 '\tldarg.1\n'
                 '\tstfld\tclass ' -> out.puttext;
                 thisOrgName[] -> out.puttext;
                 ' '-> out.put;
                 thisClassName[] -> out.puttext;
                 '::origin'->out.puttext;
                 out.newline;
                 BCstate.fields.emitInit
             if);
          // field then
             (# F: @text
             do 'F' -> F; BC.get->F.putInt;
                (F[], BC.gettext,BC.get) -> BCstate.fields.new
             #)
          // labelDef then
             '  L'->out.puttext; BC.get->out.putint; 
             ':'->out.putline;
          // callPrim then
             (# prim,arg: ^text
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if true 
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (* Rest is done in subsequent init *)
                 // 'initSuper' -> prim.equal then
                    '\tcall\tinstance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if not ('-'->arg.equal) then
                        arg[] -> emitSignature
                    if);
                    ')\n' -> out.puttext;
                    BCstate.fields.emitInit
                 // 'init' -> prim.equal then
                    '\tnewobj\tinstance void '-> out.puttext;
                    (if not common.switch[184] then
                        '[.module ' -> out.puttext;
                        arg[] (* class name*) -> out.puttext;
                        '.dll]' -> out.puttext;
                    if);
                    class[] (* class name *) -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if not ('-'->arg.equal) then
                        arg[] (* origin name *) -> emitsignature;
                    if);
                    ')' -> out.puttext;
                if);
             #);
             out.newline;
          // callExternal then
             (# prim: ^text
             do BC.getText -> prim[];
                '\tcall\t' -> out.puttext;  
                (if true
                 // 'newline' -> prim.equalNCS then
                    'void [mscorlib]System.Console::WriteLine()' 
                      -> out.puttext
                 // 'put' -> prim.equalNCS then
                    'void [mscorlib]System.Console::Write(class System.String)' -> out.puttext
                 // 'puttext' -> prim.equalNCS then
                    'void [mscorlib]System.Console::Write(class System.String)' -> out.puttext
                 // 'putline' -> prim.equalNCS then
                    'void [mscorlib]System.Console::WriteLine(class System.String)' -> out.puttext
                 // 'putint' -> prim.equalNCS then 
                    'void [mscorlib]System.Console::Write(int32)' -> out.puttext
                 else
                    prim[] -> out.puttext
                if);
                out.newline;
             #)
          // callInner then
             '\tldarg.0\n'
             '\tcallvirt ' -> out.puttext;
             (* NOT in accordance with design - FIX *)
             'instance void ' -> out.puttext;
             thisClassName[] -> out.puttext;
             '::'->out.puttext;
             thisInnerMethodName[]->out.puttext;
             '()'->out.putline
          // comment then
             (# T: ^text
             do '\t/* ' -> out.puttext; BC.gettext -> T[];
                (*T[] -> putline;*) T[] -> out.puttext;
                ' */ ' -> out.putline;
             #)
          // func then
             (*'FUNC'->out.puttext;*)
             (*BC.get->asText->out.puttext;*)
          else
             '\t' -> out.put; 
             (if opCode
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 A.get; A.loadRef
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,tag: @integer; className: ^text (*olm*)
                 do BC.get -> ONlevel;
                    BC.get -> tag;
                    (if tag = 1 then
                        BC.getText -> className[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0' -> out.puttext;
                         else
                            'ldfld\t' -> out.puttext;
                            (if tag = 1 then
                                className[] -> emitSignature
                             else
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> emitSignature; (*'orgclass'->emitcomment;*)
                            if);
                            ' ' ->out.put;
                            ONlevel 
                              -> BCstate.blocks.class 
                              -> out.puttext;
                            '::origin ' -> out.puttext;
                        if);
                    if)
                 #)
              // call then 
                 'callvirt ' -> out.puttext;
                 'instance '->out.puttext;
                 BC.getText->T[]->replaceJavaSlash->out.puttext;
                 313->trace(#do '%%%call: '->xT; T[]->xT #)
              // return then
                 (if BC.get 
                  // 0 
                  // 1
                  // 2
                     then 'ret' -> out.puttext
                  else (* error *) 
                     'xreturn' -> out.puttext
                 if);
                 '\n  }'->out.puttext
              // cmpAndJmp then
                 (BC.get,BC.get,BC.get) -> emitCmpJmp  
              // pushCst then
                 (# c: @int8 (* CAREFULL: char in *un*signed! *);
                    i: @integer;
                 do 'ldc.i4'->out.puttext;
                    BC.get->c;
                    c -> i (* sign extend *);
                    (if true
                     // (i=-1) then '.m1' -> out.puttext;
                     // (0<=i) and (i<=8) then
                        '.'->out.put; i->out.putint;
                     // (-128<=i) and (i<=127) then
                        '.s '->out.puttext; i->out.putint;
                     else
                        ' '->out.puttext; i->out.putint;
                    if);
                 #)
              // pushVal then
                 'pushVal'->out.puttext
              // pushReg then
                 'pushReg'->out.puttext;
                 dumpReg
              // stVal then
                 'stVal'->out.puttext
              // index then
                 'index'->out.puttext
              // cmpAndJmp then
                 'cmpAndJmp'->out.puttext
              // call then
                 'call\tinstance '->out.puttext
              // callInner then 'callInner' ->out.puttext
              // newVirt then 'newVirt' ->out.puttext
              // return then
                 'ret\n'->out.puttext
              // label then
                 'L'->out.puttext
              // callPrim then
                 'callPrim'->out.puttext
              // endclass then
                 '\n}' -> out.putline;
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' "'->out.puttext; BC.getText->out.puttext; '"'->out.put;
              // pushAdr then
                 'pushAdr'->out.puttext
              // loadRef then
                 'loadRef' ->out.puttext
              // storeRef then
                 'storeRef'->out.puttext
              // storeQref then
                 'storeQref'->out.puttext
              // dup then 'dup' ->out.puttext
              // jmp then
                 'br\t'->out.puttext;
                 (if BC.get
                  // label then 'L'->out.put;
                  else '?' -> out.put;
                 if);
                 BC.get->out.putint; 
              // add then
                 'add'->out.puttext
              // sub then
                 'sub'->out.puttext
              // orr then
                 'or'->out.puttext
              // andd then
                 'and'->out.puttext
              // xorr then
                 'xor'->out.puttext
              // cmp then
                 'cmp'->out.puttext
              // mult then
                 'mul'->out.puttext
              // divv then
                 'div'->out.puttext
              // modd then
                 'mod'->out.puttext
              // nott then
                 'not'->out.puttext
              // logNot then
                 'logNot'->out.puttext
              // neg then
                 'neg'->out.puttext
              // logicalShiftLeft then 
                 'shl'->out.puttext
              else
                 '<?'->out.puttext; opCode->out.putint; '?>'->out.puttext
             if);
             out.newline;
         if);
         restart read
     if);
   out.close
#)  
