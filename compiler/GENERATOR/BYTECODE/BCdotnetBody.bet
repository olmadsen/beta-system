ORIGIN 'BCmachineBody'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/basiclib/formatio'; 
INCLUDE '~beta/basiclib/pcre'; 
INCLUDE '~beta/basiclib/streamPosition'; 
INCLUDE '~beta/toollibs/utils/fileExtensions';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit false #);
trace_class:
  (# exit false #);
trace_convert:
  (# exit false #);
trace_mem:
  (# exit false #);
trace_sig:
  (# exit false #);
trace_n:
  (# exit false #);
trace_comments:
  (# exit false #);
trace_compares:
  (# exit false #);
trace_textop:
  (# exit false #);

use_reflection:
  (# exit false #);
use_betarun:
  (# exit false #);
use_modules:
  (# exit false #);
generateLineNumbers:
  (# exit common.switch[41] #);

reversecond:
  (# cond: @integer
  enter cond
  do (if cond
      // common.cond_lt then common.cond_gt -> cond
      // common.cond_le then common.cond_ge -> cond
      // common.cond_gt then common.cond_lt -> cond
      // common.cond_ge then common.cond_le -> cond
     if);
  exit cond
  #);

emitcomment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
_n:
  (# n: @integer;
  enter n
  do (if trace_n then
         ' /*'->out.puttext;
         n->out.putint;
         '*/'->out.puttext;
     if);
  #);
quote:
  (# T: ^text;
  enter T[]
  do (if T.lgth>0 then
         (if not (T.T[1]='\'') and (not (T.T[T.lgth]='\'')) then 
             T.copy -> T[];
             '\''->T.prepend;
             '\''->T.append; 
         if);
     if)
  exit T[]
  #);

FIXME: 
  (# T: ^text
  enter T[]
  do 'FIXME: ' -> (T.copy).prepend -> T[];
     '\n***** ' -> screen.puttext; T[] -> screen.putline;
     (*T[] -> emitcomment;*)
     '\n\tldstr "'->out.puttext; 
     T[]->out.puttext; 
     '"' -> out.putline;
     '\tcall void [mscorlib]System.Console::WriteLine(string)' -> out.puttext;
  #);
ConvertType:
  (# T: ^text
  enter T[]
  do (if trace_convert then
         '/*ConvertType('->out.puttext;
         T[]->out.puttext;
         ')*/' ->out.puttext;
     if);
     (if true 
      // T[]=NONE then
         (DumpStack, 'ConvertType: T[] is none') -> Stop;
      // 'I' -> T.equal then
         'int32 /*I*/' -> T[];
      // 'C' -> T.equal then
         'char /*C*/' -> T[];
      // '[I' -> T.equal then
         'int32[] /*I*/' -> T[];
      // '[C' -> T.equal then
         'char[] /*C*/' -> T[];
     if);
     INNER;
  exit T[]
  #);
RemoveClass:
  (# type: ^text
  enter type[]
  do (if 'class ' -> ((1,6)->type.sub).equal then
         (1,6) -> type.delete;
     if);
  exit type[]
  #);
     
AddClass: ConvertType
  (# isStatic: @boolean;
     location: ^text;
     static:< object;
     nonstatic:< object;
     omitstatic: @boolean;
  do (if 'static '  -> ((1,7)->T.sub).equal then
         true -> isStatic;
         (1,7)->T.delete;
         static;
      else
         nonstatic;
     if);
     (if true 
      // 'int32'   -> T.equal 
      // 'char'    -> T.equal 
      // 'void '   -> ((1,5)->T.sub).equal
      // 'int32 '  -> ((1,6)->T.sub).equal
      // 'char '   -> ((1,5)->T.sub).equal
      // 'char[]'  -> ((1,6)->T.sub).equal
      // 'int32[]' -> ((1,7)->T.sub).equal
         then
         (* nothing *)
      else
         (* Local reference. Add class keyword but no location *)
         (if trace_class then 'AddClass' -> emitcomment if);
         (if not ('class '  -> ((1,6)->T.sub).equal) then
             (*T[] -> quote -> T[];*)
             'class ' -> T.prepend;
         if)
     if);
     (if isStatic and (not omitstatic) then
         'static ' -> T.prepend;
     if);
  #);

--FieldsNewDotnet:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
       out.newline;
    // '[' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' [] ' -> out.puttext; 
       FN[] -> quote -> out.puttext;
       out.newline;
    // 'm' then
       (if numLocals>=numArguments then
           (if numLocals>numArguments then 
               ',\n\t\t\t' -> out.puttext 
            else 
               '\t.locals init   (' -> out.puttext;
           if);
           '[' -> out.puttext;
           numLocals-numArguments -> out.putint;
           '] ' -> out.puttext;
           T[] -> AddClass -> out.puttext;
           (if false then
               ' V_' -> out.puttext; 
               numLocals-numArguments -> out.putint;
            else
               ' '->out.put;
               FN[] -> out.puttext; (* local variable name *)
           if);
       if);
       numLocals+1 -> numLocals;
    // 'M' then
       (* end method locals *)
       (if numLocals>numArguments then
           ')\n' -> out.puttext;
       if);
    // 'C' then
       (* end class fields *)
       '\n' -> out.puttext;
    else
       'FieldsNewDotnet: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemDotnet:descriptor--
(# 
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       '\tldarg.0' -> out.puttext; 2->_n;
       out.newline;
       (if true
        // 'char' -> currentType.equal 
        // 'int32' -> currentType.equal 
        // 'C' -> currentType.equal 
        // 'I' -> currentType.equal then
           '\tldc.i4.0\n' -> out.puttext;
        else
           '\tldnull \n' -> out.puttext
       if);
       '\tstfld\t' -> out.puttext; 1->_n; 
       currentType[] -> ConvertType -> out.puttext;
       ' ' -> out.puttext;
       thisClassName[] -> out.puttext;
       '::' -> out.puttext;
       currentFieldName[] -> quote -> out.puttext;
       out.newline;
   if)
#)

-- emitdotNet: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   localLabNo: @integer; (* counter for local labels as generated by
                          * e.g. cmpToBool
                          *)
   
   betafile: @file(# pc: @positionConverter #);
   betafilename: ^text;
   line, column: @integer;
   init:
     (# BCmch: ^ByteCodeMachine;
     do out.entry.path.name -> thisModuleName[];
        (if generateLineNumbers then
            (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename[];
            '.bet' -> betafilename.append;
            betafilename[] -> betafile.name;
            betafile.openRead;
            betafile.pc.update;
            betafile.close;
        if);
        '.il' -> thisModuleName.stripExtension;
        thisModuleName.copy -> BCstate.thisModuleName[];
        (if use_betarun then
            emitModuleHeader;
         else
            emitAssemblyHeader;
        if);
     #);
   allocLocal:
     (# type: ^text;
     enter type[]
     do '\t.locals init ([%d] %s)\n'
          -> out.putformat(# num: @integer;
                          do BCstate.fields.numLocals 
                             - BCstate.fields.numArguments -> num;
                             num -> d;
                             type[] -> s
                          #);
        BCstate.fields.numLocals+1 -> BCstate.fields.numLocals;
     exit BCstate.fields.numLocals-1-BCstate.fields.numArguments
     #);
   releaseLocal:
     (# locNum: @integer
     enter locNum
     do (* Currently not used.
         * Could recycle locNum by remembering the index and the current type of that index.
         * A subsequent allocLocal could then reuse this local if it's the same type.
         *)
     #);
   opLocal:
     (# num: @integer
     enter num
     do '\t' -> out.puttext;
        INNER;
        'loc' -> out.puttext;
        (if true
         // num <= 3 
            then '.' -> out.put
         // num <= 255 
            then '.s ' -> out.puttext
         else
            ' ' -> out.put 
        if);
        num -> out.putint; out.newline;
     #);
   storeLocal: 
     opLocal(# do 'st' -> out.puttext; #);
   loadLocal: 
     opLocal(# do 'ld' -> out.puttext; #);
   numLocals:
     (# exit BCstate.fields.numLocals-1-BCstate.fields.numArguments #);
  
   emitSystemAssemblyReferences:
     (# 
     do '/* Assembly references. */\n'
        '.assembly extern mscorlib {}\n'
          ->out.puttext;
        (if use_betarun then
            '.assembly extern betarun {}\n'
              -> out.puttext;
        if);
        '// FIXME: hardcoded:\n'
        '.assembly extern System.Windows.Forms {\n'
        '  .publickeytoken = (B7 7A 5C 56 19 34 E0 89)\n'
        '  .ver 1:0:3300:0\n'
        '}\n'
          ->out.puttext;
     #);
   emitBETAAssemblyReferences:
     (# 
     do imports.scan
        (# e: @diskentry;
           assemblyname: ^text;
        do current[] -> e.path;
           e.path.name -> assemblyname[];
           (if assemblyname[] -> thisModuleName.equal then
               (*thisModuleName[]->emitcomment; out.newline *)
            else
               '.assembly extern ' -> out.puttext;
               assemblyname[] -> quote -> out.puttext;
               ' {\n'
               '  .ver 1:0:0:0\n'
               '}\n' -> out.puttext;
           if);
        #);
        (if false then
            '// FIXME: hardcoded:\n'
            '.assembly extern tstlib {}\n'
            '.assembly extern tstarith {}\n'
            '.assembly extern tstrelop {}\n'
            '.assembly extern tstbool {}\n'
            '.assembly extern tstblock {}\n'
            '.assembly extern tstvirt {}\n'
            '.assembly extern exe {}\n'
            '.assembly extern fill {}\n'
            '.assembly extern chk {}\n'
            '.assembly extern isPlatform {}\n'
            '.assembly extern tstenv {}\n'
              ->out.puttext;
        if);
     #);
   
   emitFileReferences:
     (# 
     do '\n/* File references */\n'
          -> out.puttext;
        imports.scan
        (#
        do '.file ' -> out.puttext;
           current[] -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
                '.dll\n' -> out.puttext;
            if);
        #);
     #);

   emitModuleReferences:
     (# 
     do '/* Module references */\n'
          -> out.puttext;
        (if use_betarun then
            '.module extern betarun_v.dll' -> out.putline;
        if);
        imports.scan
        (#
        do (if use_modules then
                '.module extern ' -> out.puttext;
             else
                '.assembly extern ' -> out.puttext;
           if);
           current[] -> quote -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
               ' {}\n' -> out.puttext;
            if);
        #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about the assembly     */\n'
             '/********************************************/\n'
             '\n'
             '/* Assembly declaration. */\n'
             '.assembly \'%s\' {\n'
             '	.hash algorithm 32772	// selected algorithm is SHA1\n'
             '	.ver 1:0:0:0		// version 1.0\n'
             '}\n' 
               -> out.putFormat(# do thisModuleName[]->s #);
             '.module \'%s.dll\'\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do 
        emitAssemblyInfo;
        emitSystemAssemblyReferences;
        emitBETAAssemblyReferences;
     #);
   emitModuleHeader:
     (# emitModuleInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about this module      */\n'
             '/********************************************/\n'
             '\n'
             '/* Module declaration. */\n'
             '.module %s.netmodule\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do emitModuleInfo;
        emitSystemAssemblyReferences;
        emitModuleReferences;
        emitFileReferences;
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo, origVarNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same???
         *)
        varNo -> origVarNo;
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint;
        (if varNo<0 then
            'Negative location/argument number' -> fixme;
            origVarNo->('mem:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            (dumpstack, 'Negative memory offset') -> stop;
        if)

     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg:
     (#  exit BC.get #);
   pushCst:
     (# i: @integer;
     do 'ldc.i4'->out.puttext;
        INNER; (* get constant into i with correct sign *)
        (if true
         // (i=-1) then '.m1' -> out.puttext;
         // (0<=i) and (i<=8) then
            '.'->out.put; i->out.putint;
         // (-128<=i) and (i<=127) then
            '.s '->out.puttext; i->out.putint;
         else
            ' '->out.puttext; i->out.putint;
        if);
        (if (32<=i) and (i<=126) then
            ' // \'%c\'' -> out.putformat(# do THIS(pushCst).i->c #);
        if);
     #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        fieldName,descName,fieldType: ^text;
        get: 
          (# hasFieldName: @integer 
          do getReg->reg; 
             (if (BC.get -> hasFieldName) = 1 then
                    BC.gettext -> fieldName[]
             if);
             BC.get->off; 
             (if (off<12) and (off<>0) then
                 '\n*** Address.get: strange offset: '->screen.puttext;
                 off -> screen.putint; 
                 (if hasFieldName=1 then
                     '. Field name: '-> screen.puttext;
                     fieldname[] -> screen.puttext;
                 if);
                 screen.newline;
             if);
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
             else
                 none -> descName[]
             if);
             (if BC.get = 1 then
                 BC.getText -> fieldType[];
              else
                 none -> fieldType[];
             if)
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> quote -> out.putText; 1->_n;
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> quote -> out.puttext; 
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext; 2->_n;
              else
                 '::' -> out.puttext;
                 fieldName[]-> quote -> out.puttext;
                 ' ' -> out.put;
             if)
          #);
        emitType:
          (#
          do (if fieldType[] <> none then
                 fieldType[] -> out.puttext
              else
                 'int32' -> out.puttext;
                 'OBS! missing type info (fieldType)' -> emitcomment
             if);
             ' ' -> out.put;
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'ldelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal 
                      // 'char' -> fieldType.equal 
                         then
                         'ldelem.u2' -> out.puttext
                      else
                         'ldelem.i4' -> out.puttext;
                         'wrong fieldType: ' 
                           -> (fieldType.copy).prepend
                           -> emitcomment;
                     if)
                  else
                     'ldelem.i4' -> out.puttext;
                     'missing fieldType' -> emitcomment;
                 if)
              else
                 (if ONlevel > 0 then
                     'ldfld\t' -> out.puttext; 1->_n;
                     emitType;
                     emitField;
                  else
                     (if isField=1 then
                         'ldfld\t' -> out.puttext; 2->_n;
                         emitType;
                         emitField; 
                      else
                         (* method field (local variable/argument?)*)
                         ('ld',off) -> emitMemOp; 
                     if);
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'stelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal
                      // 'char' -> fieldType.equal then
                         'stelem.i2' -> out.puttext (* no unsigned store *)
                      else
                         'stelem.i4' -> out.puttext;
                         'wrong fieldType: ' 
                           -> (fieldType.copy).prepend
                           -> emitcomment;
                     if)
                  else
                     'iastore' -> out.puttext;
                     'missing fieldType' -> emitcomment
                 if)
              else
                 (if ONlevel > 0 then
                     'stfld\t' -> out.puttext; 2->_n;
                     emitType;
                     emitField;
                  else
                     (if isField=1 then
                         'stfld\t' -> out.puttext; 3->_n;
                         emitType;
                         emitField;
                      else
                         ('st',off) -> emitMemOp; 
                     if)
                 if);
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; sig: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> sig[];
             (if withQua then
                 'castclass\t' -> out.puttext;
                 sig[] -> out.puttext;
                 '\n\t'->out.puttext
             if);
             (if ONlevel > 0 then
                 'stfld\t' -> out.puttext; 4->_n;
                 (*emittype; *) sig[]->AddClass->out.puttext; ' '->out.put;
                 isOrigin -> emitField;
              else           
                 (if isField = 1 then
                     'stfld\t' -> out.puttext; 5->_n;
                     (*emittype;*) sig[]->AddClass->out.puttext; ' '->out.put;
                     isOrigin -> emitField;
                  else
                     ('st',off) -> emitMemOp;  
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 'ldfld\t' -> out.puttext; 3->_n;
                 (*emittype;*) sig[]->AddClass->out.puttext; ' ' -> out.put;
                 emitField;
              else 
                 (if isField = 1 then
                     'ldfld\t' -> out.puttext; 4->_n;
                     (*emittype;*)sig[]->AddClass->out.puttext;' ' -> out.put;
                     emitField;
                  else
                     ('ld',off) -> emitMemOp;  
                 if);
             if); 
             (if withQua then
                 '\n\tcastclass\t' -> out.puttext;
                 BC.gettext -> sig[]; 
                 sig[] -> out.puttext
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0' -> out.puttext; 3->_n;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.puttext
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   emitLocals:
     (#
     do '\t.maxstack 8\n' -> out.puttext;                        
     #);
   emitCmpJmp:
     (* Compare two top elements and jump conditionally *)
     (# cond,L,lab: @integer
     enter(cond,L,lab)
     do (if trace_compares then
            'emitCmpJmp' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        '\tL'->out.puttext;
        lab -> out.putint
     #);
   emitCmpToBool:
     (* Compare two top elements and push result *)
     (# cond: @integer
     enter cond
     do (if trace_compares then
            'emitCmpToBool' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'ceq' -> out.puttext;
         // 2 (* <> *) then
            'ceq\n'
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
         // 3 (* <  *) then
            'clt' -> out.puttext 
         // 4 (* <= *) then
            'cgt\n'
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
         // 5 (* >  *) then
            'cgt' -> out.puttext 
         // 6 (* >= *) then
            'clt\n' 
            '\tldc.i4.1\n'
            '\txor' -> out.puttext;
        if);
     #);
   emitCmpBoolJmp:
     (* Compare top with 0 and jump conditionally *)
     (# cond,L,lab: @integer
     enter (cond,L,lab)
     do (if trace_compares then
            'emitCmpBoolJmp' -> emitcomment;
        if);
        'ldc.i4.0\n\t' -> out.puttext;
        (cond->reversecond,L,lab) -> emitCmpJmp;
     #);
   emitLabDef:
     (# labNo: @integer
     enter labNo
     do 'L'-> out.put; labNo -> out.putint; ':\n' -> out.puttext
     #);
   emitLabRef:
     (# labNo: @integer
     enter labNo
     do 'L'-> out.put; labNo -> out.putint; out.newline
     #);
   
   newArray:
     (# type: ^text
     enter type[]
     do '\tnewarr ' -> out.puttext; type[] -> out.puttext
     #);
   
   opCode, arg1: @integer;
   A: @Address;
   T: ^text;
   
do init;
   read:
     (if opCode <> end then
         BC.get->opCode; 
         (if trace_opcodes then
             '/* %d */\n' -> out.putformat(# do opCode -> d #);
         if);
         (if opCode
          // classDef then
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '/********************************************/\n'
             '/*        Class %22s      */\n'
             '/********************************************/\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi ' -> out.puttext;
             thisClassName[] -> quote -> out.putText;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> RemoveClass -> out.puttext;
             '{' -> out.putline;
             'object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             '  .field public ' -> out.puttext;
             thisOrgName[] -> AddClass -> out.puttext;
             ' origin'-> out.putline;
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
             BCstate.fields.init;
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                BC.get -> aux;
                (if 'main' -> thisInnerMethodName.equal then
                    '\n  .method public static void \'main\'(string[] args) cil managed\n  {' 
                      -> out.putline;
                    (if use_modules then
                        (* entrypoint defined by al.exe *)
                     else
                        (if common.switch[6] then
                            'NOT generating .entrypoint (nbeta -x)'->putline;
                         else
                            '\t.entrypoint' -> out.putline;
                        if)
                    if);
                    true -> isMainMethod
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        '\n  .method public virtual void ' -> out.puttext;
                        thisInnerMethodName[]-> quote -> out.puttext;
                        '() cil managed\n  {\n'
                        '\tret\n'
                        '  }\n' -> out.puttext;
                    if);
                    '\n  .method public ' -> out.puttext;
                    thisSignature[] 
                      -> AddClass(# nonstatic::(# do 'virtual '->out.puttext #)#)
                      -> out.puttext; (* AddClass fixes return type, but not arguments *)
                    ' cil managed \n  {' -> out.putline
                if);    
                emitLocals;
             #);
          // initCons then
             '  /* instance constructor */\n'
             '  .method public rtspecialname specialname hidebysig instance void .ctor('
               -> out.puttext;
             (if thisOrgname[]<>NONE then
                 thisOrgName[] (*-> AddClass*) -> out.puttext;
             if);
             ')\n  {' -> out.putline;
          // field then
             (# F: @text
             do 'F' -> F; BC.get->F.putInt;
                (if BC.get = 1 then
                    (F[],BC.gettext,BC.gettext,BC.get) 
                      -> BCstate.fields.new
                 else
                    (F[],'???',BC.gettext,BC.get) 
                    -> BCstate.fields.new;
                if)
             #)
          // labelDef then
             '  L'->out.puttext; BC.get->out.putint; 
             ':'->out.putline;
          // callPrim then
             (# prim,arg: ^text
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if true 
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (* Rest is done in subsequent init *)
                 // 'initSuper' -> prim.equal then
                    '\tcall\tinstance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if not ('-'->arg.equal) then
                        arg[] -> AddClass -> out.puttext
                    if);
                    ')\n' -> out.puttext;
                    BCstate.fields.emitInit
                 // 'init' -> prim.equal then
                    '\tnewobj\tinstance void '-> out.puttext;
                    class[] (* class name *) -> AddClass -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if not ('-'->arg.equal) then
                        arg[] (* origin name *) -> AddClass -> out.puttext;
                    if);
                    ')' -> out.puttext;
                 // 'AlloVR4' -> prim.equal then
                    'int32' -> newArray
                 // 'AlloVR1' -> prim.equal then
                    'char' -> newArray  
                 // 'Text2CharArray' -> prim.equal then
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'Text2CharArray:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                 // 'Text2BetaText' -> prim.equal then
                    (* Note! Hardcoding of pattern 'text'
                     * including case, etc. Should be handled
                     * more generally
                     *)
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'Text2BetaText:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()\n' 
                      -> out.puttext;
                    'char []' -> allocLocal -> storeLocal;
                    '\tldnull\n'
                    '\tnewobj\tinstance void class [tstenv]text::.ctor(class [tstenv]tstenv)\n'
                    '\tdup\n'
                      -> out.puttext;
                    numLocals -> loadLocal;
                    numLocals -> releaseLocal;
                    '\tcallvirt instance void class [tstenv]text::\'enter\'(char[])\n'
                      -> out.puttext
                 // 'CharArray2String' -> prim.equal then
                    '\t' -> out.puttext;
                    (if trace_textop then
                        'CharArray2String:'->emitcomment;
                        '\n\t' -> out.puttext;
                    if);
                    'newobj [mscorlib]System.String(char[])' -> out.puttext
                 // 'Att' -> prim.equal then
                    'missing call of attach here' -> emitcomment;
                    'we pop the stack to avoid overflow' -> emitcomment;
                    '\tpop' -> out.puttext;
                 else
                    'Primitive NYI: ' -> (prim[] -> ('(' -> (')' -> (arg.copy).append).prepend).prepend).prepend -> fixme;
                if);
             #);
             out.newline;
          // callExternal then
             (# prim: ^text
             do BC.getText -> prim[];
                '\tcall\t' -> out.puttext;  
                prim[] -> out.puttext;
                out.newline;
             #)
          // callInner then
             '\tldarg.0' -> out.puttext; 4->_n; out.newline;
             '\tcallvirt ' -> out.puttext;
             (* NOT in accordance with design - FIX *)
             'instance void ' -> out.puttext;
             thisClassName[] -> out.puttext;
             '::'->out.puttext;
             thisInnerMethodName[]->out.puttext;
             '()'->out.putline
          // comment then
             (# T: ^text
             do BC.gettext -> T[];
                (if trace_comments then
                    '\t/* ' -> out.puttext; 
                    (*T[] -> putline;*) T[] -> out.puttext;
                    ' */ ' -> out.putline;
                if)
             #)
          // position then
             BC.getShort -> line;
             (if generateLineNumbers then
                 '\t.line\t' -> out.puttext; 
                 line -> betafile.pc.posToLineCol -> (line, column);
                 line -> out.putint;
                 ':' -> out.put;
                 column+1 -> out.putint;
                 ' ' -> out.puttext;
                 betafilename[] -> quote -> out.puttext;
                 '' -> out.putline;
             if);
          // func then
             (# func: @integer;
             do BC.get->func;
                '\t' -> out.puttext;
                (if func
                 // nott then
                    '\tldc.i4.1\n' -> out.putline;
                    '\txor' -> out.putline;
                 // mult then
                    'mul'->out.puttext
                 // divv then
                    'div'->out.puttext
                 // modd then
                    'rem'->out.puttext
                 // nott then
                    'not'->out.puttext
                 // logNot then
                    'logNot'->out.puttext
                 // neg then
                    'neg'->out.puttext
                 // logicalShiftLeft then 
                    'shl'->out.puttext
                 // arithShiftLeft then 
                    'shl'->out.puttext
                 // logicalShiftRight then 
                    'shr.un'->out.puttext
                 // arithShiftRight then 
                    'shr'->out.puttext
                 else
                    func -> asText->out.puttext
                if);
                99->_n;
                out.newline;
             #)
          else
             '\t' -> out.put; 
             (if opCode
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 A.get; A.loadRef
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,ctag,ftag: @integer; 
                    className, fieldType: ^text;
                 do BC.get -> ONlevel;
                    BC.get -> ctag;
                    (if ctag = 1 then
                        BC.getText -> className[]
                    if);
                    BC.get -> ftag;
                    (if ftag = 1 then
                        BC.gettext -> fieldType[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0' -> out.puttext; 1->_n;
                         else
                            'ldfld\t' -> out.puttext; 5->_n;
                            (if ftag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> out.puttext; 
                             else
                                fieldType[] -> AddClass -> out.puttext
                            if);
                            ' ' ->out.put;
                            (if ctag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.class
                                  -> quote 
                                  -> out.puttext
                             else
                                className[] -> quote -> AddClass -> out.puttext
                            if);
                            '::origin ' -> out.puttext; 3->_n;
                        if);
                    if)
                 #)
              // call then 
                 (# calltype: @integer;
                 do BC.get -> calltype;
                    BC.getText->T[];
                    (if calltype = 1 then
                        'call' -> out.puttext 
                     else
                        'callvirt' -> out.puttext;
                    if);
                    ' '->out.put;
                    2->_n;
                    T[] -> AddClass(# static::(# do true->omitstatic #);
                                      nonstatic::(# do 'instance '->out.puttext#)
                                   #) ->out.puttext;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 #)
              // return then
                 (if BC.get 
                  // 0 
                  // 1
                  // 2
                     then 'ret' -> out.puttext
                  else (* error *) 
                     'xreturn' -> FIXME;
                 if);
                 '\n  }'->out.puttext
              // cmpToBool then
                 (if trace_compares then
                     'cmpToBool' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpAndJmp then
                 (if trace_compares then
                     'cmpAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.get) -> emitCmpJmp  
              // cmpBoolAndJmp then
                 (if trace_compares then
                     'cmpBoolAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.get) -> emitCmpBoolJmp
              // pushCst_s8 then
                 pushCst(# c: @int8 (* CAREFULL: char is unsigned! *);
                        do BC.get->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s16 then
                 pushCst(# c: @int16;
                        do BC.getshort->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s32 then
                 pushCst(# 
                        do BC.getlong->i;
                        #);
              // pushVal then
                 'pushVal'->out.puttext
              // pushNone then
                 'ldnull' -> out.puttext
              // dup then
                 BC.get -> arg1;
                 'dup' -> out.puttext;
                 (if arg1 > 0 then 
                     'IL has no dup_x1/dup_x2 instructions' -> FIXME;
                 if)     
              // pop then
                 'pop' -> out.puttext;
              // loadRange then 
                 'ldlen' -> out.puttext;
              // pushReg then
                 'pushReg'->out.puttext;
                 dumpReg
              // stVal then
                 'stVal'->out.puttext
              // index then
                 'index'->out.puttext
              // cmpAndJmp then
                 'cmpAndJmp'->out.puttext
              // call then
                 'call\tinstance '->out.puttext; 1->_n;
              // callInner then 'callInner' ->out.puttext
              // newVirt then 'newVirt' ->out.puttext
              // return then
                 'ret\n'->out.puttext
              // label then
                 'L'->out.puttext
              // callPrim then
                 'callPrim'->out.puttext
              // endclass then
                 '\n}' -> out.putline;
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' "'->out.puttext; BC.getText->out.puttext; '"'->out.put;
              // pushAdr then
                 'pushAdr'->out.puttext
              // loadRef then
                 'loadRef' ->out.puttext
              // storeRef then
                 'storeRef'->out.puttext
              // storeQref then
                 'storeQref'->out.puttext
              // dup then 'dup' ->out.puttext
              // jmp then
                 'br\t'->out.puttext;
                 (if BC.get
                  // label then 'L'->out.put;
                  else '?' -> out.put;
                 if);
                 BC.get->out.putint; 
              // add then
                 'add'->out.puttext; 1->_n;
              // sub then
                 'sub'->out.puttext
              // orr then
                 'or'->out.puttext
              // andd then
                 'and'->out.puttext
              // xorr then
                 'xor'->out.puttext
              // cmp then
                 'cmp'->out.puttext
              // mult then
                 'mul'->out.puttext
              // divv then
                 'div'->out.puttext; 1->_n;
              // modd then
                 'rem'->out.puttext; 1->_n;
              // nott then
                 'not'->out.puttext
              // logNot then
                 'logNot'->out.puttext
              // neg then
                 'neg'->out.puttext
              // logicalShiftLeft then 
                 'shl'->out.puttext
              // arithShiftLeft then 
                 'shl'->out.puttext
              // logicalShiftRight then 
                 'shr.un'->out.puttext
              // arithShiftRight then 
                 'shr'->out.puttext
              else
                 opCode -> THIS(BCmachine).astext ->out.puttext; 
                 '/* opcode '->out.puttext;
                 opcode -> out.putint;
                 ' */' -> out.puttext;
             if);
             out.newline;
         if);
         restart read
     if);
   out.close
#)  
