ORIGIN 'BCmachineBody'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/basiclib/formatio'; 
INCLUDE '~beta/basiclib/pcre'; 
INCLUDE '~beta/basiclib/streamPosition'; 
INCLUDE '~beta/toollibs/utils/fileExtensions';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit false #);
trace_class:
  (# exit false #);
trace_convert:
  (# exit false #);
trace_mem:
  (# exit false #);
trace_sig:
  (# exit false #);
trace_comments:
  (# exit false #);
use_reflection:
  (# exit false #);
use_betarun:
  (# exit false #);
use_modules:
  (# exit false #);
generateLineNumbers:
  (# exit true #);

emitcomment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
fixme: emitcomment
  (# 
  do 'FIXME:' -> out.puttext;
  #);
ConvertType:
  (# T: ^text
  enter T[]
  do (if trace_convert then
         '/*ConverType('->out.puttext;
         T[]->out.puttext;
         ')*/' ->out.puttext;
     if);
     (if true 
      // 'I' -> T.equal then
         'int32 /*I*/' -> T[];
      // 'C' -> T.equal then
         'char /*C*/' -> T[];
      // '[I' -> T.equal then
         'int32[] /*I*/' -> T[];
      // '[C' -> T.equal then
         'char[] /*C*/' -> T[];
     if);
     INNER;
  exit T[]
  #);
AddClass: ConvertType
  (# isStatic: @boolean;
     location: ^text;
     nonstatic:< object;
  do (if 'static '  -> ((1,7)->T.sub).equal then
         true -> isStatic;
         (1,7)->T.delete;
      else
         nonstatic
     if);
     (if true 
      // 'int32'   -> T.equal 
      // 'char'    -> T.equal 
      // 'void '   -> ((1,5)->T.sub).equal
      // 'int32 '  -> ((1,6)->T.sub).equal
      // 'char '   -> ((1,5)->T.sub).equal
      // 'char[]'  -> ((1,6)->T.sub).equal
      // 'int32[]' -> ((1,7)->T.sub).equal
         then
         (* nothing *)
      else
         (* Local reference. Add class keyword but no location *)
         (if trace_class then 'AddClass' -> emitcomment if);
         (if not ('class '  -> ((1,6)->T.sub).equal) then
             'class ' -> T.prepend;
         if)
     if);
     (if isStatic then
         'static ' -> T.prepend;
     if);
  #);
ReplaceJavaSlash:
  (# regexp: @pcre;
     ok: @boolean;
     T: ^text;
  enter T[]
  do (if trace_sig then
         'ReplaceJavaSlash:'->(T.copy).prepend -> emitcomment;
     if);
     '^(\\w+)/([^\']*) (.*)$' -> regexp;
     (T[], '') -> regExp.replace
     (# rep::
          (# 
          do sub2->value.puttext; (* return-type *)
             ' '->value.put;
             sub1->value.puttext; (* class *)
             '::' -> value.puttext;
             sub3->value.puttext;
             (if false then
                 '/*$1=%s$2=%s$3=%s*/' 
                   -> value.putformat(# do sub1->s; sub2->s; sub3->s #);
             if);
          #)
     #) -> (ok,T[]);
  exit T[]
  #);

--FieldsNewDotnet:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' ' -> out.puttext; F[] -> out.putline;
    // '[' then
       '  .field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' [] ' -> out.puttext; F[] -> out.putline;
    // 'm' then
       (if numLocals>=numArguments then
           (if numLocals>numArguments then 
               ',\n\t\t\t' -> out.puttext 
            else 
               '\t.locals init   (' -> out.puttext;
           if);
           '[' -> out.puttext;
           numLocals-numArguments -> out.putint;
           '] ' -> out.puttext;
           T[] -> AddClass -> out.puttext;
           ' V_' -> out.puttext;
           numLocals-numArguments -> out.putint;
       if);
       numLocals+1 -> numLocals;
    // 'M' then
       (* end method locals *)
       (if numLocals>numArguments then
           ')\n' -> out.puttext;
       if);
    // 'C' then
       (* end class fields *)
       '\n' -> out.puttext;
    else
       'FieldsNewDotnet: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemDotnet:descriptor--
(# 
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       '\tldarg.0 /*2*/\n' -> out.puttext;
       (if true
        // 'C' -> currentType.equal 
        // 'I' -> currentType.equal then
           '\tldc.i4.0\n' -> out.puttext;
        else
           '\tldnull \n' -> out.puttext
       if);
       '\tstfld /*1*/\t' -> out.puttext;
       currentType[] -> ConvertType -> out.puttext;
       ' ' -> out.puttext;
       thisClassName[] -> out.puttext;
       '::' -> out.puttext;
       currentField[] -> out.putline;
   if)
#)

-- emitdotNet: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   localLabNo: @integer; (* counter for local labels as generated by
                          * e.g. cmpToBool
                          *)
   betafile: @file(# pc: @positionConverter #);
   betafilename: ^text;
   line, column: @integer;
   init:
     (# BCmch: ^ByteCodeMachine;
     do out.entry.path.name -> thisModuleName[];
        (if generateLineNumbers then
            (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename[];
            '.bet' -> betafilename.append;
            betafilename[] -> betafile.name;
            betafile.openRead;
        if);
        '.il' -> thisModuleName.stripExtension;
        thisModuleName.copy -> BCstate.thisModuleName[];
        (if use_betarun then
            emitModuleHeader;
         else
            emitAssemblyHeader;
        if);
     #);
   swap:
     (# st0, st1: ^text;
     enter (st0[], st1[])
     do '/* swap */\n'
        '\t.locals init ([%d] %s,\n'
        '\t              [%d] %s)\n'
        '\tstloc.%d\n'
        '\tstloc.%d\n'
        '\tldloc.%d\n'
        '\tldloc.%d\n' 
          -> out.putformat(# num: @integer;
                          do BCstate.fields.numLocals 
                             - BCstate.fields.numArguments -> num;
                             (if st0[]<>NONE then
                                 st0[] -> s;
                              else
                                 '/*FIXME:*/int32' -> s;
                             if);
                             BCstate.fields.numLocals+1->d;
                             (if st1[]<>NONE then
                                 st1[] -> s;
                              else
                                 '/*FIXME:*/int32' -> s;
                             if);
                             num  ->d;
                             num+1->d;
                             num  ->d;
                             num+1->d;
                             BCstate.fields.numLocals+2 
                               -> BCstate.fields.numLocals;
                          #);
     #);
   emitSystemAssemblyReferences:
     (# 
     do '/* Assembly references. */\n'
        '.assembly extern mscorlib {}\n'
          ->out.puttext;
        (if use_betarun then
            '.assembly extern betarun {}\n'
              -> out.puttext;
        if);
        '// FIXME: hardcoded:\n'
        '.assembly extern System.Windows.Forms {\n'
        '  .publickeytoken = (B7 7A 5C 56 19 34 E0 89)\n'
        '  .ver 1:0:3300:0\n'
        '}\n'
          ->out.puttext;
     #);
   emitBETAAssemblyReferences:
     (# 
     do imports.scan
        (# e: @diskentry;
        do '.assembly extern ' -> out.puttext;
           current[] -> e.path;
           e.path.name -> out.puttext;
           ' {}\n' -> out.puttext;
        #);
     #);
   
   emitFileReferences:
     (# 
     do '\n/* File references */\n'
          -> out.puttext;
        imports.scan
        (#
        do '.file ' -> out.puttext;
           current[] -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
                '.dll\n' -> out.puttext;
            if);
        #);
     #);

   emitModuleReferences:
     (# 
     do '/* Module references */\n'
          -> out.puttext;
        (if use_betarun then
            '.module extern betarun_v.dll' -> out.putline;
        if);
        imports.scan
        (#
        do (if use_modules then
                '.module extern ' -> out.puttext;
             else
                '.assembly extern ' -> out.puttext;
           if);
           current[] -> out.puttext;
           (if use_modules then
                '.netmodule\n' -> out.puttext;
             else
               ' {}\n' -> out.puttext;
            if);
        #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about the assembly     */\n'
             '/********************************************/\n'
             '\n'
             '/* Assembly declaration. */\n'
             '.assembly %s {\n'
             '	.hash algorithm 32772	// selected algorithm is SHA1\n'
             '	.ver 1:0:0:0		// version 1.0\n'
             '}\n\n' 
               -> out.putFormat(# do thisModuleName[]->s #);
          #);
     do 
        emitAssemblyInfo;
        emitSystemAssemblyReferences;
        emitBETAAssemblyReferences;
     #);
   emitModuleHeader:
     (# emitModuleInfo:
          (# 
          do '/********************************************/\n'
             '/*       Information about this module      */\n'
             '/********************************************/\n'
             '\n'
             '/* Module declaration. */\n'
             '.module %s.netmodule\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do emitModuleInfo;
        emitSystemAssemblyReferences;
        emitModuleReferences;
        emitFileReferences;
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same???
         *)
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint               
     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg:
     (#  exit BC.get #);
   pushCst:
     (# i: @integer;
     do 'ldc.i4'->out.puttext;
        INNER; (* get constant into i with correct sign *)
        (if true
         // (i=-1) then '.m1' -> out.puttext;
         // (0<=i) and (i<=8) then
            '.'->out.put; i->out.putint;
         // (-128<=i) and (i<=127) then
            '.s '->out.puttext; i->out.putint;
         else
            ' '->out.puttext; i->out.putint;
        if);
     #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        descName,fieldType: ^text;
        get: 
          (#  
          do getReg->reg; 
             BC.get->off; 
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
             else
                 none -> descName[]
             if);
             (if BC.get = 1 then
                 BC.getText -> fieldType[]
              else
                 none -> fieldType[]
             if)
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> out.putText
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> out.puttext;
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext
              else
                 '::F' -> out.puttext;  
                 off -> out.putint;
                 ' ' -> out.put;
             if)
          #);
        emitType:
          (#
          do (if fieldType[] <> none then
                 fieldType[] -> out.puttext
              else
                 'int32' -> out.puttext;
                 'OBS! missing type info (fieldType)' -> emitcomment
             if);
             ' ' -> out.put;
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal then
                         'ldelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal then
                         'ldelem.i1' -> out.puttext
                      else
                         'ldelem.i4' -> out.puttext;
                         'wrong fieldType' -> emitcomment;
                     if)
                  else
                     'ldelem.i4' -> out.puttext;
                     'missing fieldType' -> emitcomment;
                 if)
              else
                 (if ONlevel > 0 then
                     'ldfld /*1*/\t' -> out.puttext;
                     emitType;
                     emitField;
                  else
                     (if isField=1 then
                         'ldfld /*2*/\t' -> out.puttext;
                         emitType;
                         emitField; 
                      else
                         (* method field (local variable/argument?)*)
                         ('ld',off) -> emitMemOp;
                     if);
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal then
                         'stelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal then
                         'stelem.i1' -> out.puttext
                      else
                         'stelem.i4' -> out.puttext;
                         'unknown fieldType' -> emitcomment
                     if)
                  else
                     'iastore' -> out.puttext;
                     'missing fieldType' -> emitcomment
                 if)
              else
                 (if ONlevel > 0 then
                     'stfld /*2*/\t' -> out.puttext;
                     emitType;
                     emitField;
                  else
                     (if isField=1 then
                         'stfld /*3*/\t' -> out.puttext;
                         emitType;
                         emitField;
                      else
                         ('st',off) -> emitMemOp
                     if)
                 if);
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; class: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> class[];
             (if withQua then
                 'castclass\t' -> out.puttext;
                 class[] -> out.puttext;
                 '\n\t'->out.puttext
             if);
             (if ONlevel > 0 then
                 'stfld /*4*/\t' -> out.puttext;
                 emittype;
                 isOrigin -> emitField;
              else           
                 (if isField = 1 then
                     'stfld /*5*/\t' -> out.puttext;
                     emittype;
                     isOrigin -> emitField;
                  else
                     ('st',off) -> emitMemOp
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 'ldfld /*3*/\t' -> out.puttext;
                 emittype;
                 emitField;
              else 
                 (if isField = 1 then
                     'ldfld /*4*/\t' -> out.puttext;
                     emittype;
                     emitField;
                  else
                     ('ld',off) -> emitMemOp
                 if);
             if); 
             (if withQua then
                 sig[] -> puttext;
                 '\n\tcastclass\t' -> out.puttext;
                 BC.gettext -> sig[]; 
                 sig[] -> out.puttext
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0 /*3*/' -> out.puttext;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.puttext
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   emitLocals:
     (#
     do '\t.maxstack 8\n' -> out.puttext;                        
     #);
   emitSignature:
     (# sig: ^text
     enter sig[]
     do (if trace_sig then 'emitsignature' -> emitcomment; if);
        sig[] -> out.puttext; 
     #);
   emitCmpJmp:
     (# cond,L,lab: @integer
     enter(cond,L,lab)
     do (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        '\tL'->out.puttext;
        lab -> out.putint
     #);
   emitCmpBoolJmp:
     (# cond,L,lab: @integer
     enter(cond,L,lab)
     do (if cond
         // 1 (* =  *) then
            'ceq' -> out.puttext 
         // 2 (* <> *) then
            'cne??' -> out.puttext 
         // 3 (* <  *) then
            'clt' -> out.puttext 
         // 4 (* <= *) then
            'cle??' -> out.puttext 
         // 5 (* >  *) then
            'cgt' -> out.puttext 
         // 6 (* >= *) then
            'cge??' -> out.puttext 
        if);
        '\tL'->out.puttext;
        lab -> out.putint
     #);
   emitLabDef:
     (# labNo: @integer
     enter labNo
     do 'L'-> out.put; labNo -> out.putint; ':\n' -> out.puttext
     #);
   emitLabRef:
     (# labNo: @integer
     enter labNo
     do 'L'-> out.put; labNo -> out.putint; out.newline
     #);
   
   opCode, arg1: @integer;
   A: @Address;
   T: ^text;
   
do init;
   read:
     (if opCode <> end then
         BC.get->opCode; 
         (if trace_opcodes then
             '/* %d */\n' -> out.putformat(# do opCode -> d #);
         if);
         (if opCode
          // classDef then
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '/********************************************/\n'
             '/*        Class %22s      */\n'
             '/********************************************/\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi \'' -> out.puttext;
             thisClassName[] -> out.putText;
             '\'' -> out.puttext;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> out.puttext;
             '{' -> out.putline;
             'object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             '  .field public ' -> out.puttext;
             thisOrgName[] -> AddClass -> out.puttext;
             ' origin'-> out.putline;
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
             BCstate.fields.init;
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                BC.get -> aux;
                (if 'main' -> thisInnerMethodName.equal then
                    '\n  .method public static void \'main\'(string[] args) cil managed\n  {' 
                      -> out.putline;
                    (if use_modules then
                        (* entrypoint defined by al.exe *)
                     else
                        '\t.entrypoint' -> out.putline;
                    if);
                    true -> isMainMethod
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        '\n  .method public virtual void \'' -> out.puttext;
                        thisInnerMethodName[]-> out.puttext;
                        '\'() cil managed\n  {\n'
                        '\tret\n'
                        '  }\n' -> out.puttext;
                    if);
                    '\n  .method public ' -> out.puttext;
                    thisSignature[] 
                      -> AddClass(# nonstatic::(# do 'virtual '->out.puttext #)#)
                      -> out.puttext; (* AddClass fixes return type, but not arguments *)
                    ' cil managed \n  {' -> out.putline
                if);    
                emitLocals;
             #);
          // initCons then
             '  /* instance constructor */\n'
             '  .method public rtspecialname specialname hidebysig instance void .ctor('
               -> out.puttext;
             (if thisOrgname[]<>NONE then
                 thisOrgName[] (*-> AddClass*) -> out.puttext;
             if);
             ')\n  {' -> out.putline;
          // field then
             (# F: @text
             do 'F' -> F; BC.get->F.putInt;
                (F[], BC.gettext,BC.get) -> BCstate.fields.new
             #)
          // labelDef then
             '  L'->out.puttext; BC.get->out.putint; 
             ':'->out.putline;
          // callPrim then
             (# prim,arg: ^text
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if true 
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (* Rest is done in subsequent init *)
                 // 'initSuper' -> prim.equal then
                    '\tcall\tinstance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if not ('-'->arg.equal) then
                        arg[] -> AddClass -> emitSignature
                    if);
                    ')\n' -> out.puttext;
                    BCstate.fields.emitInit
                 // 'init' -> prim.equal then
                    (if use_reflection and ('program'->class.equal) then
                        (* hack! *)
                        '\tldstr "program"' -> out.putline;
                        '\tcall object [.module betarun_v.dll]betarun.helpers::Create(string)' -> out.puttext;
                     else
                        '\tnewobj\tinstance void '-> out.puttext;
                        class[] (* class name *) -> AddClass -> out.puttext;
                        '::.ctor(' -> out.puttext;
                        (if not ('-'->arg.equal) then
                            arg[] (* origin name *) -> AddClass -> emitsignature;
                        if);
                        ')' -> out.puttext;
                    if)
                if);
             #);
             out.newline;
          // callExternal then
             (# prim: ^text
             do BC.getText -> prim[];
                '\tcall\t' -> out.puttext;  
                (if true
                 // 'newline' -> prim.equalNCS then
                    'void [mscorlib]System.Console::WriteLine()' 
                      -> out.puttext
                 // 'put' -> prim.equalNCS then
                    'void [mscorlib]System.Console::Write(char)' -> out.puttext
                 // 'puttext' -> prim.equalNCS then
                    'void [mscorlib]System.Console::Write(string)' -> out.puttext
                 // 'putline' -> prim.equalNCS then
                    'void [mscorlib]System.Console::WriteLine(string)' -> out.puttext
                 // 'putint' -> prim.equalNCS then 
                    'void [mscorlib]System.Console::Write(int32)' -> out.puttext
                 else
                    prim[] -> out.puttext
                if);
                out.newline;
             #)
          // callInner then
             '\tldarg.0 /*4*/\n'
             '\t/*callInner*/ callvirt ' -> out.puttext;
             (* NOT in accordance with design - FIX *)
             'instance void ' -> out.puttext;
             thisClassName[] -> out.puttext;
             '::'->out.puttext;
             thisInnerMethodName[]->out.puttext;
             '()'->out.putline
          // comment then
             (# T: ^text
             do BC.gettext -> T[];
                (if trace_comments then
                    '\t/* ' -> out.puttext; 
                    (*T[] -> putline;*) T[] -> out.puttext;
                    ' */ ' -> out.putline;
                if)
             #)
          // position then
             (if generateLineNumbers then
                 '\t.line ' -> out.puttext; 
                 BC.getShort -> betafile.pc.posToLineCol -> (line, column);
                 line -> out.putint;
                 ':' -> out.put;
                 column -> out.putint;
                 ' \'' -> out.puttext;
                 betafilename[] -> out.puttext;
                 '\'' -> out.putline;
             if);
          // func then
             (# func: @integer;
             do BC.get->func;
                '\t' -> out.puttext;
                (if func
                 // nott then
                    '\tifne ' -> out.puttext; 
                    localLabNo -> emitLabRef;
                    '\tldc.i4.1\n' -> out.puttext;
                    '\tbr ' -> out.puttext; 
                    localLabNo + 1 -> emitLabRef;
                    localLabNo -> emitLabDef;
                    '\tldc.i4.0\n' -> out.puttext;
                    localLabNo + 1 -> emitLabDef;
                    localLabNo + 2 -> localLabNo
                 // modd then
                    'rem' -> out.puttext;
                 else
                    func -> asText->out.puttext
                if);
                ' /* func */' -> out.puttext;
                out.newline;
             #)
          else
             '\t' -> out.put; 
             (if opCode
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 A.get; A.loadRef
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,ctag,ftag: @integer; 
                    className, fieldType: ^text;
                 do BC.get -> ONlevel;
                    BC.get -> ctag;
                    (if ctag = 1 then
                        BC.getText -> className[]
                    if);
                    BC.get -> ftag;
                    (if ftag = 1 then
                        BC.gettext -> fieldType[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0 /*1*/' -> out.puttext;
                         else
                            'ldfld /*5*/\t' -> out.puttext;
                            (if ftag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> emitSignature; 
                             else
                                fieldType[] -> AddClass -> emitSignature
                            if);
                            ' ' ->out.put;
                            (if ctag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.class
                                  -> emitSignature
                             else
                                className[] -> AddClass -> emitSignature
                            if);
                            '::origin ' -> out.puttext;
                        if);
                    if)
                 #)
              // call then 
                 (# calltype: @integer;
                 do BC.get -> calltype;
                    BC.getText->T[];
                    (if calltype = 1 then
                        'call' -> out.puttext 
                     else
                        'callvirt' -> out.puttext;
                    if);
                    ' instance '->out.puttext;
                    T[]->replaceJavaSlash->out.puttext;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 #)
              // return then
                 (if BC.get 
                  // 0 
                  // 1
                  // 2
                     then 'ret' -> out.puttext
                  else (* error *) 
                     'xreturn' -> out.puttext
                 if);
                 '\n  }'->out.puttext
              // cmpToBool then
                 'cmpToBool' -> emitcomment;
                 (BC.get,'?',localLabNo) -> emitCmpJmp;
                 '\tldc.i4.0' -> out.putline;
                 '\tbr ' -> out.puttext; localLabNo + 1 -> emitLabRef;
                 localLabNo -> emitLabDef;
                 '\tldc.i4.1\n' -> out.puttext; 
                 localLabNo + 1 -> emitLabDef;
                 localLabNo + 2 -> localLabNo
              // cmpAndJmp then
                 (BC.get,BC.get,BC.get) -> emitCmpJmp  
              // cmpBoolAndJmp then
                 'cmpBoolAndJmp' -> emitcomment;
                 (BC.get,BC.get,BC.get) -> emitCmpBoolJmp
              // pushCst_s8 then
                 pushCst(# c: @int8 (* CAREFULL: char in unsigned! *);
                        do BC.get->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s16 then
                 pushCst(# c: @int16;
                        do BC.getshort->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s32 then
                 pushCst(# 
                        do BC.getlong->i;
                        #);
              // pushVal then
                 'pushVal'->out.puttext
              // pushNone then
                 'ldnull' -> out.puttext
              // dup then
                 BC.get -> arg1;
                 'dup' -> out.puttext;
                 (if arg1 > 0 then 
                     'ERROR: IL has no dup_x1/dup_x2 instructions' -> screen.putline;
                 if)                        
              // loadRange then 
                 'ldlen' -> out.puttext;
              // pushReg then
                 'pushReg'->out.puttext;
                 dumpReg
              // stVal then
                 'stVal'->out.puttext
              // index then
                 'index'->out.puttext
              // cmpAndJmp then
                 'cmpAndJmp'->out.puttext
              // call then
                 'call\tinstance '->out.puttext
              // callInner then 'callInner' ->out.puttext
              // newVirt then 'newVirt' ->out.puttext
              // return then
                 'ret\n'->out.puttext
              // label then
                 'L'->out.puttext
              // callPrim then
                 'callPrim'->out.puttext
              // endclass then
                 '\n}' -> out.putline;
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' "'->out.puttext; BC.getText->out.puttext; '"'->out.put;
              // pushAdr then
                 'pushAdr'->out.puttext
              // loadRef then
                 'loadRef' ->out.puttext
              // storeRef then
                 'storeRef'->out.puttext
              // storeQref then
                 'storeQref'->out.puttext
              // dup then 'dup' ->out.puttext
              // jmp then
                 'br\t'->out.puttext;
                 (if BC.get
                  // label then 'L'->out.put;
                  else '?' -> out.put;
                 if);
                 BC.get->out.putint; 
              // add then
                 'add /*1*/'->out.puttext
              // sub then
                 'sub'->out.puttext
              // orr then
                 'or'->out.puttext
              // andd then
                 'and'->out.puttext
              // xorr then
                 'xor'->out.puttext
              // cmp then
                 'cmp'->out.puttext
              // mult then
                 'mul'->out.puttext
              // divv then
                 'div /*1*/'->out.puttext
              // modd then
                 'rem /*1*/'->out.puttext
              // nott then
                 'not'->out.puttext
              // logNot then
                 'logNot'->out.puttext
              // neg then
                 'neg'->out.puttext
              // logicalShiftLeft then 
                 'shl.un'->out.puttext
              // logicalShiftRight then 
                 'shr'->out.puttext
              // arithShiftLeft then 
                 'shl'->out.puttext
              // arithShiftRight then 
                 'shr'->out.puttext
              else
                 opCode -> THIS(BCmachine).astext ->out.puttext; 
                 '/* opcode '->out.puttext;
                 opcode -> out.putint;
                 ' */' -> out.puttext;
             if);
             out.newline;
         if);
         restart read
     if);
   out.close
#)  
