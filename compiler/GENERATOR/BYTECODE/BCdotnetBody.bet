ORIGIN 'BCmachineBody'; 
INCLUDE 'bytecodebackendbody'; 
INCLUDE '~beta/process/activate'; 
INCLUDE '~beta/basiclib/basicsystemenv'; 
INCLUDE '~beta/basiclib/numberio'; 
INCLUDE '~beta/basiclib/formatio'; 
INCLUDE '~beta/basiclib/streamPosition'; 
INCLUDE '~beta/toollibs/utils/fileExtensions';
INCLUDE '~beta/basiclib/texthash';
INCLUDE 'BCdotnetSupport';
MDBODY nti     'BCdotnetWindowsBody'
       default 'BCdotnetUnixBody';

--BCmachineLib: attributes--
trace_opcodes: 
  (# exit common.switch[190] #);
trace_mem:
  (# exit false #);
trace_locals:
  (# exit false #);
trace_sig:
  (# exit false #);
trace_n:
  (# exit false #);
trace_comments:
  (# exit common.switch[190] #);
trace_compares:
  (# exit false #);
trace_textop:
  (# exit false #);
trace_class:
  (# exit false #);
trace_convert:
  (# exit false #);

allow_nop_emit:
  (# exit false #);

compute_stack_height:
  (# exit false #);
check_stack: (* only relevant if compute_stack_height is true *)
  (# exit false #);
trace_stack: (* only relevant if compute_stack_height is true *)
  (# exit true #);

use_reflection:
  (# exit false #);
use_modules:
  (# exit false #);
generateLineNumbers:
  (# exit common.switch[41] #);
notifyFIXME:
  (# exit true (* not common.switch[188] *) #);
fixme_is_comment:
  (# exit true #);

defaultversion:
  (# exit '1:0:0:0' #);

betaenv_signature:
  (# T: @Text
  do 'class [\'%s\']\'%s\'' -> T.putformat(# do common.betaenv.groupname->s; common.betaenv.groupname->s; #);
  exit T.copy
  #);
betaenv_clrbody:
  (# T: @Text;
  do '%s_clrbody' -> T.putformat(# do common.betaenv.groupname->s #);
  exit T.copy
  #);

trace_opcode:
  (# opcode: @integer;
  enter opcode
  do (if trace_opcodes then
         (if opcode
          // comment then
          // position then
          else
             '/* Opcode %d: %s ' -> out.putformat(# do opCode -> d;  opCode->asText->s; #);
             (if (32<=opcode) and (opcode<=126) then
                 '\'%c\' ' -> out.putformat(# do opcode->c #);
             if);
             '*/' -> out.puttext;
         if)
     if)
  #);

reversecond:
  (# cond: @integer
  enter cond
  do (if cond
      // common.cond_lt then common.cond_gt -> cond
      // common.cond_le then common.cond_ge -> cond
      // common.cond_gt then common.cond_lt -> cond
      // common.cond_ge then common.cond_le -> cond
     if);
  exit cond
  #);

emitcomment:
  (# T: ^text
  enter T[]
  do '/* ' -> out.puttext;
     INNER;
     T[] -> out.puttext;
     ' */' -> out.puttext;
  #);
_n:
  (# n: @integer;
  enter n
  do (if trace_n then
         ' /*'->out.puttext;
         n->out.putint;
         '*/'->out.puttext;
     if);
  #);

trace_string:
  (# T: ^text
  enter t[]
  do out.nl;
     'ldstr "'->out.puttext; 
     T[]->out.puttext; 
     '"' -> out.putln;
     'call void [mscorlib]System.Console::WriteLine(string)' -> out.putln;
  #);

escBackSlash:
  (# T,S: ^text
  enter T[]
  do &text[] -> S[];
     T.scanAll
     (#
     do (if ch = '\\' then
            '\\\\' -> S.puttext
         else
            ch -> S.put
        if);
     #);
  exit S[]
  #);

FIXME: 
  (# T: ^text
  enter T[]
  do 'FIXME: ' -> (T.copy).prepend -> T[];
     (if notifyFIXME then
         '\n***** ' -> screen.puttext; T[] -> screen.putline;
     if);
     (if fixme_is_comment then
         T[] -> emitcomment;
      else
         T[] -> trace_string;
     if)
  #);
ConvertType:
  (# T: ^text
  enter T[]
  do (if trace_convert then
         '/*ConvertType('->out.puttext;
         T[]->out.puttext;
         ')*/' ->out.puttext;
     if);
     (* Delete valueType indicator character *)
     removeAtChar:
       (# 
       do '@valuetype'->T.findTextAll(# do (inx,inx)->T.delete; restart removeAtChar #);
       #);
     (if true 
      // T[]=NONE then
         (*(DumpStack, 'ConvertType: T[] is none') -> Stop;*)
         'ConvertType: T[] is none' -> fixme;
         'ConvertTypeNONE' -> T[];
      // 'I' -> T.equal then
         'int32' -> T[];   (if trace_convert then  ' /*I*/' -> T.append if);
      // '[I' -> T.equal then
         'int32[]' -> T[]; (if trace_convert then  ' /*[I*/' -> T.append if);
      // 'C' -> T.equal then
         'char' -> T[];    (if trace_convert then  ' /*C*/' -> T.append if);
      // '[C' -> T.equal then
         'char[]' -> T[];  (if trace_convert then  ' /*[C*/' -> T.append if);
      // 'D' -> T.equal then
         'float64' -> T[]; (if trace_convert then  ' /*D*/' -> T.append if);
      // '[D' -> T.equal then
         'float64[]' -> T[];  (if trace_convert then ' /*[D*/' -> T.append if);
      // 'Z' -> T.equal then
         'bool' -> T[]; (if trace_convert then  ' /*Z*/' -> T.append if);
      // '[Z' -> T.equal then
         'bool[]' -> T[];  (if trace_convert then ' /*[Z*/' -> T.append if);
     if);
     INNER;
  exit T[]
  #);
RemoveClass:
  (# type: ^text
  enter type[]
  do (if 'class ' -> ((1,6)->type.sub).equal then
         (1,6) -> type.delete;
     if);
  exit type[]
  #);

AddClass: ConvertType
  (# isStatic: @boolean;
     location: ^text;
     static:< object;
     nonstatic:< object;
     omitstatic:< booleanValue;
  do (if 'static '  -> ((1,7)->T.sub).equal then
         true -> isStatic;
         (1,7)->T.delete;
         static;
      else
         nonstatic;
     if);
     (if true 
      // T.length=0
      // 'bool'     -> T.equal 
      // 'bool '    -> ((1,5)->T.sub).equal
      // 'bool,'    -> ((1,5)->T.sub).equal
      // 'bool[]'   -> ((1,6)->T.sub).equal
      // 'char'     -> T.equal 
      // 'char '    -> ((1,5)->T.sub).equal
      // 'char,'    -> ((1,5)->T.sub).equal
      // 'char[]'   -> ((1,6)->T.sub).equal
      // 'float64'  -> T.equal 
      // 'float64 ' -> ((1,8)->T.sub).equal
      // 'float64,' -> ((1,8)->T.sub).equal
      // 'float64[]'-> ((1,9)->T.sub).equal
      // 'float32'  -> T.equal 
      // 'float32 ' -> ((1,8)->T.sub).equal 
      // 'float32,' -> ((1,8)->T.sub).equal
      // 'float32[]'-> ((1,9)->T.sub).equal
      // 'int8'     -> T.equal 
      // 'int8 '    -> ((1,5)->T.sub).equal
      // 'int8,'    -> ((1,5)->T.sub).equal
      // 'int8[]'   -> ((1,6)->T.sub).equal
      // 'int16'    -> T.equal 
      // 'int16 '   -> ((1,6)->T.sub).equal
      // 'int16,'   -> ((1,6)->T.sub).equal
      // 'int16[]'  -> ((1,7)->T.sub).equal
      // 'int32'    -> T.equal 
      // 'int32 '   -> ((1,6)->T.sub).equal
      // 'int32,'   -> ((1,6)->T.sub).equal
      // 'int32[]'  -> ((1,7)->T.sub).equal
      // 'int64'    -> T.equal 
      // 'int64 '   -> ((1,6)->T.sub).equal
      // 'int64,'   -> ((1,6)->T.sub).equal
      // 'int64[]'  -> ((1,7)->T.sub).equal
      // 'void '    -> ((1,5)->T.sub).equal
      // 'valuetype '-> ((1,10)->T.sub).equal
         then
         (* nothing *)
      else
         (* Local reference. Add class keyword but no location *)
         (if trace_class then 'AddClass' -> emitcomment if);
         (if not ('class '  -> ((1,6)->T.sub).equal) then
             (*T[] -> safequote -> T[];*)
             'class ' -> T.prepend;
         if)
     if);
     (if isStatic and (not omitstatic) then
         'static ' -> T.prepend;
     if)
  #);

parseNumberOfArguments: 
  (# numInputs, numOutputs: @integer;
     signature: ^text;
     start: @integer;
     trace: (# exit false #);
  enter signature[]
  do (if trace then
         'parseNumberOfArguments: ' -> screen.puttext;
         signature[] -> screen.puttext;
     if);
     (if 'void ' -> ((1,5)->signature.sub).equal then
         0 -> numOutputs;
      else
         1 -> numOutputs;
     if);
     '(' -> signature.findall(# do inx->start #);
     (start+1, signature.length-1) -> signature.sub -> signature[];
     (if true 
      // signature.length=0 then
         (* no parameters *)
         0 -> numInputs;
      // 'void' -> signature.equal then
         0 -> numInputs;
      else
         1 -> numInputs;
         ',' -> signature.findall(# do numInputs+1->numInputs #);
     if);
     (if trace then
         (if false then
             '. Arguments: "'->screen.puttext;
             signature[] -> screen.puttext;
             '"' -> screen.put;
         if);
         '. NoOfInputs: '->screen.puttext;
         numInputs -> screen.putint; 
         '. NoOfOutputs: '->screen.puttext;
         numOutputs -> screen.putint; 
         screen.newline;
     if);
  exit (numInputs, numOutputs)
  #);

function_stack_delta:
  (# signature: ^text;
     in, out: @integer;
  enter signature[]
  do signature[] -> parseNumberOfArguments -> (in, out);
  exit out-in
  #);

--FieldsNewClr:descriptor--
(# 
do (if methodClassTag
    // 'c' 
    // 'p' then
       out.nl;
       '.field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' ' -> out.puttext; 
       FN[] -> safequote -> out.putln;
    // '[' then
       out.nl;
       '.field public '->out.puttext;
       T[] -> AddClass -> out.puttext;
       ' [] ' -> out.puttext; 
       FN[] -> safequote -> out.putln;
    // 'm' then
       (if numCells>=numArguments then
           (if numCells=numArguments then 
               out.nl;
               '.locals init   (' -> out.puttext;
            else 
               ',' ->out.putln;
               '                ' -> out.puttext 
           if);
           '[' -> out.puttext;
           numLocals -> out.putint;
           '] ' -> out.puttext;
           T[] -> AddClass -> out.puttext;
           (if false then
               ' V_' -> out.puttext; 
               numLocals -> out.putint;
            else
               ' '->out.put;
               FN[] -> out.puttext; (* local variable name *)
           if);
           out.nl;
           numLocals+1 -> numLocals;    
       if);
       numCells+1 -> numCells;
    // 'M' then
       (* end method locals *)
       (if numCells>numArguments then
           ')' -> out.putln;
       if);
    // 'C' then
       (* end class fields *)
    else
       'FieldsNewClr: unknown tag: ' -> screen.puttext;
       methodClassTag -> screen.put; screen.newline;
   if);
#)

--FieldsEmitInitItemClr:descriptor--
(# 
do (if trace_opcodes then '/* emitInit */' -> out.puttext; if);
   (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else  
       out.nl;
       'ldarg.0' -> out.puttext; 2->_n; 
       (* 1 -> stack_delta; not here (:-( *)
       out.nl;
       (if true
        // 'bool' -> currentType.equal 
        // 'Z' -> currentType.equal 
           then
           'ldc.i4.0' -> out.puttext; (* NOT ldc.i2.0! *)
        // 'char' -> currentType.equal 
        // 'C' -> currentType.equal 
        // 'int8' -> currentType.equal 
        // 'int16' -> currentType.equal 
        // 'int32' -> currentType.equal 
        // 'I' -> currentType.equal
           then
           'ldc.i4.0' -> out.puttext;
        // 'float64' -> currentType.equal 
        // 'D' -> currentType.equal (* double/real *) then
           'ldc.r8 0' -> out.puttext; 
        else
           'ldnull' -> out.puttext
       if);
       out.nl;
       (* 1 -> stack_delta; not here (:-( *)
       'stfld  ' -> out.puttext; 1->_n; 
       currentType[] -> ConvertType -> out.puttext;
       ' ' -> out.puttext;
       thisClassName[] -> safequote -> out.puttext;
       '::' -> out.puttext;
       currentFieldName[] -> safequote -> out.putln;
       (* -2 -> stack_delta; not here (:-( *)
       (if trace_opcodes then '/* emitInit done */' -> out.puttext; if)
   if)
#)

-- emitclr: descriptor --
(# thisClassName                (* name of current class           *)
   ,thisOrgName                 (* name of current origin class    *)
   ,thisSuperName               (* name of current super           *)
   ,thisSuperOrgName            (* nameof origin of current super  *)
   ,thisSignature               (* signature of current method     *)
   ,thisInnerMethodName         (* name of a possible inner method;
                                 * or the name of method 'main'
                                 *)
   ,thisModuleName: ^text;
   thisBlockLevel,
   subLevel: @integer; (* current subpattern level *)
   noOfArguments: @integer;
   class: ^text;(*  name of class being called - 
                 * used by subsequent init - ugly
                 *)
   isMainMethod: @boolean; (* true if generating code for main method *)
   hasMainMethod: @boolean; (* true if generating code for module with main method *)
   hasFields: @boolean; (* true if generating code for a method that has any fields *)
   previousWasJmp: @boolean;
   
   betafile: @file(# initialized: @boolean; pc: @positionConverter #);
   betafilename: ^text;
   line, column: @integer;
   
   numBackendLocals: @integer;
   backendLocalLab:
     (# labno: @integer;
        def:
          (# 
          do 2 -> out.indent.dec;
             'Lb' -> out.puttext; labno -> out.putint; ':' -> out.put;
             2 -> out.indent.inc;
             out.nl;
          #);
        new:
          (# 
          do numBackendLocals+1->numBackendLocals->labno;
          #);
        astext:
          (# t: ^text;
          do ' Lb' -> t[]; labno->t.putint;
          exit t[]
          #);
     exit astext
     #);
   
   stack_height: @integer;
   max_stack_height: @integer;
   stack_delta:
     (# delta: @integer;
     enter delta 
     do (if compute_stack_height then
            delta+stack_height->stack_height;
            (if stack_height>max_stack_height then
                stack_height->max_stack_height;
            if);
            (if trace_stack then
                ' /* stack height: ' -> out.puttext;
                stack_height -> out.putint;
                ' */ ' -> out.puttext;
            if);
            (if (stack_height<0) and (stack_height-delta>=0) then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    '::' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                    'Stack underflow' -> fixme;
                 else
                    'Stack Underflow!' -> emitcomment;
                if)
            if);
        if)
     #);
   check_stack_height:
     (# predicted_height: @integer;
        msg: ^text;
     enter predicted_height
     do (if compute_stack_height then
            (if stack_height<>predicted_height then
                (if check_stack then
                    thisClassName.copy -> screen.puttext;
                    ':: ' -> screen.puttext;
                    thisSignature[] -> screen.puttext;
                    ':' -> screen.puttext;
                if);
                'Unexpected stack height ' -> msg[];
                stack_height -> msg.putint;
                ' (' -> msg.puttext;
                predicted_height -> msg.putint;
                ' expected)' -> msg.puttext;
                (if check_stack then
                    msg[] -> fixme;
                 else
                    msg[] -> emitcomment;
                    out.nl;
                if);
            if);
        if)
     #);
   
   labs: @
     (#
        stack_heights: [500] ^IntegerObject;
        clear:
          (# 
          do (for i:stack_heights.range repeat
                  NONE->stack_heights[i][]
             for);
          #);
        def: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             'L'->out.puttext; l->out.putint; 
             ': '->out.puttext;
             (if compute_stack_height then
                 (* stack height book-keeping *)
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Use stack height defined by branch to here *)
                     stack_heights[l] -> stack_height;
                     (if trace_stack then
                         '/* Stack height (from previous branches to here): ' -> out.puttext;
                         stack_height -> out.putint;
                         ' */' -> out.puttext;
                     if);
                  else
                     (if previousWasJmp then
                         (* Cannot use current stack height, since we never
                          * fall through to here
                          *)
                         (if false then
                             'At definition of L' -> msg[];
                             l-> msg.putint;
                             ': Cannot determine stack height' -> msg.puttext;
                             msg[] -> fixme;
                         if);
                         (* According to OLM: stack height should be 0 here *)
                         &IntegerObject[] -> stack_heights[l][];
                         (if trace_stack then
                             '/* Stack height (assumed): ' -> out.puttext;
                             stack_height -> out.putint;
                             ' */' -> out.puttext;
                         if);
                      else
                         &IntegerObject[] -> stack_heights[l][];
                         stack_height -> stack_heights[l];
                         (if trace_stack then
                             '/* Stack height (fall through from above): ' -> out.puttext;
                             stack_height -> out.putint;
                         if);
                     if);
                 if);
             if);
             (*out.newline;*)
          #);
        use: @
          (# l: @integer;
             msg: ^text;
          enter l
          do (* emit code *)
             '  L'->out.puttext;
             l -> out.putint;
             (if l<=0 then
                 (if not common.switch[188] then
                     (# msg: ^text;
                     do 'Use of strange label L'->msg[];
                        l-> msg.putint;
                        msg[] -> fixme;
                     #)
                 if);
             if);
             (if compute_stack_height then
                 (if l > stack_heights.range then
                     l+stack_heights.range->stack_heights.extend;
                 if);
                 (if stack_heights[l][]<>NONE then
                     (* Other branches to L. Check consistency *)
                     (if stack_height<>stack_heights[l] then
                         out.entry.path.name -> msg[];
                         ': Stack inconsistency: current stack height '
                           -> msg.puttext;
                         stack_height -> msg.putint;
                         ' at branch target L' -> msg.puttext;
                         l -> msg.putint;
                         ' differs from previous value ' -> msg.puttext;
                         stack_heights[l] -> msg.putint;
                         msg[] -> fixme;
                     if);
                  else
                     &IntegerObject[] -> stack_heights[l][];
                     stack_height -> stack_heights[l];
                 if);
             if);
          #);
     #);
   
   
   init:
     (# BCmch: ^ByteCodeMachine;
        PH: @pathhandler;
        setargfile: @text;
        trace_name: (# exit false #);
     do ObjectPool.get(# type::assemblyinfohashtable #)
          -> lookedup_assemblies[];
        out.entry.path.name -> thisModuleName[];
        (if generateLineNumbers then
            (* Construct source file path relative to current working dir *)
            (mch[]->BCmch[]).mstate.thisFullPath.copy -> betafilename[];
            (if (betafilename.length->betafilename.inxGet) = DirectoryChar then
                (betafilename.length,betafilename.length) -> betafilename.delete;
            if);
            (if trace_name then
                'betafilename1: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            betafilename[] -> betafile.name;
            betafile.entry.path.head -> betafilename[] (* strip trailing /clr *);
            (if trace_name then
                'betafilename2: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            directorychar -> betafilename.put;
            (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> betafilename.append;
            '.bet' -> betafilename.append;
            (if trace_name then
                'betafilename3: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            
            (if false then
                (* Get relative path from current directory *)
                (if trace_name then
                    'currentdirectory: '->screen.puttext;
                    currentdirectory -> screen.putline;
                if);
                (betafilename[]->BackslashToSlash, currentdirectory->BackslashToSlash) 
                  -> PH.localpath 
                  -> betafilename[];
                (if common.hostIsWindows then
                    betafilename[] -> SlashToBackslash -> betafilename[];
                if);
            if);
            
            (if trace_name then
                'betafilename4: '->screen.puttext;
                betafilename[] -> screen.putline;
            if);
            
            betafilename[] -> betafile.name;
        if);
        ('.il' -> thisModuleName.stripExtension).copy
          -> BCstate.thisModuleName[];
        (if use_modules then
            emitModuleHeader;
         else
            emitAssemblyHeader;
        if);
     #);
   allocLocal:
     (# type: ^text;
     enter type[]
     do '.locals init ([%d] %s)'
          -> out.putformat(# do BCstate.fields.numLocals -> d; type[] -> s #);
        out.nl;
        BCstate.fields.numLocals+1 -> BCstate.fields.numLocals;
     exit numLastLocal
     #);
   releaseLocal:
     (# locNum: @integer
     enter locNum
     do (* Currently not used.
         * Could recycle locNum by remembering the index and the current type of that index.
         * A subsequent allocLocal could then reuse this local if it's the same type.
         *)
     #);
   MappedLocals: [1]@integer;
   lastMappedLocal: @integer;
   allocMappedLocal:
     (# num: @integer;
        type: ^text;
        locnum: @integer;
     enter (num, type[])
     do -num -> num;
        (if num>MappedLocals.range then
            (MappedLocals.range, num-MappedLocals.range)
              -> max
              -> MappedLocals.extend;
        if);
        (if MappedLocals[num]=0 then
            (type[] -> allocLocal -> locnum) + 1 -> MappedLocals[num];
            (* adding 1 to distingguish local 0 from unassigned *)
            (if trace_locals then
                '/*Mapped and allocated local %d to %d (noOfArguments=%d)*/'
                  -> out.putformat(# do -num->d; 
                                     MappedLocals[num]->d; 
                                     noOfArguments->d;
                                  #);
                out.nl;
            if);
            num -> lastMappedLocal; 
         else
            MappedLocals[num]- 1 -> locnum;
            num -> lastMappedLocal; (* needed? *)
            (if trace_locals then
                '/*Mapped and used local %d to %d*/'
                  -> out.putformat(# do -num->d; locnum->d; #);
                out.nl;
            if);
        if);
     exit locnum
     #);
   loc2off:
     (# locnum, off: @integer
     enter locnum
     do (locnum+BCstate.fields.numArguments)*4 + 12 -> off;
     exit off
     #);
   opLocal:
     (# num: @integer;
        delta: @integer;
        isAddressOf:< booleanValue
     enter num (* local number, NOT offset *)
     do (if trace_locals then
            '/*opLocal(num=' ->out.puttext; 
            num->out.putint; 
            ')*/' -> out.puttext;
        if);
        INNER;
        'loc' -> out.puttext;
        (if isAddressOf then
            'a' -> out.put;
            (if num <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            (if true
             // num<0 then
                'Negative opLocal' -> screen.putline;
                'Negative opLocal' -> emitcomment;
                (*(dumpstack, 'Negative opLocal') -> stop*)
             // num <= 3 
                then '.' -> out.put
             // num <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
        if);
        num -> out.putint; 
        delta-> stack_delta; 
        out.nl;
     #);
   storeLocal: 
     opLocal(# do 'st' -> out.puttext; -1->delta; #);
   loadLocal: 
     opLocal(# do 'ld' -> out.puttext; 1->delta; #);
   loadLocalAddress: 
     loadLocal(# isAddressOf::trueValue #);
   numLastLocal (* Real number of last local *):
     (# exit BCstate.fields.numLocals-1 #);
   
   emitSystemAssemblyReferences:
     (# 
     do '/* Assembly references. */' -> out.putline;
        'mscorlib' -> importAssembly;
     #);
   emitBETAAssemblyReferences:
     (# 
     do (if common.ComponentDotCJ then
            'Component' -> importAssembly;
        if);
        imports.scan
        (# e: @diskentry;
           assemblyname: ^text;
        do current[] -> e.path;
           e.path.name -> assemblyname[];
           (if assemblyname.copy->untick -> thisModuleName.equal then
               (*thisModuleName[]->emitcomment; out.newline *)
            else
               assemblyName[] -> importAssembly;
           if);
        #);
     #);
   
   imported_assemblies: @texthashtable;
   
   lookedup_assemblies: ^assemblyinfohashtable;
   
   importAssembly:
     (# assemblyname: ^text;
        is_external: booleanValue
          (* Only call gacutil for non-beta assemblies.
           * Ideally imports should contain a flag indicating this,
           * but it does not currenlty.
           * So instead we test for the Microsoft .NET famework libraries.
           * Will fail for third-party assemblies, though 
           * (but they are probably not in GAC anyway.
           *)
          (# 
          do (if true
              // 'mscorlib'  -> ((1,8)->assemblyname.sub).equal
              // 'System'    -> ((1,6)->assemblyname.sub).equal
              // 'Microsoft' -> ((1,9)->assemblyname.sub).equal
                 then
                 true -> value;
             if);
          #);
     enter assemblyname[]
     do
        (if assemblyname[] -> imported_assemblies.add then
            out.indent;
            '.assembly extern%s ' 
              -> out.putformat(# 
                              do (if common.switch[186] then 
                                     ' retargetable'->s 
                                  else 
                                     ''->s
                                 if)
                              #);
            assemblyname[] -> safequote -> out.puttext;
            <<SLOT ImportAssemblyVersion: descriptor>>
        if)
     #);
   
   lookupAssemblyVersion:
     (# assemblyname: ^text;
        version, publickeytoken: ^text;
        
        gacutil: <<SLOT GacUtil: descriptor>>;
        was_there: @boolean;
     enter assemblyname[]
     do '1:0:0:0' -> version[];
        assemblyname[] 
          -> lookedup_assemblies.get
          -> (was_there, version[], publickeytoken[]);
        (if not was_there then
            gacutil;
            (assemblyname[], version[], publickeytoken[])
              -> lookedup_assemblies.add;
        if);
     exit (version[], publickeytoken[])
     #);
   
   emitFileReferences:
     (# 
     do '\n/* File references */\n'
          -> out.puttext;
        imports.scan
        (#
        do '.file ' -> out.puttext;
           current[] -> out.puttext;
           (if use_modules then
               '.netmodule\n' -> out.puttext;
            else
               '.dll\n' -> out.puttext;
           if);
        #);
     #);

   emitModuleReferences:
     (# 
     do '/* Module references */\n'
          -> out.puttext;
        imports.scan
        (#
        do (if use_modules then
               '.module extern ' -> out.puttext;
            else
               out.indent;
               '.assembly extern%s '
                 -> out.putformat(# 
                                 do (if common.switch[186] then 
                                        ' retargetable'->s 
                                     else 
                                        ''->s
                                    if);
                                 #);
                                    
           if);
           current[] -> safequote -> out.puttext;
           (if use_modules then
               '.netmodule\n' -> out.puttext;
            else
               ' {}\n' -> out.puttext;
           if);
        #);
     #);
   emitAssemblyHeader:
     (# emitAssemblyInfo:
          (# 
          do '//********************************************\n'
             '//*       Information about the assembly     *\n'
             '//********************************************\n'
             '\n'
             '/* Assembly declaration. */' -> out.putln;
             '.assembly%s \'%s\' {'
               -> out.putformat(# 
                               do (if common.switch[186] then 
                                      ' retargetable'->s 
                                   else 
                                      ''->s
                                  if);
                                  thisModuleName[]->s
                               #);
             out.indent.inc; out.putln;
             '.hash algorithm 32772	// selected algorithm is SHA1' -> out.putln;
             '.ver ' -> out.puttext; defaultversion -> out.putline;
             out.indent.dec;
             out.indent;
             '}' -> out.putline;
             '.module \'%s.dll\'\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do 
        emitAssemblyInfo;
        emitSystemAssemblyReferences;
        emitBETAAssemblyReferences;
     #);
   emitModuleHeader:
     (# emitModuleInfo:
          (# 
          do '//********************************************\n'
             '//*       Information about this module      *\n'
             '//********************************************\n'
             '\n'
             '/* Module declaration. */\n'
             '.module %s.netmodule\n\n'
               ->  out.putFormat(# do thisModuleName[]->s #);
          #);
     do emitModuleInfo;
        emitSystemAssemblyReferences;
        emitModuleReferences;
        emitFileReferences;
     #);
   emitMemOp:
     (# op, tmp: ^text; varNo, origVarNo: @integer;
     enter(op[],varNo)
     do (* currently we assume that local variables have
         * addresses: 0,12,16,20,... that are mapped to 0,1,2,3,...
         * 0 is this.
         * Hmmm, this means that this and local[0] is the same?
         * No: local number 0 has address 12+BCstate.fields.numArguments*4.
         *)
        varNo -> origVarNo;
        (if trace_mem then
            varNo->('mem:'->tmp[]).putint -> emitcomment;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
        if);
        op[] -> out.puttext;
        (if varNo>0 then
            (varNo div 4) - 2 -> varNo;
            (if true
             // varNo=0 
             // (noOfArguments<>-1) and (varNo>noOfArguments) then
                'loc' -> out.puttext;
                varNo - (noOfArguments+1) -> varNo;
             else
                'arg' -> out.puttext;
            if);
            (if true
             // varNo <= 3 
                then '.' -> out.put
             // varNo <= 255 
                then '.s ' -> out.puttext
             else
                ' ' -> out.put 
            if);
         else
            'arg.' -> out.puttext;
        if);
        varNo -> out.putint;
        (if varNo<0 then
            'Negative location/argument number' -> fixme;
            origVarNo->('mem:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            noOfArguments->('noOfArguments:'->tmp[]).putint -> emitcomment;
            tmp[] -> screen.putline;
            'Negative memory offset' -> putline;
        if);
        (if 'ld'->op.equal then
            (* ldarg/ldloc *)
            1 -> stack_delta;
         else
            (* starg/stloc *)
            -1 -> stack_delta;
        if);

     #);
   dumpReg:
     (# 
     do
        '%'->out.put;
        (if BC.get
         // thisO then 'this'->out.puttext // callO then 'call'->out.puttext
         else
            'top'->out.puttext
        if);
        
     #);
   getReg:
     (#  exit BC.get #);
   pushCst:
     (# i: @integer;
     do 'ldc.i4'->out.puttext;
        INNER; (* get constant into i with correct sign *)
        (if true
         // (i=-1) then '.m1' -> out.puttext;
         // (0<=i) and (i<=8) then
            '.'->out.put; i->out.putint;
         // (-128<=i) and (i<=127) then
            '.s '->out.puttext; i->out.putint;
         else
            ' '->out.puttext; i->out.putint;
        if);
        (if (32<=i) and (i<=126) then
            ' // \'%c\'' -> out.putformat(# do THIS(pushCst).i->c #);
        if);
        1 -> stack_delta;
     #);
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer;
        isValueTypeOrigin: @boolean;
        fieldName,descName,fieldType: ^text;
        get: 
          (# hasFieldName: @integer 
          do getReg->reg; 
             (if (BC.get -> hasFieldName) = 1 then
                 BC.gettext -> fieldName[]
             if);
             (# c: @int16;
             do BC.getShort->c;
                c -> off(* sign extend *);
             #);
             (if (off>0) and (off<12) then
                 (if not common.switch[188] then
                     (# msg: ^text;
                     do 'Address.get: strange offset: '-> msg[];
                        off -> msg.putint; 
                        (if hasFieldName=1 then
                            '. Field name: '-> msg.puttext;
                            fieldname[] -> msg.puttext;
                        if);
                        msg[] -> fixme;
                     #);
                 if);
             if);
             BC.get->size; 
             BC.get->ONlevel;
             BC.get -> isField; 
             (if isField = 1 then
                 BC.getText -> descName[]
              else
                 none -> descName[]
             if);
             (if BC.get = 1 then
                 BC.getText -> fieldType[];
                 (if trace_opcodes then
                     (# msg: ^text;
                     do 'Address.get fieldtype: '-> msg[];
                        fieldtype[] -> msg.puttext;
                        msg[] -> emitcomment;
                     #)
                 if);
              else
                 none -> fieldType[];
             if)
          #);
        emitField:
          (# isOrigin: @boolean
          enter isOrigin
          do (if isField = 1 then
                 descName[] -> safequote -> out.putText; 1->_n;
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> safequote -> out.puttext; 
             if);
             (if isOrigin then
                 '::origin ' -> out.puttext; 2->_n;
              else
                 '::' -> out.puttext;
                 fieldName[]-> safequote -> out.puttext;
                 ' ' -> out.put;
             if)
          #);
        emitType:
          (#
          do (if fieldType[] <> none then
                 fieldType[] -> ConvertType -> out.puttext
              else
                 'int32' -> out.puttext;
                 'OBS! missing type info (fieldType)' -> emitcomment
             if);
             ' ' -> out.put;
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                      // 'int8' -> fieldType.equal 
                         then
                         'ldelem.i1' -> out.puttext
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'ldelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal 
                      // 'char' -> fieldType.equal 
                      // 'int16u' -> fieldType.equal 
                         then
                         'ldelem.u2' -> out.puttext
                      // 'int16' -> fieldType.equal
                         then
                         'ldelem.i2' -> out.puttext
                      // 'F' -> fieldType.equal 
                      // 'float32' -> fieldType.equal 
                         then
                         'ldelem.r4' -> out.puttext
                      // 'D' -> fieldType.equal 
                      // 'float64' -> fieldType.equal 
                         then
                         'ldelem.r8' -> out.puttext
                      else
                         'ldelem.ref' -> out.puttext;
                     if)
                  else
                     'load: missing fieldType' -> FIXME;
                 if);
                 -1 -> stack_delta (* pops object, field name; pushes field value *);
              else
                 (if ONlevel > 0 then
                     isValueTypeOrigin->ldfld; 1->_n;
                     emitType;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *);
                  else
                     (if isField=1 then
                         isValueTypeOrigin->ldfld; 2->_n;
                         emitType;
                         emitField; 
                         0 -> stack_delta (* pops object; pushes field value *);
                      else
                         (* method field (local variable/argument?)*)
                         ('ld',off) -> emitMemOp; 
                     if);
                 if);
             if);
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'Z' -> fieldType.equal 
                      // 'bool' -> fieldType.equal 
                      // 'int8' -> fieldType.equal 
                         then
                         'stelem.i1' -> out.puttext
                      // 'I' -> fieldType.equal 
                      // 'int32' -> fieldType.equal 
                         then
                         'stelem.i4' -> out.puttext
                      // 'C' -> fieldType.equal
                      // 'char' -> fieldType.equal
                      // 'int16' -> fieldType.equal 
                         then
                         'stelem.i2' -> out.puttext (* no unsigned store *)
                      // 'F' -> fieldType.equal
                      // 'float32' -> fieldType.equal then
                         'stelem.r4' -> out.puttext
                      // 'D' -> fieldType.equal
                      // 'float64' -> fieldType.equal then
                         'stelem.r8' -> out.puttext
                      else
                         'stelem.ref' -> out.puttext;
                     if);
                  else
                     'store: missing fieldType' -> FIXME;
                 if);
                 -2 -> stack_delta (* pops object, field name; *)
              else
                 (if ONlevel > 0 then
                     'stfld  ' -> out.puttext; 2->_n;
                     emitType;
                     emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     (if isField=1 then
                         'stfld  ' -> out.puttext; 3->_n;
                         emitType;
                         emitField;
                         -2 -> stack_delta (* pops object, field name; *)
                      else
                         ('st',off) -> emitMemOp; 
                     if)
                 if);
             if);
          #);
        storeRef:
          (# withQua,isOrigin: @boolean; sig: ^text
          enter(withQua,isOrigin)
          do BC.gettext -> sig[];
             (if trace_opcodes then
                 (# msg: ^text
                 do 'storeref: '->msg[];
                    (if withQua then 'withQua, '-> msg.append; if);
                    (if isOrigin then 'isOrigin, '-> msg.append; if);
                    'isField: '-> msg.append; isField-> msg.putint;
                    ', sig: '->msg.append;
                    sig[] -> msg.append;
                    msg[]->emitcomment;
                 #);
             if);
             (if withQua then
                 sig[] -> castClass
             if);
             (if ONlevel > 0 then
                 'stfld  ' -> out.puttext; 4->_n;
                 (*emittype; *) sig[]->AddClass->out.puttext; ' '->out.put;
                 isOrigin -> emitField;
                 -2 -> stack_delta (* pops object, field name; *)
              else           
                 (if isField = 1 then
                     'stfld  ' -> out.puttext; 5->_n;
                     (*emittype;*) sig[]->AddClass->out.puttext; ' '->out.put;
                     isOrigin -> emitField;
                     -2 -> stack_delta (* pops object, field name; *)
                  else
                     (if isField = 2 then
                         'stelem.ref' -> out.puttext;
                         -3 -> stack_delta;
                      else 
                         (if trace_locals or trace_mem then
                             '/*storeref: off: '-> out.puttext;
                             off->out.putint;
                             '*/' -> out.puttext;
                         if);
                         (if off<0 then
                             (off, sig[]) -> allocMappedLocal -> loc2off -> off;
                         if);
                         ('st',off) -> emitMemOp;  
                     if);
                 if);
             if);
          #);
        loadRef:
          (# withQua: @boolean; sig: ^text
          enter withQua
          do BC.gettext -> sig[];
             (if ONlevel > 0 then
                 isValueTypeOrigin->ldfld; 3->_n;
                 (*emittype;*) sig[]->AddClass->out.puttext; ' ' -> out.put;
                 emitField;
                 0 -> stack_delta (* pops object; pushes field value *)
              else 
                 (if isField = 1 then
                     isValueTypeOrigin->ldfld; 4->_n;
                     (*emittype;*)sig[]->AddClass->out.puttext;' ' -> out.put;
                     emitField;
                     0 -> stack_delta (* pops object; pushes field value *)
                  else
                     (if isField = 2 then
                         'ldelem.ref' -> out.puttext;
                         1 -> stack_delta;
                      else
                         (if trace_locals or trace_mem then
                             '/*loadref: off: '-> out.puttext;
                             off->out.putint;
                             '*/' -> out.puttext;
                         if);
                         (if off<0 then
                             (off, sig[]) -> allocMappedLocal -> loc2off -> off;
                         if);
                         ('ld',off) -> emitMemOp;  
                     if);
                 if);
             if); 
             (if withQua then
                 out.nl;
                 BC.gettext -> sig[] -> castClass
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     'ldarg.0' -> out.puttext; 3->_n;
                     1 -> stack_delta;
                  else
                     '/* Warning: pushAdr:register not this */'->out.puttext;
                 if)
              else
                 '/* Warning: pushAdr:registeroff<>0 */'->out.putline;
                 load
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->out.putint else size->out.putint if);
             '.'->out.put;
             (if reg
              // thisO then  // callO then '%call.'->out.puttext
              else
                 '%top.'->out.puttext
             if);
             off->out.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
          #);
     #);
   allocStack:
     (#
     do (if not compute_stack_height then
            '.maxstack 1000' -> out.puttext;
        if);
     #);
   emitCmpJmp:
     (* Compare two top elements and jump conditionally *)
     (# cond,L,lab,isRef: @integer (* oLM: isRef=1: reference cmp *)
     enter(cond,L,lab,isRef)
     do (if trace_compares then
            'emitCmpJmp' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'beq' -> out.puttext 
         // 2 (* <> *) then
            'bne.un' -> out.puttext 
         // 3 (* <  *) then
            'blt' -> out.puttext 
         // 4 (* <= *) then
            'ble' -> out.puttext 
         // 5 (* >  *) then
            'bgt' -> out.puttext 
         // 6 (* >= *) then
            'bge' -> out.puttext 
        if);
        -2 -> stack_delta;
        lab -> labs.use;
     #);
   emitCmpToBool:
     (* Compare two top elements and push result *)
     (# cond: @integer
     enter cond
     do (if trace_compares then
            'emitCmpToBool' -> emitcomment;
        if);
        (if cond
         // 1 (* =  *) then
            'ceq' -> out.puttext;
         // 2 (* <> *) then
            'ceq' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
         // 3 (* <  *) then
            'clt' -> out.puttext 
         // 4 (* <= *) then
            'cgt' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
         // 5 (* >  *) then
            'cgt' -> out.puttext 
         // 6 (* >= *) then
            'clt' -> out.putln;
            'ldc.i4.1' -> out.putln;
            'xor' -> out.puttext;
        if);
        -1 -> stack_delta;
     #);
   emitCmpBoolJmp:
     (* Compare top with 0 and jump conditionally *)
     (# cond,L,lab: @integer
     enter (cond,L,lab)
     do (if trace_compares then
            'emitCmpBoolJmp' -> emitcomment;
        if);
        'ldc.i4.0' -> out.putln;
        1 -> stack_delta;
        (cond->reversecond,L,lab,0) -> emitCmpJmp;
     #);
   
   emitString:
     (* See Partition II Metadata, section 5.2 Terminals of the CIL spec *)
     (# T: ^text; 
     enter T[]
     do '"'->out.put; 
        T.scanAll
        (# escape:
             (# ch: @char
             enter ch
             do '\\'->out.put; ch->out.put
             #);
        do (if ch
            // ascii.newline then 'n' -> escape;
            // ascii.ht      then 't' -> escape
            // '"'           then '"' -> escape
            // '\\'        then  '\\'-> escape
            else 
               (if ch < ' ' then
                   '\\'-> out.put;
                   '0' + (ch div 64) -> out.put;
                   ch mod 64 -> ch;
                   '0' + (ch div 8) -> out.put;
                   ch mod 8 -> ch;
                   '0' + ch -> out.put
                else                  
                   (if ch > 255 then
                       ' ' -> out.put;
                    else
                       ch->out.put 
                   if);
               if)
           if)
        #);
        '"'->out.put; 
     #);   
   
   opCode, arg1, arg2: @integer;
   A: @Address;
   T: ^text;
   
   castClass:
     (# sig, msg: ^text;
     enter sig[]
     do sig[] -> ConvertType -> sig[];
        (if 'valuetype '->((1,10)->sig.sub).equal then
            (* Casting to and from value type instances isn’t permitted.
             * ECMA 335, section 12.1.6.2.6 
             *)
            'Not for value types: castclass  '->msg[];
            sig[] -> msg.puttext;
            msg[] -> emitcomment; 
            out.nl;
         else
            'castclass  ' -> out.puttext;
            sig[] -> out.putln;
            (* stack neutral *)
        if)
     #);
   
   thisWasAddressOf, lastWasAddressOf: @boolean;
   
   ldfld:
     (# addressOf: @boolean;
     enter addressOf
     do 'ldfld' -> out.puttext;
        (if addressOf then 'a' -> out.put if);
        '  '->out.puttext;
        true -> thisWasAddressOf;
     #);
   
   simulate_dup_x1:
     (* stack: ..., value2, value1
      *                     ^top
      *     -> ..., value1, value2, value1
      *                             ^top
      *)
     (# value1, value2: @integer;
        type1, type2: ^text
     enter (type1[], type2[])
     do (if (type1.length=0) or (type2.length=0) then
            'IL has no dup_x1 instruction' -> FIXME;
         else
            'simulate_dup_x1' -> emitcomment; out.nl;
            (* Allocate locals *)
            type1[] -> allocLocal -> value1;
            type2[] -> allocLocal -> value2;
            (* Pop into locals *)
            value1 -> storeLocal;
            value2 -> storeLocal; 
            (* Push in right order *)
            value1 -> loadLocal;
            value2 -> loadLocal;
            value1 -> loadLocal;
            (* Release locals *)
            value1 -> releaseLocal;
            value2 -> releaseLocal;
        if);
     #);
   
   simulate_dup_x2:
     (* stack: ..., value3, value2, value1
      *                            ^top
      *     -> ..., value1, value3, value2, value1
      *                                     ^top
      *)
     (# value1, value2, value3: @integer;
        type1, type2, type3: ^text
     enter (type1[], type2[], type3[])
     do (if (type1.length=0) or (type2.length=0) or (type3.length=0) then
            'IL has no dup_x2 instruction' -> FIXME;
         else
            'simulate_dup_x2' -> emitcomment; out.nl;
            (* Allocate locals *)
            type1[] -> allocLocal -> value1;
            type2[] -> allocLocal -> value2;
            type3[] -> allocLocal -> value3;
            (* Pop into locals *)
            value1 -> storeLocal;
            value2 -> storeLocal; 
            value3 -> storeLocal; 
            (* Push in right order *)
            value1 -> loadLocal;
            value3 -> loadLocal;
            value2 -> loadLocal;
            value1 -> loadLocal;
            (* Release locals *)
            value1 -> releaseLocal;
            value2 -> releaseLocal;
            value3 -> releaseLocal;
        if);
     #);
   
   simulate_dup2:
     (* stack: ..., value2, value1  
      *                     ^top
      *     -> ..., value2, value1, value2, value1
      *                                     ^top
      *)
     (# value1, value2: @integer;
        type1, type2: ^text
     enter (type1[], type2[])
     do 'simulate_dup2' -> emitcomment; out.nl;
        (* Allocate locals *)
        type1[] -> allocLocal -> value1;
        type2[] -> allocLocal -> value2;
        (* Pop into locals *)
        value1 -> storeLocal;
        value2 -> storeLocal; 
        (* Push in right order *)
        value2 -> loadLocal;
        value1 -> loadLocal;
        value2 -> loadLocal;
        value1 -> loadLocal;
        (* Release locals *)
        value1 -> releaseLocal;
        value2 -> releaseLocal;
     #);
   
   simulate_dup2_x1:
     (* stack: ..., value3, value2, value1  
      *                             ^top
      *     -> ..., value2, value1, value3, value2, value1
      *                                             ^top
      *)
     (# value1, value2, value3: @integer;
        type1, type2, type3: ^text
     enter (type1[], type2[], type3[])
     do (if (type1.length=0) or (type2.length=0) or (type3.length=0) then
            'IL has no dup2_x1 instruction' -> FIXME;
         else
            'simulate_dup2_x1' -> emitcomment; out.nl;
            (* Allocate locals *)
            type1[] -> allocLocal -> value1;
            type2[] -> allocLocal -> value2;
            type3[] -> allocLocal -> value3;
            (* Pop into locals *)
            value1 -> storeLocal;
            value2 -> storeLocal; 
            value3 -> storeLocal; 
            (* Push in right order *)
            value2 -> loadLocal;
            value1 -> loadLocal;
            value3 -> loadLocal;
            value2 -> loadLocal;
            value1 -> loadLocal;
            (* Release locals *)
            value1 -> releaseLocal;
            value2 -> releaseLocal;
            value3 -> releaseLocal;
        if)
     #);
   
   simulate_dup2_x2:
     (* stack: ..., value4, value3, value2, value1    
      *                                     ^top
      *     -> ..., value2, value1, value4, value3, value2, value1
      *                                                     ^top
      *)
     (# value1, value2, value3, value4: @integer;
        type1, type2, type3, type4: ^text
     enter (type1[], type2[], type3[], type4[])
     do (if (type1.length=0) or (type2.length=0) or (type3.length=0) or (type4.length=0) then
            'IL has no dup2_x2 instruction' -> FIXME;
         else
            'simulate_dup2_x2' -> emitcomment; out.nl;
            (* Allocate locals *)
            type1[] -> allocLocal -> value1;
            type2[] -> allocLocal -> value2;
            type3[] -> allocLocal -> value3;
            type4[] -> allocLocal -> value4;
            (* Pop into locals *)
            value1 -> storeLocal;
            value2 -> storeLocal; 
            (* Push in right order *)
            value2 -> loadLocal;
            value1 -> loadLocal;
            value4 -> loadLocal;
            value3 -> loadLocal;
            value2 -> loadLocal;
            value1 -> loadLocal;
            (* Release locals *)
            value1 -> releaseLocal;
            value2 -> releaseLocal;
            value3 -> releaseLocal;
            value4 -> releaseLocal;
        if);
     #);

   
do init;
   thisWasAddressOf -> lastWasAddressOf;
   false -> thisWasAddressOf;
   read:
     (if opCode <> end then
         BC.get->opCode -> trace_opcode;
         (if opCode
          // classDef then
             (* true -> out.indent.trace; *)
             false -> isMainMethod;
             -1 -> noOfArguments; (* ignore until first method def *)
             BC.gettext -> thisClassName[];
             '\n'
             '//********************************************\n'
             '//*       Class: %s:\n'
             '//********************************************\n'
               -> out.putFormat(# do thisClassName[]->s #);
             '.class public auto ansi ' -> out.puttext;
             thisClassName[] -> safequote -> out.putText;
             BC.get -> thisBlockLevel;
             (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
             ' extends ' -> out.puttext;
             BC.getText -> thisSuperName[] -> RemoveClass -> out.putln;
             out.indent.inc;
             '{' -> out.putln;
             'object'->thisSuperOrgName[];
             BC.get -> subLevel; 
             BC.gettext -> thisOrgName[];
             
             (if (subLevel = 0) and (common.betaenv.groupname ->thisClassName.equalNCS) then
                 '.field public static ' -> out.puttext;
                 betaenv_signature -> out.puttext;
                 ' betaenvRef'-> out.putln;
             if);
             
             (if not ('-'->thisOrgName.equal) then
                 '.field public ' -> out.puttext;
                 thisOrgName[] -> AddClass -> out.puttext;
                 ' origin'-> out.puttext;
             if);
             BCstate.fields.init;
             313->ctrace(# do '%%%class: "'->xT;
                           thisClassName[] -> xT;
                           '" blocklevel: ' -> xT;
                           thisBlockLevel -> xI; xN;
                           'super: "'->xT;
                           thisSuperName[] -> xT; 
                           '" sublevel: ' -> xT;
                           subLevel -> xI
                        #);
             
          // endclass then
             out.indent.dec;
             (*out.putln;*)
             '}'->out.putln;

             (if (thisClassName[]<>NONE) and 
                 (('BetaObject' -> thisClassName.equal) (* FIXME: needed? *) or
                  ( common.BetaObjectClass  -> thisClassName.equal)  
                 ) then
                 (* Just finished generating BetaObject (in betaenv). *)
                 GenerateClassExOException;
                 GenerateClassStructure;
                 GenerateClassBetaArray;
                 (if not common.ComponentDotCJ then
                     GenerateClassComponent;
                 if);
             if);
          // methodDef then
             (# aux: @integer; (* 0 or 1 *)
             do (* labs.clear; *)
                BC.gettext -> thisInnerMethodName[];  
                BC.gettext -> thisSignature[];
                0                       -> BCstate.fields.numCells;
                0                       -> BCstate.fields.numLocals;
                BC.get -> noOfArguments -> BCstate.fields.numArguments;
                1                       -> MappedLocals.new;
                false                   -> hasFields;
                BC.get -> aux;
                (if false then
                       '\nMethodDef: signature: ' -> puttext;
                       thisSignature[] -> putline;
                       ' noOfArgs: ' -> puttext;
                       BCstate.fields.numArguments -> putint;
                       ' InnerName: ' -> puttext;
                       thisInnerMethodName[] -> puttext;
                if);
                (if 'main' -> thisInnerMethodName.equal then
                    out.putln;
                    'static void \'Main\'(string[] args)' -> thisSignature[];
                    '.method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] -> out.puttext;
                    ' cil managed' -> out.putln;
                    out.indent.inc;
                    '{' -> out.putln;
                    (if use_modules then
                        (* entrypoint defined by al.exe *)
                     else
                        (if common.switch[6] then
                            'NOT generating .entrypoint (nbeta -x)'->putline;
                         else
                            '.entrypoint' -> out.putln;
                        if);
                    if);
                    true -> isMainMethod;
                    true -> hasMainMethod;
                 else
                    false -> isMainMethod;
                    (if aux = 0 then
                        out.putln;
                        '.method public virtual void ' -> out.puttext;
                        0 -> stack_height -> max_stack_height;
                        thisInnerMethodName[]
                          -> safequote 
                        (* -> thisSignature[] *)
                          -> out.puttext;
                        '() cil managed'
                          -> out.putln;
                        out.indent.inc;
                        '{' -> out.putln;
                        out.indent.dec;
                        'ret' -> out.putln;
                        '}' -> out.putln;
                    if);
                    out.putln;
                    '.method public ' -> out.puttext;
                    0 -> stack_height -> max_stack_height;
                    thisSignature[] 
                      -> AddClass(# nonstatic:: (# do 'virtual '->out.puttext; #);#)
                      -> out.puttext; (* AddClass fixes return type, but not arguments *)
                    ' cil managed' -> out.putln;
                    out.indent.inc;
                    '{' -> out.putln;
                if);    
                allocStack;
             #);
          // endMethod then 
             (if compute_stack_height then
                 '.maxstack ' -> out.puttext;
                 max_stack_height -> out.putint;
             if);
             out.indent.dec;
             out.putln;
             '}'->out.putline;
             
          // initCons then
             (# sig: ^text
             do BC.gettext -> sig[]; 
                'rtspecialname specialname hidebysig instance void .ctor('
                  -> thisSignature[];
                (if not ('-' -> thisOrgname.equal) then
                    sig[] -> AddClass -> thisSignature.puttext;
                if);
                ')' -> thisSignature.put;
                (if hasfields then
                    out.putln;
                    out.putln;
                if);
                '/* instance constructor */' -> out.putln;
                '.method public ' -> out.puttext;
                0 -> stack_height -> max_stack_height;
                thisSignature[] -> out.putln;
                out.indent.inc;
                '{' -> out.putln;
                allocStack;
             #) 
          // field then
             (# F: ^text
             do true -> hasfields;
                'F' -> F[]; BC.get->F.putInt;
                (if BC.get = 1 then
                    (F[],BC.gettext,BC.gettext,BC.get) 
                      -> BCstate.fields.new
                 else
                    (F[],'???',BC.gettext,BC.get) 
                      -> BCstate.fields.new;
                if)
             #)
          // labelDef then
             2 -> out.indent.dec; 
             out.nl; 
             BC.getShort -> labs.def;
             2 -> out.indent.inc;
          // callPrim then
             (# prim,arg: ^text;
                delta: @integer;
             do BC.gettext -> prim[];
                BC.getText -> arg[];
                (if trace_opcodes then
                    '/* callprim: %s(%s) */'->out.putformat(# do prim[]->s; arg[]->s #);
                if);
                (if true 
                 // 'initSuper' -> prim.equal then
                    out.nl;
                    'call  instance void '->out.puttext;
                    thisSuperName[] -> out.puttext;
                    '::.ctor(' -> out.puttext;
                    (if ('-'->arg.equal) then
                        (* no arguments *)
                        -1 -> delta;
                     else
                        (if false then
                            '/*arg:'->out.puttext; arg[]->out.puttext;'*/'->out.puttext;
                        if);
                        arg[] -> AddClass -> out.puttext;
                        -2 -> delta;
                    if);
                    ')' -> out.puttext;
                    (if (subLevel = 0) and (common.betaenv.groupname ->thisClassName.equalNCS) then
                        out.nl;
                        'ldarg.0' -> out.putln; (* this(betaenv)[] *)
                        'stsfld  %s %s::betaenvRef' 
                          -> out.putformat(# 
                                          do betaenv_signature->s; 
                                             betaenv_signature->s; 
                                          #);
                    if);
                    delta -> stack_delta;
                    (*BCstate.fields.emitInit don't: No need to initialize to default values *)
                 // 'new' -> prim.equal then
                    arg.copy -> class[]; (* ugly! *)
                    (if trace_opcodes then
                        '/* callprim: new: class is: %s */'->out.putformat(# do class[]->s #);
                    if);
                    (* Rest is done in subsequent init *)
                 // 'init' -> prim.equal then
                    (if class[]=NONE then
                        'callprim.init: class is NONE' -> putline;
                     else
                        (# ctor_signature: ^text;
                        do 'void ' -> ctor_signature[];
                           
                           class[] (* class name *) -> AddClass -> ctor_signature.puttext;
                           '::.ctor(' -> ctor_signature.puttext;
                           (if false then
                               '/*arg:'->out.puttext; arg[]->out.puttext;'*/'->out.puttext;
                           if);
                           (if ('-'->arg.equal) then
                               (* no arguments *)
                            else
                               (if arg[]=NONE then
                                   'callprim.init: arg is NONE' -> putline;
                               if);
                               arg[] (* origin name *) -> AddClass -> ctor_signature.puttext;
                           if);
                           ')' -> ctor_signature.puttext;
                           out.nl;
                           'newobj  instance '-> out.puttext;
                           ctor_signature[] -> out.puttext;
                           1+(ctor_signature[]->function_stack_delta) -> stack_delta
                        #);
                    if)
                 // 'NewVR1' -> prim.equal
                 // 'AlloVR1' -> prim.equal then
                    'char' -> newArray  
                 // 'NewVRZ' -> prim.equal
                 // 'AlloVRZ' -> prim.equal then
                    (* the following are no longer used 
                 // 'NewVR1bool' -> prim.equal
                 // 'AlloVR1bool' -> prim.equal then*)
                    'bool' -> newArray  
                 // 'NewVRB' -> prim.equal
                 // 'AlloVRB' -> prim.equal then
                    (* allocate byte array OLM??? *)
                    'int8' -> newArray                    
                 // 'NewVR2' -> prim.equal
                 // 'AlloVR2' -> prim.equal then
                    'int16' -> newArray  
                 // 'NewVR4' -> prim.equal
                 // 'AlloVR4' -> prim.equal then
                    'int32' -> newArray
                 // 'NewVR8' -> prim.equal
                 // 'AlloVR8' -> prim.equal then
                    'float64'-> newArray  
                 // 'NewRR' -> prim.equal
                 // 'AlloRR' -> prim.equal then
                    (* argument: type[] - extract type *)
                    (arg.length-1, arg.length) -> arg.delete;
                    arg[] -> newArray;
                    
                    
                 // 'ExtVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::ExtVR1(char[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'ExtVRB' -> prim.equal then
                    out.nl;
                    'call int8[] %s::ExtVRB(int8[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::CopyVR1(char[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR1' -> prim.equal then
                    out.nl;
                    'call char[] %s::CopySVR1(int32,int32,char[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::ExtVRZ(bool[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::CopyVRZ(bool[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVRZ' -> prim.equal then
                    out.nl;
                    'call bool[] %s::CopySVRZ(int32,int32,bool[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::ExtVR2(int16[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::CopyVR2(int16[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR2' -> prim.equal then
                    out.nl;
                    'call int16[] %s::CopySVR2(int32,int32,int16[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::ExtVR4(int32[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::CopyVR4(int32[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR4' -> prim.equal then
                    out.nl;
                    'call int32[] %s::CopySVR4(int32,int32,int32[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                 // 'ExtVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::ExtVR8(float64[],int32)'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopyVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::CopyVR8(float64[])'
                      -> out.putformat(# do sigBetaArray->s #);
                 // 'CopySVR8' -> prim.equal then
                    out.nl;
                    'call float64[] %s::CopySVR8(int32,int32,float64[])' 
                      -> out.putformat(# do sigBetaArray->s #);
                    
                    
                 (* ... *)
                    
                 // 'ExtRR' -> prim.equal then
                    (* Functionally equivalent to
                     * 
                     * public static char[] ExtVR1(char[] oldrep, int add) {
                     *     int copysize = oldrep.Length;
                     *     int newsize  = copysize + add;
                     *     if (newsize<0) newsize = 0;
                     *     if (copysize>newsize) copysize = newsize;
                     *     char[] newrep = new char[newsize];
                     *     System.Array.Copy(oldrep, 0, newrep, 0, copysize);
                     *     return newrep;
                     * }
                     *)
                    (# loc_oldrep, loc_add, loc_copysize, loc_newsize, loc_newrep: @integer;
                       lab1, lab2: @backendLocalLab;
                    do out.nl;
                       'ExtRR' -> emitComment;
                       (* 'ldstr "ExtRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[] -> allocLocal -> loc_oldrep;
                       'int32' -> allocLocal -> loc_add;
                       'int32'  -> allocLocal -> loc_copysize;
                       'int32'  -> allocLocal -> loc_newsize;
                       arg[] -> allocLocal -> loc_newrep;
                       (* stack: oldrep, add *)
                       loc_add -> storeLocal;
                       loc_oldrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen' -> out.putln;
                       'conv.i4' -> out.putln;
                       loc_copysize -> storeLocal;
                       loc_copysize -> loadLocal;
                       loc_add -> loadLocal;
                       'add' -> out.putln;
                       loc_newsize -> storeLocal;
                       loc_newsize -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab1.new;
                       'bge.s ' -> out.puttext; lab1->out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize -> storeLocal;
                       lab1.def; 
                       loc_copysize -> loadLocal;
                       loc_newsize -> loadLocal;
                       lab2.new;
                       'ble.s' -> out.puttext; lab2-> out.putln;
                       loc_newsize -> loadLocal;
                       loc_copysize -> storeLocal;
                       lab2.def; 
                       loc_newsize -> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_copysize -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array, int32, class [mscorlib]System.Array, int32, int32)' -> out.putln;
                       loc_newrep -> loadLocal;
                       loc_oldrep -> releaseLocal;
                       loc_add -> releaseLocal;
                       loc_copysize -> releaseLocal;
                       loc_newsize -> releaseLocal;
                       loc_newrep -> releaseLocal;
                    #);
                 // 'CopyRR' -> prim.equal then
                    (* Functionally equivalent to
                     *   public static char[] CopyVR1(char[] oldrep) {
                     *     int size = oldrep.Length;
                     *     char[] newrep = new char[size];
                     *     System.Array.Copy(oldrep, 0, newrep, 0, size);
                     *     return newrep;
                     *   }
                     *)
                    (# loc_oldrep, loc_size, loc_newrep: @integer;
                    do out.nl;
                       'CopyRR' -> emitComment;
                       (* 'ldstr "CopyRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[]    -> allocLocal -> loc_oldrep;
                       'int32'  -> allocLocal -> loc_size;
                       arg[]    -> allocLocal -> loc_newrep;
                       (* stack: oldrep *)
                       loc_oldrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen' -> out.putln;
                       'conv.i4' -> out.putln;
                       loc_size -> storeLocal;
                       loc_size -> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_oldrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_size -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
                       loc_newrep -> loadLocal;
                       loc_oldrep -> releaseLocal;
                       loc_size   -> releaseLocal;
                       loc_newrep -> releaseLocal;
                    #);
                 // 'CopySRR' -> prim.equal then
                    (* Functionally equivalent to:
                     *  public static char[] CopySVR1(int low, int high, char[] oldrep) 
                     *  {
                     *      CkSR(low, high, oldrep.Length);
                     *      int newsize = high - low + 1;
                     *      if (newsize<0) newsize = 0;
                     *      char[] newrep = new char[newsize];
                     *      if (newsize>0) System.Array.Copy(oldrep,low-1,newrep,0,newsize);
                     *      return newrep;
                     *  }
                     *)
                    (# loc_oldrep, loc_low, loc_high, loc_newsize, loc_newrep: @integer;
                       lab1, lab2: @backendLocalLab;
                    do out.nl;
                       'CopySRR' -> emitComment;
                       (*'ldstr "CopySRR" pop' -> out.putln; (* visible in ildasm *)
                       (* arg: "class [location]type[]" *)
                       out.nl;
                       arg[]    -> allocLocal -> loc_oldrep;
                       'int32'  -> allocLocal -> loc_low;
                       'int32'  -> allocLocal -> loc_high;
                       'int32'  -> allocLocal -> loc_newsize;
                       arg[]    -> allocLocal -> loc_newrep;
                       (* stack: low, high, oldrep *)
                       loc_oldrep -> storeLocal;
                       loc_high   -> storeLocal;
                       loc_low    -> storeLocal;
                       loc_low    -> loadLocal;
                       loc_high   -> loadLocal;
                       loc_oldrep -> loadLocal;
                       'ldlen'    -> out.putln;
                       'conv.i4'  -> out.putln;
                       'call  void %s::CkSR(int32,int32,int32)' 
                         -> out.putformat(# do sigBetaArray->s #); out.nl;
                       loc_high   -> loadLocal;
                       loc_low    -> loadLocal;
                       'sub'      -> out.putln;
                       'ldc.i4.1' -> out.putln;
                       'add'      -> out.putln;
                       loc_newsize-> storeLocal;
                       loc_newsize-> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab1.new;
                       'bge.s ' ->out.puttext; lab1-> out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize-> storeLocal;
                       lab1.def;
                       loc_newsize-> loadLocal;
                       (arg.lgth-1,arg.lgth) -> arg.delete; (* remove last '[]' from arg *)
                       'newarr  ' -> out.puttext; arg[] -> out.putln;
                       loc_newrep -> storeLocal;
                       loc_newsize-> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       lab2.new;
                       'ble.s ' -> out.puttext; lab2 -> out.putln;
                       loc_oldrep -> loadLocal;
                       loc_low    -> loadLocal;
                       'ldc.i4.1' -> out.putln;
                       'sub'      -> out.putln;
                       loc_newrep -> loadLocal;
                       'ldc.i4.0' -> out.putln;
                       loc_newsize -> loadLocal;
                       'call  void [mscorlib]System.Array::Copy(class [mscorlib]System.Array,int32,class [mscorlib]System.Array,int32,int32)' -> out.putln;
                       lab2.def;
                       loc_newrep -> loadLocal;
                       loc_newrep -> releaseLocal;
                       loc_oldrep -> releaseLocal;
                       loc_high   -> releaseLocal;
                       loc_low    -> releaseLocal;
                       loc_newsize-> releaseLocal;
                    #)
                 // 'CinitT' -> prim.equal then
                    (* Nothing *)
                 // 'Text2CharArray' -> prim.equal then
                    (if trace_textop then
                        'Text2CharArray:'->emitcomment;
                        out.nl;
                    if);
                    out.nl;
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                 // 'CharArray2String' -> prim.equal then
                    (if trace_textop then
                        'CharArray2String:'->emitcomment;
                        out.nl;
                    if);
                    out.nl;
                    'newobj  instance void class [mscorlib]System.String::.ctor(char[])' -> out.puttext;
                    0 -> stack_delta;
                 // 'char2rep' -> prim.equal then
                    (* a single char is on the stack;
                     * create a new char array of length 1
                     * and store the char in the array;
                     * and return the array on the stack.
                     *)
                    (# loc_ch: @integer;
                    do out.nl;
                       'char' -> allocLocal -> loc_ch -> storeLocal;
                       -1 -> stack_delta;
                       'ldc.i4.1' -> out.putln;
                       'newarr  char' -> out.putln;
                       'dup' -> out.putln;
                       'ldc.i4.0' -> out.putln;
                       loc_ch -> loadLocal;
                       4 -> stack_delta;
                       'stelem.i2' -> out.puttext;
                       -3 -> stack_delta;
                       loc_ch -> releaseLocal;
                    #);
                 // 'ExternalString2BetaText' -> prim.equal then
                    (* Note! Hardcoding of pattern 'text'
                     * including case, etc. Should be handled
                     * more generally
                     *)
                    (if trace_textop then
                        'ExternalString2BetaText:'->emitcomment;
                        out.nl;
                    if);  
                    out.nl;
                    (* Stack: string. FIXME: may be null *)
                    'callvirt instance char[] [mscorlib]System.String::ToCharArray()' 
                      -> out.puttext;
                    0 -> stack_delta;
                    out.nl;
                    'char []' -> allocLocal -> storeLocal;
                    'ldsfld  %s %s::betaenvRef' 
                      -> out.putformat(# 
                                      do betaenv_signature->s; 
                                         betaenv_signature->s; 
                                      #);
                    1 -> stack_delta;
                    out.nl;
                    'newobj  instance void class [%s]text::.ctor(class [%s]%s)' -> out.putformat(# do betaenv_name->s; betaenv_name->s; betaenv_name->s; #);
                    0 -> stack_delta;
                    out.nl;
                    'dup' -> out.puttext;
                    1 -> stack_delta;
                    out.nl;
                    numLastLocal -> loadLocal;
                    numLastLocal -> releaseLocal;
                    'callvirt instance void class [%s]text::\''
                      -> out.putformat(# do betaenv_name->s; #);
                    common.enterMethod -> out.puttext;
                    '\'(char[])' -> out.puttext;
                    -2 -> stack_delta;
                 // 'BetaText2BetaCharArray' -> prim.equal then
                    out.nl;
                    'ldfld  char[] [\'%s\']text::T' -> out.putformat(# do betaenv_name->s; #);

                 // 'BetaText2ExternalString' -> prim.equal then
                    (# textsig: @text;
                       textloc: @integer;
                    do (if trace_textop then
                           'BetaText2ExternalString:'->emitcomment;
                           out.nl;
                       if);
                       'class [\'%s\']text' -> textsig.putformat(# do betaenv_name->s; #);
                       out.nl;
                       'dup' -> out.putln;
                       textsig[] -> allocLocal -> textloc -> storeLocal;
                       'ldfld  char[] [\'%s\']text::T' -> out.putformat(# do betaenv_name->s; #);
                       out.nl;
                       'ldc.i4.0' -> out.putln;
                       textloc -> loadLocal;
                       'ldfld  int32 [\'%s\']text::lgth' -> out.putformat(# do betaenv_name->s; #);
                       out.nl;
                       'newobj  instance void class [mscorlib]System.String::.ctor(char[],int32,int32)' -> out.puttext;
                       0 -> stack_delta;
                       textloc -> releaseLocal;
                    #);
                 // 'AlloS' -> prim.equal then
                    out.nl;
                    'ldtoken  ' -> out.puttext; 
                    arg[] -> out.putln;
                    'call  class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)' -> out.putln;
                    'call  %s %s::AlloS(class [mscorlib]System.Object, class [mscorlib]System.Type)' -> out.putformat(# do sigStructure->s; sigStructure->s; #); out.putln;
                    0 -> stack_delta;
                 // 'ObjS' -> prim.equal then
                    out.nl;
                    'call %s %s::ObjS(class [mscorlib]System.Object)' -> out.putformat(# do sigStructure->s; sigStructure->s; #); 
                    out.nl;
                    -3 -> stack_delta;
                 // 'eqS' -> prim.equal then
                    out.nl;
                    'call bool %s::eqS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'neS' -> prim.equal then
                    out.nl;
                    'call bool %s::neS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'ltS' -> prim.equal then
                    out.nl;
                    'call bool %s::ltS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'leS' -> prim.equal then
                    out.nl;
                    'call bool %s::leS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'gtS' -> prim.equal then
                    out.nl;
                    'call bool %s::gtS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'geS' -> prim.equal then
                    out.nl;
                    'call bool %s::geS(%s, %s)' -> out.putformat(# do sigStructure->s; sigStructure->s; sigStructure->s; #);
                    out.nl;
                    -3 -> stack_delta;
                 // 'AlloSI' -> prim.equal then
                    out.nl;
                    'callvirt class [mscorlib]System.Object %s::AlloSI()' -> out.putformat(# do sigStructure->s; #);
                    out.nl;
                    0 -> stack_delta;
                 // 'Att' -> prim.equal then
                    out.nl;
                    'Att'->emitcomment;
                    out.nl;
                    'ldfld class [\'%s\']\'Component\' [\'%s\']\'%s\'::\'_comp\'' -> out.putformat(# do common.ComponentLocation->s; betaenv_name->s; common.BetaObjectClass->s #);
                    out.nl;
                    'callvirt void [\'%s\']\'Component\'::\'swap\'()'-> out.putformat(# do common.ComponentLocation->s; #);
                    out.nl;
                    0 -> stack_delta;
                 // 'Susp' -> prim.equal then
                    out.nl;
                    'Susp'->emitcomment;
                    out.nl;
                    'ldsfld class [\'%s\']\'Component\' [\'%s\']\'Component\'::\'current\'' -> out.putformat(# do common.ComponentLocation->s; common.ComponentLocation->s; #);
                    out.nl;
                    'callvirt void [\'%s\']\'Component\'::\'swap\'()'-> out.putformat(# do common.ComponentLocation->s; #);
                    out.nl;
                    0 -> stack_delta;
                 // 'SuspX' -> prim.equal then
                    out.nl;
                    'SuspX'->emitcomment;
                    out.nl;
                    'ldfld class [\'%s\']\'Component\' [\'%s\']\'BetaObject\'::\'_comp\'' -> out.putformat(# do common.ComponentLocation->s; betaenv_name->s; #);
                    out.nl;
                    'callvirt void [\'%s\']\'Component\'::\'swap\'()'-> out.putformat(# do common.ComponentLocation->s; #);
                    out.nl;
                    0 -> stack_delta;
                 // 'AlloC' -> prim.equal then
                    out.nl;
                    'dup' -> out.putln;
                    'newobj  instance void [\'%s\']\'Component\'::.ctor(class [\'%s\']\'BetaObject\')' -> out.putformat(# do common.ComponentLocation->s; betaenv_name->s; #);
                    out.nl;
                    'pop' -> out.putln;
                    0 -> stack_delta;
                 // 'initArgs' -> prim.equal then
                    (# BCmch: ^ByteCodeMachine;
                       program_name, sig: ^text;
                    do (* Find program name *)
                       (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> program_name[];
                       (* First argument (betanev instance) loaded by dup in genMain *)
                       (* load program name *)
                       out.nl;
                       'ldstr  ' -> out.puttext; program_name[] -> strquote -> out.putln;
                       (* load args[] of main() *)
                       'ldarg.0' -> out.putln;
                       (* Call SetArgValues, which copies main.args to betaenv.ArgVector 
                        * with conversion String->Text of each element
                        *)
                       'call   void class [\'' -> out.puttext;
                       betaenv_clrbody -> out.puttext;
                       '\']\'SetArgValues\'::\'SetArgValues\'(' -> out.puttext;
                       betaenv_signature -> out.puttext;
                       ', '
                       'class [mscorlib]System.String, '
                       'class [mscorlib]System.String[])' -> out.putln;
                    #)
                 else
                    'Primitive NYI: ' -> (prim[] -> ('(' -> (')' -> (arg.copy).append).prepend).prepend).prepend -> fixme;
                if);
             #);
          // callExternal then
             (# prim: ^text;
                pinvoke: @boolean;
                msg: ^text;
             do BC.getText -> prim[];
                (*'CallExternal: '->puttext; prim[] -> putline;*)
                true -> pinvoke;
                find: 
                  (# 
                  do '['->prim.findall(# do false->pinvoke; leave find #)
                  #);
                (if pinvoke then
                    (* platform invoke *)
                    &text[]->msg[];
                    'PInvoke of %s NYI'->msg.putformat(# do prim[]->s #);
                    msg[] -> FIXME;
                    &text[]->msg[];
                    out.nl;
                    '// .method public hidebysig static pinvokeimpl("xxx.dll" cdecl) <returntype> %s(<arguments>) cil managed preservesig {}' 
                      -> msg.putformat(# do prim[]->s #);
                    msg[] -> out.putline;;
                    &text[]->msg[];
                    '  '-> out.puttext;
                    '// call <returntype> [\'yyy\']\'yyy\'::%s(<arguments>'
                      -> msg.putformat(# do prim[]->s #);
                    msg[] -> out.putline;
                 else
                    (* Normal clr call *)
                    out.nl;
                    'call  ' -> out.puttext;  
                    prim[] -> out.puttext;
                    prim[] -> function_stack_delta -> stack_delta;
                if);
             #)
          // comment then
             (# T: ^text
             do BC.gettext -> T[];
                (if trace_comments then
                    out.nl;
                    '/* ' -> out.puttext; 
                    (*T[] -> putline;*) T[] -> out.puttext;
                    ' */ ' -> out.putline;
                if)
             #)
          // position then
             BC.getShort -> line;
             BC.getShort -> column (* Not used for Java *);
             (if generateLineNumbers then
                 (if line>=betafile.length then
                     (* FIXME! *)
                     (if true then
                         out.nl;
                         '// ignored - EOF' -> out.puttext;
                     if);
                  else
                     out.nl;
                     '.line  ' -> out.puttext; 
                     line -> out.putint;
                     ':' -> out.put;
                     column +1 -> out.putint;
                     ' ' -> out.puttext;
                     betafile.entry.path (*.name*) -> (*BackslashToSlash*) escBackSlash -> safequote -> out.puttext;
                 if);
             if);
          else
             (* Opcodes all needing a tab for indentation *)
             out.nl;
             (if opCode
              // nop then
                 (if allow_nop_emit then
                     'nop'->out.putln;
                 if);
              // pushVal then 
                 A.get; A.load; 
              // stVal then
                 A.get; A.store
              // loadRef then
                 (BC.get=1)->A.isValueTypeOrigin; A.get; A.loadRef; false->A.isValueTypeOrigin;
              // loadQRef then
                 A.get; true->A.loadRef
              // pushAdr then
                 A.get; A.pushAdr
              // storeRef then
                 A.get; A.storeRef
              // storeQref then 
                 A.get; (true,false) -> A.storeRef
              // storeOrigin then
                 A.get; (false,true) -> A.storeRef
              // loadOrigin then
                 (# ONlevel,ctag,ftag: @integer; 
                    className, fieldType: ^text;
                 do BC.get -> ONlevel;
                    BC.get -> ctag;
                    (if ctag = 1 then
                        BC.getText -> className[]
                    if);
                    BC.get -> ftag;
                    (if ftag = 1 then
                        BC.gettext -> fieldType[]
                    if);
                    (if isMainMethod then
                        (* reconsider for main/program-slot;
                         * in Java:main, we cannot access class fields;
                         * but we may do in BETA
                         *)
                        'ldnull' -> out.puttext;
                        1 -> stack_delta;
                     else
                        (if ONlevel = 0 then
                            'ldarg.0' -> out.puttext; 1->_n;
                            1 -> stack_delta;
                         else
                            'ldfld  ' -> out.puttext; 5->_n;
                            (if ftag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.orgClass
                                  -> out.puttext; 
                             else
                                fieldType[] -> AddClass -> out.puttext
                            if);
                            ' ' ->out.put;
                            (if ctag = 0 then
                                ONlevel 
                                  -> BCstate.blocks.class
                                  -> safequote 
                                  -> out.puttext
                             else
                                className[] -> safequote -> AddClass -> out.puttext
                            if);
                            '::origin ' -> out.puttext; 3->_n;
                            0 -> stack_delta;
                        if);
                    if)
                 #)
              // cast then
                 BC.gettext -> castClass
              // callInner then
                 'ldarg.0' -> out.puttext; 4->_n;
                 out.nl;
                 1 -> stack_delta;
                 'callvirt ' -> out.puttext;
                 (* NOT in accordance with design - FIX *)
                 'instance void ' -> out.puttext;
                 thisClassName[] -> out.puttext;
                 '::'->out.puttext;
                 thisInnerMethodName[]->out.puttext;
                 '()'->out.puttext;
                 -1 -> stack_delta;
              // call then 
                 (# calltype: @integer;
                    delta: @integer;
                    sig: ^text;
                    isStatic, isValueType: @boolean;
                    loc_val, start, end: @integer;
                 do BC.get -> calltype;
                    callType %Band 1 = 1 -> isStatic;
                    callType %Band 2 = 2 -> isValueType;
                    BC.getText->T[];
                    (*'// call: ' -> out.puttext; T[]->out.putline;*)
                    T[] -> function_stack_delta -> delta;
                    T[] -> AddClass(# omitStatic::trueValue #) -> sig[];
                    (if isValueType and (not isStatic) then
                        'Instance call on ValueType' -> emitcomment; out.nl;
                        (if lastWasAddressOf then
                            'Address already loaded' -> emitcomment; out.nl;
                         else
                            (* If previous was not ldflda, store receiver value type in tmp cell, and ldloca *)
                            (* Find last 'valuetype ' (there may be return type ones before the last one *)
                            'valuetype '->sig.findTextAll(# do inx->start; #); 
                            (* Find method start == type end *)
                            '::'->sig.findTextAll(# do inx-1->end; #);
                            (start,end) -> sig.sub -> allocLocal -> loc_val;
                            loc_val -> storeLocal;
                            loc_val -> loadLocalAddress;
                        if);
                    if);
                    (if true
                     // isStatic then
                        'call'        -> out.puttext;
                        '  '          -> out.puttext;
                     // isValueType then
                        (* Not static *)
                        'call'        -> out.puttext;
                        '  instance ' -> out.puttext;
                     else
                        'callvirt'    -> out.puttext;
                        '  instance ' -> out.puttext;
                    if);
                    2->_n;
                    sig[] -> out.puttext;
                    delta -> stack_delta;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 #)
              // return then
                 (# returncode: @integer;
                    msg: ^text;
                 do (if BC.get->returncode
                     // 0 // 10 then 
                        0 -> check_stack_height;
                        'ret' -> out.puttext;
                        0 -> stack_delta;
                     // 1 // 2 // 3 // 4 // 5 // 6 // 7 // 8 // 11 // 12 // 13 // 14 
                        then
                        1 -> check_stack_height;
                        'ret' -> out.puttext;
                        -1 -> stack_delta;
                     else (* error *) 
                        'xreturn: ' -> msg[];
                        returncode -> msg.putint;
                        msg[] -> FIXME;
                    if);
                 #)
              // beginLab then
                 (# restartLabno: @integer;
                    leaveLabno: @integer;
                 do BC.getLong -> restartlabno;
                    BC.getLong -> leavelabno;
                    (if BC.get = 1 then
                        '.try {' -> out.puttext;
                        out.indent.inc;
                    if);
                 #);
              // endLab then
                 (# restartLabno: @integer;
                    leaveLabno: @integer;
                    exoclass: ^text;
                    loc: @integer;
                 do BC.getLong -> restartlabno;
                    BC.getLong -> leavelabno;
                    (if false then
                        '/*endlab: restart='->out.puttext;
                        restartlabno->out.putint;
                        ', leavelabno='->out.puttext;
                        leavelabno->out.putint; '*/' -> out.putln;
                    if);
                    (if BC.get = 1 then
                        (* End try clause by jumping over handler *)
                        'leave  L' -> out.puttext; leavelabno -> out.putint; 
                        out.indent.dec;
                        out.nl;
                        '} // end .try L' -> out.puttext;
                        restartlabno->out.putint;
                        
                        (* Handler:
                         * if (e.exitobj == this){
                         *	    if (e.labno==restartlabno){
                         *	      /* We have a restart in this object */
                         *              goto Lrestart;
                         *            } else if (e.labno==leavelabno){
                         *	      /* We have a leave in this object */
                         *              goto Lleave;
                         *	    }
                         *	  }
                         * 	  /* Not leave/restart in this object - propagate */
                         * 	  throw;
                         *)
                        out.nl;
                        'catch [\'%s\']ExOException {' 
                          -> out.putformat(# do betaenv_name->s #);
                        out.indent.inc;
                        out.nl;
                        
                        &text[] -> exoclass[];
                        '[\'%s\']ExOException'
                          -> exoclass.putformat(# do betaenv_name->s #);
                        'class ' -> (exoclass.copy).prepend -> allocLocal -> loc;
                        
                        (* Save exception object e in local cell *)
                        loc -> storeLocal;
                        (* Test this[] = e.exitObj *)
                        loc -> loadLocal;
                        'ldfld  object %s::exitobj'
                          -> out.putformat(# do exoclass[]->s #);;
                        out.nl;
                        'ldarg.0' -> out.putln;
                        'bne.un  L%d_rethrow' 
                          -> out.putformat(# do restartlabno->d #);;
                        out.nl;
                        
                        (* Test e.labno=restartlabno *)
                        loc -> loadLocal;
                        'ldfld  int32 %s::labno'
                          -> out.putformat(# do exoclass[]->s #);;
                        out.nl;
                        pushCst(# do restartlabno->i #); out.nl;
                        'bne.un  L%d_testleave' 
                          -> out.putformat(# do restartlabno->d #);;
                        out.nl;
                        'leave  L%d'
                          -> out.putformat(# do restartlabno->d #);;
                        out.nl;
                        
                        'L%d_testleave:'
                          -> out.putformat(# do restartlabno->d #);;
                        out.nl;
                        (* Test e.labno=leavelabno *)
                        loc -> loadLocal;
                        'ldfld  int32 %s::labno'
                          -> out.putformat(# do exoclass[]->s #);;
                        out.nl;
                        pushCst(# do leavelabno->i #); out.nl;
                        'bne.un  L%d_rethrow' 
                          -> out.putformat(# do restartlabno->d #);;
                        out.nl;
                        'leave  L%d'
                          -> out.putformat(# do leavelabno->d #);;
                        
                        (* retrow to outer handler *)
                        2 -> out.indent.dec;
                        out.nl;
                        'L%d_rethrow:' 
                          -> out.putformat(# do restartlabno->d #);
                        2 -> out.indent.inc;
                        out.nl;
                        'rethrow' -> out.puttext;
                        loc -> releaseLocal;
                        out.indent.dec;
                        out.nl;
                        '} // end catch L' -> out.puttext;
                        restartlabno->out.putint;
                    if);
                 #);
              // break then
                 (# labno: @integer;
                    re_start: @integer;
                 do BC.getLong -> labno;
                    BC.get -> re_start;
                    (* exitObj already pushed *)
                    pushCst(# do labno -> i #); 
                    out.nl;
                    'newobj  instance void [\'%s\']ExOException::.ctor(object,int32)' -> out.Putformat(# do betaenv_name->s #);
                    out.nl;
                    'throw' -> out.puttext;
                 #)
              // cmpToBool
              // cmpToBoolFloat then
                 (if trace_compares then
                     'cmpToBool' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpToBoolRef then
                 (if trace_compares then
                     'cmpToBoolRef' -> emitcomment;
                 if);
                 BC.get -> emitCmpToBool
              // cmpAndJmp then
                 (if trace_compares then
                     'cmpAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.getShort,BC.get) -> emitCmpJmp
              // cmpAndJmpFloat then
                 (BC.get,BC.get,BC.getShort,0) -> emitCmpJmp
              // cmpBoolAndJmp then
                 (if trace_compares then
                     'cmpBoolAndJmp' -> emitcomment;
                 if);
                 (BC.get,BC.get,BC.getShort) -> emitCmpBoolJmp
              // pushCst_s8 then
                 pushCst(# c: @int8 (* CAREFULL: char is unsigned! *);
                        do BC.get->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s16 then
                 pushCst(# c: @int16;
                        do BC.getshort->c;
                           c -> i (* sign extend *);
                        #);
              // pushCst_s32 then
                 pushCst(# 
                        do BC.getlong->i;
                        #);
              // pushRealCst then
                 'ldc.r8  '  -> out.puttext;
                 (BC.getLong, BC.getLong) -> ints2real -> out.putreal;
              // pushVal then
                 'pushVal'->out.puttext
              // pushNone then
                 'ldnull' -> out.puttext;
                 1 -> stack_delta;
              // dup then
                 BC.get -> arg1; (* pos *)
                 BC.get -> arg2; (* type *)
                 (# type1, type2: ^text;
                 do BC.getText -> type1[];
                    BC.getText -> type2[];
                    (if arg2
                     // 0 then
                        (* duplicate int32 *)
                        (if arg1
                         // 0 then 
                            'dup' -> out.puttext;
                            1 -> stack_delta;
                         // 1 then
                            ('int32', type1[]) -> simulate_dup_x1;
                         // 2 then 
                            ('int32', type1[], type2[]) -> simulate_dup_x2;
                        if)
                     // 1 then 
                        (* duplicate double *) 
                        (if arg1
                         // 0 then 
                            'dup' -> out.puttext;
                            1 -> stack_delta;
                         // 1 then
                            ('int64', type1[]) -> simulate_dup_x1;
                         // 2 then 
                            ('int64', type1[], type2[]) -> simulate_dup_x2;
                        if)
                     // 2 then
                        (if arg1
                         // 0 then 
                            (* duplicate: array, index *)
                            (type1[],type2[]) -> simulate_dup2;
                         // 1 then
                            (* duplicate 2 int32 *)
                            ('int32','int32', type1[]) -> simulate_dup2_x1;
                         // 2 then
                            (* duplicate 2 int32 *)
                            ('int32','int32', type1[], type2[]) -> simulate_dup2_x2;
                        if)
                    if)
                 #);
              // pop then
                 'pop' -> out.puttext;
                 -1 -> stack_delta;
              // pop2 then
                 'pop' -> out.puttext;
                 -1 -> stack_delta;
              // _loadLocal then
                 (* 'BCdotnetBody: bytecode LoadLocal' -> screen.putline;*)
                 MappedLocals[lastMappedLocal]-1 -> loadLocal;
              // loadRange then 
                 'ldlen' -> out.puttext;
                 0 -> stack_delta;
              // pushReg then
                 '// pushReg '->out.puttext;
                 dumpReg
              // end then
                 '\n/* end */' -> out.putline;
              // pushText then
                 'ldstr'->out.puttext;
                 ' '->out.put; 
                 BC.getText->emitString;
                 1 -> stack_delta;
              // jmp then
                 (if true then
                     (* Notice: br can NOT be used to branch out of try block.
                      * See ECMA 335, Partition I, section 11.4 Control Flow
                      *)
                     'br'->out.puttext;
                  else
                     '\nUsing leave instead of br' -> putline;
                     'leave' -> out.puttext;
                 if);
                 BC.get (* opcode label *); 
                 BC.getshort -> labs.use;
                 0 -> stack_delta;
              // breakSimple then
                 (* Notice: br can NOT be used to branch out of try block.
                  * See ECMA 335, Partition I, section 11.4 Control Flow
                  *)
                 'leave' -> out.puttext;
                 BC.getlong -> labs.use;
                 0 -> stack_delta;
              // jmpt then
                 BC.get (* opcode label *); 
                 BC.gettext (* Entry to go to *);
                 'Opcode JmpT' -> FIXME;
              // cmp then
                 'cmp'->out.puttext
              // r64toR32 then
                 'conv.r4'->out.puttext;
              // r64add then
                 'add'->out.puttext;
                 -2 -> stack_delta;
              // r64Sub then
                 'sub'->out.puttext;
                 -2 -> stack_delta;
              // r64Mul then
                 'mul'->out.puttext;
                 -2 -> stack_delta;
              // r64Div then
                 'div'->out.puttext;
                 -2 -> stack_delta;
              // r64Neg then
                 'neg'->out.puttext;
              // int2double then
                 'conv.r8'->out.puttext;
                 0 -> stack_delta;
              // double2int then
                 'conv.i4'->out.puttext;
                 0 -> stack_delta;
              // int64ToInt32 then
                 'conv.i4'->out.puttext;
                 0 -> stack_delta;
              // int32ToInt64 then
                 'conv.i8'->out.puttext;
                 0 -> stack_delta;
              // r32ToR64 then
                 'conv.r8'->out.puttext;
                 0 -> stack_delta;
              // r64ToR32 then
                 'conv.r4'->out.puttext;
                 0 -> stack_delta;
              // func then
                 (# f: @integer;
                    delta: @integer;
                 do BC.get -> f -> trace_opcode;
                    (if f
                     // add then
                        'add'->out.puttext; 1->_n;
                        -1 -> delta;
                     // sub then
                        'sub'->out.puttext;
                        -1 -> delta;
                     // orr then
                        'or'->out.puttext;
                        -1 -> delta;
                     // andd then
                        'and'->out.puttext;
                        -1 -> delta;
                     // xorr then
                        'xor'->out.puttext;
                        -1 -> delta;
                     // nott then
                        (* boolean not *)
                        'ldc.i4.0\n' -> out.putln;
                        'ceq' -> out.puttext;
                        0 -> delta;
                        out.newline;
                     // mult then
                        'mul'->out.puttext;
                        -1 -> delta;
                     // divv then
                        'div'->out.puttext;
                        -1 -> delta;
                     // modd then
                        -1 -> delta;
                        'rem'->out.puttext;
                     // logNot then
                        (* bit not *)
                        'not'->out.puttext;
                        0 -> delta;
                     // neg then
                        'neg'->out.puttext;
                        0 -> delta;
                     // logicalShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // arithShiftLeft then 
                        'shl'->out.puttext;
                        -1 -> delta;
                     // logicalShiftRight then 
                        'shr.un'->out.puttext;
                        -1 -> delta;
                     // arithShiftRight then 
                        'shr'->out.puttext;
                        -1 -> delta;
                     // rotateLeft then
                        (* Perform i %rol r *)
                        (* Implemented as:
                         *   (i << r) | ((i & ((1<<r)-1)) >> (32-r))
                         *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           loc_i -> loadLocal;
                           'ldc.i4.1' -> out.putln;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           'ldc.i4.1' -> out.putln;
                           'sub' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4.s   32' -> out.putln;
                           loc_r -> loadLocal;
                           'sub' -> out.putln;
                           '\shr' -> out.putln;
                           'or' -> out.puttext;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #)
                     // rotateRight then
                        (* Perform i %ror r *)
                        (* Implemented as:
                         *   (i >> r) | ((i & ((1<<r)-1)) << (32-r))
                         *)
                        (* initial stack: r, i *)
                        (# loc_i, loc_r: @integer;
                        do (* initial stack: r, i *)
                           'int32' -> allocLocal -> loc_i;
                           'int32' -> allocLocal -> loc_r;
                           loc_r -> storeLocal;
                           loc_i -> storeLocal;
                           loc_i -> loadLocal;
                           loc_r -> loadLocal;
                           'shr' -> out.putln;
                           loc_i -> loadLocal;
                           'ldc.i4.1' -> out.putln;
                           loc_r -> loadLocal;
                           'shl' -> out.putln;
                           'ldc.i4.1' -> out.putln;
                           'and' -> out.putln;
                           'sub' -> out.putln;
                           'ldc.i4.s  32' -> out.putln;
                           loc_r -> loadLocal;
                           'sub' -> out.putln;
                           'shl' -> out.putln;
                           'or' -> out.puttext;
                           loc_i -> releaseLocal;
                           loc_r -> releaseLocal;
                           -1 -> delta;
                        #);
                     // byteswapshort then
                        (* Implemented as 
                         *   (x & 0xffff0000)
                         *   |
                         *   (((x>>8) & 0xff) | ((x<<8) & 0xff00))
                         *)
                        (* stack: x *)
                        (# loc_x: @integer;
                        do (* initial stack: x *)
                           'unsigned int32' -> allocLocal -> loc_x;
                           'conv.u4' -> out.putln;
                           'dup' -> out.putln;
                           loc_x -> storeLocal;
                           'ldc.i4  0xffff0000' -> out.putln;
                           'and' -> out.putln;
                           loc_x -> loadLocal;
                           'ldc.i4.8' -> out.putln;
                           'shr.un' -> out.putln;
                           'ldc.i4  0xff' -> out.putln;
                           'and' -> out.putln;
                           loc_x -> loadLocal;
                           'ldc.i4.8' -> out.putln;
                           'shl' -> out.putln;
                           'ldc.i4 0xff00' -> out.putln;
                           'and' -> out.putln;
                           'or' -> out.putln;
                           'or' -> out.puttext;
                           loc_x -> releaseLocal;
                        #);
                     // byteswaplong then
                        (* Implemented as
                         *  // ABCD -> DCBA
                         * uint AB = (ABCD>>16);
                         * uint CD = (uint)(ABCD & 0xffff);
                         * uint BA = (uint)((AB>>8) | ((AB & 0xff)<<8));
                         * uint DC = (uint)((CD>>8) | ((CD & 0xff)<<8));
                         * uint DCBA = (DC << 16) | BA;
                         * return DCBA;
                         *)
                        (# loc: @integer;
                        do (* stack: ABCD, ... *)
                           'int32' -> AllocLocal -> loc;
                           loc -> storeLocal;
                           loc -> loadLocal;
                           'ldc.i4  0xffff' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4.8' -> out.putln;
                           'shr.un' -> out.putln;
                           loc -> loadLocal;
                           'ldc.i4  0xffff' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4  0xff' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4.8' -> out.putln;
                           'shl' -> out.putln;
                           'or' -> out.putln;
                           'ldc.i4.s  16' -> out.putln;
                           'shl' -> out.putln;
                           loc -> loadLocal;
                           'ldc.i4.s  24' -> out.putln;
                           'shr.un' -> out.putln;
                           loc -> loadLocal;
                           'ldc.i4.s  16' -> out.putln;
                           'shr.un' -> out.putln;
                           'ldc.i4  0xff' -> out.putln;
                           'and' -> out.putln;
                           'ldc.i4.8' -> out.putln;
                           'shl' -> out.putln;
                           'or' -> out.putln;
                           'or  ' -> out.putln;
                           loc -> releaseLocal;
                        #);
                     else
                        (# msg: ^text;
                           _f: @integer;
                        do 'Unhandled bytecode' -> msg[];
                           (if (32<=f) and (f<=126) then
                               f -> _f;
                               ' \'%c\'' -> msg.putformat(# do _f->c #);
                           if);
                           ' func.' -> msg.append;
                           f -> asText -> msg.append;
                           ' ('->msg.append;
                           f->msg.putint;
                           ')' -> msg.put;
                           msg[] -> fixme;
                        #);
                    if);
                    delta -> stack_delta;
                    99->_n;
                 #)
              else
                 (# msg: ^text;
                 do 'Unhandled bytecode ' -> msg[];
                    (if (32<=opcode) and (opcode<=126) then
                        '\'%c\' ' -> msg.putformat(# do opcode->c #);
                    if);
                    opcode -> asText -> msg.append;
                    ' ('->msg.append;
                    opcode->msg.putint;
                    ')' -> msg.put;
                    msg[] -> fixme;
                 #);
             if);
         if);
         (opcode = jmp)  -> previousWasJmp;
         restart read;
     if);
   out.close
#)  

-- LIB:attributes--
safequote:
  (# T: ^text;
  enter T[]
  do (if T.lgth>0 then
         (if (not (('class [')->((1,7)->T.sub).equal)) and 
             (not (('valuetype [')->((1,11)->T.sub).equal)) and 
             (not (T.T[1]='[')) and 
             (not (T.T[1]='\'')) and 
             (not (T.T[T.lgth]='\'')) then 
             T.copy -> T[];
             '\''->T.prepend;
             '\''->T.append; 
         if);
     if)
  exit T[]
  #);
strQuote:
  (# T: ^text;
  enter T[]
  do (if T.lgth>0 then
         (if (not (T.T[1]='\"')) and 
             (not (T.T[T.lgth]='"')) then 
             T.copy -> T[];
             '"'->T.prepend;
             '"'->T.append; 
         if);
     if)
  exit T[]
  #);
unQuote:
  (# t: ^text;
  enter t[]
  do (if ((1 -> t.inxGet) = '"') AND ((t.length -> t.inxGet) = '"') then
         (2, t.length - 1) -> t.sub -> t[];
     if);
  exit t[]
  #);

unTick:
  (# t: ^text;
  enter t[]
  do (if ((1 -> t.inxGet) = '\'') AND ((t.length -> t.inxGet) = '\'') then
         (2, t.length - 1) -> t.sub -> t[];
     if);
  exit t[]
  #);

textHashTable: hashTable
  (# element::<(# T: ^text #);
     honeyM: @honeyMan;
     initialized: @boolean;
     init::< (# do honeyM.init; INNER; true -> initialized; #);
     hashFunction::<(# do e.t[]-> honeyM.hash -> value; INNER #);
     equal::< (# do left.t[]->right.t.equal->value; INNER #);
     get:<
       (# T: ^text;
          E: ^element;
          was_there: @boolean;
       enter T[]
       do T[] -> unTick -> unQuote -> unTick -> T[];
          (if not initialized then init if);
          &element[] -> e[];
          T[] -> e.T[];
          e[]->hashfunction->findIndexed
          (# predicate:: (# do (T[]->current.t.equal)->value; #);
          do current[]->e[];
             true->was_there;
          #);
          INNER;
       exit was_there
       #);
     add:<
       (* Returns true if T was not already here *)
       (# T: ^text;
          E: ^element;
          was_inserted: @boolean;
       enter T[]
       do T[] -> unTick -> unQuote -> unTick -> T[];
          (if not initialized then init if);
          &element[] -> e[];
          T[] -> e.T[];
          INNER;
          e[]->hashfunction->findIndexed
          (# predicate:: (# do (T[]->current.t.equal)->value; #);
             notFound:: (# do e[] -> insert; true -> was_inserted #)
          do current[]->e[] (* Only when found *)
          #);
       exit was_inserted
       #);
  #);

assemblyinfohashtable: texthashtable
  (# element::< (# version, publickeytoken: ^text; #);
     get::< (# version, publickeytoken: ^text;
            do E.version[] -> version[];
               E.publickeytoken[] -> publickeytoken[];
            exit (version[], publickeytoken[])
            #);
     add::< (# version, publickeytoken: ^text;
            enter (version[], publickeytoken[])
            do version[] -> E.version[];
               publickeytoken[] -> E.publickeytoken[];
            #);
  #);

---emitJasmin:dopart--
do 
---FieldsNewJasmin:descriptor--
(# #)
---FieldsEmitInitItemJasmin:descriptor---
(# #)
