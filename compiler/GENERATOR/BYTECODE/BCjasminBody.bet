ORIGIN 'BCmachineBody';

--FieldsNewJasmin:descriptor--
(# 
do (if methodClassTag 
    // 'c' // 'p' // '[' then
       '.field '->out.puttext; 
       FN[] -> out.puttext;
       ' ' -> out.puttext; 
       (if methodClassTag = '[' then '[' -> out.put if);
       T[] -> out.puttext;
   if);
#)

--FieldsEmitInitItemJasmin:descriptor--
(# class: ^ text
do (if currentTag 
    // 'p' (* part object*) 
    // '[' then (* skip *)
    else        
       '\taload_0\n' -> out.puttext;
       (if true
        // 'I' -> currentType.equal 
        // 'C' -> currentType.equal then
           '\tbipush 0\n' -> out.puttext;
        else
           '\taconst_null \n' -> out.puttext
       if);
       '\tputfield ' -> out.puttext;
       thisClassName[] -> out.puttext;
       '/' -> out.puttext;
       currentFieldName[] -> out.puttext;
       ' ' -> out.puttext;
       (if currentTag = '[' then '[' -> out.put if);
       currentType[] -> out.putline;
   if)     
#)

-- emitJasmin: DoPart --
do (# thisClassName                (* name of current class           *)
      ,thisOrgName                 (* name of current origin class    *)
      ,thisSuperName               (* name of current super           *)
      ,thisSuperOrgName            (* nameof origin of current super  *)
      ,thisSignature               (* signature of current method     *)
      ,thisInnerMethodName: ^text; (* name of a possible inner method;
                                    * or the name of method 'main'
                                    *)
      thisBlockLevel,
      subLevel: @integer; (* current subpattern level *)
      class: ^text;       (* name of class being called - 
                           * used by subsequent init - ugly
                           *)
      isMainMethod: @boolean; (* true if generating code for main method *)
      localLabNo: @integer; (* counter for local labels as generated by
                             * e.g. cmpToBool
                             *)
      opMap: [500] ^text;
      init:
        (# 
        do 1000 -> localLabNo; (* we should fix this to avoid clash
                                * with label numbers genearted by 
                                * the synthesezer
                                *)
           'bipush '->opMap[pushCst_s8][];
           'sipush '->opMap[pushCst_s16][];
           'ldc '->opMap[pushCst_s32][];
           'return\n.end method'->opMap[return][];
           'call\t'->opMap[call][];
           'goto '->opMap[jmp][];
           'nop ' -> opMap[nop][];
           ''->opMap[func][];
           ''->opMap[end][]
        #);
      emitImports:
        (#
        do (*'\nImportJasmin:'->putline;
            out.name -> putline;
           '! ImportJasmin: '->out.puttext;
           out.name -> out.putline;
           *)
           imports.scan
           (#
           do '; import: ' -> out.puttext;
              current[] -> out.putText; 
              (*current[] -> putline;
              '! ImportJasmin: '->out.puttext;
              current[] -> out.putline;  *)            
              out.newline;
           #);
        #);
      dumpOpCode:
        (# opCode: @integer
        enter opCode
        do
           (if opMap[opCode][] <> none then
               opMap[opCode][]->out.puttext
            else
               opCode->asText->out.puttext
           if)
        #);
      astext:
        (# opCode: @integer; T: @text
        enter opCode
        do
           (if opCode
            // pushCst_s8 then
               'pushCst_s8'->T
            // pushVal then
               'pushVal'->T
            // pushReg then
               'pushReg'->T
            // stVal then
               'stVal'->T
            // index then
               'index'->T
            // cmpAndJmp then
               'cmpAndJmp'->T
            // call then
               'call'->T
            // callInner then 'callInner' -> T
            // newVirt then 'newVirt' -> T
            // return then
               'return\n'->T
            // label then
               'L'->T
            // callPrim then
               'callPrim'->T
            // end then
               'end'->T
            // pushText then
               'ldc'->T
            // pushAdr then
               'pushAdr'->T
            // loadRef then
               'loadRef' -> T
            // storeRef then
               'storeRef'->T
            // storeQref then
               'storeQref'->T
            // dup then 'dup' -> T
            // pop (* //'pop': OOPS char expected here *) then 'pop' -> T
            // loadRange then 'arraylength' -> T
            // jmp then
               'jmp'->T
            // func then
               'FUNC'->T
            // add then
               'iadd'->T
            // sub then
               'isub'->T
            // orr then
               'ior'->T
            // andd then
               'iand'->T
            // xorr then
               'ixor'->T
            // cmp then
               'cmp'->T
            // mult then
               'imul'->T
            // divv then
               'idiv'->T
            // modd then
               'irem'->T
            // nott then
               'not'->T
            // logNot then
               'logNot'->T
            // neg then
               'ineg'->T
            // logicalShiftLeft  then 'ishl'->T
            // logicalShiftRight then 'ishr'->T (* perhaps this is wrong *)
            // arithShiftLeft    then 'ishl' -> T
            // arithShiftRight   then 'ishr' -> T
            else
               '?'->T; opCode->T.putint; '?'->T.put
           if)
        exit T[]
        #);
      emitMemOp:
        (# op: ^text; varNo: @integer;
        enter(op[],varNo)
        do (if varNo > 0 then
               (* currently we assume that local variables have
                * addresses: 0,12,16,20,... that are 
                * mapped to: 0, 1, 2, 3,...
                * address 0 represents this
                *)
               (varNo div 4) - 2 -> varNo;
           if);
           op[] -> out.puttext;
           (if varNo <= 3 then '_' -> out.put else ' ' -> out.put if);
           varNo -> out.putint               
        #);
      dumpReg:
        (# 
        do '; assume register on stack: regno=' -> out.puttext;
           BC.get -> out.putint           
        #);
      getReg: (#  exit BC.get #);
      Address:
        (#
           reg,off,size,isField,ONlevel: @integer; 
           fieldName,descName,fieldType: ^text;
           get: 
             (# hasFieldName: @integer
             do getReg->reg; 
                (if (BC.get -> hasFieldName) = 1 then
                    BC.gettext -> fieldName[]
                if);
                
                BC.get->off; BC.get->size; 
                BC.get->ONlevel; BC.get -> isField; 
                (if isField = 1 then
                    BC.getText -> descName[]
                 else
                    none -> descName[]
                if);
                (if BC.get = 1 then
                    BC.getText -> fieldType[]
                 else
                    none -> fieldType[]
                if);
                (if false (*isMainMethod*) then 
                    (* to prevent variables in main to be
                     * interpreted as fields in the object;
                     * main has no this, so main varaibles must
                     * be local variables in main; this is perhaps
                     * only a problem when not using switch 186
                     *)
                    0 -> isField 
                if)
             #);
           emitField:
             (# isOrigin: @boolean
             enter isOrigin
             do (if isField = 1 then
                    descName[] -> out.putText;
                 else 
                    (* this part should be eliminated *)
                    ONlevel -> BCstate.blocks.class -> out.puttext;
                    'emitfield' -> blocksCall
                if);
                (if isOrigin then
                    '/origin ' -> out.puttext
                 else
                    '/' -> out.put;
                    fieldName[] -> out.puttext;
                    ' '->out.put;
                if)
             #);
           emitType:
             (#
             do (if fieldType[] <> none then
                    (if (fieldType.length <= 2) or
                        ((fieldType.length -> fieldType.inxGet) = ';')
                        then
                        (if isField=2 then '[' -> out.put if);
                        fieldType[] -> out.puttext
                     else
                        (* we do come here, but we should perhaps fix this *)
                        fieldType[] -> emitSignature
                    if)
                 else
                    'I' -> out.put;
                    '   ; OBS! missing type info (fieldType)' -> out.puttext;
                if);
             #);
           load:
             (#
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            'iaload' -> out.puttext
                         // 'C' -> fieldType.equal then
                            'caload' -> out.puttext
                         else
                            'iaload' -> out.puttext;
                            ' ; wrong fieldType ' -> out.puttext
                        if)
                     else
                        'iaload' -> out.puttext;
                        ' ; missing fieldType ' -> out.puttext
                   if)
                 else
                    (if ONlevel > 0 then
                        'getfield ' -> out.puttext;
                        emitField;
                        emitType
                     else
                        (if isField=1 then
                            'getfield ' -> out.puttext;
                            emitField;
                            emitType
                         else
                            (* method field *)
                            ('iload',off) -> emitMemOp
                        if)
                if)if)
             #);
           store:
             (# 
             do (* local field - object/method ??*)
                (if isField = 2 then
                    (* array *)
                    (if fieldType[] <> none then
                        (if true
                         // 'I' -> fieldType.equal then
                            'iastore' -> out.puttext
                         // 'C' -> fieldType.equal then
                            'castore' -> out.puttext
                         else
                            'iastore' -> out.puttext;
                            ' ; unknown fieldType ' -> out.puttext
                        if)
                     else
                        'iastore' -> out.puttext;
                        ' ; missing fieldType ' -> out.puttext
                    if)
                 else
                    (if ONlevel > 0 then
                        'putfield ' -> out.puttext;
                        emitField;
                        emitType;
                     else
                        (if isField=1 then
                            'putfield ' -> out.puttext;
                            emitField; 
                            emitType;
                         else
                            ('istore',off) -> emitMemOp
                        if)
                if)if)
             #);
           storeRef:
             (# withQua,isOrigin: @boolean; class: ^text
             enter(withQua,isOrigin)
             do BC.gettext -> class[];
                (if withQua then
                    'checkcast ' -> out.puttext;
                    (* remove enclosing 'L...;' *)
                    (2,class.length-1) -> class.sub -> out.puttext;
                    '\n\t'->out.puttext
                if);
                (if ONlevel > 0 then
                    'putfield ' -> out.puttext; 
                    isOrigin -> emitField; 
                    class[] -> (*emitSignature*) out.puttext
                 else 
                    (if isField = 1 then
                        'putfield ' -> out.puttext; 
                        isOrigin -> emitField;
                        class[] -> (*emitSignature*) out.puttext
                     else                       
                        ('astore',off) -> emitMemOp
                    if)
                if);
             #);
           loadRef:
             (# withQua: @boolean; sig: ^text
             enter withQua
             do BC.gettext -> sig[];
                (if ONlevel > 0 then
                    'getfield ' -> out.puttext;
                    emitField; 
                    sig[] -> (*emitSignature*)  out.puttext
                 else 
                     (if isField = 1 then
                         'getfield ' -> out.puttext; 
                         emitField; 
                         sig[] -> (*emitSignature*)out.putText
                      else 
                         ('aload',off) -> emitMemOp
                if)if); 
                (if withQua then
                    (*sig[] -> puttext;*)
                    '\n\tcheckcast ' -> out.puttext;
                    BC.gettext -> sig[]; 
                    (2,sig.length-1) -> sig.sub -> out.puttext
                if);
                ' ; ' -> out.puttext;
                (if fieldName[] <> none then
                    fieldName[] -> out.puttext
                 else
                    'OBS! missing fieldName' -> out.puttext
                if)                
             #);
           pushAdr:
             (#
             do (if off = 0 then
                    (if reg
                     // thisO then
                        'aload_0' -> out.puttext;
                     else
                        '; Warning: pushAdr:register not this'->out.puttext
                    if)
                 else
                    '; Warning: pushAdr:registeroff <>0'
                    '\n\t' 
                      ->out.puttext;
                    load
                if)
             #);
           dump:
             (# 
             do
                (if size = 0 then 4->out.putint else size->out.putint if);
                '.'->out.put;
                (if reg
                 // thisO then  // callO then '%call.'->out.puttext
                 else
                    '%top.'->out.puttext
                if);
                off->out.putint
             #);
           display:
              (# 
              do ' reg:'-> puttext; reg -> putint;
                 ' off:'-> puttext; off-> putint;
                 ' size:'->puttext; size -> putint; 
                 ' ONlevel:'->puttext; ONlevel -> putint;
                 ' isField:'->puttext; isField -> putint;
                 (if isField = 1 then
                     descName[] -> puttext
                 if)
             #);
        #);
      emitLocals:
        (#
        do '\t.limit stack 8\n'
           '\t.limit locals 8\n'
         (*  '\taconst_null\n'
           '\tastore_1\n'*)
             -> out.puttext;                          
        #);
      emitSignature:
        (# sig: ^text
        enter sig[]
        do (if (1->sig.inxGet) = '[' then
               (* this should really be handled at a higher level *)
               sig[] -> out.puttext
            else
               'L' -> out.puttext; sig[] -> out.puttext; ';' -> out.puttext
           if)
        #);
      emitString:
        (# T: ^text; 
        enter T[]
        do '"'->out.put; 
           T.scanAll
           (#
           do (if ch
                  (* we should handle more special characters
                   * and generate the form '\n';
                   * currently other special chars are generated
                   * as octal values '\001'
                   *)
               // ascii.newline then
                  '\\'->out.put; 'n'->out.put
               // '"' then '\\'->out.put; '"'->out.put
               // '\\' then '\\'->out.put; '\\'->out.put
               else 
                  (if ch < ' ' then
                      '\\'-> out.put;
                      '0' + (ch div 64) -> out.put;
                      ch mod 64 -> ch;
                      '0' + (ch div 8) -> out.put;
                      ch mod 8 -> ch;
                      '0' + ch -> out.put
                   else                  
                      (if ch > 255 then
                          ' ' -> out.put;
                       else
                          ch->out.put 
                      if);
                  if)
              if)
           #);
           '"'->out.put; 
        #);
      newArray:
        (# type: ^text
        enter type[]
        do (* java arrays are 0:range-1;
            * we add one to BETA range; 
            * this gives an extra index 0
            * which will not give rise to index errors
            * must be fixed in some way
            *)
          (* '\tbipush 1\n\tiadd\n' -> out.puttext;*)
           '\tnewarray ' -> out.puttext; type[] -> out.puttext
        #);
      emitCmpJmp:
        (# cond,L,lab: @integer
        enter(cond,L,lab)
        do (if cond
            // 1 (* =  *) then
               'if_icmpeq' -> out.puttext 
            // 2 (* <> *) then
               'if_icmpne' -> out.puttext 
            // 3 (* <  *) then
               'if_icmplt' -> out.puttext 
            // 4 (* <= *) then
               'if_icmple' -> out.puttext 
            // 5 (* >  *) then
               'if_icmpgt' -> out.puttext 
            // 6 (* >= *) then
               'if_icmpge' -> out.puttext 
           if);
           '\tL'->out.puttext;
           lab -> out.putint
        #);
      emitCmpBoolJmp:
        (# cond,L,lab: @integer
        enter(cond,L,lab)
        do (if cond
            // 1 (* =  *) then
               'ifeq' -> out.puttext 
            // 2 (* <> *) then
               'ifne' -> out.puttext 
            // 3 (* <  *) then
               'iflt' -> out.puttext 
            // 4 (* <= *) then
               'ifle' -> out.puttext 
            // 5 (* >  *) then
               'ifgt' -> out.puttext 
            // 6 (* >= *) then
               'ifge' -> out.puttext 
           if);
           '\tL'->out.puttext;
           lab -> out.putint
        #);
      emitLabDef:
        (# labNo: @integer
        enter labNo
        do 'L'-> out.put; labNo -> out.putint; ':\n' -> out.puttext
        #);
      emitLabRef:
        (# labNo: @integer
        enter labNo
        do 'L'-> out.put; labNo -> out.putint; out.newline
        #);
      
      IOcall:
        (# routine: ^text; hasArg: @boolean
        enter(routine[],hasArg)
        do '\tgetstatic java/lang/System/out Ljava/io/PrintStream;\n'
             -> out.puttext;
           (if hasArg then '\tswap\n' -> out.puttext if);
           '\tinvokevirtual ' -> out.puttext; 
           routine[] -> out.puttext
        #);
      blocksCall:
        (# T: ^text
        enter T[]
        do (if false then
               '\nBlocks:' -> puttext; T[] -> putline;
               (dumpStack,'blocksCall') -> stop
           if)
        #);
      opCode,arg1: @integer; 
      A: @Address;
      T: ^text;
   do init;
      emitImports;
      read:
        (if opCode <> end then
            BC.get->opCode; 
            (* opCode:'->puttext; opCode -> putint; ' ' -> put;*)
            (if opCode
             // classDef then
                '.class '->out.puttext;
                BC.gettext
                  -> thisClassName[]
                  -> out.putLine;
                BC.get -> thisBlockLevel;
                (thisBlockLevel,thisClassname[]) -> BCstate.blocks.mark;
                '.super ' -> out.puttext;
                BC.getText -> thisSuperName[] -> out.putline;
                'java/lang/Object'->thisSuperOrgName[];
                BC.get -> subLevel; 
                BC.gettext -> thisOrgName[];
                '.field origin '
                  -> out.puttext;
                thisOrgName[] -> out.puttext;
                313->ctrace(# do '%%%class: "'->xT;
                              thisClassName[] -> xT;
                              '" blocklevel: ' -> xT;
                              thisBlockLevel -> xI; xN;
                              'super: "'->xT;
                              thisSuperName[] -> xT; 
                              '" sublevel: ' -> xT;
                              subLevel -> xI
                           #);
                
                BCstate.fields.init
                
             // endClass then (* skip *)

             // methodDef then
                (# aux,noOfEnterArgs: @integer; (* 0 or 1 *)
                do BC.gettext -> thisInnerMethodName[];  
                   BC.gettext -> thisSignature[];
                   BC.get -> noOfEnterArgs;
                   BC.get -> aux;
                   (* '\nMethdDef: ' -> puttext;
                   thisSignature[] -> putline;
                   ' noOfArgs: ' -> puttext;
                   noOfEnterArgs -> putint;
                   ' Signature:'->puttext;
                   ' InnerName;' -> puttext;
                    thisInnerMethodName[] -> puttext;*)
                   
                   (if 'main' -> thisInnerMethodName.equal then
                       '\n.method public static '
                       'main([Ljava/lang/String;)V\n'
                         -> out.puttext;
                       true -> isMainMethod
                    else
                       false -> isMainMethod;
                       (if aux = 0 then
                           (*newline;
                           thismethodname[] -> puttext;
                           ' has inner'->putline;*)
                           '\n.method ' -> out.puttext;
                           thisInnerMethodName[]-> out.puttext;
                           '()V\n'
                           '\treturn\n' -> out.puttext;
                           '.end method\n' -> out.puttext;
                       if);
                       
                       '\n.method ' -> out.puttext; 
                       thisSignature[] ->out.puttext; 
                       out.newline
                   if);    
                   emitLocals;
                #)
             // initCons then

                '.method public <init>(' -> out.puttext;
                thisOrgName[] -> out.puttext;
                ')V\n'
                '\t.limit  stack 8\n'
                '\t.limit locals 3\n' -> out.puttext;
                
             // field then
                (# F: @text
                do 'F' -> F; BC.get->F.putInt; 
                   (if BC.get = 1 then
                       (F[],BC.gettext,BC.gettext,BC.get) 
                         -> BCstate.fields.new
                    else
                       (F[],'???',BC.gettext,BC.get) 
                         -> BCstate.fields.new
                   if)
                #)
             // labelDef then
                '  L'->out.puttext; BC.get->out.putint; 
                ':'->out.put; '\t'->out.put
             // callPrim then
                (# prim,arg: ^text
                do BC.gettext -> prim[];
                   BC.getText -> arg[];
                   (if true 
                    // 'new' -> prim.equal then
                       '\tnew '-> out.puttext;
                       arg[] -> out.puttext; (* class name*)
                       '\n\tdup' -> out.puttext;
                       arg[] -> class[]; (* ugly *)                       
                    // 'initSuper' -> prim.equal then                       
                       '\tinvokenonvirtual ' -> out.puttext;
                       thisSuperName[] -> out.puttext;
                       '/<init>(' -> out.puttext;
                       (if not ('-'->arg.equal) then
                           arg[] -> emitSignature
                       if);
                       ')V\n' -> out.puttext;
                       BCstate.fields.emitInit;
                    // 'init' -> prim.equal  then
                       '\tinvokenonvirtual ' -> out.puttext;
                       class[] -> out.puttext;
                       '/<init>(' -> out.puttext;
                       (if not ('-'->arg.equal) then
                           arg[] -> emitSignature
                       if);
                       ')V' -> out.puttext
                    // 'AlloVR4' -> prim.equal then
                       'int' -> newArray
                    // 'AlloVR1' -> prim.equal then
                       'char' -> newArray  
                    // 'Text2CharArray' -> prim.equal then
                       '\tinvokevirtual java/lang/String/toCharArray()[C'
                         -> out.puttext
                    // 'Text2BetaText' -> prim.equal then
                       (* Note! Hardcoding of pattern 'text'
                        * including case, etc. Should be handled
                        * more generally
                        *)
                       (if true then
                           '\tinvokevirtual '
                           'java/lang/String/toCharArray()[C\n'
                           '\tnew text\n'
	                   '\tdup_x1\n'
	                   '\tdup_x1\n'
	                   '\taconst_null\n'
	                   '\tinvokespecial text/<init>(Ltstenv;)V\n'
	                   '\tinvokevirtual text/enter([C)V'
                           -> out.puttext
                        else
                           '\tgetstatic tstenv Ltstenv;\n'
                           '\tinvokestatic ' 
                             -> out.puttext;
                           betaenv -> out.puttext;
                           '/Text2BetaText'
                           '(Ljava/lang/String;)Ltext;'
                             -> out.puttext        
                       if)
                    // 'CharArray2String' -> prim.equal then
                       '\tnew java/lang/String\n'
                       '\tdup_x1\n'
                       '\tswap\n'
                       '\tinvokespecial java/lang/String/<init>([C)V'
                         -> out.puttext
                    // 'Att' -> prim.equal then
                       '; missing call of attach here\n'
                       '; we pop the stack to avoid overflow\n'
                       '\tpop\n'
                       -> out.puttext
                    else
                       '; Primitive: '->out.puttext; 
                       prim[] -> out.puttext; ' ' ->out.put;
                       arg[] -> out.puttext;
                   if);
                #)
             // callExternal then
                (# prim: ^text
                do BC.getText -> prim[];
                   (if true
                    // 'newline' -> prim.equalNCS then
                       ('\tjava/io/PrintStream/println()V',false)
                         -> IOcall                       
                    // 'put' -> prim.equalNCS then
                       ('java/io/PrintStream/print(C)V',true) -> IOcall
                    // 'puttext' -> prim.equalNCS then
                       ('java/io/PrintStream/print(Ljava/lang/String;)V'
                       ,true) 
                         -> IOcall
                    // 'println' -> prim.equalNCS 
                    // 'putline' -> prim.equalNCS then
                       ('java/io/PrintStream/println(Ljava/lang/String;)V'
                       ,true)
                         -> IOcall
                    // 'putint' -> prim.equalNCS then 
                       ('java/io/PrintStream/print(I)V',true) -> IOcall
                    else
                       (if (prim.length >= 19)
                           and 
                           ('java/io/PrintStream' 
                             -> ((1,19)->prim.sub).equal) then
                           (* just a hack *)
                           (prim[],true) -> IOcall
                        else
                           '\tinvokevirtual ' -> out.puttext;  
                           (*thisClassName[] -> out.puttext;
                            '/' -> out.put;*)
                           prim[] -> out.puttext;
                       if);
                       (* '\nPrim:'->puttext; prim[] -> putline *)
                   if)
                #)
             // callInner then
                '\taload_0\n'
                '\tinvokevirtual ' -> out.puttext;
                (* NOT in accordance with design - FIX *)
                thisClassName[] -> out.puttext;
                '/'->out.put;
                thisInnerMethodName[]->out.puttext;
                (if false then
                    '_do_'-> out.puttext;
                    subLevel+1 -> out.putint;
                if);
                '()V'->out.puttext
             // comment then
                (# T: ^text
                do BC.gettext -> T[];
                   (if (T.length > 0) and ((1 -> T.inxget) <> '!') 
                       or common.switch[185] then
                       ' ; ' -> out.puttext; 
                       T[] -> out.puttext
                    else
                       restart read (* skip newline *)
                   if)
                #)
             // position then
               (* '; position: ' -> out.puttext; *)
                BC.getShort (*-> out.putint;*)
             else
                '\t' -> out.put; 
                (if opCode
                 // pushVal then 
                    A.get; 
                    (*'\nload: '->puttext; A.display;*)
                    A.load; 
                 // stVal then
                    A.get; 
                    (*'\nload: '->puttext; A.display;*)
                    A.store
                 // loadRef then
                    A.get; A.loadRef
                 // loadQRef then
                    A.get; true->A.loadRef
                 // pushAdr then
                    A.get; A.pushAdr
                 // storeRef then
                    A.get; A.storeRef
                 // storeQref then 
                    A.get; (true,false) -> A.storeRef
                 // storeOrigin then
                    A.get; (false,true) -> A.storeRef
                 // loadOrigin then
                    (# ONlevel,ctag,ftag: @integer; 
                       className,fieldType: ^text
                    do BC.get -> ONlevel;
                       BC.get -> ctag;
                       (if ctag = 1 then
                           BC.getText -> className[];
                           (*'; loadOrigin:tag=1: '->out.puttext;
                           className[] -> out.puttext;
                           out.newline;*)
                       if);
                       BC.get -> ftag;
                       (if ftag = 1 then
                           BC.gettext -> fieldType[]
                       if);
                       (if isMainMethod then
                           (* reconsider for main/program-slot;
                            * in Java:main, we cannot access class fields;
                            * but we may do in BETA
                            *)
                           'aconst_null' -> out.puttext;
                        else
                           (if ONlevel = 0 then
                               'aload_0' -> out.puttext;
                            else
                               'getfield ' -> out.puttext;
                               (if ctag = 0 then
                                   ONlevel 
                                     -> BCstate.blocks.class 
                                     -> out.puttext;
                                   'loadOrigin' -> blocksCall
                                else
                                   className[] -> out.puttext
                               if);
                               '/origin ' -> out.puttext;
                               (if ftag = 0 then
                                   ONlevel 
                                     -> BCstate.blocks.orgClass
                                     -> emitSignature;
                                   'loadOrigin2' -> blocksCall
                                else
                                   fieldType[] -> emitSignature
                               if);                                   
                           if);
                       if)
                    #)
                 // call then 
                    (if false (* non virtual *) then
                        'invokenonvirtual ' -> out.puttext;
                     else
                        (if BC.get = 1 then
                            'invokestatic ' -> out.puttext;
                         else
                            'invokevirtual ' -> out.puttext;
                        if)
                    if);
                    BC.getText->T[]->out.puttext;
                    313->trace(#do '%%%call: '->xT; T[]->xT #)
                 // return then
                    (if BC.get 
                     // 0 then 'return' -> out.puttext
                     // 1 then 'ireturn' -> out.puttext
                     // 2 then 'areturn' -> out.puttext
                     else (* error *) 'xreturn' -> out.puttext
                    if);
                    '\n.end method'->out.puttext
                 // cmpToBool then
                    ' ; cmpToBool\n' -> out.puttext;
                    (BC.get,'?',localLabNo) -> emitCmpJmp;
                    '\n\tbipush 0\n'
                    '\tgoto ' -> out.puttext; localLabNo + 1 -> emitLabRef;
                    localLabNo -> emitLabDef;
                    '\tbipush 1\n' -> out.puttext; 
                    localLabNo + 1 -> emitLabDef;
                    localLabNo + 2 -> localLabNo
                    
                 // cmpAndJmp then
                    ' ; cmpAndJmp\n' -> out.puttext;
                    (BC.get,BC.get,BC.get) -> emitCmpJmp
                 // cmpBoolAndJmp then
                    ' ; cmpBoolAndJmp\n' -> out.puttext;
                    (BC.get,BC.get,BC.get) -> emitCmpBoolJmp
                 // pushReg then
                    dumpReg
                 // pushNone then
                    'aconst_null' -> out.puttext
                 // dup then
                    BC.get -> arg1;
                    'dup' -> out.puttext;
                    (if arg1 > 0 then 
                        '_x' -> out.puttext;
                        arg1 -> out.putint
                    if)  
                 // pop then
                    'pop' -> out.puttext
                 else
                    opCode->dumpOpCode; '\t'->out.put;
                    (if opCode
                     // pushCst_s8 then
                        BC.get -> out.putint                        
                     // pushCst_s16 then
                        BC.getShort -> out.putint                        
                     // pushCst_s32 then
                        BC.getLong -> out.putint                        
                     // pushText then 
                        BC.getText->emitString
                     // jmp then 
                        BC.get->asText->out.puttext; BC.get->out.putint; 
                    
                     // func then
                        (# func: @integer;
                        do BC.get->func;
                           (if func
                            // nott then
                               'ifne ' -> out.puttext; 
                               localLabNo -> emitLabRef;
                               '\ticonst_1\n' -> out.puttext;
                               '\tgoto ' -> out.puttext; 
                               localLabNo + 1 -> emitLabRef;
                               localLabNo -> emitLabDef;
                               '\ticonst_0\n' -> out.puttext;
                               localLabNo + 1 -> emitLabDef;
                               localLabNo + 2 -> localLabNo
                            else
                               func -> asText->out.puttext
                           if)
                        #)
                    if);
                    
                if)
            if);
            out.newline;
            restart read
        if);
      out.close
   #)  
