ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
---byteCode_mstate:descriptor---
(#  
   BCM: @ BCmachine
     (# emit:
          (# opCode: @integer
          enter opCode
          do opCode -> BC.put; 
             INNER
          #);
        emitShort:
          (# V: @integer;
          enter V
          do V -> BC.putShort
          #);
        emitLong:
          (# V: @integer
          enter V
          do V -> BC.putLong
          #);
        emit1: emit
          (# op1: @integer
          enter op1
          do op1->BC.put; INNER
          #);
        emit2: emit1
          (# op2: @integer
          enter op2
          do
          #);
        emitText: 
          (# T: ^text
          enter T[]
          do T[]->BC.puttext
          #);
     #);
   splitPathAndName:
     (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
        e: @diskentry
     enter orgPath[]
     do (if true then
            (* datpete: 2002-04-29: Using diskentry *)
            orgPath[] -> e.path;
            e.path.head -> path[]; directorychar -> path.put;
            e.path.name.prefix -> FN[];
         else
            (* Original olm code *)
            orgPath.copy->path[];
            path.scanAll
            (# i: @integer 
            do i+1->i; 
               (if ch = '.' then i->dotPos 
                else 
                   (if ch = '/'(* thePathHandler.directoryChar*) then
                       i -> slashPos
               if)if)
            #);
            (if false and common.switch[189] then
                '\nsplit1: ' -> puttext; path[] -> putline;
            if);
            
            (if dotPos > 0 then
                (dotPos,path.length)->path.delete
            if);
            (if false and common.switch[189] then
                'split2: ' -> puttext; path[] -> putline;
            if);
            (if slashPos > 0 then
                (slashPos+1,path.length)->path.sub -> FN[];
                (slashPos+1,path.length)->path.delete
            if);
            (if false and common.switch[189] then
                'split3: ' -> puttext; path[] -> puttext; 
                ' '->put; FN[] -> putline;
            if);
        if)
     exit(path[],FN[])
     #);
   
   BCisSplit: @boolean;
   c: ^text; (* ugly *)
   
   mkAsmFile:
     (# BC: ^text
     do 183->trace
        (#
        do 'mkAsmFile: ' ->xT; thisFullPath[] -> xT 
        #);
        (if not BCisSplit then
            thisFullPath[] -> splitPathAndNAme -> (thisFullPath[],c[]);
            true -> BCisSplit
        if);
        thisFileName[] -> (thisFullPath.copy).append -> BC[];
        183->trace(#do 'mkasmFile:BC:' -> xT; BC[] -> xT #);
        '.bin'->(BC.copy).append->mstate.BCM.save;
        '.bin'->(BC.copy).append->mstate.BCM.restore;
        (if true
         // common.targetMachineId = common.javabc then
            mstate.BCM.emitJasmin;
         // common.targetMachineId = common.dotnet then
            mstate.BCM.emitDotnet
         else
            'byteCode_close: unknown platform' -> screen.putline;
        if)
     #);
   thisFullPath,         (* full path for current source/object file *)
   thisSourceFileName,   (* name of current source file *)
   thisFileName,         (* name of current object file  *)
   thisClassName: ^text; (* name of current class 
                          * for java: currentFile = currentClass
                          * for .NET: thye may differ
                          *)
   hasClassEQfileName: @boolean; (* a class has the same name as 
                                  * thisSourceFileName; used by
                                  * Java - see mkClassListFile
                                  *)
   jasmin: @file;
   jasminIsOpen: @boolean;
   methodType: @integer; (* 0: for calling a ptn as a method
                          * 1: for generating a vclass-instance of a ptn
                          * 2: enter- do- or exit-method
                          *)
   extraOrigin:
     (#
     do (if methodType = 2 then
            '****extra origin'->putline;
            BCM.loadOrigin->mstate.BCM.emit;
            0 -> BCM.emit
        if);
     #);
   classes: @
     (# L: [4] ^text; top: @integer;
        init: (# do 0 -> top #);
        add:
          (# cn: ^text
          enter cn[]
          do (if (top+1->top) > L.range then
                 L.range -> L.extend
             if);
             cn[] -> L[top][]
          #);
        scan:
          (# current: ^text
          do (for i: top repeat
                  L[i][] -> current[];
                  inner
          for)#)
     #);
   mkClassListFile:
     (# thisFullPath: ^text; F: @file;
     enter thisFullPath[]
     do '.clst'
          -> (thisSourceFileName[]->(thisFullPath.copy).append).append 
          -> F.name;
        (*'\nClassFileName: ' -> puttext; F.name -> putline;*)
        F.openWrite;
        classes.scan
        (#
        do current[] -> F.putline;
        #);
        F.close;
        (if not hasClassEQfileName then
            (* for dependency analysis we have to ensure that
             * there is a .J-file that has the same name
             * as the cource file
             *)
            '.J'
              -> (thisSourceFileName[]->(thisFullPath.copy).append).append 
              -> F.name;
            F.openWrite;
            'for dependency analysis\n' -> F.puttext;
            F.close;
        if)
     #);
#)
---bytecode_newImp:doPart---
do (* mstate.BCM.position -> mstate.BCM.emit;
    astRef -> mstate.BCM.emitShort 
    *)

---byteCode_textOperand_out:doPart---
do T[]->mstate.BCM.emittext
   
---byteCode_dataRegOperand_out:doPart---
do rn->mstate.BCM.emit 
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.BCM.emit 
   
---byteCode_LocalLab_def:doPart---
do mstate.BCM.labelDef -> mstate.BCM.emit;
   labNo -> mstate.BCM.emit;
   
---byteCode_LocalLab_out:doPart---
do mstate.BCM.label -> mstate.BCM.emit;
   labNo -> mstate.BCM.emit
   
---byteCode_RegAdr_out:doPart---   
do reg.out; 
   off -> mstate.BCM.emit; 
   size -> mstate.BCM.emit;
   (if mstate.methodType = 2 then
       '**** extra ON '->putline;
       ONlevel+1 -> mstate.BCM.emit;
    else
       ONlevel -> mstate.BCM.emit;
   if);
   (if isField and (descName[] <> none) then 
       1 -> mstate.BCM.emit;
       descName[] -> mstate.BCM.emitText
    else 
       0 -> mstate.BCM.emit 
   if);
   (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText
    else
       0 -> mstate.BCM.emit        
   if)
   
---byteCode_RegAdr_index:doPart---
do  mstate.BCM.index->mstate.BCM.emit;
   '\nindex:'->puttext;
   
---bytecode_goOrigin:doPart---
do mstate.BCM.loadOrigin -> mstate.BCM.emit;
   on -> mstate.BCM.emit;
   '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do areg.out;
   off -> mstate.BCM.emit;
   size -> mstate.BCM.emit;   
   ONlevel -> mstate.BCM.emit;  
   2 -> mstate.BCM.emit; (* isField = 2 signals array *)
   (* all the fields; areg,off,size,ONlevel, are superflous
    * and not used by the bytecode
    *)
    (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText
    else
       0 -> mstate.BCM.emit        
    if)
   
---byteCode_nop:doPart---
do mstate.BCM.nop -> mstate.BCM.emit;
   
---byteCode_ldCst:doPart---
do (if true
    // (- 128 <= C) and (C <= 127) then
       (mstate.BCM.pushCst_s8,C) -> mstate.BCM.emit1;
    // (- common.two15 <= C) and (C <= (common.two15-1)) then
       mstate.BCM.pushCst_s16 -> mstate.BCM.emit;
       C -> mstate.BCM.emitShort; (* is this one sign extended?*)
    else
       mstate.BCM.pushCst_s32 -> mstate.BCM.emit;
       C -> mstate.BCM.emitLong
   if)
   
---byteCode_ldNone:doPart---
do mstate.BCM.pushNone -> mstate.BCM.emit;
   
---byteCode_ldValImpl:doPart---
do (if mstate.methodType = 2 then
       '**** extra ldvl origin'->putline;
       mstate.BCM.loadOrigin->mstate.BCM.emit;
       0 -> mstate.BCM.emit
   if);
   (if A.isOrigin then
       mstate.BCM.loadOrigin->mstate.BCM.emit;
       (if mstate.methodType = 2 then
           A.ONlevel+1 -> mstate.BCM.emit;
        else
            A.ONlevel -> mstate.BCM.emit
       if);
       (if A.descName[] <> none then
           1 -> mstate.BCM.emit;
           A.descName[] -> mstate.BCM.emittext;
        else
           0 -> mstate.BCM.emit
       if);
       (if A.fieldType[] <> none then
           1 -> mstate.BCM.emit;
           A.fieldType[] -> mstate.BCM.emittext;
        else
           0 -> mstate.BCM.emit
       if);
       
    else
       (if A.isRef then
           mstate.BCM.loadRef->mstate.BCM.emit
        else
           mstate.BCM.pushVal->mstate.BCM.emit
       if); 
       A.out;
       (if A.isRef then
           'UnknownType' -> mstate.BCM.emittext
       if)
   if)
   
---byteCode_loadRef:doPart---
do mstate.extraOrigin;
   (if A.isOrigin then
       mstate.BCM.loadOrigin->mstate.BCM.emit
    else
       (if knownSourceClassName[] <> NONE then
           mstate.BCM.loadQRef->mstate.BCM.emit;
        else
           mstate.BCM.loadRef->mstate.BCM.emit;
       if);
       A.out;
       basicSourceClassName[] -> mstate.BCM.emittext;
       (if knownSourceClassName[] <> NONE then
           knownSourceClassName[] -> mstate.BCM.emittext
       if)
   if)
   
---byteCode_stValImpl:doPart---
do mstate.extraOrigin;
   mstate.BCM.stVal->mstate.BCM.emit; 
   A.out;   
   
---byteCode_cpReg:doPart---
do mstate.BCM.pushReg->mstate.BCM.emit; R1.out;   
   
---byteCode_gLea:doPart---
do (if true 
    // op1.isRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isInxRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isTextOp then
       mstate.BCM.pushtext->mstate.BCM.emit; op1.out
    else
       '\nglea: operand type not handled'->putline
   if)   
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too mnay zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
--bytecode_loadRange:doPart--
do mstate.BCM.loadRange ->mstate.BCM.emit
   
---byteCode_duplicate:doPart---
do mstate.BCM.dup -> mstate.BCM.emit;
   pos -> mstate.BCM.emit;
   
--byteCode_popStack:doPart---
do mstate.BCM.pop-> mstate.BCM.emit;
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do mstate.BCM.field ->mstate.BCM.emit; 
   regRef -> mstate.BCM.emit;
   (if routineName[] <> none then
       RoutineName[] -> mstate.BCM.emitText;
    else

   if);
   (if RefName[] <> none then
       1 -> RefName.inxGet -> mstate.BCM.emit
    else
       '?' -> mstate.BCM.emit
   if)
   
--byteCode_tstNone:doPart--
do mstate.BCM.loadRef->mstate.BCM.emit; A.out;
   'UnknownNONE' -> mstate.BCM.emittext
   
---byteCode_doAsgRefAdr:doPart---
do (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; *)
   (if withQua then
       'withQUA'->putline;
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRefAdr:storeorigin'->mch.comment;
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit
       if)
   if);   
   thisAdr.out;
   (if destClassName[] <> none then
       DestClassName[] -> mstate.BCM.emittext
    else
       'UnknownAsgRefAdr'-> mstate.BCM.emittext
   if)
   
---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; (* destination *)
   (* a swap is probably needed here *)
   (if withQua then
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRegAdr:storeorigin'->mch.comment;
           'DestClassName:'->mch.comment;
           DestClassName -> mch.comment;
           'thisAdr.descName: ' -> mch.comment;
           thisAdr.descName -> mch.comment;
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit;
       if)
   if);
   thisAdr.out;
   DestClassName[] -> mstate.BCM.emittext
   
---byteCode_jmpTlong:doPart---
do mstate.BCM.jmp->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jmplong:doPart---
do mstate.BCM.jmp->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jsrT:doPart---
do mstate.BCM.call->mstate.BCM.emit; T[]->mstate.BCM.emitText   
   
--byteCode_gJmp:doPart---
do mstate.BCM.jmp->mstate.BCM.emit; op.out;
   
--byteCode_gJsr:doPart---
do mstate.BCM.call->mstate.BCM.emit; 
   (if isStatic then 
       1 -> mstate.BCM.emit
    else
       0 -> mstate.BCM.emit
   if);
   op.out;
   
---byteCode_cmpToBool:doPart--   
do op1.loadToReg; 
   op2.loadToReg;
   (* op3 is a register to load 0 or 1;
    * here we use the stack instead
    *)
   
   mstate.BCM.cmpToBool->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;

   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out;  
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   mstate.BCM.cmpBoolAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out;  
   
---byteCode_saveReturn:doPart---
do (if isGpart then
       mstate.BCM.initCons -> mstate.BCM.emit;
   if)
   
---byteCode_return:doPart---
do mstate.BCM.return -> mstate.BCM.emit;
   RToff -> mstate.BCM.emit;
   0 -> mstate.methodType
   
---byteCode_callPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; T[]->mstate.BCM.emitText;
   'Unknown'->mstate.BCM.emitText;
   
--byteCode_callAlloPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; 
   T[]->mstate.BCM.emitText;   (* the primitive *)
   (if proto[] <> none then
       proto[]->mstate.BCM.emitText; 
    else
       'UnknownProto' -> mstate.BCM.emitText
   if)
---bytecode_import:doPart---
do (if (Lab[] <> none) and ( Lab.length > 0) then
       Lab.copy -> mstate.BCM.imports.add 
   if);
   (* 'IMPORT: ' -> puttext; Lab[] -> putline *)
   
---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;

---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;
      
--byteCode_classDef:doPart--
do (if true 
    // common.switch[184] // common.switch[189] then
       (* .NET *)
    else
       (* java *)
       mstate.BCM.init;
       className[] -> mstate.thisFileName[];
       (if className[] -> mstate.thisSourceFileName.equal then
           true -> mstate.hasClassEQfileName
       if)       
   if);
   className[] -> mstate.thisClassName[];
   className[] -> mstate.classes.add;
   mstate.BCM.classDef -> mstate.BCM.emit; 
   className[]->mstate.BCM.emittext;
   blockLevel -> mstate.BCM.emit;
   superName[]->mstate.BCM.emittext;
   subLevel -> mstate.BCM.emit; (* OBS: int8 assumed here *)
   orgName[] -> mstate.BCM.emittext;
   0 -> mstate.methodType
   
--byteCode_endClass:doPart---
do mstate.BCM.endClass -> mstate.BCM.emit;
   (if not common.switch[184] then
       mstate.BCM.end -> mstate.BCM.emit;
       mstate.mkAsmFile
   if)
   
--byteCode_methodDef:doPart--
do mstate.BCM.methodDef -> mstate.BCM.emit; 
   methodName[]->mstate.BCM.emittext;
   signature[]->mstate.BCM.emittext;
   noOfEnterArgs -> mstate.BCM.emit;
   type -> mstate.BCM.emit;
   (*type -> mstate.methodType*)
   
--byteCode_emitTextConst:doPart---
do (*13->mstate.BCM.emit;
   112->mstate.BCM.emit;
   113->mstate.BCM.emit;
   *)
   mstate.BCM.pushText->mstate.BCM.emit; S[]->mstate.BCM.emitText;
(* 97 -> mstate.BCM.emit;
   97 -> mstate.BCM.emit;
   97 -> mstate.BCM.emit;
   97 -> mstate.BCM.emit;
   0 -> mstate.BCM.emit;*)
(*   '\nemitTextConst: ' -> screen.puttext;
   mstate.BCM.pushText-> screen.putint; ' '->screen.put;
   S[] ->screen. putline*)

---byteCode_close:doPart---
do 183->trace(#
             do 'Close:' ->xT; mstate.thisFullPath[] -> xT; xN;
                '   thisFileName:' -> xT; mstate.thisFileName[] -> xT; xN;
                'imports: ' -> xT;
                mstate.BCM.imports.scan(# do current[] -> xT; ' '-> put #);
             #);
   mstate.thisFullPath[] -> mstate.mkClassListFile;
   mstate.BCM.end -> mstate.BCM.emit;
   mstate.mkAsmFile; 
   mstate.BCM.imports.clear;

---byteCode_CallCproc:doPart---
do (# S: @text
   do mstate.BCM.callExternal -> mstate.BCM.emit;
      T.scanAll(#
               do (if ch > 0 then
                      ch -> S.put
               if)#);
      S[] -> mstate.BCM.emitText;   
   #)
   
---byteCode_jsrTable:doPart---
do 
   (if newVirt then
       (# R: @adrRegOperand
       do R.alloc;
          (A[],R[],4) -> ldVlImpl;
          mstate.BCM.newVirt -> mstate.BCM.emit;
       #)
    else
       mstate.BCM.callInner -> mstate.BCM.emit;
   if)
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/javabc/foo.J'
    * I.e. BCname is the name of theasmmebly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do (if localFilePath[] = none then
       (* hack to signal that BCname is the currentFileName  *)
       183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
       BCname[] -> mstate.thisFileName[];
       (if BCname[] -> mstate.thisSourceFileName.equal then
           true -> mstate.hasClassEQfileName
       if)
    else
       183 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       BCname [] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[]
       ,mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       true -> mstate.BCisSplit; (* should be eliminated since
                                  * BC is always split 
                                  *)
       (if common.switch[189] (*.NET *) then
           true -> mstate.hasClassEQfileName
       if);

       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);
   if);
   
   FIXME.init;
   mstate.BCM.init;
   mstate.classes.init;
   
   1->ThisRegOp;
   2->CallRegOp;

   
---bytecode_comment:doPart--
do mstate.BCM.comment -> mstate.BCM.emit;
   T[] -> mstate.BCM.emittext
