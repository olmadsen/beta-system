ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
--LIB:attributes--
trace_init_close: (# exit false #);

---byteCode_mstate:descriptor---
(#  
   BCM: @ BCmachine
     (# emit:
          (# opCode: @integer
          enter opCode
          do opCode -> BC.put; 
             INNER
          #);
        emitShort:
          (# V: @integer;
          enter V
          do V -> BC.putShort
          #);
        emitLong:
          (# V: @integer
          enter V
          do V -> BC.putLong
          #);
        emit1: emit
          (# op1: @integer
          enter op1
          do op1->BC.put; INNER
          #);
        emit2: emit1
          (# op2: @integer
          enter op2
          do
          #);
        emitText: 
          (# T: ^text
          enter T[]
          do T[]->BC.puttext
          #);
     #);
   splitPathAndName:
     (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
        e: @diskentry
     enter orgPath[]
     do orgPath[] -> e.path;
        e.path.head -> path[]; directorychar -> path.put;
        e.path.name.prefix -> FN[];
     exit(path[],FN[])
     #);
   
   BCisSplit: @boolean;
   c: ^text; (* ugly *)
   
   mkDepFile:
     (# dep: @file;
     do (* Touch the dep file *)
        '.dep'
          -> (thisSourceFileName[]->(thisFullSourcePath.copy).append).append 
          -> dep.name;
        (*'touching file ' -> screen.puttext; dep.name ->screen.putline;*)
        dep.touch;
     #);
   mkAsmFile:
     (# BC: ^text;
        jvm: @directory;
        dep: @file;
     do 183->trace
        (#
        do 'mkAsmFile: ' ->xT; thisFullPath[] -> xT 
        #);
        (if not BCisSplit then
            thisFullPath[] -> splitPathAndNAme -> (thisFullPath[],c[]);
            true -> BCisSplit
        if);
        thisFileName[] -> (thisFullPath.copy).append -> BC[];
        183->trace(#do 'mkasmFile:BC:' -> xT; BC[] -> xT #);
        '.bin'->(BC.copy).append->mstate.BCM.save;
        '.bin'->(BC.copy).append->mstate.BCM.restore;
        (if true
         // common.targetMachineId = common.jvm then
            mstate.BCM.emitJasmin;
            (* Ensure .dep file becomes newer than .bet/.ast file *)
            (if false then
                (* First check that jvm directory exists at all (.bet files with only 
                 * external class declarations does not generate any code at all, 
                 * but we still need to mark them as "compiled").
                 *)
                thisFullSourcePath.copy -> jvm.name;
                'touching directory ' -> screen.puttext; jvm.name ->screen.putline;
                jvm.touch;
            if);
            (if false then
                (* Then touch the dep file *)
                '.dep'
                  -> (thisSourceFileName[]->(thisFullSourcePath.copy).append).append 
                  -> dep.name;
                (*'touching file ' -> screen.puttext; dep.name ->screen.putline;*)
                dep.touch;
            if)
         // common.targetMachineId = common.clr then
            mstate.BCM.emitClr
         else
            'byteCode_close: unknown platform' -> screen.putline;
        if);
        (if not common.switch[23] then
            (* Delete .bin file *)
            (# e: @file;
            do '.bin'->(BC.copy).append->e.name;
               e.delete;
            #);
        if);
     #);
   numTempLocals: @integer;
   thisPackagePath,      (* package path *)
   thisFullPath,         (* full path of directory for for current object/class file.
                          * On JVM this include package path.
                          *)
   thisFullSourcePath,   (* Full path of directory of current source file *)
   thisSourceFileName,   (* name of current source file *)
   thisFileName,         (* name of current object file  *)
   thisClassName: ^text; (* name of current class 
                          * for java: currentFile = currentClass
                          * for .NET: they may differ
                          *)
   jasmin: @file;
   jasminIsOpen: @boolean;
   classes: @
     (# L: [4] ^text; top: @integer;
        init: (# do 0 -> top #);
        add:
          (# cn: ^text
          enter cn[]
          do (if (top+1->top) > L.range then
                 L.range -> L.extend
             if);
             cn[] -> L[top][]
          #);
        scan:
          (# current: ^text
          do (for i: top repeat
                  L[i][] -> current[];
                  inner
          for)#)
     #);
   mkClassListFile:
     (# basename: ^text;
        F: @file;
     do (thisSourceFileName[]->(thisFullPath.copy).append).append -> basename[];
        '.clst'
          -> (basename.copy).append
          -> F.name;
        (if false then
            '\nClassFileName: ' -> screen.puttext; 
            F.name -> screen.puttext; 
            ', Path: '->screen.puttext; 
            ThisFullPath[] -> screen.putline;
        if);
        F.openWrite;
        (* 'opened for writing: ' -> screen.puttext; F.name -> screen.putline; *)
        classes.scan
        (# 
        do current[] (* No extension *) -> (thisFullSourcePath.copy).append -> F.putline;
           (* current[] -> putline *)
        #);
        (if false then
            (if common.switch[189] then
                (* .NET: All attributes forms in one file.
                 * The library file may or may not define attributes fragments.
                 * In both cases a legal .il file is generated.
                 * This file must be included in assembly/link too.
                 *)
                basename[] -> F.putline; (* Add to class list for future job files *)
            if);
        if);
        F.close;
     #);
#)
---bytecode_newImp:doPart---
do mstate.BCM.position -> mstate.BCM.emit;
   astRef -> mstate.BCM.emitShort 

---byteCode_textOperand_out:doPart---
do T[]->mstate.BCM.emittext
   
---byteCode_dataRegOperand_out:doPart---
do rn->mstate.BCM.emit 
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.BCM.emit 
   
---byteCode_LocalLab_def:doPart---
do mstate.BCM.labelDef -> mstate.BCM.emit;
   labNo -> mstate.BCM.emitShort;
   
---byteCode_LocalLab_out:doPart---
do mstate.BCM.label -> mstate.BCM.emit;
   (if labNo >= common.two16 then
       'localLab_out:labNo>65536' -> putline
   if);
   labNo -> mstate.BCM.emitShort
   
---byteCode_RegAdr_out:doPart---   
do reg.out; 
   (if fieldName[] <> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText
    else
       (*'regAdr:no FieldName' -> putline;*)       
       1 -> mstate.BCM.emit;
       'NoFieldName' -> mstate.BCM.emitText
   if);
  (* (if off > 255 then '%'->put if);*)
   off -> mstate.BCM.emitShort; 
   size -> mstate.BCM.emit;
   0 (* ONlevel*) -> mstate.BCM.emit;
   (* 18/06/02: ONlevel can be eliminated and
    * ONlevel > 0 ==> isField = true
    * BUT! For loadOrigin ONlevel is used
    * but does NOT involve blocks. 
    *)
   (if isField then 
       1 -> mstate.BCM.emit;
       (if receiverType[] <> none then
           (if not common.switch[189] (* java *) then
               (if (receiverType.length->receiverType.inxGet) = ';' then
                   (2,receiverType.length-1)  (* ugly *)
                     -> receiverType.sub 
                     -> mstate.BCM.emitText
                else
                   receiverType[] -> mstate.BCM.emitText
               if)
            else
               receiverType[] -> mstate.BCM.emitText
           if)
        else
           '\nOBS!bytecode_regAdrOut:isField:no:receiverType'->putline;
       if)
    else 
       (* A method variable and this should be ok so no error here *)
       0 -> mstate.BCM.emit 
   if);
   (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText;
    else
       0 -> mstate.BCM.emit        
   if)
   
---byteCode_RegAdr_index:doPart---
do  mstate.BCM.index->mstate.BCM.emit;
   '\nindex:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do areg.out;
   (if fieldName[] <> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText
    else
       (*'InxRegAdr:no fieldName' -> putline;*)
       1 -> mstate.BCM.emit;
       'NoInxFieldName'->mstate.BCM.emitText
   if);

   off -> mstate.BCM.emitShort;
   size -> mstate.BCM.emit;   
   ONlevel -> mstate.BCM.emit;  
   2 -> mstate.BCM.emit; (* isField = 2 signals array *)
   (* all the fields; areg,off,size,ONlevel, are superflous
    * and not used by the bytecode
    *)
   (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText
    else
       0 -> mstate.BCM.emit        
   if)
   
---byteCode_nop:doPart---
do mstate.BCM.nop -> mstate.BCM.emit;
   
---byteCode_ldCst:doPart---
do (if true
    // (- 128 <= C) and (C <= 127) then
       (mstate.BCM.pushCst_s8,C) -> mstate.BCM.emit1;
    // (- common.two15 <= C) and (C <= (common.two15-1)) then
       mstate.BCM.pushCst_s16 -> mstate.BCM.emit;
       C -> mstate.BCM.emitShort; (* is this one sign extended?*)
    else
       mstate.BCM.pushCst_s32 -> mstate.BCM.emit;
       C -> mstate.BCM.emitLong
   if)
   
---byteCode_ldNone:doPart---
do mstate.BCM.pushNone -> mstate.BCM.emit;
   
---byteCode_ldValImpl:doPart---
do (if A.isOrigin then
       mstate.BCM.loadOrigin -> mstate.BCM.emit;
       (* Regarding ONlevel, see regAdr_out
        * and BCjasminBody.
        * But apparently only ONlevel = 0 and
        * ONlevel > 0 is used in BCjasminBody
        * Find out if isField can be used
        *)
       (if true
        // (A.ONlevel = 0) and A.isField then 
           'loadOrigin: ONlevel=0. isField=true' -> putline
        // (A.ONlevel > 0) and not A.isField then
           'loadOrigin: ONlevel>0, isField=false' -> putline
       if);
       (* Here we should replace ONlevel with
        * isField: 0 or 1 
        *)
       A.ONlevel -> mstate.BCM.emit;
       (if A.receiverType[] <> none then
           1 -> mstate.BCM.emit;
           (if not common.switch[189] (* java *) then
               (if (A.receiverType.length->A.receiverType.inxGet) = ';' then
                   (2,A.receiverType.length-1)  (* ugly *)
                     -> A.receiverType.sub 
                     -> mstate.BCM.emitText
                else
                   A.receiverType[] -> mstate.BCM.emitText
               if)
            else
               A.receiverType[] -> mstate.BCM.emitText
           if)
        else
           (* in regAdr_out we test isField before
            * A.receiverType[]<>none as above
            *)
           (if A.isField then
               '\nOBS!bytecode_ldVal:isField:no:receiverType'->putline;
            else
               0 -> mstate.BCM.emit
           if)
       if);
       (if A.fieldType[] <> none then
           1 -> mstate.BCM.emit;
           A.fieldType[] -> mstate.BCM.emittext;
        else
           0 -> mstate.BCM.emit
       if);   
    else
       (if A.isRef then
           mstate.BCM.loadRef->mstate.BCM.emit
        else
           mstate.BCM.pushVal->mstate.BCM.emit
       if); 
       A.out;
       (if A.isRef then (* cleanup/elim isRef?*)
           (if A.fieldType[] <> none then
               A.fieldType[] -> mstate.BCM.emittext
            else
               'ldValImpl_UnknownType' -> mstate.BCM.emittext
       if)if)
   if);
   elimSign:
     (if not A.signed and (A.fieldType[]<>none) then
         (if isJava then
             (if ('C' -> A.fieldType.equal) 
                 or ((1->A.fieldType.inxget) = '[') 
                 then leave elimSign
             if)
          else
             (if ('char' -> A.fieldType.equal) 
                 or ((A.fieldType.length->A.fieldType.inxget) = ']') 
                 then leave elimSign
             if)
         if);
         (if A.size
          // 1 then
             (&dataRegOperand[],0xFF->newCstOp,4) -> gAnd
          // 2 then
             (&dataRegOperand[],0xFFFF->newCstOp,4) -> gAnd
         if)
     if);
   
---byteCode_ByteSwap:doPart---
do (if long then
       (arithCodes.byteSwapLong,ar[])->callUnFunc
    else
       (arithCodes.byteSwapShort,ar[])->callUnFunc
   if);

---byteCode_loadRef:doPart---
do (if knownSourceClassName[] <> NONE then
       mstate.BCM.loadQRef->mstate.BCM.emit;
    else
       mstate.BCM.loadRef->mstate.BCM.emit;
   if);
   A.out;
   basicSourceClassName[] -> mstate.BCM.emittext;
   (if knownSourceClassName[] <> NONE then
       knownSourceClassName[] -> mstate.BCM.emittext
   if);
   
---byteCode_stValImpl:doPart---
do mstate.BCM.stVal->mstate.BCM.emit; 
   A.out;   
   
---byteCode_cpReg:doPart---
do mstate.BCM.pushReg->mstate.BCM.emit; R1.out;   
   
---byteCode_gLea:doPart---
do (if true 
    // op1.isRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isInxRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isTextOp then
       mstate.BCM.pushtext->mstate.BCM.emit; op1.out
    else
       '\nglea: operand type not handled'->putline
   if)   
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
---bytecode_int64ToInt32:doPart---
do mstate.BCM.int64ToInt32 -> mstate.BCM.emit
   
--bytecode_loadRange:doPart--
do mstate.BCM.loadRange ->mstate.BCM.emit
   
---byteCode_duplicate:doPart---
do mstate.BCM.dup -> mstate.BCM.emit;
   pos -> mstate.BCM.emit;
   type -> mstate.BCM.emit;
   
---byteCode_allocAndStoreLocal:doPart---
do (# RA: ^mch.RegAdr;
      first: @char;
   do &mch.RegAdr[] -> RA[];
      mstate.numTempLocals+1 -> mstate.numTempLocals;
      -mstate.numTempLocals -> RA.off;
      (if type[]=NONE then
          '\nbyteCode_allocAndStoreLocal: type is NONE!'->putline;
          (*(dumpstack, 'byteCode_allocAndStoreLocal: type is NONE!') -> stop;*)
          'AllocAndStoreLocal_UnknownType' -> type[];
       else
          (if isJava then
              ((type.lgth>=1) and ((type.T[1] = 'L') or (type.T[1]='['))) 
                -> RA.isRef;
              type.copy -> RA.fieldType[];
           else 
              true -> RA.isRef;              
          if);
      if);
      (if false then
          'bytecodebackendbody: AllocAndStoreLocal:' -> screen.putline;
          -mstate.numTempLocals->screen.putint; 
          '/'->screen.put; 
          type[]->screen.putline;
      if);
      (none,false,'',type[]) -> RA.asgRefReg;
      RA[] -> A[]
   #)
---bytecodebackend_getBits:doPart---
do (* StackTop logicalShiftLeft pos *) 
   (mstate.BCM.pushCst_s8,pos) -> mstate.BCM.emit1;
   mstate.BCM.func -> mstate.BCM.emit;
   arithCodes.logicalShiftLeft -> mstate.BCM.emit;

   
   (* StackTop logicalShiftRight 32-pos *)
   (mstate.BCM.pushCst_s8,32-length) -> mstate.BCM.emit1;
   mstate.BCM.func -> mstate.BCM.emit;
   arithCodes.logicalShiftRight -> mstate.BCM.emit;
   
---bytecodebackend_getSignedBits:doPart---
do (* StackTop logicalShiftLeft pos *) 
   (mstate.BCM.pushCst_s8,pos) -> mstate.BCM.emit1;
   mstate.BCM.func -> mstate.BCM.emit;
   arithCodes.logicalShiftLeft -> mstate.BCM.emit;

   
   (* StackTop arithShiftRight 32-pos *)
   (mstate.BCM.pushCst_s8,32-length) -> mstate.BCM.emit1;
   mstate.BCM.func -> mstate.BCM.emit;
   arithCodes.arithShiftRight -> mstate.BCM.emit;
   
   
---bytecodebackend_putBits:doPart---
do '\nOBS! putBits NOT implemented' -> putline;
   
---byteCode_loadLocal:doPart---
do (* FIXME: don't we need the variable offset? *)
   mstate.BCM.loadLocal -> mstate.BCM.emit
   
   
--byteCode_popStack:doPart---
do (if isDouble then
       mstate.BCM.pop2-> mstate.BCM.emit
    else
       mstate.BCM.pop-> mstate.BCM.emit
   if)
   
--bytecode_declareField:doPart---
   (* to replace emitCk 
    *)
do mstate.BCM.field ->mstate.BCM.emit; 
   off -> mstate.BCM.emit;
   (if fieldName[]<> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText;
    else
       'declareField:no fieldName' -> putline;
       0 -> mstate.BCM.emit
   if);
   (if fieldSig[]<> none then
       fieldSig[] -> mstate.BCM.emitText;
    else
       'OBS! no fieldSig' -> putline
   if);
   fieldKind -> mstate.BCM.emit;
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do mstate.BCM.field ->mstate.BCM.emit; 
   regRef -> mstate.BCM.emit;
   (if routineName[] <> none then
       RoutineName[] -> mstate.BCM.emitText;
    else

   if);
   (if RefName[] <> none then
       1 -> RefName.inxGet -> mstate.BCM.emit
    else
       '?' -> mstate.BCM.emit
   if)
   
---byteCode_constructorDef:doPart---
do mstate.BCM.initCons -> mstate.BCM.emit;
   signature[] -> mstate.BCM.emitText
   
---byteCode_tstNone:doPart---
do mstate.BCM.loadRef->mstate.BCM.emit; A.out;
   'UnknownNONE' -> mstate.BCM.emittext
   
---byteCode_doAsgRefAdr:doPart---
do (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; *)
   (if withQua then
       'withQUA'->putline;
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRefAdr:storeorigin'->mch.comment;
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit
       if)
   if);   
   thisAdr.out;
   (if destClassName[] <> none then
       DestClassName[] -> mstate.BCM.emittext
    else
       'UnknownAsgRefAdr'-> mstate.BCM.emittext
   if)
   
---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; (* destination *)
   (* a swap is probably needed here *)
   (if withQua then
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRegAdr:storeorigin'->mch.comment;
           'DestClassName:'->mch.comment;
           DestClassName -> mch.comment;
           (*'thisAdr.descName: ' -> mch.comment;
           thisAdr.descName -> mch.comment;*)
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit;
       if)
   if);
   thisAdr.out;
   DestClassName[] -> mstate.BCM.emittext;

---bytecode_checkCast:doPart---
do mstate.BCM.cast->mstate.BCM.emit; type[]->mstate.BCM.emitText
   
---byteCode_jmpTlong:doPart---
do mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jmplong:doPart---
do mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jsrT:doPart---
do mstate.BCM.call->mstate.BCM.emit; T[]->mstate.BCM.emitText   
   
--byteCode_gJmp:doPart---
do mstate.BCM.jmp->mstate.BCM.emit; op.out;
   
--byteCode_gJsr:doPart---
do mstate.BCM.call->mstate.BCM.emit; 
   (if isStatic then 
       1 -> mstate.BCM.emit
    else
       0 -> mstate.BCM.emit
   if);
   op.out;
   
---bytecode_beginLabel:doPart---
do mstate.BCM.beginLab -> mstate.BCM.emit;
   (*'beginLab' -> comment;*)
   restartLab.labno -> mstate.BCM.emitLong;
   leaveLab.labno -> mstate.BCM.emitLong;
   
---bytecode_endLabel:doPart---
do mstate.BCM.endLab -> mstate.BCM.emit; 
   (*'endLab'->comment;*)
   restartLab.labno -> mstate.BCM.emitLong;
   leaveLab.labno -> mstate.BCM.emitLong;
   
---bytecode_break:doPart---
do mstate.BCM.break -> mstate.BCM.emit; 
   (*'break'->comment;*)
   JmpAdr.labno -> mstate.BCM.emitLong;
   (if isLeave then 
       0 -> mstate.BCM.emit
    else
       1 -> mstate.BCM.emit
   if);
 
---byteCode_cmpToBool:doPart--   
do op1.loadToReg; 
   op2.loadToReg;
   (* op3 is a register to load 0 or 1;
    * here we use the stack instead
    *)
   (if isRef then 
       mstate.BCM.cmpToBoolRef->mstate.BCM.emit; 
    else
       mstate.BCM.cmpToBool->mstate.BCM.emit; 
   if);
   cond -> mstate.BCM.emit;

   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out; 
   (if isRef then
       1 -> mstate.BCM.emit
    else
       0 -> mstate.BCM.emit
   if)
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   mstate.BCM.cmpBoolAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out;  
   
---byteCode_floatConst:doPart---
do (# 
   do mstate.BCM.pushRealCst -> mstate.BCM.emit;
      (if isBigEndian then
          %getlongAt(@@value)   -> mstate.BCM.emitLong;
          %getlongAt(@@value+4) -> mstate.BCM.emitLong;
       else
          %getlongAt(@@value+4) -> mstate.BCM.emitLong;
          %getlongAt(@@value)   -> mstate.BCM.emitLong;
      if);
   #)
   
---byteCode_saveReturn:doPart---
do (if isGpart then
       '\nShouldNotHappen:saveReturn:initCons'->putline;
       (failuretrace,'initcons') -> stop;
       mstate.BCM.initCons -> mstate.BCM.emit;
       '()V' -> mstate.BCM.emitText
   if)
   
---byteCode_return:doPart---
do mstate.BCM.return -> mstate.BCM.emit;
   RToff -> mstate.BCM.emit;

---bytecode_endMethod:doPart---
do mstate.BCM.endMethod -> mstate.BCM.emit
   
---byteCode_callPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; T[]->mstate.BCM.emitText;
   'Unknown'->mstate.BCM.emitText;
   
--byteCode_callAlloPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; 
   T[]->mstate.BCM.emitText;   (* the primitive *)
   (if proto[] <> none then
       proto[]->mstate.BCM.emitText; 
    else
       'UnknownProto' -> mstate.BCM.emitText;
       (if 'NewRR'-> T.equal then
           (failureTrace,'UnknownProto') -> stop
       if)
   if)
---bytecode_import:doPart---
do (if (Lab[] <> none) and ( Lab.length > 0) then
       (if 'exe_preExe' -> lab.equal then
           (dumpStack,'exe_preExe') -> stop
       if);
       Lab.copy -> mstate.BCM.imports.add 
   if);
   (* 'IMPORT: ' -> puttext; Lab[] -> putline *)
   
---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;

---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;
      
--byteCode_classDef:doPart--
do (if true 
    // common.switch[184] 
    // common.switch[189] then
       (* .NET *)
    else
       (* java *)
       mstate.BCM.init;
       (* when using package as in
        *    PACKAGE 'foo.bar.fisk'
        * and a pattern
        *    myClass: (# ... #)
        * className = 'foo.bar.fisk.myClass'
        * 
        * Only 'myClass' should be used as thisFileName 
        *)
       (# lastDot: @integer; realClassName: ^text
       do (if true then
              className.scanAll
              (# pos: @integer
              do pos+1 -> pos;
                 (if ch //  '.' // '\/' then pos -> lastDot if)
              #);          
          if);
          (lastDot+1,className.length)
            -> className.sub
            -> realClassName[]
            -> mstate.thisFileName[];
       #);
       className[] -> mstate.classes.add;
   if);
   className[] -> mstate.thisClassName[];
   mstate.BCM.classDef -> mstate.BCM.emit; 
   className[]->mstate.BCM.emittext;
   blockLevel -> mstate.BCM.emit;
   superName[]->mstate.BCM.emittext;
   subLevel -> mstate.BCM.emit; (* OBS: int8 assumed here *)
   orgName[] -> mstate.BCM.emittext;

   
--byteCode_endClass:doPart---
do mstate.BCM.endClass -> mstate.BCM.emit;
   (if not common.switch[184] then
       mstate.BCM.end -> mstate.BCM.emit;
       mstate.mkAsmFile
   if)
--byteCode_endCodeSeg:doPart---
do (if not isJava then 
       mstate.mkClassListFile
   if)
   
--byteCode_methodDef:doPart--
do 0 -> mstate.numTempLocals;
   mstate.BCM.methodDef -> mstate.BCM.emit; 
   methodName[]->mstate.BCM.emittext;
   signature[]->mstate.BCM.emittext;
   noOfEnterArgs -> mstate.BCM.emit;
   type -> mstate.BCM.emit;
   
--byteCode_emitTextConst:doPart---
do mstate.BCM.pushText->mstate.BCM.emit; S[]->mstate.BCM.emitText;

---byteCode_close:doPart---
do (if trace_init_close then
       '\nCLOSE: ' -> puttext; mstate.thisFullPath[] -> puttext; mstate.thisFileName[]->putline;
   if);
   183->trace(#
             do 'Close:' ->xT; mstate.thisFullPath[] -> xT; xN;
                '   thisFileName:' -> xT; mstate.thisFileName[] -> xT; xN;
                'imports: ' -> xT;
                mstate.BCM.imports.scan(# do current[] -> xT; ' '-> put #);
             #);
   (if isJava then  
       mstate.mkClassListFile;
       mstate.mkDepFile
   if);
   (if not isJava then
       mstate.BCM.end -> mstate.BCM.emit;
       mstate.mkAsmFile; 
   if);
   mstate.BCM.imports.clear;
   
---bytecode_real64toReal32:doPart---
do mstate.BCM.r64toR32 -> mstate.BCM.emit
   
---byteCode_cmpToBoolFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpToBoolFloat -> mstate.BCM.emit;
   cond -> mstate.BCM.emit;
   
---byteCode_cmpAndJmpFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpAndJmpFloat -> mstate.BCM.emit;
   cond -> mstate.BCM.emit;
   lab.out; 
   
---byteCode_addFloat:doPart---
do mstate.BCM.r64add -> mstate.BCM.emit
   
---byteCode_subFloat:doPart---
do mstate.BCM.r64sub -> mstate.BCM.emit
   
---byteCode_mulFloat:doPart---
do mstate.BCM.r64mul -> mstate.BCM.emit
   
---byteCode_divFloat:doPart---
do mstate.BCM.r64div -> mstate.BCM.emit
   
---bytecode_negFloat:doPart---
do mstate.BCM.r64neg -> mstate.BCM.emit
   
---byteCode_int2float:dopart---
do mstate.BCM.int2double -> mstate.BCM.emit
   
---byteCode_intReg2float:dopart---
do mstate.BCM.int2double -> mstate.BCM.emit
   
---byteCode_float2int:doPart---
do mstate.BCM.double2int -> mstate.BCM.emit
   
---byteCode_CallCproc:doPart---
do (# S: ^text
   do mstate.BCM.callExternal -> mstate.BCM.emit;
      '' -> S[];
      T.scanAll(#
               do (if ch > 0 then
                      ch -> S.put
               if)#);
      S[] -> mstate.BCM.emitText;   
   #)
   
---byteCode_jsrTable:doPart---
do 
   (if newVirt then
       (# R: @adrRegOperand
       do R.alloc;
          (A[],R[],4) -> ldVlImpl;
          mstate.BCM.newVirt -> mstate.BCM.emit;
       #)
    else
       mstate.BCM.callInner -> mstate.BCM.emit;
   if)
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of the assembly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do (if localFilePath[] = none then
       (* hack to signal that BCname is the currentFileName  *)
       183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
       BCname[] -> mstate.thisFileName[];
       (if not isJava then
           mstate.thisFileName.copy -> mstate.classes.add;
       if);
    else
       183 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       mstate.classes.init; (* still ? *)   
       BCname [] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[],mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       true -> mstate.BCisSplit; (* should be eliminated since
                                  * BC is always split 
                                  *)
       mstate.thisFullPath.copy -> mstate.thisFullSourcePath[];

       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);
   if);
   (if trace_init_close then
       '\nINIT: ' -> puttext; mstate.thisFullPath[] -> puttext; mstate.thisFileName[]->putline; 
   if);
   
   FIXME.init;
   mstate.BCM.init;
   
   1->ThisRegOp;
   2->CallRegOp;

---bytecode_setPackagePath:doPart---
do packagepath.copy -> mstate.thisPackagePath[];
   packagePath[] -> mstate.thisFullPath.append;
   
---bytecode_comment:doPart--
do mstate.BCM.comment -> mstate.BCM.emit;
   T[] -> mstate.BCM.emittext
