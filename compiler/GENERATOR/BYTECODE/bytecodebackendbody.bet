ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
---byteCode_mstate:descriptor---
(#  
   BCM: @ BCmachine
     (# emit:
          (# opCode: @integer
          enter opCode
          do opCode -> BC.put; 
             INNER
          #);
        emitShort:
          (# V: @integer;
          enter V
          do V -> BC.putShort
          #);
        emitLong:
          (# V: @integer
          enter V
          do V -> BC.putLong
          #);
        emit1: emit
          (# op1: @integer
          enter op1
          do op1->BC.put; INNER
          #);
        emit2: emit1
          (# op2: @integer
          enter op2
          do
          #);
        emitText: 
          (# T: ^text
          enter T[]
          do T[]->BC.puttext
          #);
     #);
   splitPathAndName:
     (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
        e: @diskentry
     enter orgPath[]
     do (if true then
            (* datpete: 2002-04-29: Using diskentry *)
            orgPath[] -> e.path;
            e.path.head -> path[]; directorychar -> path.put;
            e.path.name.prefix -> FN[];
         else
            (* Original olm code *)
            orgPath.copy->path[];
            path.scanAll
            (# i: @integer 
            do i+1->i; 
               (if ch = '.' then i->dotPos 
                else 
                   (if ch = '/'(* thePathHandler.directoryChar*) then
                       i -> slashPos
               if)if)
            #);
            (if false and common.switch[189] then
                '\nsplit1: ' -> puttext; path[] -> putline;
            if);
            
            (if dotPos > 0 then
                (dotPos,path.length)->path.delete
            if);
            (if false and common.switch[189] then
                'split2: ' -> puttext; path[] -> putline;
            if);
            (if slashPos > 0 then
                (slashPos+1,path.length)->path.sub -> FN[];
                (slashPos+1,path.length)->path.delete
            if);
            (if false and common.switch[189] then
                'split3: ' -> puttext; path[] -> puttext; 
                ' '->put; FN[] -> putline;
            if);
        if)
     exit(path[],FN[])
     #);
   
   BCisSplit: @boolean;
   c: ^text; (* ugly *)
   
   mkAsmFile:
     (# BC: ^text
     do 183->trace
        (#
        do 'mkAsmFile: ' ->xT; thisFullPath[] -> xT 
        #);
        (if not BCisSplit then
            thisFullPath[] -> splitPathAndNAme -> (thisFullPath[],c[]);
            true -> BCisSplit
        if);
        thisFileName[] -> (thisFullPath.copy).append -> BC[];
        183->trace(#do 'mkasmFile:BC:' -> xT; BC[] -> xT #);
        '.bin'->(BC.copy).append->mstate.BCM.save;
        '.bin'->(BC.copy).append->mstate.BCM.restore;
        (if true
         // common.targetMachineId = common.jvm then
            mstate.BCM.emitJasmin;
         // common.targetMachineId = common.clr then
            mstate.BCM.emitClr
         else
            'byteCode_close: unknown platform' -> screen.putline;
        if);
        (if not common.switch[23] then
            (* Delete .bin file *)
            (# e: @file;
            do '.bin'->(BC.copy).append->e.name;
               e.delete;
            #);
        if);
     #);
   numTempLocals: @integer;
   thisFullPath,         (* full path for current source/object file *)
   thisSourceFileName,   (* name of current source file *)
   thisFileName,         (* name of current object file  *)
   thisClassName: ^text; (* name of current class 
                          * for java: currentFile = currentClass
                          * for .NET: thye may differ
                          *)
   hasClassEQfileName: @boolean; (* a class has the same name as 
                                  * thisSourceFileName; used by
                                  * Java - see mkClassListFile
                                  *)
   jasmin: @file;
   jasminIsOpen: @boolean;
   classes: @
     (# L: [4] ^text; top: @integer;
        init: (# do 0 -> top #);
        add:
          (# cn: ^text
          enter cn[]
          do (if (top+1->top) > L.range then
                 L.range -> L.extend
             if);
             cn[] -> L[top][]
          #);
        scan:
          (# current: ^text
          do (for i: top repeat
                  L[i][] -> current[];
                  inner
          for)#)
     #);
   mkClassListFile:
     (# thisFullPath: ^text; F: @file;
        dep_ext: ^text;
     enter thisFullPath[]
     do '.clst'
          -> (thisSourceFileName[]->(thisFullPath.copy).append).append 
          -> F.name;
        (if false then
            '\nClassFileName: ' -> screen.puttext; 
            F.name -> screen.puttext; 
            ', Path: '->screen.puttext; 
            ThisFullPath[] -> screen.putline;
        if);
        F.openWrite;
        (*'opened for writing: ' -> screen.puttext; F.name -> screen.putline;*)
        classes.scan
        (#
        do current[] -> (thisFullPath.copy).append -> F.putline;
        #);
        F.close;
        (if not hasClassEQfileName then
            (* for dependency analysis we have to ensure that
             * there is a .class -file that has the same name
             * as the source file
             *)
            (if isIL then
                '.dll' -> dep_ext[]; (* .il? *)
             else
                '.class' -> dep_ext[];
            if);
            dep_ext[]
              -> (thisSourceFileName[]->(thisFullPath.copy).append).append 
              -> F.name;
            F.openWrite;
            'for dependency analysis\n' -> F.puttext;
            F.close;
        if)
     #);
#)
---bytecode_newImp:doPart---
do mstate.BCM.position -> mstate.BCM.emit;
   astRef -> mstate.BCM.emitShort 

---byteCode_textOperand_out:doPart---
do T[]->mstate.BCM.emittext
   
---byteCode_dataRegOperand_out:doPart---
do rn->mstate.BCM.emit 
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.BCM.emit 
   
---byteCode_LocalLab_def:doPart---
do mstate.BCM.labelDef -> mstate.BCM.emit;
   labNo -> mstate.BCM.emitShort;
   
---byteCode_LocalLab_out:doPart---
do mstate.BCM.label -> mstate.BCM.emit;
   (if labNo >= common.two16 then
       'localLab_out:labNo>65536' -> putline
   if);
   labNo -> mstate.BCM.emitShort
   
---byteCode_RegAdr_out:doPart---   
do reg.out; 
   (if fieldName[] <> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText
    else
       (*'regAdr:no FieldName' -> putline;*)       
       1 -> mstate.BCM.emit;
       'NoFieldName' -> mstate.BCM.emitText
   if);
   off -> mstate.BCM.emit; 
   size -> mstate.BCM.emit;
   0 (* ONlevel*) -> mstate.BCM.emit;
   (* 18/06/02: ONlevel can be eliminated and
    * ONlevel > 0 ==> isField = true
    * BUT! For loadOrigin ONlevel is used
    * but does NOT involve blocks. 
    *)
   (if isField then 
       1 -> mstate.BCM.emit;
       (if receiverType[] <> none then
           (if not common.switch[189] (* not java *) then
               (if (receiverType.length->receiverType.inxGet) = ';' then
                   (2,receiverType.length-1)  (* ugly *)
                     -> receiverType.sub 
                     -> mstate.BCM.emitText
                else
                   receiverType[] -> mstate.BCM.emitText
               if)
            else
               receiverType[] -> mstate.BCM.emitText
           if)
        else
           '\nOBS!bytecode_regAdrOut:isField:no:receiverType'->putline;
       if)
    else 
       (* A method variable and this should be ok so no error here *)
       0 -> mstate.BCM.emit 
   if);
   (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText;
    else
       0 -> mstate.BCM.emit        
   if)
   
---byteCode_RegAdr_index:doPart---
do  mstate.BCM.index->mstate.BCM.emit;
   '\nindex:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do areg.out;
   (if fieldName[] <> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText
    else
       (*'InxRegAdr:no fieldName' -> putline;*)
       1 -> mstate.BCM.emit;
       'NoInxFieldName'->mstate.BCM.emitText
   if);

   off -> mstate.BCM.emit;
   size -> mstate.BCM.emit;   
   ONlevel -> mstate.BCM.emit;  
   2 -> mstate.BCM.emit; (* isField = 2 signals array *)
   (* all the fields; areg,off,size,ONlevel, are superflous
    * and not used by the bytecode
    *)
   (if fieldType[] <> none then
       1 -> mstate.BCM.emit;
       fieldType[] -> mstate.BCM.emitText
    else
       0 -> mstate.BCM.emit        
   if)
   
---byteCode_nop:doPart---
do mstate.BCM.nop -> mstate.BCM.emit;
   
---byteCode_ldCst:doPart---
do (if true
    // (- 128 <= C) and (C <= 127) then
       (mstate.BCM.pushCst_s8,C) -> mstate.BCM.emit1;
    // (- common.two15 <= C) and (C <= (common.two15-1)) then
       mstate.BCM.pushCst_s16 -> mstate.BCM.emit;
       C -> mstate.BCM.emitShort; (* is this one sign extended?*)
    else
       mstate.BCM.pushCst_s32 -> mstate.BCM.emit;
       C -> mstate.BCM.emitLong
   if)
   
---byteCode_ldNone:doPart---
do mstate.BCM.pushNone -> mstate.BCM.emit;
   
---byteCode_ldValImpl:doPart---
do (if A.isOrigin then
       mstate.BCM.loadOrigin -> mstate.BCM.emit;
       (* Regarding ONlevel, see regAdr_out
        * and BCjasminBody.
        * But apparently only ONlevel = 0 and
        * ONlevel > 0 is used in BCjasminBody
        * Find out if isField can be used
        *)
       (if true
        // (A.ONlevel = 0) and A.isField then 
           'loadOrigin: ONlevel=0. isField=true' -> putline
        // (A.ONlevel > 0) and not A.isField then
           'loadOrigin: ONlevel>0, isField=false' -> putline
       if);
       (* Here we should replace ONlevel with
        * isField: 0 or 1 
        *)
       A.ONlevel -> mstate.BCM.emit;
       (if A.receiverType[] <> none then
           1 -> mstate.BCM.emit;
           (if not common.switch[189] (* not java *) then
               (if (A.receiverType.length->A.receiverType.inxGet) = ';' then
                   (2,A.receiverType.length-1)  (* ugly *)
                     -> A.receiverType.sub 
                     -> mstate.BCM.emitText
                else
                   A.receiverType[] -> mstate.BCM.emitText
               if)
            else
               A.receiverType[] -> mstate.BCM.emitText
           if)
        else
           (* in regAdr_out we test isField before
            * A.receiverType[]<>none as above
            *)
           (if A.isField then
               '\nOBS!bytecode_ldVal:isField:no:receiverType'->putline;
            else
               0 -> mstate.BCM.emit
           if)
       if);
       (if A.fieldType[] <> none then
           1 -> mstate.BCM.emit;
           A.fieldType[] -> mstate.BCM.emittext;
        else
           0 -> mstate.BCM.emit
       if);   
    else
       (if A.isRef then
           mstate.BCM.loadRef->mstate.BCM.emit
        else
           mstate.BCM.pushVal->mstate.BCM.emit
       if); 
       A.out;
       (if A.isRef then (* cleanup/elim isRef?*)
           (if A.fieldType[] <> none then
               A.fieldType[] -> mstate.BCM.emittext
            else
               'ldValImpl_UnknownType' -> mstate.BCM.emittext
       if)if)
   if);
   elimSign:
     (if not A.signed and (A.fieldType[]<>none) then
         (if isJava then
             (if ('C' -> A.fieldType.equal) 
                 or ((1->A.fieldType.inxget) = '[') 
                 then leave elimSign
             if)
          else
             (if ('char' -> A.fieldType.equal) 
                 or ((A.fieldType.length->A.fieldType.inxget) = ']') 
                 then leave elimSign
             if)
         if);
         (if A.size
          // 1 then
             (&dataRegOperand[],0xFF->newCstOp,4) -> gAnd
          // 2 then
             (&dataRegOperand[],0xFFFF->newCstOp,4) -> gAnd
         if)
     if);
   
---byteCode_ByteSwap:doPart---
do (if long then
       (arithCodes.byteSwapLong,ar[])->callUnFunc
    else
       (arithCodes.byteSwapShort,ar[])->callUnFunc
   if);

---byteCode_loadRef:doPart---
do (if knownSourceClassName[] <> NONE then
       mstate.BCM.loadQRef->mstate.BCM.emit;
    else
       mstate.BCM.loadRef->mstate.BCM.emit;
   if);
   A.out;
   basicSourceClassName[] -> mstate.BCM.emittext;
   (if knownSourceClassName[] <> NONE then
       knownSourceClassName[] -> mstate.BCM.emittext
   if);
   
---byteCode_stValImpl:doPart---
do mstate.BCM.stVal->mstate.BCM.emit; 
   A.out;   
   
---byteCode_cpReg:doPart---
do mstate.BCM.pushReg->mstate.BCM.emit; R1.out;   
   
---byteCode_gLea:doPart---
do (if true 
    // op1.isRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isInxRegAdr then
       mstate.BCM.pushAdr->mstate.BCM.emit; op1.out
    // op1.isTextOp then
       mstate.BCM.pushtext->mstate.BCM.emit; op1.out
    else
       '\nglea: operand type not handled'->putline
   if)   
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
--bytecode_loadRange:doPart--
do mstate.BCM.loadRange ->mstate.BCM.emit
   
---byteCode_duplicate:doPart---
do mstate.BCM.dup -> mstate.BCM.emit;
   pos -> mstate.BCM.emit;
   type -> mstate.BCM.emit;
   
---byteCode_allocAndStoreLocal:doPart---
do (# RA: ^mch.RegAdr;
      first: @char;
   do &mch.RegAdr[] -> RA[];
      mstate.numTempLocals+1 -> mstate.numTempLocals;
      -mstate.numTempLocals -> RA.off;
      (if type[]=NONE then
          '\nbyteCode_allocAndStoreLocal: type is NONE!'->putline;
          (*(dumpstack, 'byteCode_allocAndStoreLocal: type is NONE!') -> stop;*)
          'AllocAndStoreLocal_UnknownType' -> type[];
       else
          (if isJava then
              ((type.lgth>=1) and ((type.T[1] = 'L') or (type.T[1]='['))) 
                -> RA.isRef;
              type.copy -> RA.fieldType[];
           else 
              true -> RA.isRef;              
          if);
      if);
      (if false then
          'bytecodebackendbody: AllocAndStoreLocal:' -> screen.putline;
          -mstate.numTempLocals->screen.putint; 
          '/'->screen.put; 
          type[]->screen.putline;
      if);
      (none,false,'',type[]) -> RA.asgRefReg;
      RA[] -> A[]
   #)
   
---byteCode_loadLocal:doPart---
do (* FIXME: don't we need the variable offset? *)
   mstate.BCM.loadLocal -> mstate.BCM.emit
   
--byteCode_popStack:doPart---
do (if isDouble then
       mstate.BCM.pop2-> mstate.BCM.emit
    else
       mstate.BCM.pop-> mstate.BCM.emit
   if)
   
--bytecode_declareField:doPart---
   (* to replace emitCk 
    *)
do mstate.BCM.field ->mstate.BCM.emit; 
   off -> mstate.BCM.emit;
   (if fieldName[]<> none then
       1 -> mstate.BCM.emit;
       fieldName[] -> mstate.BCM.emitText;
    else
       'declareField:no fieldName' -> putline;
       0 -> mstate.BCM.emit
   if);
   (if fieldSig[]<> none then
       fieldSig[] -> mstate.BCM.emitText;
    else
       'OBS! no fieldSig' -> putline
   if);
   fieldKind -> mstate.BCM.emit;
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do mstate.BCM.field ->mstate.BCM.emit; 
   regRef -> mstate.BCM.emit;
   (if routineName[] <> none then
       RoutineName[] -> mstate.BCM.emitText;
    else

   if);
   (if RefName[] <> none then
       1 -> RefName.inxGet -> mstate.BCM.emit
    else
       '?' -> mstate.BCM.emit
   if)
   
---byteCode_constructorDef:doPart---
do mstate.BCM.initCons -> mstate.BCM.emit;
   signature[] -> mstate.BCM.emitText
   
---byteCode_tstNone:doPart---
do mstate.BCM.loadRef->mstate.BCM.emit; A.out;
   'UnknownNONE' -> mstate.BCM.emittext
   
---byteCode_doAsgRefAdr:doPart---
do (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; *)
   (if withQua then
       'withQUA'->putline;
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRefAdr:storeorigin'->mch.comment;
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit
       if)
   if);   
   thisAdr.out;
   (if destClassName[] <> none then
       DestClassName[] -> mstate.BCM.emittext
    else
       'UnknownAsgRefAdr'-> mstate.BCM.emittext
   if)
   
---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   (* mstate.BCM.pushAdr->mstate.BCM.emit; thisAdr.out; (* destination *)
   (* a swap is probably needed here *)
   (if withQua then
       mstate.BCM.storeQRef->mstate.BCM.emit; (* OBS! Don't work *)
    else
       (if thisAdr.isOrigin then
           'doAsgRegAdr:storeorigin'->mch.comment;
           'DestClassName:'->mch.comment;
           DestClassName -> mch.comment;
           (*'thisAdr.descName: ' -> mch.comment;
           thisAdr.descName -> mch.comment;*)
           mstate.BCM.storeOrigin->mstate.BCM.emit
        else
           mstate.BCM.storeRef->mstate.BCM.emit;
       if)
   if);
   thisAdr.out;
   DestClassName[] -> mstate.BCM.emittext
---bytecode_checkCast:doPart---
do mstate.BCM.cast->mstate.BCM.emit; type[]->mstate.BCM.emitText
   
---byteCode_jmpTlong:doPart---
do mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jmplong:doPart---
do mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText
   
---byteCode_jsrT:doPart---
do mstate.BCM.call->mstate.BCM.emit; T[]->mstate.BCM.emitText   
   
--byteCode_gJmp:doPart---
do mstate.BCM.jmp->mstate.BCM.emit; op.out;
   
--byteCode_gJsr:doPart---
do mstate.BCM.call->mstate.BCM.emit; 
   (if isStatic then 
       1 -> mstate.BCM.emit
    else
       0 -> mstate.BCM.emit
   if);
   op.out;
   
---bytecode_beginLabel:doPart---
do mstate.BCM.beginLab -> mstate.BCM.emit;
   (*'beginLab' -> comment;*)
   restartLab.labno -> mstate.BCM.emitLong;
   leaveLab.labno -> mstate.BCM.emitLong;
   
---bytecode_endLabel:doPart---
do mstate.BCM.endLab -> mstate.BCM.emit; 
   (*'endLab'->comment;*)
   restartLab.labno -> mstate.BCM.emitLong;
   leaveLab.labno -> mstate.BCM.emitLong;
   
---bytecode_break:doPart---
do mstate.BCM.break -> mstate.BCM.emit; 
   (*'break'->comment;*)
   JmpAdr.labno -> mstate.BCM.emitLong;
   (if isLeave then 
       0 -> mstate.BCM.emit
    else
       1 -> mstate.BCM.emit
   if);
 
---byteCode_cmpToBool:doPart--   
do op1.loadToReg; 
   op2.loadToReg;
   (* op3 is a register to load 0 or 1;
    * here we use the stack instead
    *)
   (if isRef then 
       mstate.BCM.cmpToBoolRef->mstate.BCM.emit; 
    else
       mstate.BCM.cmpToBool->mstate.BCM.emit; 
   if);
   cond -> mstate.BCM.emit;

   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out; 
   (if isRef then
       1 -> mstate.BCM.emit
    else
       0 -> mstate.BCM.emit
   if)
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   mstate.BCM.cmpBoolAndJmp->mstate.BCM.emit; 
   cond -> mstate.BCM.emit;
   lab.out;  
   
---byteCode_floatConst:doPart---
do (# 
   do mstate.BCM.pushRealCst -> mstate.BCM.emit;
      (if isBigEndian then
          %getlongAt(@@value)   -> mstate.BCM.emitLong;
          %getlongAt(@@value+4) -> mstate.BCM.emitLong;
       else
          %getlongAt(@@value+4) -> mstate.BCM.emitLong;
          %getlongAt(@@value)   -> mstate.BCM.emitLong;
      if);
   #)
   
---byteCode_saveReturn:doPart---
do (if isGpart then
       '\nShouldNotHappen:saveReturn:initCons'->putline;
       (failuretrace,'initcons') -> stop;
       mstate.BCM.initCons -> mstate.BCM.emit;
       '()V' -> mstate.BCM.emitText
   if)
   
---byteCode_return:doPart---
do mstate.BCM.return -> mstate.BCM.emit;
   RToff -> mstate.BCM.emit;

---bytecode_endMethod:doPart---
do mstate.BCM.endMethod -> mstate.BCM.emit
   
---byteCode_callPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; T[]->mstate.BCM.emitText;
   'Unknown'->mstate.BCM.emitText;
   
--byteCode_callAlloPrim:doPart--
do mstate.BCM.callPrim->mstate.BCM.emit; 
   T[]->mstate.BCM.emitText;   (* the primitive *)
   (if proto[] <> none then
       proto[]->mstate.BCM.emitText; 
    else
       'UnknownProto' -> mstate.BCM.emitText;
       (if 'NewRR'-> T.equal then
           (failureTrace,'UnknownProto') -> stop
       if)
   if)
---bytecode_import:doPart---
do (if (Lab[] <> none) and ( Lab.length > 0) then
       (if 'exe_preExe' -> lab.equal then
           (dumpStack,'exe_preExe') -> stop
       if);
       Lab.copy -> mstate.BCM.imports.add 
   if);
   (* 'IMPORT: ' -> puttext; Lab[] -> putline *)
   
---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;

---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.func -> mstate.BCM.emit;
   opCode -> mstate.BCM.emit;
      
--byteCode_classDef:doPart--
do (if true 
    // common.switch[184] // common.switch[189] then
       (* .NET *)
    else
       (* java *)
       mstate.BCM.init;
       className[] -> mstate.thisFileName[];
       (if hostIsWindows then
           (if className[] -> mstate.thisSourceFileName.equalNCS then
               true -> mstate.hasClassEQfileName
           if)       
        else
           (if className[] -> mstate.thisSourceFileName.equal then
               true -> mstate.hasClassEQfileName
           if)       
       if);
   if);
   className[] -> mstate.thisClassName[];
   className[] -> mstate.classes.add;
   mstate.BCM.classDef -> mstate.BCM.emit; 
   className[]->mstate.BCM.emittext;
   blockLevel -> mstate.BCM.emit;
   superName[]->mstate.BCM.emittext;
   subLevel -> mstate.BCM.emit; (* OBS: int8 assumed here *)
   orgName[] -> mstate.BCM.emittext;

   
--byteCode_endClass:doPart---
do mstate.BCM.endClass -> mstate.BCM.emit;
   (if not common.switch[184] then
       mstate.BCM.end -> mstate.BCM.emit;
       mstate.mkAsmFile
   if)
   
--byteCode_methodDef:doPart--
do 0 -> mstate.numTempLocals;
   mstate.BCM.methodDef -> mstate.BCM.emit; 
   methodName[]->mstate.BCM.emittext;
   signature[]->mstate.BCM.emittext;
   noOfEnterArgs -> mstate.BCM.emit;
   type -> mstate.BCM.emit;
   
--byteCode_emitTextConst:doPart---
do mstate.BCM.pushText->mstate.BCM.emit; S[]->mstate.BCM.emitText;

---byteCode_close:doPart---
do 183->trace(#
             do 'Close:' ->xT; mstate.thisFullPath[] -> xT; xN;
                '   thisFileName:' -> xT; mstate.thisFileName[] -> xT; xN;
                'imports: ' -> xT;
                mstate.BCM.imports.scan(# do current[] -> xT; ' '-> put #);
             #);
   mstate.thisFullPath[] -> mstate.mkClassListFile;
   mstate.BCM.end -> mstate.BCM.emit;
   mstate.mkAsmFile; 
   mstate.BCM.imports.clear;
   
---bytecode_real64toReal32:doPart---
do mstate.BCM.r64toR32 -> mstate.BCM.emit
   
---byteCode_cmpToBoolFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpToBoolFloat -> mstate.BCM.emit;
   cond -> mstate.BCM.emit;
   
---byteCode_cmpAndJmpFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   mstate.BCM.cmpAndJmpFloat -> mstate.BCM.emit;
   cond -> mstate.BCM.emit;
   lab.out; 
   
---byteCode_addFloat:doPart---
do mstate.BCM.r64add -> mstate.BCM.emit
   
---byteCode_subFloat:doPart---
do mstate.BCM.r64sub -> mstate.BCM.emit
   
---byteCode_mulFloat:doPart---
do mstate.BCM.r64mul -> mstate.BCM.emit
   
---byteCode_divFloat:doPart---
do mstate.BCM.r64div -> mstate.BCM.emit
   
---bytecode_negFloat:doPart---
do mstate.BCM.r64neg -> mstate.BCM.emit
   
---byteCode_int2float:dopart---
do mstate.BCM.int2double -> mstate.BCM.emit
   
---byteCode_intReg2float:dopart---
do mstate.BCM.int2double -> mstate.BCM.emit
   
---byteCode_float2int:doPart---
do mstate.BCM.double2int -> mstate.BCM.emit
   
---byteCode_CallCproc:doPart---
do (# S: @text
   do mstate.BCM.callExternal -> mstate.BCM.emit;
      T.scanAll(#
               do (if ch > 0 then
                      ch -> S.put
               if)#);
      S[] -> mstate.BCM.emitText;   
   #)
   
---byteCode_jsrTable:doPart---
do 
   (if newVirt then
       (# R: @adrRegOperand
       do R.alloc;
          (A[],R[],4) -> ldVlImpl;
          mstate.BCM.newVirt -> mstate.BCM.emit;
       #)
    else
       mstate.BCM.callInner -> mstate.BCM.emit;
   if)
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of theasmmebly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do (if localFilePath[] = none then
       (* hack to signal that BCname is the currentFileName  *)
       183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
       BCname[] -> mstate.thisFileName[];
       (if hostIsWindows then
           (if BCname[] -> mstate.thisSourceFileName.equalNCS then
               true -> mstate.hasClassEQfileName
           if)
        else
           (if BCname[] -> mstate.thisSourceFileName.equal then
               true -> mstate.hasClassEQfileName
           if)
       if);
    else
       183 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       BCname [] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[]
       ,mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       true -> mstate.BCisSplit; (* should be eliminated since
                                  * BC is always split 
                                  *)
       (if common.switch[189] (*.NET *) then
           (*true -> mstate.hasClassEQfileName*)
       if);

       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);
   if);
   
   FIXME.init;
   mstate.BCM.init;
   mstate.classes.init;
   
   1->ThisRegOp;
   2->CallRegOp;

   
---bytecode_comment:doPart--
do mstate.BCM.comment -> mstate.BCM.emit;
   T[] -> mstate.BCM.emittext
