ORIGIN 'bytecodebackend';
include '~beta/basiclib/file';
INCLUDE '~beta/basiclib/fileSetExe';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '../JAVA/javaimage';
INCLUDE 'BCjavaSupport';

-- machinefactorylib: Attributes --
generateDebugInfo:  (# exit common.switch[41] #);
trace_opcodes: (# exit common.switch[190] #); 

--LIB:attributes--
trace_init_close: (# exit false #);
_checkcast:			(# exit 192 #);
makeSignature:
  (# sig: ^text
  enter sig[]
  do (if (1->sig.inxGet) = '[' then
         (* this should really be handled at a higher level *)
      else
         sig[] -> textToClassref -> sig[];
     if)
  exit sig[]
  #);

splitSignature:
  (# signature: ^text;
     name: ^text;
     isStatic: @boolean;
  enter signature[]
  do (* Signature e.g.: java/lang/String/endsWith(Ljava/lang/String;)Z *)
     signature.copy -> signature[];
     &text[] -> name[];
     (if 'static ' -> ((1,7) -> signature.sub).equal then
         true -> isStatic;
         (1,7) -> signature.delete;
     if);
     scan:
       (for i:signature.lgth repeat
            (if signature.T[i]='(' then
                (1,i-1) -> signature.sub -> name[];
                (1,i-1) -> signature.delete;
                leave scan;
            if);
       for);
     INNER;
     (* name:      java/lang/String/endsWith *)
     (* signature: (Ljava/lang/String;)Z     *)
  exit (name[], signature[], isStatic)
  #);
splitClassSignature: SplitSignature
  (# lastSlash: @integer;
     method: ^text;
  do (* name e.g.: java/lang/String/endsWith *)
     &text[] -> method[];
     scan:
       (for i:name.lgth repeat
            (if name.T[i]='(' then leave scan if);
            (if name.T[i]='/' then i->lastSlash if)
       for);
     (if lastSlash>0 then
         (1, lastSlash-1) -> name.sub -> method[];
         (1, lastSlash) -> name.delete;
     if);
  exit method[]
  #);

---byteCode_mstate:descriptor---
(# jcf: ^JavaImage;
   
   bcstate: @ <<slot new_bcstate:descriptor>>;
   
   noArgsInSignature:
     (# nargs: @int16;
        T: ^text;
     enter T[]
     do 0 -> nargs;
        T.reset;
        (for i:T.lgth repeat
             (if T.T[i]
              // '(' then
                 (* start of parameter list *)
              // ')' then
                 (* end of parameter list *)
                 leave noArgsInSignature;
              // 'B' // 'C' // 'D' // 'F' // 'I' // 'J' // 'S' // 'Z' then
                 (* BaseType *)
                 nargs+1 -> nargs;
              // 'L' then
                 (* ObjectType *)
                 i+1 -> i;
                 scanToSemiColon:
                   (if T.T[i]<>';' then i+1 -> i; restart scanToSemiColon if);
                 nargs+1 -> nargs;
              // '[' then
                 (* ArrayType *)
                 i+1 -> i;
                 scanToNonBrace:
                   (if t.t[i]='[' then i+1 -> i; restart scanToNonBrace if);
                 nargs+1 -> nargs;
              else
                 'noArgsInSignature: unknown character \''->screen.puttext;
                 t.t[i] -> screen.put;
                 '\' in signature \'' -> screen.puttext;
                 t[] -> screen.puttext;
                 '\'' -> screen.putline;
             if);
        for);
     exit nargs
     #);
   
   jvmFIXME:  (* Bytecode compiler cannot handle patterns with the
               * same name in different files for the same attributes slot;
               * there is a conflivting FIXME in BCdotnetBody
               *)
     (# T: ^text
     enter T[]
     do (if not common.switch[188] then
            'FIXME: ' -> (T.copy).prepend -> T[];
            '***** ' -> screen.puttext; T[] -> screen.putline;
            (* Possibly generate an IOcall with T[] too *)         
        if);
     #);

   trace_opcode:
     (# opcode: @integer;
     enter opcode
     do(* (if trace_opcodes then
        (if opcode
        // comment then
        // position then
        else
        'Opcode %d: %s ' -> screen.putformat(# do opCode -> d;  opCode->asText->s; #);
        (if (32<=opcode) and (opcode<=126) then
        '\'%c\' ' -> screen.putformat(# do opcode->c #);
        if);
        screen.newline;
        if)
        if)*)
     #);
   imports: @
     (# L: [100] ^text; top: @integer;
        clear: (#do 0 -> top #);
        has: booleanValue
          (# id: ^text
          enter id[]
          do (for i: top repeat
                  (if id[] -> L[i].equal then 
                      true -> value; 
                      leave has 
          if)for)#);
        add:
          (# id: ^text
          enter id[]
          do (if not (id[] -> has) then
                 (if (top+1->top) > L.range then L.range -> L.extend if);
                 id[] -> L[top][];
             if)
          #);
        scan:
          (# current: ^text
          do (for i: top repeat
                  L[i][] -> current[];
                  inner;
             for)
          #)
     #);

   allocLocal:
     (* Meaning of values in BCstate.fields.LocalVariables:
      * 0: free, -1: unknown, 1: integertype, 2: referencetype, 3: double
      *)
     (# name, type: ^text;
        slot: @integer;
     enter (name[], type[])
     do 0 -> slot;
        (if false then
            1->trace(#
                    do 'local: ' -> xT;
                       name[] -> xT; ' ' -> put; type[] -> xT
        #)if);
        findSlot:
          (for i:BCstate.fields.LocalVariables.range repeat
               (if BCstate.fields.LocalVariables[i] = 0 then
                   i -> slot;
                   leave findSlot;
               if);
          for);
        (if slot=0 then
            (* Get a new slot *)
            BCstate.fields.LocalVariables.range+1 -> slot;
            BCstate.fields.LocalVariables.range (* at least 1 *)
              -> BCstate.fields.LocalVariables.extend;         
        if);
        -1 -> BCstate.fields.LocalVariables[slot];
        (if generateDebugInfo and (name[]<>NONE) and (type[]<>NONE) then
            (65535, 0, name[], type[]) -> jcf.emitLocalVariableDefinition;
        if);
        (if false then
            'allocLocal: allocated slot '->puttext; 
            slot-> putint; 
            ', LIP=' -> puttext;
            jcf.currentmethod.LIP -> putint;
            newline;
        if);
     exit slot
     #);
   allocLocalDouble:
     (# name: ^text;
        slot: @integer;
     enter (name[])
     do 0 -> slot;
        find2Slots:
          (for i:BCstate.fields.LocalVariables.range-1 repeat
               (if (BCstate.fields.LocalVariables[i] = 0) and
                   (BCstate.fields.LocalVariables[i+1] = 0) then
                   i -> slot;
                   leave find2Slots;
               if);
          for);
        (if slot=0 then
            (* Get a new slot *)
            BCstate.fields.LocalVariables.range+2 -> slot;
            BCstate.fields.LocalVariables.range+1 (* at least 2 *)
              -> BCstate.fields.LocalVariables.extend;         
        if);
        -1 -> BCstate.fields.LocalVariables[slot];
        -1 -> BCstate.fields.LocalVariables[slot+1];
        (if generateDebugInfo and (name[]<>NONE) then
            (65535, 0, name[], 'D') -> jcf.emitLocalVariableDefinition;
        if);
        (if false then
            'allocLocal: allocated double slot '->puttext; 
            slot-> putint; 
            ', LIP=' -> puttext;
            jcf.currentmethod.LIP -> putint;
            newline;
        if);
     exit slot
     #);

   releaseLocal:
     (# slot: @integer
     enter slot
     do (if BCstate.fields.LocalVariables[slot] = 3 (* double *) then
            0 -> BCstate.fields.LocalVariables[slot];
            0 -> BCstate.fields.LocalVariables[slot+1]
         else
            0 -> BCstate.fields.LocalVariables[slot]
        if);
     #);
   
   textOperandArg: ^text; (* ugly *)
   localLabArg: @integer; (* ugly *)
   
   A: @Address;
   
   Address:
     (#
        reg,off,size,isField,ONlevel: @integer; 
        fieldName,descName,fieldType: ^text;
        emitFieldAndType:
          (# isOrigin: @boolean;
             ClassName, TheFieldName, TheFieldType: ^text;
          enter isOrigin
          do INNER;
             (if isField = 1 then
                 descName[] -> ClassName[];
              else 
                 (* this part should be eliminated *)
                 ONlevel -> BCstate.blocks.class -> ClassName[];
             if);
             (if isOrigin then
                 'origin' -> TheFieldName[]
              else
                 fieldName[] -> TheFieldName[]
             if);
             (if TheFieldType[]=NONE (* May have been set in INNER *) then
                 (if fieldType[] <> none then
                     (if (fieldType.length <= 2) or
                         ((fieldType.length -> fieldType.inxGet) = ';') then
                         fieldType.copy -> TheFieldType[];
                         (if isField=2 then '[' -> TheFieldType.prepend; if);
                      else
                         (* we do come here, but we should perhaps fix this *)
                         (if fieldtype[] = none then
                             (failureTrace,'makeSig-1') -> stop;
                         if);
                         fieldType[] (*-> makeSignature*) -> TheFieldType[];
                     if)
                  else
                     'I' -> TheFieldType[];
                     'OBS! missing type info (fieldType)' -> jvmFIXME;
                 if);
             if);
             (ClassName[], TheFieldName[], TheFieldType[]) -> jcf.emitFieldRef; 
          #);
        load:
          (#
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal then
                         iaload -> jcf.emit;
                      // 'C' -> fieldType.equal then
                         caload -> jcf.emit;
                      // 'Z' -> fieldType.equal 
                      // 'B' -> fieldType.equal then
                         baload -> jcf.emit;  
                      // 'S' -> fieldType.equal then
                         saload -> jcf.emit
                      // 'D' -> fieldType.equal then
                         daload -> jcf.emit
                      // 'J' -> fieldType.equal then
                         laload -> jcf.emit;
                      else
                         aaload -> jcf.emit;
                         (* well now we assume reference type,
                          * i.e. NOT wrong
                          (if not common.switch[188] then
                          'wrong fieldType'  -> commentstream.puttext;
                          if)
                          *)
                     if)
                  else
                     iaload -> jcf.emit;
                     (if not common.switch[188] then
                         'missing fieldType'  -> commentstream.puttext;
                     if);
                 if)
              else
                 (if ONlevel > 0 then
                     getfield  -> jcf.emit;
                     emitFieldAndType;
                  else
                     (if isField=1 then
                         getfield  -> jcf.emit;
                         emitFieldAndType;
                      else
                         (* method field *)
                         (* clean up*)
                         (if (fieldType[] <> none) then
                             (if true
                              // 'D' -> fieldType.equal 
                                 (* double/real *)
                                 then
                                 (if off < 0 then
                                     (off) -> allocMappedLocal 
                                       -> dloadLocal
                                  else
                                     (dload, dload_0, off) -> emitMemOp
                                 if);
                              // 'F' -> fieldType.equal 
                                 (* float/real32 *)
                                 then
                                 (if off < 0 then
                                     1->trace(#
                                             do 'BCjavaBody:load: ' -> xT; 
                                                'missing floadlocal' -> xT
                                             #)
                                  else
                                     display;
                                     (fload, fload_0, off) -> emitMemOp
                                 if);
                                 
                              // 'J' -> fieldType.equal then
                                 (if off < 0 then
                                     (off) -> allocMappedLocal 
                                       -> dloadLocal
                                  else
                                     (lload, lload_0, off) -> emitMemOp
                                 if);
                              else
                                 (if off<0 then
                                     (off) -> allocMappedLocal -> loadLocal
                                  else
                                     (iload, iload_0, off) -> emitMemOp
                                 if)                                    
                             if)                                    
                          else 
                             (if off<0 then
                                 (off) -> allocMappedLocal -> loadLocal
                              else
                                 (iload, iload_0, off) -> emitMemOp
                             if)
                         if)
                     if)
                 if);
             if)
          #);
        store:
          (# 
          do (* local field - object/method ??*)
             (if isField = 2 then
                 (* array *)
                 (if fieldType[] <> none then
                     (if true
                      // 'I' -> fieldType.equal then
                         iastore -> jcf.emit;
                      // 'C' -> fieldType.equal then
                         castore -> jcf.emit;
                      // 'Z' -> fieldType.equal
                      // 'B' -> fieldType.equal then
                         bastore -> jcf.emit;
                      // 'S' -> fieldType.equal then
                         sastore -> jcf.emit
                      // 'D' -> fieldType.equal then
                         dastore -> jcf.emit
                      else
                         (if fieldType.length > 2 then
                             aastore -> jcf.emit
                          else
                             (if not common.switch[188] then
                                 'unknown fieldType: ' -> puttext;
                             if);
                             fieldType[] -> putline;
                             iastore -> jcf.emit;
                         if)
                     if)
                  else
                     iastore -> jcf.emit;
                     (if not common.switch[188] then
                         'missing fieldType'  ->putline
                     if);
                 if)
              else
                 (if ONlevel > 0 then
                     putfield  -> jcf.emit;
                     emitFieldAndType;
                  else
                     (if isField=1 then
                         putfield  -> jcf.emit;
                         emitFieldAndType;
                      else
                         (* FIXME: datpete: 
                          * I think stuf is missing here for other types than int AND for mapped locals. 
                          * See Load above 
                          *)
                         (istore, istore_0, off) -> emitMemOp
                     if)
             if)if)
          #);
        storeRef:
          (# withQua,isOrigin,isRef: @boolean; 
             class: ^text;
          enter(withQua,isOrigin,class[])
          do (*BC.gettext -> class[];*)
             ((class.lgth>=1) and ((class.T[1] = 'L') or (class.T[1]='['))) -> isRef;
             (if withQua then
                 _checkcast  -> jcf.emit;

                 (if true then
                     class[] -> emitCheckCast
                  else
                     class.copy -> classRefTotext -> jcf.emitClassRef;
                 if)
             if);
             (if ONlevel > 0 then
                 putfield  -> jcf.emit; 
                 isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
              else 
                 1->trace(#
                         do 'storeRef:'->xT; isField->xI; off->xI;
                            isRef -> xB; fieldType[] -> xT
                         #);
                 (if isField = 1 then
                     putfield  -> jcf.emit; 
                     isOrigin -> emitFieldAndType(# do class.copy -> TheFieldType[] #); 
                  else
                     (if isField = 2 then
                         aastore -> jcf.emit;
                      else                       
                         (if off < 0 then
                             (if false then
                                 '\nstoreref: negative off: '->puttext; 
                                 off->putint; ' class: ' -> puttext; 
                                 class[] -> puttext; 
                                 ', isRef: '->puttext; 
                                 isRef->putboolean; 
                                 ', LIP='->puttext; 
                                 jcf.currentmethod.LIP->putint; 
                                 newline;
                             if);
                             (if true 
                              // isRef then
                                 (off) -> allocMappedLocal -> astoreLocal;
                              // (fieldType[] <> none) 
                                 and ('D' -> fieldType.equal) 
                                 (* double/real *) then 
                                 (off) -> allocMappedLocal -> dstoreLocal;
                              else
                                 (off) -> allocMappedLocal -> storeLocal;
                             if);
                          else
                             (astore, astore_0, off) -> emitMemOp
                         if);
                     if)
                 if)
             if);
          #);
        loadRef:
          (# withQua,isRef: @boolean;
             sig,knownSig: ^text
          enter(withQua,sig[],knownSig[])
          do (*BC.gettext -> sig[];*)
             ((sig.lgth>=1) and ((sig.T[1] = 'L') or (sig.T[1]='['))) -> isRef;
             (if ONlevel > 0 then
                 getfield  -> jcf.emit;
                 emitFieldAndType(# do sig.copy -> TheFieldType[] #);
              else 
                 (if isField = 1 then
                     getfield  -> jcf.emit; 
                     emitFieldAndType(# do sig.copy -> TheFieldType[] #);
                  else
                     (if isField = 2 then
                         aaload -> jcf.emit;
                      else 
                         (if off < 0 then
                             (if false then
                                 '\nloadref: negative off: '->puttext; 
                                 off->putint; ' sig: ' -> puttext; 
                                 sig[] -> puttext; 
                                 ', isRef: '->puttext; 
                                 isRef->putboolean; 
                                 ', LIP='->puttext; 
                                 jcf.currentmethod.LIP->putint; 
                                 newline;
                             if);
                             (if isRef then
                                 (off) -> allocMappedLocal -> aloadLocal;
                              else
                                 (off) -> allocMappedLocal -> loadLocal;
                             if);
                          else
                             (aload, aload_0, off) -> emitMemOp
                         if);
                     if)
                 if)
             if); 
             (if withQua then
                 _checkcast  -> jcf.emit;
                 (if true then
                     knownSig[] -> emitCheckCast

                 if)
             if);
          #);
        pushAdr:
          (#
          do (if off = 0 then
                 (if reg
                  // thisO then
                     aload_0 -> jcf.emit;
                  // callO then
                     (* skip: register on stack *)
                  else
                     'Warning: pushAdr:register not this'->jvmFIXME;
                     _nop -> jcf.emit;
                 if)
              else
                 'Warning: pushAdr:registeroff <>0\n\t' -> jvmFIXME;
                 load;
             if)
          #);
        dump:
          (# 
          do
             (if size = 0 then 4->commentstream.putint else size->commentstream.putint if);
             '.'->commentstream.put;
             (if reg
              // thisO then  
              // callO then 
                 '%call.'->commentstream.puttext
              else
                 '%top.'->commentstream.puttext
             if);
             off->commentstream.putint
          #);
        display:
          (# 
          do ' reg:'-> puttext; reg -> putint;
             ' off:'-> puttext; off-> putint;
             ' size:'->puttext; size -> putint; 
             ' ONlevel:'->puttext; ONlevel -> putint;
             ' isField:'->puttext; isField -> putint;
             descName[] -> puttext; ' '->put;
             fieldName[] -> puttext; ' '->put;
             fieldType[] -> putline
          #);
     #);
   loadOrigin:
     (# ONlevel,ctag: @integer; 
        className,fieldType: ^text;
        TheClassName, TheFieldName, TheFieldType: ^text;
     enter(ONlevel,className[],fieldType[])
     do (if isMainMethod then
            (* reconsider for main/program-slot;
             * in Java:main, we cannot access class fields;
             * but we may do in BETA
             *)
            aconst_null -> jcf.emit;
         else
            (if ONlevel = 0 then
                aload_0 -> jcf.emit;
             else
                getfield  -> jcf.emit;
                1 -> ctag; (* OBS - check this and elim ctag *)
                (if ctag = 0 then
                    ONlevel 
                      -> BCstate.blocks.class 
                      -> TheClassName[];
                 else
                    className[] -> TheClassName[]
                if);
                'origin' -> TheFieldName[];
                fieldType[] -> TheFieldType[];
                (TheClassName[], TheFieldName[], TheFieldType[])
                  -> jcf.emitFieldRef;
            if);
        if)
     #);
   (* OBS. Code duplicated from bytecodeback end - ugly *)
   add: (# exit 51 #);
   sub:(# exit 52 #);
   orr: (#exit 53 #);
   andd: (# exit 54 #);
   xorr: (# exit 55 #);
   cmp: (# exit 56 #);
   mult: (# exit 57 #);
   divv: (# exit 58 #);
   modd: (# exit 59 #);
   nott: (# exit 60 #);
   logNot: (# exit 61 #); 
   neg: (# exit 62 #);
   arithShiftLeft: (# exit 63 #);
   logicalShiftLeft: (# exit 64 #);
   arithShiftRight: (# exit 65 #);
   logicalShiftRight: (# exit 66 #);
   rotateLeft: (# exit 67 #);
   rotateRight: (# exit 68 #);
   byteSwapLong: (# exit 69 #);
   byteSwapShort: (# exit 70 #);
   
   emitFunc:
     (# func: @integer;
     enter func
     do (if func
         // add then
            iadd -> jcf.emit;
         // sub then
            isub -> jcf.emit;
         // nott then
            (* 0:     ifne L1
             * 3:     iconst_1
             * 4:     goto L2
             * 7: L1: iconst_0
             * 8: L2:
             *)
            ifne -> jcf.emit;
            7-0 -> jcf.emitShort;
            iconst_1 -> jcf.emit;
            goto -> jcf.emit;
            8-4 -> jcf.emitShort;
            iconst_0 -> jcf.emit;
         // mult then
            imul -> jcf.emit;
         // divv then
            idiv -> jcf.emit;
         // modd then
            irem -> jcf.emit;
         // xorr then
            ixor -> jcf.emit;
         // logNot then
            (* bit not *)
            iconst_m1 -> jcf.emit;
            ixor -> jcf.emit;
         // neg then
            ineg -> jcf.emit;
         // orr then
            ior -> jcf.emit;
         // andd then
            iand -> jcf.emit;
         // logicalShiftLeft then
            ishl -> jcf.emit;
         // logicalShiftRight then
            iushr -> jcf.emit;
         // arithShiftLeft then   
            ishl -> jcf.emit;
         // arithShiftRight then
            ishr -> jcf.emit;
         // rotateLeft then
            (* Perform i %rol r *)
            (* Implemented as:
             *   (i << r) | ((i & ((1<<r)-1) >> (32-r))
             *)
            (* initial stack: r, i *)
            (if false then
                swap     -> jcf.emit; (* stack: i, r *)
                dup_x2   -> jcf.emit; (* stack: i, r, i *)
                swap     -> jcf.emit; (* stack: r, i, i *)
                dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
             else
                dup2     -> jcf.emit; (* stack: r, i, r, i *)
            if);
            dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
            iconst_1 -> jcf.emit; 
            swap     -> jcf.emit; 
            (* stack: r, 1, i, r, r, i *)
            ishl     -> jcf.emit; 
            iconst_1 -> jcf.emit; 
            isub     -> jcf.emit; 
            (* stack: (1<<r)-1, i, r, r, i *)
            iand     -> jcf.emit; 
            (* stack: i&(1<<r)-1, r, r, i *)
            swap     -> jcf.emit; 
            bipush   -> jcf.emit; 32 -> jcf.emit;
            swap     -> jcf.emit; 
            isub     -> jcf.emit; 
            iushr     -> jcf.emit; 
            (* stack: (i&(1<<r)-1)>>(32-r), r, i*)
            dup_x2   -> jcf.emit; 
            _pop     -> jcf.emit; 
            (* stack: r, i, (i&(1<<r)-1)>>(32-r) *)
            ishl     -> jcf.emit; 
            ior      -> jcf.emit; 
            (* stack: (i<<r) | (i&(1<<r)-1)>>(32-r) *)
         // rotateRight then
            (* Perform i %ror r *)
            (* Implemented as:
             *   (i >> r) | ((i & ((1<<r)-1) << (32-r))
             *)
            (* initial stack: r, i *)
            (if false then
                swap     -> jcf.emit; (* stack: i, r *)
                dup_x2   -> jcf.emit; (* stack: i, r, i *)
                swap     -> jcf.emit; (* stack: r, i, i *)
                dup_x2   -> jcf.emit; (* stack: r, i, r, i *)
             else
                dup2     -> jcf.emit; (* stack: r, i, r, i *)
            if);
            dup_x2   -> jcf.emit; (* stack: r, i, r, r, i *)
            iconst_1 -> jcf.emit; 
            swap     -> jcf.emit; 
            (* stack: r, 1, i, r, r, i *)
            ishl     -> jcf.emit; 
            iconst_1 -> jcf.emit; 
            isub     -> jcf.emit; 
            (* stack: (1<<r)-1, i, r, r, i *)
            iand     -> jcf.emit; 
            (* stack: i&(1<<r)-1, r, r, i *)
            swap     -> jcf.emit; 
            bipush   -> jcf.emit; 32 -> jcf.emit;
            swap     -> jcf.emit; 
            isub     -> jcf.emit; 
            ishl     -> jcf.emit; 
            (* stack: (i&(1<<r)-1)<<(32-r), r, i*)
            dup_x2   -> jcf.emit; 
            _pop     -> jcf.emit; 
            (* stack: r, i, (i&(1<<r)-1)<<(32-r) *)
            iushr     -> jcf.emit; 
            ior      -> jcf.emit; 
            (* stack: (i>>r) | (i&(1<<r)-1)<<(32-r) *)
         // byteswapShort then
            (* Implemented as 
             *   (x & 0xffff0000)
             *   |
             *   (((x>>>8) & 0xff) | ((x<<8) & 0xff00)) 
             * OBS! Is this a little-endian implementation only?
             * For
             *    x = 0xabcdefghi
             * we get
             *    x = 0xabcdhifg
             * on big endian we should get
             *    x = 0xcdabfghi
             * ???
             *)
            (* stack: x *)
            _dup      -> jcf.emit;
            0xffff0000 -> jcf.emitLoadIntegerConstant;
            iand      -> jcf.emit;
            swap      -> jcf.emit;
            (* stack: x, (x & 0xffff0000) *)
            _dup      -> jcf.emit;
            (* stack: x, x, (x & 0xffff0000) *)
            bipush    -> jcf.emit; 8 -> jcf.emit;
            iushr      -> jcf.emit;
            0xff -> jcf.emitLoadIntegerConstant;
            iand      -> jcf.emit;
            swap      -> jcf.emit;
            (* stack: (x, (x>>8) & 0xff), (x & 0xffff0000) *)
            bipush    -> jcf.emit; 8 -> jcf.emit;
            ishl      -> jcf.emit;
            0xff00 -> jcf.emitLoadIntegerConstant;
            iand      -> jcf.emit;
            (* stack: 
             *((x<<8) & 0xff00)), ((x>>8) & 0xff), (x & 0xffff0000)
             *)
            ior       -> jcf.emit;
            (*i2s       -> jcf.emit;*)
            ior -> jcf.emit
         // byteswapLong then
            (* Implemented as
             *   int AB = (ABCD>>>16);
             *   int CD = (int)(ABCD & 0xffff);
             *   int BA = (int)((AB>>>8) | ((AB & 0xff)<<8));
             *   int DC = (int)((CD>>>8) | ((CD & 0xff)<<8));
             *   int DCBA = (DC << 16) | BA;
             *   result = DCBA;
             *)
            (* stack: ABCD *)
            (# loc_abcd: @integer;
            do allocLocal -> loc_abcd;
               loc_abcd   -> storeLocal;
               loc_abcd   -> loadLocal; 
               65535      -> jcf.emitLoadIntegerConstant;
               iand       -> jcf.emit;
               bipush     -> jcf.emit; 8 -> jcf.emit;
               iushr      -> jcf.emit;
               loc_abcd   -> loadLocal; 
               65535      -> jcf.emitLoadIntegerConstant;
               iand       -> jcf.emit;
               sipush     -> jcf.emit; 255 -> jcf.emitShort;
               iand       -> jcf.emit;
               bipush     -> jcf.emit; 8 -> jcf.emit;
               ishl       -> jcf.emit;
               ior        -> jcf.emit;
               bipush     -> jcf.emit; 16 -> jcf.emit;
               ishl       -> jcf.emit;
               loc_abcd   -> loadLocal; 
               bipush     -> jcf.emit; 24 -> jcf.emit;
               iushr      -> jcf.emit;
               loc_abcd   -> loadLocal; 
               bipush     -> jcf.emit; 16 -> jcf.emit;
               iushr      -> jcf.emit;
               sipush     -> jcf.emit; 255 ->jcf.emitShort;
               iand       -> jcf.emit;
               bipush     -> jcf.emit; 8 -> jcf.emit;
               ishl       -> jcf.emit;
               ior        -> jcf.emit;
               ior        -> jcf.emit;
               loc_abcd   -> releaseLocal;
            #);
         else
            (*
            'Unhandled bytecode func.' -> (func -> asText).prepend -> jvmFIXME;
             'Unhandled bytecode func.' -> (func -> asText).prepend -> jcf.emitComment;
             * *)
            'Unhandled bytecode func.'  -> jvmFIXME;
        if)
     #);
   loadBetaenv:
     (# 
     do getstatic -> jcf.emit;
        (common.betaenv.packagename,'betaenvRef',common.betaenv.packagename->makeSignature)
          -> jcf.emitFieldRef
     #);
   newBetaEnv:
     (#
     do (if false then
            loadBetaenv;
        if);
        new -> jcf.emit;
        common.betaenv.packagename -> jcf.emitClassRef;
        _dup -> jcf.emit;
        _dup -> jcf.emit;
        aconst_null -> jcf.emit; (* origin: null *)
        invokespecial -> jcf.emit; 
        (common.betaenv.packagename,'<init>','(Ljava/lang/Object;)V')
          -> jcf.emitMethodRef;
        
        invokevirtual -> jcf.emit; 
        (common.betaenv.packagename,'init','()V') -> jcf.emitMethodRef;
        
        (* save in betaenvref *)
           _dup -> jcf.emit;
           putstatic -> jcf.emit;
           (common.betaenv.packagename
           ,'betaenvRef'
           ,common.betaenv.packagename->makeSignature)
             -> jcf.emitFieldRef;
        #);
   
   emitPrim:
     (# prim,arg: ^text;
        index: @integer;
        sig: ^text;
     enter(prim[],arg[])
     do (if trace_opcodes then
            '  callprim: %s(%s)\n'->screen.putformat(# do prim[]->s; arg[]->s #);
        if);
        (if true 
         // 'new' -> prim.equal then
            new -> jcf.emit;
            (* class name*)
            arg[] -> jcf.emitClassRef;
            _dup -> jcf.emit;
            arg[] -> mstate.class[]; (* ugly *)  
         // 'initSuper' -> prim.equal then
            '(' -> sig[];
            (if not ('-'->arg.equal) then
                (if arg[] = none then
                    (failureTrace,'makeSig-3') -> stop;
                if);
                
                arg[] -> makeSignature -> sig.append;
            if);
            ')V' -> sig.append;
            invokespecial -> jcf.emit;
            (thisSuperName[],'<init>',sig[]) -> jcf.emitMethodRef;
            (*BCstate.fields.emitInit;*)
            (if (subLevel = 0) 
                and 
                (common.betaenv.packagename
                  ->thisClassName.equalNCS) then
                aload_0 -> jcf.emit; (* this(betaenv)[] *)
                putstatic -> jcf.emit;
                (common.betaenv.packagename
                ,'betaenvRef'
                ,common.betaenv.packagename->makeSignature)
                  -> jcf.emitFieldRef;
            if)
         // 'setClass'-> prim.equal then
            arg[] -> mstate.class[]
         // 'init' -> prim.equal  then
            invokespecial -> jcf.emit;
            (mstate.class[], '<init>', arg[]) -> jcf.emitMethodRef;
         // 'AlloS' -> prim.equal then
            arg[] -> slashTodot -> jcf.emitLoadString;
            invokestatic -> jcf.emit;
            ('java/lang/Class' ,'forName', '(Ljava/lang/String;)Ljava/lang/Class;') 
              -> jcf.emitMethodRef;
            invokestatic -> jcf.emit;
            (common.StructureClass, 'AlloS', '(Ljava/lang/Object;Ljava/lang/Class;)'->BCM.structureReturnSig) 
              -> jcf.emitMethodRef;
         // 'ObjS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass, 'ObjS', '(Ljava/lang/Object;)'->BCM.structureReturnSig)
              -> jcf.emitMethodRef;
         // 'AlloSI' -> prim.equal then
            (* Stack: Structure *)
            (* Call Structure.AlloSI which use reflection to set origin *)
            invokevirtual -> jcf.emit; 
            (common.StructureClass, 'AlloSI', '()Ljava/lang/Object;') 
              -> jcf.emitMethodRef;
         // 'AlloVR4' -> prim.equal 
            
            
         // 'NewVR4' -> prim.equal then
            T_INT -> emitNewArray
         // 'AlloVR2' -> prim.equal 
         // 'NewVR2' -> prim.equal then
            T_SHORT -> emitNewArray  
         // 'AlloVR1' -> prim.equal 
         // 'NewVR1' -> prim.equal then
            T_CHAR -> emitNewArray  
         // 'AlloVRZ' -> prim.equal 
         // 'NewVRZ' -> prim.equal then 
            T_BOOLEAN -> emitNewArray  
         // 'AlloVRB' -> prim.equal 
         // 'NewVRB' -> prim.Equal then 
            T_BYTE -> emitNewArray  
         // 'AlloVR8' -> prim.equal 
         // 'NewVR8' -> prim.equal then
            T_DOUBLE-> emitNewArray  
         // 'NewRR' -> prim.equal
         // 'AlloRR' -> prim.equal then
            (* arg = '[Ltype;' 
             * extract: 'type'
             *)
            (3,arg.length-1) -> arg.sub -> emitAnewArray;
            
         // 'ExtVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR1', '([CI)[C') -> jcf.emitMethodRef; 
         // 'ExtVRB' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVRB', '([BI)[B') -> jcf.emitMethodRef; 
         // 'CopyVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR1', '([C)[C') -> jcf.emitMethodRef; 
         // 'CopySVR1' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR1', '(II[C)[C') 
              -> jcf.emitMethodRef;             
         // 'ExtVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVRZ', '([ZI)[Z') -> jcf.emitMethodRef; 
         // 'CopyVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVRZ', '([Z)[Z') -> jcf.emitMethodRef; 
         // 'CopySVRZ' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVRZ', '(II[Z)[Z') 
              -> jcf.emitMethodRef;                         
         // 'ExtVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR2', '([SI)[S') -> jcf.emitMethodRef; 
         // 'CopyVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR2', '([S)[S') -> jcf.emitMethodRef; 
         // 'CopySVR2' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR2', '(II[S)[S') 
              -> jcf.emitMethodRef;             
         // 'ExtVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR4', '([II)[I') -> jcf.emitMethodRef; 
         // 'CopyVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR4', '([I)[I') -> jcf.emitMethodRef; 
         // 'CopySVR4' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR4', '(II[I)[I')
              -> jcf.emitMethodRef;             
         // 'ExtVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'ExtVR8', '([DI)[D') -> jcf.emitMethodRef; 
         // 'CopyVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopyVR8', '([D)[D') -> jcf.emitMethodRef; 
         // 'CopySVR8' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.BetaArrayClass, 'CopySVR8', '(II[D)[D') 
              -> jcf.emitMethodRef; 
         // 'ExtRR' -> prim.equal then
            (* FIXME: possibly use local variables instead of stack, see CopySRR *)
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (* stack: oldrep, add *)
            (* int copysize = array.length;
             * int newsize  = copysize + add;
             * if (newsize<0) newsize = 0;
             * if (copysize>newsize) copysize = newsize;
             *)
            swap              -> jcf.emit;
            dup_x1            -> jcf.emit;
            (* stack: oldrep, add, oldrep *)
            arraylength       -> jcf.emit;
            (* stack: oldrep, add, copysize *)
            dup_x1            -> jcf.emit;
            iadd              -> jcf.emit;
            (* stack: oldrep, copysize, newsize *)
            _dup              -> jcf.emit;
            (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
            (* 3: *) _pop     -> jcf.emit;
            (* 4: *) iconst_0 -> jcf.emit;
            (* 5: *)
            (* stack: oldrep, copysize, newsize *)
            dup2              -> jcf.emit;
            (* stack: oldrep, copysize, newsize, copysize, newsize *)
            (* 0: *) if_icmple-> jcf.emit; 6 -> jcf.emitShort;    
            (* stack: oldrep, copysize, newsize; use copysize=newsize *)
            (* 3: *) swap     -> jcf.emit;
            (* 4: *) _pop     -> jcf.emit;
            (* 5: *) _dup     -> jcf.emit;
            (* 6: *)
            (* stack: oldrep, copysize, newsize *)
            anewarray    -> jcf.emit; arg[] -> jcf.emitClassRef;
            dup_x2       -> jcf.emit;
            swap         -> jcf.emit;
            (* Stack: newrep, oldrep, newrep, copysize *)
            iconst_0     -> jcf.emit;
            dup_x2       -> jcf.emit;
            swap         -> jcf.emit;
            (* Stack: newrep, oldrep, 0, newrep, 0, copysize *)
            invokestatic -> jcf.emit;
            ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
            (* Stack: newrep *)
            
         // 'CopyRR' -> prim.equal then
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (# loc_oldrep, loc_size, loc_newrep: @integer;
            do (* int size = array.length;
                * if (size<0) size = 0;
                *)
               allocLocal -> loc_oldrep;
               allocLocal -> loc_size;
               allocLocal -> loc_newrep;
               _dup       -> jcf.emit;
               loc_oldrep -> astoreLocal;
               arraylength-> jcf.emit;
               loc_size   -> storeLocal;
               loc_size   -> loadLocal;
               anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
               loc_newrep -> astoreLocal;
               loc_oldrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_newrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_size   -> loadLocal;
               (* Stack: oldrep, 0, newrep, 0, size *)
               invokestatic -> jcf.emit;
               ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') -> jcf.emitMethodRef;
               loc_newrep -> aloadLocal; (* push result *)
               loc_oldrep -> releaseLocal;
               loc_newrep -> releaseLocal;
               loc_size -> releaseLocal;
            #);
            
         // 'CopySRR' -> prim.equal then
            (* arg: [Ltype;  - Convert to type: *)
            (3,arg.length-1) -> arg.sub -> arg[];
            (* Stack: low, high, oldrep *)
            (# loc_low, loc_high, loc_oldrep, loc_newsize, loc_newrep: @integer;
            do allocLocal -> loc_low;
               allocLocal -> loc_high;
               allocLocal -> loc_oldrep;
               loc_oldrep -> astoreLocal;
               loc_high   -> storeLocal;
               loc_low    -> storeLocal;
               (* CkSR(low, high, oldrep.length); *)
               loc_low    -> loadLocal;
               loc_high   -> loadLocal;
               loc_oldrep -> aloadLocal;
               arraylength-> jcf.emit;
               invokestatic -> jcf.emit; (common.BetaArrayClass, 'CkSR', '(III)V') -> jcf.emitMethodRef;
               (* int newsize = high - (low-1);
                * if (newsize<0) newsize = 0;
                *)
               loc_high -> loadLocal;
               loc_low  -> loadLocal;
               iconst_1 -> jcf.emit;
               isub     -> jcf.emit;
               _dup     -> jcf.emit;
               loc_low  -> storeLocal; (* loc_low = low-1 *)
               isub     -> jcf.emit;
               _dup     -> jcf.emit;
               (* 0: *) ifge     -> jcf.emit; 5 -> jcf.emitShort;
               (* 3: *) _pop     -> jcf.emit; 
               (* 4: *) iconst_0 -> jcf.emit;
               (* 5: *)
               allocLocal -> loc_newsize -> storeLocal;
               loc_newsize -> loadLocal;
               anewarray  -> jcf.emit; arg[] -> jcf.emitClassRef;
               allocLocal -> loc_newrep -> astoreLocal;
               loc_oldrep -> aloadLocal;
               loc_low    -> loadLocal;
               loc_newrep -> aloadLocal;
               iconst_0   -> jcf.emit;
               loc_newsize-> loadLocal;
               (* stack: oldrep, low-1, newrep, 0, newsize *)
               invokestatic -> jcf.emit;
               ('java/lang/System', 'arraycopy',  '(Ljava/lang/Object;ILjava/lang/Object;II)V') 
                 -> jcf.emitMethodRef;
               loc_newrep -> aloadLocal; (* push result *)
               loc_newrep -> releaseLocal;
               loc_oldrep -> releaseLocal;
               loc_high   -> releaseLocal;
               loc_low    -> releaseLocal;
               loc_newsize-> releaseLocal;
            #);
            
         // 'Text2CharArray' -> prim.equal then
            invokevirtual -> jcf.emit;
            ('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
         // 'CharArray2String' -> prim.equal then
            new -> jcf.emit;
            'java/lang/String' -> jcf.emitClassRef;
            dup_x1 -> jcf.emit;
            swap -> jcf.emit;
            invokespecial -> jcf.emit;
            ('java/lang/String', '<init>', '([C)V') -> jcf.emitMethodRef;
         // 'ExternalString2BetaText' -> prim.equal then
            (* Note! Hardcoding of pattern 'text'
             * including case, etc. Should be handled
             * more generally
             *)
            (# sig: ^text;
            do ''->sig[];
               '(L%s;)V' -> sig.putformat(# do common.betaenv.packagename->s #);
               (* Stack: String or null *)
               _dup -> jcf.emit;
               (*  0: *)ifnull -> jcf.emit; 23-0 -> jcf.emitShort;
               (*  3: *)invokevirtual -> jcf.emit;
               (*  4: *)('java/lang/String', 'toCharArray', '()[C') -> jcf.emitMethodRef; 
               (*  6: *)new -> jcf.emit;
               (*  7: *)'text'->(common.BetaPackage).append -> jcf.emitClassRef;
               (*  9: *)dup_x1 -> jcf.emit;
               (* 10: *)dup_x1 -> jcf.emit;
               (* 11: *)loadbetaenv;
               (* 14: *)invokespecial -> jcf.emit; 
               (* 15: *)('text'->(common.BetaPackage).append, '<init>', sig[]) -> jcf.emitMethodRef;
               (* 17: *)invokevirtual -> jcf.emit; 
               (* 18: *)('text'->(common.BetaPackage).append, common.enterMethod, '([C)V') -> jcf.emitMethodRef; 
               (* 20: *)goto -> jcf.emit; 25-20 -> jcf.emitshort;
               (* 23: *)_pop -> jcf.emit; (* FIXME: pop *String*  null to satisfy verifier *)
               (* 24: *)aconst_null -> jcf.emit; (* Push *beta.Text* null *)
               (* 25: *)(* Stack: beta.Text or null *)
            #);
         // 'BetaText2ExternalString' -> prim.equal then
            (* Stack: text *)
            new -> jcf.emit;
            'java/lang/String' -> jcf.emitClassRef; (* Stack: text, String *)
            dup_x1 -> jcf.emit; (* Stack: String, text, String *)
            swap -> jcf.emit; (* Stack: String, String, text *)
            _dup -> jcf.emit; (* Stack: String, String, text, text *)
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef;
            swap -> jcf.emit; (* Stack: String, String, T, text *)
            bipush -> jcf.emit; 0 -> jcf.emit; 
            swap -> jcf.emit; (* Stack: String, String, T, 0, text *)
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'lgth', 'I') -> jcf.emitFieldRef; 
            (* Stack: String, String, T, 0, T.lgth *)
            invokespecial -> jcf.emit;
            ('java/lang/String', '<init>', '([CII)V') 
              -> jcf.emitMethodRef;
            (* Stack: String *)
         // 'BetaText2BetaCharArray' -> prim.equal then
            getfield  -> jcf.emit; 
            ('text'->(common.BetaPackage).append,'T', '[C') -> jcf.emitFieldRef; 
            
         // 'char2rep' -> prim.equal then
            (* a single char is on the stack;
             * create a new char array of length 1
             * and store the char in the array;
             * and return the array;
             * Before: ... ch
             * After : ... array,array,index(0),ch
             *)
            bipush -> jcf.emit; 1 -> jcf.emit; 
            T_CHAR -> emitNewArray;
            dup_x1 -> jcf.emit;    
            swap -> jcf.emit;                 (* ... array,array,ch *)
            bipush -> jcf.emit; 0 -> jcf.emit;
            swap -> jcf.emit;                 (* ... array,array,0,ch *)
            castore -> jcf.emit;
         // 'eqS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'eqS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'neS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'neS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'ltS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'ltS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'leS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'leS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'gtS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'gtS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'geS' -> prim.equal then
            invokestatic -> jcf.emit;
            (common.StructureClass ,'geS', BCM.structureCompareSig) -> jcf.emitMethodRef;
         // 'Att' -> prim.equal then
            getfield  -> jcf.emit; 
            (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
              -> jcf.emitFieldRef; 
            
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') 
              -> jcf.emitMethodRef;
            
         // 'Susp' -> prim.equal then
            getstatic -> jcf.emit;
            (Common.ComponentClass, 'current', common.ComponentClass->makeSignature)
              -> jcf.emitFieldRef;
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
            
         // 'SuspX' -> prim.equal then
            getfield  -> jcf.emit; 
            (common.BetaObjectClass,'comp$', common.ComponentClass->makeSignature) 
              -> jcf.emitFieldRef; 
            invokevirtual -> jcf.emit;
            (Common.ComponentClass ,'swap', '()V') -> jcf.emitMethodRef;
            
         // 'AlloC' -> prim.equal then
            (* Generate new Comp-object - constructor takes care of se4tup *)
            (# sig: ^text;
            do &text[] -> sig[];
               (if true then
                   'AlloC'           -> jcf.emitLoadString;
                   _pop              -> jcf.emit;
               if);
               _dup                  -> jcf.emit;
               new                   -> jcf.emit;
               common.ComponentClass -> jcf.emitClassRef;
               swap                  -> jcf.emit;
               invokespecial         -> jcf.emit;
               '(L%s;)V'-> sig.putformat(# do common.BetaObjectClass -> s #);
               (common.ComponentClass, '<init>', sig[]) 
                 -> jcf.emitMethodRef; 
            #);
         // 'setup' -> prim.equal then;
            aload_0 -> jcf.emit;                       
            getfield  -> jcf.emit;
            (thisClassName[]
            , 'origin'
            , arg.copy->makeSignature)
              -> jcf.emitFieldRef; 
            
            newBetaEnv;
            
            putfield  -> jcf.emit;
            (arg[], 'origin'
            , common.betaenv.packagename->makeSignature)
              -> jcf.emitFieldRef; 
         // 'initArgs' -> prim.equal then
            (# BCmch: ^ByteCodeMachine;
               program_name, sig: ^text;
               trace: (# exit false #);
            do (* Find program name *)
               (mch[]->BCmch[]).mstate.thisSourceFileName.copy -> program_name[];
               (* Generate signature for SetArgValues, 
                * which is declared in betaenv_jvmbody
                *)
               ''->sig[];
               '(L%s;Ljava/lang/String;[Ljava/lang/String;)V' 
                 -> sig.putformat(# do common.betaenv.packagename->s #);
               (* First argument (betanev instance) loaded by dup in genMain *)
               (* load program name *)
               program_name[] -> jcf.emitLoadString;
               (if trace then
                   'Trace(main): Number of Arguments: ' -> jcf.emitLoadString;
                   getstatic -> jcf.emit;
                   ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                   swap -> jcf.emit;
                   invokevirtual -> jcf.emit;
                   ('java/io/PrintStream', 'print', '(Ljava/lang/String;)V') 
                     -> jcf.emitMethodRef;
                   aload_0 -> jcf.emit; 
                   arraylength -> jcf.emit;
                   getstatic -> jcf.emit;
                   ('java/lang/System', 'out', 'Ljava/io/PrintStream;')->jcf.emitFieldRef;
                   swap -> jcf.emit;
                   invokevirtual -> jcf.emit;
                   ('java/io/PrintStream', 'println', '(I)V') 
                     -> jcf.emitMethodRef;
               if);
               (* load args[] of main() *)
               aload_0 -> jcf.emit; 
               (* Call SetArgValues, which copies main.args to betaenv.ArgVector 
                * with conversion String->Text of each element
                *)
               invokestatic -> jcf.emit;
               ('SetArgValues'->(common.BetaPackage).append, 'SetArgValues', sig[]) 
                 -> jcf.emitMethodRef
            #);
         else
            'Primitive: '->commentstream.puttext; 
            prim[] -> commentstream.puttext; 
            ' ' ->commentstream.put;
            arg[] -> commentstream.puttext;
            '\nUnknown primitive:'->puttext;
            prim[] -> puttext; ' proto: '->puttext;
            arg[] -> putline
        if);
     #);

   emitImports:
     (#
     do (if false then
            '\nImportJava:'->putline;
            jcf.cf.name -> putline;
            imports.scan
            (#
            do 'import: ' -> commentstream.puttext;
               current[] -> commentstream.putText; 
               commentstream.newline;
            #);
        if)
     #);
         emitNewArray:
        (# type: @integer
        enter type
        do newarray  -> mstate.jcf.emit; 
           type -> mstate.jcf.emit;
        #);
      emitAnewArray:
        (# type: ^text
        enter type[]
        do anewarray  -> mstate.jcf.emit;
           type[] ->  mstate.jcf.emitClassRef;
        #);
      emitCheckCast:
        (# class: ^text
        enter class[]
        do (if (1 -> class.InxGet) = '[' then
               (* '[Lfoo;' - ugly *)
               (if true then
                   class[] -> mstate.jcf.emitClassRef
                else
                   '[' -> ((3,class.length-1) -> class.sub).prepend
                     -> mstate.jcf.emitClassRef
               if)
            else
               class.copy -> classRefTotext -> mstate.jcf.emitClassRef
           if)
        #);
      emitCmpJmp:
        (# cond,L,lab,isRef: @integer; (* isRef=1: reference comparison;
                                        * should only happen for = and <>
                                        *)
        enter(cond,L,lab,isRef)
        do (if cond
            // 1 (* =  *) then
               (if isRef = 1 then
                   if_acmpeq -> mstate.jcf.emit
                else
                   if_icmpeq -> mstate.jcf.emit
               if)
            // 2 (* <> *) then
               (if isRef = 1 then
                   if_acmpne -> mstate.jcf.emit
                else
                   if_icmpne -> mstate.jcf.emit
               if)
            // 3 (* <  *) then
               if_icmplt -> mstate.jcf.emit;
            // 4 (* <= *) then
               if_icmple -> mstate.jcf.emit;
            // 5 (* >  *) then
               if_icmpgt -> mstate.jcf.emit;
            // 6 (* >= *) then
               if_icmpge -> mstate.jcf.emit;
           if);
           lab -> mstate.jcf.labs.off -> mstate.jcf.emitShort;
        #);
      emitCmpToBool:
        (* 0:      if_xxx L1
         * 3:      bipush 0
         * 5:      goto L2
         * 8:  L1: bipush 1
         * 10: L2:
         *)          
        (# L1,L2: @integer;
        do 8-0 -> L1;
           10-5 -> L2;
           (*L1 -> mstate.jcf.emitShort; (* L1 *)
           bipush -> mstate.jcf.emit; 0 -> mstate.jcf.emit;
           goto -> mstate.jcf.emit;           
           L2 -> mstate.jcf.emitShort; (* L2 *)
           bipush -> mstate.jcf.emit; 1 -> mstate.jcf.emit;           
        #);
      emitCmpBoolJmp:
        (# cond,L,lab: @integer
        enter(cond,L,lab)
        do (if cond
            // 1 (* =  *) then
               ifeq -> mstate.jcf.emit;
            // 2 (* <> *) then
               ifne -> mstate.jcf.emit;
            // 3 (* <  *) then
               iflt -> mstate.jcf.emit;
            // 4 (* <= *) then
               ifle -> mstate.jcf.emit;
            // 5 (* >  *) then
               ifgt -> mstate.jcf.emit;
            // 6 (* >= *) then
               ifge -> mstate.jcf.emit;
           if);
           lab -> mstate.jcf.labs.off -> mstate.jcf.emitShort;
        #);
      negCond:
        (# cond: @integer
        enter cond
        do (if cond
            // 1 (* =  *) then
               2 -> cond
            // 2 (* <> *) then
               1 -> cond
            // 3 (* <  *) then
               6 -> cond
            // 4 (* <= *) then
               5 -> cond
            // 5 (* >  *) then
               4 -> cond
            // 6 (* >= *) then
               3 -> cond
           if);
        exit cond
        #);

   markAsInnerIfInnerClass:
     (# className,name,outer: ^text;
        lastSlashPos,lastDollarPos: @integer;
        decode: @
          (# pos: @integer
          do className.scanAll
             (# 
             do pos+1 -> pos;
                (if ch 
                 // '$' then pos -> lastDollarPos
                 // '/' then pos -> lastSlashPos
                if)
             #);
             
          #)
     enter className[]
     do decode;
        (if lastDollarPos > 0 then
            (* we have a nested class *)
            (lastDollarPos+1,className.length) -> className.sub -> name[];
            (1,lastDollarPos-1) -> className.sub -> outer[];
            (*1->trace(#
             do 'markAsInner: ' -> xT; className[] -> xT; 
             ' ' -> put; name[] -> xT;
             ' outer: ' -> xT; outer[] -> xT;
             #);*)
            (className[],outer[],name[],ACC_PUBLIC) -> jcf.emitInnerClassRef
        if);
     #);
   emitMemOp:
     (# op, op0: @integer; varNo: @integer;
     enter(op, op0, varNo)
     do (if varNo > 0 then
            (* currently we assume that local variables have
             * addresses: 0,12,16,20,... that are 
             * mapped to: 0, 1, 2, 3,...
             * address 0 represents this
             *)
            (varNo div 4) - 2 -> varNo;
        if);
        (op, op0, varNo) -> MemoryOperation;
     #);
   MemoryOperation:
     (# op, op0: @integer; argNo: @integer;
     enter(op, op0, argNo (* argNo: 0, 1, 2, 3, ...*))
     do (if generateDebugInfo then
            argNo -> jcf.emitLocalVariableUse;
        if);
        
        (if argNo <= 3 then 
            op0 + argNo -> jcf.emit;
         else
            op -> jcf.emit;
            argNo -> jcf.emit;
        if);
     #);
   
   opLocal:
     (# op, op0, locNo: @integer;
     enter locNo (* local number, NOT offset *)
     do INNER;
        (op, op0, locNo) -> MemoryOperation;
     #);
   aOpLocal: opLocal
     (# msg: ^text;
     do (if BCstate.fields.LocalVariables[locNo] 
         // 1 (* integertype *) 
         // 3 (* double *) then
            'aOpLocal: Using local variable of integertype/double with reference instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            2 (* referencetype *) -> BCstate.fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   dOpLocal: opLocal
     (# msg: ^text;
     do (if BCstate.fields.LocalVariables[locNo] 
         // 1 (* integertype *) 
         // 2 (* referencetype *) then
            'dOpLocal: Using local variable of integertype/referencetype with double instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            3 (* double *) -> BCstate.fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   iOpLocal: opLocal
     (# msg: ^text;
     do (if BCstate.fields.LocalVariables[locNo] 
         // 2 (* referencetype *) 
         // 3 (* double *) 
            then
            'iOpLocal: Using local variable of double/referencetype with integer instruction'->msg[];
            msg[] -> jvmFIXME;
         else
            1 (* integertype *) -> BCstate.fields.LocalVariables[locNo]
        if);
        INNER;
     #);
   astoreLocal: 
     aOpLocal(# do astore->op; astore_0->op0 #);
   aloadLocal: 
     aOpLocal(# do aload->op; aload_0->op0 #);
   dstoreLocal: 
     dOpLocal(# do dstore->op; dstore_0->op0 #);
   dloadLocal: 
     dOpLocal(# do dload->op; dload_0->op0 #);
   storeLocal: 
     iOpLocal(# do istore->op; istore_0->op0 #);
   loadLocal: 
     iOpLocal(# do iload->op; iload_0->op0 #);
   
   MappedLocals: [1]@integer;
   lastMappedLocal: @integer;
   allocMappedLocal:
     (# num: @integer;
        locnum: @integer;
        double: @boolean;
     enter (num)
     do -num -> num;
        (if num>MappedLocals.range then
            (MappedLocals.range, num-MappedLocals.range)
              -> max
              -> MappedLocals.extend;
        if);
        (if MappedLocals[num]=0 then
            (if double then
                (allocLocalDouble -> locnum) + 1 -> MappedLocals[num];
             else
                (allocLocal -> locnum) + 1 -> MappedLocals[num];
            if);
            (* adding 1 to distingguish local 0 from unassigned *)
            num -> lastMappedLocal; 
            (if false then
                'allocMappedLocal: offset='->puttext; 
                num->putint; 
                ' mapped to slot '->puttext; 
                locnum-> putint; 
                ', LIP=' -> puttext;
                jcf.currentmethod.LIP -> putint;
                newline;
            if);
         else
            MappedLocals[num]- 1 -> locnum;
            num -> lastMappedLocal; (* needed? *)
            (if false then
                'allocMappedLocal: offset='->puttext; 
                num->putint; 
                ' looked-up to slot '->puttext; 
                locnum-> putint; 
                ', LIP=' -> puttext;
                jcf.currentmethod.LIP -> putint;
                newline;
            if);
        if);
     exit locnum
     #);

   emitEndLabel:
     (* stack: ExoException object *)
     (# restartLabno: @integer;
        leaveLabno: @integer;
        handler_pc: @integer;
        restart_pc: @integer;
        loc: @integer; (* Save exception object into this local *)
        rethrowOff: integerValue
          (* Calculate offset to rethrow label from current PC.
           * Code between the two labels:
           *   loc -> aloadLocal;  (1 or 2 bytes)
           *   athrow-> jcf.emit;  (1 byte)
           *)
          (# 
          do (if loc<=3 then
                 (leavelabno -> jcf.labs.off)-2 -> value
              else
                 (leavelabno -> jcf.labs.off)-3 -> value
             if)                            
          #);
        isLocal: @boolean
     enter(restartLabNo,leaveLabNo,isLocal)
     do (* End try clause by jumping over handler *)
        goto -> jcf.emit; 
        leavelabno -> jcf.labs.off -> jcf.emitShort;
        (if isLocal then
            (* Start handler:
             * if (e.exitobj == this){
             *   if (e.labno == restartlabno){
             *      // We have a restart in this Object
             *      continue Lrestart;
             *   } else if (e.labno==leavelabno){
             *     // We have a leave in this Object
             *     break Lleave;
             *   }
             * }
             * /* Not leave/restart for this Object - propagate further */
             * throw e;
             *)
            jcf.currentmethod.LIP -> handler_pc;
            allocLocal -> loc -> astoreLocal;
            loc -> aloadLocal; 
            getfield  -> jcf.emit; ('ExOException'->(common.BetaPackage).append, 'exitobj', 'Ljava/lang/Object;') -> jcf.emitfieldref;
            aload_0   -> jcf.emit; 
            if_acmpne -> jcf.emit; rethrowOff -> jcf.emitShort; (* Lrethrow*)
            (* Ltestrestart: *)
            loc -> aloadLocal; 
            getfield  -> jcf.emit; 
            ('ExOException'->(common.BetaPackage).append, 'labno', 'I') -> jcf.emitfieldref;
            restartlabno -> jcf.emitLoadIntegerConstant;
            if_icmpne -> jcf.emit; 6 -> jcf.emitShort; (* Ltestleave *)
            (* We have a restart in this Object *)
            goto      -> jcf.emit; 
            restartlabno -> jcf.labs.off -> jcf.emitShort; (* Lrestart *)
            (* Ltestleave: *)
            loc -> aloadLocal; 
            getfield  -> jcf.emit; 
            ('ExOException'->(common.BetaPackage).append
            , 'labno', 'I') 
              -> jcf.emitfieldref;
            leavelabno -> jcf.emitLoadIntegerConstant;
            if_icmpne -> jcf.emit; 
            rethrowOff -> jcf.emitShort; (* Lrethrow *)
            (* We have a restart in this Object *)
            goto      -> jcf.emit; 
            leavelabno -> jcf.labs.off -> jcf.emitShort; (* Lleave*)
            (* Lrethrow: *)
            
            (* Not the right label in this Object 
             * - propagate further *)
            loc -> aloadLocal; 
            athrow-> jcf.emit; 
            (* Lleave: *)
            
            (* Set up try-catch info *)
            RestartLabNo -> jcf.labs.off -> restart_pc;
            (if restart_pc=0 then
                'endLab: error: Restartlabel not yet defined?' 
                  -> jvmFIXME;
            if);
            (if false then
                'endlab: L' -> screen.puttext;
                restartlabno->screen.putint;
                ': restart offset: ' -> screen.puttext;
                restart_pc -> screen.putint;
                ' at PC ' -> screen.puttext;
                jcf.currentmethod.LIP -> screen.putint;
                screen.newline;
            if);
            (jcf.currentmethod.LIP + restart_pc - 1) -> restart_pc;
            (restart_pc (*start_pc*)
            , handler_pc (*end_pc*)
            , handler_pc (*handler_pc*)
            , 'ExOException'->(common.BetaPackage).append) 
              -> jcf.emitExceptionHandlerDef;
            loc -> releaseLocal;
        if)
     #);
   emitBreak:
     (# labno: @integer;
        isLeave: @boolean (* not used?*)
     enter(labNo,isLeave)
     do (* exitObj already pushed *)
        new           -> jcf.emit; 
        'ExOException'->(common.BetaPackage).append -> jcf.emitClassRef;
        (* stack: ExOException; exitObj *)
        dup_x1        -> jcf.emit;
        (* stack: ExOException; exitObj, ExOException *)
        swap          -> jcf.emit;
        (* stack: exitObj, ExOException; ExOException *)
        labno         -> jcf.emitLoadIntegerConstant; (* potentially 32 bit constant *)
        (* stack: labno, exitObj, ExOException; ExOException *)
        invokespecial -> jcf.emit; ('ExOException'->(common.BetaPackage).append, '<init>', '(Ljava/lang/Object;I)V') -> jcf.emitMethodRef;
        athrow        -> jcf.emit;
     #);
   emitCallExternal:
     (# prim, n, d, m: ^text; s: @boolean;
     enter prim[]
     do (*BC.getText -> prim[];*)
        prim[] ->splitClassSignature->(n[], d[], s, m[]);
        (if true 
         // ('java/io/PrintStream'-> ((1,19)->prim.sub).equal) then
            (* FIXME: hardcoded 
             * Assuming that operation is on the static instance of 
             * PrintStream in java/lang/System.out.
             * We must load this first.
             *)
            getstatic -> jcf.emit;
            ('java/lang/System', 'out', 'Ljava/io/PrintStream;')
              ->jcf.emitFieldRef;
            swap -> jcf.emit;
            invokevirtual -> jcf.emit; 
            (m[], n[], d[]) -> jcf.emitMethodRef;
         // ('java/io/InputStream'-> ((1,19)->prim.sub).equal) then
            (* FIXME: hardcoded 
             * Assuming that operation is on the static instance of 
             * InputStream in java/lang/System.in.
             * We must load this first.
             *)
            getstatic -> jcf.emit;
            ('java/lang/System', 'in', 'Ljava/io/InputStream;')->jcf.emitFieldRef;
            (* swap -> jcf.emit;*)
            invokevirtual -> jcf.emit; 
            (m[], n[], d[]) -> jcf.emitMethodRef;
         else
            'callExternal' -> jvmFIXME;
            (if s then
                invokestatic -> jcf.emit;
             else
                invokevirtual -> jcf.emit;
            if);
            (m[], n[], d[]) -> jcf.emitMethodRef; 
        if);
     #);

   BCM: @ BCmachine;
   
   splitPathAndName:
     (# orgPath,path,FN: ^text; slashPos,dotPos: @integer;
        e: @diskentry
     enter orgPath[]
     do orgPath[] -> e.path;
        e.path.head -> path[]; directorychar -> path.put;
        e.path.name.prefix -> FN[];
     exit(path[],FN[])
     #);
   
   BCisSplit: @boolean;
   c: ^text; (* ugly *)
   
   mkDepFile:
     (# dep: @file;
     do (* Touch the dep file *)
        '.dep'
          -> (thisSourceFileName[]->(thisFullSourcePath.copy).append).append 
          -> dep.name;
        (*'touching file ' -> screen.puttext; dep.name ->screen.putline;*)
        dep.touch;
     #);
   numTempLocals: @integer;
   thisPackagePath,      (* package path *)
   thisFullPath,         (* full path of directory for for 
                          * current object/class file.
                          * On JVM this include package path.
                          *)
   thisFullSourcePath,   (* Full path of directory of current source file *)
   thisSourceFileName,   (* name of current source file *)
   thisFileName,         (* name of current object file  *)
   thisClassName: ^text; (* name of current class 
                          * for java: currentFile = currentClass
                          * for .NET: they may differ
                          *)
   thisSuperName: ^text;
   thisInnerMethodName: ^text;
   thisOrgName, thisSuperOrgName: ^text;
   subLevel,thisBlockLevel: @integer;
   class: ^text;       (* name of class being called - 
                        * used by subsequent init - ugly
                        *)
   isMainMethod: @boolean;
   thisSignature: ^text;
   commentStream: ^stream;
   jasmin: @file;
   jasminIsOpen: @boolean;
   lastLocalAllocated:
     (* used by allocAndStoreLocal and just for testing .NET stuff 
      * And never assigned a value here?
      *)
     @integer;

   classes: @
     (# L: [4] ^text; 
        start,end: [4] @integer;
        top: @integer;
        init: (# do 0 -> top #);
        add:
          (# cn: ^text;
             startPos,endPos: @integer
          enter(cn[],startPos,endPos)
          do (if (top+1->top) > L.range then
                 L.range -> L.extend;
                 start.range -> start.extend;
                 end.range -> end.extend
             if);
             cn[] -> L[top][];
             startPos -> start[top];
             endPos -> end[top];
          #);
        scan:
          (# current: ^text;
             startPos,endPos: @integer
          do (for i: top repeat
                  L[i][] -> current[];
                  start[i] -> startPos;
                  end[i] -> endPos;
                  inner
          for)#)
     #);
   mkClassListFile:
     (# basename: ^text;
        F: @file;
     do (thisSourceFileName[]->(thisFullPath.copy).append).append -> basename[];
        '.clst'
          -> (basename.copy).append
          -> F.name;
        (if false then
            '\nClassFileName: ' -> screen.puttext; 
            F.name -> screen.puttext; 
            ', Path: '->screen.puttext; 
            ThisFullPath[] -> screen.putline;
        if);
        F.openWrite;
        (* 'opened for writing: ' -> screen.puttext; F.name -> screen.putline; *)
        classes.scan
        (# 
        do startPos -> F.putint; 
           ' ' -> F.put;
           endPos -> F.putint;
           ' ' -> F.put;
           current[] (* No extension *) 
             -> (thisFullSourcePath.copy).append 
             -> F.putline;
           (* current[] -> putline *)
        #);
        (if false then
            (if common.switch[189] then
                (* .NET: All attributes forms in one file.
                 * The library file may or may not define attributes fragments.
                 * In both cases a legal .il file is generated.
                 * This file must be included in assembly/link too.
                 *)
                basename[] -> F.putline; (* Add to class list for future job files *)
            if);
        if);
        F.close;
     #);
#)
---bytecode_newImp:doPart---
do (if (astRef <> 65535) and (astRef >= 0) then
       astRef -> mstate.jcf.emitLineNumber
   if)
   
---byteCode_textOperand_out:doPart---
do T[] -> mstate.textOperandArg[];
   
---byteCode_dataRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_adrRegOperand_out:doPart---
do rn -> mstate.A.reg;
   
---byteCode_LocalLab_def:doPart---
do labNo -> mstate.jcf.labs.def; 
   
---byteCode_LocalLab_out:doPart--- (* unused? *)
do labNo -> mstate.localLabArg
   
---byteCode_RegAdr_out:doPart---   
do reg.out;
   fieldName[] -> mstate.A.fieldName[];
   off -> mstate.A.off;
   size -> mstate.A.size;
   0 -> mstate.A.ONlevel;
   
   (* 18/06/02: ONlevel can be eliminated and
    * ONlevel > 0 ==> isField = true
    * BUT! For loadOrigin ONlevel is used
    * but does NOT involve blocks. 
    *)
   (if isField then 
       (if not common.switch[189] (* java *) then
           (if (receiverType.length->receiverType.inxGet) = ';' then
               (2,receiverType.length-1)  (* ugly *)
                 -> receiverType.sub 
                 -> mstate.A.descName[]
            else
               receiverType[] -> mstate.A.descName[]; (*?*)
           if)
        else
           receiverType[] -> mstate.A.descName[]; (*?*)
       if);
       1 -> mstate.A.isField;
    else 
       (* A method variable and this should be ok so no error here *)
       0 -> mstate.A.isField
   if);
   fieldType[] -> mstate.A.fieldType[];   
   1->trace(#do 'RegAdrOut:'-> xT
           #)
   
---byteCode_RegAdr_index:doPart---
do '\nOBS! RegADr:index:'->puttext;
   
---bytecode_goOrigin:doPart---
do '\n***OBS loadOrigin:shouldNotHappen' -> putline
   
---byteCode_InxRegAdr_out:doPart---   
do areg.out;
   fieldName[] -> mstate.A.fieldName[];

   off -> mstate.A.off;
   size -> mstate.A.size;
   ONlevel -> mstate.A.ONlevel;
   2 -> mstate.A.isField; (* isField = 2 signals array *)
   (* All the fields; areg,off,size,ONlevel, are superflous
    * and not used by the bytecode
    *)
   fieldType[] -> mstate.A.fieldType[];
   1->trace(#do 'inxRegAdrOut:'-> xT
           #)

---byteCode_nop:doPart---
do _nop -> mstate.jcf.emit;
   
---byteCode_ldCst:doPart---
do (if true
    // (- 128 <= C) and (C <= 127) then
       bipush -> mstate.jcf.emit;
       C -> mstate.jcf.emit;       
    // (- common.two15 <= C) and (C <= (common.two15-1)) then
       sipush -> mstate.jcf.emit;
       C -> mstate.jcf.emitShort;
    else
       C -> mstate.jcf.emitLoadIntegerConstant;
   if)
   
---byteCode_ldNone:doPart---
do aconst_null -> mstate.jcf.emit;
   
---byteCode_ldValImpl:doPart---
do (if A.isOrigin then
       (# receiverType: ^text;
       do
          (* Regarding ONlevel, see regAdr_out
           * and BCjasminBody.
           * But apparently only ONlevel = 0 and
           * ONlevel > 0 is used in BCjasminBody
           * Find out if isField can be used
           *)
          (if true
           // (A.ONlevel = 0) and A.isField then 
              'loadOrigin: ONlevel=0. isField=true' -> putline
           // (A.ONlevel > 0) and not A.isField then
              'loadOrigin: ONlevel>0, isField=false' -> putline
          if);
          (* Here we should replace ONlevel with
           * isField: 0 or 1 
           *)
          (if A.receiverType[] <> none then
              (if not common.switch[189] (* java *) then
                  (if (A.receiverType.length->A.receiverType.inxGet) = ';' then
                      (2,A.receiverType.length-1)  (* ugly *)
                        -> A.receiverType.sub 
                        -> receiverType[]
                   else
                      A.receiverType[] -> receiverType[]
                  if)
               else
                  A.receiverType[] -> receiverType[]
              if)
           else
              (* in regAdr_out we test isField before
               * A.receiverType[]<>none as above
               *)
              (if A.isField then
                  '\nOBS!bytecode_ldVal:isField:no:receiverType'->putline;
              if)
          if);
          (A.ONlevel,receiverType[],A.fieldType[]) -> mstate.loadOrigin
       #)
    else
       A.out;
       (if A.isRef then (* cleanup/elim isRef?*)
           (if A.fieldType[] <> none then
               (false(*?*),A.fieldType[],none) -> mstate.A.loadRef
            else
               (false(*?*), 'ldValImpl_UnknownType',none) -> mstate.A.loadRef
           if)
        else
           mstate.A.load; 
       if)
   if);
   elimSign:
     (if not A.signed and (A.fieldType[]<>none) then
         (if isJava then
             (if ('C' -> A.fieldType.equal) 
                 or ((1->A.fieldType.inxget) = '[') 
                 then leave elimSign
             if)
          else
             (if ('char' -> A.fieldType.equal) 
                 or ((A.fieldType.length->A.fieldType.inxget) = ']') 
                 then leave elimSign
             if)
         if);
         (if A.size
          // 1 then
             (&dataRegOperand[],0xFF->newCstOp,4) -> gAnd
          // 2 then
             (&dataRegOperand[],0xFFFF->newCstOp,4) -> gAnd
         if)
     if);
   
---byteCode_ByteSwap:doPart---
do (if long then
       (arithCodes.byteSwapLong,ar[])->callUnFunc
    else
       (arithCodes.byteSwapShort,ar[])->callUnFunc
   if);

---byteCode_loadRef:doPart---
do A.out;
   (knownSourceClassName[] <> NONE
   ,basicSourceClassName[]
   ,knownSourceClassName[]) -> mstate.A.loadRef
   
---byteCode_stValImpl:doPart---
do A.out;      
   mstate.A.store;
   
---byteCode_cpReg:doPart---
do (* called from synthesizer, but no code generated *)
      
---byteCode_gLea:doPart---
do op1.out;
   (if true 
    // op1.isRegAdr then
       mstate.A.pushAdr
    // op1.isInxRegAdr then
       mstate.A.pushAdr
    // op1.isTextOp then
       mstate.textOperandArg[] -> mstate.jcf.emitLoadString;
    else
       '\nglea: operand type not handled'->putline
   if)   
   
--bytecodeBackend_gClr:doPart--
do (* don't do this; too many zero constants
    * will be pushed when clearing registers.
    * (mstate.BCM.pushCst,0) -> mstate.BCM.emit1;
    *)
   
---bytecode_int64ToInt32:doPart---
do l2i -> mstate.jcf.emit
   
---bytecode_int32ToInt64:doPart---
do i2l -> mstate.jcf.emit
   
--bytecode_loadRange:doPart--
do arraylength -> mstate.jcf.emit;
   
---byteCode_duplicate:doPart---
do (if type = 0 then
       (if pos
        // 0 then _dup -> mstate.jcf.emit;
        // 1 then dup_x1 -> mstate.jcf.emit;
        // 2 then dup_x2 -> mstate.jcf.emit;
       if)
    else (* 1: dup real64/double; 2: dup two int32 *)
       (if pos
        // 0 then dup2 ->mstate.jcf.emit;
        // 1 then dup2_x1 -> mstate.jcf.emit;
        // 2 then dup2_x2 -> mstate.jcf.emit;
   if)if)

---byteCode_allocAndStoreLocal:doPart---
do (# RA: ^mch.RegAdr;
      first: @char;
   do &mch.RegAdr[] -> RA[];
      mstate.numTempLocals+1 -> mstate.numTempLocals;
      -mstate.numTempLocals -> RA.off;
      (if type[]=NONE then
          '\nbyteCode_allocAndStoreLocal: type is NONE!'->putline;
          (*(dumpstack, 'byteCode_allocAndStoreLocal: type is NONE!') -> stop;*)
          'AllocAndStoreLocal_UnknownType' -> type[];
       else
          (if isJava then
              ((type.lgth>=1) and ((type.T[1] = 'L') or (type.T[1]='['))) 
                -> RA.isRef;
              type.copy -> RA.fieldType[];
           else 
              true -> RA.isRef;           
              type.copy -> RA.fieldType[]; (* olm:23.11.03 *)
          if);
      if);
      (if false then
          'bytecodebackendbody: AllocAndStoreLocal:' -> screen.putline;
          -mstate.numTempLocals->screen.putint; 
          '/'->screen.put; 
          type[]->screen.putline;
      if);
      (none,false,'',type[]) -> RA.asgRefReg;
      RA[] -> A[]
   #)
   
   
---byteCode_loadLocal:doPart---
do (* FIXME: don't we need the variable offset? *)
   (if mstate.BCstate.fields.LocalVariables[mstate.lastLocalAllocated]
    // -1 then
       'opcode loadlocal: using unknown local variable type' 
         -> mstate.JVMFIXME;
    // 0 then
       'opcode loadlocal: using unassigned local variable' 
         -> mstate.JVMFIXME;
    // 1 then
       mstate.lastLocalAllocated -> mstate.loadLocal
    // 2 then
       mstate.lastLocalAllocated -> mstate.aloadLocal
    else
       'opcode loadlocal: using local variable of unknown kind' 
         -> mstate.JVMFIXME;
   if)
   
--byteCode_popStack:doPart---
do (if isDouble then
       _pop2 -> mstate.jcf.emit;
    else
       _pop -> mstate.jcf.emit;
   if)
   
--bytecode_declareField:doPart---
   (* to replace emitCk  *)
do (# F: ^text
   do 'F' -> F[]; off -> F.putInt; 
      (F[],fieldName[],fieldSig[],fieldKind)
        -> mstate.BCstate.fields.new;
   #)
   
--bytecode_emitCk:doPart--
   (* OBS! This operation is used to initialize 
    * fields of an object/class. It is a HACK, 
    * since emitCk is used for another purpose
    * in other backends and reused here.
    * regReg      :offSet of field
    * RoutineName :type of field
    * RefName     :'m': a field in a method
    *              'c': a field in a class
    *              'p': a part object 
    *              '[': an array object
    *)
do 'emitCk:mstate.BCM.field ->mstate.BCM.emit;'->putline;
   (*regRef -> mstate.BCM.emit;
   (if routineName[] <> none then
       RoutineName[] -> mstate.BCM.emitText;
    else

   if);
   (if RefName[] <> none then
       1 -> RefName.inxGet -> mstate.BCM.emit
    else
       '?' -> mstate.BCM.emit
   if)*)
   
---byteCode_constructorDef:doPart---
do (if ('-' -> mstate.thisOrgName.equal) then
       (ACC_PUBLIC, '<init>', '()V', 8, 3) 
         -> mstate.jcf.currentmethod.new;
    else
       (ACC_PUBLIC, '<init>', signature[], 8, 30)
         -> mstate.jcf.currentmethod.new;
   if);
   (if generateDebugInfo then
       (0, 65535, 'this', mstate.thisClassName.copy->makeSignature) 
         -> mstate.jcf.emitLocalVariableDefinition;
       (65535, 0, 'origin', 'Ljava/lang/Object;' 
       (* FIXME: argument type *))
         -> mstate.jcf.emitlocalvariabledefinition;
   if)
   
   
---byteCode_tstNone:doPart---
do 'tstNone:mstate.BCM.loadRef->mstate.BCM.emit; A.out;'->putline
   (*   'UnknownNONE' -> mstate.BCM.emittext*)
   
---byteCode_doAsgRefAdr:doPart---
do thisAdr.out;   
   (if destClassName[] = none then
       'Unknown:doAsgRefAdr'->destClassName[]
   if);
   1->trace(#
           do
              'asgRefAdr:'->xT;
              withQua->xB;
              thisAdr.isOrigin->xB;
              destClassName[] -> xT
           #);
   (withQua,thisAdr.isOrigin(*?*),destClassName[]) -> mstate.A.storeRef
   
---byteCode_doAsgRegAdr:doPart---
do (* source reg on stack *)
   thisAdr.out;
   (if destClassName[] = none then
       'Unknown:doAsgRegAdr'->destClassName[]
   if);
   1->trace(#
           do
              'asgRegAdr:'->xT;
              withQua->xB;
              thisAdr.isOrigin->xB;
              destClassName[] -> xT
           #);

   (withQua,thisAdr.isOrigin(*?*),destClassName[]) -> mstate.A.storeRef
   
---bytecode_checkCast:doPart---
do _checkcast  -> mstate.jcf.emit; type[] -> mstate.emitCheckCast
   
---byteCode_jmpTlong:doPart---
do 'mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText: '->puttext;
   T[] -> putline;
   
---byteCode_jmplong:doPart---
do 'mstate.BCM.jmpt->mstate.BCM.emit; T[]->mstate.BCM.emitText:A: ' ->puttext;
   T[] -> putline;
   
---byteCode_jsrT:doPart---
do 'mstate.BCM.call->mstate.BCM.emit; T[]->mstate.BCM.emitText:B: ' -> puttext;
   T[] -> putline;
   
--byteCode_gJmp:doPart---
do op.out;
   goto -> mstate.jcf.emit;
   (*BC.get -> theL (* opcode label *); 
   (if mstate.localLabArg = 0 then
       '\nOOPS opcode jmp: use of strange label L0'->putline;
   if);
   mstate.localLabArg -> mstate.jcf.labs.off -> mstate.jcf.emitShort;
   
--byteCode_gJsr:doPart---
do (# isInterfaceMethod: @boolean;
      calltype: @integer;
   do (if isStatic then 
          calltype %Bor 1 -> calltype;
      if);
      (if isValueType then
          (* Call on valuetype *)
          calltype %Bor 2 -> calltype;
      if);
      (if op.T.T[1]='|' then
          (* Interface method *)
          calltype %Bor 4 -> calltype;
          (1,1) -> op.T.delete;          
          true -> isInterfaceMethod;             
      if);
      op.out;
      
      (# T, n, d, m: ^text; 
         s: @boolean;
         nargs: @int16;
      do mstate.textOperandArg[] -> T[];
         
         T[]->splitClassSignature->(n[], d[], s, m[]);
         (if isInterfaceMethod then
             invokeinterface -> mstate.jcf.emit;
             (m[], n[], d[]) -> mstate.jcf.emitInterfaceMethodRef;
             d[] -> mstate.noArgsInSignature -> nargs;
             nargs + 1 (* interface pointer counts for one *) 
               -> mstate.jcf.emit;
             0 -> mstate.jcf.emit;
          else
             (if isStatic then
                 invokestatic  -> mstate.jcf.emit;
              else
                 invokevirtual -> mstate.jcf.emit;
             if);
             (m[], n[], d[]) -> mstate.jcf.emitMethodRef; 
         if);
      #)
   #)

---bytecode_beginLabel:doPart---
do (* no code needed here?*)
   
---bytecode_endLabel:doPart---
do (restartLab.labNo,leaveLab.labno,(hasCalls or hasSlots))
     -> mstate.emitEndLabel
   
---bytecode_break:doPart---
do (JmpAdr.labno,isLeave) -> mstate.emitBreak
   
---bytecode_breaksimple:doPart---
do JmpAdr[] -> gJmp
   
---byteCode_cmpToBool:doPart--   
do op1.loadToReg; 
   op2.loadToReg;
   (* op3 is a register to load 0 or 1;
    * here we use the stack instead
    *)
   (if isRef then 
       (* 0:      if_xxx L1
        * 3:      bipush 0 or 1
        * 5:      goto L2
        * 8:  L1: bipush 1 or 1
        * 10: L2:
        *)
       (if cond = 1 (* =  *) then
           if_acmpeq -> mstate.jcf.emit;
        else (* cond = 2  <> *) 
           if_acmpeq -> mstate.jcf.emit;
       if);
       8-0 -> mstate.jcf.emitShort; (* L1 *)
       bipush -> mstate.jcf.emit; 
       (if cond = 1 (* = *) then 
           0 -> mstate.jcf.emit
        else
           1 -> mstate.jcf.emit
       if);
       goto -> mstate.jcf.emit;
       10-5 -> mstate.jcf.emitShort; (* L2 *)
       bipush -> mstate.jcf.emit; 
       (if cond = 1 then 
           1 -> mstate.jcf.emit;
        else
           0 -> mstate.jcf.emit;
       if)
    else
       (* 0:      if_xxx L1
        * 3:      bipush 0
        * 5:      goto L2
        * 8:  L1: bipush 1
        * 10: L2:
        *)
       (if cond
        // 1 (* =  *) then
           if_icmpeq -> mstate.jcf.emit;
        // 2 (* <> *) then
           if_icmpne -> mstate.jcf.emit;
        // 3 (* <  *) then
           if_icmplt -> mstate.jcf.emit;
        // 4 (* <= *) then
           if_icmple -> mstate.jcf.emit;
        // 5 (* >  *) then
           if_icmpgt -> mstate.jcf.emit;
        // 6 (* >= *) then
           if_icmpge -> mstate.jcf.emit;
       if);
       8-0 -> mstate.jcf.emitShort; (* L1 *)
       bipush -> mstate.jcf.emit; 0 -> mstate.jcf.emit;
       goto -> mstate.jcf.emit;
       10-5 -> mstate.jcf.emitShort; (* L2 *)
       bipush -> mstate.jcf.emit; 1 -> mstate.jcf.emit;
   if);

   
---byteCode_cmpAndJmp:doPart---
do op1.loadToReg; op2.loadToReg;
   lab.out;
   (cond,'L',mstate.localLabArg,isRef %band 1) -> mstate.emitCmpJmp 
   
---byteCode_cmpBoolAndJmp:doPart--
do op.loadToReg;
   lab.out;  
   (cond,'L',mstate.localLabArg) -> mstate.emitCmpBoolJmp
   
---byteCode_floatConst:doPart---
do ldc2_w  -> mstate.jcf.emit;
   value -> real2ints -> mstate.jcf.emitDoubleConstant;
   
---byteCode_saveReturn:doPart---
do (if isGpart then
       '\nShouldNotHappen:saveReturn:initCons'->putline;
       (failuretrace,'initcons') -> stop;
   if)
   
---byteCode_return:doPart---
do (if RToff
    // 0 // 10 then 
       _return -> mstate.jcf.emit;
    // 1 // 2 // 3 // 4 // 5 then 
       ireturn -> mstate.jcf.emit;
    // 6 (* real *) then 
       dreturn -> mstate.jcf.emit;
    // 7 (* real32 *) then 
       freturn -> mstate.jcf.emit;                    
    // 8 (* long=int64 *) then
       lreturn -> mstate.jcf.emit
    // 11 // 12 // 13 // 14 then 
       areturn -> mstate.jcf.emit;
    else 
       'xreturn' -> mstate.jvmFIXME;
   if);

---bytecode_endMethod:doPart---
do mstate.jcf.labs.check_all_relocated;
   
---byteCode_callPrim:doPart--
do (T[],'Unknown') -> mstate.emitPrim
   
--byteCode_callAlloPrim:doPart--
do (if proto[] = none then 'UnknownProto' -> proto[] if);
   (T[],proto[]) -> mstate.emitPrim
   
---bytecode_import:doPart---
do (if (Lab[] <> none) and ( Lab.length > 0) then
       (if 'exe_preExe' -> lab.equal then
           (dumpStack,'exe_preExe') -> stop
       if);
       Lab.copy -> mstate.BCM.imports.add 
   if);
   (*'IMPORT: ' -> puttext; Lab[] -> putline*)
   (if 'valuetype '->((1,10)->lab.sub).equal then 
       (dumpStack,'valuetype import') -> stop
   if);
   
---byteCode_callUnFunc:doPart---   
do arg.loadToReg;
   opCode -> mstate.emitFunc
   
---byteCode_callBinFunc:doPart---
do op1.loadToReg; op2.loadToReg;
   opCode -> mstate.emitFunc
   
--byteCode_classDef:doPart--
do (* when using package as in
    *    PACKAGE 'foo.bar.fisk'
    * and a pattern
    *    myClass: (# ... #)
    * className = 'foo.bar.fisk.myClass'
    * 
    * Only 'myClass' should be used as thisFileName 
    *)
   (# lastDot: @integer; realClassName: ^text
   do (if true then
          className.scanAll
          (# pos: @integer
          do pos+1 -> pos;
             (if ch //  '.' // '\/' then pos -> lastDot if)
          #);          
      if);
      (lastDot+1,className.length)
        -> className.sub
        -> realClassName[]
        -> mstate.thisFileName[];
   #);
   (className[],startPos,endPos) -> mstate.classes.add;
   
   (* BCjavaBody elim *)
   (# fn: ^text
   do &JavaImage[] -> mstate.jcf[] -> mstate.BCM.jcf[];;
      not common.switch[188]
        -> mstate.jcf.display_warnings;
      (common.verboselevel<=common.verboselevel.verbose)
        -> mstate.jcf.traceClassFileName;
      common.switch[190] 
        -> mstate.jcf.traceClassFile;
      true
        -> mstate.jcf.local_variables_always_live_until_exit;
      false
        -> mstate.jcf.report_undefined_local_variable_use;
      
      mstate.thisFileName[] -> (mstate.thisFullPath.copy).append -> fn[];
      (if common.hostIsWindows then
          (* Since package paths may now be part of the file name,
           * the file name may now contain forward slashes.
           * Thats not OK on windows.
           *)
          fn[] -> SlashToBackslash -> fn[];
      if);
      '.class' -> (fn.copy).AppendExtension -> mstate.jcf.init;
      '.bet' 
        -> (mstate.thisSourceFileName.copy).AppendExtension 
        -> mstate.jcf.SourceFile;
      (*
       newline;
       fn[] -> putline;
       *)
      false -> mstate.isMainMethod;
      
      className[]
        -> mstate.jcf.constant_pool.classes.addtext
        -> mstate.jcf.thisClassIndex;
      blockLevel-> mstate.thisBlockLevel;
      (mstate.thisBlockLevel,mstate.thisClassname[]) 
        -> mstate.BCstate.blocks.mark;
      superName[] 
        -> mstate.thisSuperName[]
        -> mstate.jcf.constant_pool.classes.addtext 
        -> mstate.jcf.superClassIndex;
      
      'java/lang/Object'->mstate.thisSuperOrgName[];
      
      subLevel -> mstate.subLevel;
      orgName[] -> mstate.thisOrgName[];
      (if (subLevel = 0) 
          and (common.betaenv.packagename->className.equalNCS) then
          ('betaenvRef', className.copy->makeSignature)
            -> mstate.jcf.fields.addText_static;
          
      if);
      (if not ('-'->orgName.equal) then
          (if true then
              ('origin', orgName[]) 
                -> mstate.jcf.emitPublicSyntheticFieldDef
          if)
          
      if);
      className[] -> mstate.markAsInnerIfInnerClass;
      mstate.BCstate.fields.init
      
   #);
   className[] -> mstate.thisClassName[];

--byteCode_marknested:doPart---
do (nestedMangled[],mstate.thisClassName[],nested[],ACC_PUBLIC)
     -> mstate.jcf.emitInnerClassRef

--byteCode_endClass:doPart---
do mstate.jcf.EmitToFile;
   (if (mstate.thisClassName[]<>NONE) 
       and (common.BetaObjectClass->mstate.thisClassName.equal) then
       (* Just finished generating BetaObject (in betaenv). *)
       mstate.BCM.GenerateJvmClassExOException;
       mstate.bcm.GenerateJvmClassStructure;
       mstate.BCM.GenerateJvmClassBetaArray;
       (if not common.ComponentDotCJ then
           mstate.BCM.GenerateJvmClassComponent;
       if);
   if);

--byteCode_endCodeSeg:doPart---
do (if not isJava then 
       mstate.mkClassListFile
   if)
   
--byteCode_methodDef:doPart--
do 0 -> mstate.numTempLocals;
   (# aux: @integer; (* 0 or 1 *)
      isStatic: @boolean;
      access: @integer;
      argn: ^text;
   do 1 -> mstate.BCstate.fields.LocalVariables.new;
      1 -> mstate.MappedLocals.new;
      
      methodname[] -> mstate.thisInnerMethodName[];  
      signature[] -> mstate.thisSignature[];
      noOfEnterArgs -> mstate.BCstate.fields.numArguments;
      type -> aux;
      
      (if 'main' -> mstate.thisInnerMethodName.equal then
          (ACC_PUBLIC %Bor ACC_STATIC, 'main', '([Ljava/lang/String;)V', 8, 8)
            -> mstate.jcf.currentmethod.new;
          (if generateDebugInfo then
              (0, 65535, 'args', 'Ljava/lang/String;') 
                -> mstate.jcf.emitlocalVariableDefinition;
          if);
          true -> mstate.isMainMethod
       else
          false -> mstate.isMainMethod;
          (if aux = 0 then
              (0 (*%Bor ACC_PUBLIC*), mstate.thisInnerMethodName[], '()V', 1,1)
                -> mstate.jcf.currentmethod.new;
              (if generateDebugInfo then
                  (if mstate.thisClassName[] = none then
                      (failureTrace,'makeSig-2') -> stop;
                  if);
                  (0, 65535, 'this', mstate.thisClassName.copy
                    -> makeSignature) 
                    -> mstate.jcf.emitLocalVariableDefinition;
              if);
              1 -> mstate.jcf.emitLinenumber; (* test to see if 
                                               * this satifies eclipse *)
              _return -> mstate.jcf.emit;
          if);
          mstate.thisSignature[] 
            -> splitSignature 
            -> (methodname[], mstate.thisSignature[], isStatic);
          (if isStatic then
              (*ACC_PUBLIC %Bor*) ACC_STATIC -> access;
           else
              ACC_PUBLIC -> access;
          if);
          (if aux = 4 then
              ACC_NATIVE %Bor access -> access
          if);
          (access, methodname[], mstate.thisSignature[], 100, 100)
            -> mstate.jcf.currentmethod.new;
          (if generateDebugInfo and (not isStatic) then
              (0, 65535, 'this', mstate.thisClassName.copy->makeSignature) 
                -> mstate.jcf.emitLocalVariableDefinition;
          if);
      if);  
      mstate.jcf.labs.clear;
      (if true then
          (* enter parameters are declared as variables too.
           * Thus no need for this!
           * Well yes - apparently sometimes!!!!! FIXME!???
           * Example: program.program() has a parameter of
           * class tstenv/betaenv, but does NOT call 
           * fields.new with tag 'm'
           *)
          (if generateDebugInfo then
              (for i:noOfEnterArgs repeat
                   'arg' -> argn[];
                   i-1 -> argn.putint; (* FIXME: argument name *)
                   (0, 65535, argn[], 'I' (* FIXME: argument type *))
                     -> mstate.jcf.emitlocalvariabledefinition;
              for);
          if);
      if);
   #);
   
--byteCode_emitTextConst:doPart---
do S[] -> mstate.jcf.emitLoadString;
   
---byteCode_close:doPart---
do (if trace_init_close then
       '\nCLOSE: ' -> puttext; 
       mstate.thisFullPath[] -> puttext; 
       mstate.thisFileName[]->putline;
   if);
   183->trace(#
             do 'Close:' ->xT; mstate.thisFullPath[] -> xT; xN;
                '   thisFileName:' -> xT; mstate.thisFileName[] -> xT; xN;
                'imports: ' -> xT;
                mstate.BCM.imports.scan(# do current[] -> xT; ' '-> put #);
             #);
   (if isJava then  
       mstate.mkClassListFile;
       mstate.mkDepFile
   if);
   (if not isJava then
       (if (mstate.thisClassName[]<>NONE) 
           and (common.BetaObjectClass->mstate.thisClassName.equal) then
           (* Just finished generating BetaObject (in betaenv). *)
           mstate.BCM.GenerateJvmClassExOException;
           mstate.bcm.GenerateJvmClassStructure;
           mstate.BCM.GenerateJvmClassBetaArray;
           (if not common.ComponentDotCJ then
               mstate.BCM.GenerateJvmClassComponent;
           if);
       if);       
   if);
   mstate.BCM.imports.clear;
   
---bytecode_real64toReal32:doPart---
do d2f -> mstate.jcf.emit
   
---bytecode_real32toReal64:doPart---
do f2d -> mstate.jcf.emit 
   
---byteCode_cmpToBoolFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   dcmpg -> mstate.jcf.emit;
   (if cond
    // 1 (* =  *) then ifeq -> mstate.jcf.emit
    // 2 (* <> *) then ifne -> mstate.jcf.emit
    // 3 (* <  *) then iflt -> mstate.jcf.emit
    // 4 (* <= *) then ifle -> mstate.jcf.emit
    // 5 (* >  *) then ifgt -> mstate.jcf.emit
    // 6 (* >= *) then ifge -> mstate.jcf.emit
   if);
   8-0 -> mstate.jcf.emitShort; (* L1 *)
   bipush -> mstate.jcf.emit; 0 -> mstate.jcf.emit;
   goto -> mstate.jcf.emit;
   10-5 -> mstate.jcf.emitShort; (* L2 *)
   bipush -> mstate.jcf.emit; 1 -> mstate.jcf.emit;   
   
---byteCode_cmpAndJmpFloat:doPart--
do op1.loadToReg; op2.loadToReg;
   lab.out; 
   dcmpg -> mstate.jcf.emit;
   (cond,'L',mstate.localLabArg) -> mstate.emitCmpBoolJmp
   
---byteCode_addFloat:doPart---
do dadd -> mstate.jcf.emit
   
---byteCode_subFloat:doPart---
do dsub -> mstate.jcf.emit
   
---byteCode_mulFloat:doPart---
do dmul -> mstate.jcf.emit
   
---byteCode_divFloat:doPart---
do ddiv -> mstate.jcf.emit 
   
---bytecode_negFloat:doPart---
do dneg -> mstate.jcf.emit
   
---byteCode_int2float:dopart---
do i2d -> mstate.jcf.emit
   
---byteCode_intReg2float:dopart---
do i2d -> mstate.jcf.emit
   
---byteCode_float2int:doPart---
do d2i -> mstate.jcf.emit 
   
---byteCode_CallCproc:doPart---
do (# S: ^text
   do '' -> S[];
      T.scanAll(#
               do (if ch > 0 then
                      ch -> S.put
               if)#);
      (* S[] -> mstate.BCM.emitText;   *)
      S[] -> mstate.emitCallExternal
   #)
   
---byteCode_jsrTable:doPart---
do 
   (if newVirt then
       (# R: @adrRegOperand
       do R.alloc;
          (A[],R[],4) -> ldVlImpl;
         '??? mstate.BCM.newVirt -> mstate.BCM.emit;'->putline
       #)
    else
       aload_0 -> mstate.jcf.emit;
       invokevirtual -> mstate.jcf.emit;
       (* NOT in accordance with design - FIX *)
       (mstate.thisClassName[], mstate.thisInnerMethodName[], '()V') 
         -> mstate.jcf.emitMethodRef; 
   if)
   
---byteCode_init:doPart---
   (* called when initializing file. For file 'foo' we have
    * BCname = '/users/smith/beta/myproject/foo/jvm/foo.J'
    * I.e. BCname is the name of the assembly file - the original
    * argument to the call of synthesizer.
    * localFilePath = '~beta/myproject' if foo is in betalib
    * I.e. BCname is the fill path and localFileptah is a local path
    *)
do (if localFilePath[] = none then
       (* hack to signal that BCname is the currentFileName  *)
       183->trace(#do 'Init:setFile:BCname: ' -> xT; BCname[] -> xT#);
       BCname[] -> mstate.thisFileName[];
       (if not isJava then
           (mstate.thisFileName.copy,0,0) -> mstate.classes.add;
       if);
    else
       183 -> trace
       (#
       do 'Init:SetPathAndFile:BCname: ' -> xT; BCname[] -> xT; xN;
          '     localFilepath: ' -> xT; localFilePath[] -> xT;
       #);
       mstate.classes.init; (* still ? *)   
       BCname [] -> mstate.thisFullPath[];
       BCname[] 
         -> mstate.splitPathAndName 
         -> (mstate.thisFullPath[],mstate.thisFileName[]->mstate.thisSourceFileName[]);  
       (if mstate.thisSourceFileName[] = NONE then
           1->trace(#
                   do 'bytecode_init: '->xT;
                      'mstate.thisSourceFileName is none'->xT
                   #)
       if);
       true -> mstate.BCisSplit; (* should be eliminated since
                                  * BC is always split 
                                  *)
       mstate.thisFullPath.copy -> mstate.thisFullSourcePath[];
       &stream[] -> mstate.commentStream[];
       183 -> trace
       (#
       do '    setFile: ' -> xT; mstate.thisFileName[] -> xT
       #);
       
   if);
   (if trace_init_close then
       '\nINIT: ' -> puttext; mstate.thisFullPath[] -> puttext; mstate.thisFileName[]->putline; 
   if);
   
   FIXME.init;
   
   1->ThisRegOp;
   2->CallRegOp;

---bytecode_setPackagePath:doPart---
do packagepath.copy -> mstate.thisPackagePath[];
   packagePath[] -> mstate.thisFullPath.append;
   
---bytecode_comment:doPart--
do (if common.switch[319]
       and 
       (T.length > 0)
       and 
       ((T.length > 0) and ((1 -> T.inxget) <> '!') or common.switch[185])  
       then
       T[] -> mstate.jcf.emitComment;
   if)
   
---new_BCstate:descriptor---
(# ObjectName:
     (# superName: ^text
     do (if true
         // common.targetMachineId = common.jvm then
            'java/lang/Object'->supername[];
         // common.targetMachineId = common.clr then
            'object'->supername[];
         else
            'Unknown_platform.Object' -> supername[];
        if);
     exit superName[]
     #);

   fields: @
     (# Field,FieldName: [5] ^text; Type: [5] ^text; Tag: [5] @char;
        top: @integer;
        init: (# do 0 -> top #);
        numLocals, numCells, numArguments: @integer;
        LocalVariables: [1]@integer;
        new:
          (# F,FN,T: ^text; methodClassTag: @char; 
          enter(F[],FN[],T[],methodClassTag)
          do (if (top+1->top) > Field.range then
                 Field.range -> Field.extend;
                 FieldName.range -> FieldName.extend;
                 Type.range -> Type.extend;
                 Tag.range -> Tag.extend
             if);
             F[] -> Field[top][];
             FN[] -> FieldName[top][];
             T[] -> Type[top][];
             methodClassTag -> Tag[top];
             (# name_index, descriptor_index: @integer;
             do (if methodClassTag 
                 // 'c' 
                 // 'p' 
                 // '[' then
                    (if methodClassTag = '[' then '[' -> T.prepend if);
                    (FN[], T[]) -> mstate.jcf.emitFieldDef;
                 // 's' then (* synthetic field, like 'comp$' *)
                    (FN[], T[]) -> mstate.jcf.emitPublicSyntheticFieldDef
                 // 'm' then
                    (FN[], T[]) -> mstate.allocLocal;
                 // 'M' // 'C' then (* ???*)
                 else
                    '\nField.add: ' -> puttext;
                    FN[] -> puttext; 
                    ' : "' -> puttext; T[] -> puttext; '"'->put;
                    methodclassTag -> put; newline;
                    (failureTrace,'fields.new:Unknown methodClassTag') -> stop
                if);
             #)

          #);
        scan:
          (# currentField,currentFieldName,currentType: ^text;
             currentTag: @char
          do (for i: top repeat
                  Field[i][] -> currentField[];
                  FieldName[i][] -> currentFieldName[];
                  Type[i][] -> currentType[];
                  Tag[i] -> currentTag;
                  INNER scan
             for)
          #);
        emitInit:
          (# 
          #)
     #);
   thisClassName, thisModuleName: ^text;
   blocks: @
     (# D: [5] ^blockDescriptor;
        level: @integer; (* the class level of this block
                          * starting with 0 (zero) at the
                          * outermost level;  currently we only
                          * count class levels; methods in
                          * classes are not counted; for methods
                          * containing classes we should reconsider
                          * the counting of levels
                          *)
        blockDescriptor:
          (# name: ^text
          #);
        mark:
          (# L: @integer; N: ^text
          enter(L,N[])
          do N[] -> thisClassName[];
             (if true            (* check that the new class to be handled
                                  * is on one of the following levels: *)
              // L = level       (* the same level *)
              // L = (level + 1) (* a level down *)
              // L = (level - 1) (* a level up   *)then
              else
                 (if not common.switch[188] then
                     '\n%%%inconsistent block levels: ' -> puttext;
                     level -> putint; ' '->put; L -> putint;
                     newline
                 if)
             if);
             E: (if L > D.range then D.range -> D.extend; restart E if);
             (if (0 <= L) and (L < D.range) then
                 &blockDescriptor[] -> D[L+1][];
                 N[] -> D[L+1].name[];
              else
                 (if not common.switch[188] then
                     '\n%%%block level out of range: ' -> puttext;
                     L -> putint; ' range: '->putText; D.range -> putint;
                     newline
                 if)
             if);
             L -> level
          #);
        pop: (# do level - 1 -> level #);
        (* When accessing fields we need the className
         * and possibly the names of enclosing classes;
         *  level:   the level of the current class;
         *           counting from 0 (zero), 1, ... from the outermost level
         *  ONlevel: no of origin levels to access a field;
         *           0: variable in method in which case we do not come here
         *           1: field in this class
         *           2: field in enclosing class of this class
         *           3: ...
         * Invariant: (0 <= ONlevel) and (ONlevel <= (level+1))
         * D[level+1]              : this class
         * D[level - (ONlevel-1)+1]: class at ONlevel from method in this class
         *                           ONlevel=1 ===> this class
         * D[level - (ONlevel-1)]  : enclosing class at ONlevel
         *                           ONlevel=1 ===> origin of this class
         *)
        class:
          (# ONlevel: @integer; CN : ^text
          enter ONlevel
          do ONlevel->check
             (# inx: @integer
             do level-(ONlevel-1)+1 -> inx;
                (if (0 < inx) and (inx <= D.range) then
                    (if D[inx][] = none then
                        'NoneClass: ' -> putline
                     else
                        D[inx].name[] -> CN[];
                    if);
                 else
                    'UndefinedOuterClass' -> CN[];
                if)
             #);
             (if CN[] = none then 'unKnownClass' -> CN[] if);
          exit CN[]
          #);
        orgClass: 
          (# ONlevel: @integer; CN : ^text
          enter ONlevel
          do 313->trace(#
                       do 'orgClass: level:' -> xT; level -> xI; 
                          ' ONlevel:'->xT; ONlevel -> Xi
                       #);
             ONlevel->check
             (# inx: @integer
             do (if ONlevel > level then
                    ObjectName ->  CN[]
                 else
                    level-(ONlevel-1) -> inx;
                    (if (0 < inx) and (inx <=D.range) then
                        D[inx].name[] -> CN[] 
                     else
                        '\n%%%orgClass: range error:' -> puttext;
                        inx ->putint; newline
                    if)
                if)
             #);
             (if CN[] = none then 'unKnownOriginClass' -> CN[] if)
          exit CN[]
          #);
        check:
          (* *)
          (# ONlevel: @integer
          enter ONlevel
          do (if (0 <= ONlevel) and (ONlevel <= (level+1)) then
                 inner
              else
                 (if not common.switch[188] then
                     '\n%%%blocks:check: inconsistent level: ' -> puttext;
                     ONlevel -> putint; ' '->put; level -> putint;
                     newline
                 if)
             if);
          #)
     #);
   
   
#)


