#!/usr/local/bin/perl -s
$BETALIB=$ENV{'BETALIB'};
$BETALIB=~s%\\%/%g;
require "$BETALIB/bin/admin/env.perl";

sub usage()
{
    local($msg) = @_;
    print "pack_dotnet: $msg\n" if ($msg ne "");
    print<<EOT;
usage: pack_dotnet [-h][-v][-r][-c][-C][-x][-d][-j]
     -h  print this help
     -v  verbose mode
     -C  skip compilation of compilers
     -Z  skip zipping of directory
EOT
    exit;
}

# -------------- Configuration-----------------------------------------

$dest        = "BETA_Net";
$beta        = "$BETALIB/boot/bin/$objdir/beta";
$nbetasrc    = "$BETALIB/compiler/nbeta.bet";
$nbeta       = "$BETALIB/compiler/$objdir/nbeta.exe";
$jbetasrc    = "$BETALIB/compiler/jbeta.bet";
$jbeta       = "$BETALIB/compiler/$objdir/jbeta.exe";
@examples    = ("tstenv.bet",
		"dotnettstenvbody.bet",
		"javabctstenvbody.bet",
		"hello.bet", 
		"Bmini0.bet", 
		"Bmini1.bet", 
		"Server.bet", 
		"Calculator.bet", 
		"Counter.bet", 
		"List.bet", 
		"NumList.bet",
		"Aclass.bet", 
		"Singular.bet", 
		"SuperFields.bet",
		"Ptn.bet", 
		"array.bet",
		"small.bet",
		"hellobox.bet",
		"Bclass*.{bet,cs,config}",
		"stack*.bet",
		"javastring.bet",
		"google*.bet",
		"google.exe.config",
		"nstring.bet",
		"jstring.bet",
		"greetings.bet",
		"beer.bet",
		"ECtest.bet",
		"EC.cs",
		"EC.java",
		);

@cleanup = ( "*/CVS",
	     "configuration/mbs_id",
	     "configuration/MBSgrammars*",
	     "configuration/ymer.pjt",
	     "configuration/env.*",
	     "grammars/*/CVS",
	     "grammars/*/*.lst",
	     "examples/googleapi/CVS",
	     "examples/googleapi/*/CVS",
	     "examples/googleapi/*/*/CVS",
	     "examples/googleapi/*/*/*/CVS",
	     "examples/googleapi/*/*/*/*/CVS",
	     "examples/googleapi/*/*/*/*/*/CVS",
	     "examples/googleapi/*/*/*/*/*/*/CVS",
	     "examples/googleapi/dotnet/GoogleSearchService.dll",
	     "examples/googleapi/dotnet/GoogleSearchService.pdb",
	     );

# -------------- Main -------------------------------------------------

use File::Path;
use File::Copy;
use File::Find;

$skipcompilation = $C;
$skipzipping = $Z;

print "Creating BETA .Net preliminary distribution in directory $dest\n";
 
if ( -d $dest ){
   print "Deleting existing $dest\n";
   &rmtree($dest, 0, 1);
}

if ($skipcompilation){
    print "Skipping recompilation of compilers (-C option)\n";
} else {
    print "Recompiling compilers\n";
    system "$beta -qwd -o $nbeta $nbetasrc > nbetaboot.out";
    system "$beta -qwd -o $jbeta $jbetasrc > jbetaboot.out";
}

print "Creating directory $dest\n";
&mkpath($dest, 0, 0755);

print "Copying compilers\n";
&mkpath("$dest/bin", 0, 0755);
&copy($nbeta, "$dest/bin");
&copy($jbeta, "$dest/bin");

print "Copying grammars\n";
&mkpath("$dest/grammars", 0, 0755);
&copydir("$BETALIB/grammars/metagram", "$dest/grammars");
&copydir("$BETALIB/grammars/pretty", "$dest/grammars");
&copydir("$BETALIB/grammars/beta", "$dest/grammars");

print "Copying configuration\n";
&copydir("$BETALIB/configuration", "$dest");

print "Copying examples\n";
&mkpath("$dest/examples", 0, 0755);
foreach $f (@examples){
    foreach $g (glob("$f")){
	&copy($g, "$dest/examples");
    }
}
&copydir("googleapi", "$dest/examples");

print "Copying documentation\n";
&mkpath("$dest/documentation", 0, 0755);
foreach $f (<$BETALIB/compiler/DOC/BYTECODE/*.*>){
    next if ($f =~ /~$/);
    &copy($f, "$dest/documentation");
}


print "Creating README-dotnet.txt\n";
open README, ">$dest/README-dotnet.txt" || die "Cannot open README-dotnet.txt for writing: $\n";
print README "   NOTICE: an HTML version of this file is available in \n\t   documentation/README-dotnet.html\n\n";
open LYNX, "lynx -dump $dest/documentation/README-dotnet.html|" || die "Cannot start lynx on documentation/README-dotnet.html: $!\n";
while(<LYNX>){
    last if (/^References/);
    s/^>/\t  >/;
    s/\[[0-9]+\]//g;
    print README;
}
close LYNX;
close README;

print "Clean up\n";
foreach $f (@cleanup){
    foreach $g (glob("$dest/$f")){
	print "  Deleting $g\n" if ($verbose);
	&rmtree($g, 0, 1);
    }
}

if ($skipzipping){
    print "Skipping zipping of directory (-Z option)\n";
} else {
    local ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime(time);
    local $zipname = sprintf("$dest-%02d-%02d-%02d.zip", 1900+$year, $month+1, $date);
    unlink "$zipname" if (-e "$zipname");
    print "Zipping directory to $zipname\n";
    system "zip -qr $zipname $dest";
}

# -------------- Routines  ---------------------------------------------

sub copydir($srcdir, $destdir){
    my ($srcdir, $destdir) = @_;
    if (1){
	system "cp -rp $srcdir $destdir";
    } else {
	# Recursive copy not part of std perl (;-(
	# Found in groups.google.com, not tested:
	my $length = length $srcdir;
	find  sub {
	    my $dest = $File::Find::name; # full source path
	    substr($dest, 0, $length) = $destdir;
	    if(-d) {
		mkdir $dest, 0777;
	    } elsif(-f _) {
		copy $_, $dest;
	    }
	}, $srcdir;
    }
}
