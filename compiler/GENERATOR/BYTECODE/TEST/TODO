
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A. General
==========

1. Problem med overskrivning af program.il/program.J for hvert
   program.
    -> Muligvis lave subdirectory til denne navngivet udfra exefilen

2. Dependency analyse for .il/.J/.dll/.class filer


B. Java specific
================

1. Generere .class filer direkte (udenom jasmin)
   Interface er nu klart i GENERATOR/JAVA/classfile.bet.
   Eksempler i GENERATOR/JAVA/TEST.


C. .NET specific
================

1. ** [OLM/PA] 
   Jeg måtte udkommentere en række af de basale patterns i tstenv, da
   der genereres ikke-verificerbart kode for disse. Primært fordi der
   er void funktioner, der efterlader noget på stakken. Det er
   f.eks. state, cstruct, der har problemet. 
   Detaljer (verificeret statig tilstede 31/5)

   ------------------------------------------------------------------------------------
   CStruct::.ctor] [offset 0x0000000D] [opcode callvirt] Stack empty:
   
     .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
     {
           ldarg.0
           call    instance void [mscorlib]System.Object::.ctor()
   
           ldarg.0
           ldarg.1
           stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin
           callvirt instance int32 class ['tstenv']'CStruct'::'byteSize'(int32)
           ldarg.0
           newarr int32
           stfld   int32[] 'CStruct'::F12
           ret
     }

   ------------------------------------------------------------------------------------
   CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow:
   
     .method public virtual int32 'exit'() cil managed
     {
           .maxstack 8
           dup
           ldstr "FIXME: IL has no dup_x1/dup_x2 instructions"    <--------
           call void [mscorlib]System.Console::WriteLine(string)
           ret
     }
   
   Skulle åbenbart have været dup_x1, men det ville jo også give stack
   underflow
   
   ------------------------------------------------------------------------------------
   Samme er i Cstruct_long.

2. FIXED!
 
3. FIXED!

4. *** [OLM]
   GENERATOR/BYTECODE/TEST/multiple fejler
     -> bruger dup_x1/dup_x2

5. FIXED!

6. ** [OLM/PA]
   Ved oversættelse af TST/btst crasher compiler under kodegenerering af
   tstvirt2.
   Sker både med nbeta og jbeta på pc OG LINUX men ikke med nogen af dem på sun
     -> Sikkert et endian problem

7. FIXED!

8. [PA]
   All source files constituting an executable must currently reside
   in the same directory.
   We intent to generate strong assemblies and config files and/or use
   the Global Assembly Cache for solving this later.

9. * [OLM]
   Vi skal kunne specificere fil location for en externalclass, og
   denne fil location skal med ind i import listen.
   Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
   behøver at skulle erklære eksterne klasser og procedurer [PA]

   Vi bør understøtte
      BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
   samt
      INCLUDE 'aSystemAssembly.dll'
   som begge bør
      1. Føre til import af assembly
      2. (senere) føre til indlæsning af klasser i assembly og
         opbygning af ast

10. FIXED!

11. FIXED!

12. *** [OLM] Location for meget
    Fra tstlib.il, class chk:
     
     .method public virtual void 'do'() cil managed 
      {
            .maxstack 8
            .line   10:7 'tstlib.bet'
            .line   10:28 'tstlib.bet'
            ldarg.0
            callvirt instance void class ['tstenv']'chk'::'slot_chk'()
                                         ^^^^^^^^^^Location skal ikke være der (er lokal)
            .line   10:9 'tstlib.bet'
            ret
      }
    
     
    Samme problem er i class fill method do()

13. *** [OLM] Forkert location
    Fra slot_fill.il:
     
    /********************************************/
    /*        Class slot_fill                   */
    /********************************************/
    .class public auto ansi 'slot_fill' extends ['tstlibbody']'preFill'{
      ...  /* instance constructor */
      .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstlib']'fill')
      {
     ldarg.0
     ldarg.1
     ldfld class ['tstenv']'tstenv' class ['tstlib']'fill'::origin 
     call instance void ['tstlibbody']'preFill'::.ctor(class ['tstlib']'tstenv')
                                                               ^^^^^^^ Skal være 'tstenv'


14. *** [OLM] Forkert location og klasse
    Fra tstblock.il:
     /********************************************/
     /*        Class TstBlock_singular_1         */
     /********************************************/
     .class public auto ansi 'TstBlock_singular_1' extends ['tstblock']'TstBlock_Q_scan'{
       ...
       .method public virtual void 'do_1'() cil managed 
       {
             .maxstack 8
             .line   65:16 'tstblock.bet'
             .line   65:21 'tstblock.bet'
             ldarg.0
             ldfld   class ['tstblock']'TstBlock' class ['tstblock']'TstBlock_singular_1'::origin 
             ldfld   class ['tstenv']'tstenv' class ['tstblock']'TstBlock'::origin 
             ldarg.0
             ldfld   char class ['tstblock']'TstBlock_Q_scan'::'c' 
             callvirt instance void class ['TstBlock']'TstBlock'::'put'(char)
                                          ^^^^^^^^^^^^^^^^^^^^^^
                                          Skulle være ['tstenv']'tstenv'

15. * [OLM] Lokal location skal ikke med
    Hvis man f.eks. oversætter
	 ORIGIN 'tstlib';         
	 -- program: Descriptor --
	 (# 
	 do 'a' -> put;
	    'b' -> fill;
	 #)  
    så vil der i program.il være en del referencer til klassen
    program, hvor der medtages location ['program'], hvilket ikke
    er nødvendigt, da det jo er i samme fil.
    F.eks.:

	  .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
	  {
		ldarg.0
		call	instance void [mscorlib]System.Object::.ctor()
	
		ldarg.0
		ldarg.1
		stfld	class ['tstenv']'tstenv' class ['program']'program'::origin 
		ret
	  }
	
	  .method public static void 'program'(class ['tstenv']'tstenv') cil managed 
	  {
		.maxstack 8
		ldarg.0
	
		newobj	instance void class ['program']'program'::.ctor(class ['tstenv']'tstenv')
		callvirt instance void class ['program']'program'::'do'()
		ret
	  }     

    Det er ikke kun æstetisk det generer: det forhindrer verifikation
    af programmet (men det kan godt køre).


16. *** [OLM] Ingen execute metode hvis ingen do-part
    Tag f.eks. følgende i tstlib.bet:
      isBytecode:
         (#  exit isJava or isIL #);
    Denne kaldes f.eks. fra tstblock.il således:
      call int32 class ['tstlib']'isBytecode'::'isBytecode'(class ['tstenv']'tstenv')
    MEN hvis der ingen do-part er i isBytecode genereres metoden
    isBytecode i klassen af samme navn slet ikke.
    Midlertidigt løst ved at tilføje tom do-part.

17. *** [OLM] Ekstra dup
    slot_isplatform.il:

      .method public virtual void 'do'() cil managed 
        {
          .maxstack 8
          .line 16:5 'dotnettstenvbody.bet'
          .line 16:18 'dotnettstenvbody.bet'
          ldarg.0
          ldfld class ['tstenv']'isPlatform' class ['slot_isPlatform']'slot_isPlatform'::origin 
          ldfld class ['tstenv']'text' class ['tstenv']'isPlatform'::'MT' 
          //dup <<<------- skal ikke være der
          ldstr "dotnet"
          
          callvirt instance char[] [mscorlib]System.String::ToCharArray()
          callvirt instance void class ['tstenv']'text'::'enter'(char[])
          .line 2:13 'dotnettstenvbody.bet'
          ret
        }       
        

18. *** [OLM] Missing index for array subscript
    
    I koden for isJavabc (og alle de tilsvarende) mangler der at blive
    pushet et index (1) iinden der slås op i array. Mangler
    tilsyneladende også for java inden caload:

      /********************************************/
      /*        Class isJavabc                    */
      /********************************************/
      .class public auto ansi 'isJavabc' extends ['tstenv']'isPlatform'{
	.field public class ['tstenv']'tstenv' origin
	...
	.method public virtual void 'do_1'() cil managed 
	{
	      .maxstack 8
	      .line   103:7 'tstlib.bet'
	      .line   103:47 'tstlib.bet'
	      ldarg.0
	      ldarg.0
	      ldfld   class ['tstenv']'text' class ['tstenv']'isPlatform'::'MT' 
	      ldfld   char[] class ['tstenv']'text'::'T' 
	      ldlen
	      ldc.i4.6
	      bne.un  L24
	      ldarg.0
	      ldfld   class ['tstenv']'text' class ['tstenv']'isPlatform'::'MT' 
	      ldfld   char[] class ['tstenv']'text'::'T' 
	  ldc.i4.1 <----- denne er indsat i hånden
	      ldelem.u2
	      ldc.i4.s 106 // 'j'
	      ceq
	      br      L25
	L24:
	      ldc.i4.0
	L25:
	      stfld   int32 class ['tstenv']'isPlatform'::'b' 
	      .line   127:2 'tstlib.bet'
	      ret
	}   

19. *** [OLM] Besynderlig argument access
    På dotnet genereres i tstblock.il klassen TstBlock_singular_1 (som
    jeg IKKE kan finde i det tilsvarende genererede Java kode).
    Heri accesses et ikke-eksisterende argument 22:

      /********************************************/
      /*        Class TstBlock_singular_1         */
      /********************************************/
      .class public auto ansi 'TstBlock_singular_1' extends ['tstblock']'TstBlock_Q_scan'{
	.field public class ['tstblock']'TstBlock' origin
      
	/* instance constructor */
	.method public rtspecialname specialname hidebysig instance void .ctor(class ['tstblock']'TstBlock')
	{
	      ldarg.0
	      ldarg.1
	      //ldarg.s 22 ?????????
	      call	instance void ['tstblock']'TstBlock_Q_scan'::.ctor(class ['tstblock']'TstBlock_Q')
      
	      ldarg.0
	      ldarg.1
	      stfld	class ['tstblock']'TstBlock' class ['tstblock']'TstBlock_singular_1'::origin 
	      ret
	}   


