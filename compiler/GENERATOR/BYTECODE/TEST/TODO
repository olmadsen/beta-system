
BETA Bytecode TODO
==================

A. General
==========

1. Problem med overskrivning af program.il/program.J for hvert
   program.
    -> Muligvis lave subdirectory til denne navngivet udfra exefilen

2. Dependency analyse for .il/.J/.dll/.class filer

3. Correct variable names instead of F12 etc


B. Java specific
================

1. Generere .class filer direkte (udenom jasmin)


C. .NET specific
================

1. [OLM/PA]
   Jeg måtte udkommentere en række af de basale patterns i tstenv, da
   der genereres ikke-verificerbart kode fir disse. Primært fordi der
   er void funktioner, der efterlader noget på stakken. Det er
   f.eks. state, cstruct, der har problemet. Ikke nogen showstopper,
   da disse ikke kaldes.
   Detaljer:

   ------------------------------------------------------------------------------------
   tstenv::CStruct] [offset 0x00000006] [opcode ret] Stack must be empty on
   return from a void function:
   
     .method public virtual void 'CStruct'() cil managed
     {
	   .maxstack 8
	   ldarg.0
   
	   newobj  instance void class ['tstenv']'CStruct'::.ctor(class ['tstenv']'tstenv')
	   ret
     }
   
   ------------------------------------------------------------------------------------
   [IL]: Error:
   [c:\beta\r5.3\compiler\generator\bytecode\test\dotnet\tstenv.dll :
   tstenv::ErrorName] [offset 0x00000006] [opcode ret] Stack must be empty on
   return from a void function:
   
     .method public virtual void 'ErrorName'() cil managed
     {
	   .maxstack 8
	   ldarg.0
   
	   newobj  instance void class ['tstenv']'ErrorName'::.ctor(class ['tstenv']'tstenv')
	   ret
     }
   
   ------------------------------------------------------------------------------------
   CStruct::.ctor] [offset 0x0000000D] [opcode callvirt] Stack empty:
   
     .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
     {
	   ldarg.0
	   call    instance void [mscorlib]System.Object::.ctor()
   
	   ldarg.0
	   ldarg.1
	   stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin
	   callvirt instance int32 class ['tstenv']'CStruct'::'byteSize'(int32)
	   ldarg.0
	   newarr int32
	   stfld   int32[] 'CStruct'::F12
	   ret
     }
   
   ------------------------------------------------------------------------------------
   CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow:
   
     .method public virtual int32 'exit'() cil managed
     {
	   .maxstack 8
	   dup
	   ldstr "FIXME: IL has no dup_x1/dup_x2 instructions"    <--------
	   call void [mscorlib]System.Console::WriteLine(string)
	   ret
     }
   
   Skulle åbenbart have været dup_x1, men det ville jo også give stack
   underflow
   
   ------------------------------------------------------------------------------------
   Samme er i Cstruct_long.


 
2. [OLM]
   Derimod er det ikke så godt at vi stadig har main() i
   tstenv.il. Dette giver en "DLL initialization routine failed" fejl
   når man prøver at bruge BETA filer som library fra C# (den var svær
   at finde - elendig .NET fejlbesked!). Jeg har lavet et medledtidig
   workaround, og beskrevet det i README-dotnet.txt.
   Om muligt bør main puttes i .il filen hørende til filen der
   definerer program slottet (foo.il, og ikke program.il). Jeg tror
   det er bedst.
 
3. [OLM]
   Der er nogle lidt forkerte locations i tstenv.il (forhindrer
   verification, men åbenbart ikke execution (?)).  Det er i
   forbindelse med SLOTs, hvor der f.eks. genereres følgende i
   put.enter() i tstenv.il:
 
      .method public virtual void 'enter'(char) cil managed 
       {
         .maxstack 8
         ldarg.0 /*1*/
         ldarg.1
         stfld char class [put]put::F12 
         ret
      }
 
   Problemet er at det angives, at F12 ligger i klassen put i location
   put (dvs i put.dll), men F12 feltet er i class put i tstenv.il.
   Der er en 4-5 stykker af denne type fejl i put, newline, putInt.

   Desuden er der nogle *manglende locations* ved oversættelse af
   TST/btst (uden tstvirt2):

       assembling ~beta/compiler/TST/dotnet/slot_fill.il
       ...
       Error: Reference to undefined class 'preFill' (token 0x01000002)
       Error: Reference to undefined class 'fill' (token 0x01000005)
       ...
       assembling ~beta/compiler/TST/dotnet/slot_chk.il
       ...
       Error: Reference to undefined class 'chk' (token 0x01000006)


4. [OLM]
   GENERATOR/BYTECODE/TEST/multiple fejler
     -> bruger dup_x1/dup_x2

5. [OLM]
   FIXED!

6. [OLM]
   Ved oversættelse af TST/btst crasher compiler under kodegenerering af
   tstvirt2.
   Sker både med nbeta og jbeta på pc men ikke med nogen af dem på sun
     -> Muligvis et problem med fil-stier

7. [OLM]
   tstlib refereres, men importeres ikke ved oversættelse af f.eks. 
   TST/tstarith.
     -> manglende import ved INCLUDE?
   Der er andre manglende imports - jeg må hardkode følgende:
   (skal nok lave liste af hvem der refererer hvis ikke de alle
   forsvinder med tstlib fejl rettelsen):

        '.assembly extern tstlib {}\n'
        '.assembly extern tstarith {}\n'
        '.assembly extern tstrelop {}\n'
        '.assembly extern tstbool {}\n'
        '.assembly extern tstblock {}\n'
        '.assembly extern tstvirt {}\n'
        '.assembly extern exe {}\n'
        '.assembly extern fill {}\n'
        '.assembly extern chk {}\n'
        '.assembly extern isPlatform {}\n'
        '.assembly extern tstenv {}\n'

8. [PA]
   All source files constituting an executable must currently reside
   in the same directory.
   We intent to generate strong assemblies and config files and/or use
   the Global Assembly Cache for solving this later.

9. [OLM]
   Vi skal kunne specificere fil location for en externalclass, og
   denne fil location skal med ind i import listen.
   Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
   behøver at skulle erklære eksterne klasser og procedurer [PA]

10.[OLM/PA]
   Der er et problem som jeg kun ser ved oversættelse af
   TST/tstlibbody:
   Ved generering af slot_exe.il fås pludselig en pushVal med et
   offset som er 8 lige inden kaldet
     callvirt instance void slot_exe::do_2()
   i slot_exe::do_1(). Det er kaldt med hasFieldName=true, men med
   fieldnavnet "NoFieldName".
   Dette resulterer i en "ldloc.-1" instruktion, som er ulovlig.
   jbeta genererer en "iload_0" her(!)

