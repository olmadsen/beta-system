ORIGIN 'tstenv'
-- PROGRAM: descriptor ---
(# (* Example of BETA program implementing          *)
   (* a small primitive recursive descent parser    *)
   (* for expressions like: a * (b + c) !           *)
   (* ! terminates the input.                       *)
   (* The following grammar is used: *)
   (*   <exp>:: = <term> {('+' | '-') <term>}*      *)
   (*   <term>:: = <factor> {('*' | '/') <factor>}* *)
   (*   <factor>:: = 'a' | 'b' | 'c'                *)
   (*             |  '(' <exp> ')'                  *)
   (*                                               *)
   (* A trace of the recursive activations          *)
   (* generated during parsing is printed.          *)
   (* In addition a reverse polish translation      *)
   (* of the input is printed.                      *)
   NextChar: 
     (* read next char from screen *)
     (# 
     do skipBlanks: 
          (if (get -> ch) // ' ' then
              restart skipBlanks
          if);
     #);
   ch: @char; (* next char on input  *)
   (* Trace and ind are used for generating a trace of recursive calls
    * encountered during parsing
    *)
   ind: @integer; (* current indentation *)
   Trace: 
     (# nest: 
          (# T: @text; n: @integer
          enter(T,n)
          do T -> putText; newline;
             ind+n -> ind;
             (for i: ind repeat ' ' -> put for)
          #)
     do '[' -> put; INNER; ('] ',-1) -> nest
     #);
   Exp: Trace
     (# c: @char
     do ('Exp',1) -> nest;
        &Term;
        parseAddOp: 
          (if ch // '+' // '-' then
              ch -> c;
              NextChar;
              &Term;
              c -> save;
              restart parseAddOp
     if)#);
   Term: Trace
     (# c: @char
     do ('Term',1) -> nest;
        &Factor;
        parseMultOp: 
          (if ch // '*' // '/' then
              ch ->  c;
              NextChar;
              &Factor;
              c -> save;
              restart parseMultOp
          if)
     #);
   Factor: Trace
     (# do
        ('Factor',1) -> nest;
        L: (# 
           do (if ch
               // 'a' // 'b' // 'c' then
                  ch ->  save;
                  NextChar;
                  leave L
               // '(' then
                  NextChar;
                  &Exp;
                  (if ch // ')' then
                      NextChar;
                      leave L
                  if)
              if);
              '?' -> put;
           #);
     #);
   Save: @
     (# ch: @char;
        T: [16]@char;
        top: @integer;
        print: (# do T -> putText #)
     enter ch
     do top+1->top;
        (if top>T.range then
            T.range->T.extend;
        if);
        ch -> T[top];
     #);
do 0 -> ind;
   'Type an expression: ' -> putText;
   NextChar;
   &Exp;
   newline;
   Save.print; newline;
#)











