ORIGIN '~beta/basiclib/betaenv';
BUILD clr 'clr/convert.dll' 'convert.cs' 'csc -t:library -out:clr/convert.dll -r:System.dll convert.cs'
      jvm 'jvm/convert.class' 'convert.java' 'javac -classpath jvm -d jvm convert.java';

(* Test conversion between primitive integer types.
 * Program should run with no verification errors and no output.
 * Currently only tests int32 vs. int 64.
 * Should also test combinations with int8 and int16.
 * And what about unsigned primitives?
 *)

--program:descriptor--
(# i64: @int64;
   i32: @int32;
   
   convert: ExternalClass
     (# 
        Int64ToInt32: proc
          (# i64: @int64;
             i32: @int32;
          enter i64
          exit i32
          #);
        Int32ToInt64: proc
          (# i32: @int32;
             i64: @int64;
          enter i32
          exit i64
          #);
        staticInt64ToInt32: static_proc
          (# i64: @int64;
             i32: @int32;
          enter i64
          exit i32
          #);
        staticInt32ToInt64: static_proc
          (# i32: @int32;
             i64: @int64;
          enter i32
          exit i64
          #);
     do 'convert' -> classname
     #);
   e: ^convert;
   
   test1:  (# exit true #);
   test2:  (# exit true #);
   test3:  (# exit true  #);
   test4:  (# exit true #);
   test5:  (# exit true #);
   test6:  (# exit true #);
   test7:  (# exit true  #);
   test8:  (# exit true #);
   test9:  (# exit true #);
   test10: (# exit true #);
   test11: (# exit true  #);
   test12: (# exit true #);
   test13: (# exit true  #);
   test14: (# exit true #);
   test15: (# exit true #);
   test16: (# exit true #);
   test17: (# exit true #);
   test18: (# exit true #);
   
do &convert[] -> e[];
   
   (* Primitive assignments *)
   (if test1 then
       1 -> i32;
       i32 -> i64;
   if);
   (if test2 then
       2 -> i64;
       i64 -> i32;
   if);
   
   (* Tests involving function arguments and results *)
   (if test3 then
       3 -> i64;
       i64 -> e.Int64ToInt32 -> i32;
   if);
   (if test4 then
       4 -> i32;
       i32 -> e.Int64ToInt32 -> i64;
   if);
   
   (if test5 then
       5 -> i32;
       i32 -> e.Int32ToInt64 -> i64;
   if);
   (if test6 then
       6 -> i64;
       i64 -> e.Int32ToInt64 -> i32;
   if);
   
   (if test7 then
       7 -> i64;
       i64 -> convert.staticInt64ToInt32 -> i32;
   if);
   (if test8 then
       8 -> i32;
       i32 -> convert.staticInt64ToInt32 -> i64;
   if);
   
   (if test9 then
       9 -> i32;
       i32 -> convert.staticInt32ToInt64 -> i64;
   if);
   (if test10 then
       10 -> i64;
       i64 -> convert.staticInt32ToInt64 -> i32;
   if);
   
   (* Tests involving function calls to function calls *)
   
   (if test11 then
       11 -> i32;
       i32 -> e.Int32ToInt64 -> e.Int64ToInt32 -> i32;
   if);
   (if test12 then
       12 -> i64;
       i64 -> e.Int64ToInt32 -> e.Int32ToInt64 -> i64;
   if);
   
   (if test13 then
       13 -> i32;
       i32 -> convert.staticInt32ToInt64 -> convert.staticInt64ToInt32 -> i32;
   if);
   (if test14 then
       14 -> i64;
       i64 -> convert.staticInt64ToInt32 -> convert.staticInt32ToInt64 -> i64;
   if);
   
   (if test15 then
       15 -> i64;
       i64 -> e.Int32ToInt64 -> e.Int64ToInt32 -> i64;
   if);
   (if test16 then
       16 -> i32;
       i32 -> e.Int64ToInt32 -> e.Int32ToInt64 -> i32;
   if);
   
   (if test17 then
       17 -> i64;
       i64 -> convert.staticInt32ToInt64 -> convert.staticInt64ToInt32 -> i64;
   if);
   (if test18 then
       18 -> i32;
       i32 -> convert.staticInt64ToInt32 -> convert.staticInt32ToInt64 -> i32;
   if);
   

#)
