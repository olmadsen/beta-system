#!/usr/local/bin/perl -s
$BETALIB=$ENV{'BETALIB'};
$BETALIB=~s%\\%/%g;
require "$BETALIB/bin/admin/env.perl";

###########################################################
##################   Configuration   ######################
###########################################################

$beta        = "$BETALIB/boot/bin/$objdir/beta";
$clroptions  = "-qw -s 23";
$jvmoptions  = "-qw -s 188 23";
$diffoptions = "-u";

# Programs to compile for both jvm and clr
@programs = 
    ("hello", 
     "Bmini0", 
     "Bmini1", 
     "Server", 
     "Calculator", 
     "Counter", 
     "List", 
     "NumList",
     "Aclass", 
     "Singular", 
     "SuperFields",
     "Ptn", 
     "array",
     "small",
     "stackuser",
     "multiple",
     "beer",
     "ECtest", 
     "constructor",
     "real32",
     "faclink",
     "go", 
     );

%programs_with_input =
    (
     "google" => "",
     "googlesnip" => "",
     "LL1" => "a + b",
     );
%clr_with_input =
    (
     "googlesnipre" => "",
     );
%jvm_with_input =
    (
     );

# Programs currently only working for jvm, or specific for jvm
@jvmonly =   
    (
     "jstring",
     "greetings", # currently has hardcoded jvm string signature
     );

# Programs specific for clr
@clronly = 
    (
     "nstring",
     );

# External programs using BETA libraries
%jvmexternals =
    (
     "BclassUser.java" => [
			   # commands to build
			   ['jbeta -x Bclass.bet', 
			    'javac -d jvm -classpath jvm BclassUser.java',
			    ],
			   # command to execute
			   'java -classpath jvm BclassUser'
			   ]
     );
%clrexternals =
    (
     "BclassUser.cs" => [ 
			  # commands to build
			  ['nbeta -x Bclass.bet',
			   'csc /nologo /r:System.dll /r:clr/betaenv.dll /r:clr/Bclass.dll BclassUser.cs',
			   ],
			  # command to execute
			  'BclassUser.exe'
			  ],
     );

# Graphics programs - unless testall -g
%jvmgraphics =
    (
     "helloapplet" => "appletviewer helloapplet.html",
     );
%clrgraphics =
    (
     "hellobox"      => "hellobox.exe",
     "hellographics" => "hellographics.exe",
     );

%known_failures =
    (
     "ECStest" => "jvm: ECStest.<init> wrong signature\n\tclr: problem with default location",
     );



###########################################################
##### End of configuration. Main below (Don't change) #####
###########################################################

&catch_signals();

&process_command_line();

&build_program_list();

if ($list){
    &list_programs();
    exit 0;
}

&compile_compiler();

print "\nTesting console programs\n";
print "========================================================\n";
&make_clean("betaenv");
&test_programs(@programs);

&test_externals();

&test_tst();

&test_graphics();

&print_summary();

###########################################################
############ End of main. Library below ###################
###########################################################

sub usage()
{
    local($msg) = @_;
    print "testall: $msg\n" if ($msg ne "");
    print<<EOT;
usage: testall [-h][-v][-r][-c][-C][-g][-t][-k][-d][-j]
 -h  print this help
 -v  verbose mode
 -l  Just list the programs without testing them
 -O  do not display correct outputs, only errors
 -r  run only (do not compile programs)
 -c  compile only (do not execute programs)
 -C  skip compilation of compiler
 -k  keep programs after execution
 -g  do not execute graphics programs
 -t  do not test TST
 -d  compile for target clr
 -j  compile for target jvm
 If no target options given, script will try to guess target
EOT
 exit;
}

sub compile_program()
{
    local ($f) = @_;
    local $exec;
    if ($host eq "windows"){
	if ($target eq "jvm"){
	    $exec = "$f.bat";
	} else {
	    $exec = "$f.exe";
	}
    } else {
	$exec = "$f";
    }
    unless ($runonly){
	print "-"x10 . "Removing $exec" . "-"x10  . "\n" if ($verbose);
	unlink ("$exec");
	unlink ("program.dll") if (-e "program.dll");
	print "-"x10 . "Compiling $f" . "-"x10  . "\n"; # if ($verbose);
	system "$compilecmd $f > $f.out 2>&1" if (! $verbose);
	system "$compilecmd $f" if ($verbose);
    }
    return $exec;
}

sub list_programs()
{
    # List programs in format ready for pack_clr
    print "\nConsole programs to test:\n";
    print "========================================================\n";
    print "\"" . join(".bet\",\n\"", sort @programs) . ".bet\",\n";
    print "\nExternal programs to test:\n";
    print "========================================================\n";
    print "\"" . join("\",\n\"", (sort keys(%externals))) . "\",\n";
    print "\nGraphics programs to test:\n";
    print "========================================================\n";
    print "\"" . join("\",\n\"", (sort keys(%graphics))) . "\",\n";
    print "\nStandard test suite:\n";
    print "========================================================\n";
    print "\"../../../TST/btst.bet\"" . "\n\n";
}


sub test_programs()
{
    local @progs = @_;
    foreach $f (@progs){
	
	$exec = &compile_program($f);

	unless ($compileonly){
	    # Execute
	    if (defined($programs_with_input{$f})){
		print "-"x10 . "Executing $exec with input \"" . $programs_with_input{$f} . "\" " . "-"x10  . "\n"; # if ($verbose);
		system "echo " . $programs_with_input{$f} . "|./$exec > $f.run";
	    } else {
		print "-"x10 . "Executing $exec" . "-"x10  . "\n"; # if ($verbose);
		system "./$exec > $f.run";
	    };
	    unless ($keepprograms) {
		unlink "./$exec";
	    }
	    &compare_expected($f);
	}
    }
}

sub test_externals()
{
    if (scalar %externals){
	print "\nTesting external programs\n";
	print "========================================================\n";
	foreach $external (keys(%externals)){
	    print "-"x10 . "Testing $external" . "-"x10  . "\n";
	    unlink ("$external.out");
	    $commandsref = $externals{$external};
	    $buildsref  = $commandsref->[0];
	    $executecmd = $commandsref->[1];
	    foreach $command (@{$buildsref}){
		print "> $command\n";
		system "$command >> $external.out" if (! $verbose);
		system "$command" if ($verbose);
	    }
	    print "> $executecmd\n";
	    system "$executecmd > $external.run";
	    &compare_expected($external);
	}
    }
}

sub test_graphics()
{
    if (scalar %graphics){
	if ($nographics){
	    print "\nGraphics programs not tested (testall -g). Do it manually:\n";
	    print "========================================================\n";
	} else {
	    print "\nStarting test of graphics programs\n";
	    print "========================================================\n";
	}
	foreach $key (keys(%graphics)){
	    $command = $graphics{$key};
	    if ($nographics){
		print "    $key:\n\tcommand: $command";
	    } else {
		$exec = &compile_program($key);
		print "-"x10 . "Testing $exec";
		print ": \"$command\"" if ($command ne $exec);
		print "-"x10  . "\n";
		system "$command";
		unless ($keepprograms) {
		    unlink "$exec";
		}
	    };
	    print "\n";
	}
	print "\n";
    }
}

sub test_tst()
{
    if ($notst){
	print "\nTST not tested (testall -t). Do it manually.\n";
    } else {
	print "\nTesting ../../../TST/btst\n";
    }
    print "========================================================\n";
    $testdir = `pwd`; chomp $testdir;
    if (chdir "../../../TST"){
	unlink ("tstenv." . $AstExt{$objdir});
	$exec = &compile_program("btst");
	print "-"x10 . "Testing $exec" . "-"x10  . "\n";
	system "$exec > $testdir/btst.run";
	unless ($keepprograms) {
	    unlink "$exec";
	}
    } else {
	print "Cannot chdir(../../../TST): $!\n";
    }
    if (!chdir("$testdir")){
	print "Cannot change dir back to $test: $!\n";
    }
    &compare_expected("btst");
}

sub make_clean()
{
    local ($betaenv) = @_;
    print "*** Removing ast files ***\n" if ($verbose);
    system "rm *.ast *.astL >/dev/null 2>&1";
    &compile_program($betaenv);
    unlink "jvm/String.class";
}

sub compile_compiler()
{
    if ($target eq "clr"){
	$sbetasrc="$BETALIB/compiler/nbeta.bet";
	$sbeta="$BETALIB/bin/$objdir/nbeta${EXESUFFIX}";
    } else {
	$sbetasrc="$BETALIB/compiler/jbeta.bet";
	$sbeta="$BETALIB/bin/$objdir/jbeta${EXESUFFIX}";
    }
    
    unless ($C || $runonly){
	print "*** Compiling $sbeta ***\n" if ($verbose);
	system "$beta -qw -o $sbeta $sbetasrc > bootbeta.out" if (!$verbose);
	system "$beta -qw -o $sbeta $sbetasrc"                if ($verbose);
    }

    $options = $clroptions     if ($target eq "clr");
    $options = $jvmoptions       if ($target eq "jvm");
    
    $compilecmd = "$sbeta $options"; 
    print "*** Compiling with command ***\n\t$compilecmd\n\n" unless ($runonly);

}

sub build_program_list()
{
    if ($target eq "clr"){
	foreach $key (keys %clr_with_input){
	    $programs_with_input{"$key"} = $clr_with_input{"$key"};
	}
	foreach $key (keys %clrgraphics){
	    $graphics{"$key"} = $clrgraphics{"$key"};
	}
	foreach $key (keys %clrexternals){
	    $externals{"$key"} = $clrexternals{"$key"};
	}
    }
    if ($target eq "jvm"){
	foreach $key (keys %jvm_with_input){
	    $programs_with_input{"$key"} = $jvm_with_input{"$key"};
	}
	foreach $key (keys %jvmgraphics){
	    $graphics{"$key"} = $jvmgraphics{"$key"};
	}
	foreach $key (keys %jvmexternals){
	    $externals{"$key"} = $jvmexternals{"$key"};
	}
    }
    
    push @programs, keys %programs_with_input;
    push @programs, @clronly   if ($target eq "clr");
    push @programs, @jvmonly     if ($target eq "jvm");

}

sub catch_signals()
{
    $SIG{'INT'}  = 'IntHandler';
}

sub process_command_line()
{
    &usage("Compile and execute all test programs") if ($h);
    if (-d "/cygdrive" || -d "C:"){
	$host   = "windows";
	$target = "clr";
    } else {
	$host   = "unix";
	$target = "jvm";
    }
    
    &usage("Both -d and -f specified") if ($d && $j);
    
    $target="clr" if ($d);
    $target="jvm" if ($j);
    $verbose = $v;
    $compileonly = $c;
    $runonly = $r;
    $skipoutput = $O;
    $keepprograms = $k;
    $nographics = $g;
    $notst = $t;
    $list = $l;
    
    if ($runonly && $compileonly){
	print "*** Both -c (compile only) and -r (run only) specified.\n";
	print "    Ignoring -c.\n";
	$compileonly=0;
    }

    print "*** Testing for target $target ***\n";
}

sub compare_expected()
{
    local ($f) = @_;
    open(IN, "<$f.run") || die "Unable to read raw output $f.run:$!";
    open(OUT, ">$f.out") || die "Unable to write processed output:$!";
    while(<IN>) {
	s/\015$//;
	print OUT;
    }
    close IN;
    close OUT;
    if ( -f "reference/$f.run" ){
	if (system("diff $diffoptions reference/$f.run $f.out") == 0){
	    system "cat $f.run" unless $skipoutput;
	    print "[output is correct]\n";
	    system "rm $f.run";
	    system "rm $f.out";
	    $status{$f} = 1;
	} else {
	    # Save diff file for easy lookup
	    system "diff $diffoptions reference/$f.run $f.out > $f.diff";
	    print "[Difference in output - see $f.diff]\n";
	    $status{$f} = 0;
	}
    } else {
	system "cat $f.run";
	system "cp $f.run reference";
	print "[No reference existed. Output above used for future reference]\n";
	print "[Please do a manual 'cvs add reference/$f.run']\n";
	$status{$f} = 2;
    }
}

sub print_summary()
{
    print "\n" . "*"x19 . " Summary " . "*"x19  . "\n";
    print "  Succeeded:\n";
    print "  =========\n";
    foreach $key (sort keys(%status)){
	print "    $key\n" if ($status{$key} == 1);
    }

    if (scalar %status){
	print "  Failed:\n";
	print "  =======\n";
	foreach $key (sort keys(%status)){
	    if ($status{$key} == 0){
		print "    $key";
		print " [see $key.diff]" if (-f "$key.diff");
		print "\n";
	    }
	}
	print "\n";
    }

    if ($target eq "clr"){
	if (scalar @jvmonly){
	    print "  Not tested for .CLR:\n";
	    print "  ====================\n";
	    print "    " . join "\n    ", @jvmonly;
	    print "\n\n";
	}
    }
    if ($target eq "jvm"){
	if (scalar @clronly){
	    print "  Not tested for JVM:\n";
	    print "  ===================\n";
	    print "    " . join "\n    ", @clronly;
	    print "\n\n";
	}
    }

    if (scalar %known_failures){
	print "  Known to fail, not yet part of above test suite (FIXME!):\n";
	print "  ========================================================\n";
	foreach $key (keys(%known_failures)){
	    print "    $key:\n\t" . $known_failures{$key};
	    print "\n";
	}
    }
}

sub IntHandler 
{
    print "User interrupt. Exitting.\n";
    exit(1);
}
