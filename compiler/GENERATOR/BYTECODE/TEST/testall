#!/usr/local/bin/perl -s
$BETALIB=$ENV{'BETALIB'};
$BETALIB=~s%\\%/%g;
if ($ENV{'MIASDK'} eq ""){
    $ENV{'MIASDK'} = ms;
}
require "$BETALIB/bin/admin/env.perl";
%options                = 0;

###########################################################
##################   Configuration   ######################
###########################################################
$beta                   = "$BETALIB/boot/bin/$objdir/beta";
$clroptions             = "-qw -s 23";
$jvmoptions  = "-qw -s 188 23"; # if -p NOT requested, please use testall -p
$diffoptions            = "-u";

&process_command_line();

# Programs to compile for both jvm and clr
@programs = 
    ("hello", 
     "Bmini0", 
     "Bmini1", 
     "Server", 
     "Calculator", 
     "Counter", 
     "List", 
     "NumList",
     "Aclass", 
     "Singular", 
     "SuperFields",
     "Ptn", 
     "array",
     "small",
     "stackuser",
     "multiple",
     "beer",
     "ECtest", 
     "ECStest",
     "constructor",
     "real32",
     "faclink",
     "go", 
     );

%programs_with_input =
    (
     "google" => "",
     "googlesnip" => "",
     "LL1" => "a + b",
     );
%clr_with_input =
    (
     "googlesnipre" => "",
     );
%jvm_with_input =
    (
     );

# Programs currently only working for jvm, or specific for jvm
@jvmonly =   
    (
     "jstring",
     "greetings", # currently has hardcoded jvm string signature
     );

# Programs specific for clr
@clronly = 
    (
     "nstring",
     );

# External programs using BETA libraries
%jvmexternals =
    (
     "BclassUser.java" => [
			   # commands to build
			   ['jbeta Bclass.bet', 
			    'javac -d jvm -classpath jvm/Bclass.jar BclassUser.java',
			    ],
			   # command to execute
			   'java -classpath "jvm/Bclass.jar' . $pathseparator . 'jvm" betauser.BclassUser'
			   ],
     "bpackageuser.java" => [
			   # commands to build
			   ['jbeta bpackage.bet', 
			    'javac -classpath jvm/bpackage.jar -d jvm bpackageuser.java',
			    ],
			   # command to execute
			   'java -classpath "jvm/bpackage.jar' . $pathseparator . 'jvm" bpackageuser'
			   ],
     "ECLIPSE" => [
		   # commands to build
		   [],
		   # command to execute
		   ($host eq "unix") ? 'cd ECLIPSE; make beta' : 'cd ECLIPSE; make beta.windows'
		   ],
     );
%clrexternals =
    (
     "BclassUser.cs" => [ 
			  # commands to build
			  ['nbeta -x Bclass.bet',
			   'csc /nologo /r:System.dll /r:clr/Bclass/betaenv.dll /r:clr/Bclass/Bclass.dll BclassUser.cs',
			   ],
			  # command to execute
			  'BclassUser.exe'
			  ],
     );

# Graphics programs - unless testall -g
%jvmgraphics =
    (
     "helloapplet" => "appletviewer helloapplet.html",
     );
%clrgraphics =
    (
     "hellobox"      => "hellobox.exe",
     "hellographics" => "hellographics.exe",
     );

%known_failures =
    (
     );



###########################################################
##### End of configuration. Main below (Don't change) #####
###########################################################

&catch_signals();

&build_program_list();

if ($options{'list'}){
    &list_programs();
    exit 0;
}

&compile_compiler();

print "\nTesting console programs\n";
print "========================================================\n";
&make_clean();
&test_programs(@programs);

&test_externals();

&test_tst();

&test_graphics();

&print_summary();

&test_standard_libraries();

###########################################################
############ End of main. Library below ###################
###########################################################

sub usage()
{
    local($msg) = @_;
    print "testall: $msg\n" if ($msg ne "");
    print<<EOT;
usage: testall [-h][-v][-r][-c][-C][-g][-t][-k][-d][-j]
 -h  print this help
 -v  verbose mode
 -l  Just list the programs without testing them
 -O  do not display correct outputs, only errors
 -r  run only (do not compile programs)
 -c  compile only (do not execute programs)
 -C  skip compilation of compiler
 -k  keep programs after execution
 -p  Invoke compiler with -p option (jvm: generate disassembly)
 -g  do not execute graphics programs
 -t  do not test TST
 -d  compile for target clr
 -j  compile for target jvm
 If no target options given, script will try to guess target
EOT
 exit;
}

sub compile_program()
{
    local ($f) = @_;
    local $exec;
    if ($host eq "windows"){
	if ($options{'target'} eq "jvm"){
	    $exec = "$f.bat";
	} else {
	    $exec = "$f.exe";
	}
    } else {
	$exec = "$f";
    }
    unless ($options{'runonly'}){
	print "-"x10 . "Removing $exec" . "-"x10  . "\n" if ($options{'verbose'});
	unlink ("$exec");
	unlink ("program.dll") if (-e "program.dll");
	print "-"x10 . "Compiling $f" . "-"x10  . "\n"; # if ($options{'verbose'});
	system "$compilecmd $f > $f.out 2>&1" if (! $options{'verbose'});
	system "$compilecmd $f" if ($options{'verbose'});
    }
    return $exec;
}

sub list_programs()
{
    # List programs in format ready for pack_clr
    print "\nConsole programs to test:\n";
    print "========================================================\n";
    print "\"" . join(".bet\",\n\"", sort @programs) . ".bet\",\n";
    print "\nExternal programs to test:\n";
    print "========================================================\n";
    print "\"" . join("\",\n\"", (sort keys(%externals))) . "\",\n";
    print "\nGraphics programs to test:\n";
    print "========================================================\n";
    print "\"" . join("\",\n\"", (sort keys(%graphics))) . "\",\n";
    print "\nStandard test suite:\n";
    print "========================================================\n";
    print "\"../../../TST/btst.bet\"" . "\n\n";
}


sub test_programs()
{
    local @progs = @_;
    foreach $f (@progs){
	
	$exec = &compile_program($f);

	unless ($options{'compileonly'}){
	    # Execute
	    $executing = ($exec eq "beer") ? "Consuming" : "Executing"; # (:-)
	    if (defined($programs_with_input{$f})){
		print "-"x10 . "$executing $exec with input \"" . $programs_with_input{$f} . "\" " . "-"x10  . "\n"; # if ($options{'verbose'});
		system "echo " . $programs_with_input{$f} . "|./$exec > $f.run";
	    } else {
		print "-"x10 . "$executing $exec" . "-"x10  . "\n"; # if ($options{'verbose'});
		system "./$exec > $f.run";
	    };
	    unless ($options{'keepprograms'}) {
		unlink "./$exec";
	    }
	    &compare_expected($f);
	}
    }
}

sub test_externals()
{
    if (scalar %externals){
	print "\nTesting external programs\n";
	print "========================================================\n";
	foreach $external (keys(%externals)){
	    print "-"x10 . "Testing $external" . "-"x10  . "\n";
	    unlink ("$external.out");
	    $commandsref = $externals{$external};
	    $buildsref  = $commandsref->[0];
	    $executecmd = $commandsref->[1];
	    foreach $command (@{$buildsref}){
		print "> $command\n";
		system "$command >> $external.out" if (! $options{'verbose'});
		system "$command" if ($options{'verbose'});
	    }
	    print "> $executecmd\n";
	    system "sh -c '$executecmd' > $external.run";
	    &compare_expected($external);
	}
    }
}

sub test_graphics()
{
    if (scalar %graphics){
	if ($options{'nographics'}){
	    print "\nGraphics programs not tested (testall -g). Do it manually:\n";
	    print "========================================================\n";
	} else {
	    print "\nStarting test of graphics programs\n";
	    print "========================================================\n";
	}
	foreach $key (keys(%graphics)){
	    $command = $graphics{$key};
	    if ($options{'nographics'}){
		print "    $key:\n\tcommand: $command";
	    } else {
		$exec = &compile_program($key);
		print "-"x10 . "Testing $exec";
		print ": \"$command\"" if ($command ne $exec);
		print "-"x10  . "\n";
		system "$command";
		unless ($options{'keepprograms'}) {
		    unlink "$exec";
		}
	    };
	    print "\n";
	}
	print "\n";
    }
}

sub test_tst()
{
    if ($options{'notst'}){
	print "\nTST not tested (testall -t). Do it manually.\n";
	return;
    } else {
	print "\nTesting ../../../TST/btst\n";
    }
    print "========================================================\n";
    $testdir = `pwd`; chomp $testdir;
    if (chdir "../../../TST"){
	unlink ("tstenv." . $AstExt{$objdir});
	$exec = &compile_program("btst");
	print "-"x10 . "Testing $exec" . "-"x10  . "\n";
	system "$exec > $testdir/btst.run";
	unless ($options{'keepprograms'}) {
	    unlink "$exec";
	}
    } else {
	print "Cannot chdir(../../../TST): $!\n";
    }
    if (!chdir("$testdir")){
	print "Cannot change dir back to $test: $!\n";
    }
    &compare_expected("btst");
}

sub test_standard_library(){
    my ($dir) = @_;
    if (! -e "$BETALIB/demo/demo-utils.perl"){
	print "$BETALIB/demo/demo-utils.perl is required. \n";
	print "Please do a 'cvs update -dP demo' from $BETALIB\n";
	exit(1);
    }
    if (-d "$BETALIB/$dir/demo"){
	chdir "$BETALIB/$dir/demo" || die "Cannot chdir($BETALIB/$dir/demo): $!\n";
	my $command = "perl -s run.demos";
	$command .= " -j" if ($options{'target'} eq "jvm");
	$command .= " -d" if ($options{'target'} eq "clr");
	$command .= " -c" if ($runonly);
	print "\n*** Testing $dir demos using command '$command'***\n\n";
	system "$command";
    } else {
	print "Cannot test standard library $dir\nas directory $BETALIB/$dir/demo does not exist.\n";
    }
}
sub test_standard_libraries(){
    
    print "========================================================\n";
    print "Now running standard library tests\n";
    print "========================================================\n";
    &test_standard_library("containers");
}

sub make_clean()
{
    print "*** Removing ast files ***\n" if ($options{'verbose'});
    system "rm *.ast *.astL >/dev/null 2>&1";

    print "*** Removing bytecode directories ***\n" if ($options{'verbose'});

    print  "rm -rf jvm $BETALIB/basiclib/jvm $BETALIB/basiclib/private/jvm\n" if ($verbose);
    system "rm -rf jvm $BETALIB/basiclib/jvm $BETALIB/basiclib/private/jvm";

    print  "rm -rf clr $BETALIB/basiclib/clr $BETALIB/basiclib/private/clr\n" if ($verbose);
    system "rm -rf clr $BETALIB/basiclib/clr $BETALIB/basiclib/private/clr";
}

sub compile_compiler()
{
    if ($options{'target'} eq "clr"){
	$sbetasrc="$BETALIB/compiler/nbeta.bet";
	$sbeta="$BETALIB/bin/$objdir/nbeta${EXESUFFIX}";
    } else {
	$sbetasrc="$BETALIB/compiler/jbeta.bet";
	$sbeta="$BETALIB/bin/$objdir/jbeta${EXESUFFIX}";
    }
    
    unless ($options{'nocompiler'} || $options{'runonly'}){
	print "*** Compiling $sbeta ***\n" if ($options{'verbose'});
	system "$beta -qw -o $sbeta $sbetasrc > bootbeta.out" if (!$options{'verbose'});
	system "$beta -qw -o $sbeta $sbetasrc"                if ($options{'verbose'});
    }

    $options = $clroptions     if ($options{'target'} eq "clr");
    $options = $jvmoptions     if ($options{'target'} eq "jvm");
    
    $compilecmd = "$sbeta $options"; 
    if (! -e $sbeta){
	# Strip path for jbeta/sbeta - necessary when used from exported system
	$compilecmd =~ s%^.*/%%;
    }
    print "*** Compiling with command:\n***\t$compilecmd\n\n" unless ($options{'runonly'});

}

sub build_program_list()
{
    if ($options{'target'} eq "clr"){
	foreach $key (keys %clr_with_input){
	    $programs_with_input{"$key"} = $clr_with_input{"$key"};
	}
	foreach $key (keys %clrgraphics){
	    $graphics{"$key"} = $clrgraphics{"$key"};
	}
	foreach $key (keys %clrexternals){
	    $externals{"$key"} = $clrexternals{"$key"};
	}
    }
    if ($options{'target'} eq "jvm"){
	foreach $key (keys %jvm_with_input){
	    $programs_with_input{"$key"} = $jvm_with_input{"$key"};
	}
	foreach $key (keys %jvmgraphics){
	    $graphics{"$key"} = $jvmgraphics{"$key"};
	}
	foreach $key (keys %jvmexternals){
	    $externals{"$key"} = $jvmexternals{"$key"};
	}
    }
    
    push @programs, keys %programs_with_input;
    push @programs, @clronly   if ($options{'target'} eq "clr");
    push @programs, @jvmonly     if ($options{'target'} eq "jvm");

}

sub catch_signals()
{
    $SIG{'INT'}  = 'IntHandler';
}

sub process_option()
{
    local ($option, $value, $condition, $on_msg) = @_;
    if ($condition){
	$options{$option} = $value;
	print "*** $on_msg\n";
    } 
}

sub process_command_line()
{
    &usage("Compile and execute all test programs") if ($h);
    if (-d "/cygdrive" || -d "C:"){
	$host   = "windows";
	$options{'target'} = "clr";
	$pathseparator = ";";
    } else {
	$host   = "unix";
	$options{'target'} = "jvm";
	$pathseparator = ":";
    }
    
    &usage("Both -d and -f specified") if ($d && $j);
    
    &process_option('target',       'clr', $d, "Explicit target: clr (-d)");
    &process_option('target',       'jvm', $j, "Explicit target: jvm (-j)");
    &process_option('verbose',      1, 	   $v, "Verbose output (-v)");
    &process_option('compileonly',  1, 	   $c, "Only compiling (-c)");
    &process_option('runonly',      1, 	   $r, "Only running programs (-r)");
    &process_option('skipoutput',   1, 	   $O, "Not displaying correct output (-O)");
    &process_option('keepprograms', 1, 	   $k, "Not deleting programs after execution (-k)");
    &process_option('nographics',   1, 	   $g, "Not testing graphics applications (-g)");
    &process_option('notst',        1, 	   $t, "Not testing TST (-t)");
    &process_option('list',         1, 	   $l, "Only listing programs (-l)");
    &process_option('nodisassemble',1, 	   $p, "Not disassembling for JVM (-p)");
    &process_option('nocompiler',   1, 	   $C, "Not compiling compiler (-C)");
    &process_option('nostdlib',     1, 	   $s, "Not testing standard libraries (-s)");

    $jvmoptions .= " -p" if (!$options{'nodisassemble'});
    
    if ($options{'runonly'} && $options{'compileonly'}){
	print "*** Both -c (compile only) and -r (run only) specified.\n";
	print "    Ignoring -c.\n";
	$options{'compileonly'}=0;
    }

    print "*** Testing for target $options{'target'} ***\n";
}

sub compare_expected()
{
    local ($f) = @_;
    open(IN, "<$f.run") || die "Unable to read raw output $f.run:$!";
    open(OUT, ">$f.out") || die "Unable to write processed output:$!";
    while(<IN>) {
	s/\015$//;
	print OUT;
    }
    close IN;
    close OUT;
    if ( -f "reference/$f.run" ){
	if (system("diff $diffoptions reference/$f.run $f.out") == 0){
	    system "cat $f.run" unless $options{'skipoutput'};
	    print "[output is correct]\n";
	    system "rm $f.run";
	    system "rm $f.out";
	    $status{$f} = 1;
	} else {
	    # Save diff file for easy lookup
	    system "diff $diffoptions reference/$f.run $f.out > $f.diff";
	    print "[Difference in output - see $f.diff]\n";
	    $status{$f} = 0;
	}
    } else {
	system "cat $f.run";
	system "cp $f.run reference";
	print "[No reference existed. Output above used for future reference]\n";
	print "[Please do a manual 'cvs add reference/$f.run']\n";
	$status{$f} = 2;
    }
}

sub print_summary()
{
    local $summaryfile = "testall.$options{'target'}.summary";
    open (SUMMARY, ">$summaryfile") or die "Cannot open $summaryfile: $!\n";
    print SUMMARY "\n" . "*"x19 . " Summary " . "*"x19  . "\n";
    print SUMMARY "Test summary for target $options{'target'}:\n\n";
    print SUMMARY "  Succeeded:\n";
    print SUMMARY "  =========\n";
    foreach $key (sort keys(%status)){
	print SUMMARY "    $key\n" if ($status{$key} == 1);
    }

    if (scalar %status){
	print SUMMARY "  Failed:\n";
	print SUMMARY "  =======\n";
	foreach $key (sort keys(%status)){
	    if ($status{$key} == 0){
		print SUMMARY "    $key";
		print SUMMARY " [see $key.diff]" if (-f "$key.diff");
		print SUMMARY "\n";
	    }
	}
	print SUMMARY "\n";
    }

    if ($options{'target'} eq "clr"){
	if (scalar @jvmonly){
	    print SUMMARY "  Not tested for .NET:\n";
	    print SUMMARY "  ====================\n";
	    print SUMMARY "    " . join "\n    ", @jvmonly;
	    print SUMMARY "\n\n";
	}
    }
    if ($options{'target'} eq "jvm"){
	if (scalar @clronly){
	    print SUMMARY "  Not tested for JVM:\n";
	    print SUMMARY "  ===================\n";
	    print SUMMARY "    " . join "\n    ", @clronly;
	    print SUMMARY "\n\n";
	}
    }

    if (scalar %known_failures){
	print SUMMARY "  Known to fail, not yet part of above test suite (FIXME!):\n";
	print SUMMARY "  ========================================================\n";
	foreach $key (keys(%known_failures)){
	    print SUMMARY "    $key:\n\t" . $known_failures{$key};
	    print SUMMARY "\n";
	}
    }
    close SUMMARY;
    system "cat $summaryfile";
    print "\n(This summary available on file $summaryfile)\n";
}

sub IntHandler 
{
    print "User interrupt. Exitting.\n";
    exit(1);
}
