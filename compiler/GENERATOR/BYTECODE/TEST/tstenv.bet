MDBODY jvm 'javabctstenvbody' 
       clr 'dotnettstenvbody'
       ppcmac 'mactstenvbody' 
       default 'tstenvbody';
(*BUILD jvm 'jvm/beta/Component.class' 'Component.java' 'javac -classpath jvm -d jvm Component.java';*)
------------betaenv: descriptor--------------   
(************************************************)
(*           Minimal BETA environment           *)
(************************************************)
(# 
   MinInt32:  (# exit 0x80000000 #);
   MinInt:    (# exit MinInt32 #);
   
   program: <<SLOT PROGRAM: descriptor>>;  
    
   <<SLOT LIB: attributes>>;
  
   put:  
     (# ch: @char;     
     enter ch    
     <<SLOT put:doPart>> 
     #);       
   newline: (# <<SLOT newline:doPart>> #);  
   putText:       
     (# T: [1] @char;
        terminated: @boolean;
     enter T     
     do (for i: T.range repeat 
             (if not terminated then
                 (if T[i]=0 then  
                     true->terminated 
                  else
                     T[i]-> put 
                 if); 
             if);
        for); 
     #);   
   putText2:      
     (# T: ^text; (*T: [1] @char*)     
     enter T[]   
     do (for i: (*T.range*) T.T.range repeat T.T[i]-> put for)
     #);   
   putLine:   
     (# T: ^Text  
     enter T[] do T->puttext; newline
     #);
   getLine:   
     (# T: ^Text;
     <<SLOT getline:doPart>>
     exit T[]
     #);
   get:
     (# ch: @char; 
     <<SLOT get:doPart>>
     exit ch 
     #);
   putInt:
     (# n,i: @integer; W: [12]@char
     enter n
     <<SLOT putint:doPart>> 
     #); 
   text: 
     (# T: [0] @char; lgth,pos: @integer;
        length: (# exit T.range #);
     enter T 
     exit T 
     #); 
   
   indent: @Integer;     
   Newl: @
     (# Prompt: [10] @char; (* prompt for each test part, max 10 chars*)
     enter prompt  
     do '.'->put; newline; Prompt->puttext; 
        (for i: 10-prompt.range repeat ' ' ->put for);
        ':' -> put; 
        (for i: 1 repeat ' ' -> put for);
        indent+1 -> indent;  
     #);
   charValue: (# value: @char do INNER exit value #);
 
   
   BOOLEAN: (#  #);
   FALSE: BOOLEAN(# #);
   TRUE: BOOLEAN(# #);  
   int8: (# #);
   CHAR: (# #); int8u: (# #);
   int16: (# #);
   int16u: (# #); shortInt: (# #);
   int32: (# #); INTEGER: (# #);
   int32u: (# #);
   int64: (# #);
   int64u: (# #);    
   real: (# x,y: @integer enter(x,y) exit(x,y) (* realdesc *) #);
   real32: (# #);
   External:
     (# CallC,CallStd,CallPascal,Pascal,PascalTrap,
  	cExternalEntry,PascalExternalEntry: @text   
     #);       
   Com: (# #); 
   Holder: (# adr: @ integer #);   
   (* state: (# #); *)
   IntegerValue: (# value: @integer do INNER exit value #);
   IntegerObject: IntegerValue(# enter value do INNER #);
   CStruct: (* Super-pattern for describing CStruct-patterns *) 
     (# R: [(byteSize) div 4 + 1] @integer; 
        byteSize:< IntegerObject
          (* R is the bytestream containing the CStruct. 
           * Must be declared as the first attribute  
           *); 
        Byte: (* Used for declaring CStruct fields *) 
          (# p: @pos; pos:< IntegerObject; val: @integer;
             set: @(# enter val do (R,p,val)->TOS'%inxPutByte' #);
          enter set 
          exit (R,p)->TOS'%inxGetByte'
          #);  
        Long: (* Used for declaring CStruct fields *)
          (# p: @pos; pos:< IntegerObject; val: @integer;
             set: @(# enter val do (R,p,val)->TOS'%inxPutLong' #);
          enter set   
          exit (R,p)->TOS'%inxGetLong' 
          #);   
     #);   
   (* Bytecode temporary stuff *)
   ExternalClass:
     (# classname: @text;
     do INNER;
     #);
   class: (# (*classname: @text;*) #);    
   proc: (# (*procname: @text;*) #); 
   Structure: (# #);
   
   Data: (# #); 
   ErrorName: (# #);   
   Object:  
     (# _Struc:  
          (# (* Changed 12/8/97 by datpete: 
              * eliminates need for runtime routine ThisS
              *)  
             (* R: ##Object do TOS'ThisS'->R## exit R## *)
          exit THIS(Object)## 
          #);
        _state:
          (# S: ##object
          enter S##
          do (# R: ^object;
                A,B,P: @integer
             do this(object)[] -> R[];
                (%getLongAt @@S) -> A; (* address of S *)
                (* copy prototype *)
                (%getLongAt (A+12)) -> P; (* the prototype of S*)
                (%getLongAt @@R) -> B; (* address of R*)
                (P+24) %putLongAt (B); (* with COM prototypes, point to the VDT*)
                (* copy origin *)
                (%getLongAt (A+8)) -> P;  
                (*(P) %putLongAt (B+8);*);
             #)
          #);
     do INNER
     #);
   repetition:       
     (* pattern describing repetitions.
      * Do NOT use as superpattern!!! 
      *) 
     (# range: (* exit the range of THIS(rep) *)
          (# n: @ integer exit N #);
        new: 
          (* allocate a new repetition of N elements
           * the current elements in THIS(rep) becomes inaccessible
           *)
          (# n: @integer enter n #);
        extend: (* extend THIS(rep) by N elements *)
          (# N: @integer enter N #);  
     #);
   
   init:
     (* Present for compatiblilty with real betaenv: Needed for bytecode *)
     (# 
     do 
     #);

do 'O'->put;
   'K'->puttext (* CopyT *);  
   '.'->putline (* MkTO *); 
   program;    
   newline
#)


 
    
   
 

