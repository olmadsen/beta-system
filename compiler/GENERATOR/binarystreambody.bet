ORIGIN 'binarystream';
INCLUDE '~beta/basiclib/v1.5/file';
---BinaryStreamRep:descriptor--
(# R: [1000] @integer;  top: @integer; (* byte pointer: [0,...] *)
   inc:
     (# N: @integer
     enter n
     do (if (n+top->top) >= (R.range*4) then R.range->R.extend if)
     #);
   align2:
     (#
     do (if top mod 2 // 1 then 1->inc if)
     #);
   align4:
     (#
     do (if top mod 4 
         // 1 then 3->inc
         // 2 then 2->inc
         // 3 then 1->inc
        if)
     #);
    F: @file
     (# binary::< TrueObject;
        accessError::(#do name -> this(BinaryStream).accessError #);
        NoSpaceError::(#do name -> this(BinaryStream).NoSpaceError #);
        WriteError::(#do name -> this(BinaryStream).WriteError #);
     #);
  
#)
---BinaryStreamPut:doPart--
do (rep.R,rep.top,ch) -> TOS'%inxPutByte'; 1->rep.inc
---BinaryStreamPutShort:doPart--
do rep.align2; (rep.R,rep.top,V) -> TOS'%inxPutShort'; 2->rep.inc
---BinaryStreamPutLong:doPart--
do rep.align4; (rep.R,rep.top,V) -> TOS'%inxPutLong'; 4->rep.inc
---BinaryStreamPutText:doPart--
do T.scanAll(#do ch->put #); 0->put
---BinaryStreamGet:doPart--
do (rep.R,rep.top) -> TOS'%inxGetByte'->ch; 1->rep.inc; 
---BinaryStreamGetShort:doPart--
do rep.align2; (rep.R,rep.top) -> TOS'%inxGetShort'->V; 2->rep.inc
---BinaryStreamGetLong:doPart--
do rep.align4; (rep.R,rep.top) -> TOS'%inxGetLong'->V; 4->rep.inc
---BinaryStreamGetText:doPart--
do &Text[]->T[];
   L: (# ch: @char
      do get->ch;
         (if ch = 0 then 
          else 
             ch->T.put;
             restart L
         if)
      #)
---BinaryStreamSave:descriptor---
(# PR: @rep.F.PutRep	 
do (if FN[] = NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenWrite; 
   (@@rep.R[1],(rep.top+4) div 4)->PR; 
   rep.F.close
#)
---BinaryStreamRestore:descriptor---
(# FG: @rep.F.GetRep; size: @Integer;
do (if FN[] = NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenRead; 
   ((rep.F.length-1) div 4)+1-> size;
   (if size > rep.R.range then
       size -> rep.R.new;
   if);
   (@@rep.R[1],size)->FG; 
   rep.F.close;
   0->rep.top
#)
