ORIGIN '~beta/basiclib/betaenv';

--LIB:attributes--

(*
 * intel.bet:
 *   Patterns used to model the intel 386/486 registers and instructions.
 *   The comments refer to sections in "Intel486 Microprocessor Family - 
 *   Programmer's Reference manual, Intel 1992, ISBN 1-55512-159-4".
 * 
 *   $Id: intel.bet,v 1.2 2001-11-22 13:05:25 corry Exp $
 *)

(* Appendix D: Condition Codes *)

cond_o:   (# exit 2x0000 #); (* overflow *)
cond_no:  (# exit 2x0001 #); (* no overflow *)
cond_b:   (# exit 2x0010 #); (* below *)
cond_nae: (# exit 2x0010 #); (* neither above nor equal *)
cond_nb:  (# exit 2x0011 #); (* not below *)
cond_ae:  (# exit 2x0011 #); (* above or equal *)
cond_e:   (# exit 2x0100 #); (* equal *)
cond_z:   (# exit 2x0100 #); (* zero *)
cond_ne:  (# exit 2x0101 #); (* not equal *)
cond_nz:  (# exit 2x0101 #); (* not zero *)
cond_be:  (# exit 2x0110 #); (* below or equal *)
cond_na:  (# exit 2x0110 #); (* not above *)
cond_nbe: (# exit 2x0111 #); (* neither below nor equal *)
cond_a:   (# exit 2x0111 #); (* above *)
cond_s:   (# exit 2x1000 #); (* sign *)
cond_ns:  (# exit 2x1001 #); (* no sign *)
cond_p:   (# exit 2x1010 #); (* parity *)
cond_pe:  (# exit 2x1010 #); (* parity even *)
cond_np:  (# exit 2x1011 #); (* no parity *)
cond_po:  (# exit 2x1011 #); (* parity odd *)
cond_l:   (# exit 2x1100 #); (* less *)
cond_nge: (# exit 2x1100 #); (* neither greater nor equal *)
cond_nl:  (# exit 2x1101 #); (* not less *)
cond_ge:  (# exit 2x1101 #); (* greater or equal *)
cond_le:  (# exit 2x1110 #); (* less or equal *)
cond_ng:  (# exit 2x1110 #); (* not greater *)
cond_nle: (# exit 2x1111 #); (* neither less nor equal *)
cond_g:   (# exit 2x1111 #); (* greater *)


(* Appendix E: Instruction Format and Timing *)

(* 10.2.3.2 Encoding of general register (reg) field *)
(* When w field present in instruction: *)

(* when w = 0 *)
al: (# exit 2x000 #);
cl: (# exit 2x001 #);
dl: (# exit 2x010 #);
bl: (# exit 2x011 #);
ah: (# exit 2x100 #);
ch: (# exit 2x101 #);
dh: (# exit 2x110 #);
bh: (# exit 2x111 #);

(* 16 bit, when w = 1 *)
ax: (# exit 2x000 #);
cx: (# exit 2x001 #);
dx: (# exit 2x010 #);
bx: (# exit 2x011 #);
sp: (# exit 2x100 #);
bp: (# exit 2x101 #);
si: (# exit 2x110 #);
di: (# exit 2x111 #);

(* 32 bit, when w = 1 *)
eax: (# exit 2x000 #);
ecx: (# exit 2x001 #);
edx: (# exit 2x010 #);
ebx: (# exit 2x011 #);
esp: (# exit 2x100 #);
ebp: (# exit 2x101 #);
esi: (# exit 2x110 #);
edi: (# exit 2x111 #);


(* Instruction Bitpatterns - from Table 10.1 *)

(* 
 * Instructions: Each pattern below enters a number of operands
 * and generates the corresponding bit pattern for the intel instruction
 * excluding immediate data etc, which are not part of the opcode itself.
 * 
 * Please look at section 10.2.1 for a general overview of the 
 * instruction format, fig. 10.1:
 * 
 *   _______________________________________________________________
 *  |   opcode1     |   opcode2     |mod| TTT | r/m | ss| inx | base| adrdisp, imm
 *  |_______________|_______________|___|_____|_____|___|_____|_____|
 *  |    byte 1     |    byte 2     |  mod_rm byte  |   s-i-b byte  |
 * 
 * The opcode bits opcode1 and opcode2 are generated by the
 * opcode patterns below (for the patterns exiting 1 and 2 values repectively).
 * The TTT bits may be either a register number, or part of the opcode, they are
 * generated by the opcodes below refering to memory.
 * 
 * The s-i-b byte contains scale, index and base parts of the indexed adressing.
 * The adrdisp may be 32, 16 or 8 bit displacement or none.
 * The imm value may be 32, 16 or 8 bit or none.
 * 
 * The mod and r/m bits of the mod_rm byte, the s-i-b byte, and adrdisp and imm 
 * should be handled by the PutOp patterns of the different mOperands.
 * Notice that the mod_rm with the proper ttt bits will already have been 
 * emitted when the PutOp is called.
 * 
 * The mnemonics below used should be interpreted as follows:
 *   postfix   meaning
 *   ---------------------------------------------
 *   _rr       register to register (reg1 to reg2)
 *   _rrr      reverse reg to reg (reg2 to reg1)
 *   _mr       memory to register
 *   _rm       register to memory
 *   _ir       immediate to register
 *   _im       immediate to memory
 *   _r        register
 *   _m        memory
 *   _i        immediate
 *   _direct   direct 32 bit relative control transfer
 *   _short    direct 8 bit relative control transfer
 * 
 *   prefix    meaning
 *   ----------------------------------------------
 *   _         short version of general instruction
 *   intel_    just to distinguishe from other patterns with otherwise
 *             identical names
 *)

(* Instruction Formats (home made) *)

format1:
  (* One input *)
  (# i1: @char;
  enter i1 
  #);
format2:
  (* Two inputs *)
  (# i1, i2: @char;
  enter (i1, i2) 
  #);
format3:
  (* Three inputs *)
  (# i1, i2, i3: @char;
  enter (i1, i2, i3) 
  #);


(* 32 bit mod_rm constants *)

(* page E-25: 32 bit address mode with mod_rm without s-i-b *)

ea_ind:     (# exit 2x00000000 #); (* (reg) *)
ea_ind_d8:  (# exit 2x01000000 #); (* d8(reg) *)
ea_ind_d32: (# exit 2x10000000 #); (* d32(reg) *)
ea_d32:     (# exit 2x00000101 #); (* d32 *)

(* page E-26: 32 bit address mode with mod_rm and s-i-b *)
ea_sib:     (# exit 2x00000100 #); (* (reg+scaled_index) *)
ea_sib_d8:  (# exit 2x01000100 #); (* d8(reg+scaled_index) *)
ea_sib_d32: (# exit 2x10000100 #); (* d32(reg+scaled_index) *)
no_index:   (# exit 2x100 #);


(*************************** Integer Operations *******************************)

(***** MOV *****)

movl_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10001001, 2x11000000 + i1*8 + i2) #);
movl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10001011, 2x11000000 + i1*8 + i2) #);
movl_mr:  format1 (* i1=reg *)
  (# exit (2x10001011, i1*8) #); 
movl_rm:  format1 (* i1=reg *)
  (# exit (2x10001001, i1*8) #);  
movl_ir:  format1 (* i1=reg1, imm after inst *)
  (# exit (2x11000111, 2x11000000 + i1) #); 
_movl_ir: format1 (* i1=reg1, imm after inst *)
  (# exit (2x10111000 + i1) #); 
movl_im:
  (# exit (2x11000111, 2x00000000) #); 

movb_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10001000, 2x11000000 + i1*8 + i2) #);
movb_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10001010, 2x11000000 + i1*8 + i2) #);
movb_mr:  format1 (* i1=reg *)
  (# exit (2x10001010, i1*8) #); 
movb_rm:  format1 (* i1=reg *)
  (# exit (2x10001000, i1*8) #);  
movb_i8r:  format1 (* i1=reg1, imm after inst *)
  (# exit (2x11000110, 2x11000000 + i1) #); 
_movb_i8r: format1 (* i1=reg1, imm after inst *)
  (# exit (2x10110000 + i1) #); 
movb_i8m:
  (# exit (2x11000110, 2x00000000) #); 

(* Special EAX variants. Moves between eax and (segment:offset) *)
movb_m_al: 
  (# exit 0xA0 #);
movl_m_eax: 
  (# exit 0xA1 #);
movb_al_m: 
  (# exit 0xA2 #);
movl_eax_m: 
  (# exit 0xA3 #);

(***** MOVSX/MOVZX *****)

(* sign extend *)
movsxwl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00001111, 2x10111111, 2x11000000 + i1*8 + i2) #); (* 0F BF C0 *)
movsxbl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00001111, 2x10111110, 2x11000000 + i1*8 + i2) #); (* 0F BE C0 *)
movsxwl_mr: format1 (* i1=reg1 *)
  (# exit (2x00001111, 2x10111111, i1*8) #); (* 0F BF 00 *)
movsxbl_mr: format1 (* i1=reg1 *)
  (# exit (2x00001111, 2x10111110, i1*8) #); (* 0F BE 00 *)

(* zero extend *)
movzxwl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00001111, 2x10110111, 2x11000000 + i1*8 + i2) #); (* 0F BF C0 *)
movzxbl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00001111, 2x10110110, 2x11000000 + i1*8 + i2) #); (* 0F BE C0 *)
movzxwl_mr: format1 (* i1=reg1 *)
  (# exit (2x00001111, 2x10110111, i1*8) #); (* 0F B7 00 *)
movzxbl_mr: format1 (* i1=reg1 *)
  (# exit (2x00001111, 2x10110110, i1*8) #); (* 0F B6 00 *)


(***** PUSH *****)

pushl_r:  format1 (* i1=reg1 *)
  (# exit (2x11111111, 2x11110000 + i1) #); 
_pushl_r: format1 (* i1=reg1 *)
  (# exit (2x01010000 + i1) #); 
pushl_m:  
  (# exit (2x11111111, 2x00110000) #);  
pushl_i8:  
  (# exit (2x01101010) #); 
pushl_i:  (* 16 and 32 bit constants *)
  (# exit (2x01101000) #); 

(***** PUSHA *****)

pushal:   (# exit (2x01100000) #); 

(***** POP *****)

popl_r:  format1 (* i1=reg1 *)
  (# exit (2x10001111, 2x11000000 + i1) #); 
_popl_r: format1 (* i1=reg1 *)
  (# exit (2x01011000 + i1) #); 
popl_m:
  (# exit (2x10001111, 2x00000000) #);  

(***** POPA *****)

popal: (# exit 2x01100001 #);

(***** XCHG *****)

xchgb_rr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10000110, 2x11000000 + i1*8 +i2) #);
xchgl_rr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10000111, 2x11000000 + i1*8 +i2) #);
xchgl_r_eax: format1 (* i1=reg1 *)
  (# exit (2x10010000 + i1) #); 
(***** NOP *****)

intel_nop: (# exit 2x10010000 #);

(***** LEA *****)

leal: format1 (* i1=reg1 *)
  (# exit (2x10001101, i1*8) #); 

(***** ALU: ADD, ADDC, AND, OR, SUB, SBB, XOR *****)

add_ttt: (# exit 2x00000000 #); (* 0x00 *)
adc_ttt: (# exit 2x00010000 #); (* 0x10 *)
and_ttt: (# exit 2x00100000 #); (* 0x20 *)
or_ttt:  (# exit 2x00001000 #); (* 0x08 *)
sub_ttt: (# exit 2x00101000 #); (* 0x28 *)
sbb_ttt: (# exit 2x00011000 #); (* 0x18 *)
xor_ttt: (# exit 2x00110000 #); (* 0x30 *)

alul_rr:  format3 (* i1=ttt, i2=reg1, i3=reg2 *)
  (# exit (2x00000001+i1, 2x11000000 + i2*8 + i3) #);
alul_rrr: format3 (* i1=ttt, i2=reg1, i2=reg2 *)
  (# exit (2x00000011+i1, 2x11000000 + i2*8 + i3) #);
alul_mr:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x00000011+i1, i2*8) #); 
alul_rm:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x00000001+i1, i2*8) #);  
alul_i8r: format2 (* i1=ttt,i2=reg1, 1 byte imm after inst *)
  (# exit (2x10000011, 2x11000000 + i1 + i2) #); 
alul_ir:  format2 (* i1=ttt, i2=reg1, 4 byte imm after inst *)
  (# exit (2x10000001, 2x11000000 + i1 + i2) #); 
alul_i8m: format1 (* i1 = ttt *)
  (# exit (2x10000011, 2x00000000+i1) #); 
alul_im:  format1 (* i1 = ttt *)
  (# exit (2x10000001, 2x00000000+i1) #); 

alub_rr:  format3 (* i1=ttt, i2=reg1, i3=reg2 *)
  (# exit (2x00000000+i1, 2x11000000 + i2*8 + i3) #);
alub_rrr: format3 (* i1=ttt, i2=reg1, i3=reg2 *)
  (# exit (2x00000010+i1, 2x11000000 + i2*8 + i3) #);
alub_mr:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x00000010+i1, i2*8) #); 
alub_rm:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x00000000+i1, i2*8) #);  
alub_i8r:  format2 (* i1=ttt, i2=reg1, imm after inst *)
  (# exit (2x10000000, 2x11000000 + i1 + i2) #); 
alub_i8m: format1 (* i1 = ttt *)
  (# exit (2x10000010, 2x00000000 + i1) #); 

(* Special EAX variants *)
alub_i_eax: format1 (* i1 = TTT, immediate byte after inst *)
  (# exit i1+4 #);
alul_i_eax: format1 (* i1 = TTT, immediate half or long after inst *)
  (# exit i1+5 #);

(***** INC, DEC *****)
inc_ttt: (# exit 2x00000000 #);
dec_ttt: (# exit 2x00001000 #);

(* change operand by one *)
byonel_r: format2 (* i1=ttt, i2=reg *)
  (# exit (2x11111111, 2x11000000 + i1 + i2) #);
_byonel_r: format2 (* i1=ttt, i2=reg *)
  (# exit 2x01000000 + i1 + i2 #);
byonel_m: format1 (* i1=ttt *)
  (# exit (2x11111111, 2x00000000+ i1) #);
byoneb_r: format2 (* i1=ttt, i2=reg *)
  (# exit (2x11111110, 2x11000000 + i1 + i2) #);
byoneb_m: format1 (* i1=ttt *)
  (# exit (2x11111110, 2x00000000+ i1) #);


(***** NOT, NEG *****)

not_ttt: (# exit 2x00010000 #);
neg_ttt: (# exit 2x00011000 #);

invl_r: format2 (* i1=ttt, i2=reg *)
  (# exit (2x11110111, 2x11000000+ i1 + i2) #);
invl_m: format1 (* i1=ttt *)
  (# exit (2x11110111, 2x00000000+ i1) #);
invb_r: format2 (* i1=ttt, i2=reg *)
  (# exit (2x11110110, 2x11000000+ i1 + i2) #);
invb_m: format1 (* i1=ttt *)
  (# exit (2x11110110, 2x00000000+ i1) #);

(***** CMP *****)

cmpl_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00111001, 2x11000000 + i1*8 + i2) #);
cmpl_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00111011, 2x11000000 + i1*8 + i2) #);
cmpl_mr:  format1 (* i1=reg *)
  (# exit (2x00111001, i1*8) #); 
cmpl_rm:  format1 (* i1=reg *)
  (# exit (2x00111011, i1*8) #);  
cmpl_ir:  format1 (* i1=reg1, imm long after inst *)
  (# exit (2x10000001, 2x11111000 + i1) #); 
cmpl_im: (* imm long after inst *)
  (# exit (2x10000001, 2x00111000) #); 
cmpl_sir:  format1 (* i1=reg1, sign extended imm byte after inst *)
  (# exit (2x10000011, 2x11111000 + i1) #); 
cmpl_sim: (* sign extended imm byte after inst *)
  (# exit (2x10000011, 2x00111000) #); 

cmpb_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00111000, 2x11000000 + i1*8 + i2) #);
cmpb_rrr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00111010, 2x11000000 + i1*8 + i2) #);
cmpb_mr:  format1 (* i1=reg *)
  (# exit (2x00111000, i1*8) #); 
cmpb_rm:  format1 (* i1=reg *)
  (# exit (2x00111010, i1*8) #);  
cmpb_ir:  format1 (* i1=reg1, imm long after inst *)
  (# exit (2x10000000, 2x11111000 + i1) #); 
cmpb_im: (* imm long after inst *)
  (# exit (2x10000000, 2x00111000) #); 
cmpb_rim: format1 (* imm byte after inst *)
  (# exit (2x10000000, 2x00111000+i1) #); 
cmpb_sir:  format1 (* i1=reg1, sign extended imm byte after inst *)
  (# exit (2x10000010, 2x11111000 + i1) #); 
cmpb_sim: (* sign extended imm byte after inst *)
  (# exit (2x10000010, 2x00111000) #); 

(* Special EAX variants *)
cmpl_i_eax:  format1 (* imm long/half after inst *)
  (# exit (2x00111101) #); 
cmpb_i_al:  format1 (* imm byte after inst *)
  (# exit (2x00111100) #); 

(***** TEST *****)

testl_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10000101, 2x11000000 + i1*8 + i2) #);

testb_rr:  format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x10000100, 2x11000000 + i1*8 + i2) #);

(***** MUL *****)

(***** IMUL *****)

imul_rr: format2 (* i1=reg1, i2=reg2 *)
  (# exit (2x00001111, 2x10101111, 2x11000000 + i1*8 + i2) #);
imul_rm: format1 (* i1=reg1 *)
  (# exit (2x00001111, 2x10101111, 2x00000000 + i1*8) #);
imul_rir: format2 (* i1=reg1, i2=reg2, imm after inst *)
  (# exit (2x01101001, 2x11000000 + i1*8 + i2) #); (* s=0 *)
imul_mir: format1 (* i1=reg1, imm after inst *)
  (# exit (2x01101001, 2x00000000 + i1*8) #); (* s=0 *)

(***** DIV *****)

(***** IDIV *****)

idivl_r: format1 (* i1=reg*)
  (# exit (2x11110111, 2x11111000+i1) #);
idivl_m:
  (# exit (2x11110111, 2x00111000) #);

(***** CBW/CWDE *****)

(***** CWD/CDQ *****)

cdq: (# exit 2x10011001 #);

(***** Shift: ROL, ROR, SAL, SHL, SHR *****)

rol_ttt: (# exit 2x00000000 #);
ror_ttt: (# exit 2x00001000 #);
(* rcl_ttt: (# exit 2x00010000 #); *)
(* rcr_ttt: (# exit 2x00011000 #); *)
shl_ttt: (# exit 2x00100000 #);
sal_ttt: (# exit 2x00100000 #);
shr_ttt: (# exit 2x00101000 #);
sar_ttt: (# exit 2x00111000 #);

shiftl_r1:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x11010001, 2x11000000 + i1 + i2) #);
shiftl_m1:  format1 (* i1=ttt *)
  (# exit (2x11010001, 2x00000000 + i1) #);
shiftl_rc:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x11010011, 2x11000000 + i1 + i2) #);
shiftl_mc:  format1 (* i1=ttt *)
  (# exit (2x11010011, 2x00000000 + i1) #);
shiftl_ri8: format2 (* i1=ttt, i2=reg1, imm after inst *)
  (# exit (2x11000001, 2x11000000 + i1 + i2) #);
shiftl_mi8: format1 (* i1=ttt, imm after inst *)
  (# exit (2x11000001, 2x00000000 + i1) #);

shiftb_r1:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x11010000, 2x11000000 + i1 + i2) #);
shiftb_m1:  format1 (* i1=ttt *)
  (# exit (2x11010000, 2x00000000 + i1) #);
shiftb_rc:  format2 (* i1=ttt, i2=reg *)
  (# exit (2x11010010, 2x11000000 + i1 + i2) #);
shiftb_mc:  format1 (* i1=ttt *)
  (# exit (2x11010010, 2x00000000 + i1) #);
shiftb_ri8: format2 (* i1=ttt, i2=reg1, imm after inst *)
  (# exit (2x11000000, 2x11000000 + i1 + i2) #);
shiftb_mi8: format1 (* i1=ttt, imm after inst *)
  (# exit (2x11000000, 2x00000000 + i1) #);


(***** RCL, RCR *****)

(***** BSWAP *****)
bswap: format1 (* i1=reg *)
  (# exit (2x00001111, 2x11001000+i1) #);

(***** XADD *****)

(***** CMPXCHG *****)

(*************************** Control transfer *******************************)

(***** Jccc *****)

jccc_short: format1 (* i1=condition *)
  (# exit (2x01110000+i1) #);
jccc: format1 (* i1=condition *)
  (# exit (2x00001111, 2x10000000+i1) #);

jo_short:   (# exit cond_o->jccc_short #);   
jno_short:  (# exit cond_no->jccc_short #);  
jb_short:   (# exit cond_b->jccc_short #);   
jnae_short: (# exit cond_nae->jccc_short #); 
jnb_short:  (# exit cond_nb->jccc_short #);  
jae_short:  (# exit cond_ae->jccc_short #);  
je_short:   (# exit cond_e->jccc_short #);   
jz_short:   (# exit cond_z->jccc_short #);   
jne_short:  (# exit cond_ne->jccc_short #);  
jnz_short:  (# exit cond_nz->jccc_short #);  
jbe_short:  (# exit cond_be->jccc_short #);  
jna_short:  (# exit cond_na->jccc_short #);  
jnbe_short: (# exit cond_nbe->jccc_short #); 
ja_short:   (# exit cond_a->jccc_short #);   
js_short:   (# exit cond_s->jccc_short #);   
jns_short:  (# exit cond_ns->jccc_short #);  
jp_short:   (# exit cond_p->jccc_short #);   
jpe_short:  (# exit cond_pe->jccc_short #);  
jnp_short:  (# exit cond_np->jccc_short #);  
jpo_short:  (# exit cond_po->jccc_short #);  
jl_short:   (# exit cond_l->jccc_short #);   
jnge_short: (# exit cond_nge->jccc_short #); 
jnl_short:  (# exit cond_nl->jccc_short #);  
jge_short:  (# exit cond_ge->jccc_short #);  
jle_short:  (# exit cond_le->jccc_short #);  
jng_short:  (# exit cond_ng->jccc_short #);  
jnle_short: (# exit cond_nle->jccc_short #); 
jg_short:   (# exit cond_g->jccc_short #); 

jo:   (# exit cond_o->jccc #);   
jno:  (# exit cond_no->jccc #);  
jb:   (# exit cond_b->jccc #);   
jnae: (# exit cond_nae->jccc #); 
jnb:  (# exit cond_nb->jccc #);  
jae:  (# exit cond_ae->jccc #);  
je:   (# exit cond_e->jccc #);   
jz:   (# exit cond_z->jccc #);   
jne:  (# exit cond_ne->jccc #);  
jnz:  (# exit cond_nz->jccc #);  
jbe:  (# exit cond_be->jccc #);  
jna:  (# exit cond_na->jccc #);  
jnbe: (# exit cond_nbe->jccc #); 
ja:   (# exit cond_a->jccc #);   
js:   (# exit cond_s->jccc #);   
jns:  (# exit cond_ns->jccc #);  
jp:   (# exit cond_p->jccc #);   
jpe:  (# exit cond_pe->jccc #);  
jnp:  (# exit cond_np->jccc #);  
jpo:  (# exit cond_po->jccc #);  
jl:   (# exit cond_l->jccc #);   
jnge: (# exit cond_nge->jccc #); 
jnl:  (# exit cond_nl->jccc #);  
jge:  (# exit cond_ge->jccc #);  
jle:  (# exit cond_le->jccc #);  
jng:  (# exit cond_ng->jccc #);  
jnle: (# exit cond_nle->jccc #); 
jg:   (# exit cond_g->jccc #);   

(***** SETcccc *****)

setccc_r: format2 (* i1=condition, i2=reg *)
  (# exit (2x00001111, 2x10010000+i1, 11000000+i2) #);

(***** LOOP *****)

(***** LOOPZ/LOOPE *****)

(***** LOOPNZ/LOOPNE *****)

(***** JCXZ *****)

(***** JECXZ *****)

(***** JMP *****)

jmp_short: 
  (# exit (2x11101011) #);
jmp_direct: (* d32 after instruction *)
  (# exit (2x11101001) #);
jmp_r: format1 (* i1=reg *)
  (# exit (2x11111111, 2x11100000+i1) #);
jmp_m: format1 (* i1=mod-rm *)
  (# exit (2x11111111, 2x00100000 + i1) #);

(***** CALL *****)

call_direct: (* d32 after instruction *)
  (# exit (2x11101000) #);
call_r: format1 (* i1=reg *)
  (# exit (2x11111111, 2x11010000+i1) #);
call_m: format1 (* i1=mod-rm *)
  (# exit (2x11111111, 2x00010000+i1) #);

(***** RET *****)

ret:
  (# exit 2x11000011 #);
ret_pop: (* imm16 after instruction *)
  (# exit 2x11000010 #);

(***** ENTER/LEAVE *****)
intel_enter: (* imm16 and 8 bit level after instruction *)
  (# exit 2x11001000 #);
intel_leave:
  (# exit 2x11001001 #);

(*************************** Multiple Segment *******************************)

(* not needed *)

(*************************** Bit manipulation *******************************)

(***** BT *****)

(***** BSF *****)

(***** BSR *****)

(*************************** String instructions *******************************)

(* not needed *)

(*************************** Flag control *******************************)

(***** CLC *****)

(***** STC *****)

(***** CMC *****)

(***** CLD *****)

(***** STD *****)

(***** CLI *****)

(***** LAHF *****)

(***** SAHF *****)
sahf:
  (# exit 2x10011110 #);

(***** PUSHF *****)

(***** POPF *****)

(*************************** Decimal Arithmetic *******************************)

(*************************** Processor Control *******************************)

(*************************** Prefix bytes *******************************)

addr_size_prefix: (# exit 2x01100111 #); (* 0x67 *)
op_size_prefix:   (# exit 2x01100110 #); (* 0x66 *)

(* LOCK prefix and the LOCK# signal *)
(* See section 13.1.1 in the "Intel486 Microporcessor Family - 
 * Programmer's Reference manual, Intel 1992, ISBN 1-55512-159-4".
 * Notice that the prefix should ONLY be used before one of
 *    BTST, BTR, BTC,
 *    XCHG, XADD, CMPXCHG,
 *    INC, DEC, NOT, NEG,
 *    ADD, ADC, SUB, SBB, AND, OR, XOR
 * and ONLY if they *write* to memory.
 * Notice also, that no lock is needed for the XCHG instruction
 * since this always locks the bus.
 *)
lock_prefix:      (# exit 0xf0       #);

(*************************** Protection control *******************************)

(*************************** Interrupt instructions *******************************)

int3:
  (# exit (2x11001100) #);
boundl_rm: format1 (* i1=reg *)
  (# exit (2x01100010, i1*8) #);

(*************************** Floating point instructions **************************)

(*** Floating point data transfer ***)
flds: (* 32 bit float *)
  (# exit (2x11011001, 2x00000000) #);
fldl: (* 64 bit float *)
  (# exit (2x11011101, 2x00000000) #);
fstps: (* 32 bit float *)
  (# exit (2x11011001, 2x00011000) #);
fstpl: (* 64 bit float *)
  (# exit (2x11011101, 2x00011000) #);
fistpl: (* 32 bit integer *)
  (# exit (2x11011011, 2x00011000) #);
fildl: (* 32 bit integer *)
  (# exit (2x11011011, 2x00000000) #);

(*** Floating point comparison with memory ***)
fcoms: (* 32 bit *)
  (# exit (2x11011000, 2x00010000) #);
fcoml: (* 64 bit *)
  (# exit (2x11011100, 2x00010000) #);
fcomps: (* 32 bit *)
  (# exit (2x11011000, 2x00011000) #);
fcompl: (* 64 bit *)
  (# exit (2x11011100, 2x00011000) #);

(*** Floating point comparison with ST(i) ***)
fcom: format1 (* i1 = st(i) *)
  (# exit (2x11011000, 2x11010000 + i1) #);
fcomp: format1 (* i1 = st(i) *)
  (# exit (2x11011000, 2x11011000 + i1) #);

(*** Floating point compare ST(0) with ST(1) and pop twice ***)
fcompp:
  (# exit (2x11011110, 2x11011001) #);

(*** Floating point constants ***)
fldz:
  (# exit (2x11011001, 2x11101110) #);
fld1:
  (# exit (2x11011001, 2x11101000) #);
fldpi:
  (# exit (2x11011001, 2x11101011) #);

(*** Floating point arithmetic ***)
fadds: (* 32 bit memory *)
  (# exit (2x11011000, 2x00000000) #);
faddl: (* 64 bit memory *)
  (# exit (2x11011100, 2x00000000) #);
faddp: format1 (* i1 = SP(i) *)
  (# exit (2x11011110, 2x11000000 + i1) #);
fsubs: (* 32 bit memory *)
  (# exit (2x11011000, 2x00100000) #);
fsubl: (* 64 bit *)
  (# exit (2x11011100, 2x00100000) #);
fsubp: format1 (* i1 = SP(i) *)
  (* last byte different from manual! *)
  (# exit (2x11011110, 2x11100000 + i1) #); 
fsubrp: format1 (* i1 = SP(i) *)
  (* last byte different from manual! *)
  (# exit (2x11011110, 2x11101000 + i1) #);
fmuls: (* 32 bit memory *)
  (# exit (2x11011000, 2x00001000) #);
fmull: (* 64 bit memory *)
  (# exit (2x11011100, 2x00001000) #);
fmulp: format1 (*i1 = SP(i) *)
  (# exit (2x11011110, 2x11001000 + i1) #);
fdivs: (* 32 bit memory *)
  (# exit (2x11011000, 2x00110000) #);
fdivl: (* 64 bit memory *)
  (# exit (2x11011100, 2x00110000) #);
fdivp: format1 (* i1 = SP(i) *)
  (* last byte different from manual! *)
  (# exit (2x11011110, 2x11110000 + i1) #);
fdivrp: format1 (* i1 = SP(i) *)
  (* last byte different from manual! *)
  (# exit (2x11011110, 2x11111000 + i1) #);
fchs:
  (# exit (2x11011001, 2x11100000) #);

(*** Floating point transcendeltal ***)

(*** Floating point processor control ***)

fstsw_ax:
  (# exit (2x11011111, 2x11100000) #);
fstcw: 
  (# exit (2x11011001, 2x00111000) #);
fldcw: 
  (# exit (2x11011001, 2x00101000) #);
fxch: format1 (* i1 = ST(i) *)
  (# exit (2x11011001, 2x11001000 + i1) #);
fsave: 
  (# exit (2x10011011, 2x11011101, 2x00110000) #);
fnsave: 
  (# exit (2x11011101, 2x00110000) #);
frstor: 
  (# exit (2x11011101, 2x00100000) #);
fincstp:
  (# exit (2x11011001, 2x11110111) #);
fdecstp:
  (# exit (2x11011001, 2x11110110) #);
ffree: format1 (* i1 = ST(i) *)
  (# exit (2x11011101, 2x11000000 + i1) #);
fwait:
  (# exit 2x10011011 #);

