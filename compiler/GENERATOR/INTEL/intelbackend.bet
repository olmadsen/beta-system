ORIGIN '../backend';
INCLUDE 'backmstate';
MDBODY linux '../LINUX/linuxbackendelf';
(*
 * Implementation of slots in ../backend.bet.
 * For helper patterns; see backmstate.bet.
 * For documentation on binary code generation for intel, see
 * ../../DOC/IntelBinary.html.
 *)

--getRegisterOffsets:doPart--
do eax-1 -> dataOff; (* first register is dataOff+1 = eax*) 
   ebp-1 -> adrOff;
   6(*?*)->primOff
   
--getNumberOfDataRegisters:dopart--
do (* See DOC/Registers.html *)
   3->regCount  (* EAX,EBX,ECX *)

--getNumberOfAdrRegisters:dopart--
do (* See DOC/Registers.html *)
   2->regCount  (* EBP,ESI *)
   
--getNumberOfRegisters:dopart--
do (* See DOC/Registers.html *)
   (if type
    // dataReg then 3->number
    // adrReg  then 2+2->number (* this+call counts too *)
    // floatReg then 6->number
    // primReg then 0->number
   if)
   
--getPhysicalRegisterNumber:dopart--
do (* See DOC/Registers.html *)
   (if type
    // dataReg then
       (if reg (* color *)
        // 1 then EAX ->physicalregister
        // 2 then EBX ->physicalregister
        // 3 then ECX ->physicalregister
        else
           'OVERFLOW in datareg: %d\n'->putformat(# do reg->d #)
       if)
    // AdrReg then
       (if reg (* color *)
        // 2+1 then EBP -> physicalregister (* this+call adds 2 *)
        // 2+2 then ESI -> physicalregister (* this+call adds 2 *)
        else
           'OVERFLOW in ADRREG: %d\t'->putformat(# do reg->d #)
       if)
    // FloatReg then
       reg->physicalregister
    // 4 then
       (# t:^text;
       do 'getPhysicalRegisterNumber: error, '->t[];
          reg->t.putint;
          (failuretrace, t[]) ->  stop
       #)
   if)
   
--primRegIsReg:doPart--
do false->value
   
--primRegIsRegAdr:doPart--
do false->value
   
--backendIsSmallAluConstant:doPart--
do true -> value (* all immediates can be encoded in instruction *)
   
--backendIsSmallAdrOff:doPart--
do true -> value (* all immediates can be encoded in instruction *)

--backendHasRotateInstr:doPart--
do true->value
   
--backendScaledIndex:doPart--
do true->value

-- backendNop: dopart --
do (if intel_trace then 'backendNop'->comment if);
   intel_nop -> B_emitbyte;
   eoo;

-- backendgLea:doPart--
do (if intel_trace then 'backendgLea'->comment if);
   I.writeReg -> leal -> emit2bytes;
   (if I.condition then ESP->I.readReg (* StackOff support *) if);
   (I.readReg,I.imm) -> IndirectReg
   
-- backendgLeaInx:doPart--
do (if intel_trace then 'backendgLea'->comment if);
   I.writeReg -> leal -> emit2bytes;
   (I.readReg, I.readReg2 (*I.inxReg*), I.scale, I.imm (*I.readOffset*) ) -> IndexReg
   
-- backendgLeaText:doPart--
do (if intel_trace then 'backendgLeaText'->comment if);
   I.writeReg -> leal -> emit2bytes;
   ea_d32 -> mstate.b.patchLastByte;
   (I.label[],wordMark)->mstate.b.mark;
   0 -> emitlong;
   eoo;
   
-- backendgLeaLabel:doPart--
do (if intel_trace then 'backendgLeaLabel'->comment if);
   I.writeReg -> leal -> emit2bytes;
   (I.labno, I.type, I.condition, 0, 0, ea_d32)
     -> LocalLabPutWithReloc;
   eoo;
   
-- backendldCst:dopart --
do (if intel_trace then 
       'backendLdCst'->comment;
       ('imm',I.imm) -> putval;
       ('readreg',I.readreg) -> putreg;
       ('writereg',I.writereg) -> putreg;
       newline;
   if);
   (I.imm, I.writeReg) -> emitMovlImmReg;
   eoo;

-- backendstCst:dopart --
do (if intel_trace then 'backendstCst' -> comment if);
   (if I.size
    // 1 then
       movb_i8m -> emit2bytes;
       (i.readReg,i.readOffset)->IndirectReg;
       i.imm -> B_emitbyte;
    // 2 then
       op_size_prefix -> B_emitbyte;
       movl_im -> emit2bytes;
       (i.readReg,i.readOffset)->IndirectReg;
       i.imm -> emithalf;
    // 4 then
       movl_im -> emit2bytes;
       (i.readReg,i.readOffset)->IndirectReg;
       i.imm -> emitlong;
   if);
   eoo;
   
---backendstCstInx:dopart---
do (if intel_trace then 'backendstCst' -> comment if);
   (if I.size
    // 1 then
       movb_i8m -> emit2bytes;
       (i.readReg,i.inxReg,I.scale,i.readOffset)->IndexReg;
       i.imm -> B_emitbyte;
    // 2 then
       op_size_prefix -> B_emitbyte;
       movl_im -> emit2bytes;
       (i.readReg,i.inxReg,I.scale,i.readOffset)->IndexReg;
       i.imm -> emithalf;
    // 4 then
       movl_im -> emit2bytes;
       (i.readReg,i.inxReg,I.scale,i.readOffset)->IndexReg;
       i.imm -> emitlong;
   if);
   eoo;
 
   
-- backendldVal:dopart --
do (if intel_trace then 'backendldVl' -> comment if);
   I[]->emitMovAddressToReg;
   eoo;
   
-- backendldVlInx:dopart --
do (if intel_trace then 'backendldVlInx' -> comment if);
   I[]->emitMovAddressInxToReg;
   eoo;
   
-- backendstVal:dopart --
do (if intel_trace then 
       'backendStVal' -> comment;
       ('size',I.size)->putreg;
       ('readReg2',I.readReg2)->putreg;
       ('readReg',I.readReg)->putreg;
       ('readOffset',I.readOffset)->putreg;
       newline;
   if);
   (I.readReg2, I.readReg, I.readOffset, I.size ) -> emitMovRegMemIndirect;
   eoo;
   
-- backendstValInx:dopart --
do (if intel_trace then 
       'backendStValInx' -> comment;
       ('size',I.size)->putreg;
       ('readReg2',I.readReg2)->putreg;
       ('readReg',I.readReg)->putreg;
       ('inxReg',I.inxReg)->putreg;
       ('readOffset',I.readOffset)->putreg;
       newline;
   if);
   (if I.size = 2 then op_size_prefix -> emitbyte if);
   (if I.size = 1 then
       I.readReg2 -> movb_rm -> emit2bytes;
    else
       I.readReg2 -> movl_rm -> emit2bytes;
   if);
   (I.readReg, I.inxReg, I.scale, I.readOffSet) -> IndexReg;
   eoo;
   
-- backendcpReg:dopart --
do (if intel_trace then 'backendcpReg' -> comment if);
   (I.readReg,I.writeReg)->movl_rr->emit2bytes;
   eoo
   
-- backendstValInText:dopart --
do (if intel_trace then 'backendstValInText' -> comment if);
   (i.readReg, i.label[]) -> emitMovlRegText;
   eoo
   
-- backendldValFromText:dopart --
do (if intel_trace then 'backendldValFromText' -> comment;
       'text: ' -> puttext; i.label[] -> putline;
   if);
   (i.label[], i.writeReg) -> emitMovlTextReg;
   eoo
     
   
-- backenddoAsgRefAdr:dopart --
do (if intel_trace then 'backenddoAsgRefAdr' -> comment if);
   'backenddoAsgRefAdr' -> TODO;
   eoo

-- backenddoAsgRefReg:dopart --
do (if intel_trace then 'backenddoAsgRefReg' -> comment if);
   'backenddoAsgRefReg' -> TODO;
   eoo

-- backendChkHeap:dopart --
do (if intel_trace then 'backendChkHeap' -> comment if);
   (# ioaOp: @
        (# putop: @ (* fills 4 bytes *)
             (# offset: @integer;
             enter offset
             do (if intel_trace then 'ioaOpPutOp' -> comment if);
                ea_d32 -> mstate.b.patchLastByte;
                ('IOA'->mstate.Cidentifier,wordMark)->mstate.b.mark;
                offset -> emitlong;
             #)
        #);
      regF: @integer; 
   do I.readReg2 -> regF;
      
      (* do the assignment *)
      4 -> I.size;
      (I.readReg, regF, I.readOffset, I.size) -> emitMovRegMemIndirect;
      (if not i.withQua then
          (if call_chkra_unconditionally then
              (if regF
               // EBP then 'ChkRA_EBP'->emitJsrT;
               // ESI then 'ChkRA_ESI'->emitJsrT;
               else
                  'ChkHeap: unknown dst register: ' -> puttext;
                  regF -> putint; 
                  newline;
              if);
           else
              (* Only call ChkRA if theCell is outside IOA *)
              regF -> cmpl_rm -> emit2bytes;           (* cmpl reg, IOA *)
              0 -> ioaOp.PutOp;
              cond_b -> jccc_short -> B_emitbyte;      (* jb Lfail *)
              mstate.b.LIP+2+4+2+1 -> emitrel8off;     (* 2 bytes *)
              regF -> cmpl_rm -> emit2bytes;           (* 2 bytes *) (* cmpl reg,IOA+4 *)
              4 -> ioaOp.PutOp;                        (* 4 bytes *)
              cond_b -> jccc_short -> B_emitbyte;      (* jb Lok *)
              (if common.switch[87] then
                  mstate.b.LIP+1+5+5+1->emitrel8off;   (* 2 bytes *)
               else
                  mstate.b.LIP+1+5+1 -> emitrel8off;   (* 2 bytes *)
              if);
              
              (* Lfail: *)
              regF -> _pushl_r -> B_emitbyte;          (* 1 byte *)
              (* Do NOT use doPush - ChkRA does the pop *)
              (if intel_trace then 
                  'ChkHeap# Not changing framesize' -> putline;
              if);
              (if common.switch[87] then
                  saveProfStackTop;                    (* -s 87: 5 bytes *)
              if);
              'ChkRA'->emitJsrT;                       (* 5 bytes *)
              
              (* Lok.def *)
              (xor_ttt, regF, regF) -> alul_rr -> emit2bytes; 
          if)
      if);
      eoo;
   #)
   
-- backendgAddImm:dopart --
do (if intel_trace then 'backendgAddImm' -> comment if);
   (add_ttt, I.imm, I.writeReg, I.size) -> emitALUinstImm;
   eoo;

-- backendgAddReg:dopart --
do (if intel_trace then 'backendgAddReg' -> comment if);
   (add_ttt, I.readReg, I.writeReg, I.size) -> emitALUinstReg;
   eoo;

-- backendaddMem:dopart --
do (if intel_trace then 'backendaddMem' -> comment if);
   'backendaddMem' -> TODO;

-- backendgNeg:dopart --
do (if intel_trace then 'backendgNeg' -> comment if);
   (if I.readReg<>I.writereg then
       'backendgNeg: different src/dst NYI!' -> TODO;
   if);
   (neg_ttt, I.readreg, I.size) -> emitINVreg;
   eoo;
   
-- backendgSubImm:dopart --
do (if intel_trace then 'backendgSubImm' -> comment if);
   (sub_ttt, I.imm, I.writeReg, I.size) -> emitALUinstImm;
   eoo;

-- backendgSubReg:dopart --
do (if intel_trace then 'backendgSubReg' -> comment if);
   (sub_ttt, I.readReg, I.writeReg, I.size) -> emitALUinstReg;
   eoo;

-- backendgMultImm:dopart --
do (if intel_trace then 'backendgMultImm' -> comment if);
   (I.writeReg, I.readReg2) -> imul_rir -> emit2bytes;
   I.imm -> emitlong;
   eoo;
   
--backendgMultReg:dopart --
do (if intel_trace then 'backendgMultReg' -> comment if);
   (I.writeReg, I.readReg) -> imul_rr -> emit3bytes;
   eoo;
   
--backendgDIVImm:dopart --
do (if intel_trace then 'backendgDIVImm' -> comment if);
   'backendgDIVImm' -> TODO;

--backendgDIVReg:dopart --
do (# numProtect, divReg: @integer;
      esi_pushed, eax_pushed, edx_pushed: @boolean;
   do (if intel_trace then 
          'backendgDIVReg' -> comment;
          ('ReadReg', I.readreg) -> putreg;
          ('ReadReg2', I.readreg2) -> putreg;
          ('WriteReg', I.writereg) -> putreg;
          newline;
      if);
      (* [INTEL] p. 26-157:
       *    IDIV EAX,r/m32
       *    Signed divide EDX:EAX (where EDX must contain sign-extension
       *    of AEX) by r/m dword (Results: EAX=Qua, EDX=Rem)
       * 
       * I.ReadReg:  Numerator  -> EDX:EAX
       * I.ReadReg2: Divisor
       * I.writeReg: Quotient/remainder
       *)
      
      0 -> numProtect;
      false -> eax_pushed -> esi_pushed -> edx_pushed;
      
      (if I.writeReg<>EDX then
          (* Save EDX = this unless it's the destination reg *)
          EDX -> pushRegister;
          true -> edx_pushed;
      if);
      (if (I.ReadReg2=EAX) or (I.ReadReg2=EDX) then
          (* divisor in numerator reg: use ESI instead *)
          ESI -> pushRegister;
          true -> esi_pushed;
          (* ESI is ref reg - no need for protect tag *)
          (I.readReg2,ESI)->movl_rr->emit2bytes;
          ESI -> divReg;
       else
          I.ReadReg2 -> divReg;
      if);
      
      (if I.ReadReg<>EAX then
          (if I.WriteReg<>EAX then
              EAX -> pushRegister;
              true -> eax_pushed;
              numProtect+1 -> numProtect;
          if);
          (I.readReg,EAX)->movl_rr->emit2bytes;
      if);
      numProtect -> pushProtectTag;
      
      cdq -> B_emitbyte; (* sign extend %eax to %edx *)
      divReg -> idivl_r -> emit2bytes; 
      
      (* Now: EAX=quotient, EDX=remainder *)
      (if I.isDiv then
          (if EAX<>I.WriteReg then
              (EAX,I.WriteReg)->movl_rr->emit2bytes;
          if);
       else
          (if EDX<>I.WriteReg then
              (EDX,I.WriteReg)->movl_rr->emit2bytes;
          if);
      if);
      
      (* Restore saved regs *)
      (if numProtect>0 then
          EDX -> popRegister (* Remove tag using EDX *)
      if);
      (if eax_pushed then
          EAX -> popRegister (* Restore EAX *)
      if);
      (if esi_pushed then
          ESI -> popRegister 
      if);
      (if edx_pushed then
          (* Restore EDX = this *)
          EDX -> popRegister 
      if);
   #);
   eoo;
   
--backendgOrImm:dopart --
do (if intel_trace then 'backendgOrImm' -> comment if);
   (if I.imm<>0 then
       (or_ttt, I.imm, I.readReg2, I.size) -> emitALUinstImm;
   if);
   eoo;

--backendgOrReg:dopart --
do (if intel_trace then 'backendgOrReg' -> comment if);
   (or_ttt, I.readReg, I.readReg2, I.size) -> emitALUinstReg;
   eoo;
  
--backendgAndImm:dopart --
do (if intel_trace then 'backendgAndImm' -> comment if);
   (if I.imm<>0xffffffff then
       (and_ttt, I.imm, I.readReg2, I.size) -> emitALUinstImm;
   if);
   eoo;

--backendgAndReg:dopart --
do (if intel_trace then 'backendgAndReg' -> comment if);
   (and_ttt, I.readReg, I.readReg2, I.size) -> emitALUinstReg;
   eoo;
   
--backendgAndNReg:dopart --
do (if intel_trace then 'backendgAndNReg' -> comment if);
   (not_ttt, I.readreg2, I.size) -> emitINVreg;
   (and_ttt, I.readReg2, I.readReg, I.size) -> emitALUinstReg;
   eoo;
   
--backendgxOrImm:dopart --
do (if intel_trace then 'backendgxOrImm' -> comment if);
   (xor_ttt, I.imm, I.readReg2, I.size) -> emitALUinstImm;
   eoo;

--backendgxOrReg:dopart --
do (if intel_trace then 'backendgxOrReg' -> comment if);
   (if I.readReg2<>I.writereg then
       'backendgXOrReg: different src/dst NYI!' -> TODO;
   if);
   (xor_ttt, I.readReg, I.readReg2, I.size) -> emitALUinstReg;
   eoo;

--backendgNot:dopart --
do (if intel_trace then 'backendgNot' -> comment if);
   (if I.readReg<>I.writereg then
       'backendgNot: different src/dst NYI!' -> TODO;
   if);
   (add_ttt, 1, I.readreg, I.size) -> emitALUinstImm;
   (and_ttt, 1, I.readreg, I.size) -> emitALUinstImm;
   eoo;

--backendlogNot:dopart --
do (if intel_trace then 'backendlogNot' -> comment if);
   (not_ttt, I.readreg, I.size) -> emitINVreg;
   eoo;

--backendgCmpImm:dopart --
do (if intel_trace then 'backendgCmpImm' -> comment if);
   (I.imm,I.readReg2,I.size)->emitCmpImmReg;
   eoo;
   
--backendgCmpReg:dopart --
do (if intel_trace then 'backendgCmpReg' -> comment if);
   'backendgCmpReg' -> TODO;
   eoo;

--backendSignExtByte:dopart --
do (if intel_trace then 'backendSignExtByte' -> comment if);
   (i.readReg, i.writeReg) -> movsxbl_rrr -> emit3bytes;   
   eoo;

--backendSignExtWord:dopart --
do (if intel_trace then 'backendSignExtWord' -> comment if);
   (i.readReg, i.writeReg) -> movsxwl_rrr -> emit3bytes;
   eoo;

--backendGetBits:dopart --
   (* pos = i.imm; length = i.size, signed flag. *)
do (if intel_trace then 'backendGetBits' -> comment if);
   'backendGetBits' -> TODO;
   eoo;
   
--backendgGetBits:dopart --
do (if intel_trace then 'backendgGetBits' -> comment if);
   'backendgGetBits' -> TODO;
   eoo;
   
--backendputBits:dopart --
do (if intel_trace then 'backendputBits' -> comment if);
   'backendputBits' -> TODO;
   eoo;
   
--backendgPutBits:dopart --
do (if intel_trace then 'backendgPutBits' -> comment if);
   'backendgPutBits' -> TODO;
   eoo;

--backendByteSwap:dopart --
do (if intel_trace then 'backendByteSwap' -> comment if);
   (if I.size=4 then
       (* assuming at least x486: bswap available *)
       I.writeReg -> bswap -> emit2bytes;
    else
       (* If word in EAX do "xchgb %ah,%al" *)
       (I.writeReg %Bor 2x100, I.writeReg) -> xchgb_rr -> emit2bytes;
   if);
   eoo;

--backendgGetDataByte:dopart --
do (if intel_trace then 'backendgGetDataByte' -> comment if);
   (if I.imm (* byteNo *)
    // 3 then (* rotate left 8 bits *)
       (rol_ttt, I.readReg) -> shiftl_ri8 -> emit2bytes;
       8 -> B_emitbyte;
    // 2 then 
       (* swap register halves. *)
       (rol_ttt, I.readReg) -> shiftl_ri8 -> emit2bytes;
       16 -> B_emitbyte;
    // 1 then (* rotate right 8 bits *)
       (ror_ttt, I.readReg) -> shiftl_ri8 -> emit2bytes;
       8 -> B_emitbyte;
   if);
   (and_ttt, 0xff, I.readReg, 4) -> emitAluImmReg;
   eoo;
   
--backendgGetDataWord:dopart --
do (if intel_trace then 'backendgGetDataWord' -> comment if);
   (if I.imm(*wordNo*)=2 then
       (* for some reason wordNo=2*i for i in getShort[i] *)
       (ror_ttt, I.readReg) -> shiftl_ri8 -> emit2bytes;
       16 -> B_emitbyte;
   if);
   (and_ttt, 0xffff, I.readReg, 4) -> emitAluImmReg;
   eoo;
   
--backendarithShiftLeftImm:dopart --
do (if intel_trace then 'backendarithShiftLeftImm' -> comment if);
   (if I.imm<>0 then
       (sal_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;
   
--backendarithShiftLeftReg:dopart --
do (if intel_trace then 'backendarithShiftLeftReg' -> comment if);
   (sal_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;
     
--backendlogicalShiftLeftImm:dopart --
do (if intel_trace then 'backendlogicalShiftLeftImm' -> comment if);
   (if I.imm<>0 then
       (shl_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;

--backendlogicalShiftLeftReg:dopart --
do (if intel_trace then 'backendlogicalShiftLeftReg' -> comment if);
   (shl_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;

--backendarithShiftRightImm:dopart --
do (if intel_trace then 'backendarithShiftRightImm' -> comment if);
   (if I.imm<>0 then
       (sar_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;

--backendarithShiftRightReg:dopart --
do (if intel_trace then 'backendarithShiftRightReg' -> comment if);
   (sar_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;

--backendlogicalShiftRightImm:dopart --
do (if intel_trace then 'backendlogicalShiftRightImm' -> comment if);
   (if I.imm<>0 then
       (shr_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;

--backendlogicalShiftRightReg:dopart --
do (if intel_trace then 'backendlogicalShiftRightReg' -> comment if);
   (shr_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;

--backendrotateLeftImm:dopart --
do (if intel_trace then 'backendrotateLeftImm' -> comment if);
   (if I.imm<>0 then
       (rol_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;
   
--backendrotateLeftReg:dopart --
do (if intel_trace then 'backendrotateLeftReg' -> comment if);
   (rol_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;
   
--backendrotateRightImm:dopart --
do (if intel_trace then 'backendrotateRightImm' -> comment if);
   (if I.imm<>0 then
       (ror_ttt, I.readReg, I.imm) -> emitSHIFTimm;
   if);
   eoo;
   
--backendrotateRightReg:dopart --
do (if intel_trace then 'backendrotateRightReg' -> comment if);
   (ror_ttt, I.readReg, I.readReg2) -> emitSHIFTreg;
   eoo;
  
--backendBeginLabel:dopart --
do (if intel_trace then 'backendBeginLabel' -> comment if);
   (ESP, I.readReg) -> movl_rr -> emit2bytes;
   (sub_ttt, 'lastCompBlock', EAX, 4)->emitAluInstText;
   (I.readReg, EDX, I.imm, 4) -> emitMovRegMemIndirect;
   eoo;

--backendFreeLabel:dopart --
do (if intel_trace then 'backendFreeLabel' -> comment if);
   'backendFreeLabel' -> TODO;
   eoo;

--backendEndLabel:dopart --
do (if intel_trace then 'backendEndLabel' -> comment if);
   (* unused *)
   
---backendFinal2VirtJump:doPart---
do (if intel_trace then 'backendFinal2VirtJump' -> comment if);
   (* The following pop is needed since getVirtualOriginStart calls
    * both getVirtualoriginStart1 (which pushes an extra register on intel)
    * but also getVirtualoriginStart2 *after* Final2VirtJump.
    * The code generated by getVirtualoriginStart2 is never executed in 
    * this case.
    * But since framesize calculations are still maintained by this backend,
    * we ignore the framesize decrement by this pop, and thus get no error 
    * when the return statement in the getVirtualoriginStart2 code is 
    * generated. The frame size will be wrong in the getVirtualoriginStart2
    * part of the code, but as said, this code is never executed.
    * The code should be removed, of course.
    *)
   (* I.readReg -> popRegister; No - decrements framesize, see above *)
   I.readreg -> _popl_r -> B_emitbyte;
   eoo;
   

--backendsaveInnerReturn:dopart --
do (if intel_trace then 'backendsaveInnerReturn' -> comment if);
   (* empty *)
   eoo;
   
---backendExternalMark:doPart---
do (if intel_trace then 'backendExternalMark' -> comment if);
   'backendExternalMark' -> TODO;
   eoo;
    
---backendinitXpar:doPart---
do (if intel_trace then 'backendinitXpar' -> comment if);
   (# extKind: (# exit i.imm #);
      BC (*parSize*): (# exit i.size #);
      LC (*exitSize*): (# exit i.length #);
      SC: (# exit 0 #);

   do (if extKind->Xpar.extKind
       // 5 (*sematt.cCallBackExt*)
       // 8 (*sematt.stdCallBackExt*) then
          48 -> Xpar.top; 
          4  -> Xpar.longSize -> Xpar.wordSize
          (* note cTop=pascTop+4 => cTop=48, pascTop=?? *)
       else 
          (* pascCallBackExt *)
          44 + (BC+SC+LC)*4 ->Xpar.TOP;
          -4 -> Xpar.longSize->Xpar.wordSize;
      if);
   #);
   eoo;
   
---backendPreGetXpar:doPart---
do (if intel_trace then 'backendPreGetXpar' -> comment if);
   (* Not used *)
   eoo;
   
---backendNoOfPreGetXpar:doPart---
do (if intel_trace then 'backendNoOfPreGetXpar' -> comment if);
   0->value;
   eoo;
   
--- backendgetXlong:doPart---
do (if intel_trace then 'backendgetXlong' -> comment if);
   Xpar.top->Xpar.SPoff -> I.readOffset; 
   ESP -> I.readReg;
   Xpar.longSize -> I.size;
   I[]->emitMovAddressToReg;
   Xpar.top+Xpar.longSize->Xpar.top;
   eoo;

---backendgetXword:doPart---
do (if intel_trace then 'backendgetXword' -> comment if);
   Xpar.top->Xpar.SPoff -> I.readOffset; 
   ESP -> I.readReg;
   Xpar.wordSize -> I.size;
   I[]->emitMovAddressToReg; 
   Xpar.top+Xpar.wordSize->Xpar.top;
   eoo;

---backendgetXbyte:doPart---
do (if intel_trace then 'backendgetXbyte' -> comment if);
   (* byte and word are always word *)
   Xpar.top->Xpar.SPoff -> I.readOffset;
   ESP -> I.readReg;
   Xpar.wordSize -> I.size;
   I[]->emitMovAddressToReg;
   Xpar.top+Xpar.wordSize->Xpar.top;
   eoo;

---backendtoXres:doPart---
do (if intel_trace then 'backendtoXres' -> comment if);
   (* Not needed *)
   
---backendXpar:descriptor---
(# extKind, top, longSize, wordSize: @integer;
   SPoff: @integer;
#)  

---backendGetRegForXres:doPart---
do (if intel_trace then 'backendGetRegForXres' -> comment; if);
   (* The following is matched by code in getExternalResult (backmstate.bet) *)
   (* pushDataRegImpl; (datpete: 28/11/2001) - Now done in INTERMEDIATEmachine *)
   saveRegImpl; (* Pushes edi and edx *)
   ebp -> PushRegister;
   esi -> PushRegister;
   eoo;

--backendreturnInner:dopart --
do (if intel_trace then 'backendreturnInner' -> comment if);
   rtsImpl;
   eoo;
   
---backendExternalEntry:doPart---
do (if intel_trace then 'backendExternalEntry' -> comment if);
   I.label[]->labelDef;
   eoo;
        
---backendExternalReturn:doPart---
do (if intel_trace then 'backendExternalReturn' -> comment if);
   rtsImpl;
   eoo;

--backendEmitTextConst:dopart --
do (if intel_trace then 'backendEmitTextConst' -> comment if);
   'backendEmitTextConst' -> TODO;
   eoo;

--backendgClr:dopart --
do (if intel_trace then 'backendgClr'->comment;  if);
   (xor_ttt, I.writeReg, I.writeReg) -> alul_rr -> emit2bytes;
   (*
    * The above xor form is preferred to "mov 0,reg", since it
    * fills only two bytes. The xor form sets the condition codes, 
    * but this should be OK.
    *) 
   eoo;

--backendpushAdr:dopart --
do (if intel_trace then 'backendpushAdr' -> comment if);
   'backendpushAdr' -> TODO; (* should never be called! *)
   eoo;

--backendPush:dopart --
do (if intel_trace then 'backendPush' ->comment if);
   I.readReg -> pushRegister;
   eoo;

--backendPop:dopart --
do (if intel_trace then 'backendPop' ->comment if);
   I.writeReg -> popRegister;
   eoo;
   
--backendPushThisOrCall:dopart --
do (if intel_trace then 'backendPushThisOrCall' -> comment if);
   (if I.bool  (* pushTh *) then EDX -> pushRegister if);
   (if I.bool2 (* pushCa *) then EDI -> pushRegister if);
   eoo;

--backendpopThisOrCall:dopart --
do (if intel_trace then 'backendpopThisOrCall' -> comment if);
   (if I.bool  (* pushTh *) then EDX -> popRegister if);
   (if I.bool2 (* pushCa *) then EDI -> popRegister if);
   eoo;

--backendsetTop:dopart --
do (if intel_trace then 'backendsetTop' -> comment if);
   (* i.imm = off *)
   (if true
    // (i.imm<0) then
       (* Negative (push)- could be an add, but easier to read if using sub *)
       (sub_ttt, -i.imm, esp, 4) -> emitAluImmReg;
    else
       (* Positive or 0 (pop): add. If zero, could possibly be optimized
        * out. But might be a zero with relocation?!
        *)
       (add_ttt, i.imm, esp, 4) -> emitAluImmReg;
   if);
   mstate.framesize - i.imm -> mstate.framesize;
   (if intel_trace then
       '==setTop#'->puttext;
       mstate.framesize -> putint; newline;
   if);
   eoo;

--backendChkCase:dopart --
do (if intel_trace then 'backendChkCase' -> comment if);
   (* inx = caseIndex-min (dataregoperand)
    * if inx >unsigned  (max-min) the  goto elseLab
    * This ALSO works if caseIndex < min.
    *)
   (# min, max: @integer;
   do i.size       -> max;
      i.readOffset -> min;
      (if ((max-min)->mstate.is8bit) and (max<min) then
          I.readReg -> cmpl_sir -> emit2bytes;
          (max-min) %band 0xff -> B_emitbyte;
       else
          (max-min, I.readReg, 4) -> emitCmpImmReg;
      if);
      ja -> emit2bytes;
      (I.labno,false) -> mstate.labs.use -> emitrel32off;
   #);
   eoo;

--backendChkIndex:dopart --
do (if intel_trace then 
       'backendChkIndex' -> comment;
       ('readReg', I.readReg) -> putreg;
       ('inxReg', I.inxReg) -> putreg;
       ('size', I.size) -> putval;
       ('isSimple', I.condition) -> putbool;
       newline;
   if);
   (if I.indexCheck then
       (if not I.condition (*isSimple*) then
           (* General rep currently implemented as refreps *)
           (if I.size<>4 then
               'backendChkIndex: general rep missing' -> TODO;
           if);
       if);
       i.inxReg -> boundl_rm -> emit2bytes;
       (* bound-check from theRep.low, i.e. theRep+8 *)
       (i.readReg,8)->IndirectReg;
   if);
   eoo;

--backendcmpToBool:dopart --
do (if intel_trace then 'backendcmpToBool' -> comment if);
   
   I.size -> check_size -> I.size;
   
   (i.readReg,i.readReg2,I.size)->emitCmpRegReg;
   
   (* FIXME: OPTIMIZE:
    * in most cases  (a<b>)->X, X is a boolean. It is therefore NOT
    * necessary to clear op before executing set. However, X may be
    * an integer in which case op MUST be cleared. The type of X is
    * NOT know here, therefore op is always cleared.
    * If the compiler introduces typechecking, X will always be a boolean
    * and clear may be avoided. 
    * This is not yet the case, since only a warning is given, by the 
    * compiler on assigning boolean to integer.
    * For now a boolean-parameter to cmpToBool indicating if destination 
    * is boolean or integer would suffice.
    * 
    * datpete: 22/03/2001:
    * NO! It does not work to skip the clear, even though
    * the compiler now tests for assignment between bool/int.
    * There are problems in other situations too, e.g. (if ...//true
    * Lots of errors in tst, if the clear is removed.
    *)
   
   I.writeReg -> _movl_ir -> B_emitbyte;
   0 -> emitlong;
   (* NB do NOT use gClr, if that is implemented by
    * "xor reg, reg", since this will change the
    * condition flags.
    *)
   (if I.cond (* setCCC I.writeReg *)
    // common.cond_eq then 
       (cond_e,  I.writeReg) -> setccc_r -> emit3bytes;
    // common.cond_ne then 
       (cond_ne, I.writeReg) -> setccc_r -> emit3bytes;
    // common.cond_lt then  
       (if I.size=4 then 
           (cond_l,I.writeReg)->setccc_r->emit3bytes;
        else
           (* unsigned comp. *)
           (cond_b,I.writeReg)->setccc_r->emit3bytes; 
       if)
    // common.cond_le then
       (if I.size=4 then 
           (cond_le,I.writeReg)->setccc_r->emit3bytes;
        else
           (* unsigned comp. *)
           (cond_be,I.writeReg)->setccc_r->emit3bytes;
       if)
    // common.cond_gt then
       (if I.size=4 then 
           (cond_g,I.writeReg)->setccc_r->emit3bytes;
        else
           (* unsigned comp. *)
           (cond_a,I.writeReg)->setccc_r->emit3bytes; 
       if)
    // common.cond_ge then
       (if I.size=4 then 
           (cond_ge,I.writeReg)->setccc_r->emit3bytes;
        else
           (* unsigned comp. *)
           (cond_ae,I.writeReg)->setccc_r->emit3bytes;
       if)
   if);
   eoo;

--backendLoadFloat:doPart---
do (if intel_trace then 'backendLoadFloat' -> comment if);
   fldl -> emit2bytes;
   (i.readReg, i.readOffset) -> IndirectReg; 
   eoo;
   
--backendLoadFloatInx:doPart---
do (if intel_trace then 'backendLoadFloatInx' -> comment if);
   fldl -> emit2bytes;
   (I.readReg, I.inxReg, 8, I.readOffSet) -> IndexReg;
   eoo;
  
--backendStoreFloat:doPart---
do (if intel_trace then 'backendStoreFloat' -> comment if);
   fstpl -> emit2bytes;
   (i.readReg, i.readOffset) -> IndirectReg; 
   eoo;
   
--backendStoreFloatInx:doPart---
do (if intel_trace then 'backendStoreFloatInx' -> comment if);
   fstpl -> emit2bytes;
   (I.readReg, I.inxReg, 8, I.readOffSet) -> IndexReg;
   eoo;

---backendStoreFloat2int:dopart---
do (if intel_trace then 'backendStoreFloat2int' -> comment if);
   FloatSetChopping
   (# 
   do fistpl -> emit2bytes; 
      (i.readReg, i.readOffset) -> IndirectReg; 
   #);
   eoo;

---backendLoadInt2FloatInx:dopart---
do (if intel_trace then 'backendLoadInt2FloatInx' -> comment if);
   fildl -> emit2bytes;
   (i.readReg, i.inxReg, 8, i.readOffset) -> IndexReg; 
   eoo;
   
---backendStoreFloat2intInx:dopart---
do (if intel_trace then 'backendStoreFloat2intInx' -> comment if);
   fstpl -> emit2bytes;
   (I.readReg, I.inxReg, 8, I.readOffSet) -> IndexReg;
   eoo;
   
---backendLoadInt2Float:dopart---
do (if intel_trace then 'backendLoadInt2Float' -> comment if);
   fildl -> emit2bytes;
   (i.readReg, i.readOffset) -> IndirectReg; 
   eoo;
   
--backendfloatConst:dopart --
do (if intel_trace then 'backendfloatConst' -> comment if);
   (if I.floatval
    // -1.0 then
       fld1 -> emit2bytes;
       fchs -> emit2bytes;
    //  1.0 then
       fld1 -> emit2bytes;
    //  0.0 then (* FIXME: should be merged with next entry, 
                  * but beta5.1.1 fails to generate correct code
                  * for this
                  *)
       fldz -> emit2bytes;
    // -0.0 then
       fldz -> emit2bytes;
    else
       (# labno: @integer;
       do 8->mstate.d.align;
          (mstate.defDataLab 
          (#
          do @@I.floatval->TOS'%AdrGetLong'->mstate.d.emitlong;
             @@I.floatval+4->TOS'%AdrGetLong'->mstate.d.emitlong;
          #)).labno-> labno;
          fldl -> emit2bytes; 
          (labno, dataToCode, true, 0, 0, ea_d32) -> LocalLabPutWithReloc; 
       #);
   if);
   eoo;

--backendint2float:dopart --
do (if intel_trace then 'backendint2float' -> comment if);
   (* See comment in ppcbackend. LoadInt2Float has done the whole job *)

--backendintReg2float:dopart --
do (if intel_trace then 'backendintReg2float' -> comment if);
   (i.readReg, mstate.d.tmplab) -> stRegInLab;
   fildl -> emit2bytes;
   mstate.d.tmplab (* ensure it is allocated *);
   (mstate.d.tmplab.lab.labno, mstate.d.tmplab.lab.type, true, 0, 0, ea_d32)
     -> LocalLabPutWithReloc;
   eoo;

--backendfloat2int:dopart --
do (if intel_trace then 'backendfloat2int' -> comment if);
   FloatSetChopping
   (# 
   do fistpl -> emit2bytes; 
      mstate.d.tmplab (* ensure it is allocated *);
      (mstate.d.tmplab.lab.labno, mstate.d.tmplab.lab.type, true, 0, 0, ea_d32)
        -> LocalLabPutWithReloc;
      (mstate.d.tmplab, I.writeReg) -> ldRegFromLab;
   #);

--backendcmpFloat:dopart --
do (if intel_trace then 'backendcmpFloat' -> comment if);
   (* stack top operations. Generate fcomp(p) - i.e. pop arguments*)
   (if I.condition (* see INTERMEDIATEmachine.cmpFloat *) then
       (if intel_trace then 'backendcmpFloat:reverseCond' -> comment if);
       I[] -> reverseCond;
   if);
   (if I.PopFloatStack then
       (* Compare and pop two operands *)
       fcompp -> emit2bytes;
    else
       (* Compare and pop only one operand *)
       1 -> fcomp -> emit2bytes;
   if);
   eoo;
   
---backendgCmpFloatMem:dopart--
do (if I.PopFloatStack then
       (* Compare and pop two operands *)
       fcompl -> emit2bytes;
    else
       (* Compare and pop only one operand *)
       fcoml -> emit2bytes;
   if);
   (I.readReg, I.readOffset) -> IndirectReg;
   
---backendgCmpFloatMemInx:dopart---
do (if I.PopFloatStack then
       (* Compare and pop two operands *)
       fcompl -> emit2bytes;
    else
       (* Compare and pop only one operand *)
       fcoml -> emit2bytes;
   if);
   (I.readReg, I.InxReg, 8, I.ReadOffset) -> IndexReg;

--backendcmpToBoolFloat:dopart --
do (if intel_trace then 'backendcmpToBoolFloat' -> comment if);
   (# Lab: @backendLocalLab;
   do lab.new;
      Lab.LabNo -> I.Labno;
      (1, I.writeReg) -> emitMovlImmReg;
      (if I.condition (* see INTERMEDIATEmachine.cmpFloat *) then
          (if intel_trace then 'backendcmpToBoolFloat:reverseCond' -> comment if);
          I[] -> reverseCond;
      if);
      (if I.cond (* IF T1 cc R then goto L *)
       // common.cond_eq then I[]->fBeqImpl
       // common.cond_ne then I[]->fBneImpl
       // common.cond_lt then I[]->fBltImpl
       // common.cond_le then I[]->fBleImpl
       // common.cond_gt then I[]->fBgtImpl
       // common.cond_ge then I[]->fBgeImpl
      if);
      (xor_ttt, I.writeReg, I.writeReg) -> alul_rr -> emit2bytes;
      Lab.Def;
   #);

--backendpopFStack:dopart --
do (if intel_trace then 'backendpopFStack' -> comment if);
   (* during cmpAndJmpFloat the fval is kept on the fstack - it must
    * be popped when no more tests are to be performed - before 'else'
    * of if no 'else' after 'if'.
    *)
   (* ffree -> emit2bytes; fincstp -> emit2bytes; (4 bytes, 3+3=6 cycles *)
   0 -> fcomp -> emit2bytes; (* 2 bytes, 4 cycles *)
   eoo;

--backendaddFloat:dopart --
do (if intel_trace then
       'backendaddFloat' -> comment;
       ('readreg', i.readReg) -> putfreg;
       ('readreg2', i.readReg2) -> putfreg;
       ('writereg', i.writeReg) -> putfreg;
       newline;
   if);
   I[] -> mstate.doFloatBinOp
   (# memory::   (# do faddl -> emit2bytes; #);
      swapped::  (# do 1 -> faddp -> emit2bytes; #);
      register:: (# do 1 -> faddp -> emit2bytes; #);
   #);
   eoo;

--backendsubFloat:dopart --
do (if intel_trace then
       'backendsubFloat' -> comment;
       ('readreg', i.readReg) -> putfreg;
       ('readreg2', i.readReg2) -> putfreg;
       ('writereg', i.writeReg) -> putfreg;
       newline;
   if);
   I[] -> mstate.doFloatBinOp
   (# memory::   (# do fsubl -> emit2bytes; #);
      swapped::  (# do 1 -> fsubrp -> emit2bytes; #);
      register:: (# do 1 -> fsubp -> emit2bytes; #);
   #);
   eoo;

--backendmulFloat:dopart --
do (if intel_trace then
       'backendmulFloat' -> comment;
       ('readreg', i.readReg) -> putfreg;
       ('readreg2', i.readReg2) -> putfreg;
       ('writereg', i.writeReg) -> putfreg;
       newline;
   if);
   I[] -> mstate.doFloatBinOp
   (# memory::   (# do fmull -> emit2bytes; #);
      swapped::  (# do 1 -> fmulp -> emit2bytes; #);
      register:: (# do 1 -> fmulp -> emit2bytes; #);
   #);
   eoo;
   
--backenddivFloat:dopart --
do (if intel_trace then
       'backenddivFloat' -> comment;
       ('readreg', i.readReg) -> putfreg;
       ('readreg2', i.readReg2) -> putfreg;
       ('writereg', i.writeReg) -> putfreg;
       newline;
   if);
   I[] -> mstate.doFloatBinOp
   (# memory::   (# do fdivl -> emit2bytes; #);
      swapped::  (# do 1 -> fdivrp -> emit2bytes; #);
      register:: (# do 1 -> fdivp -> emit2bytes; #);
   #);
   eoo;

--backendnegFloat:dopart --
do (if intel_trace then
       'backendaddFloat' -> comment;
       ('readreg', i.readReg) -> putfreg;
       ('writereg', i.writeReg) -> putfreg;
       newline;
   if);
   (* Assuming always on float stack - compare INTELBmachine *)
   fchs -> emit2bytes;
   
--backendlock:dopart --
do (if intel_trace then 'backendlock' -> comment if);
   'backendlock' -> TODO;
   eoo;

--backendallRegInPrimReg2I:dopart --
do (if intel_trace then 'backendallRegInPrimReg2I' -> comment if);
   'backendallRegInPrimReg2I' -> TODO;
   eoo;

--backendGetOriginReg:dopart --
do (if intel_trace then 'backendGetOriginReg' -> comment if);
   'backendGetOriginReg' -> TODO;
   eoo;

--backendFreeOriginReg:dopart --
do (if intel_trace then 'backendFreeOriginReg' -> comment if);
   'backendFreeOriginReg' -> TODO;
   eoo;

--backendDataRegMax:dopart --
do (if intel_trace then 'backendDataRegMax' -> comment if);
   'backendDataRegMax' -> TODO;
   eoo;

--backendNoOfFreeDataReg:dopart --
do (if intel_trace then 'backendNoOfFreeDataReg' -> comment if);
   'backendNoOfFreeDataReg' -> TODO;
   eoo;

--backendDumpReg:dopart --
do(if intel_trace then ' backendDumpReg' -> comment if);
   'backendDumpReg' -> TODO;
   eoo;

--backendPushReg:dopart --
do (if intel_trace then 'backendPushReg' -> comment if);
   liveAdr[]->scanBitvektor32
   (# 
   do (if current<>EDI then (* CallReg/Ca/CallO *)
          (*'pushAdrreg, %d\n'->screen.putformat(# do current -> d #);*)
          current -> pushRegister;
      if)
   #);
   PushDataRegImpl;
   eoo;
   
--backendPopReg:dopart --
do (if intel_trace then 'backendPopReg' -> comment if);
   
   PopDataRegImpl;
   (# Areg: [8]@boolean;
      popTag: @boolean;
      (* scan live address regs forward *)
   do liveAdr[]->scanBitvektor32
      (# 
      do (if current<>EDI then
             (*'intel.popAdrreg, %d\n'->screen.putformat(# do current -> d #);*) 
             true -> Areg[current+1]
         if)
      #);
      (* Pop live address regs backward *)
      (for i:8 repeat
           (if aReg[8-i+1] then 
               8-i -> popRegister;
           if)
      for)
   #);
   eoo;

--backendPushDataReg:dopart --
do (if intel_trace then 'backendPushDataReg' -> comment if);
   (# dataCount: @integer;
   do liveData[]->scanBitvektor32
      (# 
      do (*'pushDatareg: %d\n'->screen.putformat(# do current -> d #);*)
         dataCount+1->dataCount;
         current -> pushRegister;
      #);
      
      mstate.reg.float.saveSpace;
      (* the actual save of floating point registers
       * is made just before the call - 
       * - either callCproc for external calls
       * or gjsr for BETA calls
       *)
      
      mstate.reg.float.fTop/4 + dataCount->pushProtectTag;
   #);
   eoo;

--backendPopDataReg:dopart --
do (if intel_trace then 'backendPopDataReg' -> comment if);
   (# Dreg:[8]@boolean;
      popTag: @boolean;
   do liveData[]->scanBitvektor32
      (# 
      do (*'popDatareg: %d\n'->screen.putformat(# do current -> d #);*)
         (if false and (current=EAX) and (I[]<>NONE) and (I.condition) then
             (* Ignore eax alive after external; 
              * see INTEERMEDIATEmachine.get***Xres
              *)
          else
             true -> Dreg[current+1];
             true -> popTag;
         if);
      #);
      
      (mstate.reg.float.fTop>0) or popTag -> popTag;
      pop:
        (if popTag then
            (* Pop into first data register restored below *)
            (for i:8 repeat
                 (if dReg[8-i+1] then
                     (if popTag then
                         (* pop data tag into first data register *)
                         (if intel_trace then
                             'popDataRegs: pop tag into reg' -> putline;
                         if);
                         8-i -> popRegister;
                         false->popTag;
                         leave pop;
                     if);
                 if)
            for);
            (if popTag then
                (* popTag still true: No data regs on stack.
                 * Pop tag caused by floating point regs.
                 * FIXME: make mstate.reg.float.nrestore offset by
                 * 4 and mstate.reg.float.freeSpace subtract 4 more.
                 *)
                (# I: ^backendInstruction;
                do &backendInstruction[] -> I[];
                   4->I.imm;
                   I[] -> SetTopImpl;
                #);
            if);
        if);
      
      (* Possible tag now removed. Restore floats *)
      mstate.reg.float.nrestore;
      mstate.reg.float.freeSpace;
      
      (* Restore data regs *)
      (for i:8 repeat
           (if dReg[8-i+1] then
               (if intel_trace then
                   'popDataRegs: pop reg ' -> puttext;
                   8-i -> putint; newline;
               if);
               8-i -> popRegister;
           if)
      for);
   #);
   eoo;

--backendPushFloatReg:dopart --
do (if intel_trace then 'backendPushFloatReg' -> comment if);
   'backendPushFloatReg' -> TODO;
   eoo;

--backendPopFloatReg:dopart --
do (if intel_trace then 'backendPopFloatReg' -> comment if);
   'backendPopFloatReg' -> TODO;
   eoo;

--backendtstNone:dopart --
   (* FIXME: Could possibly be eliminated if we are sure code after
    * none check loads from the address.
    *)
do (if intel_trace then 'backendtstNone' -> comment if);
   (*   cmpb 0[R],0
    *     - 4(3) bytes
    *     - Trap if protected memory or ref none.
    * Possibly cheaper:
    *   mov 0[R],scratch
    *     - 3 bytes
    *)
   I.writeReg->cmpb_rim->emit2bytes;
   (if I.writeReg = ebp then
       ea_ind_d8 -> mstate.B.patchLastByte;
       (0,0)->emit2bytes;
    else
       0 -> B_emitbyte;
   if);
   eoo;

--backendtrap:dopart --
do (if intel_trace then 'backendtrap' -> comment if);
   'backendtrap' -> TODO;
   eoo;

--backendreturn:dopart --
do (if intel_trace then 'backendreturn' -> comment if);
   (thisO,callO) -> movl_rr->emit2bytes; 
   (* The following pop should NOT decrement mstate.framesize, since there may
    * be multiple backendreturns, in case of "leave foo" inside "foo".
    * However, since backendReturn is always the last thing executed in the 
    * generated code, this should not destroy the offsets used in subsequent 
    * instructions in this entry point. 
    *)
   thisO -> _popl_r -> B_emitbyte;
   4 -> CheckFrameSize;
   rtsImpl;
   eoo;
   
--backendsaveReturn:dopart --
do (if intel_trace then 
       'backendsaveReturn' -> comment;
       (* '\tStackCells[data]=%d, StackCells[adr]=%d, StackCells[float]=%d, StackCells[prim]=%d\n'->
        * screen.putformat
        * (# do stackCells[1]->d; stackCells[2]->d; stackCells[3]->d; stackCells[4]->d #);
        *)
   if);
   
   (* As noted in backendReturn above, we cannot ensure that the push count of 
    * the previous entry point always ends with 0, since backenReturn does 
    * not decrement the counter. Thus we nullify the counter here on entry.
    *)
   0 -> mstate.framesize;
   (if intel_trace then
       '==saveReturn#'->puttext;
       mstate.framesize -> putint; newline;
   if);
   thisO -> pushRegister (* push thisO *);
   (callO,thisO) -> movl_rr->emit2bytes; (* callO -> thisO *)
   eoo

--backendrts:dopart --
do ret->B_emitbyte;
   eoo;

--backendSaveReg:dopart --
do (if intel_trace then 'backendsaveReg' -> comment if);
   EDX -> pushRegister;
   EDI -> pushRegister;
   (if intel_trace then 'backendsaveReg done' -> comment if);
   eoo;

--backendRestoreReg:dopart --
do (if intel_trace then 'backendRestoreReg' -> comment if);
   EDI -> popRegister;
   EDX -> popRegister;
   eoo;

--backendGetPrimRes:dopart --
do (if intel_trace then 'getprimres' -> comment if);
   (if i.imm (*res*)
    // 0 (* ignore result *) 
    // 2 then (* push to C *)
    // 1 
    // 3 then
       (* the result is returned in physical register EAX. *)
       (if i.writereg<>EAX then
           calculateLiveData;
           (if eax -> liveData.has then
               (# msg: ^text;
               do 
                  'getprimres: Use of *busy* EAX instead of i.writereg: ' -> msg[];
                  i.writereg -> msg.putint;
                  msg[] -> TODO;
               #);                  
           if);
           (EAX,i.writeReg) -> movl_rr -> emit2bytes;
       if)
    // 4 then
       (* text returned from BETA COM virtual *) 
       (if intel_trace then 'backendGetPrimRes: COM' -> comment if);
       'backendGetPrimRes: COM' -> TODO;
   if);
   eoo;

--backenddeclareLong: doPart--
do (if intel_trace then 'backenddeclareLong' -> comment if);
   N->mstate.d.emitlong;
   eoo;
   
--backenddeclareWord: doPart--
do (if intel_trace then 'backenddeclareWord' -> comment if);
   N->mstate.d.emitHalf;
   eoo;
   
--backenddclWord: doPart--
do (if intel_trace then 'backenddclWord' -> comment if);
   N->mstate.d.emitHalf;
   eoo;
   
--backendemitByte: doPart--
do (if intel_trace then 'backenddeclareByte' -> comment if);
   B->mstate.d.emitByte;
   eoo;

--backendDeclareAddress:dopart --
do (if intel_trace then 'backendDeclareAddress' -> comment if);
   (I.labno, I.type, false, 0, 0, 0) 
     -> localLabPutWithReloc;
   eoo;
   
--declareDataSegmentTextAddressImpl:dopart--
do (if intel_trace then 'declareDataSegmentTextAddressImpl' -> comment if);
   (i.label[],wordMark)->mstate.d.mark; 
   0 ->mstate.d.emitlong;
   eoo;
   
--declareDataSegmentLabelAddressImpl:dopart--
do (if intel_trace then 'declareDataSegmentLabelAddressImpl' -> comment if);
   (I.labno, I.type, not I.condition (*isData*), 0, 0, ea_d32) 
     -> localLabPutWithReloc;
   eoo;
   
--backendChkConstIndex:dopart --
do (if intel_trace then 'backendChkConstIndex' -> comment if);
   'backendChkConstIndex' -> TODO;
   eoo;

--backendjsrTable:dopart --
do (if intel_trace then 'backendjsrTable' -> comment if);
   I[]->JsrRegImpl;
   eoo;

--backendjmpTlong:dopart --
do (if intel_trace then 'backendjmpTlong' -> comment if);
   (* ASSUMPTION: Always called with an argument EXTERNAL to this fragment *)
   I.label[] -> mstate.b.emitJmpExtern;
   eoo;
   
--backendjmpT:dopart --
do (if intel_trace then 'backendjmpT' -> comment if);
   (* ASSUMPTION: Always called with an argument LOCAL to this fragment *)
   I.label[] -> mstate.b.emitJmpLocal;
   eoo;

--backendjsrT:dopart --
do (if intel_trace then 'jsrT: ' -> (I.label.copy).prepend -> comment if);
   I.label[] -> emitJsrT;
   eoo;

--backendjsrReg:dopart --
do (if intel_trace then 'backendJsrReg' -> comment if);
   I.readReg -> call_r -> emit2bytes;
   eoo;
   
--backendjmpReg:dopart --
do (if intel_trace then 'backendjmpReg' -> comment if);
   I.readReg -> jmp_r -> emit2bytes;
   eoo;

--backendgJsr:dopart --
do (if intel_trace then 'gJsr' -> comment if);
   (* we rely on that NO values have been pushed
    * on the stack since float.saveSpace in pushData
    *)
   4 -> mstate.reg.float.nsave;
   
   (if I.isLocal then
       I.label -> mstate.b.emitCallLocal;
    else
       I.label -> mstate.b.emitCallExtern;
   if);
   eoo;
   
--backendjsrTableTest:dopart --
do (if intel_trace then 'backendjsrTableTest' -> comment if);
   'backendjsrTableTest' -> TODO;
   eoo;
   
--backendJumpIfTrue:dopart--
do (if intel_trace then 'backendJumpIfTrue' -> comment if);
   (cond_ae, I.labno) -> emitCondJmp; 
   eoo
   
--backendgBeq:dopart--
do (if intel_trace then 'backendgBeq' -> comment if);
   (cond_e, I.labno) -> emitCondJmp;
   eoo
   
--backendgBge:dopart--
do (if intel_trace then 'backendgBge' -> comment if);
   (cond_ge, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBne:dopart--
do (if intel_trace then 'backendgBne' -> comment if);
   (cond_ne, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBae:dopart--
do (if intel_trace then 'backendgBae' -> comment if);
   (cond_ae, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBle:dopart--
do (if intel_trace then 'backendgBle' -> comment if);
   (cond_le, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBbe:dopart--
do (if intel_trace then 'backendgBbe' -> comment if);
   (cond_be, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBgt:dopart--
do (if intel_trace then 'backendgBgt' -> comment if);
   (cond_nle, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBab:dopart--
do (if intel_trace then 'backendgBab' -> comment if);
   (cond_a, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBlt:dopart--
do (if intel_trace then 'backendgBlt' -> comment if);
   (cond_l, I.labno) -> emitCondJmp; 
   eoo 
   
--backendgBbl:dopart--
do (if intel_trace then 'backendgBbl' -> comment if);
   (cond_b, I.labno) -> emitCondJmp; 
   eoo 

--backendcmpAndJmp:dopart --
do (if intel_trace then 
       'backendcmpAndJmp' -> comment;
   if);
   I.size -> check_size -> I.size;
   (I.readReg2,I.readReg,I.size)->emitCmpRegReg;
   (if i.cond (* IF T1 cc R then goto L *)
    // common.cond_eq then 
       I[]->gBeqImpl;
    // common.cond_ne then 
       I[]->gBneImpl
    // common.cond_lt then 
       (if I.size=4 then I[]->gBltImpl else I[]->gBblImpl if)
    // common.cond_le then 
       (if I.size=4 then I[]->gBleImpl else I[]->gBbeImpl if)
    // common.cond_gt then 
       (if I.size=4 then I[]->gBgtImpl else I[]->gBabImpl if)
    // common.cond_ge then 
       (if I.size=4 then I[]->gBgeImpl else I[]->gBaeImpl if)
   if);
   eoo;

--backendcmpAndJmpImm:dopart --
do (if intel_trace then 
       'backendcmpAndJmpImm' -> comment;
       ('imm',I.imm) -> putval;
       ('reg',I.readreg) -> putreg;
       ('size',I.size) -> putval;
   if);
   I.size -> check_size -> I.size;
   (I.imm,I.readReg,I.size)->emitCmpImmReg;
   (if i.cond (* IF T1 cc R then goto L *)
    // common.cond_eq then 
       I[]->gBeqImpl;
    // common.cond_ne then 
       I[]->gBneImpl
    // common.cond_lt then 
       (if I.size=4 then I[]->gBltImpl else I[]->gBblImpl if)
    // common.cond_le then 
       (if I.size=4 then I[]->gBleImpl else I[]->gBbeImpl if)
    // common.cond_gt then 
       (if I.size=4 then I[]->gBgtImpl else I[]->gBabImpl if)
    // common.cond_ge then 
       (if I.size=4 then I[]->gBgeImpl else I[]->gBaeImpl if)
   if);
   eoo;

--backendcmpBoolAndJmp:dopart --
do (if intel_trace then 'backendcmpBoolAndJmp' -> comment if);
   (0,I.readReg,I.size)->emitCmpImmReg;
   (if i.cond (* IF T1 cc R then goto L *)
    // common.cond_eq then 
       I[]->gBeqImpl;
    // common.cond_ne then 
       I[]->gBneImpl
    // common.cond_lt then 
       (if I.size=4 then I[]->gBltImpl else I[]->gBblImpl if)
    // common.cond_le then 
       (if I.size=4 then I[]->gBleImpl else I[]->gBbeImpl if)
    // common.cond_gt then 
       (if I.size=4 then I[]->gBgtImpl else I[]->gBabImpl if)
    // common.cond_ge then 
       (if I.size=4 then I[]->gBgeImpl else I[]->gBaeImpl if)
   if);
   eoo;

--backendcmpAndJmpFloat:dopart --
do (if intel_trace then 'backendcmpAndJmpFloat' -> comment if);
   (* stack top operation - compare top elements, 
    * BUT unless pop is true top-1 MUST be kept on the stack after compare,
    * since it may be used in subsequent compares
    *)
   (if I.condition (* see INTERMEDIATEmachine.cmpFloat *) then
       (if intel_trace then 'backendcmpAndJmpFloat:reverseCond' -> comment if);
       I[] -> reverseCond;
   if);
   (if I.cond (* IF T1 cc R then goto L *)
    // common.cond_eq then I[]->fBeqImpl
    // common.cond_ne then I[]->fBneImpl
    // common.cond_lt then I[]->fBltImpl
    // common.cond_le then I[]->fBleImpl
    // common.cond_gt then I[]->fBgtImpl
    // common.cond_ge then I[]->fBgeImpl
   if);
   (if not I.PopFloatStack then
       (* pop fstack: if no jump then if alternative is selected *)
       popFstackImpl;
   if);
   eoo;
   
--backendfBeq:dopart --
do (if intel_trace then 'backendfBeq' -> comment if);
   TstFloat(# do (cond_e, I.labno) -> emitCondJmp; eoo #);
   eoo;

--backendfBge:dopart --
do (if intel_trace then 'backendfBge' -> comment if);
   TstFloat(# do (cond_ae, I.labno) -> emitCondJmp; eoo #);
   eoo;
   
--backendfBle:dopart --
do (if intel_trace then 'backendfBle' -> comment if);
   TstFloat(# do (cond_be, I.labno) -> emitCondJmp; eoo #);
   eoo;

--backendfBne:dopart --
do (if intel_trace then 'backendfBne' -> comment if);
   TstFloat(# do (cond_nz, I.labno) -> emitCondJmp; eoo #);
   eoo;

--backendfBgt:dopart --
do (if intel_trace then 'backendfBgt' -> comment if);
   TstFloat(# do (cond_a, I.labno) -> emitCondJmp; eoo #);
   eoo;

--backendfBlt:dopart --
do (if intel_trace then 'backendfBlt' -> comment if);
   TstFloat(# do (cond_b, I.labno) -> emitCondJmp; eoo #);
   eoo;

--backendgJmp:dopart --
do (if intel_trace then 'backendgJmp' -> comment if);
   I.labno -> mstate.b.emitJumpLab
   (# 
   do (if isShort then
          jmp_short -> B_emitbyte;
       else
          jmp_direct -> B_emitbyte;
      if);
   #);
   eoo;

--backendCallPrim:dopart --
do (if common.switch[87] then
       (* profiling *)
       saveProfStackTop; 
   if);
   (if true
    // ('ExO'->I.label.equal)
    // ('ExOx'->I.label.equal) then
       (* FIXME: Temp. hack - see INTERMEDIATEmachine.break *)
       (I.imm, EAX) -> emitMovlImmReg;
    // ('CopyT'->I.label.equal)
    // ('MkTO'->I.label.equal) then
       (* CopyT and MkTO pops it's 3 arguments itself.
        * Thus the 3 pops before it should be ignored by the
        * pushpop counter.
        *)
       mstate.framesize - 3*4 -> mstate.framesize;
       (if intel_trace then
           '==CallPrim/MkTO/CopyT#'->puttext;
           mstate.framesize -> putint; newline;
       if);
    // ('CopyPPP'->I.label.equal)
    // ('CopySPP'->I.label.equal) then
       mstate.framesize - 1*4 -> mstate.framesize;
    // ('CpkVT'->I.label.equal)
    // ('CpkSVT'->I.label.equal)
    // ('CpkVT_W'->I.label.equal)
    // ('CpkSVT_W'->I.label.equal) then
       (* Each of these runtime routines push 1 argument onto the stack *)
       mstate.framesize + 1*4  -> mstate.framesize;
       (if intel_trace then
           '==CallPrim/Cpk#'->puttext;
           mstate.framesize -> putint; newline;
       if);
   if);
   i[]->jsrTimpl;
   (if intel_trace then
       '==callprim#'->puttext;
       mstate.framesize -> putint; newline;
   if);
   eoo;

--backendCallAlloPrim:dopart --
do (* we rely on that NO values have been pushed
    * on the stack since float.saveSpace in pushDataReg
    *)
   4 -> mstate.reg.float.nsave;
   (* restore is made in popDataReg *)
   
   (if common.switch[87] then
       saveProfStackTop;
   if);
   I[]->jsrTImpl;
   eoo;

--backendinitPrimCall:dopart --
do (if intel_trace then 'backendinitPrimCall' -> comment if);
   eoo;

--backendPushClong:dopart --
do (if intel_trace then 'backendPushClong' -> comment; if);
   I.readReg -> pushRegister;
   eoo;
   
--backendPushClongImm:dopart --
do (if intel_trace then 'backendPushClong' -> comment; if);
   i.imm -> pushImmediate;
   eoo;

--backendPushCdouble:dopart --
do (if intel_trace then 'backendPushCdouble' -> comment if);
   (* OPTIMIZE: push_m takes 4 cycles on 486. The following takes
    * only two cycles on a 486 and increses pairing oppotunity on 
    * the pentium (but it will require a register):
    *   movl mem, reg
    *   push reg
    *)
   doPush(# do pushl_m -> emit2bytes; (I.readreg, I.readOffset+4) -> IndirectReg #);
   doPush(# do pushl_m -> emit2bytes; (I.readreg, I.readOffset)   -> IndirectReg #);
   eoo;
   
--backendPushCfloat:dopart --
do (if intel_trace then 'backendPushCfloat' -> comment if);
   (* Push 2 top elements of floating point stack onto activation-stack *)
   (sub_ttt,8, esp, 4) -> emitAluImmReg;
   mstate.framesize+2*4 -> mstate.framesize;
   (if intel_trace then
       '==PushCfloat#'->puttext;
       mstate.framesize -> putint; newline;
   if);
   fstpl -> emit2bytes; (esp,0) -> IndirectReg;
   eoo;
   
--backendInitExternalCall:dopart --
do (if intel_trace then 'backendInitExternalCall' -> comment if);
   (* Nothing to do - see getRegForXres *)
   
--backendCallC:dopart --
do (# proc: (# exit I.label[] #);
      extType: (# exit i.imm #);
      noOfParam: (# exit i.size #);
      exitType: (# exit i.type #);
   do (* stackOff is 
       * noOfPar*4 + (tag+savedRegisters)*4
       * savedregisters is 4 (see getRegForXres)
       *)
      I.size*4 + (1+4)*4 -> mstate.reg.float.nsave;
      
      I.label.copy -> I.label[];
      (if common.switch[87] then
          saveProfStackTop;
      if);
      (if I.imm (* extType *)
       // 1 (* sematt.cExt *) then
          proc -> mstate.Cidentifier;
          I[]->jsrTImpl;
       // 2 (* sematt.pascExt - not relevant for linux *) then
          (proc).MakeUC;
          I[]->jsrTImpl;
       // 7 (* sematt.stdExt *) then
          (if true
           // isMicrosoft then
              '__imp__'->(proc).prepend;
              '@'->(proc).append; (* Sets text-pointer to EOS *)
              I.size*4->(proc).putInt;
              (* Call memory-indirect *)
              call_m -> emit2bytes;
              (*(proc[]->NewTextOp).putop;*)
           // isGnu then
              proc -> mstate.Cidentifier;
              '@'->(proc).append; (* Sets text-pointer to EOS *)
              I.size*4->(proc).putInt;
              (* Call pc-relative *)
              I[]->jsrTImpl;
           // isX86sol
           // isLinux then
              proc -> mstate.Cidentifier;
              I[]->jsrTImpl;           
           else
              'CallCproc: stdCall for wrong architecture'->putline
          if);
       else
          'CallCproc: wrong type'->putline
      if);
   #);
   eoo;
   
---backendNoXres:doPart---
do (if intel_trace then 'backendNoXres' -> comment if);
   I[] -> getExternalResult;
   eoo;

---backendgetSimpleXres:doPart---
do (if intel_trace then 'backendgetSimpleXres' -> comment if);
   I[] -> getExternalResult(# do getSimpleResult #);
   eoo;
   
---backendgetTextXres:doPart---
do (if intel_trace then 'backendgetTextXres' -> comment if);
   (* Not used anymore *)
   'backendgetTextXres' -> TODO;
   eoo;
   
---realXresIsDouble:doPart---
do (if intel_trace then 'realXresIsDouble:doPart' -> comment if);
   (extType = 6 (* pascal *)) -> value;
   eoo;
   
---backendgetDoubleXres:doPart---
do (if intel_trace then 'backendgetDoubleXres' -> comment if);
   I[] -> getExternalResult(# do getDoubleResult #);
   eoo;
   
---backendgetFloatXres:doPart---
do (if intel_trace then 'backendgetFloatXres' -> comment if);
   mstate.reg.float.markReturn;
   I[] -> getExternalResult;
   eoo;
   
---backendgetDataRefXres:doPart---
do (if intel_trace then 'backendgetDataRefXres' -> comment if);
   I[] -> getExternalResult(# do getSimpleResult #);
   eoo;
   
---backendgetDataPartXres:doPart---
do (if intel_trace then 'backendgetDataPartXres' -> comment if);
   I[] -> getExternalResult(# do getSimpleResult #);
   eoo;
   
--backendallocExternalResult:doPart--
do (if i.imm (*exitType*) = common.dataXpartPar then 
       'alloc external result: reserving stackbytes: '->puttext;
       I.size -> putint;
       newline;
       (sub_ttt, i.size(*byteSize*), esp, 4) -> emitAluImmReg;
       mstate.framesize + I.size -> mstate.framesize;
       (if intel_trace then
           '==allocExternalResult#'->puttext;
           mstate.framesize -> putint; newline;
       if);
   if);

---backendSPtoPrim:dopart---
do (* empty *)
   
---backendgetSaveHeapTop:doPart---
do (if intel_trace then 'backendgetSaveHeapTop' -> comment if);
   (esp, 'BetaStackTop'->mstate.Cidentifier) -> emitMovlRegText;
   eoo;
      
--backendsetBreak:doPart--
do int3 -> B_emitbyte
  
---backendXparForward:doPart--
do (if intel_trace then 'backendXparForward' -> comment if);
   (if extKind
    // 1 (* sematt.cExt*) 
    // 7 (* sematt.stdExt*)
    // 9 (* sematt.externalDispatch *)
    // 10 (* sematt.dispatchExt*) then
       (* externalDispatch is StdCall, that uses C-parameters (right to left)
        * and pascal style Callee-cleanup. On linux they're C 
        *)
       false->value
    // 2 (* sematt.pascExt*) 
    // 3 (* sematt.pascTrapExt*) then 
       true->value
    else
       'backendXparForward: unknown type' -> TODO;
   if);
   eoo;

--backendInlineAlloiNGNP:dopart --
do (if intel_trace then 'backendInlineAlloiNGNP' -> comment if);
   'backendInlineAlloiNGNP' -> TODO;
   eoo;

--backenddeAllocIOA:dopart --
do (if intel_trace then 'backenddeAllocIOA' -> comment if);
   'backenddeAllocIOA' -> TODO;
   eoo;

--backendStackAlloPrim:dopart --
do (if intel_trace then 'backendStackAlloPrim' -> comment if);
   'backendStackAlloPrim' -> TODO;
   eoo;
   
--backendasciiText:doPart--
do (if intel_trace then 'backendasciiText' -> comment if);
   (if isWtext then
       T.scanAll(#do ch->mstate.d.emitHalf #);
       0->mstate.d.emitHalf;
    else
       T.scanAll(#do ch->mstate.d.emitByte  #);
       0->mstate.d.emitByte;
   if);
   2->mstate.d.align;
   eoo;
   
---backendInitMachine:descriptor---
(#
do (if intel_trace then 'backendInitMachine' -> comment if);
   
   true -> cap.isIntel;
   (*true -> cap.hasRotateInstr;*)
   (*false -> cap.PrimRegIsReg;*)
   (*false -> cap.PrimRegIsRegAdr;*)
   true -> cap.hasByteSwap;
   
   (* Preferred registers. See getPhysicalRegisterNumber *)
   (* ECX *)
   3 -> cap.shiftregister; 
   (* ESI, better than EBP *)
   4 -> cap.tstnoneregister;
   (* EAX for C-results *)
   1 -> cap.externalResultRegister;
   
   
   name[] -> BC.name;
   (*openDbgInf;*)
   mstate.init; 
   (*true->loadPrototype*)
   eoo;
#)

--backendClose:doPart--
do (if intel_trace then 'backendClose' -> comment if);
   (* This is slot EndDataSeg which used to be in CODEmachine *)
   'BETA_data3'->LabelDef;
   (***** end EndDataSeg *)

   (* Note, BC.name has the form:
    *      'somePath/foo'
    * This extension has been remloved by INtERMEDIATEmachine
    * 
    * Switches:
    *   24:   only generate .db. Has NOT been tested.
    *)
   (# FN,T,name: ^text; switch39: @boolean
   do (if trace_back then
          '>>>> closeMachine: ' -> puttext; BC.name -> putline
      if);
       textalign -> mstate.b.align;
      dataalign -> mstate.d.align;
      
      BC.name->FN[];
      (* producing debug tables *)
      (* FN[]->saveDbgInf;*)
      (if trace_back then
          '>>>>> backendClose: missing: FN[]->saveDbgInf;' -> putline
      if);
      mstate.emitCodeToFile;
      (if resolve_local_calls then
          mstate.verifyRelocations;
      if);
   #);
   eoo;
   
--backenddefineMainLabel:doPart--
do (if intel_trace then 'backenddefineMainLabel' -> comment if);
   (# T: ^text;
   do 
      (* Generate UoFV entry point before main *)
      'UoFV' -> mstate.Cidentifier -> T[] -> export;  
      T[] -> labelDef;
      EDX -> pushRegister;
      -37 -> pushImmediate;(* UnorderedFval; see betarun/C/betaerror.h *)
      'BetaError' -> mstate.CIdentifier -> T[]; 
      &BackendInstruction(# do 'BetaError'->label[] #)->gJsrImpl;
      rtsImpl;	
      
      (* Generate main entrypoint *)
      (if isNTI then
          (* Generate the WinMain@16 entrypoint instead of main *)
          '_WinMain@16' -> T[];
          T[] -> export; T[] -> labelDef;
          &BackendInstruction(# do '_SetupArgValues'->label[] #)->gJsrImpl;
       else      
          (* Generate main entrypoint *)
          'main' -> mstate.Cidentifier -> T[];
          T[] -> export;
          T[] -> labelDef;
          &BackendInstruction(# do 'SetArgValues'->label[] #)->gJsrImpl;
      if);
      
      (if true then
          (* Clear GC regs 
           * - no need: SYNTHESIZER does this after calling Initialize
           * - well, yes: SYNTHESIZER clears %edi, %esi, pReg1, %edx
           * but not %ebp! FIXME
           *)
          (xor_ttt, ebp, ebp) -> alul_rr -> emit2bytes;
          (if false then
              (xor_ttt, esi, esi) -> alul_rr -> emit2bytes;
              (xor_ttt, edi, edi) -> alul_rr -> emit2bytes;
              (xor_ttt, edx, edx) -> alul_rr -> emit2bytes;
          if);
      if);
      eoo;
   #)
--backendswitchToCode:doPart--
do true->mstate.inCode;
   eoo;
   
--backendswitchToData:doPart--
do false->mstate.inCode;
   eoo;
   
--backendexport:doPart--
do (if intel_trace then 
       'backendexport'->comment;
       Lab.copy -> puttext; ':' -> putline;
   if);
   Lab.copy->entryPoints.find
   (# notFound::
        (#
        do true->E.export; -1->E.LIP; E[]->entryPoints.insert;
        #)
   do true->E.export;
   #);
   eoo;

--backendlabelDef:doPart--
do (if intel_trace then
       'backendlabelDef' -> comment; 
       lab[] -> puttext;
       (if mstate.inCode then ' inCode' -> putline else ' inData'->putline if);
   if);

   (if mstate.inCode then
       (lab.copy,entryDefMark)->mstate.b.mark
    else
       (lab.copy,entryDefMark)->mstate.d.mark
   if);
   eoo;

---backendputD:descriptor--
(#
do (if intel_trace then 'backendputD' -> comment if);
   'backendputD' -> TODO;
   eoo;
#)

---backendputA:descriptor--
(#
do (if intel_trace then 'backendputA' -> comment if);
   'backendputA' -> TODO;
   eoo;
#) 

---backendimm:descriptor--
(#
do (if intel_trace then 'backendimm' -> comment if);
   'backendimm' -> TODO;
   eoo;
#)

-- backendputS: DoPart --
do (if intel_trace then 'backendputS' -> comment if);
   'backendputS' -> TODO;
   eoo;
   
---backendstValInLab: doPart---
do (if intel_trace then 'backendstValInLab' -> comment if);
   'backendstValInLab' -> TODO;
   eoo;

---backendldValFromLab: dopart---
do (if intel_trace then 'backendldValFromLab' -> comment if);
   'backendldValFromLab' -> TODO;
   eoo;

---backendEndCodeSeg: dopart---
do (if intel_trace then 'backendEndCodeSeg' -> comment if);
   'BETA_code2'->LabelDef;
   nopImpl;
   switchToData;
   'BETA_data2'->LabelDef;
   eoo;


---backendCallO: dopart---
do edi->rNo

---backendThisO: dopart---
do edx->rNo
   
---backendentryPointsEqual: descriptor---
(#
do (if intel_trace then 'backendentryPointsEqual' -> comment if);
   'backendentryPointsEqual' -> TODO;
   eoo;
#)

---backendLocalLabDef: doPart---
do (if intel_trace then
       'backendLocalLabDef'->comment;
       astext->putline;
   if);
   (if type=interFragment then
       asText->export; 
       (asText,entryDefMark)->mstate.b.mark;
       (labno,false)->mstate.labs.def;
    else
       (if mstate.inCode then
           (labno,false)->mstate.labs.def;
        else
           (labno,true)->mstate.labs.def;
       if);
   if);
   eoo;
   
---backendInitCreateDataFile: doPart---
do (if intel_trace then 'backendInitCreateDataFile' -> comment if);
   (none,common[],fileName.copy,none) -> init;
   switchToData;
   'BETA_DATA' ->export;
   'BETA_DATA' -> labelDef;
   eoo;
   
--backendNextGroup: dopart---
do (if intel_trace then 'backendNextGroup' -> comment if);
   (id[],false) ->importData;
   &backendinstruction(#do id[]->label[] #) 
     ->  declareDataSegmentTextAddressImpl
   
---backendEndCreateDataFile:dopart---
do (if intel_trace then 'backendEndCreateDataFile' -> comment if);
   (* Double NULL termination to allow for extension of 
    * BETA_DATA list (by runtime system)
    *)
   0 -> declareLong;
   0 -> declareLong;
   close;
   eoo;
   
---backendAsText:doPart---
   (* part of this one was in REALmachine
    * therest in SPARCmachine
    *)
do &text[]->localLabText[];
   (if type = interFragment then
       descId[]->localLabText.puttext; 
       labNo->localLabText.putInt; 
    else
      'L'->localLabText;
       labNo->localLabText.putInt
   if);
   eoo;
   
---GlobalCodeLabelDef:doPart---
do (if intel_trace then 'GlobalCodeLabelDef' -> comment if);
   (I.label.copy,entryDefMark)->mstate.b.mark;
   (if NOT I.isLocal then
       (I.label[],false) -> entrypoints.addDef  
   if);
   eoo;
   
--backendAllocObj:doPart--
   (* Tentry  = prototype
    * STACK   = [returnAdr, origin, 1. arg, 2. arg, 3. arg, ... ]
    *            ^top
    *)
do (if intel_trace then 'backendAllocObj' -> comment if);
   (* FIXME! The entry code here must be fixed to be
    * able to wotk with garbage collection.
    * Should look like a call back entry, but also
    * be prepared to be called from C
    *)
   SaveAllReg;
   
   (* Move origin to pReg1 using ECX *)
   ECX -> movl_mr -> emit2bytes;
   (ESP, 4 + noOfSavedRegForCOM * 4) -> IndirectReg;
   (ECX, 'pReg1'->mstate.Cidentifier) -> emitMovlRegText;
   
   (* clear GC registers except RegCall (%edi - parameter to AlloI) 
    * before calling AlloI.
    * They are undefined when coming from C, and could crash a GC 
    * during the following AlloI.
    *)
   (xor_ttt, ebp, ebp) -> alul_rr -> emit2bytes;
   (xor_ttt, esi, esi) -> alul_rr -> emit2bytes;
   (xor_ttt, edx, edx) -> alul_rr -> emit2bytes;
   (xor_ttt, ecx, ecx) -> alul_rr -> emit2bytes;
   
   (* I.Proto is ignored by CallAlloPrim on intel - we must lea it
    * explicitly:   
    *)
   I.proto[]->I.label[];
   EDI -> I.writeReg;
   I[] -> gLeaTextImpl;
   
   'AlloI'->I.label[];
   I[] -> CallAlloPrimImpl;
   (* now: callReg (EDI) = new object; mov into current object (EDX) *)
   (EDI, EDX) -> movl_rr -> emit2bytes;
   eoo;
   
--backendGetCOMpar:doPart--
do (if intel_trace then 'backendGetCOMpar' -> comment if);
   I.writeReg -> movl_mr -> emit2bytes;
   (ESP, 8 + NoOfSavedRegForCOM*4 + (I.paramNo-1) * 4) -> IndirectReg;
   eoo;
   
--backendExternalDispatch:doPart--
do (if intel_trace then 'backendExternalDispatch' -> comment if);
   I[] -> jsrRegImpl;
   eoo;
   
---backendReturnVirtualCOM:doPart--
do (if intel_trace then 'backendReturnVirtualCOM' -> comment if);
   RestoreAllReg;
   (if isNTI then
       (* NTI: we must pop arguments too (stdCall) *)
       ret_pop -> B_emitbyte;
       I.length(*noOfReg*) * 4 -> emitHalf; 
       mstate.framesize - I.length*4 -> mstate.framesize;
       (if intel_trace then
           '==ReturnVirtualCOM#'->puttext;
           mstate.framesize -> putint; newline;
       if);
    else
       rtsImpl;
   if);   
   eoo;
   
---backendDoHead:descriptor---
(#
do (if intel_trace then newline; 'backendDoHead' -> comment if);
   (* empty *)
   eoo;
#)

--backendSpillDataRegImpl:dopart--
do
   (* i.readreg er det fysiske register, der skal spilles
    * i.imm er stackcellens nummer plus antallet af fysiske registre.
    * i.type er register type, datareg, adrreg, ...
    *)
   (# t:^text;
   do (if i.type
       // dataReg then 'd' -> t[];
       // adrReg then 'a' -> t[];
       else
          'backendSpillDataRegImpl: unsupported register type: '->puttext;
          i.type -> putint;
          newline;
      if);
      t[] -> mstate.Cidentifier -> t[];
      i.imm-(i.type->CAP.getNumberOfRegisters)->t.putint;
      (i.readReg,t[])->emitMovlRegText;
   #)
      
--backendLoadSpilledDataRegImpl:dopart--
do
   (# t:^text;
   do (if i.type
       // dataReg then 'd' -> t[];
       // adrReg then 'a' -> t[];
       else
          'backendSpillDataRegImpl: unsupported register type: '->puttext;
          i.type -> putint;
          newline;
      if);
      t[] -> mstate.Cidentifier -> t[];
      i.imm-(i.type->CAP.getNumberOfRegisters)->t.putint;
      (t[],i.writeReg)->emitMovlTextReg;
      
      (* datpete: 12/12/01: Since address registers are used to point into
       * the middle of objects, e.g. at reference assignments, and not only 
       * as GC root registers, these registers may be spilled into memory 
       * locations. These locations can survive a long time, and cause GC 
       * errors if not cleared. This is true for spilling on the stack too 
       *)
      (if i.type=adrReg then
          (*(0,t[]) -> emitMovlImmText;*)
          (* One could consider this code instead:
           *   xor  r32, r32   # 1/3 (2 bytes)
           *   xchg r32, m32   # 3/5 (5 bytes)
           * The code is lightly smaller, but the two mov instructions 
           * used above only take 1 cycles to complete, whereas the xor/xchg 
           * takes 8 cycles plus a LOCK pipeline stall
           *)
      if);

   #)
