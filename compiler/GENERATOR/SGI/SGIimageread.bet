ORIGIN '../ELF/ELFimageread';
LIB_ITEM 'imageread';
INCLUDE '../ELF/elf_mips';

--ImageReadMapOffset: dopart--
do (off div 4) + 1 -> off
        
--ImageReadMapRelType: dopart--
do (if reltype
    // R_MIPS_CALL16 then callMark -> map (* assumes PIC *)
    // R_MIPS_GOT16 then datamark -> map (* assumes PIC *)
    // R_MIPS_HI16 then setHiMark -> map
    // R_MIPS_LO16 then setLoMark -> map
       (* FIXME: cannot determine if it should instead be 
        * setLoMarkSt, setLoMarkJmp, setLoMarkLdd, setLoMarkLd.
        *)
    // R_MIPS_32 then wordMark -> map
    // R_MIPS_NONE then entryDefMark -> map
    // R_MIPS_26 then jmpMark -> map
   if);
   
--ImageReadRelocation: descriptor--
(# (* sgi uses Rel *)
   
   rel_inx: @integer;

   maprel: @
     (* Compare with the generation of Rel entries in SGIelf *)
     (# rel: ^Elf32_Rel;
        mark, type: @integer;
        ep: ^EntryPointInfo;
        getsym: @f.getSymTabEnt;
        getshstr: @f.getSectionName;
        sym: ^Elf32_Sym;
        hdr: ^Elf32_Shdr;
        name: ^text;
     enter rel[]
     do rel.r_offset -> mapoffset -> mark;
        rel.r_info -> ELF32_R_SYM -> getsym -> (sym[], hdr[]);
        sym[] -> mapsym -> ep[];
        rel.r_info -> ELF32_R_TYPE -> mapreltype -> type;
     exit (mark, type, ep[])
     #);
do 
   f.scanDataRelEnts;
   f.cache.data_rel.range -> data_image.noOfRel;
   data_image.markTop -> rel_inx;
   data_image.noOfRel + data_image.markTop -> data_image.marktop;
   (if data_image.marktop > data_image.marks.range then
       data_image.marktop -> data_image.marks.extend;
       data_image.marktop -> data_image.types.extend;
       data_image.marktop -> data_image.epElm.extend;
   if);
   (for i:data_image.noOfRel repeat
        rel_inx+1 -> rel_inx;
        f.cache.data_rel[i][] -> maprel -> 
        (data_image.marks[rel_inx] 
        ,data_image.types[rel_inx]
        ,data_image.epElm[rel_inx][]);
   for);
   f.scanTextRelEnts;
   f.cache.text_rel.range -> text_image.noOfRel;
   text_image.markTop -> rel_inx;
   text_image.noOfRel + text_image.markTop -> text_image.marktop;
   (if text_image.marktop > text_image.marks.range then
       text_image.marktop -> text_image.marks.extend;
       text_image.marktop -> text_image.types.extend;
       text_image.marktop -> text_image.epElm.extend;
   if);
   (for i:text_image.noOfRel repeat
        rel_inx+1 -> rel_inx;
        f.cache.text_rel[i][] -> maprel -> 
        (text_image.marks[rel_inx] 
        ,text_image.types[rel_inx]
        ,text_image.epElm[rel_inx][]);
   for);
#)
   
   
