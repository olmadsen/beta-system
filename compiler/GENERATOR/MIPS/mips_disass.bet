ORIGIN '../disass';
LIB_ITEM 'betacodegen';
---compiler_disass_lib:attributes---
putReg:
  (# r: @integer; T: ^stream
  enter(r,T[])
  do 
     (if true 
         (*
          // (2 <= r) and (r <= 3) then 'v'->T.put; r-2 -> T.putInt;
          // (4 <= r) and (r <= 7) then 'a'->T.put; r-4 -> T.putInt;
          // (8 <= r) and (r <= 15) then 't'->T.put; r-8 -> T.putInt;
          // (16 <= r) and (r <= 23) then 's'->T.put; r-16 -> T.putInt;
          // (24 <= r) and (r <= 25) then 't'->T.put; r-24 -> T.putInt;
          // (26 <= r) and (r <= 27) then 
          'k'->T.put; 't'->T.put;  r-26 -> T.putInt;
          // (28 = r) then 'g'->T.put; 'p'->T.put
          *)
      // (28 = r) then '$'->T.put; 'g'->T.put; 'p'->T.put
      // (29 = r) then '$'->T.put; 's'->T.put; 'p'->T.put
         (*
          // (30 = r) then 's'->T.put; '8'->T.put
          // (31 = r) then 'r'->T.put; 'a'->T.put
          *)
      else
         '$'->T.put; 
         r->T.putInt
     if)
  #);
     
--compiler_hasDisass:doPart--
do true -> value
---compiler_disass:doPart--
do (# PutFReg:
        (# r: @integer; T: ^stream
        enter(r,T[])
        do '$'->T.put; 'f'->T.put; r->t.putInt;
        #);
      PutFmt:
        (# fmt: @integer; T: ^stream
        enter(fmt,T[])
        do (if fmt
            // 16 then 's'->T.put
            // 17 then 'd'->T.put
            // 20 then 'w'->T.put
            else '?'->T.put
           if)
        #);
      fi: (#exit 1#);
      fi2: (#exit 2 #);
      fr: (#exit 3 #);
      fj: (#exit 4#);
      frj1: (#exit 5#);
      fi3: (#exit 6#);
      frj2: (#exit 7#);
      fi4: (#exit 8#);
      fr1d: (#exit 9#);
      frdm: (#exit 10#);
      fRS: (#exit 11#);
      fRf :(#exit 12#);
      fIf: (#exit 13#);
      fRf2: (#exit 14#);
      fRf3: (#exit 15#);
      fBreak: (#exit 16#);
      f,op: @integer;      
   do (0,6)->instruction.%getBits -> op;
      (if op
       // 2 then 'j'->CT; fJ->f
       // 4 then 'beq'->CT; fi4->f;
       // 5 then 'bne'->CT; fi4->f;
       // 8 then 'addi'->CT; fi2->f
       // 9 then 'addiu'->CT; fi2->f
       // 10 then 'slti'->CT; fi2->f
       // 11 then 'sltiu'->CT; fi2->f
       // 12 then 'andi'->CT; fi2->f
       // 13 then 'ori'->CT; fi2->f
       // 14 then 'xori'->CT; fi2->f
       // 15 then 'lui'->CT; fi3->f
       // 17 then 
          (26,6)->instruction.%getBits -> op;
          (if op
           // 0 then 
              (21,11)->instruction.%getBits -> op;
              (if op
               // 0 then
                  'mfc1'->CT; fRf3->f;
               else
                  'add.'->CT;  fRf->f;
              if);
           // 1 then 'sub.'->CT;  fRf->f;
           // 2 then 'mul.'->CT;  fRf->f;
           // 3 then 'div.'->CT;  fRf->f;
           // 6 then 'mov.'->CT; fRf2->f;
           else 
              'float?.'->CT; fRf->f;
          if);
       // 32  then 'b'->CT; fJ->f;
       // 35 then 'lw'->CT; fI->f;
       // 36 then 'lbu'->CT; fI->f;
       // 40 then 'sb'->CT; fI->f;

       // 43 then 'sw'->CT; fI->f;

       // 47 then 'ld'->CT; fI->f;
       // 53 then 'ldc1'->CT; fIf->f
       // 61 then 'sdc1'->CT; fIf->f
       // 0 then
          (26,6)->instruction.%getBits -> op;
          (if op
           // 2 then 'srl'->CT; fRS->f;
           // 3 then 'sra'->CT; fRS->f;
           // 4 then 'sllv'->CT; fR->f;
           // 6 then 'srlv'->CT; fR->f;
           // 7 then 'srav'->CT; fR->f;
           // 8 then 'jr'->CT; frj1->f
           // 9 then 'jalr'->CT; frj2->f
           // 13 then 'break'->CT; fbreak->f
           // 16 then 'mfhi'->CT; fr1d->f
           // 18 then 'mflo'->CT; fr1d->f
           // 24 then 'mult'->CT; frdm->f;
           // 26 then 'div'->CT; frdm->f;
           // 32 then 'add'->CT; fr->f
           // 33 then 'addu'->CT; fr->f
           // 34 then 'sub'->CT; fr->f
           // 36 then 'and'->CT; fr->f
           // 37 then 'or'->CT; fr->f
           // 38 then 'xor'->CT; fr->f
           // 39 then 'nor'->CT; fr->f
           // 42 then 'slt'->CT; fr->f
           // 43 then 'sltu'->CT; fr->f
           // 48 then 'tge'->CT; fRS->f;
           // 0 then 
              (if instruction = 0 then 
                  'nop'->CT; 0->f
               else 'sll'->CT; fRS->f
              if)
           else 'nop #.word\t'->CT; (instruction,true,CT[])->putHex
          if)
       else 'nop #.word\t'->CT; (instruction,true,CT[]) -> putHex
      if);
      '\t' ->CT.put;
      (if f 
       // fi then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          (16,16)->instruction.%getSignedBits -> CT.putInt;
          '('->CT.put;
          ((6,5)->instruction.%getBits,CT[]) ->putReg; 
          ')'->CT.put;
       // fi2 then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          ((6,5)->instruction.%getBits,CT[]) ->putReg; ','->CT.put;
          (16,16)->instruction.%getSignedBits -> CT.putInt;
       // fi3 then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          (16,16)->instruction.%getSignedBits -> CT.putInt;
       // fi4 then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          ((6,5)->instruction.%getBits,CT[]) ->putReg; ','->CT.put;
          (16,16)->instruction.%getSignedBits -> op;
          op -> PrintLab
       // fr then
          ((16,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put; 
          ((6,5)->instruction.%getBits,CT[]) ->putReg; ','->CT.put;
          ((11,5)->instruction.%getBits,CT[]) -> putReg;
       // fj then
          ((6,26)->instruction.%getSignedBits,true,CT[])->putHex
       // frj1 then
          ((6,5)->instruction.%getBits,CT[]) ->putReg; 
       // frj2 then
          ((16,5)->instruction.%getBits,CT[]) ->putReg;  ','->CT.put;
          ((6,5)->instruction.%getBits,CT[]) ->putReg; 
       // fr1d then
          ((16,5)->instruction.%getBits,CT[]) ->putReg 
       // frdm then
          ((6,5)->instruction.%getBits,CT[]) ->putReg;   ','->CT.put;
          ((11,5)->instruction.%getBits,CT[]) -> putReg;
       // fRS then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          ((16,5)->instruction.%getBits,CT[]) ->putReg;  ','->CT.put;
          (21,5)->instruction.%getBits ->CT.putInt
       // fIf then
          ((11,5)->instruction.%getBits,CT[]) -> putFReg; ','->CT.put;
          ((6,5)->instruction.%getBits,CT[]) ->putReg;   '('->CT.put;
          (16,16)->instruction.%getBits ->CT.putInt;  ')'->CT.put;
       // fRf then
          ((6,5)->instruction.%getBits,CT[])->putFmt;
          ((11,5)->instruction.%getBits,CT[]) -> putFReg; ','->CT.put;
          ((16,5)->instruction.%getBits,CT[]) -> putFReg; ','->CT.put;
          ((21,5)->instruction.%getBits,CT[]) -> putFReg;
       // fRf2 then
          ((6,5)->instruction.%getBits,CT[])->putFmt;
          ((21,5)->instruction.%getBits,CT[]) -> putFReg; ','->CT.put;
          ((16,5)->instruction.%getBits,CT[]) -> putFReg;
       // fRf3 then
          ((11,5)->instruction.%getBits,CT[]) -> putReg; ','->CT.put;
          ((16,5)->instruction.%getBits,CT[]) -> putFReg;
       // fBreak then
          ((11,5)->instruction.%getBits,CT[]) -> putReg 
      if);
   #)
   
