ORIGIN '../backend';
INCLUDE 'mips';
INCLUDE 'mipsimage';
BODY '../SGI/sgielfbackend';

-- backendatt: attributes --
trace: (# exit true #);
datareg: (#  exit 1 #);
Adrreg: (#  exit 2 #);
Floatreg: (#  exit 3 #);
Primreg: (#  exit 4 #);

TODO: 
  (# t:^Text
  enter t[]
  do (if trace then
         '\nTODO: '->screen.putText;
         (if t[] = NONE then
             '(with no arg)'->screen.puttext;
          else
             t[]->screen.puttext;
         if)
      else
         (failureTrace, t[])->stop;
     if)
  #);
doJsrT:
  (# T: ^text; I: @backendInstruction
  enter T[]
  do T[]->I.label[];
     I[]->jsrtImpl
  #);
(*PushRealThis:          
  (# 
  do (if mstate.thisPushCount = 0 then
         mstate.stacks.pushRef -> mstate.realThisSpOff;
         (thisO,mips_sp,mstate.realThisSpOff) -> SW -> mstate.b.emit;
      else
         thisO -> pushRef
     if);
     mstate.thisPushCount + 1 -> mstate.thisPushCount
  #);
PopRealThis:      
  (#
  do mstate.thisPushCount - 1 -> mstate.thisPushCount;
     thisO -> popRef
  #);

pushRef:
  (# reg:@integer;
  enter reg
  do (reg,mips_sp,mstate.stacks.pushRef)-> SW ->mstate.b.emit;
  #);
pushData:
  (# reg:@integer;
  enter reg
  do (reg,mips_sp,mstate.stacks.pushData)-> SW ->mstate.b.emit;
  #);      
popRef:
  (# reg:@integer;
  enter reg
  do (reg,mips_sp,mstate.stacks.popRef)-> LW ->mstate.b.emit;
  #);
popData:
  (# reg:@integer;
  enter reg
  do (reg,mips_sp,mstate.stacks.popData)-> LW ->mstate.b.emit;
  #);
*)
CstOpToReg:
  (# C: @integer; dr: @integer
  enter C
  do dataTmp -> dr;
     (if (C < minOff) or (maxOff < C) then
         (C,dr) -> PutSet
      else
         (dr,C) -> LI -> mstate.b.emit 
     if)
  exit dr
  #);

CallProc:
  (# T: ^text; noGPrestore: @ boolean;
  enter T[]
  do (if common.switch[62] then
         (T[],callMark) -> mstate.b.mark; 
         (mips_R25,mips_GP,0) -> LW -> mstate.b.emit;
         (mips_R25,mips_RA)->JALR->mstate.b.emit;
         INNER;
         (* restore GP *)
         (if not NoGPrestore (* NoGPrestore=true for ExO *) then 
             mstate.stacks.GPsave;
             (mips_GP,mips_SP,0) -> LW  -> mstate.b.emit;
         if)
      else
         (T[],callMark) -> mstate.b.mark; 
         0-> JAL ->mstate.b.emit;
         INNER
     if)
  #);

getExternalResult:
  (# getSimpleRes:      
       (# I: ^backendInstruction
       enter I[]
       do (mips_R2,0,I.writeReg) -> ADD -> mstate.b.emit
       #); 
     getDoubleRes:
       (# I: ^backendInstruction
       enter I[]
       do (mips_R2,0,I.writeReg) -> ADD -> mstate.b.emit;
          (mips_R3,0,I.writeReg2) -> ADD -> mstate.b.emit
       #);
     
  do false -> mstate.alloI;;
     INNER;
     mstate.xFreeOreg
  #);

doCall: 
  (# delay: @integer; callLab:<object (* make this more efficient *)
  do inner
  #);

doCall2:
  (* used for real BETA calls of e.g. M-entry-points *)
  (* Complicated if C-call in progress:
   * ...
   * call AlloI
   * a1 -> R19   callReg in R19
   * ...         what if enter/exit parameters? Seems NOT to work!
   * pushOreg
   * R19 -> a1   
   * call M17FOO
   * a1 -> R19
   * popOreg    may override a1
   * a1 -> R26  save argument1 in R26, remember that arg1 inTmp  (R26)
   * r19 -> a1  a1 = callReg again
   * 
   * All this is only necessary if more than 2 arguments !
   * The above comment is no longer valied. See evval2:listEvVal:asgtoCproc,
   * and callAlloPrim and getPrimRes
   *)
  (# 
  do (if mstate.Xlevel > 0 then
         mState.xCnt -> pushOregisters -> mState.busyCall
     if);
     INNER doCall2;
     (if mstate.Xlevel > 0 then
         (mState.xCnt,mState.busyCall) -> popOregisters
     if)
  #);

--getRegisterOffsets:doPart--
do 7->dataOff;
   15->adrOff;
   4->primOff 
   
--getNumberOfDataRegisters:dopart--
do (* See DOC/Registers.html *)
   4->regCount  (* $8 - $11 *)

--getNumberOfAdrRegisters:dopart--
do (* See DOC/Registers.html *)
   3->regCount  (* $16 - $18 *)
   
--getNumberOfRegisters:dopart--
do (* See DOC/Registers.html *)
   (if type
    // dataReg then 4->number
    // adrReg  then 2+3->number (* this+call counts for 2 *)
    // floatReg then 16->number (* 32? *)
    // primReg then 5->number
   if)
   
--getPhysicalRegisterNumber:dopart--
do (* See DOC/Registers.html *)
   (if type
    // dataReg then
       (reg-1)+8 -> physicalregister
    // adrReg then
       (reg-1-2)+16 -> physicalregister
       (* this and call registers count too *)
    // floatReg then
       reg*2 -> physicalRegister (* we currently don't use (f0,f1)*)
    // primReg then
       mips_r4+reg -> physicalregister 
   if)
   
--primRegIsReg:doPart--
do (reg <= 4) -> value  
   
--primRegIsRegAdr:doPart--
do true->value
   
--backendIsSmallAluConstant:doPart--
do (minOff<= c) and (c <= maxOff) -> value
   
--backendIsSmallAdrOff:doPart--
do (minOff <= c) and (c <= maxOff) -> value               (* mej *)
   (* right ? *)   
   
--backendHasRotateInstr:doPart--
do false -> value
   
--backendScaledIndex:doPart--
do false ->value;

-- backendNop: dopart --
do xNOP -> mstate.b.emit

-- backendgLea:doPart--
do (i.writeReg,i.readReg,I.imm)->ADDI->mstate.b.emit
   
-- backendgLeaInx:doPart--                            (* mej *)
do (i.readReg, i.readReg2, i.writeReg)->ADD->mstate.b.emit;
   (if i.imm <> 0 then
       (i.writeReg, i.writeReg, i.imm)->ADDI->mstate.b.emit;
   if);
   
-- backendgLeaText:doPart--
do (I.label[],i.writeReg) -> putSetText
   
-- backendgLeaLabel:doPart--
do '.L'->I.label[];
   I.labNo->I.label.putint;
   (I.label[],i.writeReg) -> PutSetLocalDatalab
   
-- backendldCst:dopart --
do (I.writeReg,I.imm)->PutSet

-- backendstCst:dopart --
do 'backendstCst'->TODO
   
-- backendstCstInx:dopart --
do 'backendstCstInx'->TODO

-- backendldVal:dopart --
do (if i.size=4 then
       (i.writeReg,i.readReg, i.readOffset)->LW->Mstate.B.Emit
    else
       (if i.size=1 then 
           (if i.signed then
               (i.writeReg,i.readReg, i.readOffset)->LB->Mstate.B.Emit
            else
               (i.writeReg,i.readReg, i.readOffset)->LBU->Mstate.B.Emit
           if)
        else
           (* size=2 *)
           (if i.signed then
               (i.writeReg,i.readReg, i.readOffset)->LH->Mstate.B.Emit
            else
               (i.writeReg,i.readReg, i.readOffset)->LHU->Mstate.B.Emit
           if)
       if)
   if)

 
-- backendldVlInx:dopart --                            (* mej *)  
do (I.inxReg, I.readReg, I.inxReg)->ADD->Mstate.B.Emit;
   (if i.size=4 then
       (i.writeReg,  i.inxReg, i.readOffSet)->LW->Mstate.B.Emit
    else
       (if i.size=1 then
           (if i.signed then
               (i.writeReg, i.inxReg, i.readOffSet)->LB->Mstate.B.Emit
            else
               (i.writeReg, i.inxReg, i.readOffSet)->LBU->Mstate.B.Emit
           if)
        else
           (* size=2 *)
          (if i.signed then
               (i.writeReg, i.inxReg, i.readOffSet)->LH->Mstate.B.Emit
            else
               (i.writeReg, i.inxReg, i.readOffSet)->LHU->Mstate.B.Emit
           if)
       if)
   if);
    
-- backendstVal:dopart --
do (if i.size=4 then
       (i.readReg2,i.readReg, i.readOffset)->SW->Mstate.B.Emit
    else
       (if i.size=1 then 
           (i.readReg2,i.readReg, i.readOffset)->SB->Mstate.B.Emit
        else
           (* size=2 *)
           (i.readReg2,i.readReg, i.readOffset)->SH->Mstate.B.Emit
       if)
   if)
   
   
-- backendstValInx:dopart --
do (I.inxReg, I.readReg, I.inxReg)->ADD->mstate.b.emit;
   
   (if i.size=4 then
       (i.readReg2, i.inxReg, i.readOffset)->SW->mstate.b.emit;
    else
       (if i.size=1 then 
           (i.readReg2, i.inxReg, i.readOffset)->SB->mstate.b.emit
        else
           (* size=2 *)
           (i.readReg2, i.inxReg, i.readOffset)->SH->mstate.b.emit
           
       if)
   if);
    
-- backendcpReg:dopart --
do (I.readReg,0,I.writeReg)->ADD->mstate.b.emit
   
-- backendstValInText:dopart --
do 'backendstValInText'->TODO
   
-- backenddoAsgRefAdr:dopart --
do (*empty*)

-- backenddoAsgRefReg:dopart --
do (* empty for mips*)

-- backendChkHeap:dopart --
   (*R[] -> S.X[]  offset til X 28 
    sub %i0, %g6, %g1       ! %g1 = %i0 - heapBot
    cmp %g1, %g7            ! %g7 - %g1
    bltu 1f                 ! jump if %g1 < %g7,
    dvs %i0 in [heapBot, heapBot+%g7[
    st %o0, [%l0+56]        ! delay slot, udf|res f|r jump
    mov %o0, %g2            ! Begge argumenter skal vel overf|res til CheckRef.?
    call ChkRA
    add %l1, 56, %g1
    1:

    Husk at %g6 og %g7 ikke indeholder IOA_bot og IOA_top, men
    IOA_bot og (IOA_top - IOA_bot).
    *)
   (* I.readReg : register containing source reference
    * I.readReg2: register containing destination address
    *)
   
do (*(i.readReg,i.readReg2,i.readOffset)->SW->mstate.b.emit;*)
   
   (if I.withQua then
       (i.readReg,i.readReg2,i.readOffset)->SW->mstate.b.emit;
    else
       (*  IOA[0] = IOA_bot
        *  IOA[4] = IOS_used = IOA_top - IOA_bot
        * 
        *  Check if   R in [IOA_bot, IOA_bot + IOA_used[
        * 
        *  Memory     [ ............ [IOA_bot, IOA_top[ ........]
        *                   R1               R2           R3 
        *  d = R1 - IOAbot  :  d < 0
        *  d = R2 - IOAbot  :  0 <= d < IOA_used
        *  d = R3 - IOAbot  :  IOA_used <= d < MemMax
        * 
        *  IOA_used unsigned<= d  : R is NOT in IOA
        *)

       ('_IOA',IOAusedReg) -> PutSetText;
       (IOAbotReg,IOAusedReg,0)-> LW ->mstate.b.emit;
       (IOAusedReg,IOAusedReg,4)-> LW ->mstate.b.emit;
       
       (*  I.readReg2 - IOAbot -> dataTmp1 *)
       (IOAbotReg,I.readReg2,dataTmp1) -> SUB -> mstate.b.emit;
       (# L: @backendLocalLab; IX: @backendInstruction
       do L.new;
          dataTmp1 -> IX.readReg2;
          IOAusedReg -> IX.readReg;
          L[]->IX.lab[]; L.labNo->IX.labNo;
          IX[] -> BLEU_macro;
          (I.readReg,I.readReg2,0) -> SW -> mstate.b.emit;
          (if callRegBusy then callO->pushRef if);
          PushRegImpl;
          'ChkRA' 
            -> CallProc(#do(mips_R4,I.readReg2) ->MOV-> mstate.b.emit #);
          PopRegImpl;
          (if callRegBusy then callO -> popRef if);
          L.def
       #)
   if)
       
-- backendgAddImm:dopart --
do (i.writeReg,i.readReg2,I.imm)->ADDI->mstate.b.emit
   
   (* The format or imm- and reg-instructions does not seem 
    * consistent with respect to the location of writereg?
    *)
   
-- backendgAddReg:dopart --
do (i.readReg,i.readReg2,i.writeReg)->ADD->mstate.b.emit

-- backendaddMem:dopart --
do 'backendaddMem'->TODO

-- backendgNeg:dopart --
do (I.readReg,mips_R0,I.writeReg)->SUB->mstate.b.emit

-- backendgSubImm:dopart --
do (i.writeReg,i.readReg2,-I.imm)->ADDI->mstate.b.emit
   
-- backendgSubReg:dopart --
do (i.readReg,i.readReg2,i.writeReg)->SUB->mstate.b.emit

-- backendgMultImm:dopart --                   (* mej *)
do
   (# 
      constReg: @integer;
      nop: @boolean;
   do I.imm->CstOpToReg->constReg;
      
      (* The next two instructions following MFLO and MFHI cannot be
       * MULT, DIV, etc
       *)
      (if (mstate.b.LIP - mstate.lastMfHiLo) <= 8 then 
          (for i: (12 - (mstate.b.LIP - mstate.lastMfHiLo)) div 4 repeat
               (if nop then xNOP->mstate.b.emit 
                else ClearStackTop; true->nop
               if)
          for)
      if);
      
      
      (I.readReg2,constReg) -> MULT -> mstate.b.emit;
      mstate.b.LIP -> mstate.lastMfHiLo;
      I.writeReg -> MFLO -> mstate.b.emit;
      
   #)
--backendgMultReg:dopart --                  (* mej change *)
do
   (# 
      nop: @boolean;
   do 
   (* mej: this check below wasn't already copied from MIPSmachine 
    * (so I did it) -
    * we still need to check for MFLO and MFHI, don't we? *)
   
   (* The next two instructions following MFLO and MFHI cannot be
    * MULT, DIV, etc
    *)
   (if (mstate.b.LIP - mstate.lastMfHiLo) <= 8 then 
       (for i: (12 - (mstate.b.LIP - mstate.lastMfHiLo)) div 4 repeat
            (if nop then xNOP->mstate.b.emit 
             else ClearStackTop; true->nop
            if)
       for)
   if);
   
   (I.readReg,I.writeReg) -> MULT -> mstate.b.emit;
   mstate.b.LIP -> mstate.lastMfHiLo;
   I.writeReg -> MFLO -> mstate.b.emit;
   #);
   
--backendgDIVImm:dopart --                       (* mej *)
   (* NOT CALLED ? (sparc slot is empty... 
    * looks like INTERMEDIATEmachine does this?) *)   
do 'backendgDIVImm'->TODO;

--backendgDivReg:dopart --                        (* mej *)
do (# 
      nop: @boolean;
   do (* The next two instructions following MFLO and MFHI cannot be
       * MULT, DIV, etc
       *)
      (if (mstate.b.LIP - mstate.lastMfHiLo) <= 8 then 
          (for i: (12 - (mstate.b.LIP - mstate.lastMfHiLo)) div 4 repeat
               (if nop then xNOP->mstate.b.emit 
                else ClearStackTop; true->nop
               if)
          for)
      if);
      
      (i.readReg,i.readReg2) -> mips_DIV -> mstate.b.emit;
      
      (* check for division by zero. If divisor is non-zero, jump past
       * the NOP and the BREAK (2 instructions) *)
      (i.readReg2,2)  ->  BNEZ -> mstate.b.emit;
      
      XNOP -> mstate.b.emit;
      
      (* 7 means 'division by zero' to the runtime system catching 
       * the resulting exception *)
      7 -> mips_BREAK -> mstate.b.emit; 
      
      mstate.b.LIP -> mstate.lastMfHiLo;
      (if i.isDiv then
          (* this is a division operation, get the quotient *)
          I.writeReg -> MFLO -> mstate.b.emit
       else
          (* this is a modulo operation, get the remainder *)
          I.writeReg -> MFHI -> mstate.b.emit
      if)
      
   #)
--backendgOrImm:dopart --                                   (* mej *)
   (* if not (minOff<i.imm<maxOff) then we have a problem with sign extension,
    * because ORI does zero-extension instead of sign-extension. In that case
    * load the imm value to a register instead. *)
   
do (# dTmp: @integer;
      
   do (if (i.imm<0) or (i.imm>maxOff) then
          i.imm ->CstOpToReg->dTmp;
          (i.readReg2,dTmp,i.writeReg)->mips_OR->mstate.b.emit;
       else
          (I.writeReg,I.readReg2,I.imm) -> ORI -> mstate.b.emit;
      if);
   #);
--backendgOrReg:dopart --
do (i.readReg,i.readReg2,i.writeReg) -> mips_OR -> mstate.b.emit;
   
--backendgAndImm:dopart --                                   (* mej *)
   (* if not (minOff<i.imm<maxOff) then we have a problem with sign extension,
    * because ANDI does zero-extension instead of sign-extension. In that case
    * load the imm value to a register instead. *)
do (# dTmp: @integer;
      
   do (if (i.imm<0) or (i.imm>maxOff) then
          i.imm ->CstOpToReg->dTmp;
          (i.readReg2,dTmp,i.writeReg)->mips_AND->mstate.b.emit;
       else
          (I.writeReg,I.readReg2,I.imm) -> ANDI -> mstate.b.emit;
      if);
   #);

--backendgAndReg:dopart --
do (i.readReg,i.readReg2,i.writeReg) -> mips_AND -> mstate.b.emit
   
--backendgAndNReg:dopart --                                 (* mej *)
   (* the register mips_r0 is hardwired to the zero value -  
    * thus NOR'ing with mips_r0 effects a logical NOT operation. *)
do (# tmpReg: @integer
   do dataTmp->tmpReg;
      (i.readReg2,mips_r0,tmpReg) -> NOR -> mstate.b.emit;
      (i.readReg,tmpReg,i.writeReg) -> mips_AND -> mstate.b.emit;
   #)
   
--backendgxOrImm:dopart --                                 (* mej *)
   (* if not (minOff<i.imm<maxOff) then we have a problem with sign extension,
    * because XORI does zero-extension instead of sign-extension. In that case
    * load the imm value to a register instead. *)
do (# dTmp: @integer;
      
   do (if (i.imm<0) or (i.imm>maxOff) then
          i.imm ->CstOpToReg->dTmp;
          (i.readReg2,dTmp,i.writeReg)->mips_XOR->mstate.b.emit;
       else
          (I.writeReg,I.readReg2,I.imm) -> XORI -> mstate.b.emit;
      if);
   #);

--backendgxOrReg:dopart --
do (i.readReg,i.readReg2,i.writeReg) -> mips_XOR -> mstate.b.emit

--backendgNot:dopart --
do (I.writeReg,I.readReg,1) -> XORI -> mstate.b.emit

--backendlogNot:dopart --
do (I.readReg,mips_R0,I.writeReg) -> NOR -> mstate.b.emit

-- backendgCmpImm: dopart --
do 'backendgCmpImm' -> TODO (* not used ?*)
   
-- backendgCmpReg: dopart --
do 'backendgCmpReg' -> TODO; (* not used ?*)

--backendSignExtByte:dopart --
do (0,I.readReg,I.writeReg,24) -> SLL -> mstate.b.emit;
   (0,I.readReg,I.writeReg,24) -> SRA -> mstate.b.emit;  

--backendSignExtWord:dopart --
do (0,I.readReg,I.writeReg,16) -> SLL -> mstate.b.emit;
   (0,I.readReg,I.writeReg,16) -> SRA -> mstate.b.emit;      (* mej *)

--backendGetBits:dopart --
   (* pos = i.imm; length = i.size, signed flag. *)
   
   (* A general GetBits operation has been implemented in IMmachine, 
    * so we don't need to do it here.    
    *)
do
   'backendGetBits'->TODO;
     
-- backendgGetBits: dopart --
do 'backendgGetBits' -> TODO;
   
-- backendputBits: dopart --
   
   (* A general PutBits operation has been implemented in IMmachine, 
    * so we don't need to do it here.    
    *)
do 'backendputBits' -> TODO;
   
-- backendgPutBits: dopart --
do 'backendgPutBits' -> TODO;

-- backendByteSwap: dopart -- 
   (* A general byteswap operation has been implemented in IMmachine
    * so we don't need to do it here. *)
do 'backendByteSwap' -> TODO;

-- backendgGetDataByte: dopart --                           (* mej *)
do (if i.imm (*  byteNo *)
    // 0 then (* shift right 24 *)
       (0,i.readReg,i.writeReg,24)->SRL->mstate.B.emit;
    // 1 then (* shift right 16 *)
       (0,i.readReg,i.writeReg,16)->SRL->mstate.B.emit;
      (* (i.writeReg,i.writeReg,255)->ANDI->mstate.B.emit;*)
    // 2 then (* shift right 8 bits *)
       (0,i.readReg,i.writeReg,8)->SRL->mstate.B.emit;
       (*(i.writeReg,i.writeReg,255)->ANDI->mstate.B.emit;*)
    // 3 then (* shift right 0 bits *)
       (*(i.readReg,255,i.writeReg)->ANDI->mstate.B.emit;*)
   if);   
   (i.writeReg,i.writeReg,255)->ANDI->mstate.B.emit;
   
-- backendgGetDataWord: dopart --                           (* mej *)
do (if (*wordNo*) i.imm = 0 then
       (0,i.readReg,i.writeReg,16)->SRL->mstate.B.emit;
    else
       (0,i.readReg,i.writeReg,16)->SLL->mstate.B.emit;
       (0,i.writeReg,i.writeReg,16)->SRL->mstate.B.emit;
   if);
   
-- backendarithShiftLeftImm: dopart --                       (* mej *)
do (0,i.readReg,i.writeReg,i.imm)->SLL->mstate.B.emit;
   
-- backendarithShiftLeftReg: dopart --                       (* mej *)
do (i.readReg,i.readReg2,i.writeReg)->SLLV->mstate.B.emit;
   
-- backendlogicalShiftLeftImm: dopart --                     (* mej *)
do (0,i.readReg,i.writeReg,i.imm)->SLL->mstate.B.emit;

-- backendlogicalShiftLeftReg: dopart --                     (* mej *)
do (i.readReg,i.readReg2,i.writeReg)->SLLV->mstate.B.emit;

-- backendarithShiftRightImm: dopart --                      (* mej *)
do (0,i.readReg,i.writeReg,i.imm)->SRA->mstate.b.emit;
   
-- backendarithShiftRightReg: dopart --                      (* mej *)
do (i.readReg,i.readReg2,i.writeReg)->SRAV->mstate.b.emit;
   
-- backendlogicalShiftRightImm: dopart --                    (* mej *)
do (0,i.readReg,i.writeReg,i.imm)->SRL->mstate.b.emit;
   
-- backendlogicalShiftRightReg: dopart --                    (* mej *)
do (i.readReg,i.readReg2,i.writeReg)->SRLV->mstate.b.emit;
   
-- backendrotateLeftImm: dopart --
do 'backendrotateLeftImm' -> TODO;
   
-- backendrotateLeftReg: dopart --
do 'backendrotateLeftReg' -> TODO;
   
-- backendrotateRightImm: dopart --
do 'backendrotateRightImm' -> TODO;
   
-- backendrotateRightReg: dopart --
do 'backendrotateRightReg' -> TODO;
   
-- backendBeginLabel: dopart --
do (if I.bool2(*hasSlots*) then RestoreGP if)

-- backendFreeLabel: dopart --
do 'backendFreeLabel' -> TODO;

-- backendEndLabel: dopart --
do (if I.bool2(*hasSlots*) then RestoreGP if)

-- backendsaveInnerReturn: dopart --
do I[]->SaveReturnImpl
   
---backendExternalMark:doPart---
do (* empty *)
   
---backendExternalReturn:doPart---
do (* pop BetaStackTop;
    * possible C-calls during the call-back may
    * have given a new value to BetaStackTop
    *)
   ('BetaStackTop',dataTmp1) -> PutSetText; 

   (dataTmp2,mips_SP,0) -> LW -> mstate.b.emit;
   (dataTmp2,dataTmp1,0) -> SW ->mstate.b.emit;
  
   RestoreRegisters;
   I[]->ReturnImpl;
   
---backendinitXpar:doPart---
do 1->Xpar.getNo
   
---backendPreGetXpar:doPart---
do (* not used *)
   
---backendNoOfPreGetXpar:doPart---
do 0->value (* onlye used fo rsparc *)
   
--- backendgetXlong:doPart---
do (I.writeReg
   ,mips_SP
   ,mstate.stacks.callBackStackOffset + (Xpar.getNo-1) * 4) 
     -> LW 
     -> mstate.b.emit;
   (mips_R2,I.writeReg) -> MOV -> mstate.b.emit; (* needed for textpar*)
   
   xPar.getNo+1 -> xPar.getNo

---backendgetXword:doPart---
do 'backendgetXword' -> TODO

---backendgetXbyte:doPart---
do 'backendgetXbyte' -> TODO

---backendtoXres:doPart---
do (mips_R2,I.readReg) -> MOV -> mstate.b.emit;
   
---backendXpar:descriptor---
(# getNo: @integer #)
   
---backendGetRegForXres:doPart---
do (* NOT used on mips *)

-- backendreturnInner: dopart --
do I[]->ReturnImpl
   
---backendExternalEntry:doPart---
do (# 
   do I.label.copy->labelDef;
      (* save arguments of call back function; we dont know how many arguments 
       * there are and should probably NOT save more there are, since
       * there may not be room on the stack?? The number of arguments could
       * be a parameter to ExternalEntry.
       * We should consider floating point arguments. However, they are NOT
       * used by AlloSICB.
       * AlloSICB has only 2 arguments, but we save all 4 arg. registers.
       *)
      (mips_R4,mips_SP,0) -> SW -> mstate.b.emit;
      (mips_R5,mips_SP,4) -> SW -> mstate.b.emit;
      (mips_R6,mips_SP,8) -> SW -> mstate.b.emit;
      (mips_R7,mips_SP,12) -> SW -> mstate.b.emit;
      (if common.switch[62] then
          (PICcallReg,PICcallReg,20) -> ADDIU -> mstate.b.emit;
      if);
      
      (* ???true -> inGpart; (* this is a hack to ensure that caller save registers
                        * are saved; we are of course NOT in a G-part
                        *)
      SaveReturnImpl; 
      SaveRegisters;
      (mips_R4,mips_R8) -> MOV -> mstate.b.emit;
      
      ('BetaStackTop',dataTmp1) -> PutSetText;
      (mips_R5,dataTmp1,0)-> LW ->mstate.b.emit;
      
      'AlloSICB'->I.label[]; I[]->jsrTImpl;
      
      (thisO,mips_R2) -> MOV -> mstate.b.emit; (* needed for text par *)
      
      (mips_R5,mips_R2) -> MOV -> mstate.b.emit;
   #)
   
--backendEmitTextConst:dopart --
do 'backendEmitTextConst' -> TODO

--backendgClr:dopart --
do (if I.writeReg < 26 
       (* due to sparc-dependent programming in IMmachinebody*) then       
       (mips_R0,mips_R0,I.writeReg) -> mips_OR -> mstate.b.emit
   if)

--backendpushAdr:dopart --
do 7->mstate.FIXME;

-- backendPush: dopart --
do (if I.condition then
       I.readReg->pushData
    else
       I.readReg->pushRef
   if)
   
-- backendPop: dopart --
do (if I.condition then
       I.writeReg->popData
    else
       I.writeReg->popRef
   if)

--backendPushThisOrCall:dopart --                        (* mej *)
do (if i.bool then PushRealThis if);
   (if i.bool2 then callO->pushRef if);
   

--backendpopThisOrCall:dopart --                         (* mej *)
do (if i.bool2 then callO->popRef if);
   (if i.bool then PopRealThis if);
   
   
-- backendsetTop: dopart --
do 'backendsetTop' -> TODO;

--backendChkCase:dopart --
   (* inx = caseIndex-min
    * if inx >unsigned  (max-min) the  goto elseLab
    * This ALSO works if caseIndex < min.
    * Similar to ChkIndex below.
    * Note that min is NOT used here.
    *)
do (* the interface from here to BGTIU_macro
    * is not so clean
    * *)
   I.readReg-> I.readReg2;
   I.size-I.readOffset (*max-min*) -> I.imm;
   
   I[] -> BGTIU_macro;

   2 -> I.imm;
   I[]->logicalShiftLeftImmImpl;
   
--backendChkIndex:dopart --
   (* not used  *) (* MEJ: why not??? *)                 (* mej *)
do (# mult: @boolean; log: @integer
   do (* 1->MSTATE.FIXME; *)
      (if I.condition (*isSimple*) then
          (if I.size
           // 4 then
              (0, I.inxReg,I.inxReg,2)->SLL->mstate.b.emit;
           // 2 then
              (0, I.inxReg,I.inxReg,1)->SLL->mstate.b.emit;
           // 1 then
           // 8 then
              (0, I.inxReg,I.inxReg,3)->SLL->mstate.b.emit;       
          if)
       else 
          
          (* mej: this was copied from sparcbackend.bet and no changes 
           * were made below. Still ok for MIPS? *)
          (if (I.size->exact_log2->log) <> - 1 then
              (0,I.inxReg,I.inxReg,log)->SLL->mstate.b.emit
           else
              true->mult; 
              (*(if indexCheck then EmitDelayNOP if); *)
          if)
      if);
      (if mult then 
          I.size->I.imm;
          I.inxReg->I.readReg2->I.writeReg;
          i[]->gMultImmImpl 
      if);
   #)

-- backendcmpToBool: dopart --
do (if I.cond (* readReg op readReg2 -> writeReg  - or: ??
               * readReg2 op readReg -> writeReg
               *)
    // 1 (* =  *) then
       (I.readReg2,I.readReg,I.writeReg) -> SUB -> mstate.b.emit;
       (I.writeReg,mips_R0,I.writeReg) -> SLTU -> mstate.b.emit; (* 0 ==> equal *)
       (I.writeReg,I.writeReg,1) -> XORI -> mstate.b.emit
    // 2 (* <> *) then
       (I.readReg2,I.readReg,I.writeReg) -> SUB -> mstate.b.emit;
       (I.writeReg,mips_R0,I.writeReg) -> SLTU -> mstate.b.emit; (* 0 ==> equal *)
2    // 3 (* <  *) then 
       (I.readReg,I.readReg2,I.writeReg) -> SLT -> mstate.b.emit
    // 4 (* <= *) then (* a <= b ==> not b < a *)
       (I.readReg2,I.readReg,I.writeReg) -> SLT -> mstate.b.emit;
       (I.writeReg,I.writeReg,1) -> XORI -> mstate.b.emit
    // 5 (* >  *) then
       (I.readReg2,I.readReg,I.writeReg) -> SLT -> mstate.b.emit
    // 6 (* >= *) then
       (I.readReg,I.readReg2,I.writeReg) -> SLT -> mstate.b.emit;
       (I.writeReg,I.writeReg,1) -> XORI -> mstate.b.emit
   if);

--backendLoadFloat:doPart---                                  (* mej *)
do (I.writeReg,i.readReg,i.readOffSet) -> LDC1 ->mstate.b.emit;

--backendLoadFloatInx:doPart---                               (* mej *)
do (I.inxReg, I.readReg, I.inxReg)->ADD->Mstate.B.Emit;
   (I.writeReg,i.inxReg,i.readOffset)->LDC1->mstate.b.emit;
   
--backendStoreFloat:doPart---                                 (* mej *)
do (I.readReg2,i.readReg,i.readOffset)->SDC1->mstate.b.emit;   
   
--backendStoreFloatInx:doPart---                              (* mej *)
do (I.inxreg,I.readReg,I.inxReg)->ADD->mstate.b.emit;
   (I.readReg2,i.inxReg,i.readOffset)->SDC1->mstate.b.emit;
   
---backendStoreFloat2int:dopart---
do (I.writeReg,I.readReg2) -> TRUNC_W_D -> mstate.b.emit;
   (I.writeReg,dataTmp1) -> MFC1 -> mstate.b.emit;
   (dataTmp1,I.readReg,I.readOffSet) -> SW -> mstate.b.emit;

   
---backendStoreFloat2intInx:dopart---
do (# DT,DTx: @integer
   do DataTmp->DT;
      DataTmp->DTx;
      (I.writeReg,I.readReg2) -> TRUNC_W_D -> mstate.b.emit;
      (* note we cannot overwrite inxReg or readReg *)
      (I.readReg,I.inxReg,DTx)->ADD->mstate.b.emit; 
      (I.writeReg,DT) -> MFC1 -> mstate.b.emit;
      (DT,DTx,I.readOffSet) -> SW -> mstate.b.emit;
   #)
   
---backendLoadInt2Float:dopart---
   (* see backendInt2float *)
do (# DT: @integer
   do DataTmp->DT;
      (DT,I.readReg,I.readOffSet)-> LW ->mstate.b.emit;
      (I.writeReg,DT) -> MTC1 -> mstate.b.emit;
      (I.writeReg,I.writeReg) -> CVT_D_W -> mstate.b.emit;
   #)

---backendLoadInt2FloatInx:dopart---
do (# DT,DTx: @integer
   do DataTmp->DT;
      DataTmp->DTx;
      (I.readReg,I.inxReg,DTx)->ADD->mstate.b.emit; 
      (DT,DTx,I.readOffSet)-> LW ->mstate.b.emit;
      (I.writeReg,DT) -> MTC1 -> mstate.b.emit;
      (I.writeReg,I.writeReg) -> CVT_D_W -> mstate.b.emit;
   #)
  
--backendfloatConst:dopart --
do (# dReg: @integer; S: ^text; 
   do 8->mstate.d.align;
      mstate.defDataLab
      (# 
      do @@I.floatVal   ->TOS'%AdrGetLong'->mstate.d.emit;
         @@I.floatVal+4 ->TOS'%AdrGetLong'->mstate.d.emit;
      #)
        ->S[];
      
      dataTmp -> dReg;
      (S[],dReg) -> PutSetLocalDataLab;
      (I.writeReg,dReg,0) -> LDC1 -> mstate.b.emit   
#)

-- backendint2float: dopart --
   (* Note: in INTERMEDIATEmachine, floatRegOp::int2float
    * uses F.loadInt (loadInt2Float), which loads the integer 
    * to load the integer to a floating point register 
    * - on some platforms, loadInt2Float cannot convert
    * the finteger to a float and this has to be done by
    * int2Float (this doPart). For MIPS, loadInt2Float
    * does the conversion. Here we then have to copy
    * readReg to floatReg. This should be improved!
    *)
do (if I.readReg <> I.writeReg then
       (I.readReg,I.writeReg)->Fmov
   if)

-- backendintReg2float: dopart --
   (* e.g. iE + iE -> x *)
do (I.writeReg,I.readReg) -> MTC1 -> mstate.b.emit;
   (I.writeReg,I.writeReg) -> CVT_D_W -> mstate.b.emit;

-- backendfloat2int: dopart --
   (*  xE -> externalFunc -> V
    * where xE is a floatingpoint expression
    * and externalFunc expects an integer
    * float2int converst xE to an integer
    *)
do (I.readReg,I.readReg) -> TRUNC_W_D -> mstate.b.emit;
   (I.readReg,I.writeReg) -> MFC1 -> mstate.b.emit;

-- backendcmpToBoolFloat: dopart --
do (# Lab: @backendLocalLab
   do Lab.new;
      (if I.cond
       // 1 (* = *) // 3 (* < *) // 4 (* <= *) then
          (Lab.labNo->mstate.labs.off) div 4-> BC1T -> mstate.b.emit
       else
          (Lab.labNo->mstate.labs.off) div 4-> BC1F -> mstate.b.emit
      if);
      (I.writeReg,1)->PutSet;
      (I.writeReg,0)->PutSet;
      Lab.Def
   #)    

-- backendpopFStack: dopart --
do (* empty *)

-- backendCmpFloat: dopart --
do (I.cond,I.readReg2,I.readReg) -> CMP_FLOAT_macroX;
   
--- backendgCmpFloatMem:doPart---
do 'backendCmpFloatMem'->TODO
   
--- backendgCmpFloatMemInx:doPart---
do 'backendCmpFloatMemInx'->TODO 
   
--backendaddFloat:dopart --                                    (* mej *)
do (i.writeReg, i.readReg, i.readReg2) -> ADD_D ->mstate.b.emit;

-- backendsubFloat: dopart --                                  (* mej *)
do (i.writeReg, i.readReg, i.readReg2) -> SUB_D ->mstate.b.emit;

-- backendmulFloat: dopart --                                  (* mej *)
do (i.writeReg, i.readReg, i.readReg2) -> MUL_D ->mstate.b.emit;

-- backenddivFloat: dopart --                                  (* mej *)
do (i.writeReg, i.readReg, i.readReg2) -> DIV_D ->mstate.b.emit;
   
-- backendnegFloat: dopart --                                  (* mej *)
do (i.writeReg, i.readReg, i.readReg) -> NEG_D ->mstate.b.emit;
   
--backendLoadSpilledDataRegImpl:dopart --
do 'backendLoadSpilledDataRegImpl'->TODO
   
--backendSpillDataRegImpl:dopart--
do 'backendSpillDataRegImpl'->TODO

-- backendlock: dopart --
do 'backendlock' -> TODO;

-- backendallRegInPrimReg2I: dopart --
do 'backendallRegInPrimReg2I' -> TODO;

--backendGetOriginReg:dopart --
do (* empty *)

--backendFreeOriginReg:dopart --
do (* empty *)

--backendDataRegMax:dopart --
do 'backendDataRegMax'->TODO

--backendNoOfFreeDataReg:dopart --
do 'backendNoOfFreeDataReg'->TODO

--backendDumpReg:dopart --
do 'backendDumpReg'->TODO

--backendPushReg:dopart --
do liveAdr[]->scanBitvektor32
   (# 
   do (if ((current<>mips_r30) and (current<>mips_r5)) then
          current->pushRef;
      if);
   #);
   
   liveData[]->scanbitvektor32
   (# 
   do (*'pushData: ' -> puttext; current->putint; newline;*)
      current->saveData;
   #);
   
   (* required: mstate.floatReg[1:16/32?]=false *)
   liveFloats[]->scanBitVektor32
   (#
   do 1->mstate.floatReg[current+1];
      current-> saveFloat;
      (*'pushFloat: '-> puttext; current->putint; newline;*)
   #);
   (* NO dataMark is pushed since separate stacks *)
   
--backendPopReg:dopart --
do (* Pop order does not matter ???? *)
   (# Areg,Dreg: [32]@boolean;
      hasAdrRegsOnStack,hasDataRegsOnStack,hasFloatRegsOnStack: @boolean
   do (if true then
          FloatRegOnStack:
            (for i: mstate.floatReg.range repeat
                 (if mstate.floatReg[16-i+1] > 0 then
                     true -> hasFloatRegsOnStack;
                     leave FloatRegOnStack
            if)for);
          liveData[]->scanBitvektor32
          (# 
          do true -> Dreg[current+1];
             true -> hasDataRegsOnStack
          #);
          
          liveAdr[]->scanBitvektor32
          (# 
          do (if (current <> thisO) and (current <> callO) then
                 true -> Areg[current+1];
                 true -> hasAdrRegsOnStack
          if)#);
          (* MIPS has NO datamark since separate stacks *)
          (if hasFloatRegsOnStack then 
              (for i: mstate.floatReg.range repeat
                   (if mstate.floatReg[16-i+1] > 0 then
                       (*'popFloat: '-> puttext; (16-i)->putint; newline;*)
                       16-i -> restoreFloat;
                       0->mstate.floatReg[16-i+1];
          if)for)if);
          (if hasDataRegsOnStack then
              (for i: 32 repeat
                   (if dReg[32-i+1] then
                       (*'popData: '-> puttext; 32-i->putint; newline;*)
                       32-i->restoreData
          if)for)if);
          (if hasAdrRegsOnStack then
              (for i: 32 repeat
                   (if aReg[32-i+1] then 
                       (* 'popRef: '-> puttext; 32-i->putint; newline;*)
                       32-i -> popRef
          if)for)if)
          
       else
          liveAdr[]->scanbitvektor32
          (# 
          do (if ((current<>mips_r30) and (current<>mips_r5)) then
                 '\nmips.popAdrreg, %d'->screen.putformat(# do current -> d #);
                 current->popRef;
             if);
          #);
          
          liveData[]->scanbitvektor32
          (# 
          do '\nmips.popDatareg, %d'->screen.putformat(# do current -> d #);
             current->popData;
          #);
      if);   
   #)
   
--backendPushDataReg:dopart --
do 'backendPushDataReg'->TODO

--backendPopDataReg:dopart --
do 'backendPopDataReg'->TODO

--backendPushFloatReg:dopart --
do 'backendPushFloatReg'->TODO

--backendPopFloatReg:dopart --
do 'backendPopFloatReg'->TODO

--backendtstNone:dopart --
do  clearStackTop;
   (if common.switch[77] then
       (* force read of R to R0 to check for NONE or lazy ref;
        * used for new persistence implementation.
        *)
       (mips_R0,I.writeReg,0) -> LW -> mstate.b.emit
    else       
       (mips_R0,I.writeReg)->TGE->mstate.b.emit
   if)

-- backendtrap: dopart --
do 'backendtrap' -> TODO;

--backendreturn:dopart --
do (thisO,0,callO)->ADD->mstate.b.emit;
   PopThis;
   PopReturn;
   DoReturn
   
--backendsaveReturn:dopart --
do SaveStackFrame;
   PushReturn;
   (callO,0,thisO)->ADD->mstate.b.emit;
   ClearAdrTmpRegs;

--backendrts:dopart --
do (if not common.switch[214] then
       XNOP->mstate.b.emit; 
   if); 
   mips_ra -> JR -> mstate.b.emit;
   XNOP->mstate.b.emit; 

--backendSaveReg:dopart --
   (* Save registers a0 and a1 
    * saveReg/restoreReg are called from evlib:pushThisAndCall and
    * when calling externals.
    * These two situations should be distinguished
    * OBS! the two booleans pushCa and pushTh should be tested!
    * SUN4B should also be fixed for this
    *)
do callO -> PushRef;
   PushRealThis (*thisRegOp[] -> PushRef*)

--backendRestoreReg:dopart --
do PopRealThis; (*thisRegOp[] -> PopRef;*)
   callO -> PopRef;

--backendGetPrimRes:dopart --
   (* GetPrimRes MUST always be called in order to update o-registers*)
do (if not mstate.alloi and mState.restoreCallReg and mstate.initPrimCall
       then 
       (* this is a funny situation; happens when allocating
        * virtual objects in declarations X: @V;
        * getPrimRes is called before CallAlloI;
        * in fact AlloI will be called after getPrimRes
        * but (see jsrtable) we should NOT restore callO.
        * And even worse for local virtuals X: @V there is no
        * jsrTable; we must thus NOT restore if NO primCall
        * CallAlloPrim has been made:-(
        * mstate.initPrimCall = false if initPrimCall with no 
        * callprim/CallAlloPrim
        *)
       (*       (adrTmp1,0,callO) -> mips_OR -> mstate.b.emit;*)
   if);
   (if I.imm (* res *)
    // 0 (* o: ignore result*) then
       mstate.xFreeOreg 
    //1 (* use result *)then
       (mips_R2,0,I.writeReg) -> ADD -> mstate.b.emit;
       mState.xFreeOreg
    //2 (* result is X-parameter *) then mState.xMovePrimToX
    //3 (* result is used immediately *) then
       (mips_R2,0,I.writeReg) -> ADD -> mstate.b.emit; (* ???*)
       mState.xFreeOreg
   if);
   (if mstate.alloI then
       (* see callAlloPrim *)
       (callO,adrTmp1) -> MOV -> mstate.b.emit;
       false -> mstate.AlloI
   if)

--backenddeclareLong: doPart--
do N->mstate.d.emit
   
--backenddeclareWord: doPart--
do N->mstate.d.emitHalf
   
--backenddclWord: doPart--
do N->mstate.d.emitHalf
   
--backendemitByte: doPart--
do B->mstate.d.emitByte

--backendDeclareAddress:dopart --
do (i.labNo->LocalLabtext,wordMark)->mstate.b.mark; 
   0->mstate.b.emit
   
--declareDataSegmentLabelAddressImpl:dopart--
do (i.labNo->localLabtext,wordMark)->mstate.d.mark; 
   0->mstate.d.emit   
   
--declareDataSegmentTextAddressImpl:dopart--
do (i.label.copy,wordMark)->mstate.d.mark; 
   0->mstate.d.emit   
   
--backendChkConstIndex:dopart --
do 'backendChkConstIndex'->TODO

--backendjsrTable:dopart --
do (PICcallReg,I.readReg)->MOV->mstate.b.emit;
   (if I.condition (*newVirt*) then 
       false -> mstate.restoreCallReg; (*  hack! 
                                        * Note: see gen1body:newVirt for
                                        * the case where a jmp is used;
                                        * must also be fixed;
                                        * this imp may no longer bee needed 
                                        * since we now use mips_RA instead 
                                        * of callReg
                                        *)
       (PICcallReg,mips_RA)->JALR->mstate.b.emit;
       ClearStackTop;
       RestoreGP;
    else I[] -> JsrRegImpl
   if)

-- backendjmpTlong: dopart --
do (if common.switch[62] then
       (I.label[],callMark) -> mstate.b.mark;
       (mips_R25,mips_GP,0) -> LW -> mstate.b.emit;
       mips_R25 -> JR -> mstate.b.emit;
    else
       (I.label[],setHiMark)->mstate.b.mark;
       (dataTmp1,0,0)-> LUI ->mstate.b.emit;
       (I.label[],setLoMark)->mstate.b.mark;
       (dataTmp1,dataTmp1,0)-> ADDIU ->mstate.b.emit;
       dataTmp1->JR->mstate.b.emit;
   if);
   xNOP->mstate.b.emit;
   (* clearStackTop should NOT be necessary here and for jmpT *)
   (if common.switch[68] then
       (callO,mips_R2) -> MOV -> mstate.b.emit;
   if);
   
-- backendjmpT: dopart --
do I[]->jmptLongImpl

--backendjsrT:dopart --
do I.label[] -> CallProc(#do ClearStackTop #)

-- backendjsrReg: dopart --
do doCall2
   (#
   do (if I.readReg <> PICcallReg then
          (PICcallReg,I.readReg) -> MOV -> mstate.b.emit
      if);
      (PICcallReg,mips_R31) -> JALR -> mstate.b.emit;
      ClearStackTop;
      RestoreGP
   #)

-- backendjmpReg: dopart --                                (* mej *)
do i.readReg -> JR -> mstate.b.emit;
   (if mstate.inBindVirtuals then (* 19.12.95 *)
       xNOP -> mstate.b.emit
    else ClearStackTop
   if)
   (* be careful with ClearStackTop here, 
    * since this call may
    * be in a final2virt code where sp is NOT well-
    * defined; perhaps we should keep explicit track of
    * when generating code for virtual bindings
    *)

--backendgJsr:dopart --
do doCall2
   (# 
   do (if mstate.thisPushCount > 0 then 
          thisO -> pushRef;
          1 -> mstate.popThis;
          mstate.stacks.markRef;
          (thisO,mips_sp,mstate.realThisSpOff) -> LW -> mstate.b.emit
      if);
      I.label[] -> CallProc(#do ClearStackTop #);
      (if mstate.popThis 
       // 1 then thisO -> popRef
       // 2 then mstate.stacks.popRefTop
      if); 
      0 -> mstate.popThis
   #)
   
--backendjsrTableTest:dopart --
do 'backendjsrTableTest'->TODO

--backendJumpIfTrue:dopart --
do 'backendJumpIfTrue'->TODO

-- backendgBeq: dopart --
do 'backendgBeq' -> TODO;

-- backendgBne: dopart --
do 'backendgBne' -> TODO;

-- backendgBge: dopart --
do 'backendgBge' -> TODO;

-- backendgBae: dopart --
do 'backendgBae' -> TODO;

-- backendgBle: dopart --
do 'backendgBle' -> TODO;

-- backendgBbe: dopart --
do 'backendgBbe' -> TODO;

-- backendgBgt: dopart --
do 'backendgBgt' -> TODO;

-- backendgBab: dopart --
do 'backendgBab' -> TODO;

-- backendgBlt: dopart --
do 'backendgBlt' -> TODO;

-- backendgBbl: dopart --
do 'backendgBbl' -> TODO;

--backendcmpAndJmp:dopart --
do (if I.cond (* IF readReg cc readReg2 then goto L ?? is this right? *)
    // 1 (* =  *) then
       (I.readReg2,I.readReg,(I.labNo->mstate.labs.off) div 4) 
         -> BEQ -> mstate.b.emit
    // 2 (* <> *) then 
       (I.readReg2,I.readReg,(I.labNo->mstate.labs.off) div 4) 
         -> BNE -> mstate.b.emit
    // 3 (* <  *) then I[] -> BLT_macro
    // 4 (* <= *) then I[] -> BLE_macro
    // 5 (* >  *) then I[] -> BGT_macro
    // 6 (* >= *) then I[] -> BGE_macro
   if);
   ClearStackTop
   (* THIS ClearStackTop is 1 instruction and FITS INTO THE DELAY SLOT 
    * of the branch instructions. 
    * If this were to be removed, you should put a nop instruction
    * instead in order not to execute anything inappropriate in the
    * delay slot. *)
      
--backendcmpAndJmpImm:dopart --                          (* mej *)
do (# dTmp: @integer; 
      (* dTmp is used to hold the imm. value as well as 
       * the result of SLTI *)
   do (if I.cond 
       // 1 (* =  *) then
          i.imm -> CstOpToReg -> dTmp;
          (dTmp,I.readReg,(I.labNo->mstate.labs.off) div 4) 
            -> BEQ -> mstate.b.emit
       // 2 (* <> *) then 
          i.imm -> CstOpToReg -> dTmp;
          (dTmp,I.readReg,(I.labNo->mstate.labs.off) div 4) 
            -> BNE -> mstate.b.emit
       // 3 (* <  *) then 
          (# do dataTmp->dTmp;
             (* is readReg < imm ? *)
             (dTmp,I.readReg,I.imm) -> SLTI -> mstate.b.emit;
             
             (* branch if the answer is not equal to false (0), i.e. true (1) *)
             (dTmp,0, (I.labNo->mstate.labs.off) div 4) -> BNE ->mstate.b.emit
          #);
       // 4 (* <= *) then 
          (# 
          do i.imm->CstOpToReg->dTmp;
             (* readReg<= dTmp <=> NOT (dTmp<readReg) *)
             (I.readReg,dTmp,dTmp) -> SLT -> mstate.b.emit;
             
             (* comparing to 0 introduces the NOT from the comment above *)
             (dTmp,0, (I.labNo->mstate.labs.off) div 4) -> BEQ ->mstate.b.emit
          #);
       // 5 (* >  *) then
          (#  do i.imm->CstOpToReg->dTmp;
             (I.readReg,dTmp,dTmp) ->  SLT -> mstate.b.emit;
             (dTmp,0, (I.labNo->mstate.labs.off) div 4) -> BNE ->mstate.b.emit
          #)  
       // 6 (* >= *) then
          (# do dataTmp->dTmp;
             (* readReg >= imm  <=> NOT (readReg < imm) *)
             (dTmp,I.readReg,I.imm) -> SLTI -> mstate.b.emit;
             
             (* branch if the answer is equal to false (0) *)
             (dTmp,0, (I.labNo->mstate.labs.off) div 4) -> BEQ ->mstate.b.emit
          #);
          
      if);
      ClearStackTop 
      (* THIS ClearStackTop is 1 instruction and FITS INTO THE DELAY SLOT 
       * of the branch instructions. 
       * If this were to be removed, you should put a nop instruction
       * instead in order not to execute anything inappropriate in the
       * delay slot. *)
   #);

-- backendcmpBoolAndJmp: dopart --
do (if I.cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then 
       (I.readReg,mips_r0,(I.labNo->mstate.labs.off) div 4) 
         -> BEQ -> mstate.b.emit
    // 2 (* <> *) then 
       (I.readReg,mips_r0,(I.labNo->mstate.labs.off) div 4) 
         -> BNE -> mstate.b.emit
    // 3 (* <  *) 
    // 4 (* <= *) 
    // 5 (* >  *) 
    // 6 (* >= *) then
       '**** SGI compiler error: CmpBoolAndJump: <, <=, >, >='->cError
   if);
   ClearStackTop


--backendcmpAndJmpFloat:dopart --
do (if I.cond
    // 1 (* = *) // 3 (* < *) // 4 (* <= *) then
       (I.labNo->mstate.labs.off) div 4-> BC1T -> mstate.b.emit
    else
       (I.labNo->mstate.labs.off) div 4-> BC1F -> mstate.b.emit
   if);
   ClearStackTop

-- backendfBeq: dopart --
do 'backendfBeq' -> TODO;

-- backendfBge: dopart --
do 'backendfBge' -> TODO;
   
-- backendfBle: dopart --
do 'backendfBle' -> TODO;

-- backendfBne: dopart --
do 'backendfBne' -> TODO;

-- backendfBgt: dopart --
do 'backendfBgt' -> TODO;

-- backendfBlt: dopart --
do 'backendfBlt' -> TODO;

--backendgJmp:dopart --
do (* NOTE: funny form of PC relative here!
    * J is a bit hard to use here!
    * (mstate.b.LIP + (lop.labNo->mstate.labs.off) div 4)
    *  -> J
    *  ->mstate.b.emit;
    *)
   (mips_R0,mips_R0,(I.labNo->mstate.labs.off) div 4)
     -> BEQ
     ->mstate.b.emit;
   ClearStackTop (* 19.12.95 *)

-- backendCallPrim: dopart --
do (# RA: @backendLocalLab; aR: @adrRegOperand; 
      isAtt, isSusp,isExO,popThis,realThisOK: @boolean;
      max: @integer;
      T: ^text;
   do I.label[]-> T[]; 
      (if true
       // 'Att'->T.equal then
          (if mstate.thisPushCount > 0 then
              (* we must transfer the real thisO which as been 
               * pushed on the stack 
               *)
              mstate.stacks.markRef;
              (thisO,mips_sp,mstate.realThisSpOff) -> LW -> mstate.b.emit;
              true -> realThisOK (* we dont have to worry about restoring
                                  * the realThis below
                                  *)
          if);
          (mips_R4,thisO) -> MOV -> mstate.b.emit;
          (* mips_R5 is component for Att, dummy for Susp *)
          RA.new;  
          true->RA.betalabel;
          (*RA.labNo->I.labNo;
          mips_r6->I.writeReg;
          I[]-> gLeaLabelImpl;*)
          (RA.asText,mips_r6)->putSetLocalDataLab;
          true->isSusp;
          (mips_R7,mips_SP) -> MOV -> mstate.b.emit;
          (* the following is generated to ensure that dyn of attached object
           * will refer to the component and not to the calling object.
           *)
          (thisO,callO) -> MOV -> mstate.b.emit;
          true -> isAtt
       // 'Susp'->T.equal then
          (*(mips_R4,thisO) -> MOV -> mstate.b.emit;*)
          RA.new;  true->RA.betalabel;
          (*6->aR.rn;
           (RA[],aR[])-> gLeaLabel;*)
          (RA.asText,mips_r6)->putSetLocalDataLab;
          true->isSusp;
          (mips_R7,mips_SP) -> MOV -> mstate.b.emit;
       // 'ExO' -> T.equal 
       // 'ExOx' -> T.equal then
          (* dataRegA = R8: labelOffSet in destObj 
           *            R4: jumpAdr
           *            R5: destObj
           *            R6: label after ExO
           *            R7: thisObject
           *            R8: SP
           * adrTmp1 =  R19: jumpAdr
           *)
          RA.new;  true->RA.betalabel;
          (*6->aR.rn;
          (RA[],aR[])-> gLeaLabel;*)
          (RA.asText,mips_r6)->putSetLocalDataLab;
          (mips_R7,thisO) -> MOV -> mstate.b.emit;
          (mips_SP,mips_SP,16) -> SW -> mstate.b.emit; (* R8 <- SP *)
          (adrTmp1,mips_R4) -> MOV -> mstate.b.emit;   (* adrTmp1 <- jumpAdr *)
          (if 'ExO' -> T.equal then
              (thisO,mips_R5) -> MOV -> mstate.b.emit; (* thisO <- destObj *)
          if);
          true->isExO;
      if);
      
      calculateLiveData; (* do we have to do this also for ppc?*)
      pushRegImpl;
      
      (* restore thisReg *)
      (if not realThisOk and (mstate.thisPushCount > 0) then 
          thisO -> pushRef;
          true -> popThis;
          mstate.stacks.markRef;
          (thisO,mips_sp,mstate.realThisSpOff) -> LW -> mstate.b.emit
      if);
      
      i.label[] -> CallProc(#do ClearStackTop #); 
      
      (* invert restore of thisreg *)
      (if popThis then thisO -> popRef if);
      
      popRegImpl;
      
      (if mstate.popThis 
       // 1 then thisO -> popRef
       // 2 then mstate.stacks.popRefTop
      if); 
      0 -> mstate.popThis;
      
      (if isSusp or isAtt then  
          RA.def;
          (mips_SP,mips_R4) -> MOV -> mstate.b.emit;
          (thisO,mips_R5) -> MOV -> mstate.b.emit;
          RestoreGP;
       else (if isExO then
                (* NOTE: may not always work correctly since the correct
                 * GP may not be computed. If ExO is to a label in
                 * another fragment, the GP of this fragment MUST be
                 * used. The restore of GP in jsrT above is thus 
                 * superflouos and the GP of the fragment being jumped
                 * to MUST be restored. This GP is found in SP(GPoff)
                 * of the fragment being jumped to. Unfortunately
                 * GPoff is NOT know here!
                 *)
                RA.def;
                (if 'ExOx' -> T.equal then
                    (thisO,mips_R2,-8) -> LW -> mstate.b.emit
                if);
                adrTmp1 -> JR -> mstate.b.emit;
                (mips_SP,mips_R2) -> MOV -> mstate.b.emit; (* set SP *)
            if)
      if);
      true->mstate.initPrimCall;

   #)
   
--backendSPtoPrim:doPart---
do (I.writeReg,I.imm)->SPtoPrimReg
       
   
--backendCallAlloPrim:dopart --
do I.proto[]->mstate.proto[]; 

   (mips_r3+3,1) ->  SPtoPrimReg;
   
   I.label[] -> CallProc(#do ClearStackTop #);

   none->mstate.proto[];
   (if (mstate.Xlevel > 1) then 
       (* external call in progress;
        * see evval2:listEvVal:asgToCproc
        *)
       (adrTmp1,mips_R2) -> MOV -> mstate.b.emit; 
       true->mstate.alloI;
    else
       (callO,mips_R2) -> MOV -> mstate.b.emit;
   if);

   (if mstate.popThis 
    // 1 then thisO -> popRef
    // 2 then mstate.stacks.popRefTop
   if); 
   0 -> mstate.popThis;
   true->mstate.initPrimCall  

--backendinitPrimCall:dopart --
do I.size (* noOfPAr *)->mState.xInitOreg;
   (* NOTE: is I.imm for some platforms; change this
    * on all other platforms to be I.size;
    * it should be consistent with initExternalCall
    * which uses I.size
    *)

--backendPushClong:dopart --
do (if I.readOffSet > 0 then
       (I.readReg,mips_sp,(I.readOffSet-1)*4)->SW->mstate.b.emit;
    else
       I[] -> pushCpar
   if)
   
--backendPushClongImm:dopart --
do (if I.readOffSet > 0 then
       (dataTmp1,I.imm) -> putSet;
       (dataTmp1,mips_sp,(I.readOffSet-1)*4)->SW->mstate.b.emit;
    else
       'pushClongImm '->todo
   if)
   
-- backendPushCdouble: dopart --
do (# FR,oReg: @integer;
      dr1,dr2: @integer
   do mstate.getFparPair -> (FR,oReg);
      (if not mstate.hasIntPar and (FR > 0) then
          (FR,I.readReg,I.readOffSet)-> LDC1 ->mstate.b.emit
       else       
          (if oReg < mips_r8 then
              (* load A to oReg *)
              (oReg  ,I.readReg,I.readOffSet)  -> LW ->mstate.b.emit;
              (oReg+1,I.readReg,I.readOffSet+4)-> LW ->mstate.b.emit;
           else
           (* move A to stack *)
           DataTmp -> dr1;
           DataTmp -> dr2;    
           (dr1,I.readReg,I.readOffSet)     -> LW ->mstate.b.emit;
           (dr2,I.readReg,I.readOffSet+4)   -> LW ->mstate.b.emit;
           (dr1,mips_SP,(oReg-mips_R4)*4)   -> SW ->mstate.b.emit;
           (dr2,mips_SP,(oReg-mips_R4+1)*4) -> SW ->mstate.b.emit;
   if)if)
#)
   
-- backendPushCfloat: dopart --
do (# FR,oReg: @integer
   do mstate.getFparPair -> (FR,oReg);
      (if not mstate.hasIntPar and (FR > 0) then
          (FR,I.readReg)-> MOV_D  ->mstate.b.emit  
       else
          (if oReg < mips_R8 then 
              (* move F to oReg *)
              (I.readReg  ,oReg+1) -> MFC1 -> mstate.b.emit;
              (I.readReg+1,oReg  ) -> MFC1 -> mstate.b.emit;
           else
              (* push I.readReg on stack *)
              (I.readReg,mips_SP,(oReg-mips_r4)*4) 
                -> SDC1 
                -> mstate.b.emit; 
   if)if)
#)

   
--backendInitExternalCall:dopart --
do (if (I.size mod 2) = 1 then I.size + 1 -> I.size if);
   (* if external floats then 8-byte alignment necessary *)
   I.size->mState.xInitOreg;
   
--backendCallC:dopart --
do (if I.type = 7 (*double*) then (* check? *)
       (# fp,fp0: @floatRegOp;
       do true -> mstate.F0notUsed; (* dont push/pop %f0 *)
          1->mstate.FIXME;
          (*fp.alloc; *)
          (if fp.rn <> 0 then 
              (* %f0 is busy - save it until after the call *)
              floatTmp->mstate.saveF0[];
              (* (fp0[],mstate.saveF0[])->fMov;*)
              (* AVOID! push of F0  by PushReg -> max *)
           else
              none -> mstate.saveF0[];
          if);
          (*fp.deAlloc*)
       #);
    else
       false -> mstate.F0notUsed;
       none -> mstate.saveF0[];
   if);
   (if mstate.a1InTmp then (* hack *)
       (mips_R26,0,mips_R5) -> mips_OR -> mstate.b.emit; (* HACK *)
       false->mstate.a1InTmp
   if);
   CalculateLiveData; (* also for ppc? *)
   PushRegImpl;
   thisO -> PushRef;
   (* should callReg be saved here? *)
   I[]->jsrTimpl;
   thisO -> PopRef;
   PopRegImpl;
   false -> mstate.F0notUsed; (* in general %f0 is in use *)
   
---backendNoXres:doPart---
do getExternalResult

---backendgetSimpleXres:doPart---
do getExternalResult(#do I[]->getSimpleRes #)
      
---backendgetTextXres:doPart---
do getExternalResult(#do I[]->getSimpleRes #)
   
---realXresIsDouble:doPart---
do false->value
     
---backendgetDoubleXres:doPart---
do getExternalResult(#do I[]->getDoubleRes #)
   
---backendgetFloatXres:doPart---
do getexternalResult(#do  (0(*FP0*),I.writeReg)->Fmov #)
   
---backendgetDataRefXres:doPart---
do getExternalResult(# do I[]->getSimpleRes#)
   
---backendgetDataPartXres:doPart---
do getExternalResult(#do 2->mstate.FIXME #)
   
---backendgetSaveHeapTop:doPart---
do (# dr1,dr2: @integer
   do DataTmp -> dr1; dataTmp -> dr2;
      ('BetaStackTop',dr1) -> PutSetText;
      mstate.stacks.popFrame;
      (dr2, mips_SP,0) -> ADDIU -> mstate.b.emit;
      (dr2,dr1,0)-> SW -> mstate.b.emit;
   #)
   
--backendallocExternalResult:doPart--
do 
   
--backendsetBreak:doPart--
do 'backendsetBreak'->TODO
   
---backendXparForward:doPart--
do true->value

--backendInlineAlloiNGNP:dopart --
do 'backendInlineAlloiNGNP'->TODO

--backenddeAllocIOA:dopart --
do 'backenddeAllocIOA'->TODO

-- backendStackAlloPrim: dopart --
do 'backendStackAlloPrim' -> TODO;
   
--backendasciiText:doPart--
do (if iswtext then
       T.scanAll
       (#  do ch->mstate.d.emitHalf #);
       0->mstate.d.emitHalf
    else 
       T.scanAll(#do ch->mstate.d.emitByte #);
       0->mstate.d.emitByte;
       4->mstate.d.align  
   if)
   
---backendInitMachine:descriptor---
(#
do name[] -> BC.name;
   (if trace_back then
       '>>>> initMachine: ' -> puttext; name[] -> putline
   if);
   (*openDbgInf;*)
   mstate.init
#)
--backendClose:doPart--
do 
(* write assembly dump to file 'foo...s', 
 * and NOT to 'foo..s' in order NOT to confuse
 * dependency analysis
 *)
(# switch39: @boolean; FN: ^text
do (***** EndDataSeg *****)
    'BETA_data3'->LabelDef;
   (***** end EndDataSeg *)
   
   BC.name->FN[];
   (*FN[]->saveDbgInf;*)
   (if common.switch[18] then
       '...s'->(FN.copy).append->BC.name;
       BC.openWrite;
       (*'#************** text segment ************\n'->BC.putX;*)
       '.text\n.set noreorder\n'->BC.putX;
       true->mstate.inCode;
       mstate.b.appendToBC;
       (*'\n#************** data segment ************\n' -> BC.putX;*)
       '.data\n'->BC.putX;
       '.align 8\n'->BC.putX;
       common.switch[39]->switch39; (* save current value *)
       0->mstate.d.emit; (* to ensure that BETA_data3 is printed *)
       true->common.switch[39]; (* emit .word, NOT asm-code *)
       false->mstate.inCode;
       mstate.d.appendToBC;
       switch39->common.switch[39];
       (*mstate.b.emitSymbols;*) (* includes d also *)
       BC.close;
   if);
   FN[]->BC.name; (* restore BC.name to 'somePath/foo' *)
   mstate.emitCodeToFile
#)

   
--backenddefineMainLabel:doPart--
do (# NewEntry:
     (# T: ^text
     enter T[]
     do T[] -> export; T[] -> labelDef;
        (T[],false)->entryPoints.addDef;
        SaveStackFrame;
        PushReturn;
     #);
   RTS:
     (#
     do PopThis;
        PopReturn;
        DoReturn;
     #);
   GenPrim:
     (# T: ^text; noOfArg: @integer; (* no of arguments Excluding SP *)
        Dreg: @integer;
        frameSize: (#exit 40 #); 
        (* OBS! Important assumption:
         * The size of a stack frame is minimum 40 bytes;
         * this holds space for up to 6 arguments to external routines,
         * dynamic link, return address and the GP.
         * See computation of stackFrameSize above.
         * Note that xMax = 5; i.e. in all stack frames, space is
         * reserved for 5 arguments. This was assumed to be the max
         * for external routines. This is not the case since some
         * of the ones generated here have 6 arguments. Perhaps it
         * is not necessary to define xMax, but for here it has
         * the advantage that the stackFrameSize is always 40 for
         * all the routines generated here.
         *)
     enter(T[],noOfArg)
     do T[] -> NewEntry;
        dataTmp -> Dreg;
        noOfArg+1 -> mstate.stacks.xFrame; (* reserve space for arguments
                                            * on the stack
                                            *)
        (for i: noOfArg > MaxNoOfPrimReg repeat
             (* copy from stack to stack *)
             (Dreg,mips_SP,frameSize + 16 + (i-1)*4) -> LW -> mstate.b.emit;
             (Dreg,mips_SP,16 + (i-1)*4) -> SW -> mstate.b.emit;
        for);
        (mips_r3+noOfArg+1,0) -> SpToPrimReg;
        'C' -> T.prepend;
        T[] -> CallProc(#do ClearStackTop#);
        RTS;
     #);
   T: ^text; aR: @adrRegOperand
do true->mState.isBetaEnv;

   &text[]->T[];
   
   (* CallB(this1,CallReg,BetaEntry,SP)
    * 
    * Routine to be used for calling a BETA entry-point
    * 
    * 1.  A G-entry point from AlloI
    * 
    *       callB(returnmark,CalledObject,G-entry)
    * 
    * 2.  The top M1BETAENV entry point 
    * 
    *     Either AttachBasicComponent
    * 
    *         ...?
    * 
    *     or  simple call from minirun.c
    *        CallB(0,InitialBetaEnvObject,M1BETAENV)
    * 
    * 3.  Attach of some M11FOO
    *     
    *     CallB(component,CalledObject,M11FOO)
    *)
   'CallB' -> T; T[] -> export; T[] -> labelDef;
   ('CallB',false)->entryPoints.addDef;
   SaveStackFrame;
   PushReturn;
   (*  mstate.stacks.popFrame;*)
   SaveRegisters;
   (PICcallReg,mips_R6) -> MOV -> mstate.b.emit;
   (mips_R7,mips_SP,0) -> SW -> mstate.b.emit;
   PICcallReg -> aR;
   (PICcallReg,mips_R31) -> JALR -> mstate.b.emit;
   (thisO,mips_R4) -> MOV -> mstate.b.emit;
   RestoreRegisters;
   PopReturn;
   DoReturn;

   'DoGC' -> T; T[] -> export; T[] -> labelDef;
   ('DoGC',false)->entryPoints.addDef;
   SaveStackFrame;
   PushReturn;
   (* mstate.stacks.popFrame;*)
   (mips_R4,mips_SP,40) -> ADDIU -> mstate.b.emit; (*size of this stack frame*)
   (mips_R5,thisO) -> MOV -> mstate.b.emit;
   (mips_R6,mips_R0) -> MOV -> mstate.b.emit;
   'doGC' -> doJsrT;
   ClearStackTop;
   PopReturn;
   DoReturn;
   
   'HandleIndexErr' -> T; T[] -> export; T[] -> labelDef;
   ('HandleIndexErr',false)->entryPoints.addDef;
   SaveStackFrame;
   PushReturn;
   (*mstate.stacks.popFrame;*)
   (mips_R4,common.RepRangeErr) -> LI -> mstate.b.emit;
   (mips_R5,thisO) -> MOV -> mstate.b.emit;
   (mips_R6,mips_SP,40) -> ADDIU -> mstate.b.emit; (*size of this stack frame*)
   (mips_R7,mips_RA) -> MOV -> mstate.b.emit;
   'BetaError' -> doJsrT;
   ClearStackTop;
   PopReturn;
   DoReturn;
   
   'FailureExit' -> T; T[] -> export; T[] -> labelDef;
   ('FailureExit',false)->entryPoints.addDef;
   SaveStackFrame;
   PushReturn;
   (mips_R4,common.StopCalledErr) -> LI -> mstate.b.emit;
   (mips_R5,thisO) -> MOV -> mstate.b.emit;
   (mips_R6,mips_SP,40) -> ADDIU -> mstate.b.emit; (*size of this stack frame*)
   (mips_R7,mips_RA) -> MOV -> mstate.b.emit;
   'BetaError' -> doJsrT;
   ClearStackTop;
   PopReturn;
   DoReturn;
   
   'DumpStack' -> T; T[] -> export; T[] -> labelDef;
   ('DumpStack',false)->entryPoints.addDef;
   SaveStackFrame;
   PushReturn;
   (mips_R4,common.DumpStackErr) -> LI -> mstate.b.emit;
   (mips_R5,thisO) -> MOV -> mstate.b.emit;
   (mips_R6,mips_SP,40) -> ADDIU -> mstate.b.emit; (*size of this stack frame*)
   (mips_R7,mips_RA) -> MOV -> mstate.b.emit;
   'BetaError' -> doJsrT;
   ClearStackTop;
   PopReturn;
   DoReturn;
   
   'GetSP' -> T; T[] -> export; T[] -> labelDef;
   ('GetSP',false)->entryPoints.addDef;
   mips_ra-> JR ->mstate.b.emit;
   (mips_R2,mips_SP) -> MOV -> mstate.b.emit;

   ('CpkVT',   1) -> GenPrim;
   ('CpkSVT',  3) -> GenPrim;
   ('CopySRR', 5) -> GenPrim;
   ('CopySVR1',5) -> GenPrim;
   ('CopySVR2',5) -> GenPrim;
   ('CopySVR4',5) -> GenPrim;
   ('CopySVR8',5) -> GenPrim;
   ('CopySVRI',5) -> GenPrim;
   ('CopySVRC',5) -> GenPrim;
   ('Qua',3) -> GenPrim;

   'BETA_main' -> T ; T[] -> export;  T[] -> labelDef;
   ('BETA_main',false)->entryPoints.addDef;

#)

--backendswitchToCode:doPart--
do true->mstate.inCode
   
--backendswitchToData:doPart--
do false->mstate.inCode
   
--backendexport:doPart--
do Lab.copy->entryPoints.find
   (# notFound::
        (#
        do true->E.export; E[]->entryPoints.insert;
        #)
   do true->E.export
   #)

--backendlabelDef:doPart--
do (if mstate.inCode then
       (lab.copy,entryDefMark)->mstate.b.mark;
       mState.stacks.init;
    else
       (lab.copy,entryDefMark)->mstate.d.mark
   if);

---backendputD:descriptor--
(##)

---backendputA:descriptor--
(##) 

---backendimm:descriptor--
(##)

-- backendputS: DoPart --
do 
 
---backendaddTargetInfo: doPart---
do (if data then
       mstate.d.LIP->E.LIP
    else
       mstate.b.LIP->E.LIP
   if)

---backendstValInLab: doPart---
do 'backendstValInLab'->TODO

---backendldValFromLab: dopart---
do 'backendldValFromLab'->TODO
   
---backendldValFromText: dopart---
do
   
---backendCallO: dopart---
do 5 -> rNo

---backendEndCodeSeg: dopart---
do 'BETA_code2'->LabelDef;
   nopImpl;
   
   (*2->MSTATE.FIXME;*)
   mstate.stacks.init; (* ad hoc call *)
   
   switchToData;
   
   'BETA_data2'->LabelDef

---backendentryPointsInsert: dopart---
do elm.T[]->mstate.strTbl.insert->elm.m.strInx;
   mstate.symtabTop + 1 -> mstate.symtabTop -> elm.m.symtabInx

---backendThisO: dopart---
do  30 -> rNo

---backendentryPointsEqual: descriptor---
(# #)

---backendLocalLabDef: doPart---
do (if type
    // dataToCode then
       labNo->mstate.d.markLocalLab
    // codeToData  then (* virtual generation *)
       (asText,entryDefMark)->mstate.b.mark;
       (if common.switch[62] then
           ('_gp_disp',setHiMark)->mstate.b.mark;
           (mips_GP,0,0)-> LUI ->mstate.b.emit;
           ('_gp_disp',setLoMark)->mstate.b.mark;
           (mips_GP,mips_GP,0)-> ADDIU ->mstate.b.emit;
           (mips_R25,mips_GP,mips_GP)-> ADDU ->mstate.b.emit;
           (* Note: We do NOT save mips_GP here, since we don't call any
            * other entry points; or do we ? It MUST be investigated
            * if other entry-points are called; 
            * othwerwise here is a potential error.
            *)
       if)       
    // codeLocal then
       (asText,entryDefMark)->mstate.b.mark
    // interFragment then
       asText->export; 
       (asText,entryDefMark)->mstate.b.mark
    else
       (* just to be sure to cover all cases*)
       (if isTextAdr then
           (* label in data segment for asciz-text or real-const *)
           labNo->mstate.d.markLocalLab
        else
           (*label in code segment *)
           (if betaLabel then
               (* as in L: (if ... leave L ; ...if)
                * or start label of  case-imp
                *)
               (asText,entryDefMark)->mstate.b.mark
           if)
       if);       
   if);
   labNo->mstate.labs.def;  (* perhaps NOT this one if codeToData
                             * we seem to get an extra label in this
                             * case - and perhaps also for dataToCode
                             * (asciz)
                             *)
   
---Backendinitcreatedatafile: doPart---
do (none,common[],fileName.copy,none) -> init;
   switchToData;
   'BETA_DATA' ->export;
   'BETA_DATA' -> labelDef;
   
--backendNextGroup: dopart---
do (id[],false) ->importData;
   &backendinstruction(#do id[]->label[] #) 
     ->  declareDataSegmentTextAddressImpl
   
---backendEndCreateDataFile:dopart---
do (* Double NULL termination to allow for extension of 
    * BETA_DATA list (by runtime system)
    *)
   0 -> declareLong;
   0 -> declareLong;
   close;   
   
---backendAsText:doPart---
do &text[]->localLabText[];
   (if type = interFragment then
       descId[]->localLabText.puttext; 
       labNo->localLabText.putInt; 
    else
      '.L'->localLabText;
       labNo->localLabText.putInt
   if)
   
---GlobalCodeLabelDef:doPart---
do (if mstate.inCode then
       (* the following is for resetting IP such that .db offsets are
        * correctly calculated from the start of theG/M-entrypoint;
        * it is ONLY needed because of the two instructions generated above;
        * if the 2 instructions before the entry-point are removed, the
        * IP clearing should be removed
        *)
       (I.label.copy,entryDefMark)->mstate.b.mark;
       mState.stacks.init;
    else
       (I.label.copy,entryDefMark)->mstate.d.mark
   if);
   (if NOT I.isLocal then
       (I.label[],false) -> entrypoints.addDef  
   if)
   
---backendFinal2VirtJump:dopart---
do (if common.switch[62] then
       (PICcallReg,CallO) -> MOV -> mstate.b.emit
   if)
   
--backendAllocObj:doPart--
do 6->mstate.FIXME
   
--backendGetCOMpar:doPart--
do 3->mstate.FIXME
   
--backendExternalDispatch:doPart--
do 4->mstate.FIXME
   
---backendReturnVirtualCOM:doPart--
do 5->mstate.FIXME
   
---backendDoHead:descriptor---
(##)
