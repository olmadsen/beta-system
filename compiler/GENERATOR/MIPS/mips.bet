ORIGIN '~beta/basiclib/betaenv';
LIB_ITEM 'betacodegen';
--LIB:attributes--

(*
 * mips.bet:
 *   Patterns used to model the MIPS registers and instructions.
 *   The comments refer to sections in "MIPS R4000 Microprocessor 
 *   User's Manual", MIPS Computer Systems, Inc., 1991.
 * 
 *   $Id: mips.bet,v 1.1 2001-05-29 13:26:00 corry Exp $
 *)

(* Section 1.3.2: Register numbers *)

mips_r0 : (# exit 0  #); 
mips_r1 : (# exit 1  #); 
mips_r2 : (# exit 2  #); 
mips_r3 : (# exit 3  #); 
mips_r4 : (# exit 4  #); 
mips_r5 : (# exit 5  #); 
mips_r6 : (# exit 6  #); 
mips_r7 : (# exit 7  #); 
mips_r8 : (# exit 8  #); 
mips_r9 : (# exit 9  #); 
mips_r10: (# exit 10 #); 
mips_r11: (# exit 11 #); 
mips_r12: (# exit 12 #); 
mips_r13: (# exit 13 #); 
mips_r14: (# exit 14 #); 
mips_r15: (# exit 15 #); 
mips_r16: (# exit 16 #); 
mips_r17: (# exit 17 #); 
mips_r18: (# exit 18 #); 
mips_r19: (# exit 19 #); 
mips_r20: (# exit 20 #); 
mips_r21: (# exit 21 #); 
mips_r22: (# exit 22 #); 
mips_r23: (# exit 23 #); 
mips_r24: (# exit 24 #); 
mips_r25: (# exit 25 #); 
mips_r26: (# exit 26 #); 
mips_r27: (# exit 27 #); 
mips_r28: (# exit 28 #); 
mips_r29: (# exit 29 #); 
mips_r30: (# exit 30 #); 
mips_r31: (# exit 31 #); 
mips_gp: (# exit 28 #);
mips_sp: (# exit 29 #); 
mips_ra: (# exit 31 #); 

(* Section 1.3.3, 2.1, A.2: Instruction Formats *)

formatI: 
  (* Immediate *)
  (# rs, rt, imm16: @integer;
     X: (# op: @integer;
        enter op
        exit op %bor (rs %sll 21) %bor (rt %sll 16) %bor (imm16 %band 0xffff)
        #);
  enter (rt, rs, imm16)
  #);

formatIB: 
  (* Immediate branch *)
  (# rs, off16: @integer;
     X: (# op: @integer;
        enter op
        exit op %bor (rs %sll 21) %bor (off16 %band 0xffff)
        #);
  enter (rs, off16)
  #);

formatJ:
  (* Jump *)
  (# imm26: @integer;
     X: (# op: @integer;
        enter op
        exit op %bor (imm26 %band 0x03ffffff)
        #);
  enter imm26
  #);

formatRfull:
  (* Register *)
  (# rs, rt, rd, sa, funct: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rt %sll 16) %bor (rd %sll 11) %bor (sa %sll 6) %bor funct
        #);
  enter (rs, rt, rd, sa, funct)
  #);

formatR:
  (* Register - with sa and funct filled out *)
  (# rs, rt, rd: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rt %sll 16) %bor (rd %sll 11)
        #);
  enter (rt, rs, rd)
  #);

formatRnew: (* formatR with logical correct operand order: rd <- rs op rt *)
  (* Register - with sa and funct filled out *)
  (# rs, rt, rd: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rt %sll 16) %bor (rd %sll 11)
        #);
  enter (rd, rs, rt)
  #);

formatR1D:
  (* 1 dest register op *)
  (# rd: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rd %sll 11)
        #);
  enter (rd)
  #);

formatR1S:
  (* 1 source register op *)
  (# rs: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21)
        #);
  enter (rs)
  #);

formatRJ2:
  (* Register jump 2 regs *)
  (# rs, rd: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rd %sll 11)
        #);
  enter (rs, rd)
  #);

formatRJ1:
  (* Register jump 1 reg *)
  (# rs: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) 
        #);
  enter (rs)
  #);

formatRS:
  (* Register shift instruction *)
  (# rs, rt, rd, sa: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rt %sll 16) %bor (rd %sll 11) %bor (sa %sll 6)
        #);
  enter (rs, rt, rd, sa)
  #);

formatRDM:
  (* Register division/multiplication - with rd, sa and funct filled out *)
  (# rs, rt, rd: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (rs %sll 21) %bor (rt %sll 16)
        #);
  enter (rs, rt)
  #);

formatRT:
  (* trap on register *)
  formatRDM(# #);

formatIT:
  (* trap on immediate *)
  (# rs, imm16: @integer;
     X: (# op: @integer;
        enter op
        exit op %bor (rs %sll 21) %bor (imm16 %band 0xffff)
        #);
  enter (rs, imm16)
  #);


formatRD: (* floating point operation *)
  (* Register - with sa and funct filled out *)
  (# fd,fs,ft: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (ft %sll 16) %bor (fs %sll 11) %bor (fd %sll 6)
        #);
  enter (fd, fs, ft)
  #);

formatRD2: (* floating point operation *)
  (# fd,fs: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (fs %sll 11) %bor (fd %sll 6)
        #);
  enter (fd, fs)
  #);

formatRD3: (* floating point operation *)
  (# rt,fs: @integer;
     X: (# op: @integer 
        enter op 
        exit op %bor (fs %sll 16) %bor (rt %sll 11)
        #);
  enter (rt, fs)
  #);
formatRD4:
  (# imm16: @integer;
       X: (# op: @integer
          enter op
          exit op %bor (imm16 %band 0xffff)
          #)
  enter imm16
  #);
formatX:
  (* for instructions not yet implemented *)
  (# X: @integer
  do 'instruction not yet implemented' -> putline;
  #);

(* Appendix A: CPU Instruction Set Details *)


(* Not in manual *)
abs_d:      formatX(# exit 0x46200005->X #);
abs_s:      formatX(# exit 0x46000005->X #);
abs:        formatX(# exit 0->X #);

(* Not in manual *)
add_d:      formatRD(# exit 0x46200000->X #);
add_s:      formatX(# exit 0x46000000->X #);

add:        formatR(# exit 0x00000020->X #);

addi:       formatI(# exit 0x20000000->X #);

addiu:      formatI(# exit 0x24000000->X #);

addu:       formatR(# exit 0x00000021->X #);

mips_and:   formatR(# exit 0x00000024->X #);

andi:       formatI(# exit 0x30000000->X #);

(* Not in manual *)
(* b:          formatX(# exit 0x04010000->X #); *)
b:          formatX(# exit 0x10000000->X #);
bal:        formatX(# exit 0x04110000->X #);

(* coprocessor branch - NYI *)
bc0f:       formatX(# exit 0x41000000->X #);
bc0fl:      formatX(# exit 0x41020000->X #);
bc0t:       formatX(# exit 0x41010000->X #);
bc0tl:      formatX(# exit 0x41030000->X #);
bc1f:       formatRD4(# exit 0x45000000->X #);
bc1fl:      formatX(# exit 0x45020000->X #);
bc1t:       formatRD4(# exit 0x45010000->X #);
bc1tl:      formatX(# exit 0x45030000->X #);
bc2f:       formatX(# exit 0x49000000->X #);
bc2fl:      formatX(# exit 0x49020000->X #);
bc2t:       formatX(# exit 0x49010000->X #);
bc2tl:      formatX(# exit 0x49030000->X #);
bc3f:       formatX(# exit 0x4d000000->X #);
bc3fl:      formatX(# exit 0x4d020000->X #);
bc3t:       formatX(# exit 0x4d010000->X #);
bc3tl:      formatX(# exit 0x4d030000->X #);

beq:        formatI(# exit 0x10000000->X #);

beql:       formatI(# exit 0x50000000->X #);

(* Not in manual *)
beqz:       formatX(# exit 0x10000000->X #);
beqzl:      formatX(# exit 0x50000000->X #);
bge:        formatX(# exit 0->X #);
bgel:       formatX(# exit 2->X #);
bgeu:       formatX(# exit 0->X #);
bgeul:      formatX(# exit 2->X #);

bgez:       formatIB(# exit 0x04010000->X #);
bgezal:     formatIB(# exit 0x04110000->X #);
bgezall:    formatIB(# exit 0x04130000->X #);
bgezl:      formatIB(# exit 0x04030000->X #);

(* Not in manual *)
bgt:        formatX(# exit 0->X #);
bgtl:       formatX(# exit 2->X #);
bgtu:       formatX(# exit 0->X #);
bgtul:      formatX(# exit 2->X #);

bgtz:       formatIB(# exit 0x1c000000->X #);
bgtzl:      formatIB(# exit 0x5c000000->X #);

(* Not in manual *)
ble:        formatX(# exit 0->X #);
blel:       formatX(# exit 2->X #);
bleu:       formatX(# exit 0->X #);
bleul:      formatX(# exit 2->X #);

blez:       formatIB(# exit 0x18000000->X #);
blezl:      formatIB(# exit 0x58000000->X #);

(* Not in manual *)
blt:        formatX(# exit 0->X #);
bltl:       formatX(# exit 2->X #);
bltu:       formatX(# exit 0->X #);
bltul:      formatX(# exit 2->X #);

bltz:       formatIB(# exit 0x04000000->X #);
bltzal:     formatIB(# exit 0x04100000->X #);
bltzall:    formatIB(# exit 0x04120000->X #);
bltzl:      formatIB(# exit 0x04020000->X #);

bne:        formatI(# exit 0x14000000->X #);
bnel:       formatI(# exit 0x54000000->X #);

(* Not in manual *)
bnez:       formatIB(# exit 0x14000000->X #);
bnezl:      formatX(# exit 0x54000000->X #);

mips_break:
  (# mips_code: @integer
  enter mips_code
  exit 0x0000000d % bor (mips_code %sll 16) (*olm: 16 was 5 *)
  #);

(* not in manual *)
c_eq_d:     formatRD3(# exit 0x46200032->X #);
c_eq_s:     formatX(# exit 0x46000032->X #);
c_f_d:      formatX(# exit 0x46200030->X #);
c_f_s:      formatX(# exit 0x46000030->X #);
c_le_d:     formatRD3(# exit 0x4620003e->X #);
c_le_s:     formatX(# exit 0x4600003e->X #);
c_lt_d:     formatRD3(# exit 0x4620003c->X #);
c_lt_s:     formatX(# exit 0x4600003c->X #);
c_nge_d:    formatRD3(# exit 0x4620003d->X #); 
c_nge_s:    formatX(# exit 0x4600003d->X #);
c_ngl_d:    formatX(# exit 0x4620003b->X #);
c_ngl_s:    formatX(# exit 0x4600003b->X #);
c_ngle_d:   formatX(# exit 0x46200039->X #);
c_ngle_s:   formatX(# exit 0x46000039->X #);
c_ngt_d:    formatRD3(# exit 0x4620003f->X #);
c_ngt_s:    formatX(# exit 0x4600003f->X #);
c_ole_d:    formatX(# exit 0x46200036->X #);
c_ole_s:    formatX(# exit 0x46000036->X #);
c_olt_d:    formatX(# exit 0x46200034->X #);
c_olt_s:    formatX(# exit 0x46000034->X #);
c_seq_d:    formatX(# exit 0x4620003a->X #);
c_seq_s:    formatX(# exit 0x4600003a->X #);
c_sf_d:     formatX(# exit 0x46200038->X #);
c_sf_s:     formatX(# exit 0x46000038->X #);
c_ueq_d:    formatX(# exit 0x46200033->X #);
c_ueq_s:    formatX(# exit 0x46000033->X #);
c_ule_d:    formatX(# exit 0x46200037->X #);
c_ule_s:    formatX(# exit 0x46000037->X #);
c_ult_d:    formatX(# exit 0x46200035->X #);
c_ult_s:    formatX(# exit 0x46000035->X #);
c_un_d:     formatX(# exit 0x46200031->X #);
c_un_s:     formatX(# exit 0x46000031->X #);

cache:      formatI(# exit 0xbc000000->X #);

(* Not in manual *)
ceil_l_d:   formatX(# exit 0x4620000a->X #);
ceil_l_s:   formatX(# exit 0x4600000a->X #);
ceil_w_d:   formatX(# exit 0x4620000e->X #);
ceil_w_s:   formatX(# exit 0x4600000e->X #);

(* Move control from coprocessor - NYI *)
cfc0:       formatX(# exit 0x40400000->X #);
cfc1:       formatX(# exit 0x44400000->X #);
cfc2:       formatX(# exit 0x48400000->X #);
cfc3:       formatX(# exit 0x4c400000->X #);
ctc0:       formatX(# exit 0x40c00000->X #);
ctc1:       formatX(# exit 0x44c00000->X #);
ctc2:       formatX(# exit 0x48c00000->X #);
ctc3:       formatX(# exit 0x4cc00000->X #);

(* Not in manual *)
cvt_d_l:    formatX(# exit 0x46a00021->X #);
cvt_d_s:    formatX(# exit 0x46000021->X #);
cvt_d_w:    formatRD2(# exit 0x46800021->X #);
cvt_l_d:    formatX(# exit 0x46200025->X #);
cvt_l_s:    formatX(# exit 0x46000025->X #);
cvt_s_d:    formatX(# exit 0x46200020->X #);
cvt_s_l:    formatX(# exit 0x46a00020->X #);
cvt_s_w:    formatX(# exit 0x46800020->X #);
cvt_w_d:    formatX(# exit 0x46200024->X #);
cvt_w_s:    formatX(# exit 0x46000024->X #);
dabs:       formatX(# exit 3->X #);

dadd:       formatR(# exit 0x0000002c->X #);
daddi:      formatI(# exit 0x60000000->X #);
daddiu:     formatI(# exit 0x64000000->X #);
daddu:      formatR(# exit 0x0000002d->X #);

ddiv:       formatRDM(# exit 0x0000001e->X #);
ddivu:      formatRDM(# exit 0x0000001f->X #);

(* Not in manual *)
div_d:      formatRD(# exit 0x46200003->X #);
div_s:      formatX(# exit 0x46000003->X #);

mips_div:   formatRDM(# exit 0x0000001a->X #);
divu:       formatRDM(# exit 0x0000001b->X #);

(* Doubleword move from/to system control coprocessor - NYI *)
dmfc0:      formatX(# exit 0x40200000->X #);
dmfc1:      formatRD3(# exit 0x44200000->X #);
dmtc0:      formatX(# exit 0x40a00000->X #);
dmtc1:      formatRD3(# exit 0x44a00000->X #);

(* Not in manual *)
dmul:       formatX(# exit 3->X #);
dmulo:      formatX(# exit 3->X #);
dmulou:     formatX(# exit 3->X #);

dmult:      formatRDM(# exit 0x0000001c->X #);
dmultu:     formatRDM(# exit 0x0000001d->X #);

(* Not in manual *)
dneg:       formatX(# exit 0x0000002e->X #);
dnegu:      formatX(# exit 0x0000002f->X #);
drem:       formatX(# exit 0x0000001e->X #);
dremu:      formatX(# exit 0x0000001f->X #);

dsll:       formatRS(# exit 0x00000038->X #);
dsllv:      formatR(# exit 0x00000014->X #);
dsll32:     formatR(# exit 0x0000003c->X #);
dsra:       formatRS(# exit 0x0000003b->X #);
dsrav:      formatR(# exit 0x00000017->X #);
dsra32:     formatRS(# exit 0x0000003f->X #); (* NB rs should be 0 *)
dsrl:       formatRS(# exit 0x0000003e->X #);
dsrlv:      formatR(# exit 0x00000016->X #);
dsrl32:     formatRS(# exit 0x0000003e->X #);

dsub:       formatR(# exit 0x0000002e->X #);
dsubu:      formatR(# exit 0x0000002f->X #);

eret:       formatX(# exit 0x42000018->X #);

(* Not in manual *)
floor_l_d:  formatX(# exit 0x4620000b->X #);
floor_l_s:  formatX(# exit 0x4600000b->X #);
floor_w_d:  formatX(# exit 0x4620000f->X #);
floor_w_s:  formatX(# exit 0x4600000f->X #);
flush:      formatX(# exit 0x98000000->X #);
invalidate: formatX(# exit 0xb8000000->X #);

j:          formatJ(# exit 0x08000000->X #);
                      (*jal:        formatJ(# exit 0x09000000->X #);*)
jal:        formatJ(# exit 0x0c000000->X #);
jalr:       formatRJ2(# exit 0x00000009->X #);
jr:         formatRJ1(# exit 0x00000008->X #);

(* Not in manual *)
l_d:        formatX(# exit 0xd4000000->X #);
l_s:        formatX(# exit 0xc4000000->X #);
la:         formatX(# exit 0->X #);

lb:         formatI(# exit 0x80000000->X #);
lbu:        formatI(# exit 0x90000000->X #);

(* Not in manual *)
lcache:     formatX(# exit 0x88000000->X #);

ld:         formatI(# exit 0xdc000000->X #);

(* Load double to/from coprocessor - NYI *)
ldc1:       formatI(# exit 0xd4000000->X #);
ldc2:       formatX(# exit 0xd8000000->X #);
ldc3:       formatX(# exit 0xdc000000->X #);

ldl:        formatI(# exit 0x68000000->X #);
ldr:        formatI(# exit 0x6c000000->X #);
lh:         formatI(# exit 0x84000000->X #);
lhu:        formatI(# exit 0x94000000->X #);

(* Not in manual *)
li_d:       formatX(# exit 0->X #);
li_s:       formatX(# exit 0->X #);
                      (*li:         formatX(# exit 0x34000000->X #); see below*)

ll:         formatI(# exit 0xc0000000->X #);
lld:        formatI(# exit 0xd0000000->X #);
lui:        formatI(# exit 0x3c000000->X #);
lw:         formatI(# exit 0x8c000000->X #);

(* load word from/to coprocessor - NYI *)
lwc0:       formatX(# exit 0xc0000000->X #);
lwc1:       formatI(# exit 0xc4000000->X #);
lwc2:       formatX(# exit 0xc8000000->X #);
lwc3:       formatX(# exit 0xcc000000->X #);

lwl:        formatI(# exit 0x88000000->X #);
lwr:        formatI(# exit 0x98000000->X #);

(* Not in manual *)
lwu:        formatX(# exit 0x9c000000->X #);

(* Move from system control coprocessor - NYI *)
mfc0:       formatX(# exit 0x40000000->X #);
mfc1:       formatRD3(# exit 0x44000000->X #);
mfc2:       formatX(# exit 0x48000000->X #);
mfc3:       formatX(# exit 0x4c000000->X #);

mfhi:       formatR1D(# exit 0x00000010->X #);
mflo:       formatR1D(# exit 0x00000012->X #);

(* Not in manual *)
mov_d:      formatRD2(# exit 0x46200006->X #);
mov_s:      formatX(# exit 0x46000006->X #);
move:       formatX(# exit 0x00000025->X #);

(* Move to system control coprocessor - NYI *)
mtc0:       formatX(# exit 0x40800000->X #);
mtc1:       formatRD3(# exit 0x44800000->X #);
mtc2:       formatX(# exit 0x48800000->X #);
mtc3:       formatX(# exit 0x4c800000->X #);

mthi:       formatR1S(# exit 0x00000011->X #);
mtlo:       formatR1S(# exit 0x00000013->X #);

(* Not in manual *)
mul_d:      formatRD(# exit 0x46200002->X #);
mul_s:      formatX(# exit 0x46000002->X #);
mul:        formatX(# exit 0->X #);
mulo:       formatX(# exit 0->X #);
mulou:      formatX(# exit 0->X #);

mult:       formatRDM(# exit 0x00000018->X #);
multu:      formatRDM(# exit 0x00000019->X #);

(* Not in manual *)
neg_d:      formatRD(# exit 0x46200007->X #);
neg_s:      formatX(# exit 0x46000007->X #);
neg:        formatX(# exit 0x00000022->X #);
negu:       formatX(# exit 0x00000023->X #);

xnop:        (# exit 0x00000000 #); (* ? not in manual ? *)

nor:        formatR(# exit 0x00000027->X #);

mips_not:   formatX(# exit 0x00000027->X #); (* same as nor ?? *)

mips_or:    formatR(# exit 0x00000025->X #);
ori:        formatI(# exit 0x34000000->X #);

(* Not in manual *)
rem:        formatX(# exit 0x0000001a->X #);
remu:       formatX(# exit 0x0000001b->X #);
rfe:        formatX(# exit 0x42000010->X #);
rol:        formatX(# exit 0->X #);
ror:        formatX(# exit 0->X #);
round_l_d:  formatX(# exit 0x46200008->X #);
round_l_s:  formatX(# exit 0x46000008->X #);
round_w_d:  formatX(# exit 0x4620000c->X #);
round_w_s:  formatX(# exit 0x4600000c->X #);
s_d:        formatX(# exit 0xf4000000->X #);
s_s:        formatX(# exit 0xe4000000->X #);

sb:         formatI(# exit 0xa0000000->X #);
sc:         formatI(# exit 0xe0000000->X #);

(* Not in manual *)
scache:     formatX(# exit 0xa8000000->X #);

scd:        formatI(# exit 0xf0000000->X #);
sd:         formatI(# exit 0xfc000000->X #);

(* Store double from coprocessor - NYI *)
sdc1:       formatI(# exit 0xf4000000->X #);
sdc2:       formatX(# exit 0xf8000000->X #);
sdc3:       formatX(# exit 0xfc000000->X #);

sdl:        formatI(# exit 0xb0000000->X #);
sdr:        formatI(# exit 0xb4000000->X #);

(* Not in manual *)
seq:        formatX(# exit 0->X #);
sge:        formatX(# exit 0->X #);
sgeu:       formatX(# exit 0->X #);
sgt:        formatX(# exit 0->X #);
sgtu:       formatX(# exit 0->X #);

sh:         formatI(# exit 0xa4000000->X #);

(* Not in manual *)
sle:        formatX(# exit 0->X #);
sleu:       formatX(# exit 0->X #);

sll:        formatRS(# exit 0x00000000->X #);
sllv:       formatR(# exit 0x00000004->X #);
slt:        formatR(# exit 0x0000002a->X #);
slti:       formatI(# exit 0x28000000->X #);
sltiu:      formatI(# exit 0x2c000000->X #);
sltu:       formatR(# exit 0x0000002b->X #);

(* Not in manual *)
sne:        formatX(# exit 0->X #);
sqrt_d:     formatX(# exit 0x46200004->X #);
sqrt_s:     formatX(# exit 0x46000004->X #);

sra:        formatRS(# exit 0x00000003->X #); (* NB rs should be 0 *)
srav:       formatR(# exit 0x00000007->X #);
srl:        formatRS(# exit 0x00000002->X #);
srlv:       formatR(# exit 0x00000006->X #);

(* Not in manual *)
sub_d:      formatRD(# exit 0x46200001->X #);
sub_s:      formatX(# exit 0x46000001->X #);

sub:        formatR(# exit 0x00000022->X #);
subu:       formatR(# exit 0x00000023->X #);
sw:         formatI(# exit 0xac000000->X #);

(* Store word from coprocessor - NYI *)
swc0:       formatX(# exit 0xe0000000->X #);
swc1:       formatX(# exit 0xe4000000->X #);
swc2:       formatX(# exit 0xe8000000->X #);
swc3:       formatX(# exit 0xec000000->X #);

swl:        formatI(# exit 0xa8000000->X #);
swr:        formatI(# exit 0xb8000000->X #);

sync:       (# exit 0x0000000f #);

syscall:    (# exit 0x0000000c #);

teq:        formatRT(# exit 0x00000034->X #);
teqi:       formatIT(# exit 0x040c0000->X #);
tge:        formatRT(# exit 0x00000030->X #);
tgei:       formatIT(# exit 0x04080000->X #);
tgeiu:      formatIT(# exit 0x04090000->X #);
tgeu:       formatRT(# exit 0x00000031->X #);

(* Tlb instr - NYI *)
tlbp:       formatX(# exit 0x42000008->X #);
tlbr:       formatX(# exit 0x42000001->X #);
tlbwi:      formatX(# exit 0x42000002->X #);
tlbwr:      formatX(# exit 0x42000006->X #);

tlt:        formatRT(# exit 0x00000032->X #);
tlti:       formatIT(# exit 0x040a0000->X #);
tltiu:      formatIT(# exit 0x040b0000->X #);
tltu:       formatRT(# exit 0x00000033->X #);
tne:        formatRT(# exit 0x00000036->X #);
tnei:       formatIT(# exit 0x040e0000->X #);
 
(* Not in manual *)
trunc_l_d:  formatX(# exit 0x46200009->X #);
trunc_l_s:  formatX(# exit 0x46000009->X #);
trunc_w_d:  formatRD2(# exit 0x4620000d->X #);
trunc_w_s:  formatX(# exit 0x4600000d->X #);
ulh:        formatX(# exit 0->X #);
ulhu:       formatX(# exit 0->X #);
ulw:        formatX(# exit 0->X #);
ush:        formatX(# exit 0->X #);
usw:        formatX(# exit 0->X #);

mips_xor:   formatR(# exit 0x00000026->X #);
xori:       formatI(# exit 0x38000000->X #);

hi:
  (* extract high part of operand *)
  (# word: @integer enter word exit (word %srl 16) #);
lo: 
  (* extract low part of operand *)
  (# word: @integer enter word exit (word %band 0xffff) #);

li: 
  (# rt,imm16: @integer
  enter(rt,imm16)
  exit (rt,mips_R0,imm16) -> ADDI (* dont use ORI, since we must 
                                   * have sign extension *)
  #);

mov:
  (# rd, rs: @integer
  enter(rd, rs)
  exit (rs,0,rd) -> mips_OR (* confusing order:-( *)
  #)
