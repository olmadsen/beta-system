ORIGIN 'asmlink';
INCLUDE 'BYTECODE/fileseplib';
LIB_ITEM 'betacodegen';
---asmlink_init:doPart---
do asmLink.TX.clear; asmLink.Libs.clear; asmLink.build.clear;
   &text[] -> asmLink.fSwitch[]; &text[] -> asmLink.BetaRun[];
   (if betarunSwitch[] <> NONE then betarunSwitch -> asmLink.betaRun if);
   &text[]->asmLink.ObjName[]; (*  to assure NOT none *)
--createCodeDirectory:descriptor---
(# T: ^text; lastSlash: @integer
do (if codeDirectory[] = NONE then
       ((rootfragment[],thePathhandler.currentDirectory)
         -> thePathHandler.convertFilePath
       ,false)
         -> insertSubDir(#do JobExt->path.append #)
         -> T[];
       thePathHandler.DirectoryChar -> T.findAll(#do inx -> lastSlash #);
       (1,lastSlash-1) 
         -> T.sub
         -> codeDirectory[]
         -> (&directory[]).touchDir
       (# error::(#do T[]->thisTranslate.transCreateDirException#)#)
   if)
#)
--createObjDirectory:descriptor---
(# T: ^text; lastSlash: @integer
do (if objDirectory[] = NONE then
       (objName[],thePathhandler.currentDirectory)
         -> thePathHandler.convertFilePath
         -> T[];
       thePathHandler.DirectoryChar -> T.findAll(#do inx -> lastSlash #);
       (1,lastSlash-1) 
         -> T.sub
         -> objDirectory[];
       (* if objName is  '/..../kuk/foo' then objDirectory is '/..../kuk'
        * if objName is  'foo' then the pathHandler expands it to a full
        * path, but the tagetDirectory needs to be appended; this is
        * checked and handled below
        * rubbish!!!
        0 -> lastSlash;
        thePathHandler.DirectoryChar 
        -> objName.findAll(#do inx -> lastSlash #);
        (if lastSlash = 0 then
        '/' -> objDirectory.put;
        targetDirectory[] -> objDirectory.append; 
        if);
        *)
       objDirectory[] -> (&directory[]).touchDir
       (# error::(#do T[]->thisTranslate.transCreateDirException #)#)
   if)
#)

---asmlink_TextLst_insert:doPart---
do (if false then
       '\nTextLst.insert: kind: ' ->puttext; 
       kind -> putint;
       ' FullFN: '->puttext;
       FullFN[] -> putline;
   if);
   actionPart:
     (#
     do (if kind 
         // bytecodeKind 
         // makeKind 
            then (* Check for duplicates *)
            scan
            (# 
            do (if thisElm.kind = makeKind then
                   (if (FullFN[]->thisElm.T.equal) then
                       'asmlink_TextLst_insert: duplicate: ' -> puttext; FullFN[]-> putline;
                       leave actionPart;
                   if)
               if)
            #)
        if);  
        FullFN[]->E.T[]; kind->E.kind;  
        assemble->E.assemble; inLib->E.inLib;
     #);  
   
---asmlink_Libs_insert:doPart---
do T[]->E.T[]; &text[]->linkArgs[]->E.args[]
   
---asmlink_build_insert:doPart---             
do d[] -> E.directory[]; c[] -> E.command[]
   
----AsmLink: descriptor----
(*  Generation of assembler and linker directives. *)
(# <<SLOT asmlinklib:attributes>>; (* XXXasmlink may use this slot for
                                    * declaring auxillary patterns
                                    *)
   
   asmState: @<<SLOT asmState:descriptor>>; (* XXXasmlink may use this slot for
                                             * declaring auxillary variables
                                             *)
      
   isNew: @booleanValue
     (# T: [4] ^text; top: @integer;
        P: ^text;
        isMember: booleanValue
          (* Check only (but fixes slashes in P[] *)
          (# P: ^text;
          enter P[]
          do (P[], '/', 1) -> removeDoubleCh;
             (if (P.length>1) and ((P.length->P.inxGet)='/') then
                 (P.length, P.length) -> P.delete;
             if);
             (for i: top repeat
                  (if T[i][] -> P.equal then
                      true -> value;
                      leave isMember
                  if)
             for);
          #);
     enter P[]
     do (if (not(P[]->isMember)) -> value then
            (if (top+1->top) > T.range then T.range -> T.extend if);
            P[] -> T[top][];
        if);
     #);
   addSharedLibFile:   
     (# libFile, res: ^text
     enter libFile[]
     do <<SLOT AddSharedLibFile: descriptor>>
     exit res[]
     #);
   echo:   (# do <<SLOT Echo:descriptor>> #);
   remove:
     (# name: ^text; check: @boolean
     enter(check,name[]) do <<SLOT Remove:descriptor>>
     #);
   ChangeDirectory:
     (# dir: ^text enter dir[] 
     do (if verboseLevel<=verboseLevel.verbose then
            echo; 'change directory: ' -> AFF.puttext; 
            dir[] -> AFF.putLine;
        if);
        (#<<SLOT ChangeDirectory:doPart>> #)
     #);
   AddCommand:
     (# cmd: ^text enter cmd[] <<SLOT AddCommand:doPart>> #);
   make:   
     (# m: @text; first: @boolean 
     enter(first,m) do <<SLOT Make:descriptor>> 
     #);
   resource:   
     (# m: @text; first: @boolean 
     enter(first,m) do <<SLOT Resource:descriptor>> 
     #);
   stripPath:
     (# t: ^text; i,last: @integer
     enter t[]
     do t.scanAll
        (#
        do i+1 -> i;
           (if ch = thePathHandler.directoryChar then i -> last if);
        #);
        (last+1,t.length) -> t.sub -> t[]
     exit t[]
     #);
   quote:
     (# t: ^text; copy: ^Text;
     enter t[]
     do &Text[] -> copy[]; 
        '"' -> copy.put;
        (if (*switch182 or*) common.switch[56] then
            t[] -> stripPath -> copy.puttext
         else
            t[] -> copy.puttext;
        if);
        '"' -> copy.put;
     exit copy[]
     #);
   cont:   (# do <<SLOT cont: descriptor>> #);
   linkObj : (# lobj: ^ text enter lobj[] do <<SLOT linkObj:descriptor>> #);
   userDefinedBetaRun: @boolean; (*true if betarun defined using BETARUN prop*)
   addBetaRun: 
     (# betarun: ^text; 
     enter(betaRun[],userDefinedBetaRun)
     do <<SLOT addBetaRun:descriptor>> 
     #);
   
   Assembler:
     (# F : ^ text; inFile,outFile: @Text
     enter F[]
     do <<SLOT assemble: descriptor >>;
     #);
   
   contCh: charValue(#do <<SLOT contCh:descriptor>> #);   
   
   xLinkObj:
     (# t: ^text; S: @text
     enter t[]
     do (*'"'->S.put;
         t[] -> S.append; 
         '"'->S.put; *)
        t[] -> quote -> S.puttext;
        contCh -> S.put; '\n\t'->S.append;
        S[] -> ldA.prepend;
     #);
   
   LinkLibraries: <<SLOT linkLibraries:descriptor>>;
   
   addClassList: (* add files from .clst *)
     (# Line,FN: ^text; F: @file; ch: @char;
        clstname, clstbasename: ^text;
        self_added: @boolean;
        trace: (# exit false #);
        startPos,endPos: @integer
     enter FN[]
     do FN.copy -> F.name;
        F.entry.path.head -> clstname[];
        DirectoryChar -> clstname.put;
        (*common.BetaPackage -> clstname.append;*)
        F.entry.path.name -> clstname.append;
        clstname.copy -> clstbasename[];
        
        (* Open the .clst file *)
        '.clst' ->  clstname.append;
        (if common.hostIsWindows then
            clstname[] -> SlashToBackslash;
        if);
        clstname[] -> F.name;
        (if trace then
            'asmlinkbody: addclasslist: opening ' -> puttext; F.name -> putline;
        if);
        F.openRead;
        L: (if not F.eos then
               F.getInt -> startPos;
               F.getInt -> endPos;
               F.get -> ch; (* blank after endPos *)
               F.getline -> Line[];
               (if false then
                   startpos -> putint; ' ' ->put;
                   endPos -> putint; ' "'->puttext;
                   line[] -> puttext; '"\n'->puttext;
               if);
               (if line.length>0 then
                   (if common.isJVM then
                       (* to generate possible '..j' file *)
                       Line.copy -> assembler; 
                   if);
                   (if trace then
                       'addClassList: '->screen.puttext;
                       Line[] -> screen.putline;
                   if);
                   (if common.switch[189] then
                       (if not self_added then
                           (if common.hostIsWindows then
                               Line[] -> clstbasename.equalNCS -> self_added;
                            else
                               Line[] -> clstbasename.equal -> self_added;
                           if);
                       if);
                   if);
                   Line.copy (* no extension *) -> quote -> linkObj;
               if);
               restart L;
           if);
        F.close;
     #);
   BetaLib,BetaRunLib: ^Text;
   AFF: @File
     (# AccessError:: (# do name -> thisTranslate.TransAccessException #);
        NoSpaceError:: (# do NoSpaceError #);
        WriteError:: (# do NoSpaceError #);
        OtherError:: (# do (name,msg[]) -> thisTranslate.otherFileError #);
        NoSuchFileError::
          (* someone has removed the job-file during compilation;
           * we could perhaps ignore it but to play it safe ...
           *)
          (#
          do 'Someone has removed the job-file during compilation' -> msg;
             (name,msg[]) -> thisTranslate.otherFileError
          #)
     #);
   
   Linker:
     (# SplitLdA:
          (* check if the list of beta.o files in ldA is too long
           * for the link-directive and if it is, split the linking into
           * a number of calls to the linker
           *)
          (# first,last,last1: @integer; T: ^text; TmpFiles: @text;
             hasBetaEnv: @boolean
          do (if ldA.length > ldArgMax  then
                 1->first; (*true -> hasBetaEnv;*)
                 split1:
                   (#
                   do (* search back from  ldA[start+ldArgMax-1] to
                       * a char separating two file names in ldA
                       *)
                      split2:
                        (for i: ldArgMax repeat
                             (if ((first+ldArgMax-i)->last1) <= ldA.length 
                                 then
                                 (if (last1->ldA.inxGet) <= ' ' 
                                     then leave split2
                        if)if)for);
                      last1->last;
                      (* remove possible trailing cr/lf/tab and \ *)
                      remove:
                        (if last-1->last->ldA.inxGet
                         // ' ' // ascii.ht // ascii.newline // contCh then
                            restart remove
                        if);
                      (if first < last then (* datpete 6/7/95 *)
                          (first,last)->ldA.sub->T[]; T.newline;
                          (T[],hasBetaEnv)->ldTmp->quote->TmpFiles.append; 
                          ' ' -> TmpFiles.put;
                          contCh->TmpFiles.put;
                          TmpFiles.newline;
                          ascii.ht -> TmpFiles.put;
                          false -> hasBetaEnv
                      if);
                      (if (last1+1->first) <= ldA.length  then 
                          restart split1
                      if)
                   #);
                 TmpFiles[]->ldA[];                 
             if)
          #);

        ldArgMax: integerValue(#do <<SLOT ldArgMax:descriptor>> #);
        ldTmp:
          (# tmpArgs: ^text; TmpF: ^text; hasBetaEnv: @boolean
          enter(tmpArgs[],hasBetaEnv)
          do <<SLOT ldTmp:descriptor>>
          exit TmpF[]
          #);
        betaenvObj: ^ text;  betaenvIsSharedLib: @boolean
     do (* Put the beta .o into the link directive.
         * 6/87/8:
         * The following is probably no longer true:
         * The beta.o files must appear consequtively in the link
         * directive, since the initFragment part of the persistence
         * store assumes that all data areas of beta.o files appear
         * consequetively in the exe-file. This is currently an experiment
         * but it may be abandoned if some of the linkers do not place
         * these data segments consequetively!
         * The first beta.o file MUST be betaenv/tstenv
         *)
        (if (not switch182) then
            NONE -> betaenvObj[];
            L: TX.Scan
              (#
              do (if thisElm.kind = BetaEnvKind then 
                     (*(if common.switch[16] then thisElm.T.copy->mkSym.addFile if);*)
                     BinExt -> (thisElm.T.Copy).Append -> betaenvObj[];
                     thisElm.inLib and hasSharedLibs -> betaenvIsSharedLib;
                     (* Some linkers may have problems with betaenv 
                      * if it is a shared library
                      *)
                     leave L (* there is only one betaenv *)
                 if);
              #);
            (if (betaenvObj[]<>NONE) and (not common.switch[61]) then
                betaenvObj[] -> quote -> linkObj
            if)
        if);
        
        (if switch182 then
            (* Bytecode *)
            TX.Scan
            (#
            do (if false then
                   'TX: kind: '->puttext;
                   (if thisElm.kind
                    // BetaEnvKind then 'BetaEnvKind'->puttext;
                    // BetaKind then 'BetaKind'->puttext;
                    // ObjKind then 'ObjKind'->puttext;
                    // LibKind then 'LibKind'->puttext;
                    // MakeKind then 'MakeKind'->puttext;
                    // LinkOptKind then 'LinkOptKind'->puttext;
                    // ResourceKind then 'ResourceKind'->puttext;
                    // BetaDataKind then 'BetaDataKind'->puttext;
                    // ByteCodeKind then 'ByteCodeKind'->puttext;
                    // ByteCodeFileKind then 'ByteCodeFileKind'->puttext;
                    else
                       thisElm.kind->putint; 
                   if);
                   ', T: ' ->puttext; thisElm.T.copy->putline;
               if);
               (if thisElm.kind 
                // BetaKind then
                   'asmlink: bytecode: met betakind: ' ->puttext; thisElm.T.copy->putline;
                // ByteCodeKind then
                   (if not (thisElm.inLib and hasSharedLibs) then
                       thisElm.T.Copy (* No extension *) -> quote -> linkObj;
                   if)
                // byteCodeFileKind then
                   thisElm.T.copy -> addClassList;
               if);
            #)
         else
            (* Normal .o file linkage *)
            TX.Scan
            (#
            do (if thisElm.kind = BetaKind then
                   (if not (thisElm.inLib and hasSharedLibs) then
                       BinExt->(thisElm.T.Copy).Append-> quote -> linkObj
                   if)
               if)
            #);
        if);
        
        SplitLdA;
        
        (if common.switch[61] and not betaenvIsSharedLib then
            (# S: @text
            do betaenvObj[] -> quote -> S.append; 
               contCh -> S.put; '\n\t'->S.append;
               S[] -> ldA.prepend;
            #)
        if);
        
        (if not switch182 then
            (* put the BETA_DATA-file into the link directive;
             * it must appear before any shared libraries; 
             * otherwise  problmes for sgi.
             *)
            TX.scan
            (#
            do (if thisElm.kind = BetaDataKind then
                   thisElm.T.copy -> betaDataFile[];
	           (if (common.targetMachineId = common.nti_ms) 
                       or (common.targetMachineId = common.nti_gnu) 
                       or (common.targetMachineId = common.nti) then
                       BinExt -> (thisElm.T.Copy).Append -> LinkObj
	            else 
                       BinExt -> (thisElm.T.Copy).Append -> xLinkObj
                   if)
            if)#);
            
        if);
        
        (BetaRun[],userDefinedBetaRun)->addBetaRun;

        (* Put the OBJFILES (also from BUILD) into the link directive *)
        TX.Scan
        (# classExt: ^text;
        do (if thisElm.kind = ObjKind then
               (if common.switch[182] then
                   (* Bytecode: BUILD is somewhat misused for
                    * e.g. JNI wrapper building.
                    * See e.g. BETALIB/javalib/betahelpers.bet.
                    * This results in OBJFILES, that are not
                    * .class files. Ignore these.
                    *)
                   (if true 
                    // isJava then '.class' -> classExt[] 
                    // isClr then'.dll'-> classExt[] 
                    // isPRE then '.prc' -> classExt[]
                    else
                       '\nOBS! asmLinkBody:bytecode:unknown platform' 
                       -> putline;
                       (* -> systemError*)
                   if);
                   (if classExt[] -> (thisElm.T.copy).hasExtension then
                       thisElm.T.copy -> quote -> linkObj
                   if);
                else
                   thisElm.T.copy -> quote -> linkObj
               if);
           if)
        #);
        
        (if not switch182 then
            <<SLOT asmlinkdynamic:descriptor>>; (* solaris hack*)
            
            (* Put the shared libs into the link directive *)
            Libs.scan
            (#
            do (if hasSharedLibs then 
                   thisElm.T.copy-> addSharedLibFile -> linkObj 
               if)
            #);
            
            (* Put the LIBFILES into the link directive *)
            TX.scan
            (#
            do (if thisElm.kind = LibKind then 
                   thisElm.T.copy-> quote -> linkObj
            if)#); 
            
            (* Specify directories needed by LINKOPT libraries *)
            <<SLOT AddLinkDirs: descriptor>>;
            
            (* Put the LINKOPT into the link directive: will this work for MAC? *)
            TX.scan
            (#
            do (if thisElm.kind = LinkOptKind then 
                   thisElm.T.copy -> linkObj (* NO quote here *)
            if)#); 
            
            <<SLOT libraries: descriptor>>;
            
            (*lda[]->putline;*)
        if); (* end of skip *)
        <<SLOT link: descriptor>>;
        ldA[]->AFF.putline;
        <<SLOT linkTrailer:descriptor>>;
     #);
   
   hostMachineType: ^text;
   CWD,        (* current working directory *)
   ldA: ^text; (* to collect arguments to ld or quarker *)
   betaDataFile: ^text;
   resource_met: @boolean;
do &text[]->ldA[];
   machine_type->hostMachineType[];
   '~beta/'->BetaLib[]; 
   TargetMachine -> thisBetarun -> (BetaLib.copy).Append -> betaRunLib[];
   (BetaLib[],thePathhandler.currentDirectory)
     -> thePathHandler.convertFilePath->BetaLib[];
   
   (if demoVersion then 
       'betarun.demo'->(betaRunLib.Copy).Append-> betarun[]
    else
       (if betarun.empty then
           (# BR: @text
           do 'betarun' -> BR;
              (if true 
               // common.switch[69] then 
                  (* use personal edition version *)
                  '_pe' -> BR.append
               // common.switch[80] then
                  (* Unconditional GC debug runtime system *)
                  '_ugc' -> BR.append
               // common.switch[13] then 
                  (* use debug runtime system *)
                  '_debug' -> BR.append
               // common.switch[88] then 
                  (* use full speed runtime system with symbolic debug info *)
                  '_sym' -> BR.append
               // common.switch[31] then 
                  (* use profiling betarun system *)
                  '_pg' -> BR.append
               // common.switch[41] then 
                  (* use valhalla betarun system *)
                  '_v' -> BR.append
              if);
              (if common.switch[64] then 
                  (* multi-tasking - independent of above options *)
                  '_mt' -> BR.append 
              if);
              BR[]->(betaRunLib.Copy).Append-> betarun[]
           #)
        else true->userDefinedBetaRun
       if)
   if);
   (betarun[],thePathhandler.currentDirectory)
     ->thePathHandler.convertFilePath->betarun[];
   
   (if fSwitch.empty then 'switch'-> fSwitch if);
   
   (* The job-file is placed in the code directory; make sure it exists *)
   CreateCodeDirectory;
   
   (* create job-file *)
   ((rootfragment[],thePathhandler.currentDirectory)
     -> thePathHandler.convertFilePath
   ,false)
     -> insertSubDir(#do JobExt->path.append #)
     -> AFF.name; 
   AFF.openWrite;
   
   (* check or create the director for the executable *)
   CreateObjDirectory;
   
   371->trace
   (# full: ^text
   do (rootfragment[],thePathhandler.currentDirectory)
        -> thePathHandler.convertFilePath -> full[];
      '\tFragment file   : '->xT; rootFragment[] -> xT;
      '\n\tFull path       : '->xT; full[] -> xT;
      '\n\tObject file     : '->xT; objName[] -> xT;
      '\n\tCode directory  : '->xT; codeDirectory[] -> xT;
      '\n\tObject file dir : '->xT; objDirectory[] -> xT;
      '\n\tJob file        : '->xT; AFF.name ->xT; xN
   #);
   <<SLOT header: descriptor>>;

   (if nolink then true->common.switch[6] if);
   (if (not common.switch[6]) and (not ('nti' -> hostMachineType.equal)) then
       (* remove old version of objFile*)   
       (true,(asmlink.ExeExt->(objName.Copy).Append))->remove
   if);
   
   (* Assemble (some of) the Beta files *)
   TX.Scan
   (#
   do (if (*switch182 and not (common.switch[184] or common.switch[189])*)
          common.isJVM then 
          (if thisElm.kind = ByteCodeKind then
              thisElm.T.copy->&Assembler;
          if);
       else
          (if ThisElm.assemble then 
              thisElm.T.copy->&Assembler
          if);
      if);
   #);
   
   (* Put possible build commands into the job-file *)
   build.scan
   (# 
   do (if thisElm.directory[] <>  NONE then
          (if CWD[] = NONE then
              thePathHandler.currentDirectory -> CWD[];
          if);
          thisElm.directory[] -> ChangeDirectory;
      if);
      (if verboseLevel < verboseLevel.nothing then
          echo; thisElm.command[] -> quote -> AFF.putLine;
      if);
      thisElm.command[] -> AddCommand
   #);
   (if CWD[] <> NONE then CWD[] -> ChangeDirectory if);
   
   (* Put the make and resource files into the job file *)
   TX.scan
   (# first_done: @boolean;
   do (if thisElm.kind 
       // MakeKind then
          (NOT first_done,thisElm.T) -> make; true->first_done    
       // ResourceKind then
          (if (not common.switch[6]) or ('nti' -> hostMachineType.equal) then
              (* if not link then not resource (except on Windows NT) *)
              (if verboseLevel<verboseLevel.nothing then
                  echo; 'Resource '->AFF.puttext; thisElm.T.copy -> AFF.putLine;
              if);
              (NOT first_done,thisElm.T) -> resource; true->first_done; true -> resource_met;   
          if);
      if);
   #);
   
   (if (common.targetMachineId = common.nti_ms) and resource_met then
       (* Hack indicating that last resource file has been treated *)
       (false, '') -> resource
   if);
   
   (if hasSharedLibs then LinkLibraries if);

   (if not common.switch[6] then
       (if verboseLevel <= verboseLevel.actions then
           (if common.targetMachineId<>common.ppcmac then
               (* ppcmac jobfile prints another message *)
               (if HasSharedLibs then
                   echo;
                   'Linking using shared BETA libraries!\n'->AFF.putText
                else
                   echo;
                   'Linking\n'->AFF.puttext; 
               if)
           if)
       if);
       Linker;
   if);
   
   (if common.switch[6] then
       echo; 
       (if common.targetMachineId
        // common.jvm then
           'Creating library JAR file\n'->AFF.puttext; 
        // common.clr then
           'Creating library DLL directory\n'->AFF.puttext; 
        // common.pre then
           'Creating PRE component\n' -> AFF.puttext;
       else
          '\nLinker: unknown platform' -> putline;
       if);
       Linker;
   if);
   
   <<SLOT trailer:descriptor >>;
   
   (if (not common.switch[18]) (* preserve *)
       and (not common.switch[23]) (* preserve job file *)
       and (betaDataFile[] <> NONE) then
       (true,objFileExtension -> (betadataFile.copy).append) -> Remove;
       (true,dbFileExtension -> (betadataFile.copy).append) -> Remove;
   if);
   AFF.close;

   <<SLOT jobFilePermission:descriptor>>;
   
   L:
     (if (not common.switch[33]) (* -j/--nojob *) then
         (AFF[],common[],infoStream[],messageStream[],
         hostMachineType[], TargetMachine, jobfilemachine[],
         interactiveCompiler)
           -> thisTranslate.JobFileRunner
     if);
#)
