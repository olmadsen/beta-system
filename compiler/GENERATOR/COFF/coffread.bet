ORIGIN 'cofffile';
BODY 'coffreadbody';

(* coffread.bet:
 *   Lowlevel patterns for reading object files in COFF format.
 *
 *   $Id: coffread.bet,v 1.1 2001-05-29 13:25:57 corry Exp $
 *)

--LIB: attributes--

coffreader: cofffile
  (#
     (* File Header *)

     getFilehdr:
       (* Get COFF file header from file - NONE if error *)
       (# hdr: ^filehdr;
          it: @<<SLOT CoffFileGetFilehdr: descriptor>>
       do it;
       exit hdr[]
       #);
     
     (* Optional Header *)

     getAouthdr:
       (* Get optional header from file - NONE if error *)
       (# hdr: ^filehdr;
          it: @<<SLOT CoffFileGetAouthdr: descriptor>>
       do it;
       exit hdr[]
       #);

     (* Section Headers *)

     getScnhdr:
       (* Get a section header from file - NONE if error *)
       (# sh: ^scnhdr;
          sh_inx: @integer (* counted from 0 *);
          it: @<<SLOT CoffFileGetScnhdr: descriptor>>
       enter sh_inx
       do it;
       exit sh[]
       #);

     scanScnhdrs:
       (* Scan through all section headers - INNER called for each *)
       (# current: ^scnhdr;
          current_inx: @integer;
       do <<SLOT CoffFileScanShdrs: descriptor>>
       #);
     
          (* Reading data and text segment *)
     
     getData:
       (* Returns an externally allocated buffer containing the
        * .data segment and the size in bytes of this buffer.
        * After performing this, cache.data_ptr will contain the bytes 
        * from the ".data" segment, and cache.data_hdr will be the 
        * section header for section ".data".
        *)
       (# it: @<<SLOT CoffFileGetData: descriptor>>;
          ptr, size: @integer;
       do it;
       exit (ptr, size)
       #);
     
     getText:
       (* Returns an externally allocated buffer containing the
        * .text segment and the size in bytes of this buffer.
        * After performing this, cache.text_ptr will contain the bytes 
        * from the ".text" segment, and cache.text_hdr will be the 
        * section header for section ".text".
        *)
       (# it: @<<SLOT CoffFileGetText: descriptor>>;
          ptr, size: @integer;
       do it;
       exit (ptr, size)
       #);

     (* Symbol Table *)

     getSyment:
       (* Get an entry from the symbol table - NONE if error *)
       (# sym: ^syment;
          sym_inx: @integer (* counted from 0 *);
          it: @<<SLOT CoffFileGetSyment: descriptor>>
       enter sym_inx
       do it;
       exit sym[]
       #);

     scanSyments:
       (* Scan through all entries in the symbol table.
        * INNER is called for each entry. current is the current entry.
        * current_inx is the index of the symbol. 
        * After performing this, cache.syments will contain the symbols,
        * cache.syments.range will be the number of symbols.
        *)
       (# current: ^syment;
          current_inx: @integer;
       do <<SLOT CoffFileScanSyments: descriptor>>
       #);

     (* Relocation Entries *)

     getDataReloc:
       (* Get a relocation entry for .data - NONE if error *)
       (# rel: ^reloc;
          rel_inx: @integer (* counted from 0 *);
          it: @<<SLOT CoffFileGetDataReloc: descriptor>>
       enter rel_inx
       do it;
       exit rel[]
       #); 
     
     getTextReloc:
       (* Get a relocation entry for .text - NONE if error *)
       (# rel: ^reloc;
          rel_inx: @integer (* counted from 0 *);
          it: @<<SLOT CoffFileGetTextReloc: descriptor>>
       enter rel_inx
       do it;
       exit rel[]
       #); 

     scanDataReloc:
       (* Scan through all reloc entries for .data.
        * INNER is called for each entry. current is the current entry.
        * current_sec is the section being scanned. current_inx is the
        * index into this section.
        * After a complete scan, cache.data_reloc contains the list of 
        * all reloc-entries for .data.
        *)
       (# current: ^reloc;
          current_inx: @integer;
       do <<SLOT CoffFileScanDataReloc: descriptor>>
       #);
     
     scanTextReloc:
       (* Scan through all reloc entries for .text.
        * INNER is called for each entry. current is the current entry.
        * current_sec is the section being scanned. current_inx is the
        * index into this section.
        * After a complete scan, cache.text_reloc contains the list of 
        * all reloc-entries for .text.
        *)
       (# current: ^reloc;
          current_inx: @integer;
       do <<SLOT CoffFileScanTextReloc: descriptor>>
       #);

     (* String Table *)
     
     getString:
       (* Get string from string table - NONE if error.
        * str_inx is index into stringtable.
        *)
       (# str: ^text;
          str_inx: @integer; 
          it: @<<SLOT CoffFileGetStr: descriptor>>
       enter str_inx
       do it;
       exit str[]
       #);
     
     getName:
       (* Decode a string encoded directly or indirectly (via string 
        * table) in name1_4 and name1_8
        *)
       (# name1_4, name5_8: @integer;
          name: ^text;
          it: @<<SLOT CoffFileGetName: descriptor>>
       enter (name1_4, name5_8)
       do it;
       exit name[]
       #);

     cache: @
       (# 
          hdr: ^filehdr;
          scnhdrs: [0]^scnhdr;
          syments: [0]^syment;
          data_reloc:  [0]^reloc;
          text_reloc:  [0]^reloc;
          strings: [0]@char;
          data_ptr: @integer;
          data_hdr: ^scnhdr;
          text_ptr: @integer;
          text_hdr: ^scnhdr;
       #);
     
     <<SLOT CoffReaderLib: attributes>>;
  #);


reloc_type_astext:
  (# type: @integer;
     desc: ^text
  enter type
  <<SLOT CoffRelocTypeAsText: dopart>>
  exit desc[]
  #);

