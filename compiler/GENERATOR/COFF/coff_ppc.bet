ORIGIN 'coff';

(* coff_ms.bet:
 *    Microsoft PE/COFF dependent COFF definitions,
 *    as described in "Microsoft Portable Executable and
 *    Common Object File Format Specification 4.1" from
 *    Microsoft Developer Network Development Library CD October 1995.
 *
 *    $Id: coff_ppc.bet,v 1.5 2002-03-15 13:30:45 corry Exp $
 *) 

--LIB: attributes--

(* From winnt.h *)



(* Abstract:
 * 
 *    This module defines the 32-Bit Windows types and constants that are
 *     defined by NT, but exposed through the Win32 API.
 *)


(* 
 *  Image Format
 *)

(* #include "pshpack1.h" *)

IMAGE_DOS_SIGNATURE:	(# exit 0x5A4D #);      (* MZ *)
IMAGE_OS2_SIGNATURE:	(# exit 0x454E #);      (* NE *)
IMAGE_OS2_SIGNATURE_LE:	(# exit 0x454C #);      (* LE *)
IMAGE_VXD_SIGNATURE:	(# exit 0x454C #);      (* LE *)
IMAGE_NT_SIGNATURE:	(# exit 0x00004550 #);  (* PE00 *)

IMAGE_DOS_HEADER:
  (* DOS .EXE header *)
  (#      
     e_magic: @int16u;                     (* Magic number *)
     e_cblp: @int16u;                      (* Bytes on last page of file *)
     e_cp: @int16u;                        (* Pages in file *)
     e_crlc: @int16u;                      (* Relocations *)
     e_cparhdr: @int16u;                   (* Size of header in paragraphs *)
     e_minalloc: @int16u;                  (* Minimum extra paragraphs needed *)
     e_maxalloc: @int16u;                  (* Maximum extra paragraphs needed *)
     e_ss: @int16u;                        (* Initial (relative) SS value *)
     e_sp: @int16u;                        (* Initial SP value *)
     e_csum: @int16u;                      (* Checksum *)
     e_ip: @int16u;                        (* Initial IP value *)
     e_cs: @int16u;                        (* Initial (relative) CS value *)
     e_lfarlc: @int16u;                    (* File address of relocation table *)
     e_ovno: @int16u;                      (* Overlay number *)
     e_res1, 
     e_res2, 
     e_res3, 
     e_res4: @int16u;  (* Reserved words *)
     e_oemid: @int16u;                     (* OEM identifier (for e_oeminfo) *)
     e_oeminfo: @int16u;                   (* OEM information; e_oemid specific *)
     e_res2_1,
     e_res2_2,
     e_res2_3,
     e_res2_4,
     e_res2_5,
     e_res2_6,
     e_res2_7,
     e_res2_8,
     e_res2_9,
     e_res2_10: @int16u;   (* Reserved words *)
     e_lfanew: @integer;                    (* File address of new exe header *)
  #);

IMAGE_OS2_HEADER:
  (* OS/2 .EXE header *)
  (#      
     ne_magic: @int16u;                    (* Magic number *)
     ne_ver: @char;                      (* Version number *)
     ne_rev: @char;                      (* Revision number *)
     ne_enttab: @int16u;                   (* Offset of Entry Table *)
     ne_cbenttab: @int16u;                 (* Number of bytes in Entry Table *)
     ne_crc: @integer;                      (* Checksum of whole file *)
     ne_flags: @int16u;                    (* Flag word *)
     ne_autodata: @int16u;                 (* Automatic data segment number *)
     ne_heap: @int16u;                     (* Initial heap allocation *)
     ne_stack: @int16u;                    (* Initial stack allocation *)
     ne_csip: @integer;                     (* Initial CS:IP setting *)
     ne_sssp: @integer;                     (* Initial SS:SP setting *)
     ne_cseg: @int16u;                     (* Count of file segments *)
     ne_cmod: @int16u;                     (* Entries in Module Reference Table *)
     ne_cbnrestab: @int16u;                (* Size of non-resident name table *)
     ne_segtab: @int16u;                   (* Offset of Segment Table *)
     ne_rsrctab: @int16u;                  (* Offset of Resource Table *)
     ne_restab: @int16u;                   (* Offset of resident name table *)
     ne_modtab: @int16u;                   (* Offset of Module Reference Table *)
     ne_imptab: @int16u;                   (* Offset of Imported Names Table *)
     ne_nrestab: @integer;                  (* Offset of Non-resident Names Table *)
     ne_cmovent: @int16u;                  (* Count of movable entries *)
     ne_align: @int16u;                    (* Segment alignment shift count *)
     ne_cres: @int16u;                     (* Count of resource segments *)
     ne_exetyp: @char;                   (* Target Operating system *)
     ne_flagsothers: @char;              (* Other .EXE flags *)
     ne_pretthunks: @int16u;               (* offset to return thunks *)
     ne_psegrefbytes: @int16u;             (* offset to segment ref. bytes *)
     ne_swaparea: @int16u;                 (* Minimum code swap area size *)
     ne_expver: @int16u;                   (* Expected Windows version number *)
  #);

IMAGE_VXD_HEADER:
  (* Windows VXD header *)
  (#      
     e32_magic: @int16u;                   (* Magic number *)
     e32_border: @char;                  (* The byte ordering for the VXD *)
     e32_worder: @char;                  (* The word ordering for the VXD *)
     e32_level: @integer;                   (* The EXE format level for now = 0 *)
     e32_cpu: @int16u;                     (* The CPU type *)
     e32_os: @int16u;                      (* The OS type *)
     e32_ver: @integer;                     (* Module version *)
     e32_mflags: @integer;                  (* Module flags *)
     e32_mpages: @integer;                  (* Module # pages *)
     e32_startobj: @integer;                (* Object # for instruction pointer *)
     e32_eip: @integer;                     (* Extended instruction pointer *)
     e32_stackobj: @integer;                (* Object # for stack pointer *)
     e32_esp: @integer;                     (* Extended stack pointer *)
     e32_pagesize: @integer;                (* VXD page size *)
     e32_lastpagesize: @integer;            (* Last page size in VXD *)
     e32_fixupsize: @integer;               (* Fixup section size *)
     e32_fixupsum: @integer;                (* Fixup section checksum *)
     e32_ldrsize: @integer;                 (* Loader section size *)
     e32_ldrsum: @integer;                  (* Loader section checksum *)
     e32_objtab: @integer;                  (* Object table offset *)
     e32_objcnt: @integer;                  (* Number of objects in module *)
     e32_objmap: @integer;                  (* Object page map offset *)
     e32_itermap: @integer;                 (* Object iterated data map offset *)
     e32_rsrctab: @integer;                 (* Offset of Resource Table *)
     e32_rsrccnt: @integer;                 (* Number of resource entries *)
     e32_restab: @integer;                  (* Offset of resident name table *)
     e32_enttab: @integer;                  (* Offset of Entry Table *)
     e32_dirtab: @integer;                  (* Offset of Module Directive Table *)
     e32_dircnt: @integer;                  (* Number of module directives *)
     e32_fpagetab: @integer;                (* Offset of Fixup Page Table *)
     e32_frectab: @integer;                 (* Offset of Fixup Record Table *)
     e32_impmod: @integer;                  (* Offset of Import Module Name Table *)
     e32_impmodcnt: @integer;               (* Number of entries in Import Module Name Table *)
     e32_impproc: @integer;                 (* Offset of Import Procedure Name Table *)
     e32_pagesum: @integer;                 (* Offset of Per-Page Checksum Table *)
     e32_datapage: @integer;                (* Offset of Enumerated Data Pages *)
     e32_preload: @integer;                 (* Number of preload pages *)
     e32_nrestab: @integer;                 (* Offset of Non-resident Names Table *)
     e32_cbnrestab: @integer;               (* Size of Non-resident Name Table *)
     e32_nressum: @integer;                 (* Non-resident Name Table Checksum *)
     e32_autodata: @integer;                (* Object # for automatic data object *)
     e32_debuginfo: @integer;               (* Offset of the debugging information *)
     e32_debuglen: @integer;                (* The length of the debugging info. in bytes *)
     e32_instpreload: @integer;             (* Number of instance pages in preload section of VXD file *)
     e32_instdemand: @integer;              (* Number of instance pages in demand load section of VXD file *)
     e32_heapsize: @integer;                (* Size of heap - for 16-bit apps *)
     e32_res3_1,
     e32_res3_2,
     e32_res3_3: @integer;(* Reserved words *)
     e32_winresoff: @integer;
     e32_winreslen: @integer;
     e32_devid: @int16u;                   (* Device ID for VxD *)
     e32_ddkver: @int16u;                  (* DDK version for VxD *)
  #);

(* File header format. *)

IMAGE_FILE_HEADER: filehdr
  (#
     Machine: (# enter f_magic exit f_magic #);
     NumberOfSections: (# enter f_nscns exit f_nscns #);
     TimeDateStamp: (# enter f_timdat exit f_timdat #);
     PointerToSymbolTable: (# enter f_symptr exit f_symptr #);
     NumberOfSymbols: (# enter f_nsyms exit f_nsyms #);
     SizeOfOptionalHeader: (# enter f_opthdr exit f_opthdr #);
     Characteristics: (# enter f_flags exit f_flags #);
  #);

IMAGE_SIZEOF_FILE_HEADER:	(# exit 20 #);

IMAGE_FILE_RELOCS_STRIPPED:	(# exit 0x0001 #);  (* Relocation info stripped from file. *)
IMAGE_FILE_EXECUTABLE_IMAGE:	(# exit 0x0002 #);  (* File is executable  (i.e. no unresolved externel references). *)
IMAGE_FILE_LINE_NUMS_STRIPPED:	(# exit 0x0004 #);  (* Line nunbers stripped from file. *)
IMAGE_FILE_LOCAL_SYMS_STRIPPED:	(# exit 0x0008 #);  (* Local symbols stripped from file. *)
IMAGE_FILE_BYTES_REVERSED_LO:	(# exit 0x0080 #);  (* Bytes of machine word are reversed. *)
IMAGE_FILE_32BIT_MACHINE:	(# exit 0x0100 #);  (* 32 bit word machine. *)
IMAGE_FILE_DEBUG_STRIPPED:	(# exit 0x0200 #);  (* Debugging info stripped from file in .DBG file *)
IMAGE_FILE_SYSTEM:		(# exit 0x1000 #);  (* System File. *)
IMAGE_FILE_DLL:			(# exit 0x2000 #);  (* File is a DLL. *)
IMAGE_FILE_BYTES_REVERSED_HI:	(# exit 0x8000 #);  (* Bytes of machine word are reversed. *)

IMAGE_FILE_MACHINE_UNKNOWN:	(# exit 0 #);
IMAGE_FILE_MACHINE_I386:	(# exit 0x14c #);   (* Intel 386. *)
IMAGE_FILE_MACHINE_R3000:	(# exit 0x162 #);   (* MIPS little-endian, 0x160 big-endian *)
IMAGE_FILE_MACHINE_R4000:	(# exit 0x166 #);   (* MIPS little-endian *)
IMAGE_FILE_MACHINE_R10000:	(# exit 0x168 #);   (* MIPS little-endian *)
IMAGE_FILE_MACHINE_ALPHA:	(# exit 0x184 #);   (* Alpha_AXP *)
IMAGE_FILE_MACHINE_POWERPC:	(# exit 0x1F0 #);   (* IBM PowerPC Little-Endian *)
IMAGE_FILE_MACHINE_POWERPC_BIG:	(# exit 0x1DF #);   (* PowerPC Bige-Endian ?? *)

(* Directory format. *)

IMAGE_DATA_DIRECTORY:
  (#
     VirtualAddress: @integer;
     Size: @integer;
  #);

IMAGE_NUMBEROF_DIRECTORY_ENTRIES:	(# exit 16 #);


(* Optional header format. *)

IMAGE_OPTIONAL_HEADER:
  (#
     (* Standard fields. *)

     Magic: @int16u;
     MajorLinkerVersion: @char;
     MinorLinkerVersion: @char;
     SizeOfCode: @integer;
     SizeOfInitializedData: @integer;
     SizeOfUninitializedData: @integer;
     AddressOfEntryPoint: @integer;
     BaseOfCode: @integer;
     BaseOfData: @integer;

     (* NT additional fields. *)

     ImageBase: @integer;
     SectionAlignment: @integer;
     FileAlignment: @integer;
     MajorOperatingSystemVersion: @int16u;
     MinorOperatingSystemVersion: @int16u;
     MajorImageVersion: @int16u;
     MinorImageVersion: @int16u;
     MajorSubsystemVersion: @int16u;
     MinorSubsystemVersion: @int16u;
     Reserved1: @integer;
     SizeOfImage: @integer;
     SizeOfHeaders: @integer;
     CheckSum: @integer;
     Subsystem: @int16u;
     DllCharacteristics: @int16u;
     SizeOfStackReserve: @integer;
     SizeOfStackCommit: @integer;
     SizeOfHeapReserve: @integer;
     SizeOfHeapCommit: @integer;
     LoaderFlags: @integer;
     NumberOfRvaAndSizes: @integer;
     DataDirectory1_1: @integer;
     DataDirectory1_2: @integer;
     DataDirectory2_1: @integer;
     DataDirectory2_2: @integer;
     DataDirectory3_1: @integer;
     DataDirectory3_2: @integer;
     DataDirectory4_1: @integer;
     DataDirectory4_2: @integer;
     DataDirectory5_1: @integer;
     DataDirectory5_2: @integer;
     DataDirectory6_1: @integer;
     DataDirectory6_2: @integer;
     DataDirectory7_1: @integer;
     DataDirectory7_2: @integer;
     DataDirectory8_1: @integer;
     DataDirectory8_2: @integer;
     DataDirectory9_1: @integer;
     DataDirectory9_2: @integer;
     DataDirectory10_1: @integer;
     DataDirectory10_2: @integer;
     DataDirectory11_1: @integer;
     DataDirectory11_2: @integer;
     DataDirectory12_1: @integer;
     DataDirectory12_2: @integer;
     DataDirectory13_1: @integer;
     DataDirectory13_2: @integer;
     DataDirectory14_1: @integer;
     DataDirectory14_2: @integer;
     DataDirectory15_1: @integer;
     DataDirectory15_2: @integer;
     DataDirectory16_1: @integer;
     DataDirectory16_2: @integer;
  #);

IMAGE_ROM_OPTIONAL_HEADER:
  (#
     Magic: @int16u;
     MajorLinkerVersion: @char;
     MinorLinkerVersion: @char;
     SizeOfCode: @integer;
     SizeOfInitializedData: @integer;
     SizeOfUninitializedData: @integer;
     AddressOfEntryPoint: @integer;
     BaseOfCode: @integer;
     BaseOfData: @integer;
     BaseOfBss: @integer;
     GprMask: @integer;
     CprMask1: @integer;
     CprMask2: @integer;
     CprMask3: @integer;
     CprMask4: @integer;
     GpValue: @integer;
  #);

IMAGE_SIZEOF_ROM_OPTIONAL_HEADER:	(# exit 56 #);
IMAGE_SIZEOF_STD_OPTIONAL_HEADER:	(# exit 28 #);
IMAGE_SIZEOF_NT_OPTIONAL_HEADER:	(# exit 224 #);

IMAGE_NT_OPTIONAL_HDR_MAGIC:	(# exit 0x10b #);
IMAGE_ROM_OPTIONAL_HDR_MAGIC:	(# exit 0x107 #);

(* IMAGE_NT_HEADERS:
 *   (#
 *     Signature: @integer;
 *     IMAGE_FILE_HEADER FileHeader;
 *     IMAGE_OPTIONAL_HEADER OptionalHeader;
 *   #);
 * 
 * IMAGE_ROM_HEADERS:
 *   (#
 *     IMAGE_FILE_HEADER FileHeader;
 *     IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
 *   #);
 *)

(* Subsystem Values *)

IMAGE_SUBSYSTEM_UNKNOWN:	(# exit 0 #);   (* Unknown subsystem. *)
IMAGE_SUBSYSTEM_NATIVE:	(# exit 1 #);   (* Image doesn't require a subsystem. *)
IMAGE_SUBSYSTEM_WINDOWS_GUI:	(# exit 2 #);   (* Image runs in the Windows GUI subsystem. *)
IMAGE_SUBSYSTEM_WINDOWS_CUI:	(# exit 3 #);   (* Image runs in the Windows character subsystem. *)
IMAGE_SUBSYSTEM_OS2_CUI:	(# exit 5 #);   (* image runs in the OS/2 character subsystem. *)
IMAGE_SUBSYSTEM_POSIX_CUI:	(# exit 7 #);   (* image run  in the Posix character subsystem. *)


(* Directory Entries *)

IMAGE_DIRECTORY_ENTRY_EXPORT:	(# exit 0 #);   (* Export Directory *)
IMAGE_DIRECTORY_ENTRY_IMPORT:	(# exit 1 #);   (* Import Directory *)
IMAGE_DIRECTORY_ENTRY_RESOURCE:	(# exit 2 #);   (* Resource Directory *)
IMAGE_DIRECTORY_ENTRY_EXCEPTION:	(# exit 3 #);   (* Exception Directory *)
IMAGE_DIRECTORY_ENTRY_SECURITY:	(# exit 4 #);   (* Security Directory *)
IMAGE_DIRECTORY_ENTRY_BASERELOC:	(# exit 5 #);   (* Base Relocation Table *)
IMAGE_DIRECTORY_ENTRY_DEBUG:	(# exit 6 #);   (* Debug Directory *)
IMAGE_DIRECTORY_ENTRY_COPYRIGHT:	(# exit 7 #);   (* Description String *)
IMAGE_DIRECTORY_ENTRY_GLOBALPTR:	(# exit 8 #);   (* Machine Value (MIPS GP) *)
IMAGE_DIRECTORY_ENTRY_TLS:	(# exit 9 #);   (* TLS Directory *)
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG:	(# exit 10 #);   (* Load Configuration Directory *)
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:	(# exit 11 #);   (* Bound Import Directory in headers *)
IMAGE_DIRECTORY_ENTRY_IAT:	(# exit 12 #);   (* Import Address Table *)

(* Section header format. *)

IMAGE_SIZEOF_SHORT_NAME:	(# exit 8 #);

IMAGE_SECTION_HEADER: scnhdr
  (#
     Name1_4: (# enter s_name1_4 exit s_name1_4 #);
     Name5_8: (# enter s_name5_8 exit s_name5_8 #);
     PhysicalAddress: (# enter s_paddr exit s_paddr #);
     VirtualAddress: (# enter s_vaddr exit s_vaddr #);
     SizeOfRawData: (# enter s_size exit s_size #);
     PointerToRawData: (# enter s_scnptr exit s_scnptr #);
     PointerToRelocations: (# enter s_relptr exit s_relptr #);
     PointerToLinenumbers: (# enter s_lnnoptr exit s_lnnoptr #);
     NumberOfRelocations: (# enter s_nreloc exit s_nreloc #);
     NumberOfLinenumbers: (# enter s_nlnno exit s_nlnno #);
     Characteristics: (# enter s_flags exit s_flags #);
  #);

IMAGE_SIZEOF_SECTION_HEADER:	(# exit 40 #);

(* Section characteristics. *)

(*      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved. *)
(*      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved. *)
(*      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved. *)
(*      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved. *)
IMAGE_SCN_TYPE_NO_PAD:	(# exit 0x00000008 #);  (* Reserved. *)
(*      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved. *)

IMAGE_SCN_CNT_CODE:	(# exit 0x00000020 #);  (* Section contains code. *)
IMAGE_SCN_CNT_INITIALIZED_DATA:	(# exit 0x00000040 #);  (* Section contains initialized data. *)
IMAGE_SCN_CNT_UNINITIALIZED_DATA:	(# exit 0x00000080 #);  (* Section contains uninitialized data. *)

IMAGE_SCN_LNK_OTHER:	(# exit 0x00000100 #);  (* Reserved. *)
IMAGE_SCN_LNK_INFO:	(# exit 0x00000200 #);  (* Section contains comments or some other type of information. *)
(*      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved. *)
IMAGE_SCN_LNK_REMOVE:	(# exit 0x00000800 #);  (* Section contents will not become part of image. *)
IMAGE_SCN_LNK_COMDAT:	(# exit 0x00001000 #);  (* Section contents comdat. *)
(*                                           0x00002000  // Reserved. *)

(*      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000 *)
IMAGE_SCN_MEM_FARDATA:	(# exit 0x00008000 #);
(*      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000 *)
IMAGE_SCN_MEM_PURGEABLE:	(# exit 0x00020000 #);
IMAGE_SCN_MEM_16BIT:	(# exit 0x00020000 #);
IMAGE_SCN_MEM_LOCKED:	(# exit 0x00040000 #);
IMAGE_SCN_MEM_PRELOAD:	(# exit 0x00080000 #);

IMAGE_SCN_ALIGN_1BYTES:	(# exit 0x00100000 #);  
IMAGE_SCN_ALIGN_2BYTES:	(# exit 0x00200000 #);  
IMAGE_SCN_ALIGN_4BYTES:	(# exit 0x00300000 #);  
IMAGE_SCN_ALIGN_8BYTES:	(# exit 0x00400000 #);  
IMAGE_SCN_ALIGN_16BYTES:	(# exit 0x00500000 #);  (* Default alignment if no others are specified. *)
IMAGE_SCN_ALIGN_32BYTES:	(# exit 0x00600000 #);  
IMAGE_SCN_ALIGN_64BYTES:	(# exit 0x00700000 #);  
(* Unused                                    0x00800000 *)

IMAGE_SCN_LNK_NRELOC_OVFL:	(# exit 0x01000000 #);  (* Section contains extended relocations. *)
IMAGE_SCN_MEM_DISCARDABLE:	(# exit 0x02000000 #);  (* Section can be discarded. *)
IMAGE_SCN_MEM_NOT_CACHED:	(# exit 0x04000000 #);  (* Section is not cachable. *)
IMAGE_SCN_MEM_NOT_PAGED:	(# exit 0x08000000 #);  (* Section is not pageable. *)

(* IMAGE_SCN_MEM_SHARED:	(# exit 0x10000000 #);   Section is shareable.
 * IMAGE_SCN_MEM_EXECUTE:	(# exit 0x20000000 #);   Section is executable.

(*IMAGE_SCN_MEM_READ:	(# exit 0x40000000 #);  ( * Section is readable.
 *IMAGE_SCN_MEM_WRITE:	(# exit 0x80000000 #);  ( * Section is writeable
 * 
 * OLM: old above, new below - difference may be due to endian  differences?
 *)
IMAGE_SCN_MEM_SHARED:	(# exit 0x00000010 #);  (* Section is shareable. *)
IMAGE_SCN_MEM_EXECUTE:	(# exit 0x00000020 #);  (* Section is executable. *)
IMAGE_SCN_MEM_READ:	(# exit 0x00000040 #);  (* Section is readable. *)
IMAGE_SCN_MEM_WRITE:	(# exit 0x00000080 #);  (* Section is writeable. *)

(* Symbol format. *)

IMAGE_SYMBOL: syment
  (* alias for syment in coff.bet *)
  (#
     N1_4: (# enter n_name1_4 exit n_name1_4 #);
     N5_8: (# enter n_name5_8 exit n_name5_8 #);
     Value: (# enter n_value exit n_value #);
     SectionNumber: (# enter n_scnum exit n_scnum #);
     Type: (# enter n_type exit n_type #);
     StorageClass: (# enter n_sclass exit n_sclass #);
     NumberOfAuxSymbols: (# enter n_numaux exit n_numaux #);
  #);
;

IMAGE_SIZEOF_SYMBOL:	(# exit 18 #);

(* Section values. *)

(* Symbols have a section number of the section in which they are *)
(* defined. Otherwise, section numbers have the following meanings: *)

IMAGE_SYM_UNDEFINED: (# exit 0 #);       (* Symbol is undefined or is common. *)
IMAGE_SYM_ABSOLUTE:   (# exit -1 #);       (* Symbol is an absolute value. *)
IMAGE_SYM_DEBUG: (# exit -2 #);        (* Symbol is a special debug item. *)

(* Type (fundamental) values. *)

IMAGE_SYM_TYPE_NULL:	(# exit 0x0000 #);  (* no type. *)
IMAGE_SYM_TYPE_VOID:	(# exit 0x0001 #);  
IMAGE_SYM_TYPE_CHAR:	(# exit 0x0002 #);  (* type character. *)
IMAGE_SYM_TYPE_SHORT:	(# exit 0x0003 #);  (* type short integer. *)
IMAGE_SYM_TYPE_INT:	(# exit 0x0004 #);  
IMAGE_SYM_TYPE_LONG:	(# exit 0x0005 #);  
IMAGE_SYM_TYPE_FLOAT:	(# exit 0x0006 #);  
IMAGE_SYM_TYPE_DOUBLE:	(# exit 0x0007 #);  
IMAGE_SYM_TYPE_STRUCT:	(# exit 0x0008 #);  
IMAGE_SYM_TYPE_UNION:	(# exit 0x0009 #);  
IMAGE_SYM_TYPE_ENUM:	(# exit 0x000A #);  (* enumeration. *)
IMAGE_SYM_TYPE_MOE:	(# exit 0x000B #);  (* member of enumeration. *)
IMAGE_SYM_TYPE_BYTE:	(# exit 0x000C #);  
IMAGE_SYM_TYPE_WORD:	(# exit 0x000D #);  
IMAGE_SYM_TYPE_UINT:	(# exit 0x000E #);  
IMAGE_SYM_TYPE_DWORD:	(# exit 0x000F #);  
IMAGE_SYM_TYPE_PCODE:	(# exit 0x8000 #);  

(* Type (derived) values. *)

IMAGE_SYM_DTYPE_NULL:	(# exit 0 #);       (* no derived type. *)
IMAGE_SYM_DTYPE_POINTER:	(# exit 1 #);       (* pointer. *)
IMAGE_SYM_DTYPE_FUNCTION:	(# exit 2 #);       (* function. *)
IMAGE_SYM_DTYPE_ARRAY:	(# exit 3 #);       (* array. *)

(* Storage classes. *)

(* OLM*)
C_HIDEXT: (#exit 0x6b #);

(* Peter: *)
IMAGE_SYM_CLASS_END_OF_FUNCTION: (# exit -1 #);
IMAGE_SYM_CLASS_NULL:	(# exit 0x0000 #);
IMAGE_SYM_CLASS_AUTOMATIC:	(# exit 0x0001 #);
IMAGE_SYM_CLASS_EXTERNAL:	(# exit 0x0002 #);
IMAGE_SYM_CLASS_STATIC:	(# exit 0x0003 #);
IMAGE_SYM_CLASS_REGISTER:	(# exit 0x0004 #);
IMAGE_SYM_CLASS_EXTERNAL_DEF:	(# exit 0x0005 #);
IMAGE_SYM_CLASS_LABEL:	(# exit 0x0006 #);
IMAGE_SYM_CLASS_UNDEFINED_LABEL:	(# exit 0x0007 #);
IMAGE_SYM_CLASS_MEMBER_OF_STRUCT:	(# exit 0x0008 #);
IMAGE_SYM_CLASS_ARGUMENT:	(# exit 0x0009 #);
IMAGE_SYM_CLASS_STRUCT_TAG:	(# exit 0x000A #);
IMAGE_SYM_CLASS_MEMBER_OF_UNION:	(# exit 0x000B #);
IMAGE_SYM_CLASS_UNION_TAG:	(# exit 0x000C #);
IMAGE_SYM_CLASS_TYPE_DEFINITION:	(# exit 0x000D #);
IMAGE_SYM_CLASS_UNDEFINED_STATIC:	(# exit 0x000E #);
IMAGE_SYM_CLASS_ENUM_TAG:	(# exit 0x000F #);
IMAGE_SYM_CLASS_MEMBER_OF_ENUM:	(# exit 0x0010 #);
IMAGE_SYM_CLASS_REGISTER_PARAM:	(# exit 0x0011 #);
IMAGE_SYM_CLASS_BIT_FIELD:	(# exit 0x0012 #);

IMAGE_SYM_CLASS_FAR_EXTERNAL:	(# exit 0x0044 #);  

IMAGE_SYM_CLASS_BLOCK:	(# exit 0x0064 #);
IMAGE_SYM_CLASS_FUNCTION:	(# exit 0x0065 #);
IMAGE_SYM_CLASS_END_OF_STRUCT:	(# exit 0x0066 #);
IMAGE_SYM_CLASS_FILE:	(# exit 0x0067 #);
(* new *)
IMAGE_SYM_CLASS_SECTION:	(# exit 0x0068 #);
IMAGE_SYM_CLASS_WEAK_EXTERNAL:	(# exit 0x0069 #);

(* type packing constants *)

N_BTMASK:	(# exit 0x000F #);
N_TMASK:	(# exit 0x0030 #);
N_TMASK1:	(# exit 0x00C0 #);
N_TMASK2:	(# exit 0x00F0 #);
N_BTSHFT:	(# exit 4 #);
N_TSHIFT:	(# exit 2 #);

(* MACROS (others defined in coff.bet) *)

(* Basic Type of  x *)
BTYPE: 
  (# x: @integer;
  enter x
  exit ((x) %Band N_BTMASK)
  #);

INCREF: 
  (# x: @integer;
  enter x
  exit 
     (((x %Band (%Bnot N_BTMASK)) %sll N_TSHIFT)) 
     %Bor (IMAGE_SYM_DTYPE_POINTER %sll N_BTSHFT) 
     %Bor (x %Band N_BTMASK)
  #);

DECREF: 
  (# x: @integer;
  enter x
  exit  (((x %srl N_TSHIFT) %Band (%Bnot N_BTMASK)) %Bor (x %Band N_BTMASK))
  #);


(* Auxiliary entry format. *)


(* typedef union _IMAGE_AUX_SYMBOL {
 *     struct {
 *         TagIndex: @integer;                      {* struct, union, or enum tag index *}
 *         union {
 *             struct {
 *                 Linenumber: @int16u;             {* declaration line number *}
 *                 Size: @int16u;                   {* size of struct, union, or enum *}
 *             } LnSz;
 *            TotalSize: @integer;
 *         } Misc;
 *         union {
 *             struct {                            {* if ISFCN, tag, or .bb *}
 *                 PointerToLinenumber: @integer;
 *                 PointerToNextFunction: @integer;
 *             } Function;
 *             struct {                            {* if ISARY, up to 4 dimen. *}
 *                 WORD     Dimension[4];
 *             } Array;
 *         } FcnAry;
 *         TvIndex: @int16u;                        {* tv index *}
 *     } Sym;
 *     struct {
 *         BYTE    Name[IMAGE_SIZEOF_SYMBOL];
 *     } File;
 *     struct {
 *         Length: @integer;                         {* section length *}
 *         NumberOfRelocations: @int16u;            {* number of relocation entries *}
 *         NumberOfLinenumbers: @int16u;            {* number of line numbers *}
 *         CheckSum: @integer;                       {* checksum for communal *}
 *         SHORT   Number;                         {* section number to associate with *}
 *         Selection: @char;                      {* communal selection type *}
 *     } Section;
 * } IMAGE_AUX_SYMBOL;
 *)

IMAGE_AUX_SYMBOL_SECTION: auxent
  (* The only aux symbol I need *)
  (# (* section length *)
     Length:              @long;                               
     (* number of relocation entries *)
     NumberOfRelocations: @short(# pos::(# do  4->value#)#); 
     (* number of line numbers *)
     NumberOfLinenumbers: @short(# pos::(# do  6->value#)#);      
     (* checksum for communal *)
     CheckSum:            @long (# pos::(# do  8->value#)#);                  
     (* section number to associate with *)
     Number:              @short(# pos::(# do 12->value#)#);                   
     (* communal selection type *)
     Selection:           @byte (# pos::(# do 14->value#)#);                    
  #);

IMAGE_SIZEOF_AUX_SYMBOL:	(# exit 18 #);

(* values for x_smtyp below *)

XTY_SD: (#exit 1 #);


(* values for x_smclass *)
XMC_PR: (# exit 0 #); (* text: program code *);
XMC_TC: (# exit 3 #); (* data: General TOC entry *);
XMC_RW: (# exit 5 #); (* data: read/write data *)
XMC_DS: (# exit 10 #); (* data: function descriptor *)
XMC_TC0: (# exit 15 #); (* data: TOC anchor *);

IMAGE_AUX_CSECT_ENTRY: auxent
  (* OLM??*)
  (# x_scnlen:            @long;                               
     (*...*)
     x_parmhash:          @long(# pos::(# do  4->value#)#); 
     (* *)
     x_snhash:            @short(# pos::(# do 8->value#)#);      
     (* *)
     x_smtyp:             @byte(# pos::(# do 10->value#)#);                  
     (*...*)
     x_smclass:           @byte(# pos::(# do 11->value#)#);                   
     (*...*)
     x_stab:              @long(# pos::(# do 12->value#)#);   
     (*...*)
     x_snstab:            @short(# pos::(#do 16->value #)#);
  #);  

(* Communal selection types. *)


IMAGE_COMDAT_SELECT_NODUPLICATES:	(# exit 1 #);
IMAGE_COMDAT_SELECT_ANY:	(# exit 2 #);
IMAGE_COMDAT_SELECT_SAME_SIZE:	(# exit 3 #);
IMAGE_COMDAT_SELECT_EXACT_MATCH:	(# exit 4 #);
IMAGE_COMDAT_SELECT_ASSOCIATIVE:	(# exit 5 #);
IMAGE_COMDAT_SELECT_LARGEST:	(# exit 6 #);
IMAGE_COMDAT_SELECT_NEWEST:	(# exit 7 #);

IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY:	(# exit 1 #);
IMAGE_WEAK_EXTERN_SEARCH_LIBRARY:	(# exit 2 #);
IMAGE_WEAK_EXTERN_SEARCH_ALIAS:	(# exit 3 #);


(* Relocation format.  OLM: eliminated

IMAGE_RELOCATION: reloc
  (#
     VirtualAddress: (# enter r_vaddr exit r_vaddr #);
     RelocCount: 
       (* Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set 
       (# enter r_vaddr exit r_vaddr #);
        SymbolTableIndex: (# enter r_symndx exit r_symndx #);
        Type: (# enter r_type exit r_type #);
  #);
        *)
IMAGE_SIZEOF_RELOCATION:	(# exit 10 #);


(* I386 relocation types. *)


IMAGE_REL_I386_ABSOLUTE:	(# exit 0x0000 #);  (* Reference is absolute, no relocation is necessary *)
IMAGE_REL_I386_DIR16:	(# exit 0x0001 #);  (* Direct 16-bit reference to the symbols virtual address *)
IMAGE_REL_I386_REL16:	(# exit 0x0002 #);  (* PC-relative 16-bit reference to the symbols virtual address *)
IMAGE_REL_I386_DIR32:	(# exit 0x0006 #);  (* Direct 32-bit reference to the symbols virtual address *)
IMAGE_REL_I386_DIR32NB:	(# exit 0x0007 #);  (* Direct 32-bit reference to the symbols virtual address, base not included *)
IMAGE_REL_I386_SEG12:	(# exit 0x0009 #);  (* Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address *)
IMAGE_REL_I386_SECTION:	(# exit 0x000A #);
IMAGE_REL_I386_SECREL:	(# exit 0x000B #);
IMAGE_REL_I386_REL32:	(# exit 0x0014 #);  (* PC-relative 32-bit reference to the symbols virtual address *)


(* MIPS relocation types. *)


IMAGE_REL_MIPS_ABSOLUTE:	(# exit 0x0000 #);  (* Reference is absolute, no relocation is necessary *)
IMAGE_REL_MIPS_REFHALF:	(# exit 0x0001 #);
IMAGE_REL_MIPS_REFWORD:	(# exit 0x0002 #);
IMAGE_REL_MIPS_JMPADDR:	(# exit 0x0003 #);
IMAGE_REL_MIPS_REFHI:	(# exit 0x0004 #);
IMAGE_REL_MIPS_REFLO:	(# exit 0x0005 #);
IMAGE_REL_MIPS_GPREL:	(# exit 0x0006 #);
IMAGE_REL_MIPS_LITERAL:	(# exit 0x0007 #);
IMAGE_REL_MIPS_SECTION:	(# exit 0x000A #);
IMAGE_REL_MIPS_SECREL:	(# exit 0x000B #);
IMAGE_REL_MIPS_SECRELLO:	(# exit 0x000C #);  (* Low 16-bit section relative referemce (used for >32k TLS) *)
IMAGE_REL_MIPS_SECRELHI:	(# exit 0x000D #);  (* High 16-bit section relative reference (used for >32k TLS) *)
IMAGE_REL_MIPS_REFWORDNB:	(# exit 0x0022 #);
IMAGE_REL_MIPS_PAIR:	(# exit 0x0025 #);


(* Alpha Relocation types. *)


IMAGE_REL_ALPHA_ABSOLUTE:	(# exit 0x0000 #);
IMAGE_REL_ALPHA_REFLONG:	(# exit 0x0001 #);
IMAGE_REL_ALPHA_REFQUAD:	(# exit 0x0002 #);
IMAGE_REL_ALPHA_GPREL32:	(# exit 0x0003 #);
IMAGE_REL_ALPHA_LITERAL:	(# exit 0x0004 #);
IMAGE_REL_ALPHA_LITUSE:	(# exit 0x0005 #);
IMAGE_REL_ALPHA_GPDISP:	(# exit 0x0006 #);
IMAGE_REL_ALPHA_BRADDR:	(# exit 0x0007 #);
IMAGE_REL_ALPHA_HINT:	(# exit 0x0008 #);
IMAGE_REL_ALPHA_INLINE_REFLONG:	(# exit 0x0009 #);
IMAGE_REL_ALPHA_REFHI:	(# exit 0x000A #);
IMAGE_REL_ALPHA_REFLO:	(# exit 0x000B #);
IMAGE_REL_ALPHA_PAIR:	(# exit 0x000C #);
IMAGE_REL_ALPHA_MATCH:	(# exit 0x000D #);
IMAGE_REL_ALPHA_SECTION:	(# exit 0x000E #);
IMAGE_REL_ALPHA_SECREL:	(# exit 0x000F #);
IMAGE_REL_ALPHA_REFLONGNB:	(# exit 0x0010 #);
IMAGE_REL_ALPHA_SECRELLO:	(# exit 0x0011 #);  (* Low 16-bit section relative reference *)
IMAGE_REL_ALPHA_SECRELHI:	(# exit 0x0012 #);  (* High 16-bit section relative reference *)


(* OLM: MAC PowerPC relocation types. Just a guess *)
U16: (# exit 0x0f00 #); (* ((16 - 1) << 8) *)
S16: (# exit 0x8f00 #); (* (signed << 15) + ((16 - 1) << 8) *)
S26: (# exit 0x9900 #); (* (signed << 15) + ((26 - 1) << 8) *)
U26: (# exit 0x1900 #); (* (26 -1) << 8 *)
U32: (# exit 0x1f00 #); (* ((32 - 1) << 8) *)
S32: (# exit 0x9f00 #); (* (signed << 15 ) + ((32 - 1) << 8) *)

R_POS: (# exit 0x00 #);
R_TOC: (# exit 0x03 #);
R_BA:  (# exit 0x08 #);
R_RBA: (# exit 0x18 #);
R_BR:  (# exit 0x0a #);

xIMAGE_REL_PPC_ABSOLUTE:(# exit 0x0000 #);  (* NOP *)
xIMAGE_REL_PPC_ADDR32:	(# exit U32+R_POS #);  (* 32-bit address *)
R_BA_s26: (#exit s26+R_BA#); (* 26-bit address, 
                              * shifted left 2 (branch absolute) 
                              * R_BA is NOT supported by PowerPC
                              *)
R_BR_S26: (#exit S26+R_BR#); (* 26-bit PC-relative offset, 
                              * shifted left 2 (branch relative) 
                              *)

xIMAGE_REL_PPC_REFLO:	(#exit S16 + 0x0 #); (* to be defined *)
xIMAGE_REL_PPC_REFHI:	(#exit S16 + 0x0 #); (* to be defined *)
xIMAGE_REL_PPC_TOCREL16:(#exit R_TOC + U16 #);(* 16-bit offset from TOC base *)

(* IBM PowerPC relocation types. *)

IMAGE_REL_PPC_ABSOLUTE:	(# exit 0x0000 #);  (* NOP *)
IMAGE_REL_PPC_ADDR64:	(# exit 0x0001 #);  (* 64-bit address *)
IMAGE_REL_PPC_ADDR32:	(# exit 0x0002 #);  (* 32-bit address *)
IMAGE_REL_PPC_ADDR24:	(# exit 0x0003 #);  (* 26-bit address, shifted left 2 (branch absolute) *)
IMAGE_REL_PPC_ADDR16:	(# exit 0x0004 #);  (* 16-bit address *)
IMAGE_REL_PPC_ADDR14:	(# exit 0x0005 #);  (* 16-bit address, shifted left 2 (load doubleword) *)
IMAGE_REL_PPC_REL24:	(# exit 0x0006 #);  (* 26-bit PC-relative offset, shifted left 2 (branch relative) *)
IMAGE_REL_PPC_REL14:	(# exit 0x0007 #);  (* 16-bit PC-relative offset, shifted left 2 (br cond relative) *)
IMAGE_REL_PPC_TOCREL16:	(# exit 0x0008 #);  (* 16-bit offset from TOC base *)
IMAGE_REL_PPC_TOCREL14:	(# exit 0x0009 #);  (* 16-bit offset from TOC base, shifted left 2 (load doubleword) *)

IMAGE_REL_PPC_ADDR32NB:	(# exit 0x000A #);  (* 32-bit addr w/o image base *)
IMAGE_REL_PPC_SECREL:	(# exit 0x000B #);  (* va of containing section (as in an image sectionhdr) *)
IMAGE_REL_PPC_SECTION:	(# exit 0x000C #);  (* sectionheader number *)
IMAGE_REL_PPC_IFGLUE:	(# exit 0x000D #);  (* substitute TOC restore instruction iff symbol is glue code *)
IMAGE_REL_PPC_IMGLUE:	(# exit 0x000E #);  (* symbol is glue code; virtual address is TOC restore instruction *)
IMAGE_REL_PPC_SECREL16:	(# exit 0x000F #);  (* va of containing section (limited to 16 bits) *)
IMAGE_REL_PPC_REFHI:	(# exit 0x0010 #);
IMAGE_REL_PPC_REFLO:	(# exit 0x0011 #);
IMAGE_REL_PPC_PAIR:	(# exit 0x0012 #);

IMAGE_REL_PPC_TYPEMASK:	(# exit 0x00FF #);  (* mask to isolate above values in IMAGE_RELOCATION.Type *)

(* Flag bits in IMAGE_RELOCATION.TYPE *)

IMAGE_REL_PPC_NEG:	(# exit 0x0100 #);  (* subtract reloc value rather than adding it *)
IMAGE_REL_PPC_BRTAKEN:	(# exit 0x0200 #);  (* fix branch prediction bit to predict branch taken *)
IMAGE_REL_PPC_BRNTAKEN:	(# exit 0x0400 #);  (* fix branch prediction bit to predict branch not taken *)
IMAGE_REL_PPC_TOCDEFN:	(# exit 0x0800 #);  (* toc slot defined in file (or, data in toc) *)


(* Based relocation format. *)


IMAGE_BASE_RELOCATION:
  (#
     VirtualAddress: @integer;
     SizeOfBlock: @integer;
  #);

IMAGE_SIZEOF_BASE_RELOCATION:	(# exit 8 #);


(* Based relocation types. *)

IMAGE_REL_BASED_ABSOLUTE:	(# exit 0 #);
IMAGE_REL_BASED_HIGH:	(# exit 1 #);
IMAGE_REL_BASED_LOW:	(# exit 2 #);
IMAGE_REL_BASED_HIGHLOW:	(# exit 3 #);
IMAGE_REL_BASED_HIGHADJ:	(# exit 4 #);
IMAGE_REL_BASED_MIPS_JMPADDR:	(# exit 5 #);


(* Line number format. *)

IMAGE_LINENUMBER: lineno
  (#
     SymbolTableIndex: (# enter l_symndx exit l_symndx #);  (* Symbol table index of function name if Linenumber is 0. *)
     VirtualAddress: (# enter l_paddr exit l_paddr #);      (* Virtual address of line number. *)
     Linenumber: (# enter l_lnno exit l_lnno #);            (* Line number. *)
  #);

IMAGE_SIZEOF_LINENUMBER:	(# exit 6 #);

(* Archive format. *)

IMAGE_ARCHIVE_START_SIZE:	(# exit 8 #);
IMAGE_ARCHIVE_START: 		(# exit '!<arch>\n' #);
IMAGE_ARCHIVE_END: 		(# exit '`\n' #);
IMAGE_ARCHIVE_PAD: 		(# exit '\n' #);
IMAGE_ARCHIVE_LINKER_MEMBER: 	(# exit '/               ' #);
IMAGE_ARCHIVE_LONGNAMES_MEMBER:	(# exit '' #);

(* IMAGE_ARCHIVE_MEMBER_HEADER:
 *   (#
 *      BYTE     Name[16];                          {* File member name - `/' terminated. *}
 *      BYTE     Date[12];                          {* File member date - decimal. *}
 *      BYTE     UserID[6];                         {* File member user id - decimal. *}
 *      BYTE     GroupID[6];                        {* File member group id - decimal. *}
 *      BYTE     Mode[8];                           {* File member mode - octal. *}
 *      BYTE     Size[10];                          {* File member size - decimal. *}
 *      BYTE     EndHeader[2];                      {* String to end header. *}
 *   #);
 *)

IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR:	(# exit 60 #);


(* 
 * DLL support. 
 *)

(* Export Format *)


IMAGE_EXPORT_DIRECTORY:
  (#
     Characteristics: @integer;
     TimeDateStamp: @integer;
     MajorVersion: @int16u;
     MinorVersion: @int16u;
     Name: @integer;
     Base: @integer;
     NumberOfFunctions: @integer;
     NumberOfNames: @integer;
     AddressOfFunctions: @integer;
     AddressOfNames: @integer;
     AddressOfNameOrdinals: @integer;
  #);


(* Import Format *)


(* IMAGE_IMPORT_BY_NAME:
 *   (#
 *      Hint: @int16u;
 *      BYTE    Name[1];
 *   #);
 *)

IMAGE_THUNK_DATA:
  (#
     u1: @integer;
  #);

IMAGE_ORDINAL_FLAG:	(# exit 0x80000000 #);

IMAGE_SNAP_BY_ORDINAL: 
  (# Ordinal: @integer;
  enter Ordinal
  exit ((Ordinal %Band IMAGE_ORDINAL_FLAG) <> 0)
  #);

IMAGE_ORDINAL: 
  (# Ordinal: @integer;
  enter Ordinal
  exit (Ordinal %Band 0xffff)
  #);

IMAGE_IMPORT_DESCRIPTOR:
  (#
     Characteristics: @integer;                (* 0 for terminating null import descriptor *)
     OriginalFirstThunk: (# enter Characteristics exit Characteristics #);   (* RVA to original unbound IAT *)
     TimeDateStamp: @integer;                  (* 0 if not bound, 
                                                * -1 if bound, and real date\time stamp
                                                *     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) 
                                                * O.W. date/time stamp of DLL bound to (Old BIND) 
                                                *)

     ForwarderChain: @integer;                 (* -1 if no forwarders *)
     Name: @integer;
     FirstThunk: @integer;           (* RVA to IAT (if bound this IAT has actual addresses) *)
  #);


(* New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ] *)

IMAGE_BOUND_IMPORT_DESCRIPTOR:
  (#
     TimeDateStamp: @integer;
     OffsetModuleName: @int16u;
     NumberOfModuleForwarderRefs: @int16u;
     (* Array of zero or more IMAGE_BOUND_FORWARDER_REF follows *)
  #);

IMAGE_BOUND_FORWARDER_REF:
  (#
     TimeDateStamp: @integer;
     OffsetModuleName: @int16u;
     Reserved: @int16u;
  #);



(* Thread Local Storage *)


IMAGE_TLS_DIRECTORY:
  (#
     StartAddressOfRawData: @integer;
     EndAddressOfRawData: @integer;
     AddressOfIndex: @integer;
     AddressOfCallBacks: @integer;
     SizeOfZeroFill: @integer;
     Characteristics: @integer;
  #);



(* Resource Format. *)



(* Resource directory consists of two counts, following by a variable length
 * array of directory entries.  The first count is the number of entries at
 * beginning of the array that have actual names associated with each entry.
 * The entries are in ascending order, case insensitive strings.  The second
 * count is the number of entries that immediately follow the named entries.
 * This second count identifies the number of entries that have 16-bit integer
 * Ids as their name.  These entries are also sorted in ascending order.
 *
 * This structure allows fast lookup by either name or number, but for any
 * given resource entry only one form of lookup is supported, not both.
 * This is consistant with the syntax of the .RC file and the .RES file.
 *)

IMAGE_RESOURCE_DIRECTORY:
  (#
     Characteristics: @integer;
     TimeDateStamp: @integer;
     MajorVersion: @int16u;
     MinorVersion: @int16u;
     NumberOfNamedEntries: @int16u;
     NumberOfIdEntries: @int16u;
  #);

IMAGE_RESOURCE_NAME_IS_STRING:	(# exit 0x80000000 #);
IMAGE_RESOURCE_DATA_IS_DIRECTORY:	(# exit 0x80000000 #);


(* Each directory contains the 32-bit Name of the entry and an offset,
 * relative to the beginning of the resource directory of the data associated
 * with this directory entry.  If the name of the entry is an actual text
 * string instead of an integer Id, then the high order bit of the name field
 * is set to one and the low order 31-bits are an offset, relative to the
 * beginning of the resource directory of the string, which is of type
 * IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
 * low-order 16-bits are the integer Id that identify this resource directory
 * entry. If the directory entry is yet another resource directory (i.e. a
 * subdirectory), then the high order bit of the offset field will be
 * set to indicate this.  Otherwise the high bit is clear and the offset
 * field points to a resource data entry.
 *)


(* IMAGE_RESOURCE_DIRECTORY_ENTRY:
 *   (#
 *     union {
 *         struct {
 *             DWORD NameOffset:31;
 *             DWORD NameIsString:1;
 *         };
 *         Name: @integer;
 *         Id: @int16u;
 *     };
 *     union {
 *         OffsetToData: @integer;
 *         struct {
 *             DWORD   OffsetToDirectory:31;
 *             DWORD   DataIsDirectory:1;
 *         };
 *     };
 *   #);
 *)

(* For resource directory entries that have actual string names, the Name
 * field of the directory entry points to an object of the following type.
 * All of these string objects are stored together after the last resource
 * directory entry and before the first resource data object.  This minimizes
 * the impact of these variable length objects on the alignment of the fixed
 * size directory entry objects. 
 *)


(* IMAGE_RESOURCE_DIRECTORY_STRING:
 *   (#
 *     Length: @int16u;
 *     CHAR    NameString[ 1 ];
 *   #);
 *)

(* IMAGE_RESOURCE_DIR_STRING_U:
 *   (#
 *     Length: @int16u;
 *     WCHAR   NameString[ 1 ];
 *   #);
 *)


(* Each resource data entry describes a leaf node in the resource directory
 * tree.  It contains an offset, relative to the beginning of the resource
 * directory of the data for the resource, a size field that gives the number
 * of bytes of data at that offset, a CodePage that should be used when
 * decoding code point values within the resource data.  Typically for new
 * applications the code page would be the unicode code page.
 *)


IMAGE_RESOURCE_DATA_ENTRY:
  (#
     OffsetToData: @integer;
     Size: @integer;
     CodePage: @integer;
     Reserved: @integer;
  #);


(* Load Configuration Directory Entry *)


IMAGE_LOAD_CONFIG_DIRECTORY:
  (#
     Characteristics: @integer;
     TimeDateStamp: @integer;
     MajorVersion: @int16u;
     MinorVersion: @int16u;
     GlobalFlagsClear: @integer;
     GlobalFlagsSet: @integer;
     CriticalSectionDefaultTimeout: @integer;
     DeCommitFreeBlockThreshold: @integer;
     DeCommitTotalFreeThreshold: @integer;
     LockPrefixTable: @integer;;
     MaximumAllocationSize: @integer;
     VirtualMemoryThreshold: @integer;
     ProcessHeapFlags: @integer;
     Reserved1, 
     Reserved2, 
     Reserved3, 
     Reserved4: @integer;
  #);



(* Function table entry format for MIPS/ALPHA images.  Function table is
 * pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
 * This definition duplicates ones in ntmips.h and ntalpha.h for use
 * by portable image file mungers.
 *)


IMAGE_RUNTIME_FUNCTION_ENTRY:
  (#
     BeginAddress: @integer;
     EndAddress: @integer;
     ExceptionHandler: @integer;
     HandlerData: @integer;
     PrologEndAddress: @integer;
  #);


(* Debug Format *)


IMAGE_DEBUG_DIRECTORY:
  (#
     Characteristics: @integer;
     TimeDateStamp: @integer;
     MajorVersion: @int16u;
     MinorVersion: @int16u;
     Type: @integer;
     SizeOfData: @integer;
     AddressOfRawData: @integer;
     PointerToRawData: @integer;
  #);

IMAGE_DEBUG_TYPE_UNKNOWN:	(# exit 0 #);
IMAGE_DEBUG_TYPE_COFF:	(# exit 1 #);
IMAGE_DEBUG_TYPE_CODEVIEW:	(# exit 2 #);
IMAGE_DEBUG_TYPE_FPO:	(# exit 3 #);
IMAGE_DEBUG_TYPE_MISC:	(# exit 4 #);
IMAGE_DEBUG_TYPE_EXCEPTION:	(# exit 5 #);
IMAGE_DEBUG_TYPE_FIXUP:	(# exit 6 #);
IMAGE_DEBUG_TYPE_OMAP_TO_SRC:	(# exit 7 #);
IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:	(# exit 8 #);

IMAGE_COFF_SYMBOLS_HEADER:
  (#
     NumberOfSymbols: @integer;
     LvaToFirstSymbol: @integer;
     NumberOfLinenumbers: @integer;
     LvaToFirstLinenumber: @integer;
     RvaToFirstByteOfCode: @integer;
     RvaToLastByteOfCode: @integer;
     RvaToFirstByteOfData: @integer;
     RvaToLastByteOfData: @integer;
  #);

FRAME_FPO:	(# exit 0 #);
FRAME_TRAP:	(# exit 1 #);
FRAME_TSS:	(# exit 2 #);
FRAME_NONFPO:	(# exit 3 #);

FPO_DATA:
  (#
     ulOffStart: @integer;             (* offset 1st byte of function code *)
     cbProcSize: @integer;             (* # bytes in function *)
     cdwLocals: @integer;              (* # bytes in locals/4 *)
     cdwParams: @int16u;              (* # bytes in params/4 *)
     bits: @int16u;
     (*    WORD        cbProlog : 8;           {* # bytes in prolog *}
      *    WORD        cbRegs   : 3;           {* # regs saved *}
      *    WORD        fHasSEH  : 1;           {* TRUE if SEH in func *}
      *    WORD        fUseBP   : 1;           {* TRUE if EBP has been allocated *}
      *    WORD        reserved : 1;           {* reserved for future use *}
      *    WORD        cbFrame  : 2;           {* frame type *}
      *)
  #);
SIZEOF_RFPO_DATA:	(# exit 16 #);


IMAGE_DEBUG_MISC_EXENAME:	(# exit 1 #);

(* IMAGE_DEBUG_MISC:
 *   (#
 *     DataType: @integer;               {* type of misc data, see defines *}
 *     Length: @integer;                 {* total length of record, rounded to four *}
 *                                         {* byte multiple. *}
 *     BOOLEAN     Unicode;                {* TRUE if data is unicode string *}
 *     BYTE        Reserved[ 3 ];
 *     BYTE        Data[ 1 ];              {* Actual data *}
 *   #);
 *)


(* Function table extracted from MIPS/ALPHA images.  Does not contain *)
(* information needed only for runtime support.  Just those fields for *)
(* each entry needed by a debugger. *)


IMAGE_FUNCTION_ENTRY:
  (#
     StartingAddress: @integer;
     EndingAddress: @integer;
     EndOfPrologue: @integer;
  #);


(* Debugging information can be stripped from an image file and placed
 * in a separate .DBG file, whose file name part is the same as the
 * image file name part (e.g. symbols for CMD.EXE could be stripped
 * and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
 * flag in the Characteristics field of the file header.  The beginning of
 * the .DBG file contains the following structure which captures certain
 * information from the image file.  This allows a debug to proceed even if
 * the original image file is not accessable.  This header is followed by
 * zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
 * IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
 * the image file contain file offsets relative to the beginning of the
 * .DBG file. 
 *)

(* If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
 * is left in the image file, but not mapped.  This allows a debugger to
 * compute the name of the .DBG file, from the name of the image in the
 * IMAGE_DEBUG_MISC structure. 
 *)


IMAGE_SEPARATE_DEBUG_HEADER:
  (#
     Signature: @int16u;
     Flags: @int16u;
     Machine: @int16u;
     Characteristics: @int16u;
     TimeDateStamp: @integer;
     CheckSum: @integer;
     ImageBase: @integer;
     SizeOfImage: @integer;
     NumberOfSections: @integer;
     ExportedNamesSize: @integer;
     DebugDirectorySize: @integer;
     Reserved1,
     Reserved2,
     Reserved3,
     Reserved4 :@integer;  (* Note: reserved1 is actually the section alignment *)
  #);

IMAGE_SEPARATE_DEBUG_SIGNATURE:	(# exit 0x4944 #);

(* #include "poppack.h" *)


(* 
 * End Image Format
 *)

