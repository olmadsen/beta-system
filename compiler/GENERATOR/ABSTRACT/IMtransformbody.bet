ORIGIN 'IMmachinebody';
-- IntermediateMachinelib: Attributes --
OptimizeRefAsg:
  (# graph:^IntermachineBBgraph;
     cn: ^IntermachineBBgraph.realnode;
     ar:^adrregoperand;
     ldval,stval:^graph.realnode;
     (*     aress:^AdrRegOpEssence;*)
     callreg:(# exit 2 #);
     thisdp: ^Idopart;
  enter thisdp[]
  do thisdp.graph[]->graph[];
     graph.codescan
     (# objincallreg:@boolean;
     do false->objincallreg;
        curr.realgraph[]->cn[];
        l:(if cn[]<>none then
              (if (cn.inst.opcode = ICallAlloPrim) and cn.inst.bool then
                  true->objincallreg;
               else
                  (if (*(cn.inst.writereg1[]<>none) and *)
                      (cn.inst.writereg = callreg) then 
                      false->objinCallReg 
                  if);
                  (if (cn.inst.opcode = IdoAsgRefAdr) and (not cn.inst.bool) 
                      and (cn.inst.readReg=callreg) then
                      &adrregoperand[]->ar[];
                      graph.regstop+1->graph.regstop->ar->putint;
                      (if graph.regstop>=graph.regs.range then
                          4->graph.regs.extend
                      if);
                      adrReg->graph.regs[ar];
                      '\n+++++ar.createEssence->aress[]' -> putline;
                      
                      (* ar.createEssence->aress[];*)

                      
                      &graph.realnode[]->ldval[];
                      IldVal->ldVal.type;
                      (* aress[]->ldVal.ess2[]->ldVal.writereg1[];
                       cn.inst.readreg2[]->ldVal.ess1[]->ldVal.readReg[];
                       *)
                      &graph.realnode[]->stval[];
                      IstVal->stval.type;
                      (* aress[]->stVal.ess1[]->stVal.readReg[];
                       cn.inst.readReg[]->stVal.ess2[]->stVal.readreg2[];
                       cn.inst.const2->stval.const2;
                       *)
                      
                      (none, stval[],cn[])->graph.insertRealNodeBefore;
                      (none, ldval[],stval[])->graph.insertRealNodeBefore;
                      cn.next[](*chkheap*)->graph.removerealnode;
                      cn[]->graph.removerealnode
                      
                  if)                  
              if);
              cn.next[]->cn[];
              restart l
          if)
     #)
  #);

--analysedp:dopart--
do (if common.switch[311] then
       'Analyzing dopart: %s\n'
         ->screen.putformat (#  do thisdp.name[]->s #)
   if);
   thisdp.graph.buildgraph;

   (if not common.switch[121] then
       '--ConstRepCheck'->(*lpl*)screen.puttext;
       cr.initialize;
       '--cr.initialize done'->(*lpl*)screen.puttext;
       thisdp.graph[]->cr.analyseGraph;
       '++++ cr.transform is missing!' -> putline;
       (*cr.transform;*)
       '--PeepHole1'->(*lpl*)screen.puttext;
       thisdp.graph[]->ph;
       av.initialize;
       '--Available exp'->(*opl*)screen.puttext;
       thisdp.graph[]->av.analyseGraph;
       '----AV transform'->(*opl*)screen.puttext;
       (if not common.switch[87] then av.transform; av.transform2 if);
       (if common.switch[250] then 
           thisdp[]->OptimizeRefAsg;
           thisdp.graph[]->ph
       if)
   if);
   (if IMtrace_low then '--LiveRegs'->(*lpl*)screen.puttext;  if);
   thisdp.graph[]->liveRegs.analyseGraph; 
   liveRegs.thisAnalysis[]->thisdp.lastanalysis[];
   (* colorinf.. uses lastanalysis *)
   (if not common.switch[121] then
       (if IMtrace_low then 
           '----LiveRegs transform'->(*lpl*)screen.puttext 
       if);
       (if not common.switch[122] then liveRegs.transform if);
       thisdp.graph[]->ph2;
       thisdp.graph[]->liveRegs.analysegraph
   if); 
   liveRegs.thisAnalysis[]->thisdp.liveAnalysis[];
   (* FGCHERE *)
   (if IMtrace_low then
       '--ColorRegs'->(*lpt*)screen.puttext;
       thisdp.name[]->(*lpl*)screen.putline;
   if);
   (# c:@char;
      colorRegs:
        (# restart_CR:@boolean;
           isSpilled:[1]@boolean;
           initialized:@boolean;
           copymemoryCells:@integer;
        do
           (if not initialized then 
               thisdp.graph.regs.range->isSpilled.new;
               true->isSpilled[1];
               true->isSpilled[2];
               true->initialized
           if);
           false->restart_CR;
           thisdp[]->colorInterferenceGraph
           (# 
              setup::
                (#
                do copymemoryCells->memoryCellOffset;
                #);
              allowSpill::
                (# 
                do (* 'AllowSpil on %d\n'->putformat(# do regno->d #); *)
                   not isSpilled[regno]->result
                #);
              insertSpills:
                (# reg:@integer;
                   graph:^IntermachineBBgraph;
                   allocRegister:
                     (# type:@integer;
                        regno,regstop:@integer
                     enter type
                     do graph.regsTop->regstop;
                        (if regstop = graph.regs.range then
                            8->graph.regs.extend;
                            8->graph.primregs.extend;
                            8->graph.preColor.extend;
                            8->isSpilled.extend
                        if);
                        regstop+1->regstop;
                        type->graph.regs[regstop];
                        regstop->graph.regstop;
                        true->isSpilled[regstop];
                     exit regstop
                     #)
                enter reg
                do true->isSpilled[reg];
                   (* 'insertSpills on %d\n'->putformat(# do reg->d #); *)
                   thisdp.graph[]->graph[];

                   thisDp.graph.BBcodescan
		   (# ldReg,stReg:^graph.realnode;
                      cn: ^IntermachineBBgraph.realnode;
                      BI,newBI:^BackendInstruction;
                      newRegNo:@integer;
                   do current[]->cn[];
                      cn.inst[]->BI[];
                      (if cn.type<>ILoadSpilledDataReg then
                          (if (reg=BI.writeReg) then
                              
                              (* allocate new register number *)
                              graph.regs[reg]->allocRegister->newRegNo;
                              
                              newRegno->BI.writeReg;
                              (* insert ISpillDataReg after *)
                              &graph.realnode[]->stReg[];
                              &BackendInstruction[]->newBI[]->stReg.inst[];
                              nodes[reg].rn->newBI.imm;
                              nodes[reg].type->newBi.type;
                              
                              ISpillDataReg -> streg.type;
                              newRegNo -> newBi.readreg;
                              (stReg[],cn[])->graph.insertRealNodeAfter;
                              (*'Load Exchanged register %d with new register %d, cell =%d\n'->putformat 
                               (# do reg->d ; newregno->d; newBi.imm->d #) *) 
                          if)
                      if);
                      (if cn.type<>ISpillDataReg then
                          (if reg
                           //BI.readReg
                           //BI.readReg2
                           //BI.readReg3
                           //BI.inxreg then
                              
                              (* allocate new register number *)
                              graph.regs[reg]->allocRegister->newRegNo;

                              (* insert ILoadSpilledDataReg before *)
                              &graph.realnode[]->ldReg[];
                              &BackendInstruction[]->newBI[]->ldReg.inst[];
                              
                              ILoadSpilledDataReg -> ldReg.type;
                              newRegNo -> newBI.writeReg;
                              nodes[reg].rn->newBI.imm;
                              nodes[reg].type->newBi.type;
                              
                              (curr[], ldReg[],cn[])->graph.insertRealNodeBefore;
                              (if reg
                               //BI.readReg then newRegNo -> BI.readReg
                               //BI.readReg2 then newRegNo -> BI.readReg2
                               //BI.readReg3 then newRegNo -> BI.readReg3
                               //BI.inxreg then newRegNo -> BI.inxReg
                              if);
                              (*'Store Exchanged register %d with new register %d, cell=%d\n'->putformat 
                               (# do reg->d ; newregno->d; newBi.imm->d #)  *)
                          if)
                      if)
                   #)
                #)
           do (*'SPILLING'->putline;*)
              (for spillnumber:memoryCells repeat
                   (*'SPILLING Register: %d\n'->putformat(# do inmemorycells[spillnumber]->d #);   *)

                   inmemorycells[spillnumber]->insertSpills;
                   thisdp.graph[]->liveRegs.analysegraph;
                   liveRegs.thisAnalysis[]->thisdp.liveAnalysis[];
                   liveRegs.thisAnalysis[]->thisdp.lastanalysis[];

                   (* IFragmentSet.dumpvcg;   *)
              for);
              true->restart_CR;
              memoryCells+copymemoryCells->copymemoryCells;
           #);
           (if restart_CR then restart colorRegs if)
        #)
   do colorRegs
   #);
   
   (if not backend.cap.isIntel then
       thisdp[]->ca.setdp;
       thisdp.graph[]->ca.analyseGraph;
       ca.thisAnalysis[]->thisdp.clearAnalysis[]; 
   if);
   (if false then
       (if common.switch[125] then
           cr.thisAnalysis[]->thisdp.lastanalysis[]
        else
           av.thisAnalysis[]->thisdp.lastAnalysis[]
       if)
   if)
--analysegp:DoPart--
do
   (*  'Analyzing gpart: %s\n'->lpf (#  do thisgp.name[]->s #);*)
   thisgp.graph.buildgraph;
   (if not common.switch[121] then
       thisgp.graph[]->ph
   if);
   thisgp.graph[]->liveRegs.analyseGraph;
   liveRegs.thisAnalysis[]->thisgp.lastanalysis[]->thisgp.liveAnalysis[];
   
   (if thisgp.graph.isleaf and (thisgp.graph.regstop<7) then
       true->thisgp.codeAsLeaf;
       thisgp[]->colorSimpleLeafRoutine
    else
       thisgp[]->colorInterferenceGraph
   if);
   
   thisgp[]->ca.setdp;
   thisgp.graph[]->ca.analyseGraph;
   ca.thisAnalysis[]->thisgp.clearAnalysis[] 





