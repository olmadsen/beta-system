ORIGIN 'IMmachinebody';
-- IntermediateMachinelib: Attributes --
OptimizeRefAsg:
  (# graph:^IntermachineBBgraph;
     cn: ^IntermachineBBgraph.realnode;
     ar:^adrregoperand;
     ldval,stval:^graph.realnode;
     (*     aress:^AdrRegOpEssence;*)
     callreg:(# exit 2 #);
     thisdp: ^Idopart;
  enter thisdp[]
  do thisdp.graph[]->graph[];
     graph.codescan
     (# objincallreg:@boolean;
     do false->objincallreg;
        curr.realgraph[]->cn[];
        l:(if cn[]<>none then
              (if (cn.inst.opcode = ICallAlloPrim) and cn.inst.bool then
                  true->objincallreg;
               else
                  (if (*(cn.inst.writereg1[]<>none) and *)
                      (cn.inst.writereg = callreg) then 
                      false->objinCallReg 
                  if);
                  (if (cn.inst.opcode = IdoAsgRefAdr) and (not cn.inst.bool) 
                      and (cn.inst.readReg=callreg) then
                      &adrregoperand[]->ar[];
                      graph.regstop+1->graph.regstop->ar->putint;
                      (if graph.regstop>=graph.regs.range then
                          4->graph.regs.extend
                      if);
                      adrReg->graph.regs[ar];
                      '\n+++++ar.createEssence->aress[]' -> putline;
                      
                      (* ar.createEssence->aress[];*)

                      
                      &graph.realnode[]->ldval[];
                      IldVal->ldVal.type;
                      (* aress[]->ldVal.ess2[]->ldVal.writereg1[];
                       cn.inst.readreg2[]->ldVal.ess1[]->ldVal.readReg[];
                       *)
                      &graph.realnode[]->stval[];
                      IstVal->stval.type;
                      (* aress[]->stVal.ess1[]->stVal.readReg[];
                       cn.inst.readReg[]->stVal.ess2[]->stVal.readreg2[];
                       cn.inst.const2->stval.const2;
                       *)
                      
                      (stval[],cn[])->graph.insertRealNodeBefore;
                      (ldval[],stval[])->graph.insertRealNodeBefore;
                      cn.next[](*chkheap*)->graph.removerealnode;
                      cn[]->graph.removerealnode
                      
                  if)                  
              if);
              cn.next[]->cn[];
              restart l
          if)
     #)
  #);

--analysedp:dopart--
do (if common.switch[311] then
       'Analyzing dopart: %s\n'
         ->screen.putformat (#  do thisdp.name[]->s #)
   if);
   thisdp.graph.buildgraph;

   (if not common.switch[121] then
       '--ConstRepCheck'->(*lpl*)screen.puttext;
       cr.initialize;
       '--cr.initialize done'->(*lpl*)screen.puttext;
       thisdp.graph[]->cr.analyseGraph;
       '++++ cr.transform is missing!' -> putline;
       (*cr.transform;*)
       '--PeepHole1'->(*lpl*)screen.puttext;
       thisdp.graph[]->ph;
       av.initialize;
       '--Available exp'->(*opl*)screen.puttext;
       thisdp.graph[]->av.analyseGraph;
       '----AV transform'->(*opl*)screen.puttext;
       (if not common.switch[87] then av.transform; av.transform2 if);
       (if common.switch[250] then 
           thisdp[]->OptimizeRefAsg;
           thisdp.graph[]->ph
       if)
   if);
   (if IMtrace_low then '--LiveRegs'->(*lpl*)screen.puttext;  if);
   thisdp.graph[]->liveRegs.analyseGraph; 
   liveRegs.thisAnalysis[]->thisdp.lastanalysis[];
   (* colorinf.. uses lastanalysis *)
   (if not common.switch[121] then
       (if IMtrace_low then 
           '----LiveRegs transform'->(*lpl*)screen.puttext 
       if);
       (if not common.switch[122] then liveRegs.transform if);
       thisdp.graph[]->ph2;
       thisdp.graph[]->liveRegs.analysegraph
   if); 
   liveRegs.thisAnalysis[]->thisdp.liveAnalysis[];
   (if IMtrace_low then
       '--ColorRegs'->(*lpt*)screen.puttext;
       thisdp.name[]->(*lpl*)screen.putline;
   if);
   (# c:@char;
      colorRegs:
        (# restart_CR:@boolean;
           isSpilled:[1]@boolean;
           initialized:@boolean;
        do
           (if not initialized then 
               thisdp.graph.regstop->isSpilled.new;
               true->initialized
           if);
           false->restart_CR;
           thisdp[]->colorInterferenceGraph
           (# 
              allowSpill::
                (# 
                do (* 'AllowSpil on %d\n'->putformat(# do regno->d #); *)
                   not isSpilled[regno]->result
                #);
              insertSpills:
                (# reg:@integer;
                   graph:^IntermachineBBgraph;
                enter reg
                do true->isSpilled[reg];
                   (* 'insertSpills on %d\n'->putformat(# do reg->d #); *)
                   thisdp.graph[]->graph[];

                   thisDp.graph.BBcodescan
		   (# ldReg,stReg:^graph.realnode;
                      cn: ^IntermachineBBgraph.realnode;
                      BI,newBI:^BackendInstruction;

                   do current[]->cn[];
                      cn.inst[]->BI[];
                      (if cn.type<>ILoadSpilledDataReg then
                          (if (reg=BI.writeReg) then
                              (* insert ISpillDataReg after *)
                              &graph.realnode[]->stReg[];
                              &BackendInstruction[]->newBI[]->stReg.inst[];
                              nodes[reg].rn->newBI.imm;
                              nodes[reg].type->newBi.type;
                              
                              ISpillDataReg -> streg.type;
                              reg -> newBi.readreg;
                              (stReg[],cn[])->graph.insertRealNodeAfter
                          if)
                      if);
                      (if cn.type<>ISpillDataReg then
                          (if reg
                           //BI.readReg
                           //BI.readReg2
                           //BI.readReg3
                           //BI.inxreg then
                              (* insert ILoadSpilledDataReg before *)
                              &graph.realnode[]->ldReg[];
                              &BackendInstruction[]->newBI[]->ldReg.inst[];
                              
                              ILoadSpilledDataReg -> ldReg.type;
                              reg -> newBI.writeReg;
                              nodes[reg].rn->newBI.imm;
                              nodes[reg].type->newBi.type;
                              
                              (ldReg[],cn[])->graph.insertRealNodeBefore
                          if)
                      if)
                   #)
                #)
           do (for spillnumber:memoryCells repeat
                   (* 'SPILLING Register: %d\n '->putformat(# do inmemorycells[spillnumber]->d #); *)

                   inmemorycells[spillnumber]->insertSpills;
                   thisdp.graph[]->liveRegs.analysegraph;
                   liveRegs.thisAnalysis[]->thisdp.liveAnalysis[];
                   liveRegs.thisAnalysis[]->thisdp.lastanalysis[];

                   (* IFragmentSet.dumpvcg;   *)
              for);
              true->restart_CR
           #);
           (if restart_CR then restart colorRegs if)
        #)
   do colorRegs
   #);
   
   (if not backend.cap.isIntel then
       thisdp[]->ca.setdp;
       thisdp.graph[]->ca.analyseGraph;
       ca.thisAnalysis[]->thisdp.clearAnalysis[]; 
   if);
   (if false then
       (if common.switch[125] then
           cr.thisAnalysis[]->thisdp.lastanalysis[]
        else
           av.thisAnalysis[]->thisdp.lastAnalysis[]
       if)
   if)
--analysegp:DoPart--
do
   (*  'Analyzing gpart: %s\n'->lpf (#  do thisgp.name[]->s #);*)
   thisgp.graph.buildgraph;
   (if not common.switch[121] then
       thisgp.graph[]->ph
   if);
   thisgp.graph[]->liveRegs.analyseGraph;
   liveRegs.thisAnalysis[]->thisgp.lastanalysis[]->thisgp.liveAnalysis[];
   
   (if thisgp.graph.isleaf and (thisgp.graph.regstop<7) then
       true->thisgp.codeAsLeaf;
       thisgp[]->colorSimpleLeafRoutine
    else
       thisgp[]->colorInterferenceGraph
   if);
   
   thisgp[]->ca.setdp;
   thisgp.graph[]->ca.analyseGraph;
   ca.thisAnalysis[]->thisgp.clearAnalysis[] 





