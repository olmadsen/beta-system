ORIGIN '~beta/basiclib/betaenv';
--lib:attributes--
(* Emacs code to fix them all:
  (defun fix-constant ()
  (interactive)
  (let ((cstCounter 1))
    (while t
      (search-forward-regexp "exit[ ]+-?[0-9]+[ ]*#")
      (replace-match (format "exit %d #" cstCounter))
      (setq cstCounter (1+ cstCounter)))))
 * 
 * Use: eval-region on it, then set cursor at instr to get index 1
 * (Inop for now), M-X fix-constant, and it's fixed...
 *)
(* constants *)
(* local label constants *)
descLocal: (#  exit 0 #);
codeLocal: (#  exit 1 #);
codeToData: (#  exit 2 #);
interFragment: (#  exit 3 #);
caseStart: (#  exit 4 #);
caseEntry: (#  exit 5 #);
caseEnd: (#  exit 6 #);
dataLocal: (#  exit 7 #);
dataToCode: (#  exit 8 #);


(* Special Nodes *)
IEntryNode: (# exit -1 #);
IExitNode: (# exit -2 #);
(* register operations *)
Inop: (#  exit 1 #);
IldCst: (#  exit 2 #);
IstCst: (#  exit 3 #);
IldvalFromLab: (# exit 4 #);
IstValInLab: (# exit 5 #);
IldVal: (# exit 6 #);
IldValInx: (#  exit 7 #);
IstVal: (#  exit 8 #);
IstValInx: (#  exit 9 #);
IcpReg: (#  exit 10 #);
IstValInText: (#  exit 11 #);
IdoAsgRefAdr: (#  exit 12 #);
IdoAsgRefReg: (#  exit 13 #);
IChkHeap: (#  exit 14 #);
(* Arithmetic *)
IgAddImm: (#  exit 15 #);
IgAddReg: (#  exit 16 #);
IAddMem: (#  exit 17 #);


IgNeg: (#  exit 18 #);
IgSubImm: (#  exit 19 #);
IgSubReg: (#  exit 20 #);
IgMultImm: (#  exit 21 #);
IgMultReg: (#  exit 22 #);
IgDIVImm: (#  exit 23 #);
IgDIVReg: (#  exit 24 #);
IgOrImm: (#  exit 25 #);
IgOrReg: (#  exit 26 #);
IgAndImm: (#  exit 27 #);
IgAndReg: (#  exit 28 #);
IgXorImm: (#  exit 29 #);
IgXorReg: (#  exit 30 #);
IgAndNImm: (#  exit 31 #);
IgAndNReg: (#  exit 32 #);
IgNot: (#  exit 33 #);
IlogNot: (#  exit 34 #);
IgCmpImm: (#  exit 35 #);
IgCmpReg: (#  exit 36 #);
(* Bit operations *)
ISignExtByte: (#  exit 37 #);
ISignExtWord: (#  exit 38 #);
IgetBits: (#  exit 39 #);
IGetSignedBits: (#  exit 40 #);
IgGetBits: (#  exit 41 #);
IgGetSignedBits: (#  exit 42 #);
IputBits: (#  exit 43 #);
IgPutBits: (#  exit 44 #);
IByteSwap: (#  exit 45 #);
IgGetDataByte: (#  exit 46 #);
IgGetDataWord: (#  exit 47 #);
IarithShiftLeftImm: (#  exit 48 #);
IarithShiftLeftReg: (#  exit 49 #);
IlogicalShiftLeftImm: (#  exit 50 #);
IlogicalShiftLeftReg: (#  exit 51 #);
IarithShiftrightImm: (#  exit 52 #);
IarithShiftrightReg: (#  exit 53 #);
IlogicalShiftRightImm: (#  exit 54 #);
IlogicalShiftRightReg: (#  exit 55 #);
IrotateLeftImm: (#  exit 56 #);
IrotateLeftReg: (#  exit 57 #);
IrotateRightImm: (#  exit 58 #);
IrotateRightReg: (#  exit 59 #);

IBeginLabel: (#  exit 60 #);
IFreeLabel: (#  exit 61 #);
IEndLabel: (#  exit 62 #);
ISaveInnerReturn: (#  exit 63 #);
IReturnInner: (#  exit 64 #);
IEmitTextConst: (#  exit 65 #);
Iglea: (#  exit 66 #);
IgleaInx: (# exit 67 #);
IgleaLabel: (#  exit 68 #);
IgleaText: (# exit 69 #); 
IleaToPrimReg: (#  exit 70 #);
IgClr: (#  exit 71 #);
IpushAdr: (#  exit 72 #);
IPush: (#  exit 73 #);
IPop: (#  exit 74 #);
IPushThisOrCall: (#  exit 75 #);
IpopThisOrCall: (#  exit 76 #);
IsetTop: (#  exit 77 #);
IChkIndex: (#  exit 78 #);
IcmpToBool: (#  exit 79 #);

(* Floating point operations *)
IfloatConst: (#  exit 80 #);
Iint2float: (#  exit 81 #);
IintReg2float: (#  exit 82 #);
Ifloat2int: (#  exit 83 #);
IcmpToBoolFloat: (#  exit 84 #);
IpopFStack: (#  exit 85 #);
IcmpFloat: (#  exit 86 #);
IaddFloat: (#  exit 87 #);
IsubFloat: (#  exit 88 #);
ImulFloat: (#  exit 89 #);
IdivFloat: (#  exit 90 #);
InegFloat: (#  exit 91 #);
(* concurrency not used? *)
Ilock: (#  exit 92 #);
(* register Allocation *)
ISpillDataReg: (# exit 93 #);
ILoadSpilledDataReg: (# exit 94 #);
IFreeAdr: (#  exit 95 #);
IFreeData: (#  exit 96 #);
IReleaseReg: (#  exit 97 #);
IthisO: (#  exit 98 #);
IcallO: (#  exit 99 #);
IDecrCallReg: (#  exit 100 #);
IGetCallReg: (#  exit 101 #);
IFreeCallReg: (#  exit 102 #);
CallRegInPrimReg2I: (#  exit 103 #);
IGetOriginReg: (#  exit 104 #);
IFreeOriginReg: (#  exit 105 #);
IDataRegMax: (#  exit 106 #);
INoOfFreeDataReg: (#  exit 107 #);
IDumpReg: (#  exit 108 #);
IPushReg: (#  exit 109 #);
IPopReg: (#  exit 110 #);
IPushDataReg: (#  exit 111 #);
IPopDataReg: (#  exit 112 #);
IPushFloatReg: (#  exit 113 #);
IPopFloatReg: (#  exit 114 #);
ItstNone: (#  exit 115 #);
Itrap: (#  exit 116 #);
Ireturn: (# exit 117 #);
IsaveReturn:(# exit 118 #);
Irts:(# exit 119 #);
Ilabel:(# exit 120 #);
ISaveReg:(# exit 121 #);
IRestoreReg:(# exit 122 #);
IGetPRimRes:(# exit 123 #);
IChkConstIndex: (# exit 124 #);
ILoadMemoryRegister:(# exit 125 #);
IStoreMemoryRegister:(# exit 126 #);

(* Control Flow operations *)
(* external (out of dopart) *)
callInstruction:(# exit 127 #);
IjsrTable: (#  exit 128 #);
IjmpTlong: (#  exit 129 #);
IjmpT: (#  exit 130 #);
IjsrT: (#  exit 131 #);
IjsrReg: (#  exit 132 #);
IjmpReg: (#  exit 133 #);
IgJsr: (#  exit 134 #);
IjsrTableTest: (# exit 135 #);

(* local *)
localjumpnr:(# exit 136 #);
IChkCase: (#  exit 137 #);
IDeclareAddress: (# exit 138 #);
IjumpIfTrue: (#  exit 139 #);
IgBeq: (#  exit 140 #);
IgBne: (#  exit 141 #);
IgBge: (#  exit 142 #);
IgBae: (#  exit 143 #);
IgBle: (#  exit 144 #);
IgBbe: (#  exit 145 #);
IgBgt: (#  exit 146 #);
IgBab: (#  exit 147 #);
IgBlt: (#  exit 148 #);
IgBbl: (#  exit 149 #);
IcmpAndJmp: (#  exit 150 #);
IcmpAndJmpImm: (#  exit 151 #);
IcmpBoolAndJmp: (#  exit 152 #);
IcmpAndJmpFloat: (#  exit 153 #);
IfBeq: (#  exit 154 #);
IfBge: (#  exit 155 #);
IfBle: (#  exit 156 #);
IfBne: (#  exit 157 #);
IfBgt: (#  exit 158 #);
IfBlt: (#  exit 159 #);

(* local jump allways *)
localjumpallways:(# exit 160 #);
IgJmp: (#  exit 161 #);



(* RuntimeCalls & externals *)
runtimecalls:(# exit 162 #);
ICallPrim: (# exit 163 #);
ICallAlloPrim: (# exit 164 #);
IinitPrimCall:(# exit 165 #);
IPushClong: (# exit 166 #);
IPushClongImm: (# exit 167 #);
IInitExternalCall:(# exit 168 #);

ICallCProc:(# exit 169 #);
IInlineAlloiNGNP:(# exit 170 #);

runtimeCallsEnd:(# exit 171 #);
(*other *)
other:(# exit 172 #);
IdeAllocIOA:(# exit 173 #);
IStackAlloPrim:(# exit 174 #);

IGlobalCodeLabelDef: (# exit 175 #);
IGetSimpleXres: (# exit 176 #);
IGetTextXres: (# exit 177 #);
IGetDoubleXres: (# exit 178 #);
IGetFloatXres: (# exit 179 #);
IGetDataRefXres: (# exit 180 #);
IGetDataPartXres: (# exit 181 #);
ISaveHeapTop: (# exit 182 #);
IRealXresIsDouble: (# exit 183 #);

IExternalEntry: (# exit 184 #);
IExternalMark: (# exit 185 #);
IExternalReturn: (# exit 186 #);
IinitXpar:(# exit 187 #);
IgetXlong: (# exit 188 #);
IgetXword: (# exit 189 #);
IgetXbyte: (# exit 190 #);
ItoXres: (# exit 191 #);
IGetRegForXres: (# exit 192 #);
IendX: (# exit 193 #);
IpreGetXpar: (#exit 194 #);
InoXres: (# exit 195 #);

IloadFloat: (# exit 196 #);
IloadFloatInx: (# exit 197 #);
IstoreFloat: (# exit 198 #);
IstoreFloatInx: (# exit 199 #);
IstoreFloat2int: (# exit 200 #);
IstoreFloat2intInx: (# exit 201 #);
IloadInt2float: (# exit 202 #);

IpushCfloat: (# exit 203 #);
IpushCdouble: (# exit 204 #);

IloadInt2floatInx: (# exit 205 #);

IexternalDispatch: (# exit 206 #);
IreturnVirtualCOM: (# exit 207 #);
IgetCOMpar: (# exit 208 #);
IallocObj: (# exit 209 #);

InewFragment: (#exit 210 #);
InewProto: (#exit 211 #);
InewImp: (#exit 212 #);
InewEval: (#exit 213 #);
IopenDbgInf: (#exit 214 #);
IsaveDbgInf: (#exit 215 #); 

IFakeRegisterWrite: (#exit 216 #); 
ISPtoPrimReg: (# exit 217 #);

ins2text:
  (# instId: @integer; T: @text
  enter instId
  do 'Inst:'->T;
     (if instId 
      // IEntryNode     then 'EntryNode'  -> T
      // IExitNode      then 'ExitNode'->T
      // Inop           then 'nop'->T
      // IldCst         then 'ldCst'->T;
      // IstCst         then 'stCst'->T
      // IldvalFromLab  then 'ldvalFromLab'->T 
      // IstValInLab    then 'stValInLab'->T 
      // IldVal          then 'ldVl'->T 
      // IldValInx      then 'ldValInx'->T 
      // IstVal         then 'stVal'->T 
      // IstValInx      then 'stValInx'->T 
      // IcpReg         then 'cpReg'->T 
      // IstValInText   
      // IdoAsgRefAdr     
      // IdoAsgRefReg   then instId->T.putint  
      // IChkHeap       then 'ChkHeap'->T;
      // IgAddImm       then 'gAddImm'->T
      // IgAddReg       then 'gAddReg' -> T
      // IAddMem        then 'AddMem'->T
      // IgNeg          then 'gNeg'->T
      // IgSubImm       then 'gSubImm'->T
      // IgSubReg       then 'gSubReg'->T
      // IgMultImm    then 'IgMultImm'->T     
      // IgMultReg    then 'IgMultReg'->T 
      // IgDIVImm       then 'gDIVImm'->T
      // IgDIVReg       then 'gDIVReg'->T
      // IgOrImm        then 'gOrImm'->T
      // IgOrReg        then 'gOrReg'->T
      // IgAndImm    then 'IgAndImm'->T     
      // IgAndReg    then 'IgAndReg'->T     
      // IgXorImm    then 'IgXorImm'->T     
      // IgXorReg    then 'IgXorReg'->T     
      // IgNot    then 'IgNot'->T     
      // IlogNot    then 'IlogNot'->T     
      // IgCmpImm    then 'IgCmpImm'->T     
      // IgCmpReg    then 'IgCmpReg'->T     
      // ISignExtByte    then 'ISignExtByte'->T     
      // ISignExtWord    then 'ISignExtWord'->T     
      // IgetBits    then 'IgetBits'->T     
      // IGetSignedBits    then 'IGetSignedBits'->T     
      // IgGetBits    then 'IgGetBits'->T     
      // IgGetSignedBits    then 'IgGetSignedBits'->T     
      // IputBits    then 'IputBits'->T     
      // IgPutBits    then 'IgPutBits'->T     
      // IByteSwap    then 'IByteSwap'->T     
      // IgGetDataByte    then 'IgGetDataByte'->T     
      // IgGetDataWord    then 'IgGetDataWord'->T     
      // IarithShiftLeftImm    then 'IarithShiftLeftImm'->T     
      // IarithShiftLeftReg    then 'IarithShiftLeftReg'->T     
      // IlogicalShiftLeftImm    then 'IlogicalShiftLeftImm'->T     
      // IlogicalShiftLeftReg    then 'IlogicalShiftLeftReg'->T     
      // IarithShiftrightImm    then 'IarithShiftrightImm'->T     
      // IarithShiftrightReg    then 'IarithShiftrightReg'->T     
      // IlogicalShiftRightImm    then 'IlogicalShiftRightImm'->T     
      // IlogicalShiftRightReg    then 'IlogicalShiftRightReg'->T     
      // IrotateLeftImm    then 'IrotateLeftImm'->T     
      // IrotateLeftReg    then 'IrotateLeftReg'->T     
      // IrotateRightImm    then 'IrotateRightImm'->T     
      // IrotateRightReg    then 'IrotateRightReg'->T     
      // IBeginLabel    then 'IBeginLabel'->T     
      // IFreeLabel    then 'IFreeLabel'->T     
      // IEndLabel    then 'IEndLabel'->T     
      // IsaveInnerReturn     then 'saveInnerReturn'->T
      // IreturnInner    then 'IreturnInner'->T     
      // IEmitTextConst    then 'IEmitTextConst'->T     
      // Iglea    then 'Iglea'->T     
      // IgleaLabel    then 'IgleaLabel'->T     
      // IgleaText    then 'IgleaText'->T
      // IleaToPrimReg    then 'IleaToPrimReg'->T     
      // IgClr    then 'IgClr'->T     
      // IpushAdr    then 'IpushAdr'->T     
      // IPush    then 'IPush'->T     
      // IPop    then 'IPop'->T     
      // IPushThisOrCall    then 'IPushThisOrCall'->T     
      // IpopThisOrCall    then 'IpopThisOrCall'->T     
      // IsetTop    then 'IsetTop'->T     
      // IChkCase    then 'IChkCase'->T     
      // IChkIndex    then 'IChkIndex'->T   
      // IcmpToBool  then 'cmpToBool'->T
      // IfloatConst then 'floatConst'->T;    
      // Iint2float    then 'Iint2float'->T     
      // IintReg2float    then 'IintReg2float'->T     
      // Ifloat2int    then 'Ifloat2int'->T     
      // IcmpToBoolFloat    then 'IcmpToBoolFloat'->T     
      // IpopFStack    then 'IpopFStack'->T     
      // IcmpFloat    then 'IcmpFloat'->T     
      // IaddFloat     then 'addFloat'->T;
      // IsubFloat     then 'subFloat'->T;
      // ImulFloat     then 'mulFlot'->T;
      // IdivFloat     then 'divFloat'->T
      // InegFloat    then 'InegFloat'->T     
      // Ilock    then 'Ilock'->T     
      // IFreeAdr    then 'IFreeAdr'->T     
      // IFreeData    then 'IFreeData'->T 
      // IReleaseReg    then 'IReleaseReg'->T     
      // IthisO    then 'IthisO'->T     
      // IcallO    then 'IcallO'->T     
      // IDecrCallReg    then 'IDecrCallReg'->T     
      // IGetCallReg    then 'IGetCallReg'->T     
      // IFreeCallReg    then 'IFreeCallReg'->T     
      // CallRegInPrimReg2I    then 'CallRegInPrimReg2I'->T     
      // IGetOriginReg    then 'IGetOriginReg'->T     
      // IFreeOriginReg    then 'IFreeOriginReg'->T     
      // IDataRegMax    then 'IDataRegMax'->T     
      // INoOfFreeDataReg    then 'INoOfFreeDataReg'->T     
      // IDumpReg    then 'IDumpReg'->T
      // IPushReg      then 'PushReg'->T
      // IPopReg       then 'PopReg'->T
      // IPushDataReg  then 'PushdataReg'->T   
      // IPopDataReg   then 'PopDatareg'->T  
      // IPushFloatReg then 'PushFloatReg'->T    
      // IPopFloatReg  then 'PopFloatReg'->T    
      // ItstNone      then 'TstNone'->T;
      // Itrap         then instId->T.putint
      // Ireturn       then 'return'->T
      // IsaveReturn   then 'saveReturn' -> T
      // Irts          then 'rts'->T
      // Ilabel        then 'label'->T
      // ISaveReg           then 'ISaveReg'->T   
      // IRestoreReg        then 'IRestoreReg'->T   
      // IGetPRimRes        then 'IGetPRimRes'->T   
      // IDeclareAddress    then 'IDeclareAddress'->T
      // IChkConstIndex    then 'IChkConstIndex'->T 
      // IjsrTable    then 'IjsrTable'->T     
      // IjmpTlong    then 'IjmpTlong'->T     
      // IjmpT    then 'IjmpT'->T     
      // IjsrT    then 'IjsrT'->T     
      // IjsrReg    then 'IjsrReg'->T     
      // IjmpReg    then 'IjmpReg'->T     
      // IgJsr    then 'IgJsr'->T     
      // IjsrTableTest    then 'IjsrTableTest'->T
      // localjumpnr    then 'localjumpnr'->T   
      // IjumpIfTrue    then 'IjumpIfTrue'->T     
      // IgBeq    then 'IgBeq'->T     
      // IgBne    then 'IgBne'->T     
      // IgBge    then 'IgBge'->T     
      // IgBae    then 'IgBae'->T     
      // IgBle    then 'IgBle'->T     
      // IgBbe    then 'IgBbe'->T     
      // IgBgt    then 'IgBgt'->T     
      // IgBab    then 'IgBab'->T     
      // IgBlt    then 'IgBlt'->T     
      // IgBbl    then 'IgBbl'->T     
      // IcmpAndJmp    then 'IcmpAndJmp'->T     
      // IcmpAndJmpImm    then 'IcmpAndJmpImm'->T     
      // IcmpBoolAndJmp    then 'IcmpBoolAndJmp'->T     
      // IcmpAndJmpFloat    then 'IcmpAndJmpFloat'->T     
      // IfBeq    then 'IfBeq'->T     
      // IfBge    then 'IfBge'->T     
      // IfBle    then 'IfBle'->T     
      // IfBne    then 'IfBne'->T     
      // IfBgt    then 'IfBgt'->T     
      // IfBlt    then 'IfBlt'->T     
      // localjumpallways    then 'localjumpallways'->T   
      // IgJmp    then 'IgJmp'->T     
      // runtimecalls    then 'runtimecalls'->T   
      // ICallPrim    then 'ICallPrim'->T 
      // ICallAlloPrim    then 'ICallAlloPrim'->T 
      // IinitPrimCall    then 'IinitPrimCall'->T   
      // IPushClong    then 'IPushClong'->T 
      // IPushCfloat then 'PushCfloat'->T;
      // IStoreFloat then 'StoreFloat'->T;
      // IInitExternalCall then 'InitExternalCall'->T;
      // ICallCProc then 'CallCProc'->T;   
      // IInlineAlloiNGNP    then 'IInlineAlloiNGNP'->T   
      // runtimeCallsEnd    then 'runtimeCallsEnd'->T   
      // other    then 'other'->T   
      // IdeAllocIOA    then 'IdeAllocIOA'->T   
      // IStackAlloPrim    then 'IStackAlloPrim'->T      
      // IGlobalCodeLabelDef then  'GlobalCodeLabelDef' -> T        
      // INewImp then 'NewImp'->T;
      // IFakeRegisterWrite then 'FakeRegisterWrite'->T;
      else
         instId -> T.putint
     if);
  exit T[]
  #)
