ORIGIN '../machine';
INCLUDE '../../OPTIMIZER/analyzer'
        'IMgraph';
-- AbstractMachinelib: Attributes --
Ianalyzer: analyzer
  (#
     graphType::< IntermachineBBgraph;
     flowFunctionType::<
       (#
          nop:< (#  do INNER #);
          ldCst:< (#  do INNER #);
          stCst:< (#  do INNER #);
          ldByte:< (#  do INNER #);
          ldHalf:< (#  do INNER #);
          ldVal:< (#  do INNER #);
          ldvalFromLab:< (#  do INNER #);
          ldVl:< (#  do INNER #);
          stByte:< (#  do INNER #);
          stHalf:< (#  do INNER #);
          stVal:< (#  do INNER #);
          stValInLab:< (#  do INNER #);
          cpReg:< (#  do INNER #);
          cpByteMem:< (#  do INNER #);
          cpHalfMem:< (#  do INNER #);
          cpMem:< (#  do INNER #);
          stValInText:< (#  do INNER #);
          doAsgRefAdr:< (#  do INNER #);
          doAsgRefReg:< (#  do INNER #);
          ChkHeap:< (#  do INNER #);
          gadd:<(# do inner #);
          addMem:< (#  do INNER #);
          gNeg:< (#  do INNER #);
          gSub:< (#  do INNER #);
          gMult:< (#  do INNER #);
          gDIV:< (#  do INNER #);
          gOr:< (#  do INNER #);
          gAnd:< (#  do INNER #);
          gXor:< (#  do INNER #);
          gNot:< (#  do INNER #);
          logNot:< (#  do INNER #);
          gCmp:< (#  do INNER #);
          SignExtByte:< (#  do INNER #);
          SignExtWord:< (#  do INNER #);
          GetBits:< (#  do INNER #);
          GetSignedBits:< (#  do INNER #);
          gGetBits:< (#  do INNER #);
          gGetSignedBits:< (#  do INNER #);
          putBits:< (#  do INNER #);
          gPutBits:< (#  do INNER #);
          ByteSwap:< (#  do INNER #);
          gGetDataByte:< (#  do INNER #);
          gGetDataWord:< (#  do INNER #);
          arithShiftLeft:< (#  do INNER #);
          logicalShiftLeft:< (#  do INNER #);
          arithShiftright:< (#  do INNER #);
          logicalShiftRight:< (#  do INNER #);
          rotateLeft:< (#  do INNER #);
          rotateRight:< (#  do INNER #);
          BeginLabel:< (#  do INNER #);
          FreeLabel:< (#  do INNER #);
          EndLabel:< (#  do INNER #);
          saveInnerReturn:< (#  do INNER #);
          returnInner:< (#  do INNER #);
          EmitTextConst:< (#  do INNER #);
          rts:<(# do INNER #);
          glea:< (#  do INNER #);
          gleaLabel:< (#  do INNER #);
          gleaText:< (#  do INNER #);
          leaToPrimReg:< (#  do INNER #);
          gClr:< (#  do INNER #);
          pushAdr:< (#  do INNER #);
          Push:< (#  do INNER #);
          Pop:< (#  do INNER #);
          PushThisOrCall:< (#  do INNER #);
          popThisOrCall:< (#  do INNER #);
          setTop:< (#  do INNER #);
          ChkCase:< (#  do INNER #);
          ChkIndex:< (#  do INNER #);
          cmpToBool:< (#  do INNER #);
          floatConst:< (#  do INNER #);
          int2float:< (#  do INNER #);
          intReg2float:< (#  do INNER #);
          float2int:< (#  do INNER #);
          cmpToBoolFloat:< (#  do INNER #);
          popFStack:< (#  do INNER #);
          cmpFloat:< (#  do INNER #);
          addFloat:< (#  do INNER #);
          subFloat:< (#  do INNER #);
          mulFloat:< (#  do INNER #);
          divFloat:< (#  do INNER #);
          negFloat:< (#  do INNER #);
          lock:< (#  do INNER #);
          FreeAdr:< (#  do INNER #);
          FreeData:< (#  do INNER #);
          ReleaseReg:< (#  do INNER #);
          thisO:< (#  do INNER #);
          callO:< (#  do INNER #);
          DecrCallReg:< (#  do INNER #);
          GetCallReg:< (#  do INNER #);
          FreeCallReg:< (#  do INNER #);
          allRegInPrimReg2I:< (#  do INNER #);
          GetOriginReg:< (#  do INNER #);
          FreeOriginReg:< (#  do INNER #);
          DataRegMax:< (#  do INNER #);
          NoOfFreeDataReg:< (#  do INNER #);
          DumpReg:< (#  do INNER #);
          PushReg:< (#  do INNER #);
          PopReg:< (#  do INNER #);
          PushDataReg:< (#  do INNER #);
          PopDataReg:< (#  do INNER #);
          PushFloatReg:< (#  do INNER #);
          PopFloatReg:< (#  do INNER #);
          tstNone:< (#  do INNER #);
          trap:< (#  do INNER #);
          return:< (#  do INNER #);
          saveReturn:< (#  do INNER #);
          jsrTable:< (#  do INNER #);
          jmpTlong:< (#  do INNER #);
          jmpT:< (#  do INNER #);
          jsrT:< (#  do INNER #);
          jsrReg:< (#  do INNER #);
          jmpReg:< (#  do INNER #);
          gJsr:< (#  do INNER #);
          jumpIfTrue:< (#  do INNER #);
          gBeq:< (#  do INNER #);
          gBne:< (#  do INNER #);
          gBge:< (#  do INNER #);
          gBae:< (#  do INNER #);
          gBle:< (#  do INNER #);
          gBbe:< (#  do INNER #);
          gBgt:< (#  do INNER #);
          gBab:< (#  do INNER #);
          gBlt:< (#  do INNER #);
          gBbl:< (#  do INNER #);
          cmpAndJmp:< (#  do INNER #);
          cmpBoolAndJmp:< (#  do INNER #);
          cmpAndJmpFloat:< (#  do INNER #);
          fBeq:< (#  do INNER #);
          fBge:< (#  do INNER #);
          fBle:< (#  do INNER #);
          fBne:< (#  do INNER #);
          fBgt:< (#  do INNER #);
          fBlt:< (#  do INNER #);
          localjumpallways:< (#  do INNER #);
          gJmp:< (#  do INNER #);
          (* added by OLM: *)
          label:< (#  do INNER #);
          callAlloPrim:< (# do INNER #);
          getPrimRes:<  (# do INNER #);
          initPrimCall:< (# do INNER #);
          done:@boolean;
       do false->done;
          (if in[]<>none then
              in.copy->result[];
           else
              &carrier[]->result[]
          if);
          INNER;
          (if done then leave flowFunctionType if);
          (* !!!!!!!!!!! OLM: several constants removed 
           * several instructions have been changed from 
           * e.g. gAdd to gAddImm
           *)
          (if current.type
           // Inop then
              nop
           // IldCst then
              ldCst
           // IstCst then
              stCst
           // IldvalFromLab then
              ldvalFromLab
           // IldVal then
              ldVal
           // IstVal then
              stVal
           // IstValInLab then
              stValInLab
           // IcpReg then
              cpReg
           // IstValInText then
              stValInText
           // IdoAsgRefAdr then
              doAsgRefAdr
           // IdoAsgRefReg then
              doAsgRefReg
           // IChkHeap then
              ChkHeap
           // IgAddimm then gAdd
           // IgAddreg then gAdd (* added by OLM *)
           // IaddMem then
              addMem
           // IgNeg then
              gNeg
           // IgSubImm then
              gSub
           // IgMultImm then
              gMult
           // IgDIVReg then
              gDIV
           // IgDivImm then
              gDIV
           // IgOrImm then
              gOr
           // IgAndImm then
              gAnd
           // IgXorImm then
              gXor
           // IgNot then
              gNot
           // IlogNot then
              logNot
           // IgCmpImm then
              gCmp
           // ISignExtByte then
              SignExtByte
           // ISignExtWord then
              SignExtWord
           // IgetBits then
              getBits
           // IGetSignedBits then
              GetSignedBits
           // IgGetBits then
              gGetBits
           // IgGetSignedBits then
              gGetSignedBits
           // IputBits then
              putBits
           // IgPutBits then
              gPutBits
           // IByteSwap then
              ByteSwap
           // IgGetDataByte then
              gGetDataByte
           // IgGetDataWord then
              gGetDataWord
           // IarithShiftLeftImm then
              arithShiftLeft
           // IlogicalShiftLeftImm then
              logicalShiftLeft
           // IarithShiftrightImm then
              arithShiftright
           // IlogicalShiftRightImm then
              logicalShiftRight
           // IrotateLeftImm then
              rotateLeft
           // IrotateRightImm then
              rotateRight
           // IjumpIfTrue then
              jumpIfTrue
           // ItstNone then
              tstNone
           // IgBeq then
              gBeq
           // IgBne then
              gBne
           // IgBge then
              gBge
           // IgBae then
              gBae
           // IgBle then
              gBle
           // IgBbe then
              gBbe
           // IgBgt then
              gBgt
           // IgBab then
              gBab
           // IgBlt then
              gBlt
           // IgBbl then
              gBbl
           // Itrap then
              trap
           // IjsrTable then
              jsrTable
           // IjmpTlong then
              jmpTlong
           // IjmpT then
              jmpT
           // IjsrT then
              jsrT
           // IjsrReg then
              jsrReg
           // IjmpReg then
              jmpReg
           // IgJmp then
              gJmp
           // IgJsr then
              gJsr
           // IBeginLabel then
              BeginLabel
           // IFreeLabel then
              FreeLabel
           // IEndLabel then
              EndLabel
           // IsaveInnerReturn then
              saveInnerReturn
           // IreturnInner then
              returnInner
           // Ireturn then
              return
           // IsaveReturn then
              saveReturn
           // IEmitTextConst then
              EmitTextConst
           // Irts then
              rts
           // Iglea then
              glea
           // IgleaLabel then
              gleaLabel
           // Igleatext then gleaText
           // IleaToPrimReg then
              leaToPrimReg
           // IgClr then
              gClr
           // IpushAdr then
              pushAdr
           // IPush then
              Push
           // IPop then
              Pop
           // IPushThisOrCall then
              PushThisOrCall
           // IpopThisOrCall then
              popThisOrCall
           // IsetTop then
              setTop
           // IChkCase then
              ChkCase
           // IChkIndex then
              ChkIndex
           // IcmpToBool then
              cmpToBool
           // IcmpAndJmp then
              cmpAndJmp
           // IcmpBoolAndJmp then
              cmpBoolAndJmp
           // IfloatConst then
              floatConst
           // Iint2float then
              int2float
           // IintReg2float then
              intReg2float
           // Ifloat2int then
              float2int
           // IcmpToBoolFloat then
              cmpToBoolFloat
           // IcmpAndJmpFloat then
              cmpAndJmpFloat
           // IpopFStack then
              popFStack
           // IcmpFloat then
              cmpFloat
           // IfBeq then
              fBeq
           // IfBge then
              fBge
           // IfBle then
              fBle
           // IfBne then
              fBne
           // IfBgt then
              fBgt
           // IfBlt then
              fBlt
           // IaddFloat then
              addFloat
           // IsubFloat then
              subFloat
           // ImulFloat then
              mulFloat
           // IdivFloat then
              divFloat
           // InegFloat then
              negFloat
           // Ilock then
              lock
           // IFreeAdr then
              FreeAdr
           // IFreeData then
              FreeData
           // IReleaseReg then
              ReleaseReg
           // IthisO then
              thisO
           // IcallO then
              callO
           // IDecrCallReg then
              DecrCallReg
           // IGetCallReg then
              GetCallReg
           // IFreeCallReg then
              FreeCallReg
           // CallRegInPrimReg2I then
              allRegInPrimReg2I
           // IGetOriginReg then
              GetOriginReg
           // IFreeOriginReg then
              FreeOriginReg
           // IDataRegMax then
              DataRegMax
           // INoOfFreeDataReg then
              NoOfFreeDataReg
           // IDumpReg then
              DumpReg
           // IPushReg then
              PushReg
           // IPopReg then
              PopReg
           // IPushDataReg then
              PushDataReg
           // IPopDataReg then
              PopDataReg
           // IPushFloatReg then
              PushFloatReg
           // IPopFloatReg then
              PopFloatReg
           // Ilabel then label
           // IinitPrimCall then initPrimCall
           // IGetPrimRes then GetPrimRes
           // IcallAlloPrim then CallAlloPrim   
           else
              'INST was not found'->puttext;
              current.type->putint;newline
          if)
       #)
  #);

Ifastanalyzer:fastanalyzer
  (# 
     graphType::< IntermachineBBgraph;
  #);
