ORIGIN '../machine' ;
BODY '../CODEmachine';
(*
 * 	Logical registers		Physical registerds
 *
 *	th				EDX
 *	ca				EDI
 * 
 *	Address registers
 * 
 *	R1 (a2)				share EBP and ESI
 *	R2 (a3)		
 *	R3 (a4)		
 * 
 *	a7 (sp)				ESP
 *		
 *	d0				share EAX, EBX and ECX
 *	d1		
 *	d2		
 *	d3
 *	...
 *	d7:
 * 
 *	Numbers for physical registers
 * 
 *		1		%edx
 *		2		%edi
 *		3		%ebp
 *		4		%esi
 *		5		%eax
 *		6		%ebx
 *		7		%ecx
 *		8		%esp
 * 
 * ai, i=0:7, aMap[i+1] in [-1,0,1:4,8]
 * di, i=0:7, dMap[i+1] in [-1,0,5-7]
 * where        -1: in tmp. location
 * 		 0: not allocated to any register
 * 		 k,k>0: mapped to physical register k
 * 
 * i=1,8: fMap[i] in [1,8]
 *)
--mstate:descriptor--
(# addressSize: @integer; 
   (* LASSE hack fra larsp/beta/system/v4.2/gen1.bet.
    * o: long
    * 1: word
    * 2: byte
    * should be in accordance with size value from codegen:
    * byte:1, word:2, long:4
    *)
   segNo : @integer;
   floatReg: [8] @ integer; (*???*)
   TmpLab: @
     (# lab: ^Locallab;
     do (if lab[]=NONE then
            &locallab[] -> lab[];
            lab.new;
            switchtodata;
            'tmplab' -> comment;
            lab.def;
            '\t.long\t0\n' -> BC.putT;
            '\t.long\t0\n' -> BC.putT;
            switchtocode;
        if);
     exit lab[]
     #);
#)
--DataRegOpRegF: dopart--
do (* regF not used in LINUXmachine *)
--AdrRegOpRegF: dopart--
do (* regF not used in LINUXmachine *)
--isObjectReg:descriptor--
(##)
--FloatRegOpRegF: dopart--
do (* regF not used in LINUXmachine *)
   
--machineatt:attributes--
edx: (#exit 1 #); edi: (#exit 2 #); ebp: (#exit 3 #); esi: (#exit 4 #);
eax: (#exit 5 #); ebx: (#exit 6 #); ecx: (#exit 7 #); esp: (#exit 8 #);

eoo: (* end-of-operation*)
  (#do 0->mState.AddressSize; BC.putNL #);
eo: (#do 0->mState.addressSize #);

SetCC:
  (# cond,size: @integer; op: ^mOperand
  enter(cond,op[],size)
  do (op[],none)->ldOps;
     (* in most cases  (a<b>)->X, X is a boolean. It is therefore NOT
      * necessary to clear op before executing set. However, X may be
      * an integer in which case op MUST be cleared. The type of X is
      * NOT know here, therefore op is always cleared.
      * If the compiler introduces typechecking, X will always be a boolean
      * and clear may be avoided
      *)
     0->mstate.addressSize; '\tmovl\t$0,'->BC.putT; op.putOp; BC.putNL;
     
     (if cond (* setCOND op *)
      // 1 (* =  *) then '\tsete\t'->BC.putT
      // 2 (* <> *) then '\tsetne\t'->BC.putT
      // 3 (* <  *) then 
         (if size
          //4 then '\tsetl\t'->BC.putT
          //2 then '\tsetb\t'->BC.putT (* unsigned compare *)
          //1 then '\tsetb\t'->BC.putT (* unsigned compare *)
         if)
      // 4 (* <= *) then
         (if size
          //4 then '\tsetle\t'->BC.putT
          //2 then '\tsetbe\t'->BC.putT (* unsigned compare *)
          //1 then '\tsetbe\t'->BC.putT (* unsigned compare *)
         if)
      // 5 (* >  *) then 
         (if size
          // 4 then'\tsetg\t'->BC.putT
          // 2 then'\tseta\t'->BC.putT (* unsigned compare *)
          // 1 then'\tseta\t'->BC.putT (* unsigned compare *)
         if)
      // 6 (* >= *) then 
         (if size
          // 4 then '\tsetge\t'->BC.putT
          // 2 then '\tsetae\t'->BC.putT (* unsigned compare *)
          // 1 then '\tsetae\t'->BC.putT (* unsigned compare *)
         if)
     if);
     2->mstate.addressSize;
     op.putOp; eoo
  #);
regA: 
  (# T: ^Stream; n: @integer (* n in [0:7] *)
  enter(T[],n)
  do (if n
      // 0 then '%edx' -> T.puttext (* f1 *)
      // 1 then '%edi' -> T.puttext (* f2 *)
      // 7 then '%esp' -> T.puttext (* f8 *)
      else
         (if rep.aMap[n+1]
          (* // true ?? removed by DATPETE april 3 1995 *)
          // ebp then '%ebp' -> T.puttext (* f3 *)
          // esi then '%esi' -> T.puttext (* f4 *)
          // -1 then '%tmp'->T.puttext
  if)if)#);
regD: 
  (# T: ^stream; n: @integer 
  enter(T[],n) 
  do (if rep.dMap[n+1]
      // eax then '%eax' -> T.puttext (* f5 *)
      // ebx then '%ebx' -> T.puttext (* f6 *)
      // ecx then '%ecx' -> T.puttext (* f7 *)
      // -1 then '%tmp'->T.puttext
      else 'dReg:'->T.putText; n->T.putint
     if) 
  #);
regF: 
  (# T: ^stream; n: @integer ; (* f1-8 *)
  enter(T[],n) 
  do (if n
      // edx then '%edx' -> T.puttext
      // edi then '%edi' -> T.puttext
      // ebp then '%ebp' -> T.puttext
      // esi then '%esi' -> T.puttext
      // eax then '%eax' -> T.puttext
      // ebx then '%ebx' -> T.puttext
      // ecx then '%ecx' -> T.puttext
      // esp then '%esp'->T.putText
      else 'fReg:'->T.putText; n->T.putint
     if) 
  #);
regT:
  (# T: ^stream; R: @char; n: @integer
  enter(T[],R,n)
  do R->T.put; n->T.putInt
  #);
dumpR:
  (# T: @text; ch: @char
  do (if common.switch[45] then
         (for i:5 repeat
              'a'->T.put; i-1->T.putInt; '='->T.put; (T[],i-1)->regA; ' '->T.put; 
         for);
         T->comment; T.clear;
         (for i:5 repeat
              'd'->T.put; i-1->T.putInt; '='->T.put; (T[],i-1)->regD; ' '->T.put; 
         for);
         T->comment; T.clear;
         (for i: 8 repeat
              (if i
               //1//2//3//4 then 'a'->ch
               //5//6//7 then 'd'->ch
               //8 then 'S'->ch
              if);
              (T[],i)->regF; '='->T.put; (T[],ch,rep.fMap[i]-1)->regT; ' '->T.put
         for);
         T->comment; T.clear
     if);
  #);
UseFreg:
  (* returns true if op uses a datareg assigned to physical register fNo *)
  (# op: ^mOperand; fNo,ano,dno: @integer; useOp: @ boolean
  enter(op[],fNo)
  do op.getReg->(ano,dno);
     (if dno>0 then
         rep.dMap[dno]=fNo -> useOp
     if)
  exit useOp
  #);
GetFreg:
  (* get a specific physical register: fNo.
   * Pre-condition: fNo is NOT used by op1!
   * Do NOT conflict with op1: 
   * op1 does NOT use fNo, but
   * must NOT be assigned to fNo
   *)
  (# op1: ^mOperand; fNo: @integer; dr,oldDr: @dataRegOperand; T: @text
  enter(op1[],fNo)
  do (if common.switch[45] then 'getF1:'->comment; dumpR if);
     (if (rep.fMap[fNo]->oldDr)>0 then 
         oldDr-1->oldDr;
         '\tmov\t'->BC.putT; (BC[],fNo)->regF; sep; 
         (BC[],'d',oldDr)->regT; BC.putNL;
         -1->rep.dMap[oldDr+1]; (* oldDr is now in tmp. location *)
     if);
     dr.alloc; dr.deAlloc; (* it seems that the prealloc spoils it *)
     dr.alloc; 
     (if common.switch[45] then
         'DataReg:'->T; dr->T.putInt; T->comment;
     if);
     fNo->rep.dMap[dr+1]; dr+1->rep.fMap[fNo];
     (* A problem if op1 uses fNo!!
      * It is a precondition of this proc. that op1 does NOT use fNo
      *)
     (dr[],op1[])->ldOps;
     (if common.switch[45] then
         'getF2:'->comment; dumpR;
     if);
     dr.deAlloc; (* now dumpR will not show allocation of dr *)
  exit oldDr
  #);   
AssignRegToFreg:
  (* assign register to a specific physical register *)
  (# dr: @dataRegOperand; FR: @integer; T: @text
  enter(dr,FR)
  do (if common.switch[45] then
         'AssignRegtoFreg:'->T; dr->T.putInt; ','->T.put; FR->T.putInt;
         T->comment; dumpR;
     if);
     (if rep.dmap[dr+1]>0 then
         '! fReg already assigned'->comment;
         0->rep.fMap[rep.dMap[dr+1]]
     if);
     (NONE,FR)->GetFreg;
     FR->rep.dMap[dr+1]; dr+1->rep.fMap[FR]
  #);
allocA:
  (# ano1,ano2,OLDano1Map,fno: @integer
  enter(ano1,ano2)
  do (if ano1>0 then
         (if rep.aMap[ano1]>0 then (* ok *)
          else 
             (* allocate freg to ano1 *)
             alloc:
               (# T: @text
               do (if common.switch[45] then
                      'Alloc '->T; (T[],ano1-1)->regA; T->comment
                  if);
                  (* check if there is an unused freg *)
                  (for i:2 repeat
                       (if rep.fmap[i+2]//0 then 
                           (if common.switch[45] then
                               ' free freg found'->comment
                           if);
                           i+2->fno;
                           leave alloc
                  if)for);
                  
                  (* there are no unused freg's.
                   * find one that is not allocated to ano2
                   *)
                  (for i: 2 repeat
                       (if rep.fmap[i+2]//ano2 then 
                        else 
                           (* store rep.fmap[i+2] *)
                           '\tmov'->BC.putT; 4->BC.putS; 
                           (BC[],rep.fMap[i+2]-1)->regA; sep;
                           (BC[],'a',rep.fMap[i+2]-1)->regT; 
                           BC.putNL;
                           -1->rep.aMap[rep.fMap[i+2]];
                           i+2->fno;
                           leave alloc
                  if)for);
                  'Error in adr. reg alloc'->bugstream.putLine;
                  'Error in adr. reg alloc'->comment
               #);
             (* check if physical register needs to be restored *)
             rep.aMap[ano1]->OLDano1Map;
             ano1->rep.fmap[fno]; fno->rep.aMap[ano1];
             (if OLDano1Map//-1 then (* in tmp store *)
                 '\tmov'->BC.putT; 4->BC.putS; 
                 (BC[],'a',ano1-1)->regT; sep;
                 (BC[],ano1-1)->regA;
                 (*'Restore reg from tmp'->comment;*)
                 BC.putNL;
  if)if)if)#);

allocD:
  (# dno1,dno2,fno,OLDdno1Map: @integer; (* dn01,dno2 in [1-8] *)
  enter(dno1,dno2)
  do (if dno1>0 then
         (if rep.dMap[dno1]>0 then (* dno1 already assigned to freg *)
          else
             (* allocate freg to dno1 *)
             alloc:
               (# T: @text
               do (if common.switch[45] then
                      'Alloc '->T; (T[],dno1-1)->regD; T->comment
                  if);
                  (* check if there is an unused freg *)
                  (for i:3 repeat
                       (if rep.fmap[i+4]//0 then
                           (if common.switch[45] then
                               'free freg found'->comment
                           if);
                           i+4->fno;
                           leave alloc
                  if)for);
                  
                  (* there are no unused freg's.
                   * find one that is not alloacted to dno2
                   *)
                  (for i: 3 repeat
                       (if rep.fmap[i+4]//dno2 then
                        else 
                           (* store rep.fmap[i+4] *)
                           '\tmov'->BC.putT; 4->BC.putS; 
                           (BC[],rep.fMap[i+4]-1)->regD; sep;
                           (BC[],'d',rep.fMap[i+4]-1)->regT; BC.putNL;
                           -1->rep.dMap[rep.fMap[i+4]];
                           i+4->fno;
                           leave alloc
                  if)for);
                  'Error in data reg alloc'->bugstream.putLine;
                  'Error in data reg alloc'->comment
               #);
             (* check if physical register needs to be restored *)
             rep.dMap[dno1]->OLDdno1Map;
             dno1->rep.fmap[fno]; fno->rep.dMap[dno1];
             (if OLDdno1Map//-1 then (* in tmp store *)
                 '\tmov'->BC.putT; 4->BC.putS; 
                 (BC[],'d',dno1-1)->regT; sep;
                 (BC[],dno1-1)->regD;
                 (*'Restore reg from tmp'->comment;*) 
                 BC.putNL;
  if)if)if)#);

ldOps:
  (# op1,op2: ^mOperand; ano1,ano2,dno1,dno2: @integer;
     T: @text;
     pA: (# n: @integer
         enter n
         do (if n<>0 then
                ' a'->T.putText; n-1->T.putint
         if)#);
     pD: (# n: @integer
         enter n
         do (if n<>0 then
                ' d'->T.putText; n-1->T.putint
         if)#);
     
  enter(op1[],op2[])
  do op1.getReg->(ano1,dno1);
     (if op2[]//NONE then else op2.getReg->(ano2,dno2) if);
     (ano1,ano2)->allocA; (ano2,ano1)->allocA;
     (dno1,dno2)->allocD; (dno2,dno1)->allocD;
     
     (if common.switch[45] then
         'Use: '->T; ano1->pA; dno1->pD; ano2->pA; dno2->pD; T->comment;
         dumpR
     if)
  #);
chkEmitReg:
  (# op1,op2: ^mOperand; size: @integer; dr: @dataRegOperand 
  enter(op1[],op2[],size)
  do (if op2.isPrimRegOp then
         dr.alloc;
         (op1[],dr[])->ldOps;
         '\tmov'->BC.putT; 4->BC.putS; op1.putOp; sep; dr.putOp; eoo;
         (op2[],dr[])->ldOps;
         '\tmov'->BC.putT; 4->BC.putS; dr.putOp; sep; op2.putOp; eoo;
         dr.deAlloc;
      else
         (if size//4 then else op2[]->gClr if);
         '\tmov'->BC.putT; size->BC.putS; op1.putOp; BC.sep; 
         op2.putOp; eoo
     if);
  #);

swapFreg:
  (# F1,F2: ^floatRegOp; swap: @boolean
  enter(F1[],F2[])
  do (rep.floatMap[F1.rN+1]>rep.floatMap[F2.rN+1])->swap;
     (if common.switch[350] then
         (# T: @text
         do 'swapFstack: '->T.puttext;
            F1.rn->T.putint; '='->T.put; rep.floatMap[F1.rN+1]->T.putint;
            ','->T.put;
            F2.rn->T.putint; '='->T.put; rep.floatMap[F2.rN+1]->T.putint;
            (if swap then' swap'->T.puttext else' noswap'->T.puttext if);
            T->comment; T[]->bugstream.putline
     #)if)
  exit swap
  #);
NotCompleted:
  (# routine: @text
  enter routine
  do '[ ' -> common.tracestream.putText;
     routine[] -> common.tracestream.putText;
     ' not impl. ]' -> common.tracestream.putText;
     '\t# [ ' -> BC.putT; routine -> BC.putT;
     ' not impl. ]' -> BC.putT; eoo
  #);
NotTested:
  (# routine: @text
  enter routine
  do '[ ' -> common.tracestream.putText;
     routine[] -> common.tracestream.putText;
     ' not tested ]' -> common.tracestream.putText;
  #);

primRegOperand: registerOperand
  (* due to the small number of registers on the INTEL processor, 
   * the primitive registers are allocated as memory cells:
   * 
   * 	pReg1:
   * 	pReg2:
   * 	pReg3:
   * 	pReg4:
   * 	pReg5:
   *)
  (# putOp::<(#do 'pReg'->BC.putT; rN->BC.putI #);
     loadOp::<(#do this(primRegOperand)[]->op[] #);
     isPrimRegOp:: TrueValue;
     pushCpar::<(#do (this(primRegOperand)[],R[])->cpReg #);
     alloc::< (#do cError(#do 'Attempt to alloc primReg'->T#)#);
     deAlloc::< (#do cError(#do 'Attempt to deAlloc primReg'->T #) #);
     reUse::< (#do cError(#do 'Attempt to reUse primReg'->T#) #);
     display::<(#do ' Primreg'->T #)
  #);
physRegOperand: registerOperand
  (* representation of physical registers.
   * dataRegA/B are represented this way
   *)
  (# putOp::<(#do (BC[],rN)->this(machine).regF #);
     loadOp::<(#do this(physRegOperand)[]->op[] #);
     pushCpar::<(#do (this(physRegOperand)[],R[])->cpReg #);
     alloc::< (#do cError(#do 'Attempt to alloc physReg'->T#)#);
     deAlloc::< (#do cError(#do 'Attempt to deAlloc physReg'->T #) #);
     reUse::< (#do cError(#do 'Attempt to reUse physReg'->T#) #);
     display::<(#do ' PhysReg:'->T; rN->T.putInt #)
  #);
TstFloat:
  (# oldDr: @dataRegOperand
  do (* allocate %ax (16-bit of %eax): NOT YET DONE! *)
     (NONE,eax)->getFreg->oldDr;
     '\tfstsw\t%ax\n'->BC.putT; (* move FP condition codes to %ax *)
     '\tsahf\n\tjp\tUoFV\n'->BC.putT;
     (oldDr[],none)->ldOps;
     INNER
  #);
GetCL:
  (* the shl and shr operations has one of the forms:
   *    shl   op,imm
   *    shl   op,cl
   * This operation allocates cl for these operations.
   * cl is the lower 8-bit of ecx.
   * ecx is  dataReg2.
   *
   * The ecxRegister is the register assumed to contain ecx (cl)
   *
   * The plan goes as follows:
   *
   * if ecx not in use:
   *   mov ecx,ecxRegister
   *   INNER
   * else /*ecx in use*/
   *   if ecxRegsiter is ecx
   *     INNER
   *   else
   *     push ecx
   *     mov ecx,ecxregister
   *     INNER
   *     pop ecx
   *   fi
   * fi
   *
   *)
  (# ecxRegister: ^mOperand;
     ecxInUse: @boolean;
     ecxRight: @boolean;
  enter ecxRegister[]
  do (rep.dReg[3]<>0) -> ecxInUse;
     ( (# a,d:@integer do ecxRegister.getReg->(a,d) exit d #) = 3)
       -> ecxRight;
     (if not ecxRight then (* Action needed *)
         (if ecxInUse then (* Need pus, pop *)
             '\tpushl\t%ecx'->BC.putLine
         if);
         '\tmovl\t'->BC.putT; ecxRegister.putOp; ',%ecx'->BC.putLine
     if);
     INNER;
     (if (not ecxRight) and (ecxInUse) then
         '\tpopl\t%ecx'->BC.putLine;
     if);
  #);
AdrReg:
  (# RegNo, Type: @integer; inCode:@boolean;
  enter (RegNo, Type, inCode)
  do (if Type//1//2 then 
         (* Register EBP is default based on the stack segment,
          * so change the base segment to DS = Data Segment.
          * This observation took half a day.
          *)
         (*
          (if inCode then 
          'CS:' -> BC.putT
          else
          (if regNo//3 then 'DS:' -> BC.putT if)
          if);
          *)
         '[' -> BC.putC 
     if);
     (if RegNo
      // 0 then '%edx' -> BC.putT
      // 1 then '%edi' -> BC.putT
      // 7 then '%esp' -> BC.putT
      else
         (if rep.aMap[RegNo+1]
          (*  ?? removed by DATPETE april 3 1995 *)
          // 3 then '%ebp' -> BC.putT
          // 4 then '%esi' -> BC.putT
          else
             ('AdrReg wrong regno = ', RegNo) -> reportErrorInt; 
             '[A'->BC.putT;RegNo->BC.putI;']'->BC.putC;
     if)if);
     INNER;
     (if Type//1//2 then ']' -> BC.putC if)
  #);
IndirectReg:
  (# RegNo, Offset: @integer; inCode: @boolean;
  enter (RegNo, Offset, inCode)
  do(* (if Mstate.AddressSize
     // 0 then 'DWORD PTR ' -> BC.putT;
     // 1 then 'WORD PTR ' -> BC.putT;
     // 2 then 'BYTE PTR ' -> BC.putT;
     if);
     *
     (if inCode then 'CS:' -> BC.putT
     else (if regNo//3 then 'DS:' -> BC.putT if)
     if);
     *)
     (if Offset//0 then else Offset -> BC.putI if);
     '(' -> BC.putC; (RegNo, 0, false) -> AdrReg; ')' -> BC.putC;
  #);
IndexReg:
  (# RegNo, IndexReg, Scale, Offset: @integer; inCode: @boolean;
  enter (RegNo, IndexReg, Scale, Offset, inCode)
  do (*(if inCode then 'CS:' -> BC.putT
      else (if regNo//3 then 'DS:' -> BC.putT if)
      if);
      *)
     Offset -> BC.putI; 
     '('->BC.putC; 
     (RegNo,0,false) -> AdrReg; sep;
     IndexReg -> DataRegOne; sep;
     Scale -> BC.PutI;
     ')' -> BC.putC;
  #);
reportError:
  (# mess: @text;
  enter mess
  do
     '## Codegen error for intel:' ->bugstream.putText;
     mess[] ->bugstream.putText; 
     
     eoo;
     '## Codegen error for intel:' -> BC.putT;
     mess -> BC.putT;
     
     inner;
     
     bugstream.newline; eoo
  #);
reportErrorInt: reportError
  (# theInt: @integer
  enter theInt
  do
     theInt ->bugstream.putInt;
     theInt -> BC.putI;
  #);
DataReg:
  (# RegNo: @integer
  enter RegNo
  do (if rep.dMap[RegNo+1]
      // 5 then
         (if Mstate.AddressSize
          // 0 then  '%eax' -> BC.putT
          // 1 then  '%ax'  -> BC.putT
          // 2 then  '%al'  -> BC.putT
         if)
      // 6 then 
         (if Mstate.AddressSize
          // 0 then  '%ebx' -> BC.putT
          // 1 then  '%bx'  -> BC.putT
          // 2 then  '%bl'  -> BC.putT
         if)
      // 7 then 
         (if Mstate.AddressSize
          // 0 then  '%ecx' -> BC.putT
          // 1 then  '%cx'  -> BC.putT
          // 2 then  '%cl'  -> BC.putT
         if)
      else
         ('DataReg wrong regno = ', RegNo) -> reportErrorInt;
         '[D'->BC.putT;RegNo->BC.putI;']'->BC.putC;
     if);
     
  #);
DataRegOne:
  (# RegNo: @integer
  enter RegNo
  do (if rep.dMap[RegNo+1]
      // 5 then '%eax' -> BC.putT
      // 6 then '%ebx' -> BC.putT
      // 7 then '%ecx' -> BC.putT;
      else
         ('DataReg wrong regno = ', regNo) -> reportErrorInt;
         '[D'->BC.putT;RegNo->BC.putI;']'->BC.putC;
     if);
     
  #);
Areg: (# number:@integer enter number do (number, 0, false) -> AdrReg  #);
Dreg: (# number:@integer enter number do   number -> DataReg #);
imm: (# off: @ integer enter(off) do off-> BC.putI #);
sep: (#do ','->BC.putC #);

--DataRegMax:dopart--
do 5->val
(*--RelativeAdr:descriptor--
 * (#
 * do '\t.word\t'->BC.putT; L1.putOp; '-'->BC.putC; 
 *  L2->BC.putT; eoo;
 * #)
 *)
--popCallStack:descriptor--
(#
do '\taddl\t$'->BC.putT; N*4-> BC.putI; ',%esp' -> BC.putT; eoo
#)
--SaveReg:descriptor--
(* On entry to a c function call. *)
(#
do 
   '\tpush\t%edx' -> BC.putT; eoo;
   '\tpush\t%edi' -> BC.putT; eoo;
#)
--RestoreReg:descriptor--
(* On exit to a c function call. *)
(#
do
   '\tpop\t%edi' ->BC.putT; eoo;
   '\tpop\t%edx' ->BC.putT; eoo;
#)
--AlcPascResult:descriptor--
  (# 
  do ';\tAlcPascalResult\t'->BC.putT; eoo
  #)
--PascalTrap:descriptor--
  (* no meaning for DX200 *)
  (#
  do ';\tPascalTrap\t'->BC.putT; TrapId->BC.putT; eoo
  #)
--SetTop:descriptor--
  (#
  do '\tlea\t'->BC.putT; (7,off, false) -> IndirectReg;
     sep; (7,0,false) -> AdrReg; eoo
  #)
--comment:dopart--
do '## ' -> BC.putT; T -> BC.putT; eoo
--VirtLabDef:descriptor--
(#do 'L' -> BC.putC; labNo -> BC.putI; ':' -> BC.putC #)  
--jsrT:dopart--
do '\tcall\t'->BC.putT; T->BC.putT; eoo
--jmpT:dopart--
do '\tjmp\t' -> BC.putT; T->BC.putT; eoo
--jmpTlong:dopart--
do '\tjmp\t' -> BC.putT; T->BC.putT; eoo
--gJmp:dopart--
do '\tjmp\t' -> BC.putT; op.putOp; eoo
--gJsr:dopart--
do '\tcall\t' -> BC.putT; op.putOp; eoo
--rts:dopart--
do '\tret\t' -> BC.putT; eoo
--gClr:dopart--
do (op[],none)->ldOps;
   '\tmov' -> BC.putT; 4->BC.putS; '$0,' -> BC.putT; op.putOp; eoo
--Push:descriptor--
(#
do (op[],none)->ldOps; 0->mstate.addressSize;
   '\tpushl\t' -> BC.putT; op.putOp; eoo 
#)
--Pop:descriptor--
(#
do  (op[],none)->ldOps; 0->mstate.addressSize;
   '\tpopl\t'->BC.putT; op.putOp;eoo 
#)
--ldCst:dopart--
do (R[],none)->ldOps; '\tmov'->BC.putT; 4->BC.putS; C.putOp; BC.sep; R.putOP; eoo
--cstLoadOp:dopart--
do
--cstOpLoadToReg:dopart--
do
--stCst:descriptor--
(#
do (A[],none)->ldOps; 
   '\tmov'->BC.putT; size->BC.putS; C.putOp; BC.sep; A.putOP; eoo 
#)
--ldByte:descriptor---
(#
do (op1[],op2[])->ldOps;
   (op1[],op2[],1)->chkEmitReg 
#)
--ldHalf:descriptor---
(#
do (op1[],op2[])->ldOps;
   (op1[],op2[],2)->chkEmitReg 
#)
--ldVal:descriptor--
(# 
do (A[],R[])->ldOps;
   (A[],R[],4)->chkEmitReg 
#)
--ldValFromLab:dopart--
do (L[],R[])->ldOps;
   (L[],R[],4)->chkEmitReg 
--ldVl:descriptor--
(#
do (A[],R[])->ldOps;
   (A[],R[],size)->chkEmitReg 
#)
--stByte:descriptor---
(#
do (op1[],op2[])->ldOps;
   '\tmov'->BC.putT; 1->BC.putS; op1.putOp; BC.sep; op2.putOP; eoo
#)
--stHalf:descriptor---
(#
do (op1[],op2[])->ldOps;
   '\tmov'->BC.putT; 2->BC.putS; op1.putOp; BC.sep; op2.putOP; eoo
#)
--stVal:descriptor--
(#
do (R[],A[])->ldOps;
   '\tmov'->BC.putT; 4->BC.putS; R.putOp; BC.sep; A.putOP; eoo 
#)
--stValInLab:dopart--
do (R[],L[])->ldOps;
   '\tmovl\t'->BC.putT; R.putOp; BC.sep; L.putOP; eoo;
--cpReg:dopart--
do (R1[],R2[])->ldOps;
   '\tmov'->BC.putT; 4->BC.putS; R1.putOp; BC.sep; R2.putOP; eoo
--cpByteMem:descriptor--
(# dr: @dataRegOperand
do dr.alloc;
   (A1[],dr[])->ldOps;
   '\tmov'->BC.putT; 1->BC.putS; A1.putOp; sep; dr.putOp; eoo;
   (A2[],dr[])->ldOps;
   '\tmov'->BC.putT; 1->BC.putS; dr.putOp; sep; A2.putOp; eoo;
   dr.deAlloc;
#)
--cpHalfMem:descriptor--
(# dr: @dataRegOperand
do dr.alloc;
   (A1[],dr[])->ldOps;
   '\tmov'->BC.putT; 2->BC.putS; A1.putOp; sep; dr.putOp; eoo;
   (A2[],dr[])->ldOps;
   '\tmov'->BC.putT; 2->BC.putS; dr.putOp; sep; A2.putOp; eoo;
   dr.deAlloc;
#)
--cpMem:descriptor--
(# regNo: @integer; dr: @dataRegOperand
do (* move Memory to Memory:
    * op1 and op2 are both memory locations.
    * For Motorola 68xxx this is the same as gmove;
    * for Intel 80386 it is not possible to move one
    * memory location to another 
    *)
   dr.alloc;
   (A1[],dr[])->ldOps;
   '\tmov'->BC.putT; 4->BC.putS; A1.putOp; sep; dr.putOp; eoo;
   (A2[],dr[])->ldOps;
   '\tmov'->BC.putT; 4->BC.putS; dr.putOp; sep; A2.putOp; eoo;
   dr.deAlloc
#)
--stValInText:dopart--
do (op[],none)->ldOps; '\tmov\t'->BC.putT; op.putOp; BC.sep; L.putOP; eoo
--gLea:descriptor---
(#
do (op1[],op2[])->ldOps; 
   '\tlea\t'->BC.putT; op1.putOp; sep; op2.putOP; eoo 
#)  
--leaToPrimReg:descriptor--
(# ar: @AdrRegOperand
do ar.alloc; 
   (op1[],ar[])->ldOps; (op1[],ar[])->gLea;
   (ar[],op2[])->ldOps; (ar[],op2[])->cpReg;
#)
--gLeaLabel:descriptor---
(#
do (op1[],op2[])->gLea
#)
--ChkCase:dopart--
   (* inx = caseIndex-min
    * if inx >unsigned  (max-min) the  goto elseLab
    * This ALSO works if caseIndex < min.
    * Similar to ChkIndex below.
    * Note that min is NOT used here.
    *)
do '\tcmpl\t$'->BC.putT; (max-min)->BC.putI; sep;
   inx.putOp;
   '\n\tja\t'->BC.putT; elseLab.putOp; eoo
--ChkIndex:descriptor--
(#
do (*'ChkIndex'->comment;*)
   (op1[],op2[])->ldOps; 
   '\tbound'->BC.putT; 4->BC.putS; op2.putOp; sep; op1.putOP; eoo 
#)
--ChkHeap:descriptor--
(#  Lok,Lfail: @LocalLab
do Lfail.new; Lok.new;
   dumpR;
   (op[],none)->ldOps;
   '\tcmpl\tIOA,'->BC.putT; op.putOp;
   '\n\tjb\t'->BC.putT; Lfail.putOp; 
   '\n\tcmpl\tIOA+4,'->BC.putT; op.putOp;
   '\n\tjb\t'->BC.putT; Lok.putOp; BC.putNL;
   Lfail.def;
   op[]->push;
   'ChkRA'->jsrT;
   Lok.def;
   op[]->gClr; (***<<<<<<<<<<<<<<<<<<< *******)
   dumpR
#)
--SignExtByte:descriptor--
(#
do (op[],none)->ldOps;
   (*'\tmovsx\t'->BC.putT;  not know by assembler - the following is a guess!!*)
  '\tmovsb'->BC.putT; 4->BC.putS;
   2->mstate.addressSize; op.putOp; sep; 
   0->mstate.addressSize; op.putOp; eoo 
#)
--SignExtWord:descriptor--
(#
do (op[],none)->ldOps;
   (*'\tmovsx\t'->BC.putT; not know by assembler - the following is a guess!!*)
   '\tmovsw'->BC.putT; 4->BC.putS;
   1->mstate.addressSize; op.putOp; sep; 
   0->mstate.addressSize; op.putOp; eoo 
#)
--GetBits:descriptor--
(************** NOTE: since the IX386 is little endian, the bit position (pos)
 * is transformed as follows:
 * 
 * 	32 - (pos+length) -> pos
 * 
 *)
(*  shift left op1,pos:		shl   op1,pos
 *  shift right p1,32-length    shr   op1,32-length
 * Note that op1=op2=some data register
 *)
(# 
do 32 - (pos+length) -> pos;
   (op1[],none)->ldOps;
   '\tshl'->BC.putT; 4->BC.putS; '$'->BC.putC; pos->BC.putI; sep; op1.putOp; 
   '\n\tshr'->BC.putT; 4->BC.putS; '$'->BC.putC; 32-length->BC.putI; sep; 
   op1.putOp; eoo
#)
--GetSignedBits:descriptor--
(*  shift  left op1,pos:		shl   op1,pos
 *  ashift right p1,32-length    	sar   op1,32-length
 * Note that op1=op2=some data register
 *)
(# 
do 32 - (pos+length) -> pos;
   (op1[],none)->ldOps;
   '\tshl'->BC.putT; 4->BC.putS; '$'->BC.putC; pos->BC.putI; sep; op1.putOp;
   '\n\tsar'->BC.putT; 4->BC.putS; '$'->BC.putC; 32-length->BC.putI; sep; 
   op1.putOp; eoo
#)
--gGetBits:dopart--
   (* NOTE: since the IX386 is little endian, the bit position (pos)
    * is transformed as follows:
    *
    *      32 - (pos+length) -> pos
    *
    *)
   (*  shift left op1,pos:         shl   op1,pos
    *  shift right p1,32-length    shr   op1,32-length
    * Note that op1=op2=some data register
    *)
do (*'gGetBits'->comment;*)
   (dr[],none)->ldOps;
   '\tadd'->BC.putT; 4->BC.putS; lDr.putOp; sep; pDr.putOp;
   '\n\tneg'->BC.putT; 4->BC.putS; pDr.putOp;
   '\n\tadd'->BC.putT; 4->BC.putS; '$32,'->BC.putT; pDr.putOp; BC.putNL;
   pDr[]->GetCL
   (# do '\tshl'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; dr.putOp; BC.putNL #);
   '\tneg'->BC.putT; 4->BC.putS; lDr.putOp;
   '\n\tadd'->BC.putT; 4->BC.putS; '$32,'->BC.putT; lDr.putOp; BC.putNL;
   lDr[]->GetCL
   (# do '\tshr'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; dr.putOp; BC.putNL #)
--gGetSignedBits:dopart--
   (*  shift  left op1,pos:                shl   op1,pos
    *  ashift right p1,32-length           sar   op1,32-length
    * Note that op1=op2=some data register
    *)
do (*'gGetSignedBits'->comment;*)
   (dr[],none)->ldOps;
   '\tadd'->BC.putT; 4->BC.putS; lDr.putOp; sep; pDr.putOp;
   '\n\tneg'->BC.putT; 4->BC.putS; pDr.putOp;
   '\n\tadd'->BC.putT; 4->BC.putS; '$32,'->BC.putT; pDr.putOp; BC.putNL;
   pDr[]->GetCL
   (# do '\tshl'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; dr.putOp; BC.putNL #);
   '\n\tneg'->BC.putT; 4->BC.putS; lDr.putOp;
   '\n\tadd'->BC.putT; 4->BC.putS; '$32,'->BC.putT; lDr.putOp; BC.putNL;
   lDr[]->GetCL
   (# do '\tsar'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; dr.putOp; BC.putNL #);
--PutBits:dopart--
(*  op1 -> op2[pos:length]
 * 
 *  andl  mask1,op1 		   clear bits outside bitfield of source
 *  shl   32-pos-length,op1
 *  movl  op2, dr		   get destination 
 *  andl  NOT(mask2),dr                 clear bitfield in destination
 *  orl   op1,dr		   or destination with source -> destination
 *  movl  dr,op2		   store destination back
 * 
 * NOTE: drF is a free data register. In operations like
 *    (@@X,7)->TOS'%putBits[12,9]
 * drF is used to compute drF, but it is free when putBits is called.
 * It could have been freed in gen1 before calling putbits, but
 * this will also require changes to evval2:listEvVal:asgToInlinePrim.
 *)
do (# dr: @dataRegOperand; rN,m: @integer; mask: @text;
   
      putHex:  (* should be moved to betaenv.stream *)
        (# i,j,n,noOfSpaces: @ integer; 
           negative: @ boolean; c: [20] @ integer;
           max: (#a,b: @integer
                enter(a,b)
                do (if a<b then b->a if)
                exit b
                #);
           width:<(# value: @integer do 8->value; inner exit value#)
        enter n
        do (n<0)->negative ;
           (if negative then -n-1->n if);
           0->i;
           loop:
             (if ((i=0) or (0 < n)) then
                 i+1->i;
                 (n mod 16)->c[i];
                 n div 16->n;
                 restart loop
             if);
           (0,(width-i))->max->noOfspaces;
           (# t: [i+noOfspaces] @char
           do
              (if negative
               // false then (for l: noOfspaces repeat '0'->t[l] for);
               else (for l: noOfspaces repeat 'F'->t[l] for);
              if);
              (for l: i repeat 
                   c[i-(l-1)]->j;
                   (if negative then 15-j->j if);
                   (if true// (j<10) then
                       j+'0'->t[l+noOfspaces];
                    else j-10+'A'->t[l+noOfspaces] 
              if)for);
              '0'->BC.putT; 'x'->BC.putC;
              (for i:T.range repeat T[i]->BC.putC for)
        #)#)
      
   do 32 - (pos+length) -> pos;
      dumpR;
      (1 %sll length_ - 1 ->m;
      
      (op1[],none)->ldOps;
      '\tandl\t$'->BC.putT; m->putHex; sep; op1.putOp; eoo;
      
      '\tshll\t$'->BC.putT; 32-pos-length->BC.putI; sep; op1.putOp; eoo;
      
      dr.alloc;
      (dr[],op2[])->ldOps;
      '\tmovl\t'->BC.putT; op2.putOp; sep; dr.putOp; eoo;
      
      %Bnot m ->m;
      (for i: 32-pos-length repeat (m %sll 1)+1->m for);
      dumpR;
      '\tandl\t$'->BC.putT; m->putHex; sep; dr.putOp;
      dumpR;
      (op1[],dr[])->ldOps;
      '\n\torl\t'->BC.putT; op1.putOp; sep; dr.putOp; eoo;
      dumpR;
      (dr[],op2[])->ldOps;
      '\tmovl\t'->BC.putT; dr.putOp; sep; op2.putOp; eoo;
      dr.deAlloc
   #)
--gPutBits:dopart--
   (*  dr -> ar[pDr:lDr]
    *
    *  and   op1,mask1                clear bits outside bitfield of source
    *  shl   op1,32-(pos+length)
    *  mov   dr,op2                   get destination
    *  and   dr,NOT(mask2)            clear bitfield in destination
    *  or    dr,op1                   or destination with source -> destination
    *  mov   op2,dr                   store destination back
    *
    * NOTE: drF is a free data register. In operations like
    *    (@@X,7)->TOS'%putBits[12,9]
    * drF is used to compute drF, but it is free when putBits is called.
    * It could have been freed in gen1 before calling putbits, but
    * this will also require changes to evval2:listEvVal:asgToInlinePrim.
    *)
do (* shift dr into correct position *)
   pDr[]->GetCL
   (# do '\tshl'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; dr.putOp; BC.putNL #);
   
   (* save dr *)
   '\tpushl\t'->BC.putT; dr.putOp; BC.putNL;
   
   (* build mask *)
   '\tmovl\t$1,'->BC.putT; dr.putOp; BC.putNL;
   lDr[]->GetCL
   (# do '\tshll\t%cl,'->BC.putT; dr.putOp; BC.putNL #);
   '\tdecl\t'->BC.putT; dr.putOp; BC.putNL;
   
   (* shift mask into position *)
   pDr[]->GetCL
   (# do '\tshll\t%cl,'->BC.putT; dr.putOp; BC.putNL #);
   
   (* pDr no longer needed *)
   
   (* clear bits in ar *)
   '\tnotl\t'->BC.putT; dr.putOp;
   '\n\tandl\t'->BC.putT; dr.putOp; sep; ar.putOp; BC.putNL;
   
   (* restore dr *)
   '\tnotl\t'->BC.putT; dr.putOp; BC.putNL;
   
   (* restore dr into pDr *)
   '\tpopl\t'->BC.putT; pDr.putOp; BC.putNL;
   
   (* clear unused bits in dr (alias pDr) *)
   '\tandl\t'->BC.putT; dr.putOp; sep; pDr.putOp; BC.putNL;
   
   (* Put value in place *)
   '\torl\t'->BC.putT; pDr.putOp; sep; ar.putOp; eoo;
--ByteSwap:descriptor--
(# dr1: @dataRegOperand; restoreEAX: @boolean
do dr1.alloc;
   (ar[],dr1[])->ldOps;
   (if long then
       '\tmovl\t('->BC.putT; ar.putOp; '),'->BC.putT; dr1.putOp
    else
       '\tmovw\t('->BC.putT; ar.putOp; '),'->BC.putT; dr1.putOp
   if);
   BC.putNL;
   (if rep.dmap[dr1.rn+1]// eax then (* ok*)
    else
       true->restoreEAX;
       '\tpush\t%eax\n'->BC.putT;
       '\tmovl\t'->BC.putT; dr1.putOp; ',%eax\n'->BC.putT
   if);
   (if long then
       (*'\tbswap\t('->BC.putT; ar.putOp; ')\n'->BC.putT*)
       '\txchgb\t%ah,%al\n\trorl\t$16,%eax\n\txchgb\t%ah,%al\n'->BC.putT
    else (* short *)
       '\txchgb\t%ah,%al\n'->BC.putT
   if);
   (if restoreEAX then 
       '\tmovl\t%eax,'->BC.putT; dr1.putOp; 
       '\n\tpop\t%eax\n'->BC.putT
   if);
   (if long then
       '\tmovl\t'->BC.putT; dr1.putOp; ',('->BC.putT; ar.putOp; ')\n'->BC.putT
    else
       '\tmovw\t'->BC.putT; dr1.putOp; ',('->BC.putT; ar.putOp; ')\n'->BC.putT
   if);
   dr1.deAlloc
#)
--arithShiftLeft:dopart-- 
(* in most (all?) cases shiftleft is a with a constant argument.
 * The code below is thus very inefficient
 * In evval1.:asgToInline and gen1.inlineprimitive
 * it should be possible to optimize this situation.
 * Note %cl is lower byte of %ecx.
 * Note: the description of shiftArith (sal) and shift logical (shl)
 * in the Intel book seem to be identical? This is because arithmetic
 * and logical shift is almost the same for INTEL arithmetic shift shifts
 * in the sign byte whereas logical does NOT.
 * BETA logical shift corresponds to INTEL rotate instructions:
 * NO! I seem to be wrong - BETA logical shift is NOT rotate
 *)
do (op1[],op2[])->ldOps;
   (if op1.isCstOp then
       '\tsal'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->getCL
       (# do '\tsal'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; op2.putOp; eoo #)
   if)
--arithShiftRight:dopart-- 
do (op1[],op2[])->ldOps;
   (if op1.isCstOp then
       '\tsar'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->getCL
       (# do '\tsar'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; op2.putOp; eoo #)
   if)
--logicalShiftLeft:dopart-- 
do (op1[],op2[])->ldOps;
   (if op1.isCstOp then
       '\tshl'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->getCL
       (# do '\tshl'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; op2.putOp; eoo #)
   if)
--logicalShiftRight:dopart-- 
do (op1[],op2[])->ldOps;
   (if op1.isCstOp then
       '\tshr'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->getCL
       (# do '\tshr'->BC.putT; 4->BC.putS; '%cl,'->BC.putT; op2.putOp; eoo #)
   if)
--rotateLeft:doPart--
do (if op1.isCstOp then
       '\trol'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->GetCL
       (# do '\trol'->BC.putT;4->BC.putS;'%cl,'->BC.putT;op2.putOp;BC.putNL #)
   if)
--rotateRight:doPart---
do (if op1.iscstOp then
       '\tror'->BC.putT; 4->BC.putS; op1.putOp; sep; op2.putOp; eoo
    else
       op1[]->GetCL
       (# do '\tror'->BC.putT;4->BC.putS;'%cl,'->BC.putT;op2.putOp;BC.putNL #)
   if)
--gAdd:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\tadd'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo
#)
--gSub:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\tsub'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo
#)
--gNeg:descriptor--
(# 
do (op[],none)->ldOps; '\tneg'->BC.putT; size->BC.putS; op.putOp; eoo 
#)
--gCmp:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\tcmp'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo 
#)
--gMult:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\timul\t' -> BC.PutT; op1.putOp; sep; op2.putOP; eoo
#)
--gDiv:descriptor--
(* op1: ^mOperand, op2: ^ doubleDataRegOperand
 *
 * NOTE: op1 may be a DataRegOperand in op2.dNo1 - ugly!
 * (This is no longer possible!!)
 * 
 * Generate code for:
 * 	op2.dNo2 div op1 -> (op2.dNo1,op2.dNo2)
 * 
 * where op2.dNo1 is remainder, 
 * and   op2.dNo2 is quotient
 * 
 * Intel 386 instruction:
 *	idiv r/m32, %eax:	signed divide edx:eax by r/m32 ;
 * 				where edx is sign-extension of eax;
 *	 			results: eax=quotient, edx=remainder
 * 
 * push %edx	%edx is thisReg, bit used by idiv
 * op1->%eax
 * op2->%ebx
 * cdq		sign extend eax to edx
 * idiv %ebx,%eax
 * %eax->op2.dNo1
 * %edx->%ebx->op2.dNo1
 * pop %edx
 *
 *)
(# 
   swap: 
     (* eax->edx, ebx->eax, edx->ebx *)
     (#
     do (if common.switch[45] then 'swap'->comment if);
        '\tmovl\t%eax,%edx\n\tmovl\t%ebx,%eax\n\tmovl\t%edx,%ebx\n'->BC.putT;
     #);
   op1ToEBX:
     (* move op1 to register %ebx *)
     (#
     do (if common.switch[45] then 'op1ToEBX'->comment if);
        L: (#
           do (if op1.isDataRegOp then
                  (if rep.dMap[op1Reg+1]//ebx then 
                      (* op1 already in %edx *) leave L 
              if)if);
              (op1[],EBX)->getFreg;
              (if true
               // op1.isAddress then
                  (op1[],dataRegB[])->ldVal; 
               // op1.isLocalLabOp then
                  (op1[],dataRegB[])->ldValFromLab; 
               // op1.isRegOp then
                  (op1[],dataRegB[])->cpReg; 
               else
                  cError(# do 'op1ToEBX: unKnown op1' -> T #);
              if)
           #)#);
   op2ToEAX:
     (* move op2 to register %eax *)
     (#
     do (if common.switch[45] then 'op2ToEAX'->comment if);
        (if rep.dmap[op2.dNo2+1]//eax then (* op2 already in %eax *)
         else
            (* get EAX *)
            (op2.dNo2[],EAX)->getFreg;
            (op2.dNo2[],dataRegA[])->cpReg;
        if);
        (*op2.dNo2.deAlloc*)
     #);
   isFreg:
     (* returns true if logical register rn is assigned 
      * to physical register fn
      *)
     (# rn,fn: @integer; b: @boolean
     enter(rn,fn)
     do rep.dMap[rn+1]=fn -> b
     exit b
     #);
   op1Reg: ^dataRegOperand;
   op1InEAX,op2InEBX: @boolean;
do dumpR;
   
   '\tpush\t%edx' -> BC.putT; eoo; (* save %edx = thisObj *)
   
   (* find out in which registers op1/op2 are *)
   (if op1.isDataRegOp then
       op1[]->op1Reg[];
       (if op2.dNo1=op1Reg then (* suk! *) 
           (* op1 is in a register but NOT op2.dNo1 *)
           (* this can never happen *)
           cerror(#do '\ngdiv argument error'->T #);
        else (* op1 is in the register op2.dNo1 *)
       if);
      (op1reg.rN,eax)->isFreg->op1InEAX
   if);
   op2.dNo1.deAlloc;
   (op2.dNo2,ebx)->isFreg->op2InEBX;

   (if op1InEAX and op2InEBX then 
       (* op1 are in %eax but should be in %ebx;
        * op2 are in %ebx but should be in %eax;
        * i.e. %eax and %ebx must be swapped
        *)
       swap
    else
       (if op1InEAX then
           (* op1 is in %eax (i.e. NOT %ebx), 
            * and op2 is NOT in %ebx;
            * we may move op1 to %ebx
            *)
           op1ToEBX;
           op2ToEAX
        else
           (* op1 is NOT in %eax; we may move op2 to %eax *)
           op2ToEAX;
           op1ToEBX
   if)if);
   op2.dNo2.deAlloc;

   '\tcdq\n'->BC.putT; 			(* sign extend %eax to %edx *)
   '\tidivl\t%ebx,%eax\n'->BC.putT;	(* finally we may divide! *)

   dumpR;

   (* at this point eax and ebx are allocated to idiv  *)
   (* in some situations op2.dNo2 is via reUse alloacted twice.
    * i.e. op2.dNo2 may still be assigned to eg eax
    *)
   (if rep.dReg[op2.dno2+1]//0 then 
       op2.dNo2.Alloc
    else
       cError(#do 'Linux:gDiv:op2.dno2>0'-> T #)
   if);

   (* assign dNo2 to eax *)
   eax->rep.dMap[op2.dNo2+1]; op2.dNo2+1->rep.fMap[eax];
   
   (* assign dNo1 to ebx *)
   op2.dNo1.alloc; 
   (*(none,EBX)->GetFreg;*)
   ebx->rep.dMap[op2.dNo1+1]; op2.dNo1+1->rep.fMap[ebx];
   '\tmovl\t%edx,%ebx\n' -> BC.putT;
   
   '\tpop\t%edx\n' -> BC.putT;    (* restore %edx = thisObj *)
   dumpR;  
#)
--gOr:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\tor'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo 
#)
--gAnd:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\tand'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo
#)
--gXor:descriptor--
(# 
do (op1[],op2[])->ldOps;
   '\txor'->BC.putT; size->BC.putS; op1.putOp; sep; op2.putOP; eoo 
#)
--gNot:descriptor--
(# 
do (op[],none)->ldOps;
   '\tadd'->BC.putT; size->BC.putS; '$1,' -> BC.putT; op.putOp; 
   '\n\tand\t$1,' -> BC.putT; op.putOp; eoo
#)
--LogNot:descriptor--
(# 
do (op[],none)->ldOps;
   '\tnot'->BC.putT; size->BC.putS; op.putOp; eoo 
#)
--gGetDataByte:descriptor--
(* this slot implements
 * 	 X->TOS'%getByte[i]', where i=0,1,2,3
 * X is loaded to a register. Since the IX386 is little-endian
 * byte[0] is the least significant bits
 * ...
 * byte[3] are the most significant. 
 * The if- cases 0,1,2,3 are thus reverse of the big-endian MC68
 *)
(#
do (op1[],none)->ldOps;
   (if byteNo
    // 3 then (* rotate left 8 bits *)
       '\trol'->BC.putT; 4->BC.putS; '$8,'->BC.putT; op1.putOp; eoo
    // 2 then 
       (* swap register halves.
        * the 486 has a bswap operation, but this is not on the 386.
        * the xchg operation seems only for swapping bytes?
        *)
       '\trol'->BC.putT; 4->BC.putS; '$16,'->BC.putT; op1.putOp; eoo
    // 1 then (* rotate right 8 bits *)
       '\tror'->BC.putT; 4->BC.putS; '$8,'->BC.putT; op1.putOp; eoo
   if);
   '\tand'->BC.putT; 4->BC.putS; '$255,'->BC.putT; op1.putOp; eoo
#)
--gGetDataWord:descriptor--
(* Supports
 * 	X->TOS'%getShort[i]', where i=0,1
 * X is loaded into register. 
 * As for gGetDataByte, the if-cases are reverse of the MC68.
 * See above
 *)
(#
do (op1[],none)->ldOps;
   (if wordNo//2 then
       (* for some reason wordNo=2*i for i in getShort[i] *)
       '\tror'->BC.putT; 4->BC.putS; '$16,'->BC.putT; op1.putOp; eoo
   if);
   '\tand'->BC.putT; 4->BC.putS; '$0xffff,'->BC.putT; op1.putOp; eoo
#)
--JumpIfTrue:descriptor--
(#
do '\tjnc\t'->BC.putT; op.putOp; eoo
#)
--gBeq:descriptor--
(#
do '\tje\t'->BC.putT; op.putOp; eoo
#)
--gBge:descriptor--
(#do '\tjge\t'->BC.putT; op.putOp; eoo#)
--gBne:descriptor--
(#do '\tjne\t'->BC.putT; op.putOp; eoo#)
--gBae:descriptor--
(#do '\tjae\t'->BC.putT; op.putOp; eoo#)
--gBle:descriptor--
(#do '\tjle\t'->BC.putT; op.putOp; eoo#)
--gBbe:descriptor--
(#do '\tjbe\t'->BC.putT; op.putOp; eoo#)
--gBgt:descriptor--
(#do '\tjnle\t'->BC.putT; op.putOp; eoo#)
--gBab:descriptor--
(#do '\tja\t'->BC.putT; op.putOp; eoo#)
--gBlt:descriptor--
(#do '\tjl\t'->BC.putT; op.putOp; eoo#)
--gBbl:descriptor--
(#do '\tjb\t'->BC.putT; op.putOp; eoo#)
--trap:descriptor--
(* should make a case on trap, cond=4 => le *)
(* OLM: it seems that one of the instructions int/into should be used *)
(#do(* '\ttle\n'->BC.putT *)#)
--initExternalCall:dopart--
do
--CallCproc:descriptor--
(#
do (if extType
    // 2 (* pascExt *) then '\tcall\t'->BC.putT
    else (* 1=cExt *) '\tcall\t'->BC.putT
   if);
   T->BC.putT; eoo
#)
--PopCword:descriptor--
(#do '\tpop\tax'->BC.putT; eoo #)
--CstOpPut:dopart--
do '$'->BC.putC; C->BC.putI
--TextOpPut:dopart--
do T->BC.putT
--DataRegOpPut:dopart--
do rN -> DataReg
--AdrRegOpPut:dopart--
do (if ind then (rN, 0, false) -> IndirectReg
    else (rN, 0, false) -> AdrReg if)
--stackTopAdrPutOp:descriptor--
(#do '(%sp)+'->BC.putT #)
--doubleDataRegPut:descriptor--
(#do 'doubleDataReg' -> NotCompleted #)
--LocalLabDef:dopart--
do (if type = interFragment then
       asText -> export;
       asText -> labelDef
   if);
   'L' -> BC.putC; labNo->BC.putI; ':'->BC.putC; eoo
--LocalLabPut:dopart--
do (if type = interFragment then
       asText -> BC.putText
    else
       'L' -> BC.putC; labNo->BC.putI
   if)
--StackOffPut:descriptor--
  (#
  do (7,off,false) -> IndirectReg
  #)
--AssemblerHeader:descriptor--
(# 
do '\t## INTEL-386 generated by beta compiler' -> BC.putT; eoo;
   (* '\tNAME\t BETA'->BC.putT; localPath->BC.putT;  eoo; eoo; *)
   
   '\t.data\n\t.globl\tpReg1,pReg2,pReg3,pReg4,pReg5\n'->BC.putT;
   
   '\t.text\n\t.align 2\n'->BC.putT;
   
   &physRegOperand[]->dataRegA[]; 5->dataRegA;
   &physRegOperand[]->dataRegB[]; 6->dataRegB;
   &primRegOperand[]->dataRegX[]; 1->dataRegX;
   &primRegOperand[]->dataRegY[]; 2->dataRegY;
   
   (* initial allocation - is not necessary when all ldOps have been
    * inserted in the code
    *)
   (* assign th,ca,a2,a3 to physical registers *)
   (for i:4 repeat
        i->rep.aMap[i]; i->rep.fMap[i]
   for);
   (* assign sp to physical register *)
   8->rep.aMap[8]; 8->rep.fMap[8];
   (* assign d0,d1,d2 to physical registers *)
   (for i:3 repeat
        i+4->rep.dMap[i]; i->rep.fMap[i+4]
   for)
#)
--DebugHeader:descriptor--
(##)
---BeginProtoTypes:descriptor---
(#
do '.data\n' -> BC.putT;
#)
--SwitchToData:descriptor--
(#do '.data\n'->BC.putT #)
--SwitchToCode:descriptor--
(#do '.text\n'->BC.putT #)
--Export:dopart--
do '.globl\t'-> BC.putT; Lab->BC.putT; eoo;
(*    Lab[] -> libState.exportedLabels.add; *)
--Import:descriptor--
(#
do (if wasAdded then
       (if common.switch[45] then
	   '/* \t.IMPORT '->BC.putT; Lab->BC.putT; ' CODE */\n'->BC.putT;
       if);
   if);
   (* (if (lab[]<>none) then
    (if TRUE
    // (lab[] -> libState.importedLabels.isDefined) then
    else 
    lab[] -> libState.importedLabels.add
    if)
    else
    '*** SHOULD NOT HAPPEN: No label in import!' ->bugstream.putline;
    if)*)
#)
--ImportData:descriptor--
(#
do (if common.switch[45] then
       (if wasAdded then
           '/* \t.IMPORT '->BC.putT; Lab->BC.putT; ' DATA '->BC.putT;
           (if local then
               ' from local data segment */\n'->BC.putT
            else
               ' from external data segment */\n'->BC.putT
           if)           
       if);
   if)
#)
--DeclareLong:descriptor--
(#do '\t.long\t' -> BC.putT;  N->BC.putI; eoo #)
--DeclareAddress:descriptor--
(#do '\t.long\t' -> BC.putT;  op.putOp; eoo #)
--DeclareWord:descriptor--
(#do '\t.word\t' -> BC.putT; N->BC.putI;  eoo #)
--DclWord:descriptor--
(#do '\t.word\t' -> BC.putT;  n ->BC.putI; eoo #)
---EmitBytes:descriptor--
(#do INNER emitBytes; BC.putNl #)
--EmitByte:descriptor--
(#
do (if cnt mod 10 // 0 then 
       (if cnt//0 then else BC.putNL if);
       '\t.byte\t'->BC.putT 
    else BC.sep 
   if);
   B->BC.putHexByte 
#)
--Skip:descriptor--
(#  #)
--AsciiZ:descriptor--
(* For sun3 the output has the form
 *\t.asciz "........"
 * Chars with a value less that ' ' (32) are converted to
 * the form \ooo where ooo is the octal value of the character.
 * Chars with an ascii value greater than 128 are converted to ' '.
 * The char '"' is printed as '\"'.
 * Note: the Linux assembler cannot handle strings, like
 * "...\0110..."
 * i.e. more than 3 digits following '\'. It eats all 4 digits,
 * but should only take 3. Therefore '.byte' instructions are generated
 * for char values < 32
 *)
(# inAscii: @boolean
do T.scanAll
   (# 
   do (if (ch<' ')or(ch>127) then
          (if inAscii then '"'->BC.putC; BC.putNL if);
          '\t.byte\t'->BC.putT; ch->BC.putI; BC.putNL;
          false->inAscii;
          (*
          '\\'->BC.putC; 
          '0'+(ch div 64)->BC.putC; (ch mod 64)->ch;
          '0'+(ch div  8)->BC.putC; (ch mod  8)->ch;
           '0'+ch->BC.putC;
           *)
       else
          (if inAscii//false then '\t.ascii\t"' -> BC.putT if);
          true->inAscii;
          (if ch 
           // '"' then '\\'->BC.putC; '"'->BC.putC 
           // '\\' then '\\'->BC.putC; '\\'->BC.putC 
    else ch->BC.putC if)if)#);
   (if inAscii then '"' -> BC.putC if);
   '\n\t.byte\t0' -> BC.putT; eoo;
   (*(if (T.length MOD 2)//0 then '\t.byte\t0' -> BC.putT; eoo if);*)
   '.align 2\n' -> BC.putT 
#)
--defineMainLabel1:descriptor--
(# T: @text
do 'UoFV' -> T ; T[] -> export;  T[] -> labelDef;
   '\tpushl\t%edx\n' -> BC.PutT;
   '\tpushl\t$-37\n' 
     -> BC.PutT; (* UnorderedFval - see betarun/C/betaerror.h *)
   'BetaError' -> jsrT;
   rts;	
   'main' -> T ; T[] -> export;  T[] -> labelDef;
   'SetArgValues'->jsrT;
   '\tmovl\t$0,%ebp\n\tmovl\t$0,%esi\n\t\movl\t$0,%edi\n\tmovl\t$0,%edx\n'
     ->BC.putT
#)
--LabelDef:descriptor--
(#
do T->BC.putT; ':'->BC.putC; eoo;
#)
--SubDescriptorSlotEntry:descriptor--
(# #)
--RegInd:dopart--
do (R, 0, false) -> IndirectReg;
--RegisterOffSet:dopart---
do 'RegisterOffSet' -> NotCompleted
--FloatRegOpPut:descriptor--
(##)
--FloatRegOpLoad:descriptor--
(#
do (A[],none)->ldOps;
   '\tfldl\t'->BC.putT; A.putOp; eoo 
#)
--FloatRegOpStore:descriptor--
(#do (A[],none)->ldOps; '\tfstpl\t'->BC.putT; A.putOp; eoo #)
--FloatRegOpStoreTmp:descriptor--
(#
do this(floatRegOp)[]->A[]
#)
--floatRegOpStore2int:descriptor--
(#
do D.alloc; (A[],none)->ldOps;
   
   '# save old FPU control word and set chopping\n'->BC.putT;
   '\tpushl %eax\n'->BC.putT;
   '\tfnstcw -4(%esp)\n'->BC.putT;
   '\tmovl -4(%esp),%eax\n'->BC.putT;
   '\tmovb $12,%ah\n'->BC.putT;
   '\tmovl %eax,-8(%esp)\n'->BC.putT;
   '\tfldcw -8(%esp)\n'->BC.putT;
   '\tpopl %eax\n'->BC.putT;
   
   '\n\tfistpl\t'->BC.putT; A.putOp; eoo;
   
   '# restore old FPU control word\n\tfldcw -8(%esp)\n'->BC.putT;
   
   (A[],D[])->ldOps;
   '\tmovl\t'->BC.putT; A.putOp; BC.sep; D.putOp; eoo;
   deAlloc
   
#)
--float2int:doPart---
   (* FR: ^floatRegOp; dr: ^registerOperand *)
do (mstate.tmplab,none)->ldOps;
   '# save old FPU control word and set chopping\n'->BC.putT;
   '\tpushl %eax\n'->BC.putT;
   '\tfnstcw -4(%esp)\n'->BC.putT;
   '\tmovl -4(%esp),%eax\n'->BC.putT;
   '\tmovb $12,%ah\n'->BC.putT;
   '\tmovl %eax,-8(%esp)\n'->BC.putT;
   '\tfldcw -8(%esp)\n'->BC.putT;
   '\tpopl %eax\n'->BC.putT;
   
   '\n\tfistpl\t'->BC.putT; (mstate.tmplab).putOp; eoo;
   
   '# restore old FPU control word\n\tfldcw -8(%esp)\n'->BC.putT;
   
   (mstate.tmplab, dr[]) -> ldValFromLab;

--floatConst:descriptor---
(# Lab: @ localLab
do switchToData;
   FR.alloc;
   Lab.new; Lab.def; 
   '\t.double\t0f'->BC.putT; T->BC.putT; eoo;
   switchToCode;
   '\tfldl\t'->BC.putT; Lab.putOp; eoo
#)
--intReg2float:descriptor--
(# A1: @RegAdr; F: ^floatRegOp
do (A[],mstate.tmplab)->stValInLab;
   A1.reg.alloc;
   (mstate.tmplab,A1.reg[])->gLeaLabel;
   A1[]->int2float->F[]; F->FR; (* clumsy *)
   A1.reg.deAlloc
#)
--int2float:descriptor--
(#
do (A[],none)->ldOps; FR.alloc; '\tfildl\t'->BC.putT; A.putOp; eoo
#)
--cmpFloat:descriptor--
(#
do (A[],none)->ldOps;
   (if A.isFloatRegOp then 
       (* stack top operations. Generate fcompp - i.e. pop arguments*)
       (if (A[],LF[])->swapFreg then
           (* swap top fstack elements before compare *)
           '\tfxch\t%st(1)\n\tfcompp\n'->BC.putT
        else       
           '\tfcompp'->BC.putT
       if)
    else '\tfcompl\t'->BC.putT; A.putOp  (* cmp mem64 to stacktop *)
   if); 
   eoo 
#)
--fBeq:descriptor--
(#
do TstFloat
   (#
   do '\tje\t'->BC.putT; op.putOp; eoo
#)#)
--fBge:descriptor--
(#
do TstFloat
   (#
   do '\tjae\t'->BC.putT; op.putOp; eoo;
#)#)
--fBle:descriptor--
(#
do TstFloat
   (#
   do '\tjbe\t'->BC.putT; op.putOp; eoo;
#)#)
--fBne:descriptor--
(#
do TstFloat
   (#
   do '\tjnz\t'->BC.putT; op.putOp; eoo
#)#)
--fBgt:descriptor--
(#
do TstFloat
   (#
   do '\tja\t'->BC.putT; op.putOp; eoo
#)#)
--fBlt:descriptor--
(#
do TstFloat
   (#
   do '\tjb\t'->BC.putT; op.putOp; eoo
#)#)
--addFloat:descriptor--
(#
do (A[],none)->ldOps;
   '\tfadd'->BC.putT;
   (if AinFreg then (* fadd two top stack elements *)
       'p'->BC.putT
    else 'l\t'->BC.putT; A.putOp (* add mem64 to top stak element *)
   if);
   eoo 
#)
--subFloat:descriptor--
(#
do (A[],none)->ldOps;
   (* AinReg may be false even if A is in Freg.
    * see evval2:floatEvVal:sub
    *)
   (if A.isFloatRegOp then (* fsub two top stack elements *)
       (if (A[],LF[])->swapFreg then
           '\tfsubrp'->BC.putT
        else
           '\tfsubp'->BC.putT
       if)
    else '\tfsubl\t'->BC.putT; A.putOp (* add mem64 to top stak element *)
   if);
   eoo 
#)
--mulFloat:descriptor--
(#
do (A[],none)->ldOps;
   '\tfmul'->BC.putT; 
   (* AinReg may be false even if A is in Freg.
    * see evval2:floatEvVal:sub
    *)
   (if A.isFloatRegOp then (* fmul two top stack elements *)
       'p'->BC.putT;
       (* NOTE: linux asm converts 'fmul' into 'fmul ST,ST(1)' 
        * which does NOT pop. 'fmulp' is accepted although it is NOT in
        * the I486 manual.
        * Same seesm to happen for fadd, fsub,fdiv
        *)
    else 'l\t'->BC.putT; A.putOp (* add mem64 to top stak element *)
   if);
   eoo 
#)
--divFloat:descriptor--
(#
do (A[],none)->ldOps;
   (* AinReg may be false even if A is in Freg.
    * see evval2:floatEvVal:sub
    *)
   (if A.isfloatRegOp then (* fdiv two top stack elements *)
       (if (A[],LF[])->swapFreg then
           '\tfdivrp'->BC.putT
        else
           '\tfdivp'->BC.putT
       if)
    else '\tfdivl\t'->BC.putT; A.putOp (* add mem64 to top stak element *)
   if);
   eoo 
#)
--pushFloatReg:descriptor--
(#do 'pushFloatReg'->comment #)
--popFloatReg:descriptor--
(#do 'popFloatReg'->comment #)
--negFloat:descriptor--
(#
do 'negfloat' -> comment;
   '\tfchs\n'->BC.putT
#)
--PopCbyte:descriptor--
(* only relevant for MAC Pascal *)
(#
do '!!error: popCbyte'->BC.putT
#)
--xpar:descriptor--
(# extKind,top,(*parSize,*)longSize,wordSize: @integer;
   SP: @stackOff;
#)
--debugProtoInfo:descriptor--
(##)
--debuggPartInfo:descriptor--
(##)
--debugImpInfo:descriptor--
(##)
--debugBeforeEndMinfo:descriptor--
(##)
--debugAfterEndMinfo:descriptor--
(##)
--endDebugCode:descriptor--
(##)
--xParForward:descriptor--
(#
do (if extKind
    // 1 (* sematt.cExt*) then false->forward
    // 2 (* sematt.pascExt*) // 3 (* sematt.pascTrapExt*) then true->forward
if)#)
--toXres:descriptor--
(##)
---GetXbyte:descriptor--
(* only for MAC Pascal, byte and word are always word *)
(#
do Xpar.top->Xpar.SP; (XPar.SP[],dr[])->ldHalf;
   Xpar.top+Xpar.wordSize->Xpar.top
#)
--getXword:descriptor--
(#
do Xpar.top->Xpar.SP; (XPar.SP[],dr[])->ldHalf;
   Xpar.top+Xpar.wordSize->Xpar.top
#)
--getXlong:descriptor--
(#
do Xpar.top->Xpar.SP; (XPar.SP[],dr[])->ldVal;
   Xpar.top+Xpar.longSize->Xpar.top
#)
--initGetXpar:descriptor--
(#
do (if extKind->Xpar.extKind// 5 (*sematt.cCallBackExt*) then
       (* note on HP and MAC, 72->Xpar.top is the correct value.
        * On Linux fewer registers are pushed
        *)
       48->Xpar.top; 4->Xpar.longSize->Xpar.wordSize
       (* note cTop=pascTop+4 => cTop=48, pascTop=?? *)
    else (*pascCallBackExt*)
       (* NOTE: this has NOT been fixed for Pascal - 68 is the same as for hp*)
       68+((BC+SC)*2+LC*4(*->Xpar.parSize*))->Xpar.TOP;
       -4->Xpar.longSize; -2->Xpar.wordSize;
   if);
#)
--saveheapTop:descriptor--
(#
do '\tmovl\t%esp,BetaStackTop\n'->BC.putT
#)
--pushCfloat:descriptor--
(* is on top of f-stack - push to activation-stack *)
(#
do '\tsubl\t$8,%esp\n\tfstpl\t(%esp)\n'->BC.putT
#)
--PushCsingle:descriptor--
(#
#)

--PushClong:descriptor--
(#
do (op[],none)->ldOps; op[]->Push
#)
--PushCword:descriptor--
(#
do (op[],none)->ldOps; op[]->Push 
#)
--PushCbyte:descriptor--
(#
do (op[],none)->ldOps; op[]->Push 
#)
--PushCDoubleAdr:descriptor--
(# A1: ^address
do A.copy->A1[]; (*addOff changes A*)
   4->A.addOff->pushClong; A1[]->pushClong;
#)
--PushCtext:descriptor--
(##)
--callO:dopart--
do 1->rNo
--thisO:dopart--
do 0->rNo
--pushAdr:descriptor--
(# do '\tpushl\t$'->BC.putT; op.putOp; eoo #)
(* This is the older version which was slower, bigger and used a register.
 * {* there may not be a free adrReg here! *}
 * (# ar: @adrRegOperand
 * do ar.alloc; (op[],ar[])->ldOps; (op[],ar[])->gLea; ar[]->push; ar.deAlloc
 * #)
 *)
--inxRegAdrPutOp:dopart--
do (aReg,dReg,size,off,false)->IndexReg
--adrLoadFloatOp:descriptor--
(##)
--nop:descriptor--
(#do '\tnop\n'->BC.putT #)
--regAdrPutOp:dopart--
do (* guessing:*)
   (reg,off,false)->IndirectReg
--localLabLoadAdr:dopart--
do
--localLabAstext:descriptor--
(#
do 'L'->localLabText.put; labNo->localLabText.putInt
#)
--textOpLoadAdr:dopart--
do
--putS:dopart---
do (if size
    //4 then 0->mstate.addressSize; 'l'->BC.putC;
    //2 then 1->mstate.addressSize; 'w'->BC.putC;
    //1 then 2->mstate.addressSize; 'b'->BC.putC
   if);
   '\t'->BC.putT
--putA:descriptor--
(##)
--putD:descriptor--
(##)
--imm:descriptor--
(#do '$'->put; off-> putI #)
--newCtextOp:descriptor--
(# do T[]->op #)

(****************** the following forms are from MC68machine.bet ************)
--BeginLabel:doPart--
do
(# sp,aReg:@adrRegOperand; A: @regAdr
do aReg.alloc; 7->sp;
   (sp[],aReg[])->cpReg;
   ('lastCompBlock'->NewCtextOp,aReg[],4)->gSub;
   thisO->A.reg; common.direct->A.access; off->A.off;
   (aReg[],A[])->stVal;
   aReg.deAlloc;
#)
--endLabel:doPart--
do 
--pushThisOrCall:descriptor--
(#
do (if pushTh then thisRegOp[]->push if);
   (if pushCa then callRegOp[]->push if)
#)
--popThisOrCall:descriptor--
(#
do (if popCa then callRegOp[]->pop if);
   (if popTh then thisRegOp[]->pop if)
#)
--InxRegAdrPushRegAndOff:descriptor--
(#
do ((off div 4)->newCstOp,dReg[],4)->gAdd; 
   aReg[]->pushClong; dReg[]->pushClong
#)
--cmpToBool:descriptor--
(# Lab: @localLab
do (if true then
       (op1[],op2[],size)->gCmp;
       (cond,op3[],size)->SetCC
    else
       (1->NewCstOp,op3[])->ldCst;
       (op1[],op2[],size)->gCmp;
       Lab.new;
       (if cond (* IF T1 cc R then goto L *)
        // 1 (* =  *) then Lab[]->gBeq
        // 2 (* <> *) then Lab[]->gBne
        // 3 (* <  *) then 
           (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
        // 4 (* <= *) then 
           (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
        // 5 (* >  *) then 
           (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
        // 6 (* >= *) then 
           (if size//4 then Lab[]->gBge else Lab[]->gBae if)
       if);
       (op3[],none)->ldOps;
       op3[]->gClr;
       Lab.Def;
   if)
#)
--cmpAndJmp:descriptor--
(#
do (op1[],op2[])->ldOps;
   (op1[],op2[],size)->gCmp;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->gBeq
    // 2 (* <> *) then Lab[]->gBne
    // 3 (* <  *) then 
       (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
    // 4 (* <= *) then 
       (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
    // 5 (* >  *) then 
       (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
    // 6 (* >= *) then 
       (if size//4 then Lab[]->gBge else Lab[]->gBae if)
   if)
#)
(* --cmpBoolAndJmp:descriptor--
 * (#
 * do 
 *    {* OLM: 8/3/95: tst - only here to be able to compile *}
 *    (if cond {* IF T1 cc R then goto L *}
 *     // 1 {* =  *} then Lab[]->gBeq
 *     // 2 {* <> *} then Lab[]->gBne
 *     // 3 {* <  *} then 
 *        (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
 *     // 4 {* <= *} then 
 *        (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
 *     // 5 {* >  *} then 
 *        (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
 *     // 6 {* >= *} then 
 *        (if size//4 then Lab[]->gBge else Lab[]->gBae if)
 *    if)
 * #)
 *)
--cmpBoolAndJmp:descriptor--
(#
do (0->NewCstOp,op[],size)->gCmp;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->gBeq
    // 2 (* <> *) then Lab[]->gBne
    // 3 (* <  *) then
       (if size = 4 then Lab[]->gBlt else Lab[]->gBbl if)
    // 4 (* <= *) then
       (if size = 4 then Lab[]->gBle else Lab[]->gBbe if)
    // 5 (* >  *) then
       (if size = 4 then Lab[]->gBgt else Lab[]->gBab if)
    // 6 (* >= *) then
       (if size = 4 then Lab[]->gBge else Lab[]->gBae if)
   if);
#)
--cmpToBoolFloat:descriptor--
(# Lab: @localLab
do (if true//false then
       (op2[],op1[])->cmpFloat; (* notice operand order *)
       (* a  SetCC for float is necessary -
        * fCond codes must be moved to EHFLAGS before testing!
        * And probably other tests (below instead of less )
        * must be used
        *)
       (cond,op3[],0)->SetCC (** DONT WORK - BUT IS NOT USED *)
    else
       (op3[],none)->ldOps;
       (1->NewCstOp,op3[])->ldCst;
       (op2[],op1[])->cmpFloat; (* notice operand order *)
       Lab.new;
       (if cond (* IF T1 cc R then goto L *)
        // 1 (* =  *) then Lab[]->fBeq
        // 2 (* <> *) then Lab[]->fBne
        // 3 (* <  *) then Lab[]->fBlt
        // 4 (* <= *) then Lab[]->fBle
        // 5 (* >  *) then Lab[]->fBgt
        // 6 (* >= *) then Lab[]->fBge
       if);
       op3[]->gClr;
       Lab.Def
   if)
#)
--cmpAndJmpFloat:descriptor--
(#
do (if op1.isFloatRegOp then
       (* stack top operation - compare top elements, 
        * BUT unless pop is true top-1 MUST be kept on the stack after compare,
        * since it may be used in subsequent compares
        *)
       (if (op1[],op2[])->swapFreg then
           (* Reverse condition instead of operands for non-symmetric conditions *)
           (if cond
                // 3 (* <  *) then 5 (* >  *) -> cond
                // 4 (* <= *) then 6 (* >= *) -> cond
                // 5 (* >  *) then 3 (* <  *) -> cond
                // 6 (* >= *) then 4 (* <= *) -> cond
           if);
       if);
       (if pop then
           (* Compare and pop two operands *)
           '\tfcompp\t'->BC.putT
        else
           (* Compare and pop only one operand *)
           '\tfcomp\t%st(1)'->BC.putT
       if);
    else 
       '\tfcoml\t'->BC.putT; op1.putOp  (* cmp mem64 op1 to stacktop *)
   if); 
   eoo ;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->fBeq
    // 2 (* <> *) then Lab[]->fBne
    // 3 (* <  *) then Lab[]->fBlt
    // 4 (* <= *) then Lab[]->fBle
    // 5 (* >  *) then Lab[]->fBgt
    // 6 (* >= *) then Lab[]->fBge
   if);
   (if not pop then
       (* If branch not taken *)
       popFstack;
   if)
#)
--popFstack:descriptor--
(* during cmpAndJmpFloat the fval is kept on the fstack - it must
 * be popped when no more tests are to be performed - before 'else'
 * of if no 'else' after 'if'.
 *)
(#
do (* '\tfldz\nfcompp\n'->BC.putT; *) (* 9 clock cycles *)
   '\tffree\t%st(0)\nfincstp\n'->BC.putT; (* 6 clock cycles *)
#)
--tstNone:descriptor--
(# dr: @dataRegOperand; L: @localLab
do dr.alloc; 
   (A[],dr[])->ldOps;
   (A[],dr[])->ldVal; 
   4 (*le*) -> trap;
   (* since no trap currently, an explicit test is carried out.
    * Only a temporary solution
    *)
   L.new;
   '\ttestl\t' -> BC.puttext; dr.putop; sep; dr.putop; BC.newline;
   (*(0->newCstOp,dr[],4)->gCmp;*)
   L[]->gBgt;
   'RefNone'->jsrT;
   L.def;
   (dr[],R[])->ldOps;
   (dr[],R[])->cpReg;
   dr.deAlloc;
#)
--SaveReturn:descriptor--
(* this fragment contains fragment forms which are common for all 
 * Motorola based machines
 *)
(#
do thisRegOp[]->push;
   (callRegOp[],thisRegOp[])->cpReg
#)
--Return:descriptor--
(#
do (thisRegOp[],callRegOp[])->cpReg;
   thisRegOp[]->Pop;
   rts
#)
--ExternalEntry:descriptor--
(#  
do entryId[]->labelDef;
#)
--SaveInnerReturn:dopart--
do
--ExternalMark:descriptor---
(##)
--ExternalReturn:descriptor--
(# do rts #)
--ReturnInner:dopart--
do rts
--RegAdrIndex:descriptor--
(# IA: @InxRegAdr; aR: @adrRegOperand; A1: @RegAdr; log: @integer;
do reAlloc->aR; (thisOp,aR[])->ldVal; freeAdr;
   aR->A1.reg; 8->A1.off;
   (if not common.switch[14] then 
       (*'ChkIndex from RegAdrIndex'->comment;*)
       (A1[],dReg[])->ChkIndex 
   if);
   
   (* @@R[i] = R.start + protoHead.size + (i-1)*size
    *        = R.start + protoHead.size - size + i*size
    * where 
    *    protohead.size = 16  if  simple
    *    protohead.size = 24  if  not simple
    *)
   (if isSimple then
       (if size
        // 1 then 15->IA.off
        // 2 then 14->IA.off
        // 4 then 12->IA.off
        // 8 then 8->IA.off
        else cerror(#do '\nIllegal index offset!'->T #)
       if);    
       size->IA.size; (* OBS only OK for size=1,2,4,8 *)
    else
       24-size->IA.off;
       (if size
        // 4 
        // 8 then
           (* use indexed adressing with scale *)
           size -> IA.size;
        else
           (* multiply *)
           (if (size->exact_log2->log) <> -1 then
               (log->newCstOp,dreg[])->logicalShiftLeft;
            else
               (size->newCstOp,dReg[],4)->gMult
           if);
           1->IA.size;
       if);
   if);
   aR->IA.aReg; dReg->IA.dReg; 
   access->IA.access;
   IA[]->A[];
#)
---RegAdrLoadOp:descriptor--
(##)
--InxRegAdrLoadFloatOp:descriptor---
(##)
---RegAdrLoadAdrOp:descriptor--
(#do this(RegAdr)[]->op[] #)
--RegAdrLoadAdr:dopart--
do
--InxRegAdrLoadOp:descriptor---
(##)
--InxRegAdrLoadAdrOp:descriptor--
(##)
--InxRegAdrLoadAdr:dopart---
do
--addMem:descriptor--
(# dr: @dataRegOperand
do (op1[],op2[],4)->gAdd;
   dr.alloc; (op2[],dr[])->ldVal; dr[]->R[]
#)
(******************** external calls ***************)
--getRegForXres:descriptor--
(# drX: @ dataRegOperand
do -1->max;
   pushDataReg->max;
	 (* max>-1 if some data registers are in use;
	  * data registers [0,max] are pushed; d0, d1 may still be free;
	  * make sure they are allocated, since popReg will overwrite them.
          * OBS! It should be checked if this works for nested C-calls
	  *)
   0->dummyMax;
   L:
     (for i: max repeat
	  drX.alloc; drX->Rep.dummyReg[i]; (* D0,d1,...Dmax-1 *)
          353->trace(#do 'DummyAlloc:d'->xT; drX->xI;
                       ' max='->xT; max->xI
                    #);
	  (if (drX>max) then
              353->trace(#do 'releasedAgain'->xT #);
	      drX.deAlloc; i-1->dummyMax; 
              leave L
     if)for);
   saveReg;
   '\tpush\t%ebp\n' -> this(machine).BC.putT;
   '\tpush\t%esi\n' -> this(machine).BC.putT;
#)
--endX:descriptor--
(# drX: @ dataRegOperand
do (for j:dummyMax repeat
        353->trace(#do 'DummyRelease:d'->xT; Rep.dummyReg[j]->xI #);
        Rep.dummyReg[j]->drX; drX.deAlloc 
   for);
   (if extType
    // 1 (*sematt.cExt OOPS*) then (BC,SC,LC)->popCallStack
    // 2 (*sematt.pascExt OOPS*)
    // 3 (*semAtt.pascTrapExt OOPS*) then (BC,SC,LC)->popCallStack
   if);
   '\tpop\t%esi\n' ->this(machine).BC.putT;
   '\tpop\t%ebp\n' ->this(machine).BC.putT; 
   restoreReg;
       (* (if (max>=0) then max->popDataReg if) *)
   max->popDataReg
#)
--getXres:descriptor--
(# 
   getCres:
     (# 
     do (if (max>=0) then (dataRegA[],drA[])->cpReg if);
	(if exitType
	 //1 //2 //3 then drA[]->simpleRes
	 // 4 then (* text *)
	    (# drT: @dataRegOperand
	    do (extType,exitType,BC,SC,LC,max,dummyMax)->endX; 
	       true->endXcalled;
		   (* this situation can be very complicated:
		    * gen.copyCtext assume text in dataRegA;
		    * drA may not be dataRegA=EAX;
		    *)
	       (if (drA[],EAX)->UseFreg then textRes
		else
		  drT.alloc;
		   (if (drT[],EAX)->UseFreg then 
                       (* now its free! gylle! should NOT happen, since
                        * drT has not been assigned to a physical register
                        *)
		      (drA[],dataRegA[])->cpReg;
		      textRes;
		   else 
		      (dataRegA[],drT[])->cpReg;
		      (drA[],dataRegA[])->cpReg;
		      textRes; 
		      (drT[],dataRegA[])->cpReg;
		   if);
		   drT.deAlloc;
	       if); 
	       drA.deAlloc
	    #)
	 // 5 then (* rep *)  cError(#do 'Exit cProc: general rep'->t #)
	 // 6 then (* cStruc *)
		(* create an instance of theDesc->rA;
		 * movl d0-12(16?),rA@(12)
		 * this makes theDesc.R denotes the cStruc
		 * The adjustment of d0 is necessary,since the cStruc
		 * has no BETA structural attributes (PT,GC,low,high)
	         * access of the form rA.R[inx] with index check
		 * will NOT be possible *)
	     cError(#do 'Exit cProc: cStruc exit'->t #)
	 // 7 (*double*) then
	    (# FP: @floatRegOp
            do drA.deAlloc; (* NOT used when result is a flota val.
                             * Perhaps the drA.alloc; etc below should
                             * be moved to the places where drA is actually
                             * used!
                             *)
               FP.alloc; (* result on top of F-stack *)
               FP[]->floatRes
            #)
         // 10 (*data*) then
            (# dr: @dataRegOperand
            do dr.alloc;
               (* result is stored in memory cell corresponding to dr,
                * since all adr registers are popped later in endX 
                *)
               '\tmov'->this(machine).BC.putT;
               4->this(machine).BC.putS; drA.putOp; sep;
               (this(machine).BC[],'d',dr.Rn)->regT; this(machine).BC.putNL;
               -1->rep.dMap[dr.rN+1]; (* ar NOT i register *)
               (*(drA[],dr[])->cpReg;*)
               dr[]->dataRefRes;
            #)
        if)        
     #);
   getPascRes:
     (#
     do (if exitType
         //1 (*byte*) then
		 drA[]->gClr; drA[]->popCbyte; drA[]->simpleRes
         //2 (*word*) then
		 drA[]->gClr; drA[]->popCword; drA[]->simpleRes
         //3 (*long*) then drA[]->pop; drA[]->simpleRes
         //4 (*text*) then 
            'UnpackPascalText'->jsrT;
            (* address of Pascal text is on top of SP-stack;
             * UnpackPascalText must deliver adr. of BETA text somewhere!
             *)
            'ExternalPasc: exit text'->notImpl
         //5 (*rep*) then cError(#do 'ExternalPasc:exit rep'->T #)
         //6 (*cStruc*) then cError(#do 'ExternalPasc:exit cStruc'->T #)
         //7 (*double*) then
            (# 
            do drB.alloc;
               (if (max>=drB) then
                   cError(#do'ExternalPasc:max>=drB'->T#)if);
               drB[]->pop; drA[]->pop;
               (drA[],drB[])->doubleRes
            #)
        if)
     #);
   endXcalled: @boolean;
   drA,drB: @dataRegOperand
do drA.alloc; 
   (drA,EAX)->AssignRegToFreg;
   (* Does the next imp. have a mening on Ix86?*)
   (if (max>=drA) then cError(#do 'External: max>=drA'->T #)if);
   (if extType
    // 1 (*semAtt.cExt OOPS*) then getCres
    // 2 (*semAtt.pascExt OOPS*)//3 (*semAtt.pascTrapExt OOPS*) then getPascRes
    else cError(#do 'Illegal external exit type:'->T; extType->I #)
   if);
   (if endXcalled//false then (extType,exitType,BC,SC,LC,max,dummyMax)->endX if);
#)
--jsrReg:dopart--
do (* no indirect for INNER on I486 op.mkIndirect;*)
   '\tcall\t'->BC.putT; op.putOp; eoo
--jmpReg:dopart--
do (* no indirect for INNER on I486 op.mkIndirect;*)
   '\tjmp\t'->BC.putT; op.putOp; eoo
--JsrTable:descriptor--
(# do (A[],callRegOp[])->ldVal; callRegOp[]->JsrReg; #)
--RegAdrToOriginReg:descriptor--
(* access = common.direct;
 * reg and off may be defined
 *)
(#
do (reg[],dataRegX[])->cpReg;
   (if off//0 then (* off may be negative *)
    else
       (off->newCstOp,dataRegX[],4)->gAdd if)
#)
---PushReg:descriptor---
   (# ar: @adrRegOperand
   do (*351->cTrace(#do 'PushReg'->xT #);*)
      (for i: rep.aReg.range repeat
	   (if (rep.aReg[i]>0) then
	       (if (i<>callO+1) then
		   i-1->ar; ar[]->Push
      if)if)for);
      PushDataReg->max
   #)
---PushDataReg:descriptor---
   (# tag: @integer;
   do (* push possible busy dataregisters *)
      -1->rep.dMax;
      (for i: rep.dReg.range repeat
	   (if (rep.dReg[i]>0) then i-1->rep.dMax 
      if)for);
      (if (rep.dMax>-1) then
	  (for i: rep.dMax+1 repeat
	       (i-1)->NewDataRegOp->push
      for)if);
      (* push possible busy float registers *)
      (* see comment in INTELBmachine
      -1->rep.fMax;
      (for i: rep.floatReg.range repeat
           (if rep.floatReg[i]>0 then i-1->rep.fMax
      if)for);
      (if rep.fMax>-1 then
          (for i: rep.fMax+1 repeat
               (i-1)->pushFloatReg
       for)if);
       *)
      
      (* push data/float reg mark *)
      -((rep.dMax+1) (* +(rep.fMax+1)*2 *) + 4) -> tag;
      (if tag<-4 then
          tag->NewCstOp->push;
      if);
      rep.dMax->max (* max is ONLY dataReg max *)
   #)
---PopDataReg:descriptor---
   (# 
   do (if (max(*rep.dMax*) (*+rep.fMax*) > (*-2*) -1) then
	  4->setTop
      if);
          (* (for i: rep.fMax+1 repeat (rep.fMax-i+1)->popFloatReg for); *)
      (for i:max+1 repeat  (max-i+1)->NewDataRegOp->pop for)
   #)
---PopReg:descriptor---
   (# ar: @adrRegOperand; i: @integer
   do max->PopDataReg;
      (for j: rep.aReg.range repeat
           rep.aReg.range+1-j->i; (* i in [rep.aReg.range..1] *)
           (if (i<>(callO+1)) then
	       (if (rep.aReg[i]>0) then
		    i-1->ar; ar[]->pop
      if)if)for);
   #)
---initPrimCall:descriptor--
(# dr: @dataRegOperand; saved: @integer; ar: @adrRegOperand
do (if rep.aReg[6] (* a5 *) >0 then
       'InitPrimCall:a5 is busy - OK!'->bugstream.putline;
       true->primRep.a5Saved;
       6->ar; ar[]->push;
   if)
#)
---primRep:descriptor--
(# saved,used,busy: [8] @boolean; someSaved,a5Saved: @boolean;
   noOfPar: @integer (* will nested prim calls work here?*)
#)
--getPrimReg:descriptor--
(# dr: @primRegOperand;
do (* allocate prim register pNo *)
   pNo->dr;
   dr[]->primReg[]
#)
--CallPrim:descriptor--
(# d0: @dataRegOperand; (* initial value d0*)
do d0.alloc;
   (d0,EAX)->AssignRegToFreg;
   d0.dealloc;
   (* any previous assigment of EAX to some registers should now be undone*)
   T->jsrT
#)
--getPrimRes:descriptor--
(#
do (if res
    //0 (* ignore result *) 
    //2 then (* push to C *)
    else (* 1, 3 *)
       (* 3 should be optimized as for MIPS *)
       (* the result is returned in physical register EAX
        * a logical register must be allocated and assigned to EAX
        *)
       dr.alloc;
       (dr,EAX)->AssignRegToFreg;
       (* dr.dealloc; OLM 8/3/95: why was this deallochere before??
        * should give a lot of dataReg negative!
        *)
   if)
#)
(**************** register allocation ***************)
---GetAdr:dopart---
(* allocate a2,a3,a4,... *)
do 10->rN; (* just during testing *)
   L: (for i:5 repeat
           (if (rep.aReg[i+2]>0)//false then
               rep.aReg[i+2]+1->rep.aReg[i+2];
               i+1->rN;
               leave L
      if)for);
   (if rN > 4 then
       (# rNx: @integer
       do rN -> rNx;
          'AdrReg overflow'->comment; 2->rN; (* prevent index error *)
          rNx ->AdrRegOverflow;
   #)if)
---GetData:dopart---
do 10->rN; (* just during testing *)
   L: (for i:6 repeat
           (if (rep.dReg[i]>0)//false then
               rep.dReg[i]+1->rep.dReg[i];
               i-1->rN;
               leave L
      if)for);
   (if rN = 10 then 
       'DataReg overflow'->comment; 0->rN; (* prevent index error *)
       DataRegOverflow
   if)
---freeAdr:dopart---
do (# fNo: @integer
   do (if (callO<rNo)and(rNo<8) then
          (* count down rep.aReg[rNo+1] *)
          rep.aReg[rNo+1]-1->rep.aReg[rNo+1];
          (if rep.aReg[rNo+1]=0 then
              (* rNo need not be assigned to physical register anymore *)
              rep.aMap[rNo+1]->fNo; 
              0->rep.aMap[rNo+1]; 
              (if fNo>0 then 
                  0->rep.fMap[fNo]; 
              if);
              (* Save current physical assignment in 
               * THIS(RegisterOperand).fn for possible
               * later use in ReUse.
               *)
              fNo->fn;
           else
              (if (rep.aReg[rNo+1]<0) then
                  cError
                  (# S: @text
                  do 'AdrReg negative:a'->S; rNo->S.putInt; S[]->T; S->comment;
                     0->rep.aReg[rNo+1] 
                  #)
              if)
          if)
      if);
   #)
---adrRegInUse:dopart--
do rep.aReg[rN+1]>0 -> value
---dataRegInUse:dopart--
do rep.dReg[rN+1]>0 -> value
---freeData:dopart---
do (# fNo: @integer
   do (if (0<=rNo)and(rNo<8) then
          (* count down rep.dReg[rNo+1] *)
          rep.dReg[rNo+1]-1->rep.dReg[rNo+1];
          (if rep.dReg[rNo+1]=0 then 
              (* rNo need not be assigned to physical register anymore *)
              rep.dMap[rNo+1]->fNo; 
              0->rep.dMap[rNo+1]; 
              (if fNo>0 then 
                  0->rep.fMap[fNo];
              if);
              (* Save current physical assignment in 
               * THIS(RegisterOperand).fn for possible
               * later use in ReUse.
               *)
              fNo->fn;
           else
              (if (rep.dReg[rNo+1]<0) then
                  cError
                  (# S: @text
                  do 'DataReg negative:d'->S; rNo->S.putInt; S[]->T;S->comment;
                     0->rep.dReg[rNo+1] 
                  #)
              if)
          if)
      if)
   #)
---releaseReg:descriptor---
(#
do (for i: rep.aReg.range repeat 
        0->rep.aReg[i]->rep.dReg[i]->rep.dMap[i]
   for);
   (for i:3 repeat (* clear assignment to a2,a3,a4 
                    * aMap[1]= a0
                    * aMap[2]= a1
                    * aMap[3-5]= a2-a4
                    * aMap[6-7]= unused
                    * aMap[8]= sp
                    *)
        0->rep.aMap[i+2]
   for);
   (* clear assignment of %ebp, %esi. %eax, %ebx, %ecx *)
   (for i: 5 repeat  0->rep.fMap[i+2] for);
   
   (for i: rep.floatReg.range repeat 0->rep.floatReg[i]->rep.floatMap[i] for);
   0->rep.floatMapTop
#)
--noOfFreeDataReg:descriptor---
  (#do (for i: dataRegMax repeat (if rep.dReg[i+1]//0 then val+1->val if)for)#)
--DataRegOpReUse:descriptor--
(# N: @integer; 
do rN+1->N;
   (if (0<N) and (N<=rep.dReg.range) then
       rep.dReg[N]+1->rep.dReg[N];
       (if fn
        // 0 then
           (* not reusable *)
        // -1 then
           (* reuse from memory cell *)
           (* indicate in dMap that rN is in memory *)
           -1->rep.dMap[N]; 
        else
           (* in physical register *)
           (* indicate in dMap that rN is in fn *)
           fn->rep.dMap[N]; 
           (* indicate in fmap, that fn is used for rN *)
           N->rep.fMap[fn];
       if)
    else 
       'DataRegOpReuse: index error'->bugstream.putline
   if)
#)
--AdrRegOpReUse:dopart--
do rep.aReg[rN+1]+1->rep.aReg[rN+1];
   (if fn
    // 0 then
       (* not reusable *)
    // -1 then
       (* reuse from memory cell *)
       (* indicate in aMap that rN is in memory *)
       -1->rep.aMap[rN+1]; 
    else
       (* in physical register *)
       (* indicate in aMap that rN is in fn *)
       fn->rep.aMap[rN+1]; 
       (* indicate in fmap, that fn is used for rN *)
       rN+1->rep.fMap[fn];
   if);
---RegRep:descriptor---
(# aReg,dReg,aMap,dmap,fMap: [8] @ Integer; dMax: @integer;
   
   (* floatReg keeps track of allocation of floating point regsiters.
    * The i386, however, has NO floating point registers,
    * but a stack! The registers are therefore hypothetical.
    * A FP register represents a value on the FPU stack.
    * Since the FPU is a stack it is necessary to keep track
    * of the order of the FP registers on the stack. They are pushed 
    * in order they are allocated. The array floatMap keep
    * track of the allocation order of FP registers.
    * In a given expression, the registers may be allocated
    * in the order
    *    fp0, fp1, fp2, fp0
    * after allocation of fp2, fp0 is released and then allocated
    * again. The register number can therefore NOT be used to determine
    * the order on the stack. When a fp-register is allocated, it
    * i assigned an increasing value kept in floatMap. For the above
    * sequence we have
    *    fM[fp0]=1, fM[fp1]=2, fM[fp2]=3, fM[fp0]=4
    * Given two FP resgisters, the one with the highest fM number
    * is on top of the stack. This info is used in swapFreg
    *)
   floatReg,
   floatMap: [8] @ integer; 
   fMax,floatMapTop: @integer; 
   dummyReg:[100]@integer; (* used by getRegForX /endX*)
#)
--FloatRegOpAlloc:descriptor--
(#
do 10->rN;
   L:
     (for i: rep.floatReg.range repeat
 	  (if rep.floatReg[i]//0 then
	      rep.floatReg[i]+1->rep.floatReg[i]; 
              rep.floatMapTop+1->rep.floatMapTop->rep.floatMap[i];
              i-1->rN;
              leave L
if)for)#)
--FloatRegOpDeAlloc:descriptor--
(#do (if (0<=rN) and (rN<rep.floatReg.range) then
         rep.floatReg[rN+1]-1->rep.floatReg[rN+1] 
      else 'FloatReg inx err.'->bugstream.putLine
if)#)
--FloatRegOpReUse:descriptor--
(#do rep.floatReg[rN+1]+1->rep.floatReg[rN+1]  #)
---DumpReg:descriptor--
   (# dmp:
      (# R: @char; i,V: @integer;
      enter(R,i,V)
      do R->T.put; i-1->T.putInt; ':'->T.put; V->T.putInt
      #);
      T: @text
   do common.tracestream.newline;
      (for i:rep.aReg.range repeat ('a',i,rep.aReg[i])->dmp for);
      (for i:rep.dReg.range repeat ('d',i,rep.dReg[i])->dmp for);
      T[]->common.tracestream.putText; (*T->comment;*)
      common.tracestream.newline;
      dumpR
   #)
---GetCallReg:descriptor--
   (# ar: @adrRegOperand
   do (*(if (rep.aReg[callO+1]>0) then
          CallO->ar; ar[]->push
      if); *)
      rep.aReg[callO+1]+1->rep.aReg[callO+1];
      (*351->cTrace(#do 'GetCallReg'->T #)*)
   #)
---DecrCallReg:descriptor---
   (#
   do rep.aReg[callO+1]-1->rep.aReg[callO+1];
      (if (rep.aReg[callO+1]<0) then
	  0->rep.aReg[callO+1];
	  cError(#do 'CallReg negative: a1'-> T#);
   if)#)
---FreeCallReg:descriptor--
   (# ar: @adrRegOperand; (*A1: @RegAdr*)
   do rep.aReg[callO+1]-1->rep.aReg[callO+1];
   #)
--CallRegBusy:doPart--
do (rep.aReg[callO+1]>0) -> value
--CallRegInPrimReg2:doPart--
do false -> value
--GetOriginReg:descriptor--
(# #)
--freeOriginReg:descriptor--
(##)
--callAlloPrim:descriptor--
(#do T->jsrT #)
--getVirtualOriginStart1:descriptor--
(* the code generated here may be called from a place where the address
 * registers are in use. aR.alloc is thus not a safe way of allocating
 * an address register. Its current value must thus be saved (pushed)
 * before it is used.
 *)
(# A1: @RegAdr; aR: @adrRegOperand; pReg: @primRegOperand
do aR.alloc; aR[]->push;
   1->pReg; (pReg[],ar[])->cpReg;
   aR->A1.reg; A1[]->startA[]
#)
--getVirtualOriginStart2:descriptor--
(# A1: ^ RegAdr; pReg: @primRegOperand
do startA[]->A1[]; (* inefficient*)
   (if not OriginRegIsDefined then
       (* OLM: 8.5.98 *)
       A1.toOriginReg; (* will deAlloc A1.reg*)
   if);
   A1.reg[]->pop;
#)
---Final2VirtJump:descriptor--
(# A1: ^ RegAdr
do startA[]->A1[]; (* inefficient*)
   A1[] -> pop
#)
--InitMachine:descriptor--
(#
do BC.openWrite; 
   true->loadPrototype;
#)
--CloseMachine:descriptor--
(#
do BC.close
#)
--asgRefAdr:descriptor--
(* assign A to thisAddress *)
(# aR,aR1,aR2: @adrRegOperand; L: @localLab; T: @Text;
   A1: @regAdr; dr: @dataRegOperand
do (*'asgRefAdr' -> comment;*)
   common.direct->access; (* this Address is a dynamic reference *)
   (* this is a hack. Will not work for arrays !!!*)
   toReg2->aR->aR2; (* aR=destination *)
   (if A.access //common.direct then
       (*(if aR1//thisO then true->A1.frozenReg (*else aR1.deAlloc * )if);*)
       (* aR1 = thisO possible in this(P)[]->R[] *)
       (if A.regType//thisO//callO then
           A.toReg2->aR1; (* 12.10.92*) (* aR1=source *)
           (* A.freeAdr; 12.10.92: in evval1: asgToAdr: A[]->rA.asgRefAdr->..
            * A[] is used in thisVal and cannot be released.
            * The problem is if this can imply that regs are not released?
            *)
           (*aR.mkIndirect; olm: ? - eliminated *)
           (* (aR1[],aR[])->stVal; *) (* datpete: ?? *)
           aR->A1.reg; (* olm: ? *) 
           (aR1[],A1[])->stVal;
           aR1.deAlloc
        else
           (* A and aR1 use the same register - dont deAlloc aR1.
            * However A is invalidated since aR1 is redefined
            *)
           aR[]->push;
           (A[],aR[])->gLea; dr.alloc; (aR[],dr[])->cpReg;
           aR[]->pop;
           (* aR.mkIndirect; olm: ? - elim*)(* dont do this before push/pop *)
           (* (dr[],aR[])->stVal; *) (* datpete: ?? *)
           (*olm: ? *) aR->A1.reg; (dr[],A1[])->stVal;
           dr.deAlloc
       if)
       (*aR1.deAlloc; 12.10.92*) (* 2.9.92*)
       (* A1[]->A[] 2.9.92*)
    else 
       (*aR.mkIndirect; olm: ? - eliminated*)
       (* (A[],aR[])->cpMem *) (* datpete: ?? *)
       (*olm: ? *) aR->A1.reg; (A[],A1[])->cpMem;
   if);
   aR2[]->dest[]
#)
--asgRefReg:descriptor-- (* MUST be fixed like asgRefAdr above *)
(* as asgRefAdr, but A is an adrRegOperand *)
(# aR,aR1,aR2: @adrRegOperand; L: @localLab; T: @Text; A1: @RegAdr
do (*'asgRefReg' -> comment;*)
   common.direct->access; (* this Address is a dynamic reference *)
   toReg2->aR->aR2; (* aR=destination *)
   (* aR.mkIndirect; olm: ? - eliminated *)
   (* (A[],aR[])->stVal; *) (* datpete: ?? *)
   (*olm: ? *) aR->A1.reg; (A[],A1[])->stVal;
   (* aR2[]->ChkHeap;
    aR2.deAlloc*)
   aR2[]->dest[]
#)
---targetEntryPointInfo:descriptor--
(##)
---addTargetInfo:doPart----
do
---entryPointsInsert:doPart---
do
--entryPointsEqual:descriptor---   
(##)
---SPtoPrimReg:doPart---
do
--externalDispatch:descriptor--
(# do 'externalDispatch'->putline; #)
--Lock:descriptor--
(# do 'Lock'->putline; #)
--Unlock:descriptor--
(# do 'Unlock'->putline; #)
--enablePreemption:descriptor--
(# do 'enablePreemption'->putline; #)
--disablePreemption:descriptor--
(# do 'disablePreemption'->putline; #)
--allocObj:dopart--
do 'allocObj'->putline;
--SaveCodeState:doPart--
do
--restoreCodeState:doPart--
do
--EmitCk: descriptor--
(##)
