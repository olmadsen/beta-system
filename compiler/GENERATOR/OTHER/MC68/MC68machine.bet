ORIGIN 'machine';
BODY 'CODEmachine';
--leaToPrimReg:descriptor--
(# ar: @AdrRegOperand
do ar.alloc; (op1[],ar[])->gLea;
   (ar[],op2[])->cpReg;
#)
--BeginLabel:doPart--
do (# sp,aReg:@adrRegOperand; A: @regAdr
   do aReg.alloc; 7->sp;
      (sp[],aReg[])->cpReg;
      ('lastCompBlock'->NewCtextOp,aReg[],4)->gSub;
      thisO->A.reg; common.direct->A.access; off->A.off;
      (aReg[],A[])->stVal;
      aReg.deAlloc;
   #)
--endLabel:doPart--
do
--pushThisOrCall:descriptor--
(#
do (if pushTh then thisRegOp[]->push if);
   (if pushCa then callRegOp[]->push if)
#)
--popThisOrCall:descriptor--
(#
do (if popCa then callRegOp[]->pop if);
   (if popTh then thisRegOp[]->pop if)
#)
--InxRegAdrPushRegAndOff:descriptor--
(#
do ((off div 4)->newCstOp,dReg[],4)->gAdd; 
   aReg[]->pushClong; dReg[]->pushClong
#)
--cmpToBool:descriptor--
(# Lab: @localLab
do (1->NewCstOp,op3[])->ldCst;
   (op1[],op2[],size)->gCmp;
   Lab.new;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->gBeq
    // 2 (* <> *) then Lab[]->gBne
    // 3 (* <  *) then
       (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
    // 4 (* <= *) then 
       (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
    // 5 (* >  *) then 
       (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
    // 6 (* >= *) then 
       (if size//4 then Lab[]->gBge else Lab[]->gBae if)
   if);
   op3[]->gClr;
   Lab.Def;
#)
--cmpAndJmp:descriptor--
(#
do (op1[],op2[],size)->gCmp;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->gBeq
    // 2 (* <> *) then Lab[]->gBne
    // 3 (* <  *) then
       (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
    // 4 (* <= *) then 
       (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
    // 5 (* >  *) then 
       (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
    // 6 (* >= *) then 
       (if size//4 then Lab[]->gBge else Lab[]->gBae if)
   if);
#)
(* --cmpBoolAndJmp:descriptor--
 * (#
 * do {* OLM: 8/3/95:
 *     * test op ? -- this slot is ONLY inserted to be able to compile!!
 *     *}
 *    (if cond {* IF T1 cc R then goto L *}
 *     // 1 {* =  *} then Lab[]->gBeq
 *     // 2 {* <> *} then Lab[]->gBne
 *     // 3 {* <  *} then
 *        (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
 *     // 4 {* <= *} then 
 *        (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
 *     // 5 {* >  *} then 
 *        (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
 *     // 6 {* >= *} then 
 *        (if size//4 then Lab[]->gBge else Lab[]->gBae if)
 *    if);
 * #)
 *)
--cmpBoolAndJmp:descriptor--
(#
do (***** SPARC:
    * op.loadOp->op[];
    * '\ttst\t'->BC.putT; op.putOp; eoi;
    *    (if cond {* IF T1 cc R then goto L *}
    *     // 1 {* =  *} then '\tbeq\t'->BC.putX
    *     // 2 {* <> *} then '\tbne\t'->BC.putX
    *     // 3 {* <  *} then '\tblt\t'->BC.putX
    *     // 4 {* <= *} then '\tble\t'->BC.putX
    *     // 5 {* >  *} then '\tbgt\t'->BC.putX
    *     // 6 {* >= *} then '\tbge\t'->BC.putX
    *    if);
    *    Lab.putOp; nopDelay
    *)
   
   (0->NewCstOp,op[],size)->gCmp;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->gBeq
    // 2 (* <> *) then Lab[]->gBne
    // 3 (* <  *) then
       (if size//4 then Lab[]->gBlt else Lab[]->gBbl if)
    // 4 (* <= *) then 
       (if size//4 then Lab[]->gBle else Lab[]->gBbe if)
    // 5 (* >  *) then 
       (if size//4 then Lab[]->gBgt else  Lab[]->gBab if)
    // 6 (* >= *) then 
       (if size//4 then Lab[]->gBge else Lab[]->gBae if)
   if);
#)
--cmpToBoolFloat:descriptor--
(# Lab: @localLab
do (1->NewCstOp,op3[])->ldCst;
   (op2[],op1[])->cmpFloat; (* notice operand order *)
   Lab.new;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->fBeq
    // 2 (* <> *) then Lab[]->fBne
    // 3 (* <  *) then Lab[]->fBlt
    // 4 (* <= *) then Lab[]->fBle
    // 5 (* >  *) then Lab[]->fBgt
    // 6 (* >= *) then Lab[]->fBge
   if);
   op3[]->gClr;
   Lab.Def
#)
--cmpAndJmpFloat:descriptor--
(#
do (op2[],op1[])->cmpFloat;
   (if cond (* IF T1 cc R then goto L *)
    // 1 (* =  *) then Lab[]->fBeq
    // 2 (* <> *) then Lab[]->fBne
    // 3 (* <  *) then Lab[]->fBlt
    // 4 (* <= *) then Lab[]->fBle
    // 5 (* >  *) then Lab[]->fBgt
    // 6 (* >= *) then Lab[]->fBge
   if)
#)
--SaveReturn:descriptor--
(* this fragment contains fragment forms which are common for all 
 * Motorola based machines
 *)
(#
do thisRegOp[]->push;
   (callRegOp[],thisRegOp[])->cpReg
#)
--Return:descriptor--
(#
do (thisRegOp[],callRegOp[])->cpReg;
   thisRegOp[]->Pop;
   rts
#)
--ExternalEntry:descriptor--
(#do entryId[]->labelDef #)
--SaveInnerReturn:dopart--
do
--ExternalMark:descriptor---
(##)
--ExternalReturn:descriptor--
(# do rts #)
--ReturnInner:dopart--
do rts
--RegAdrIndex:descriptor--
(# IA: @InxRegAdr; aR: @adrRegOperand; A1: @RegAdr; log: @integer;
do 'RegAdrIndex' -> comment;
   reAlloc->aR; (thisOp,aR[])->ldVal; freeAdr;
   aR->A1.reg; 8->A1.off;
   (if not common.switch[14] then (A1[],dReg[])->ChkIndex if);
   
   (* @@R[i] = R.start + protoHead.size + (i-1)*size
    *        = R.start + protoHead.size - size + i*size
    * where 
    *    protohead.size = 16  if  simple
    *    protohead.size = 24  if  not simple
    *)
   (if isSimple then
   (if size
    // 1 then 15->IA.off
    // 2 then 14->IA.off
    // 4 then 12->IA.off
    // 8 then 8->IA.off
    else cerror(#do '\nIllegal index offset!'->T #)
   if);    
   size->IA.size; (* OBS only OK for size=1,2,4,8 *)
    else
       (*'## size is ' -> BC.puttext; size -> BC.putint; BC.newline;*)
       24-size->IA.off;
       (if size
        // 4 
        // 8 then
           (* use indexed adressing with scale *)
           size -> IA.size;
        else
           (* multiply *)
           (if (size->exact_log2->log) <> -1 then
               (log->newCstOp,dreg[])->logicalShiftLeft;
            else
               (size->newCstOp,dReg[],4)->gMult
           if);
           1->IA.size;
       if);
   if);
   (*'## IA.size is ' -> BC.puttext; IA.size -> BC.putint; BC.newline;*)

   aR->IA.aReg; dReg->IA.dReg; 
   access->IA.access;
   IA[]->A[];
   'End RegAdrIndex' -> comment;
#)
---RegAdrLoadOp:descriptor--
(##)
--InxRegAdrLoadFloatOp:descriptor---
(##)
---RegAdrLoadAdrOp:descriptor--
(#do this(RegAdr)[]->op[] #)
--RegAdrLoadAdr:dopart--
do
--InxRegAdrLoadOp:descriptor---
(##)
--InxRegAdrLoadAdrOp:descriptor--
(##)
--InxRegAdrLoadAdr:dopart---
do
--addMem:descriptor--
(# dr: @dataRegOperand
do (op1[],op2[],4)->gAdd;
   dr.alloc; (op2[],dr[])->ldVal; dr[]->R[]
#)
(******************** external calls ***************)
--getRegForXres:descriptor--
(# drX: @ dataRegOperand
do -1->max;
   pushDataReg->max;
   (* max>-1 if some data registers are in use;
    * data registers [0,max] are pushed; d0, d1 may still be free;
    * make sure they are allocated, since popReg will overwrite them.
    * OBS! It should be checked if this works for nested C-calls
    *)
   0->dummyMax;
   L:
     (for i: max repeat
	  drX.alloc; drX->Rep.dummyReg[i]; (* D0,d1,...Dmax-1 *)
          (*353->trace(#do 'DummyAlloc:d'->xT; drX->xI #);*)
	  (if (drX>max) then
              (*353->trace(#do 'releasedAgain'->xT #);*)
	      drX.deAlloc; i-1->dummyMax; 
              leave L
     if)for);
   saveReg; (*saveHeapTop;*)
#)
--endX:descriptor--
(# drX: @ dataRegOperand
do (for j:dummyMax repeat
        (*353->trace(#do 'DummyRelease:d'->xT; Rep.dummyReg[j]->xI #);*)
        Rep.dummyReg[j]->drX; drX.deAlloc 
   for);
   (if extType
    // 1 (*sematt.cExt OOPS*) then (BC,SC,LC)->popCallStack
    // 2 (*sematt.pascExt OOPS*)
    // 3 (*semAtt.pascTrapExt OOPS*) then (BC,SC,LC)->popCallStack
   if);
   restoreReg;
       (* (if (max>=0) then max->popDataReg if) *)
   max->popDataReg
#)

-- jmpReg:doPart --
do op.mkIndirect; op[]->gJmp
--JsrTable:descriptor--
(# aR: @adrRegOperand
do callO->aR; (A[],aR[])->ldVal; aR.mkIndirect; aR[]->JsrReg
#)
--RegAdrToOriginReg:descriptor--
(* access = common.direct;
 * reg and off may be defined
 *)
(#
do (reg[],dataRegX[])->cpReg;
   (if off = 0 then (* offset may be negative *)
    else (off->newCstOp,dataRegX[],4)->gAdd if)
#)
---PushReg:descriptor---
(# ar: @adrRegOperand
do (*351->cTrace(#do 'PushReg'->T #);*)
   (for i: rep.aReg.range repeat
        (if (rep.aReg[i]>0) then
            (if (i<>callO+1) then
                i-1->ar; ar[]->Push
   if)if)for);
   PushDataReg->max
#)
---PushDataReg:descriptor---
(# T: @text
do (* push possible busy dataregisters *)
   -1->rep.dMax;
   (for i: rep.dReg.range repeat
        (if (rep.dReg[i]>0) then i-1->rep.dMax 
   if)for);
   (if (rep.dMax>-1) then
       (for i: rep.dMax+1 repeat
            (i-1)->NewDataRegOp->push
   for)if);
   (* push possible busy float registers *)
   -1->rep.fMax;
   (for i: rep.floatReg.range repeat
        (if rep.floatReg[i]>0 then i-1->rep.fMax
   if)for);
   (if rep.fMax>-1 then
       (for i: rep.fMax+1 repeat
            (i-1)->pushFloatReg
   for)if);
   (* push dat/float reg mark *)
   (if (rep.dMax+rep.fMax)>-2 then
       -((rep.dMax+1)+(rep.fMax+1)*2+4)->NewCstOp->push
   if);
   rep.dMax->max (* max is ONLY dataReg max *)
#)
---PopDataReg:descriptor---
(# T: @text
do (if (max(*rep.dMax*)+rep.fMax>-2) then
       4->setTop
   if);
   (for i: rep.fMax+1 repeat (rep.fMax-i+1)->popFloatReg for);
   (for i:max+1 repeat  (max-i+1)->NewDataRegOp->pop for)
#)
---PopReg:descriptor---
(# ar: @adrRegOperand; i: @integer
do max->PopDataReg;
   (for j: rep.aReg.range repeat
        rep.aReg.range+1-j->i; (* i in [rep.aReg.range..1] *)
        (if (i<>(callO+1)) then
            (if (rep.aReg[i]>0) then
                i-1->ar; ar[]->pop
   if)if)for);
#)
---primRep:descriptor--
(# saved,used,busy: [8] @boolean; someSaved,a5Saved: @boolean; 
   noOfPar: @integer; (* will nested prim calls work here?*)
   returnReg: @dataRegOperand;
   callprim_used: @boolean;
#)
---initPrimCall:descriptor--
(# dr: @dataRegOperand; saved: @integer; ar: @adrRegOperand
do (if rep.aReg[6] (* a5 *) >0 then
       'InitPrimCall:a5 is busy - OK!'->common.bugstream.putline;
       true->primRep.a5Saved;
       6->ar; ar[]->push;
   if);
   (for i: noOfPar->primRep.noOfPar repeat
        (if rep.dReg[9-i]>0 then
            8-i->dr;
            dr[]->push; 
            0->rep.dReg[9-i];
            true->primRep.saved[9-i]->primRep.someSaved; saved+1->saved
   if)for);
   (if saved >0 then (* push mark?*) if)
#)
--getPrimReg:descriptor--
(# dr: @dataRegOperand(# isPrimRegOp::trueValue #);
   pn: @integer
do (* allocate register D[pNo] *)
   8-pNo->pN; (* parameters are transferred in d7,d6,d5,... *)
   (* the following may be superflous *)
   (if rep.dReg[pN+1]>0 then
       '\nprim reg is busy\n'->common.bugstream.puttext
   if);
   1->rep.dReg[pN+1]; true->primRep.used[pN+1];
   pN->dr;
   dr[]->primReg[]
#)
--CallPrim:descriptor--
(# d0: @dataRegOperand; (* initial value d0*)
do (for i:8 repeat 
        (if primRep.used[i] then 
            0->rep.dReg[i]; false->primRep.used[i]
   if)for);
   primRep.returnReg.alloc; true->primRep.callprim_used;
   (if primRep.returnReg >0 then
       (* MUST be d0 - otherwise current d0 is pushed*)
       'save d0 in d0tmp'->comment;
       (d0[],d0tmp[])->stValInLab
       (*d0[]->push;*)
       (* push a mark?*)
   if);
   T->jsrT
#)
--getPrimRes:descriptor--
(# drx: @dataRegOperand; ar: @adrRegOperand;
   getRes: @
     (#
     do (if res
        //0 (*ignore result*) then
           (if primRep.callprim_used then
               primRep.returnReg.dealloc;
           if);
         //2 (* push to C - done by RT routine?*) then
           (if primRep.callprim_used then
               primRep.returnReg.dealloc;
           if);    
         else (* 1, 3 *)
            (* 3 should be optimized as for MIPS *)
           (if primRep.returnReg=0 then (* ok - result can stay in d0*)
               primRep.returnReg->dr
            else 
               (* move d0 to returnReg, 
                * restore d0 
                * make returnReg the result
                *)
                (dr[],primrep.returnReg[])->cpReg; (* dr is by default d0*)
                (*(primrep.returnReg[],dr[])->cpReg; - wrong? overrides d0*)
                'get d0 from d0tmp'->comment;
                (d0tmp[],dr[])->ldValFromLab;
                (*dr[]->pop;*)
                (* primRep.returnReg[]->pop; -- also wrong*)
                primRep.returnReg->dr;
        if)if);

     #)
do (if primRep.someSaved then
       (* realloc *)
       (for i:8 repeat
            (if primRep.saved[9-i] then
                1->rep.dReg[9-i]
       if)for);
       getRes;
       (* pop mark *)
       (for i:8 repeat
            (if primRep.saved[9-i] then
                false->primRep.saved[9-i];
                8-i->drx; drx[]->pop
       if)for);
       false->primRep.someSaved
    else (* allocation/deallocation of primreg MUST be cleaned UP*)
       (for i:primrep.noOfPar repeat
            0->rep.dReg[9-i]; false->primRep.used[9-i]
       for);
       getRes;
   if);
   (if primRep.a5Saved then
       'restore a5'->common.bugstream.putline;
       6->ar; ar[]->pop
   if);
   false->primRep.callprim_used;
#)
(**************** register allocation ***************)
---GetAdr:dopart---
(* allocate a2,a3,a4,... *)
do 10->rNo; (* just during testing *)
   L: (for i:5 repeat
           (if not (rep.aReg[i+2]>0) then
               rep.aReg[i+2]+1->rep.aReg[i+2];
               i+1->rNo;
               leave L
      if)for);
   (if (rNo>4) then
       (if rNo
	// 5 then cError(#do 'AdrReg overflow (a5)'->T #)
	// 6 then cError(#do 'AdrReg overflow (a6)'->T #)
	// 7 then cError(#do 'AdrReg overflow (a7)'->T #)
	else cError(#do 'AdrReg overflow (a8...)'->T #)
   if)if)
---GetData:dopart---
do 10->rNo; (* just during testing *)
   L: (for i:6 repeat
           (if not (rep.dReg[i] > 0) then
               rep.dReg[i]+1->rep.dReg[i];
               i-1->rNo;
               leave L
      if)for);
   (if rNo=10 then 
       cError(#do 'DataReg overflow'->T; 'DataReg overflow'->comment #) 
   if)
---freeAdr:dopart---
   (* do not try to deallocate thisO or callO.
    * sometimes they are allocated, 
    * which they should not have been
    *)
do (if (callO<rNo)and(rNo<8) then 
       rep.aReg[rNo+1]-1->rep.aReg[rNo+1];
       (if (rep.aReg[rNo+1]<0) then
           cError
           (# S: @text
           do 'AdrReg negative:a'->S; rNo->S.putInt; S[]->T; S->comment;
       0->rep.aReg[rNo+1] #)if)if)
---adrRegInUse:dopart--
do rep.aReg[rN+1]>0 -> value
---dataRegInUse:dopart--
do rep.dReg[rN+1]>0 -> value
---freeData:dopart---
do (if (0<=rNo)and(rNo<8) then
       rep.dReg[rNo+1]-1->rep.dReg[rNo+1];
       (if (rep.dReg[rNo+1]<0) then
           cError
           (# S: @text
           do 'DataReg negative:d'->S; rNo->S.putInt; S[]->T; S->comment;
              0->rep.dReg[rNo+1] 
#)if)if)
---releaseReg:descriptor---
(#
do (for i: rep.aReg.range repeat 0->rep.aReg[i]->rep.dReg[i] for);
   (for i: rep.floatReg.range repeat 0->rep.floatReg[i] for)
#)
--noOfFreeDataReg:descriptor---
(#do (for i: dataRegMax repeat (if rep.dReg[i+1] = 0 then val+1->val if)for)#)
--DataRegOpReUse:descriptor--
(# N: @integer
do rN+1->N;
   (if (0<N) and (N<=rep.dReg.range) then
       rep.dReg[N]+1->rep.dReg[N]
    else (*cError(#do 'DataRegOpReuse: index error'->T #)*)
       'DataRegOpReuse: index error'->bugstream.putline
if)#)
--AdrRegOpReUse:dopart--
do rep.aReg[rN+1]+1->rep.aReg[rN+1]
---RegRep:descriptor---
(# aReg,dReg: [8] @ Integer; dMax: @integer;
   floatReg: [8] @ integer; fMax: @integer; 
   dummyReg:[100]@integer; (* used by getRegForX /endX*)
#)
--FloatRegOpAlloc:descriptor--
(#
do 10->rN;
   L:
     (for i: rep.floatReg.range repeat
 	  (if rep.floatReg[i] = 0 then
	      rep.floatReg[i]+1->rep.floatReg[i]; i-1->rN;
              leave L
if)for)#)
--FloatRegOpDeAlloc:descriptor--
(#do (if (0<=rN) and (rN<rep.floatReg.range) then
         rep.floatReg[rN+1]-1->rep.floatReg[rN+1] 
      else 'FloatReg inx err.'->bugstream.putLine
if)#)
--FloatRegOpReUse:descriptor--
(#do rep.floatReg[rN+1]+1->rep.floatReg[rN+1]  #)
---DumpReg:descriptor--
(# dmp:
     (# R: @char; i,V: @integer;
     enter(R,i,V)
     do R->T.put; i-1->T.putInt; ':'->T.put; V->T.putInt
     #);
   T: @text
do common.tracestream.newline;
   (for i:rep.aReg.range repeat ('a',i,rep.aReg[i])->dmp for);
   (for i:rep.dReg.range repeat ('d',i,rep.dReg[i])->dmp for);
   T[]->putText; (*T->comment;*) common.tracestream.newline
#)
---GetCallReg:descriptor--
(# ar: @adrRegOperand
do (*(if (rep.aReg[callO+1]>0) then
    CallO->ar; ar[]->push
    if); *)
   rep.aReg[callO+1]+1->rep.aReg[callO+1];
   (*351->cTrace(#do 'GetCallReg'->T #)*)
#)
---DecrCallReg:descriptor---
(#
do rep.aReg[callO+1]-1->rep.aReg[callO+1];
   (if (rep.aReg[callO+1]<0) then
       0->rep.aReg[callO+1];
       cError(#do 'CallReg negative: a1'-> T#);
if)#)
---FreeCallReg:descriptor--
(# ar: @adrRegOperand; (*A1: @RegAdr*)
do rep.aReg[callO+1]-1->rep.aReg[callO+1];
#)
--CallRegBusy:doPart--
do (rep.aReg[callO+1]>0) -> value
--CallRegInPrimReg2:doPart--
do false -> value
--GetOriginReg:descriptor--
(# #)
--freeOriginReg:descriptor--
(##)
--callAlloPrim:descriptor--
(#do T->jsrT #)
--jmptLong:dopart--
do T->jmpT
--getVirtualoriginStart1:descriptor--
(* the code generated here may be called from a place where the address
 * registers are in use. aR.alloc is thus not a safe way of allocating
 * an address register. Its current value must thus be saved (pushed)
 * before it is used.
 *)
(# A1: @RegAdr; aR: @adrRegOperand; pReg: @dataRegOperand
do aR.alloc; aR[]->push;
   7->pReg; (pReg[],ar[])->cpReg;
   aR->A1.reg; A1[]->startA[]
#)
--getVirtualoriginStart2:descriptor--
(# A1: ^ RegAdr; pReg: @dataRegOperand
do startA[]->A1[]; (* inefficient*)
   (* 7->pReg;(A1.reg[],pReg[])->cpReg;*)
   A1.toOriginReg; (* will deAlloc A1.reg*)
   A1.reg[]->pop;
   (* A1.reg.deAlloc*)
#)
---Final2VirtJump:descriptor--
(# A1: ^ RegAdr
do startA[]->A1[]; (* inefficient*)
   A1[] -> pop
#)
--popFstack:descriptor--
(* only used by LINUX/NTImachine *)
(##)
---EmitBytes:descriptor--
(# #)
--EmitByte:descriptor--
(# #)
---targetEntryPointInfo:descriptor--
(# #)
---addTargetInfo:doPart----
do
---entryPointsInsert:doPart---
do
--entryPointsEqual:descriptor---   
(##)
---SPtoPrimReg:doPart---
do
--isObjectReg:descriptor--
(##)
