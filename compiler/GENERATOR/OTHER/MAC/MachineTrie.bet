(* Version: Hash1.00opt	 				*)
(* ©1993,1994 by Mj¿lner Informatics ApS (C)1993,1994 *)
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/containers/hashTable';

--- LIB: attributes ---

ListElement: 
  (# adr: @Integer; isContextData: @Boolean;
  Enter (adr, isContextData)
  Exit (adr, isContextData)
  #);

IntList: list(# element::< integerObject #);
MoreList:
  (# ListCounter, id, adr: @Integer; theList: [1]^ListElement;
	   A5, dumped, isContextData: @Boolean; tempEL: ^ListElement;
     
     Init: (# Do 0->ListCounter; #);

		 Append: 
		   (# adr: @Integer; isContextData: @Boolean;
			 Enter (adr, isContextData)
       Do ListCounter + 1->ListCounter;
          (if ListCounter > theList.Range//TRUE then
              theList.Range->theList.Extend;
          if);
          (*&ListElement[]->tempEL[];
           (adr, isContextData)->tempEL;
           tempEL[]->theList[listCounter][];
           *)
          &ListElement[]->theList[listCounter][];
          (adr, isContextData)->theList[listCounter];
			 #);
	#);
	
HashElement: (# word: ^Text; more: ^MoreList; #);

Trie: hashTable
  (# bugstream: ^stream;
     Element::< HashElement;

	HashFunction::<
	  (#
	  Do (for i: e.word.lgth repeat
               e.word.T[i] + value->value;
		   for);
	  #);
      
     equal::< (# do left.word[]->right.word.equal->value #);
      
	dummy: @element;
	lastFound: ^Element; (* to speed ud: the last Declared or found element in table *)

	DeclareWord: 
    (# word: ^Text;
       e: ^Element;
		   id, address: @Integer;
		   A5Rel: @Boolean; isContextData: @Boolean;
     Enter (word[],id, address, A5rel, isContextData)
       Do word[]->dummy.word[];
          dummy[]->hashfunction->findIndexed
          (# predicate::< (# do word[]->current.word.equal->value #);
          do current[]->e[];
        #);
				NONE->dummy.word[];
        (if e[]//NONE then (* element not in table *)
		      &Element[]->e[];
              word.copy->e.word[];
              &MoreList[]->e.more[];
              (*&IntList[]->e.more.theList[];*)
              FALSE->e.more.dumped;
              (if A5Rel//TRUE then A5Rel->e.more.A5; if);
              e.more.Init;
              id->e.more.id;
              address->e.more.adr;
              isContextData->e.more.isContextData;
					e[]->insert;
        if);
				e[]->lastFound[]; (* e is either a new element or a found element *)
	  #);
	DeclareWordNew: 
    (# word: ^Text;
       e: ^Element;
		   id, address: @Integer;
		   A5Rel, isContextData: @Boolean;
     Enter (word[],id, address, A5rel, isContextData)
     Do &Element[]->e[];
          word.copy->e.word[];
          &MoreList[]->e.more[];
          FALSE->e.more.dumped;
          (if A5Rel//TRUE then A5Rel->e.more.A5; if);
          e.more.Init;
          id->e.more.id;
          address->e.more.adr;
          isContextData->e.more.isContextData;
				e[]->insert;
				e[]->lastFound[];
	  #);
	(*InsertAddress:
    (# word: ^Text;
       e: ^Element;
		   address: @Integer;
     Enter (word[], address)
     Do word[] -> dummy.word[];
        dummy[] -> hashfunction -> findIndexed
        (# predicate::< (# do word[] -> current.word.equal -> value #);
        do address -> current.more.adr;
        #);
				NONE->dummy.word[];
	  #);*)
		InsertAddress: (* use lastFound to speed up things *)
		(# address: @Integer;
		enter address
		do (if lastFound[]//NONE then
		       'InsertAddress: no lastFound'->syserror;
		    else
              address->lastFound.more.adr;
          if);
       #);
     (*
	InsertWord: 
		(# word: ^Text;
			 e: ^Element;
			 id: @Integer;
			 A5Rel: @Boolean;
			 tempObj: ^IntegerObject;
		enter (word[],id, A5rel)
      do word[]->dummy.word[];
      dummy[]->hashfunction->findIndexed
      (# predicate::< (# do word[]->current.word.equal->value #);
      do current[]->e[];
			 #);
				NONE->dummy.word[];
			 (if e[]//NONE then {* element not in table *}
      '#Error label not declared: '->bugstream.PutText;
      word[]->bugstream.PutText; ' Current: '->bugstream.PutText;
      else
      (if e.more.dumped//TRUE then
      {*&intList[]->e.more.theList[];*}
      e.more.Init;
      FALSE->e.more.dumped;
      FALSE->e.more.A5;
      if);
      (if A5Rel//TRUE then A5Rel->e.more.A5; if);
      id->e.more.append;
      if);
		#);
		*)
	InsertWord:  (* use lastFound to speed up things *)
		(# id: @Integer;
			 A5Rel, isContextData: @Boolean;
			 tempObj: ^IntegerObject;
		enter (id, A5rel, isContextData) (* id = adr *)
		do (if lastFound[]//NONE then
		       'InsertWord: no lastFound'->syserror;
		    else
              (if lastFound.more.dumped//TRUE then
                  (*&intList[]->e.more.theList[];*)
                  lastFound.more.Init;
                  FALSE->lastFound.more.dumped;
                  FALSE->lastFound.more.A5;
              if);
              (if A5Rel//TRUE then A5Rel->lastFound.more.A5; if);
              (id, isContextData)->lastFound.more.append;
          if);
		#);

	Member: 
		(# word: ^Text;
			 found: @Boolean;
		 enter word[]
       do word[]->dummy.word[];
          dummy[]->hashfunction->findIndexed
          (# predicate::< (# do word[]->current.word.equal->value #);
          do current[]->lastFound[];true->found;
          #);
          NONE->dummy.word[];
          (if found//false then NONE->lastFound[] if);
		 Exit found
		 #);

	Get: 
		(#
			word: ^Text;
			e: ^Element;
			found: @Boolean;
			moreL: ^MoreList;
		Enter word[]
       Do word[]->dummy.word[];
          dummy[]->hashfunction->findIndexed
          (# predicate::< (# do word[]->current.word.equal->value #);
          do current[]->e[]->lastFound[];
			 #);
				NONE->dummy.word[];
			 (if e[]//NONE then (* element not in table *)
              FALSE->found;
              NONE->lastFound[];
           else
              TRUE->found;
              e.more[]->moreL[];
			 if);
		Exit (found, moreL[])
		#);	
     OOPS: 
       (# T: ^text
       enter T[]
       do bugstream.newline; '******* System error!!!'->bugstream.putLine;
          T[]->bugstream.putLine; 
          INNER;
       #);
     SysError: OOPS
       (# continue: @boolean
       do 'Please report this error to Mj¿lner Informatics'->bugstream.putline;
          INNER;
      (if continue//false then
       (FailureTrace,'Compilation stopped because of compiler error!')
	     -> &Stop
   if)#);
  #);
