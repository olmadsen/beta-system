ORIGIN 'Machinearray';

(* ©1993,1994 by Mj¿lner Informatics ApS (C)1993,1994 *)


---BetaArrayInsert:dopart---
do aCounter + 1 -> aCounter;
   (if aCounter > TArray.Range // TRUE then
       TArray.Range -> TArray.Extend;
       AArray.Range -> AArray.Extend;
   if);
   lab[] -> TArray[aCounter][];
   counter + gOffset + dataOffset -> AArray[aCounter];
   counter + 4 -> counter;


---BetaArrayDeclare:dopart---
do dCounter + 1 -> dCounter;
   (if dCounter > DTArray.Range // TRUE then
       DTArray.Range -> DTArray.Extend;
       DAArray.Range -> DAArray.Extend;
   if);
   tLab[] -> DTArray[dCounter][];
   adr -> DAArray[dCounter];


---BetaArraySolve:descriptor---
(# tmp: @Integer; found: @Boolean; more: ^MoreList;
do (for f:aCounter repeat
        1 -> tmp;
        L:

          (if TArray[f][] -> DTArray[tmp].EqualNCS // TRUE then
              (DAArray[tmp], (AArray[f]-4) div 4) -> theArray.%putLong;
              (* Above line tos_converted from: (theArray, AArray[f]-4, DAArray[tmp]) -> TOS'%inxPutLong'; *)
              Leave L;
           else
              tmp + 1 -> tmp;
              (if tmp > dCounter // TRUE then
                  TArray[f][] -> ExportTabel.Get -> (found, more[]);
                  (if found // TRUE then
                      (more.adr, (AArray[f]-4) div 4) -> theArray.%putLong;
                      (* Above line tos_converted from: (theArray, AArray[f]-4, more.adr) -> TOS'%inxPutLong'; *)
                      Leave L;
                   else
                      '\nBeta_Label not declared: ' ->Bugstream.Puttext;
                      TArray[f][]->bugstream.putline;
                      Leave L;
                  if);
               else
                  Restart L;
              if);
          if);
   for);
   0 -> dCounter -> aCounter; (* Reset *)
#)


--- PutFPLLabel: descriptor--
(#  textAdr, found: @Boolean; tempLabAdr: ^LabAdr;  more: ^MoreList;
   t: ^Text;
do	(if lno > labelTabel.Range // TRUE then
            labelTabel.Range -> labelTabel.Extend;
	if);

   (if labelTabel[lNo][] // NONE  then
       'L' -> t[];
       lNo -> t.PutInt;
       t[] -> entryTabel.Get -> (found, more[]);
       (if found
        // TRUE then
           (t[], more.Id, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWord;
           ((*t[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
        // FALSE then
           &LabAdr[] -> tempLabAdr[];
           (lNo, counter + 2 + dataOffset, gOffset, BRelative, contextData) -> tempLabAdr;
           tempLabAdr[] -> unsolvedRefs[currURefIndex][];
           currURefIndex + 1 -> currURefIndex;
           (if currURefIndex > unsolvedRefs.Range // TRUE then
               unsolvedRefs.Range -> unsolvedRefs.Extend;
               (if logging then
                   'Extending unsolvedRefs: '->logfile.puttext;
                   unsolvedRefs.Range->logfile.putint;
                   logfile.newline;
               if);
           if);
       if);
       (if BRelative // TRUE then dataOffset + 2 -> dataOffset; if);
    else
       (if BRelative
        // FALSE then
           (labelTabel[lNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[lNo].adr - counter - 2) -> TOS'%inxPutShort'; *)
        // TRUE then
           (labelTabel[lNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 4) -> theArray.%putLong;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[lNo].adr - counter - 2) -> TOS'%inxPutLong'; *)
           dataOffset + 2 -> dataOffset;
       if);
   if);
   
   dataOffset + 2 -> dataOffset;
   
   operandNo + 1 -> operandNo;
   (if operandNo = noOfOp // True then
       (inst, (counter + gOffset) div 2) -> theArray.%putShort;
       (* Above line tos_converted from: (theArray, counter + gOffset, inst) -> TOS'%inxPutShort'; *)
       counter + 2 + dataOffset -> counter -> IP;
   if);
#)


-- PutLLabel:descriptor--
(#  tempLabAdr: ^LabAdr; t: @Text; more: ^MoreList;
do
   (* when the label is local, use relative addressing *)
   (*(if textAdr // TRUE then TRUE -> BRelative; if);*)
   (if lno > labelTabel.Range // TRUE then
       labelTabel.Range -> labelTabel.Extend;
   if);
   (if labelTabel[lNo][] // NONE  then
       'L' -> t; lNo -> t.PutInt;
       t[] -> entryTabel.Get -> (found, more[]);
       (if found
        // TRUE then
           (t[], more.Id, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWord;
           ((*t[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
        // FALSE then
           &LabAdr[] -> tempLabAdr[];
           (lNo, counter + 2 + dataOffset, gOffset, BRelative, contextData) -> tempLabAdr;
           tempLabAdr[] -> unsolvedRefs[currURefIndex][];
           currURefIndex + 1 -> currURefIndex;
           (if currURefIndex > unsolvedRefs.Range // TRUE then 
               unsolvedRefs.Range -> unsolvedRefs.Extend;
               (if logging then
                   'Extending unsolvedRefs: '->logfile.puttext;
                   unsolvedRefs.Range->logfile.putint;
                   logfile.newline;
               if);
           if);
       if);
       (if BRelative // TRUE then dataOffset + 2 -> dataOffset; if);
    else
       (if BRelative
        // FALSE then
           (labelTabel[lNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[lNo].adr - counter - 2) -> TOS'%inxPutShort'; *)
        // TRUE then
           (labelTabel[lNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 4) -> theArray.%putLong;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[lNo].adr - counter - 2) -> TOS'%inxPutLong'; *)
           dataOffset + 2 -> dataOffset;
       if);
   if);
   
   (if textAdr // False then (* we do not need to know if the instruction is a branch *)
       (if operandNo
        // 0 then
           inst %Bor 2x111010 -> inst;
           (* Above line tos_converted from: (inst, 2x111010) -> TOS'%or' -> inst; *)
        // 1 then
           inst %Bor 2x010111000000 -> inst;
           (* Above line tos_converted from: (inst, 2x010111000000) -> TOS'%or' -> inst; *)
       if);
    else 
       (*((LlabNo).L, A5)*)
       (if (labelTabel[lNo].isData and not contextData)
        // TRUE then
           (if dataMName[] -> ImportTabel.Member
            // TRUE then
               ((*dataMName[],*) counter + 4 + dataOffset, TRUE, contextData) -> ImportTabel.InsertWord;
            // FALSE then
               (dataMName[], currDataModuleId, counter + 4 + dataOffset, TRUE, contextData) -> ImportTabel.declareWordNew;
               ((*dataMName[],*) counter + 4 + dataOffset, TRUE, contextData) -> ImportTabel.InsertWord;
           if);
           
           (if operandNo
            // 0 then
               inst %Bor 2x110101 -> inst;
               (* Above line tos_converted from: (inst, 2x110101) -> TOS'%or' -> inst; *)
            // 1 then
               inst %Bor 2x101110000000 -> inst;
               (* Above line tos_converted from: (inst , 2x101110000000) -> TOS'%or' -> inst; *)
           if);
           
           (2x1000000101110000, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, 2x1000000101110000) -> TOS'%inxPutShort'; *)
           (labelTabel[lNo].Adr, (counter + 4 + gOffset + dataOffset) div 4) -> theArray.%putLong;
           (* Above line tos_converted from: (theArray, counter + 4 + gOffset + dataOffset, labelTabel[lNo].Adr) -> TOS'%inxPutLong'; *)
           dataOffset + 4 -> dataOffset;
           
        // FALSE then
           (if operandNo
            // 0 then
               inst %Bor 2x101101 -> inst;
               (* Above line tos_converted from: (inst, 2x101101) -> TOS'%or' -> inst; *)
            // 1 then
               inst %Bor 2x101101000000 -> inst;
               (* Above line tos_converted from: (inst, 2x101101000000) -> TOS'%or' -> inst; *)
           if);
       if);
   if);
   
   dataOffset + 2 -> dataOffset;
   
   operandNo + 1 -> operandNo;
   (if operandNo = noOfOp // True then
       (inst, (counter + gOffset) div 2) -> theArray.%putShort;
       (* Above line tos_converted from: (theArray, counter + gOffset, inst) -> TOS'%inxPutShort'; *)
       counter + 2 + dataOffset -> counter -> IP;
   if);
#)


-- PutTLabel: descriptor --
(# ch2: @char;
do 2 -> tLabel.inxGet->ch2;
   (if ((1 -> tLabel.inxGet) = 'L') and (ch2 >= '1') and (ch2 <= '9') // True then (* local label *)
       (* when label is local, use relative addressing *)
       (2, tLabel.lgth) -> tLabel.Sub -> temp[];
       temp.GetInt -> tLabelNo;
       (if tLabelNo > labelTabel.Range // TRUE then
           labelTabel.Range -> labelTabel.Extend;
       if);
       (if labelTabel[tLabelNo][] // NONE then
           tLabel[] -> entryTabel.Get -> (found, more[]);
           (if found
            // TRUE then
               (tLabel[], more.Id, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWord;
               ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
            // FALSE then
               &LabAdr[] -> tempLabAdr[];
               (tLabelNo, counter + 2 + dataOffset, gOffset, BRelative, contextData) -> tempLabAdr;
               tempLabAdr[] -> unsolvedRefs[currURefIndex][];
               currURefIndex + 1 -> currURefIndex;
               (if currURefIndex > unsolvedRefs.Range // TRUE then
                   unsolvedRefs.Range -> unsolvedRefs.Extend;
		   (if logging then
		       'Extending unsolvedRefs: '->logfile.puttext;
		       unsolvedRefs.Range->logfile.putint;
		       logfile.newline;
		   if);
               if);
           if);
           (if BRelative // TRUE then dataOffset + 2 -> dataOffset; if);
        else
           (if BRelative
            // FALSE then
               (labelTabel[tLabelNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
               (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[tLabelNo].adr - counter - 2) -> TOS'%inxPutShort'; *)
            // TRUE then
               (labelTabel[tLabelNo].adr - counter - 2, (counter + 2 + gOffset + dataOffset) div 4) -> theArray.%putLong;
               (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, labelTabel[tLabelNo].adr - counter - 2) -> TOS'%inxPutLong'; *)
               dataOffset + 2 -> dataOffset;
           if);
       if);
       (if operandNo
        // 0 then
           inst %Bor 2x111010 -> inst;
           (* Above line tos_converted from: (inst, 2x111010) -> TOS'%or' -> inst; *)
        // 1 then
           inst %Bor 2x010111000000 -> inst;
           (* Above line tos_converted from: (inst, 2x010111000000) -> TOS'%or' -> inst; *)
       if);
    else (* not a local label *)
       tLabel[] -> ImportTabel.Get -> (found, more[]);
       (if found
        // TRUE then
           (if more.A5
            // FALSE then
               ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
               (if operandNo
                // 0 then
                   inst %Bor 2x111001 -> inst;
                   (* Above line tos_converted from: (inst, 2x111001) -> TOS'%or' -> inst; *)
                // 1 then
                   inst %Bor 2x001111000000 -> inst;
                   (* Above line tos_converted from: (inst, 2x001111000000) -> TOS'%or' -> inst; *)
               if);
               dataOffset + 2 -> dataOffset;
            // TRUE then
               (if contextData // TRUE then
                   ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
                else
                   ((*tLabel[],*) counter + 4 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
               if);
               (if operandNo
                // 0 then
                   inst %Bor 2x110101 -> inst;
                   (* Above line tos_converted from: (inst, 2x110101) -> TOS'%or' -> inst; *)
                // 1 then
                   inst %Bor 2x101110000000 -> inst;
                   (* Above line tos_converted from: (inst, 2x101110000000) -> TOS'%or' -> inst; *)
               if);
               (if contextData // FALSE then
                   (2x1000000101110000, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
                   (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, 2x1000000101110000) -> TOS'%inxPutShort'; *)
                   dataOffset + 4 -> dataOffset;
               if);
           if);
        // FALSE then (* tLabel is NOT in ImportTabel *)
           tLabel[] -> ExportTabel.Get -> (found, more[]);
           (if found
            // TRUE then
               (tLabel[], more.id, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWordNew;
               ((*tLabel[], *)counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
            // FALSE then (* unsolved *)
               (*tLabel[] -> theRecords[currDicIndex].Insert;
                (tLabel[], idCounter, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWordNew;
                (counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
                idCounter + 1 -> idCounter;*)
               tLabel[] -> UnsolvedLabel.Get -> (found, more[]);
               (if found
                // false then
                   (tLabel[], idCounter, counter + 2 + dataOffset, true, contextData) -> UnsolvedLabel.DeclareWordNew;
                   (counter + 2 + dataOffset, true, contextData) -> UnsolvedLabel.InsertWord;
                // true then
                   (counter + 2 + dataOffset, true, contextData) -> UnsolvedLabel.InsertWord;
               if);			  			
           if);
           (if operandNo
            // 0 then
               inst %Bor 2x111001 -> inst;
               (* Above line tos_converted from: (inst, 2x111001) -> TOS'%or' -> inst; *)
            // 1 then
               inst %Bor 2x001111000000 -> inst;
               (* Above line tos_converted from: (inst, 2x001111000000) -> TOS'%or' -> inst; *)
           if);
           dataOffset + 2 -> dataOffset;
       if);
   if);
   
   dataOffset + 2 -> dataOffset;
   
   operandNo + 1 -> operandNo;
   (if operandNo = noOfOp // True then
       (inst, (counter + gOffset) div 2) -> theArray.%putShort;
       (* Above line tos_converted from: (theArray, counter + gOffset, inst) -> TOS'%inxPutShort'; *)
       counter + 2 + dataOffset -> counter -> IP;
   if);
#)


-- PutTOp: dopart --
do (*(if 1->tLabel.inxGet//'G' then
    * counter->Tracestream.Putint; ': '->Tracestream.Puttext; 
    * tLabel[]->Tracestream.Puttext;
    * (if fctd then ' TRUE'->Tracestream.Putline; 
    * else ' FALSE'->Tracestream.Putline if);
    * if);
    *)
   
   (if fctd // True Then (* ((T).L,A5) *)
       (if operandNo
        // 0 then
           2x0000000000110101 %Bor inst -> inst;
           (* Above line tos_converted from: (2x0000000000110101, inst) -> TOS'%or' -> inst; *)
        // 1 then
           2x0000101110000000 %Bor inst -> inst;
           (* Above line tos_converted from: (2x0000101110000000, inst) -> TOS'%or' -> inst; *)
       if);
       (if tLabel[] -> ImportTabel.Member then
           ((*tLabel[],*) counter + 4 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
           (2x1000000101110000, (counter + 2 + gOffset + dataOffset ) div 2) -> theArray.%putShort;
           (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset , 2x1000000101110000) -> TOS'%inxPutShort'; *)
           dataOffset + 4 -> dataOffset;
        else
           tLabel[] -> UnsolvedLabel.Get -> (found, more[]);
           (if found
            // false then
               (tLabel[], idCounter, counter + 4 + dataOffset, true, contextData) -> UnsolvedLabel.DeclareWordNew;
               (counter + 4 + dataOffset, true, contextData) -> UnsolvedLabel.InsertWord;
               (2x1000000101110000, (counter + 2 + gOffset + dataOffset ) div 2) -> theArray.%putShort;
               (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset , 2x1000000101110000) -> TOS'%inxPutShort'; *)
               dataOffset + 4 -> dataOffset;
            // true then
               (counter + 4 + dataOffset, true, contextData) -> UnsolvedLabel.InsertWord;
               (2x1000000101110000, (counter + 2 + gOffset + dataOffset ) div 2) -> theArray.%putShort;
               (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset , 2x1000000101110000) -> TOS'%inxPutShort'; *)
               dataOffset + 4 -> dataOffset;
           if);			  
       if);
    else
       tLabel[] -> ImportTabel.Get -> (found, more[]);
       (if found
        // TRUE then
           (if more.A5
            // FALSE then
               ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
               (if operandNo
                // 0 then
                   inst %Bor 2x111001 -> inst;
                   (* Above line tos_converted from: (inst, 2x111001) -> TOS'%or' -> inst; *)
                // 1 then
                   inst %Bor 2x001111000000 -> inst;
                   (* Above line tos_converted from: (inst, 2x001111000000) -> TOS'%or' -> inst; *)
               if);
               dataOffset + 2 -> dataOffset;
            // TRUE then
               (if contextData // TRUE then
                   ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
                else
                   ((*tLabel[],*) counter + 4 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
                   (2x1000000101110000, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
                   (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, 2x1000000101110000) -> TOS'%inxPutShort'; *)
                   dataOffset + 4 -> dataOffset;
               if);
               (if operandNo
                // 0 then
                   inst %Bor 2x110101 -> inst;
                   (* Above line tos_converted from: (inst, 2x110101) -> TOS'%or' -> inst; *)
                // 1 then
                   inst %Bor 2x101110000000 -> inst;
                   (* Above line tos_converted from: (inst, 2x101110000000) -> TOS'%or' -> inst; *)
               if);
               (*(if contextData // FALSE then
                (2x1000000101110000, (counter + 2 + gOffset + dataOffset) div 2) -> theArray.%putShort;
                (* Above line tos_converted from: (theArray, counter + 2 + gOffset + dataOffset, 2x1000000101110000) -> TOS'%inxPutShort'; *)
                dataOffset + 4 -> dataOffset;
                if);*)
           if);
        // FALSE then (* not in ImportTabel *)
           tLabel[] -> ExportTabel.Get -> (found, more[]);
           (if found
            // TRUE then
               (tLabel[], more.id, counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.declareWord;
               ((*tLabel[],*) counter + 2 + dataOffset, FALSE, contextData) -> ImportTabel.InsertWord;
            // FALSE then
               tLabel[] -> UnsolvedLabel.Get -> (found, more[]);
               (if found//false then
                   (tLabel[], idCounter, counter + 2 + dataOffset, FALSE, contextData) -> UnsolvedLabel.declareWordNew;
                   (counter + 2 + dataOffset, FALSE, contextData) -> UnsolvedLabel.InsertWord;
                else
                   (counter + 2 + dataOffset, FALSE, contextData) -> UnsolvedLabel.InsertWord;
               if);
               (*dataOffset + 2 -> dataOffset;*)
           if);
           (if operandNo
            // 0 then
               inst %Bor 2x111001 -> inst;
               (* Above line tos_converted from: (inst, 2x111001) -> TOS'%or' -> inst; *)
            // 1 then
               inst %Bor 2x001111000000 -> inst;
               (* Above line tos_converted from: (inst, 2x001111000000) -> TOS'%or' -> inst; *)
           if);
           dataOffset + 2 -> dataOffset;
       if);
   if);

   dataOffset + 2 -> dataOffset;
   
   operandNo + 1 -> operandNo;
   (if operandNo = noOfOp // True then
       (if contextData // false then
           (inst, (counter + gOffset) div 2) -> theArray.%putShort;
           (* Above line tos_converted from: (theArray, counter + gOffset, inst) -> TOS'%inxPutShort'; *)
           counter + 2 + dataOffset -> counter -> IP;
       if);
   if);


-- SwitchToDataBody:dopart --
Do (if contextData // FALSE then
       TRUE -> contextData;
       (if firstModule // FALSE then
	   (* We now know the size of the last contents record, 
            * so go ahead and save it 
            *)
	   counter - contentsStart -> currContentsRec.size;
	   counter -> codeCounter;
	   dataCounter -> counter;
	   codeCounter + 1 -> gOffset;
	   currContentsRec[] -> theRecords[recCounter][];
	   recCounter + 1-> recCounter;
	   (if recCounter > theRecords.Range // TRUE then 
	       theRecords.Range -> theRecords.Extend;
               recordlog
	   if);
       if);
       (if hasDataModule // FALSE then
           (#	(*tempRec: ^ModuleRecord;*)
           Do	TRUE -> hasDataModule;
              (* new data module 
               &moduleRecord[] -> tempRec[];
               (5, 0, moduleNo, 0) -> tempRec;
               tempRec[] -> theRecords[recCounter][];
               recCounter + 1-> recCounter;
               (if recCounter > theRecords.Range // TRUE then
               theRecords.Range -> theRecords.Extend;
               recordlog
               if);
               moduleNo + 1 -> moduleNo;*)
              NewModule;
           #);
       if);
       (*else
        FALSE -> firstModule;
        if);*)
       counter -> contentsStart;
       &contentsRecord[] -> currContentsRec[];
       (8, 9, 0, counter, counter + gOffset) -> currContentsRec;
   if);


-- SwitchToCodeBody:dopart --
Do	(if contextData // TRUE then
            FALSE -> contextData;
            (if firstModule // FALSE then
           (* We now know the size of the last contents record, 
            * so go ahead and save it
            *)
                counter - contentsStart -> currContentsRec.size;
                counter -> dataCounter;
                codeCounter -> counter;
                dataCounter + 1 -> gOffset;
                currContentsRec[] -> theRecords[recCounter][];
                recCounter + 1-> recCounter;
                (if recCounter > theRecords.Range // TRUE then
                    theRecords.Range -> theRecords.Extend;
                    recordlog
                if);
             else
                False -> firstModule;
            if);
            counter -> contentsStart;
            &contentsRecord[] -> currContentsRec[];
            (8, 8, 0, counter, counter + gOffset) -> currContentsRec;
        if);


-- ImportBody:dopart --
Do (if t[] -> importTabel.Member
    // FALSE then
       (t[], idCounter, counter, FALSE, contextData) -> importTabel.DeclareWordNew;
       t[] -> theRecords[currDicIndex].Insert;
       idCounter + 1 -> idCounter;
   if);


-- ImportDataBody: dopart --
Do	(if t[] -> importTabel.Member
         // FALSE then
            (if contextData // FALSE then
           (t[], idCounter, counter, TRUE, contextData) 
             -> importTabel.DeclareWordNew;
        else
           (t[], idCounter, counter, False, contextData) 
             -> importTabel.DeclareWordNew;
            if);
            t[] -> theRecords[currDicIndex].Insert;
            idCounter + 1 -> idCounter;
        if);


-- ExportBody:dopart --
Do	(t[], idCounter, counter, FALSE, contextData) -> ExportTabel.DeclareWord;
   t[] -> theRecords[currDicIndex].Insert;
   idCounter + 1 -> idCounter;
   (*		(if TRUE
    *     // (1 -> t.inxGet) = 'M' then { M Entrypoint }
    *     &DescriptorEntry[] -> currDescEntry[];
    *     t -> currDescEntry;
    *     currDescEntry[] -> descriptorList.Insert;
    *     counter -> currDescriptorAdr;
    *     // (1 -> t.inxGet) = 'T' then { T Entrypoint }
    *     { save it till we gonna write the corresponding M entry }
    *     currTEntryIndex + 1 -> currTEntryIndex;
    *     (if currTEntryIndex > TEntryTable.Range // TRUE  then
    *     TEntryTable.Range -> TEntryTable.Extend;
    *     if);
    *     &Text[] -> TEntryTable[currTEntryIndex][];
    *     t -> TEntryTable[currTEntryIndex];
    *     ('M', 1) -> TEntryTable[currTEntryIndex].InxPut;
    *     if);
    *)

-- EntryBody:descriptor --
(# ll: ^LocalLabel; t: ^Text;
Do &Text[] -> t[]; 'L' -> t.put; labNo -> t.PutInt;
   (t[], idCounter, counter, FALSE, contextData) -> entryTabel.DeclareWord;
   t[] -> theRecords[currDicIndex].Insert;
   idCounter + 1 -> idCounter;
#)


-- ProcBody:dopart --
Do	FALSE -> contextData;
   TRUE -> firstModule;
   (if firstProc
    // FALSE then 
       NewDictionary;
    // TRUE then
       FALSE -> firstProc;
   if);
   NewModule;
   TRUE -> contextData; (* make sure that we get contents record the first time *)
   SwitchToCode;


-- EndProcBody:descriptor --
(#	tempRec: ^SizeRecord;
Do	counter - contentsStart -> currContentsRec.size;
   currContentsRec[] -> theRecords[recCounter][];
   recCounter + 1 -> recCounter;
   (if recCounter > theRecords.Range // TRUE then
       theRecords.Range -> theRecords.Extend;
       recordlog
   if);
   
   (if contextData // TRUE then
       counter -> dataCounter;
    else
       counter -> codeCounter;
   if);
   
   (if hasCodeModule // TRUE then
       &SizeRecord[] -> tempRec[];
       (7, 0, codeCounter) -> tempRec;
       tempRec[] -> theRecords[recCounter][];
       recCounter + 1 -> recCounter;
       (if recCounter > theRecords.Range // TRUE then
           theRecords.Range -> theRecords.Extend;
           recordlog
       if);
   if);
   
   (if hasDataModule // TRUE then
       &SizeRecord[] -> tempRec[];
       (7, 1, dataCounter) -> tempRec;
       tempRec[] -> theRecords[recCounter][];
       recCounter + 1 -> recCounter;
       (if recCounter > theRecords.Range // TRUE then
           theRecords.Range -> theRecords.Extend;
           recordlog
       if);
   if);
   
   TRUE -> UpdateTabels;
#)


-- RecordBody:descriptor --
(# tempRec: ^ModuleRecord;
Do FALSE -> contextData;
   TRUE -> firstModule;
   counter + gOffset -> gOffset;
   
   0 -> counter -> datacounter -> dataOffset;
   dataCounter -> dataRecStart;
   idCounter -> currRecId;
   NewDictionary;
   (*(name, idCounter) -> dictionary.DeclareWord;*)
   name[] -> theRecords[currDicIndex].Insert;
   &ModuleRecord[] -> tempRec[];
   (5, 1, currRecId, 0) -> tempRec;
   TRUE -> hasDataModule;
   tempRec[] -> theRecords[recCounter][];
   recCounter + 1 -> recCounter;
   (if recCounter > theRecords.Range // TRUE then 
       theRecords.Range -> theRecords.Extend; 
       recordlog
   if);
   
   idCounter + 1 -> idCounter;
   
   SwitchToData;	    
#)


-- EndRecordBody:descriptor --
(# tempRec: ^SizeRecord;
Do counter - contentsStart -> currContentsRec.size;
   currContentsRec[] -> theRecords[recCounter][];
   recCounter + 1 -> recCounter;
   (if recCounter > theRecords.Range // TRUE then
       theRecords.Range -> theRecords.Extend;
       recordlog
   if);
   
   &SizeRecord[] -> tempRec[];
   (7, 1, counter - dataRecStart) -> tempRec;
   tempRec[] -> theRecords[recCounter][];
   recCounter + 1 -> recCounter;
   (if recCounter > theRecords.Range // TRUE then
       theRecords.Range -> theRecords.Extend;
       recordlog
   if);
   
   FALSE -> UpdateTabels;
#)


-- UpdateTabelsBody:descriptor --
(# tEntry: ^EntryRecord; tRef: ^MoreList;
   refRec: ^ReferenceRecord;
Do ExportTabel.Scan
   (#
   Do (if current.more.Dumped // FALSE then
          &EntryRecord[] -> tEntry[];
          (if current.more.isContextData
           // TRUE then
              (6, 9, current.more.id, current.more.adr) -> tEntry;
           // FALSE then
              (6, 8, current.more.id, current.more.adr) -> tEntry;
          if);

          tEntry[] -> theRecords[recCounter][];
          recCounter + 1 -> recCounter;
          (if recCounter > theRecords.Range // TRUE then
              theRecords.Range -> theRecords.Extend;
              recordlog
          if);
          TRUE -> current.more.dumped;
      if);
   #);

   entryTabel.Scan
   (#
   Do (if current.more.Dumped // FALSE then
          &EntryRecord[] -> tEntry[];
          (if current.more.isContextData
           // TRUE then
              (6, 1, current.more.id, current.more.adr) -> tEntry;
           // FALSE then
              (6, 0, current.more.id, current.more.adr) -> tEntry;
          if);
          
          tEntry[] -> theRecords[recCounter][];
          recCounter + 1 -> recCounter;
          (if recCounter > theRecords.Range // TRUE then
              theRecords.Range -> theRecords.Extend;
              recordlog
          if);
          TRUE -> current.more.dumped;
      if);
   #);
   
   unsolvedLabel.Scan
   (# adr: @Integer; context: @Boolean; dummy: @Text; more: ^MoreList; found: @Boolean;
   do (if current.more.Dumped // false then
          &ReferenceRecord[] -> refRec[];
          current.word[] -> ExportTabel.get -> (found, more[]);
          (if found//false then
              (current.word[], idCounter, counter, true, true) -> importTabel.DeclareWord;
              (for f:current.more.ListCounter repeat
                   current.more.theList[f] -> (adr, context);
                   (adr, True, context) -> importTabel.InsertWord;
              for);
              current.word[] -> theRecords[currDicIndex].Insert;
              idCounter + 1 -> idCounter;
           else
              (if current.more.ListCounter > 0 // TRUE then
                  (if current.more.A5
                   // TRUE then
                      (if current.more.isContextData
                       // TRUE then
                          (9, 137, more.id, true) -> refRec;
                       // FALSE then
                          (9, 136, more.id, true) -> refRec;
                      if);
                   // FALSE then
                      (if current.more.isContextData
                       // TRUE then
                          (9, 9, more.id, current.more.isContextData) -> refRec;
                       // FALSE then
                          (9, 8, more.id, current.more.isContextData) -> refRec;
                      if);
                  if);
                  (for f:current.more.ListCounter repeat
                       current.more.theList[f] -> (adr, context);
                       (dummy[], adr, context) -> refRec.Insert;
                  for);
                  refRec[] -> theRecords[recCounter][];
                  recCounter + 1 -> recCounter;
                  (if recCounter > theRecords.Range // TRUE then
                      theRecords.Range -> theRecords.Extend;
                      recordlog
                  if);
              if);
          if);  
          TRUE -> current.more.dumped;
      if);
   #);
   
   ImportTabel.Scan
   (# adr: @Integer; context: @Boolean; dummy: @Text;
   Do (if current.more.Dumped // FALSE then
          &ReferenceRecord[] -> refRec[];
          (if current.more.ListCounter > 0 // TRUE  then
              (if current.more.A5
               // TRUE then
                  (if current.more.isContextData
                   // TRUE then
                      (9, 137, current.more.id, true) -> refRec;
                   // FALSE then
                      (9, 136, current.more.id, true) -> refRec;
                  if);
               // FALSE then
                  (if current.more.isContextData
                   // TRUE then
                      (9, 9, current.more.id, current.more.isContextData) -> refRec;
                   // FALSE then
                      (9, 8, current.more.id, current.more.isContextData) -> refRec;
                  if);
              if);
              (*current.more.ListCounter -> refRec.repCounter;
               current.more.theList -> refRec.offRep;
               refRec.RepCounter * 4 -> refRec.size;*)
              (for f:current.more.ListCounter repeat
                   current.more.theList[f] -> (adr, context);
                   (dummy[], adr, context) -> refRec.Insert;
              for);
              refRec[] -> theRecords[recCounter][];
              recCounter + 1 -> recCounter;
              (if recCounter > theRecords.Range // TRUE then
                  theRecords.Range -> theRecords.Extend;
                  recordlog
              if);
          if);
          TRUE -> current.more.dumped;
      if);
   #);
#)

--MachineArrayUpdateCounter: dopart--
do (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayInxPutByte: dopart--
do (if ((offset+1)>theArray.range*4) then
       (* offset out of range *)
       (# t: @Text;
       do 'inxputbyte: offset out of range: '->t.puttext;
          offset->t.putint; ' '->t.put;
          theArray.range*4->t.putint;
          t[]->SysError(# do true->continue #);
       #);
       theArray.range->theArray.extend;
   if);
   (value, offset) -> theArray.%putByte;
   (* Above line tos_converted from: (theArray,offset, value)->TOS'%inxPutByte'; *)

--MachineArrayInxPutShort: dopart--
do (if ((offset+2)>theArray.range*4) then
       (* offset out of range *)
       (# t: @Text;
       do 'inxputshort: offset out of range: '->t.puttext;
          offset->t.putint; ' '->t.put;
          theArray.range*4->t.putint;
          t[]->SysError(# do true->continue #);
       #);
       theArray.range->theArray.extend;
   if);
   (value, (offset) div 2) -> theArray.%putShort;
   (* Above line tos_converted from: (theArray,offset, value)->TOS'%inxPutShort'; *)

--MachineArrayInxPutLong: dopart--
do (if ((offset+4)>theArray.range*4) then
       (* offset out of range *)
       (# t: @Text;
       do 'inxputlong: offset out of range: '->t.puttext;
          offset->t.putint; ' '->t.put;
          theArray.range*4->t.putint;
          t[]->SysError(# do true->continue #);
       #);
       theArray.range->theArray.extend;
   if);
   (value, (offset) div 4) -> theArray.%putLong;
   (* Above line tos_converted from: (theArray,offset, value)->TOS'%inxPutLong'; *)

--MachineArrayPutInst: dopart--
Do 0->operandNo;
   0->dataOffset;
   (if 1 %Band counter//1 then counter + 1->counter if); (* word align instruction *)
   (* Above line tos_converted from: (if (1,counter)->TOS'%and'//1 then counter + 1->counter if); *)
   (if counter+gOffset+24>theArray.Range*4 then 
       (* range * 4, because counter is counting byte size *)
       theArray.Range div 5->theArray.Extend;
       (if logging then
           '\n***WARNING Extending theArray: '->logfile.puttext;
           theArray.Range->logfile.putint;
       if);
   if);
   opdateCounter;

--MachineArrayPutFPInst: dopart--
Do 0->operandNo;
   0->dataOffset;
   (if 1 %Band counter//1 then counter + 1->counter if); (* word align instruction *)
   (* Above line tos_converted from: (if (1,counter)->TOS'%and'//1 then counter + 1->counter if); *)
   (if counter+gOffset+24>theArray.Range*4 then 
       theArray.Range div 5->theArray.Extend;
       (if logging then
           '\n***WARNING Extending theArray: '->logfile.puttext;
           theArray.Range->logfile.putint;
       if);
   if);
   
   ( counter + gOffset + 2, fpInst)->inxputshort; (* FP instruction *)
   dataOffset + 2->dataOffset;
   2x1111001000000000->THIS(MachineArray).inst; (* cpGen, id = FP *)
   noOfOp->THIS(MachineArray).noOfOp;
   
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutAReg: dopart--
Do (if operandNo
    //0 then
       2x001000 %Bor regNo->regNo;
       (* Above line tos_converted from: (2x001000, regNo)->TOS'%or'->regNo; *)
    //1 then
       regNo %sll 9->regNo;
       (* Above line tos_converted from: regNo->TOS'%shiftleft[9]'->regNo; *)
       2x001000000 %Bor regNo->regNo;
       (* Above line tos_converted from: (2x001000000, regNo)->TOS'%or'->regNo; *)
   if);
   operandNo + 1->operandNo;    
   
   inst %Bor regNo->inst;
   (* Above line tos_converted from: (inst, regNo)->TOS'%or'->inst; *)
   
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutDReg: dopart--
Do (if operandNo
    //0 then
       operandNo + 1->operandNo;
    //1 then
       regNo %sll 9->regNo;
       (* Above line tos_converted from: regNo->TOS'%shiftleft[9]'->regNo; *)
       operandNo + 1->operandNo;
   if);
   
   inst %Bor regNo->inst;
   (* Above line tos_converted from: (inst, regNo)->TOS'%or'->inst; *)
   
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutConst: dopart--
Do (if operandNo
    //0 then
       2x111100 %Bor Inst->Inst;
       (* Above line tos_converted from: (2x111100, Inst)->TOS'%or'->Inst; *)
       (if iSize
        //1 then
           ( counter+2 + gOffset + dataOffset, c)->inxputshort;
           dataOffset + 2->dataOffset;
        //2 then
           ( counter+2 + gOffset + dataOffset, c)->inxputshort;
           dataOffset + 2->dataOffset;
        //4 then
           ( counter+2 + gOffset + dataOffset, c)->inxputlong;
           dataOffset + 4->dataOffset;
       if);
    else
       'An error you can not have a constant as second operand'->Bugstream.Putline;
   if);
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayFPReg: dopart--
do operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayDefTlabel: dopart--
Do (if 1 %Band counter//1 then 
(* Above line tos_converted from: Do (if (1,counter)->TOS'%and'//1 then *)
       (* Align label *)counter + 1->counter; 
   if);
   (if tLabel[]->ExportTabel.Member//FALSE then
       (*'#Warning: LabelDefined without export'->Tracestream.Puttext;
        * tLabel[]->Tracestream.Putline;
        * (tLabel[], idCounter, counter, FALSE, contextData)
        * ->ExportTabel.DeclareWordNew;
        * tLabel[]->theRecords[currDicIndex].Insert;
        * idCounter + 1->idCounter;
        *)
       (tLabel[], counter)->BetaArray.Declare;
    else
       ((*tLabel[], *)counter)
         ->ExportTabel.InsertAddress (* assume ExportTabel.Member is true *);
   if);

--MachineArrayPutSP: dopart--
Do (if operandNo//0 then
       2x0000000000001111 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000000000001111, inst)->TOS'%or'->inst; *)
    else
       2x0000111001000000 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000111001000000, inst)->TOS'%or'->inst; *)
   if);
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutNSP: dopart--
   Do (if operandNo//0 then
              2x0000000000100111 %Bor inst->inst;
              (* Above line tos_converted from: (2x0000000000100111, inst)->TOS'%or'->inst; *)
           else
              2x0000111100000000 %Bor inst->inst;
              (* Above line tos_converted from: (2x0000111100000000, inst)->TOS'%or'->inst; *)
          if);
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutPSP: dopart--
Do (if operandNo//0 then
       2x0000000000011111 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000000000011111, inst)->TOS'%or'->inst; *)
    else
       2x0000111011000000 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000111011000000, inst)->TOS'%or'->inst; *)
   if);
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutStackOff: dopart--
Do (if operandNo//0 then
       2x0000000000101111 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000000000101111, inst)->TOS'%or'->inst; *)
    else
       2x0000111101000000 %Bor inst->inst;
       (* Above line tos_converted from: (2x0000111101000000, inst)->TOS'%or'->inst; *)
   if);
   ( counter + dataOffset + 2 + gOffset, off)->inxputshort;
   dataOffset + 2->dataOffset;
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayIndirect: dopart--
Do (if off//0 then
       2x010->mode; (* optimies code, if offset is 0 *)
       (if operandNo
        //0 then
           mode %sll 3->mode;
           (* Above line tos_converted from: mode->TOS'%shiftleft[3]'->mode; *)
        //1 then
           mode %sll 6->mode;
           (* Above line tos_converted from: mode->TOS'%shiftleft[6]'->mode; *)
           reg %sll 9->reg;
           (* Above line tos_converted from: reg->TOS'%shiftleft[9]'->reg; *)
       if);
       mode %Bor inst->inst;
       (* Above line tos_converted from: (mode, inst)->TOS'%or'->inst; *)
       reg %Bor inst->inst;
       (* Above line tos_converted from: (reg, inst)->TOS'%or'->inst; *)
    else
       (if operandNo
        //0 then
           mode %sll 3->mode;
           (* Above line tos_converted from: mode->TOS'%shiftleft[3]'->mode; *)
        //1 then
           mode %sll 6->mode;
           (* Above line tos_converted from: mode->TOS'%shiftleft[6]'->mode; *)
           reg %sll 9->reg;
           (* Above line tos_converted from: reg->TOS'%shiftleft[9]'->reg; *)
       if);
       mode %Bor inst->inst;
       (* Above line tos_converted from: (mode, inst)->TOS'%or'->inst; *)
       reg %Bor inst->inst;
       (* Above line tos_converted from: (reg, inst)->TOS'%or'->inst; *)
       (if operandNo
        //0 then
           ( counter + 2 + gOffset + dataOffset, off)->inxputshort;
           dataOffset + 2->dataOffset;
        //1 then
           ( counter + 2 + gOffset + dataOffset, off)->inxputshort;
           dataOffset + 2->dataOffset;
       if);
   if);
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayIndirectIndx: dopart--
Do aReg->tempReg;
   (if operandNo
    //0 then
       tempReg %Bor inst->inst;
       (* Above line tos_converted from: (tempReg, inst)->TOS'%or'->inst; *)
       mode %sll 3->mode;
       (* Above line tos_converted from: mode->TOS'%shiftleft[3]'->mode; *)
       mode %Bor inst->inst;
       (* Above line tos_converted from: (mode, inst)->TOS'%or'->inst; *)
    //1 then
       tempReg %sll 9->tempReg;
       (* Above line tos_converted from: tempReg->TOS'%shiftleft[9]'->tempReg; *)
       mode %sll 6->mode;
       (* Above line tos_converted from: mode->TOS'%shiftleft[6]'->mode; *)
       tempReg %Bor inst->inst;
       (* Above line tos_converted from: (tempReg, inst)->TOS'%or'->inst; *)
       mode %Bor inst->inst;
       (* Above line tos_converted from: (mode, inst)->TOS'%or'->inst; *)
   if);
   
   dReg->tempReg;
   tempReg %sll 12->tempReg;
   (* Above line tos_converted from: tempReg->TOS'%shiftleft[12]'->tempReg; *)
   scaleWord %Bor tempReg->scaleWord;
   (* Above line tos_converted from: (scaleWord, tempReg)->TOS'%or'->scaleWord; *)
   ( counter + dataOffset + 2 + gOffset, scaleWord)->inxputshort;
   (if off = -1//False then (* not 8 bit displacement *)
       ( counter + dataOffset + 4 + gOffset, off)->inxputlong;
       dataOffset + 4->dataOffset;
   if);
   dataOffset + 2->dataOffset;
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter +gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayDefLLabel: dopart--
Do (if lNo > labelTabel.Range then
       labelTabel.Range->LabelTabel.Extend;
       (if logging then
           '\n***WARNING Extending labelTabel: '->logfile.puttext;
           labelTabel.Range->logfile.putint;
       if);
   if);
   &LocalLabel[]->labelTabel[lNo][];
   (counter, contextData, currDataModuleId)->labelTabel[lNo];

--MachineArrayComputedRef: dopart--
Do &CompRefAdr[]->temp[];
   (l1, l2[], counter, gOffset)->temp;
   counter + 2->counter;
   temp[]->compRefTabel[currCompRefCounter][];
   currCompRefCounter + 1->currCompRefCounter;
   (if currCompRefCounter > compRefTabel.Range then
       compRefTabel.Range->compRefTabel.Extend;
       (if logging then
           '\n***WARNING Extending compRefTabel: '->logfile.puttext;
           compRefTabel.Range->logfile.putint;
       if);
   if);
   
   
   
   
   
   
   
   
   

--MachineArrayStartUp: dopart--
Do importTabel.Init; exportTabel.Init; entryTabel.Init; unsolvedLabel.Init;
   
   (* Try experients on sizing the repetitions based on groupfile size *)
   (* name: 'midgaard:beta:basiclib:v1.3:mac:betaenv' *)
   ':'->name.findAll(# do inx->i #); (* find last ':' *)
   (1,i-4)->name.sub->groupname[]; (* = 'midgaard:beta:basiclib:' *)
   (i+1,name.lgth)->name.sub->groupname.append; (* = 'midgaard:beta:basiclib:betaenv' *)
   '.group'->groupname.append;
   groupname[]->group.name;
   (if group.entry.exists then
       (* sizes for astBody: groupfile: 387K
        theArray: 40000 = 104
        theRecords: 3200 = 9
        labelTabel: 4000 = 11
        unsolvedRefs: 2000 = 6
        compRefTabel: 800 = 3
        * sizes for astlevel: groupfile: 204K
        theArray: 10000 = 50
        theRecords: 3200 = 16
        labelTabel: 2000 = 10
        unsolvedRefs: 500 = 3
        compRefTabel: 800 = 4
        * sizes for astparser: groupfile: 123K
        theArray: 10000 = 82
        theRecords: 800 = 7
        labelTabel: 1000 = 9
        unsolvedRefs: 500 = 5
        compRefTabel: 200 = 2
        *)
       group.Length div 1000->groupLength;
       (*'group.Length: '->tracestream.puttext; groupLength->tracestream.putint; *)
       (5000,groupLength*100)->max->theArray.extend;
       (200,groupLength*15)->max->theRecords.extend;
       (500,groupLength*10)->max->labelTabel.extend;
       (500,groupLength*5)->max->unsolvedRefs.extend;
       (100,groupLength*3)->max->compRefTabel.extend;
    else
       (* No group file??. Use defaults *)
       5000->theArray.extend;
       200->theRecords.extend;
       500->labelTabel.extend;
       500->unsolvedRefs.extend;
       100->compRefTabel.extend;
   if);
   
   FALSE->aligned;
   FALSE->BRelative->A5Rel;
   1->recCounter->currURefIndex->currCompRefCounter;
   &FirstRecord[]->tempRec[];
   (1, 0, 2)->tempRec; (* Nonsymbolic MPW 3.0 OMF file *)
   tempRec[]->theRecords[recCounter][];
   recCounter + 1->recCounter;
   0->counter->datacounter->codecounter->contentsStart;
   1->gOffset->idCounter->moduleNo->currEntryCounter;
   
   NewDictionary;
   TRUE->FirstProc;
   (*&DictionaryRecord[]->tempRec2[];
    (4, 0, idCounter)->tempRec2; recCounter->currDicIndex;
    tempRec2[]->theRecords[recCounter][];
    recCounter + 1->recCounter;
    (if recCounter > theRecords.Range then
    theRecords.Range->theRecords.Extend;
    if);*)
   

--MachineArrayShutDown: descriptor--
(# tempRec: ^LastRecord; temp, lno, adr, off: @Integer;
   dummy, tt: ^Text; tRef: ^MoreList; 
   compRefRec: ^ComputedRefRecord; found: @Boolean;
Do &Text[]->dummy[];

   (*Resolve refenrences, local labels so use relative addresses *)
   '.'->common.infostream.Puttext;
   (for f: currURefIndex - 1 repeat
        (if labelTabel[unsolvedRefs[f].labNo][]//NONE then

            'Unsolved Reference'->Bugstream.Puttext; Bugstream.Newline;
         else
            (if unsolvedRefs[f].BR
             //FALSE then
                LabelTabel[unsolvedRefs[f].labNo].adr - unsolvedRefs[f].adr->temp;
                ( unsolvedRefs[f].adr + unsolvedRefs[f].off, temp)->inxputshort;
             //TRUE then
                ( unsolvedRefs[f].adr + unsolvedRefs[f].off, LabelTabel[unsolvedRefs[f].labNo].adr - unsolvedRefs[f].adr)->inxputlong;
            if);
        if);
   for);
   
   (* Solve Beta_Labels *)
   BetaArray.Solve;
   
   (* calculate computed references *)
   &ComputedRefRecord[]->compRefRec[];
   (*(10, 145, 0, currRecId, currRecId)->compRefRec;*)
   (10, 145, 0, currDataModuleId, currDataModuleId)->compRefRec;
   
   (for f: currCompRefCounter - 1 repeat
        compRefTabel[f]->(lno, tt[], adr, off);
        tt[]->ExportTabel.Get->(found, tRef[]);
        (if found//FALSE then 'Unknow label in computed reference'->Bugstream.Puttext; Bugstream.Newline; if);
        ( adr + off, labelTabel[lno].adr - tRef.adr)->inxputshort;
        (dummy[], adr)->compRefRec.Insert;
   for);
   
   compRefRec[]->theRecords[recCounter][];
   recCounter + 1->recCounter;
   (if recCounter > theRecords.Range then
       theRecords.Range->theRecords.Extend;
       recordlog
   if);
   
   &LastRecord[]->tempRec[];
   2->tempRec;
   tempRec[]->theRecords[recCounter][];
   (* Write Array to file *)
   (# Create: External
        (# fileName: @Integer;
           vRefNum: @ShortInt;
           Creator,Type: @Integer;
           OSErr: @ShortInt;
        enter (fileName,vRefNum,Creator,Type)
        do 'CREATE'->CallPascal
        exit OSErr
        #);
      p: [0]@char;
      T: ^Text;
   do oFile.name->T[];
      T.lgth+1->p.extend;
      (for i: T.lgth repeat T.T[i]->p[i+1] for);
      T.lgth->p[1];
      (@@p[1],0,0x4d505320,0x4f424a20)->create;
   #);
   oFile.OpenWrite;
   (for f: recCounter repeat
        (if theRecords[f][]//NONE then
            Bugstream.Newline; 'F: '->bugstream.puttext;
            f->Bugstream.Putint; ' None'->Bugstream.Puttext;
         else
            theRecords[f].Dump;
        if);
   for);
   
   oFile.Close;

   
   (* Write Descriptor file *)
   (*sFile.OpenWrite;
    noOfDescriptor + 2->sFile.PutLong;
    currDescriptorAdr->sFile.PutLong;
    (for f: currTEntryIndex repeat
    TEntryTable[f]->descriptorList.Dump;
    for);
    sFile.Close;*)
   
   (if false then
       (# histogram: [0] @integer;
          max, min, average, usedIndices: @integer;
       do '!Writing Logfile'->common.tracestream.puttext;
          'ExportTabel stat: '->logFile.puttext;
          ExportTabel.statistics(# do logFile[]->print #)
            ->(histogram, max, min, average, usedIndices);
          'Used indices: '->logfile.puttext;
          usedIndices->logfile.putint; logfile.newline;
          'Elements: '->logfile.puttext; 
          ExportTabel.size->logfile.putint; logfile.newline;
          'EntryTabel stat: '->logFile.puttext;
          EntryTabel.statistics(# do logFile[]->print #)
            ->(histogram, max, min, average, usedIndices);
          'Used indices: '->logfile.puttext; 
          usedIndices->logfile.putint; logfile.newline;
          'Elements: '->logfile.puttext; 
          EntryTabel.size->logfile.putint; logfile.newline;
          'ImportTabel stat: '->logFile.puttext;
          ImportTabel.statistics(# do logFile[]->print #)
            ->(histogram, max, min, average, usedIndices);
          'Used indices: '->logfile.puttext; 
          usedIndices->logfile.putint; logfile.newline;
          'Elements: '->logfile.puttext; ImportTabel.size->logfile.putint;
          logfile.newline;
          logFile.newline;
          'theArray: '->logFile.puttext; theArray.range->logFile.putint; 
          logFile.newline;
          'theRecords: '->logFile.puttext; theRecords.range->logFile.putint;
          logFile.newline;
          'labelTabel: '->logFile.puttext; labelTabel.range->logFile.putint;
          logFile.newline;
          'unsolvedRefs: '->logFile.puttext; 
          unsolvedRefs.range->logFile.putint; logFile.newline;
          'compRefTabel: '->logFile.puttext; 
          compRefTabel.range->logFile.putint; logFile.newline;
          (*logFile.close;*)
       #)
   if);
   
   (* Make locally clean up *)
   0->theArray.new;
   0->theRecords.new;
   0->labelTabel.new;
   0->unsolvedRefs.new;
   0->compRefTabel.new;
   ImportTabel.clear; ExportTabel.clear; EntryTabel.clear; UnsolvedLabel.clear;
#)

--MachineArrayPutLong: dopart--
Do ( counter + dataOffset + 2 + gOffset, l)->inxputlong;
   dataOffset + 4->dataOffset;
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutWord: dopart--
Do ( counter + dataOffset + 2 + gOffset, w)->inxputshort;
   dataOffset + 2->dataOffset;
   
   operandNo + 1->operandNo;
   (if operandNo = noOfOp then
       ( counter + gOffset, inst)->inxputshort;
       counter + 2 + dataOffset->counter->IP;
   if);

--MachineArrayPutDC: dopart--
Do (if counter+goffset+4>thearray.range*4 then
       theArray.Range div 5->theArray.Extend;
       (if logging then
           '\n***WARNING Extending theArray: '->logfile.puttext;
           theArray.Range->logfile.putint;
       if);
   if);
   (if size
    //1 then
       ( counter + gOffset, c)->inxputbyte;
       counter + 1->counter;
    //2 then
       ( counter + gOffset, c)->inxputshort;
       counter + 2->counter;
    //4 then
       ( counter + gOffset, c)->inxputlong;
       counter + 4->counter;
   if);

--MachineArrayPutDCB: dopart--
Do (if counter+goffset+t.lgth>thearray.range*4 then
       theArray.Range div 5->theArray.Extend;
       (if logging then
           '\n***WARNING Extending theArray: '->logfile.puttext;
           theArray.Range->logfile.putint;
       if);
   if);
   
   (for f: t.lgth repeat
        ( counter + gOffset, t.T[f])->inxputbyte;
        counter + 1->counter;
   for);
   (*( counter + gOffset, 0)->inxputbyte; (* zero terminate *)
   counter + 1->counter;
   (if 1 %Band counter//1 then
   (* Above line tos_converted from: (if (1,counter)->TOS'%and'//1 then *)
       (if contextData then
           FALSE->aligned;
           counter - contentsStart->currContentsRec.size;
           currContentsRec[]->theRecords[recCounter][];
           recCounter + 1->recCounter;
           (if recCounter > theRecords.Range then 
               theRecords.Range->theRecords.Extend;
           if);
           counter + 1->counter;
           counter->contentsStart;
           &contentsRecord[]->currContentsRec[];
           (8, 9, 0, counter, counter + gOffset)->currContentsRec;
           switchToData;
        else
           (*( counter + gOffset, 0)->inxputbyte; (* ALIGN *)
           counter + 1->counter;
       if);
   if);

--MachineArrayDeclareAddress: dopart--
Do (if 1 %Band counter//1 then counter + 1->counter if);
(* Above line tos_converted from: Do (if (1,counter)->TOS'%and'//1 then counter + 1->counter if); *)
   0->dataOffset;
   counter - 2->counter; (* hack, the operand asumes an instruction before 
                          * the operation 
                          *)
   0->operandNo;

--MachineArrayRecordLog: dopart--
do (if logging then
       '\n***WARNING Extending theRecords: '->logfile.puttext;
       theRecords.Range->logfile.putint;
   if);

--MachineArraySeg: dopart--
do name.copy->newname[];
   '.o'->name.append;
   name[]->oFile.Name;
   idCounter->currSegId;
   idCounter + 1->idCounter;
   (*name[]->theRecords[currDicIndex].Insert;*)            
   segName[]->theRecords[currDicIndex].Insert;
   '.des'->newName.Append;
   newName[]->sFile.Name;		    
   false->logging;
   (if logging then
       (*****
        name.copy->logName[];
        '.log'->logName.append;
        logName[]->logFile.Name;
        logFile.openwrite;
        ****)
       screen[]->logfile[];
   if);

--MachineArrayNewModule: descriptor--
(# segNo: @Integer; data: @Boolean; tempRec: ^ModuleRecord;
   id: @Integer; found: @Boolean; more: ^intList; tempText: ^Text;
Do '#'->tempText[]; moduleNo->tempText.putInt;
   (*(tempText[], idCounter, counter, FALSE)->ExportTabel.DeclareWord;*)
   tempText[]->theRecords[currDicIndex].Insert;
   
   &ModuleRecord[]->tempRec[];
   (if contextData then
       (5, 1, idCounter, 0)->tempRec;
       TRUE->hasDataModule;
       idCounter->currDataModuleId;
       tempText->dataMName;
    else
       (*currSegName->dictionary.Get->(found, more[], id);*)
       (5, 0, idCounter, currSegId)->tempRec;
       TRUE->hasCodeModule;
   if);
   tempRec[]->theRecords[recCounter][];
   recCounter + 1->recCounter;
   (if recCounter > theRecords.Range then 
       theRecords.Range->theRecords.Extend; 
       recordlog
   if);
   
   idCounter + 1->idCounter;
   moduleNo + 1->moduleNo;
#)

--MachineArrayEndModule: descriptor--
(# tempInt: @Integer;
Do counter + gOffset->tempInt;
   (if hasCodeModule then
       ( tempInt, 7)->inxputbyte;
       ( tempInt + 1, 0)->inxputbyte;
       ( tempInt + 2, codeCounter)->inxputlong;
       False->hasCodeModule;
       tempInt + 6->tempInt;
   if);
   
   (if hasDataModule then
       ( tempInt, 7)->inxputbyte;
       ( tempInt + 1, 1)->inxputbyte;
       ( tempInt + 2 , dataCounter)->inxputlong;
       False->hasDataModule;
       tempInt + 6->tempInt;
   if);
   
   recOffset + (tempInt - (counter + gOffset))->recOffset;
#)

--MachineArrayNewDictionary: descriptor--
(# tempRec: ^DictionaryRecord;
do &DictionaryRecord[]->tempRec[];
   (4, 0, idCounter)->tempRec; recCounter->currDicIndex;
   tempRec[]->theRecords[recCounter][];
   recCounter + 1->recCounter;
   (if recCounter > theRecords.Range then
       theRecords.Range->theRecords.Extend;
       recordlog
   if);
#)

--MachineArrayStab: dopart--
Do (counter - currDescriptorAdr, astRef)->currDescEntry.Insert;
   counter->currDescriptorAdr;
   noOfDescriptor + 2->noOfDescriptor;

--MachineArrayEndMentry: dopart--
Do (*(counter - currDescriptorAdr, 0)->currDescEntry.Insert;
    noOfDescriptor + 2->noOfDescriptor;*)

--MachineArrayDescriptorEntryInsert: dopart--
Do currEntry + 1->currEntry;
   (if currEntry > StabList.Range then
       StabList.Range->StabList.Extend;
   if);
   &StabEntry[]->StabList[currEntry][];
   (offset, astIndex)->StabList[currEntry];

--MachineArrayDescriptorEntryDump: descriptor--
(# 
Do (for f: currEntry repeat
        StabList[f].offset->sFile.PutLong;
        StabList[f].astIndex->sFile.PutLong;
   for);
#)

--MachineArrayDescriptorListHash: dopart--
do L: (for i: 7 repeat
           e.mName.lgth-i+1->inx;
           (if inx < 1 then leave L if);
           e.mName.T[inx] + value->value;
      for)

--MachineArrayDescriptorListDump: dopart--
Do 0->theIndex; 
   L: (for i: 7 repeat
           tName.lgth-i+1->inx;
           (if inx < 1 then leave L if);
           tName.T[inx] + theIndex->theIndex;
      for);
   theIndex->findIndexed->temp[];
   (if temp[]//NONE then
       -1->sFile.PutLong;
       -1->sFile.PutLong;
    else
       temp.Dump;
   if);

--MachineArrayDictionaryRecordInsert: dopart--
Do repCount + 1->repCount;
   (if repCount > nameRep.Range then
       nameRep.Range->nameRep.Extend;
   if);
   name.copy->nameRep[repCount][];
   size + name.lgth + 1->size;

--MachineArrayDictionaryRecordDump: dopart--
Do flags->oFile.putbyte;
   size + 6->oFile.putshort;
   firstID->oFile.putshort;
   (* put dictionary *)
   (for f: repCount repeat
        nameRep[f].lgth->oFile.putByte;
        nameRep[f][]->oFile.putText;
   for);
   (if 1 %Band size//1 then 0->oFile.putByte; if); (* PAD *)
   (* Above line tos_converted from: (if (1,size)->TOS'%and'//1 then 0->oFile.putByte; if); *)

--MachineArrayContentsRecordDump: dopart--
do (if size > 32767 then
       (*'Record to large'->SysError(# do true->continue #);*)
       (if size mod 2//1 then
           (size - 1) div 2->sizemod;
        else
           size div 2->sizemod;
       if);
       flags->oFile.putbyte;
       sizemod + 8->oFile.putshort;
       offset->oFile.putlong;
(*****
       index - 1->loop;
       (for f: sizemod repeat
            loop + f -> theArray.%getByte->oFile.putByte;
            (* Above line tos_converted from: (theArray, loop + f)->TOS'%inxGetByte'->oFile.putByte; *)
       for);
*****)
       (@@theArray[1]+index, sizemod) -> oFile.putbytes;
	   
       (if 1 %Band sizemod//1 then 0->oFile.putByte; if); (* PAD *)
       (* Above line tos_converted from: (if (1,sizemod)->TOS'%and'//1 then 0->oFile.putByte; if); *)
       8->oFile.putbyte;
       flags->oFile.putByte;
       size - sizemod + 8->oFile.putshort;
       offset + sizemod->oFile.putlong;
(*****
       index + sizemod - 1->loop;
       (for f: size - sizemod repeat
            loop + f -> theArray.%getByte->oFile.putByte;
            (* Above line tos_converted from: (theArray, loop + f)->TOS'%inxGetByte'->oFile.putByte; *)
       for);
****)
       (@@theArray[1]+index + sizemod, size - sizemod) -> oFile.putbytes;

       (if (1) %Band (size - sizemod)//1 then 0->oFile.putByte; if);
       (* Above line tos_converted from: (if (1, size - sizemod)->TOS'%and'//1 then 0->oFile.putByte; if); *)
    else
       flags->oFile.putbyte;
       size + 8->oFile.putshort;
       offset->oFile.putlong;
       (if size > 0 then
(******
           index - 1->index;
           (for f: size repeat
                index + f -> theArray.%getByte->oFile.putByte;
                (* Above line tos_converted from: (theArray, index + f)->TOS'%inxGetByte'->oFile.putByte; *)
           for);
*******)
           (@@theArray[1]+index, size) -> oFile.putbytes;
       if);
       (if 1 %Band size//1 then 0->oFile.putByte; if); (* PAD *)
       (* Above line tos_converted from: (if (1,size)->TOS'%and'//1 then 0->oFile.putByte; if); *)
   if);

--MachineArrayReferenceRecordInsert: dopart--
Do (if isContextData then
       countData + 1->countData;
       (if countData > dataOffRep.Range then
           countData->dataOffRep.Extend;
       if);
       off->dataOffRep[countData];
       true->fromData;
    else
       countCode + 1->countCode;
       (if countCode > codeOffRep.Range then
           countCode->codeOffRep.Extend;
       if);
       off->codeOffRep[countCode];
       true->fromCode;
   if);

--MachineArrayReferenceRecordDump: dopart--
Do (if fromCode AND fromData then (* we gonna make two refRecs *)
       (if isContextData then (* first make refRec from code *)
           0x88->flags;
        else
           0x08->flags;
       if);
       flags->oFile.putByte;
       4 * countCode + 6->oFile.Putshort;
       refId->oFile.PutShort;
       (@@codeOffRep[1], countCode)->oFile.PutRep;
       
       (* then make refRec from data *)
       0x09->oFile.PutByte; (* because we make a new refRec *)
       0x09->oFile.PutByte;
       4 * countData + 6->oFile.PutShort;
       refId->oFile.PutShort;
       (@@dataOffRep[1], countData)->oFile.PutRep;
    else
       (if true
        //fromCode then
           (if isContextData then
               0x88->flags;
            else
               0x08->flags;
           if);
           flags->oFile.putByte;
           4 * countCode + 6->oFile.Putshort;
           refId->oFile.PutShort;
           (@@codeOffRep[1], countCode)->oFile.PutRep;
        //fromData then
           0x09->oFile.PutByte;
           4 * countData + 6->oFile.PutShort;
           refId->oFile.PutShort;
           (@@dataOffRep[1], countData)->oFile.PutRep;
       if);
           (*(if (1 %Band size)=1 then 0->oFile.putByte; if);*)
   if);

--MachineArrayComputedRefRecordInsert: dopart--
Do repCounter + 1->repCounter;
   (if repCounter > offRep.Range then
       offRep.Range->offRep.Extend;
   if);
   
   off->offRep[repCounter];
   size + 2->size;

--MachineArrayComputedRefRecordDump: dopart--
Do flags->oFile.PutByte;
   size + 8->oFile.PutShort;
   id1->oFile.PutShort;
   id2->oFile.PutShort;
   (for f: repCounter repeat
        offRep[f]->oFile.PutShort;
   for);
   (if 1 %Band size//1 then 0->oFile.putByte; if);
   (* Above line tos_converted from: (if (1,size)->TOS'%and'//1 then 0->oFile.putByte; if); *)

--MachineArrayOOPS: dopart--
do bugstream.newline; '******* System error!!!'->bugstream.putline;
   T[]->bugstream.putline; 
   INNER;

--MachineArraySysError: dopart--
do 'Please report this error to Mj¿lner Informatics'->bugstream.putline;
   INNER;
   (if continue//false then
       (FailureTrace,'Compilation stopped because of compiler error!')
         -> &Stop
   if)
