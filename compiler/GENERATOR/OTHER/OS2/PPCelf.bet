ORIGIN 'PPCmachine';
INCLUDE 'ELF/elffile';
INCLUDE 'ELF/elf_ppc';
MAKE sun4s 'ELF/makefile';
---emitCodeToFile:descriptor---'
(#
   align4: @
     (# n: @integer
     enter n
     exit (n + 3) %band (%bnot 3)
     #);
   SectionStringTable: @
     (* Data for section string table *)
     (# shstr: ^text;
        sectionStringStart,
        textStart,
        dataStart,
        relTextStart,
        relDataStart,
        strtabStart,
        symtabStart,
        regInfoStart: @integer;
        init:
          (#
          do &text[]->shstr[];
             0->shstr.put;
             shstr.length->sectionStringStart;
	     '.shstrtab'->shstr.append; 0->shstr.put;
             shstr.lgth->textStart;
             '.text'->shstr.append; 0->shstr.put;
             shstr.lgth->dataStart;
             '.data'->shstr.append; 0->shstr.put;
             shstr.lgth->relTextStart;
             '.rela.text'->shstr.append; 0->shstr.put;
             shstr.lgth->relDataStart;
             '.rela.data'->shstr.append; 0->shstr.put;
             shstr.lgth->strtabStart;
             '.strtab'->shstr.append; 0->shstr.put;
             shstr.lgth->symtabStart;
             '.symtab'->shstr.append; 0->shstr.put;
             (*shstr.lgth->regInfoStart;
              '.reginfo'->shstr.append; 0->shstr.put;*)
     #)#);

   sections: @
     (# (*sectionInx: (#exit 1 #);
        sectionStringStart: @ (#exit elfHeaderSize #);
        sectionStringSize: @ (#exit SectionStringTable.shstr.lgth ( *NO GC!* )#);
        textInx: (#exit 2 #);
        textStart: @ (#exit sectionStringStart + sectionStringSize->align4 #);
        textSize: @ (#exit b.LIP->align4 #);
        dataInx: (#exit 3 #);
        dataStart: @ (#exit textStart + textSize #);
        dataSize: @ (#exit d.LIP->align4 #);
        symTabInx: (#exit 4 #);
        symtabStart: @ (#exit dataStart + dataSize #);
        symtabSize: @ (#exit (mstate.symtabTop + 1) * symEntSize #);
        stringInx: (#exit 5 #);
        stringStart: @ (#exit symtabStart + symtabSize #);
        stringSize: @ (#exit mstate.strTbl.str.lgth ( * be sure its static * )#);
        relTextInx: (#exit 6 #);
        relTextStart: @ (#exit stringStart + stringSize->align4 #);
        relTextSize: @ (#exit mstate.b.noOfRel * relaSize #);
        relDataInx: (#exit 7 #);
        relDataStart: @ (#exit relTextStart + relTextSize #);
        relDataSize: @ (#exit mstate.d.noOfRel * relaSize #);
         headerStart: @ (#exit relDataStart + relDataSize #);
         *)
        sectionInx,sectionStringStart: @integer;
        sectionStringSize: @ (#exit SectionStringTable.shstr.lgth (*NO GC!*)#);
        textInx,textStart: @ integer;
        textSize: @ (#exit b.LIP->align4 #);
        dataInx, dataStart: @ integer;
        dataSize: @ (#exit d.LIP->align4 #);
        symTabInx, symtabStart: @ integer;
        symtabSize: @ (#exit (mstate.symtabTop + 1) * symEntSize #);
        stringInx, stringStart: @ integer;
        stringSize: @ (#exit mstate.strTbl.str.lgth (* be sure its static *)#);
        relTextInx, relTextStart: @ integer;
        relTextSize: @ (#exit mstate.b.noOfRel * relaSize #);
        relDataInx, relDataStart: @ integer;
        relDataSize: @ (#exit mstate.d.noOfRel * relaSize #);
        (*regInfoInx,regInfoStart: @integer;
         regInfoSize: @ (#exit 24 #);*)
        headerStart: @ integer;
        pos,inx: @integer;
        init:
          (# ElfHeader:
               (#
               do  pos + elfHeaderSize -> pos
               #);
             SectionString:
               (#
               do inx + 1 -> inx -> sectionInx;
                  pos -> sectionStringStart;
                  (pos + SectionStringSize) -> align4 -> pos
               #);
             (*regInfoSec:
               (#
               do inx + 1 -> inx -> regInfoInx;
                  pos -> regInfoStart;
                  pos + regInfoSize -> pos
              #);*)
             textSec:
               (#
               do inx + 1 -> inx -> textInx;
                  pos -> textStart;
                  pos + textSize -> pos
               #);
             dataSec:
               (#
               do inx + 1 -> inx -> dataInx;
                  pos -> dataStart;
                  pos + dataSize -> pos
               #);  
             symTab:
               (#
               do inx + 1 -> inx -> symTabInx;
                  pos -> symtabStart;
                  pos + symTabSize -> pos;
               #);
             string:
               (#
               do inx + 1 -> inx -> stringInx;
                  pos -> stringStart;
                  (pos + stringSize) -> align4 -> pos;
               #);
             relText:
               (#
               do inx + 1 -> inx -> reltextInx;
                  pos -> relTextStart;
                  pos + reltextSize -> pos;
               #);
             relData:
               (#
               do inx + 1 -> inx -> relDataInx;
                  pos -> relDataStart;
                  pos + relDataSize -> pos
               #);
             header:
               (#
               do pos -> headerStart
               #);
          do ElfHeader;
            (* SectionString;
             textSec;
             dataSec;
             symTab;
             string;
             reltext;
             relData;
             header*)
             (*regInfoSec;*)
             symTab; (* symboltable MUST come before relocation entries
                      * since emitSymbolTable sorts the symbols;
                      * alternateveliy the sorting should be executed
                      * initially before emitting any sections
                      *)
             textSec;
             reltext;
             dataSec;             
             relData;
             SectionString;

             string;
             header
          #)
     #);
   EmitHeader:
     (* Construct elf header *)
     (#
     do
        (
        0 (* No entry point *), 
        sections.headerStart (* offset to section header table in foo.o*), 
        0 (*EF_MIPS_PIC+EF_MIPS_NOREORDER*), (* sun4s has no flags *)
        sections.inx+1
        (* undefined, section string, text, data, reltext, relData,
         * string, symtab (*,regInfo)
         *),
        sections.sectionInx (* index of .shstrndx in section header table *)
        ) -> EF.putEhdr;
     #);
   EmitRegInfo:
     (# R: [6] @integer
     do 0xffffffff -> R[1];
        (@@R[1],24)->putB
     #);
   EmitText:
     (#
     do (@@b.buffer[1],sections.textSize)->putB;
     #);
   EmitData:
     (#
     do (@@d.buffer[1],sections.dataSize)->putB;
     #);
   EmitRel:
     (# im: ^Image;
        relType: [markMax] @integer; 
        mark,symtabInx,relInfo,n: @integer
     do R_PPC_REL24      ->relType[callMark];
        R_PPC_ADDR16_HI  ->relType[setHiMark];
        R_PPC_ADDR16_LO  ->relType[setLoMark];
        R_PPC_ADDR16_LO  ->relType[setLoMarkSt];
        R_PPC_ADDR16_LO  ->relType[setLoMarkJmp];
        R_PPC_ADDR16_LO  ->relType[setLoMarkLdd];
        R_PPC_ADDR16_LO  ->relType[setLoMarkLd];
        R_PPC_ADR32      ->relType[wordMark];
        R_PPC_NONE       ->relType[entryDefMark];
        R_PPC_REL24      ->relType[jmpMark];
        (*
        R_SPARC_WDISP22     ->relType[bgtuMark];*)
        INNER; (* define im to be one of mstate.d or mstate.b *)
        (for i: im.markTop repeat
             (if im.types[i]->mark
              // entryDefMark then
              else
                 (* symtab indexes are counted 0,1,... *)
                 im.epElm[i].m.symtabInx ->symtabInx;
                 (symtabInx %sll 8) + relType[mark]->relInfo;
                 ((im.marks[i]-1)*4,relInfo,0)->EF.putRelaEnt;
                 n+1->n;
             if)
        for);
        (if n <> im.noOfRel then 
            '\nWARNIG rel count inconsistencies: '->putText;
            n->putint; ' '->put; im.noOfRel->putint; newline
        if)
     #);
   EmitRelText: EmitRel(#do mstate.b[]->im[] #);
   EmitRelData: EmitRel(#do mstate.d[]->im[] #);
   lastLocalInSymtab: @integer;
   EmitSymbolTable:
     (# sort:
          (* local symbols MUST preceede global symbols *)
          (# first,last: @integer; S: ^EntryPointInfo
          do 3->first; mstate.symtabTop->last;
             findGlobal:
               (* ep[1..first-1]=local and ep[last+1..ep.range]=global 
                * and first < last
                *)
               (if first < last then
                   (if ep[first][]->isGlobal then
                       findLocal:
                         (if first < last then
                             (if ep[last][]->isGlobal then
                                 last-1->last;
                                 restart findLocal
                              else
                                 (* ep[first]=global and  ep[last]=local*)
                                 (* swap *)
                                 ep[first][]->S[]; ep[last][]->ep[first][];
                                 S[]->ep[last][];
                                 first->ep[first].m.symTabInx;
                                 last->ep[last].m.symTabInx;
                                 (* ep[first]=local and ep[last]=global *)
                                 last-1->last
                   if)if)if);
                   (* ep[first]=local*)
                   first+1->first;
                   restart findGlobal;
               if)
          #);
        isGlobal:
          (# S: ^EntryPointInfo; b: @boolean
          enter S[]
          exit (S.local and S.export) or not S.local
          #);
        defSec, n: @integer; 
        ep: [mstate.symtabTop] ^EntryPointInfo
     do entryPoints.scan
        (#
        do current[]->ep[current.m.symtabInx][] ; n+1->n
        #);
        (if (n + 2) <> mstate.symtabTop then
            '\n WARNIG: inconistencies in symtab size:'->puttext;
            n->putint; ' '->put; mstate.symtabTop->putint; newline;
        if);
        sort;
        (0,0,0,0,0,SHN_UNDEF)->EF.putSymEnt; (* initial entry*)
        (0(*textStrTblSTart*)
        ,0,
        0 (*sections.textSize*)
        ,STT_SECTION,0,sections.textInx)
          ->EF.putSymEnt; 
        (0 (*dataStrTblStart*)
        ,0,
        0 (*sections.dataSize*)
        ,STT_SECTION,0,sections.dataInx)
          ->EF.putSymEnt; 
        (for i: ep.range-2 repeat
             (# current: ^ EntryPointInfo; binding,type,info: @integer
             do ep[i+2][]->current[];
                
                (* how do we know if a symb is imported? -
                 * Apparently: any symbol not being defined is global.
                 * binding is thus redefined below if not a def 
                 *)
                (if current.local then (*defined in this fragment *)
                    (* define a symtab entry for a label def. *)
                    (if current.export then (* exported from this fragment *)
                        STB_GLOBAL->binding
                     else 
                        STB_LOCAL->binding;
                        i+2->lastLocalInSymtab;
                    if);
                    (if current.data then (*defined in data fragment *)
                        STT_OBJECT->type;
                        sections.dataInx->defSec
                     else
                        STT_FUNC->type                         ;
                        sections.textInx->defSec
                    if)
                 else
                    0->defSec;
                    STB_GLOBAL->binding;
                    (if current.data then
                        STT_OBJECT->type
                     else
                        STT_FUNC->type
                if)if);
                (*STT_NOTYPE->type;*)
                (binding %sll 4) + type -> info;
                (current.m.strInx (* index into strTable *)
                , current.LIP   (* offset where symb is defined, if defined*)
                , 0               (* size *)
                , info
                , 0               (* other *)
                , defSec          (* st_shndx - section defining symbol *)
                )->EF.putSymEnt;
        #)for);
     #);
   EmitSectionStringTable:
     (* Write section string table *)
     (#
     do (@@sectionStringTable.shstr.T[1], sections.sectionStringSize->align4) 
          -> putb
     #);
   EmitStringTable:
     (#
     do (@@mstate.strTbl.str.T[1],sections.stringSize->align4)->putb
     #);
   EmitSectionHeaderTable:
     (#
     do (* Write the empty section header (always present) *)
        (0, SHT_NULL, 0, 0, 0, 0, SHN_UNDEF, 0, 0, 0) -> EF.putShdr;
        (for i: sections.inx repeat 
             (if i 
              // sections.sectionInx then
                 (* Write the section string table header *)
                 (1 (* name is index 1 in .shstrtab *), 
                 SHT_STRTAB (* type *), 
                 0 (* flags *), 
                 0 (* address in executable unspecified *),
                 sections.sectionStringStart (*elfheadersize*) (* Offset to section in file *), 
                 sections.sectionStringSize,
                 SHN_UNDEF (* no link info *), 
                 0 (* No info *), 
                 1 (* byte alignment *), 
                 0 (* not fixed size entries *)
                 ) -> EF.putShdr;        
              // sections.textInx then
                 (* Write the text section table header *)
                 (sectionStringTable.textStart (* start in .shstrtab *),
                 SHT_PROGBITS (* type !!!*), 
                 SHF_ALLOC + SHF_EXECINSTR(* flags !!!*), 
                 0 (* address in executable unspecified !!! *),
                 sections.textStart (* Offset to section in file !!!*), 
                 sections.textSize,
                 SHN_UNDEF (* no link info !!!*), 
                 0 (* No info *), 
                 4 (* byte alignment *), 
                 0 (* not fixed size entries !!!*)
                 ) -> EF.putShdr;        
              // sections.dataInx then                 
                 (* Write the data section table header *)
                 (sectionStringTable.dataStart,
                 SHT_PROGBITS (* type !!!*), 
                 SHF_ALLOC + SHF_WRITE (* flags !!!*), 
                 0 (* address in executable unspecified !!!*),
                 sections.dataStart (* Offset to section in file !!!*), 
                 sections.dataSize,
                 SHN_UNDEF (* no link info !!!*), 
                 0 (* No info *), 
                 256 (*8*) (* byte alignment *), 
                 0 (* not fixed size entries !!!*)
                 ) -> EF.putShdr;        
              // sections.symtabInx then
                 (* Write the .symtab header *)
                 (sectionStringTable.symtabStart, 
                 SHT_SYMTAB (* type *), 
                 0 (*SHF_ALLOC*) (* flags *), 
                 0 (* address in executable unspecified *),
                 sections.symtabStart (* Offset to section in file *), 
                 sections.symtabSize,
                 sections.stringInx,  (* sh_link *)
                 3 (*lastLocalInSymtab+1*), (* sh_inf0 *)
                 4 (* byte alignment *), 
                 symEntSize    (* size of a symtab entry *)
                 ) -> EF.putShdr;
              // sections.stringInx then 
                 (* Write the string table header *)
                 (sectionStringTable.strtabStart, 
                 SHT_STRTAB (* type *), 
                 0 (*SHF_ALLOC*) (* flags *), 
                 0 (* address in executable unspecified *),
                 sections.stringStart (* Offset to section in file *), 
                 sections.stringSize,
                 SHN_UNDEF (* no link info *), 
                 0 (* No info *), 
                 1 (* byte alignment *), 
                 0 (* not fixed size entries *)
                 ) -> EF.putShdr;
              // sections.relTextInx then
                 (* Write the .rel.text section table header *)
                 (sectionStringTable.relTextStart,
                 SHT_RELA (*A*) (* type !!!*), 
                 0 (*SHF_ALLOC*) (* flags !!!*), 
                 0 (* address in executable unspecified !!!*),
                 sections.relTextStart (* Offset to section in file !!!*), 
                 sections.relTextSize,
                 sections.symtabInx,   (* sh_link *)
                 sections.textInx,     (* sh_info *)
                 4 (* byte alignment *), 
                 relaSize
                 ) -> EF.putShdr;        
              // sections.relDataInx then
                 (* Write the .rel.data section table header *)
                 (sectionStringTable.relDataStart,
                 SHT_RELA(*A*) (* type !!!*), 
                 0 (*SHF_ALLOC*) (* flags !!!*), 
                 0 (* address in executable unspecified !!!*),
                 sections.relDataStart (* Offset to section in file !!!*), 
                 sections.relDataSize,
                 sections.symtabInx,   (* sh_link *)
                 sections.dataInx,     (* sh_info *)
                 8 (* byte alignment *), 
                 relaSize
                 ) -> EF.putShdr;
              (*// sections.regInfoInx then
                 (* Write tyhe -reginfo scetion table header * )
                 (sectionStringTable.regInfoStart,
                 SHT_MIPS_REGINFO, (* type * )
                 SHF_ALLOC,        (* flags * )
                 0,                (* adr in executable unspecified * )
                 sections.regInfoStart, (* offset to section in file* )
                 sections.regInfoSize , (* section size * )
                 0,                     (* sh_link * )
                 0,                     (* sh_info * )
                 4,                     (* byte alignment * )
                 1                      (* entry size ?* )
                                         ) -> EF.putShdr;*)
        if)for)
     #);
   
   EF: @elffile
     (# accesserror::< (#do name->common.PassCodeFileAccessError #);
        NoSpaceError::< (* disk is full *)
          (#do delete; common.PassNoSpaceError #);
        WriteError::< (* disk is full *)
          (#do delete; common.PassNoSpaceError #);
     #);

   putb: @EF.putbytes;
   
   T: ^text;
do (BC.name).copy->T[];
   (*(T.length-1,T.length)->T.delete; ( * T = '.../foo.' * )
    * 
    *)
   (if common.switch[55] then '.go'->T.append->EF.name
    else '.o'->T.append->EF.name
   if);
   EF.openWrite;
   SectionStringTable.init;
   sections.init;
   
   EmitHeader;
   
   (*EmitRegInfo;*)
   EmitSymbolTable;
   EmitText;
   EmitRelText;
   EmitData;
   EmitRelData;
   EmitSectionStringTable;

   EmitStringTable;
   EmitSectionHeaderTable;

   EF.close;
#)

