ORIGIN '~beta/basiclib/binfile';
INCLUDE '~beta/sysutils/endian';
INCLUDE '~beta/basiclib/numberio';
--LIB: attributes--

(* classfiledefs.bet:
 *   Patterns for manipulating Java class files.
 * 
 *   See http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html
 *   Section numbers below refer to this document.
 *)

(* Section 4.1 *)
JAVA_MAGIC: (# exit 0xcafebabe #);
JAVA_MAJOR: (# exit 45 #);
JAVA_MINOR: (# exit 3 #);

(* Access flags *)
ACC_PUBLIC: (# exit 0x0001 #);
ACC_PRIVATE: (# exit 0x0002 #);
ACC_PROTECTED: (# exit 0x0004 #);
ACC_STATIC: (# exit 0x0008 #);
ACC_FINAL: (# exit 0x0010 #);
ACC_SYNCHRONIZED: (# exit 0x0020 #);
ACC_SUPER: (# exit 0x0020 #);
ACC_VOLATILE: (# exit 0x0040 #);
ACC_TRANSIENT: (# exit 0x0080 #);
ACC_NATIVE: (# exit 0x0100 #);
ACC_INTERFACE: (# exit 0x0200 #);
ACC_ABSTRACT: (# exit 0x0400 #);
ACC_STRICT: (# exit 0x0800 #);

ACC_VISIBILITY:
  (# exit (ACC_PUBLIC %Bor ACC_PRIVATE %Bor ACC_PROTECTED) #);

(* Constant types *)
CONSTANT_Class: (# exit 7 #);
CONSTANT_Fieldref: (# exit 9 #);
CONSTANT_Methodref: (# exit 10 #);
CONSTANT_InterfaceMethodref: (# exit 11 #);
CONSTANT_String: (# exit 8 #);
CONSTANT_Integer: (# exit 3 #);
CONSTANT_Float: (# exit 4 #);
CONSTANT_Long: (# exit 5 #);
CONSTANT_Double: (# exit 6 #);
CONSTANT_NameAndType: (# exit 12 #);
CONSTANT_Utf8: (# exit 1 #);
CONSTANT_Unicode: (# exit 2 #);

const2text:
  (# const: @integer;
     txt: ^text;
  enter const
  do (if const
      // 7 then 'CONSTANT_Class' -> txt[]
      // 9 then 'CONSTANT_Fieldref' -> txt[]
      // 10 then 'CONSTANT_Methodref' -> txt[]
      // 11 then 'CONSTANT_InterfaceMethodref' -> txt[]
      // 8 then 'CONSTANT_String' -> txt[]
      // 3 then 'CONSTANT_Integer' -> txt[]
      // 4 then 'CONSTANT_Float' -> txt[]
      // 5 then 'CONSTANT_Long' -> txt[]
      // 6 then 'CONSTANT_Double' -> txt[]
      // 12 then 'CONSTANT_NameAndType' -> txt[]
      // 1 then 'CONSTANT_Utf8' -> txt[]
      // 2 then 'CONSTANT_Unicode' -> txt[]
      else 
         '???' -> txt[]
     if);
  exit txt[]
  #);

--BinFilelib: attributes--

tracePos:
  (# prompt: ^text;
  enter prompt[]
  do '  Writing ' -> screen.puttext;
     prompt[] -> screen.puttext;
     ' ' -> screen.put;
     INNER;
     ' at address 0x' -> screen.puttext;
     GetPos -> screen.puthex; 
     ' (' -> screen.puttext;
     GetPos -> screen.putint;
     ')' -> screen.putline;
  #);
tracePosValue: tracePos
  (# value: @integer
  enter value
  do '0x' -> screen.puttext;
     value -> screen.puthex;
     ' ' -> screen.put;
  #);
tracePosText: tracePos
  (# t: ^text
  enter t[]
  do t[] -> screen.puttext;
     ' ' -> screen.put;
  #);

(* Section 4.1 *)
interface_info: entry
  (# interface_name_index: @int16u;
     write::
       (# 
       do interface_name_index -> htons -> putShort; 
       #);
  #);

interface_table: entry_table(# entrytype::interface_info #);


(* section 4.4: The Constant Pool *)

cp_info: entry
  (* Section 4.4 *)
  (# tag:< charvalue;
     moretrace:< object;
     write::<
       (# t: ^text;
       do (if trace then
              '  #' -> t[];
              inx -> t.putint;
              ' ' -> t.put;
              tag -> const2text -> t.append;
              t[] -> tracePos(# do moretrace; #);
          if);
          tag->putByte;
          INNER;
       #);
  exit THIS(cp_info)[]
  #);
CONSTANT_Class_info: cp_info
  (* Section 4.4.1 *)
  (# tag:: (# do CONSTANT_Class->value #);
     name_index: @int16u;
     moretrace::<
       (#
       do name_index -> screen.putint;
       #);
     write:: 
       (# 
       do name_index -> htons -> putShort;
       #);
  enter name_index
  #);
CONSTANT_ref_info: cp_info
  (* Section 4.4.2 *)
  (# class_index: @int16u;
     name_and_type_index: @int16u;
     moretrace::<
       (#
       do class_index -> screen.putint;
          ','->screen.put;
          name_and_type_index -> screen.putint;
       #);
     write:: 
       (# 
       do class_index -> htons -> putShort;
          name_and_type_index -> htons -> putShort;
       #);
  enter (class_index, name_and_type_index)
  #);
CONSTANT_Fieldref_info: CONSTANT_ref_info
  (* Section 4.4.2 *)
  (# tag:: (# do CONSTANT_Fieldref->value #);
  #);
CONSTANT_Methodref_info: CONSTANT_ref_info
  (* Section 4.4.2 *)
  (# tag:: (# do CONSTANT_Methodref->value #);
  #);
CONSTANT_InterfaceMethodref_info: CONSTANT_ref_info
  (* Section 4.4.2 *)
  (# tag:: (# do CONSTANT_InterfaceMethodref->value #);
  #);
CONSTANT_String_info: cp_info
  (* Section 4.4.3 *)
  (# tag:: (# do CONSTANT_String->value #);
     string_index: @int16u;
     moretrace::<
       (#
       do string_index -> screen.putint;
       #);
     write:: (# do string_index -> htons -> putShort; #);
  enter string_index
  #);
CONSTANT_U4_info: cp_info
  (* Section 4.4.4 *)
  (# bytes: @int32;
     moretrace::<
       (#
       do bytes -> screen.putint;
       #);
     write:: (# do bytes -> htonl -> putlong; #);
  #);
CONSTANT_Integer_info: CONSTANT_U4_info
  (* Section 4.4.4 *)
  (# tag:: (# do CONSTANT_Integer->value #);#);
CONSTANT_Float_info: CONSTANT_U4_info
  (* Section 4.4.4 *)
  (# tag:: (# do CONSTANT_Float->value #);
  #);
CONSTANT_Long_info: cp_info
  (* Section 4.4.5 *)
  (# tag:: (# do CONSTANT_long->value #);
     high_bytes: @int32;
     low_bytes: @int32;
     moretrace::<
       (#
       do high_bytes -> screen.putint;
          ','->screen.put;
          low_bytes -> screen.putint;
       #);
     write::
       (# 
       do high_bytes -> htonl -> putlong; 
          low_bytes -> htonl -> putlong; 
       #);
  #);
CONSTANT_Double_info: cp_info
  (* Section 4.4.5 *)
  (# tag:: (# do CONSTANT_Double->value #);
     double: @real;
     use2longs: @boolean;
     l1, l2: @integer;
     moretrace::<
       (#
       do double -> screen.putreal;
       #);
     write:: 
       (# pl: @putlong
       do (if use2longs then
              l1 -> htonl -> pl;
              l2 -> htonl -> pl;
           else
              (if isBigEndian then
                  %getlongAt(@@double)   -> htonl -> pl; 
                  %getlongAt(@@double+4) -> htonl -> pl; 
               else
                  %getlongAt(@@double+4) -> htonl -> pl; 
                  %getlongAt(@@double)   -> htonl -> pl; 
              if);
          if);
       #);
  enter double
  #);
CONSTANT_NameAndType_info: cp_info
  (* Section 4.4.6 *)
  (# tag:: (# do CONSTANT_NameAndType->value #);
     name_index: @int16u;
     descriptor_index: @int16u;
     moretrace::<
       (#
       do name_index -> screen.putint;
          ',' -> screen.put;
          descriptor_index -> screen.putint;
       #);
     write:: 
       (#
       do name_index -> htons -> putShort;
          descriptor_index -> htons -> putShort;
       #);
  enter (name_index, descriptor_index)
  #);
CONSTANT_Utf8_info: cp_info
  (* Section 4.4.7 *)
  (# tag:: (# do CONSTANT_Utf8->value #);
     length: @int16u;
     bytes: [8]@int8u;
     moretrace::<
       (#
       do '"' -> screen.put;
          s[] -> screen.puttext;
          '"' -> screen.put;
       #);
     write:: 
       (# pb: @putBytes;
       do length -> htons -> putShort; 
          (@@bytes[1], length) -> pb;
       #);
     s: ^text; (* Should really be a unicode string *)
     encode:
       (# inc:
            (# 
            do length+1->length;
               (if length>bytes.range then
                   bytes.range->bytes.extend;
               if);
            #);
       enter s[]
       do 0->length;
          s.scanall
          (# 
          do (if true
              // (0x01<=ch) and (ch<=0x7f) then
                 inc;
                 ch -> bytes[length];
              // ch=0 then
                 inc;
                 2x11000000 -> bytes[length];
                 inc;
                 2x10000000 -> bytes[length];
              // (0x80<=ch) and (ch<=0x7ff) then
                 (* actually 0xff currently max in beta *)
                 inc;
                 2x11000000 %Bor ((ch %srl 6) %Band 2x11111)->bytes[length];
                 inc;
                 2x10000000 %Bor (ch %Band 2x111111)->bytes[length];
              // (0x07ff<=ch) and (ch<=0xffff)then
                 (* (currently not possible in beta) *)
                 inc;
                 2x11100000 %Bor ((ch %srl 12) %Band 2x1111)->bytes[length];
                 inc;
                 2x10000000 %Bor ((ch %srl 6) %Band 2x111111)->bytes[length];
                 inc;
                 2x10000000 %Bor (ch %Band 2x111111)->bytes[length];
              else
                 (* Should not happen - not even for unicode!! *)
                 'CONSTANT_Utf8_info.make_utf8: NYI for ch=\''
                   -> screen.puttext;
                 ch->screen.put;
                 '\' (' -> screen.puttext;
                 ch->screen.putint;
                 ')' -> screen.putline;
                 inc;
                 '?' -> bytes[length];
             if);
          #);
       #);
  enter encode
  #);

constant_pool_table: entry_table
  (# entrytype::cp_info; 
     numdoubleslots: @integer;
     usecount::
       (# 
       do (* Recalculate numdoubleslots in case user has not updated it correctly *)
          0 -> numdoubleslots;
          (for i:count repeat
               i+numdoubleslots -> entries[i].inx;
               (if (entries[i].tag=CONSTANT_Double) or (entries[i].tag=CONSTANT_Long) then
                   numdoubleslots+1->numdoubleslots;
               if);
          for);
          count+numdoubleslots+1->value
       #);
  #);

(* Section 4.5: Fields *)

field_info: entry
  (* Section 4.5 *)
  (# access_flags: @int16u;
     name_index: @int16u;
     descriptor_index: @int16u;
     attributes: @Attribute_table;
     write::
       (# ps: @putShort;
          t: ^text;
       do (if trace then
              '  Field(' -> t[];
              access_flags -> t.putint;
              ','->t.put;
              name_index->t.putint;
              ','->t.put;
              descriptor_index -> t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          access_flags     -> htons -> ps;
          name_index       -> htons -> ps;
          descriptor_index -> htons -> ps;
          attributes.write;
       #);
  enter (access_flags, name_index, descriptor_index)
  exit THIS(field_info)[]
  #);

field_table: entry_table(# entrytype::field_info #);


(* Section 4.6: Methods *)

method_info: entry
  (* Section 4.6 *)
  (# access_flags: @int16u;
     name_index: @int16u;
     descriptor_index: @int16u;
     attributes: @Attribute_table;
     write::
       (# ps: @putShort;
          t: ^text;
       do (if trace then
              '  Method(' -> t[];
              access_flags -> t.putint;
              ','->t.put;
              name_index->t.putint;
              ','->t.put;
              descriptor_index -> t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          access_flags     -> htons -> ps;
          name_index       -> htons -> ps;
          descriptor_index -> htons -> ps;
          attributes.write;
       #);
  enter (access_flags, name_index, descriptor_index)
  exit THIS(method_info)[]
  #);

method_table: entry_table(# entrytype::method_info #);

(* Section 4.7: Attributes *)

attribute_info: entry
  (* Section 4.7 *)
  (# attribute_name_index: @int16u;
     attribute_length:< integerValue;
     write::<
       (# t: ^text
       do (if trace then
              '  Attribute(' -> t[];
              attribute_name_index->t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          attribute_name_index -> htons -> putShort; 
          attribute_length     -> htonl -> putLong;
          INNER;
       #);
  enter attribute_name_index
  exit THIS(attribute_info)[]
  #);

Attribute_table: entry_table
  (# entrytype::Attribute_info;
     length: integerValue
       (# 
       do (for i:count repeat
               2+4+entries[i].attribute_length+value -> value;
          for);
       #);
  #);

ConstantValue_attribute: attribute_info
  (* Section 4.7.2 *)
  (# attribute_length:: (# do 2-> value #);
     constantvalue_index: @int16u;
     write:: (# do constantvalue_index -> htons -> PutShort;#);
  enter constantvalue_index
  #);
     
Code_attribute: attribute_info
  (* Section 4.7.3 *)
  (# 
     attribute_length:: 
       (# 
       do 2+2+4+code_length+2+exceptions.length+2+attributes.length 
            -> value
       #);
     max_stack: @int16u;
     max_locals: @int16u;
     code_length: @int32u;
     _code: [128]@int8u;
     exceptions: @Exception_table;
     attributes: @Attribute_table;
     putByte:
       (# b: @int8u;
       enter b
       do code_length+1->code_length;
          (if code_length>_code.range then
              _code.range->_code.extend;
          if);
          b -> _code[code_length]
       #);
     putShort:
       (# s: @int16u;
       enter s
       do code_length+2->code_length;
          (if code_length>_code.range then
              _code.range->_code.extend;
          if);
          s %srl 8     -> _code[code_length-1];
          s %Band 0xff -> _code[code_length];
       #);
     putlong:
       (# s: @int32u;
       enter s
       do code_length+4->code_length;
          (if code_length>_code.range then
              _code.range->_code.extend;
          if);
          (s %srl 24) %Band 0xff -> _code[code_length-3];
          (s %srl 16) %Band 0xff -> _code[code_length-2];
          (s %srl 8)  %Band 0xff -> _code[code_length-1];
          s %Band 0xff           -> _code[code_length];
       #);
     patchShort:
       (* Patch the short at _code[byteindex..byteindex+1]
        * with the sum of whats already there and s.
        *)
       (# byteindex, s: @int16u;
       enter (byteindex, s)
       do s + ((_code[byteindex] %sll 8) + _code[byteindex+1]) -> s;
          (s %srl 8)     -> _code[byteindex];
          (s %Band 0xff) -> _code[byteindex+1];
       #);
     write::
       (# pb: @THIS(BinFile).PutBytes;
          ps: @THIS(BinFile).PutShort;
          pl: @THIS(BinFile).PutLong;
       do max_stack -> htons -> ps;
          max_locals -> htons -> ps;
          code_length -> htonl -> pl;
          (@@_code[1], code_length) -> pb;
          exceptions.write;
          attributes.write;
       #);
  enter (max_stack, max_locals)
  #);

Exception_info: entry
  (* Section 4.7.3 - part of code attribute (exception handler def) *)
  (# start_pc: @int16u;
     end_pc: @int16u;
     handler_pc: @int16u;
     catch_type: @int16u;
     write::
       (# t: ^text;
       do (if trace then
              '  Exception(' -> t[];
              start_pc -> t.putint;
              ','->t.put;
              end_pc -> t.putint;
              ','->t.put;
              handler_pc -> t.putint;
              ','->t.put;
              catch_type -> t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          start_pc -> htons -> putShort;
          end_pc -> htons -> putShort;
          handler_pc -> htons -> putShort;
          catch_type -> htons -> putShort;
       #);
  enter (start_pc, end_pc, handler_pc, catch_type)
  #);

Exception_table: entry_table
  (* Section 4.7.3 - part of code attribute (exception handler def) *)
  (# entrytype::Exception_info;
     length: integerValue(# do count*8 -> value #);
  #);

Exception_index_info: entry
  (* Section 4.7.4 - method attribute (thrown exceptions) *)
  (# class_index: @int16u;
     write::
       (# 
       do class_index -> htons -> putShort;
       #);
  enter class_index
  #);

ExceptionIndexTable: entry_table
  (* Section 4.7.4 - method attribute (thrown exceptions) *)
  (# entrytype::Exception_index_info;
     length: integerValue(# do count*2 -> value #);
  #);

Exceptions_attribute: attribute_info
  (* Section 4.7.4 - method attribute (thrown exceptions)  *)
  (# attribute_length:: (# do 2+exception_index_table.length-> value #);
     exception_index_table: @ExceptionIndexTable; 
     write:: (# do exception_index_table.write #);
  #);

InnerClass_info: entry
  (* Section 4.7.5 *)
  (# inner_class_info_index: @int16u;
     outer_class_info_index: @int16u;
     inner_name_index: @int16u;
     inner_class_access_flags: @int16u;
     write::
       (# t: ^text;
       do (if trace then
              '  InnerClass(' -> t[];
              inner_class_info_index -> t.putint;
              ','->t.put;
              outer_class_info_index->t.putint;
              ','->t.put;
              inner_name_index -> t.putint;
              ','->t.put;
              inner_class_access_flags -> t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          inner_class_info_index -> htons -> putShort;
          outer_class_info_index -> htons -> putShort;
          inner_name_index -> htons -> putShort;
          inner_class_access_flags -> htons -> putShort;
       #);
  enter (inner_class_info_index, outer_class_info_index, inner_name_index, inner_class_access_flags)
  #);

InnerClass_table: entry_table
  (# entrytype::InnerClass_info;
     length: integerValue(# do count*8 -> value #);
  #);

InnerClass_attribute: attribute_info
  (* Section 4.7.5 *)
  (# attribute_length:: (# do 2+classes.length-> value #);
     classes: @InnerClass_Table; 
     write:: (# do classes.write; #);
  #);

Synthetic_attribute: attribute_info
  (* Section 4.7.6 *)
  (# #);

SourceFileValue_attribute: attribute_info
  (* Section 4.7.7 *)
  (# attribute_length:: (# do 2-> value #);
     sourcefile_index: @int16u;
     write:: (# do sourcefile_index -> htons -> PutShort;#);
  enter sourcefile_index
  #);

LineNumber_info: entry
  (* Section 4.7.8 *)
  (# start_pc: @int16u;
     line_number: @int16u;
     write::
       (# t: ^text;
       do (if trace then
              '  Linenumber(' -> t[];
              start_pc -> t.putint;
              ','->t.put;
              line_number->t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          start_pc -> htons -> putShort;
          line_number -> htons -> putShort;
       #);
  enter (start_pc, line_number)
  #);

LineNumber_table: entry_table
  (# entrytype::LineNumber_info;
     length: integerValue(# do 2+count*4 -> value #);
  #);

LineNumberTable_attribute: attribute_info
  (* Section 4.7.8 *)
  (# attribute_length:: (# do line_number_table.length-> value #);
     line_number_table: @LineNumber_Table; 
     write:: (# do line_number_table.write; #);
  #);

LocalVariable_info: entry
  (* Section 4.7.9 *)
  (# start_pc: @int16u;
     length: @int16u;
     name_index: @int16u;
     descriptor_index: @int16u;
     index: @int16u;
     write::
       (# t: ^text;
       do (if trace then
              '  LocalVariable(' -> t[];
              start_pc -> t.putint;
              ','->t.put;
              length -> t.putint;
              ','->t.put;
              name_index->t.putint;
              ','->t.put;
              descriptor_index->t.putint;
              ')' -> t.put;
              t[] -> tracePos;
          if);
          start_pc -> htons -> putShort;
          length -> htons -> putShort;
          name_index -> htons -> putShort;
          descriptor_index -> htons -> putShort;
          index -> htons -> putShort;
       #);
  enter (start_pc, length, name_index, descriptor_index, index)
  #);

LocalVariable_table: entry_table
  (# entrytype::LocalVariable_info;
     length: integerValue(# do 2+count*10 -> value #);
  #);

LocalVariableTable_attribute: attribute_info
  (* Section 4.7.9 *)
  (# attribute_length:: (# do local_variable_table.length-> value #);
     local_variable_table: @LocalVariable_Table; 
     write:: (# do local_variable_table.write; #);
  #);

Deprecated_attribute: attribute_info
  (* Section 4.7.10 *)
  (# #);

(* Generic patterns used above *)
entry:
  (# trace:< booleanValue;
     write:< object;
     inx: @integer;
  #);

entry_table:
  (# entrytype:< entry;
     entries: [8]^entrytype;
     count: @int16u;
     usecount:< integerValue(# do count->value; INNER #);
     add:
       (# e: ^entry;
       enter e[]
       do count+1 -> count;
          (if count>entries.range then
              entries.range->entries.extend;
          if);
          e[] -> entries[count][];
       #);
     write:
       (# 
       do usecount -> htons -> putShort;
          (for i:count repeat
               entries[i].write;
          for);
       #);
  #);
