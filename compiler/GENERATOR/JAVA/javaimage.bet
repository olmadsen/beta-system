ORIGIN 'classfile';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/basiclib/texthash';
--LIB: attributes--

JavaImage:
  (# cf: @ClassFile;
     
     traceClassFile: @boolean;
     traceClassFileName: @boolean;
     
     thisClassIndex, superClassIndex: @integer;
          
     init:<
       (# classfilename: ^text;
       enter classfilename[]
       do classfilename[] -> cf.name;
          constant_pool.init;
          fields.init;
       #);
     
     (* Handy shortcuts for often used operations *)
     emit:
       (# enter emitByte #);
     emitByte:
       (# enter currentmethod._code.putByte #);
     emitShort:
       (# enter currentmethod._code.putShort #);
     emitLong:
       (# enter currentmethod._code.putLong #);
     emitMethodRef:
       (# enter constant_pool.methodrefs.addtext -> emitShort #);
     emitFieldRef:
       (# enter constant_pool.fieldrefs.addtext -> emitShort #);
     emitClassRef:
       (# enter constant_pool.classes.addtext -> emitShort #);
     emitString:
       (# enter constant_pool.strings.addtext -> emit #);
     emitIntegerConstant:
       (# enter constant_pool.integers.add -> emit #);
     emitDoubleConstant:
       (# enter constant_pool.doubles.add -> emit #);
     emitFieldDef:
       (# enter fields.addtext #);
     emitComment:
       (# comment: ^text;
       enter comment[]
       do (if currentmethod._code[]<>NONE then
              ldc -> emit;
              'comment: ' -> (comment.copy).prepend -> emitString;
              pop -> emit;
           else
              'EmitComment: No method defined yet. Cannot emit comment:\n  comment: '
                -> screen.puttext;
              comment[] -> screen.putline;
          if);
       #);
     emitLineNumber:
       (# line: @integer;
       enter line
       do (if currentmethod._code[]<>NONE then
              (currentmethod.LIP, line) -> currentmethod.linenumber;
          if);
       #);
     
     emitToFile:
       (# e: @diskentry;
       do (if traceClassFile then
              '\nWriting ' -> screen.puttext;
              cf.name -> screen.putline;
           else
              (if traceClassFileName then
                  (*'\n'*)
                  ' [' -> screen.puttext;
                  cf.name -> e.path;
                  e.path.name -> screen.puttext;
                  ']' -> screen.puttext;
              if);
          if);
          cf.openWrite;
          (JAVA_MAGIC, JAVA_MINOR, JAVA_MAJOR, ACC_SUPER, thisClassIndex, superClassIndex) 
            -> cf.write(# trace::(# do traceClassFile->value #)#);
          cf.close;
       #);
     
     constant_pool: @
       (# 
          strings: @integerHashTable
            (# entrytype::CF_CONSTANT_String_info;
               addentry::(# do i->entry.string_index #);
               
            #);
          classes: @integerHashTable
            (# entrytype::CF_CONSTANT_Class_info;
               addentry::(# do i->entry.name_index #);
            #);
          refstype: integerPairHashTable
            (# entrytype::< cf.CONSTANT_ref_info;
               addentry::<(# do (i1,i2)->(entry.class_index, entry.name_and_type_index) #);
               addtext:
                 (# c, n, t: ^text; index1, index2: @integer;
                 enter (c[], n[] , t[])
                 do c[] -> classes.addtext -> index1;
                    (n[], t[]) -> name_types.addtext -> index2;
                    (index1, index2) -> add -> index1;
                 exit index1
                 #);
            #);
          methodrefs: @refstype
            (# entrytype::CF_CONSTANT_Methodref_info;
            #);
          fieldrefs: @refstype
            (# entrytype::CF_CONSTANT_Fieldref_info;
            #);
          doubles: @doubleHashTable
            (# entrytype::CF_CONSTANT_Double_info;
               addentry::(# do d->entry.double #)
            #);
          integers: @integerHashTable
            (# entrytype::CF_CONSTANT_Integer_info;
               addentry::(# do i->entry.bytes #)
            #);
          name_types: @integerPairHashTable
            (# entrytype::CF_CONSTANT_NameAndType_info;
               addentry::(# do (i1,i2)->(entry.name_index, entry.descriptor_index) #);
               addtext:
                 (# n, t: ^text; index1, index2: @integer;
                 enter (n[] , t[])
                 do n[] -> utf8strings.add -> index1; 
                    t[] -> utf8strings.add -> index2; 
                    (index1, index2) -> add -> index1;
                 exit index1
                 #);
            #);
          utf8strings: @texthashtable
            (# entrytype::CF_CONSTANT_Utf8_info;
               addentry::(# do t[]->entry.encode #)
            #);
          init:
            (# 
            do strings.init;
               classes.init;
               methodrefs.init;
               fieldrefs.init;
               doubles.init;
               name_types.init;
               utf8strings.init;
               integers.init;
            #);
       #);
     
     fields: @hashtable
       (* Similar to integerPairHashtable below, but not part of constant_pool *)
       (# info: ^CF_Field_info;
          init:
            (# 
            do (if info[]<>NONE then
                   info.write;
               if);
               &CF_Field_info[] -> info[];
            #);
          entrytype:< CF_Field_info;
          addentry:<
            (# entry: ^entrytype;
               index: @integer;
               i1, i2: @integer 
            enter (i1,i2)
            do &entrytype[] -> entry[];
               (i1, i2) -> (entry.name_index, entry.descriptor_index);
               INNER;
               entry[] -> cf.fields.add;
               cf.fields.count -> index;
            exit index
            #);
          element::
            (# i1, i2: @integer;
               index: @integer (* index in cf.fields *);
            #);
          hashFunction::< 
            (# do ((e.i1 + e.i2) mod range) ->value; #);
          equal::< 
            (# 
            do (left.i1=right.i1) and (left.i2=right.i2) -> value;
            #);
          add:
            (# i1, i2: @integer;
               E: ^element;
            enter (i1, i2)
            do &element[]->E[];
               (i1, i2) -> (E.i1, E.i2);
               E[]->hashfunction->findIndexed
               (# predicate::< 
                    (# 
                    do (i1=current.i1) and (i2=current.i2)->value;
                    #);
                  notFound::< 
                    (# 
                    do (i1,i2) -> addentry -> E.index;
                       E[]     -> insert;
                    #)
               do current[]->E[] (* Only when found *)
               #);
            exit E.index
            #);
          addText:
            (# fieldname, fieldtype: ^text;
               name_index, descriptor_index: @integer;
            enter (fieldname[], fieldtype[])
            do fieldname[] -> constant_pool.utf8strings.add -> name_index;
               fieldtype[] -> constant_pool.utf8strings.add -> descriptor_index;
               (name_index, descriptor_index) -> add; 
            #)
       #);
     
     currentmethod: @
       (# info: ^CF_Method_info;
          _code: ^CF_Code_attribute;
          line_numbers: ^CF_LineNumberTable_attribute;
          LIP: (# exit _code.code_length #);
          new: 
            (# access, maxstack, maxlocals: @integer;
               name, signature: ^text;
               name_index, descriptor_index, code_index: @integer;
            enter (access, name[], signature[], maxstack, maxlocals)
            do name[] -> constant_pool.utf8strings.add -> name_index;
               signature[] -> constant_pool.utf8strings.add -> descriptor_index;
               (access, name_index, descriptor_index) 
                 -> &CF_Method_info
                 -> info[]
                 -> cf.methods.add;
               'Code' -> constant_pool.utf8strings.add -> code_index;
               (code_index, maxstack, maxlocals)
                 -> &CF_Code_attribute 
                 -> _code[]
                 -> info.attributes.add;
               NONE -> line_numbers[];
            #);
          linenumber:
            (# pc, line: @integer;
               i: ^CF_LineNumber_info;
            enter (pc, line)
            do (if line_numbers[]=NONE then
                   'LineNumberTable' 
                     -> constant_pool.utf8strings.add
                     -> &CF_LineNumberTable_attribute
                     -> line_numbers[]
                     -> _code.attributes.add;
               if);
               &CF_LineNumber_info[] -> i[] -> line_numbers.line_number_table.add;
               (pc, line) -> i;
            #);
       enter new
       #);
     
     labs: @
       (#
          adr: [500] @integer;
          use: [500] ^loc;
          loc: (# off: @integer; next: ^loc #);
          clear:
            (# 
            do (for i:use.range repeat
                    NONE->use[i][]
               for);
            #);
          def: @
            (# l,patchAdr,patchInst: @integer; s: ^loc
            enter l
            do
               (if l > adr.range then
                   l+adr.range->adr.extend;
                   l+use.range->use.extend;
               if);
               currentmethod.LIP->adr[l];
               use[l][]->s[];
               none ->use[l][];
               LL:
                 (if s[] <> none then
                     (if false then
                         'patch short at ' -> screen.puttext;
                         s.off -> screen.putint;
                         ' with ' -> screen.puttext;
                         currentmethod.LIP+1-s.off -> screen.putint;
                     if);
                     
                     (s.off+1, currentmethod.LIP+1-s.off) 
                       -> currentmethod._code.patchShort;
                     s.next[]->s[];
                     restart LL
                 if)
            #);
          off: @
            (# l,of: @integer; s: ^loc; 
            enter l
            do
               (if l > adr.range then
                   l+adr.range->adr.extend; 
                   l+use.range->use.extend
               if);
               (if adr[l] = 0 then (* forward ref *)
                   &loc[]->s[];
                   currentmethod.LIP->s.off;
                   use[l][]->s.next[];
                   s[]->use[l][];
                   currentmethod.LIP-1->of; (* exits 0 *)
                else
                   adr[l]->of
               if)
            exit of-currentmethod.LIP+1
            #);
          
       #);
     
     SourceFile:
       (# file: ^text;
          index1, index2: @integer;
       enter file[]
       do 'SourceFile' 
            -> constant_pool.utf8strings.add 
            -> index1;
          file[] 
            -> constant_pool.utf8strings.add 
            -> index2;
          (index1, index2) 
            -> &CF_SourceFileValue_attribute
            -> cf.attributes.add;
       #);

     
     CP_HashTable: hashTable
       (# entrytype:< cf.entry;
          addentry:<
            (# entry: ^entrytype;
               index: @integer
            do &entrytype[] -> entry[];
               INNER;
               entry[] -> cf.constant_pool.add;
               cf.constant_pool.count -> index;
            exit index
            #);
       #);
     textHashTable: CP_hashTable
       (# element::
            (# t: ^text;
               index: @integer (* index in cf.constant_pool *);
            #);
          addentry::< (# t: ^text enter t[]  do INNER #);
          honeyM: @honeyMan;
          init::<
            (# 
            do honeyM.init;
            #);
          hashFunction::< 
            (# do e.t[]-> honeyM.hash ->value; #);
          equal::< 
            (# 
            do left.t[]->right.t.equal->value;
            #);
          add:
            (# T: ^text;
               E: ^element;
            enter T[]
            do &element[]->E[];
               T[]->E.T[];
               E[]->hashfunction->findIndexed
               (# predicate::< 
                    (# 
                    do (T[]->current.t.equal)->value;
                    #);
                  notFound::< 
                    (# 
                    do T[] -> addentry -> E.index;
                       E[] -> insert;
                    #)
               do current[]->E[] (* Only when found *)
               #);
            exit E.index
            #)
       #);
     
     integerHashTable: CP_hashTable
       (# addentry::< (# i: @integer enter i do INNER #);
          element::
            (# i: @integer;
               index: @integer (* index in cf.constant_pool *);
            #);
          hashFunction::< 
            (# do (e.i mod range) ->value; #);
          equal::< 
            (# 
            do left.i=right.i -> value;
            #);
          add:
            (# i: @integer;
               E: ^element;
            enter i
            do &element[]->E[];
               i->E.i;
               E[]->hashfunction->findIndexed
               (# predicate::< 
                    (# 
                    do i=current.i->value;
                    #);
                  notFound::< 
                    (# 
                    do i   -> addentry -> E.index;
                       E[] -> insert;
                    #)
               do current[]->E[] (* Only when found *)
               #);
            exit E.index
            #);
          addtext:
            (# s: ^text; index: @integer;
            enter s[] 
            do s[] -> constant_pool.utf8strings.add -> add -> index; 
            exit index
            #);
       #);
     
     integerPairHashTable: CP_hashTable
       (# addentry::< (# i1, i2: @integer enter (i1,i2) do INNER #);
          element::
            (# i1, i2: @integer;
               index: @integer (* index in cf.constant_pool *);
            #);
          hashFunction::< 
            (# do ((e.i1 + e.i2) mod range) ->value; #);
          equal::< 
            (# 
            do (left.i1=right.i1) and (left.i2=right.i2) -> value;
            #);
          add:
            (# i1, i2: @integer;
               E: ^element;
            enter (i1, i2)
            do &element[]->E[];
               (i1, i2) -> (E.i1, E.i2);
               E[]->hashfunction->findIndexed
               (# predicate::< 
                    (# 
                    do (i1=current.i1) and (i2=current.i2)->value;
                    #);
                  notFound::< 
                    (# 
                    do (i1,i2) -> addentry -> E.index;
                       E[]     -> insert;
                    #)
               do current[]->E[] (* Only when found *)
               #);
            exit E.index
            #)
       #);
     
     doubleHashTable: CP_hashTable
       (# addentry::< (# d: @real enter d do INNER #);
          element::
            (# d: @real;
               index: @integer (* index in cf.constant_pool *);
            #);
          hashFunction::< 
            (# do ((e.d -> value) mod range) ->value; #);
          equal::< 
            (# 
            do left.d=right.d -> value;
            #);
          add:
            (# d: @real;
               E: ^element;
            enter d
            do &element[]->E[];
               d->E.d;
               E[]->hashfunction->findIndexed
               (# predicate::< 
                    (# 
                    do d=current.d->value;
                    #);
                  notFound::< 
                    (# 
                    do d   -> addentry -> E.index;
                       E[] -> insert;
                    #)
               do current[]->E[] (* Only when found *)
               #);
            exit E.index
            #)
       #);
     
     (* Class file structs with tracing controlled by local variable traceClassFile *)
     CF_CONSTANT_Class_info: 
       cf.CONSTANT_Class_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_ref_info: 
       cf.CONSTANT_ref_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Fieldref_info: 
       cf.CONSTANT_Fieldref_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Methodref_info: 
       cf.CONSTANT_Methodref_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_InterfaceMethodref_info: 
       cf.CONSTANT_InterfaceMethodref_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_String_info: 
       cf.CONSTANT_String_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_U4_info: 
       cf.CONSTANT_U4_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Integer_info: 
       cf.CONSTANT_Integer_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Float_info: 
       cf.CONSTANT_Float_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Long_info: 
       cf.CONSTANT_Long_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Double_info: 
       cf.CONSTANT_Double_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_NameAndType_info: 
       cf.CONSTANT_NameAndType_info(# trace::(# do traceClassFile->value #)#);
     CF_CONSTANT_Utf8_info: 
       cf.CONSTANT_Utf8_info(# trace::(# do traceClassFile->value #)#);
     CF_field_info: 
       cf.field_info(# trace::(# do traceClassFile->value #)#);
     CF_method_info: 
       cf.method_info(# trace::(# do traceClassFile->value #)#);
     CF_attribute_info:
       cf.attribute_info(# trace::(# do traceClassFile->value #)#);
     CF_Exception_info: 
       cf.Exception_info(# trace::(# do traceClassFile->value #)#);
     CF_InnerClass_info: 
       cf.InnerClass_info(# trace::(# do traceClassFile->value #)#);
     CF_LineNumber_info: 
       cf.LineNumber_info(# trace::(# do traceClassFile->value #)#);
     CF_LocalVariable_info: 
       cf.LocalVariable_info(# trace::(# do traceClassFile->value #)#);
     
     
     CF_ConstantValue_attribute: 
       cf.ConstantValue_attribute(# trace::(# do traceClassFile->value #)#);
     CF_Code_attribute: 
       cf.Code_attribute(# trace::(# do traceClassFile->value #)#);
     CF_Exceptions_attribute: 
       cf.Exceptions_attribute(# trace::(# do traceClassFile->value #)#);
     CF_InnerClass_attribute: 
       cf.InnerClass_attribute(# trace::(# do traceClassFile->value #)#);
     CF_Synthetic_attribute: 
       cf.Synthetic_attribute(# trace::(# do traceClassFile->value #)#);
     CF_SourceFileValue_attribute: 
       cf.SourceFileValue_attribute(# trace::(# do traceClassFile->value #)#);
     CF_LineNumberTable_attribute: 
       cf.LineNumberTable_attribute(# trace::(# do traceClassFile->value #)#);
     CF_LocalVariableTable_attribute: 
       cf.LocalVariableTable_attribute(# trace::(# do traceClassFile->value #)#);
     CF_Deprecated_attribute: 
       cf.Deprecated_attribute(# trace::(# do traceClassFile->value #)#);
     
  #);


