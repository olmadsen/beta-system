ORIGIN '~beta/basiclib/betaenv';

-- LIB: attributes --


mach_header:
  (# magic: @int32u;
     cputype: @int32;
     cpusubtype: @int32;
     filetype: @int32u;
     ncmds: @int32u;
     sizeofcmds: @int32u;
     flags: @int32u;
  #);

mach_header_size: (# exit 28 #);
MH_MAGIC: (# exit 0xfeedface #);

(*
 * The layout of the file depends on the filetype.  For all but the MH_OBJECT
 * file type the segments are padded out and aligned on a segment alignment
 * boundary for efficient demand pageing.  The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,
 * MH_DYLINKER and MH_BUNDLE file types also have the headers included as part
 * of their first segment.
 * 
 * The file type MH_OBJECT is a compact format intended as output of the
 * assembler and input (and possibly output) of the link editor (the .o
 * format).  All sections are in one unnamed segment with no segment padding. 
 * This format is used as an executable format when the file is so small the
 * segment padding greatly increases its size.
 *
 * The file type MH_PRELOAD is an executable format intended for things that
 * are not executed under the kernel (proms, stand alones, kernels, etc).  The
 * format can be executed under the kernel but may demand paged it and not
 * preload it before execution.
 *
 * A core file is in MH_CORE format and can be any in an arbritray legal
 * Mach-O file.
 *
 * Constants for the filetype field of the mach_header
 *)

MH_OBJECT: 	(# exit 0x1 #);		(* relocatable object file *)
MH_EXECUTE: 	(# exit 0x2 #);		(* demand paged executable file *)
MH_FVMLIB: 	(# exit 0x3 #);		(* fixed VM shared library file *)
MH_CORE: 	(# exit 0x4 #);		(* core file *)
MH_PRELOAD: 	(# exit 0x5 #);		(* preloaded executable file *)
MH_DYLIB: 	(# exit 0x6 #);		(* dynamicly bound shared library file*)
MH_DYLINKER: 	(# exit 0x7 #);		(* dynamic link editor *)
MH_BUNDLE: 	(# exit 0x8 #);		(* dynamicly bound bundle file *)

(* Constants for the flags field of the mach_header *)
MH_NOUNDEFS: 	(# exit 0x1 #);		(* the object file has no undefined
					   references, can be executed *)
MH_INCRLINK: 	(# exit 0x2 #);		(* the object file is the output of an
					   incremental link against a base file
					   and can't be link edited again *)
MH_DYLDLINK: 	(# exit 0x4 #);		(* the object file is input for the
					   dynamic linker and can't be staticly
					   link edited again *)
MH_BINDATLOAD: 	(# exit 0x8 #);		(* the object file's undefined
					   references are bound by the dynamic
					   linker when loaded. *)
MH_PREBOUND: 	(# exit 0x10 #);	(* the file has its dynamic undefined
					   references prebound. *)
MH_SPLIT_SEGS: 	(# exit 0x20 #);	(* the file has its read-only and
					   read-write segments split *)
MH_LAZY_INIT: 	(# exit 0x40 #);	(* the shared library init routine is
					   to be run lazily via catching memory
					   faults to its writeable segments *)
MH_TWOLEVEL: 	(# exit 0x80 #);	(* the image is using two-level name
					   space bindings *)
MH_FORCE_FLAT: 	(# exit 0x100 #);	(* the executable is forcing all images
					   to use flat name space bindings *)
MH_NOMULTIDEFS: (# exit 0x200 #);	(* this umbrella guarantees no multiple
					   defintions of symbols in its
					   sub-images so the two-level namespace
					   hints can alwasys be used. *)
(*
 * The load commands directly follow the mach_header.  The total size of all
 * of the commands is given by the sizeofcmds field in the mach_header.  All
 * load commands must have as their first two fields cmd and cmdsize.  The cmd
 * field is filled in with a constant for that command type.  Each command type
 * has a structure specifically for it.  The cmdsize field is the size in bytes
 * of the particular load command structure plus anything that follows it that
 * is a part of the load command (i.e. section structures, strings, etc.).  To
 * advance to the next load command the cmdsize can be added to the offset or
 * pointer of the current load command.  The cmdsize MUST be a multiple of
 * sizeof(long) (this is forever the maximum alignment of any load commands).
 * The padded bytes must be zero.  All tables in the object file must also
 * follow these rules so the file can be memory mapped.  Otherwise the pointers
 * to these tables will not work well or at all on some machines.  With all
 * padding zeroed like objects will compare byte for byte.
 *)
 
load_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
  #);

(*
 * After MacOS X 10.1 when a new load command is added that is required to be
 * understood by the dynamic linker for the image to execute properly the
 * LC_REQ_DYLD bit will be or'ed into the load command constant.  If the dynamic
 * linker sees such a load command it it does not understand will issue a
 * "unknown load command required for execution" error and refuse to use the
 * image.  Other load commands without this bit that are not understood will
 * simply be ignored.
 *)


LC_REQ_DYLD: (# exit 0x80000000 #);

(* Constants for the cmd field of all load commands, the type *)
LC_SEGMENT: (# exit 0x1 #);	(* segment of this file to be mapped *)
LC_SYMTAB: (# exit 0x2 #);	(* link-edit stab symbol table info *)
LC_SYMSEG: (# exit 0x3 #);	(* link-edit gdb symbol table info (obsolete) *)
LC_THREAD: (# exit 0x4 #);	(* thread *)
LC_UNIXTHREAD: (# exit 0x5 #);	(* unix thread (includes a stack) *)
LC_LOADFVMLIB: (# exit 0x6 #);	(* load a specified fixed VM shared library *)
LC_IDFVMLIB: (# exit 0x7 #);	(* fixed VM shared library identification *)
LC_IDENT: (# exit 0x8 #);	(* object identification info (obsolete) *)
LC_FVMFILE: (# exit 0x9 #);	(* fixed VM file inclusion (internal use) *)
LC_PREPAGE: (# exit 0xa #);     (* prepage command (internal use) *)
LC_DYSYMTAB: (# exit 0xb #);	(* dynamic link-edit symbol table info *)
LC_LOAD_DYLIB: (# exit 0xc #);	(* load a dynamicly linked shared library *)
LC_ID_DYLIB: (# exit 0xd #);	(* dynamicly linked shared lib identification *)
LC_LOAD_DYLINKER: (# exit 0xe #);	(* load a dynamic linker *)
LC_ID_DYLINKER: (# exit 0xf #);	(* dynamic linker identification *)
LC_PREBOUND_DYLIB: (# exit 0x10 #);	(* modules prebound for a dynamicly *)
				(*  linked shared library *)
LC_ROUTINES: (# exit 0x11 #);	(* image routines *)
LC_SUB_FRAMEWORK: (# exit 0x12 #);	(* sub framework *)
LC_SUB_UMBRELLA: (# exit 0x13 #);	(* sub umbrella *)
LC_SUB_CLIENT: (# exit 0x14 #);	(* sub client *)
LC_SUB_LIBRARY: (# exit 0x15 #);	(* sub library *)
LC_TWOLEVEL_HINTS: (# exit 0x16 #);	(* two-level namespace lookup hints *)

 
(*
 * A variable length string in a load command is represented by an lc_str
 * union.  The strings are stored just after the load command structure and
 * the offset is from the start of the load command structure.  The size
 * of the string is reflected in the cmdsize field of the load command.
 * Once again any padded bytes to bring the cmdsize field to a multiple
 * of sizeof(long) must be zero.
 *)
 
 
(*
 * The segment load command indicates that a part of this file is to be
 * mapped into the task's address space.  The size of this segment in memory,
 * vmsize, maybe equal to or larger than the amount to map from this file,
 * filesize.  The file is mapped starting at fileoff to the beginning of
 * the segment in memory, vmaddr.  The rest of the memory of the segment,
 * if any, is allocated zero fill on demand.  The segment's maximum virtual
 * memory protection and initial virtual memory protection are specified
 * by the maxprot and initprot fields.  If the segment has sections then the
 * section structures directly follow the segment command and their size is
 * reflected in cmdsize.
 *)


segment_command_size: (# exit 56 #);

segment_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     segname1: @int32u;
     segname2: @int32u;
     segname3: @int32u;
     segname4: @int32u;
     vmaddr: @int32u;
     vmsize: @int32u;
     fileoff: @int32u;
     filesize: @int32u;
     maxprot: @int32;
     initprot: @int32;
     nsects: @int32u;
     flags: @int32u;
  #);

(* Constants for the flags field of the segment_command *)
SG_HIGHVM: 	(# exit 0x1 #);	(* the file contents for this segment is for
				   the high part of the VM space, the low part
				   is zero filled (for stacks in core files) *)
SG_FVMLIB: 	(# exit 0x2 #);	(* this segment is the VM that is allocated by
				   a fixed VM library, for overlap checking in
				   the link editor *)
SG_NORELOC: 	(# exit 0x4 #);	(* this segment has nothing that was relocated
				   in it and nothing relocated to it, that is
				   it maybe safely replaced without relocation*)


(*
 * A segment is made up of zero or more sections.  Non-MH_OBJECT files have
 * all of their segments with the proper sections in each, and padded to the
 * specified segment alignment when produced by the link editor.  The first
 * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header
 * and load commands of the object file before its first section.  The zero
 * fill sections are always last in their segment (in all formats).  This
 * allows the zeroed segment padding to be mapped into memory where zero fill
 * sections might be.
 *
 * The MH_OBJECT format has all of its sections in one segment for
 * compactness.  There is no padding to a specified segment boundary and the
 * mach_header and load commands are not part of the segment.
 *
 * Sections with the same section name, sectname, going into the same segment,
 * segname, are combined by the link editor.  The resulting section is aligned
 * to the maximum alignment of the combined sections and is the new section's
 * alignment.  The combined sections are aligned to their original alignment in
 * the combined section.  Any padded bytes to get the specified alignment are
 * zeroed.
 *
 * The format of the relocation entries referenced by the reloff and nreloc
 * fields of the section structure for mach object files is described in the
 * header file <reloc.h>.
 *)

section_size: (# exit 68 #);

section:
  (# sectname1: @int32u;
     sectname2: @int32u;
     sectname3: @int32u;
     sectname4: @int32u;
     segname1: @int32u;
     segname2: @int32u;
     segname3: @int32u;
     segname4: @int32u;
     address: @int32u;
     size: @int32u;
     offset: @int32u;
     align: @int32u;
     reloff: @int32u;
     nreloc: @int32u;
     flags: @int32u;
     reserved1: @int32u;
     reserved2: @int32u;
  #);

(*
 * The flags field of a section structure is separated into two parts a section
 * type and section attributes.  The section types are mutually exclusive (it
 * can only have one type) but the section attributes are not (it may have more
 * than one attribute).
 *)
SECTION_TYPE: 		(# exit 0x000000ff #);	(* 256 section types *)
SECTION_ATTRIBUTES: 	(# exit 0xffffff00 #);	(*  24 section attributes *)

(* Constants for the type of a section *)
S_REGULAR: 		(# exit 0x0 #);	(* regular section *)
S_ZEROFILL: 		(# exit 0x1 #);	(* zero fill on demand section *)
S_CSTRING_LITERALS: 	(# exit 0x2 #);	(* section with only literal C strings*)
S_4BYTE_LITERALS: 	(# exit 0x3 #);	(* section with only 4 byte literals *)
S_8BYTE_LITERALS: 	(# exit 0x4 #);	(* section with only 8 byte literals *)
S_LITERAL_POINTERS: 	(# exit 0x5 #);	(* section with only pointers to *)
					(*  literals *)
					
(*
 * For the two types of symbol pointers sections and the symbol stubs section
 * they have indirect symbol table entries.  For each of the entries in the
 * section the indirect symbol table entries, in corresponding order in the
 * indirect symbol table, start at the index stored in the reserved1 field
 * of the section structure.  Since the indirect symbol table entries
 * correspond to the entries in the section the number of indirect symbol table
 * entries is inferred from the size of the section divided by the size of the
 * entries in the section.  For symbol pointers sections the size of the entries
 * in the section is 4 bytes and for symbol stubs sections the byte size of the
 * stubs is stored in the reserved2 field of the section structure.
 *)
S_NON_LAZY_SYMBOL_POINTERS: (# exit 0x6 #);	(* section with only non-lazy
						   symbol pointers *)
S_LAZY_SYMBOL_POINTERS: (# exit 0x7 #);	(* section with only lazy symbol
						   pointers *)
S_SYMBOL_STUBS: (# exit 0x8 #);	(* section with only symbol
						   stubs, byte size of stub in
						   the reserved2 field *)
S_MOD_INIT_FUNC_POINTERS: (# exit 0x9 #);	(* section with only function
						   pointers for initialization*)
S_MOD_TERM_FUNC_POINTERS: (# exit 0xa #);	(* section with only function
						   pointers for termination *)
S_COALESCED: (# exit 0xb #);	(* section contains symbols that
						   are to be coalesced *)
(*
 * Constants for the section attributes part of the flags field of a section
 * structure.
 *)
SECTION_ATTRIBUTES_USR: (# exit 0xff000000 #);	(* User setable attributes *)
S_ATTR_PURE_INSTRUCTIONS: (# exit 0x80000000 #);	(* section contains only true
						   machine instructions *)
S_ATTR_NO_TOC: (# exit 0x40000000 #);	(* section contains coalesced
						   symbols that are not to be
						   in a ranlib table of
						   contents *)
SECTION_ATTRIBUTES_SYS: (# exit 0x00ffff00 #);	(* system setable attributes *)
S_ATTR_SOME_INSTRUCTIONS: (# exit 0x00000400 #);	(* section contains some
						   machine instructions *)
S_ATTR_EXT_RELOC: (# exit 0x00000200 #);	(* section has external
						   relocation entries *)
S_ATTR_LOC_RELOC: (# exit 0x00000100 #);	(* section has local
						   relocation entries *)


(*
 * The names of segments and sections in them are mostly meaningless to the
 * link-editor.  But there are few things to support traditional UNIX
 * executables that require the link-editor and assembler to use some names
 * agreed upon by convention.
 *
 * The initial protection of the "__TEXT" segment has write protection turned
 * off (not writeable).
 *
 * The link-editor will allocate common symbols at the end of the "__common"
 * section in the "__DATA" segment.  It will create the section and segment
 * if needed.
 *)


SEG_PAGEZERO: (# exit '__PAGEZERO' #);	(* the pagezero segment which has no *)
					(* protections and catches NULL *)
					(* references for MH_EXECUTE files *)


SEG_TEXT: 	(# exit '__TEXT' #);	(* the tradition UNIX text segment *)
SECT_TEXT: 	(# exit '__text' #);	(* the real text part of the text *)
					(* section no headers, and no padding *)
SECT_FVMLIB_INIT0: (# exit '__fvmlib_init0' #);	(* the fvmlib initialization *)
						(*  section *)
SECT_FVMLIB_INIT1: (# exit '__fvmlib_init1' #);	(* the section following the *)
					        (*  fvmlib initialization *)
						(*  section *)

SEG_DATA: 	(# exit '__DATA' #);	(* the tradition UNIX data segment *)
SECT_DATA: 	(# exit '__data' #);	(* the real initialized data section *)
					(* no padding, no bss overlap *)
SECT_BSS: 	(# exit '__bss' #);		(* the real uninitialized data section*)
					(* no padding *)
SECT_COMMON: 	(# exit '__common' #);	(* the section common symbols are *)
					(* allocated in by the link editor *)

SEG_OBJC: (# exit '__OBJC' #);	(* objective-C runtime segment *)
SECT_OBJC_SYMBOLS: (# exit '__symbol_table' #);	(* symbol table *)
SECT_OBJC_MODULES: (# exit '__module_info' #);	(* module information *)
SECT_OBJC_STRINGS: (# exit '__selector_strs' #);	(* string table *)
SECT_OBJC_REFS: (# exit '__selector_refs' #);	(* string table *)

SEG_ICON: 	(# exit '__ICON' #);	(* the icon segment *)
SECT_ICON_HEADER: (# exit '__header' #);	(* the icon headers *)
SECT_ICON_TIFF: (# exit '__tiff' #);	(* the icons in tiff format *)

SEG_LINKEDIT: (# exit '__LINKEDIT' #);	(* the segment containing all structs *)
					(* created and maintained by the link *)
					(* editor.  Created with -seglinkedit *)
					(* option to ld(1) for MH_EXECUTE and *)
					(* FVMLIB file types only *)

SEG_UNIXSTACK: (# exit '__UNIXSTACK' #);	(* the unix stack segment *)

(*
 * Fixed virtual memory shared libraries are identified by two things.  The
 * target pathname (the name of the library as found for execution), and the
 * minor version number.  The address of where the headers are loaded is in
 * header_addr.
 *)

fvmlib:
  (# name: @int32u;
     minor_version: @int32u;
     header_addr: @int32u;
  #);
  
(*
 * Fixed virtual memory shared libraries are identified by two things.  The
 * target pathname (the name of the library as found for execution), and the
 * minor version number.  The address of where the headers are loaded is in
 * header_addr.
 *)


fvmlib_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     name: @int32u;
     minor_version: @int32u;
     header_addr: @int32u;
  #);
  
  
  
(*
 * Dynamicly linked shared libraries are identified by two things.  The
 * pathname (the name of the library as found for execution), and the
 * compatibility version number.  The pathname must match and the compatibility
 * number in the user of the library must be greater than or equal to the
 * library being used.  The time stamp is used to record the time a library was
 * built and copied into user so it can be use to determined if the library used
 * at runtime is exactly the same as used to built the program.
 *)

dylib:
  (# name: @int32u;
     timestamp: @int32u;
     current_version: @int32u;
     compatibility_version: @int32u;
  #);
  

(*
 * A dynamicly linked shared library (filetype == MH_DYLIB in the mach header)
 * contains a dylib_command (cmd == LC_ID_DYLIB) to identify the library.
 * An object that uses a dynamicly linked shared library also contains a
 * dylib_command (cmd == LC_LOAD_DYLIB) for each library it uses.
 *)
 
dylib_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     name: @int32u;
     timestamp: @int32u;
     current_version: @int32u;
     compatibility_version: @int32u;
  #);
  
(*
 * A dynamically linked shared library may be a subframework of an umbrella
 * framework.  If so it will be linked with "-umbrella umbrella_name" where
 * Where "umbrella_name" is the name of the umbrella framework. A subframework
 * can only be linked against by its umbrella framework or other subframeworks
 * that are part of the same umbrella framework.  Otherwise the static link
 * editor produces an error and states to link against the umbrella framework.
 * The name of the umbrella framework for subframeworks is recorded in the
 * following structure.
 *)
sub_framework_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     umbrella: @int32u; (* lc_str name *)
  #);

(*
 * For dynamically linked shared libraries that are subframework of an umbrella
 * framework they can allow clients other than the umbrella framework or other
 * subframeworks in the same umbrella framework.  To do this the subframework
 * is built with "-allowable_client client_name" and an LC_SUB_CLIENT load
 * command is created for each -allowable_client flag.  The client_name is
 * usually a framework name.  It can also be a name used for bundles clients
 * where the bundle is built with "-client_name client_name".
 *)

sub_client_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     client: @int32u; (* lc_str name *)
  #);
  

(*
 * A dynamically linked shared library may be a sub_umbrella of an umbrella
 * framework.  If so it will be linked with "-sub_umbrella umbrella_name" where
 * Where "umbrella_name" is the name of the sub_umbrella framework.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * umbrella framework will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks to be implicited linked in.  Any other
 * dependent dynamic libraries will not be linked it when -twolevel_namespace
 * is in effect.  The primary library recorded by the static linker when
 * resolving a symbol in these libraries will be the umbrella framework.
 * Zero or more sub_umbrella frameworks may be use by an umbrella framework.
 * The name of a sub_umbrella framework is recorded in the following structure.
 *)

sub_umbrella_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     sub_umbrella: @int32u; (* lc_str name *)
  #);

(*
 * A dynamically linked shared library may be a sub_library of another shared
 * library.  If so it will be linked with "-sub_library library_name" where
 * Where "library_name" is the name of the sub_library shared library.  When
 * staticly linking when -twolevel_namespace is in effect a twolevel namespace 
 * shared library will only cause its subframeworks and those frameworks
 * listed as sub_umbrella frameworks and libraries listed as sub_libraries to
 * be implicited linked in.  Any other dependent dynamic libraries will not be
 * linked it when -twolevel_namespace is in effect.  The primary library
 * recorded by the static linker when resolving a symbol in these libraries
 * will be the umbrella framework (or dynamic library). Zero or more sub_library
 * shared libraries may be use by an umbrella framework or (or dynamic library).
 * The name of a sub_library framework is recorded in the following structure.
 * For example /usr/lib/libobjc_profile.A.dylib would be recorded as "libobjc".
 *)

sub_library_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     sub_library: @int32u; (* lc_str name *)
  #);

(*
 * A program (filetype == MH_EXECUTE) or bundle (filetype == MH_BUNDLE) that is
 * prebound to its dynamic libraries has one of these for each library that
 * the static linker used in prebinding.  It contains a bit vector for the
 * modules in the library.  The bits indicate which modules are bound (1) and
 * which are not (0) from the library.  The bit for module 0 is the low bit
 * of the first byte.  So the bit for the Nth module is:
 * (linked_modules[N/8] >> N%8) & 1
 *)

prebound_dylib_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     name: @int32u;
     nmodules: @int32u;
     linked_modules: @int32u; (* bit vector of linked modules *)
  #);

(*
 * A program that uses a dynamic linker contains a dylinker_command to identify
 * the name of the dynamic linker (LC_LOAD_DYLINKER).  And a dynamic linker
 * contains a dylinker_command to identify the dynamic linker (LC_ID_DYLINKER).
 * A file can have at most one of these.
 *)

dylinker_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     name: @int32u; (* lc_str name *)
  #);


(*
 * Thread commands contain machine-specific data structures suitable for
 * use in the thread state primitives.  The machine specific data structures
 * follow the struct thread_command as follows.
 * Each flavor of machine specific data structure is preceded by an unsigned
 * long constant for the flavor of that data structure, an unsigned long
 * that is the count of longs of the size of the state data structure and then
 * the state data structure follows.  This triple may be repeated for many
 * flavors.  The constants for the flavors, counts and state data structure
 * definitions are expected to be in the header file <machine/thread_status.h>.
 * These machine specific data structures sizes must be multiples of
 * sizeof(long).  The cmdsize reflects the total size of the thread_command
 * and all of the sizes of the constants for the flavors, counts and state
 * data structures.
 *
 * For executable objects that are unix processes there will be one
 * thread_command (cmd == LC_UNIXTHREAD) created for it by the link-editor.
 * This is the same as a LC_THREAD, except that a stack is automatically
 * created (based on the shell's limit for the stack size).  Command arguments
 * and environment variables are copied onto that stack.
 *)

thread_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
  #);

(*
 * The routines command contains the address of the dynamic shared library 
 * initialization routine and an index into the module table for the module
 * that defines the routine.  Before any modules are used from the library the
 * dynamic linker fully binds the module that defines the initialization routine
 * and then calls it.  This gets called before any module initialization
 * routines (used for C++ static constructors) in the library.
 *)

routines_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     init_addres: @int32u;
     init_module: @int32u;
     reserved1: @int32u;
     reserved2: @int32u;
     reserved3: @int32u;
     reserved4: @int32u;
     reserved5: @int32u;
     reserved6: @int32u;
  #);
 
 
(*
 * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD
 * "stab" style symbol table information as described in the header files
 * <nlist.h> and <stab.h>.
 *)

symtab_command_size: (# exit 24 #);
symtab_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     symoff: @int32u;
     nsyms: @int32u;
     stroff: @int32u;
     strsize: @int32u;
  #);

(*
 * This is the second set of the symbolic information which is used to support
 * the data structures for the dynamicly link editor.
 *
 * The original set of symbolic information in the symtab_command which contains
 * the symbol and string tables must also be present when this load command is
 * present.  When this load command is present the symbol table is organized
 * into three groups of symbols:
 *	local symbols (static and debugging symbols) - grouped by module
 *	defined external symbols - grouped by module (sorted by name if not lib)
 *	undefined external symbols (sorted by name if MH_BINDATLOAD is not set)
 * In this load command there are offsets and counts to each of the three groups
 * of symbols.
 *
 * This load command contains a the offsets and sizes of the following new
 * symbolic information tables:
 *	table of contents
 *	module table
 *	reference symbol table
 *	indirect symbol table
 * The first three tables above (the table of contents, module table and
 * reference symbol table) are only present if the file is a dynamicly linked
 * shared library.  For executable and object modules, which are files
 * containing only one module, the information that would be in these three
 * tables is determined as follows:
 * 	table of contents - the defined external symbols are sorted by name
 *	module table - the file contains only one module so everything in the
 *		       file is part of the module.
 *	reference symbol table - is the defined and undefined external symbols
 *
 * For dynamicly linked shared library files this load command also contains
 * offsets and sizes to the pool of relocation entries for all sections
 * separated into two groups:
 *	external relocation entries
 *	local relocation entries
 * For executable and object modules the relocation entries continue to hang
 * off the section structures.
 *)

dysymtab_command_size: (# exit 80  #);

dysymtab_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     
    (*
     * The symbols indicated by symoff and nsyms of the LC_SYMTAB load command
     * are grouped into the following three groups:
     *    local symbols (further grouped by the module they are from)
     *    defined external symbols (further grouped by the module they are from)
     *    undefined symbols
     *
     * The local symbols are used only for debugging.  The dynamic binding
     * process may have to use them to indicate to the debugger the local
     * symbols for a module that is being bound.
     *
     * The last two groups are used by the dynamic binding process to do the
     * binding (indirectly through the module table and the reference symbol
     * table when this is a dynamicly linked shared library file).
     *)
     ilocalsym: @int32u;
     nlocalsym: @int32u;
     iextdefsym: @int32u;
     nextdefsym: @int32u;
     iundefsym: @int32u;
     nundefsym: @int32u;
     
    (*
     * For the for the dynamic binding process to find which module a symbol
     * is defined in the table of contents is used (analogous to the ranlib
     * structure in an archive) which maps defined external symbols to modules
     * they are defined in.  This exists only in a dynamicly linked shared
     * library file.  For executable and object modules the defined external
     * symbols are sorted by name and is use as the table of contents.
     *)
     tocoff: @int32u;		(* file offset to table of contents *)
     ntoc: @int32u;		(* number of entries in table of contents *)

    (*
     * To support dynamic binding of "modules" (whole object files) the symbol
     * table must reflect the modules that the file was created from.  This is
     * done by having a module table that has indexes and counts into the merged
     * tables for each module.  The module structure that these two entries
     * refer to is described below.  This exists only in a dynamicly linked
     * shared library file.  For executable and object modules the file only
     * contains one module so everything in the file belongs to the module.
     *)
     modtaboff: @int32u;	(* file offset to module table *)
     nmodtab: @int32u;	(* number of module table entries *)

    (*
     * To support dynamic module binding the module structure for each module
     * indicates the external references (defined and undefined) each module
     * makes.  For each module there is an offset and a count into the
     * reference symbol table for the symbols that the module references.
     * This exists only in a dynamicly linked shared library file.  For
     * executable and object modules the defined external symbols and the
     * undefined external symbols indicates the external references.
     *)
     extrefsymoff: @int32u;  (* offset to referenced symbol table *)
     nextrefsyms: @int32u;	 (* number of referenced symbol table entries *)

    (*
     * The sections that contain "symbol pointers" and "routine stubs" have
     * indexes and (implied counts based on the size of the section and fixed
     * size of the entry) into the "indirect symbol" table for each pointer
     * and stub.  For every section of these two types the index into the
     * indirect symbol table is stored in the section header in the field
     * reserved1.  An indirect symbol table entry is simply a 32bit index into
     * the symbol table to the symbol that the pointer or stub is referring to.
     * The indirect symbol table is ordered to match the entries in the section.
     *)
     indirectsymoff: @int32u; (* file offset to the indirect symbol table *)
     nindirectsyms: @int32u;  (* number of indirect symbol table entries *)

    (*
     * To support relocating an individual module in a library file quickly the
     * external relocation entries for each module in the library need to be
     * accessed efficiently.  Since the relocation entries can't be accessed
     * through the section headers for a library file they are separated into
     * groups of local and external entries further grouped by module.  In this
     * case the presents of this load command who's extreloff, nextrel,
     * locreloff and nlocrel fields are non-zero indicates that the relocation
     * entries of non-merged sections are not referenced through the section
     * structures (and the reloff and nreloc fields in the section headers are
     * set to zero).
     *
     * Since the relocation entries are not accessed through the section headers
     * this requires the r_address field to be something other than a section
     * offset to identify the item to be relocated.  In this case r_address is
     * set to the offset from the vmaddr of the first LC_SEGMENT command.
     * For MH_SPLIT_SEGS images r_address is set to the the offset from the
     * vmaddr of the first read-write LC_SEGMENT command.
     *
     * The relocation entries are grouped by module and the module table
     * entries have indexes and counts into them for the group of external
     * relocation entries for that the module.
     *
     * For sections that are merged across modules there must not be any
     * remaining external relocation entries for them (for merged sections
     * remaining relocation entries must be local).
     *)
     extreloff: @int32u;	(* offset to external relocation entries *)
     nextrel: @int32u;	(* number of external relocation entries *)

    (*
     * All the local relocation entries are grouped together (they are not
     * grouped by their module since they are only used if the object is moved
     * from it staticly link edited address).
     *)
     locreloff: @int32u;	(* offset to local relocation entries *)
     nlocrel: @int32u;	(* number of local relocation entries *)
  #);
  
(*
 * An indirect symbol table entry is simply a 32bit index into the symbol table 
 * to the symbol that the pointer or stub is refering to.  Unless it is for a
 * non-lazy symbol pointer section for a defined symbol which strip(1) as 
 * removed.  In which case it has the value INDIRECT_SYMBOL_LOCAL.  If the
 * symbol was also absolute INDIRECT_SYMBOL_ABS is or'ed with that.
 *)
 

INDIRECT_SYMBOL_LOCAL: (# exit 0x80000000 #);
INDIRECT_SYMBOL_ABS: (# exit 0x40000000 #);

(* a table of contents entry *)

dylib_table_of_contents:
  (# symbol_index: @int32u;
     module_index: @int32u;
  #);
(* a module table entry *)
dylib_module:
  (# module_name: @int32u;

     iextdefsym: @int32u;
     nextdefsym: @int32u;
     irefsym: @int32u;
     nrefsym: @int32u;
     ilocalsym: @int32u;
     nlocalsym: @int32u;

     iextrel: @int32u;
     nextrel: @int32u;

     iinit_iterm: @int32u;
     ninit_nterm: @int32u;

     objc_module_info_addr: @int32u;
	  			
     objc_module_info_size: @int32u;
  #);

(* 
 * The entries in the reference symbol table are used when loading the module
 * (both by the static and dynamic link editors) and if the module is unloaded
 * or replaced.  Therefore all external symbols (defined and undefined) are
 * listed in the module's reference table.  The flags describe the type of
 * reference that is being made.  The constants for the flags are defined in
 * <mach-o/nlist.h> as they are also used for symbol table entries.
 *)
 
 
dylib_reference:
  (#  isym_flags: @int32u; (* isym: 24, flags:8 *)
  #);

(*
 * The twolevel_hints_command contains the offset and number of hints in the
 * two-level namespace lookup hints table.
 *)

twolevel_hints_command:
  (# cmd: @int32u;
     cmdsize: @int32u;
     offset: @int32u;
     nhints: @int32u;
  #);

(*
 * The entries in the two-level namespace lookup hints table are twolevel_hint
 * structs.  These provide hints to the dynamic link editor where to start
 * looking for an undefined symbol in a two-level namespace image.  The
 * isub_image field is an index into the sub-images (sub-frameworks and
 * sub-umbrellas list) that made up the two-level image that the undefined
 * symbol was found in when it was built by the static link editor.  If
 * isub-image is 0 the the symbol is expected to be defined in library and not
 * in the sub-images.  If isub-image is non-zero it is an index into the array
 * of sub-images for the umbrella with the first index in the sub-images being
 * 1. The array of sub-images is the ordered list of sub-images of the umbrella
 * that would be searched for a symbol that has the umbrella recorded as its
 * primary library.  The table of contents index is an index into the
 * library's table of contents.  This is used as the starting point of the
 * binary search or a directed linear search.
 *)

twolevel_hint:
  (# isub_image_itoc: @int32u; (* isub_image:8, itoc:24 *)
  #);


N_STAB: (# exit 0xE0 #);
N_PEXT: (# exit 0x10 #);
N_TYPE: (# exit 0x0E #);
N_EXT: (# exit 0x01 #);


N_UNDF: (# exit 0x0 #);
N_ABS: (# exit 0x2 #);
N_SECT: (# exit 0xe #);
N_PBUD: (# exit 0xc #);
N_INDR: (# exit 0xa #);

NO_SECT: (# exit 0 #);
MAX_SECT: (# exit 255 #);

(* Relocation info *)



reloc_size: (# exit 8 #);

R_PCREL: (# exit 0x80 #);

R_LONG: (# exit 0x40 #);
R_WORD: (# exit 0x20 #);

R_EXTERN: (# exit 0x10 #);


PPC_RELOC_VANILLA: (# exit 0 #);
PPC_RELOC_PAIR: (# exit 1 #);
PPC_RELOC_BR14: (# exit 2 #);
PPC_RELOC_BR24: (# exit 3 #);
PPC_RELOC_HI16: (# exit 4 #);
PPC_RELOC_LO16: (# exit 5 #);
PPC_RELOC_HA16: (# exit 6 #);
PPC_RELOC_LO14: (# exit 7 #);
PPC_RELOC_SECTDIFF: (# exit 8 #);
PPC_RELOC_PB_LA_PTR: (# exit 9 #);
PPC_RELOC_HI16_SECTDIFF: (# exit 10 #);
PPC_RELOC_LO16_SECTDIFF: (# exit 11 #);
PPC_RELOC_HA16_SECTDIFF: (# exit 12 #);
PPC_RELOC_JBSR: (# exit 13 #);

PR_SCATTERED: (# exit 0x80 #);
PR_LONG: (# exit 0x20 #);
PR_WORD: (# exit 0x10 #);
PR_PCREL: (# exit 0x40 #);
