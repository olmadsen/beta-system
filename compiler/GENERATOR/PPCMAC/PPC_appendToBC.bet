ORIGIN '../PPC/PPCmachine'
---MIPSappendToBC:descriptor---
(#  mips_disass: 
     (# instruction,op: @integer;
        T: @text;
        fi: (#exit 1#);
        fi2: (#exit 2 #);
        fr: (#exit 3 #);
        fj: (#exit 4#);
        frj1: (#exit 5#);
        fi3: (#exit 6#);
        frj2: (#exit 7#);
        fi4: (#exit 8#);
        fr1d: (#exit 9#);
        frdm: (#exit 10#);
        fRS: (#exit 11#);
        fRf :(#exit 12#);
        fIf: (#exit 13#);
        f: @integer;
     enter instruction
     do (*(instruction,true)->puthex; ' '->BC.put;*)
        (0,6)->instruction.%getBits -> op;
        (if op
         // 2 then 'j'->T; fJ->f
         // 4 then 'beq'->T; fi4->f;
         // 5 then 'bne'->T; fi4->f;
         // 8 then 'addi'->T; fi2->f
         // 9 then 'addiu'->T; fi2->f
         // 10 then 'slti'->T; fi2->f
         // 11 then 'sltiu'->T; fi2->f
         // 12 then 'andi'->T; fi2->f
         // 13 then 'ori'->T; fi2->f
         // 14 then 'xori'->T; fi2->f
         // 15 then 'lui'->T; fi3->f
         // 17 then 
            (26,6)->instruction.%getBits -> op;
            (if op
             // 0 then 'add.'->T;  fRf->f;
             // 1 then 'sub.'->T;  fRf->f;
             // 2 then 'mul.'->T;  fRf->f;
             // 3 then 'div.'->T;  fRf->f;
            if);
         // 32  then 'b'->T; fJ->f;
         // 35 then 'lw'->T; fI->f;
         // 36 then 'lbu'->T; fI->f;
         // 40 then 'sb'->T; fI->f;

         // 43 then 'sw'->T; fI->f;

         // 47 then 'ld'->T; fI->f;
         // 53 then 'ldc1'->T; fIf->f
         // 61 then 'sdc1'->T; fIf->f
         // 0 then
            (26,6)->instruction.%getBits -> op;
            (if op
             // 2 then 'srl'->T; fRS->f;
             // 3 then 'sra'->T; fRS->f;
             // 4 then 'sllv'->T; fR->f;
             // 6 then 'srlv'->T; fR->f;
             // 7 then 'srav'->T; fR->f;
             // 8 then 'jr'->T; frj1->f
             // 9 then 'jalr'->T; frj2->f
             // 16 then 'mfhi'->T; fr1d->f
             // 18 then 'mflo'->T; fr1d->f
             // 24 then 'mult'->T; frdm->f;
             // 26 then 'div'->T; frdm->f;
             // 32 then 'add'->T; fr->f
             // 34 then 'sub'->T; fr->f
             // 36 then 'and'->T; fr->f
             // 37 then 'or'->T; fr->f
             // 38 then 'xor'->T; fr->f
             // 39 then 'nor'->T; fr->f
             // 42 then 'slt'->T; fr->f
             // 43 then 'sltu'->T; fr->f
             // 48 then 'tge'->T; fRS->f;
             // 0 then 
                (if instruction = 0 then (*??*) 'nop'->T
                 else 'sll'->T; fRS->f
                if)
             else 'nop #.word\t'->T; (instruction,true,T[])->putHex
            if)
         else 'nop #.word\t'->T; (instruction,true,T[]) -> putHex
        if);
        '\t' ->T.put;
        (if f 
         // fi then
            ((11,5)->instruction.%getBits,T[]) -> putReg; ','->T.put;
            (16,16)->instruction.%getSignedBits -> T.putInt;
            '('->T.put;
            ((6,5)->instruction.%getBits,T[]) ->putReg; 
            ')'->T.put;
         // fi2 then
            ((11,5)->instruction.%getBits,T[]) -> putReg; ','->T.put;
            ((6,5)->instruction.%getBits,T[]) ->putReg; ','->T.put;
            (16,16)->instruction.%getSignedBits -> T.putInt;
         // fi3 then
            ((11,5)->instruction.%getBits,T[]) -> putReg; ','->T.put;
            (16,16)->instruction.%getSignedBits -> T.putInt;
         // fi4 then
            ((11,5)->instruction.%getBits,T[]) -> putReg; ','->T.put;
            ((6,5)->instruction.%getBits,T[]) ->putReg; ','->T.put;
            (16,16)->instruction.%getSignedBits -> op;
            op * 4 -> op;
            op + saveLIP * 4 -> op;
            (* !! -4 is NOT confirmed; probably something wrong with lab
             * calculations
             *)
            (op (*- 4*) )->FindLab -> op;
            '$L'->T.putText; op->T.putInt; 
         // fr then
            ((16,5)->instruction.%getBits,T[]) -> putReg; ','->T.put; 
            ((6,5)->instruction.%getBits,T[]) ->putReg; ','->T.put;
            ((11,5)->instruction.%getBits,T[]) -> putReg;
         // fj then
            ((6,26)->instruction.%getSignedBits,true,T[])->putHex
         // frj1 then
            ((6,5)->instruction.%getBits,T[]) ->putReg; 
         // frj2 then
            ((16,5)->instruction.%getBits,T[]) ->putReg;  ','->T.put;
            ((6,5)->instruction.%getBits,T[]) ->putReg; 
         // fr1d then
            ((16,5)->instruction.%getBits,T[]) ->putReg 
         // frdm then
            ((6,5)->instruction.%getBits,T[]) ->putReg;   ','->T.put;
            ((11,5)->instruction.%getBits,T[]) -> putReg;
         // fRS then
            ((11,5)->instruction.%getBits,T[]) -> putReg; ','->T.put;
            ((16,5)->instruction.%getBits,T[]) ->putReg;  ','->T.put;
            (21,5)->instruction.%getBits ->T.putInt
         // fIf then
            ((11,5)->instruction.%getBits,T[]) -> putFReg; ','->T.put;
            ((6,5)->instruction.%getBits,T[]) ->putReg;   '('->T.put;
            (16,16)->instruction.%getBits ->T.putint;  ')'->T.put;
         // fRf then
            ((6,5)->instruction.%getBits,T[])->putFmt;
            ((11,5)->instruction.%getBits,T[]) -> putFReg; ','->T.put;
            ((16,5)->instruction.%getBits,T[]) -> putFReg; ','->T.put;
            ((21,5)->instruction.%getBits,T[]) -> putFReg;
        if);
     exit T
     #);             
   FindLab:
     (# LIP,L: @integer
     enter LIP
     do (*'Find:'->puttext; LIP -> putInt; '.'->put;*)
        find:
          (for i: labs.adr.range repeat
               (if labs.adr[i] <> 0 then
                   (*labs.adr[i]->putInt; ','->put;*)
                   (if labs.adr[i] = LIP then
                       i  -> L;
                       leave find
          if)if)for)
     exit L
     #);
   Puthex: (* problmes with the one in machine for 0xFFC00000*)
     (# n: @integer;
        emit: @
          (# v: @integer;
             put: @
               (# c: @integer 
               enter c 
               do (if c < 10 then '0'+c->S.put else 'A'+c-10->S.put if)
               #)
          enter v
       do v div 16 -> put;
             v mod 16 -> put          
          #);
        zero: @
          (#
          do (if putLeadingZeros then '0'->S.put; '0'->S.put if)
          #);
        putLeadingZeros: @boolean; v: @integer;
        S: ^stream
     enter(n,putLeadingZeros,S[])
     do '0x'->S.putText;
        (if ((0->n.%getByte)->v) <> 0 then v-> Emit else zero if);    
        (* Above line tos_converted from: (if (@@n->TOS'%adrGetByte[0]'->v) <> 0 then v-> Emit else zero if); *)
        (if ((1->n.%getByte)->v) <> 0 then v-> Emit else zero if);    
        (* Above line tos_converted from: (if (@@n->TOS'%adrGetByte[1]'->v) <> 0 then v-> Emit else zero if); *)
        (if ((2->n.%getByte)->v) <> 0 then v-> Emit else zero if);
        (* Above line tos_converted from: (if (@@n->TOS'%adrGetByte[2]'->v) <> 0 then v-> Emit else zero if); *)
        (3->n.%getByte)->emit
        (* Above line tos_converted from: @@n->TOS'%adrGetByte[3]'->emit *)
     #);

   putReg:
     (# r: @integer; T: ^stream
     enter(r,T[])
     do 
        (if true 
            (*
         // (2 <= r) and (r <= 3) then 'v'->T.put; r-2 -> T.putint;
         // (4 <= r) and (r <= 7) then 'a'->T.put; r-4 -> T.putint;
         // (8 <= r) and (r <= 15) then 't'->T.put; r-8 -> T.putint;
         // (16 <= r) and (r <= 23) then 's'->T.put; r-16 -> T.putint;
         // (24 <= r) and (r <= 25) then 't'->T.put; r-24 -> T.putint;
         // (26 <= r) and (r <= 27) then 
            'k'->T.put; 't'->T.put;  r-26 -> T.putint;
             // (28 = r) then 'g'->T.put; 'p'->T.put
             *)
         // (29 = r) then '$'->T.put; 's'->T.put; 'p'->T.put
            (*
         // (30 = r) then 's'->T.put; '8'->T.put
             // (31 = r) then 'r'->T.put; 'a'->T.put
             *)
         else
            '$'->T.put; 
            r->T.putInt
        if)
     #);
   PutFReg:
     (# r: @integer; T: ^stream
     enter(r,T[])
     do '$'->T.put; 'f'->T.put; r->t.putInt;
     #);
   PutFmt:
     (# fmt: @integer; T: ^stream
     enter(fmt,T[])
     do (if fmt
         // 16 then 's'->T.put
         // 17 then 'd'->T.put
         // 20 then 'w'->T.put
         else '?'->T.put
        if)
     #);
   saveLIP: @integer;
   emitElm:
     (# i: @integer; T: @text
     enter i -> saveLIP
     do (if common.switch[39] then
            '\t.word\t'->BC.putT; (buffer[i],true,BC[])->putHex;
            '.word\t0x12345678'->Tab
         else
            buffer[i]->mips_disass->T; 
            '\t'->BC.putX; T[]->BC.putX;
            T[]->tab
        if)
     #);
   tab: @
     (*assume: T='op \toperands'*)
     (# T: ^text; ht,n: @integer
     enter T[]
     do 0->n;
        T.scanAll
        (#do n+1->n; 
           (if ch=ascii.ht then ht+1->ht;0->n if)
        #);
        (* i no. of chars after '\t' if one exists *)
           (*(for i: 1 - ht repeat ascii.ht->BC.putC for);*)
        n->emitSp
     #);
   emitSp:
     (# n: @integer
     enter n
     do (for i: 30-n repeat ' '->BC.putC for);
     #);
   emitReg:
     (# i,sc,in: @integer
     enter(i,sc)
     do buffer[i]->in;
        ((sc,5) -> in.%getBits,BC[]) -> putReg;
     #);
   emitFReg:
     (# i,sc,in: @integer
     enter(i,sc)
     do buffer[i]->in;
        (in %srl sc) %band 0x1F->in;
        '%'->BC.putC; 'f'->BC.putC; in->BC.putI;
        (if in<10 then ' '->BC.putC if)
     #);
   emitSym:
     (# inx,n: @integer
     enter inx
     do epElm[inx].m.strInx->strTbl.scan(#do ch->BC.putC; n+1->n #)
     exit n
     #);
   emitHiSym:
     (# inx,n: @integer
     enter inx
     do (*'hi('->BC.putX; inx ->emitSym->n; ')'->BC.putC*)
        '0'->BC.putC
     exit n
     #);
   emitLoSym:
     (# inx,n: @integer
     enter inx
     do (*'lo('->BC.putX; inx ->emitSym->n; ')'->BC.putC*)
        '0'->BC.putC
     exit n
     #);
   fromLastEntry,n,lapTop: @integer
do (if lastMark=0 then 1->lastMark if);
   1->lapTop;
   (for i:  LIP div 4 repeat
        (if inCode then
            (for lapTop: labs.adr.range  repeat
                 (if labs.adr[lapTop] > 0 then 
                     (if labs.adr[lapTop] = (i - 1) * 4 then
                         '$L'->BC.putX; lapTop->BC.putI; 
                         ':'->BC.put; '\n'->BC.put;
        if)if)for)if);
        L:
          (if marks[lastMark]=i then
              (* relocatable item *)
              (if types[lastMark]
               // callMark then 
                  '\tjal\t'->BC.putX; 
                  lastMark->emitSym->emitSp
               // bgtuMark then
                  '\tbgtu\t'->BC.putX; lastMark->emitSym->emitSp
               // jmpMark then                            
                  '\tj\t'->BC.putX; lastMark->emitSym->emitSp
               // setHiMark then
                  (* Note, due to limitations  the sgi assembler,
                   * 2 instructions (this one and a subsequent ori/setLoMark)
                   * may become more than 2 instructions
                   *)
                  '\tla\t'->BC.putX; (i,11)->emitReg;
                  ','->BC.putC; 
                  lastMark->emitSym->n;
                  n+4+2+3->emitSp; 
                  (*'\tlw\t'->BC.putX; (i,11)->emitReg;
                  ',0('->BC.putX;  (i,11)->emitReg; ')'->BC.putC;
                   n+4+2+3->emitSp;*)
               // setLoMark then
                  '\t#! Local adr. may not be valid!'->BC.putX;
                  (*'\tori\t'->BC.putX; 
                  (i,6)->emitReg; ','->BC.putC;
                  (i,11)->emitReg; ','->BC.putC;
                  lastMark->emitLoSym->n;
                   n+8+2+3->emitSp;*)
               // setLoMarkSt then
                  '\tsw\t'->BC.putX; 
                  (i,11)->emitReg; ','->BC.putC;
                  lastMark->emitLoSym->n;
                  '('->BC.putC;
                  (i,6)->emitReg;  
                  ')'->BC.putC; 
                  n+9+2+3+1->emitSp;
               // setLoMarkJmp then (*  NOT used for MIPS *)
                  '\tb\t'->BC.putX;
                  (dataTmp1,BC[])->putReg;
                  '+lo('->BC.putX; 
                  lastMark->emitSym->n;
                  ')'->BC.putX;
                  n+8+1->emitSp;
               // setLoMarkLdd then
                  '\tldd\t[%lo('->BC.putX; 
                  lastMark->emitSym->n;
                  ')+%g1],'->BC.putX;
                  (i,25)->emitFreg;
                  n+5+5+4-1->emitSp;
               // setLoMarkLd then
                  '\tlw\t[%lo('->BC.putX; 
                  lastMark->emitSym->n;
                  ')+%g1],'->BC.putX;
                  (i,25)->emitFreg;
                  n+5+5+4->emitSp;
               // wordMark then
                  '\t.word\t'->BC.putX; 
                  lastMark->emitSym->emitSp;
               // entryDefMark then
                  (if epElm[lastMark].export then
                      '\n.globl\t'->BC.putX; 
                      lastMark->emitSym; BC.putNl;
                  if);
                  lastMark->emitSym; ':'->BC.putC; BC.putNL;
                  (if (lastMark+1) <= marks.range then 
                      (if marks[lastMark+1]=i then 
                          (* several marks at same adr*)
                          lastMark+1->lastMark;
                          restart L
                  if)if);
                  0->fromLastEntry;
                  i->emitElm
              if);
              (if lastMark<marks.range then lastMark+1->lastMark
               else 0->marks[lastMark]
              if)
           else   
              i->emitElm
          if);
        '#'->BC.putC;  ' '->BC.putC;
        (fromLastEntry,false,BC[])->putHex; ' '->BC.putC; '('->BC.putC; 
        fromLastEntry->BC.putI;  ')'->BC.putC;
        fromLastEntry+4->fromLastEntry;
        ascii.ht->BC.putC; 
        ((i-1)*4,false,BC[])->putHex; ' '->BC.putC; '('->BC.putC;
        (i-1)*4->BC.putI; ')'->BC.putC;
        BC.putNl;
   for);
#)
---MIPSwriteAsmFile:descriptor ---
(* write assembly dump to file 'foo...s', 
 * and NOT to 'foo..s' in order NOT to confuse
 * dependency analysis
 *)
(# switch39: @boolean
do BC.name->FN[]; 
   '...s'->(FN.copy).append->BC.name;
   BC.openWrite;
   (*'#************** text segment ************\n'->BC.putX;*)
   '.text\n.set noreorder\n'->BC.putX;
   true->mstate.inCode;
   mstate.b.appendToBC;
   (*'\n#************** data segment ************\n' -> BC.putX;*)
   '.data\n'->BC.putX;
   '.align 8\n'->BC.putX;
   common.switch[39]->switch39; (* save current value *)
   0->mstate.d.emit; (* to ensure that BETA_data3 is printed *)
   true->common.switch[39]; (* emit .word, NOT asm-code *)
   false->mstate.inCode;
   mstate.d.appendToBC;
   switch39->common.switch[39];
   (*mstate.b.emitSymbols;*) (* includes d also *)
   BC.close;
   (* remove the extra '.' in 'foo...s' 
    * (FN.length-1,FN.length-1)->FN.delete;
    *)
   FN[]->BC.name; (* restore BC.name to 'somePath/foo' *)
#)
