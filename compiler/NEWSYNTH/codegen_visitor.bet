(*ORIGIN '~beta/betaast/betacfl';*)
ORIGIN '../SYNTHESIZER/synthesizerbody';
INCLUDE '~beta/betaast/betasematt';
INCLUDE '../GENERATOR/machine';
INCLUDE '../SYNTHESIZER/signature';
INCLUDE '../SYNTHESIZER/genlib_bytecode';
INCLUDE 'newgen';
include 'display_visitor';
(*---cfllevellib:attributes---*)
---thegenlib:attributes---
a2i:
  (# A: ^ast; I: @ASTindex
  enter A[]
  do A[] -> astAsAstIndex -> I
  exit I[]
  #);
IVisitor: betaCfl.treeLevelVisitor
  (# G: ^newgen
  enter G[]
  #); 
FormVisitor: Ivisitor
  (#  visit_descriptorForm::
       (#
       do 'Form:descriptorForm:'->putline;
          this(FormVisitor)[] -> (N.getObjectDescriptor).accept
       #);
     visit_attributesForm::
       (# A: ^beta.attributes;          
       do 'Form:attributesForm:'->putline;
          N.getAttributes -> A[];
          A.newScan
          (#
          do this(formVisitor)[] -> current.accept; (* attributedecl *)
          #)
       #);
     visit_objectDescriptor::
       (#
       do 'Form:objectDescriptor:'->putline;
          (G[],G.BCname[],N[],0) -> genClass
       #);
     visit_patternDecl::
       (# 
       do 'Form:pattern:'->putline;
          (G[],G.BCname[],N.getobjectDescriptor,0) -> genClass
       #);
     visit_doPart::
       (#
       do 'Form:dopart:'->putline
       #);
     visit_mainPart::
       (#
       do 'Form:mainpart:'->putline
       #)
  exit this(FormVisitor)[]
  #);
CodeGenVisitor: Ivisitor
  (# InnerDescs:[3] ^beta.ObjectDescriptor; top: @integer;
     scan:
       (# current: ^beta.objectDescriptor
       do (for i: top repeat
               InnerDescs[i][] -> current[];
               INNER scan
          for)
       #);
     visit_descriptorForm::
       (#
       do this(CodeGenVisitor)[] -> (N.getObjectDescriptor).accept
       #);
     visit_attributesForm::
       (# A: ^beta.attributes
       do N.getAttributes -> A[];
          A.newScan
          (#
          do this(CodeGenVisitor)[] -> current.accept
          #)
       #);
     visit_objectDescriptor::
       (# A: ^ast;
          P: ^beta.prefix;
          dn: ^descName
       do (if (top+1->top) > InnerDescs.range then 
                  InnerDescs.range -> InnerDescs.extend 
              if);
          N[] -> innerDescs[top][]
       #);
     visit_prefix::
       (# 
       do 'prefix:'->puttext
       #);
     visit_patternDecl::
       (# OD: ^beta.ObjectDescriptor;
          NS: ^beta.names
       do N.getNames -> NS[];
          N.getObjectDescriptor -> OD[];
          ns.newScan
          (# ND: ^NameDecl
          do current.getNameDecl->ND[];
             (G[],ND.getText,OD[],false) -> genPtnMethod;
          #);
          this(CodeGenVisitor)[] -> OD.accept
       #);
     visit_mainPart::
       (# A: ^beta.attributes;
          M: ^Beta.actionPart;
       do N.getAttributes -> A[];
          A.newScan
          (#
          do 
             this(CodeGenVisitor)[] -> current.accept
          #);
          N.getActionPart -> M[];
          this(CodeGenVisitor)[] -> M.accept
       #);
     visit_actionPart::
       (# A: ^ast; doP: ^beta.doPart;
       do N.getDoPartOpt -> A[]; 
          (if A## // optional## // unexpanded## then
           else
              A[] -> doP[];
              this(CodeGenVisitor)[] -> doP.accept
          if)
       #);
     visit_doPart::
       (# imps: ^beta.imperatives;
          sig: @signature;
          D: @ASTindex;
          innerName,methodName: ^text;
          subLevel: @integer; (* currently no value *)
          GD: @GenDo
       do 'dopart:'->puttext;
          ((N.father).father).father -> astAsAstIndex -> D;
          (D[],thisSuperChain,false) -> sig.setMethodDesc;
          sig.noEnter;
          sig.exitVoid;
          (common.doMethod,subLevel) 
            -> methodAndInnerName 
            -> (methodName[],innerName[]);
          methodName[] -> sig.addMethod;
          sig.asText -> putline;
          (0,innerName[],false,sig.asText,0) -> G.mch.initDo;

          true -> inEnterDoExitMethod;
          GD.restartLab.new; 
          GD.restartLab.def;                 
          N.getImperatives 
            -> astAsAstIndex
            -> GD.Scan;
          (* false -> inDoPartWithTmp*)
          false -> inEnterDoExitMethod;

          (false,0) -> G.mch.return;
          G.mch.endMethod
       #);
     
     visit_insertedItem::
       (# 
       do 'insertedItem:'->puttext;
          this(CodeGenVisitor)[] -> (N.getObjectDescriptor).accept;
       #);
     visit_assignmentEvaluation::
       (#
       do this(CodeGenVisitor)[] -> (N.getEvaluation).accept;
          this(CodeGenVisitor)[] -> (N.getTransaction).accept;
       #);
     visit_integerconst::
       (# C: ^const
       do 'integer:'->putline;
          N.getConst->C[];
          (C.getValue->G.mch.newCstOp,G.mch.dataTop[]) -> G.mch.ldCst;
       #);
  exit this(CodeGenVisitor)[]        
  #);

DescName: Ivisitor
  (# name: @text
       (# addSep: @boolean;
          extend:
            (# T: ^text
            enter T[]               
            do (if addSep then '$' -> put if);
               T[] -> append;
               true -> addSep
            #)
       #);
     visit_descriptorForm::
       (#
       do 'form' -> name.extend
       #);
     visit_attributesform::
       (#
       do G.common.betaPackage -> name.append
       #);
     visit_objectDescriptor::
       (#
       do this(DescName)[] -> (N.father).accept
       #);
     visit_mainPart::
       (#
       do this(DescName)[] -> (N.father).accept
       #);
     visit_patternDecl::
       (# names: ^beta.names;
          ND: ^beta.nameDcl;
          NDX: ^nameDecl;
          T: ^text
       do N.getNames -> names[];
          this(DescName)[] -> ((N.father).father).accept;
          names.newscan
          (#
          do current[] -> ND[];
             ND.getNameDecl -> NDX[];
             NDX.gettext -> name.extend
          #)
       #);
     visit_insertedItem::
       (# A: ^ast;
          OD: ^beta.objectDescriptor
       do N.getObjectDescriptor -> A[];
          (if A## <> unExpanded## then
              A[] -> OD[];
              'singular_' -> name.extend;
              OD.descNo -> name.putint
          if)
       #);
  exit this(descName)[]
  #);

GenClass:
  (# G: ^newgen;
     path: ^text;
     desc: ^beta.objectDescriptor;
     blockLevel: @integer;
  enter(G[],path[],desc[],blockLevel)
  <<SLOT new_genClass:doPart>>
  #);
GenPtnMethod:
  (# G: ^newgen;
     methodName: ^text;
     desc: ^beta.objectDescriptor;
     isStatic: @boolean
  enter(G[],methodName[],desc[],isStatic)
  <<SLOT new_GenPtnMethod:doPart>>
  #);
isJava: (# exit true #); (* perhaps isJava in com.bet *)

---new_genClass:doPart---
do (# className: @descName;
      superDesc,supername,orgName: ^text;
      subLevel: @integer;
      CG: @CodeGenVisitor;
   do (if isJava then
          (* open file *)
      if);
      '\nGenClass: '->puttext;
      desc[] -> astAsAstIndex -> thisDesc;
      '***'->putline;
      G[] -> className;
      className[] -> (desc.father).accept;
      className.name[] -> putline;
      
      'LBetaObject;'->orgName[];
      (if  G[] = none then 'G none' -> putline if);
      (if  G.mch[] = none then 'G.mch none' -> putline if);
      ((*theDesc.nodeId div 2, - we reuse a field - BAD *)
      blockLevel,className.name[],false
      ,'LBetaObject;' (*((superDesc[],superName[])->SuperSignature).asText*)
      ,subLevel,orgName[])
        -> G.mch.initGen;
      
      G[] -> CG -> (desc.getMainPart).accept;
      'end'->putline;
      G.mch.endClass;
      (if isJava then
          G.mch.close
      if);
      CG.scan
      (#
      do (G[],G.BCname[],current[],1) -> genClass
      #)
   #)
---new_GenPtnMethod:doPart---
do (# sig: @signature;
      nScan,xScan: @sematt.nxScanner;
      hasNcode,hasDoCode,hasXcode: @boolean;
      exitId: @integer;
      exitVal: ^ASTindex
   do desc[] -> astAsAstIndex -> thisDesc;
      true -> hasDoCode;
      (desc[]->a2i,true,thisSuperChain) -> nScan;
      nScan.length > 0 -> hasNcode;
      (desc[]->a2i,false,thisSuperChain) -> xScan;
      xScan.length > 0 -> hasXcode;
      
      (desc[]->a2i,thisSuperChain,false) -> sig.setMethodDesc;

      (if isStatic then sig.markStatic if);
      desc[]->a2i -> sig.addEnter;
      exitP[] -> sig.addExit;
      methodName[] -> sig.addMethod;
      
      sig.exitId -> exitId;
      sig.exitVal[] -> exitVal[];
      
      sig.exitVal[] <> none -> hasXcode; (* note we override hasXcode
                                          * above; exitP is only for
                                          * the mainpart; possible exitlist
                                          * in superpatterns are not
                                          * handled
                                          *)

      (0,methodName[],true,sig.asText,sig.noOfEnterArgs) -> G.mch.initDo;

      (false,exitId) -> G.mch.return;
      G.mch.endMethod
   #)
   
