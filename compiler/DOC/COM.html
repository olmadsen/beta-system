<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
   <META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
   <LINK REL="stylesheet" HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE="text/css">
   <TITLE>Design of BETA COM Implementation</TITLE>
</HEAD>
<BODY>

<H1><A NAME="design"></A>Design of BETA COM Implementation</H1>

<P>This note describes design, implementation and status for support of
the Microsoft COM model in BETA. Section 1 gives a short introduction to
COM. Section 2 describes the current design for COM support in BETA. Section
3 describes the compiler implementation. Section 4 describes design of
run-time elements. Section 5 is a list of open issues. </P>

<P>Since this note describes work in progress, parts of it may be incomplete.
</P>

<H1>Contents</H1>

  <UL>
  <LI><A HREF="#model">1. Microsoft COM object model</A></LI>
    <UL>
    <LI><A HREF="#layout">1.1 Object layout</A></LI>
    <LI><A HREF="#call">1.2 Call</A></LI>
    <LI><A HREF="#interfaces">1.3 Interfaces</A></LI>
    <LI><A HREF="#uuid">1.4 Unique interface ID</A></LI>
    <LI><A HREF="#refcount">1.5 Reference counting</A></LI>
    <LI><A HREF="#predefined">1.6 Predefined virtual functions</A></LI>
    <LI><A HREF="#odl">1.7 ODL</A></LI>
    <LI><A HREF="#tlb">1.7 Type libraries</A></LI>
    </UL>
  <LI><A HREF="#betacom">2. COM support in BETA</A></LI>
    <UL>
    <LI><A HREF="#BasicCOM">2.1 Basic COM</A></LI>
      <UL>
      <LI><A HREF="#ImportingBasicCOM">2.1.1 Importing basicCOM Objects to BETA</A></LI>
      <LI><A HREF="#ImplementingBasicCom">2.1.2 Implementing basic COM objects in BETA</A></LI>
      <LI><A HREF="#ParametersToBasicCOM">2.1.3 Parameters to basic COM objects</A></LI>
      </UL>
    <LI><A HREF="#BasicCOMwithIUnknown">2.2 Basic COM with IUnknown</A></LI>
    <LI><A HREF="#Full COM">2.3 Full COM</A></LI>
    <LI><A HREF="#ComWithSeveralInterfaces">2.4 Implementing COM objects with Several Interfaces in BETA</A></LI>
    <LI><A HREF="#RulesForUsingCOM">2.5 Rules for Using COM Objects in BETA</A></LI>
      <UL>
      <LI><A HREF="#PatternCOM">The predefined Pattern COM</A></LI>
      <LI><A HREF="#Patterns_IID_IUnknown">Patterns IID and IUnknown</A></LI>
      <LI><A HREF="#Out_inout">Out- and inout parameters</A></LI>
      <LI><A HREF="#holder_objects">Compiler Support for Holder objects</A></LI>
      <LI><A HREF="#dynref">Dynamic Reference declaration</A></LI>
      <LI><A HREF="#COM_Holder_Allocation">COM/Holder Allocation</A></LI>
      <LI><A HREF="#staticref">Static Reference Declaration</A></LI>
      <LI><A HREF="#pattern_data">Data objects reconsidered</A></LI>
      <LI><A HREF="#doparts">COM Object Do Parts</A></LI>
      <LI><A HREF="#enter_exit">COM Object Enter- and Exit Parts</A></LI>
      <LI><A HREF="#com_virtual_call">Call of attribute functions</A></LI>
      <LI><A HREF="#com_ref_params">COM reference parameters</A></LI>
      <LI><A HREF="#qua">Qua-check and other security issues</A></LI>
      </UL>
    <LI><A HREF="#idl_tlb">2.6 IDL/ODL and Type Libraries</A></LI>
      <UL>
      <LI><A HREF="#idl_odl">IDL/ODL</A></LI>
      <LI><A HREF="#type_libraries">Type libraries</A></LI>
      </UL>
    </UL>
  <LI><A HREF="#implementation">3. Implementation</A></LI>
    <UL>
    <LI><A HREF="#object_layout">3.1 COM Object Layout</A></LI>
    <LI><A HREF="#checking">3.2 Changes to Semantic Checking</A></LI>
    <LI><A HREF="#coding">3.3 Changes to code generation</A></LI>
        <UL>
        <LI><A HREF="#com_object_generation">Generation of COM object</A></LI>
        <LI><A HREF="#com_virtual_call">Call of a COM virtual function</A></LI>
        <LI><A HREF="#compiler_status">Code generation status</A></LI>
        </UL>
    </UL>
  <LI><A HREF="#rts">4. Run-Time System Issues</A></LI>
    <UL>
    <LI><A HREF="#AlloCOM">4.1 Allocation of COM objects</A></LI>
    <LI><A HREF="#ChkRA">4.2 ChkRA</A></LI>
    <LI><A HREF="#Part_object_off-lining">4.3 Part object off-lining</A></LI>
    <LI><A HREF="#COM_GC">4.4 garbage collection</A></LI>
    </UL>
  <LI><A HREF="#todo">5. Open Issues</A></LI>
  </UL>

<!-- end of TOC -->

<H1><A NAME="model">1. Microsoft COM object model</A></H1>

<P>COM is a binary object model that defines the memory layout of objects
and the calling sequence for dispatch of virtual functions. </P>

<P>COM is a mechanism for exchanging objects at run-time and for reusing
objects developed by others. COM is language independent in the sense that
COM objects may be developed in any programming language that supports
the COM model. COM is, of course, a minimal common subset. </P>

<P>COM may be used for supporting distributed objects. The actual object
accessed via a COM interface may be located at another location. The distribution
support for COM is called DCOM </P>

<P>COM is the basis for MS OLE/ActiveX, which are class libraries available
for building applications. Win 95 supplies a number of such class libraries.
3rd party, users, etc. may define their own OLE/ActiveX class libraries.
</P>

<H2><A NAME="layout">1.1 Object layout</A></H2>

<PRE CLASS=beta>

Reference     Object                   VDT

             ---------               ---------
 R: ^T ----&gt; |       | ---------&gt;    |       | ----&gt; f1
             ---------               |-------|
                                     |       | ----&gt; f2
                                     |-------|
                                     |       | ----&gt; f3
                                     |-------|
                                     | ...   |
                                     ---------
</PRE>

<H2><A NAME="call">1.2 Call</A></H2>

<PRE CLASS=beta>
(e1,e2,e3) -&gt; R.f2 -&gt; V
</PRE>

<H2><A NAME="interfaces">1.3 Interfaces</A></H2>

<P>An object may have several interfaces: </P>

<PRE CLASS=beta>
      A
  ---------
  |       |
B |   X   | C
  |       |
  ---------
</PRE>

<P>The object X has 3 interfaces A, B, and C. An interface is &quot;just&quot;
a COM object. </P>

<P>An interface is an object with a dispatch table: </P>

<PRE CLASS=beta>
eference     Object                   VDT

            ---------       ---------
R: ^A ----&gt; |       | ----&gt; |       | ----&gt; f1
            ---------       |-------|
            |       |       |       | ----&gt; f2
            ---------       |-------|
                ^           |       | ----&gt; f3
                |           |-------|
                |           | ...   |
                |           ---------
                |
                |-----------------------------------------&gt; ---------
                                                            |       |
            ---------       ---------                       |       |
S: ^B ----&gt; |       | ----&gt; |       | ----&gt; g1              |       |
            ---------       |-------|                       |   X   |
            |       |       |       | ----&gt; g2              |       |
            ---------       |-------|                       |       |
                |           |       | ----&gt; g3              ---------
                |           |-------|                       ^       ^
                |           | ...   |                       |       |
                |           ---------                       |       |
                |                                           |       |
                |--------------------------------------------       |
                                                                    |
            ---------       ---------                               |
T: ^C ----&gt; |       | ----&gt; |       | ----&gt; h1                      |
            ---------       |-------|                               |
            |       |       |       | ----&gt; h2                      |
            ---------       |-------|                               |
                |           |       | ----&gt; h3                      |
                |           |-------|                               |
                |           | ...   |                               |
                |           ---------                               |
                |                                                   |
                |----------------------------------------------------
</PRE>

<H2><A NAME="uuid">1.4 Unique interface ID</A></H2>

<P>All interfaces are assigned a unique id in the form of a 128 bit key.
If an interface is changed, it will be assigned a new id. </P>

<H2><A NAME="refcount">1.5 Reference counting</A></H2>

<P>Memory management of COM objects is based on reference counting. It
is the user of a COM interface who is responsible for maintaining the reference
count, by using predefined virtual functions (see below) </P>

<H2><A NAME="predefined">1.6 Predefined virtual functions</A></H2>

<P>All COM objects must support the following 3 predefined virtual functions:
</P>

<PRE CLASS=beta>
QueryInterface  Query interface and return IF it it exists
                It is possible to ask an object if it supports a
                given interface, and if so this interface is returned.

AddRef
Release
</PRE>

<P>Reference counting must be done in the following way: </P>

<PRE CLASS=beta>
Reference assignment:

     S[] -&gt; R[];     

         (if R[] &lt;&gt; NONE then R.Release if);
         execute: S[] -&gt; R[]
         (if R[] &lt;&gt; NONE then R.AddRef if);

None assignment

     NONE -&gt; S[];

          (if S[] &lt;&gt; NONE then S.Release if); 
          execute: NONE -&gt; S[];
</PRE>

<H2><A NAME="odl">1.7 ODL</A></H2>

<P>ODL is an IDL inspired language for describing COM interfaces </P>

<H2><A NAME="tlb">1.8 Type libraries</A></H2>

<P>Type libraries are a binary representation of COM interfaces. </P>

<H1><A NAME="betacom">2. COM support in BETA</A></H1>

<P>In this section design of COM support for BETA is described. Real working
examples may be found in the cvs project 'beta_project/compiler/TST' - 
hereafter simply named <CODE>TST</CODE>.
</P>

<P>At a first glance COM appears to be a simple model, but in order to
implement full support for Microsoft COM there are a lot of nasty details,
especially with respect to parameters. In this document we thus describe
COM support in BETA at the following three levels:</P>

<UL>
<LI>Basic COM</LI>

<LI>Basic COM with IUnknown</LI>

<LI>Full COM</LI>
</UL>

<H2><A NAME="BasicCOM">2.1 Basic COM</A></H2>

<P>At this level the only changes to BETA and its implementation is support
for the COM object-layout and parameters in the form of basic patterns
(integer, char, boolean, real) and references to COM objects.</P>

<P>The compiler assumes the existence of a predefined pattern COM:</P>

<PRE CLASS=beta>
COM: (# #);
</PRE>

<P>A class pattern may be declared as a subpattern of COM:</P>

<PRE CLASS=beta>myClass: COM
(# foo1:&lt; (# ... #);
   foo2:&lt; (# ... #);
   ...
   foon:&lt; (# ... #)
#)
</PRE>

<P>If we have a reference to myClass</P>

<PRE CLASS=beta>
R: ^myClass
</PRE>

<P>then R may be used as a normal object reference, i.e. it is possible
to invoke a virtual pattern in R:</P>

<PRE CLASS=beta>
R.foo1
</PRE>

<P>One difference between a COM object an an ordinary object is that the
first field in a COM object points to the virtual dispatch table in the
prototype and not as for normal objects directly to the prototype. This
is further described in the section on implementation.</P>

<P>Another important differnce is that the virtual patterns declared inside
a subpattern of COM cannot be used as general patterns. They can only be
used as procedure pattern invocations. Thye can e.g. NOT be used as class
patterns. The reason is that the code generated for COM virtuals is following
the calling conventions for virtual COM functions.</P>

<H3><A NAME="ImportingBasicCOM">2.1.1 Importing basicCOM Objects to BETA</A></H3>

<P>The above specification of myClass may have the form of an interface,
i.e. only the parameters of virtual functions are described:</P>

<PRE CLASS=beta>myClass: COM
(# foo1:&lt; (# #);
   foo2:&lt; (# a,b,c: @integer enter(a,b,c) exit c #);
   foo3:&lt; (# R: ^myClass; r: @real enter R[] exit R #)
#)
</PRE>

<P>By means of an external function, it is then possible to obtain a reference
to COM object:</P>

<PRE CLASS=beta>getObject: external(# R: ^myClass exit R[] #)</PRE>

With declarations:

<PRE CLASS=beta>myObj: ^myClass; V: @integer; r: @real</PRE>

<P>An instance of myClass may be imported from an external language like
C by calling a function like getObject: </P>

<PRE CLASS=beta>getObject -&gt; myObj[];
myObj.foo1;
(e1,e2,e3) -&gt; myObj.foo2 -&gt; V;
</PRE>

<PRE CLASS=beta>myObj[] -&gt; myObj.foo3 -&gt; r;</PRE>

<P>NOTE: there is no security regarding a COM object imported from an external
language. It is completely up to the external language to make sure that
the imported reference is in fact a reference to a COM object. Using COM
is thus an insecure way of programming.</P>

<P>An example of importing a COM object from C may be found in the TST
examples: </P>

<PRE CLASS=beta>
CaccountUser.bet Caccount.c
</PRE>

<H3><A NAME="ImplementingBasicCom">2.1.2 Implementing basic COM objects in BETA</A></H3>

<P>A subpattern of COM may be used to implement COM objects in BETA. Consider
the following pattern:</P>

<PRE CLASS=beta>
myCOMClass: COM
   (# foo1:&lt; 
        (# do ... #);
      foo2:&lt; 
        (# a,b,c: @integer enter(a,b,c) do ... exit c #);
      foo3:&lt; 
        (# R: ^myClass; r: @real enter R[] do ... exit R #)
   #)
</PRE>

<P>In the above subpattern of COM the virtual patterns have a do-part.
Instances of myCOMClass will now behave like COM-objects and can be exported
to external languages. Consider a function:</P>

<PRE CLASS=beta>putObject: external(# R: ^myCOMClass enter R[] #)</PRE>

<P>and declarations</P>

<PRE CLASS=beta>myCOM: @myCOMClass</PRE>

<P>The object myCOM may now be exported by executing</P>

<PRE CLASS=beta>myCOM[] -&gt; putObject</PRE>

<P>As for importing COM objects, there is is no security regarding exporting a
COM object to an external language.</P>

<H3><A NAME="ParametersToBasicCOM">2.1.3 Parameters to basic COM objects</A></H3>

<P>At the basic COM level, the only type of parameters that are considered,
are basic patterns like integer, boolean, char and real and references
to COM objects. For the basic patterns, a call-by-value semantics is used
and for references to COM objects, the reference is copied. This is a nice
and clean principle. As we shall later see, the parameter situation with
Microsoft COM is much more complicated.</P>

<H2><A NAME="BasicCOMwithIUnknown">2.2 Basic COM with IUnknown</A></H2>

<P>At this level, a standard pattern IUnknown is added corresponding to
the Microsoft COM IUnknown classes. IUnknown and corresponding classes
are declared as follows:</P>

<PRE CLASS=beta>
HRESULT: (# ... #);
GUID: (# ... #);
CLSID: GUID(# ... #);
IID: GUID(# ... #);
IUnknown: COM
  (# QueryInterface:&lt; 
         (# iidref: @int32; 
            theIID: ^IUnknownHolder; hres: @int32
         enter(iidref,theIID[])
         exit hres
         #);
       AddRef:&lt; (# ... #);
       Release:&lt; (# ... #)
   #);
CoInitialize: external (# ... #);
CoUnitialize: external(# ... #);
CoCreateInstance: (# ... #);
CLSCTX_INPROC_SERVER: (# exit 1 #);
ComErrorMessage: external (# ... #)
</PRE>

<P>
All COM class patterns that are going to be used together with Microsoft
Windows must be subpatterns of IUnknown. An interface to an imported IUnknown
object may look as:</P>

<PRE CLASS=beta>
myMSCOMclass: IUnknown
  (# f1:&lt; (# ...  #);
     f2:&lt; (# ...  #);
     f3:&lt; (# ... #);
  #)
</PRE>

<P>An IUnknown object implemented in BETA may look as follows:</P>

<PRE CLASS=beta>
myMSCOMclass2: IUnknown
  # QueryInterface::&lt; (# ... do ... #);
    AddRef::&lt; (# ... do ... #);
    Release::&lt; (# ... do ... #);
    f1:&lt; (# ... do ... #);
    f2:&lt; (# ... do ... #);
    f3:&lt; (# ... do ... #);
  
    ... data items implementing myCOMclass ....
  #)
</PRE>

<P>Here we bind QueryInterface, AddRef and Release and define new COM virtuals
and data-items to represent the COM object.</P>

<P>An example of implementing a COM object in BETA and exporting it to
C may be found in the TST example:<BR>
</P>

<PRE CLASS=beta>
COMaccount.bet COMaccountUser.c
</PRE>

<H2><A NAME="Full COM">2.3 Full COM</A></H2>

<P>So far we have only allowed basic patterns and references to COM objects
as parameters. Reality is much more complicated. We will return to this
matter.</P>

<H2><A NAME="ComWithSeveralInterfaces">2.4 Implementing COM objects with Several Interfaces in BETA</A></H2>

<P>Nested classes seem well suited to implement the notion of several interfaces.
The following example shows how an object X with interfaces A, B, and C
may be implemented using nested classes.<BR>
</P>

<PRE CLASS=beta>
CX: 
  (# IA: IUnknown
       (# QueryInterface::&lt;
          (#
          do (if IFID
              // IAID then this(IA)[][] -&gt; IF[]
              // IBID then &amp;IB[] -&gt; IF[]
              // ICID then &amp;IC[] -&gt; IF[]
              else 
                 NONE -&gt; IF[]
             if)
          #);

          AddRef::&lt; (#... #);
          Release:&lt; (# ... #);
          f1:&lt; ...
          f2:&lt; ...
          f3:&lt; ...
       #);
     IB: IUnknown
       (# ...
          g1:&lt; ...
          g2:&lt; ...
          g3:&lt; ...
       #);

     IC. IUnknown
     (# ...
        h1:&lt; ...
        h2:&lt; ...
        h3:&lt; ...
     #);
  #)
</PRE>

An example of a COM object with several interfaces implemented in BETA<BR>
and exported to C may be found in the TST examples:</P>

<PRE CLASS=beta>
IUnknown.bet  
MiniThought.beta   MiniThoughtUser.c      
MiniThought2.beta  MiniThoughtUser2.c
</PRE>

<P>
In the mentioned example currently 2 versions of Iunknown are defined, A nice BETA version
(IUnknown) and a more correct COM version (IUnknown2) (see below). MiniThought
uses the nice solution whereas MiniThought2 uses the 'real' COM definition.
And of course the real COM solution should be called IUnknown!<BR>
</P>

<H2><A NAME="RulesForUsingCOM">2.5 Rules for Using COM Objects in BETA</A></H2>

<H3><A NAME="PatternCOM">The predefined Pattern COM</A></H3> 

The predefined pattern

<PRE CLASS=beta>
COM: (# #)
</PRE>

is an abstract superpattern. Any descriptor that specialises pattern
COM describes a COM object. It may be either a COM object imported
form external languages or a COM object implemented in BETA. Basic COM
objects in BETA are defined by the general layout of COM objects.
Pattern COM does not define 'QueryInterface,' 'AddRef' and 'Release'.

<H3><A NAME="Patterns_IID_IUnknown">Patterns IID and IUnknown</A></H3>

The pattern IUnkown is supposed to be defined in a library and to 
define <CODE>QueryInterface</CODE>, <CODE>AddRef</CODE> and <CODE>Release</CODE>:

<PRE CLASS=beta>
IUnknown: COM
   (# Query:
        (# theIID: ^IID;  
           ppv: @ Integer;
           ppvObj: ^IUnknown;
           returnPPV: (# ... #);
           H: @integer;
        enter(theIID[],ppv)
        exit H
        #);
      QueryInterface:&lt; Query;            
      AddRef:&lt; ...
      Release:&lt; ...
   #)
</PRE>

The pattern IID represents the Globally Unique Identifier:

<PRE CLASS=beta>
IID: data(# ... #);
</PRE>

There is also a pattern

<PRE CLASS=beta>
HRESULT: 
  (# ...
     succeeded: (# ... #);
     failed: (# ... #);
</PRE>

that represents return values. 


<H3><A NAME="Out_inout">Out- and inout parameters</A></H3>
Consider references

<PRE CLASS=beta>
anIID: ^IID; R: ^IUnknown; S: ^IUnknown; V: @integer
</PRE>

A call of QueryInterface might then look like:

<PRE CLASS=beta>
(anId[],@@R) -&gt; S.QueryInterface -&gt; V;
</PRE>

This illustrates a general problem:
<P>
The COM standard as expressed through the definition of QueryInterface
is not ideal seen from a BETA point of view (perhaps ugly in
general). COM states that all functions must return a HRESULT which is
an integer defining the status of the result. All other return values
must be passed as input parameters. This means that return values in
the form of objects (interfaces) must be passed as the address of a
pointer variable. In pseudo BETA this would make QueryInterface look
like:

<PRE CLASS=beta>
Query:
  (# theIID: ^IID;  
     ppvObj: ^^IUnknown;
     H: @HRESULT;
  enter(theIID[],ppvObj[])
  exit H
  #);
</PRE>

and the corresponding call:

<PRE CLASS=beta>
(anId[],R[][]) -&gt; S.QueryInterface -&gt; V;
</PRE>

However, BETA cannot express a reference to a reference.
<P>
What we really would  like to have is in the following style

<PRE CLASS=beta>
Query:
  (# theIID: ^IID;  
     ppvObj: ^IUnknown;
     H: @HVALUE;
  enter theIID[]
  exit(H,ppvObj[])
  #);
</PRE>

with calls of the form:

<PRE CLASS=beta>
anId[] -&gt; S.QueryInterface -&gt; (R[],V)
</PRE>

i.e. with multiple return values.
This is, however, not the usual C-style! 
<P>
Instead we have introduced so-called <EM>holder</EM> objects, which are treated specially by the compiler:


<H3><A NAME="holder_objects">Compiler Support for Holder objects</A></H3>

<P>A basic pattern of the form </P>

<PRE CLASS=beta>
holder: (# adr: @integer #);
</PRE>

<P>has been introduced to hold addresses of basic values (integer, etc.)
and references to other COM objects. </P>

<P>Subpatterns of the form </P>

<PRE CLASS=beta>
intHolder: holder  
  (# value: @integer;
  enter value
  exit value 
  #);
refHolder: holder
  (# type:&lt; object;
     ref: ^type;
  enter ref[]
  exit ref[]
  #)
</PRE>

have been defined.

<P>For A virtual COM function having an Out or InOut parameter being a reference
to a basic value or a reference to a reference, the corresponding BETA
enter parameter must be a reference to a holder object. </P>

<P>When a BETA call is made of such a function, the address of <CODE>value</CODE>
or <CODE>ref</CODE> (generally the address of the first item after the <CODE>adr</CODE> item)
is passed as a parameter to the virtual function. 
This passing of the address naturally means that the holder object must not be moved by garbage collection. This is enforced by allocating Holder object the same way as COM objects are alloced, see
<A HREF="COM_Holder_Allocation">COM/Holder Allocation</A>.
</P>

<P>For a virtual COM function implemented in BETA, a holder object is
generated for each Out and InOut parameter, and the address passed as
parameter and the value or reference at that address is stored in the
Holder object.  In the do-part, the BETA code can then work normally
on the attributes of this holder object.  Before returning from the
do-part of the COM virtual, the compiler generates <EM>writeback</EM>
code, that writes the attributes of the holder object back to the
address saved in the <CODE>adr</CODE>attibute.
</P>

<P>In the following example (TST/comTst), foo has an enter parameter which
is a reference to an integer. Bar has an enter parameter which is a reference
to a reference. </P>

<PRE CLASS=beta>
(# myClass: COM
     (# foo:&lt;  
          (# n: @integer; S: ^intHolder; 
          enter(n,S[])  
          do (* intHolder is generated by compiler and assigned to S[] *)
             n -&gt; putint; ' ' -&gt; put; S -&gt; putint; ' '-&gt;put;
             n + S -&gt; S; S -&gt; putint; newline;
             (* S.value is written back to S.adr by compiler *)
          #);
        bar:&lt;
          (# n: @integer; R: ^myClassHolder
          enter(n,R[])
          do (* myClassHolder is generated by compiler and assigned to R[] *)
             &amp;myClass[] -&gt; R;
             n -&gt; R.ref.kuk;
             (* R.ref is written back to R.adr by compiler *)
          #);
        kuk: @integer
     #);
   myClassHolder: refHolder(# type::myClass #);   
   R: @myClass;
   Q: @intHolder;
   P: @myClassHolder 
do 111-&gt;Q;
   (11,Q[]) -&gt; R.foo;
   Q -&gt; putint; newline;
   (333,P[]) -&gt; R.bar;
   P.ref.kuk -&gt; putint; newline;
#)
</PRE>


<H3><A NAME="dynref">Dynamic Reference declaration</A></H3>

A COM object may be referenced from a dynamic reference in the usual
way:

<PRE CLASS=beta>
R: ^ myClass;
</PRE>

<H3><A NAME="COM_Holder_Allocation">COM/Holder Allocation</A></H3>

Dynamic COM objects can be generated in the usual way:

<PRE CLASS=beta>
&amp;myClass[] -&gt; R[];
</PRE>

Since references to COM objects can be passed to external languages
such as C, COM objects are allocated in the non-moving <CODE>AOA</CODE> heap by
means of a special allocation routine <CODE>AlloCOM</CODE>.

COM objects cannot be moved by the garbage collector. Memory
management for COM objects is through the use of AddRef and Release.
<P>
Likewise, since the address of the second attributes of holder objects
are given to external calls, holders are allocated in <CODE>AOA</CODE> by means of <CODE>AlloCOM</CODE>.

<H3><A NAME="staticref">Static Reference Declaration</A></H3>

A static COM object can be part of a general object or a COM object

<PRE CLASS=beta>
yourComClass: COM (# ... #);

myComClass: COM                              (1)
   (# ...
      myPart: @ yourComClass                 
   #);

myClass: (# ...; X: @yourComClass #)         (2)
</PRE>

In case (1) the COM part object (myPart) is allocated in-line as for
general non-virtual/descriptor-slot part objects.
<P>
In case (2) the COM object is alloacted off-line using <CODE>AlloCOM</CODE>. I.e. X is represented
as a reference to the instance of yourComClass.
<P>
The reason for the difference is as mentioned in the section on
dynamic generation, that COM objects must be allocated in a heap where
they are not moved by the standard BETA garbage collector. In case (1)
the COM object can be allocated in-line since the enclosing COM object
is guaranted not to move. In case (2) the enclosing object may be move
and therefore the COM part object is allocated in the COM object
heap. As with dynamic references, the same allocation treatment takes 
place for Holder objects.

<H3><A NAME="pattern_data">Data objects reconsidered</A></H3>

Pattern Data does not work as intended in general. They have to be allocated
outside the BETA heap to be able to pass to C. And there are problems
with references to data-objects in registers.
<P>
With respect to allocation, we could change the meaning of pattern
<CODE>Data</CODE> such that data objects are ONLY allowed as part objects of
COM-objects and/or data-objects. This will ensure that data-objects
are always at the same address. And a data-object exists as long as
the enclosing COM-object exists.
<P>
This is now a recomendation, but it is <EM>not</EM> checked by the compiler.

<H3><A NAME="doparts">COM Object Do Parts</A></H3>

A COM object cannot have a do-part. This may be reconsidered in
connection with design of an object factory mechanism for BETA COM
objects. A possible DO-part may be used to specify code that
instantiates a COM-object.

<H3><A NAME="enter_exit">COM Object Enter- and Exit Parts</A></H3>

A COM object cannot have an enter- or exit-part. This may again have
to be reconsidered for a possible object factory mechanism.
<P>
A COM virtual pattern may have an enter part with the types

<PRE CLASS=beta>
basic patterns, text, ref. to COM object, 
cstruct?, data?, 
</PRE>

A COM virtual pattern may have an exit part with one element:

<PRE CLASS=beta>
basic pattern, text, ref. to COM object,
cstruct?, data?, 
</PRE>

<H3><A NAME="com_virtual_call">Call of attribute functions</A></H3>

A COM virtual pattern may be executed as a procedure/function in the
usual way:

<PRE CLASS=beta>
(e1,e2,e3) -&gt; R.foo1 -&gt; x;
</PRE>

<H3><A NAME="com_ref_params">COM reference parameters</A></H3>

If foo is a C-function then foo may return a COM-object:

<PRE CLASS=beta>
foo -&gt; R[];
</PRE>

And similarly an external function bar may receive a COM object

<PRE CLASS=beta>
R[] -&gt; bar
</PRE>

<H3><A NAME="qua">Qua-check and other security issues</A></H3>

Consider

<PRE CLASS=beta>
A: COM(# ... #); R: ^A, S: ^B
</PRE>

and a reference assignment

<PRE CLASS=beta>
R[] -&gt; S[]
</PRE>

For general BETA objects, this assigment will give rise to a QUA-check
that checks that R actually refers to an instance of B (or subpattern
of B). This may not be possible with COM objects.

<OL>
<LI> If R denotes an external COM object, then the standrad BETA QUA checking
     cannot work, since an external COM object does not have a BETA-like 
     prototype.

<LI> If R denotes a BETA implemented COM object, standard QUA-checking
     should be possible. 
</OL>

In general the QUA mechanism should at run-time be able to distinguish
between (1) and (2) and do the QUA-checking in case (2). In case (1)
the assignment will be insecure.
<P>
For case (1) it might be possible use the COM class-id and
QueryInterface to check the legality of the assignment. This will,
however, have to be further investigated.
<P>
Currently Qua-checking is just disabled for COM objects!
<P>
In general use of COM is insecure, since BETA has no way of checking
that an imported COM object is safe. Similary a client of an exported
COM object may be unsafe. In general good debugging mechanisms should
be investigated.


<H2><A NAME="idl_tlb">2.6 IDL/ODL and Type Libraries</A></H2>

<H3><A NAME="idl_odl">IDL/ODL</A></H3>

From IDL, corresponding descriptors of BETA interfaces can be
generated. This has been implemented by
<A HREF="http://www.mjolner.com/mjolner-system/documentation/bidl/index.html">
IDL to BETA compiler</A>.
<P>
Similarly ODL definitions could be generated from BETA; no tools have been made for this.

<H3><A NAME="type_libraries">Type libraries</A></H3>

It may be better to use type libraries directly In BETA. For import of
COM objects, a corresponding type library may be included by BETA.
Similarly a type library may be generated from BETA implemented COM
objects.

<H1><A NAME="implementation">3. Implementation</A></H1>

<P>This section describes the implementation of COM support in BETA. </P>

<H2><A NAME="object_layout">3.1 COM Object Layout</A></H2>

A COM object may be implemented as follows:

<PRE CLASS=beta>
myClass: IUnknown
   (# a: @integer;
      b: @char;
      foo1:&lt; (# ... #);
      foo2:&lt; (# ... #);
      ...
      foon:&lt; (# ... #);
      c: @real
   #)
</PRE>

As described above, there are certain restrictions on the use of COM
objects and COM virtuals.  Also there are restrictions on how to
define COM objects and COM virtuals. However, there are no restrictions
on the data-items that can be used to represent COM objects.
<P>
The layout for a COM object is as follows:

<PRE CLASS=beta>
 Object                   Prototype
                        ---------
                        |       | BETA prototype start
                        | ...   |
                        |       |
---------               |-------|
|       | -------&gt; VDT: |       | ----&gt; f1
|-------|               |-------|
| GC-f  |               |       | ----&gt; f2
|-------|               |-------|
|   a   |               |       | ----&gt; f3
|-------|               |-------|
|   b   |               | ...   |
|-------|               ---------
|   c   |
---------
</PRE>

The only difference from a standrad BETA object is that the prototype
for the object refers directly to the dispatch table in the prototype.
The prototype has the usual form, but the object does NOT refer to its
start. Note that there is a fixed (negative) offset from the VDT-start
to the start of the prototype.


<H2><A NAME="checking">3.2 Changes to Semantic Checking</A></H2>

<UL>
<LI>
  A pattern ChkComDesc (chkdescbody.bet) performs the main checking of
  a COM descriptor
</UL>

COM object-descriptors will during checking be marked as:

<UL>
<LI><B>ComKind</B><BR>A COM object imported to BETA
<LI><B>ComKind</B><BR>A COM object implemented in BETA
<LI><B>externalVirtualKind</B><BR>A virtual pattern inside a COM object, either an
                          imported object or a BETA implemented COM object.
                          Perhaps 2 kinds are needed for this!
<LI><B>holderKind</B><BR>
    A subpattern of <CODE>Holder</CODE> used for passing pointers inside BETA objects to external calls
</UL>

As mentioned elsewhere we should perhaps distinguish between imported
and exported COM objects.
<P>
Missing semantic checks:

<OL>
<LI>A COM virtual can have at most one exit element.
<LI>No do parts allowed in COM objects
<LI>No enter-exit allowed in COM objects
</OL>


<H2><A NAME="coding">3.3 Changes to code generation</A></H2>

<P>Code layout for a COM virtual pattern with NO super pattern. I.e. the
topmost descriptor of a COM virtual: </P>

<PRE CLASS=beta>
G11FOO:  saveReturn
         Allocate activation object
         ...           - standard G-part
         ...
         &lt;store arguments in object&gt; perhaps before standard G-part?
M11FOO:  ...             - there is no save return here
         ...             - standard M-part

         returnExitElement
         return
</PRE>
The idea is that a COM virtual is called by placing arguments to the
virtual (including the object = origin) in standard input registers,
%o0, %o1, ...,  and then calling the G-part. After execution of the
standard G-part, the arguments are stored in the object and the M-part
is immediately executed. Finally the exit element is returned.
 <P>
Code layout for a virtual COM subpattern. (We assume that G11FOO,
M11FOO is the superpattern)

<UL>
<LI>
The problem here is to avoid allocating the object twice by
  calling the G-part of the super (G11FOO). I.e. currently
  there can be no CODE in the super part! We will have to handle
  this as for V-entry points!

<PRE CLASS=beta>
G21FOO: saveReturn
        Allocate activation object
        
        ...          - standard G-part
        ...
       &lt;store arguments in object&gt; perhaps before standard G-part?
       JMP M11FOO  - execute Top-DO part

M21FOO: saveInnerRetun
        ...
        ...        - standard M-part
        innerReturn
</PRE>
        
</UL>

When calling the pattern above, G21FOO will be the entry-point.
G21FOO will jump to M11FO. M11FOO may through inner call M21FOO. This
works in the usual way since the object has a normal BETA prototype
with a dispatch table containing the inner dispatch table.

<H4><A NAME="com_object_generation">Generation of COM object</A></H4>

<UL>
<LI>The slot <CODE>AllocObj</CODE> in machine.bet is used to generate in the
  G-entry part for allocation of a COM virtual function. This is similar to
  dynamic generation in V-entries.

<LI>A routine <CODE>AlloCOM</CODE> is called. <CODE>AlloCOM</CODE> allocates
  the object in the non-moving <CODE>AOA</CODE> heap, but otherwise behaves like <CODE>AlloI</CODE>. 
  See <A HREF="#AlloCOM">AlloCOM</A>.

<LI>No INNER entries should be generated for a COM dispatch table; this
  is implemented, however, one zero-entry is currently generated before
  the virtual-dispatch-table. Should be eliminated. Until this has been
  done, it can be fixed by AlloCOM that just MUST point to the start of
  the VDT. <EM>FIXME: Still a problem?</EM>

<LI>G-entries are used in the dispatch-table instead of T-entries
</UL>

<H4><A NAME="com_virtual_call">Call of a COM virtual function</A></H4>

<UL>
<LI>Currently a call of an external virtual is made in the same way whether 
  it is a BETA COM virtual or an external COM virtual;
  perhaps we should distinguish! Currently a C call is made.

<LI>Transfer of a COM object to C has been implemented - just the reference
  is passed. BUT a call to addRef must be made.

</UL>

<H4><A NAME="compiler_status">Code generation status</A></H4>

<UL>
<LI>Some incomplete code is generated for COM object and COM virtual
  patterns that are just used to specify interfaces to external
  languages. This should be cleaned up. And we should consider to
  forbid generating objects in BETA from such interface patterns. <EM>FIXME: Still a problem?</EM>

<LI>Reconsider transfer of text objects. In the G-part of virtual,
  an ASCIZ text MUST be expected, since we may come from C.
  OK for text const - must be fixed for text object and
  char-rep. <EM>FIXME: Still a problem?</EM>

<LI>Reconsider M-entry-label for virtual Com; <CODE>initDo</CODE> is currently not called
  which means that in some cases, <CODE>dbgInf</CODE> is NONE. <EM>FIXME: Still a problem?</EM>

<LI>Avoid double allocation in G-part of virtual COM subpatterns. <EM>FIXME: Still a problem?</EM>

<LI>
  The calling convention for COM is  <CODE>__stdcall</CODE> (Pascal). This means that the
  called function must pop the arguments from the stack. Except if the 
  function has a variable number of arguments, in which case the caller
  must pop the stack. Poping of arguments is done in XXXmachine slot
  getXres. If 'extType = 9 (* externalDispatch *)' then we have a
  COM virtual call.
<P>
  For UNIX we just use standard C calling convention for COM function calls.


<LI>A virtual COM specified by name may be inconsistent if name is used
    for other purposes than a virtual COM

<PRE CLASS=beta>
myClass: COM
   (# f1:&lt; object; (* always illegal *) FIXME: still the case?
      f2:&lt; foo;    (* OK if foo is NOT used for other purposes *)
   #)
</PRE>

    This is not properly checked in <CODE>chkComDesc</CODE>

<LI>The calling convention for reals as arguments to COM virtual
    functions must be checked, and correct code must be generated. 
    Currently, when a COM virtual has a real argument, a compiler
    message 'computedAdrVal:asgToRealAdr' will be printed.

<LI>A data/cstruct can be passed by value to external and returned by value
    from external. Implemented for INTEL but not for SPARC.
    It is NOT implemented the other way around: i.e. a BETA COM component
    cannot have call-by-enter and exit- data/cstruct parameters.

</UL>

<H1><A NAME="rts">4. Run-Time System Issues</A></H1>

<H2><A NAME="AlloCOM">4.1 Allocation of COM objects</A></H2>

<CODE>AlloCOM</CODE> has been implemented. It will allocate the object directly
in <CODE>AOA</CODE>, and the object thus is never moved by GC.
Otherwise it works as <CODE>AlloI</CODE>.

<H2><A NAME="ChkRA">4.2 ChkRA</A></H2>
Part objects in COM objects are thus also directly allocated in <CODE>AOA</CODE>.
This means that special care must be taken when assigning origins in
the <CODE>AlloCOM</CODE> and in the G-parts of part objects: Normally origin
assignment in G-parts do not call <CODE>ChkRA</CODE>, since the objects just
allocated are known to be in <CODE>IOA</CODE>. However, this is not the case for
COM objects. 

<H2><A NAME="Part_object_off-lining">4.3 Part object off-lining</A></H2>
There should <EM>only</EM> be static instances of the
following kind of objects in a COM object:
<UL>
<LI>Basic types (integer, char etc)
<LI>Specialization of <CODE>DATA</CODE>
<LI>Specializations of <CODE>Holder</CODE>
<LI>Other <CODE>COM</CODE> objects
</UL>

To enfore this, the compiler
<OL>
<LI><EM>will</EM> generate <CODE>ChkRA</CODE> in all origin assignments in
G-parts of <EM><CODE>COM</CODE> objects</EM> and <EM><CODE>Holder</CODE> objects</EM>
<LI>In all <CODE>COM</CODE> objects and <CODE>Holder</CODE> objects, every static part object
that is <EM>not</EM> itself either a <CODE>COM</CODE> object or a <CODE>Holder</CODE> object
will <EM>not</EM> be inlined as a real part object, but will instead
be allocated off-line in <CODE>IOA</CODE>.
<LI>As previously mentioned, static COM and Holder objects that do not have surrounding COM/Holder objects will be allocated off-line using AlloCOM.
</OL>

<H2><A NAME="COM_GC">4.4 garbage collection</A></H2>
<UL>
<LI>
  As mentioned, there are various issues related to <CODE>AOA</CODE> to <CODE>IOA</CODE> 
reference book-keeping, see <A HREF="ChkRA">ChkRA</A>.
<LI>
  There may be references between the BETA heap and the COM heap.
  Should the compiler use a special tag for references to COM-objects
  in the dynamic reference table in prototypes? We currently mark as
  normal ref, origin or constant ref. A 4th marking could be COM ref.
  <EM>FIXME: what is the current marking?</EM>

<LI>
  As for pattern data: GC-registers may hold references to 
  COM objects, and these should NOT be garbage collected.
  The GC must thus be able to decide if a reference is to an object
  outside the BETA heap. 
  Note that a COM
  reference may point into the BETA <CODE>AOA</CODE> heap or into some place
  allocated by an external language.

<LI>
  A strategy for GC of COM objects must be invented. This might be 
  something like: the refCount in a COM object counts the number of external
  reference to the object. If zero then there is no external references.
  A COM object is alive as long as refCount is greater than zero or there
  the COM object may be reached from a live object in the BETA heap.
  For BETA implemented COM objects, the GC must be able to access the 
  reference counter. This is <EM>not</EM> implemented.
</UL>
<P>

<H1><A NAME="todo">5. Open Issues</A></H1>

<UL>

<LI>
  A ComQua check should be designed.

<LI>
  ClassFactory and instantiation!

<LI>
  When passing ref to ref from stack variables in C to BETA, the address
  may apparently be a negative value. This means that NONE check for
  COM object refs must NOT trap on negative values!

<LI>
  Use of UniCode strings.

  We must handle wchar, wchar_t, OLECHAR, LPOLESTR, ...

  Currently a first version of unicodetext (wtext) has been implemented.
  See the description in:
  <A HREF="http://www.daimi.au.dk/~olm/DOC/UniCode.html">http://www.daimi.au.dk/~olm/DOC/UniCode.html</A>

</UL>

</BODY>
</HTML>
