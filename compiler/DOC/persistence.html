<HTML>

<HEAD>
<TITLE>Persistence documentation</TITLE>
<LINK REV="made" HREF="mailto:olm@daimi.aau.dk">
</HEAD>

<BODY>
<H1>Persistence documentation</H1>

<PRE>

Note about persistent store implementation
------------------------------------------

For the pstore we have to solve the following problems

1.	Eliminate initfragment
2.	Make it possible to store a COOL/C++ object in a pstore
	and subsequently read it from a BETA program and vice versa

Re 1.
A program must have information that makes it possible to perform
the following mappings

	1.	prototyplabel  -&gt; (file name, prototypeOffset)

        2.	(file name, prototypeOffset) -&gt; prototypelabel

1. is no problem with the current run-time layout. 2. is a problem when
the objeserver in

	T## -&gt; PS.get -&gt; R[]

follows references to objects NOT in the same fragment as T.

It is suggested to put a table in each .o-file such that from betaenv
it is possible to find the corresponding table in all .o-files
linked with the program.

Re. 2
It should be possible for COOL/C++ to computer prototype ids without
knowing about BETA .o-files. 

It is suggested to identify each prototype in a fragment file with a
unique number 1,2,3, etc.  A table in the .o-file maps these numbers
into prototype labels.


This gives the following layouts. of .o-files

foo.bet:

ORIGIN 'pip'
INCLUDE 'foo1'
INCLUDE 'foo2'
BODY 'bar1'
BODY 'bar2'
--lib:attributes--
p1: (# ... #);
...

foo.o:

.text
	executable code

.data
	various constants
X_foo:	L1
	T1FOO
	T2FOO
	T3FOO
	0
	X_foo1
	X_foo2
	X_bar1
	X_bar2
	0
L1:	asciz "~olm/.../foo"	
	...
T1FOO: 	...
T2FOO: 	...
T3FOO: 	...

The label X_foo is OK, since we already assume that no two attributes
files have the same name.

Consider a file with descriptor forms:

bar1.bet

ORIGIN 'foo'	(* can be another file*)
INCLUDE 'kuk'
--F1:descriptor--
...
--F2:descriptor--
...
--F3:descriptor--
...

bar1.o:

.text
	...
.data
	...
X_bar1:	L1
	T1F1
	T2F1
	T3F1
	T1F2
	T2F2
	T2F3
	...
	0
	X_KUK
	0
L1:	asciz " .../bar1"

Here the problem is that X_bar1 implies that ALL files with descriptor forms
must also have different names. This means that the name of ALL files
in a program must be different. This is more restrictive than the current
compilers.

It is not possible to use say 'X_F1' instead of 'X_bar1' which would
assure uniqueness. The problem is that 'foo.bet' may be compiled before
'bar1' and 'bar2' are even created. And even if they exist, fragment
forms may be moved between them. Changes to bar1 or bar2 should never
imply recompilation of foo.

Possible solutions

1.	Use the file name always as in 'X_foo'
	Will require all file names to be unique.
	It is simple!

2.	Generate a label for each descriptor form. I.e for bar1
	
		X_F1:
		X_F2:

	This is also simple, but will make take more space. It will also
	makes more work for the linker.

	The reason that foo can be compiled without knowing about bar1
	and bar2, is that a label of this form can be generated for each
	descriptor slot defined in foo. It does then not matter in
	which body files the slot is actually bound.

3.	Generate a unique label from the file name, like

		_users_olm_beta_test_bar1:

	This requires that the file-interface is able to produce
	a unique path for each file name. Note that there may be
	links to a file. So a file may may have several logical
	names. We will need the same path name every time.
	We were investigating this when we made the pathhandler
	and I think that the answer is that it is not possible to
	generate such a unique path name?


Currently I think that solution 2 is to prefer?
Comments?

---olm

</PRE>

</BODY>
</HTML>