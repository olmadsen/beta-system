
\section{Mapping nested patterns}
Consider the following structure of nested (inner) patterns:
{\tt\small\begin{verbatim}
   A: (# ...
         AA: (# ...
                AAA: (# ... #)
             #)
      #)
\end{verbatim}
}

This structure is mapped into the following structure of nested
CJ-classes:

{\tt\small\begin{verbatim}
   class A extends Object { 
      class AA extends Object { 
         ...
         class AAA extends Object {
            ...
         }
      }
   }
\end{verbatim}
} 

The above scheme is semantically correct for Java, but does not work
for \CS.In \CS\ instances of inner classes cannot refer to instance
variables in the enclosing object.  To handle this BETA and Java
maintains a structural reference to the enclosing object of an inner
class.  For \CS, we have to generate this reference as part of the
mapping. The above nested BETA patterns are thus mapped into the
following \CS\ structure:

{\tt\small\begin{verbatim}
   class A extends Object { 
      class AA extends Object { 
         A origin;
         AA(A org) { origin = org;}
         ...
         class AAA extends Object {
            AA origin; 
            AAA(AA org) { origin = org; }
            ...
         }
      }
   }
\end{verbatim}
} 

Each inner class has an explicit reference, {\tt origin} to its
enclosing object. The origin reference is setup by a constructor that
has the origin as an argument.

\note{Figure with nested A, AA, and AAA instances?}

The {\tt Account} example thus maps into the following classes for
\CS:

{\tt\small\begin{verbatim}
   class Account extends Object {
      int balance = 0;
      int deposit(int amount) {
          deposit D = new deposit(this);
          D.enter(amount);
          D.do();
          return D.exit();
      }
      void withdraw(int amount) { ... };
      class deposit extends Object { 
         origin Account;
         int amount;
         deposit(origin org) { origin = org; }
         void enter(int a) { amount = a; }
         void do() { origin.balance = origin.balance + amount; }
         int exit() { return origin.balance; }
      }
      class withdraw extends Object { ... };
}
\end{verbatim}
}

\note{Some explanation ...}

An inspection of the class-files and generated by Java (and \CS?)
reveals that inner classes are flattened as outer classes and thus all
appear at the same level of block structure.  To handle this a name
mangling scheme is used by Java (and \CS?) to ensure uniqueness of
class names. The above BETA patterns then at the class-file level are
mapped into the following flat structure of classes:

{\tt\small\begin{verbatim}
   class A extends Object { ... }
   class A$AA extends Object { 
      A origin;
      A$AA(A org) { origin = org; }
      ...
   }
   class A$AA$AAA extends Object {
      A$AA orgin;
      A$AA$AAA(A$AA org) { origin org; }
      ...
   }
\end{verbatim}
} 
  
The flattening, name mangling and explicit origin reference are only a
matter at the class-file level. At the user level -- Java and \CS\ 
programmers using BETA, the flattening does not show up.  Except that
\CS\ programmers have to deal with the origin reference.

\note{We should either make use of Java inner classes or have a remark
  about it. I.e. that we currently do not use them but plan to.}
