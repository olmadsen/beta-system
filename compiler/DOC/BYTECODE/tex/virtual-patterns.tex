
\section{Mapping virtual patterns}

A BETA pattern may be virtual. A virtual pattern used as as procedure
corresponds to a (virtual) method in Java and \CS. A virtual pattern
used as a class corresponds to a class parameter of a generic class
(parameterized class) in Java -- there is no counterpart in \CS\ (Is
this correct?).

\note{More references to virtual class literature}

The following example shows the use of virtual patterns. The pattern
{\tt Buffer} is a generic buffer that may hold an instance of the
pattern {\tt elm}.  Pattern {\tt elm} is declared as a virtual pattern
attribute of {\tt Buffer} -- the {\tt <} in {\tt elm:< object}
indicates that {\tt elm} is a virtual attribute -- the {\tt object}
part of the declaration indicates that {\tt elm} may be extended in
subpatterns of {\tt Buffer} to subpatterns of {\tt object}. This means
that the type (qualification) of {\tt elm} in {\tt Buffer} is {\tt
  object} and that {\tt elm} can be used as if it is pattern {\tt
  object}.

The instance variable {\tt theElm}, the enter-argument {\tt E} of
{\tt insert} and the exit-value {\tt X} of {\tt get}
are all declared to be of type {\tt elm}, i.e. in {\tt
  Buffer}, {\tt object}.

Since {\tt object} is the most general superpattern in BETA, only few
properties of {\tt elm } is known in {\tt Buffer}, but in subpatterns
of {\tt Buffer}, {\tt elm} may be extended to any other pattern.

\note{display - currently ignored}

{\tt\small\begin{verbatim}
   Buffer:
     (# elm:< object;
        theElm: ^elm;
        put:
          (# E: ^elm
          enter E[] do E[] -> theElm[]
          #);
        get: 
          (# X: ^elm
          do theElm[] -> X[]
          exit E[]
          #);
        display:<
          (#
          do 'Buffer: ' -> screen.puttext; inner;
          #)
     #);
\end{verbatim}
}

Since {\tt elm} is qualified by {\tt object} arbitrary objects may be
inserted into a {\tt Buffer} as shown in the following example where
an {\tt Account} and a {\tt Person} are inserted into a {\tt
  Buffer}-object.

{\tt\small\begin{verbatim}
   (# B: @Buffer; 
      Joe: @Person;
      myAccount: @Account
      X: ^object;
   do myAccount[] -> B.put;
      Joe[] -> B.put;
      B.get -> X[];
   #)
\end{verbatim}
}

The statement {\tt B.get -> X[]} retrieves the element from the buffer
and assigns it to {\tt X}. Since {\tt get} returns a reference of type
{\tt elm} the type of {\tt X} also has to be {\tt object}

Also the type of en element retrieved from the buffer by {\tt get}
is only know to be of type {\tt object}.

In pattern {\tt AccountBuffer} -- a subpattern of {\tt Buffer} -- {\tt
  elm} is extended to be the pattern {\tt Account} as specified by the
declaration {\tt elm::< Account}. This means that inside {\tt
  AccountBuffer}, we know that the instance variable {\tt theElm} is
at least of type {\tt Account}. This is also the case for the
enter-argument {\tt E} of put and the exit-value {\tt X} of get.


%This fact is used i the {\tt display}
%method where {\tt theElm} is used is written as a text to the screen.

{\tt\small\begin{verbatim}
   AccountBuffer: Buffer
     (# elm::< Account
        display::< 
          (#
          do theElm.balance -> putint;
          #)
     #);
\end{verbatim}
}

The next example shows a use {\tt AccountBuffer}
where only instances of {\tt Account} or subpatterns of {\tt Account}
may be inserted:

{\tt\small\begin{verbatim}
   (# Joe: @Person;
      myAccount: @Account
      Q: @AccountBuffer; 
      S: ^Account
   do myAccount[] -> B.put;
      Joe[] -> B.put;
      B.get -> X[];
      myAccount[] -> Q.put;
      Q.get -> S[];
   #)
\end{verbatim}
}

In addition the type of elements retrieved from {\tt Q} is known to be
of type {\tt Account}

\subsection{First version of mapping}
\note{Better heading needed} The pattern {\tt Buffer} is mapped into
the following Java class.  The operations {\tt put} and {\tt get} are
mapped into a method and an inner class following the general mapping
for nested patterns. 

The special thing here is the treatment of the virtual pattern {\tt
  elm}. Since {\tt elm} is declared as a virtual {\tt object}, the
type of {\tt theElm}, the argument {\tt a} of {\tt put} and the
argument {\tt a} of the enter-method of class {\tt put} all become
{\tt Object}.\footnote{There is a subtle difference between {\tt
    object} in BETA and {\tt Object} in Java that we will ignore in
  this paper}

{\tt\small\begin{verbatim}
   class Buffer extends Object {
     Object theElm;

     void put(Object a) {
        put I = new put();
        I.enter(a);
        I.do         
       }
     Object get() { 
        get G = new get();
        G.do();
        return G.exit();
     }

     class put {
        Object E;
        void enter(Object a) { E = a; }
        void do() { theElm = E; }
     }
     class get { 
        Object X;
        void do() { X = theElm; }
        Object exit() { return X; }
     }
   }
\end{verbatim}
}

The BETA example above of using {\rm Buffer} is straight forward to
map into the following CJ program:

{\tt\small\begin{verbatim}
   Account B;
   Person Joe = new Person();
   Object X;
   Account myAccount = new Account();
   Account S;
   B.put(myAccount);
   B.put(Joe);
   X = B.get();
\end{verbatim}
}


The pattern {\tt AccountBuffer} is mapped into the following Java class:

{\tt\small\begin{verbatim}
   class AccountBuffer extends Buffer {
   }
\end{verbatim}
}

As can bee seen, the body of the class is empty\footnote%
{This is not entirely true since the current version of JBeta
  generates dummy-methods corresponding to {\tt elm} in {\tt Buffer}}
and {\tt AccountBuffer}, the reason being that the body of the BETA
{\tt AccountBuffer} only extends the virtual pattern {\tt elm} to be
at least {\tt Account}. This extension cannot be expressed in Java.
Instead we have to make use of casts at various places.  The BETA
example of using {\tt AccountBuffer} thus maps into:

{\tt\small\begin{verbatim}
   Person Joe = new Person();
   Account myAccount = new Account();
   AccountBuffer Q;
   Account S;

   Q.put(myAccount);
   S = (Account) Q.get();    // cast
\end{verbatim}
}

Note the statement {\tt S = (Account) Q.get();} where the value
returned by {\tt Q.get()} must be casted to {\tt Account}. This cast
is superfluous since the BETA compiler knows that it will not be
needed. This can as mentioned not be expressed in Java.

\note{Covariance should be mentioned}

\subsection{Mapping {\tt  display} into CJ}
The mapping of the virtual pattern {\tt display} follow the general
scheme of mapping a nested pattern: a method and an inner class is
generatated as shown below:


{\tt\small\begin{verbatim}
   class Buffer extends Object {
     ...

     void display() {
        display D = new display();
        D.do();
      }

     class display extends Object { 
        void do() {
          System.out.println(``Buffer: ``);
          do_1();
        }
        void do_1();
     }
   }
\end{verbatim}
}
 
In {\tt AccountBuffer}, the extension of {\tt display} gives rise to a
redefinition of the {\tt display}-method and -class:

{\tt\small\begin{verbatim}
   class AccountBuffer extends Buffer {
     ...

     void display() {
        display D = new display();
        D.do();
      }

     class display extends Buffer.display { 
       void do_1() { System.out.println(theElm.balance); }
     }
   }
\end{verbatim}
}

As can be seen a new {\tt display}-class is defined in {\tt
  AccountBuffer} and this class is a subclass of the {\tt
  display}-class from {\tt Buffer}.  The {\tt display}-method
generates an instance of the {\tt display}-class from {\tt
  AccountBuffer}. In

{\tt\small\begin{verbatim}
    Buffer B = new Buffer();
    B.display;
    Buffer A = new AccountBuffer();
    A.display()
\end{verbatim}
}

{\tt B.display()} executes {\tt display} as defined in {\tt Buffer}
whereas {\tt A.display} executes {\tt display} as defined in {\tt
  AccountBuffer} according to the BETA semantics of method
combination using inner.

\subsection{Mapping nested virtual classes}
A virtual pattern may also be a nested pattern as shown in the next example:

{\tt\small\begin{verbatim}
Structure:
  (# root: @Node;
     Node:< 
       (# label: @integer;
          add:< (# N: ^Node enter N[] do inner #);
       #);
     add:
       (# V: @integer; N: ^Node
       enter V
       do &Node[] -> N[];
          V -> N.label;
          N[] -> root.add
       #) 
  #);
\end{verbatim}
}

An instance of pattern {\tt Structure} has three attributes: an
instance variables {\tt root} of type {\tt Node}, a nested virtual
pattern {\tt Node}, and an operation {\tt add} for adding a {\tt Node}
to the {\tt structure}. A {\tt Node} has two attributes: an instance
variable {\tt label} and an operation {\tt add}.

Since {\tt node} is a nested virtual pattern, {\tt Node} may be
extended in subpatterns of {\tt Structure}. Instances of {\tt Node}
will then be instances of the extended pattern. In {\tt Structure} two
instances of {\tt Node} are created: one by {\tt root: @Node} and one
in {\tt add} by the statement {\tt \&Node[] -> N[]}. These
instance will be of a possibly extension of {\tt Node}.

In pattern {\tt List}, {\tt Node} is extended with an instance
variable {\tt succ} and an extension of {\tt add}.

{\tt\small\begin{verbatim}
List: Structure 
  (# 
     Node::< 
       (# succ: ^Node;
          add::< (# ... #)
       #)
  #);
\end{verbatim}
}

If {\tt L} is a {\tt List} then {\tt L.root} and the instances created
by {\tt L.add} below are instance of the extended {\tt Node} pattern.

The extension of the virtual {\tt add} is supposed to append the
enter-argument {\tt N} to the list defined by {\tt succ}.

{\tt\small\begin{verbatim}
(# L: @List;
do (for i: 10 repeat i -> L.add for);
#)
\end{verbatim}
}

The next example shows another example of an extension of {\tt Node}
in a subpattern {\tt BinTree} of {\tt Structure}:

{\tt\small\begin{verbatim}
BinTree: Structure
  (#
     Node::< 
       (# left,right: ^Node;
          addRight: @boolean;
          add::< (# ... #);
       #)
  #)
\end{verbatim}
}

Pattern {\tt Node} is extended with instance variables {\tt left},
{\tt right} and {\tt addRight}, the latter in the extension of {\tt
  add} to alternate between adding {\tt N} to the left- or right part
of the binary tree.

The example shows how to add elements to a {\tt BinTree}.

{\tt\small\begin{verbatim}
(# T: @BinTree;
do (for i: 10 repeat i -> T.add for);
#)
\end{verbatim}
}

\subsubsection{Mapping of nested virtuals into CJ}

Pattern {\tt Structure} is mapped into the CJ class shown below. The
parts relating to the nested virtual {\tt Node}-pattern is the
method{\tt Node new\$Node()} and the inner {\tt class Node}. For
simplicity the {\tt add}-methods of {\tt Structure} are shown as
CJ-methods although they are really mapped into a method and a class:


{\tt\small\begin{verbatim}
   class Structure {
       Node root = new$Node();

       Node new$Node() { return new Node(); }

       void add(int V) {
          Node N = new$Node();
          N.label = V;
          root.add(N);
       }    
       
      class Node {
         int label;
         void add(Node N){ ... };
      }
   }
\end{verbatim}
}

Pattern {\tt List} is mapped into the following CJ class:

{\tt\small\begin{verbatim}
   class List extends Structure {

       Structure.Node new$Node() { return new Node(); }

       class Node extends Structure.Node {
          Structure.Node succ;
          void add(Structure.Node N) { ... }

       }
   }
\end{verbatim}
} 
  
\note{We use {\tt Structure.Node} above, to ensure that {\tt
    new\$Node()} is overwritten. Could we use {\tt Node} instead?
  Return type is not used to distinguish signatures?}

Here it should be noticed that a an inner class {\tt Node}
corresponding to the extension of {\tt Node} in {\tt List} is defined.
This class is a subclass of the {\tt Node} class (denoted {\tt
  Structure.Node} defined in {\tt Structure}.

Also, the method with signature {\tt Structure.Node new\$Node() } is a
redefinition of the corresponding method in {\tt Structure}. The
redefinition ensures that an instance of the {\tt List.Node} is
returned in accordance with the semantics of virtual classes.

Finally we consider the use of {\tt List}:

{\tt\small\begin{verbatim}
   List L = new List();
   for (i=0; i<=10; i++) L.add(i); 
\end{verbatim}
}

\note{Need external instances L.Node, T.Node}

\subsection{Summing up}

For a pattern: a call- and a new-method.

Also the case for a virtual pattern

For a non-nested (global), no inner class

For a nested virtual: both

Special dummy/empty cases that may be avoided

Extra casts are needed

Note, however, that how close CJ is to support virtual patterns.
Mainly a matter of the new-method and avoiding the casts.
We may simulate virtual classes by the above means.

