
\section{Evaluation}

\subsection{Language interoperability}

It is simple and straight forward to use CJ classes from BETA.  This
incluses instatiating CJ classes and and invoking methods on
CJ-objects. It is also possible to inherit from CJ classes in BETA.

To be able to use a CJ class from BETA a BETA external class
corresponding to the CJ class must be defined.  Since clr/jvm is name
\& type-based, one just need to specify the signature of the methods
that will beused from BETA.  This is much simpler than using COM where
the full interface has to be specified since the interface is based on
offsets in the vtable.  This means that all methods preeceding a used
method in the vtable must be declared.

In most cases, however, the external class may be generated from the
class-file which means that the programmer does not have to woory
about specifying the external class.

The use of BETA pattersn from CJ is just as simple and straight forward.
Classes and methdos generated from BETA may be used in CJ. This includes
inheritance from BETA classes.
A CJ programmer must of course know the mapping of BETA to CJ. Currently
there is no tool forgenerating a CJ interface to BETA. it is possible
to generated CJ code form the class-files but this is not optimal.
We discuss the mapping further below.

There are some remainingissues regarding interoperability
due to incompatibility of BETA and CJ. These are

\begin{itemize}
\item
Issues with constructors, including default constructor 
\item
BETA object requires surrounding object (origin)
\item
Overloading
\item
Issues --
Libraries and frameworks in Java/\CS\  -- 
Java-string, \CS-String, BETA-text

Automatic coercion implemented

\item
External class interface

Interface syntax needed -- currently clumsy

External name \& location

Automatic include of interface files

.NET assemblies

Java class-files
\end{itemize}

\note{A summary of the experiences with language interoperability on
  JVM/CLR}

\subsection{Quality of the mapping and changes to BETA}
Given the generality of BETA compared to CJ, we find that
the current mapping to CJ is satisfactory from a usability
point-of-view. The main nuisance is that two methods and an inner
class is generated for each pattern attribute. 

When the BETA project was initiated the main goal of unifying
abstraction mechanisms like class and method into patterns was to
obtain a uniform treatment of all abstraction mechanisms of the
language. Given a pattern abstraction it was expected that specialized
patterns for class and methods should be available.  This was termed
{\it language restriction}. However, in practice there was no real
demand/need for these special purpose abstractions. 

In the context of mapping BETA to CJ, the idea of language
restrictions have been reintroduced. It is now in fact possible to
annotate a pattern with either {\tt class} or {\tt proc} meaning that
the pattern can only be used as a class or method. For such annotated
patterns, only one method needs to be generated. And for {\tt
proc}-patterns the inner class may in fact be inlined -- the latter
optimization has not been implemented.

At this stage of the project, efficiency and optimization of the
mapping has had little attention.The first impression, however, is
that the JVM/CLR implementation results in code that is significantly
slower than the native BETA compilers. We do expect to able to improve
on parts of the implementation, but certain parts such as
leave/restart and coroutines the mapping appear to be inherently
inefficient.


\subsection{Platform issues}
\begin{itemize}
\item
No static link on stack frames
\item
Nested procedures/methods cannot be implemented using the stack
\item
Very rigid typing of class-fields 
\item
And method-locals on .NET
\item
Constructor initialization 
\item
Impossible to make setups before calling super constructor
\item
General exit out of nested method calls
\item
No support for covariant arguments
\item
No support for covariant return types
\item
Active objects
\item

.NET class references must be fully qualified, including location of binding
\item
Problems with separate compilation
\item
Large number of classes generated due to the generality of BETA patterns
\item
Java class files can only contain one (non-static) class per file 

\item
Lots of class files are generated
\item
.NET assemblies can contain any number of classes 
\item
No swap and dup\_x1/x2 on .NET
\item
Requirements for fully typed local variables in .NET. 
\item
Means that swap cannot be implemented in backend using 
local variables unless type of two top-of-stack objects are known.
\item
Type of field: super/this class

\end{itemize}

\subsection{Platform advantages}
Well-defined run-time format

More than just a calling convention for procedures

Memory management

Storage allocation

Object format \& method activation format

Garbage collection

Efficient code generation

We will have BETA for all Java- and .NET platforms

Can this be utilized efficiently?

If simple and direct mapping - yes

If complex mapping - no?

Inlining may help

Can rely on generating methods that the JIT inlines

\subsection{Conclusion}

It has been possible and in most cases straight forward to map BETA to
CJ. The main problems have been coroutines, leave/restart and nested
procedure patterns.

It has been possible to find a redable mapping to be used
by CJ programmers using BETA. 

Language incompatabilities...

The jvm/clr platforms .....

More generality of future platforms ....

But language interoperability possible to a certain degree.
However, is it just a matter of different syntax?
What is the pincipal difference between a mschineplatform
like Intel and jvm/clr?



