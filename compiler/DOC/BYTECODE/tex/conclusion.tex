
\section{Conclusion}

\subsection{Quality of the mapping and changes to BETA}
Given the generality of BETA compared to Java, we find that
the current mapping to Java is satisfactory from a usability
point-of-view. The main nuisance is that two methods and an inner
class is generated for each pattern attribute. 

When the BETA project was initiated the main goal of unifying
abstraction mechanisms like class and method into patterns was to
obtain a uniform treatment of all abstraction mechanisms of the
language. Given a pattern abstraction it was expected that specialized
patterns for class and methods should be available.  This was termed
{\it language restriction}. However, in practice there was no real
demand/need for these special purpose abstractions. 

In the context of mapping BETA to Java, the idea of language
restrictions have been reintroduced. It is now in fact possible to
annotate a pattern with either {\tt class} or {\tt proc} meaning that
the pattern can only be used as a class or method. For such annotated
patterns, only one method needs to be generated. And for {\tt
  proc}-patterns the inner class may in fact be inlined -- the latter
optimization has not been implemented.

At this stage of the project, efficiency and optimization of the
mapping has had little attention.The first impression, however, is
that the JVM/CLR implementation results in code that is significantly
slower than the native BETA compilers. We do expect to able to improve
on parts of the implementation, but certain parts such as
leave/restart and coroutines the mapping appear to be inherently
inefficient.


\subsection{Contributions} 

\subsection{Lessons Learned}

\subsection{Platform issues}
\begin{itemize}
\item
No static link on stack frames
\item
Nested procedures/methods cannot be implemented using the stack
\item
Very rigid typing of class-fields 
\item
And method-locals on .NET
\item
Constructor initialization 
\item
Impossible to make setups before calling super constructor
\item
General exit out of nested method calls
\item
No support for covariant arguments
\item
No support for covariant return types
\item
Active objects
\item

.NET class references must be fully qualified, including location of binding
\item
Problems with separate compilation
\item
Large number of classes generated due to the generality of BETA patterns
\item
Java class files can only contain one (non-static) class per file 

\item
Lots of class files are generated
\item
.NET assemblies can contain any number of classes 
\item
No swap and dup\_x1/x2 on .NET
\item
Requirements for fully typed local variables in .NET. 
\item
Means that swap cannot be implemented in backend using local variables unless type of two top-of-stack objects are known.
\item
Type of field: super/this class

\end{itemize}

\subsection{Platform advantages}
Well-defined run-time format

More than just a calling convention for procedures

Memory management

Storage allocation

Object format \& method activation format

Garbage collection

Efficient code generation

We will have BETA for all Java- and .NET platforms

Can this be utilized efficiently?

If simple and direct mapping - yes

If complex mapping - no?

Inlining may help

Can rely on generating methods that the JIT inlines

\subsection{Language interoperability}
\note{Elaborate}

Java/\CS\  class inherited from BETA

Straight forward

Since name \& type-based,
just specify the methods you will use

Simpler than for COM --
COM uses offsets

All preceding methods must be declared

BETA pattern inherited from Java/\CS\  class --
Also straight forward

Issues with default constructor 

BETA object requires surrounding object (origin)

Issues --
Libraries and frameworks in Java/\CS\  -- 
Java-string, \CS-String, BETA-text

Automatic coercion implemented

Overloading

Constructors

External class interface

Interface syntax needed -- currently clumsy

External name \& location

Automatic include of interface files

.NET assemblies

Java class-files


\note{A summary of the experiences with language interoperability on
  JVM/CLR}
