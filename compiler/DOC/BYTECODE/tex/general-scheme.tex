
\section{The general scheme for mapping a pattern}
\note{Consider skipping this part -- is very sketchy}

Consider a pattern with nested patterns:
{\tt\small\begin{verbatim}
   Foo:
      (# ...
         f1: (# ... enter N1 do ... exit X1 #);
         f2: (# ... enter N2 do ... exit X2 #);
         f3: (# ... enter N3 do ... exit X3 #);
      enter N
      do ...
      exit X
      #)
\end{verbatim}
}
\note{We still need to introduce the new-method}

Pattern {\tt Foo} is mapped into the following class:
{\tt\small\begin{verbatim}
   class Foo extends Object {
      ...
      sX1 f1(sN1) { ... } // call-method for f1
      f1 new$f1() { ... } // new-method for f1

      sX2 f2(sN2) { ... } // call-method for f2
      f2 new$f2() { ... } // new-method for f2

      sX3 f3(sN3) { ... } // call-method for f3
      f3 new$f3() { ... } // new-method for f2

      void enter(sN) { ... }
      void do() { ... }
      sX exit() { ... }

      class f1 extends Object { ... }
      class f2 extends Object { ... }
      class f3 extends Object { ... }
   }
\end{verbatim}
}

\noindent
where {\tt sX1}, {\tt sN1}, \ldots, {\tt sN}, and {\tt sX} are the
signatures corresponding to {\tt X1},{\tt N2}, \ldots {\tt N}, and {\tt
  X} respectively.
