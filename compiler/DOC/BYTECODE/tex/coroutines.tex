
\section{Coroutines, concurrency and synchronization}
BETA has semi-coroutines in the style of Simula. BETA coroutines may
be executed in the usual non-premptive way as known from Simula but
also in concurrency with preemptive scheduling.  For synchronization
of concurrent coroutines, a {\tt Semaphore} pattern is avaliable to
express synchronization at the basic level. The BETA mechanisms for
coroutines, concurrency and synchronization are at a much more
primitive level than in CJ. However, the abstraction mechanisms of
BETA makes it easy to build higher-level concurrency mechanisms such
as monitor and Ada-like rendezvous. The BETA libraries include a
number of such concurrency abstractions.
  
Since CJ does not support Simula-style coroutines, there is no direct
way of mapping BETA coroutines to CJ. Instead BETA coroutines are
implemented in CJ by means of threads. This results in a considerable
overhead -- basically a coroutine shift is much simpler than a thread
shift. 

In the following a brief introduction to Simula-like semi-coroutines
is given followed by a description of the implementation in CJ.  The
implementation is heavily inspired by \cite{helsgaun}.

\subsection{Semi-coroutines}
In this section the notion of a semi-coroutine is described as an
extension ot CJ.  The basic functionality of a coroutine is defined in
a class {\tt Coroutine} -- similar to class {\tt Thread} for
implementing threads.  Class {\tt Coroutine} has the following
structure:

{\tt\small\begin{verbatim}
   class Coroutine {
     ...
     void call() { ... }
     void suspend() { ... }
     abstract void Do(); // abstract
   }
\end{verbatim}
}
\noindent
\begin{itemize}
\item A {\tt Coroutine} has a special method {\tt Do} which defines
  the main action-part of the coroutine -- similar to the {\tt
  run}-method for {\tt Thread}.
  
\item A concrete coroutine is defined as a subclass of {\tt Coroutine}
  including a redefinition of the {\tt Do}-method.
  
\item If {\tt S} is a reference to a {\tt Coroutine}, then {\tt
    S.call()} will invove the {\tt Do}-method of {\tt S}.
  
\item Execution of a {\tt suspend} in the {\tt S.Do()} (or methods
  invoked from {\tt S.do()}) will return to the point of {\tt S.call()}
    and resume execution after {\tt S.call()}.

\end{itemize}

A semi-coroutine is a simple form of thread. Each coroutine is a
thread of method activitations, but at most one coroutine is executing
at a given point in time.  In a situation we concurrent threads, each
such thread may contain coroutines. In this paper, we assume that a
program contains at most one thread.

In the following, an example of a CJ program using coroutines is
shown.  The example includes two generators of integers. The first
generator is defined by class {\tt Adder} below. The constructor of an
{\tt Adder}-object has a start value and a max value. For each
activation ({\tt call}) of an {\tt Adder}-object, a new value is
generated and returned by means of the attribute {\tt res}. The new
value is computed by doubling the previous value.  The value is
computed recursively by means of {\tt compute}. When a new value has
been computed, {\tt compute} executes a {\tt susend}. At subsequent
calls, {\tt compute} is called recursively to compute the next value.

{\tt\small\begin{verbatim}
   class Adder extends Coroutine {
      public int res;
      int start, max;
      public Adder(int s, int m) { 
         start = s; max = m; 
      }
      void compute(int V) {
         res = V+V;
         A1: 
         suspend();
         A2:
         if (V < max) compute(V+1);
      }
      public void Do() { compute(start); }
   }
\end{verbatim}
}

\noindent 
Class {\tt Multiplier} is similar to class {\tt Adder}. The only
difference is that the next value is computed by multiplying the
previous value by itself.

{\tt\small\begin{verbatim}

   class Multiplier extends Coroutine {
      public int res;
      int start, max;
      public Multiplier(int s, int m) { 
         start = s; max = m; 
      }
      void compute(int V){
         res = V*V;
         M: 
         suspend();
         if (V < max) compute(V+1);
      }
      public void Do() { compute(start); }
   }
\end{verbatim}
}

\noindent Class {\tt Merger} creates an instance of {\tt Adder}
and one of {\tt Multiplier}. It then prints the values generated by
the two objects in ascending order:
\begin{itemize}
\item
The two first values are produced by executing {\tt A-call()} and {\tt
M.call()}.
\item
The two values are then compared ( {\tt A.res < M.res}) and the
smallest one is printed.
\item
If {\tt A.res} is smallest, the next valeu from {\tt A} is generated
by executing {\tt A.call}.
\item
If {\tt M.res} is smallest, the next value of {\tt M} is generated by
executing {\tt M.call}.
\item 
This process continues until seven values have been printed.  We have
ignored the details of a resonable termination process.
\end{itemize}


{\tt\small\begin{verbatim}
   class Merger extends Coroutine {
      Adder A = new Adder(3,6);
      Multiplier M = new Multiplier(2,5);
      public void Do() {
         int i;
         L1:
         A.call();
         L2:
         M.call();
         L3:
         for (i=0; i<6; i++){
            if (A.res < M.res) {
                System.out.println("A: " + A.res);
                L5:
                A.call();
            }
            else {
                System.out.println("M: " + M.res);
                M.call();
                L6:
            }
        }
      }      
      public static void main(String args[]) {
         Merger merger = new Merger();
         merger.call();
      }
   }
\end{verbatim}
}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1.2\textwidth]{Coroutines.pdf}
    \caption{Execution states of Merger coroutines}
    \label{coroutine}
  \end{center}
\end{figure}


In figure \ref{coroutine} is shown six snapshots of the execution states
of the Merger example.

\begin{itemize}
\item The round square boxes illustrate {\tt Coroutine}-objects.
\item The oval boxes illustrate method invocations.
\item The arrows illustrate {\it caller-links} showing the calling
  structure of method invocations, i.e. the method invocation stack.
\item Figure (a) shows the initial situation during execution of {\tt
  merger.call()} in {\tt main} at the beginning of {\tt merger.Do}.
  \begin{itemize}
  \item The coroutines {\tt A} and {\tt M} have been generated.
  \item
    By convention, a coroutine associated with a running thread is
    marked by a {\tt *}. In this example the {\tt merger}-coroutine is
    associated with a a running thread. The caller-link of the active
    coroutine refers to the method currently being executed. In (a),
    {\tt merger*} refers to the {\tt Do}-method which is currently
    executing.
  \item For suspended coroutines, the caller-link refers to the top
    element of the execution stack of the coroutine. In the initial
    situation after a coroutine has been generated, the caller-link
    refers to the coroutine object. This is the situation in figure
    (a) where the caller-link of {\tt A} and {\tt M} refers to the
    {\tt A}- and {\tt M}-objects respectively.
  \end{itemize}
\item Figure (b) shows the situation where the first {\tt A.call()} in
  {\tt merger.Do} is being executed. This implies that the {\tt
  A}-coroutine is executed by {\tt merger}. Execution of {\tt
  merger} implies that the {\tt Do}-method of {\tt A} is invoked.
  The {\tt Do}-method then calls {\tt compute}. The snapshot is at the
  label {\tt A1:} just before {\tt suspend} in this first invocation of
  {\tt compute}.

\item Figure (c) shows the situation after execution of {\tt suspend}
  in {\tt A} at the label {\tt L3:} in {\tt merger.Do}.  Execution of
  {\tt suspend} in {\tt A} implies that execution of {\tt A} is
  suspended.  In a suspended coroutine, the caller-reference of the
  coroutine ({\tt A} in this example) refers the top element of the
  execution stack of the coroutine -- {\tt compute} in this example.
\item Figure (d) shows the situation where the {\tt M.call()} after
  the label {\tt L3:} has been executed by {\tt merger}. This implies
  an execution of {\tt M} leading to a similar situation for {\tt M}
  as the one described for {\tt A} in (b). The snapshot is at the
  label {\tt M:} in {\tt M.compute}.
\item Figure (e) shows the situation at {\tt L4:} in {\tt merger} where
  {\tt A} and {\tt M} both are suspended. 
\item Figure (f) shows the situation after a subsequent call of {\tt
   A} has been executed leading to a second invocation of {\tt
   compute}.
\end{itemize}


\subsection{Implementation of class {\tt Coroutine}}
Class {\tt Coroutine} is implemented by means of a class {\tt Component}
as shown in the following example:

{\tt\small\begin{verbatim}
   class Coroutine {
     private Component thisC = new Component(this);

     void call() { thisC.swap(); }
     void suspend() { thisC.swap(); }
     abstract void Do(); 
   }
\end{verbatim}
}
\noindent
As can be seen, the implementation of {\tt call} and {\tt suspend} is
identical and the magic is in the {\tt swap}-method.

A coroutine shift (call or suspend) is basically just a {\it swap} of
two references. This is illustrated in Figure \ref{swap}.
\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1.2\textwidth]{Coroutines-2.pdf}
    \caption{Illustration of the call and suspend}
    \label{swap}
  \end{center}
\end{figure}

\begin{itemize}
\item The transition from (a) to (b) illustrates a suspend of {\tt M}.
   In (a) there is a caller-link from the object {\tt M} to the method
   invocation {\tt merger.Do} and a caller-link from the object {\tt
   merger*} to the method invocation {\tt M.compute}. Execution of
   suspend implies that these two links are swapped. The result may be
   seen in part (b) of the figure.

\item The transition from (c) to (d) illustrates a call of {\tt A}.
  In (e) there are caller-links from {\tt merger*} to {\tt merger.do}
  and from {\tt A} to {\tt A.compute}. Execution of {\tt A.call()}
  implies that these two links are swapped. The result may be seen on
  part (d) of the figure.

\end{itemize}
\noindent 
As can be seen it is pretty simple to implement coroutines. All that
is needed is a caller-link to implement the call-stack and a simple
swap-operation.  The caller-link corresponds to the return link of a
usual method invocation stack. The BETA-implementation of coroutines
is implemented this way. Unfortunately the situation i CJ is a bit
more complicated since we have to get around the CJ-run time structure
and thread mechanism. This is further described in the next section.

The notion of semi-coroutine originates from Simula, which also
includes the original Conway-style of symmetric coroutine
\cite{conway}. The coroutine model based on swap originates from Dahl
\&\ and Wang \cite{dw}. BETA has adapted the semi-coroutine model as
described in \cite{betabook}, chapter xx where it is also described
how to implement symmetric coroutines using semi-coroutines.


\subsection{Class {\tt Component}}
In this section we describe the details of the cortoutine implementation
in CJ. 
Class {\tt Component} is as mentioned implemented using threads and
could be defined as a subclass of class {\tt Thread}. For reasons of
efficiency -- see later -- the thread-part of a {\tt Component} is
defined in an associated {\tt Runner}-object. Class {\tt Runner} is a
subclass of class {\tt Thread}. Class {\tt Component} has the
following structure:

{\tt\small\begin{verbatim}
   class Component {
      static Component current;     // The current executing Component
      private Component caller;     // The calling Component
      
      private Runner myRunner;      // the associated Thread
      private Coroutine body;       // The actual Coroutine
      private boolean isTerminated; // True if terminated
      
      public Component(Coroutine b) {
         body = b;
         caller = this;
         myRunner = new Runner(this);
      }

      public void swap() {
         Component old_current = current;
         current = caller;
         caller = old_current;

         synchronized(old_current.myRunner) {
            current.myRunner.go();
            if (old_current.isTerminated) {
               return;
            } else {
              try{ old_current.myRunner.wait(); }
              catch (InterruptedException e) {}
            }
         }         
      }
   }
\end{verbatim}
}
\noindent
The current active Component of the coroutine-system is represented by
the static field {\tt current}.

When an instance of {\tt Component} is created the constructor sets up
the initial situation where:

\begin{itemize}
\item
The {\tt body}-field refers the {\tt Corutine}-object, implemented by
this {\tt Component}
\item 
The {\tt caller}-field refers to this {\tt Component}
\item 
A {\tt Runner}-object is created and assigned to {\tt myRunner}.
\end{itemize}
\noindent
When a {\tt call} or {\tt suspend} is executed by a {\tt Coroutine}
the {\tt swap}-method of the associated {\tt Component} is executed.
\begin{itemize}
\item The first part of {\tt swap} implements a swap of {\tt current}
and {\tt caller} as described above. ...
\item Then swap invokes {\tt current.myRunner.go()} which starts the
Thread if this is the first call of swap/call. Otherwise it resumes
execution of the new active {\tt Component} -- the one referred by
current. Since {\tt swap} implements {\tt call} as well as {\tt
suspend} there are basically two situations:
\begin{itemize}
\item {\bf call}: If {\tt current} has not been called before, the {\tt
Do}-method of the associated {\tt Coroutine} is executed. If {\tt
current} has been called before, it has executed a {\tt suspend},
execution is resumed after this {\tt suspend}.
\item {\bf suspend}: Execution is resumed after the invocation of {\tt
call}.
\end{itemize}
\end{itemize}

Below is shown the implementation of class {\tt Runner}.


{\tt\small\begin{verbatim}
   class Runner extends Thread {
      Component myComponent;

      Runner(Component C) { myComponent = C; }

      public void run() {
         myComponent.body.Do(); // Run Do-method of Coroutine
         
         // Terminate this Component
         myComponent.isTerminated = true;
         myComponent.swap();
      }   

      public void go() {
        if !isAlive() { start(); }
        else {
           synchronized(this) {notify();};
        }
      }
   }
\end{verbatim}
}

\note{Diagram and sequence diagram to illustrate call and suspend}
\subsection{Mapping BETA coroutine}
Using class Component above, it is pretty straight forward to
implement BETA's coroutines.

BETA has a toplevel pattern called {\tt Object}, which in CJ is mapped
to class {\tt BetaObject}. Class {\tt BetaObject} has a field {\tt
comp\$} referring an associated {\tt Component}.


{\tt\small\begin{verbatim}
   class BetaObject {
      Component comp$
   }
\end{verbatim}
}

\noindent
Consider the following example of a BETA coroutine:

{\tt\small\begin{verbatim}
   MyCo:
      (# foo:
          (#
          do ...; suspend; ...
          #)
      do ...; foo; ...
      #);
    M: ^| MyCo;
 
    &|MyCo[] -> M[];
    L: M;     (* a call of M *)
\end{verbatim}
}
\noindent
The {\tt |} in {\tt M: \^| MyCo} specifies that {\tt M} is a
reference to a coroutine of type {\tt MyCo}. Similarly, the {\tt |} in
{\tt \&MyCo} specifies that a coroutine instance of {\tt MyCo} is
generated.

A coroutine call in BETA has the same syntax as invoking an object. A
call of {\tt M }takes place at the label {\tt L}.

A BETA coroutine is mapped into CJ in the following way:

\begin{itemize}
\item {\bf Generation}. When an instance of a coroutine is generated,
a corresponding instance of {\tt Component} is generated and assigned
to the {\tt comp\$}-field. 
\item {\bf Call.} A call {\tt M} is mapped into {\tt M.comp\$.swap()}.
\item {\bf Suspend.} A suspend executed by {\tt M} is similarly mapped
into {\tt comp\$.swap()}.
\end{itemize}

\note{Perhaps a figure showing M and a reference to the associated Component}

\note{Check this}

\subsection{Remaining details of the implementation}
As mentioned the mapping of coroutines is heavily inspired by
\cite{helsgaun}, which describes a complete implentation of both
semi-coroutines and symmetric coroutines from Simula.  Since BETA
coroutines are simpler than Simula coroutines the mapping to CJ is
aslo simpler than the one described in \cite{helsgaun}.  Following
\cite{helsgaun} the actual implementation of coroutines is 
further refined as described below:

\begin{itemize}
\item A Java program does not terminate as long as there are active
threads. When a BETA program terminates, there may be suspended
coroutines that have not terminated. To handle this the statement {\tt
SetDaemon(true)} is called for each Runner to indicate that the
program may terminate even if the Runner has not terminated.  \CS?

\item In the above implementation a new {\tt Thread} is generated
whenever a new {\tt Coroutine} is generated.  Thread allocation is
very expensive in Java. In a some Simula and BETA program a large
number of coroutines may be allocated duringa program execution. Often
only a few of these are alive at a given point in time.  For this
reason it improves efficiency to keep a pool of Threads.

\end{itemize}


As mentioned a terminated BETA program may generate a large number
of coroutines. In BETA, a coroutine is alive as long as there
is a reference to it form a live object. When a coroutine
cannot be reached from a live object, it may be garbage collected.

This is however a problem in in the Java implementation. Even if a
BETA coroutine is not reachable from an active object it is reacheable
form the associated {\tt Runner/Thread}. And since non-terminated
threads are roots for the garbage collector in Java, these coroutines
and associated {\tt Runner}-objects are never garbage collected. This
is currently and unsolved problem for Java.

For \CS?

The complete implementation of class {\tt Component} and {\tt Runner}
is shown in the appendix.
