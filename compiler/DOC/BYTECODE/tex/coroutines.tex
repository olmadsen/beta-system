
\section{Coroutines, concurrency and synchronization}
BETA has semi-coroutines in the style of Simula. BETA coroutines may be
executed in the usual non-premptive way as known form Simula but
also in concurrency with preemptive scheduling.  For synchronization
of concurrent coroutines, a {\tt Semaphore} pattern is avaliable to
express synchronization at the basic level. The BETA mechanism for
coroutines, concurrency and synchronization are at a much more
primitive level than in CJ. However, the powerful abstraction
mechanisms of BETA makes it easy to build higher-level concurrency
mechanisms such as monitors and Ada-like rendezvous and the BETA
libraries include a number of such concurrency abstractions.
  
The basic coroutines can be implemented in CJ using Threads, but this
requires considerable overhead -- basically a coroutine shift is much
simpler than a thread shift. The coroutine implementation in CLR/JVM
is probably the part of BETA that does not map very well. Space does
not allow to give the details of the coroutine implementation, which
is heavily inspired by \cite{helsgaun}.

\subsection{Quality of the mapping and changes to BETA}
Given the generality of BETA compared to Java, we find that
the current mapping to Java is satisfactory from a usability
point-of-view. The main nuisance is that two methods and an inner
class is generated for each pattern attribute. 

When the BETA project was initiated the main goal of unifying
abstraction mechanisms like class and method into patterns was to
obtain a uniform treatment of all abstraction mechanisms of the
language. Given a pattern abstraction it was expected that specialized
patterns for class and methods should be available.  This was termed
{\it language restriction}. However, in practice there was no real
demand/need for these special purpose abstractions. 

In the context of mapping BETA to Java, the idea of language
restrictions have been reintroduced. It is now in fact possible to
annotate a pattern with either {\tt class} or {\tt proc} meaning that
the pattern can only be used as a class or method. For such annotated
patterns, only one method needs to be generated. And for {\tt
  proc}-patterns the inner class may in fact be inlined -- the latter
optimization has not been implemented.

At this stage of the project, efficiency and optimization of the
mapping has had little attention.The first impression, however, is
that the JVM/CLR implementation results in code that is significantly
slower than the native BETA compilers. We do expect to able to improve
on parts of the implementation, but certain parts such as
leave/restart and coroutines the mapping appear to be inherently
inefficient.

