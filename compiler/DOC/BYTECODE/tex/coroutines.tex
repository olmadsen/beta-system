
\section{Coroutines, concurrency and synchronization}
BETA has semi-coroutines in the style of Simula. BETA coroutines may
be executed in the usual non-premptive way as known from Simula but
also in concurrency with preemptive scheduling.  For synchronization
of concurrent coroutines, a {\tt Semaphore} pattern is avaliable to
express synchronization at the basic level. The BETA mechanisms for
coroutines, concurrency and synchronization are at a much more
primitive level than in CJ. However, the abstraction mechanisms of
BETA makes it easy to build higher-level concurrency mechanisms such
as monitor and Ada-like rendezvous. The BETA libraries include a
number of such concurrency abstractions.
  
Since CJ does not support Simula-style coroutines, there is no direct
way of mapping BETA coroutines to CJ. Instead BETA coroutines are
implemented in CJ by means of threads. This results in a considerable
overhead -- basically a coroutine shift is much simpler than a thread
shift. The coroutine implementation in CLR/JVM is probably the part of
BETA that does not map very well.

In the following a brief introduction to Simula-like semi-coroutines
is given followed by a description of the implementation in CJ.  The
implementation is heavily inspired by \cite{helsgaun}.

\subsection{Semi-coroutines}
In this section the notion of a semi-coroutine is described as an
extension ot CJ.  The basic functionality of a coroutine is defined in
a class {\tt Coroutine} -- similar to class {\tt Thread} for
implementing threads.  Class {\tt Coroutine} has the following
structure:

{\tt\small\begin{verbatim}
   class Coroutine {
     ...
     void call() { ... }
     void suspend() { ... }
     void Do(); // abstract
   }
\end{verbatim}
}
\noindent
\begin{itemize}
\item A {\tt Coroutine} has a special method {\tt Do} which defines
  the main action-part of the coroutine -- similar to the run-method
  for {\tt Thread}.
  
\item A concrete coroutine is defined as a subclass of {\tt Coroutine}
  including a redefinition of the {\tt Do}-method.
  
\item If {\tt S} is a reference to a {\tt Coroutine}, then {\tt
    S.call} will invove the {\tt Do}-method of {\tt S}.
  
\item Execution of a {\tt suspend} in the {\tt S.Do()} (or methods
  invoked from {\tt S.do()}) will return to the point of {\tt S.call()}
    and resume execution after {\tt S.call()}.

\end{itemize}

A semi-coroutine is a simple form of thread. Each coroutine is a
thread of method activitations, but at most one coroutine is executing
at a given point in time.

If more than one thread is executing concurrenly, each thread may
contain coroutines. 

\note{Clarify this; perhaps assume only one thread and say that in a
  multi-thread situation there are a number of alternatives for
  defining the behavior of coroutines}

The following is an example of a program in CJ using coroutines:

{\tt\small\begin{verbatim}
   class Co1 extends Coroutine {
   
      void Do() { ... }
      void foo1() { ... }
   }

   class Co2 extends Coroutine {
   
      void Do() { ... }
      void foo2() { ... }
   }

   class Co extends Coroutine {

      static void main(String args[]) {
         Co C = new Co();
         C.call();
         ...
      }
   }

\end{verbatim}
}

\note{Elaborate -- meaningful example is needed}

\note{Graphic example showing coroutine shifts. X.1: call; X.2: suspend}

\subsection{Implementation of class {\tt Coroutine}}

BETA coroutines are implemented by means of a class {\tt Component},
which also can be used to implement class {\tt Coroutine}.  The
example of class {\tt Coroutine} is shown in the next example:

{\tt\small\begin{verbatim}
   class Coroutine {
     private Component thisC = new Component(this);

     void call() { thisC.swap(); }
     void suspend() { thisC.swap(); }
     void Do(); // abstract
   }
\end{verbatim}
}
\noindent
As can be seen, the implementation of {\tt call} and {\tt suspend} is
identical and the magic is in the {\tt swap}-method.

A coroutine shift (call or suspend) is basically just a {\it swap} of
two references. 

Consider figure X.1 illustrating a call. As can be seen the active
reference and the caller reference of S are swapped.  Consider figure
X.2 illustrating a suspend. As can be seen the active reference and
the caller reference of S are swapped.  In both cases there is a swap
of two references.

The notion of semi-coroutine originates from Simula, which also
includes the original Conway-style of symmetric coroutine
\cite{conway}. The coroutine model based on swap originates from Dahl
\&\ and Wang \cite{dw}. BETA has adapted the semi-coroutine model as
described in \cite{betabook}, chapter xx where it is also described
how to implement symmetric coroutines using semi-coroutines.


\subsection{Class {\tt Component}}
Class {\tt Component} is as mentioned implemented using threads and
could be defined as a subclass of class {\tt Thread}. For reasons of
efficiency -- see later -- the thread-part of a {\tt Component} is
defined in an associated {\tt Runner}-object. Class {\tt Runner} is a
subclass of class {\tt Thread}. Class {\tt Component} has the
following structure:

{\tt\small\begin{verbatim}
   class Component {
      static Component current;     // The current executing Component
      private Component caller;     // The calling Component
      
      private Runner myRunner;      // the associated Runner
      private Coroutine body;       // The actual Coroutine
      private boolean isTerminated; // True if terminated
      
      public Component(Coroutine b) {
         body = b;
         caller = this;
         myRunner = new Runner(this);
      }

      public void swap() {
         Component old_current = current;
         current = caller;
         caller = old_current;

         synchronized(old_current.myRunner) {
            current.myRunner.go();
            if (old_current.isTerminated) {
               return;
            } else {
              try{ old_current.myRunner.wait(); }
              catch (InterruptedException e) {}
            }
         }         
      }
   }
\end{verbatim}
}
\noindent
The current active Component of the coroutine-system is represented by
the static field {\tt current}.

When an instance of {\tt Component} is created the constructor sets up
the initial situation where:

\begin{itemize}
\item
The {\tt body}-field refers the {\tt Corutine}-object, implemented by
this {\tt Component}
\item 
The {\tt caller}-field refers to this {\tt Component}
\item 
A {\tt Runner}-object is created and assigned to {\tt myRunner}.
\end{itemize}
\noindent
When a {\tt call} or {\tt suspend} is executed by a {\tt Coroutine}
the {\tt swap}-method of the associated {\tt Component} is executed.
\begin{itemize}
\item The first part of {\tt swap} implements a swap of {\tt current}
and {\tt caller} as described above. ...
\item Then swap invokes {\tt current.myRunner.go()} which starts the
Thread if this is the first call of swap/call. Otherwise it resumes
execution of the new active {\tt Component} -- the one referred by
current. Since {\tt swap} implements {\tt call} as well as {\tt
suspend} there are basically two situations:
\begin{itemize}
\item {\bf call}: If {\tt current} has not been called before, the {\tt
Do}-method of the associated {\tt Coroutine} is executed. If {\tt
current} has been called before, it has executed a {\tt suspend},
execution is resumed after this {\tt suspend}.
\item {\bf suspend}: Execution is resumed after the invocation of {\tt
call}.
\end{itemize}
\end{itemize}

Below is shown the implementation of class {\tt Runner}.


{\tt\small\begin{verbatim}
   class Runner extends Thread {
      Component myComponent;

      Runner(Component C) { myComponent = C; }

      public void run() {
         myComponent.body.Do(); // Run Do-method of Coroutine
         
         // Terminate this Component
         myComponent.isTerminated = true;
         myComponent.swap();
      }   

      public void go() {
        if !isAlive() { start(); }
        else {
           synchronized(this) {notify();};
        }
      }
   }
\end{verbatim}
}

\note{Diagram and sequence diagram to illustrate call and suspend}
\subsection{Mapping BETA coroutine}
Using class Component above, it is pretty straight forward to
implement BETA's coroutines.

BETA has a toplevel pattern called {\tt Object}, which in CJ is mapped
to class {\tt BetaObject}. Class {\tt BetaObject} has a field {\tt
comp\$} referring an associated {\tt Component}.


{\tt\small\begin{verbatim}
   class BetaObject {
      Component comp$
   }
\end{verbatim}
}

\noindent
Consider the following example of a BETA coroutine:

{\tt\small\begin{verbatim}
   MyCo:
      (# foo:
          (#
          do ...; suspend; ...
          #)
      do ...; foo; ...
      #);
    M: ^| MyCo;
 
    &|MyCo[] -> M[];
    L: M;     (* a call of M *)
\end{verbatim}
}
\noindent
The {\tt |} in {\tt M: \^| MyCo} specifies that {\tt M} is a reference
to a coroutine of type {\tt MyCo}. Similarly, the {\tt |} in {\tt
\&MyCo} specifies that a coroutine instance of {\tt MyCo} is
generated.

A coroutine call in BETA has the same syntax as invoking an object. A
call of {\tt M }takes place at the label {\tt L}.

A BETA coroutine is mapped into CJ in the following way:

\begin{itemize}
\item {\bf Generation}. When an instance of a coroutine is generated,
a corresponding instance of {\tt Component} is generated and assigned
to the {\tt comp\$}-field. 
\item {\bf Call.} A call {\tt M} is mapped into {\tt M.comp\$.swap()}.
\item {\bf Suspend.} A suspend executed by {\tt M} is similarly mapped
into {\tt comp\$.swap()}.
\end{itemize}

\note{Perhaps a figure showing M and a reference to the associated Component}

\note{Check this}

\subsection{Remaining details of the implementation}
As mentioned the mapping of coroutines is heavily inspired by
\cite{helsgaun}, which describes a complete implentation of both
semi-coroutines and symmetric coroutines from Simula.  Since BETA
coroutines are simpler than Simula coroutines the mapping to CJ is
aslo simpler than the one described in \cite{helsgaun}.  Following
\cite{helsgaun} the actual implementation of coroutines is 
further refined as described below:

\begin{itemize}
\item A Java program does not terminate as long as there are active
threads. When a BETA program terminates, there may be suspended
coroutines that have not terminated. To handle this the statement {\tt
SetDaemon(true)} is called for each Runner to indicate that the
program may terminate even if the Runner has not terminated.  \CS?

\item In the above implementation a new {\tt Thread} is generated
whenever a new {\tt Coroutine} is generated.  Thread allocation is
very expensive in Java. In a some Simula and BETA program a large
number of coroutines may be allocated duringa program execution. Often
only a few of these are alive at a given point in time.  For this
reason it improves efficiency to keep a pool of Threads.

\end{itemize}


As mentioned a terminated BETA program may generate a large number
of coroutines. In BETA, a coroutine is alive as long as there
is a reference to it form a live object. When a coroutine
cannot be reached from a live object, it may be garbage collected.

This is however a problem in in the Java implementation. Even if a
BETA coroutine is not reachable from an active object it is reacheable
form the associated {\tt Runner/Thread}. And since non-terminated
threads are roots for the garbage collector in Java, these coroutines
and associated {\tt Runner}-objects are never garbage collected. This
is currently and unsolved problem for Java.

For \CS?

The complete implementation of class {\tt Component} and {\tt Runner}
is shown in the appendix.
