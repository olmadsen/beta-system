
\section{Coroutines, concurrency and synchronization}
BETA has semi-coroutines in the style of Simula. BETA coroutines may
be executed in the usual non-premptive way as known from Simula but
also in concurrency with preemptive scheduling.  For synchronization
of concurrent coroutines, a {\tt Semaphore} pattern is avaliable to
express synchronization at the basic level. The BETA mechanisms for
coroutines, concurrency and synchronization are at a much more
primitive level than in CJ. However, the abstraction mechanisms of
BETA makes it easy to build higher-level concurrency mechanisms such
as monitor and Ada-like rendezvous. The BETA libraries include a
number of such concurrency abstractions. See \cite{betabook}
for examples of how to define such abstractions.
  
Since CJ does not support Simula-style coroutines, there is no direct
way of mapping BETA coroutines to CJ. Instead BETA coroutines are
implemented in CJ by means of threads. This results in a considerable
overhead -- basically a coroutine shift is much simpler than a thread
shift. 

In the following a brief introduction to Simula-like semi-coroutines
is given followed by a description of the implementation in CJ.  The
implementation is heavily inspired by \cite{helsgaun}.

\subsection{Semi-coroutines}
In this section the notion of a semi-coroutine is described as an
extension of CJ.  The basic functionality of a coroutine is defined in
a class {\tt Coroutine} -- similar to class {\tt Thread} for
implementing threads.  Class {\tt Coroutine} has the following
structure:

{\tt\small\begin{verbatim}
   class Coroutine {
     ...
     void call() { ... }
     void suspend() { ... }
     abstract void Do(); // abstract
   }
\end{verbatim}
}
\noindent
\begin{itemize}
\item A {\tt Coroutine} has a special method {\tt Do} which defines
  the main action-part of the coroutine -- similar to the {\tt
  run}-method for {\tt Thread}.
  
\item A concrete coroutine is defined as a subclass of {\tt Coroutine}
  including a redefinition of the {\tt Do}-method.
  
\item If {\tt S} is a reference to a {\tt Coroutine}, then {\tt
    S.call()} will invoke the {\tt Do}-method of {\tt S}.
  
\item Execution of a {\tt suspend} in the {\tt S.Do()} (or methods
  invoked from {\tt S.do()}) will return to the point of {\tt S.call()}
    and resume execution after {\tt S.call()}.

\end{itemize}

A semi-coroutine is a simple form of thread. Each coroutine is a
thread of method activitations, but at most one coroutine is executing
at a given point in time.  In a situation with concurrent threads, each
such thread may contain coroutines. In this paper, we assume that a
program contains at most one thread.

In the following, an example of a CJ program using coroutines is
shown.  The example includes two generators of integers. The first
generator is defined by class {\tt Adder} below. The constructor of an
{\tt Adder}-object takes a start value. For each
activation ({\tt call}) of an {\tt Adder}-object, a new value is
generated and returned by means of the attribute {\tt res}. The values
computed are the sequence {\tt 2 * start}, {\tt 2 * (start+1)}, ...
The value is computed recursively by means of {\tt compute}. When a
new value has been computed, {\tt compute} executes a {\tt suspend}. At
subsequent calls, {\tt compute} is called recursively to compute the
next value.

{\tt\small\begin{verbatim}
   class Adder extends Coroutine {
      public int res;
      int start;
      public Adder(int s) { start = s; }
      void compute(int V) {
         res = 2 * V;
         A1: 
         suspend();
         A2:
         compute(V+1);
      }
      public void Do() { compute(start); }
   }
\end{verbatim}}

\noindent 
Class {\tt Multiplier} is similar to class {\tt Adder}. The only
difference is that the values computed are {\tt start * start}, {\tt
(start+1) * (start+1)}, ...

{\tt\small\begin{verbatim}
   class Multiplier extends Coroutine {
      public int res;
      int start;
      public Multiplier(int s) { start = s; }
      void compute(int V){
         res = V*V;
         M: 
         suspend();
         compute(V+1);
      }
      public void Do() { compute(start); }
   }
\end{verbatim}}

\noindent 
Class {\tt Merger} creates an instance of {\tt Adder} and one of {\tt
Multiplier}. It then prints the values generated by the two objects in
ascending order:
\begin{itemize}
\item
The two first values are produced by executing {\tt A.call()} and {\tt
M.call()}.
\item
The two values are then compared ( {\tt A.res < M.res}) and the
smallest one is printed.
\item
If {\tt A.res} is smallest, the next value from {\tt A} is generated
by executing {\tt A.call}.
\item
If {\tt M.res} is smallest, the next value from {\tt M} is generated by
executing {\tt M.call}.
\item 
This process continues until seven values have been printed.  
\end{itemize}


{\tt\small\begin{verbatim}
   class Merger extends Coroutine {
      Adder A = new Adder(3);
      Multiplier M = new Multiplier(2);
      public void Do() {
         int i;
         L1:
         A.call();
         L2:
         M.call();
         L3:
         for (i=0; i<6; i++){
            if (A.res < M.res) {
                System.out.println("A: " + A.res);
                A.call();
            }
            else {
                System.out.println("M: " + M.res);
                M.call();
            }
        }
      }      
      public static void main(String args[]) {
         Merger merger = new Merger();
         merger.call();
      }
   }
\end{verbatim}
}

\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1.2\textwidth]{Coroutines.pdf}
    \caption{Execution states of Merger coroutines}
    \label{coroutine}
  \end{center}
\end{figure}


In figure \ref{coroutine} is shown six snapshots of the execution states
of the Merger example.

\begin{itemize}
\item The round square boxes illustrate {\tt Coroutine}-objects.
\item The oval boxes illustrate method invocations.
\item The arrows illustrate {\it caller-links} showing the calling
  structure of method invocations, i.e. the method invocation stack.
\item Figure (a) shows the initial situation during execution of {\tt
  merger.call()} in {\tt main} at the label {\tt L1:} of {\tt
  merger.Do}.
  \begin{itemize}
  \item The coroutines {\tt A} and {\tt M} have been generated.
  \item
    By convention, a coroutine associated with a running thread is
    marked by a {\tt *}. In this example the {\tt merger}-coroutine is
    associated with a a running thread. The caller-link of the active
    coroutine refers to the method currently being executed. In (a),
    {\tt merger*} refers to the {\tt Do}-method which is currently
    executing.
  \item For suspended coroutines, the caller-link refers to the top
    element of the execution stack of the coroutine. In the initial
    situation after a coroutine has been generated, the caller-link
    refers to the coroutine object itself. This is the situation in figure
    (a) where the caller-link of {\tt A} and {\tt M} refers to the
    {\tt A}- and {\tt M}-objects respectively.
  \end{itemize}
\item Figure (b) shows the situation where the first {\tt A.call()} in
  {\tt merger.Do} is being executed. This implies that the {\tt
  A}-coroutine is executed by {\tt merger}. Execution of {\tt
  merger} implies that the {\tt Do}-method of {\tt A} is invoked.
  The {\tt Do}-method then calls {\tt compute}. The snapshot is at the
  label {\tt A1:} just before {\tt suspend} in this first invocation of
  {\tt compute}.

\item Figure (c) shows the situation after execution of {\tt suspend}
  in {\tt A} at the label {\tt L2:} in {\tt merger.Do}.  Execution of
  {\tt suspend} in {\tt A} implies that execution of {\tt A} is
  suspended.  In a suspended coroutine, the caller-reference of the
  coroutine ({\tt A} in this example) refers the top element of the
  execution stack of the coroutine -- {\tt compute} in this example.
\item Figure (d) shows the situation where the {\tt M.call()} after
  the label {\tt L2:} has been executed by {\tt merger}. This implies
  an execution of {\tt M} leading to a similar situation for {\tt M}
  as the one described for {\tt A} in (b). The snapshot is at the
  label {\tt M:} in {\tt M.compute}.
\item Figure (e) shows the situation at {\tt L3:} in {\tt merger} where
  {\tt A} and {\tt M} both are suspended. 
\item Figure (f) shows the situation after a subsequent call of {\tt
   A} has been executed leading to a second invocation of {\tt
   compute}. The snapshot is at the label {\tt A2:}.
\end{itemize}


\subsection{Implementation of class {\tt Coroutine}}
Class {\tt Coroutine} is implemented by means of a class {\tt Component}
as shown in the following example:

{\tt\small\begin{verbatim}
   class Coroutine {
     private Component thisC = new Component(this);

     void call() { thisC.swap(); }
     void suspend() { thisC.swap(); }
     abstract void Do(); 
   }
\end{verbatim}
}
\noindent
As can be seen, the implementations of {\tt call} and {\tt suspend} are
identical and the magic is in the {\tt swap}-method.

A coroutine shift (call or suspend) is basically just a {\it swap} of
two references. This is illustrated in Figure \ref{swap}.
\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1.2\textwidth]{Coroutines-2.pdf}
    \caption{Illustration of the call and suspend}
    \label{swap}
  \end{center}
\end{figure}

\begin{itemize}
\item The transition from (a) to (b) illustrates a suspend of {\tt M}.
   In (a) there is a caller-link from the object {\tt M} to the method
   invocation {\tt merger.Do} and a caller-link from the object {\tt
   merger*} to the method invocation {\tt M.compute}. Execution of
   suspend implies that these two links are swapped. The result may be
   seen in part (b) of the figure.

\item The transition from (c) to (d) illustrates a call of {\tt A}.
  In (c) there are caller-links from {\tt merger*} to {\tt merger.Do}
  and from {\tt A} to {\tt A.compute}. Execution of {\tt A.call()}
  implies that these two links are swapped. The result may be seen on
  part (d) of the figure.

\end{itemize}
\noindent 
As can be seen it is pretty simple to implement coroutines. All that
is needed is a caller-link to implement the call-stack and a simple
swap-operation.  The caller-link corresponds to the return link of a
usual method invocation stack. The BETA-implementation of coroutines
is implemented this way. Unfortunately the situation i CJ is a bit
more complicated since we have to get around the CJ-run time structure
and thread mechanism. This is further described in the next section.

The notion of semi-coroutine originates from Simula, which also
includes the original Conway-style of symmetric coroutine
\cite{conway}. The coroutine model based on swap originates from Dahl
\&\ and Wang \cite{dw}. BETA has adapted the semi-coroutine model as
described in \cite{betabook}, chapter 13 where it is also described
how to implement symmetric coroutines using semi-coroutines.


\subsection{Class {\tt Component}}
In this section we describe the details of the coroutine implementation
in CJ. 
Class {\tt Component} is as mentioned implemented using threads and
could be defined as a subclass of class {\tt Thread}. For reasons of
efficiency -- see later -- the thread-part of a {\tt Component} is
defined in an associated {\tt Runner}-object. Class {\tt Runner} is a
subclass of class {\tt Thread}. Class {\tt Component} has the
following structure:\footnote{In this CJ code, the synchronization
  mechanisms of JAVA is used. JAVA defines the {\tt{}wait()} and
  {\tt{}notify()} methods directly on {\tt{}java.lang.Object}. For .NET
  this is not the case; instead the .NET class library supplies the
  {\tt{}System.Threading.Monitor.Wait(anObject)} and 
  {\tt{}System.Threading.Monitor.Pulse(anObject)}, respectively}

{\tt\small\begin{verbatim}
   class Component {
      static Component current;     // The current executing Component
      private Component caller;     // The calling Component
      
      private Runner myRunner;      // the associated Thread
      private Coroutine body;       // The actual Coroutine
      private boolean isTerminated; // True if terminated
      
      public Component(Coroutine b) {
         body = b;
         caller = this;
         myRunner = new Runner(this);
      }

      public void swap() {
         Component old_current = current;
         // swap pointers
         current = caller;
         caller = old_current;

         synchronized(old_current.myRunner) {
            // start or resume new current
            current.myRunner.go();
            // terminate or suspend old current
            if (old_current.isTerminated) {
               return;
            } else {
              try{ old_current.myRunner.wait(); }
              catch (InterruptedException e) {}
            }
         }         
      }
   }
\end{verbatim}
}
\noindent
The current active Component of the coroutine-system is represented by
the static field {\tt current}.

When an instance of {\tt Component} is created the constructor sets up
the initial situation where:

\begin{itemize}
\item
The {\tt body}-field refers the {\tt Corutine}-object, implemented by
this {\tt Component}
\item 
The {\tt caller}-field refers to this {\tt Component}
\item 
A {\tt Runner}-object is created and assigned to {\tt myRunner}.
\end{itemize}
\noindent
When a {\tt call} or {\tt suspend} is executed by a {\tt Coroutine}
the {\tt swap}-method of the associated {\tt Component} is executed.
\begin{itemize}
\item The first part of {\tt swap} implements a swap of {\tt current}
and {\tt caller} as described above. ...
\item Then swap invokes {\tt current.myRunner.go()} which starts the
Thread if this is the first call of swap/call. Otherwise it resumes
execution of the new active {\tt Component} -- the one referred by
current. Since {\tt swap} implements {\tt call} as well as {\tt
suspend} there are basically two situations:
\begin{itemize}
\item {\bf call}: If {\tt current} has not been called before, the {\tt
Do}-method of the associated {\tt Coroutine} is executed, see
  implementation of {\tt Runner.go()} below. If {\tt
current} has been called before, it has executed a {\tt suspend},
execution is resumed after this {\tt suspend}.
\item {\bf suspend}: Execution is resumed after the invocation of {\tt
call}.
\end{itemize}
\end{itemize}

\noindent
Below is shown the implementation of class {\tt Runner}.

{\tt\small\begin{verbatim}
   class Runner extends Thread {
      Component myComponent;

      Runner(Component C) { myComponent = C; }

      public void run() {
         myComponent.body.Do(); // Run Do-method of Coroutine
         
         // Terminate this Component
         myComponent.isTerminated = true;
         myComponent.swap();
      }   

      public void go() {
        if (!isAlive()) { 
           start(); // calls run
        } else {
           synchronized(this) { 
             notify(); // resume this
           }
        }
      }
   }
\end{verbatim}
}

In Figure \ref{coimpl-1} is shown how the logical structure of a
coroutine (part (a)) is represented using the classes {\tt Component}
and {\tt Runner} (part (b)). The {\tt merger}-coroutine has executed a
call of {\tt A}. The {\tt merger}-coroutine is waiting 
in {\tt old\_current.wait()}, i.e. in {\tt merger.myComponent.myRunner.wait()}.
\note{Peter: Ændret fra {\it on a synchronize on its corresponding
    {\tt myRunner}-object}, også i figuren, CHECK!}
%%% on a synchronize on its corresponding {\tt myRunner}-object.

\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1\textwidth]{Coroutines-3.pdf}
    \caption{Illustration of coroutine implementation in CJ}
    \label{coimpl-1}
  \end{center}
\end{figure}

Figure \ref{coimpl-2} illustrates the representation of {\tt A} when
{\tt A} has executed a {\tt suspend}. {\tt A} is now waiting on a
synchronize on its corresponding {\tt myRunner}-object. The {\tt
merger}-coroutine is currently active.

\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=1\textwidth]{Coroutines-4.pdf}
    \caption{Illustration of suspended coroutine implementation in CJ}
    \label{coimpl-2}
  \end{center}
\end{figure}


\subsection{Mapping BETA coroutine}
Using class Component above, it is pretty straight forward to
implement BETA's coroutines.

BETA has a toplevel pattern called {\tt Object}, which in CJ is mapped
to class {\tt BetaObject}. Class {\tt BetaObject} has a field {\tt
comp\$} referring an associated {\tt Component}.

{\tt\small\begin{verbatim}
   class BetaObject {
      Component comp$
   }
\end{verbatim}
}

\note{Peter: This class corresponds to the {\tt Coroutine} class
  defined above for CJ, with {\tt Comp\$} corresponding to {\tt
  thisC}. In fact, the CJ code above could be used unchanged for BETA
  if {\tt BetaObject} was defined as a subclass of {\tt Coroutine},
  but for efficiency reasons the BETA implementation use a version of
  class {\tt Component} where {\tt BetaObject} is used instead of {\tt
  Coroutine}}

\noindent
Consider the following example of a BETA coroutine:

{\small\begin{alltt}
   MyCo:
      (# foo:
          (#
          do ...; suspend; ...
          #)
      do ...; foo; ...
      #);
    M: ^| MyCo;
 
    {\bf\tt{}&|MyCo[] -> M[];}
    L: M;     (* a call of M *)
\end{alltt}
}
\noindent
The {\tt |} in {\tt M: \^{}| MyCo} specifies that {\tt M} is a
reference to a coroutine of type {\tt MyCo}. Similarly, the {\tt |} in
{\tt \&|MyCo} specifies that a coroutine instance of {\tt MyCo} is
generated.

\note{Peter: Notice that this means that {\em any pattern} may be used
  as a Coroutine - this is the reason for having the {\tt Comp\$}
  reference in each \tt{BetaObject}}

A coroutine call in BETA has the same syntax as invoking an object. A
call of {\tt M }takes place at the label {\tt L}.

A BETA coroutine is mapped into CJ in the following way:

\begin{itemize}
\item {\bf Generation}. When an instance of a coroutine is generated,
a corresponding instance of {\tt Component} is generated and assigned
to the {\tt comp\$}-field. 
\item {\bf Call.} A call {\tt M} is mapped into {\tt M.comp\$.swap()}.
\item {\bf Suspend.} A suspend executed by {\tt M} is similarly mapped
into {\tt comp\$.swap()}.
\end{itemize}

\note{Perhaps a figure showing M and a reference to the associated
  Component. Peter: basically the same figure as figure 3, with
  BetaObject instead of Couritine}

\note{Check this}

\subsection{Remaining details of the implementation}
As mentioned the mapping of coroutines is heavily inspired by
\cite{helsgaun}, which describes a complete implentation of both
semi-coroutines and symmetric coroutines from Simula.  Since BETA
coroutines are simpler than Simula coroutines the mapping to CJ is
aslo simpler than the one described in \cite{helsgaun}.  Following
\cite{helsgaun} the actual implementation of coroutines is 
further refined as described below:

\begin{itemize}
\item A Java program does not terminate as long as there are active
threads. When a BETA program terminates, there may be suspended
coroutines that have not terminated. To handle this the statement {\tt
SetDaemon(true)} is called for each Runner to indicate that the
program may terminate even if the Runner has not terminated.  \CS?

\item In the above implementation a new {\tt Thread} is generated
whenever a new {\tt Coroutine} is generated.  Thread allocation is
very expensive in Java. In a some Simula and BETA program a large
number of coroutines may be allocated duringa program execution. Often
only a few of these are alive at a given point in time.  For this
reason it improves efficiency to keep a pool of Threads.

\end{itemize}


As mentioned a terminated BETA program may generate a large number
of coroutines. In BETA, a coroutine is alive as long as there
is a reference to it form a live object. When a coroutine
cannot be reached from a live object, it may be garbage collected.

This is however a problem in in the Java implementation. Even if a
BETA coroutine is not reachable from an active object it is reacheable
form the associated {\tt Runner/Thread}. And since non-terminated
threads are roots for the garbage collector in Java, these coroutines
and associated {\tt Runner}-objects are never garbage collected. This
is currently and unsolved problem for Java.

For \CS?

The complete implementation of class {\tt Component} and {\tt Runner}
is shown in the appendix.
