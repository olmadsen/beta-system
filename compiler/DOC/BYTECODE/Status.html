<html>
<head>
<TITLE>Status for BETA Bytecode Implementation</TITLE>

<body>

Currently quite incomplete!

<h1> Introduction </h1>

The following preliminary tools exists:

<ul>
<li>A variant of the BETA compiler, called <code>sbeta</code>. It uses
a special backend for generating an abstract form of byte code.  It is
placed in
<pre>
   compiler/sbeta.bet
</pre>
The bytecode backend is in 
<pre>
   compiler/GENERATOR/BYTECODE
</pre>
<li>
The transformer from BETA to the Java subset (not used by compiler) is in
<pre>
   /users/olm/beta/codegenscripts
</pre>
</ul>

<h1>BETA Bytecode Subset</h1>
Only a very limited subset of BETA is implemented by
the current version of the bytecode compiler. 
The paln is to implement full BETA to the extent that this is possible.
The following is an incomplete description of this subset.

<p>
OBS! None of the restrictions mentioned below are checked by the compiler.
<p>
Basically patterns can be used as classes with procedure attributes
as in

<pre>
MyClass: MySuper
   (# foo1: (# x,y,z: @integer enter(x,y,z) do ... exit z #)
      foo2: (# S: ^YourClass enter S[] do ... #);
      ...
   #);
</pre>

The pattern <code>MyClass</code> is an example of a class-pattern;
<code>foo1, foo2</code>, and <code>foo2</code> are examples of 
procedure-patterns.
<p>
Class-patterns can be nested.

<p>
<b>Patterns</b>. 
A pattern has to be in one of the following forms:
<ul>
<li>
A <b>class-pattern</b> - a pattern with no enter-, do- and exit-part.
A possible superpattern must be a class-pattern.
<li>
A <b>procedure-pattern</b> - a pattern with a do-part and possible enter-
and exit-parts. 
<br>No super pattern is allowed.
<br>A procedure-pattern may only appear inside a class-pattern.
<li>
An <b>external-pattern</b> - a subpattern of <code>external</code>.
<br>External-patterns should appear at the outermost block-level.
<br>
External-patterns having the names, <code>put, putint</code>, and
<code>puttext</code> are implemented as calls to
<code>'java/io/PrintStream/print'</code>; and putline is implemented
as <code>'java/io/PrintStream/println'</code>.

</ul>

<b>Virtual patterns</b>
<ul>
<li>
Procedure-patterns may be virtual. The form must be
<p>
<pre>
      foo:< (# ... do ... #)
</pre>
And corresponding bindings may have the form
<pre>
      foo::< (# ... do ... #) 
</pre>
Enter- and exit-parameters may only appear in the
virtual declaration.
<P>
The form
<pre>
      foo:< bar
</pre>
is illegal.
<li>
A class-pattern may be virtual using the form
<pre>
      element:< Object
</pre>
And corresponding bindings may have the form
<pre>
      element::< Person
</pre>
Virtual class-patterns may only appear as attributes of non-virtual
class-patterns-
</ul>

<b>Data-items</b>.
The following rules apply to data-items
<ul>
<li>
Simple variables defined by basic patterns such as integer, boolean and char
are allowed:
<pre>
   a: @integer
</pre>
<li>
Dynamic references are allowed:
<pre>
   S: ^MyClass
</pre>
<li>
Static (part-) objects are <b>not</b> allowed.
 That is
<pre>
   W: @MyClass
</pre>
<b>is illegal</b>.
</ul>

<p>
<b>Evaluations</b>.
Evaluations of the form
<ul>
<li>
<pre>
E -> V
</pre>
where E is a value-expression and V is a variable of type integer, 
boolean, or char
are allowed.
<br>
An exprsion E may be composed form constant, variables,
and (all - many have been tested:-) binary- and unary operators.
<li>
<pre>
S[] -> R[]
</pre>
that is reference expressions are allowed.
<li>
<pre>
&MyClass[] -> S[]
</pre>
that is object generation is allowed
<li>
An evaluation of the form
<pre>
   (e1,e2,e3) -> R.foo -> V
</pre>
is legal if R is a dynamic reference qualified by a class-pattern
and foo is a procedure-pattern attribute of this class.
</ul>

<h2>Fragment structure</h2>
A special version of betaenv/tstenv must be used. It is located in
<pre>
   compiler/GENERATOR/BYTECODE/TEST
</pre>
A fragment file should have the form
<pre>
   origin 'tstenv'
   ---lib:attributes---
   Class1: (# ... #);
   Class2: (# ... #);
   Class3: Class2(# ... #)
   ---program:descriptor---
   (# S: ^Class1; ...
   do &Class1[] -> S[]; 
      ...
   #)
</pre>
The program-slot is interpreted as a class
<pre>
   class Main extends Object
     { 
       static void main(String args[])
         { Class1 S1; ...
           S1 = new Class1();
           ...  
         }
     }
</pre>
The declarations and do-part of the program-slot
is placed in the body of the main-method.

<h2>Demo examples</h2>
A number od demo examples may be found in
<pre>
   compiler/GENERATOR/BYTECODE/TEST
</pre>

<h1>Using the Bytecode Compiler</h1>
If foo.bet is a BETA-file corresponding to the
subset described in the previous section, it may be compiled
by calling - in the following we assume that Java bytecode
is generated - .NET will follow the same pattern.

<pre>
   sbeta -t javabc foo
</pre>
The resulting program may be executed by 
<pre>
   java Main
</pre>

<h2>Stuff generated</h2>
Consider a file <code>foo.bet</code>, with class-patterns 
<code>Class1</code>, <code>Class2</code>, and <code>Class3</code>.
<ul>
<li>
The bytecode platforms are called <code>javabc</code> 
and <code>dotnet</code>.
A code subdirectory - e.g. <code>javabc</code> - is created
<li>
A jobfile <code>javabc/foo..job</code>, with calls of the jasmin-assembler
is generated
<li>
For each class, like <code>Class1</code>, the following is generated
<ul>
<li>
A file <code>javabc/Class1.bin</code> is generated containing a binary form
of the bytecode.
<li>
A text file <code>javabc/Class1.J</code> containing Jasmin assembler code
is generated - Jasmin is a Java bytecode assembler.
<li>
A class file <code>Class1.class</code> is generated by Jasmin
- Jasmin is called in the job file
</ul>
</ul>

</body>
</head>
</html>
