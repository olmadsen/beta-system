<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<title>Status for BETA Bytecode Implementation</title>
<link rev="made" href="mailto:beta@daimi.au.dk">
<LINK REL="stylesheet" HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE="text/css">
</HEAD>

<body>

Currently quite incomplete!

<h1> Introduction </h1>


<html>
<head>
<TITLE></TITLE>

The following preliminary tools exists:

<ul>
<li>2 variants of the BETA compiler, called <code>jbeta</code> and <CODE>nbeta</CODE>. They use
a special backend for generating an abstract form of byte code.  They
are placed in 

<pre class=beta>
compiler/jbeta.bet
compiler/nbeta.bet
</pre>
The bytecode backend is in 

<pre class=beta>
compiler/GENERATOR/BYTECODE
</pre>
<li>
The transformer from BETA to the Java subset (not used by compiler) is in

<pre class=beta>
/users/olm/beta/codegenscripts
</pre>
</ul>

<h1>BETA Bytecode Subset</h1>
Only a subset of BETA is implemented by
the current version of the bytecode compiler. 
The paln is to implement full BETA to the extent that this is possible.
The following is an incomplete description of this subset.

<p>
OBS! None of the restrictions mentioned below are checked by the compiler.
<p>
Basically patterns can be used as classes with procedure attributes
as in


<pre class=beta>
MyClass: MySuper
(# foo1: (# x,y,z: @integer enter(x,y,z) do ... exit z #)
   foo2: (# S: ^YourClass enter S[] do ... #);
   ...
#);
</pre>

The pattern <code>MyClass</code> is an example of a class-pattern;
<code>foo1, foo2</code>, and <code>foo2</code> are examples of 
procedure-patterns.
<p>
Class-patterns can be nested.

<p>
<b>Patterns</b>. 
A pattern has to be in one of the following forms:
<ul>
<li>
A <b>class-pattern</b> - a pattern with no enter-, do- and exit-part.
A possible superpattern must be a class-pattern.
<li>
A <b>procedure-pattern</b> - a pattern with a do-part and possible enter-
and exit-parts. 
<br>No super pattern is allowed.
<br>A procedure-pattern may only appear inside a class-pattern.
<li>
An <b>external-pattern</b> - a subpattern of <code>external</code>.
<br>External-patterns should appear at the outermost block-level.
<br>
External-patterns having the names, <code>put, putint</code>, and
<code>puttext</code> are implemented as calls to
<code>'java/io/PrintStream/print'</code>; and putline is implemented
as <code>'java/io/PrintStream/println'</code>.

</ul>

<b>Virtual patterns</b>
<ul>
<li>
Procedure-patterns may be virtual. The form must be
<p>

<pre class=beta>
foo:< (# ... do ... #)
</pre>
And corresponding bindings may have the form

<pre class=beta>
foo::< (# ... do ... #) 
</pre>
Enter- and exit-parameters may only appear in the
virtual declaration.
<P>
The form

<pre class=beta>
foo:< bar
</pre>
is illegal.
<li>
A class-pattern may be virtual using the form

<pre class=beta>
element:< Object
</pre>
And corresponding bindings may have the form

<pre class=beta>
element::< Person
</pre>
Virtual class-patterns may only appear as attributes of non-virtual
class-patterns-
</ul>

<b>Data-items</b>.
The following rules apply to data-items
<ul>
<li>
Simple variables defined by basic patterns such as integer, boolean and char
are allowed:

<pre class=beta>
a: @integer
</pre>
<li>
Dynamic references are allowed:

<pre class=beta>
S: ^MyClass
</pre>
<li>
Static (part-) objects are <b>not</b> allowed.
That is

<pre class=beta>
W: @MyClass
</pre>
<b>is illegal</b>.
</ul>

<p>
<b>Evaluations</b>.
Evaluations of the form
<ul>
<li>

<pre class=beta>
E -> V
</pre>
where E is a value-expression and V is a variable of type integer, 
boolean, or char
are allowed.
<br>
An exprsion E may be composed form constant, variables,
and (all - many have been tested:-) binary- and unary operators.
<li>

<pre class=beta>
S[] -> R[]
</pre>
that is reference expressions are allowed.
<li>

<pre class=beta>
&MyClass[] -> S[]
</pre>
that is object generation is allowed
<li>
An evaluation of the form

<pre class=beta>
(e1,e2,e3) -> R.foo -> V
</pre>
is legal if R is a dynamic reference qualified by a class-pattern
and foo is a procedure-pattern attribute of this class.
</ul>

<h2>Fragment structure</h2>
A special version of betaenv/tstenv must be used. It is located in

<pre class=beta>
compiler/GENERATOR/BYTECODE/TEST
</pre>
A fragment file should have the form

<pre class=beta>
origin 'tstenv'
---lib:attributes---
Class1: (# ... #);
Class2: (# ... #);
Class3: Class2(# ... #)
---program:descriptor---
(# S: ^Class1; ...
do &Class1[] -> S[]; 
...
#)
</pre>
The program-slot is interpreted as a class

<pre class=beta>
class Main extends Object
  { 
    static void main(String args[])
      { Class1 S1; ...
        S1 = new Class1();
        ...  
      }
  }
</pre>
The declarations and do-part of the program-slot
is placed in the body of the main-method.

<h2>Demo examples</h2>
A number od demo examples may be found in

<pre class=beta>
compiler/GENERATOR/BYTECODE/TEST
</pre>

<h1>Using the Bytecode Compiler</h1>
If foo.bet is a BETA-file corresponding to the
subset described in the previous section, it may be compiled
by calling - in the following we assume that Java bytecode
is generated - .NET will follow the same pattern.


<pre class=beta>
sbeta -t jvm foo
</pre>
The resulting program may be executed by 

<pre class=beta>
java Main
</pre>

<h2>Stuff generated</h2>
Consider a file <code>foo.bet</code>, with class-patterns 
<code>Class1</code>, <code>Class2</code>, and <code>Class3</code>.
<ul>
<li>
The bytecode platforms are called <code>jvm</code> 
and <code>clr</code>.
A code subdirectory - e.g. <code>jvm</code> - is created
<li>
A jobfile <code>jvm/foo..job</code>, with calls of java -jar is called
<li>
For each class, like <code>Class1</code>, the following is generated
<ul>
<li>
A file <code>jvm/Class1.bin</code> is generated containing a binary form
of the bytecode.
<li>
A class file <code>Class1.class</code> is generated directly by the compiler.
</ul>
</ul>

</body>
</html>
