<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<title>Special BETA Constructs for JVM/CLR Support</title>
<link rev="made" href="mailto:beta@daimi.au.dk">
<LINK REL="stylesheet" HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE="text/css">
</HEAD>

<BODY>

<H1>Special BETA Constructs for JVM/CLR Support</H1>

To facilitate interoperability with JVM and CLR, a
number of special constructs have been introduced into BETA. These
constructs are mostly temporary workarounds, to get things up and
running, and will be attempted handled in a more elegant way in a
future release.

<H2>Special Prefix Patterns</H2>

A number of special superpatterns are available, which when used as
prefix for a pattern will modify the
way the pattern is mapped to JVM/CLR code. These are:

<OL>

<LI><CODE><B>ExternalClass</B></CODE><BR>

The pattern <A HREF="#ExternalClass"><CODE>ExternalClass</CODE></A> is
used to declare classes originating from outside BETA, e.g. Java or C#
in BETA syntax.  This is currently needed to allow the BETA compiler
to support type-safe use of non-BETA classes. As this can be quite
tedious to do by hand, a <A HREF="converter/index.html">tool</A> has
been made, that will read the binary external classes and emit BETA
declarations corresponding to them. In a future version of the BETA
compiler, this may be automated.
<BR>
See <A HREF="#ExternalClass">ExternalClass</A> below for specific usage of
<CODE>ExternalClass</CODE>.

<LI><A NAME="class"><CODE><B>class</B></CODE></A><BR>
The pattern <CODE>class</CODE> is used to restrict a pattern to class
usage only. As a BETA pattern can be used as both a class/type and as
a method, normally code will be generated for both usages. Using
<CODE>class</CODE> as prefix for a pattern will make the compiler not
generate code for the usage of the pattern as a method.<BR>
<CODE>class</CODE> is only used for patterns implementing
functionality in BETA, i.e. not for classes in Java/.NET.

<LI><A NAME="proc"><CODE><B>proc</B></CODE></A><BR>
The pattern <CODE>proc</CODE> is used to restrict a pattern to method
usage only. As a BETA pattern can be used as both a class/type and as
a method, normally code will be generated for both usages. Using
<CODE>proc</CODE> as prefix for a pattern will make the compiler not
generate code for the usage of the pattern as a class.<BR>
<CODE>proc</CODE> is used both for patterns implementing
methods in BETA and for methods in external classes.


<LI><A NAME="cons"><CODE><B>cons</B></CODE></A><BR>
Using <CODE>cons</CODE> as a prefix of a pattern tells the compiler to
generate special code for the pattern to be used as a
<EM>constructor</EM>. These methods have special internal names and
calling conventions in the generated byte codes. Specifying
<CODE>cons</CODE> implies <CODE>proc</CODE>, i.e. the pattern cannot
be used as a class.<BR>
There may be specified more than one constructor, as long as they
differ in <CODE>enter</CODE> lists (corresponding to
<EM>signatures</EM> in the byte code).<BR>
<CODE>cons</CODE> can be used both in a BETA pattern implementing
functionality to be used from BETA and/or external languages, and in  
<CODE>ExternalClass</CODE> declarations.<BR>
However, there is a problem in the current implementation: If the
constructor is to be called from BETA code, it should include a local
variable of the same type as the class it is creating, and the
constructor should return this value, e.g.:
<PRE class=beta>
Foo: 
  (# ...
     create: cons
       (# result: ^Foo;
       exit result[]
       #);
  #)
</PRE>
On the other hand, if the constructor is to be called from outside
BETA, you should <EM>not</EM> declare the variable and the exit part,
since this will lead to illegal byte code.<BR>
See <A HREF="#Constructors">Constructors</A> below for further
information on how to specify and use constructors in BETA patterns.

<LI><A NAME="static_proc"><CODE><B>static_proc</B></CODE></A><BR>
Using <CODE>static_proc</CODE> as a prefix for a method in an
<CODE>ExternalClass</CODE> specification (as opposed to just
<CODE>proc</CODE>) tells the BETA compiler that this is a
<EM>static</EM> method, which has a special calling convention in the
byte code, and which is invoked on the external class itself and not on
an object.<BR>
Notice that specifying <CODE>static_proc</CODE> as a prefix of a
pattern implementing functionality in BETA is <EM>not supported</EM>;
the compiler will currently not complain, but generate non-functional 
(illegal) byte code.

<LI><A NAME="static_cons"><CODE><B>static_cons</B></CODE></A><BR>
Using <CODE>static_cons</CODE> as a prefix for a method in an
<CODE>ExternalClass</CODE> specification (as opposed to just
<CODE>cons</CODE>) tells the BETA compiler that this is a
<EM>static constructor</EM> which has a special calling convention in the
byte code, and which is invoked on the external class itself and not on
an object.<BR>
Notice that specifying <CODE>static_cons</CODE> as a prefix of a
pattern implementing functionality in BETA is <EM>not supported</EM>;
the compiler will currently not complain, but generate non-functional 
(illegal) byte code.
</OL>

Notice, that since these are to be used as superpatterns, you cannot
specify a "real" superpattern. We hope to introduce a notation a la
the .NET attributes into BETA, to allow for specifying these
special behaviours without using superpattern notation.

<H2>Specifying JVM Packages</H2>

BETA code compiled with <CODE>jbeta</CODE> by default is emitted to
the JVM package named <CODE>beta</CODE>. If another package is to be
used (e.g. to because some java code is to use the BETA generated
code), a new BETA property has been defined:

<PRE class=beta>
PACKAGE 'org.foo.bar';
</PRE>

This property can be added in the beginning of the file, typically just
after <CODE>ORIGIN</CODE>.

<H2><A NAME="ExternalClass">External Class Declarations</A></H2>
To access an external class, you just make a BETA pattern with the
prefix <CODE>ExternalClass</CODE>, and declares the various methods in
this external class, you want to access, as local patterns with
prefixes
<CODE>proc</CODE>/<CODE>static_proc</CODE>/<CODE>cons</CODE>/<CODE>static_cons</CODE>.
You furthermore specify the <EM>fully qualified class name</EM> of the
class in the form of an assignment to an attribute called
<CODE>className</CODE> inside the do-part of the
<CODE>ExternalClass</CODE>. Finally you can declare (non-static) fields of the
external objects, just by declaring dynamic BETA references with the
correct qualification.
<BR>
As an example, here is an excerpt of the <CODE>ExternalClass</CODE>
declaration corresponding to the Java <CODE>String</CODE> class:

<PRE class=beta>
String: ExternalClass
  (#
     _init: cons (* constructor *)
       (# result: ^String;
       exit result[]
       #);
     ...
     _init_ArrayOfC: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1[])
       exit result[]
       #);
     ...
     compareTo_String: proc (* overloaded compareTo *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'compareTo' -&gt; procname;
       exit result
       #);
     compareTo_Object: proc (* overloaded compareTo *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'compareTo' -&gt; procname;
       exit result
       #);
     ...
  do 'java/lang/String' -&gt; className;
#)
</PRE>

And here is the corresponding .NET declarations:

<PRE class=beta>
String: ExternalClass
  (# ...
     _init_ArrayOfChar: cons (* constructor *)
       (# result: ^String;
          arg1: [0]@char;
       enter (arg1[])
       exit result[]
       #);
     _init_char_int32: cons (* constructor *)
       (# result: ^String;
          arg1: @char;
          arg2: @int32;
       enter (arg1, arg2)
       exit result[]
       #);
     ...
     CompareTo_Object: proc (* overloaded CompareTo *)
       (# result: @int32;
          arg1: ^Object;
       enter (arg1[])
       do 'CompareTo' -&gt; procname;
       exit result
       #);
     CompareTo_String: proc (* overloaded CompareTo *)
       (# result: @int32;
          arg1: ^String;
       enter (arg1[])
       do 'CompareTo' -&gt; procname;
       exit result
       #);
     ...
  do '[mscorlib]System.String' -&gt; className
#)
</PRE>

You can then <A NAME="#Instantiation">instantiate</A>
<CODE>String</CODE> objects in BETA using these patterns, and
subsequently access methods and fields in these objects.
<BR>
It may seem confusing that the <CODE>className</CODE> specification
resembles a statement, and a future version of the BETA compiler may
support an improved way of specifying this.
<BR>
Notice, that two <A NAME="converter/index.html">tools</A> have been
provided, that can be used to convert an external class to corresponding BETA
declarations instead of writing these by hand. 
In a future version of the compiler, this may be handled
automatically.

<H3>Specializations of ExternalClasses</H3>

In BETA you can declare a subpattern of a pattern with prefix
<CODE>ExternalClass</CODE>. This may mean two different things: Either
you are just declaring an interface to another external class, which
happens to be a subclass of the first external class you declared,
<EM>or</EM> you want to implement a specialization of the external
class in BETA.
<BR>
To distinguish between these two situations, a subtle solution is
currently supported by the compiler:

<UL>
<LI>If you specify the do-part of an <CODE>ExternalClass</CODE> or
specialization thereof
(typically specifying the <CODE>className</CODE>), the class is
considered external, and the compiler will not generate code for the
class.<BR>
If you specify an <EM>empty do-part</EM>, a default
<CODE>className</CODE> is assumed. 
<BR>
For an external class <CODE>Foo</CODE>:
<PRE class=beta>
Foo: ExternalClass
  (# ...
  do (* empty do part *)
  #)
</PRE>
the default <CODE>className</CODE> will be:
<UL>
<LI>For Java: <CODE>Foo</CODE>, i.e. a class <CODE>Foo</CODE> in the
default (empty) Java package
<LI>For .NET: <CODE>[Foo]Foo</CODE>, i.e. a class <CODE>Foo</CODE> in
assembly <CODE>Foo</CODE> (typically file <CODE>Foo.dll</CODE>).
</UL>

<LI>If no do-part is specified, the pattern is considered a BETA
specialization of the external class, and the compiler will generate
code for the class and its methods.
</UL>



<H3>JVM Interfaces</H3>
The Java virtual machine use different calling conventions when
calling interface-methods and class-methods. To inform <CODE>jbeta</CODE> about
this, the pipe character '|' should be used as the first character when
specifying the <CODE>className</CODE> for :

<PRE class=beta>
do '<B>|</B>.....' -&gt; className;
</PRE>


<H3>CLR value types</H3>
The .NET CLR use different calling conventions when
calling methods on reference types and valuetypes. To inform <CODE>nbeta</CODE> about
this, the ad character '@' should be used as the first character when
specifying the <CODE>className</CODE> for a value type:

<PRE class=beta>
do '<B>@</B>...' -&gt; className
</PRE>


<H2><A NAME="Constructors">Constructors</A></H2>
There are currently four ways to declare a constructor in BETA code:

<UL>
<LI><CODE><B>_init</B></CODE><BR>
Specifying a pattern with the special pattern name <CODE>_init</CODE>
(one underscore) is a rudimentary way of declaring <EM>one</EM>
constructor in a BETA pattern. It is now deprecated, as it only allows
for the declaration of one constructor. Use the 
<A NAME="#cons">cons</A> prefix instead.
<LI><CODE><B>cons</B></CODE>
The special prefix <CODE>cons</CODE> was described 
<A NAME="#cons">above</A>, and is the recommended way to specify an
instance constructor in a BETA pattern or <CODE>ExternalClass</CODE>.
<LI><CODE><B>static_cons</B></CODE>
The special prefix <CODE>static_cons</CODE> was described 
<A NAME="#static_cons">above</A>, and is the recommended way to specify an
static constructor in an <CODE>ExternalClass</CODE> declaration.
<LI><CODE><B>__init</B></CODE>
Specifying a pattern with the special pattern name <CODE>__init</CODE>
(two underscores) is a way of declaring <EM>one</EM> constructor,
which does not require a surrounding object as argument, when called
from  outside BETA. Normal constructors have a hidden (synthetic)
first argument being the surrounding BETA object. This must be
supplied when the constructor is invoked.<BR>
The surrounding object is still needed, though, and to set up this, a
special low-level primitive is suplied, that <EM>must</EM> be called
inside the do-part of the <CODE>__init</CODE> pattern, preferably as
the first thing done:
<UL>
<LI><CODE><B>%setup 'betaenv'</B></CODE>
</UL>
This special statement will make the BETA compiler do two things:
<OL>
<LI>Create a <CODE>betaenv</CODE> object
<LI>Set up the surrounding object reference of the object being
created to be this <CODE>betaenv</CODE> object.
</OL>

There are a number of problems and limitations with the current
implementation of parameterless constructors:

<UL>
<LI>The name <CODE>__init</CODE> does not very well signal that this
is a special pattern. Should probably be changed to, e.g. a prefix
<CODE>default_cons</CODE>.
<LI>The compiler ought to set up the <CODE>betaenv</CODE> object
automatically
<LI>You should only specify an <CODE>__init</CODE> in a BETA library
to be called from Java/.NET, not as part of an
<CODE>ExternalClass</CODE> declaration
<LI>If you specify an <CODE>__init</CODE> you should <EM>not</EM>
specify any <CODE>_init</CODE> and/or <CODE>cons</CODE> patterns. If
you do so, currently the parameterles constructor will not be
generated. As a side effect, a pattern containing an
<CODE>__init</CODE> <EM>cannot</EM> be instantiated using standard
BETA syntax <CODE>&amp;Foo[] -&gt; ...</CODE>. See 
<A NAME="#Instantiation">Instantiation</A> below.
<LI>You should only specify <CODE>__init</CODE> in an outer-most
pattern, i.e. one that is declared in <CODE>LIB:attributes</CODE>. For
inner classes, the surrounding object is automatically set up. If you
specify an <CODE>__init</CODE> for an inner pattern, illegal bytecode
will result.
<LI>Using multiple BETA patterns each with an <CODE>__init</CODE>
constructor may lead to multiple <CODE>betaenv</CODE> instances. This
should not be a problem. 
<LI>You <EM>should not</EM> specify an <CODE>__init</CODE> constructor
for a BETA pattern, that has another BETA pattern as prefix. This will
currently cause illegal byte code to be generated. Instead, make a
dynamic part object containing an instantiation of the pattern, you
would have liked to use a prefix, and delegate calls for the prefix
into this local object.
<LI>You <EM>should not</EM> declare any static references ("static"
here being in the BETA meaning, e.g. <CODE>X: <B>@</B>P</CODE>, not to
be confused with <CODE>static</CODE> variables in Java/.NET) in a
pattern having an <CODE>__init</CODE> constructor. The problem is that
the compiler will currently try to instantiate the static references
before the <CODE>betaenv</CODE> is set up. This only pertains to
non-simple patterns; basic types like <CODE>integer</CODE>,
<CODE>char</CODE>, etc. can be specified statically.
</UL>

</UL>

<H3><A NAME="Instantiation">Instantiation</A></H3>

There are a number of ways to instantiate objects when using
constructors:

<UL>

<LI>Use <CODE>&amp;Foo[] -&gt; ...</CODE><BR>
This is the normal BETA instantiation mechanism. For a BETA pattern,
this creates the object, and sets up the surrounding object in the
usual BETA way. This means that the normal BETA constructor (either
implicit or a declared <CODE>_init</CODE> (one underscore) or 
<CODE>cons</CODE> without declared arguments) is called.<BR>
If <CODE>Foo</CODE> is a specialization of an
<CODE>ExternalClass</CODE>, this instantiation will lead to a call of
a parameterless constructor in the external class.

<LI>Use <CODE>(arg1, arg2, ..., argN) -&gt; &amp;Foo -&gt; ...</CODE>
This is an extension of the normal BETA instantiation mechanism. The
effect is like the one described above, except that a constructor with
declared arguments <CODE>(arg1, arg2, ..., argN)</CODE> is called. If
<CODE>Foo</CODE> is a normal BETA pattern, it <EM>must</EM> have a
declared <CODE>_init</CODE> (one underscore) or <CODE>cons</CODE> with
the specified parameter list for this to work.

<LI>Call method declared as <CODE>cons</CODE> on object<BR>
This is the prefered method for instantiating objects via an
instance constructor in an <CODE>ExternalClass</CODE>. 
However, it can be used internally in BETA too, see 
<A NAME="#cons">cons</A> above.

<LI>Call method declared as <CODE>static_cons</CODE> on
<CODE>ExternalClass</CODE>
This is the prefered method for instantiating objects via a static
constructor in an <CODE>ExternalClass</CODE>. 
It can <EM>not </EM>be used internally in BETA, see 
<A NAME="#static_cons">static_cons</A> above.

</UL>


<H2>Overloaded Methods</H2>
In external classes, <EM>method overloading</EM> is commonly
used. This means that a number of methods in a class may have the same
name, but different parameter lists and possibly return values
(neither Java nor .NET allows for overloaded methods to be
distinguished by different return values <EM>only</EM>).
<BR>
BETA does not have overloaded pattern names. To declare interface to
an <CODE>ExternalClass</CODE> with two or more methods with identical
names, in BETA just make corresponding <CODE>proc</CODE> (or
<CODE>static_proc</CODE>) declarations, where you specify the actual
(identical) external name as a string argument to an attribute called
<CODE>procname</CODE> in <CODE>proc</CODE>/<CODE>static_proc</CODE>. E.g.
<PRE class=beta>
foo: ExternalClass
  (# bar_I: proc
       (# i: @integer
       enter i	
       do 'bar' -&gt; procname;
       #);
     bar_C: proc
       (# c: @char
       enter c
       do 'bar' -&gt; procname;
       #);
  #);
</PRE>

It may seem confusing that the <CODE>procname</CODE> specification
resembles a statement, and a future version of the BETA compiler may
support an improved way of specifying this.

<H2>Not Yet Specifiable</H2>
The following do not yet have textual BETA representations, and
thus cannot be expressed directly in BETA. To access such entities,
you will currently have to make wrapper classes in Java/C#.

<UL>
<LI>Static fields
<LI>.NET enumerations
</UL>


</BODY>
</HTML>