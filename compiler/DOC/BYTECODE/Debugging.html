<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<title>Source Level Debugging</title>
<link rev="made" href="mailto:beta@daimi.au.dk">
<LINK REL="stylesheet" HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE="text/css">
</HEAD>

<BODY>

One of the advantages of using JVM and .NET is that if we generate
sufficient debug information the execution platforms directly support
source-level debugging of BETA code in their respective tools.
<P>
Below are preliminary examples of this for both .NET and JVM.
<P>
<UL>
<LI><A HREF="#clr">BETA.NET source level debugging</A></LI>
<UL>
<LI><A HREF="#vsnet">Debugging using Visual Studio .NET</A></LI>
<LI><A HREF="#dbgclr">Debugging using DbgCLR.exe</A></LI>
<LI><A HREF="#cordbg">Debugging using CorDBG.exe</A></LI>
<LI><A HREF="#il">IL debugging</A></LI>
</UL>
<LI><A HREF="#java">BETA.Java Source Level Debugging</A></LI>
<UL>
<LI><A HREF="#javagraphical">Graphical debuggers for Java?</A></LI>
<LI><A HREF="#jdb">Using jdb</A></LI>
</UL>
</UL>


<H2><A NAME="clr">BETA.NET source level debugging</A></H2>

You can source level debug BETA programs compiled for .NET with both
the free stand alone debuggers <CODE>DbgCLR.exe</CODE> (graphical) and 
<CODE>CorDBG.exe</CODE> (textual) supplied with the 
<A HREF="http://msdn.microsoft.com/netframework/downloads/howtoget.asp">.NET Framework SDK</A>
as well as with the built-in debugger in Visual Studio .NET.

<H3><A NAME="vsnet">Debugging using Visual Studio .NET</A></H3>

To use Visual Studio .NET for BETA source level debugging, do this:

<OL>
<LI>To debug foo.exe produced from foo.bet, you first choose menu item
    <CODE>[File->Open Solution...]</CODE>.
   
<LI>In the dialog that appears, you choose 
    <CODE>Files of types: All project files</CODE> and navigate to <CODE>foo.exe</CODE>.
    Double click <CODE>foo.exe</CODE>.

<LI>Now set a breakpoint at the beginning of the program:
    From menu item <CODE>[Debug->New Breakpoint (Ctrl-B)]</CODE> specify
    breakpoint in Function <CODE>program.do</CODE>.

<LI>Now start the program using menu item <CODE>[Debug->Start (F5)]</CODE>.
    The program will now stop at the do-part of the <CODE>PROGRAM</CODE> fragment.
    You can now single step, inspect variables etc. at BETA source
    level.
</OL>

Below is a screen shot showing a debugging session (slightly reduced
size; click image to see it in full size in a separate window):

<BLOCKQUOTE>
<A HREF="visual_studio_net_debug.jpg" TARGET="_blank">
<IMG SRC="visual_studio_net_debug.jpg" WIDTH="80%" HEIGHT="80%" ALT="Visual Studio .NET Debugging Session">
</A>
</BLOCKQUOTE>

As can be seen, a breakpoint has been set in <CODE>program.do</CODE>
(as described above) as well as in line 12 and 17. The latter two were
set using the contextual right button menu in the SuperFields.bet
source window.<BR>
The breakpoint at line 12 (in the <CODE>get</CODE> method has been
hit, and a single Step-into command has been issued, thus executing
the statement <CODE>x + y -&gt; z</CODE> (the maroon indication of the
statement seems to be off by one - we'll check this later (:-)).<BR>
As can be seen from the red 77 in the locals window, this assignment
caused the local variable named z to get the new value 77.
<P>
By default Visual Studio will only be able to find source files in the
current directory. This means that when you, e.g., "step into (F11)" a
method residing in a source file outside the current directory, this
will behave as a "step over (F10)"!. To avoid this, you can specify
the <CODE>Debug Source Files</CODE> property:<BR>
To access the <CODE>Debug Source Files</CODE> property page,
right-click on your <CODE>Solution</CODE> in <CODE>Solution
Explorer</CODE> and choose <CODE>Properties</CODE> from the shortcut
menu. Expand the <CODE>Common Properties</CODE> folder and click the
<CODE>Debug Source Files</CODE> page.  
<P>
Additional information can be found on, e.g., 
<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vsdebug/html/vxtskdebugginganexecreatedwithoutvisualstudioproject.asp">Visual Studio: Debugging an Executable That Is Not Part of a Visual Studio Solution</A>

<H3><A NAME="dbgclr">Debugging using DbgCLR.exe</A></H3>

Along with the free .NET framework comes a stand alone source level
debugger named <CODE>DbgCLR.exe</CODE>. It typically resides in 
<CODE>C:\Program Files\Microsoft.Net\FrameworkSDK\GuiDebug\DbgCLR.exe</CODE>

<OL>
<LI>
Open <CODE>DbgCLR.exe</CODE> by double clicking its icon in the Windows Explorer.

<LI>
Given that <CODE>foo.bet</CODE> has been compiled to <CODE>foo.exe</CODE>, you may now
specify <CODE>foo.exe</CODE> in menu item <CODE>[Debug->Program to debug]</CODE>.

<LI>
Now set a breakpoint at the beginning of the program:
From menu item <CODE>[Debug->New Breakpoint (Ctrl-B)]</CODE> specify
breakpoint in Function <CODE>program.do</CODE>.

<LI>
Now start the program using menu item <CODE>[Debug->Start (F5)]</CODE>.
The program will now stop at the do-part of the <CODE>PROGRAM</CODE> fragment.
You can now single step, inspect variables etc. at BETA source
level.

</OL>

Below is a screen dump showing the same debugging session as above in
Visual Studio .NET.

<BLOCKQUOTE>
<A HREF="dbgclr.jpg" TARGET="_blank">
<IMG SRC="dbgclr.jpg" WIDTH="80%" HEIGHT="80%" ALT="DbgCLR Debugging Session">
</A>
</BLOCKQUOTE>

Notice that <CODE>DbgCLR</CODE> will only be able to automatically
open source files in the <EM>current directory</EM>.
Thus when you "step into (F11)" a file, that does not reside in the
current directory, this will behave as a step over! 
This can be avoided by making the other source file "known" by
preopening it. If you accept saving the solution file, when the
current debug session is ended, the next time you debug the same
program, the previously opened source files will be known.
<P>
Addition information: 
<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netstart/html/vcorithecom20sdkdebugger.asp">CLR Debugger Solution Model</A>.

<H3><A NAME="cordbg">Debugging using CorDBG.exe</A></H3>

There is also a command line debugger included in the .NET
Framework.<BR>
It is named <CODE>cordbg.exe</CODE> and is normally automatically accessible
from your shell (as the .NET Framework Installer will have included
the path to it in your search path).
<P>
If you compiled with <CODE>nbeta -d</CODE>, <CODE>cordbg</CODE> is very useful for debugging
IL code. It automatically breaks a the main entry point when run as
<PRE class=beta>
&gt; cordbg foo.exe
</PRE>
The syntax for breaking in the do method of calls program is
<PRE class=beta>
(cordbg) b program::do
</PRE>
You may also use cordbg for source level debug, and specify, e.g.,
<PRE class=beta>
(cordbg) b foo.bet:16
</PRE>
to make it break in line 16 of <CODE>foo.bet</CODE>. In this case foo should be
compiled without the <CODE>-d</CODE> option. To get more help on using <CODE>cordbg</CODE>
type this:
<PRE class=beta>
(cordbg) help
</PRE>


<H3><A NAME="il">IL debugging</A></H3>
<P>
If you want to debug at IL level instead of BETA source level, you
can compile with:
<PRE class=beta>
&gt; nbeta -d foo
</PRE>
or (forcing total recompile):
<PRE class=beta>
&gt; nbeta -s 12 -d foo
</PRE>



<H2><A NAME="java">BETA.Java Source Level Debugging</A></H2>



<H3><A NAME="javagraphical">Graphical debuggers for Java?</A></H3>

We have so far had no success in doing BETA source level debugging in
any of the graphical debuggers for Java that we have tried.
For a survey of our efforts see <A HREF="Compare.html#javadbg">here</A>.


<H3><A NAME="jdb">Using jdb</A></H3>

The standard 
<A HREF="http://java.sun.com/j2se/1.4/download.html">J2SE SDK version 1.4</A> 
includes the textual debugger called
<CODE>jdb</CODE>.
Below is a session showing BETA source level debugging using this
debugger (notice that the class files generated by the BETA compiler
are placed in a sub directory named <CODE>jvm</CODE>, and the
currently the <CODE>main</CODE> function is placed in a file always
named <CODE>program.class</CODE>):

<PRE class=beta>
tcsh&gt; <B>jdb -classpath jvm program</B>
Initializing jdb ...
&gt; <B>stop in program.do</B>
Deferring breakpoint program.do.
It will be set after the class is loaded.
&gt; <B>run</B>
run program
&gt; 
VM Started: Set deferred breakpoint program.do
OK.

Breakpoint hit: "thread=main", program.do(), line=29 bci=0
29    do &SuperFieldsSub[] -&gt; S[];

main[1] <B>list</B>
25      #)
26    ---program:descriptor---
27    (# S: ^SuperFieldsSub;
28       N: @integer
29 =&gt; do &SuperFieldsSub[] -&gt; S[];
30       33 -&gt; S.x;
31       44 -&gt; S.y;
32       S.x -&gt; putint;
33       newline;
34       S.y -&gt; putint; 
main[1] <B>stop in SuperFieldsSub.get</B>
Deferring breakpoint SuperFieldsSub.get.
It will be set after the class is loaded.
main[1] <B>cont</B>
&gt; Set deferred breakpoint SuperFieldsSub.get
33
44

Breakpoint hit: "thread=main", SuperFieldsSub.get(), line=12 bci=0
12           do x -&gt; z;

main[1] <B>list</B>  
8      (# y: @integer;
9         R: ^SuperFieldsSub;
10         get: proc
11           (# z: @integer
12 =&gt;        do x -&gt; z;
13              z + y -&gt; z;
14           exit z
15           #); 
16         call: proc
17           (# N: @integer; P1,P2: ^SuperFieldsSub

main[1] <B>next</B>
&gt; 
Step completed: "thread=main", SuperFieldsSub.get(), line=13 bci=5
13              z + y -&gt; z;

main[1] <B>locals</B>
Method arguments:
Local variables:
z = 33
main[1] <B>dump this</B>
 this = {
    origin: instance of tstenv(id=292)
    y: 44
    R: null
    SuperFields.origin: instance of tstenv(id=292)
    SuperFields.x: 33
    SuperFields.Q: null
}

main[1] <B>where</B>
  [1] SuperFieldsSub.get (SuperFields.bet:13)
  [2] program.do (SuperFields.bet:36)
  [3] tstenv.program (null)
  [4] tstenv.do (tstenv.bet:174)
  [5] program.main (null)
main[1] <B>clear SuperFieldsSub.get</B>
Removed: breakpoint SuperFieldsSub.get
main[1] <B>cont</B>
&gt; 77
77
77
77
77


The application exited
tcsh&gt; 
</PRE>



</BODY>
</HTML>