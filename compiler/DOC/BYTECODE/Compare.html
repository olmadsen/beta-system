<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<title>Comparison of JVM and .NET platforms</title>
<link rev="made" href="mailto:beta@daimi.au.dk">
<LINK REL="stylesheet" HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE="text/css">
</HEAD>

<BODY>

<H1>Comparison of JVM and .NET platforms</H1>

Below follows a list of notable differences in the JVM and .NET
platforms, which has had effect on our code generation principles.
<P>

<DL>

<DT><B><A NAME="fields">References to fields</A></B>
<DD>When refering a field F in an object OBJ of class CLS, which has
superclass SUP, and where F is declared in SUP a difference exist:
<UL>
<LI>In .NET you must refer the field as SUP::F
<LI>In JVM you must refer the field as CLS/F
</UL>

<DT><B><A NAME="numclasses">Number of classes in files</A></B>
<DD>
<UL>
<LI>In JVM each public class must be in a separate file, with the
same name as the class
<LI>In .NET any number of classes (and other stuff) can be packed into
an <EM>assembly</EM>
</UL>


<DT><B><A NAME="classref">References to other classes</A></B>
<DD>When refering classes in other files a difference exist:
<UL>
<LI>In .NET you must in general refer the other class using a fully
qualified name:
<BLOCKQUOTE>
[resolution]namespaces.class
</BLOCKQUOTE>
where resolution (which we internally call <EM>location</EM>) is the
file location of the dll/netmodule/exe containing the class.
<LI>In JVM you need not specify any resolution/location, as long as
the class loader can find the class in the CLASSPATH. This, of course,
is possible because the class wil be in a file of the same name.
</UL>
On .NET this has caused us some troubles because our separate compilation
scheme means that when generating code for a class containing unbound
SLOTS in general we do not know in what files these SLOTs are bound,
and thus we cannot know how to refer these classes.<BR>
The solution we have chosen is to generate every SLOT binding
(fragment form) in a separate file with the same name as the SLOT
(much in the JVM style).<BR>
Instead of using fully qualified names for classes, one can chose to
use partial assembly names, and then use the methods of the 
<CODE>Assembly</CODE> class in the <code>system.reflection</code>
namespace. we have tried to do this but did not succeed.

<DT><B><A NAME="newobj">Allocating new objects</A></B>
<DD>When allocating new objects a difference exist:
<UL>
<LI>In JVM you first call <CODE>new</CODE> and then call the
constructor <CODE>&lt;init&gt;</CODE> of the newly generated object.
<LI>In .NET you call <CODE>newobj</CODE> with the constructor of the
class as argument. Then <CODE>newobj</CODE> calls the constructor.
</UL>
This implies one difference in code generation: On .NET you must push
all arguments to the constructor <EM>before</EM> calling
<CODE>newobj</CODE>, whereas on JVM, you push the constructor
arguments <EM>after</EM> the <CODE>new</CODE> call (just before the
call of <CODE>&lt;init&gt;</CODE>).

<DT><B><A NAME="locals">Local variables</A></B>
<DD>For local variables in functions a difference exist:
<UL>
<LI>In .NET all local variables must be <EM>declared with type</EM>
<LI>In JVM you only declare how many local variables you need
</UL>
This means that where you can sometimes reuse local variables for
different values in JVM, you cannot do this in .NET unless the
different values are of the same type.


<DT><B><A NAME="stack">Different stack manipulation bytecodes</A></B>
<DD>Despite being a stack based architecture, .NET has chosen to leave
out some of the stack manipulating bytecodes, that JVM has:
<UL>
<LI>
<B>.NET has no <CODE>swap</CODE> instruction<BR></B>
This affects the evaluation order the compiler can use, but can in
general be solved.
<LI>
<B>.NET has no <CODE>dup_x1</CODE> or <CODE>dup_x2</CODE></B>
instructions<BR>
This has proven to be a complicated problem for us. E.g. the BETA
evaluation
<PRE class=beta>
x -&gt; y -&gt; z
</PRE>
demonstrates this: The java code for this is
<PRE class=beta>
&lt;push object of z field&gt;
&lt;push object of y field&gt;
&lt;evaluate x&gt; ; pushes result on stack
dup_x1
putfield y
putfield z
</PRE>

However in .NET we have to use a local variable to store the duplicate
in. And since local variables are typed (as noted above) we need a
separate local variable for each situation, where we would have used
dup_x1:

<PRE class=beta>
&lt;push object of z field&gt;
&lt;push object of y field&gt;
&lt;evaluate x&gt; ; pushes result on stack
dup
.locals init ([n] &lt;type of x&gt;) // n is the next free local
variable slot
stloc n
stfld y
ldloc n
stfld z
</PRE>
</UL>

<DT><B><A NAME="float">Different float addressing</A></B>
<DD>In various situations you must reserve <EM>two</EM> slots when
addressing floating point variables in Java bytecode. E.g. when 
an argument for a methods is a float, the next argument is addressed
two numbers higher.<BR>
On .NET this is not an issue - the variables are numbered sequently no
matter their types.

<DT><B><A NAME="keywords">Java lack of keyword escaping</A></B>
<DD>When generating bytecode for BETA, the do-parts of patterns where originally
turned into a method called <CODE>do()</CODE>. If java code is to call
this method directly, currently the only means for doing this is by
using reflection, since the word <CODE>do</CODE> is a reserved word in
Java.
<BR>
In contrast, in C# one can call such a method by "escaping" the
keyword (using <CODE>@do()</CODE>).
But due to the problem in Java, we now instead call this method 
<CODE>Do</CODE> (capital <CODE>D</CODE>).

<DT><B><A NAME="javadbg">No Java graphical debugger that supports non-java source files?</A></B>
<DD>
Unlike the nice experience with Microsoft Visual Studio .NET source
level debugging (see <A HREF="Debugging.html">Source Level
Debugging</A>)
we have so far had no success in doing source level debugging in any
graphical Java debugger.<P>
The following IDE's and debuggers have been tried.
None of them seem to respect a <CODE>Sourcefile</CODE> attribute which points to non
java source files. Some even did not allow opening a class file
directly, and the ones that did all generated a Java source file stub
from the BETA generated class file.

<P>
<B>IDE's</B>
<UL>
<LI>NetBeans [<A HREF="http://www.netbeans.org">http://www.netbeans.org</A>]
<LI>Eclipse [<A HREF="http://www.eclipse.org">http://www.eclipse.org</A>]
<LI>JBuilder 7 [<A HREF="http://www.borland.com/jbuilder">http://www.borland.com/jbuilder</A>]
<LI>Oracle9i JDeveloper [<A HREF="http://www.oracle.com/ip/develop/ids/">http://www.oracle.com/ip/develop/ids/</A>]
</UL>

<P>
<B>Debuggers</B>
<UL>
<LI>SUN javadt [<A HREF="http://java.sun.com/products/jpda/">http://java.sun.com/products/jpda/</A>]
<LI>jswat [<A HREF="http://www.bluemarsh.com/java/jswat/">http://www.bluemarsh.com/java/jswat/</A>]
<LI>jdebugtool [<A HREF="http://www.debugtools.com">http://www.debugtools.com</A>]
<LI>jdpkg [<A HREF="http://www.cs.huji.ac.il/support/docs/java/jikes/jd.html">http://www.cs.huji.ac.il/support/docs/java/jikes/jd.html</A>]
</UL>

<P>
All seem to depend on JDI (Java Debugger Interface),
which is assumed not to support non-java sourcefiles.
<BR>
On the other hand jdb support non java source files(?)

<P>
<B>Command line wrappers</B>
<UL>
<LI>jdbtool [<A HREF="http://www.oops.demon.co.uk/jdbtool">http://www.oops.demon.co.uk/jdbtool</A>]</LI> 
Tk jdb wrapper - expects .java file
<LI>ddd [<A HREF="http://www.gnu.org/software/ddd/">http://www.gnu.org/software/ddd/</A>]</LI> 
binary jdb/gdb/etc. wrapper - expects .java file
</UL>

</DL>


</BODY>
</HTML>