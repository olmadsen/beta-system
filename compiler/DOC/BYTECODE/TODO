
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A. General
==========

1. Problem med overskrivning af program.il/program.class for hvert
   program.
    -> Muligvis lave subdirectory til denne navngivet udfra exefilen
1.a
   Aflægger af problemet: Hvis man oversætter foo.bet, og siden
   oversætter bar.bet, men bar.class/bar.il er nyere end bar.bet, så
   bliver der ikke genereret en ny program.class/program.il, og
   afvikling af bar vil derfor udføre foo.

2. Dependency analyse for .il/.dll/.class filer - er det løst generelt?


B. Java specific
================

1. * Få GENERATOR/BYTECODE/TEST/helloapplet.bet til at virke

2. * For hver .bet fil, der oversættes, bliver den *sidste* .class file,
     dette giver anledning til, genereret 2 gange.

C. .NET specific
================

1. ** [OLM/PA] 
   Problemer med Cstruct.
   Verificeret 2/7.

   ------------------------------------------------------------------------------------
   [tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode callvirt] [found objref ('this' ptr) 'CStruct'] [expected Int32] Unexpected type on the stack.
   
        .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
        {
              ldarg.0
              call    instance void [mscorlib]System.Object::.ctor()

              ldarg.0
              ldarg.1
              stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin 
              ldarg.0
              ldarg.0
              callvirt instance int32 class ['tstenv']'CStruct'::'byteSize'(int32)
              newarr int32
              stfld   int32[] class ['tstenv']'CStruct'::'R' 
              ret
        }   

   ------------------------------------------------------------------------------------
   [tstenv.dll : CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow.
   
 	.method public virtual int32 'exit'() cil managed 
 	{
 	      .maxstack 8
 	      dup
 	      .locals init ([0] int32)
 	      stloc.0

 	      ret
 	}     

   ------------------------------------------------------------------------------------
   Samme er i Cstruct_long.

2. FIXED!

3. FIXED!

7. [PA]
   All source files constituting an executable must currently reside
   in the same directory.
   We intent to generate strong assemblies and config files and/or use
   the Global Assembly Cache for solving this later.

8. * [OLM]
   Vi skal kunne specificere fil location for en externalclass, og
   denne fil location skal med ind i import listen.
   Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
   behøver at skulle erklære eksterne klasser og procedurer [PA]

   Vi bør understøtte
      BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
   samt
      INCLUDE 'aSystemAssembly.dll'
   som begge bør
      1. Føre til import af assembly
      2. (senere) føre til indlæsning af klasser i assembly og
         opbygning af ast

9.  * [OLM] Lokal location skal ikke med
    Hvis man f.eks. oversætter
	 ORIGIN 'tstlib';         
	 -- program: Descriptor --
	 (# 
	 do 'a' -> put;
	    'b' -> fill;
	 #)  
    så vil der i program.il være en del referencer til klassen
    program, hvor der medtages location ['program'], hvilket ikke
    er nødvendigt, da det jo er i samme fil.
    F.eks.:

	  .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
	  {
		ldarg.0
		call	instance void [mscorlib]System.Object::.ctor()
	
		ldarg.0
		ldarg.1
		stfld	class ['tstenv']'tstenv' class ['program']'program'::origin 
		ret
	  }
	
	  .method public static void 'program'(class ['tstenv']'tstenv') cil managed 
	  {
		.maxstack 8
		ldarg.0
	
		newobj	instance void class ['program']'program'::.ctor(class ['tstenv']'tstenv')
		callvirt instance void class ['program']'program'::'do'()
		ret
	  }     

    Det er ikke kun æstetisk det generer: det forhindrer verifikation
    af programmet (men det kan godt køre).

10. FIXED!

11. Verification errors ved oversættelse af btst minus tstvirt2:
    Jeg skal nok uddybe disse senere.
 
	[slot_exe.dll : slot_exe::.ctor] Could not load type  from assembly 
	[tstvirt.dll : TstVirt_D2::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_T::set] [offset 0x00000005] [opcode ret] Stack must be empty on return from a void function.
	[tstvirt.dll : TstVirt_TT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_TTT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_TTTT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_DD::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstblock.dll : TstBlock_singular_1::do_1] [offset 0x0000003B] [opcode ret] Stack must be empty on return from a void function.
	[tstblock.dll : TstBlock_singular_1::do_1] [offset 0x0000003B] Stack depth differs depending on path.
	[tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : isNTI::exit] [offset 0x00000006] [opcode call] [token  0x0A000072] Unable to resolve token.
	  -> detaljer: se 10.
	[tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode callvirt] [found objref ('this' ptr) 'CStruct'] [expected Int32] Unexpected type on the stack.
	  -> detaljer: se 1.
	[tstenv.dll : CStruct::.ctor] [offset 0x00000019] [opcode stfld] Stack underflow.
	[tstenv.dll : CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow.
	  -> detaljer: se 1.
	[tstenv.dll : CStruct_Long::exit] [offset 0x00000000] [opcode dup] Stack underflow.
	  -> detaljer: se 1.

12. *** [OLM]
      Problem med Object.

      F.eks. i TstVirt_T.set():
       
        .method public virtual void 'set'() cil managed 
        {
              .maxstack 8
              //newobj        instance void class [mscorlib]System.Object::.ctor(class ['tstenv']'tstenv')
              ret
        }

      Set er erklaæret således:
         set:< object
      Do delen af dette er vel tom?
      I hvert fald skal der ikke noget argument med tili instantieringen af Object.
      Du instantierer også et objekt i java, men det bruges ikke til noget
      (og giver fejl på dotnet, hvis jeg ikke som her kommenterer
      det helt ud: stack skal være tom når man går ud af en void
      function). 
