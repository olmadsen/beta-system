
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A. General
==========

1. Problem med overskrivning af program.il/program.class for hvert
   program.
    -> Muligvis lave subdirectory til denne navngivet udfra exefilen
1.a
   Aflægger af problemet: Hvis man oversætter foo.bet, og siden
   oversætter bar.bet, men bar.class/bar.il er nyere end bar.bet, så
   bliver der ikke genereret en ny program.class/program.il, og
   afvikling af bar vil derfor udføre foo.

2. Dependency analyse for .il/.dll/.class filer

3. Oversættelse af GENERATOR/BYTECODE/TEST/google fejler på begge
   platforme (vil kun kunne køre under dotnet som øjeblikkeligt
   implementeret, men compiler fejlen kan reproduceres med jbeta,
   derfor placeret her i generelle afdeling):

	Target machine platform: javabc
	Building dependency graph for: 'google' ...
	
	*** Error/warning in property list of:
		/users/datpete/beta/r5.3/compiler/GENERATOR/BYTECODE/TEST/google
	
		*** Property "build" has no value for "javabc"
	
	
	Translating fragments ...
	Bind fragments in: 'google'!Checking!Code generation
        # Beta execution aborted: Repetition index out of range



B. Java specific
================

1. Få GENERATOR/BYTECODE/TEST/helloapplet.bet til at virke


C. .NET specific
================

1. ** [OLM/PA] 
   Jeg måtte udkommentere en række af de basale patterns i tstenv, da
   der genereres ikke-verificerbart kode for disse. Primært fordi der
   er void funktioner, der efterlader noget på stakken. Det er
   f.eks. state, cstruct, der har problemet. 
   Detaljer (verificeret statig tilstede 31/5)

   ------------------------------------------------------------------------------------
   CStruct::.ctor] [offset 0x0000000D] [opcode callvirt] Stack empty:
   
     .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
     {
           ldarg.0
           call    instance void [mscorlib]System.Object::.ctor()
   
           ldarg.0
           ldarg.1
           stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin
           callvirt instance int32 class ['tstenv']'CStruct'::'byteSize'(int32)
           ldarg.0
           newarr int32
           stfld   int32[] 'CStruct'::F12
           ret
     }

   ------------------------------------------------------------------------------------
   CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow:
   
     .method public virtual int32 'exit'() cil managed
     {
           .maxstack 8
           dup
           ldstr "FIXME: IL has no dup_x1/dup_x2 instructions"    <--------
           call void [mscorlib]System.Console::WriteLine(string)
           ret
     }
   
   Skulle åbenbart have været dup_x1, men det ville jo også give stack
   underflow
   
   ------------------------------------------------------------------------------------
   Samme er i Cstruct_long.

2. FIXED!

3. ** [OLM/PA]
   Ved oversættelse af TST/btst crasher compiler under kodegenerering af
   tstvirt2.
   Sker både med nbeta og jbeta på pc OG LINUX men ikke med nogen af dem på sun
     -> Sikkert et endian problem

7. [PA]
   All source files constituting an executable must currently reside
   in the same directory.
   We intent to generate strong assemblies and config files and/or use
   the Global Assembly Cache for solving this later.

8. * [OLM]
   Vi skal kunne specificere fil location for en externalclass, og
   denne fil location skal med ind i import listen.
   Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
   behøver at skulle erklære eksterne klasser og procedurer [PA]

   Vi bør understøtte
      BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
   samt
      INCLUDE 'aSystemAssembly.dll'
   som begge bør
      1. Føre til import af assembly
      2. (senere) føre til indlæsning af klasser i assembly og
         opbygning af ast

9.  * [OLM] Lokal location skal ikke med
    Hvis man f.eks. oversætter
	 ORIGIN 'tstlib';         
	 -- program: Descriptor --
	 (# 
	 do 'a' -> put;
	    'b' -> fill;
	 #)  
    så vil der i program.il være en del referencer til klassen
    program, hvor der medtages location ['program'], hvilket ikke
    er nødvendigt, da det jo er i samme fil.
    F.eks.:

	  .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
	  {
		ldarg.0
		call	instance void [mscorlib]System.Object::.ctor()
	
		ldarg.0
		ldarg.1
		stfld	class ['tstenv']'tstenv' class ['program']'program'::origin 
		ret
	  }
	
	  .method public static void 'program'(class ['tstenv']'tstenv') cil managed 
	  {
		.maxstack 8
		ldarg.0
	
		newobj	instance void class ['program']'program'::.ctor(class ['tstenv']'tstenv')
		callvirt instance void class ['program']'program'::'do'()
		ret
	  }     

    Det er ikke kun æstetisk det generer: det forhindrer verifikation
    af programmet (men det kan godt køre).

10. * [OLM] 'isNTI_ms' bliver til 'ms'
    I klassen isNTI_ms ser det ut til at den statiske isNTI_ms metode,
    denne burde indeholde, er kommet til at hedde 'ms'.
      -> name mangling problem

11. Verification errors ved oversættelse af btst minus tstvirt2:
    Jeg skal nok uddybe disse senere.
 
	[slot_exe.dll : slot_exe::.ctor] Could not load type  from assembly 
	[tstvirt.dll : TstVirt_D2::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_T::set] [offset 0x0000000B] [opcode newobj] [token  0x0A00003D] Unable to resolve token.
	[tstvirt.dll : TstVirt_T::set] [offset 0x0000000B] [opcode newobj] [token  0x0A00003D] Unable to resolve token.
	[tstvirt.dll : TstVirt_T_singular_1::do] [offset 0x00000006] [opcode callvirt] [token  0x0A000042] Unable to resolve token.
	[tstvirt.dll : TstVirt_TT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_TTT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_TTTT::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstvirt.dll : TstVirt_DD::.ctor] [offset 0x00000002] [token  0x01000013] [argument #0x00000000] Unable to resolve token.
	[tstblock.dll : TstBlock_singular_1::do_1] [offset 0x0000003B] [opcode ret] Stack must be empty on return from a void function.
	[tstblock.dll : TstBlock_singular_1::do_1] [offset 0x0000003B] Stack depth differs depending on path.
	[tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] Stack must be empty on return from a void function.
	[tstlib.dll : isNTI::exit] [offset 0x00000006] [opcode call] [token  0x0A000072] Unable to resolve token.
	[tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode callvirt] [found objref ('this' ptr) 'CStruct'] [expected Int32] Unexpected type on the stack.
	[tstenv.dll : CStruct::.ctor] [offset 0x00000019] [opcode stfld] Stack underflow.
	[tstenv.dll : CStruct_Byte::exit] [offset 0x00000000] [opcode dup] Stack underflow.
	[tstenv.dll : CStruct_Long::exit] [offset 0x00000000] [opcode dup] Stack underflow.

12. *** [OLM]
      En række fejl i tstvirt.il:
       
      /********************************************/
      /*        Class TstVirt_T_singular_1        */
      /********************************************/
      .class public auto ansi 'TstVirt_T_singular_1' extends [mscorlib]System.Object{
        .field public class ['tstvirt']'TstVirt_T' origin
        .field public class [mscorlib]System.Object 'R'
       
        ....
       
        .method public virtual void 'do'() cil managed 
        {
              .maxstack 8
              ldarg.0
              ldfld   class ['tstvirt']'TstVirt_T' class ['tstvirt']'TstVirt_T_singular_1'::origin 
              callvirt instance void class  [/*'tstenv'*/tstvirt]'TstVirt_T'::'set'() 
               ldarg.0
              //ldarg.0
              //ldfld class ['tstvirt']'TstVirt_T' class ['tstvirt']'TstVirt_T_singular_1'::origin
              newobj  instance void class [mscorlib]System.Object::.ctor(/*class ['tstenv']'tstenv'*/)
              stfld   class [mscorlib]System.Object class ['tstvirt']'TstVirt_T_singular_1'::'R' 
              .line   42:45 'tstvirt.bet'
              ret
        }

      Du kan se hvad jeg har ændret:
      1. i callvirt af metode set skal location for TstVirt_T ikke være tstenv men tstvirt.
      2. Ved allokering af Object skal der ikke noget argument med til constructoren
       
       
      Herudover et tilsvarende problem i TstVirt_T.set():
       
        .method public virtual void 'set'() cil managed 
        {
              .maxstack 8
              //ldarg.0
              //ldfld class ['tstvirt']'TstVirt' class ['tstvirt']'TstVirt_T'::origin 
              //ldfld class ['tstenv']'tstenv' class ['tstvirt']'TstVirt'::origin 
       
              //newobj        instance void class [mscorlib]System.Object::.ctor(class ['tstenv']'tstenv')
              ret
        }

      Set er erklaæret således:
         set:< object
      Do delen af dette er vel tom?
      I hvert fald skal der ikke noget argument med tili instantieringen af Object.
      Du instantierer også et objekt i java, men det bruges ikke til noget
      (og giver fejl på dotnet, hvis jeg ikke som her kommenterer
      det helt ud: stack skal være tom når man går ud af en void
      function). 
