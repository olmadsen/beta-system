
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A.   General
============

A1.  Missing BETA features
     a. Covariant parameters(?)
    	Ole currently working with it
 
A2.  Interface to external features
     a. Enumerations
    	Problem: The *values* are simple numbers, but they are *typed*
    	in external languages.
    	Currently problem in TEST/hellographics (LinearGradientMode)
	if enumerations_implemented is set to true.
     b. Value types (structs)
    	Handle as dynamic or static beta references?
    	Allocation (does not use new/newobject, but calls constructor)
     c. Static fields
     d. Hvorledes skal vi bære os ad med at fange exceptions som rejses af
	java klasse rutiner? F.eks. foresager basiclib/demo/file/fileerror en
	exception. Vi kan jo ikke syntaktisk udtrykke try-catch i beta.
	Der er dog i betaenv patterns try og throw, men hvis try skal kunne
	fange exceptions fra java skal compileren kende til dette pattern,
	eller også skal vi have nogle %try, %catch og %throw primitiver, 
	som disse patterns kan implementeres med.

 
A3. Introduce properties for patterns in BETA (instead of prefixes)?
     Examples:
       - proc
       - class
       - static
       - byval
       - enum

A4.  Detalje med real32 konstanter

     Prøv at oversætte flg. program:

     ORIGIN 'tstenv';
     --LIB:attributes--
     foo: externalclass
     	 (# f: proc
     	    (# x: @real32
     	    enter x
     	    #);
     	 #)
     --PROGRAM: descriptor--
     (# f: ^foo;
     do &foo[] -> f[];
     	  15 -> f.f;
     	  15.0 -> f.f;
     #)
     
     Hvis man ser på det genererede kode kan man se at der ikke overføres
     aktuel parameter af type float32 i det første kald af f.f, men kun i
     det andet, hvor man eksplicit gør det klart at der er tale om en float
     konstant.

A5.  int64 arithmetic

A6.  Problems with TEST/betaenv*.bet

     A few constructs used in TEST/betaenv*.bet cause verification
     problems. These are all marked with

     FIXME: bytecode verification problems

A7.  TOS'DoGC'

     Bind fragments in: 'betaenv_stdbody'!Checking
     ==================
     Compiler warnings:
     ==================
     
     tos'DoGC'
	     ^
     ***** TOS-primitives are no longer supported - use new %-primitives in
     stead
     ----- line: 174; char positions: 5136,5151 -----
     
     Den burde nok erstattes af et nyt primitiv.



B.   Java specific
==================

B1.  Make (some) graphical Java debugger able to handle BETA?
     -> ask SUN

B2.  (Work around for problem implemented)     

B3.  (Problem disappeared after recoding)

B4.  * [OLM]
     Problem med objinterface (%asComponent og beta/lang/Object).

     Jeg har prøvet at implementere lidt mere af objinterface til jvm (jeg
     skulle lige have en pause fra JNI (:-)).
     
     Jeg har prøvet at bruge .%asComponent et par steder i
     objinterface_jvmbody (under antagelse af at den returnerer NONE, hvis
     objektet ikke er en component). Men der kommer semantisk fejl, når den
     bruges i boolean-evaluation (led efter FIXME; det er pt kommenteret ud).
     
     Jeg har endvidere forsøgt at kode noget reflektion i beta, til at
     implementere udskrift af et objekts felter i printObj.
     Dette giver en underlig 
     
     java.lang.NoClassDefFoundError: beta/lang/Object
				     ^^^^^^^^^^^^^^^^
     
     Det er argumenterne til f.eks. Field.getType, der bliver af denne
     type.
     Disse er erklæret til at være Object, og skulle i en external proc
     blive til java/lang/Object.
     
     Denne sidste fejl kommer ved at ændre print_field_values til true.

B5.  *** [OLM]
     Program:

     Origin '~beta/basiclib/betaenv';
     --lib: attributes--
     indenter:
       (# contents: [1] ^textLine;
	  textLine:<
	    (# 
	    #);
	  setContents:<
	    (# unformattet: ^text; 
	    enter unformattet[]
	    <<SLOT setContents: doPart>> 
	    #);
       #);
     betaIndenter: indenter
       (# textLine::
	    (# 
	    #);
	  setContents:: (# <<SLOT beta_setContents:doPart>> #);
       #);
     -- setContents: DoPart --
     do (# (* stuff deleted *)
	do INNER setContents;
	#);
     -- beta_setContents: DoPart --
     do (if (contents[1][]<>NONE) then
	if)  
     --program: descriptor--
     (# i: @betaindenter;
     do '(# #)' -> i.SetContents;
     #)   
   
   Error:

   java.lang.NoSuchFieldError: contents
        at beta.betaIndenter$setContents.do_1(../../indenter.bet:26)

B6. * [OLM]
    In the following code (can be activated by trying the demo
    process/demo/lsl), the two temporary variables isr and temp are
    needed.
    If they are left out, verification errors will occur at run time:
    Part of process/private/processmanager_jvm.bet:

       OutErrHandler: Thread
	 (# 
	    is: ^InputStream;
	    
	    setstream: 
	      (# 
	      enter is[]
	      #);
	    
	    run:
	      (# br: ^BufferedReader;
		 temp: ^String;
		 isr: ^InputStreamReader;
	      do is[] 
		   -> InputStreamReader._init_InputStream
		   -> isr[]; (* FIXME *)
		 isr[]
		   -> BufferedReader._init_Reader -> br[];
		 read:
		   (if (br.readLine->temp[] (* FIXME *))<>NONE then
		       temp[] -> screen.putline;
		       restart read;
		   if);
		 is.close;
	      #);
	 #);  

    The first FIXME indicates that if the assignment is done as
 
                 is[] 
		   -> InputStreamReader._init_InputStream
		   -> BufferedReader._init_Reader -> br[]

    a verification error "call to wrong initialization method" occurs.
    This has something to do with order of calls of <init> and
    super-<init>
    The second FIXME indicates that if temp is declared as Text
    instead of String, the verification error "Unable to pop operand
    off an empty stack" occurs.


C.   .NET specific
==================

C0.  Eliminated by rewrite

C1.  Codegeneration for .NET compact framework
     - switch 186 currently used
     - possibly a new target platform (clr_cf)?
     - looking up version/publickeys in CF DLLs?
     	-> ask microsoft
     
C2.  [PA/OLM]
     Vi skal kunne specificere kompleks location (f.eks. med
     versionsnummer) for en externalclass.
     Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
     behøver at skulle erklære eksterne klasser og procedurer [PA]
     Delvis løsning er lavet: Hvis assemblyet er i Global Assembly
     cache slås dets versionsnummer op og bruges af compiler.
     
     Vi bør understøtte
     	 BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
     samt
     	 INCLUDE 'aSystemAssembly.dll'
     som begge bør
     	 1. Føre til import af assembly
     	 2. (senere) føre til indlæsning af klasser i assembly og
     	    opbygning af ast
     
     
C3.  * [OLM] Lokal location skal ikke med
     Hvis man f.eks. oversætter
     	   ORIGIN 'tstlib';         
     	   -- program: Descriptor --
     	   (# 
     	   do 'a' -> put;
     	      'b' -> fill;
     	   #)  
     så vil der i program.il være en del referencer til klassen
     program, hvor der medtages location ['program'], hvilket ikke
     er nødvendigt, da det jo er i samme fil.
     I visse tilfæde forvirrer dette verifieren.
     
C4.  Kommenterede verification errors ved oversættelse af btst:
     (Sidst konstateret: 2002-08-08 - sikkert bedre nu)
     
     a. [tstref.dll : tstRef$noNone::do] [offset 0x00000009] [opcode stloc.0] [found objref 'text'] [expected Int32] 
     	  -> Unexpected type on the stack.
     
     	    .method public virtual void 'do'() cil managed 
     	    {
     		  .maxstack 1000
     		  ldarg.0
     		  ldarg.0
     		  ldarg.0
     		  callvirt instance class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'bar'()
     		  dup
     		  .locals init ([0] int32)
     		  stloc.0
     		  stfld	class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'s' 
     		  ldloc.0
     		  callvirt instance void class ['tstref']'tstRef$noNone'::'foo'(class ['tstenv']'text')
     		  ret
     	    }     
     
     	  Ser ud til at allocAndStoreLocal kaldes med forkert type
     	  (int32 istedet for text).
     
     b. [tstref.dll : tstRef$noNone::do] [offset 0x00000010] [opcode callvirt] [found Int32] [expected objref 'text'] 
     	  -> Unexpected type on the stack.
     
     	  Samme som C6.a
     
     c. [tst\clr\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000020] [opcode beq] 
     	  -> Int32 objref 'BetaObject' Non-compatible types on the stack.
     
     Detaljer (debug/fixme kode rykket ind for ikke at forvirre):
     
     	     .method public virtual void 'do'() cil managed 
     	      {
     		    .maxstack 1000
     		    ldarg.0
     		    ldfld   class ['tstenv']'BetaObject' class ['tstvirt2']'tstvirt2$final2virtZ$Xqua'::'R' 
     			    // pushReg %top
     			    ldstr "FIXME: Primitive NYI: ObjS(Unknown)"
     			    call void [mscorlib]System.Console::WriteLine(string)
     			    // pushReg %top
     		    newobj  instance void class ['tstenv']'BetaObject'::.ctor()
     			    // pushReg %top
     			    // pushReg %call
     			    ldstr "FIXME: Primitive NYI: leS(Unknown)"
     			    call void [mscorlib]System.Console::WriteLine(string)
     		    ldc.i4.0
     		    beq     L2
     
     d. [tst\clr\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000056] [opcode ret] 
     	  -> Stack must be empty on return from a void function.
     
     e. [tstvirt2.dll : tstvirt2$future::do] [offset 0x00000023] [opcode ldfld] [token  0x0A0001AE] 
     	  -> Unable to resolve token.
     
     f. [tst\clr\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     g. [tst\clr\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] 
     	 -> Stack depth differs depending on path.
     
     	 Detaljer: Forsøg på stakhøjde annotering:
     
     	  .method public virtual void 'do_1'() cil managed 
     	  {
     		  .maxstack 1000
     		  ldarg.0 /* 1 */ 
     		  ldfld	class ['tstblock']'TstBlock' class ['tstblock']'TstBlock$singular_1'::origin /* 1 */ 
     		  ldfld	class ['tstenv']'tstenv' class ['tstblock']'TstBlock'::origin /* 1 */ 
     		  ldarg.0 /* 2 */ 
     		  ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c' /* 2 */ 
     		  callvirt instance void class ['tstenv']'tstenv'::'put'(char) /* 0 */ 
     		  ldarg.0 /* 1 */ 
     		  ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c'  /* 1 */ 
     		  dup /* 2 */ 
     		  ldc.i4.s 118  /* 3 */ 
     		  bne.un	L14 /* 3 */ 
     		  pop /* 2 */ 
     		  ldarg.0 /* 3 */ 
     		  br	L13 /* 3 */ 
     	  L14:    /* 3 (kommer fra bne.un ovenfor */ 
     		  dup /* 4 */
     		  ldc.i4.s 122  /* 5 */ 
     		  bne.un	L15 /* 5 */ 
     		  pop /* 4 */ 
     		  ldarg.0 /* 5 */ 
     		  br	L13 /* 5 */ 
     	  L15:    /* 5 (kommer fra bne.un ovenfor) */
     		  pop /* 4 */ 
     	  L13:
     		  ret /* 4 (hvis man kommer fra pop ovenfor) */ /* 5 (hvis man kommer fra br L13 ovenfor) */ 
     	  }     
     
     
     h. [tst\clr\tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] 
     	  -> Stack must be empty on return from a void function.
     
     	   .method public virtual void 'do'() cil managed 
     	   {
     		 .maxstack 1000
     		 ldarg.0
     		 ldarg.0
     		 ldarg.0
     		 ldarg.0
     		 ldfld   int32 class ['tstlib']'chkR'::'i' 
     		 ....
     
     	 Lang - men ligner også for mange load af this, ligesom nedenfor.
     
     i. [tst\clr\tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     	 .method public virtual void 'enter'(int32,int32,char) cil managed 
     	 {
     	       .maxstack 1000
     	       ldarg.0
     	       ldarg.0
     	       ldarg.0
     	       ldarg.1
     	       stfld   char class ['tstlib']'chkR'::'ch' 
     	       ret
     	 }
     
     	 For mange load af this.
     
     
     j. [tst\clr\tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     Lang - men ligner også for mange load af this.
     
     k. [tst\clr\tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     	    .method public virtual void 'enter'(int32,int32) cil managed 
     	    {
     		  .maxstack 1000
     		  ldarg.0
     		  ldarg.0
     		  ret
     	    }  
     
     Ligner C6.i problemet.
     
     l. [tst\clr\tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode newobj] 
     	 -> [found objref ('this' ptr) 'CStruct'] [expected objref 'tstenv'] Unexpected type on the stack.
     
     	    .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
     	    {
     		  ldarg.0
     		  call    instance void ['tstenv']'BetaObject'::.ctor()
     
     		  ldarg.0
     		  ldarg.1
     		  stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin 
     		  ldarg.0
     		  ldarg.0    <-- Dette er et Cstruct object (this)
     
     		  newobj  instance void class ['tstenv']'IntegerObject'::.ctor(class ['tstenv']'tstenv')
     		
     	     IntegerObjects constructor forventer en tstenv origin.
     
     m. [tst\clr\tstenv.dll : CStruct$Byte::exit] [offset 0x00000000] [opcode dup] 
     	 -> Stack underflow.
     
     		.method public virtual int32 'exit'() cil managed 
     		{
     		      .maxstack 1000
     		      dup
     		      .locals init ([0] int32)
     		      stloc.0
     
     		      ret
     		}          
     
     	  Der mangler vist noget?
     
     n. [tst\clr\tstenv.dll : CStruct$Long::exit] [offset 0x00000000] [opcode dup] 
     	 -> Stack underflow.
     
     	  Samme som C6.m.
     
C5.  Import handling clean-up:
     All imports should be able to handle in
     signature.bet:descLocation, but some imports are also done in
     signature.bet:add_clr_location, and in
     genexternal:ExternalCallCall.
     
C6.  Use BETA as script language in ASP.NET pages.
     How to configure IIS to understand Language=BETA
     -> ask microsoft
     
C7.  Construct a Visual Studio .NET extension for BETA.
     - build rules
     - syntactic coloring
     - Nemmest med yacc/lex syntax for BETA
     
C8.  Lille detalje ved multiple assignments
     
     Ved multiple assignments genereres på clr nogle temporære lokale
     celler til den value, der skal assignes.  Dette er jo typede lokale
     variable.
     
     Hvis man f.eks. har
     
     	  a,b: ^object
     do &object[]->a[]->b[]
     
     så genereres det rigtige, nemlig en lokal variabel kvalificeret ved
     BetaObject.
     
     MEN hvis man istedet siger
     
     do NONE -> a[] -> b[]
     
     så bliver den lokale variable kvalificeret ved int32.
     Til min store overraskelse virker det dog, så indtil videre er NULL åb
     enbart
     assignkompatibel med int32.
     
     Tilsvarende:
     
     	  a, b, c: @char;
     do 'a' -> a;
     	  a -> b -> c;
     
     Her bliver den temporære variabel type 'char', hvilket jo er korrekt.
     Men i
     
     a, b, c: @char;
     do 'a' -> a -> b -> c;
     
     bliver den temporære af type int32.

C9. I forbindelse med externalclass skal vi kunne håndtere ref/out
    parametre.
    Til disse bruges ldind.* og stind.* instruktionerne.
    Der skal være en måde at udtrykke i BETA at det er ref/out
    parameter. Attribut?

	