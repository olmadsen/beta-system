
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A.   General
============

A1.  Missing BETA features
     a. Covariant parameters(?)
    	Ole currently working with it
     b. leave/restart out of components
 
A2.  Interface to external features
     a. Enumerations
    	Problem: The *values* are simple numbers, but they are *typed*
    	in external languages.
    	Currently problem in TEST/hellographics (LinearGradientMode)
	if enumerations_implemented is set to true.
     b. Value types (structs)
    	Handle as dynamic or static beta references?
    	Partially handled now, see compiler/DOC/BYTECODE/converter/implementation.html
     c. Static fields
     d. Hvorledes skal vi bære os ad med at fange exceptions som rejses af
	java klasse rutiner? F.eks. foresager basiclib/demo/file/fileerror en
	exception. Vi kan jo ikke syntaktisk udtrykke try-catch i beta.
	Der er dog i betaenv patterns try og throw, men hvis try skal kunne
	fange exceptions fra java skal compileren kende til dette pattern,
	eller også skal vi have nogle %try, %catch og %throw primitiver, 
	som disse patterns kan implementeres med.
     e. Vi kan ikke udtrykke at en ekstern klasse implementerer en
	række interfaces. I eksterne sprog kan der assignes til en
	variabel kvalificeret ved een af de implementerede interfaces,
	denne "inheritance" kan vi ikke udtrykke i beta.
	Giver pt. konkrete problemer for .NET implementationen af time.

 
A3. Introduce properties for patterns in BETA (instead of prefixes)?
     Examples:
       - proc
       - class
       - static
       - byval
       - enum

A4.  Detalje med real32 konstanter

     Prøv at oversætte flg. program:

     ORIGIN 'tstenv';
     --LIB:attributes--
     foo: externalclass
     	 (# f: proc
     	    (# x: @real32
     	    enter x
     	    #);
     	 #)
     --PROGRAM: descriptor--
     (# f: ^foo;
     do &foo[] -> f[];
     	  15 -> f.f;
     	  15.0 -> f.f;
     #)
     
     Hvis man ser på det genererede kode kan man se at der ikke overføres
     aktuel parameter af type float32 i det første kald af f.f, men kun i
     det andet, hvor man eksplicit gør det klart at der er tale om en float
     konstant.

A5.  int64 arithmetic/comparison. 

     See e.g. FIXME in file_clrbody:DiskEntrySize, where assignment
     sometimes fails (specificly in managed nbeta when reading file
     lenghts for .line directives. Even though this seems to work in
     stand alone one-liners using the same DiskEntrySize???

A6.  TOS'DoGC'

     Bind fragments in: 'betaenv_stdbody'!Checking
     ==================
     Compiler warnings:
     ==================
     
     tos'DoGC'
	     ^
     ***** TOS-primitives are no longer supported - use new %-primitives in
     stead
     ----- line: 174; char positions: 5136,5151 -----
     
     Den burde nok erstattes af et nyt primitiv, som kan kalde
     Java/.NET GC

A7.  PA
       java2beta:
         conversion-rules.txt (.xml)
         -w
         checkForNestedType (applet konvertering)
         implemented interfaces in comment
         putCaster
       dotnet2beta:
         -l


A8. Class Structure: No check for identical originOff's
    Result: too many temporary objects generated in Structure.ltS.

A9. X.%byteSwapShort wrong endian? See tstnewprim.bet, pattern
    tstswap.

A10. leave/restart across Components

A11. %setup 'betaenv' should TEST for betaenvRef being none before
     generating a new betaenv object. Will allow for multiple %setup in
     same program (e.g. multiple BETA generated libraries used from
     java).

A12. There are a number of problems with all the special constructs
     invented for interoperability, see
     compiler/DOC/BYTECODE/bytecode/Special.html

A13. Optimization?
     No need for origin field if on same origin level.


B.   Java specific
==================

B1.  Make (some) graphical Java debugger able to handle BETA?
     Mads pretty close with Eclipse!

B2.  * [OLM]
     Problem med objinterface (%asComponent og beta/lang/Object).

     Jeg har prøvet at implementere lidt mere af objinterface til jvm.
     
     Jeg har prøvet at bruge .%asComponent et par steder i
     objinterface_jvmbody (under antagelse af at den returnerer NONE, hvis
     objektet ikke er en component). Men der kommer semantisk fejl, når den
     bruges i boolean-evaluation (led efter FIXME; det er pt kommenteret ud).
     
     Jeg har endvidere forsøgt at kode noget reflektion i beta, til at
     implementere udskrift af et objekts felter i printObj.
     Dette giver en underlig 
     
     java.lang.NoClassDefFoundError: beta/lang/Object
				     ^^^^^^^^^^^^^^^^
     
     Det er argumenterne til f.eks. Field.getType, der bliver af denne
     type.
     Disse er erklæret til at være Object, og skulle i en external proc
     blive til java/lang/Object.
     
     Denne sidste fejl kommer ved at ændre print_field_values til true.

B5. * [OLM]
    In the following code (can be activated by trying the demo
    process/demo/lsl), the two temporary variables isr and temp are
    needed.
    If they are left out, verification errors will occur at run time:
    Part of process/private/processmanager_jvm.bet:

       OutErrHandler: Thread
	 (# 
	    is: ^InputStream;
	    
	    setstream: 
	      (# 
	      enter is[]
	      #);
	    
	    run:
	      (# br: ^BufferedReader;
		 temp: ^String;
		 isr: ^InputStreamReader;
	      do is[] 
		   -> InputStreamReader._init_InputStream
		   -> isr[]; (* FIXME *)
		 isr[]
		   -> BufferedReader._init_Reader -> br[];
		 read:
		   (if (br.readLine->temp[] (* FIXME *))<>NONE then
		       temp[] -> screen.putline;
		       restart read;
		   if);
		 is.close;
	      #);
	 #);  

    The first FIXME indicates that if the assignment is done as
 
                 is[] 
		   -> InputStreamReader._init_InputStream
		   -> BufferedReader._init_Reader -> br[]

    a verification error "call to wrong initialization method" occurs.
    This has something to do with order of calls of <init> and
    super-<init>
    The second FIXME indicates that if temp is declared as Text
    instead of String, the verification error "Unable to pop operand
    off an empty stack" occurs.


C.   .NET specific
==================

C1.  Codegeneration for .NET compact framework
     - switch 186 currently used
     - possibly a new target platform (clr_cf)?
     - looking up version/publickeys in CF DLLs?
     	-> ask microsoft
     
C2.  [PA/OLM]
     Vi skal kunne specificere kompleks location (f.eks. med
     versionsnummer) for en externalclass.
     Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
     behøver at skulle erklære eksterne klasser og procedurer [PA]
     Delvis løsning er lavet: Hvis assemblyet er i Global Assembly
     cache slås dets versionsnummer op og bruges af compiler.
     
     Vi bør understøtte
     	 BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
     samt
     	 INCLUDE 'aSystemAssembly.dll'
     som begge bør
     	 1. Føre til import af assembly
     	 2. (senere) føre til indlæsning af klasser i assembly og
     	    opbygning af ast
     
     
C3.  * [OLM] Lokal location skal ikke med
     Hvis man f.eks. oversætter
     	   ORIGIN 'tstlib';         
     	   -- program: Descriptor --
     	   (# 
     	   do 'a' -> put;
     	      'b' -> fill;
     	   #)  
     så vil der i program.il være en del referencer til klassen
     program, hvor der medtages location ['program'], hvilket ikke
     er nødvendigt, da det jo er i samme fil.
     I visse tilfæde forvirrer dette verifieren.
     

C4.  Import handling clean-up:
     All imports should be able to handle in
     signature.bet:descLocation, but some imports are also done in
     signature.bet:add_clr_location, and in
     genexternal:ExternalCallCall.
     
C5.  Use BETA as script language in ASP.NET pages.
     How to configure IIS to understand Language=BETA
     -> ask microsoft
     
C6.  Construct a Visual Studio .NET extension for BETA.
     - build rules
     - syntactic coloring
     - Nemmest med yacc/lex syntax for BETA
     
C7.  Lille detalje ved multiple assignments
     
     Ved multiple assignments genereres på clr nogle temporære lokale
     celler til den value, der skal assignes.  Dette er jo typede lokale
     variable.
     
     Hvis man f.eks. har
     
     	  a,b: ^object
     do &object[]->a[]->b[]
     
     så genereres det rigtige, nemlig en lokal variabel kvalificeret ved
     BetaObject.
     
     MEN hvis man istedet siger
     
     do NONE -> a[] -> b[]
     
     så bliver den lokale variable kvalificeret ved int32.
     Til min store overraskelse virker det dog, så indtil videre er NULL 
     åbenbart assignkompatibel med int32.
     
     Tilsvarende:
     
     	  a, b, c: @char;
     do 'a' -> a;
     	  a -> b -> c;
     
     Her bliver den temporære variabel type 'char', hvilket jo er korrekt.
     Men i
     
     a, b, c: @char;
     do 'a' -> a -> b -> c;
     
     bliver den temporære af type int32.

C8. I forbindelse med externalclass skal vi kunne håndtere ref/out
    parametre.
    Til disse bruges ldind.* og stind.* instruktionerne.
    Der skal være en måde at udtrykke i BETA at det er ref/out
    parameter. Attribut?

C9. Håndtere dup_x1/dup_x1/dup2/dup2_x1/dup2_x2 på .NET.
    Pt. under implementation.

C10. Fixed.

C11. FIXED: tstenv.isBigEndian svarer true på .NET på windows

C12. Use .NET nested classes

C13. Implement bootstrapped nbeta using wrapper C# code for
     unsupported features.

C14. sysutils/endian.bet sat til altid at sige little endian til .net.
     Men hvad med big-endian platforme som mac?
     Modsatte problem findes for jvm.
     Især problem for bobs med at finde korrekte .btab eller .btabL
     fil.
