
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A. General
==========

A1. Gøre switch 320 default (uden at sætte den i nbeta/jbeta)

A2. Dependency analyse for .il/.dll/.class filer - er det løst
    generelt?
    Nej: F.eks. genoversættes dotnettstenvbody altid.
    Omvendt: Hvis een af filerne svarende til et SLOT slettes,
    genoversættes tilsvarende BETA fil ikke.

A3. FIXED!

A4. FIXED!

A5. ** [OLM]  (verificeret: 2002-09-02)
    Text konstant exit pattern kan ikke assignes til text reference (compiler
    crasher).
    Eksempel:
	origin 'tstenv'   
	---lib:attributes---
	String: externalClass
	  (#
	  do 'java/lang/String' -> classname
	  #);
	jstringuser: externalclass
	  (# display: proc
	       (# S: ^String
	       enter S[]
	       #);
	  #);
	Greetings:
	  (# exit 'Greetings from BETA' #);
	---program:descriptor---
	(# X: ^jstringuser;
	   T: ^text; 
	do &jstringuser[] -> X[];
	   'To keep checker happy' -> X.display; (* checker fejlen *)
	   Greetings -> T[]; (* compiler crasher *)
	   T[] -> X.display;
	#)      

A6. FIXED!

A7. ** [OLM] 
    GENERATOR/BYTECODE/TEST/javastring: 
    a.  FIXED!
    b.  Objekt referencer til External[Class] skal oversættes til native
        object mens andre referencer kvalificeret som Object skal
        oversættes til BetaObject.
	Eller også skal der altid bruges native object, og så laves et
	cast inden man forsøger at udføre et objekt, der faktisk er et
        BETA object.
	Men det er uklart hvor stort et problem det egentlig er.
    c.  I tilfælde at overloadede metoder i ExternalClass er vi nødt
        til at kunne specificere de forskellige signaturer for disse
        proc's ligesom vi allerede kan i External. I tstenv er den en
        (pt udkommenteret) 'procname', der var tænkt anvendt til
        dette.
	Denne 'procname' burde nok hedde signature, ligesom 'callC' i
        external burde have et alias med navn 'signature'.

B. Java specific
================

B1. * [OLM]
    For hver .bet fil, der oversættes, bliver den *sidste* .class file,
    dette giver anledning til, genereret 2 gange.

B2. FIXED!

B3. * [PA/OLM]
    Implementere getLine i tstenv_javabcbody (mangler til google demoen).
    Kræver support for loading af statis felt System.in, enten ved
    generel mekanisme eller ved hardcoding i compiler (ligesom
    System.out pt loades hvis man bruger PrintStream).
    Desuden er der brug for at kalde constructors med argumenter.



C. .NET specific
================

C1. * [PA/OLM]
    Problem med overskrivning af program.il/program.class for hvert
    program.
     -> Muligvis lave subdirectory til denne navngivet udfra exefilen
        (ikke problem i java, da program.class er pakket ind i jar filen)

C2. * [PA/OLM]
    Hvis man oversætter foo.bet, og siden
    oversætter bar.bet, men bar.class/bar.il er nyere end bar.bet, så
    bliver der ikke genereret en ny program.class/program.il, og
    afvikling af bar vil derfor udføre foo.

C3. [PA]
    All source files constituting an executable must currently reside
    in the same directory.
    We intent to generate strong assemblies and config files and/or use
    the Global Assembly Cache for solving this later.

C4. * [PA/OLM]
    Vi skal kunne specificere kompleks location (f.eks. med
    versionsnummer) for en externalclass.
    Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
    behøver at skulle erklære eksterne klasser og procedurer [PA]
    Delvis løsning er lavet: Hvis assemblyet er i Global Assembly
    Cache slås dets versionsnummer op og bruges af compiler.

    Vi bør understøtte
       BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
    samt
       INCLUDE 'aSystemAssembly.dll'
    som begge bør
       1. Føre til import af assembly
       2. (senere) føre til indlæsning af klasser i assembly og
          opbygning af ast
    
 
C5.  * [OLM] Lokal location skal ikke med
     Hvis man f.eks. oversætter
     	 ORIGIN 'tstlib';         
     	 -- program: Descriptor --
     	 (# 
     	 do 'a' -> put;
     	    'b' -> fill;
     	 #)  
     så vil der i program.il være en del referencer til klassen
     program, hvor der medtages location ['program'], hvilket ikke
     er nødvendigt, da det jo er i samme fil.
     I visse tilfæde forvirrer dette verifieren.

C6. Kommenterede verification errors ved oversættelse af btst:
    (verificeret: 2002-08-08)

     a. [tstref.dll : tstRef$noNone::do] [offset 0x00000009] [opcode stloc.0] [found objref 'text'] [expected Int32] 
        -> Unexpected type on the stack.

	  .method public virtual void 'do'() cil managed 
	  {
		.maxstack 1000
		ldarg.0
		ldarg.0
		ldarg.0
		callvirt instance class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'bar'()
		dup
		.locals init ([0] int32)
		stloc.0
		stfld	class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'s' 
		ldloc.0
		callvirt instance void class ['tstref']'tstRef$noNone'::'foo'(class ['tstenv']'text')
		ret
	  }     

	Ser ud til at allocAndStoreLocal kaldes med forkert type
	(int32 istedet for text).

     b. [tstref.dll : tstRef$noNone::do] [offset 0x00000010] [opcode callvirt] [found Int32] [expected objref 'text'] 
        -> Unexpected type on the stack.

	Samme som C6.a

     c. [tst\dotnet\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000020] [opcode beq] 
        -> Int32 objref 'BetaObject' Non-compatible types on the stack.

     Detaljer (debug/fixme kode rykket ind for ikke at forvirre):

 	   .method public virtual void 'do'() cil managed 
            {
                  .maxstack 1000
                  ldarg.0
                  ldfld   class ['tstenv']'BetaObject' class ['tstvirt2']'tstvirt2$final2virtZ$Xqua'::'R' 
                          // pushReg %top
                          ldstr "FIXME: Primitive NYI: ObjS(Unknown)"
                          call void [mscorlib]System.Console::WriteLine(string)
                          // pushReg %top
                  newobj  instance void class ['tstenv']'BetaObject'::.ctor()
                          // pushReg %top
                          // pushReg %call
                          ldstr "FIXME: Primitive NYI: leS(Unknown)"
                          call void [mscorlib]System.Console::WriteLine(string)
                  ldc.i4.0
                  beq     L2

     d. [tst\dotnet\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000056] [opcode ret] 
        -> Stack must be empty on return from a void function.

     e. [tstvirt2.dll : tstvirt2$future::do] [offset 0x00000023] [opcode ldfld] [token  0x0A0001AE] 
        -> Unable to resolve token.

     f. [tst\dotnet\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] [opcode ret] 
       -> Stack must be empty on return from a void function.

     g. [tst\dotnet\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] 
       -> Stack depth differs depending on path.

       Detaljer: Forsøg på stakhøjde annotering:

  	.method public virtual void 'do_1'() cil managed 
  	{
  		.maxstack 1000
  		ldarg.0 /* 1 */ 
  		ldfld	class ['tstblock']'TstBlock' class ['tstblock']'TstBlock$singular_1'::origin /* 1 */ 
  		ldfld	class ['tstenv']'tstenv' class ['tstblock']'TstBlock'::origin /* 1 */ 
  		ldarg.0 /* 2 */ 
  		ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c' /* 2 */ 
  		callvirt instance void class ['tstenv']'tstenv'::'put'(char) /* 0 */ 
  		ldarg.0 /* 1 */ 
  		ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c'  /* 1 */ 
  		dup /* 2 */ 
  		ldc.i4.s 118  /* 3 */ 
  		bne.un	L14 /* 3 */ 
  		pop /* 2 */ 
  		ldarg.0 /* 3 */ 
  		br	L13 /* 3 */ 
  	L14:    /* 3 (kommer fra bne.un ovenfor */ 
  		dup /* 4 */
  		ldc.i4.s 122  /* 5 */ 
  		bne.un	L15 /* 5 */ 
  		pop /* 4 */ 
  		ldarg.0 /* 5 */ 
  		br	L13 /* 5 */ 
  	L15:    /* 5 (kommer fra bne.un ovenfor) */
  		pop /* 4 */ 
  	L13:
  		ret /* 4 (hvis man kommer fra pop ovenfor) */ /* 5 (hvis man kommer fra br L13 ovenfor) */ 
  	}     


     h. [tst\dotnet\tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] 
        -> Stack must be empty on return from a void function.

 	 .method public virtual void 'do'() cil managed 
 	 {
 	       .maxstack 1000
 	       ldarg.0
 	       ldarg.0
 	       ldarg.0
 	       ldarg.0
 	       ldfld   int32 class ['tstlib']'chkR'::'i' 
               ....

       Lang - men ligner også for mange load af this, ligesom nedenfor.

    i. [tst\dotnet\tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] 
       -> Stack must be empty on return from a void function.

       .method public virtual void 'enter'(int32,int32,char) cil managed 
       {
             .maxstack 1000
             ldarg.0
             ldarg.0
             ldarg.0
             ldarg.1
             stfld   char class ['tstlib']'chkR'::'ch' 
             ret
       }

       For mange load af this.


     j. [tst\dotnet\tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] 
       -> Stack must be empty on return from a void function.

     Lang - men ligner også for mange load af this.

     k. [tst\dotnet\tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] 
       -> Stack must be empty on return from a void function.
 
	  .method public virtual void 'enter'(int32,int32) cil managed 
	  {
		.maxstack 1000
		ldarg.0
		ldarg.0
		ret
	  }  

     Ligner C6.i problemet.

     l. [tst\dotnet\tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode newobj] 
       -> [found objref ('this' ptr) 'CStruct'] [expected objref 'tstenv'] Unexpected type on the stack.

 	  .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
 	  {
 	        ldarg.0
 	        call    instance void ['tstenv']'BetaObject'::.ctor()

 	        ldarg.0
 	        ldarg.1
 	        stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin 
 	        ldarg.0
 	        ldarg.0    <-- Dette er et Cstruct object (this)

 	        newobj  instance void class ['tstenv']'IntegerObject'::.ctor(class ['tstenv']'tstenv')
              
           IntegerObjects constructor forventer en tstenv origin.

     m. [tst\dotnet\tstenv.dll : CStruct$Byte::exit] [offset 0x00000000] [opcode dup] 
       -> Stack underflow.

 	      .method public virtual int32 'exit'() cil managed 
 	      {
 	            .maxstack 1000
 	            dup
 	            .locals init ([0] int32)
 	            stloc.0

 	            ret
 	      }          

	Der mangler vist noget?

     n. [tst\dotnet\tstenv.dll : CStruct$Long::exit] [offset 0x00000000] [opcode dup] 
       -> Stack underflow.

        Samme som C6.m.

C7.  FIXED!

C8.  Import handling clean-up:
     All imports should be able to handle in
     signature.bet:descLocation, but some imports are also done in
     signature.bet:add_dotnet_location, and in
     genexternal:ExternalCallCall.

C9.  FIXED!


