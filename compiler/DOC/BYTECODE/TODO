
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A.   General
============

A1.  Missing BETA features
     a. Covariant parameters(?)
    	Ole currently working with it
 
A2.  Interface to external features
     a. Enumerations
    	Problem: The *values* are simple numbers, but they are *typed*
    	in external languages.
    	Currently problem in TEST/hellographics (LinearGradientMode)
	if enumerations_implemented is set to true.
     b. Value types (structs)
    	Handle as dynamic or static beta references?
    	Allocation (does not use new/newobject, but calls constructor)
     c. Static fields
     d. Hvorledes skal vi bære os ad med at fange exceptions som rejses af
	java klasse rutiner? F.eks. foresager basiclib/demo/file/fileerror en
	exception. Vi kan jo ikke syntaktisk udtrykke try-catch i beta.
	Der er dog i betaenv patterns try og throw, men hvis try skal kunne
	fange exceptions fra java skal compileren kende til dette pattern,
	eller også skal vi have nogle %try, %catch og %throw primitiver, 
	som disse patterns kan implementeres med.

 
A3. Introduce properties for patterns in BETA (instead of prefixes)?
     Examples:
       - proc
       - class
       - static
       - byval
       - enum

A4.  Detalje med real32 konstanter

     Prøv at oversætte flg. program:

     ORIGIN 'tstenv';
     --LIB:attributes--
     foo: externalclass
     	 (# f: proc
     	    (# x: @real32
     	    enter x
     	    #);
     	 #)
     --PROGRAM: descriptor--
     (# f: ^foo;
     do &foo[] -> f[];
     	  15 -> f.f;
     	  15.0 -> f.f;
     #)
     
     Hvis man ser på det genererede kode kan man se at der ikke overføres
     aktuel parameter af type float32 i det første kald af f.f, men kun i
     det andet, hvor man eksplicit gør det klart at der er tale om en float
     konstant.

A5.  int64 arithmetic

A6.  Problems with TEST/betaenv*.bet

     A few constructs used in TEST/betaenv*.bet cause verification
     problems. These are all marked with

     FIXME: bytecode verification problems

A7.  TOS'DoGC'

     Bind fragments in: 'betaenv_stdbody'!Checking
     ==================
     Compiler warnings:
     ==================
     
     tos'DoGC'
	     ^
     ***** TOS-primitives are no longer supported - use new %-primitives in
     stead
     ----- line: 174; char positions: 5136,5151 -----
     
     Den burde nok erstattes af et nyt primitiv.



B.   Java specific
==================

B1.  Make (some) graphical Java debugger able to handle BETA?
     -> ask SUN

B2.  Problem med foreløbige process implementation

     Prøv at oversætte process/demo/lsl.bet med jbeta og start den:
     
     [r5.3] alex(421) ./lsl
     Not yet implemented for JVM: systemenv_jvmbody:pioPrivate
     Not yet implemented for JVM: processmanger_jvm:ProcessStillRunning
     java.lang.VerifyError: (class: beta/slot$ProcessStartMDBody, method: d
     o signature: ()V) Expecting to find object/array on stack
	     at beta.SystemEnv$Process$start.slot$ProcessStartMDBody(../../
     processmanagerbody.bet:1)
	     at beta.SystemEnv$Process$start.do(../../processmanagerbody.be
     t:55)
	     at beta.SystemEnv$Process.start(../../processmanager.bet:1)
	     at beta.program.do_2(../../lsl.bet:13)
	     at beta.SystemEnv.do_1(../../basicsystemenv.bet:311)
	     at beta.SysHead.do(../../basicsystemenv.bet:379)
	     at beta.Component.run(Unknown Source)
     Not yet implemented for JVM: systemenv:jvmbody:BasicScheduler: private
     .mdpriv.check
     
     Jeg har endnu ikke kigget på hvad porblemet er, men det har at gøremed
     at jeg i process/private/processmanager_jvm har lavet en klasse
     OutErrHandler, som nedarver fra Java's thread klasse.
     En sådan skal jeg instantiere til håndtering af processens stdout og
     stderr, og det er denne instantiering jeg har problemer med.
     Som du ser har jeg prøvet at erklære to forskellige constructors for
     denne klasse, men begge har problemer: Det committede opfører sig som
     ovenfor, mens man kan ændre til at bruge den anden constructor ved at
     ændre en (if true ... if) i ---ProcessStartMDBody:descriptor--- til 
     (if false ... if).
     Den opfører sig anderledes, men det er også noget med forkert
     initialisering.

     ***** MERE:
	  
     Ole,
     
     jeg har checket en processmanager_jvm.bet ind , hvor der er puttet
     lidt flere patterns ind, så kodestumperne bliver lidt mindre.
     Hermed tror jeg jeg har fundet ud af hvad problemet med den ene type
     instantiering er.
     
     Følgende kode
     
	    (# fisk1: @char;
	    do private.jp.getInputStream 
		 -> OutErrHandler._init_InputStream
		 -> private.out[];
	    #);
     
     giver følgende fejl (reformateret for læsbarhed):
     
     java.lang.VerifyError: 
       class: beta/slot$ProcessStartMDBody$singular_3
       method: do 
       signature: ()V
       Expecting to find object/array on stack
     
     En jcf-dump af den ser således ud (bred):
     
     Method name:"do" public Signature: 18=()void
     Attribute "Code", length:99, max_stack:100, max_locals:100, code_length:49
       0: aload_0
       1: getfield #22=<Field beta.slot$ProcessStartMDBody$singular_3.origin beta.slot$ProcessStartMDBody>
       4: getfield #30=<Field beta.slot$ProcessStartMDBody.origin beta.SystemEnv$Process$start>
       7: getfield #35=<Field beta.SystemEnv$Process$start.origin beta.SystemEnv$Process>
      10: getfield #41=<Field beta.SystemEnv$Process.private beta.SystemEnv$Process$private>
      13: new #43=<Class beta.OutErrHandler>
      16: dup
      17: aload_0
      18: getfield #22=<Field beta.slot$ProcessStartMDBody$singular_3.origin beta.slot$ProcessStartMDBody>
      21: getfield #30=<Field beta.slot$ProcessStartMDBody.origin beta.SystemEnv$Process$start>
      24: getfield #35=<Field beta.SystemEnv$Process$start.origin beta.SystemEnv$Process>
      27: getfield #41=<Field beta.SystemEnv$Process.private beta.SystemEnv$Process$private>
      30: getfield #49=<Field beta.SystemEnv$Process$private.jp java.lang.Process>
      33: invokevirtual #55=<Method java.lang.Process.getInputStream ()java.io.InputStream>
      36: invokespecial #58=<Method beta.OutErrHandler.<init> (beta.betaenv,java.io.InputStream)void>
      39: checkcast #43=<Class beta.OutErrHandler>
      42: checkcast #43=<Class beta.OutErrHandler>
      45: putfield #62=<Field beta.SystemEnv$Process$private.out beta.OutErrHandler>
      48: return
     
     Så vidt jeg kan se er problemet at constructoren for
     beta.OutErrHandler forventer et beta.betaenv argument som første
     argument, men at dette ikke er puttet på stakken.
     Det er vel rigtigt nok at der forventes et betaenv argument, da det er
     en klasse erklæret i BETA i LIB:attributes.
     Men det er sikkert mekanismen med kald af statiske metoder, der ikke
     tager højde for at en i BETA erklæret metode skal have origin med?
     

B3.  (Problem disappeared after recoding)

B4.  Problem med objinterface (%asComponent og beta/lang/Object).

     Jeg har prøvet at implementere lidt mere af objinterface til jvm (jeg
     skulle lige have en pause fra JNI (:-)).
     
     Jeg har prøvet at bruge .%asComponent et par steder i
     objinterface_jvmbody (under antagelse af at den returnerer NONE, hvis
     objektet ikke er en component). Men der kommer semantisk fejl, når den
     bruges i boolean-evaluation (led efter FIXME; det er pt kommenteret ud).
     
     Jeg har endvidere forsøgt at kode noget reflektion i beta, til at
     implementere udskrift af et objekts felter i printObj.
     Dette giver en underlig 
     
     java.lang.NoClassDefFoundError: beta/lang/Object
				     ^^^^^^^^^^^^^^^^
     
     Det er argumenterne til f.eks. Field.getType, der bliver af denne
     type.
     Disse er erklæret til at være Object, og skulle i en external proc
     blive til java/lang/Object.
     
     Denne sidste fejl kommer ved at ændre print_field_values til true.

B5.  Program:

     Origin '~beta/basiclib/betaenv';
     --lib: attributes--
     indenter:
       (# contents: [1] ^textLine;
	  textLine:<
	    (# 
	    #);
	  setContents:<
	    (# unformattet: ^text; 
	    enter unformattet[]
	    <<SLOT setContents: doPart>> 
	    #);
       #);
     betaIndenter: indenter
       (# textLine::
	    (# 
	    #);
	  setContents:: (# <<SLOT beta_setContents:doPart>> #);
       #);
     -- setContents: DoPart --
     do (# (* stuff deleted *)
	do INNER setContents;
	#);
     -- beta_setContents: DoPart --
     do (if (contents[1][]<>NONE) then
	if)  
     --program: descriptor--
     (# i: @betaindenter;
     do '(# #)' -> i.SetContents;
     #)   
   
   Error:

   java.lang.NoSuchFieldError: contents
        at beta.betaIndenter$setContents.do_1(../../indenter.bet:26)



C.   .NET specific
==================

C0.  Problem med nbeta (2003-09-04)

     $ nbeta hello
     Mjolner BETA Compiler: 5.3(5.5.1303/117) - clr
     Building dependency graph for: 'hello' ...
     Translating fragments ...
     Bind fragments in: 'hello'!Checking!Code generation
     Bind fragments in: 'private/betaenvbody'Code generation
     Bind fragments in: 'betaenv_clrbody'!Checking!Code generation
     %1: call: void class
     ['betaenv_clrbody']'beta/C$WriteChar'::'WriteChar'(char)
     %1: External: ReadLine: External
	(# result: ^String;  do <<AssignmentEvaluation>>;  exit result[] #)
      path: C:\beta\r5.3\basiclib\private\clr\betaenv_clrbody.il
      class: beta/C$ReadLine
      method: ReadLinevalueSignature: falling back on unknownValue for desc
     =18002
     valueSignature: falling back on unknownValue for desc=18002
     
     %1: External: Read: External
	(# result: @int32;  do <<AssignmentEvaluation>>;  exit result #)
      path: C:\beta\r5.3\basiclib\private\clr\betaenv_clrbody.il
      class: beta/C$Read
      method: Read
     *** Exception processing
     File exception for 'C:\beta\r5.3\basiclib\private\clr\beta/C$ReadLine.
     bin'
     No such file


C1.  Codegeneration for .NET compact framework
     - switch 186 currently used
     - possibly a new target platform (clr_cf)?
     - looking up version/publickeys in CF DLLs?
     	-> ask microsoft
     
C2.  [PA/OLM]
     Vi skal kunne specificere kompleks location (f.eks. med
     versionsnummer) for en externalclass.
     Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
     behøver at skulle erklære eksterne klasser og procedurer [PA]
     Delvis løsning er lavet: Hvis assemblyet er i Global Assembly
     cache slås dets versionsnummer op og bruges af compiler.
     
     Vi bør understøtte
     	 BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
     samt
     	 INCLUDE 'aSystemAssembly.dll'
     som begge bør
     	 1. Føre til import af assembly
     	 2. (senere) føre til indlæsning af klasser i assembly og
     	    opbygning af ast
     
     
C3.  * [OLM] Lokal location skal ikke med
     Hvis man f.eks. oversætter
     	   ORIGIN 'tstlib';         
     	   -- program: Descriptor --
     	   (# 
     	   do 'a' -> put;
     	      'b' -> fill;
     	   #)  
     så vil der i program.il være en del referencer til klassen
     program, hvor der medtages location ['program'], hvilket ikke
     er nødvendigt, da det jo er i samme fil.
     I visse tilfæde forvirrer dette verifieren.
     
C4.  Kommenterede verification errors ved oversættelse af btst:
     (Sidst konstateret: 2002-08-08 - sikkert bedre nu)
     
     a. [tstref.dll : tstRef$noNone::do] [offset 0x00000009] [opcode stloc.0] [found objref 'text'] [expected Int32] 
     	  -> Unexpected type on the stack.
     
     	    .method public virtual void 'do'() cil managed 
     	    {
     		  .maxstack 1000
     		  ldarg.0
     		  ldarg.0
     		  ldarg.0
     		  callvirt instance class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'bar'()
     		  dup
     		  .locals init ([0] int32)
     		  stloc.0
     		  stfld	class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'s' 
     		  ldloc.0
     		  callvirt instance void class ['tstref']'tstRef$noNone'::'foo'(class ['tstenv']'text')
     		  ret
     	    }     
     
     	  Ser ud til at allocAndStoreLocal kaldes med forkert type
     	  (int32 istedet for text).
     
     b. [tstref.dll : tstRef$noNone::do] [offset 0x00000010] [opcode callvirt] [found Int32] [expected objref 'text'] 
     	  -> Unexpected type on the stack.
     
     	  Samme som C6.a
     
     c. [tst\clr\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000020] [opcode beq] 
     	  -> Int32 objref 'BetaObject' Non-compatible types on the stack.
     
     Detaljer (debug/fixme kode rykket ind for ikke at forvirre):
     
     	     .method public virtual void 'do'() cil managed 
     	      {
     		    .maxstack 1000
     		    ldarg.0
     		    ldfld   class ['tstenv']'BetaObject' class ['tstvirt2']'tstvirt2$final2virtZ$Xqua'::'R' 
     			    // pushReg %top
     			    ldstr "FIXME: Primitive NYI: ObjS(Unknown)"
     			    call void [mscorlib]System.Console::WriteLine(string)
     			    // pushReg %top
     		    newobj  instance void class ['tstenv']'BetaObject'::.ctor()
     			    // pushReg %top
     			    // pushReg %call
     			    ldstr "FIXME: Primitive NYI: leS(Unknown)"
     			    call void [mscorlib]System.Console::WriteLine(string)
     		    ldc.i4.0
     		    beq     L2
     
     d. [tst\clr\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000056] [opcode ret] 
     	  -> Stack must be empty on return from a void function.
     
     e. [tstvirt2.dll : tstvirt2$future::do] [offset 0x00000023] [opcode ldfld] [token  0x0A0001AE] 
     	  -> Unable to resolve token.
     
     f. [tst\clr\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     g. [tst\clr\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] 
     	 -> Stack depth differs depending on path.
     
     	 Detaljer: Forsøg på stakhøjde annotering:
     
     	  .method public virtual void 'do_1'() cil managed 
     	  {
     		  .maxstack 1000
     		  ldarg.0 /* 1 */ 
     		  ldfld	class ['tstblock']'TstBlock' class ['tstblock']'TstBlock$singular_1'::origin /* 1 */ 
     		  ldfld	class ['tstenv']'tstenv' class ['tstblock']'TstBlock'::origin /* 1 */ 
     		  ldarg.0 /* 2 */ 
     		  ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c' /* 2 */ 
     		  callvirt instance void class ['tstenv']'tstenv'::'put'(char) /* 0 */ 
     		  ldarg.0 /* 1 */ 
     		  ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c'  /* 1 */ 
     		  dup /* 2 */ 
     		  ldc.i4.s 118  /* 3 */ 
     		  bne.un	L14 /* 3 */ 
     		  pop /* 2 */ 
     		  ldarg.0 /* 3 */ 
     		  br	L13 /* 3 */ 
     	  L14:    /* 3 (kommer fra bne.un ovenfor */ 
     		  dup /* 4 */
     		  ldc.i4.s 122  /* 5 */ 
     		  bne.un	L15 /* 5 */ 
     		  pop /* 4 */ 
     		  ldarg.0 /* 5 */ 
     		  br	L13 /* 5 */ 
     	  L15:    /* 5 (kommer fra bne.un ovenfor) */
     		  pop /* 4 */ 
     	  L13:
     		  ret /* 4 (hvis man kommer fra pop ovenfor) */ /* 5 (hvis man kommer fra br L13 ovenfor) */ 
     	  }     
     
     
     h. [tst\clr\tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] 
     	  -> Stack must be empty on return from a void function.
     
     	   .method public virtual void 'do'() cil managed 
     	   {
     		 .maxstack 1000
     		 ldarg.0
     		 ldarg.0
     		 ldarg.0
     		 ldarg.0
     		 ldfld   int32 class ['tstlib']'chkR'::'i' 
     		 ....
     
     	 Lang - men ligner også for mange load af this, ligesom nedenfor.
     
     i. [tst\clr\tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     	 .method public virtual void 'enter'(int32,int32,char) cil managed 
     	 {
     	       .maxstack 1000
     	       ldarg.0
     	       ldarg.0
     	       ldarg.0
     	       ldarg.1
     	       stfld   char class ['tstlib']'chkR'::'ch' 
     	       ret
     	 }
     
     	 For mange load af this.
     
     
     j. [tst\clr\tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     Lang - men ligner også for mange load af this.
     
     k. [tst\clr\tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] 
     	 -> Stack must be empty on return from a void function.
     
     	    .method public virtual void 'enter'(int32,int32) cil managed 
     	    {
     		  .maxstack 1000
     		  ldarg.0
     		  ldarg.0
     		  ret
     	    }  
     
     Ligner C6.i problemet.
     
     l. [tst\clr\tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode newobj] 
     	 -> [found objref ('this' ptr) 'CStruct'] [expected objref 'tstenv'] Unexpected type on the stack.
     
     	    .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
     	    {
     		  ldarg.0
     		  call    instance void ['tstenv']'BetaObject'::.ctor()
     
     		  ldarg.0
     		  ldarg.1
     		  stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin 
     		  ldarg.0
     		  ldarg.0    <-- Dette er et Cstruct object (this)
     
     		  newobj  instance void class ['tstenv']'IntegerObject'::.ctor(class ['tstenv']'tstenv')
     		
     	     IntegerObjects constructor forventer en tstenv origin.
     
     m. [tst\clr\tstenv.dll : CStruct$Byte::exit] [offset 0x00000000] [opcode dup] 
     	 -> Stack underflow.
     
     		.method public virtual int32 'exit'() cil managed 
     		{
     		      .maxstack 1000
     		      dup
     		      .locals init ([0] int32)
     		      stloc.0
     
     		      ret
     		}          
     
     	  Der mangler vist noget?
     
     n. [tst\clr\tstenv.dll : CStruct$Long::exit] [offset 0x00000000] [opcode dup] 
     	 -> Stack underflow.
     
     	  Samme som C6.m.
     
C5.  Import handling clean-up:
     All imports should be able to handle in
     signature.bet:descLocation, but some imports are also done in
     signature.bet:add_clr_location, and in
     genexternal:ExternalCallCall.
     
C6.  Use BETA as script language in ASP.NET pages.
     How to configure IIS to understand Language=BETA
     -> ask microsoft
     
C7.  Construct a Visual Studio .NET extension for BETA.
     - build rules
     - syntactic coloring
     - Nemmest med yacc/lex syntax for BETA
     
C8.  Lille detalje ved multiple assignments
     
     Ved multiple assignments genereres på clr nogle temporære lokale
     celler til den value, der skal assignes.  Dette er jo typede lokale
     variable.
     
     Hvis man f.eks. har
     
     	  a,b: ^object
     do &object[]->a[]->b[]
     
     så genereres det rigtige, nemlig en lokal variabel kvalificeret ved
     BetaObject.
     
     MEN hvis man istedet siger
     
     do NONE -> a[] -> b[]
     
     så bliver den lokale variable kvalificeret ved int32.
     Til min store overraskelse virker det dog, så indtil videre er NULL åb
     enbart
     assignkompatibel med int32.
     
     Tilsvarende:
     
     	  a, b, c: @char;
     do 'a' -> a;
     	  a -> b -> c;
     
     Her bliver den temporære variabel type 'char', hvilket jo er korrekt.
     Men i
     
     a, b, c: @char;
     do 'a' -> a -> b -> c;
     
     bliver den temporære af type int32.
