
BETA Bytecode TODO
==================

Prioriteter: *** Høj
             **  Mellem
             *   Lav

A. General
==========

A1. Gøre switch 320 default (uden at sætte den i nbeta/jbeta)

A2. Dependency analyse for .il/.dll/.class filer - er det løst
    generelt?
    Nej: F.eks. genoversættes dotnettstenvbody altid.
    Omvendt: Hvis een af filerne svarende til et SLOT slettes,
    genoversættes tilsvarende BETA fil ikke.

A3. *** [OLM] Objekt typer som external parametre.

    I forbindelse med google demoen har jeg
    prøvet at implementere en getline.
    Hertil skal jeg bruge en *statisk* external ReadLine, som returnerer en
    String-reference.
    Dvs følgende:

    --LIB: attributes--
    String: ExternalClass
      (#
      do '[mscorlib]System.String' -> className;
      #);
    ReadLine: External
      (# result: ^String;
      do '[mscorlib]System.String [mscorlib]System.Console::ReadLine()' -> callC;
      exit result[]
      #);     
    ---getline:doPart--
    do ReadLine -> T[];

    Problemet her er at External ikke ligesom ExternalClass.proc vil acceptere
    String som parameter/retur type.
    Vil du indføre det på et tidspunkt?

A4. *** [OLM] 
    Checker problemet (generelt problem).
    Kan reproduceres ved at udkommentere
       'Greatings from BETA' -> X.display;
    i GENERATOR/BYTECODE/TEST/jstring.bet og oversætte denne med jbeta.

A5. ** [OLM] 
    Text konstant exit pattern kan ikke assignes til text reference (compiler
    crasher).
    Eksempel:
	origin 'tstenv'   
	---lib:attributes---
	String: externalClass
	  (#
	  do 'java/lang/String' -> classname
	  #);
	jstringuser: externalclass
	  (# display: proc
	       (# S: ^String
	       enter S[]
	       #);
	  #);
	Greetings:
	  (# exit 'Greetings from BETA' #);
	---program:descriptor---
	(# X: ^jstringuser;
	   T: ^text; 
	do &jstringuser[] -> X[];
	   'To keep checker happy' -> X.display; (* checker fejlen *)
	   Greetings -> T[]; (* compiler crasher *)
	   T[] -> X.display;
	#)      

A6. *** [OLM]
    Text konstant exit pattern brugt direkte i parameter liste crasher ikke
    compileren, men der genereres forkert kode (mangler konvertering til
    External String).
    Eksemple:

	origin 'tstenv'   
	---lib:attributes---
	String: externalClass
	  (#
	  do 'java/lang/String' -> classname
	  #);
	jstringuser: externalclass
	  (# display: proc
	       (# S: ^String
	       enter S[]
	       #);
	  #);
	Greetings:
	  (# exit 'Greetings from BETA' #);
	---program:descriptor---
	(# X: ^jstringuser;
	   T: ^text; 
	do &jstringuser[] -> X[];
	   Greetings -> X.display;
	#)      



B. Java specific
================

B1.  * [OLM]
     For hver .bet fil, der oversættes, bliver den *sidste* .class file,
     dette giver anledning til, genereret 2 gange.


C. .NET specific
================

C1. * [PA/OLM]
    Problem med overskrivning af program.il/program.class for hvert
    program.
     -> Muligvis lave subdirectory til denne navngivet udfra exefilen
        (ikke problem i java, da program.class er pakket ind i jar filen)

C2. * [PA/OLM]
    Hvis man oversætter foo.bet, og siden
    oversætter bar.bet, men bar.class/bar.il er nyere end bar.bet, så
    bliver der ikke genereret en ny program.class/program.il, og
    afvikling af bar vil derfor udføre foo.

C3. [PA]
    All source files constituting an executable must currently reside
    in the same directory.
    We intent to generate strong assemblies and config files and/or use
    the Global Assembly Cache for solving this later.

C4. * [OLM]
    Vi skal kunne specificere kompleks location (f.eks. med
    versionsnummer) for en externalclass.
    Senere: Compiler skal kunne læse .Net assemblies direkte, så man ikke
    behøver at skulle erklære eksterne klasser og procedurer [PA]

    Vi bør understøtte
       BUILD 'myassembly.dll' 'myassembly.cs' 'csc ...';
    samt
       INCLUDE 'aSystemAssembly.dll'
    som begge bør
       1. Føre til import af assembly
       2. (senere) føre til indlæsning af klasser i assembly og
          opbygning af ast
    
 
C5.  * [OLM] Lokal location skal ikke med
     Hvis man f.eks. oversætter
     	 ORIGIN 'tstlib';         
     	 -- program: Descriptor --
     	 (# 
     	 do 'a' -> put;
     	    'b' -> fill;
     	 #)  
     så vil der i program.il være en del referencer til klassen
     program, hvor der medtages location ['program'], hvilket ikke
     er nødvendigt, da det jo er i samme fil.
     I visse tilfæde forvirrer dette verifieren.

C6. Kommenterede verification errors ved oversættelse af btst:
    (verificeret 8/8/2002)

     a. [tstref.dll : tstRef$noNone::do] [offset 0x00000009] [opcode stloc.0] [found objref 'text'] [expected Int32] 
        -> Unexpected type on the stack.

	  .method public virtual void 'do'() cil managed 
	  {
		.maxstack 1000
		ldarg.0
		ldarg.0
		ldarg.0
		callvirt instance class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'bar'()
		dup
		.locals init ([0] int32)
		stloc.0
		stfld	class ['tstenv']'text' class ['tstref']'tstRef$noNone'::'s' 
		ldloc.0
		callvirt instance void class ['tstref']'tstRef$noNone'::'foo'(class ['tstenv']'text')
		ret
	  }     

	Ser ud til at allocAndStoreLocal kaldes med forkert type
	(int32 istedet for text).

     b. [tstref.dll : tstRef$noNone::do] [offset 0x00000010] [opcode callvirt] [found Int32] [expected objref 'text'] 
        -> Unexpected type on the stack.

	Samme som C6.a

     c. [tst\dotnet\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000020] [opcode beq] 
        -> Int32 objref 'BetaObject' Non-compatible types on the stack.

     Detaljer (debug/fixme kode rykket ind for ikke at forvirre):

 	   .method public virtual void 'do'() cil managed 
            {
                  .maxstack 1000
                  ldarg.0
                  ldfld   class ['tstenv']'BetaObject' class ['tstvirt2']'tstvirt2$final2virtZ$Xqua'::'R' 
                          // pushReg %top
                          ldstr "FIXME: Primitive NYI: ObjS(Unknown)"
                          call void [mscorlib]System.Console::WriteLine(string)
                          // pushReg %top
                  newobj  instance void class ['tstenv']'BetaObject'::.ctor()
                          // pushReg %top
                          // pushReg %call
                          ldstr "FIXME: Primitive NYI: leS(Unknown)"
                          call void [mscorlib]System.Console::WriteLine(string)
                  ldc.i4.0
                  beq     L2

     d. [tst\dotnet\tstvirt2.dll : tstvirt2$final2virtZ$Xqua::do] [offset 0x00000056] [opcode ret] 
        -> Stack must be empty on return from a void function.

     e. [tstvirt2.dll : tstvirt2$future::do] [offset 0x00000023] [opcode ldfld] [token  0x0A0001AE] 
        -> Unable to resolve token.

     f. [tst\dotnet\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] [opcode ret] 
       -> Stack must be empty on return from a void function.

     g. [tst\dotnet\tstblock.dll : TstBlock$singular_1::do_1] [offset 0x0000003B] 
       -> Stack depth differs depending on path.

       Detaljer: Forsøg på stakhøjde annotering:

  	.method public virtual void 'do_1'() cil managed 
  	{
  		.maxstack 1000
  		ldarg.0 /* 1 */ 
  		ldfld	class ['tstblock']'TstBlock' class ['tstblock']'TstBlock$singular_1'::origin /* 1 */ 
  		ldfld	class ['tstenv']'tstenv' class ['tstblock']'TstBlock'::origin /* 1 */ 
  		ldarg.0 /* 2 */ 
  		ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c' /* 2 */ 
  		callvirt instance void class ['tstenv']'tstenv'::'put'(char) /* 0 */ 
  		ldarg.0 /* 1 */ 
  		ldfld	char class ['tstblock']'TstBlock$Q$scan'::'c'  /* 1 */ 
  		dup /* 2 */ 
  		ldc.i4.s 118  /* 3 */ 
  		bne.un	L14 /* 3 */ 
  		pop /* 2 */ 
  		ldarg.0 /* 3 */ 
  		br	L13 /* 3 */ 
  	L14:    /* 3 (kommer fra bne.un ovenfor */ 
  		dup /* 4 */
  		ldc.i4.s 122  /* 5 */ 
  		bne.un	L15 /* 5 */ 
  		pop /* 4 */ 
  		ldarg.0 /* 5 */ 
  		br	L13 /* 5 */ 
  	L15:    /* 5 (kommer fra bne.un ovenfor) */
  		pop /* 4 */ 
  	L13:
  		ret /* 4 (hvis man kommer fra pop ovenfor) */ /* 5 (hvis man kommer fra br L13 ovenfor) */ 
  	}     


     h. [tst\dotnet\tstlib.dll : chkR::do] [offset 0x00000057] [opcode ret] 
        -> Stack must be empty on return from a void function.

 	 .method public virtual void 'do'() cil managed 
 	 {
 	       .maxstack 1000
 	       ldarg.0
 	       ldarg.0
 	       ldarg.0
 	       ldarg.0
 	       ldfld   int32 class ['tstlib']'chkR'::'i' 
               ....

       Lang - men ligner også for mange load af this, ligesom nedenfor.

    i. [tst\dotnet\tstlib.dll : chkR::enter] [offset 0x00000009] [opcode ret] 
       -> Stack must be empty on return from a void function.

       .method public virtual void 'enter'(int32,int32,char) cil managed 
       {
             .maxstack 1000
             ldarg.0
             ldarg.0
             ldarg.0
             ldarg.1
             stfld   char class ['tstlib']'chkR'::'ch' 
             ret
       }

       For mange load af this.


     j. [tst\dotnet\tstlib.dll : eqR::do] [offset 0x0000002B] [opcode ret] 
       -> Stack must be empty on return from a void function.

     Lang - men ligner også for mange load af this.

     k. [tst\dotnet\tstlib.dll : eqR::enter] [offset 0x00000002] [opcode ret] 
       -> Stack must be empty on return from a void function.
 
	  .method public virtual void 'enter'(int32,int32) cil managed 
	  {
		.maxstack 1000
		ldarg.0
		ldarg.0
		ret
	  }  

     Ligner C6.i problemet.

     l. [tst\dotnet\tstenv.dll : CStruct::.ctor] [offset 0x0000000F] [opcode newobj] 
       -> [found objref ('this' ptr) 'CStruct'] [expected objref 'tstenv'] Unexpected type on the stack.

 	  .method public rtspecialname specialname hidebysig instance void .ctor(class ['tstenv']'tstenv')
 	  {
 	        ldarg.0
 	        call    instance void ['tstenv']'BetaObject'::.ctor()

 	        ldarg.0
 	        ldarg.1
 	        stfld   class ['tstenv']'tstenv' class ['tstenv']'CStruct'::origin 
 	        ldarg.0
 	        ldarg.0    <-- Dette er et Cstruct object (this)

 	        newobj  instance void class ['tstenv']'IntegerObject'::.ctor(class ['tstenv']'tstenv')
              
           IntegerObjects constructor forventer en tstenv origin.

     m. [tst\dotnet\tstenv.dll : CStruct$Byte::exit] [offset 0x00000000] [opcode dup] 
       -> Stack underflow.

 	      .method public virtual int32 'exit'() cil managed 
 	      {
 	            .maxstack 1000
 	            dup
 	            .locals init ([0] int32)
 	            stloc.0

 	            ret
 	      }          

	Der mangler vist noget?

     n. [tst\dotnet\tstenv.dll : CStruct$Long::exit] [offset 0x00000000] [opcode dup] 
       -> Stack underflow.

        Samme som C6.m.

C7.  * [PA/OLM] 
     Default location for external class.
     Det vil være rart hvis default location for externalclass (hvis
     der ikke skrives en eksplicit i classname) er klassenavnet.

C8.  Import handling clean-up:
     All imports should be able to handle in
     signature.bet:descLocation, but some imports are also done in
     signature.bet:add_dotnet_location, and in
     genexternal:ExternalCallCall.
