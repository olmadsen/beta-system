<HTML>

<HEAD>
<TITLE>Mjølner BETA Low Level Primitives (unsafe)</TITLE>
<LINK REV="made" HREF="mailto:pa@daimi.aau.dk">
</HEAD>

<BODY bgcolor="lightblue">
<H1>Mjølner BETA Low Level Primitives (unsafe)</H1>

<H2><A NAME="contents">Contents</A></H2>

<UL>
<LI><A HREF="#intro">Introduction</A></LI>
<LI><A HREF="#unsafe">Unsafe Low Level Operations</A></LI>
<LI><A HREF="#@@">The <CODE>@@</CODE> operator</A></LI>
<UL>
<LI><A HREF="#inxget">Indexed get byte/short/long from a repetition (no index check)</A></LI>
<UL>
<LI><A HREF="#inxcheck">Index check!</A></LI>
</UL>
<LI><A HREF="#inxput">Index put byte/short/long into a repetition (no index check)</A></LI>
<LI><A HREF="#getval">Direct memory reads</A></LI> 
<LI><A HREF="#putval">Direct memory writes</A></LI>
<LI><A HREF="#comment">Comment</A></LI>
<LI><A HREF="#problems">Problems</A></LI>
</UL>
</UL>

<H2><A NAME="intro">Introduction</A></H2>

This document complements the general description of
<A HREF="http://www.daimi.au.dk/~beta/doc/beta/lowlevel.html">Low Level Primitives</A> in the
Mjølner implementation of the BETA language.  
<P>

<TABLE align=center border=1 color="red" bordercolor="red">
<TR>
<TD>
<FONT color="red">
<B>
THIS DOCUMENT IS NOT PART OF THE OFFICIAL BETA DEFINITION.<BR> 
PLEASE DO NOT GIVE THIS DOCUMENT TO OTHER PEOPLE.
</B>
</FONT>
</TD>
</TABLE>

<H2><A NAME="unsafe">Unsafe Low Level Operations</A></H2>

Some of the operations in this documents are insecure, in the sense that
wrong use may write/write to arbitrary memory locations, or may
disturb garbage collection and yield fatal runtime errors. Some of the low
level features are ONLY intended for implementation of low level
system issues.  They should NOT be used by ordinary programmers.

<H2><A NAME="@@">The <CODE>@@</CODE> operator</A></H2>

The <CODE>@@</CODE> operator returns the address of the argument. 
The semantics of
<CODE>@@</CODE>
 is highly dependent of the Mjølner implementation of BETA and is NOT part
of the official language. It is intended for implementation of low
level system features. The use of <CODE>@@</CODE> should be avoided, since the
semantics may change with implementation changes.
<P>
Consider an object:

<BLOCKQUOTE>
<PRE>
(# n: @integer;
   ch: @char;
   T: @text;
   S: ^text;
   V:< text;
   U: @V
   R: [111] @integer
#)
</PRE>
</BLOCKQUOTE>

The following are examples of <CODE>@@</CODE> expressions:

<BLOCKQUOTE>
<DL>
<DT><CODE>@@n</CODE>
<DD>The address of the memory location holding the integer attribute 
    <CODE>n</CODE>

<DT><CODE>@@ch</CODE>    
<DD>The address of the memory location holding the char attribute 
    <CODE>ch</CODE>

<DT><CODE>@@T</CODE>	  
<DD>The address of the memory location of the text object 
    <CODE>T</CODE>.
    Note that text is NOT a virtual pattern. In this case, 
    <CODE>@@T</CODE> is the same address as <CODE>T[]</CODE>

<DT><CODE>@@S</CODE>     
<DD>The address of the memory location holding the reference attribute
    <CODE>S</CODE>. 
    I.e. the address of the memory location holding a reference to
    the text object referred by <CODE>S</CODE>.

<DT><CODE>@@U</CODE>     
<DD>Since V is a virtual pattern, U is represented as a reference to a
    V object. @@U is the address of the memory location of this 
    reference.

<DT><CODE>@@R</CODE>    
<DD><CODE>R</CODE>
    is represented as a reference to a repetition object. 
    <CODE>@@R</CODE> is the 
    address of the memory cell holding this reference. 

<DT><CODE>@@R[10]</CODE> 
<DD>The address of the memory location holding <CODE>R[10]</CODE>. Notice the 
    difference between <CODE>@@R</CODE> and <CODE>@@R[1]</CODE>!
</DL>
</BLOCKQUOTE>

<H3><A NAME="inxget">Indexed get byte/short/long from a repetition (no index check)</A></H3>

Note: these operation are insecure.

<BLOCKQUOTE>
<PRE>
OP:	byteNo-&gt;R.%inxOP

	where inxOp is one of:

		getByte, getShort, getLong,
		getSignedByte, getSignedShort

	and inx in [0..R.OpRange-1]
</PRE>
</BLOCKQUOTE>

Note: <CODE>R.OpRange</CODE> is NOT <CODE>R.range</CODE>. 
If <CODE>R: [range] @integer</CODE>, then
then for getByte, <CODE>R.OpRange</CODE> is <CODE>R.range*4</CODE> etc.

<BLOCKQUOTE>
<PRE>
usage:	 inx-&gt;R.%getByte
</PRE>
</BLOCKQUOTE>

Note the difference between
<CODE>2 -&gt; A.%getByte</CODE>
and
<CODE>inx -&gt; R.%getByte</CODE>
  
where <CODE>A</CODE> is e.g. an integer variable and 
<CODE>R</CODE> a repetition.
The compiler now figures out that <CODE>R</CODE>R is a repetition,
 i.e. <CODE>inxGetByte</CODE>, etc.
have shortened to <CODE>getByte</CODE>.
<P>
In the old TOS-based primitives, <CODE>inx</CODE> used to a byte
offset even for short
and long. This means that the index-sequence for e.g. getShort is
<BLOCKQUOTE>
<PRE>
0, 2, 4, ...
</PRE>
</BLOCKQUOTE>

In the current implementation this is NOT true for short and long.
For short it is  short offset
For long is long offset.
<P>
Consider
  
<BLOCKQUOTE>
<PRE>
R: [10] @integer
</PRE>
</BLOCKQUOTE>
<P>
<CODE>5-&gt;R.%getByte</CODE> gets  byte no. 6 in R, i.e. byte 1 in 
<CODE>R[2]</CODE> 
(<CODE>R[2]</CODE>  consists of the bytes R[2].b0, R2].b1, etc.)
<P>

<CODE>3-&gt;R.%getShort</CODE> gets the short at byteposition 6, i.e.
bytes 2-3 in <CODE>R[2]</CODE>
<P>
In the old implementation this corresponds to
<CODE>6-&gt;R.%getShort</CODE>.
  
<H4><A NAME="inxcheck">Index check!</A></H4>
The old TOS-based inxPutByte primitives did NOT have index-
check. Should we have this? It may turn to be inefficeint, since e.g.
<BLOCKQUOTE>
<PRE>
R: [10] @ integer
</PRE>
</BLOCKQUOTE>

will have  1,10 in the low,high locations, and putByte should
check against 0,39. 
Since R.range can be changed dynamically, this may be a bit
expensive.
<P>
A future version should offer index-check.


<H3><A NAME="inxput">Index put byte/short/long into a repetition (no index check)</A></H3>

Note: these operations are insecure!

<BLOCKQUOTE>
<PRE>
OP:	(val,inx)-&gt;R.%inxOp

	where inxOp is one of

	putByte, putShort, putLong

usage:	(val,inx)-&gt;R.%putByte
</PRE>
</BLOCKQUOTE>

See the comments above for the indexed get-operations.

<H3><A NAME="getval">Direct memory reads</A></H3> 

Note: these operations are insecure.

<BLOCKQUOTE>
<PRE>
OP:	%getValAt (adr)
</PRE>
</BLOCKQUOTE>

where <CODE>getValAt</CODE> is one of:

<BLOCKQUOTE>
<PRE>
getByteAt, getShortAt, getLongAt
</PRE>
</BLOCKQUOTE>

The value at the address adr is read from memory. adr can be
an arbitrary evaluation yielding an integer.

<BLOCKQUOTE>
<PRE>
Usage: 	%getValAt (adr) -&gt; V
</PRE>
</BLOCKQUOTE>

<H3><A NAME="putval">Direct memory writes</A></H3>

Note: these operations are insecure.

<BLOCKQUOTE>
<PRE>
OP:	(val) %putValAt (adr)
</PRE>
</BLOCKQUOTE>

where adrPutOp is one of:

<BLOCKQUOTE>
<PRE>
putByteAt, putShortAt, putLongAt
</PRE>
</BLOCKQUOTE>

where adr is an evaluation yielding an integer.
<P>
The value val is stored at the the address specified by adr..

<BLOCKQUOTE>
<PRE>
usage:	(val) %putValAt (adr)
</PRE>
</BLOCKQUOTE>

Note:  The expression
  
<BLOCKQUOTE>
<PRE>
-11 %putByteAt @@Z+1
</PRE>
</BLOCKQUOTE>
  
will not put the value -11 at <CODE>@@Z+1</CODE>, since %putByteAt has highest
priority, so the above means
  
<BLOCKQUOTE>
<PRE>
- (11 %putByteAt @@Z) + 1
</PRE>
</BLOCKQUOTE>
  
It is therefore recommend to use parentheses as in
  
<BLOCKQUOTE>
<PRE>
(-11) %putByteAt (@@Z+1)
</PRE>
</BLOCKQUOTE>
  
<P>
Note: in cases like the above, it is better to write
<BLOCKQUOTE>
<PRE>
(-11,1)-&gt;Z.%putByte
</PRE>
</BLOCKQUOTE>
than
<BLOCKQUOTE>
<PRE>
(-11) %putByteAt (@@Z+1)
</PRE>
</BLOCKQUOTE>

since 'putByte is a 'safe' operation whereas 'putByteAt' is unsafe.
The operation 'putByteAt' can write a value at an arbitrary address.
If an addres is computed it is of course necessary to use 'putByteAt'.

<H3><A NAME="comment">Comment</A></H3>

We should still consider which of the above operations should be for
the users! BETA becomes more and more unsafe by introducing such
operations. I think that we should consider a compiler switch for
unsafe operations. I.e. normally the compiler do NOT accept unsafe
operations. Only if the switch is set, such operations are accepted.
Instead of a compiler switch, it could be a property of the fragment:

<BLOCKQUOTE>
<PRE>
foo.bet:

ORIGIN 'betaenv'
UNSAFE
INCLUDE ...
---x:A---
...
</PRE>
</BLOCKQUOTE>

This will mark unsafe modules. And these should include all modules
calling external procedures.
<P>
Modula3 has this distinction between modules.
<P>
Although most C-programmers dont care about safeness, there are still
a large number of people around that thinks that a high-level language
should be safe. BETA should be safe!

<H3><A NAME="problems">Problems</A></H3>

<PRE>
Flemming og jeg har idag kigger grundigt på %getBits og %getByte.

Der er flg problemer:

1) Nummereringen af bits og bytes er forskellig efter endian

2) Nummereringen er efter alle professionelle bit-vende're på mjølners
mening "helt i skoven".

3) Der er ikke forskel på getSignedByte og GetByte på (i hvert fald) sun.
(Den bruger ldsb i begge tilfælde). Det skal der være.

Forklaring:

2) Iflg. http://www./~olm/DOC/NewPrim.html er bit 0 den MEST significante
bit på sun, og den MINDST sig.  på intel.

2) Korrekt semantik iflg alle her:  Bit 0 skal være den MINDST significante
på ALLE platform.  Dvs. Bit 0 skal være den bit, der fås ved at udføre (i
%Band 2^0), dvs ((n,1)->i.%getBits) skal være (i %Band 2^n)

2) Der bør være samme semantik på tværs af endian, idet der er tale om
operationer på en Integer, som jo er det samme på tværs af endian, ikke på
"noget i memory".

1) Hvis nummereringen laves ens, vil man kunne implementere numberio uden
MDBODIES.   Lige nu virker putBinary, putByteHex, putHex ikke på Intel.

Implementationen på intel, hvor der bruges to shifts til at fiske de
rigtige bits ud, er korrekt.

Vi mener, det er langt mere holdbart at rette kodegenereringen, så der
nummereres konsistent end at hacke i f.eks. numberio-bodier.  Og når denne
rettelse skal laves, bør der rettes op på semantikken som beskrevet i 2)

Her er den "korrekte" nummerering:  Som eksempel bruges tallet 0x87654321.
Lad os slå fast igen at endian IKKE spiller nogen som helst rolle i dette
her!

          |---------------------------------------|
Integer:      8    7    6    5    4    3    2    1     
          |---------------------------------------|
Bytes:            87        65        43        21
          |31-----------------|------------------0|
Bits:      1000 0111 0110 0101 0100 0011 0010 0001  
          |---------------------------------------|

BETA-Kode, der illustrerer den korrekte definition:
(# i: @Integer;
do 0x87654321 -> i;
   0 -> i.%getByte	== 0x21
   3 -> i.%getByte	== 0x87

   (0,1) -> i.%getBits	== 1
   (1,4) -> i.%getBits	== 0
   (5,1) -> i.%getBits	== 1
   (6,2) -> i.%getBits	== 0
   (8,2) -> i.%getBits	== 0b11 == 0x3
   (31,1)-> i.%getBits	== 1
#);
</PRE>
