<HTML>

<HEAD>
<TITLE>Intel Binary Compiler</TITLE>
</HEAD>

<BODY>
<H1>Intel Binary Compiler</H1>

<H2>Contents</H2>

<UL>
<LI><A HREF="#intro">Introduction</A>
<LI><A HREF="#files">File organization</A>
<LI><A HREF="#bits">Bitpattern generation</A>
<LI><A HREF="#bincode">Binary codegeneration principle</A>
<LI><A HREF="#registers">Register model</A>
<UL>
  <LI><A HREF="#maps">aMap and dMap</A>
  <LI><A HREF="#fmap">fMap</A>
</UL>
<LI><A HREF="#optimization">Possible optimizations</A>
<LI><A HREF="#todo">Known problems</A>
<LI><A HREF="LinuxELF.html">Linux ELF specifics</A>
<LI><A HREF="WindowsCOFF.html">Windows PE COFF specifics</A>
<LI><A HREF="#bibliography">Bibliography</A>
</UL>

<H2><A NAME="intro">Introduction</A></H2>
Description of the binary intel BETA compiler backend.  Knowledge of
the virtual machine in the BETA compiler GENERATOR part (mOperands,
PutOp, LocalLabs, etc.) is assumed below, and is not explained
further.

<H2><A NAME="files">File organization</A></H2>

The files constituting the binary intel backend are 
(paths relative to directory GENERATOR):

<P>
<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR>
<TD><CODE>INTEL/intel.bet</CODE></TD>
<TD>Patterns used to generate the binary constants for the individual 
    intel instructions.
</TD>
</TR>

<TR>
<TD><CODE>INTEL/INTELmstate</CODE></TD>
<TD ROWSPAN=3>
Files corresponding to XXXmachine on other platforms.<BR>
The separationinto distinct files has been done to speed up 
recompilation.
</TD>
</TR>

<TR>
<TD><CODE>INTEL/INTELBmachine</CODE></TD>
</TR>

<TR>
<TD><CODE>INTEL/INTELtrace</CODE></TD>
</TR>
			

<TR>
<TD><CODE>LINUX/LINUXelf</CODE></TD>
<TD>Linux ELF file organization</TD>
</TR>

<TR>
<TD><CODE>NTI/WIN32coff</CODE></TD>	
<TD>Microsoft (and GNU) PE COFF file organization</TD>
</TR>

</TABLE>


<H2><A NAME="bits">Bitpattern generation</A></H2>

The patterns in intel.bet are used to model the intel 386/486
registers and instructions.  The comments refer to sections in
<A HREF="#intelbook">[INTELBOOK]</A>.

<P>
Each pattern for the different instructions enters a number of operands
and generates the corresponding bit pattern for the intel instruction
excluding immediate data etc, which are not part of the opcode itself.
<P>
Please look at section 26.2.1 for a general overview of the 
instruction format, fig. 26.1. Any instruction is a prefix of the
following general format:

<P>
<CENTER>
<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR ALIGN=CENTER>
<TD>opcode1</TD>
<TD>opcode2</TD>
<TD>mod</TD>
<TD>TTT</TD>
<TD>r/m</TD>
<TD>ss</TD>
<TD>inx</TD>
<TD>base</TD>
<TD>adrdisp, imm</TD>
</TR>

<TR ALIGN=CENTER>
<TD width="16%">byte1</TD>
<TD width="16%">byte2</TD>
<TD width="16%" COLSPAN=3>mod_rm byte</TD>
<TD width="16%" COLSPAN=3>s-i-b byte</TD>
<TD>bytes 5, 6, ...</TD>
</TR>

</TABLE>
</CENTER>
<P>

The opcode bits opcode1 (always present) and opcode2 are generated by 
the opcode patterns in <CODE>intel.bet</CODE>
(the patterns exiting 1 and 2 bytes repectively).
The TTT bits may be either a register number, or part of the opcode,
they are generated by the opcodes in <CODE>intel.bet</CODE> refering to
memory.
<P>
The s-i-b byte contains scale, index and base parts of the indexed 
adressing.<BR>
The adrdisp may be 32, 16 or 8 bit displacement or none.<BR>
The imm value may be 32, 16 or 8 bit or none.
<P>
The mod and r/m bits of the mod_rm byte, the s-i-b byte, and adrdisp
and imm are handled by the PutOp patterns of the different
mOperands.  Notice that the mod_rm with the proper TTT bits will
already have been emitted by the bitpattern generation patterns in
<CODE>intel.bet</CODE> when the PutOp is called.
<P>
The mnemonics used in the bitpattern generation patterns in
<CODE>intel.bet</CODE> means:
<P>
<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR><TH>Postfix</TH><TH>Meaning</TH></TR>
<TR><TD>_rr    </TD><TD>register to register (reg1 to reg2)</TD></TR>
<TR><TD>_rrr   </TD><TD>reverse reg to reg (reg2 to reg1)</TD></TR>
<TR><TD>_mr    </TD><TD>memory to register</TD></TR>
<TR><TD>_rm    </TD><TD>register to memory</TD></TR>
<TR><TD>_ir    </TD><TD>immediate to register</TD></TR>
<TR><TD>_im    </TD><TD>immediate to memory</TD></TR>
<TR><TD>_r     </TD><TD>register</TD></TR>
<TR><TD>_m     </TD><TD>memory</TD></TR>
<TR><TD>_i     </TD><TD>immediate</TD></TR>
<TR><TD>_direct</TD><TD>direct 32 bit relative control transfer</TD></TR>
<TR><TD>_short </TD><TD>direct 8 bit relative control transfer</TD></TR>
</TABLE>
<P>

<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR><TH>Prefix</TH><TH>Meaning</TH></TR>
<TR><TD>_     </TD><TD>short version of general instruction,
                       often using register EAX</TD></TR>
<TR><TD>intel_</TD><TD>just to distinguish from other patterns with 
                       otherwise identical names</TD></TR>
</TABLE>
<P>

<H2><A NAME="bincode">Binary codegeneration principle</A></H2>

<OL>
<LI>
   Instructions with no memory referencing operands
   are generated directly using the patterns in intel.bet.
<LI>
   Instructions referencing memory are generated as follows
   (see intel.bet):
   <OL TYPE="a">
   <LI>
      generate 1 or two opcode bytes and the mod_rm byte with only 
      the TTT bits filled out.
   <LI>
      call putOp for the memory referencing operand. This should
      plug in the rest of the bits in the mod_rm byte using
      mstate.b.patchLastByte. <BR>
      Also a possible s-i-b byte as well as a possible displacement
      byte should be generated by the putOp.
   </OL>
<LI>
   Finally call eoo to update IP (for .db files)
<LI>
   Note: because some instructions have special short versions if one of
   the operands are EAX (called "accumulator" in 
   <A HREF="#intelbook">[INTELBOOK]</A>). 
   Be sure to use the patterns
   <PRE>
       emitCmpImmReg       for  "cmp  imm,reg"          (all sizes) 
       emitAluImmReg       e.g. "add  imm,reg"          (all sizes) 
       emitMovlRegText     for  "movl reg,textaddress" 
       emitMovlTextReg     for  "movl textaddress,reg"
       emitMovlRegPrimreg  for  "movl reg,pReg"
       emitMovlPrimregReg  for  "movl pReg,reg"
       stValInLab          for  "movl reg,L"  and  "movl pReg,L"
       ldValFromLab        for  "movl L,reg"  and  "movl L,pReg"
   </PRE>
   - which checks for this - whenever appropriate.
</OL>

<H2><A NAME="registers">Register model</A></H2>

<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
 <TR><TH>Logical registers</TH><TH>Physical registers</TH></TR>
 <TR><TD>a0 (th)	  </TD><TD>EDX               </Td></TR>
 <TR><TD>a1 (ca)          </TD><TD>EDI</Td></TR>
				  
 <TR><TD>a2		  </TD><TD ROWSPAN=3>share EBP and ESI</Td></TR>
 <TR><TD>a3			  
 <TR><TD>a4			  
				  
 <TR><TD>a7 (sp)	  </TD><TD>ESP</Td></TR>
				  
 <TR><TD>d0	          </TD><TD ROWSPAN=8>share EAX, EBX and ECX</TD></TR>
 <TR><TD>d1	          
 <TR><TD>d2	          
 <TR><TD>d3	          
 <TR><TD>d4	          
 <TR><TD>d5	          
 <TR><TD>d6	          
 <TR><TD>d7	          


</TABLE>
<P>

Numbers for physical registers are (see intel.bet):

<PRE>
        eax: (# exit 0 #);
        ecx: (# exit 1 #);
        edx: (# exit 2 #);
        ebx: (# exit 3 #);
        esp: (# exit 4 #);
        ebp: (# exit 5 #);
        esi: (# exit 6 #);
        edi: (# exit 7 #);
</PRE>

For each logical register a0, a1, ..., a7, d0, d1, ..., d7 there
is a corresponding memory location where the value of the logical
register may have been saved.
<P>

Since a0, a1, and a7 are permanently assigned
physical registers and since a5, a6 are NOT used, it is actually
only the register a2, a3, a4 that may be saved in memory locations.
All of d0-d7 may be saved in memory locations.
<P>

A logical register may have one of the following assigments:
<OL>
<LI>assigned to a physical register
<LI>NOT assigned to any register
<LI>assigned to its memory location
</OL>

The arrays aMap, dMap, fMap handles mapping to/from logical registers
and physical registers or tmp. memory locations.
<P>

<H3><A NAME="maps">aMap and dMap</A></H3>

aMap and dMap are defined as follows:
<P>

<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR>
<TD>aMap[aReg+1]</TD>
<TD>maps the logical a-register into a physical register,
    no assignment, or memory location as described above
</TD>
</TR>
<TR>
<TD>dMap[dReg+1]</TD>
<TD>maps the logical d-register into a physical register
    no assignment, or memory location as described above
</TD>
</TR>
</TABLE>
<P>
Possible values:
<P>
For <CODE>ai</CODE>, i=0..7, <CODE>aMap[i+1]</CODE> is in 
<CODE>[-1, 0, EDX+1, EDI+1, EBP+1, ESI+1, ESP+1]</CODE><BR>
For <CODE>di</CODE>, i=0..7, <CODE>dMap[i+1]</CODE> is in 
<CODE>[-1, 0, EAX+1, EBX+1, ECX+1]</CODE>
<P>

where      

<P>
<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR>
<TD>-1  </TD><TD>means in memory location (<CODE>in_memory</CODE>)</TD>
<TR>
<TD>0   </TD><TD>means not assigned to any register (<CODE>unassigned</CODE>)</TD>
<TR>
<TD>fReg+1</TD><TD>means mapped to physical register fReg</TD>
</TABLE>
<P>

<H3><A NAME="fmap">fMap</A></H3>

fMap is defined as follows:
<P>

<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR>
<TD>fMap[fReg+1]</TD>
<TD>maps the physical registers fReg into the corresponding
    logical register, or no assignment
</TD>
</TR>
</TABLE>
<P>
Possible values:
<P>
For i=1,8: <CODE>fMap[i]</CODE> is in <CODE>[1,8]</CODE> as follows:
<P>
<PRE>
fMap[EDX+1] is th+1 = a0+1
fMap[EDI+1] is ca+1 = a1+1
fMap[EBP+1] is in [a2+1, a3+1, a4+1, 0]
fMap[ESI+1] is in [a2+1, a3+1, a4+1, 0]
fMap[ESP+1] is sp+1 = a7+1
fMap[EAX+1] is in [d0+1, d1+1, ..., d7+1, 0] 
fMap[EBX+1] is in [d0+1, d1+1, ..., d7+1, 0]
fMap[ECX+1] is in [d0+1, d1+1, ..., d7+1, 0]
</PRE>

where      

<P>
<TABLE BORDER CELLPADDING=5 CELLSPACING=0>
<TR>
<TD>0   </TD><TD>means not assigned to a logical register (<CODE>unassigned</CODE>)</TD>
<TR>
<TD>ai+1</TD><TD>means mapped to logical address register ai</TD>
<TR>
<TD>di+1</TD><TD>means mapped to logical data register di</TD>
</TABLE>
<P>


<H2><A NAME="optimization">Possible optimizations</A></H2>

<OL>
<LI>
   Various places are marked with "OPTIMIZE:". Some of these are obvious 
   TODOs, whereas other come from 
   <A HREF="#inteloptimization">[INTELOPTIMIZATION]</A>.
<LI>
   By now jumps to locallabs are optimized to short jumps, if
   the jump is backward and 8 bit. Ideally short forward jumps should be
   recognized too, but thats more tricky (requires more than one
   pass).
<LI>
   lea may sometimes be used as a three/four operand addition 
   instruction, e.g.  lea ecx, [eax+ebx+4+a]. This is not used.
<LI>
   There are often "double" move instructions in G-parts, e.g.
   <PRE>
   0x8052426 &lt;G1TSTVIRT2&gt;:   pushl  %edx
   0x8052427 &lt;G1TSTVIRT2+1&gt;: movl   %edi,%edx
   0x8052429 &lt;G1TSTVIRT2+3&gt;: movl   %edx,0x18(%edx)
   0x805242c &lt;G1TSTVIRT2+6&gt;: movl   %edx,%edi
   0x805242e &lt;G1TSTVIRT2+8&gt;: popl   %edx
   0x805242f &lt;G1TSTVIRT2+9&gt;: ret</PRE>
   This could instead have been
   <PRE>
   0x8052426 &lt;G1TSTVIRT2&gt;:   movl   %edi,0x18(%edi)
   0x8052429 &lt;G1TSTVIRT2+3&gt;: ret</PRE>
<LI>
   It should now be possible to avoid all the tests for PrimRegs in 
   register operations - ask Ole for details.
<LI>
   Possibly add operations <CODE>f2a</CODE>, <CODE>f2d</CODE>,
   <CODE>a2f</CODE>, <CODE>d2f</CODE> to <CODE>RegRep:descriptor</CODE>.
   This will make code more readable.
</OL>

<H2><A NAME="todo">Known problems</A></H2>

<OL>
<LI>
   ToOrigin calls CpReg with e.g. 0x8(%ebx) and pReg1 as operands.
   This makes ldOps use %eax as temporary register, i.e. it is a data
   register used for an address.
<LI>
<PRE>
Vi har et generelt problem - så hold tungen lige i munden:

Kig på

      s[] -> q[]

koden er her i forkortet version

      move    @@q , R1
      move    s   , R2
      move    R2, (R1)

R1 er altså addressen på q; dvs R1 indholder ikke en objekt referenc


Ved assignments der IKKE er mellem data-objekter cleares R1
på en eller anden måde af koden.

Det der gik galt i dit eksempel var at tre addresse registre
(R1,R2,R3) var i sving og disse deler som sagt 2 fysiske adr registr

Undervejs blev R1 ovenfor så gemt i en lager celle (a2) som
så ikke havde en objektreference.

MEN generelt kan det ske ved alle former for reference assigments,
at der er 3 travle R registre og at et eller flere af disse
fx R1 ovenfor kommer i et af lager cellerne a2-a4. Dette vil så
forvirre GC. Da det ikke hidtil har drillet voldsomt (det kan gi
sporadiske fejl) vil det nok ikke drille mere end det plejer
men vi skal ha fundet en løsning på et eller andet tidspunkt.
</PRE>

<LI>
<PRE>
Jeg har lavet et fix i INTELBmachine:gDiv som eliminerer
fejlen. Se kommentar mærket 'olm'. Men jeg forstår
ikke hvorfor det virker! Oprindelig gik jeg efter at eliminere
den 'konsistens' fejlbesked som dumpR udskrev. Jeg forstår
hvorfor den kom og fiksede den, men jeg forstår som sagt
ikke hvorfor det eliminerer fejlen. Vi bør NOK forstå hvorfor
det eliminerer fejlen, men det er helvedes indviklet.

--olm

> Jeg har tracet lidt på fejlen og vedlægger
> en trace. Det ser ud til at problemet opstår i
> 
>       ((i mod 100) div  10)
> 
> Allerede efter i mod 100 er der en register konflikt
> 
> Jeg har ikke ledt efter årsagen, men sikkert en fejl i gDiv
> 
> ---olm
</PRE>

<LI>
<PRE>
Det var en kedelig en.:-)

- generelt kan 2 eller flere groups
  ha dopart slots der hedder det samme
  (se fx dependency/checkslots).
  Dopart navne bruges ikke til entrypoints
  
  I fx 
  
  ---x:descriptor---
  (# Y: (# <<SLOT YYY:dopart>> #)
  #)
  
  vil YYY få navnet M2X
  
- Det der går galt her er at
  
  readfile (tstdoubledofield_ntibody)
  blir til M2TEXTFIELDPRIVATE
  
  Da den kaldes i en readFileDP i tstdoubledoextbody
  fejler local åbenbart:-(

Jeg kan ikke lige nu se hvor let det er at fikse
men jeg tror at det kan klares ved at teste på
origin af doparten - altså om det er den man
tro det er.
</PRE>

<LI>Problem with the following program: Gives floating point stack
underflow.
<P>
<PRE>
ORIGIN '~beta/basiclib/betaenv';
--- PROGRAM: descriptor ---
(# valg: @char; 
   jeps: @real;
do
   20.00->jeps;
   (if jeps
    // 20.00 then
   if);
   (if valg <> 'q' then
       restart Program
   if)
#)

(*
0x805669d <M1PROGRAM>:  pushl  %edx
0x805669e <M1PROGRAM+1>:        movl   %edi,%edx
0x80566a0 <M1PROGRAM+3>:        fldl   0x806bad4
0x80566a6 <M1PROGRAM+9>:        fstpl  0x10(%edx)
0x80566a9 <M1PROGRAM+12>:       fldl   0x10(%edx)
0x80566ac <M1PROGRAM+15>:       fldl   0x806badc
0x80566b2 <M1PROGRAM+21>:       fcomp  %st(1)
0x80566b4 <M1PROGRAM+23>:       fnstsw 
0x80566b6 <M1PROGRAM+25>:       sahf   
0x80566b7 <M1PROGRAM+26>:       jp     0x80508b5 <UoFV>
0x80566bd <M1PROGRAM+32>:       jne    0x80566c5 <M1PROGRAM+40>
0x80566c3 <M1PROGRAM+38>:       fcomp  %st(0)
0x80566c5 <M1PROGRAM+40>:       fcomp  %st(0)
0x80566c7 <M1PROGRAM+42>:       movzbl 0xc(%edx),%eax
0x80566cb <M1PROGRAM+46>:       movl   $0x71,%ebx
0x80566d0 <M1PROGRAM+51>:       cmpl   %ebx,%eax
0x80566d2 <M1PROGRAM+53>:       je     0x80566da <M1PROGRAM+61>
0x80566d8 <M1PROGRAM+59>:       jmp    0x80566a0 <M1PROGRAM+3>
0x80566da <M1PROGRAM+61>:       movl   %edx,%edi
0x80566dc <M1PROGRAM+63>:       popl   %edx
0x80566dd <M1PROGRAM+64>:       ret    
*)

</PRE>



</OL>


<H2><A NAME="bibliography">Bibliography</A></H2>


<DL>

<DT><A NAME="intelbook">[INTELBOOK]</A>
<DD>
<EM>Intel486 Microprocessor Family - Programmer's Reference manual</EM><br>
Intel 1992, ISBN 1-55512-159-4<BR>
<P>

<DT><A NAME="intelwww">[INTELWWW]</A>
<DD>
<EM><A HREF="http://www.intel.com/design/pentiumii/manuals/243191.htm">Intel Architecture Software Developer's Manual, Volume 2: Instruction Set
Reference Manual</A></EM><br>
<A HREF="http://www.daimi.aau.dk/~devise/internal/beta/PDF/Pentium_II_Instruction_Set.pdf">Local copy of PDF file</A>.<BR>
Part of <A HREF="http://www.intel.com/design/pentiumii/manuals/">Pentium® II Processors - Manuals</A><BR>
<P>

<DT><A NAME="inteldoc">[INTELDOC]</A>
<DD>
<A HREF="http://www.daimi.aau.dk/~devise/Internal/beta/INTEL/">Other
INTEL documentation</A>.<BR>
<P>

<DT><A NAME="inteloptimization">[INTELOPTIMIZATION]</A>
<DD>
<EM>Optimizations for Intel's 32 bit Processors</EM><br>
Intel Application Note AP-500, February 1994.<BR>
See also <A
HREF="http://www.intel.com/design/pentiumii/manuals/242816.htm">Intel
Architecture Optimizations Manual</A>.<BR>
<A HREF="http://www.daimi.aau.dk/~devise/Internal/beta/PDF/Intel_Optimization.pdf">Local copy of PDF file</A>.
<P>

</DL>


</BODY>
</HTML>