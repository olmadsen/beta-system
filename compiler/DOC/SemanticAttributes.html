<HTML>

<HEAD>
<TITLE>Semantic Attributes</TITLE>
<LINK REV="made" HREF="mailto:olm@daimi.aau.dk">
</HEAD>

<BODY>
<H1>Semantic Attributes</H1>

This document describes semantic attributes used by the BETA compiler.
<P>
An AST node of a given syntactic category of a grammar (here the BETA
grammar) can have one or more semantic attributes. A semantic attribue
is 4 bytes reserved in the AST node. The content of a semantic node
may be a simple value, like an integer, or a reference to an AST node,
possible in another fragment. The interpretation of a semantic node is
determined by the access pattern from the meta programming
system. I. e. there is no type checking on semantic attributes.

<p>
The number of semantic attributes associated with a node of a given
syntactic category is defined by the BETA grammar. See
<tt>'~beta/grammars/beta/beta-meta.gram'</tt>.

<P>
A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTES.
<P>
The following types are used todescribe semantic attributes:
<UL>
<LI><tt>int</tt> means an integer value.
<LI><tt>Iref</tt> means a reference to an AST node within the same fragment.
<LI><tt>Xref</tt> means a reference to an AST node in the same fragment 
    or in another fragment.
</UL>

<PRE>

List of semantic attributes:
 
   syntactic category:	Name:	     Type:	Location:
 
   attributesForm	Xorigin      Xref	2
 
   descriptorForm       descNo       int        1
    	  		Xorigin      Xref       2
 			sysAtt       Xref       3    hashIndex

 
   objectDescriptor	descNo       int        1
   			origin       Iref       2
   			size         int        3
 			attSize      int        4
			virtSize     int        4  !!!
 			kind         int        5
 			dclRoot      Iref       6
 			lib          Iref       7
                        returnOff    int        8  [bits  0-15]
 			originOff    int        8  [bits 16-31]
 			descId                  computed
 
   descriptor:slot      descNo       int        1
 			slotOrigin   Xref       2
 			size         int        3
 			attSize      int        4
 			kind         ínt        5
 			dclRoot      Iref       6
 		 	lib          Iref       7
 			originOff    int        8
 		 	descId                  computed
 			next         Iref       1
 
   repetitionDecl       origin       Iref       2
 
   forImp               origin       Iref       2
 
   MandatoryEnter
   OptionalEnter
   MandatoryExit
   OptionalExit		NXoff	     int        1
 			NXsize	     int        2
   insertedObject	insOff       int        2
   objectEval 		evalKind     int        1
   			insOff	     int        2 (if evalKind=insObj)
   labelledImp          origin       Iref       2
 
   nameApl              dclRef       Xref       1
 	                on           int        2
 	                pn           int        3 bits 0-15
 	                onForThis    int        3 bits 16-31
                        descRef      Xref       4
 
   nameDcl              accesss      int        1, first byte
 		        off          int        1, last 3 bytes
 		        left         Iref       2, first 2 bytes
 			right        Iref       2, last 2 bytes
 			sort         Iref       computed
   binding:nameDcl	virtDcl      Xref       1
                                                only to be used for nameDcl
 					        which are parts of bindingDecl.

   label:nameDcl        restartAdr   int        2, first 2 bytes
                                                only to be used for the
 					        namedcl-part of a labelledImp,
 					        
   label:nameDcl	leaveAdr     int        2, last 2 bytes
                                                only to be used for the
 					        namedcl-part of a labelledImp,
 					        
</PRE>
Notes:
<UL>
<LI>1.Attribute use for objectDescriptor:
  <UL>An objectDescriptor is classified into different categories
  <LI>Basic value (integer, char, boolean, real, ...)<br>
      attSize = -1 means unsigned<br>
      attSize = 0 means signed<br>
      This is NOT very clever and should be changed.<br>
      For a descriptor we need:<br>
      objSize: the size of att+doPart<br>
      NXoff:   start offset of tmp space for N/X parts<br>
      
  <LI>Constant value (<tt>(# exit 17 #)</tt><br>
      attSize represents the value of the constant (e.g. 17)
  <LI>Data
  <LI>General<br>
      virtSize (same attribute as attSize) represents the size of the virtual
      dispatch table.<br>
      For switch 180, returnOff represents the size of the object without
      possible space for enter/exit part. This should be cleaned up
      
  </UL>
<LI>2. DoPart form<br>
    <UL>
    <LI>descNo is size of doPart
    <LI>
    </UL>
<LI>3. MainPart form<br>
    <UL>
    <LI>descNo represents size of descriptor with mainPart
    <LI>kind represents the kind of the descriptor with mainPart
    </UL>
</ul>

</BODY>
</HTML>