<HTML>

<HEAD>
<TITLE>Things to be done!</TITLE>
<LINK REV="made" HREF="mailto:olm@daimi.aau.dk">
</HEAD>

<BODY>
<H1>Things to be done!</H1>

<PRE>

A.	Short term problems
===============================================================================

1.	Correct and optimized qua-check  &lt;------------------------------- DONE!

2.	Type check for simple types  &lt;----------------------------------- DONE!
		integrate fixBinOp, chkBinOpTypes, chkLst

3.	Reorganize compiler such that  x: @AST.index can be declared &lt;--- DONE!
	as x: @index to avoid index-check. Perhaps
	x: @astinterface.index will do?
	'index' has been renamed to 'ASTindex'.

4.	Eliminate thisVal in evVal.  &lt;----------------------------------- DONE!

5.	Change cError(#do 'foo'-&gt;T #); to 'foo'-&gt;cError &lt;---------------- DONE!
        cError is now called SystemError.

6.	Fix mainPart-slot problems!

7.	Fix ..db for callback (mbs/comp/todo.valhalla)

8.	Selective warnings - qua, no inner, etc.

9.	Division by zero - compile time and run-time

10.	Accepter non-terminaler alle vegne!

11.	Underscore i slot navne  &lt;-------------------------------------- DONE!

12.	Warning for operations that may cause endian problems

13.	Warning for unsafe operations. Safe module

14.	Fix handling of pattern data

15	Handle arguments in beta '-w -q tst'

16.	Special global search for this(p)

17.	Warning/codegen for stand-alone expressions:

		(e2,e2,e3)
		var = expr

18.	Do all checking before code generation

19.	Warning ved P.n where n is a simple integer?

20.	Parse fejl ved ukomplet program i
		(#
		do
	markeres 'do' som fejlpunktet

21.	It is NOT checked if a for-index variable gets assigned

22.	Proper handling of null-chars in strings (CopyT, puttext)

23.	Check that a call-back rotuine is NOT called directly in beta
	or make it work. Consider allowing inner for specializing a hierarchy
	of externals (real as well as call-back)

24.	Bobsgen should be fixed to handle digits in nonterminals and terminals.
	BOBS do handle arbitray characters in nonterminals and digits in
	terminals. The problem is the TABLES file and tabc, where a production
	label from the mps-gen is the nont followed by the prod no, i.e.
	trailing digits in the nont cannot be distinguished from the prod no's.
	Unknown why digits in terminals cause problmes, but also in tabc

25.	Check lst-error messages; make then work again with improved 
	messages; check FEJL/lstmsg*.bet; mbs/comp/lsterr

===============================================================================

B.	Long term PROBLEMS 

===============================================================================

	These are known problems, but neat solutions are needed

1.	Identical slot-names 

	May give link-errors, or unforeseen errors.

2.	Identical file names for libraries

	As for 1.

3.	Leave/restart out of active stack
-----------------------------------------
In the following example, the calls of -&gt;P will give a RT error
since the A-object in which &A[]-&gt;R[] was executed is NOT on
the stack, i.e. leave dont find it.
The RT error is: Attempt to leave basic component.
The message could probably be improved, in this case.
When calling -&gt;X; it seems to work.

Perhaps there is no major problem here?

---program:descriptor---
(# P: (# first: @boolean
      enter first
      do (if first then
             L: (# A: (# do leave L #)
                do &A[]-&gt;R[]
                #);
          else R
         if);
         'Hello world' -&gt;putLine;
         
      #);
   R: ^object;
   X: @P
do 'Go1'-&gt;putline;
   true-&gt;X; (*true-&gt;P*)
   'Go2'-&gt;putline;
   false-&gt;X; (*false-&gt;P*)
   'Go3'-&gt;putline
#)

4.	Recursive excution of static objects
--------------------------------------------

	X: @(# do ...; X; ..... #)

is NOT catched. The old implementation catched this since the
return addres was stored int the object. And it was tested if
it was zero before calling. If non-zero, there was a recursive error.

Perhaps the compiler can check that such recursion cannot happen?
Probably hard with modularization

5.	Stack overflow
--------------------------

A stack overflow causes a segmentation fault! Can we handle that
in a graceful manner?

6.	Struc-objects
---------------------

	En BETA pattern variabel er paa runtime repraesenteret vha. en
	prototype pointer samt 1 (en) origin reference. Antagelsen bag den
	repraesentation er at alle origins for et pattern kan beregnes ud
	fra det mest specifikke pattern. MEN DET KAN DE IKKE ALTID!!
	
	Betragt foelgende eksempel:
	
	        foo: (# bar: (# do INNER #)#);
	        f: ^foo;
	        b,bcopy: ^foo.bar;
	        s: ##Object;
	     do ...
	        &f.bar(# ... #)[]-&gt;b[];
	        NONE-&gt;f[];
	        b##-&gt;s##;
	        &s[]-&gt;bcopy[]; (* RUNTIME ERROR: REFERENCE IS NONE!!! *)
	
	Og hvorfor nu det?
	
	Jo, compileren forsoeger at beregne det mindst specifikke origin for
	bcopy objektet ud fra f (fundet via det mest specifikke origin), som
	jo nu er NONE.
	
	Og loesningen? Struct objekter skal indeholde samtlige origin 
	referencer, og ikke kun den mest specifikke. Det er ikke engang 
	svaert, og jeg forstaar egt. ikke hvorfor det ikke blev gjort fra 
	start...

7.	Dynamic objects in qualifications
------------------------------------------

	En anden ting: Ved du godt, at der kan kommer "reference is none"
	pga qua check i visse situationer?
	Lennert l|b ind i det ved

	 	&x[] -&gt; foo.y[]

	hvor foo.y var erkl{ret som

	 	y:&lt; a.b.c;

8.	Unbound slots
---------------------

	The compiler should NOT link if there are unbound descriptor/dopart
	slots.

	*	Collect all slots being met in a global list

	*	Remove when there is a binding

	*	Nolink if slots are left - give warning

	Problem: 
	Not all fragments are treated by the compiler. A body-fragment
	that has not been changed since the last compilation is not
	compiled. Possible unbound slots in such a fragment will not be
	found. They will be found when the body-fragment was compiled,
	but the information will be lost for the next compilation.
	I.e. a re-ill not scan the slots in the body-fragment.
	


==============================================================================

C.	Language completion

==============================================================================

1.	General repetitions

		R: [12] @ T

2.	Leave/restart of pattern inside a nested singular

		foo: (# do ..... (# do leave foo #); ... #)

3.	Nested comments

4.	True concurrency

5.	System level exceptions

6.	Componet ref &lt;-&gt; item ref &lt;-&gt; struc ref

	x: ^ T; y: ^ | T; z: ##T

	  x[] -&gt; y[];   
          y[] -&gt; x[]; (* run-time check *)
          z[] -&gt; x[];
          x[] -&gt; z[]; (* run-time check *)

7.	Char var -&gt; text

	a: @char: T: @text; .... a-&gt;T should be possible;
	what about a -&gt; T[]; yes!

8.	int8,int16,int32,int64,int8u,int16u,int32u,int64u

9.	Unicode strings

10.	Comparison, etc of non-basic patterns, like Point: (# ... exit(x,y) #);

11.	Virtual declarations before,after:&lt; object should be allowed.
	Require some work in bindVirtual, since it assumes one name,
	but no major work.

=============================================================================

D.	Optimizations

=============================================================================

1.	Optimize allocation of static items with respect
	to computing the origin.
	Example: x: @AST.index has a lot of origin levels.

2.	Optimize computation of origins by selecting origin 
	from part-objects and prefix-objects.

3.	Origin within singular part-objects can be computed 
	at compile-time.

4.	On SPARC(risk?) it is cheaper to test for empty inner (zero)
	instead of jumping to Return

5.	Can empty virtuals be optimized away?
		set: (# scan: (# while:&lt;(# do inner #); 
                               do (if while then ... if) #)#)
                s: @set; s.scan(# do #)
        Since s is static then by inlining scan(# ... #)
	while can be eliminated.

6.	If only 'inner' as in   &lt;--------------------------------------- DONE!

		P: (#do inner #)

	then in PP: P(# do ... }

		PP; should exe PP-do-part instead of P-do-part

	For V:&lt;(# do inner #) an indirect jsr can be made at the
	point of exe of V, instead of jst to topDesc.

	And no code should be generated for such descriptors.

7.	Rewrite asgRefAdr and chkHeap to eliminate superfluous  &lt;-------- DONE!
	clears and merge code to use delay slots! (SPARC only)

8.	Similarly when QUA-check

9.	Eliminate code-gen for empty G-parts.  &lt;------------------------- DONE!
	And superfluous 'nop' before 'ret' for sun4s/sun4s

10.	Use delay slot for mul/div - and fix pushCpar for constants

11.	Optimize sparc-code for non-local virtuals - use delay slots &lt;--- DONE!

12.	Improve code-gen for simple-if &lt;--------------------------------- DONE!

13.	Implement short-circuit eval for boolean exps &lt;------------------ DONE!

14.	Check simpleEvVal:asgToAdr, etc. return computedEvVal &lt;--------- DONE!
	when possible, and perhaps fix mch.copyMem to return
	register value when an intermediate register is used.

15.	Eliminate jmp-chains for nested if-imps

16.	Allocate text/real consts:
		foo: (#exit 'foo' #);
		pi: (#exit '3.14' #)
	once in data segment - use e.g. M-entrypoint for naming this

17.	Optimize qua-check and struc-comparisons

	   R## = T##	simple inlining of code

	   qua-check	use display of super-prototypes in prototype

	Avoid making struc-object for pattern T## in R## = T##

18.	According to Peter,"add 4, sp" takes less space that "lea sp(4),sp"
	on ix86.

==============================================================================

E	Other issues

==============================================================================

1. Compiler/bind fragments uhensigtsmaessighed: Ifoelge Kim kan det gaa
   haardt ud over effektiviteten at man skal scanne slots i same fragment-
   gruppe som det fragment der skal bindes. Dette kan dog nok ikke umiddelbart
   aendres, grundet definition i BETA bogen.
   Mindst 2 effektiviseringer mulige:

     a. Indfoere hash-tabel over SLOTs. (I stedet for nuvaerende linket liste).
     b. Evt. undlade at scanne slots i det fragment der skal bindes. Kim kigger
        paa muligheden.

2.	Fix optimized version of bobs/v6.9

3.	Eliminate errorName in betaenv

4.	Peter wants a -static option

5.	Index check fails on MC68 for range=0 - see mbs/comp/todo

6.	Division by zero:

	Der er tilsyneladende et problem med heltalsnuldivision p} sun4 og
	sun4s, hvor tilordningen
	   1/0 -&gt; i (* i: @integer *)
	kan afvikles uden problemer! Et evt. efterf|lgende
	   i -&gt; putInt
	giver udskriften
	   2147483647
	alias MaxInt.
	Der er ogs} problemer med flydendetalsnuldivision, denne gang p}
	b}de sun4, sun4s og snake, hvor tilordningen
	   1.0/0.0 -&gt; r (* r: @real *)
	igen g}r lige igennem. Denne gang reddes J|rgens {re dog af, at
	   r -&gt; putReal
	h{nger! :-)
	Linux og hpux8 virker ok.
	/Jacob

==============================================================================

F.	Language changes

==============================================================================

1.	F: ##V; V:&lt; ... is NOT allowed

2.	V ::&lt; &lt;&lt;SLOT ...&gt;&gt; NOT allowed

3.	Shorthand (if // b1 then ... //b2 then .... if)

4.	A: B(# do ... leave/restart B; ... #)
	and perhaps further up the super-chain of A

==============================================================================

G.	Fra status listen - skal integreres med ovenstaaende

==============================================================================

        Nye kendte fejl:
        ------------------
	2. Data instans fejlen

	Der skal m}ske indf|res en UNSAFE property.
	Problem med new og extend for generellerepetitions
	\nsker til forbedring af pattern data
        -------------------------------------
         - address attribute?
	   een af fordelene ved pattern ExternalRecord, er at man kan genneml|be
           ARRAYS af extern allokerede structs ved simpelthen at addere til "ptr"
           attributten i ExternalRecord. Dette er pt ikke muligt med "data".
           Skal der indf|res en "address" attribut p}"data"? Ellers vil den nok
           ikke kunne erstatte ExternalRecord p} lang sigt, som det er tilt{nkt
         - size attribut?
           Det vil v{re rart om man kunne f} den samlede st|rrelse af et data
           objekt at vide (ligesom bytesize i CStruct og sizeof() operationen i C)
         - Repetitions af de tilladte typer ville v{re rart (eks [16]@char).
         - maskinafh{ngigt alignment muligt? (allokering sker vel
           p} check tid?)
           F.eks. er addressen for "l" i forhold til adressen p} "c"
           ikke den samme p} hp9000s300 og hppa maskiner i f|lgende:
              struct {
                char c; /* fylder 2 bytes p} mc68020, 4 p} sparc/snake */
                long l;
              }
         - Mulighed for at accesse structs i struct vha nestede data patterns?
	 - Interface til C-tekster (char *). Automatisk konvertering til BETA
           objekter ved access, som i externals?
	 - Benyttelse som interface til externe navngivne variable, f.eks.
	     CVariable: Data(# do cLong #)
               (* Sammenlign External(# do callC #) *);
             XmLabelWidgetClass: @CVariable;
             XmRowColumnWidgetClass: @CVariable;
               eller
             rowColumnWidgetClass: @Data(# do 'XmRowColumnWidgetClass' -&gt; cLong #);

           Med denne mulighed kunne f.eks. motifInt.c og motif.make (der giver
           anledning til een af de mange 'make' liner ved overs{ttelse af motif
           programmer) helt undv{res, da motifInt.c kun rummer C-funktioner, der
	   returnerer v{rdien af navngivne globale C variable.
           Tilsvarende for cByte, cShort, pascalByte, pascalLong, pascalShort.
         - I C kan man i structures erkl{re bitfelter.
           Derfor ville foo: @bit og bar: [5]@bit v{re nyttig i data.


</PRE>

</BODY>
</HTML>