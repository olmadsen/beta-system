<HTML>

<HEAD>
<TITLE>Virtual Handling</TITLE>
<LINK REV="made" HREF="mailto:olm@daimi.aau.dk">
</HEAD>

<BODY>
<H1>Virtual Handling</H1>

<PRE>
A SuperChain represents a sequence of descriptors:
 
	 D1, D2, ... Dn 

where D1 is the start of the chain and

      Dn is represented by this(SuperChain)

The descriptor D1 represents a point in a fragment where some name, X,
is denoted. X is placed directly within D1, i.e. NOT in any internal
descriptor of D1.

The SuperChain is constructed during checking of X in various
situations. If X is a virual pattern or qualified by a virtual
pattern, the chain may be constructed in order to find the most
special descriptor of X visible from the point where X is placed.

Each Di in a chain has a 'kind' attribute describing its relation to its 
predecessor in the chain. The following values of kind are possible

     single: n=1 ; on,pn,on1,pn1, desc is defined.
		(but on,pn,on1,pn1 are not used?)

     plain: 1&lt;n  ; on,pn,on1,pn1, desc is defined.
		(but on1=pn1=0, i.e. NOT used?)

	Di is pattern-defined and Di is the superpattern of Di-1

	on,pn is the search-path from the prefix of Di-1 to Di
	Note that if Di = A (# .... #), then A is a nameApl in the 
	origin of A(# ... #). I.e. the search patah is from the 
	descriptor containing Di.

     remotePre: 1&lt;n ; on=on1=0, preDen defined.

	Di is pattern-defined, Di is the superpattern of Di-1, and Di
	is a remote name.

     implicitPre: 1&lt;n ; on,pn,on1,pn1 defined. 

     	Di-1 of the form V::&lt; (# #)
     	Di of the form V:&lt; A, V::&lt; A, 

     implicitRemotePre: 1&lt;n ; on=on1=0, preDen defined

     	Di-1 of the form V::&lt; (# #)
     	Di of the form V:&lt; R.A

     nest: 1&lt;n ; desc is defined.

	Di is a descriptor local to some Dj, j in [1,i-1] and
	Dk.kind&lt;&gt;nest, for k in [j,i-1]

Examples of chains:

1.	A simple super chain has the form:

	 	D1, D2, ... Dn 

  	where Di is the super pattern of Di-1, i&gt;1, and
  	D1.kind=single and Di.kind=plain, i&gt;1, as in

		A: (# ... #);		D3.kind=plain
		B: A(# ... #);		D2.kind=plain
		C: B(# ... #);		D1.kind=single

2.	A super chain with remote prefix is similar to 1., except that
	Di.kind=remotePre, for some i&gt;0 as in

		A: (# ... #);  		D3.kind=plain
		B: R.P(# ... #);	D2.kind=remotePre
                C: B(# ... #)		D1.kind=single
  
3.	A super chain with implixt prefix is similar to 1. except that
	Di.kind=implicitPre,for some i&gt;0, as in

		A: (# V:&lt; A;		D3.kind=implicitPre
		   #);
		B: A(# V:: (# ... #)	D2.kind=implicitPre
		    #);
		C: B(# V:: (# ... #)	D1.kind=single
		    #)

4.	A super chain with implicit remote prefix is similar to 3. except that
	Di.kind=implicitRemotePre, for some i&gt;0, as in

		A: (# V:&lt; R.A;		D3.kind=implicitRemotePre
		   #);
		B: A(# V:: (# ... #)	D2.kind=implicitPre
		    #);
		C: B(# V:: (# ... #)	D1.kind=single
		    #)

5.	A nested super chain may have the form 

		A1, A2, ..., An,
			     B1, B2, ..., Bm

	where A1, A2, ..., An and B1, B2, ..., Bm are super chains as
	the ones described in 1-4. I.e. Ai,i &gt;0 is a prefix of Ai-1, and
	Bi, i&gt;0 is a prefix of Bi-1. And B1.kind=nest, which means
	that B1 is defined within some Ai, . Example:

		G: (# ... #);		B2.kind=plain
		A: X(# ...
		       F: G(# ... #)	B1.kind=nest
		     #)			A3.kind=plain
		B: A(# ... #);		A2.kind=plain
		C: B(# ... #);		A1.kind=single


	Nested cuper chains are used to check assignments of the form

		X -&gt; Y

	where it is necessary to be able to get the actual descriptors
	of the elements of the exit/enter-lists of X and Y.

	Nested super chains are also used in computed remotes of the form

		(foo).x

	where the actual descriptor of the exit-element of foo must be known.

	Nested super chains in general
	------------------------------

	A sequence of nested super chains may have the form

		chain= (D1 D2 ... Dn
				  E1 E2 ... Em
					    F1 F2 ... Fk)

	where E1.kind=nest and F1.kind=nest.

	An enter/exit element, X, in Fk will have its actual descriptor
	searched relative to the whole chain, and a new chain with Xdesc
	as the last element will be returned, and Xdesc.kind=nest.

	The actualDesc of a possible prfix of Fk must be searched in
	the enclosing desc of chain (chain[]-&gt;ENC). 

	In the simple case where F1 F2 ... Fk are at the same block level,
	the ENC-CHAIN is:
		D1 D2 ... Dn E1 E2 ... Em

	The chain for this super desc will be chain[]-&gt;PRE, i.e.

		chain= (D1 D2 ... Dn
				  E1 E2 ... Em
					    F1 F2 ... Fk Fk-1)
	

-----

The pattern BindVirtual in sematt.bet has attributes for handling
binding of virtual patterns. The following attributes are relevant for
the use of SuperChain

	SuperChain: (# .. #) 	as described above

	NewSingle: 
	  (# desc: @AST.index enter desc ... #) 	
	  creates a new SuperChain D based on desc, where D.kind=single

	TheDesc:
           (# ES,desc: @AST.index; MN: @integer;
	      LL: ^SuperChain; isVirt: @Boolean
           enter(LL[],ES)
           do &lt;&lt;SLOT TheDesc:descriptor&gt;&gt;
           exit(desc,MN,LL[],isVirt)
           #);

A call of the form 

	(chain[],ES)-&gt;TheDesc-&gt; (ESdesc,MN,ESchain[],isVirt)

	where chain= D1, D2, ... Dn 

computes the actual descriptor of ES relative to chain.  This means
that if ES is defined using a virtual, the actual descriptor of ES
will be the most specific binding of this virtual seen from within D1.

A call of TheDesc may be initiated during checking of an
attribute-denotation, X, located within D1. The actual descriptor of
ES may be needed during the checking of X. ES is locatedin Dn. It may
be either the prefix of Dn or an anter/exit-element in Dn, or appear
in a declaration like S: ^ES, etc.

	ESdesc is the actual descriptor of ES relative to chain.

	ESchain is chain appended with new SuperChain elements

		E1, E2, ... Ek. k&gt;1

	and Ek=ESdesc, and Ek.kind=nest

	Specify the relations between chain and Ei ...!!!


</PRE>

</BODY>
</HTML>