<HTML>

<HEAD>
<TITLE>General Intel specifics</TITLE>
<LINK REV="made" HREF="mailto:olm@daimi.aau.dk">
</HEAD>

<BODY>
<H1>General Intel specifics</H1>

<PRE>

Documentation for INTEL 386 code generator
------------------------------------------

The following is the original (slightly modified) register allocation
for the INTEl 386:

	Registers

	th		EDX
	ca		EDI

	Address registers

	R1 (a2)		EBP
	R2 (a3)		ESI
	R3 (a4)		ECX 	- also used as datareg2 (d2)!!!

	a7 (sp)		ESP
	
	d0		EAX
	d1		EBX
	d2		ECX	- also used as R3 !!!!

	and there are no more data registers!

21.12.93: Proposal for revised register handling
------------------------------------------------

31.12.92: The proposal has been accepted! I.e. the following describes
register handling for the INTEL 386.

A distinction between logical and physical registers are made.  The
logical registers are the ones allocated by the compiler. The physical
registers are the ones on the processor.  On the Motorola and RISC
machines, there is a physical register corresponding to ecah logical
register. This is not possible on the I386/486 processor, which has
fewer registers.

The th (a0), ca(a1) registers are permanently allocated to physical
registers.  The 3 address registers (a2,a3,a4) share two physical
registers.  The 6 data registers share 3 data registers.

The following table shows the register allocation for the I386/486
processor:

	Logical registers		Physical registerds

	th				EDX
	ca				EDI

	Address registers

	a2				share EBP and ESI
	a3		
	a4		

	a7 (sp)				ESP
		
	d0				share EAX, EBX and ECX
	d1		
	d2		
	d3
	d4
	d5

Note, that it might be considered to let a2-a4, and d0-d7 share the 5
registers EBP-ECX. This will, however, create a problem for the
garbage collector, sicen it must know whether or not a register
contains a value or an object reference.

In memory the following temp. locations are allocated for the
registers:

	a2:
	a3:
	a4:
	d0:
	d1:
	d2:
	d3:
	d4
	d5::

If a logical register holds a defined value, and it is not allocated a
physical register, then the value is store in the corresponding
tmp. location.

Before each operation, the address registers a2-a4 and data registers
used by the arguments of the operation are mapped to physical
registers.

At most two address registers and two data registers are used by an
operation (I think!).

In practice, it is expected to be rare that more than 2 address
regsiers and more than 3 data registers are in use at the same time.
This may, however, be wrong!

Consider the operation add(op1,op2). The following beta code is executed
to emit this instruction:

	(op1[],op2[])-&gt;ldOps; { allocate physical registers for op1 and op2}
	' add '-&gt; BC.putT; op1.putOp; sep; op2.putOp; BC.putNL

The above design has been implemented in LINUXmachine. See this file
for implementations details
	        
--------------------------------------
15.5.93: created files IUXmachine.bet, etc. for compiler version
	to INTEL 386 UNIX based systems:

1.	all operands of mov, add, etc. have standard UNIX order, i.e.
	reverse order of standard INTEL assemblers!

2.	all operations and registers must be in lower case

4.	imult and div: arguments must be in special registers.

5.	better register allocation must be made:

	declare virtual registers d3,d4,d5,d6,d7, etc. in memory.
	before each operation using dataregister d3-, find free
	register to load value, unless operation can operate on memory.
	if no free register, store some register temporarely and restore after
	operation.

	Alo sa better register allocation is needed for primitive operations
	like putbits. Perhaps gen3body should handle dealloc of D-registers.
	In general arguments to primitive operations could be more efficient
	if not always passed via D[.] array.

6.	primitive registers are defined as the following memory locations:

		pReg1:
		pReg2:
		...

	but does not work properly since instructions like

		movl	12(%edx),pReg1

	are generated, and the processor does not implement

		movl	mem,mem

	Has been fixed!

7.	return result from primitive operations must be handled.

8.	Shift operations, shr,shl,etc

	In gen1body:shift it is tested if the shift count is greater than 8
	in which case the count is loaded into a register to be used as
	argument of shift operations. This is apparently necessary on
	the  MC68xxx. On the INTEL, the argument to shr, etc. must always
	be an 8-constant. It can never be a register.
	The test for count size should be moved to machine dependent parts.


9.	Floating point: Ccode.s seems to indicate that there is only ONE
	floating point register?
	NO! According to an Intel 486 manual in GADS bookstore, there are
	a number of floating point registers (8?). They may, however, be used
	as a stack. They are porbably being used that way by the  C compiler
	that translated  CCode.s?

---------------------------------------------------------

19.9.93

10.	Until recently, the origin parameter to AlloI, etc was passed
	in adr.reg. no. 2 (MC68: a2, SPARC: %i2).
	This has been changed. 'origin' is now passed in pReg1.
	This has not been updated in IUXmachine. 

	It is necessary to decide how to represent primitive registers
	on the Intel processor. A first attempt is described in item 1
	above, but as it is mentioned, this does not work!
	Perhaps some of the pRegs, (0,1) should be allocated in registers
	whereas the rest might be allocated in memory.

----------------------------------------------------------

15.12.93:	The above implementation of primitive regsiters does
         	now work. In memToMem operations it is checked if the
         	destination is a primReg in which case two operatiosn
         	are generated. See chkEmitReg

</PRE>

</BODY>
</HTML>