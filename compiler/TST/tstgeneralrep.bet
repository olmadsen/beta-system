ORIGIN 'tstenv';    
INCLUDE 'tstlib'
---lib: attributes---
tstGeneralRep:
  (# A:
       (# R4: [14] @ Foo; 
          R5: [15] @ Bar;
          R6: [16] @ Fisk;
          R7: [17] @ | GoGo;
          R8: [18] @ | Run;
          Bar: < object;
          Fisk: <<SLOT Fisk:descriptor>>     ;
          GoGo: 
            (# T: @text 
            enter T
            do N->put; T->putText; 
               suspend; 
               T->puttext; N->put
            exit N+5
            #);
          Run:<
            (# V: @integer
            enter V
            do L: (#do V+N->put; inner Run; suspend; restart L #)
            #);
          cpXt:<
            (# R5x,R5y: [1] @ Bar;
	       R8x,R8y: [1] @ | Run;
               ch: @char;
            enter ch
            do R5 -> R5x;  (* virtual copy valueRep *)
               R8 -> R8x;  (* virtual copy component valueRep *)
               inner
             #);
       #);
     Foo: (# ch: @char; t: @text #);   
     X: @ A(# Bar::< (# ch: @char #);
              Run::< (# do V+N+1->put #);
	      cpXt::
		(#
		do ch->R5[3].ch;
                   (if (R5[3].ch = R5x[3].ch)  
                       and (ch = R5x[3].ch)  then ch->put else '!'->put if);
                   ch + 1 -> ch;
                   ch -> R5x[3].ch;
                   R5x[2:4]-> R5y; (* virtual value rep slice *)
                   (if R5y[2].ch = ch then ch->put else '!' ->put if);
                   'x'->ch; ch->R8x[4].V; 1->N; 
                   R8x[4]; (* y-z *)
                   '0'->R8x[4].V;
		    R8x[2:5] -> R8y; 	
                   (if R8y[3].V = '0' then '0'->put else '!' ->put if); 
                 #)
           #);
     N: @char;
     astr:
       (# n: @integer; t: @text
       enter n
       do (if n
           //1 // 4 then 'ab'->t
           //2 then 'mn'->t
           //3 then 'yz'->t
           //4 then 'vw'->t
           //5 // 11 then 'fg'->t
           //6 // 12 then 'hi'->t
           //7 then 'rs'->t
           //8 then 'tu'->t
           //9 then '34'->t
           //10 then '56'->t
          if);
       exit t
       #);
     M: @integer;
     R9,R9x: [1] @ | Go;
     Go: (# i: @integer do N->put; suspend; N+1->put; #);   
     Home: (# ch: @char enter ch do ch->put #);
     R10,R11: [1] @Home;
  do (for i: 4 repeat 
          i->astr->X.R4[i].t;
          (if i
           // 1 // 4 then 
              'c'->X.R4[i].ch; 
              'd'->X.R5[i].ch; 
           // 2 then 
              'o'->X.R4[i].ch; 
              'p'->X.R5[i].ch; 
           // 3 then 
              '0'->X.R4[i].ch; 
              '1'->X.R5[i].ch; 
     if)for);
     4->M;
     (for i: 4 repeat
          X.R4[i].t->putText;             (* ab     mn    yz   ab *)
          X.R4[i].ch->put;                (* c      o     0    c  *)
          X.R5[i].ch->put;                (* d      p     1    d  *)
          (if i
           // 1 // 4 then 'e'->N    
           // 2 then 'q'->N               
           // 3 then '2'->N               
          if);
          i + M -> astr -> X.R7[i] -> N;  (* efg    qrs   234  efg *)
          i + 1 + M ->astr -> X.R7[i];    (* hij    tuv   567  hij *)
          m+1->M;
          1->X.R8[i];                     (* kl     wx    89   kl  *)
          (if i = 3 then newl if);
     for);
     5->R9.new;
     'm'->N; 
     R9[2]; 
     R9[2];
     1000->R9.extend;
     'o'->N;
     R9[999]; R9[999];
           
     'q'->R10[1];

     5000->R10.extend; (* 50000 gir IOA full *)
     'r'->R10[4999]; 
       
     R10->R11; 's'->R11[4001];
     
     401->R9[401].i;
     R9[201:403]->R9x;
     (if R9x[201].i = 401 then 't'->put else '!'->put; if);
     'u'->N; R9x[200]; R9x[200];
     
     'w'->X.cpXt;
     
     '1'->fill; 
  #)
---fisk:descriptor--
(# a: @integer
#)

