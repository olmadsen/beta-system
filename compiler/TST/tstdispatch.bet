origin 'tstenv';   
build default '$$/cdispatch.o'   'cdispatch.c'  '\$CC -c -o $0 $1'
---lib:attributes---
trace: (#exit true #);
struct_tagDISPPARAMS: DATA
  (# rgvarg: @int32 (* (Build argument array in ExternalRecord) *);
     rgdispidNamedArgs: @int32 (* (Build argument array in ExternalRecord) *);
     cArgs: @int32u (* UINT *);
     cNamedArgs: @int32u (* UINT *);
     
  #);
getArg: external(# args,N,arg: @integer enter(args,N) exit arg#);
getType: external(# args,N,arg: @integer enter(args,N) exit arg#);
textLen: external(# name,len: @int32 enter name exit len #);
copyText: external(# name,dest,len: @int32 enter(name,dest,len)#);
PutDispId: external(# dispId,ResList: @int32 enter(dispId,ResList)#);

printArgs:
  (# A: ^  struct_tagDISPPARAMS; V: @integer
  enter A[]
  do 
     (if A[] <> none then   
         ' rgvarg=' -> puttext; A.rgvarg->putint; newline;
         (for i: A.rgvarg repeat
              'argument '->puttext; i -> putint; ':'->put;
              (A.rgdispidNamedArgs,i) -> getType ->V;
              ' type='->puttext; V -> putint;
              (A.rgdispidNamedArgs,i) -> getArg ->V;
              ' arg='->puttext; V -> putint;
              newline
         for);
      else
         '\nprintArgs: A[] = none' -> putline
     if)
     
  #);  

Idispatch: dispatch
  (# GetIDsOfNames:<
       (# names,resList: @int32; (*[0]@char;*)
          result: @int32 (* HRESULT *)
       enter(names,resList)
       do inner
       exit result
       #);        
     
     Invoke:<
       (# dispIdMember: @int32;
          pDispParams: ^struct_tagDISPPARAMS; (* DISPPARAMS* *)
          result: @int32 (* HRESULT *)  
       enter(dispIdMember,pDispParams[])
       do INNER
       exit result
       #);          
  #);
---program:descriptor--- 
(# myX: Idispatch  
     (# f1:<  
          (# V,W: @integer
          enter(V,W)
          do '**** myX::f1:('->puttext;
             V ->putint; ','->put; W ->putint; 
             ') ****'->putline
          #);
        f2:<
          (# a,b: @integer;  
             c: [0] @char;  
             s: ^myData;    
             r: ^myCOM;
             h: ^myHolder 
          enter(a,b,c,s[],r[],h[]) 
          exit a 
          #);          
        f3:< 
          (# a,b,c: @integer 
          enter(a,b,c) 
          do '**** myX::f3:('->puttext; 
             a -> putint; ','->put; b ->putint; ',' -> put; c -> putint;
             ') ****'->putline;
          #);
        f4:<
          (# a: @integer
          enter a 
          do '**** myX::f4:('->puttext; a -> putint; ') ****'->putline;
          #); 
        GetIDsOfNames::<
          (# T: @text 
               (# equal:
                    (# t1: ^ text; b: @boolean
                    enter t1[]
                    do (if T.range = t1.T.range then
                           (for i: T.range repeat
                                (if T[i] <> t1.T[i] then
                                    leave equal
                           if)for); 
                           true -> b
                       if)
                    exit b
                    #);
               #); 
             dispId: @integer
          do (if trace then
                 'GetIDsOfNames: ' -> puttext;
             if);
             names -> textLen -> T.T.new;
             (names,@@T.T[1],T.T.range) -> copyText;
             (if trace then  
                 T[] -> puttext2; ' ==> ' ->puttext;
             if);
             (if true
              // 'f1' -> T.equal then 1 -> dispId
              // 'f2' -> T.equal then 2 -> dispId
              // 'f3' -> T.equal then 3 -> dispId
              // 'f4' -> T.equal then 4 -> dispId
             if); 
             (if trace then  dispId -> putint; newline; if);
             (dispId,ResList) -> putDispId
          #); 
        invoke::<
          (# a1,a2,a3: @integer  
          do (if trace then
                 'Invoke: dispIdMember=' ->puttext; dispIdMember -> putint;
                 pDispParams[] -> printArgs;
             if);
             (pDispParams.rgdispidNamedArgs,1) -> getArg ->a1;

             
             (if dispIdMember 
              // 1 then
                 (pDispParams.rgdispidNamedArgs,2) -> getArg ->a2;
                 (a1,a2) -> f1
              // 3 then 
                 (pDispParams.rgdispidNamedArgs,2) -> getArg ->a2;
                 (pDispParams.rgdispidNamedArgs,3) -> getArg ->a3;
                 'a3:'->puttext; a3 -> putint; newline;
                 (a1,a2,a3) -> f3
              // 4 then
                 a1 -> f4 
             if)
          #) 
     #);
   myData: data(# q,w,e: @integer #); 
   myCOM: COM (# f:< (# #)#);
   myHolder: holder(# value: @integer enter value exit value #);
   P: ^myX;
   q, w,x: @integer; 
   S: ^myData;  
   R: ^myCOM;      
   H: ^myHolder;   
   A: @  struct_tagDISPPARAMS;
   res: @integer
do newline; 
   &myX[] -> P[];     
   678->q;        
   (111,q) -> P.f1;
   
   newline;  
   (888,999,1020) -> P.f3;
   
   newline; 
   
   223344 -> q;
   q -> P.f4;  
   
   newline;     

   556677 -> P.f4
   (*(1,q,'hello',S[],R[],H[]) -> P.f2 -> x; *)
#)
