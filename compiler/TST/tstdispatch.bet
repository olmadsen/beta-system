origin 'tstenv'; 
(*origin '~beta/basiclib/betaenv';*)
build default '$$/cdispatch.o'    'cdispatch.c'  '\$CC -c -o $0 $1'
      nti     '$$/cdispatch.obj'  'cdispatch.c' 'betacc $0 $1'
      ppcmac  ':$$:cdispatch.obj' 'cdispatch.c'  'mrc -w 35 -o $0 $1'
---lib:attributes---
trace: (#exit true #);

struct_tagDISPPARAMS: DATA
  (# rgvarg: @int32 (* (Build argument array in ExternalRecord) *);
     rgdispidNamedArgs: @int32 (* (Build argument array in ExternalRecord) *);
     cArgs: @int32u (* UINT *);
     cNamedArgs: @int32u (* UINT *);
     
  #);

getArg: external(# args,N,arg: @integer enter(args,N) exit arg#);
getRefArg: external(# args,N,rArg: @integer enter(args,N) exit rArg#);
getTextArg: 
  external(# args,N: @integer; arg: [0]@char enter(args,N) exit arg#);
getCOMrefArg: 
  external (# args,N: @integer;xR: ^COM  enter(args,N) exit xR[] #);
getType: external(# args,N,arg: @integer enter(args,N) exit arg#);
textLen: external(# name,len: @int32 enter name exit len #);
copyText: external(# name,dest,len: @int32 enter(name,dest,len)#);
PutDispId: external(# dispId,ResList: @int32 enter(dispId,ResList)#);
 
printArgs:
  (# A: ^  struct_tagDISPPARAMS; V: @integer; T: [0]@char
  enter A[]
  do 
     (if A[] <> none then   
         ' cArgs=' -> puttext; A.cArgs->putint; newline;
         (for i: A.cArgs repeat
              'argument '->puttext; i -> putint; ':'->put;
              (A.rgvarg,i) -> getType ->V;
              ' type='->puttext; V -> putint;
              ' arg='->puttext; 
              (if V
               // 3 then
                  (A.rgvarg,i) -> getArg ->V;
                  V -> putint;
               // 4 then
                  (A.rgvarg,i) -> getTextArg ->T;
                  T -> puttext
               // 14 then 
                  (A.rgvarg,i) -> getRefArg ->V;
                  V -> putint
              if);
              newline
         for);
      else
         '\nprintArgs: A[] = none' -> putline
     if)
     
  #);  


int32uHolder: Holder
  (# value: @int32u enter value exit value #);
RefHolder: Holder
  (# type:< COM;
     ref: ^type;
  enter ref[] 
  exit ref[]
  #); 
ITYpeInfo: COM(# #); (* juts a dummy decl *)
ITypeInfoHolder: refHolder
    (# type:: ITypeInfo #);
GUIDdata: DATA (# #);
VARIANT: DATA(# #);
struct_tagEXCEPINFO: DATA(# #);

Idispatch: dispatch  
  (# QI:< (# #); 
     AddRef:< (# #);
     DeleteRef:< (# #);
     GetTypeInfoCount:<
       (# result: @int32 (* HRESULT *);
          pctinfo: ^int32uHolder (* UINT* *); 
       enter pctinfo[]
       do INNER;
       exit result
       #);    
     GetTypeInfo:<
       (# result: @int32 (* HRESULT *);
          iTInfo: @int32u (* UINT *); 
          _lcid: @int32u (* LCID *); 
          ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
       enter (iTInfo, _lcid, ppTInfo[])
       do INNER;
       exit result
       #);
     GetIDsOfNames:<
       (# result: @int32; (* HRESULT *)
          riid: ^GUIDdata;
          rgzNames: @int32u;
          cNames: @int32u;
          _lcid: @int32u;
          rgDispId: @int32; (*[0]@char;*)
       enter(riid[],rgzNames,cNames,_lcid,rgDispId)
       do inner 
       exit result 
       #);        
   
     Invoke:<
       (# dispIdMember: @int32;
          riid: ^GUIDdata (* REFIID* *);
          _lcid: @int32u (* LCID *);
          wFlags: @int16u (* WORD *);
          pDispParams: ^struct_tagDISPPARAMS; (* DISPPARAMS* *)
          pVarResult: ^VARIANT (* VARIANT* *); 
          pExcepInfo: ^struct_tagEXCEPINFO (* EXCEPINFO* *); 
          puArgErr: ^int32uHolder (* UINT* *); 
          result: @int32 (* HRESULT *)  
       enter(dispIdMember,riid[],_lcid,wFlags,pDispParams[]
          ,pVarResult[], pExcepInfo[], puArgErr[])
       do INNER
       exit result
       #);          
  #);
---program:descriptor--- 
(# myX: Idispatch  
     (# f1:<    
          (# V,W: @integer
          enter(V,W)      
          do '**** myX::f1:('->puttext;
             V ->putint; ','->put; W ->putint; 
             ') ****'->putline
          #);
        f2:<
          (# a: @integer;
             h: ^myHolder ;
          enter(a,h[]) 
          do '**** myX::f2:(' -> puttext;
             a -> putint; ','->put;
             h -> putint; 
             ') **** -> ' -> puttext;
             2122 -> h;
             2123 -> a;
          exit a 
          #);              
        f3:< 
          (# a,b,c: @integer 
          enter(a,b,c) 
          do '**** myX::f3:('->puttext; 
             a -> putint; ','->put; b ->putint; ',' -> put; c -> putint;
             ') ****'->putline;
          #);
        f4:<
          (# a: @integer
          enter a 
          do '**** myX::f4:('->puttext; a -> putint; ') ****'->putline;
          #); 
        f5:<
          (# a: @integer; T: [0] @char
          enter(a,T)
          do '**** myX::f5:('->puttext; a -> putint; ',\''->puttext;
             T -> puttext;
             '\') ****'->putline;
          #);
        f6:<                    
          (# a: @integer; S: ^myCOM
          enter(a,S[])
          do '**** myX::f6:('->puttext; a -> putint; ','->put;
             a -> S.f;
             ') ****'->putline;
          exit a
          #);
        GetIDsOfNames::<
          (# T: @text 
               (# equal:
                    (# t1: ^ text; b: @boolean
                    enter t1[]
                    do (if T.range = t1.T.range then
                           (for i: T.range repeat
                                (if T[i] <> t1.T[i] then
                                    leave equal
                           if)for); 
                           true -> b
                       if)
                    exit b
                    #);
               #); 
             dispId: @integer
          do (if trace then
                 'GetIDsOfNames: ' -> puttext;
             if);
             rgzNames -> textLen -> T.T.new;
             (rgzNames,@@T.T[1],T.T.range) -> copyText;
             (if trace then  
                 T[] -> puttext2; ' ==> ' ->puttext;
             if);
             (if true
              // 'f1' -> T.equal then 1 -> dispId
              // 'f2' -> T.equal then 2 -> dispId
              // 'f3' -> T.equal then 3 -> dispId
              // 'f4' -> T.equal then 4 -> dispId
              // 'f5' -> T.equal then 5 -> dispId
              // 'f6' -> T.equal then 6 -> dispId
             if); 
             (if trace then  dispId -> putint; newline; if);
             (dispId,rgDispId) -> putDispId
          #); 
        invoke::<
          (# a1,a2,a3: @integer; t1: [0]@char 
          do (if trace then
                 'Invoke: dispIdMember=' ->puttext; dispIdMember -> putint;
                 pDispParams[] -> printArgs;
             if);
             (pDispParams.rgvarg,1) -> getArg ->a1;

             
             (if dispIdMember 
              // 1 then
                 (pDispParams.rgvarg,2) -> getArg ->a2;
                 (a1,a2) -> f1;
              // 2 then
                 (# h: @myHolder
                 do (pDispParams.rgvarg,2) -> getRefArg -> h.adr;
                    (# qq: @char do  (a1,h[]) -> f2  -> x; #);
                    x -> putint; newline
                 #)
              // 3 then 
                 (pDispParams.rgvarg,2) -> getArg ->a2;
                 (pDispParams.rgvarg,3) -> getArg ->a3;
                 (a1,a2,a3) -> f3 
              // 4 then
                 a1 -> f4 
              // 5 then
                 (pDispParams.rgvarg,2) -> getTextArg -> t1;
                 (a1,t1) -> f5
              // 6 then
                 (# S: ^myCom
                 do (pDispParams.rgvarg,2) -> getCOMrefArg -> S[];
                    (a1,S[]) -> f6 ->x
                 #)
             if)
          #) 
     #);
   myData: data(# q,w: @integer; ch: @char #); 
   myCOM: COM 
     (# f:< (# a: @integer 
            enter a 
            do '**** myCOM::f:('->puttext; a->Putint; ') ****' -> puttext
            #)
     #);
   myHolder: holder(# value: @integer enter value exit value #);
   P: ^myX;
   q, w,x: @integer; 
   S: @myData;  
   R: @myCOM;      
   H: @myHolder;   
   A: @  struct_tagDISPPARAMS;
   res: @integer;
   XXX:(# val: @integer do 12->val exit val+val#)
do
   &myX[] -> P[];     
   
   newline;
   678->q;          
   (111,q) -> P.f1;
   
   newline;  
   555->q;
   (888,q+q,XXX) -> P.f3;  
 
   newline; 
     
   223344 -> q;
   q -> P.f4;   
  
   newline;      
    
   556677 -> P.f4;
 
   newline;  
   (8899,'Hello') -> P.f5;
     
   newline;
   12->S.q; 23 -> s.w; ':'->s.ch;
   44 - H;
   (88,H[]) -> P.f2 -> x; 
   
   newline;
   (99,R[]) -> P.f6 -> x;
   
#)



