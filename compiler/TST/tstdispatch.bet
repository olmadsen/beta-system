origin 'tstenv';
include 'tstdispatchlib'
---program:descriptor--- 
(# myX: Idispatch  
     (# f1:<    
          (# V,W: @integer
          enter(V,W)      
          do '**** myX::f1:('->puttext;
             V ->putint; ','->put; W ->putint; 
             ') ****'->putline
          #);
        f2:<
          (# a: @integer;
             h: ^myHolder ;
          enter(a,h[]) 
          do '**** myX::f2:(' -> puttext;
             a -> putint; ','->put;
             h -> putint; 
             ') **** -> ' -> puttext;
             2122 -> h;
             2123 -> a;
          exit a  
          #);               
        f3:< 
          (# a,b,c: @integer 
          enter(a,b,c) 
          do '**** myX::f3:('->puttext; 
             a -> putint; ','->put; b ->putint; ',' -> put; c -> putint;
             ') ****'->putline;
          #);
        f4:<
          (# a: @integer
          enter a 
          do '**** myX::f4:('->puttext; a -> putint; ') ****'->putline;
          #); 
        f5:< 
          (# a: @integer; T: [0] @char
          enter(a,T) 
          do '**** myX::f5:('->puttext; a -> putint; ',\''->puttext;
             T -> puttext;
             '\') ****'->putline;
          #);
        f6:<                    
          (# a: @integer; S: ^myCOM
          enter(a,S[])
          do '**** myX::f6:('->puttext; a -> putint; ','->put;
             a -> S.f;
             ') ****'->putline;
          exit a
          #);
        f7:< 
          (# S: @BSTR 
          enter S 
          do'**** myX::f7:('->puttext; 
             ') ****'->putline;
          #);
        GetIDsOfNames::<
          (# T: @text 
               (# equal:
                    (# t1: ^ text; b: @boolean
                    enter t1[]
                    do (if T.range = t1.T.range then
                           (for i: T.range repeat
                                (if T[i] <> t1.T[i] then
                                    leave equal
                           if)for); 
                           true -> b 
                       if)
                    exit b
                    #);
               #); 
             dispId: @integer
          do (if trace then
                 'GetIDsOfNames: ' -> puttext;
             if);
             rgzNames -> textLen -> T.T.new;
             (rgzNames,@@T.T[1],T.T.range) -> copyText;
             (if trace then  
                 T[] -> puttext2; ' ==> ' ->puttext;
             if);
             (if true
              // 'f1' -> T.equal then 1 -> dispId
              // 'f2' -> T.equal then 2 -> dispId
              // 'f3' -> T.equal then 3 -> dispId
              // 'f4' -> T.equal then 4 -> dispId
              // 'f5' -> T.equal then 5 -> dispId
              // 'f6' -> T.equal then 6 -> dispId
              // 'f7' -> T.equal then 7 -> dispId
             if); 
             (if trace then  dispId -> putint; newline; if);
             (dispId,rgDispId) -> putDispId
          #); 
        invoke::<
          (# a1,a2,a3: @integer; t1: [0]@char 
          do (if trace then
                 'Invoke: dispIdMember=' ->puttext; dispIdMember -> putint;
                 pDispParams[] -> printArgs;
             if);
             (pDispParams.rgvarg,1) -> getArg ->a1;

             
             (if dispIdMember 
              // 1 then
                 (pDispParams.rgvarg,2) -> getArg ->a2;
                 (a1,a2) -> f1;
              // 2 then
                 (# h: @myHolder
                 do (pDispParams.rgvarg,2) -> getRefArg -> h.adr;
                    (# qq: @char do  (a1,h[]) -> f2  -> x; #);
                    x -> putint; newline
                 #)
              // 3 then 
                 (pDispParams.rgvarg,2) -> getArg ->a2;
                 (pDispParams.rgvarg,3) -> getArg ->a3;
                 (a1,a2,a3) -> f3 
              // 4 then
                 a1 -> f4 
              // 5 then
                 (pDispParams.rgvarg,2) -> getTextArg -> t1;
                 (a1,t1) -> f5
              // 6 then
                 (# S: ^myCom
                 do (pDispParams.rgvarg,2) -> getCOMrefArg -> S[];
                    (a1,S[]) -> f6 ->x
                 #)
              // 7 then
                 (* we cant yet handle the argument correctly *)
                 a1 -> f7 
             if)
          #) 
     #);
   myData: data(# q,w: @integer; ch: @char #); 
   myCOM: COM 
     (# f:< (# a: @integer 
            enter a 
            do '**** myCOM::f:('->puttext; a->Putint; ') ****' -> puttext
            #)
     #); 
   myHolder: holder(# value: @integer enter value exit value #);
   P: ^myX;
   q, w,x: @integer; 
   S: @myData;    
   R: @myCOM;      
   H: @myHolder;   
   A: @  struct_tagDISPPARAMS;
   res: @integer;
   XXX:(# val: @integer do 12->val exit val+val#);
   BS: @BSTR
do
   &myX[] -> P[];     
   
   newline;
   678->q;          
   (111,q) -> P.f1;
  
   newline;  
   555->q;
   (888,q+q,XXX) -> P.f3;  
 
   newline; 
     
   223344 -> q;
   q -> P.f4;   
  
   newline;      
    
   556677 -> P.f4;
 
   newline;  
   (8899,'Hello') -> P.f5;
     
   newline;
   12->S.q; 23 -> s.w; ':'->s.ch;
   44 - H;
   (88,H[]) -> P.f2 -> x;   
   
   newline;
   (99,R[]) -> P.f6 -> x;
   
   newline;  
   BS -> P.f7
#)







  



