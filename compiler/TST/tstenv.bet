(*LIBRARY 'tstenv'       *) 
[[------------ENV: descriptor--------------   
(************************************************)
(*           Minimal BETA environment           *)
(************************************************)
(# program: <<SLOT PROGRAM: descriptor>>;
  
   <<SLOT LIB: attributes>>;

   put:
     (# write: External
          (# index,address,bufSize,status: @integer
          enter(index,address,bufSize)
          exit (status)
          #);
        ch: @ char; status: @integer   
     enter ch
     do (1,@@ch,1)->write->status
     #);
   newline: (# do 10 -> put; (* Mac 13 *) #);
   putText:
     (# T: [1] @char
     enter T
     do (for i: T.range repeat T[i]-> put for)
     #);
   putLine:
     (# T: ^Text
     enter T[] do T->puttext; newline
     #);
   putInt:
     (# n,i: @integer; W: [12]@char
     enter n
     do (if n<0 then '-'->put; -n->n if); 
        L:
          (if n//0 then 
              (if i//0 then '0'->put
               else
                  (for j:i repeat
                       W[i-j+1]+'0'->put
              for)if)
           else
              n mod 10 -> W[i+1->i];
              n div 10 ->n;
              restart L
        if)
     #);
   text: (# T: [1] @char; lgth,pos: @integer enter T exit T #);
  
   indent: @Integer;
   Newl: @
     (# Prompt: [10] @char; (* prompt for each test part, max 10 chars*)
     enter prompt
     do '.'->put; newline; Prompt->puttext; 
        (for i: 10-prompt.range repeat ' ' ->put for);
        ':' -> put;
        (for i: 1 (*indent*) repeat ' ' -> put for);
        indent+1 -> indent;
     #);
   charValue: (# value: @char do INNER exit value #);
   CHAR: (# #);
   INTEGER: (# #);
   BOOLEAN: (# #);
   FALSE: BOOLEAN(# #);
   TRUE: BOOLEAN(# #);  
   shortInt: (# #);
   real: (# x,y: @integer enter(x,y) exit(x,y) (* realdesc *) #);
   External:
     (# CallC,CallPascal,Pascal,PascalTrap,
  	cExternalEntry,PascalExternalEntry: @text   
     #); 
   IntegerValue: (# value: @integer do INNER exit value #);
   IntegerObject: IntegerValue(# enter value do INNER #);
   CStruct: (* Super-pattern for describing CStruct-patterns *)
     (# R: [(byteSize) div 4 + 1] @integer;
        byteSize:< IntegerObject
          (* R is the bytestream containing the CStruct. 
           * Must be declared as the first attribute 
           *);
        Byte: (* Used for declaring CStruct fields *)
          (# p: @pos; pos:< IntegerObject; val: @integer;
             set: @(# enter val do (R,p,val)->TOS'%inxPutByte' #);
          enter set
          exit (R,p)->TOS'%inxGetByte'
          #);
        Long: (* Used for declaring CStruct fields *)
          (# p: @pos; pos:< IntegerObject; val: @integer;
             set: @(# enter val do (R,p,val)->TOS'%inxPutLong' #);
          enter set
          exit (R,p)->TOS'%inxGetLong'
          #);
     #);

   Data: (# #);     
   ErrorName: (# #);
   Object:
     (# Struc: (# R: ##Object do TOS'ThisS'->R## exit R## #); 
      do INNER
      #);
   repetition:       
      (* pattern describing repetitions.
       * Do NOT use as superpattern!!! 
       *)
      (# range: (* exit the range of THIS(rep) *)
	   (# n: @ integer exit N #);
         new:
	   (* allocate a new repetition of N elements
	    * the current elements in THIS(rep) becomes inaccessible
            *)
	   (# n: @integer enter n #);
         extend: (* extend THIS(rep) by N elements *)
	   (# N: @integer enter N #);
      #);
         
do 'O'->put; 'K'->put; newline;
   &program;
   newline
#)
-------------------------]]

