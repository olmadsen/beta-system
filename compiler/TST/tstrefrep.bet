ORIGIN 'tstenv' ; 
INCLUDE 'tstlib'
---lib:attributes---
TstRefRep:
  (# smartchar: (# rep: @char;
		   putC: (# do rep->put #);
		enter rep 
		exit rep
		#);
     putSmartChar:
       (# s: ^smartchar
       enter s[]
       do (if s[]=NONE then
              '<NONE>' -> puttext;
           else
              '\'' -> put;
              s -> put;
              '\'' -> put;
          if)
       #);
     cmpS: 
       (# i: @integer;
          s1, s2: ^smartchar;
          indicator: @char
       enter (i, s1[], s2[], indicator)
       do (if s1[]<>s2[] then 
              '['->put; 
              indicator->put;
              i->putint; 
              ':' -> puttext;
              s1[] -> putsmartchar; 
              '<>' -> puttext;
              s2[] -> putsmartchar;
              ']'->put; 
              (* Object.%break; *) 
          if);
       #);
     R: [integerValue(#do (if isByteCodeMode then 26 -> value else 1-> value if)#)] ^smartchar; S: [10] @char;
     addZ: (# i: @integer enter i do i+'0'->i exit i #);
     R1,R2: [10] ^smartchar;
     R3: [2] ^smartchar;
     R4: [2] @integer;
     Stext:
       (# R: [1] @ Char; len: @integer
       enter (# enter R do R.range->len #)
       exit R[1:len]
       #);
     T1,T2: @ Stext;
     c: ^smartchar;
     ch: @char;
     chars, chars2: [500]^smartchar;
     chars3: [0]^smartchar;
     Test1:
       (# 
       do (for i: 26 repeat
               (if (i>R.range)//true then R.range->R.extend if);
               &smartchar[]->R[i][]; 'a'-1+i->R[i] 
          for);
          (if R.range>26 //true then 26-R.range->R.extend if);
          (for i: R.range repeat R[i].putC for);
          (for i: s.range repeat i->addZ->S[i] for);
          (for i: s.range repeat S[i]-1->R[i] for); 
          (for i: s.range repeat R[i].putC for);
       #);

     Test2:
       (# Test2a:
            (# 
            do (for i: 10 repeat &smartchar[]->R1[i][]; 'a'-1+i->R1[i] for);
               R1->R2 (* CopyRR, range 10 *); 
               (for i:R2.range repeat R2[i].putC for);
            #);
          Test2b:
            (# 
            do 7->R3.new; 
               (for i:R3.range repeat &smartchar[]->R3[i][];   
                    i+'k'-1->R3[i]; R3[i].putC;
               for);
            #);
          Test2c:
            (# 
            do (if false(*isByteCodeMode*) then
                   '####' -> puttext;
                else
                   R1[2:5]->R2; (* CopySRR, range 4 *)
                   (for i:R2.range repeat  
                        R2[i]+16 -> R2[i]; 
                        R2[i].putC; 
                   for); 
               if);
            #);
          Test2d:
            (# 
            do 18->S.new; 
               '!vwxyz0123456789$'->S; 
               S[2:15]->puttext (* CopySRR, range 14 *);
            #);
          Test2e:
            (# 
            do 13->R4.new; 177->R4[13];
               (if R4[13] // 177 then '9'->put; else error; if);
            #);
       do Test2a;
          Test2b;
          Test2c;
          Test2d;
          Test2e;
       #);
     
     CopyRR:
       (# 
       do chars -> chars2 (* CopyRR, range 500 *);
          (for i:500 repeat
               (i, chars[i][], chars2[i][], '$') -> cmpS;
          for);
       #);
     
     ExtRR:
       (# 
       do 500 -> chars2.extend; (* ExtRR, addrange=500 *)
          (for i:500 repeat 
               (i, chars[i][], chars2[i][], '*') -> cmpS
          for); 
          (for i:500 repeat
               (i+500, chars2[500+i][], NONE, '+') -> cmpS;
          for);
       #);
     
     CopySRR:
       (# 
       do chars2[2:499] -> chars3; (* CopySRR, range 498 *)
          (for i:498 repeat
               (i, chars2[i+1][], chars3[i][], '&') -> cmpS;
          for)
       #);
     
     Test3:
       (# 
       do 'a' -> ch;   
          (for i:26 repeat  
               &smartchar[] -> chars[i][]; 
               ch -> chars[i]; 
               chars[i] -> put;
               ch+1->ch;
          for);
          (for i:500-26 repeat 
               (26+i, chars[26+i][], NONE, '%') -> cmpS;
          for);
          &smartchar[] -> chars[500][];
          CopyRR;
          ExtRR;
          &smartchar[] -> chars2[499][];
          CopySRR;
       #);
     
  do Test1;
     'Ref. rep2' -> newl;
     
     Test2;
     'Ref. rep3' ->newl;   
     
     Test3;
     '0' -> fill;   
     
  #)

