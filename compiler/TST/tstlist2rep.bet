ORIGIN 'tstenv';     
INCLUDE 'tstlib'
---lib:attributes---
tstlist2rep:
  (# stream: 
       (# putt:
            (# ch: @char
            enter ch
            do ch -> put
            #)
       #);
     screen: @stream;
     
     R: [3] @ integer;
     PutR: 
       (# base: @char
       enter base
       do (for i: R.range repeat
               R[i] + base - 1 -> put 
          for);
       #);
     
     a,b: @integer; 
     foo:  
       (# s: ^stream; L: [1] @integer; ch: @char
       enter(s[],L,ch)
       do (for i:l.range repeat
               L[i] -> S.putt;
          for);
          ch -> put; 
       #);
     bar: 
       (# c: [1] @char
       enter c 
       do (for i:c.range repeat c[i] -> put for);
       #);
     ch: @char;
     F: [1] @real;  
     PutF:
       (# N: @integer
       do (for i: F.range repeat
               (if F[i] 
                // 1.1 then 't' -> put
                // 2.2 then 'u' -> put
                // 3.3 then 'v' -> put
                // 4.4 then 'w' -> put
                // 5.5 then 'x' -> put
                // 55 then 'y' -> put
                // 66 then 'z' -> put
                // 77 then '0' -> put
                else 
                   (if (F[i], 3.3) -> eqR then
                       'v' -> put
                    else
                       error
          if)if)for); 
       #);  
     X: @real;

     S: [1] ^text;
     T1,t2: @text; t3: ^text; 
     tstMore:
       (# T,S: @text
            (# pos: @integer;
               get:
                 (# ch: @char 
                 do T[pos+1->pos] -> ch
                 exit ch
                 #);
               getint:
                 (# n: @integer; ch: @char
                 do L: (if (get->ch) <= ' ' then restart L if);
                    L: (if ('0'<= ch) and (ch <= '9') then
                           n*10 + ch - '0' -> n;
                           get -> ch;
                           restart L
                       if) 
                 exit n
                 #); 
            #);  
          a1,a2,a3: @integer;
          R: [1] @char 
       do 97 -> S;
          S[] -> puttext2; 
 
          '98  99  100  101 102 103 104 105' -> T; 
          0 -> T.pos; 
           
          T.getint -> S; 
          S[] -> puttext2;
          
          T.getint->a1;  T.getint->a2;  T.getInt->a3;
          (# x: @char 
          do (a1,a2,a3) -> S;
          #);
          S[]->puttext2;
          
          T.getint->a1;  T.getint->a2;  T.getInt->a3;
          (a1,a2,a3) -> R;
          (for i: R.range repeat R[i]->put for);
       #);  
     tstwithObj:
       (# putInt16Array: 
            (# Dimensions: [0]@integer;
               R: ^text;
            enter(Dimensions, R[]) 
            do (for i: dimensions.range repeat 
                    dimensions[i] -> put
               for);

            #); 
          ccc: @char;
          foo: (# do ccc+1 -> ccc exit ccc #)
       do 'h'-> ccc;
          ((foo,foo), &text[]) -> putInt16Array 
       #); 
     tstChar2Rep:
       (# Q: [0] @integer;
          W: [0] @int16;
          E: [0] @int8;
          R: [0] @char          
       do '5' -> Q; Q[1] -> put;   
          '6' -> W; W[1] -> put;   
          '7' -> E; E[1] -> put;   
          '8' -> R; R[1] -> put;   
       #); 
     tstList2RefRep:
       (# T: (# ch: @char do ch -> put #);
          R: [1] ^T;
           
          s1,s2,s3: ^T;
          fool:
            (# R: [0] ^text
            enter R
            do (for i:R.range repeat 
                    R[i][] -> puttext2 
            for)#);
          t1,t2,t3: @text;
          t4: ^text;
          TT: [0]^text;
          putTT: (#do (for i: TT.range repeat TT[i][]->puttext2 for)#);
          L: [10] ^TTT;
          L1,L2: ^TTT; 
          TTT: (# x,y: @integer 
               do xx + 1 -> xx; xx+1111 -> x; xx+2222 -> y 
               exit this(TTT)[]
               #);
          xx: @integer;
          PutL:
            (#
            do (if L.range=1 then 
                   'w'->put;              
                   (if L[1].x = 1113 then 'x'->put else error if);
                   (if L[1].y = 2224 then 'y'->put else error if)
                else error 
               if)
            #);

       do &T[] -> s1[]; 'b' -> s1.ch;
          &T[] -> s2[]; 'c' -> s2.ch;
          &T[] -> s3[]; 'd' -> s3.ch;
          (# x: @char;    
          do (s1[],s2[],s3[]) -> R;  
          #);
          (if R.range = 3 then 'a' -> put  if);
          (for i: R.range repeat R[i] for);
          'efg' -> t1.T;
          'hi' -> t2.T;
          'j' -> t3.T;
          (# dum: @integer do    (t1[],t2[],t3[]) -> fool; #);
          &text[] -> t4[];
          'mn' -> t4.T;
          (# x: @char do ('kl',t4[],'o','p','qr') -> fool #); 
          (if safeMode and isINTEL then 
              'st' -> puttext;
           else
              (* Fails with unconditional GC *)
              'st'->T1; 
              (# dummy:@char do T1[]->TT; #);
              putTT; 
          if);
          (if (*safeMode and *)isINTEL then
              'uv' -> puttext;
           else
              (* Fails with unconditional GC *)
              'uv'->T4;  
              T4[]->TT; putTT;  
          if);
          1 ->xx;
          (if safeMode and isINTEL then
              'wxy' -> puttext;
           else
              (* Fails with unconditional GC *)
              &TTT -> L; PutL; 
          if); 
       #) 
       
  do 2->a; 3 -> b;      
     (1,a,b) -> R; 
     'a' -> PutR;   
     'd' -> a; 
     (screen[],(a,'d'-2+b,'f','g','h'),'i') -> foo;
 
     ('j','k','l','m','n') -> bar;
       
     'o'-'a'+1 -> a; 
     a -> R;
     'a' -> PutR; 
  
     'p'-'a'+1 -> R;
     'a' -> PutR; 
     
     a + 2 -> R; 'a' -> PutR;
     'r' -> bar; 
     's'-> ch;
     ch -> bar;
     (if safeMode and isSun4s then 
         't' -> put;
      else  
         (* fails with unconditional GC *)
         1.1 -> F; PutF;          (* 't' *)
     if); 
     2.2 -> X;  
     X -> F; PutF;                (* 'u' *)
     (if safeMode and isSun4s then 
         'v' -> put;
      else 
         (* fails with unconditional GC *)
         x + 1.1 -> F; PutF;      (* 'v' *) 
     if); 
     (if safeMode and isINTEL then 
         'wx' -> puttext; 
      else
         (* Fails with unconditional GC on intel *)
         (# x: @char 
         do  (4.4,5.5) -> F;  
         #);
         PutF;     (* To be fixed 'wx' *) 
     if);
     77 -> a;  
     (55,66,a) -> F; PutF;             (* To be fixed 'yz' *) 
     (8.8,9.9) -> R; '1'-7 -> PutR;    (* OK *)
     (screen[],'3','4') -> foo; 
     tstChar2Rep;
     '9'->fill;    
     'List2rep2'->newL; 
     tstMore;
     tstWithObj; 
     
     'k' -> fill;
     'List2rep3'->newL;
     (if false(*isByteCodeMode*) then
         '#########################'->puttext
      else
         tstList2RefRep;
     if);
     'z' -> fill;       
  #)


  


 
