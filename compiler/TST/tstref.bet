ORIGIN 'tstenv';   
INCLUDE 'tstlib';
-----LIB:attributes---
tstRef:
  (# foo: 
       (# x,y: @char
       enter x
       do y->put; x->put; INNER
       #);
     bar: foo(# z: @char do z->put; inner #);

     X: @foo; (* p.g.a. checker-fejl skal der vaere en statisk instans*)
     Y: @bar; (* af alle ptn der genereres dynamisk!! *)     
     R1,R2: ^foo; 
     R3: ^bar; R4: ^foo;
     QQ: (# do NONE->R3[] exit R3[] #);
     tstQua:
       (# ch: @char; V:< object; R: ^foo; S: ^bar; T: ^V  
       enter ch
       do &bar[]->R[]; 
          R[]->S[];  
          ch->R.x;
          &V[] -> T[]; 
          inner
       #);  
     tstQua2: tstQua
       (# V:: bar  
       do R.x->T.y; T.y->put
       #);
     noNone:    
       (# s: ^text;
          foo: (# q: ^text enter q[] #);
          bar: (# t: ^text exit t[] #);
       do bar -> s[] -> foo; (* an error once gave ref.is.none here *)
       #); 
     tstNeEq:
       (# q1,q2: ^text;
          b: @boolean
       do none -> q1[];
          &text[] -> q2[];
          (if q1[] <> none then '!'->put else 'a' -> put if);
          (if true
           // q1[] <> none then
              '!'->put
           // q2[] <> none then
              'b'->put
          if);
          q1[] <> none -> b;
          (if b then '!' -> put else 'c'->put if);
          q2[] <> none -> b;
          (if b then 'd' -> put else '!'->put if);
          q1[] = none -> b;
          (if b then 'e' -> put else '!'->put if);
          q2[] = none -> b;
          (if b then '!' -> put else 'f'->put if);
       #);

  do 'a'->X.y; 'b'->X;
     &foo[]->R1[]; 'c'->R1.y; 'd'->R1;
     R1[]->R2[]; 'e'->R2.y; 'f'->R2; 
     &bar[]->R3[]; 'g'->R3.y; 'i'->R3.z; 'h'->R3;      
     R3[]->R1[]; 'j'->R1.y; 'l'->R3.z; 'k'->R1;
     Y[]->R2[]; 'm'->R2.y; 'o'->Y.z; 'n'->R2;
   
     R1[]->R2[]; (R1[]=R2[],true ,'p')->chkBool;
     X[] ->R4[]; (R1[]=R4[],false,'q')->chkBool;
     (X[] =X[] ,true, 'r')->chkBool;
     (* (X[] =Y[] ,false,'s')->chkBool; compile-time error*)
     (Y[] = Y[],true,'s')->chkBool;
     X[]->R1[];  (X[] =R1[],true ,'t')->chkBool; 
     Y[]->R1[];  (X[] =R1[],false,'u')->chkBool;
  
     R1[]->R2[]; (if R1[]//R2[] then 'v'->put else error if);
     X[]->R2[];  (if R1[]//R2[] then error else 'w'->put if); 
     (if X[]//X[] then 'x'->put else error if);
         (*  (if X[]//Y[] then error else 'y'->put if); compile-time error *)
     (if Y[]//R2[] then error else 'y'->put if);
     X[]->R1[];  (if X[]//R1[] then 'z'->put else error if);
     (if R1[]//X[] then '0'->put else error if);

     NONE->R1[]; (R1[]=NONE,true,'1')->chkBool; (* etc *)
     (X[]=NONE,false,'2')->chkBool; (* etc *)
     (*!!!! X[]=NONE is always true; this is pure luck
      * since cmp would otherwise not work *)
     (if R1[] // NONE then '3'->put else error if);
     (if NONE // R1[] then '4'->put else error if);
     (if X[] // NONE then error else '5'->put if);
     (if NONE // X[] then error else '6'->put if);  
     (if NONE // NONE then '7'->put else error if); 
     (if (QQ=NONE)//true then '8'->put else error if);
     (if false (*isBytecodeMode*) then
         '#' -> put
      else
         '9'->tstQua2;
     if);
     noNone;
     'tstref2'->newL;
     tstNeEq;
     'g'->fill;
  #)





 


  


