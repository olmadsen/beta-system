ORIGIN 'tstenv';            
INCLUDE 'tstlib';   
BUILD  ppcmac	':$$:ctstcproc.obj' 'ctstcproc.c'  'mrc -D mac -w 35 -o $0 $1'
       nti      '$$/ctstcproc.obj' 'ctstcproc.c'  'betacc $0 $1'
       default	'$$/ctstcproc.o'   'ctstcproc.c'  '\$CC -c -o $0 $1'
-----LIB:attributes-----
tstCProc:   
  (#
     (* Should test the External interface from Beta.   
      * This fragment is dependent on ctstcproc.c, where all c functions
      * are defined.  
      *)
     ident: External(# r,s:[1]@char enter r  exit s #);      
     Q,P: [1]@char;
     
     giveArg:  External(# a,b,c,d:@char enter (a,b,c) exit d #);
     giveMe1Argument: giveArg(##);
     giveMe2Argument: giveArg(##);
     giveMe3Argument: giveArg(##);    
     doCallBack: External 
       (# F: ##foo; ch: @ char 
       enter F## do 'doCallBack'->callC exit ch 
       #);
     foo: External   
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *)
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer
       enter(a,T,x3,x4,x5,x6,x7,x8) 
       do cExternalEntry;
	  a->put; T->puttext; x8->put;
          'p'->b
       exit b
       #);
     doCallBack2: External 
       (# F: ##external; ch: @ char 
       enter F## do callC; exit ch     
       #); 
     fooSuper: External    
       (#
       do cExternalEntry;     
          inner
       #);
     fooAsSub: fooSuper
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *)
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer
       enter(a,T,x3,x4,x5,x6,x7,x8) 
       do a->put; T->puttext; x8->put;  112233->b;  
       exit b 
       #);  
     sumMany: External
       (# a,b,c,d,e,f,g,h,i,j,k: @integer  
       enter(a,b,c,d,e,f,g,h,i,j)
       exit k
       #);
     exitk: 
       (# ch: @char 
       do (* to provoke an AlloI to test unconditional 
           * GC during evaluation of exitK in
           *      ('!','!',exitk) -> giveMe3Argument -> put;
           * This is needed to test that CalllReg is properly
           * handled on MIPS and PPC
           *)
          (# dummy: @char
          do 'k'->ch 
          #)
       exit ch 
       #);
     tstData:  
       (# Xdata: data(# w: @integer; ch: @char; q: @char; y: @integer #);
          Ydata: Xdata(# a,b: @char; d: @integer #);
          (* the following pattern is to ensure that the checker will accept
           * references to the pattern being checked 
           *)
          Zdata: Ydata(# x: ^Xdata; y: ^Ydata; z: ^Zdata #);
          ZZdata: data(# x: ^Xdata; y: ^Ydata; z: ^Zdata #);
          R: ^Zdata; 
          a: @ COM (# X: @Xdata;#);
          
          S: ^Ydata; 
          XdataToYdata: external(# R: ^Xdata; S: ^Ydata enter R[] exit S[] #);
          dataByValue: external(# S: @Xdata enter S #) ;
          myCom: COM (# #);
          dataWithCom: data(# S: ^myCom; R: @data (# #);  #);
       do 99->a.X.w; 'a'->a.X.ch; 'q'->a.X.q; 111->a.X.y;
          (*Xdata -> dataByValue; not yet legal *)  
          (* &Zdata[] -> R[]; - cannot link*)  
          a.X[]->XdataToYdata->S[];
          (* 'From beta: \t'->puttext;
           'w:'->puttext; S.w->putint;
           ', ch:'->puttext; S.ch->put; 
           ', q:'->puttext; S.q->put;
           ', y:'->puttext; S.y->putint; 
           ', a:'->puttext; S.a->put;
           ', b:'->puttext; S.b->put;
           ', d:'->puttext; S.d->putint; newline;  
           *)
          (S.w,98,'t')->chk; 
          (S.ch,'#','u')->chk; (S.q,'$','v')->chk;
          (S.y,110,'w')->chk; (S.a,'+','x')->chk; (S.b,'*','y')->chk;
          (S.d,444,'z')->chk;
       #); 
     tstCstruct:   
       (# Xdata: cstruct
            (# byteSize::(#do 12->value; #);
               w: long(# pos::(#do 0->value#)#); 
               ch: byte(# pos::(#do 4->value#)#);
               q: @byte(# pos::(#do 5->value#)#)
            #);
          X: @Xdata; Y: ^Xdata; R: @text;
          XdataToText: external(# R: ^Xdata; S: [1]@char enter R[] exit S #);
          RR:[1]@char
       do 99->X.w; 'a'->X.ch;   
          X[]->XdataToText->putText;
          &Xdata[]->Y[];
          99->Y.w; 'a'->Y.ch;
          Y[]->XdataToText->R; 
          (for i: 3 repeat R.T[i]+3->put for); 
       #);
     QQQ:
       (# a,b,d: @integer; C: ##external
       enter(a,b,c##,d)  
       do c##->doCallBack->put;  
       #); 
     tstSlice:
       (* b-g *)
       (# printSub: external(# s: [1] @char enter s #);  
          fdd: external
            (# a: @integer; T: [1] @ char
            enter(a,T)
            exit a
            #); 
          TT: @newtext;  
          newText: (# T: [12] @ char; top: @integer enter T exit T[1:top] #);
          ch: @char; inx: @integer
       do '!?!?!bcdef#¤%&' ->Q;
          Q[6:10] -> printSub;
          111->inx;  
          'qwerty!?' ->TT; 
          6->TT.top;
          (inx,TT) -> fdd -> ch;
           ch->put;  
       #);
     
     callwithreals:
       (#
          tst3reals: external
            (* Tests if the entered 3 reals are consecutive, i.e.
             * 1.0, 2.0, 3.0.
             *)
            (# r1, r2, r3: @real;
               match: @integer;
            enter (r1, r2, r3)
            exit match      
            #);
       do (if ((1.0, 2.0, 3.0) -> tst3reals) = 1 then
              'r'->put; 
           else    
              '!'->put;
          if);
       #);
     tstvariablearguments:
       (#
          tstvarargs: external
            (* Tests if the entered numreals reals are consecutive, i.e.
             * 1.0, 2.0, 3.0, ...
             * May be called with an arbitrary number of reals.
             * Here we call it with 3.
             *)
            (# numreals: @integer;
               r1, r2, r3: @real;
               match: @integer;
            enter (numreals, r1, r2, r3)
            exit match
            #);
       do (if ((3, 1.0, 2.0, 3.0) -> tstvarargs) = 1 then
              's'->put;
           else
              '!'->put;
          if);
       #);
     
     tstIntRealComb:
       (# tstreal1: external
            (# n1: @integer; d1: @real enter(n1,d1) exit n1 #);
          tstreal2: external 
            (# n1: @integer; d1,d2: @real enter(n1,d1,d2) exit n1 #);
          tstreal3: external
            (# n1: @integer; d1,d2,d3: @real enter(n1,d1,d2,d3) exit n1 #);
          tstreal4: external
            (# n1,n2: @integer; d1,d2: @real enter(n1,n2,d1,d2) exit n1 #);
          tstreal5: external
            (# n1,n2,n3: @integer; d1: @real enter(n1,n2,n3,d1) exit n1 #);
          tstreal6: external (# d1: @real; n1: @integer enter(d1,n1) exit n1 #);
          tstreal7: external 
            (# d1,d2: @real; n1: @integer enter(d1,d2,n1) exit n1 #);
          tstreal8: external 
            (# d1: @real; n1,n2: @integer enter(d1,n1,n2) exit n1 #);
          tstreal9: external 
            (# d1: @real; n1,n2,n3: @integer enter(d1,n1,n2,n3) exit n1 #);
          tstreal10: external 
            (# d1,d2: @real; n1: @integer enter(d1,n1,d2) exit n1 #);
          tstreal11: external
            (# n1: @integer; d1,d2,d3,d4: @real enter(n1,d1,d2,d3,d4) exit n1 #);
          tstreal12: external
            (# d1,d2,d3,d4: @real; n: @int32 enter(d1,d2,d3,d4) exit n1 #); 
          n1,n2: @integer; d1,d2,d3,d4: @real
       do (if ((10,11.0) -> tstreal1) = 21 then
              't' ->put
           else '!' -> put
          if);    
          (if ((10,11.0,12.0) -> tstreal2) = 33 then
              'u' ->put
           else '!' -> put
          if);
          (if ((10,11.0,12.0,13.0) -> tstreal3) = 46 then
              'v' ->put
           else '!' -> put
          if);
          (if ((10,11,12.0,13.0) -> tstreal4) = 46 then
              'w' ->put
           else '!' -> put
          if);
          (if ((10,11,12,13.0) -> tstreal5) = 46 then 
              'x' ->put   
           else '!' -> put
          if);
          (if ((20.0,21) -> tstreal6) = 41 then
              'y' ->put   
           else '!' -> put
          if);
          (if ((22.0,23.0,24) -> tstreal7) = 69 then
              'z' ->put   
           else '!' -> put
          if);
          (if ((25.0,26,27) -> tstreal8) = 78 then
              '0' ->put   
           else '!' -> put
          if);
          (if ((28.0,29,30,31) -> tstreal9) = 118 then
              '1' ->put   
           else '!' -> put
          if);
          (if ((31.0,32,33.0) -> tstreal10) = 96 then
              '2' ->put   
           else '!' -> put
          if);
          10 -> n1; 11.1 -> d1; 11.9 -> d2;
          (if ((n1,d1,d2) -> tstreal2) = 33 then
              '3' -> put
           else
              '!' -> put
          if);
          10.0 -> d1; 11 -> n1; 13 -> n2;
          (if ((d1,n1,n2) -> tstreal8) = 34 then
              '4' -> put
           else
              '!' -> put
          if);
          30.2 -> d1; 50 -> n1; 19.8 -> d2;
          (if ((d1,n1,d2) -> tstreal10) = 100 then 
              '5' -> put
           else 
              '!' -> put
          if);  
          (if ((10,11.1,11.9,5.3,4.7) -> tstreal11) = 43 then  
              '6' -> put
           else
              '!' -> put
          if);
          (if ((1.1,2.2,3.3,4.4) -> tstreal12) = 11 then
              '7' -> put 
           else 
              '!' -> put
          if)
       #);
     a,b,d: @integer;
     radd: external(# x,y: @real enter (x,y) exit x #); 
     intFloat: external(# n: @integer; X: @real enter(n,X) exit n #); 
     floatInt: external(# n: @integer; X: @real enter(X,n) exit n #); 
     intFloatArgs: 
       (* mixture of int and real parameters is a mess 
        * on RISCs. More cases should be added here
        *)  
       (# X: @real
       do (if (1,2.0) -> intFloat // 3 then 'n'->put if);
          2.0 -> X;
          (if (2,X) -> intFloat // 4 then 'o' -> put if);
          (if (3.0,3) -> floatInt // 6 then 'p'->put if);
          4.0 -> X;
          (if (X,4) -> floatInt // 8 then 'q' -> put if);
       #);
     copyCh: external (# ch: @char enter ch exit ch #);
     flush_stdout: external (#  #);
     multipleAsg:
       (# Y: ^Q;
          Q: (# x,y,a: @char #);
          X: @ (# a,b,c: @char #)
       do &Q[] -> Y[];
          '8'-> Y.a; 
          (# dum: @char do Y.a -> X.b -> copyCh -> X.c #);
          X.c -> put;
       #);
     arg9:
       (* Used to fail on sparc: Problem is that there are 5 arguments 
        * in registers and two on stack when copyCh is called. 
        *)
       (# printf9: external
            (# fmt: [0]@char;
               o1, o2, o3, o4, o5, o6, o7, o8: @integer
            enter (fmt, o1, o2, o3, o4, o5, o6, o7, o8)
            do 'printf' -> callC;
            #);
       do ('%c%c%c%c%c%c%c%c', 'a','b','c','d','e','f','g','h'->copyCh)
            -> printf9;
          flush_stdout;
       #);
     primToX:
       (# printf9: external
            (# fmt: [0]@char;  
               o1, o2, o3, o4, o5, o6, o7, o8: [1]@char;
            enter (fmt, o1, o2, o3, o4, o5, o6, o7, o8)
            do 'printf' -> callC;
            #);
          T1,T2,T3,T4,T5,T6,T7,T8: [1]@char  
       do 'i' -> T1;
          'j' -> T2;
          'k' -> T3;
          'l' -> T4;
          'm' -> T5;
          'n' -> T6;
          'o' -> T7;
          'p' -> T8;
          ('%s%s%s%s%s%s%s%s', T1,T2,T3,T4,T5,T6,T7,T8)     -> printf9;
          flush_stdout;
       #);
     ext696:
       (# ident: External(# in: @Boolean; out:@Integer enter in do exit out #);
          binary:< (# value: @Boolean enter value do INNER exit value #);
          entry: @ (# private: @ (# path: ^Text; #)#);
       do (# doopen:
               (# name: ^Text;
                  mode: @Integer;
                  perm: @Boolean;
               enter (name[], mode, perm)
               do name->putText;
               #);
          do 's'->entry.private.path[];
             (entry.private.path[],binary->ident,false) -> doOpen;
             't'->put;
          #);
       #);
     BigCprocTextReturn:
       (# r: [300]@char;
          result: [0]@char;
       do (* Return a big text from C. Involves having CopyCT
           * allocate the resulting object directly in AOA.
           *)
          (for i:300 repeat
               'a' + (i mod 28) -> r[i];
          for);
          r -> (* CpkVT *) ident -> (* CopyCT *) result;
          (for i:300 repeat
               (if result[i]<>('a' + (i mod 28)) then
                   '&' -> put;
                   i ->putint;
                   '&' -> put;
               if);
          for);
          (if result.range=300 then
              result['h' - 'a' ]  (* 'h' *) -> put;
           else
              '!' -> put;
          if);
       #);
     dataRef:
       (* ensure that adr register pointing to data object
        * is proprly cleared
        *)
       (# myData: data(# x,y: @int32; c: @char #);
          foo:
            (# a: @integer; s: ^ myData
            enter(a,S[]) 
            do (if a = S.x then S.c -> put
                else '!'->put
               if)
            #); 
          q: @ COM(# Q: @myData;   #);
          W: ^myData 
       do 12 -> q.Q.x; 'u' -> q.Q.c;
          (12,q.Q[])-> foo ;
          q.Q[] -> W[];
          21 -> W.x; 'v'->W.c;
          (21,W[]) -> foo
       #) 
  do  
     (* Test char repetition as enter/exit parameters to Externals.
      * Validating PackVarTextToC (on enter) and CopyCtext (on exit).
      * Outputs 'abcdefg'
      *)  
     'abc' -> Q;
     Q (* CpkVT *) -> ident -> (* CopyCT *) P;
     (if Q.range=P.range then 'a' -> put else '!' -> put if);
     (for i:P.range repeat  
          (if Q[i]=P[i] then 'a'+i -> put else '!' -> put if)
     for);  
     Q[2:3] (* CpkSVT *) -> ident -> (* CopyCT *) P;
     (if P.range=2 then 'e' -> put else '!' -> put if);
     (for i:P.range repeat  
          (if Q[1+i]=P[i] then 'e'+i -> put else '!' -> put if)
     for);  
     
     (* h *)
     BigCprocTextReturn;
     
     (* Test the order of the parameters. *)
     ('i','!','!') -> giveMe1Argument -> put;
     ('!','j','!') -> &giveMe2Argument -> put; 
     ('!','!',exitk) -> giveMe3Argument -> put; 

     (a,b,foo##,d)->QQQ;
     (*call back from C of ('l','mn','!','!','!','!','!','o')->foo;*)
     (if (1,2,3,4,5,6,7,8,9,10)->sumMany//55 then 'q'->put  
      else '!'->put    
     if);  

     (('a','!','!') -> giveMe1Argument,('!','r','!') -> giveMe2Argument,
     ('!','!','g') -> giveMe3Argument)->giveMe2Argument->put;
       
     ('!','!','s') -> giveMe3Argument -> put;
     tstData;               (* 't-z' *)
     tstCstruct;
     fooAsSub##->doCallBack2->a; 
     newl; 
     (if a <> 112233 then '!'->put else 'a'->put if) ;
     tstSlice;  (* b-g *)
     25->a; 75->b;
     (if ((a,b) -> radd) = 100 then 'h'->put else '!'->put if);  
     (if ((-25,125) -> radd) = 100 then 'i'->put else '!'->put if);
     'j'->put;   
     ('!',exitk,'?') -> giveMe2Argument -> put;  
     (1,2,3,4
     ,(100,200,300,400,500,600,700,800,900,1000)->sumMany->b
     ,6,7
     ,(10,20,30,40,50,60,70,80,90,100)->sumMany->d,9,10) 
       -> sumMany 
       -> a;
     (* b = 5500, d = 550, a = 6092 *)
     (if a = 6092 then 'l' -> put else '!' -> put if);
     (# xx: cStruct(# bytesize::(#do 4->value #)
                   enter R[1]
                   exit R[1]
                   #);
        id:  external(# X,V: @integer enter X exit V #);
        xxx: @xx; a: @integer
     do 1020 -> xxx.R[1]; xxx -> id -> a;
        (if a = 1020 then 'm' -> put else '!' -> put if)
     #);
     intFloatArgs;
     callwithreals;
     tstvariablearguments;
     tstIntRealComb;;
     multipleAsg;
     '9'->fill; 
     newl;
     arg9;
     primToX;
     'qr' -> ident -> ident -> puttext;
     ext696;
     dataRef;
    'w' -> fill;
  #)



 
