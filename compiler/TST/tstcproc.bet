ORIGIN 'tstenv';  
INCLUDE 'tstlib';       
BUILD  hpux9mc	'$$/ctstcproc.o'   'ctstcproc.c'  'gcc-2.5.8 -c -o $0 $1'
       mac	'$$/ctstcproc.o'   'ctstcproc.c'  'gcc -O6 -c -o $0 $1'
       nti      '$$/ctstcproc.obj' 'ctstcproc.c'  'cl -Fo$0 $1'
       sgi      '$$/ctstcproc.obj' 'ctstcproc.c'  '\$CC -c -o $0 $1'
       default	'$$/ctstcproc.o'   'ctstcproc.c'  'gcc -c -o $0 $1'
-----LIB:attributes-----
tstCProc:   
  (#
     (* Should test the External interface from Beta.   
      * This fragment is dependent on ctstcproc.c, where all c functions
      * are defined.
      *)
     ident: External(# r,s:[1]@char enter r  exit s #);      
     Q,P: [1]@char;
     
     giveArg:  External(# a,b,c,d:@char enter (a,b,c) exit d #);
     giveMe1Argument: giveArg(##);
     giveMe2Argument: giveArg(##);
     giveMe3Argument: giveArg(##);    
     doCallBack: External
       (# F: ##foo; ch: @ char 
       enter F## do 'doCallBack'->callC exit ch 
       #);
     foo: External
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *)
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer
       enter(a,T,x3,x4,x5,x6,x7,x8)
       do cExternalEntry;
	  a->put; T->puttext; x8->put;
          'p'->b 
       exit b
       #);
     doCallBack2: External
       (# F: ##external; ch: @ char 
       enter F## do callC exit ch 
       #);
     fooSuper: External
       (#
       do cExternalEntry;
          inner
       #);
     fooAsSub: fooSuper
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *)
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer
       enter(a,T,x3,x4,x5,x6,x7,x8)
       do a->put; T->puttext; x8->put;  112233->b;
       exit b
       #);  
     sumMany: External
       (# a,b,c,d,e,f,g,h,i,j,k: @integer  
       enter(a,b,c,d,e,f,g,h,i,j)
       exit k
       #);
     exitk: (# ch: @char do 'k'->ch exit ch #);
     tstData:
       (# Xdata: data(# w: @integer; ch: @char; q: @char; y: @integer #);
          Ydata: Xdata(# a,b: @char; d: @integer #);
          (* the following pattern is to ensure that the checker will accept
           * references to the pattern being checked 
           *)
          Zdata: Ydata(# x: ^Xdata; y: ^Ydata; z: ^Zdata #);
          X: @Xdata; S: ^Ydata;
          XdataToYdata: external(# R: ^Xdata; S: ^Ydata enter R[] exit S[] #)
       do 99->X.w; 'a'->X.ch; 'q'->X.q; 111->X.y;
          X[]->XdataToYdata->S[];
          (* 'From beta: \t'->puttext;
           'w:'->puttext; S.w->putint;
           ', ch:'->puttext; S.ch->put;
           ', q:'->puttext; S.q->put;
           ', y:'->puttext; S.y->putint;
           ', a:'->puttext; S.a->put;
           ', b:'->puttext; S.b->put;
           ', d:'->puttext; S.d->putint; newline;  
           *)
          (S.w,98,'t')->chk; (S.ch,'#','u')->chk; (S.q,'$','v')->chk;
          (S.y,110,'w')->chk; (S.a,'+','x')->chk; (S.b,'*','y')->chk;
          (S.d,444,'z')->chk;
       #); 
     tstCstruct:   
       (# Xdata: cstruct
            (# byteSize::(#do 12->value; #);
               w: long(# pos::(#do 0->value#)#); 
               ch: byte(# pos::(#do 4->value#)#);
               q: @byte(# pos::(#do 5->value#)#)
            #);
          X: @Xdata; Y: ^Xdata; R: @text;
          XdataToText: external(# R: ^Xdata; S: [1]@char enter R[] exit S #)
       do 99->X.w; 'a'->X.ch;   
          X[]->XdataToText->putText;
          &Xdata[]->Y[];
          99->Y.w; 'a'->Y.ch;
          Y[]->XdataToText->R; 
          (for i: 3 repeat R.T[i]+3->put for)
       #);
     QQQ:
       (# a,b,d: @integer; C: ##external
       enter(a,b,c##,d) 
       do c##->doCallBack->put;  
       #);
     tstSlice:
       (# printSub: external(# s: [1] @char enter s #);  
          fdd: external
            (# a: @integer; T: [1] @ char
            enter(a,T)
            exit a
            #);
          TT: @newtext;
          newText: (# T: [12] @ char; top: @integer enter T exit T[1:top] #);
          ch: @char; inx: @integer
       do '!?!?!bcdef#¤%&' ->Q;
          Q[6:10] -> printSub; 
          111->inx;  'qwerty!?' ->TT; 6->TT.top;
          (inx,TT) -> fdd -> ch;
          ch->put
       #);
  
     a,b,d: @integer;
     radd: external(# x,y: @real enter (x,y) exit x #);
     intFloat: external(# n: @integer; X: @real enter(n,X) exit n #);
     floatInt: external(# n: @integer; X: @real enter(X,n) exit n #);
     intFloatArgs: 
       (* mixture of int and real parameters is a mess
        * on RISCs. More cases should be added here
        *)
       (# X: @real
       do (if (1,2.0) -> intFloat // 3 then 'n'->put if);
          2.0 -> X;
          (if (2,X) -> intFloat // 4 then 'o' -> put if);
          (if (3.0,3) -> floatInt // 6 then 'p'->put if);
          4.0 -> X;
          (if (X,4) -> floatInt // 8 then 'q' -> put if);
       #)
  do 
     (* Test char repetition as enter/exit parameters to Externals.
      * Validating PackVarTextToC (on enter) and CopyCtext (on exit)
      *)  
     'abcdefg' -> Q;
     Q -> ident -> P;
     (if Q.range//P.range then 'a' -> put else '!' -> put if);
     (for i:P.range repeat  
          (if Q[i]//P[i] then 'a'+i -> put else '!' -> put if)
     for);
     (* Test the order of the parameters. *)
     ('i','!','!') -> giveMe1Argument -> put;
     ('!','j','!') -> &giveMe2Argument -> put; 
     ('!','!',exitk) -> giveMe3Argument -> put; 
     (if false then '**CallBack**'->puttext
      else
         (* foo##->doCallBack->put;  *)
         (a,b,foo##,d)->QQQ;
         (*call back from C of ('l','mn','!','!','!','!','!','o')->foo;*)
         (if (1,2,3,4,5,6,7,8,9,10)->sumMany//55 then 'q'->put  
          else '!'->put    
         if);  
     if);   
     (('a','!','!') -> giveMe1Argument,('!','r','!') -> giveMe2Argument,
     ('!','!','g') -> giveMe3Argument)->giveMe2Argument->put;
     
     ('!','!','s') -> giveMe3Argument -> put;
     tstData; 
     tstCstruct;
     (if false then '**CallBack**'->puttext
      else 
         fooAsSub##->doCallBack2->a;
     if);
     newl;
     (if a <> 112233 then '!'->put else 'a'->put if) ;
     tstSlice;
     25->a; 75->b;
     (if ((a,b) -> radd) = 100 then 'h'->put else '!'->put if);  
     (if ((-25,125) -> radd) = 100 then 'i'->put else '!'->put if);
     'j'->put;   
     ('!',exitk,'?') -> giveMe2Argument -> put;  
     (1,2,3,4
     ,(100,200,300,400,500,600,700,800,900,1000)->sumMany->b
     ,6,7
     ,(10,20,30,40,50,60,70,80,90,100)->sumMany->d,9,10) 
       -> sumMany 
       -> a;
     (* b = 5500, d = 550, a = 6092 *)
     (if a = 6092 then 'l' -> put else '!' -> put if);
     (# xx: cStruct(# bytesize::(#do 4->value #)
                   enter R[1]
                   exit R[1]
                   #);
        id:  external(# X,V: @integer enter X exit V #);
        xxx: @xx; a: @integer
     do 1020 -> xxx.R[1]; xxx -> id -> a;
        (if a = 1020 then 'm' -> put else '!' -> put if)
     #);
     intFloatArgs;
     'r'->fill;  
  #)

     
        
