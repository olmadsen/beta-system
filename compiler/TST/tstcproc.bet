ORIGIN 'tstenv';     
INCLUDE 'tstlib';    
BUILD  ppcmac	':$$:ctstcproc.obj' 'ctstcproc.c' 'mrc -D mac -w 35 -o $0 $1'
       nti      '$$/ctstcproc.obj' 'ctstcproc.c'  'betacc $0 $1'
       default	'$$/ctstcproc.o'   'ctstcproc.c'  '\$CC -g -c -o $0 $1'
-----LIB:attributes-----
tstCProc:   
  (#
     (* Should test the External interface from Beta.   
      * This fragment is dependent on ctstcproc.c, where all c functions
      * are defined.  
      *)  
     ident: External(# r,s:[1]@char enter r  exit s #);      
     Q,P: [1]@char;
      
     giveArg:  External(# a,b,c,d:@char enter (a,b,c) exit d #);
     giveMe1Argument: giveArg(##); 
     giveMe2Argument: giveArg(##);
     giveMe3Argument: giveArg(##);   
     doCallBack: External  
       (# F: ##foo; ch: @ char   
       enter F## do 'doCallBack'->callC exit ch 
       #);
     foo: External   
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *) 
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer 
       enter(a,T,x3,x4,x5,x6,x7,x8) 
       do cExternalEntry;  
	  a->put; T->puttext; x8->put;
          'p'->b;
       exit b 
       #); 
     doCallBack2: External   
       (# F: ##external; ch: @ char  
       enter F## do callC; exit ch      
       #);  
     fooSuper: External    
       (#
       do cExternalEntry;      
          inner 
       #);
     fooAsSub: fooSuper 
       (* Note that a :@ char does NOT work. The compiler generates mov.b
        * to pop a from C stack
        *)
       (# a,b:@ integer; T: [1] @ char; 
          x3,x4,x5,x6,x7,x8: @integer
       enter(a,T,x3,x4,x5,x6,x7,x8) 
       do a->put; T->puttext; x8->put;  112233->b;  
       exit b 
       #);   
     sumMany: External
       (# a,b,c,d,e,f,g,h,i,j,k: @integer   
       enter(a,b,c,d,e,f,g,h,i,j)
       exit k
       #);
     exitk: 
       (# ch: @char 
       do (* to provoke an AlloI to test unconditional 
           * GC during evaluation of exitK in
           *      ('!','!',exitk) -> giveMe3Argument -> put;
           * This is needed to test that CalllReg is properly
           * handled on MIPS and PPC
           *)
          (# dummy: @char
          do 'k'->ch 
          #)
       exit ch 
       #);
     tstData:  
       (# Xdata: data(# w: @integer; ch: @char; q: @char; y: @integer #);
          Ydata: Xdata(# a,b: @char; d: @integer #);
          (* the following pattern is to ensure that the checker will accept
           * references to the pattern being checked 
           *)
          Zdata: Ydata(# x: ^Xdata; y: ^Ydata; z: ^Zdata #);
          ZZdata: data(# x: ^Xdata; y: ^Ydata; z: ^Zdata #);
          R: ^Zdata; 
          a: @ COM (# X: @Xdata;#);
           
          S: ^Ydata; 
          XdataToYdata: external(# R: ^Xdata; S: ^Ydata enter R[] exit S[] #);
          dataByValue: external(# S: @Xdata enter S #) ;
          myCom: COM (# #);
          dataWithCom: data(# S: ^myCom; R: @data (# #);  #);
       do 99->a.X.w; 
          'a'->a.X.ch;
          'q'->a.X.q;
          111->a.X.y;
          (*Xdata -> dataByValue; not yet legal *)  
          (* &Zdata[] -> R[]; - cannot link*)  
          a.X[]->XdataToYdata->S[];  
          (* 'From beta: \t'->puttext;
           'w:'->puttext; S.w->putint;
           ', ch:'->puttext; S.ch->put; 
           ', q:'->puttext; S.q->put;
           ', y:'->puttext; S.y->putint; 
           ', a:'->puttext; S.a->put;
           ', b:'->puttext; S.b->put;
           ', d:'->puttext; S.d->putint; newline;  
           *) 
          (S.w,98,'t')->chk; 
          (S.ch,'#','u')->chk; (S.q,'$','v')->chk;
          (S.y,110,'w')->chk; (S.a,'+','x')->chk; (S.b,'*','y')->chk;
          (S.d,444,'z')->chk;
       #); 
     tstCstruct:   
       (# Xdata: cstruct
            (# byteSize::(#do 12->value; #); 
               w: long(# pos::(#do 0->value#)#); 
               ch: byte(# pos::(#do 4->value#)#); 
               q: @byte(# pos::(#do 5->value#)#)
            #);
          X: @Xdata; Y: ^Xdata; R: @text;
          XdataToText: external(# R: ^Xdata; S: [1]@char enter R[] exit S #);
          RR:[1]@char
       do 99->X.w; 
          'a'->X.ch;
          X[]->XdataToText->putText; 
          &Xdata[]->Y[];
          99->Y.w; 'a'->Y.ch;
          Y[]->XdataToText->R;  
          (for i: 3 repeat R.T[i]+3->put for); 
       #);
     QQQ:  
       (# a,b,d: @integer; C: ##external
       enter(a,b,c##,d)  
       do c##->doCallBack->put;  
       #); 
     tstSlice:
       (* b-g *)
       (# printSub: external(# s: [1] @char enter s #);   
          fdd: external
            (# a: @integer; T: [1] @ char
            enter(a,T)
            exit a 
            #); 
          TT: @newtext;  
          newText: (# T: [12] @ char; top: @integer enter T exit T[1:top] #);
          ch: @char; inx: @integer
       do '!?!?!bcdef#¤%&' ->Q;
          Q[6:10] -> printSub;
          111->inx;  
          'qwerty!?' ->TT; 
          6->TT.top;
          (inx,TT) -> fdd -> ch;
          ch->put;  
       #);
     
     callwithreals:
       (#
          tst3reals: external
            (* Tests if the entered 3 reals are consecutive, i.e.
             * 1.0, 2.0, 3.0.
             *)
            (# r1, r2, r3: @real;
               match: @integer;
            enter (r1, r2, r3)
            exit match      
            #);
       do (if ((1.0, 2.0, 3.0) -> tst3reals) = 1 then
              'r'->put; 
           else    
              error;
          if);
       #);
     tstvariablearguments:
       (#
          tstvarargs: external
            (* Tests if the entered numreals reals are consecutive, i.e.
             * 1.0, 2.0, 3.0, ...
             * May be called with an arbitrary number of reals.
             * Here we call it with 3.
             *)
            (# numreals: @integer;
               r1, r2, r3: @real;
               match: @integer;
            enter (numreals, r1, r2, r3)
            exit match
            #);
       do (if ((3, 1.0, 2.0, 3.0) -> tstvarargs) = 1 then
              's'->put;
           else
              error;
          if);
       #);
     
     tstIntRealComb:
       (# tstreal1: external
            (# n1: @integer; d1: @real enter(n1,d1) exit n1 #);
          tstreal2: external 
            (# n1: @integer; d1,d2: @real enter(n1,d1,d2) exit n1 #);
          tstreal3: external
            (# n1: @integer; d1,d2,d3: @real enter(n1,d1,d2,d3) exit n1 #);
          tstreal4: external
            (# n1,n2: @integer; d1,d2: @real enter(n1,n2,d1,d2) exit n1 #);
          tstreal5: external
            (# n1,n2,n3: @integer; d1: @real enter(n1,n2,n3,d1) exit n1 #);
          tstreal6: external (# d1: @real; n1: @integer enter(d1,n1) exit n1 #);
          tstreal7: external 
            (# d1,d2: @real; n1: @integer enter(d1,d2,n1) exit n1 #);
          tstreal8: external 
            (# d1: @real; n1,n2: @integer enter(d1,n1,n2) exit n1 #);
          tstreal9: external 
            (# d1: @real; n1,n2,n3: @integer enter(d1,n1,n2,n3) exit n1 #);
          tstreal10: external 
            (# d1,d2: @real; n1: @integer enter(d1,n1,d2) exit n1 #);
          tstreal11: external
            (# n1: @integer; d1,d2,d3,d4: @real enter(n1,d1,d2,d3,d4) exit n1 #);
          tstreal12: external
            (# d1,d2,d3,d4: @real; n: @int32 enter(d1,d2,d3,d4) exit n1 #); 
          n1,n2: @integer; d1,d2,d3,d4: @real
       do (if ((10,11.0) -> tstreal1) = 21 then
              't' ->put
           else error
          if);    
          (if ((10,11.0,12.0) -> tstreal2) = 33 then
              'u' ->put
           else error
          if);
          (if ((10,11.0,12.0,13.0) -> tstreal3) = 46 then
              'v' ->put
           else error
          if);
          (if ((10,11,12.0,13.0) -> tstreal4) = 46 then
              'w' ->put
           else error
          if);
          (if ((10,11,12,13.0) -> tstreal5) = 46 then 
              'x' ->put   
           else error
          if);
          (if ((20.0,21) -> tstreal6) = 41 then
              'y' ->put   
           else error
          if);
          (if ((22.0,23.0,24) -> tstreal7) = 69 then
              'z' ->put   
           else error
          if);
          (if ((25.0,26,27) -> tstreal8) = 78 then
              '0' ->put   
           else error
          if);
          (if ((28.0,29,30,31) -> tstreal9) = 118 then
              '1' ->put   
           else error
          if);
          (if ((31.0,32,33.0) -> tstreal10) = 96 then
              '2' ->put   
           else error
          if);
          10 -> n1; 11.1 -> d1; 11.9 -> d2;
          (if ((n1,d1,d2) -> tstreal2) = 33 then
              '3' -> put
           else
              error
          if);
          10.0 -> d1; 11 -> n1; 13 -> n2;
          (if ((d1,n1,n2) -> tstreal8) = 34 then
              '4' -> put
           else
              error
          if);
          30.2 -> d1; 50 -> n1; 19.8 -> d2;
          (if ((d1,n1,d2) -> tstreal10) = 100 then 
              '5' -> put
           else 
              error
          if);  
          (if ((10,11.1,11.9,5.3,4.7) -> tstreal11) = 43 then  
              '6' -> put
           else
              error
          if);
          (if ((1.1,2.2,3.3,4.4) -> tstreal12) = 11 then
              '7' -> put 
           else 
              error
          if)
       #);
     a,b,d: @integer;
     radd: external(# x,y: @real enter (x,y) exit x #); 
     intFloat: external(# n: @integer; X: @real enter(n,X) exit n #); 
     floatInt: external(# n: @integer; X: @real enter(X,n) exit n #); 
     intFloatArgs: 
       (* mixture of int and real parameters is a mess 
        * on RISCs. More cases should be added here
        *)  
       (# X: @real
       do (if (1,2.0) -> intFloat // 3 then 'n'->put if);
          2.0 -> X;
          (if (2,X) -> intFloat // 4 then 'o' -> put if);
          (if (3.0,3) -> floatInt // 6 then 'p'->put if);
          4.0 -> X;
          (if (X,4) -> floatInt // 8 then 'q' -> put if);
       #);
     copyCh: external (# ch: @char enter ch exit ch #);
     flush_stdout: external (#  #);
     multipleAsg:
       (# Y: ^Q;
          Q: (# x,y,a: @char #);
          X: @ (# a,b,c: @char #)
       do &Q[] -> Y[];
          '8'-> Y.a; 
          (# dum: @char do Y.a -> X.b -> copyCh -> X.c #);
          X.c -> put;
       #);
     arg9:
       (* Used to fail on sparc: Problem is that there are 5 arguments 
        * in registers and two on stack when copyCh is called. 
        *)
       (# printf9: external
            (# fmt: [0]@char;
               o1, o2, o3, o4, o5, o6, o7, o8: @integer
            enter (fmt, o1, o2, o3, o4, o5, o6, o7, o8)
            do 'printf' -> callC;
            #);
       do ('%c%c%c%c%c%c%c%c', 'a','b','c','d','e','f','g','h'->copyCh)
            -> printf9;
          flush_stdout;
       #);
     primToX:
       (# printf9: external  
            (# fmt: [0]@char;  
               o1, o2, o3, o4, o5, o6, o7, o8: [1]@char;
            enter (fmt, o1, o2, o3, o4, o5, o6, o7, o8)
            do 'printf' -> callC;
            #);
          T1,T2,T3,T4,T5,T6,T7,T8: [1]@char  
       do 'i' -> T1;
          'j' -> T2;
          'k' -> T3;
          'l' -> T4; 
          'm' -> T5;
          'n' -> T6;
          'o' -> T7;
          'p' -> T8;
          ('%s%s%s%s%s%s%s%s', T1,T2,T3,T4,T5,T6,T7,T8)     -> printf9;
          flush_stdout;
       #);
     ext696:
       (# ident: External(# in: @Boolean; out:@Integer enter in do exit out #);
          binary:< (# value: @Boolean enter value do INNER exit value #);
          entry: @ (# private: @ (# path: ^Text; #)#);
       do (# doopen: 
               (# name: ^Text;
                  mode: @Integer;
                  perm: @Boolean;
               enter (name[], mode, perm)
               do name->putText;   
               #);
          do 's'->entry.private.path[];
             (entry.private.path[],binary->ident,false) -> doOpen; 
             't'->put;
          #);
       #);
     BigCprocTextReturn: 
       (# r: [300]@char; 
          result: [0]@char;
       do (* Return a big text from C. Involves having CopyCT
           * allocate the resulting object directly in AOA.
           *)
          (for i:300 repeat
               'a' + (i mod 28) -> r[i];
          for);
          r -> (* CpkVT *) ident -> (* CopyCT *) result;
          (for i:300 repeat
               (if result[i]<>('a' + (i mod 28)) then
                   '&' -> put;
                   i ->putint;
                   '&' -> put;
               if);
          for);
          (if result.range=300 then 
              result['h' - 'a' ]  (* 'h' *) -> put;
           else
              error;
          if);
       #);
     dataRef:  
       (* ensure that adr register pointing to data object
        * is proprly cleared
        *) 
       (# myData: data(# x,y: @int32; c: @char #);
          foo: 
            (# a: @integer; s: ^ myData
            enter(a,S[]) 
            do (if a = S.x then S.c -> put

                else error
               if)
            #); 
          q: @ COM(# Q: @myData;   #);
          W: ^myData 
       do 12 -> q.Q.x; 'u' -> q.Q.c;
          (12,q.Q[])-> foo ;
          q.Q[] -> W[];
          21 -> W.x; 'v'->W.c;
          (21,W[]) -> foo
       #); 
     test8: 
       (# A: (#      
              do 
              exit F
              #);     
          F: (# a,b,c: @integer do '!'->a; 'w'->b; '?'->c exit(a,b,c)#);
          giveArg:  External(# a,b,c,d:@char enter (a,b,c) exit d #);
          giveMe2Argument: giveArg(##);
       do (if safeMode and isNEWRUN then
              'u' -> put;
           else
              (* datpete: The generated code fails with unconditional GC.
               * An object pointer becomes 0x75 ('u').
               *)
              A -> GiveMe2Argument -> put; 
          if)
       #);
     extern: 
       (# giveArg:  External(# a,b,c,d:@char enter (a,b,c) exit d #);
          giveMe2Argument: giveArg(##);  
          A1: (# do exit '!' -> F #);
          A2: (# do exit 'x' -> F #);
          A3: (# do exit '?' -> F #);
          F: (# ch: @char enter ch exit ch #) 
       do (if safeMode and isNEWRUN then
              'x' -> put;
           else
              (* fails with unconditional GC *)
              (A1,A2,A3) -> giveMe2Argument -> put;
          if);
       #); 
     testsFromTstReal:
       (* Tests of external patterns that used to be
        * in tstreal.bet, but has been moved to here
        * to avoid external patterns in tstreal.
        * Since the bytecode compilers cannot handle 
        * external patterns, all external tests should
        * be moved to tstcproc
        *)
       (# radd: external(# x,y,z: @real enter(x,y) exit z #);
          tan: external(# x: @real enter x exit x #);
          sin: external(# x: @real enter x exit x #); 
          cos: external(# x: @real enter x exit x #); 
          atan2: external(# x,y: @real enter(x,y) exit x#);
          pi: (#exit 3.14159265358979323846 #);
          GlGeometric:
            (# power: @real;
               width: @Real;
               ch: @char
            do 1.00 -> power;
               100 -> width;
               INNER;
               '1' -> ch
            exit ch
            #);
          GlEllipse: GlGeometric
            (# x, angle: @real;
            do 0 -> angle;
               (width / 2) * (angle -> cos) -> x;
               (x,50,'0') -> chk;
            #);
          real2intExternal:
            (# r1, r2, r3: @real;
               i: @integer;
               giveArg:  External(# a,b,c,d:@integer enter (a,b,c) exit d #);
               giveMe1Argument: giveArg(##);
               giveMe2Argument: giveArg(##);
               radd: external(# x,y: @real enter (x,y) exit x #); 
               ch: @char
            enter ch
            do 1.0 -> r1;
               2.0 -> r2;
               3.0 -> r3;
               (r1,r2,r3) -> giveMe1Argument -> i;
               (i,1,ch) -> chk;
               (r1+r1,r2+r3,r3+1.0) -> giveMe2Argument -> i;
               (i,5,'2') -> chk;
               (r1,(r1,r2) -> radd,7.14) -> giveMe2Argument -> i;
               (i,3,'3') -> chk;   
            #);
          realSaveExtern:
            (# X,Y,R: @real; b: @boolean;
               rcopy: external(#R: @real enter R exit R #);
               XXX: (# x: @real do 3.14 -> x exit x #);
            do  10.0 -> X; 2.0 -> R;
               (X-R*R->rcopy) > (X / 2.0)-> b;
               (if b then '4' -> put else error if);          
               (X-R*R->rcopy) > (X / 0.5)-> b;
               (if b then error else '5' -> put if);
               0 -> X;
               (XXX-x*x,XXX+x*x) -> radd -> y;
               (y,6.28,'6') -> chkR 
            #);
          stackFloatRegs: 
            (# x: @real
            do 1/100 -> x;
               (# xxx: @char    
               do (((1.0/x) - (x->tan)) , 99.99, '7') -> ChkR;  
                  ((((1,1)->atan2)*360)/(pi*2),45.00,'8') -> ChkR;  
               #);
               (* the following don't work on hpux9pa;
                * on linux a similar eval. (FEJL/real2) cannot terminate
                *)   
               (# dummy: @char; 
               do (((((((1,1)->atan2)*360)/(pi*2))/45,
                  ((((1,1)->atan2)*360)/(pi*2))/45) 
                    -> atan2
                  ) * 360 
                  ) / (pi*2) -> x;
                  (x,45,'9') -> chkR; 
               #);
            #); 
          
          x,y,z: @real
       do 1100.0011->x; 
          (x,11.11)->radd->z;   
          (z,1111.1111,'y')->chkR;    
          2200.0022->x; 22.22->y; 
          ((x+(x-x),y)->radd,2222.2222,'z')->chkR;
          GlEllipse ->       (* '0' *)
          real2intExternal;  (* '123' *)
          realSaveExtern;    (* '456' *)
          (if safeMode then
              stackFloatRegs;     (* '789' *)
           else
              '<backend:float exception>'->puttext
          if);
       #);
     oneMore: (* Also from tstreal *)
       (# x,r,a,y,tauNr: @real;    
          tau: external(# x: @real do exit x #); 
          rcopy: external(# x: @real enter x exit x #);
          inc: (# a1,a2: @real enter(a1,a2) do (a1+a2,29.0,'9')->chkR #)
       do 2.0->x; 
          1.0->r->a;
          3.0->y;
          (x+r*tau*(a+tau)->rcopy, y+r*tau*(a+tau)->rcopy) -> inc;
       #);
     
  do (* Test char repetition as enter/exit parameters to Externals.
      * Validating PackVarTextToC (on enter) and CopyCtext (on exit).
      * Outputs 'abcdefg'
      *)  
     'abc' -> Q; 
     Q (* CpkVT *) -> ident -> (* CopyCT *) P;
     (if Q.range=P.range then 'a' -> put else error if);
     (for i:P.range repeat  
          (if Q[i]=P[i] then 'a'+i -> put else error if)
     for);  
     Q[2:3] (* CpkSVT *) -> ident -> (* CopyCT *) P;
     (if P.range=2 then 'e' -> put else error if);
     (for i:P.range repeat  
          (if Q[1+i]=P[i] then 'e'+i -> put else error if)
     for);  

     (* h *) 
     BigCprocTextReturn;

     (* Test the order of the parameters. *) 
     ('i','!','!') -> giveMe1Argument -> put;
     ('!','j','!') -> &giveMe2Argument -> put; 
     ('!','!',exitk) -> giveMe3Argument -> put; 
     (a,b,foo##,d)->QQQ;  
     (*call back from C of ('l','mn','!','!','!','!','!','o')->foo;*)
     (if (1,2,3,4,5,6,7,8,9,10)->sumMany//55 then 'q'->put  
      else error    
     if);  
 
     (('a','!','!') -> giveMe1Argument,('!','r','!') -> giveMe2Argument,
     ('!','!','g') -> giveMe3Argument)->giveMe2Argument->put;
       
     ('!','!','s') -> giveMe3Argument -> put;
     tstData;               (* 't-z' *)
     tstCstruct; (* '0' - '5' *)
     fooAsSub##->doCallBack2->a;   
     'CProc2'-> newl; 
     (if a <> 112233 then error else 'a'->put if) ;
     tstSlice;  (* b-g *)
     25->a; 75->b;
     (if ((a,b) -> radd) = 100 then 'h'->put else error if);   
     (if ((-25,125) -> radd) = 100 then 'i'->put else error if);
     'j'->put;   
     ('!',exitk,'?') -> giveMe2Argument -> put;  
     (# xxx: @integer do
     (1,2,3,4
     ,(100,200,300,400,500,600,700,800,900,1000)->sumMany->b
     ,6,7  
     ,(10,20,30,40,50,60,70,80,90,100)->sumMany->d,9,10) 
       -> sumMany 
          -> a;
     #);
     (*newline;
     a -> putint; newline;
     b -> putint; newline;
     d->putint; newline;  *)
     (* b = 5500, d = 550, a = 6092 *)
     (if a = 6092 then 'l' -> put else error if);
     (# xx: cStruct(# bytesize::(#do 4->value #)
                   enter R[1]
                   exit R[1]
                   #);
        id:  external(# X,V: @integer enter X exit V #);  
        xxx: @xx; a: @integer
     do 1020 -> xxx.R[1]; xxx -> id -> a;
        (if a = 1020 then 'm' -> put else error if)
     #);
     intFloatArgs;
     callwithreals;
     tstvariablearguments;   (* 's' *)
     tstIntRealComb;;                 
     multipleAsg;  
     oneMore;                (* '9' *)
     'CProc3'->newl;
     arg9;
     primToX;
     'qr' -> ident -> ident -> puttext;
     ext696;
     dataRef;
     test8;
     extern;
     testsFromTstReal;
  #)

 


