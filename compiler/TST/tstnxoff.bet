origin 'tstenv';  
INCLUDE 'tstlib';
---lib:attributes---
tstnxoff:
  (# A: (# i,a,b: @integer
        do 'c' -> a; 'd' -> b;
        exit (a,b,F)
        #);
     F: (# c,d: @integer do 'a'-> c; 'b' -> d; exit (c,d) #);
     B: (# x,y: @integer  
        enter(x,y,G)   
        do x -> put; y -> put; 
        #);
     G: (# v,w: @integer
        enter(v,w)
        do v -> put; w -> put
        #);  
     H: (# q,w,e,ff: @integer  
        enter(G,e)
        exit(q,w,F)  
        #); 
     HH: H  
       (# qq,ww: @integer  
       enter(G,qq)
       exit(ww+qq,F)   
       #);
     HHH:
       (# a,b,c,d: @integer
       enter(a,b,FF) 
       #);  
     FF: F(# q1,q2: @integer
          enter(q1,q2) 
          #);       
     Arith:
       (# A1: (# do exit A2 #);  
          A2: (# ch: @char do 'e'-> ch exit ch #); 
          ch: @char
       do A1 -> ch; ch -> put;
          A1+1 -> ch; ch -> put
       #);  
     Olsen:
       (# C: @ (# exit(S[i],S[j]) #);
          D: @ (# enter(S[k],S[l]) do #); 
          S: [11] ^ T; T: (# ch: @char enter ch do exit ch #);
          i,j,k,l: @integer
       do 1->i; 2->j; 3->k; 4->l; 
          (for i:4 repeat &T[]->S[i][] for);
          'g'->S[1]; 'h'->S[2];  
          C-> D;
          S[3]->put; S[4]->put;  
       #);
     test1: 
       (# A: @  
            (# i,a,b: @integer
            do
            exit (a,b,F)
            #);  
          F: (# c,d: @integer do 'k'-> c; 'l'-> d exit (c,d) #);
          T: (# ch: @char do gCh+1 -> gCh -> ch  #);
          TT: T(# exit this(TT)[]#);
          gCh: @char;  
          B: @ 
            (# r1,r2: ^T 
            do &TT -> r1[]; &TT -> r2[]
            exit (r1[],r2[],G)
            #);
          G: (# r3: ^T; r4: ^T do &TT -> r3[]; &TT-> r4[] exit(r3[],r4[])#);
          
          A1:
            (# q1,q2,q3,q4: @char;
            do 'i'-> A.a; 'j'-> A.b;  
               A -> (q1,q2,(q3,q4));
               q1->put;   q2->put;   q3->put;   q4->put;
            #); 
          A2: 
            (# s1,s2,s3: ^T; s4: ^TT
            do 'l'-> gCh;
               B -> (s1[],s2[],(s3[],s4[]));  
               s1.ch -> put; s2.ch -> put; 
               s3.ch -> put; s4.ch -> put; 
            #); 
       do A1; A2;    
       #); 
     test2:
       (* For A -> ... 
        * the exit values are fetched without executing code since
        * F has no do-part. When fetching the F-exit values, callReg
        * is pushed (originally referring to A) and set to refer to F.
        * Not possible to just freeze the adr of F, since exit of
        * non-local part objects may be arbitrarely long
        *)
       (# A: @ 
            (# i,a,b: @integer 
            do
            exit (a,b,F)
            #);
          F: @ 
            (# c,d: @integer 
            exit (c,d) 
            #);
          q1,q2,q3,q4: @char
       do 'q'-> A.a; 'r'-> A.b; 's'-> F.c; 't'-> F.d ;
          A -> (q1,q2,(q3,q4));
          q1 -> put; q2 -> put; q3 -> put; q4 -> put;
       #);
     test3:
       (* For A -> ..
        * the exit values are fetched relative to the address of A.
        * Possible since F is a part object of A
        *)
       (# A: @ 
            (# F: @ 
                 (# c,d: @integer 
                 exit (c,d) 
                 #);
               i,a,b: @integer
            do
            exit (a,b,F)
            #);
          q1,q2,q3,q4: @char
       do 'u'-> A.a; 'v'-> A.b; 'w'-> A.F.c; 'x'-> A.F.d ;
          A -> (q1,q2,(q3,q4));
          q1 -> put; q2 -> put; q3 -> put; q4 -> put;
       #);
     test4: 
       (# A: (# exit B #);
          B: (# do exit 'y' #);
          A1: (# exit B1 #);
          B1: (# do exit 'z' #);        
          R: [1] @ char
       do A -> put;
          (if false(*isByteCodeMode*) then '#' -> put
           else
              A1 -> R;  
              R -> puttext;
          if) 
       #);
     test5:
       (# A: @ | 
            (# i,a,b: @integer
            do
            exit (a,b,F)
            #);
          F: (# c,d: @integer do '2'-> c; '3'-> d exit (c,d) #);
          T: (# ch: @char do gCh+1 -> gCh -> ch exit this(T)[] #);
          gCh: @char;
          B: @ |
            (# r1,r2: ^T 
            do &T -> r1[]; &T -> r2[]
            exit (r1[],r2[],G)
            #);
          G: (# r3,r4: ^T do &T -> r3[]; &T -> r4[] exit(r3[],r4[])#);
           
          A1:
            (# q1,q2,q3,q4: @char; 
            do '0'-> A.a; '1'-> A.b;
               (if false (*isByteCodeMode*) then
                   '%%%%'->puttext
                else
                   A -> (q1,q2,(q3,q4));
                   q1->put;   q2->put;   q3->put;   q4->put;
               if)
            #);
          A2:  
            (# s1,s2,s3,s4: ^T; 
            do '3'-> gCh; 
               (if false (*isByteCodeMode*) then
                   '%%%%'->puttext
                else
                   B -> (s1[],s2[],(s3[],s4[]));
                   s1.ch -> put; s2.ch -> put; s3.ch -> put; s4.ch -> put;  
               if)
            #); 
       do A1; A2;  
          '8'->fill;
       #); 
     test6:
       (# Bch:   
            (# x,y: @char
            enter(x,y,G)   
            do x -> put; y -> put; 
            #);
          A: (# i,a,b: @integer
             do 'o' -> a; 'p' -> b;
             exit (a,b,F)
             #);
          F: (# c,d: @integer do 'm'-> c; 'n' -> d; exit (c,d) #);
          
          x,y,z,v: @integer
       do 'a'->v; 'b'->x; 'c'-> y; 'd' -> z; 
          (y,z,(v,x)) -> B; 
          ('g','h',('e','f')) -> Bch;
          'i'->v; 'j'->x; 'k'-> y; 'l' -> z;
          (y,z,(v,x)) -> Bch;
          A -> Bch
       #); 
     test7:
       (# BX:   
            (# x,y: ^TX
            enter(x[],y[],G)   
            do x.ch -> put; y.ch -> put;  
            #);
          AX: (# i: @integer; a,b:@TX 
              do 's' -> a.ch; 't' -> b.ch;
              exit (a[],b[],FX)
              #);
          FX: (# c,d: @integer do 'q'-> c; 'r' -> d; exit (c,d) #);
          TX: (# ch: @char #)    
       do   
          AX -> BX 
       #);
     test8: (* the old test8 used external and has been moved
             * to tstcproc since bytecode compiler handling of
             * external procedures is not clear
             *)
       (# do 'u'->put #);
     test9: 
       (# nxText: 
            (# T: [10] @char; length: @integer;
               setT: (# enter T do T.range-> length #)
            enter setT
            exit T[1:length]
            #);
          foo:
            (# S,R: @nxText; s1,s2: ^nxText;
            enter S
            do S -> R -> puttext;
               &nxText[]->s1[]; 
               (* (# x: @char do 'xy'->s1; #); (* ??? seems to work 
                                                * if in singular descriptor
                                                *)
               'xy' -> s1;
               &nxText[]->s2[]; s1 -> s2;
               s2 -> puttext
            #); 
          t: @nxText;   
          test10:  
            (# qqqq: (# q: ^nxText;#);
               
               R1: [1] @char; 
               r: ^qqqq
            do &qqqq[] -> r[]; 
               &nxText[] -> r.q[]; ''-> r.q;
               (* CopySVR1 must check if slice-range is empty *)
               (# a: @char do r.q.T[2:r.q.length] -> R1;#);
               (if R1.range = 0 then 'z'->put if)
            #); 
          test11: 
            (# expandToFullPath:
                 (# name: ^text; n1: @nxText; n2: ^nxText
                 enter name[]
                 do name-> n1
                 exit 
	            (n1[],n1[])->thePathHandler.convertFilePath
                 #);
               thePathHandler: @
                 (# convertfilePath:<
                      (# s1,s2: ^nxText 
                      enter(s1[],s2[])
                      do 
                      exit s1[]
                      #);
                 #);
               open:
                 (# T: ^nxText; s: ^nxtext
                 enter (T[],s[])
                 do T -> puttext
                 #);
               s: ^nxText  
            do  ('01'->expandToFullPath,s[]) -> open
            #)
       do 'vw'->t;
          t -> foo;
          test10;
          test11
       #);
     test12:
       (# foo:
            (# inx,i,j: @integer
            enter theIndex->inx
            do inner
            #);
          theIndex: @integerValue(#enter value do #);;
          bar: (# fool: foo(#do ch->put #) do 113 -> fool #); 
          ch: @char 
       do '2'->ch; 
          bar;
       #);
     test13:
       (# descKind:  
            (# D: @INDEX; v: @integer enter D do D.kind->v exit 0->v.%getByte #);
            (* Above line tos_converted from: (# D: @INDEX; enter D exit D.kind->TOS'%getByte[0]' #); *)
          getPossibleSlot:
            (# n,val: @integer
            enter n
            do  (if isBigEndian then
                    0x33232425 -> val
                 else
                    0x25242333 -> val
                if);
            exit val
            #); 
          index:    
            (# v: @integer;
               kind: (#exit 5 -> getPossibleSlot #)
            enter v
            exit v
            #);
          D: @ index;
       do D -> descKind -> put;
       #) ;
     test14:        
       (# kuk: 
            (# V1: @index; v2: @char;v3: ^text;
               fool: (#do '4'->V1.a; '5'->V2; suspend #);
            enter(V1,v3[],v2) do fool exit(v1,v2,v3[])
            #); 
          index:  (# a,b: @integer enter(a,b) exit(a,b) #);
          a,b: @char;
          II: @index;
          S: ^text  
       do (# K: @ | kuk;  
          do (II,S[],a) -> K -> (II,b,S[]);
          #);
          II.a->put; b -> put;
       #);
     test15:  
       (# fuggy: (#  enter a do inner #);
          a: @text;
          googy: fuggy 
            (# t: ^text
            enter t[]
            do a->puttext;
            #)
       do ('6',none) -> googy
       #);
          
  do A -> B; 
     Arith;  
     olsen; (* 'g' - 'h' *)
     test1; (* 'i' - 'p' *) 
     test2; 
     test3;     
     test4;     
     test5;  
     'NXoff1' -> newl;
     test6;    (* 'a-p' *)
     test7;    (* 'q-t' *)
     test8;
     test9;
     test12;   (* ' -2' *)
     test13;   (* '3' *) 

     (if false(*isByteCodeMode*) then
         '%%'->puttext
      else
         (if ismacosx then
             'test14 fails with ugc for macosx-' -> puttext;
          else
             test14;   (* '4- ' *)
         if);
     if);
     test15;   
     (if false(*isByteCodeMode*) then
         '###'->puttext
      else
         (# A: (# exit B #); 
            B: (# R: [1] @char do '789' -> R exit R #);  
            S: [1] @char
         do A -> S;
            S -> puttext;
         #)
     if)        
  #)






