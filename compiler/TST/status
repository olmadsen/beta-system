Status for new backend pr 14.2.01
---------------------------------

Currently no know errors on sun4s.

To be fixed:

2.      Register spilling. When more registers are needed than there
        are physical registers, registers must be save/restored on the stack.
2.1     Compute total size of adrReg,dataReg,externalParamArea
        for allocation of tmp-stack-space
2.2     Implement spilling algorithm
2.3     Test spilling on sun4s 
2.4     ...???

3.      Allocation of specific physical registers;
        sometimes it is necessary to be able to allocate/control
        explicit physical registers:
3.1     For external calls the return value is often in a specific
        register like %o0 - %eax for INTEL
3.2     For floating point on sparc: %f0
3.3     For COM calls the input arguments are in
            %i0, %i1, %i2, ...
3.4     Similar for callBack - here a trick has been used
        to get the input values from the registers

4.      Index-check is NOT complete - reconsider interface!

5.      %i2,%i3,%i4 are always cleared at G- and M-entrypoints.
        This should be handled by INTERMEDIATEmachine.
        FG has fixed this - but call of AlloI must be checked

6.      In asgRef, the dest-register is cleared in order not to confuse GC.
        Must be handled in a better way.

7.      Constant arguments
        In some places (arithShiftLeft) we need to check the size
        of a constant argument.

8.      In intReg2float we use %f0 because there seems to be problems with
        writeReg2

9.      Check with FG & AE why we changed syntlibbody:goorigin to
                   (if common.switch[121] then
                       reg1.alloc;
                       (A2[],reg1[])->mch.ldVal;
                       A2.reg.deAlloc;
                       reg1 -> A2.reg
                    else
                       (A2[],reg1[])->mch.ldVal;
                   if)
        Aha! Probably to make more efficient use of registers.
        But it gives errors for origin bind tables. In bind tables
        we should use %o0, since an allocated register may be in use
        at the call site.

10. Later intel optimizations.
    Intel supports e.g. push <address>, which is currently generated
    as lea <address>,<reg>; push <reg>.
    Add capability to allow intermediatemachine to make these
    optimizations. 

    Der er utroligt mange steder %edx (current object)
    gemmes henover kald af det ene og andet.
    Det ser ud til at det er PushReg (der jo gemmer alle aktive registre)
    der gør dette. 
    I resultatet af den gamle kodegenerering sker dette ikke.
    Er det fordi %edx skal ignoreres af PushReg/PopReg?

    F.eks. ved kald af ExtVR1 skal der puttes en konstant i primreg
    (memory).
    Intel kan gøre dette direkte, men det går pt via register.

    I for løkker tælles index variablen op ved at loaded den fra
    memory tiol register, incremente register, og store register i
    memory.
    Intel kan incremente memory direkte.

    Der optræder ofte lea 0(reg1),reg2 (svarende til mov reg1,reg2).
    Jeg tror at nogle af disse er unødvendige moves, som ikke bliver
    optimeret væk da optimizeren ikke genkender dette som en move
    register. Eks. M17TSTGENERALREP.


11. intel:

    ORIGIN 'tstenv';        
    INCLUDE 'tstlib'
    --program:descriptor--
    (# S: [1] @char;  
       R: [1] @char;  
       addZ: (# i: @integer enter i do i+'0'->i exit i #);
    do 1->addZ->S[1];
       S[1]->R[1];
    #)

    gives

    ...
    0x80510f6 <M1PROGRAM+77>:       movzbl 0xf(%esi,%eax,1),%eax
    0x80510fb <M1PROGRAM+82>:       mov    %al,0xf(%ebp,%ebx,1)
 
    The first should be             mov    0xf(%esi,%eax,1),%al
    (size=1)

12. intel:

    ORIGIN 'tstenv';        
    INCLUDE 'tstlib'
    --program:descriptor--
    (# i,j: @integer;
    do (if (i>j)//true then newline if);
    #)  

    1. The if should generally be identified as a simple-if
    2. On intel generates:

    push   %edx
    mov    %edi,%edx
    mov    0xc(%edx),%ebx
    mov    0x10(%edx),%eax
    cmp    %eax,%ebx
    mov    $0x0,%eax     <<<<<----- (1)
    setg   %al
    cmp    $0x1,%eax     <<<<<----- (2)
    jne    0x805107d <M1PROGRAM+52>
    mov    0x8(%edx),%eax
    mov    %eax,0x8070b04
    lea    0x806fb40,%edi
    call   0x80671e0 <AlloI>
    call   0x8051022 <M4BETAENV>
    mov    %edx,%edi
    pop    %edx
    ret    

    If the compiler could give size=1 to cmpAndJmp, which generates
    (2), the clearing og eax at (1) by cmpToBool could be avoided.

13. intel remaining:
    tstenv
        Problem with cstruct. Results in error in cproc:
        CProc     : abcdefghijklmnopqrstuvwxyz???BBB6789.
        Problem in INTERMEDIATEmachine.stval always using 4 as size.
        Old TOS calls use size=1, even for stVal.
        Does NOT work to use A.size in stVal (:-(
    tstlist2rep
        *Compiler* crashes during graph coloring.
        Boiled down:
               ORIGIN 'tstenv' ; 
               --program:descriptor--
               (# fool: (# R: [0] ^text enter R #);
                  t4: ^text;
               do ('kl',t4[],'o','p','qr') -> fool
               #)
        Turns out to be problem with missing spilling too.
    tstnewprim
        NewPrim3  : abcdefghijklmnopqrstuvwxyz0123!56789.
        NewPrim4  : !!!!!!ghijklmnopqrstuvwxyz0123456789.
        problems with gPutBits due to Register spill missing
    tstvarptn
        abcde!ghijklmnopqrstuvwxyz0123456789.
        Problem with spilling: a busy register is saved in 
        pReg1 during call of AlloSI (primitive spilling), 
        but pReg1 is destroyed by AlloSI (since it calls AlloI).
    tstreal, tstlvra, tstlib
        Floating Point INTEL register coloring NYI
    tstgeneralrep
        abcdefghijklmnopqrstuvwxyz0-37-37-37456789.
        M17TSTGENERALREP: '1'+i in %D10 (eax) not saved
        during call of NewVR1.
    tstcom
        Tstcom    : abcdefghijklmnopqrs
        Use of StackOff operand type in SYNTHESIZER.
        StackOff not supported by INTERMEDIATEmachine.
    tst
        Reference is none - after tstint8; 
        Problems with prompt for tstlist2rep:
          'List2Rep'-> T[3][]; 
          3 -> i;
          T[i][] ->T[i-1][];
          T[i-1]->newL;
        In the first line of this code, MkTO is called with
        *repetition* on stack instead of item in which to find
        repeptition. 

------

OBS! All backend switches have been assigned new numbers, since some
of the numbers were used by other parts of the compiler.

     120:        old 81
     121:        old 86
     122:        old 89
     123:        old 351
     124:        old 352

