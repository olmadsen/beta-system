Status for new backend pr 14.2.01
---------------------------------

Currently no know errors on sun4s.

To be fixed:

2.	Register spilling. When more registers are needed than there
	are physical registers, registers must be save/restored on the stack.
2.1	Compute total size of adrReg,dataReg,externalParamArea
	for allocation of tmp-stack-space
2.2	Implement spilling algorithm
2.3	Test spilling on sun4s 
2.4	...???

3.	Allocation of specific physical registers;
	sometimes it is necessary to be able to allocate/control
	explicit physical registers:
3.1	For external calls the return value is often in a specific
	register like %o0 - %eax for INTEL
3.2	For floating point on sparc: %f0
3.3	For COM calls the input arguments are in
	    %i0, %i1, %i2, ...
3.4	Similar for callBack - here a trick has been used
	to get the input values from the registers

4.	Index-check is NOT complete - reconsider interface!

5.	%i2,%i3,%i4 are always cleared at G- and M-entrypoints.
	This should be handled by INTERMEDIATEmachine.
	FG has fixed this - but call of AlloI must be checked

6.	In asgRef, the dest-register is cleared in order not to confuse GC.
	Must be handled in a better way.

7.	Constant arguments
	In some places (arithShiftLeft) we need to check the size
	of a constant argument.

8.	In intReg2float we use %f0 because there seems to be problems with
	writeReg2

9.	Check with FG & AE why we changed syntlibbody:goorigin to
		   (if common.switch[121] then
                       reg1.alloc;
                       (A2[],reg1[])->mch.ldVal;
                       A2.reg.deAlloc;
                       reg1 -> A2.reg
                    else
                       (A2[],reg1[])->mch.ldVal;
                   if)
	Aha! Probably to make more efficient use of registers.
	But it gives errors for origin bind tables. In bind tables
	we should use %o0, since an allocated register may be in use
	at the call site.

10. Later optimizations.
    Intel supports e.g. push <address>, which is currently generated
    as lea <address>,<reg>; push <reg>.
    Add capability to allow intermediatemachine to make these
    optimizations. 

11. intel:

    ORIGIN 'tstenv';        
    INCLUDE 'tstlib'
    --program:descriptor--
    (# S: [1] @char;  
       R: [1] @char;  
       addZ: (# i: @integer enter i do i+'0'->i exit i #);
    do 1->addZ->S[1];
       S[1]->R[1];
    #)

    gives

    ...
    0x80510f6 <M1PROGRAM+77>:       movzbl 0xf(%esi,%eax,1),%eax
    0x80510fb <M1PROGRAM+82>:       mov    %al,0xf(%ebp,%ebx,1)
 
    The first should be             mov    0xf(%esi,%eax,1),%al
    (size=1)

12. intel:

    ORIGIN 'tstenv';        
    INCLUDE 'tstlib'
    --program:descriptor--
    (# i,j: @integer;
    do (if (i>j)//true then newline if);
    #)  

    1. The if should generally be identified as a simple-if
    2. On intel generates:

    push   %edx
    mov    %edi,%edx
    mov    0xc(%edx),%ebx
    mov    0x10(%edx),%eax
    cmp    %eax,%ebx
    mov    $0x0,%eax     <<<<<----- (1)
    setg   %al
    cmp    $0x1,%eax     <<<<<----- (2)
    jne    0x805107d <M1PROGRAM+52>
    mov    0x8(%edx),%eax
    mov    %eax,0x8070b04
    lea    0x806fb40,%edi
    call   0x80671e0 <AlloI>
    call   0x8051022 <M4BETAENV>
    mov    %edx,%edi
    pop    %edx
    ret    

    If the compiler could give size=1 to cmpAndJmp, which generates
    (2), the clearing og eax at (1) by cmpToBool could be avoided.

13. intel remaining:
    tstenv
	Problem with cstruct. Results in error in cproc:
	CProc     : abcdefghijklmnopqrstuvwxyz???BBB6789.
	not examined further
    tstlist2rep
	Crashes during graph coloring
    tstnewprim
	NewPrim3  : abcdefghijklmnopqrstuvwxyz0123!56789.
	NewPrim4  : !!!!!!ghijklmnopqrstuvwxyz0123456789.
	problems with gPutBits due to Register spill missing
    tstvarptn
        abcde!ghijklmnopqrstuvwxyz0123456789.
	not examined
    tstreal, tstlvra, tstlib
	Floating Point INTEL register coloring NYI
    tstgeneralrep
	abcdefghijklmnopqrstuvwxyz0-37-37-37456789.
	Not examined.
    tstcom
	Crashes immediately
	TODO: : backendAllocObj
	TODO: : backendExternalDispatch
	TODO: : backendGetCOMpar
	TODO: : backendReturnVirtualCOM
    tst
	Reference is none - after tstint8; not examined

------

OBS! All backend switches have been assigned new numbers, since some
of the numbers were used by other parts of the compiler.

     120:	 old 81
     121:	 old 86
     122:	 old 89
     123:	 old 351
     124:	 old 352

