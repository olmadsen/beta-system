ORIGIN 'tstenv'; 
INCLUDE 'tstlib'; 
BODY 'tstthis2'
---lib:attributes---
TstThis:
  (# P: (# a1: (# do exit this(p)[] #);
           a2: (# R: ^ P do (for 1 repeat this(p)[]->R[] for) exit R[] #);
 	   a3: (# R: ^ P do L: A(#do this(p)[]->R[] #) exit R[] #);
           T: @ text; S: ^object 
        enter T
        do  T->putText;
           this(P)[]-> S[]    
        exit S[]
        #); 
     A: (# do INNER #);   
     T1: (#do'q'->put #); 
     T2: object(#do 'r'->put;INNER #); 
     R: ^ Object; 
     X: @ P; S: ^P; 

     B: (# x,y: @char; olsen:< Object;
           M: (# 
              do this(B)->put; 
                 this(B).x->put; 
                 (if false(*isByteCodeMode*) then '#'->put else This(B).olsen
                 if)
              #) 
        do 's'->y; 't'->x
        exit y 
        #);
     aB: @B(# olsen::< (#do 'u'->put #)#);
     F: <<SLOT thisF:descriptor>>; aF:^F;
     F2: (# ch: @char do (#<<SLOT thisF2:dopart>> #)#); aF2: ^F2;
     hml: 
       (# A: (# display:< (# do 'x' -> put; inner #)#);
          B: A  
            (# display::< (#do error; inner #); 
               C: A(# display::< (# do 'y' -> put; inner #);
                      test: (# do this(A).display #);
                   #);
            #);
          theB: @B (# theC: @C #);
       do theB.theC.test;
       #);
     les:
       (# interfaceObject: (# open:<  (#do 'z'->x; inner #); x: @char #);
          window: interfaceObject(# open::< (#do inner #)#)  ; 
          myWindow: window(# open::(#do this(interfaceObject).x -> put #)#);
       do  (&myWindow[]).open
       #);
     foo1:
       (# ch: @char;
          copy: (# <<SLOT copy:dopart>> #)
       do
          (# x: @char
          do (# y: @char do '0' -> this(foo1).ch #)
          #);
          ch -> put;
          ch+1 -> ch;
          copy
       #);
     foo2: 
       (# ch: @char
         <<SLOT foo2:doPart>>
       #);
     bar1:
       (# c1: @char;
          bar2:
            (# c2: @char
              <<slot bar2:dopart>>
            #);
       do bar2
       #);
     fool:
       (# ch: @char;
          move1: 
            (# F: ^fool; 
            do this(fool)[] -> F[];  
               this(fool)[] -> go
            #);
          move2: (# do <<SLOT move2:descriptor>> #);
       #);
     go: (# F: ^fool enter F[] do F.ch -> put #);
     
     FF: @fool;
     foobar1: (# emit: (# do '7'->put #) #);
     foobar2: foobar1
       (# go:
            (# V: ^foobar1
            do this(foobar1)[] -> V[]
            exit V[]
            #);
       #);
     superThis:
       (# FG:
            (# setup:(# <<SLOT setup:dopart>> #);
               prop: ^property
            #);
          property: (# scan: (# do inner #)#);
          F: @FG
       do F.setup
       #)

  do 'abcdef'->X.T; X->R[]; 
     'ghijk'->X.T; X.a1->S[]; S.T->puttext;
     'lmnop'->X.T; X.a2->S[]; S.T->puttext;  
     &T1[]->R[]; R; 
     &T2[]->R[]; R;   
     aB.M;  
     F; aF; 
     F2; aF2;  
     hml;    
     les;
     foo1;
     foo2;
     bar1;
     '5'->FF.ch;
     FF.move1;
     '6'->FF.ch;
     FF.move2;
     ((&foobar2[]).go).emit;
     superThis;
     '9'->puttext
  #)
---copy:doPart---
do  
   (# x: @char 
   do this(foo1).ch -> x;
      x -> put
   #)

---foo2:doPart--- 
do
   (# x: @char
   do (# y: @char do '2' -> this(foo2).ch #)
   #);
   ch -> put
---bar2:doPart---
do '3' -> this(bar2).c2;  
   '4' -> this(bar1).c1;
   (# x: @char
   do c2 -> put;
      c1 -> put
   #)
   
---move2:descriptor---
(#
do  this(fool)[] -> go 
#)

---setup:dopart--
do
   find: this(FG).prop.scan
     (#
     do '8' ->put
     #)
