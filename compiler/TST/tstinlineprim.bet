ORIGIN 'tstenv'     
---INCLUDE 'tstlib'
---Lib:attributes---
TstInlinePrim:
  (* test of low level operations *)
  (# isBigEndian:
       (# X: @integer; b: @boolean
       do 0x01000000->X; @@X->TOS'%adrGetByte[0]'->b
       exit b
       #);
     
     CHK:
       (# a,b: @integer; c: @Char
       enter(a,b,c)
       do (if a//b then c->put else '!'->put if)
       #);
     
     X,Y,Z: @integer;
     R,Rx: [3]@integer;
     
     ZZ: (# do exit @@X #)
  do -1->X;
     (@@X,12)->TOS'%putByte[2]';
     (X->TOS'%getByte[2]',12,'a')->CHK;
     
     (* NOTE: the following does not work on an Intel processor
      * sice it uses little-endian
      *)
     (* ((1024+2048+100->TOS'%getByte[2]'),12,'a')->CHK; *)
     
     (@@Z,1)->TOS'%putByte[0]';
     (@@Z,2)->TOS'%putByte[1]';
     (@@Z,4)->TOS'%putByte[2]';
     (@@Z,8)->TOS'%putByte[3]';
     
     (* Little-endian problem with the following: 
      * (Z,(8 + 4*256 + 2*256*256 + 256*256*256),'b')->CHK;
      *)
     (Z->TOS'%getByte[0]',1,'b')->CHK;
     
     (Z->TOS'%getByte[0]',1,'c')->CHK;
     (Z->TOS'%getByte[1]',2,'d')->CHK;
     (Z->TOS'%getByte[2]',4,'e')->CHK;
     (Z->TOS'%getByte[3]',8,'f')->CHK;
     
     (for i: R.range*4 repeat
          (R,i-1,'f'+i)->TOS'%inxPutByte'
     for);
     R->Rx;
     (#do (for i: Rx.range*4 repeat 
               ((Rx,i-1)->TOS'%inxGetByte')-> put (* 'g-r'*)
     for)#);  
     
     (* putShort 's-t' *)
     (@@X,11111)->TOS'%putShort[0]';
     (ZZ,12222)->TOS'%putShort[1]';
     (X->TOS'%getShort[0]',11111,'s')->CHK;
     (X->TOS'%getShort[1]',12222,'t')->CHK;
     
     (for i: R.range*2 repeat
          (R,(i-1)*2,'t'+i)->TOS'%inxPutShort'
     for);
     (for i: R.range*2 repeat
          ((R,(i-1)*2)->TOS'%inxGetShort')-> put (* 'u-z'*)
     for);
     (for i: R.range repeat
          (R,(i-1)*4,'0'+i-1)->TOS'%inxPutLong'
     for);
     (for i: R.range repeat
          ((R,(i-1)*4)->TOS'%inxGetLong')-> put (* '0-2'*)
     for);
     
     (for i:R.range repeat 0->R[i] for);
     
     (R,0,'3')->TOS'%inxPutByte';
     (R,1,'4')->TOS'%inxPutByte';
     (R,2,'5')->TOS'%inxPutByte';
     (R,3,'6')->TOS'%inxPutByte';
     (R,4,'7')->TOS'%inxPutLong';
     (* OBS paa sparc skal longs vaere 4-aligned *)
     (R,8,'8')->TOS'%inxPutShort';  
     (R,10,'9')->TOS'%inxPutShort';
     
     (R,0)->TOS'%inxGetByte'->put;
     (R,1)->TOS'%inxGetByte'->put;
     (R,2)->TOS'%inxGetByte'->put;
     (R,3)->TOS'%inxGetByte'->put;
     (R,4)->TOS'%inxGetLong'->put;
     (R,8)->TOS'%inxGetShort'->put;
     (R,10)->TOS'%inxGetShort'->put;
     
     newl;
     (@@X,-11)->TOS'%putByte[0]';
     (@@X,-22)->TOS'%putByte[1]';
     (@@X, 33)->TOS'%putByte[2]';
     (@@X,-44)->TOS'%putByte[3]';
     (X->TOS'%getSignedByte[0]',-11,'a')->CHK;
     (X->TOS'%getSignedByte[1]',-22,'b')->CHK;
     (X->TOS'%getSignedByte[2]', 33,'c')->CHK;
     (X->TOS'%getSignedByte[3]',-44,'d')->CHK;
     
     (for i:R.range repeat 0->R[i] for);
     
     (R,0,-111)->TOS'%inxPutByte';
     (R,1,-122)->TOS'%inxPutByte';
     (R,2,-4444)->TOS'%inxPutShort';
     (R,4,-33333)->TOS'%inxPutLong';
     (R,8,55)->TOS'%inxPutByte';
     (R,9,-66)->TOS'%inxPutByte';
     (R,10,1233)->TOS'%inxPutShort';
     
     ((R,0)->TOS'%inxGetSignedByte',-111,'e')->CHK;
     ((R,1)->TOS'%inxGetSignedByte',-122,'f')->CHK;
     ((R,2)->TOS'%inxGetSignedShort',-4444,'g')->CHK;
     ((R,4)->TOS'%inxGetLong',-33333,'h')->CHK;
     ((R,8)->TOS'%inxGetSignedByte',55,'i')->CHK;
     ((R,9)->TOS'%inxGetSignedByte',-66,'j')->CHK;
     ((R,10)->TOS'%inxGetSignedShort',1233,'k')->CHK;
     
     (((111000111->TOS'%not') + 1),-111000111,'l')->CHK;
     
     ('q'->TOS'%shiftLeft[16]') + 'w' -> X;
     (X, 256*256*95+95)->TOS'%and'->X;
     (if isBigEndian//true then
         (X->TOS'%getByte[1]','Q','m')->CHK;
         (X->TOS'%getByte[3]','W','n')->CHK;
      else
         (X->TOS'%getByte[2]','Q','m')->CHK;
         (X->TOS'%getByte[0]','W','n')->CHK
     if);
     
     ('E'->TOS'%shiftLeft[16]') + 'R' -> X;
     (X, 256*256*32+32)->TOS'%or'->X;
     (if isBigEndian//true then
         (X->TOS'%getByte[1]','e','o')->CHK;
         (X->TOS'%getByte[3]','r','p')->CHK;
      else
         (X->TOS'%getByte[2]','e','o')->CHK;
         (X->TOS'%getByte[0]','r','p')->CHK
     if);

     1->Y; (for i:24 repeat  Y*2->Y for);
     
     ((26,21)->TOS'%xor',15,'q')->CHK;
     
     ((3->TOS'%shiftLeft[4]'),48,'r')->CHK;
     ((1->TOS'%shiftLeft[24]'),Y,'s')->CHK;
     ((1024->TOS'%shiftRight[10]'),1,'t')->CHK;
     ((3->TOS'%aritShiftLeft[4]'),48,'u')->CHK;
     ((1024->TOS'%aritShiftRight[10]'),1,'v')->CHK;
     ((-1024->TOS'%aritShiftRight[10]'),-1,'w')->CHK;
     
     0->X;
     (@@X,7)->TOS'%putBits[12,9]'; (* bits 12:20 *)
     ((X->TOS'%getBits[12,9]'),7,'x')->CHK; 
     ((X->TOS'%getSignedBits[12,9]'),7,'y')->CHK;
     ((X->TOS'%getSignedBits[18,3]'),-1,'z')->CHK;
     
     (@@Z->TOS'%adrGetByte[0]',1,'0')->CHK;
     (@@Z->TOS'%adrGetByte[1]',2,'1')->CHK;
     (@@Z->TOS'%adrGetByte[2]',4,'2')->CHK;
     (@@Z->TOS'%adrGetByte[3]',8,'3')->CHK;
     
     (* putShort '4-5' *)
     (@@X,11111)->TOS'%putShort[0]';
     (@@X,12222)->TOS'%putShort[1]';
     (@@X->TOS'%adrGetShort[0]',11111,'4')->CHK;
     (@@X->TOS'%adrGetShort[1]',12222,'5')->CHK;
     
     (* NB: adrGetSignedX is not tested! Neither is adrGetLong *)

     (@@X,'6')->TOS'%putByte[0]'; (@@X,'7')->TOS'%putByte[1]';
     (@@X,'8')->TOS'%putByte[2]'; (@@X,'9')->TOS'%putByte[3]';
     X->TOS'%getBits[0,8]'->put; X->TOS'%getBits[8,8]'->put;
     X->TOS'%getBits[16,8]'->put; X->TOS'%getBits[24,8]'->put;
     
     newl;
     (@@X,'a')->TOS'%PutBits[0,8]'; (@@X,'b')->TOS'%PutBits[8,8]';
     (@@X,'c')->TOS'%PutBits[16,8]'; (@@X,'d')->TOS'%PutBits[24,8]';
     
     X->TOS'%getByte[0]'->put; X->TOS'%getByte[1]'->put;
     X->TOS'%getByte[2]'->put; X->TOS'%getByte[3]'->put;
     'e'->fill

  #)





