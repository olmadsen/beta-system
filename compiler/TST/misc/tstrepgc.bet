origin '~beta/basiclib/v1.4/betaenv'
---program:descriptor---
(# word:
     (# t: @text;
        read:<
          (# ch: @char
          do t.clear; get->ch;
             L: (if keyboard.eos then ascii.nul->ch
                 else (if ch
                       // ' ' then
                       // '\n' then
                       else 
                          ch->t.put;
                          get->ch;
                          restart L
                if)if)
          exit ch
          #);
        print:<
          (#
          do t[]->puttext; ' '->put;
          #);
     #);
   line:
     (# words: [1] @word; top: @integer;
        read:<
          (# ch: @char
          do (if (top+1->top) > words.range then
                 words.range->words.extend
             if);
             (if (words[top].read -> ch) = ' ' then restart read if);
          exit ch (* ch = '\n' or ch = eos *)
          #);
        reverse:
          (#
          do
          #);
        copy:<
          (# l: ^|line
          enter l[]
          do l.words->words; l.top->top;
             l[]->cash.saveC;
          #)             
     do 2->words.extend;
        '***'->words[top+1->top].t.append;
        'end'->words[top+1->top].t.append;
        (for i: top repeat words[i].print for);
        newline;
     #);
   document: 
     (# lines: [10] @ | line; top: @integer;
        read:<
          (#
          do (if (top+1->top) > lines.range then
                 lines.range->lines.extend
             if);
             (if lines[top].read = '\n' then restart read if);
          #);
        print:<
          (#
          do (for i : top repeat lines[i] for);
          #);
        reverse:
          (# l: [top] @ | line;
          do (for i: top repeat
                  lines[i].reverse;
             for);
             (for i: top repeat
                  lines[top-i+1][] -> l[i].copy
             for);
             l -> lines;
             this(reverse)[]->cash.saveI
          #);
     #);
   d: @document;
   cash: @ 
     (# c: [4] ^| object; ctop: @integer;
        saveC:
          (#  r: ^| object;
          enter r[]
          do (if (ctop+1->ctop) > c.range then c.range->c.extend if);
             r[]-> c[ctop][]
          #);
        i: [4] ^ object; itop: @integer;
        saveI:
          (#  r: ^ object;
          enter r[]
          do (if (itop+1->itop) > i.range then i.range->i.extend if);
             r[]-> i[itop][]
          #);
        clear:
          (#
          do 4->c.new; 4->i.new; 0->ctop->itop; 
          #)
     #);
   
do d.read;
   d.print;
   (for i: 10000 repeat 
        d. reverse; 
        (if (i mod 300) = 0 then 
            '*********************************************Clear: '->puttext;
            i->putint; newline;
            cash.clear 
        if)
   for);
   d.print
#)
  
