Mjolner BETA Compiler version 5.5 (752) for SUN-4 Solaris 2.x (ELF)
Target machine type sun4s
Building dependency graph for: 'tst' ...
Parsing: 'tstholder'
Translating fragments ...
Bind fragments in: 'tstholder'!Checking
%192: test: (#  exit false #) 
%192: intHolder: holder
   (#
      value: @integer;
      isNone: <<ObjectDescriptor>>;
      writeBack: <<ObjectDescriptor>>
   enter value
   exit value
   #) 
%192: refHolder: holder
   (# type:< object; ref: ^type; writeBack: <<ObjectDescriptor>>
   enter ref[]
   exit ref[]
   #) 
%192: tstHolder:
   (#
      myClass: <<ObjectDescriptor>>;
      TTTT: <<ObjectDescriptor>>;
      myClassHolder: <<ObjectDescriptor>>;
      R: @myClass;
      Q: @intHolder;
   do <<Imperatives>>
   #) 
%192: myClass: COM
   (#
      foo:< <<ObjectDescriptor>>;
      bar:< <<ObjectDescriptor>>;
      foo1:< <<ObjectDescriptor>>;
      foo2:< <<ObjectDescriptor>>;
      foo3:< <<ObjectDescriptor>>;
   #) 
%192: TTTT: COM (# foo1:< <<ObjectDescriptor>>; foo2:< <<ObjectDescriptor>>;  #) 
%192: myClassHolder: refHolder (# type:: myClass #) 
%192: R: @myClass 
%192: foo:<
   (# n: @integer; S: ^intHolder; 
   enter <<Evaluations>>
   do <<Imperatives>>
   #) 
%192: bar:<
   (# n: @integer; R: ^myClassHolder
   enter <<Evaluations>>
   do <<Imperatives>>
   #) 
%192: foo1:< (# S: ^intHolder enter S[] do <<Imperatives>> #) 
%192: foo2:<
   (# <<Names>>: @integer; S: ^myClassHolder
   enter <<Evaluations>>
   do <<Imperatives>>
   #) 
%192: foo3:<
   (# n: @integer; S: ^myClassHolder
   enter <<Evaluations>>
   do <<Imperatives>>
   #) 
%192: kuk: @integer 
%192: n: @integer 
%192: S: ^intHolder 
%192: value: @integer 
%192: isNone: (#  exit <<EqExp>> #) 
%192: writeBack: (#  do <<PrimitiveExp>> #) 
%192: n: @integer 
%192: R: ^myClassHolder 
%192: Setup:R 
%192: Setup: 1 R: ^myClassHolder R 
%192: Setup:R.ref 
%192: Setup: 1 ref: ^type ref 
%192: type:< object 
%192: ref: ^type 
%192: writeBack: (#  do <<PrimitiveExp>> #) 
%192: type:: myClass 
%192: S: ^intHolder 
%192: n,a,b,c: @integer 
%192: S: ^myClassHolder 
%192: n: @integer 
%192: S: ^myClassHolder 
%192: Setup:S 
%192: Setup: 1 S: ^myClassHolder S 
%192: Setup:S.ref 
%192: Setup: 1 ref: ^type ref 
%192: ComPart:  false 
%192: Q: @intHolder 
%192: HolderPart:  false 
%192: P: @myClassHolder 
%192: HolderPart:  false 
%192: Setup:R 
%192: Setup: 1 R: @myClass R 
%192: Setup:R 
%192: Setup: 1 R: @myClass R 
%192: Setup:P 
%192: Setup: 1 P: @myClassHolder P 
%192: Setup:P.ref 
%192: Setup: 1 ref: ^type ref 
%192: Setup:P 
%192: Setup: 1 P: @myClassHolder P 
%192: Setup:P.ref 
%192: Setup: 1 ref: ^type ref 
%192: Setup:R 
%192: Setup: 1 R: @myClass R 
%192: Setup:R 
%192: Setup: 1 R: @myClass R 
%192: Setup:P 
%192: Setup: 1 P: @myClassHolder P 
%192: Setup:P.ref 
%192: Setup: 1 ref: ^type ref 
%192: x: @char 
%192: S: ^myClassHolder 
%192: y: @char 
%192: Setup:R 
%192: Setup: 1 R: @myClass R 
%192: Setup:S 
%192: Setup: 1 S: ^myClassHolder S 
%192: Setup:S.ref 
%192: Setup: 1 ref: ^type ref 
%192: R: @TTTT 
%192: foo1:< (# S: ^intHolder enter S[] do (*) <<SimpleIfImp>> #) 
%192: foo2:<
   (# S: ^intHolder; n: @integer
   enter <<Evaluations>>
   do <<SimpleIfImp>>
   #) 
%192: S: ^intHolder 
%192: Setup:S 
%192: Setup: 1 S: ^intHolder S 
%192: S: ^intHolder 
%192: n: @integer 
%192: Setup:S 
%192: Setup: 1 S: ^intHolder S 
%192: ComPart:  false 
%192: X: @intHolder 
%192: HolderPart:  false 
%192: Setup:R 
%192: Setup: 1 R: @TTTT R 
%192: Setup:R 
%192: Setup: 1 R: @TTTT R 
%192: Setup:R 
%192: Setup: 1 R: @TTTT R 
%192: Setup:r 
%192: Setup: 1 R: @TTTT R !Code generation
%192: attDesc: n 
%192: attDesc: @integer 
%192: attDesc: S[] 
%192: attDesc: ^intHolder 
%192: attDesc: S[] 
%192: attDesc: ^intHolder 
%192: attDesc: n 
%192: attDesc: @integer 
%192: attDesc: S[] 
%192: attDesc: ^myClassHolder 
%192: attDesc: n 
%192: attDesc: @integer 
%192: attDesc: S[] 
%192: attDesc: ^myClassHolder 
%192: attDesc: S[] 
%192: attDesc: ^intHolder 
%192: attDesc: n 
%192: attDesc: @integer 
%192: attDesc: R[] 
%192: attDesc: ^myClassHolder 
%192: attDesc: n 
%192: attDesc: @integer 
%192: attDesc: S[] 
%192: attDesc: ^intHolder 
Bind fragments in: 'tst'!Checking
%192: T: @text
   (# <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>;  #) 
%192: isHpux9pa: (# b: @boolean do <<AssignmentEvaluation>> exit b #) 
%192: isSun4s: (# b: @boolean do <<AssignmentEvaluation>> exit b #) 
%192: isSgi: (# b: @boolean do <<AssignmentEvaluation>> exit b #) 
%192: isPpc: (# b: @boolean do <<AssignmentEvaluation>> exit b #) 
%192: Setup:T 
%192: Setup: 1 T: @text
   (# <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>;  #) T 
%192: Setup:T 
%192: Setup: 1 T: @text
   (# <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>;  #) T 
%192: Setup:T 
%192: Setup: 1 T: @text
   (# <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>;  #) T 
%192: Setup:T 
%192: Setup: 1 T: @text
   (# <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>; <<PatternDecl>>;  #) T 
%192: b: @boolean 
%192: Setup:T 
%192: Setup: 1 T: [1] @char T 
%192: b: @boolean 
%192: Setup:T 
%192: Setup: 1 T: [1] @char T 
%192: b: @boolean 
%192: Setup:T 
%192: Setup: 1 T: [1] @char T 
%192: b: @boolean 
%192: Setup:T 
%192: Setup: 1 T: [1] @char T !Code generation
Linking
Object program on file: tst
