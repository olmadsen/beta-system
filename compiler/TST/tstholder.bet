ORIGIN 'tstenv';  
INCLUDE 'tstlib';
---lib:attributes--- 

(* datpete: 2003-02-27: Holders need not anylonger be allocated
 * as static part objects of COM, as both COM and Holder objects 
 * are always allocated directly in AOA.
 * Even part objects of regular patterns: These are actually 
 * offline allocated using AlloCOM.
 *)

test: (#exit false #); 
(* Using: 
 *    holder: (# adr: @integer #)     
 *)
intHolder: holder  
  (# value: @integer;
     isNone: (# exit value = 0 #);
  enter value
  exit value          
  #);
refHolder: holder    
  (# type:< COM;
     ref: ^type;
  enter ref[] 
  exit ref[]
  #); 
tstHolder: 
  (# myClass: COM
       (# foo:<
            (# n: @integer; S: ^intHolder;       
            enter(n,S[])
            do (if test then
                   n -> putint; ' ' -> put; S -> putint; ' '->put;
               if); 
               (if S = 111 then 'a' -> put else error if);
               n + S -> S; 
               (if test then S -> putint; newline; if)  
            #);
          bar:<
            (# n: @integer; R: ^myClassHolder        
            enter(n,R[]) 
            do (if test then 'myClass::bar'->putline if); 
               &myClass[] -> R; 
               n -> R.ref.kuk;
               (if test then 'myClass::bar:end'->putline if);
            #);    
          foo1:<   
            (# S: ^intHolder 
            enter S[] 
            do (if test then  S -> putInt; newline if);
               (if S = 444 then 'd' -> put else error if);
               111 + S -> S; 
            #);
          foo2:<
            (# n,a,b,c: @integer; S: ^myClassHolder
            enter(n,S[])
            do (* Call foo3, which instantiates a myClass and return via Holder (two level holder writeback) *)
               (n,S[]) -> foo3;
            #);
          foo3:<
            (# n: @integer; S: ^myClassHolder
            enter(n,S[])
            do (* Instantiate a myClass and return via Holder *)
               &myClass[] -> S;
               n -> S.ref.kuk;
            #);
               
          kuk: @integer   
       #);  

   TTTT: COM  
     (# foo1:<
          (# S: ^intHolder  
          enter S[]
          do (*n -> putint; ','->put; S -> putint; newline;*)
             (if S.isNone then
                 'i' -> put 
              else
                 (if S = 1010 then 'h' -> put else error if);
             if)
          #);
        foo2:<        
            (# S: ^intHolder; n: @integer
            enter (n,S[])
            do (if S.isNone then
                   'k'->put
                else 
                   (if S = 101 then 'j' -> put else error if);
               if)
            #);
     #);

     R: @myClass;
     myClassHolder: refHolder(# type::myClass #);         
     
     Q: @intHolder;
     P: @myClassHolder;
     
  do 111->Q;
     (if test then 'main 1:'->putline if);        
     (11,Q[]) -> R.foo; (* 'a' *) 
     (* The above fails if GC during AlloI in foo G-part because address of 
      * integer inside Q is pushed on stack .
      * NO not anymore: The COM object around Q ensures that Q is 
      * allocated in AOA and thus never moved.
      *)
       
     (if test then                
         'main 2:'->putline;
         Q -> putint; newline;
     if);  
     (if Q = 122 then 'b' -> put else error if);
     
     (333,P[]) -> R.bar;   
     (if test then P.ref.kuk -> putint; newline; if);
     (if P.ref.kuk = 333 then 'c' -> put else error if);
     
     444 -> Q; 
     Q[] -> R.foo1;
     (* Q -> putint; newline;   *)
     (if Q = 555 then 'e' -> put else error if);
     
     (* Call foo2 which calls foo3 *)
     (666,P[]) -> R.foo2;
     (if P.ref.kuk = 666 then 'f' -> put else error; P.ref.kuk->putint; if);
     
     (* call foo3 directly *)
     (# S: ^ myClassHolder
     do &myClassHolder[] -> S[];
        (777,S[]) -> R.foo3;
        (if S.ref.kuk = 777 then 'g' -> put else error if);
     #);
     
     (# R: @TTTT;
        X: @intHolder;
     do 1010 -> X; 
        X[] -> R.foo1;
        none -> R.foo1;
        101 -> X;
        (5,X[]) -> R.foo2; 
        (6,none) -> r.foo2;
     #);

     'l' -> fill;
  #)
