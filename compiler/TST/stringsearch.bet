origin 'tstenv';
include 'basicsystemenv'
---program:descriptor---
BasicSystemEnv
(# S: @text;
   R: @text;
   
   inSub:
     (# first,D,inx: @integer 
     enter(first,D)
     do -1 -> inx;
        search:
          (for i: D repeat (*'.'->put;*)
               (if (first+i+ SL) > S.T.range then leave search if);
               L:
                 (# 
                 do (if first+i-1>S.T.range then
                        IO.entry
                        (# 
                        do 
                           'inSub: index error: first+i-1: '->puttext;
                           first+i-1->putint; ' S.T.range: '->puttext;
                           S.T.range -> putint; newline;
                        #);
                        Leave L;
                    if);
                    (if S.T[first+i-1] = R.T[1] then
                        (for j: sL-1 repeat (*','->put;*)
                             (if first+i+j-1>S.T.range then
                                 IO.entry
                                 (# 
                                 do 
                                    'inSub: index error: first+i+j-1: '->puttext;
                                    first+i+j-1->putint; ' S.T.range: '->puttext;
                                    S.T.range -> putint; newline;
                                 #);
                                 Leave L;
                             if);
                             (if j+1>R.T.range then
                                 IO.entry
                                 (# 
                                 do 
                                    'inSub: index error: j+1: '->puttext;
                                    j+1->putint; ' R.T.range: '->puttext;
                                    R.T.range -> putint; newline;
                                 #);
                                 Leave L;
                             if);
                             (if S.T[first+i+j-1] <> R.T[j+1] then
                                 leave L
                             if)
                        for); 
                        i -> inx;
                        leave search; 
                    if) 
                 #)
          for);
        (*'!'->put; newline*)
     exit inx
     #);

   sl,start: @integer;
   
   searchSlave:
     (#
     do 
        L:
          (# first,inx: @integer
          do jobs.getNext -> first; 
             IO.entry(#do 'slave: '->puttext; first->putint; newline; #);
             (if first > 0 then
                 (first,jobs.D) -> InSub -> inx;
                 (if inx > 0 then 
                     inx -> jobs.found
                  else
                     restart L
                 if)
          if)#)
     #);
   
   jobs: @ |
     (# m,done: @semaphore;
        entry: (# do m.P; INNER; m.V #);
        getNext: entry
          (# inx: @integer
          do (if (currentInx = maxInx) and (inx < S.T.range) then
                 lastInx -> inx;
                 lastInx + D -> lastInx;
             if)
          exit inx
          #);
        found: entry
          (# inx: @integer
          enter inx
          do (if inx < currentInx then
                IO.entry
                 (#
                 do '='->put; inx->putint; ','->put;
                    inx -> currentInx;
                    currentInx -> putint; newline
                 #); 
                 done.V (* not quite enough *)
             if)
          #);
        getInx: 
          (#
          do (*IO.entry(#do '*'->put #);*)
             done.P; 
             (*IO.entry(#Do ':'->put; currentInx -> putint; newline #);*)
          exit currentInx
          #);
        D,lastInx, currentInx: @integer;
        init:<
          (#
          do maxInx -> currentInx;
             1 -> lastInx;
             8 -> D;
             M.init; done.init;
             (*M.V*)
          #);
        maxInx: (# exit S.T.range + 1999 #)
     #);
   NoOfSlaves: (# exit 3 #);
   inx: @integer
do
   'This a good example of a string' -> S;
   'good' -> R;
   R.T.range -> SL;
   1->start;
   'Searching: ' -> puttext; R[] -> putline;
   'in: '->puttext; S[]->putline;
   jobs.init;
   (for i: NoOfSlaves repeat
        &|SearchSlave[] -> fork
   for);
   
        (*IO.entry(#do '->'->putline #);*)

   jobs.m.V; 
   jobs.getInx -> inx;
   IO.entry
   (#
   do '\nSubstring found at index: '->puttext;
      inx->putint; newline;
      '(should be 8).' -> putline;
   #)


#)
