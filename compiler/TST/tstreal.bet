ORIGIN 'tstenv';   
INCLUDE 'tstlib'; 
-----LIB:attributes--- 
TstReal:
  (# x,y,z,v,w: @real;  b: @boolean; i,j: @integer;
     R: [10]@real;     
     pi: (#exit 3.14159265358979323846 #);
    
     ch: @char;
     nextCh: @
       (#
       do (if (ch+1->ch)>'z' //true then
              '0'->ch
          if)
       exit ch
       #); 
     aa: @ (# v: @real;
           enter v
           do (v,2.0,nextCh)->chkR;
           #);
     bb: @ (# v: @real
           enter v
           do  (v,1.5,nextCh)->chkR;
           #);          
     cc: @ (# v: @real
           enter v
           do  (v,1.0,nextCh)->chkR;
           #);        
     (* tstsub and tstdiv are needed to check floating point on I386
      * which is having a floating point stack instead of registers.
      * This means that the order of pushing the operands on
      * the stack is IMPORTANT
      *)
     tstSub:
       (# i: @integer; x,y: @real; a,b: @real;
       do 4.0->x->a; 2.0->y->b;
          4.0 - 2.0 ->aa;
          4.0 - y ->aa;
          4.0 - (x-x+y) ->aa;
          x - 2.0 ->aa;  
          x - y -> aa;
          x - (x-x+y) -> aa;  
          (x+y-y) - 2.0 ->aa;
          (x+y-y) - y ->aa;
          (x+y-y) - (a-a+b) -> aa;
          3.0 - 2 -> cc;
          3.0 - 2 ->cc;  
          3.0 - 2.0 -> cc;
          3.0 - 2.0 ->cc;               
          2->i;
          3.0 - i -> cc;
          3.0 - i ->cc;  
       #);
     tstDiv:
       (# i: @integer; x,y: @real; a,b: @real; 
       do 4.0->x->a; 2.0->y->b;
          4.0 div 2.0 ->aa;
          4.0 div y ->aa;
          4.0 div (x-x+y) ->aa;
          x div 2.0 ->aa;
          x div y -> aa;
          x div (x-x+y) -> aa;
          (x+y-y) div 2.0 ->aa;
          (x+y-y) div y ->aa;
          (x+y-y) div (a-a+b) -> aa;
          3.0 div 2 -> bb;
          3.0 div 2 ->bb;  
          3 / 2 -> bb;
          3.0 / 2 -> bb;
          3.0 div 2.0 -> bb;
          3.0 div 2.0 ->bb;               
          3 / 2.0 -> bb;
          3.0 / 2.0 -> bb;
          2->i;
          3.0 div i -> bb;
          3.0 div i ->bb;  
          3 / i -> bb;
          3.0 / i -> bb;  
       #);   
     
     moreTsts:    
       (# a:@ (# aaa: @real; r: (# do 300.0 -> aaa exit aaa #) #);
          p: (# y: @real do 3.14->y exit y #);
          p1: (# exit 3.14 #);
          x: @real; I: @integer
       do (# xxx: @char do  (300.0 * p, 942.0,'a')->chkR; #);
          (a.r * 3.14, 942.0,'b')->chkR;   
          (a.r * p, 942.0,'c')->chkR;
          a.r * p -> x;         
          (if (x > -0.0001) and (x < 0.0001) // true then error if);
          (300.0*3.14) div 180.0 -> x;
          (a.r * p1) div 180.0 -> y;
          (x,y,'d')->chkR;
          3.0->x;
          (1.11*x->I,3,'e')->chkR;
       #);
     again: 
       (# v: @real;  
          base: @integer; 
          ch: @char;
          sh: @int16u;
          I: @integer; 
       do 10->base; 1->V; '9'->ch; 20->sh; 30->I;
          V*base+(ch-'0'->I)+sh->V; (V,39.0,'f')->chkR
       #);
     qword:
       (* datpete 6/7/95:
        * tst that real to integer store does not destroy next long.
        * Was a problem on NTI.
        *)
       (# X: @(# i, j: @integer #);
          r: @real;
       do 99 -> X.j;
          1.0 -> r;
          r -> X.i;
          (X.j,99,'h')->chk;
       #);
     tstFloatRangeAndExtend:
       (# R: [10(*10.1 float not allowed by checker*)] @integer; 
       do (if R.range = 10 then 'i'->put else error if);
          (if false(*isByteCodeMode*) then
              '#' -> put
           else 
              (# dummy:@char do R.range + R.range/2 -> R.extend; #);
              (if R.range = 25 then 'j'->put else error if)
          if) 
       #); 
     longAnd:
       (# cx,x0,cy,y0,midrsegx,x1,y1,midrsegy,x2,y2,midx23,midy23: @real
       do (if ((cx=x0) and 
             (cy=y0) and 
             (midrsegx=x1) and
             (midrsegy=y1) and 
             (midx23=x2) and 
             (midy23=y2) and 
             (cy=y0) and 
             (midrsegx=x1) and
             (midrsegy=y1) and   
             (midx23=x2) and 
              (midy23=y2))
           // true then (* test if register overflow *)  
          if)
       #);
     tstGif: 
       (# x,y: @real;
          snorf: (# u: @real do 3 -> u exit u #);
       
       do (if 3.0
           // 1 then '?' -> put 
           // 3 then 'o' -> put
           else
              error              
          if);
          3.0 -> x;
          (if x  
           // 1 then '?' -> put
           // 3 then 'p' -> put
           else error
          if);
          (if snorf
           // 1 then '?' -> put
           // 3 then 'q' -> put
           else error
          if);
          (if snorf -> y
           // 1 then '?' -> put
           // 3 then 'r' -> put
           else error
          if);  
       #);
     tstSimpleIf:
       (# x,y: @real
       do 3.11 -> x;
          6.12 -> y; 
          (if x < y  then 's' -> put else error if); 
          (if x <= y then 't' -> put else error if);
          (if x > y  then error else 'u' -> put if);
          (if x >= y then error else 'v' -> put if);
          (if x <> y then 'w' -> put else error if);
          (if x = y  then error else 'x' -> put if);

          6.12 -> x;
          (if x < y  then error else 'y' -> put if);
          (if x <= y then 'z' -> put else error if);
          (if x > y  then error else '0' -> put if);
          (if x >= y then '1' -> put else error if);
          (if x <> y then error else '2' -> put if);
          (if x = y  then '3' -> put else error if); 

          3.11 -> y;
          (if x < y  then error else '4' -> put if);
          (if x <= y then error else '5' -> put if);
          (if x > y  then '6' -> put else error if);
          (if x >= y then '7' -> put else error if);
          (if x <> y then '8' -> put else error if);
          (if x = y  then error else '9' -> put if);
       #);
     tstCstExp:
       (# x: @real
       do (-4.0) - (-8.0)-> x;
          (x,4.0,'a') -> chkR
       #);
     recursiveFloat: 
       (# foo:
            (# n: @integer; x,y,z: @real
            enter n
            do 5.0 -> x; 2.0 -> y;
               (if n > 0 then
                   ((n-1) -> foo) + x/y -> z
                else
                   1.0 -> z;
               if)
            exit z
            #);
          x: @real
       do 15 -> foo -> x;
          (x,38.5,'b') -> chkR
       #);

     Save2floatonstack:
       (# port:
            (# value: @real
            enter value
            do
            exit value
            #);
          T,x0: @port;  
          mass,R,S,p: @real
       do 2.0 -> mass;
          3.0 -> R;
          10.0 -> T;
       
          4.0 -> x0;
          5.0 -> S; 
      
          mass*R*T / (x0*S)-> p;
          
          (p,3.0,'h') -> chkR;
       #);
     doinner:  
       (# do inner #);
     realAndText: doinner  
       (# chk: @chkR; 
          end, omega: @real;  
          F: ^text; 
          pi: (# Exit 3.14159265358979323846 #);  
       do pi->omega;  
          (if false(*isByteCodeMode*) then
           else
              (2*pi / omega,'simul')->(end,F[]); (* bytecode problem with
                                                  * list -> list
                                                  * assignment
                                                  *)
          if);
          (end,2.0,'i') -> chk;
       #);    
     realNegation:
       (# r: @real;
       do 3.14 -> r;
          (-r, -3.14, 'm') -> ChkR;
       #); 
          
 
  do (if false then '###' -> puttext else
         1.11->x; 2.22->y; x+y->z;   z-x->v;  
     (x,1.11,'a')->chkR; (v,2.22,'b')->chkR; (z,3.33,'c')->chkR;    
     1.66->v; 0.55->w; x+y+v-w->x; (x,4.44,'d')->chkR;        
     4.80->x; 4.08->y; 3.0->z; 0.33->v;
     (x+y)-(z+v)->x; (x,5.55,'e')->chkR;
     6->i; i->x; 
     (x+0.66,6.66,'f')->chkR; 
     (# dummy:@char do 7.49->x; #); (*used to be 7.99 - check rounding strategy*)
     (# dummy:@char do x->i; #);
     (# dummy:@char do i+0.77->x #);
     (# dummy:@char do (x,7.77,'g')->chkR; #);
     8->i; 0.88->x; (i+x,8.88,'h')->chkR;	 
     0.99->x; (9+x,9.99,'i')->chkR;
     10->x; (x,10,'j')->chkR;
     11->x; 10.101->y; x*y->z; (z,111.111,'k')->chkR;
     4.4->x; 977.7768->y; (y div x,222.222,'l')->chkR;
     2->x; 100->y; 6.66666->z; ((y*z) / x,333.333,'m')->chkR;
     111.111->x; 222.222->y;
     x<y->b; 
     (if b//true then 'n'->put else error if);
     x->y; (if x // y then 'o'->put else error if);
     x->z;  3.14->y; 3.141->v;
     (for ii: 4 repeat  
          (if x
           // y then 
              100->i; 11->j; 
              111.111111->y; ((i+j)+0.111111,y,'r')->chkR   
           // z then 'p'->put; x->v; 111.1111->z   
           // v then 'q'->put; x->y; 111.11111->v  
           else    
              3.14E5->x; -3.14E5->y; 111.5E-7->z; -111.5E-7->v;
              ((x+y)+(z+v),0,'s')->chkR;
     if)for); 
     x->y;
     (x<y,false,'t')->chkBool;
     (x<=y,true,'u')->chkBool; 
     (x>y,false,'v')->chkBool; 
     (x>=y,true,'w')->chkBool; 

     1010.1010E2->x; 1010.1010E3->y; 1010.1010E-2->z; x->v;
     (*  z < x=v < y *)
     ((x+(x-y))=(y+0),false,'x')->chkBool;
     (x=v,true, 'y')->chkBool;
     (x<>y,true,'z')->chkBool;   
     (x<>v,false,'0')->chkBool; 
     
     '12'->puttext;          (* external tests moved to tstcproc *)     

     11100.10101->R[1]; 11.0101->R[2]; 
     R[1]+R[2]->R[3]; (R[3],11111.11111,'3')->chkR;
     (for i:6 repeat 3.14E3*i->R[i] for);
     (for i:6 repeat (R[i],i*3.14E3,'3'+i)->chkR for); 
     'Real2' -> newl; 
     'a'-1->ch;
     tstSub;
     tstDiv;      
     'Real3' -> newl;  
     moreTsts;               (* 'abcde'   *)
     again;                  (* 'f'       *)
     'g'->put;               (* external tests moved to tstcproc *)
     qword;                  (* 'h'       *)
     tstFloatRangeAndExtend; (* 'ij'      *)
     longAnd;                (* no output *)
     (* datpete 9/12/96: linux error reported by Kai Petzke: *)
     (if 0.0<0.0 then error else 'k'->put if);
     
     'lmn'->puttext;         (* external tests moved to tstcproc *)
          
     tstGif;                 (* 'o' - 'r' *)
     tstSimpleIf;            (* 's' - '9' *)
     
     'Real4' -> newL;        (* line 4 *)
     tstCstExp;              (* 'a' *)
     recursiveFloat;         (* 'b' *)

     'cdefg' -> puttext;     (* external tests moved to tstcproc *)     

     save2floatonStack;      (* 'h' *)
     (if false(*isByteCodeMode*) then
         '#'->put
      else
         RealAndText;            (* 'i' *)
     if);
     'jkl' -> puttext;       (* external tests moved to tstcproc *)

     realNegation;           (* 'm' *)
         'n' -> fill
     if)
  #)

