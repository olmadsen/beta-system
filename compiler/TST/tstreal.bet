ORIGIN 'tstenv';
INCLUDE 'tstlib'
-----LIB:attributes---
TstReal:
  (# x,y,z,v,w: @real;  b: @boolean; i,j: @integer;
     R: [10]@real;    
     chkR: 
       (* Note that comparions of reals as in X+Y
        * does in general not work satisfactory for floating point numbers.
        * E.g 1.11->x; 3.33->y; y-x->z; x=2.22 may be false
        *)
       (# x,y,z: @real; ch: @char 
       enter(x,y,ch)
       do x-y->z; (* The difference should be close to zero *)
          z->i;   (* round to nearest integer, should be zero *)
          (if i<0 //true then -i->i if);
          (if i//0 then ch->put else '!'->put if)
       #);
     radd: EXTERNAL(# x,y,z: @real enter(x,y) exit z #);
     
     ch: @char;
     nextCh: @
       (#
       do (if (ch+1->ch)>'z' //true then
              '0'->ch
          if)
       exit ch
       #);
     aa: @ (# v: @real;
           enter v
           do (v,2.0,nextCh)->chkR;
           #);
     bb: @ (# v: @real
           enter v
           do  (v,1.5,nextCh)->chkR;
           #);          
     cc: @ (# v: @real
           enter v
           do  (v,1.0,nextCh)->chkR;
           #);          
     (* tstsub and tstdiv are needed to check floating point on I386
      * which is having a floating point stack instead of registers.
      * This means that the order of pushing the operands on
      * the stack is IMPORTANT
      *)
     tstSub:
       (# i: @integer; x,y: @real; a,b: @real;
       do 4.0->x->a; 2.0->y->b; 
          4.0 - 2.0 ->aa;
          4.0 - y ->aa;
          4.0 - (x-x+y) ->aa;
          x - 2.0 ->aa;
          x - y -> aa;
          x - (x-x+y) -> aa;
          (x+y-y) - 2.0 ->aa;
          (x+y-y) - y ->aa;
          (x+y-y) - (a-a+b) -> aa;
          3.0 - 2 -> cc;
          3.0 - 2 ->cc;  
          3.0 - 2.0 -> cc;
          3.0 - 2.0 ->cc;               
          2->i;
          3.0 - i -> cc;
          3.0 - i ->cc;  
       #);
     tstDiv:
       (# i: @integer; x,y: @real; a,b: @real; 
       do 4.0->x->a; 2.0->y->b; 
          4.0 div 2.0 ->aa;
          4.0 div y ->aa;
          4.0 div (x-x+y) ->aa;
          x div 2.0 ->aa;
          x div y -> aa;
          x div (x-x+y) -> aa;
          (x+y-y) div 2.0 ->aa;
          (x+y-y) div y ->aa;
          (x+y-y) div (a-a+b) -> aa;
          3.0 div 2 -> bb;
          3.0 div 2 ->bb;  
          3 / 2 -> bb;
          3.0 / 2 -> bb;
          3.0 div 2.0 -> bb;
          3.0 div 2.0 ->bb;               
          3 / 2.0 -> bb;
          3.0 / 2.0 -> bb;
          2->i;
          3.0 div i -> bb;
          3.0 div i ->bb;  
          3 / i -> bb;
          3.0 / i -> bb;  
       #);   
     
     moreTsts:
       (# a:@ (# aaa: @real; r: (# do 300.0 -> aaa exit aaa #) #);
          p: (# y: @real do 3.14->y exit y #);
          p1: (# exit 3.14 #);
          x: @real; I: @integer
       do (300.0 * p, 942.0,'a')->chkR;
          (a.r * 3.14, 942.0,'b')->chkR;   
          (a.r * p, 942.0,'c')->chkR;
          a.r * p -> x;         
          (if (x > -0.0001) and (x < 0.0001) // true then '!'->put if);
          (300.0*3.14) div 180.0 -> x;
          (a.r * p1) div 180.0 -> y;
          (x,y,'d')->chkR;
          3.0->x;
          (1.11*x->I,3,'e')->chkR;
       #);
     again:
       (# v: @real;
          base: @integer;
          ch: @char;
          sh: @shortInt;
          I: @integer;
       do 10->base; 1->V; '9'->ch; 20->sh; 30->I;
          V*base+(ch-'0'->I)+sh->V; (V,39.0,'f')->chkR
       #);
     oneMore:
       (# x,r,a,y,tauNr: @real;    
          tau: external(# x: @real do exit x #); 
          rcopy: external(# x: @real enter x exit x #);
          inc: (# a1,a2: @real  enter(a1,a2) do (a1+a2,29.0,'g')->chkR #)
       do 2.0->x; 1.0->r->a; 3.0->y;
          (x+r*tau*(a+tau)->rcopy, y+r*tau*(a+tau)->rcopy) -> inc;
       #)
  do 1.11->x; 2.22->y; x+y->z;   z-x->v;
     (x,1.11,'a')->chkR; (v,2.22,'b')->chkR; (z,3.33,'c')->chkR;
     1.66->v; 0.55->w; x+y+v-w->x; (x,4.44,'d')->chkR;
     4.80->x; 4.08->y; 3.0->z; 0.33->v;
     (x+y)-(z+v)->x; (x,5.55,'e')->chkR;
     6->i; i->x; (x+0.66,6.66,'f')->chkR;
     7.49->x; (*used to be 7.99 - check rounding strategy*)
     x->i; (i+0.77,7.77,'g')->chkR;
     8->i; 0.88->x; (i+x,8.88,'h')->chkR;	
     0.99->x; (9+x,9.99,'i')->chkR;
     10->x; (x,10,'j')->chkR;
     11->x; 10.101->y; x*y->z; (z,111.111,'k')->chkR;
     4.4->x; 977.7768->y; (y div x,222.222,'l')->chkR;
     2->x; 100->y; 6.66666->z; ((y*z) / x,333.333,'m')->chkR;
     111.111->x; 222.222->y;
     x<y->b;
     (if b//true then 'n'->put else '!'->put if);
     x->y; (if x // y then 'o'->put else '!'->put if);
     x->z;  3.14->y; 3.141->v;  
     (for ii: 4 repeat  
          (if x
           // y then 
              100->i; 11->j; 
              111.111111->y; ((i+j)+0.111111,y,'r')->chkR   
           // z then 'p'->put; x->v; 111.1111->z  
           // v then 'q'->put; x->y; 111.11111->v  
           else    
              3.14E5->x; -3.14E5->y; 111.5E-7->z; -111.5E-7->v;
              ((x+y)+(z+v),0,'s')->chkR;
     if)for); 
     x->y;
     (x<y,false,'t')->chkBool;
     (x<=y,true,'u')->chkBool;
     (x>y,false,'v')->chkBool; 
     (x>=y,true,'w')->chkBool;
     
     1010.1010E2->x; 1010.1010E3->y; 1010.1010E-2->z; x->v;
     (*  z < x=v < y *)
     ((x+(x-y))=(y+0),false,'x')->chkBool;
     (x=v,true, 'y')->chkBool;
     (x<>y,true,'z')->chkBool;
     (x<>v,false,'0')->chkBool;
     
     1100.0011->x; 11.11->y; (x,y)->radd->z; (z,1111.1111,'1')->chkR; 
     2200.0022->x; 22.22->y; ((x+(x-x),y)->radd,2222.2222,'2')->chkR; 
     (*     3300.0033->x; 33.33->y; x+y->real2text->puttext; ' '->put;*)
     11100.10101->R[1]; 11.0101->R[2]; 
     R[1]+R[2]->R[3]; (R[3],11111.11111,'3')->chkR;
     (for i:6 repeat 3.14E3*i->R[i] for);
     (for i:6 repeat (R[i],i*3.14E3,'3'+i)->chkR for); 
     newl;
     'a'-1->ch;
     tstSub;
     tstDiv;  
     newl;
     moreTsts;
     again; 
     oneMore;
     'h'->fill;
  #)
