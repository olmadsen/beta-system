ORIGIN 'tstenv';     
INCLUDE 'tstlib'; 
-----LIB:attributes--- 
TstReal:
  (# x,y,z,v,w: @real;  b: @boolean; i,j: @integer;
     R: [10]@real;     
     radd: external(# x,y,z: @real enter(x,y) exit z #);
     tan: external(# x: @real enter x exit x #);
     sin: external(# x: @real enter x exit x #); 
     cos: external(# x: @real enter x exit x #); 
     atan2: external(# x,y: @real enter(x,y) exit x#);
     pi: (#exit 3.14159265358979323846 #);
     
     ch: @char;
     nextCh: @
       (#
       do (if (ch+1->ch)>'z' //true then
              '0'->ch
          if)
       exit ch
       #);
     aa: @ (# v: @real;
           enter v
           do (v,2.0,nextCh)->chkR;
           #);
     bb: @ (# v: @real
           enter v
           do  (v,1.5,nextCh)->chkR;
           #);          
     cc: @ (# v: @real
           enter v
           do  (v,1.0,nextCh)->chkR;
           #);          
     (* tstsub and tstdiv are needed to check floating point on I386
      * which is having a floating point stack instead of registers.
      * This means that the order of pushing the operands on
      * the stack is IMPORTANT
      *)
     tstSub:
       (# i: @integer; x,y: @real; a,b: @real;
       do 4.0->x->a; 2.0->y->b;
          4.0 - 2.0 ->aa;
          4.0 - y ->aa;
          4.0 - (x-x+y) ->aa;
          x - 2.0 ->aa;
          x - y -> aa;
          x - (x-x+y) -> aa;
          (x+y-y) - 2.0 ->aa;
          (x+y-y) - y ->aa;
          (x+y-y) - (a-a+b) -> aa;
          3.0 - 2 -> cc;
          3.0 - 2 ->cc;  
          3.0 - 2.0 -> cc;
          3.0 - 2.0 ->cc;               
          2->i;
          3.0 - i -> cc;
          3.0 - i ->cc;  
       #);
     tstDiv:
       (# i: @integer; x,y: @real; a,b: @real; 
       do 4.0->x->a; 2.0->y->b;
          4.0 div 2.0 ->aa;
          4.0 div y ->aa;
          4.0 div (x-x+y) ->aa;
          x div 2.0 ->aa;
          x div y -> aa;
          x div (x-x+y) -> aa;
          (x+y-y) div 2.0 ->aa;
          (x+y-y) div y ->aa;
          (x+y-y) div (a-a+b) -> aa;
          3.0 div 2 -> bb;
          3.0 div 2 ->bb;  
          3 / 2 -> bb;
          3.0 / 2 -> bb;
          3.0 div 2.0 -> bb;
          3.0 div 2.0 ->bb;               
          3 / 2.0 -> bb;
          3.0 / 2.0 -> bb;
          2->i;
          3.0 div i -> bb;
          3.0 div i ->bb;  
          3 / i -> bb;
          3.0 / i -> bb;  
       #);   
     
     moreTsts:    
       (# a:@ (# aaa: @real; r: (# do 300.0 -> aaa exit aaa #) #);
          p: (# y: @real do 3.14->y exit y #);
          p1: (# exit 3.14 #);
          x: @real; I: @integer
       do (# xxx: @char do  (300.0 * p, 942.0,'a')->chkR; #);
          (a.r * 3.14, 942.0,'b')->chkR;   
          (a.r * p, 942.0,'c')->chkR;
          a.r * p -> x;         
          (if (x > -0.0001) and (x < 0.0001) // true then error if);
          (300.0*3.14) div 180.0 -> x;
          (a.r * p1) div 180.0 -> y;
          (x,y,'d')->chkR;
          3.0->x;
          (1.11*x->I,3,'e')->chkR;
       #);
     again: 
       (# v: @real;  
          base: @integer; 
          ch: @char;
          sh: @int16u;
          I: @integer;
       do 10->base; 1->V; '9'->ch; 20->sh; 30->I;
          V*base+(ch-'0'->I)+sh->V; (V,39.0,'f')->chkR
       #);
     oneMore:
       (# x,r,a,y,tauNr: @real;    
          tau: external(# x: @real do exit x #); 
          rcopy: external(# x: @real enter x exit x #);
          inc: (# a1,a2: @real  enter(a1,a2) do (a1+a2,29.0,'g')->chkR #)
       do 2.0->x; 
          1.0->r->a;
          3.0->y;
          (x+r*tau*(a+tau)->rcopy, y+r*tau*(a+tau)->rcopy) -> inc;
       #);
     qword:
       (* datpete 6/7/95:
        * tst that real to integer store does not destroy next long.
        * Was a problem on NTI.
        *)
       (# X: @(# i, j: @integer #);
          r: @real;
       do 99 -> X.j;
          1.0 -> r;
          r -> X.i;
          (X.j,99,'h')->chk;
       #);
     tstFloatRangeAndExtend:
       (# R: [10(*10.1 float not allowed by checker*)] @integer; 
       do (if R.range = 10 then 'i'->put else error if);
          (# dummy:@char do R.range + R.range/2 -> R.extend; #);
          (if R.range = 25 then 'j'->put else error if)
       #);
     longAnd:
       (# cx,x0,cy,y0,midrsegx,x1,y1,midrsegy,x2,y2,midx23,midy23: @real
       do (if ((cx=x0) and 
             (cy=y0) and 
             (midrsegx=x1) and
             (midrsegy=y1) and 
             (midx23=x2) and 
             (midy23=y2) and 
             (cy=y0) and 
             (midrsegx=x1) and
             (midrsegy=y1) and   
             (midx23=x2) and 
              (midy23=y2))
           // true then (* test if register overflow *)  
          if)
       #);
     stackFloatRegs: 
       (# x: @real
       do 1/100 -> x;
          (# xxx: @char    
          do (((1.0/x) - (x->tan)) , 99.99, 'l') -> ChkR;  
             ((((1,1)->atan2)*360)/(pi*2),45.00,'m') -> ChkR;  
          #);
          (* the following don't work on hpux9pa;
           * on linux a similar eval. (FEJL/real2) cannot terminate
           *)   
          (# dummy: @char; 
          do (((((((1,1)->atan2)*360)/(pi*2))/45,
                ((((1,1)->atan2)*360)/(pi*2))/45) 
                -> atan2
               ) * 360 
              ) / (pi*2) -> x;
             (x,45,'n') -> chkR; 
          #);
       #); 
     tstGif:
       (# x,y: @real;
          snorf: (# u: @real do 3 -> u exit u #);
          
       do (if 3.0
           // 1 then '?' -> put 
           // 3 then 'o' -> put
           else
              error              
          if);
          3.0 -> x;
          (if x  
           // 1 then '?' -> put
           // 3 then 'p' -> put
           else error
          if);
          (if snorf
           // 1 then '?' -> put
           // 3 then 'q' -> put
           else error
          if);
          (if snorf -> y
           // 1 then '?' -> put
           // 3 then 'r' -> put
           else error
          if);  
       #);
     tstSimpleIf:
       (# x,y: @real
       do 3.11 -> x;
          6.12 -> y; 
          (if x < y  then 's' -> put else error if); 
          (if x <= y then 't' -> put else error if);
          (if x > y  then error else 'u' -> put if);
          (if x >= y then error else 'v' -> put if);
          (if x <> y then 'w' -> put else error if);
          (if x = y  then error else 'x' -> put if);

          6.12 -> x;
          (if x < y  then error else 'y' -> put if);
          (if x <= y then 'z' -> put else error if);
          (if x > y  then error else '0' -> put if);
          (if x >= y then '1' -> put else error if);
          (if x <> y then error else '2' -> put if);
          (if x = y  then '3' -> put else error if); 

          3.11 -> y;
          (if x < y  then error else '4' -> put if);
          (if x <= y then error else '5' -> put if);
          (if x > y  then '6' -> put else error if);
          (if x >= y then '7' -> put else error if);
          (if x <> y then '8' -> put else error if);
          (if x = y  then error else '9' -> put if);
       #);
     tstCstExp:
       (# x: @real
       do (-4.0) - (-8.0)-> x;
          (x,4.0,'a') -> chkR
       #);
     recursiveFloat:
       (# foo:
            (# n: @integer; x,y,z: @real
            enter n
            do 5.0 -> x; 2.0 -> y;
               (if n > 0 then
                   ((n-1) -> foo) + x/y -> z
                else
                   1.0 -> z;
               if)
            exit z
            #);
          x: @real
       do 15 -> foo -> x;
          (x,38.5,'b') -> chkR
       #);

     GlGeometric:
       (# power: @real;
          width: @Real;
       do 1.00 -> power;
          100 -> width;
          INNER;
          'd' -> put;
       #);
     GlEllipse: GlGeometric
       (# x, angle: @real;
       do 0 -> angle;
          (width / 2) * (angle -> cos) -> x;
          (x,50,'c') -> chk;
       #);
     real2intExternal:
       (# r1, r2, r3: @real;
          i: @integer;
          giveArg:  External(# a,b,c,d:@integer enter (a,b,c) exit d #);
          giveMe1Argument: giveArg(##);
          giveMe2Argument: giveArg(##);
          radd: external(# x,y: @real enter (x,y) exit x #); 
       do 1.0 -> r1;
          2.0 -> r2;
          3.0 -> r3;
          (r1,r2,r3) -> giveMe1Argument -> i;
          (i,1,'e') -> chk;
          (r1+r1,r2+r3,r3+1.0) -> giveMe2Argument -> i;
          (i,5,'f') -> chk;
          (r1,(r1,r2) -> radd,7.14) -> giveMe2Argument -> i;
          (i,3,'g') -> chk;   
       #);
     Save2floatonstack:
       (# port:
            (# value: @real
            enter value
            do
            exit value
            #);
          T,x0: @port;  
          mass,R,S,p: @real 
       do 2.0 -> mass;
          3.0 -> R;
          10.0 -> T;
          
          4.0 -> x0;
          5.0 -> S;
          
          mass*R*T / (x0*S)-> p;
          
          (p,3.0,'h') -> chkR;
       #);
     doinner:
       (# do inner #);
     realAndText: doinner
       (# chk: @chkR;
          end, omega: @real;
          F: ^text;
          pi: (# Exit 3.14159265358979323846 #);
       do pi->omega;
          (2*pi / omega,'simul')->(end,F[]);
          (end,2.0,'i') -> chk;
       #);     
     realSaveExtern:
       (# X,Y,R: @real; b: @boolean;
          rcopy: external(#R: @real enter R exit R #);
            XXX: (# x: @real do 3.14 -> x exit x #);
       do  10.0 -> X; 2.0 -> R;
          (X-R*R->rcopy) > (X / 2.0)-> b;
          (if b then 'j' -> put else error if);          
          (X-R*R->rcopy) > (X / 0.5)-> b;
          (if b then error else 'k' -> put if);
          0 -> X;
          (XXX-x*x,XXX+x*x) -> radd -> y;
          (y,6.28,'l') -> chkR 
       #)

  do 1.11->x; 2.22->y; x+y->z;   z-x->v;  
     (x,1.11,'a')->chkR; (v,2.22,'b')->chkR; (z,3.33,'c')->chkR;    
     1.66->v; 0.55->w; x+y+v-w->x; (x,4.44,'d')->chkR;        
     4.80->x; 4.08->y; 3.0->z; 0.33->v;
     (x+y)-(z+v)->x; (x,5.55,'e')->chkR;
     6->i; i->x; 
     (x+0.66,6.66,'f')->chkR; 
     (# dummy:@char do 7.49->x; #); (*used to be 7.99 - check rounding strategy*)
     (# dummy:@char do x->i; #);
     (# dummy:@char do i+0.77->x #);
     (# dummy:@char do (x,7.77,'g')->chkR; #);
     8->i; 0.88->x; (i+x,8.88,'h')->chkR;	 
     0.99->x; (9+x,9.99,'i')->chkR;
     10->x; (x,10,'j')->chkR;
     11->x; 10.101->y; x*y->z; (z,111.111,'k')->chkR;
     4.4->x; 977.7768->y; (y div x,222.222,'l')->chkR;
     2->x; 100->y; 6.66666->z; ((y*z) / x,333.333,'m')->chkR;
     111.111->x; 222.222->y;
     x<y->b; 
     (if b//true then 'n'->put else error if);
     x->y; (if x // y then 'o'->put else error if);
     x->z;  3.14->y; 3.141->v;
     (for ii: 4 repeat  
          (if x
           // y then 
              100->i; 11->j; 
              111.111111->y; ((i+j)+0.111111,y,'r')->chkR   
           // z then 'p'->put; x->v; 111.1111->z   
           // v then 'q'->put; x->y; 111.11111->v  
           else    
              3.14E5->x; -3.14E5->y; 111.5E-7->z; -111.5E-7->v;
              ((x+y)+(z+v),0,'s')->chkR;
     if)for); 
     x->y;
     (x<y,false,'t')->chkBool;
     (x<=y,true,'u')->chkBool; 
     (x>y,false,'v')->chkBool; 
     (x>=y,true,'w')->chkBool; 

     1010.1010E2->x; 1010.1010E3->y; 1010.1010E-2->z; x->v;
     (*  z < x=v < y *)
     ((x+(x-y))=(y+0),false,'x')->chkBool;
     (x=v,true, 'y')->chkBool;
     (x<>y,true,'z')->chkBool;   
     (x<>v,false,'0')->chkBool; 
     1100.0011->x; 11.11->y; 
     (x,11.11)->radd->z;   
     (z,1111.1111,'1')->chkR;      
     2200.0022->x; 22.22->y; ((x+(x-x),y)->radd,2222.2222,'2')->chkR; 
     11100.10101->R[1]; 11.0101->R[2]; 
     R[1]+R[2]->R[3]; (R[3],11111.11111,'3')->chkR;
     (for i:6 repeat 3.14E3*i->R[i] for);
     (for i:6 repeat (R[i],i*3.14E3,'3'+i)->chkR for); 
     'Real2' -> newl; 
     'a'-1->ch;
     tstSub;
     tstDiv;      
     'Real3' -> newl;  
     moreTsts;               (* 'abcde'   *)
     again;                  (* 'f'       *)
     oneMore;                (* 'g'       *)
     qword;                  (* 'h'       *)
     tstFloatRangeAndExtend; (* 'ij'      *)
     longAnd;                (* no output *)
     (* datpete 9/12/96: linux error reported by Kai Petzke: *)
     (if 0.0<0.0 then error else 'k'->put if);
     (if safeMode then
         stackFloatRegs;     (* 'l' - 'n' *)
      else
         '<backend:float exception>'->puttext
     if);
     tstGif;                 (* 'o' - 'r' *)
     tstSimpleIf;            (* 's' - '9' *)
     
     'Real4' -> newL;   (* line 4 *)
     tstCstExp;         (* 'a' *)
     recursiveFloat;    (* 'b' *)
     GlEllipse;         (* 'c' *)
     real2intExternal;  (* 'e'-'g' *)
     save2floatonStack; (* 'h' *)
     RealAndText;       (* 'i' *)
     realSaveExtern;    (* 'j'-'l' *)
     'm' -> fill
  #)

