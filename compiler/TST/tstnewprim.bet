ORIGIN 'tstenv';   
INCLUDE 'tstlib'
---Lib:attributes---
TstNewPrim:
  (* test of low level operations *)
  (# CHK:
       (# a,b: @integer; c: @Char
       enter(a,b,c)
       do (if a//b then c->put else error if)
       #);
    
     X,Y,Z: @integer;
     R,Rx: [3]@integer;
     
     testNewTypes: 
       (# ch: @
            (# ch: @char
            do (if ch = 'z' then
                   '0'-> ch
                else
                   ch+1 -> ch
               if)
            exit ch 
            #);
          I8: @int8;
          I8u: @int8u;
          I16: @int16;
          I16u: @int16u;
          I32: @int32;
          I32u: @int32u;
       do 'k'-1->ch.ch;
          (* Test special cases for int8, int8u: FIXME: missing *)
          (* Test special cases for int16, int16u *)
          2 -> I16; 
          (I16 %srl 1, 1, ch) -> CHK; (* 'k' *)
          (I16 %srl 2, 0, ch) -> CHK;
          (I16 %srl 3, 0, ch) -> CHK;
          (I16 %sra 1, 1, ch) -> CHK;
          (I16 %sra 2, 0, ch) -> CHK;
          (I16 %sra 3, 0, ch) -> CHK;
          0xffff -> I16; 
          (* All arithmetic is calculated as 32-bit values;
           * when loading I16, a sign extension is made,
           * i.e. we operate on 0xffffffff
           *)
          (I16 %srl 1, 0x7fffffff, ch) -> CHK; (* 'q' *)
          (I16 %srl 2, 0x3fffffff, ch) -> CHK;  
          (I16 %srl 3, 0x1fffffff, ch) -> CHK;
          (I16 %sra 1, 0xffffffff, ch) -> CHK;
          (I16 %sra 2, 0xffffffff, ch) -> CHK;
          (I16 %sra 3, 0xffffffff, ch) -> CHK;
          2 -> I16u;
          (I16u %srl 1, 1, ch) -> CHK;      (* 'w' *)
          (I16u %srl 2, 0, ch) -> CHK;
          (I16u %srl 3, 0, ch) -> CHK;
          (I16u %sra 1, 1, ch) -> CHK;
          (I16u %sra 2, 0, ch) -> CHK;      (* '0' *)
          (I16u %sra 3, 0, ch) -> CHK;
          0xffff -> I16u;
          (I16u %srl 1, 0x7fff, ch) -> CHK;  (* '2' *)
          (I16u %srl 2, 0x3fff, ch) -> CHK;  (* '3' *)
          (I16u %srl 3, 0x1fff, ch) -> CHK;  (* '4' *)
          (* I16u = 0x00ffff
           * when shifting right arithmetic 
           * NO bit is shifted in for the sign bit
           *)
          (I16u %sra 1, 0x7fff, ch) -> CHK;  (* '5' *)
          (I16u %sra 2, 0x3fff, ch) -> CHK;  (* '6' *)
          (I16u %sra 3, 0x1fff, ch) -> CHK;  (* '7' *)
          (* FIXME: Test %sll/%sla too *)
          
          (* What should the semantics of the following be? Should it be errors? *)
          (if false then
              (# c:@char;
              do 0x12345678 -> I32;
                 (17 -> I32.%getlong, 0, ch) -> CHK; (* longNo ignored for %getLong *)
                 (17 -> I32.%getshort, 0x5678, ch) -> CHK; (* shortNo modulus 2 *)
              #);
              
              (# c: @char;
              do 0x1234 -> I16;
                 0xffff -> I16u;
                 (0 -> I16.%getLong, 0x1234ffff (*???*), ch) -> CHK; (* Bus error on sparc *)
              #);
          if);
       #);
     
     tstSwap: 
       (# ch: @(# ch: @char; do ch+1 -> ch exit ch #);
          j,k:@int16u;
          i:@int32;
          r:[12]@int32;
       do 'a'-1->ch.ch;
          0x12345678->i;
          i.%ByteSwapLong;
          (i,0x78563412,ch)->CHK;  (* 'a' *)
          i.%ByteSwapLong;
          (i,0x12345678,ch)->CHK;  (* 'b' *)
          0x1234->j;
          0x5678->k;
          j.%ByteSwapShort;
          (j,0x3412,ch)->CHK;      (* 'c' *)
          j.%ByteSwapShort;
          (j,0x1234,ch)->CHK;      (* 'd' *)
          (*j.%ByteSwapLong; Will crash, check and complain 
           k.%ByteSwapLong;*)
          0x12345678->r[3];
          r[3].%ByteSwapLong;
          (r[3],0x78563412,ch)->CHK;     (* 'e' *)
          0x12345678->r[5];
          r[5].%ByteSwapShort;
          (if isBigEndian and not (isJvm or isCLR) then 
              (* Should this be machine dependant?
               * The short value of the int32 is not the 
               * first 16 bits in the 0x12345678 constant ??? 
               * OBS! Probably the wrong choice for JVM/CLR -
               * JVM is in general big endian but byteSwapShort
               * seems to be a little endian implementation,
               * see BCjavaBody
               *) 
              (r[5],0x34125678,ch)->CHK  (* 'f' *)
           else
              (r[5],0x12347856,ch)->CHK  (* 'f' *) 
          if); 
       #);
     PutGetByte: 
       (# 
       do -1->X;
          (12,2)->X.%putByte;  
          (2->X.%getByte,12,'a')->CHK;
          
          (1,0)->Z.%putByte;
          (2,1)->Z.%putByte;
          (4,2)->Z.%putByte;
          (8,3)->Z.%putByte;
          
          (* Little-endian problem with the following: 
           * (Z,(8 + 4*256 + 2*256*256 + 256*256*256),'b')->CHK;  
           *)
          (0->Z.%getByte,1,'b')->CHK;
          
          (0->Z.%getByte,1,'c')->CHK;
          (1->Z.%getByte,2,'d')->CHK;
          (2->Z.%getByte,4,'e')->CHK;
          (3->Z.%getByte,8,'f')->CHK;
       #);
     
     RepetitionPutGetByte:
       (# PutBytes:
            (# value, index: @integer;
               PutByte:
                 (# do (value,index)->R.%putByte #);
            do (for i: R.range*4 repeat      
                    'f'+i->value;
                    i-1 -> index;
                    PutByte;
               for);
            #);
          GetBytes:
            (# 
            do (for i: Rx.range*4 repeat 
                    i-1->Rx.%getByte-> put (* 'g-r'*)    
               for)
            #);
       do PutBytes;
          R->Rx;
          GetBytes;
       #);
     
     PutGetShort:
       (#
       do 
          (* putShort 's-t' *)
          (11111,0)->X.%putShort;
          (12222,1)->X.%putShort;
          (0->X.%getShort,11111,'s')->CHK;
          (1->X.%getShort,12222,'t')->CHK;
          (for i: R.range*2 repeat  
               ('t'+i,(i-1) (* *2 *))->R.%putShort (****<<<< OBS different inx*)
          for);
          (for i: R.range*2 repeat
               (i-1)(* *2 *) ->R.%getShort-> put (* 'u-z'*)
          for);
       #);
     
     PutGetLong:
       (#
       do (for i: R.range repeat
               ('0'+i-1,(i-1) (* *4 *))->R.%putLong
          for);
          (for i: R.range repeat
               (i-1) (* *4*) ->R.%getLong-> put (* '0-2'*)
          for); 
       #);
     
     RepetitionPutGetByte2:
       (# 
       do (for i:R.range repeat 0->R[i] for);
          
          ('3',0)->R.%putByte;
          ('4',1)->R.%putByte;
          ('5',2)->R.%putByte;
          ('6',3)->R.%putByte;
          
          ('7',1 (* 4 *))->R.%putLong;
          (* OBS paa sparc skal longs vaere 4-aligned *)
          ('8',4 (* 8 *))->R.%putShort;  
          ('9',5 (* 10 *))->R.%putShort;
          
          0->R.%getByte->put;  
          1->R.%getByte->put;
          2->R.%getByte->put; 
          3->R.%getByte->put;
          
          1 (* 4 *)->R.%getLong->put;  
          4 (* 8 *)->R.%getShort->put;
          5 (* 10 *)->R.%getShort->put;
       #);
     tstReps: 
       (# V,i: @integer; R: [3]@integer; ch: @char
       do 2->i;
          ('g',12,8) -> R[i].%putBits;
          (12,8) -> R[i].%getBits -> ch;
          ch -> put;
          'h'->V;
          (V,12,9) -> R[i].%putBits;
          (12,9) -> R[i].%getBits -> ch;
          ch -> put;
          2-> i;
          ('i',0) -> R[i].%putShort;
          0 -> R[i].%getShort -> ch;
          ch -> put;
          3-> i;
          ('j',0) -> R[i].%putShort;
          0 -> R[i].%getShort -> ch;   
          ch -> put;
       #);
     
     moreSwap:
       (# i: @int32;
       do 0x87654321 -> i; (* notice: has MSB set, i.e. negative; tests that correct shift is used *)
          i.%byteSwapLong;
          (i,0x21436587,'8')->CHK;
       #);
     shiftItem:
       (# doGet: @ (# a: @integer do 8 -> a; exit a #);
       do
          ((doGet %sll 4),128,'9') -> CHK
       #)
  do (if isPRE then '###'->puttext else
     PutGetByte;
     
     RepetitionPutGetByte;
     
     PutGetShort;
     
     PutGetLong; 
     
     RepetitionPutGetByte2;
     
     'NewPrim2' -> newl; 
     
     (if isbyteCodeMode then
         (-11,0)->X.%putByte;
         (-22,1)->X.%putByte;
         (33,2)->X.%putByte;
         (-44,3)->X.%putByte;
      else
         (-11) %putByteAt @@X; 
         (-22) %putByteAt (@@X+1); 
         (33) %putByteAt (@@X+2);
         (-44) %putByteAt (@@X+3);
     if);
     (0->X.%getSignedByte,-11,'a')->CHK;
     (1->X.%getSignedByte,-22,'b')->CHK;
     (2->X.%getSignedByte, 33,'c')->CHK;
     (3->X.%getSignedByte,-44,'d')->CHK;
     (for i:R.range repeat 0->R[i] for);
         
     (-111,0)->R.%putByte;
     (-122,1)->R.%putByte;
     (-4444,1(*2*))->R.%putShort;
     (-33333,1(*4*))->R.%putLong;
     (55,8)->R.%putByte;
     (-66,9)->R.%putByte;
     (1233,5(*10*))->R.%putShort;
         
     (0->R.%getSignedByte,-111,'e')->CHK;
     (1->R.%getSignedByte,-122,'f')->CHK;
     (1 (*2*)->R.%getSignedShort,-4444,'g')->CHK;
     (1 (*4*)->R.%getLong,-33333,'h')->CHK;     
     (8->R.%getSignedByte,55,'i')->CHK;
     (9->R.%getSignedByte,-66,'j')->CHK;
     (5(*10*)->R.%getSignedShort,1233,'k')->CHK;
     
     ((%bnot 111000111 + 1),-111000111,'l')->CHK;

     'q' %sll 16 + 'w' -> X;
     X %bAND (256*256*95+95) ->X;
     (if isBigEndian//true then
         (1->X.%getByte,'Q','m')->CHK; 
         (3->X.%getByte,'W','n')->CHK;
      else
         (2->X.%getByte,'Q','m')->CHK;
         (0->X.%getByte,'W','n')->CHK
     if);
     
     'E' %sll 16 + 'R' -> X;
     X %bOR (256*256*32+32)->X;
     (if isBigEndian//true then
         (1->X.%getByte,'e','o')->CHK;
         (3->X.%getByte,'r','p')->CHK;
      else
         (2->X.%getByte,'e','o')->CHK;
         (0->X.%getByte,'r','p')->CHK
     if);

     1->Y; (for i:24 repeat  Y*2->Y for);
     (26 %bxor 21,15,'q')->CHK; 
     (3 %sll 4,48,'r')->CHK;
     (1 %sll 24,Y,'s')->CHK;
     (1024 %srl  10,1,'t')->CHK;
     (3 %sla 4,48,'u')->CHK;
     (1024 %sra 10,1,'v')->CHK;
     (-1024 %sra 10,-1,'w')->CHK;
     0->X;
     (7,12,9)->X.%putBits;
     ((12,9)->X.%getBits,7,'x')->CHK; 
     ((12,9)->X.%getSignedBits,7,'y')->CHK;
     (if isBigEndian then
         ((18,3)->X.%getSignedBits,-1,'z')->CHK;
      else
         ((12,3)->X.%getSignedBits,-1,'z')->CHK;
     if);   
     (0->Z.%getByte,1,'0')->CHK;  
     (1->Z.%getByte,2,'1')->CHK;
     (2->Z.%getByte,4,'2')->CHK;
     (3->Z.%getByte,8,'3')->CHK;
     (if isByteCodeMode then
         '45'->puttext
      else (* not implementable of jvm/clr *)
         (* putShort '4-5' *)
         11111 %putShortAt @@X;
         12222 %putShortAt (@@X+2);   
         (0->X.%getShort,11111,'4')->CHK;
         (1->X.%getShort,12222,'5')->CHK;
     if);
     (* NB: adrGetSignedX is not tested Neither is adrGetLong *)
     
     ('6',0)->X.%putByte; ('7',1)->X.%putByte;
     ('8',2)->X.%putByte; ('9',3)->X.%putByte;
     (0,8)->X.%getBits->put; (8,8)->X.%getBits->put;
     (16,8)->X.%getBits->put; (24,8)->X.%getBits->put;
     
     'NewPrim3'->newl; 
     ('a',0,8)->X.%PutBits; ('b',8,8)->X.%PutBits;
     ('c',16,8)->X.%PutBits; ('d',24,8)->X.%PutBits;
     
     0->X.%getByte->put; 1->X.%getByte->put; 
     2->X.%getByte->put; 3->X.%getByte->put;
     
     (for i: 4 repeat ('d'+i,i-1)->X.%putByte for);
          
     (for i: 4 repeat i-1->X.%getByte->put for);
     (for i: 4 repeat ('h'+i,i+3)->X.%putByte for);
     (for i: 4 repeat i+3->X.%getByte->put for);
     
     1->X; 
     X %rol 8 -> x; 
     (X,256,'m')->CHK;
     X %ror 2 -> X; (X,64,'n')->CHK; 
     
     4->X;  32->Y;
     X %rol Y -> x; 
     
     (X,4,'o')->CHK; 
     1->X; 30->Y;
     X %ror Y -> X; (X,4,'p')->CHK;  
     
     (for i: 4 repeat
          (if i=3 then  
              8->Y; 
              (-12,(i-1)*8,Y)->X.%PutBits 
           else     
              ('p'+i,(i-1)*8,8)->X.%PutBits 
          if)
     for);
     (for i: 4 repeat 
          (if i=3 then
              (((i-1)*8,Y)->X.%GetSignedBits,-12,'s')->CHK 
           else
              ((i-1)*8,8)->X.%getBits->put
     if)for); 

     (if isByteCodeMode then
         'uvwxy' -> puttext
      else (* not implementable for jvm/clr *)
         (# XX: @integer;  
         do (-11) %putByteAt @@XX; XX->X;
            %getByteAt (@@X) -> Y;
            (245,Y,'u')->CHK;
            %getSignedByteAt (@@X) -> Y;
            (-11,Y,'v')->CHK;
            (-222) %putShortAt @@XX; XX->X;
            %getShortAt (@@X) -> Y;
            (65314,Y,'w')->CHK;
            %getSignedShortAt (@@X) -> Y;
            (-222,Y,'x')->CHK;
            (12345) %putLongAt (@@X); X->XX;
            %getLongAt (@@X) -> Y; 
            (12345,Y,'y')->CHK;   
         #);
     if);
     (if isBigEndian then
         0x01020499 -> X
      else 
         0x99040201 -> X
     if);
     0 -> Y;
     (Y->X.%getByte,1,'z')->CHK;
     1 -> Y;
     (Y->X.%getByte,2,'0')->CHK;
     2 -> Y;
     (Y->X.%getByte,4,'1')->CHK;
     3 -> Y;
     (Y->X.%getByte,0x99,'2')->CHK;
     
     (if isBigEndian then
         0x0000FFFF -> X
      else
         0xFFFF0000 -> X
     if);
     0 -> Y; 
     (Y -> X.%getShort,0,'3') -> CHK;
     1 -> Y;
     (Y -> X.%getShort,0xFFFF,'4') -> CHK;
     
     (# S: [10] @char; n: @integer
     do (for i: 10 repeat 'a'-1+i -> S[i] for);
        6 -> n; (* 1st byte is no. 0 *)
        (n->S.%getByte,'g','5') -> CHK;
        3 -> n; 
        (if isBigEndian then
            'g' * 256 + 'h' -> X
         else
            'h' * 256 + 'g' -> X
        if);
        (if isByteCodeMode then
            '6' -> put
         else (* S.%getShort on a char rep! *)
            (n->S.%getShort,X,'6') -> CHK;
        if)
     #);         
         
     (# s: [4] @integer; i,b,x: @integer
     do 0x00a00000 -> s[3]; 3 -> i; 
        (if isBigEndian then 1 -> b else 2 -> b if);
        b -> S[i].%getByte -> x;
        (if x = 0xa0 then '7' -> put else error if)
     #);
     
     '8'->fill;
     'NewPrim4'->newL;
     tstSwap; (* 'a' - 'f' *)
     tstReps;
     testNewTypes; 
     moreSwap; (* 8 *)
         shiftItem; (* 9 *)
     if)
  #)

