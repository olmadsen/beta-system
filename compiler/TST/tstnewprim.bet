ORIGIN 'tstenv';  
INCLUDE 'tstlib'
---Lib:attributes---
TstNewPrim:
  (* test of low level operations *)
  (# CHK:
       (# a,b: @integer; c: @Char
       enter(a,b,c)
       do (if a//b then c->put else '!'->put if)
       #);
     
     X,Y,Z: @integer;
     R,Rx: [3]@integer;
     
     testNewTypes: 
       (# ch: @(# ch: @char; do ch+1 -> ch exit ch #);
          I8: @int8;
          I8u: @int8u;
          I16: @int16;
          I16u: @int16u;
          I32: @int32;
          I32u: @int32u;
       do 'a'-1->ch.ch;
          (* Test special cases for int8, int8u: FIXME: missing *)
          (* Test special cases for int16, int16u *)
          2 -> I16;
          (I16 %srl 1, 1, ch) -> CHK; (* a *)
          (I16 %srl 2, 0, ch) -> CHK;
          (I16 %srl 3, 0, ch) -> CHK;
          (I16 %sra 1, 1, ch) -> CHK;
          (I16 %sra 2, 0, ch) -> CHK;
          (I16 %sra 3, 0, ch) -> CHK;
          0xffff -> I16;
          (I16 %srl 1, 0x7fff, ch) -> CHK; (* g *)
          (I16 %srl 2, 0x3fff, ch) -> CHK;
          (I16 %srl 3, 0x1fff, ch) -> CHK;
          (I16 %sra 1, 0xffff, ch) -> CHK;
          (I16 %sra 2, 0xffff, ch) -> CHK;
          (I16 %sra 3, 0xffff, ch) -> CHK;
          2 -> I16u;
          (I16u %srl 1, 1, ch) -> CHK;      (* m*)
          (I16u %srl 2, 0, ch) -> CHK;
          (I16u %srl 3, 0, ch) -> CHK;
          (I16u %sra 1, 1, ch) -> CHK;
          (I16u %sra 2, 0, ch) -> CHK; 
          (I16u %sra 3, 0, ch) -> CHK;
          0xffff -> I16u;
          (I16u %srl 1, 0x7fff, ch) -> CHK;  (* s *)
          (I16u %srl 2, 0x3fff, ch) -> CHK;  (* t *)
          (I16u %srl 3, 0x1fff, ch) -> CHK;  (* u *)
          (I16u %sra 1, 0xffff, ch) -> CHK;  (* v *)
          (I16u %sra 2, 0xffff, ch) -> CHK;  (* w *)
          (I16u %sra 3, 0xffff, ch) -> CHK;  (* x *)
          (* FIXME: Test %sll/%sla too *)
          
          (* What should the semantics of the following be? Should it be errors? *)
          (if false then
              (# c:@char;
              do 0x12345678 -> I32;
                 (17 -> I32.%getlong, 0, ch) -> CHK; (* longNo ignored for %getLong *)
                 (17 -> I32.%getshort, 0x5678, ch) -> CHK; (* shortNo modulus 2 *)
              #);
              
              (# c: @char;
              do 0x1234 -> I16;
                 0xffff -> I16u;
                 (0 -> I16.%getLong, 0x1234ffff (*???*), ch) -> CHK; (* Bus error on sparc *)
              #);
          if);
          ch -> fill;
          
       #);
     
     ZZ: (# do exit @@X #);
     tstSwap:
       (# ch: @(# ch: @char; do ch+1 -> ch exit ch #);
          j,k:@int16u;
          i:@int32;
          r:[12]@int32;
       do 'a'-1->ch.ch;
          0x12345678->i;
          i.%ByteSwapLong;
          (i,0x78563412,ch)->CHK;
          i.%ByteSwapLong;
          (i,0x12345678,ch)->CHK;
          0x1234->j;
          0x5678->k;
          j.%ByteSwapShort;
          (j,0x3412,ch)->CHK;
          j.%ByteSwapShort;
          (j,0x1234,ch)->CHK;
          (*j.%ByteSwapLong; Will crash, check and complain 
           k.%ByteSwapLong;*)
          0x12345678->r[3];
          r[3].%ByteSwapLong;
          (r[3],0x78563412,ch)->CHK;
          0x12345678->r[5];
          r[5].%ByteSwapShort;
          (if isBigEndian then 
              (* must this be machine dependant?
               * The short value of the int32 is not the 
               * first 16 bits in the 0x12345678 constant ??? 
               *)
              (r[5],0x34125678,ch)->CHK
           else
              (r[5],0x12347856,ch)->CHK
          if); 
          ch->fill;
       #);
  do -1->X;
     (12,2)->X.%putByte;  
     (2->X.%getByte,12,'a')->CHK;
     
     (1,0)->Z.%putByte;
     (2,1)->Z.%putByte;
     (4,2)->Z.%putByte;
     (8,3)->Z.%putByte;
     
     (* Little-endian problem with the following: 
      * (Z,(8 + 4*256 + 2*256*256 + 256*256*256),'b')->CHK;  
      *)
     (0->Z.%getByte,1,'b')->CHK;
     
     (0->Z.%getByte,1,'c')->CHK;
     (1->Z.%getByte,2,'d')->CHK;
     (2->Z.%getByte,4,'e')->CHK;
     (3->Z.%getByte,8,'f')->CHK;
       
     (for i: R.range*4 repeat     
          ('f'+i,i-1)->R.%putByte
     for);
     R->Rx;
     (# dum: @integer
     do (for i: Rx.range*4 repeat 
               i-1->Rx.%getByte-> put (* 'g-r'*)    
     for)#);  
     
     (* putShort 's-t' *)
     (11111,0)->X.%putShort;
     (ZZ,12222)->TOS'%putShort[1]';
     (0->X.%getShort,11111,'s')->CHK;
     (1->X.%getShort,12222,'t')->CHK;
     
     (for i: R.range*2 repeat  
          ('t'+i,(i-1) (* *2 *))->R.%putShort (****<<<< OBS different inx*)
     for);
     (for i: R.range*2 repeat
          (i-1)(* *2 *) ->R.%getShort-> put (* 'u-z'*)
     for);
     (for i: R.range repeat
          ('0'+i-1,(i-1) (* *4 *))->R.%putLong
     for);
     (for i: R.range repeat
          (i-1) (* *4*) ->R.%getLong-> put (* '0-2'*)
     for);
     
     (for i:R.range repeat 0->R[i] for);
     
     ('3',0)->R.%putByte;
     ('4',1)->R.%putByte;
     ('5',2)->R.%putByte;
     ('6',3)->R.%putByte;
     ('7',1 (* 4 *))->R.%putLong;
     (* OBS paa sparc skal longs vaere 4-aligned *)
     ('8',4 (* 8 *))->R.%putShort;  
     ('9',5 (* 10 *))->R.%putShort;
     
     0->R.%getByte->put;  
     1->R.%getByte->put;
     2->R.%getByte->put;
     3->R.%getByte->put;
     1 (* 4 *)->R.%getLong->put;  
     4 (* 8 *)->R.%getShort->put;
     5 (* 10 *)->R.%getShort->put;
     
     'NewPrim2' -> newl; 
     (*     (-11,0)->X.%putByte;
      (-22,1)->X.%putByte;
      (33,2)->X.%putByte;
      (-44,3)->X.%putByte;
      *)

     (-11) %putByteAt @@X;
     (-22) %putByteAt (@@X+1);
     (33) %putByteAt (@@X+2);
     (-44) %putByteAt (@@X+3);

     (0->X.%getSignedByte,-11,'a')->CHK;
     (1->X.%getSignedByte,-22,'b')->CHK;
     (2->X.%getSignedByte, 33,'c')->CHK;
     (3->X.%getSignedByte,-44,'d')->CHK;
     
     (for i:R.range repeat 0->R[i] for);
     
     (-111,0)->R.%putByte;
     (-122,1)->R.%putByte;
     (-4444,1(*2*))->R.%putShort;
     (-33333,1(*4*))->R.%putLong;
     (55,8)->R.%putByte;
     (-66,9)->R.%putByte;
     (1233,5(*10*))->R.%putShort;
     
     (0->R.%getSignedByte,-111,'e')->CHK;
     (1->R.%getSignedByte,-122,'f')->CHK;
     (1 (*2*)->R.%getSignedShort,-4444,'g')->CHK;
     (1 (*4*)->R.%getLong,-33333,'h')->CHK;     
     (8->R.%getSignedByte,55,'i')->CHK;
     (9->R.%getSignedByte,-66,'j')->CHK;
     (5(*10*)->R.%getSignedShort,1233,'k')->CHK;
     
     ((%bnot 111000111 + 1),-111000111,'l')->CHK;
     
     'q' %sll 16 + 'w' -> X;
     X %bAND (256*256*95+95) ->X;
     (if isBigEndian//true then
         (1->X.%getByte,'Q','m')->CHK;
         (3->X.%getByte,'W','n')->CHK;
      else
         (2->X.%getByte,'Q','m')->CHK;
         (0->X.%getByte,'W','n')->CHK
     if);
     
     'E' %sll 16 + 'R' -> X;
     X %bOR (256*256*32+32)->X;
     (if isBigEndian//true then
         (1->X.%getByte,'e','o')->CHK;
         (3->X.%getByte,'r','p')->CHK;
      else
         (2->X.%getByte,'e','o')->CHK;
         (0->X.%getByte,'r','p')->CHK
     if);

     1->Y; (for i:24 repeat  Y*2->Y for);
     (26 %bxor 21,15,'q')->CHK; 
     (3 %sll 4,48,'r')->CHK;
     (1 %sll 24,Y,'s')->CHK;
     (1024 %srl  10,1,'t')->CHK;
     (3 %sla 4,48,'u')->CHK;
     (1024 %sra 10,1,'v')->CHK;
     (-1024 %sra 10,-1,'w')->CHK;
     
     0->X;
     (7,12,9)->X.%putBits;
     ((12,9)->X.%getBits,7,'x')->CHK; 
     ((12,9)->X.%getSignedBits,7,'y')->CHK;
     (if isBigEndian then
         ((18,3)->X.%getSignedBits,-1,'z')->CHK;
      else
         ((12,3)->X.%getSignedBits,-1,'z')->CHK;
     if); 
     
     (0->Z.%getByte,1,'0')->CHK;  
     (1->Z.%getByte,2,'1')->CHK;
     (2->Z.%getByte,4,'2')->CHK;
     (3->Z.%getByte,8,'3')->CHK;
     (* putShort '4-5' *)
     11111 %putShortAt @@X;
     12222 %putShortAt (@@X+2);   
     (0->X.%getShort,11111,'4')->CHK;
     (1->X.%getShort,12222,'5')->CHK;
     
     (* NB: adrGetSignedX is not tested Neither is adrGetLong *)

     ('6',0)->X.%putByte; ('7',1)->X.%putByte;
     ('8',2)->X.%putByte; ('9',3)->X.%putByte;
     (0,8)->X.%getBits->put; (8,8)->X.%getBits->put;
     (16,8)->X.%getBits->put; (24,8)->X.%getBits->put;
     
     'NewPrim3'->newl; 
     ('a',0,8)->X.%PutBits; ('b',8,8)->X.%PutBits;
     ('c',16,8)->X.%PutBits; ('d',24,8)->X.%PutBits;
      
     0->X.%getByte->put; 1->X.%getByte->put;
     2->X.%getByte->put; 3->X.%getByte->put;


     (for i: 4 repeat ('d'+i,i-1)->X.%putByte for);
 
     (for i: 4 repeat i-1->X.%getByte->put for);
     (for i: 4 repeat ('h'+i,i+3)->X.%putByte for);
     (for i: 4 repeat i+3->X.%getByte->put for);

     1->X; 
     X %rol 8 -> x; (X,256,'m')->CHK;
     X %ror 2 -> X; (X,64,'n')->CHK; 
     
     4->X;  32->Y;
     X %rol Y -> x; (X,4,'o')->CHK; 
     1->X; 30->Y;
     X %ror Y -> X; (X,4,'p')->CHK;  
     (# dummy: @char;
     do (for i: 4 repeat
             (if i=3 then  
                 8->Y;
                 (# dummy:@char 
                 do (-12,(i-1)*8,Y)->X.%PutBits;
                 #);
              else     
                 (# dummy:@char 
                 do ('p'+i,(i-1)*8,8)->X.%PutBits;
                 #);
             if)
        for);
        (for i: 4 repeat
             (if i=3 then
                 (# dummy:@char 
                 do (((i-1)*8,Y)->X.%GetSignedBits,-12,'s')->CHK;
                 #);
              else
                 (# dummy:@char
                 do ((i-1)*8,8)->X.%getBits->put
                 #);
             if)
        for);   
     #);
     (# XX: @integer;  
     do (-11) %putByteAt @@XX; XX->X;
        %getByteAt (@@X) -> Y;
        (245,Y,'u')->CHK;
        %getSignedByteAt (@@X) -> Y;
        (-11,Y,'v')->CHK;
        (-222) %putShortAt @@XX; XX->X;
        %getShortAt (@@X) -> Y;
        (65314,Y,'w')->CHK;
        %getSignedShortAt (@@X) -> Y;
        (-222,Y,'x')->CHK;
        (12345) %putLongAt (@@X); X->XX;
        %getLongAt (@@X) -> Y; 
        (12345,Y,'y')->CHK;   
     #);
     (if isBigEndian then
         0x01020499 -> X
      else 
         0x99040201 -> X
     if);
     0 -> Y;
     (Y->X.%getByte,1,'z')->CHK;
     1 -> Y;
     (Y->X.%getByte,2,'0')->CHK;
     2 -> Y;
     (Y->X.%getByte,4,'1')->CHK;
     3 -> Y;
     (Y->X.%getByte,0x99,'2')->CHK;
       
     (if isBigEndian then
         0x0000FFFF -> X
      else
         0xFFFF0000 -> X
     if);
     0 -> Y; 
     (Y -> X.%getShort,0,'3') -> CHK;
     1 -> Y;
     (Y -> X.%getShort,0xFFFF,'4') -> CHK;
     
     (# S: [10] @char; n: @integer
     do (for i: 10 repeat 'a'-1+i -> S[i] for);
        6 -> n; (* 1st byte is no. 0 *)
        (n->S.%getByte,'g','5') -> CHK;
        3 -> n;
        (if isBigEndian then
            'g' * 256 + 'h' -> X
         else
            'h' * 256 + 'g' -> X
        if);
        (n->S.%getShort,X,'6') -> CHK;
     #);
     
     (# s: [4] @integer; i,b,x: @integer
     do 0x00a00000 -> s[3]; 3 -> i; 
        (if isBigEndian then 1 -> b else 2 -> b if);
        b -> S[i].%getByte -> x;
        (if x = 0xa0 then '7' -> put else '!' -> put if)
     #);
     '8'->fill;
     'NewPrim4'->newL;
     tstSwap;
     (* newl; testNewTypes; - will crash *)
  #)

