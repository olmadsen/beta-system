origin 'tstenv';
include 'tstlib'
---lib:attributes---
tstInlineNX:
  (# add1: 
       (# a,b: @integer
       enter(a,b)
       exit a+b
       #);
     add2:
       (# a: @integer
       enter a
       exit a + b
       #);
     tab: @
       (# R: [12] @integer;
          Get:
            (# v,i: @integer     
            enter i
            exit R[i+b]
            #)
       #); 
     sub1:
       (# a,b: @integer;
          X: (# c: @integer  
             enter c
             exit a-b+c
             #)
       enter(a,b)
       exit 5->X
       #);
     XXX: 
       (# c: @integer
       enter c
       exit c-11
       #);
     foo2:
       (# a,b: @integer
       enter(a,b)
       exit a+b->XXX
       #);
     bar: 
       (# a,b,c: @integer;
          X: (# d: @integer  
             enter d
             exit a+b*2+c+d
             #)
       enter(a,b,c)
       #);
     bar1: bar(# exit 2->X #);
     formatRot:
       (# rA,rS,SHorRb,MB,ME: @integer;
          X: (# op: @integer
             enter op
             exit op + ME - SHorRb   (* 'a' + 31 - 28 = *)
                  + (rA + rS)*MB - 3 (* 3*3 - 3*)
             #)  
       enter (rA,rS,SHorRb,MB,ME)
          (*   1, 2,    28, 3,31 *)
       #);     
     rlwinm: formatRot(# exit 'a' -> X #);     

     SRWI:   
       (# rA, rS,SH: @integer;  
       enter(rA,rS,SH)
       exit
          (rA,rS,32-SH,SH,31) -> RLWINM
          (*1, 2,   28, 3,31)*)
       #);

     a,b,c: @integer;
     ck: @chk;
     double:
       (# a: @integer
       enter a
       exit (a+a) (* datareg negative *)
       #);
     tooMuch: (# q1,q2,q3,q4: @ integer
              enter(q1,q2,q3,q4)
              exit (a+b) * ((a+b) * ((a+b) * ((a+b) * (((a+b) *(a+b))))))
              #);
     static: (# a,b: @integer
             enter(a,b)
             exit a+b
             #);
     static2: @ (# exit a+b #);
     static3: (# exit static2 + 1#);
     
     foo: (# do static3 -> put #)
  do (for i: 1 repeat
          (11,22) -> add1 -> a; (a,33,'a') -> ck;                (* a *)
          33->a; (a,44) -> add1 -> a;  (a,77,'b') -> ck;         (* b *)
          55->b; (a,b) -> add1 -> b; (b,132,'c') -> ck;          (* c *)
          'a' -> b; 3 -> add2 -> a; a->put;                      (* d *)
          3->b; 2->a; 'e'->tab.R[5]; a -> tab.Get -> c; c->put;  (* e *)
          ('g',6) -> sub1 -> c; c -> put;                        (* f *)
          ('e',13) -> foo2 -> c; c -> put;                       (* g *)
          ('a',2,1) -> bar1 -> c; c -> put;                      (* h *)
          (1,2,3) -> SRWI -> c; c -> put;                        (* i *)
          ('i',1) -> static -> put;                              (* j *)
          'h' -> a; 3 -> b; static2 -> put;                      (* k *)
          static3 -> put;                                        (* l *)
          (i,i,i,i) -> tooMuch -> c;
          i -> double ->  c;
     for)
  #)  
---program:descriptor--
(#  
do 'InlineNX' -> newL;
   tstInlineNX;     
#)



