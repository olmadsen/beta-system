ORIGIN 'tstenv';
LIB_ITEM 'tstenv'; 

BUILD   jvm 
        'jvm/beta/Component.class' 
        '$(BETALIB)/basiclib/private/external/Component.java' 
        'javac -classpath jvm -d jvm $1';
OBJFILE jvm
        'jvm/beta/Component$Runner.class';

---LIB:attributes---
String: externalclass
  (# 
  do 'java/lang/String' -> classname;
  #);
PrintStream: externalClass
  (# print: proc
       (# ch: @char
       enter ch
       #)
  do 'java/io/PrintStream' -> className
  #);
SetArgValues: 
  (# program_name: ^String;
     args: [0]^String;
  enter (program_name[],args)
  do args.range+1 -> ArgVector.new (* +1 to add program name *);
     program_name[] -> ArgVector[1][] (* Automatic conversion String->Text *);
     (for i:args.range repeat
          args[i][] -> ArgVector[i+1][]; (* Automatic conversion String->Text *)
     for)
  #);

---put:doPart---
do (* We want to print to System.out.
    * Cannot call print method of the above declared PrintStream class
    * since this requires us to get the static 'java.lang.System.out' field.
    * This could be done using reflection, or by using a helper class as in
    * betaenv_jvmbody, but this is too complex to tstenv, which is supposed to 
    * be simple (at this stage - 'put' is one of the axioms).
    * The call of the external below only works due to a dreadfull hack in 
    * the compiler: Whenever an External is called, and this is specified to
    * be a method of java.lang.PrintStream, the java.lang.System.out field
    * is loaded before calling the method!
    * See handling of bytecode callExternal in BCJavaBody.
    *)
   (# write: External   
        (# ch: @char
        enter ch 
        do 'java/io/PrintStream/print(C)V' -> callC 
        #);
   do ch -> write           
   #)    
---newline:doPart---
do '\n' -> put
   
---isPlatform:descriptor---
(# 
do (*'\nMissing: machine_type -> MT; ' -> putline*)
   'jvm' -> MT
#)

