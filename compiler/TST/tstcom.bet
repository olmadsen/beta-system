ORIGIN 'tstenv';      
INCLUDE 'tstlib';
BUILD default '$$/ctstcom.o' 'ctstcom.c' '\$CC -g -c -o $0 $1'     
nti     '$$/ctstcom.obj' 'ctstcom.c' 'betacc $0 $1';     
---lib:attributes---
tstCOM:
  (* tst patterns for COM interface *)
  (# test: (# exit false #); 
     
     myData: data
       (# x: @int32;
          s: @int16;     
          c: @char
       enter(x,s,c)
       exit(x,s,c)   
       #);
     myBigData: data
       (# x: @int32;
          y: @int32;
          s: @int16;     
          c: @char
       enter(x,s,c)
       exit(x,s,c)   
       #);
     (******************************************** 
      * Definitions for interfacing to external 
      * COM class imported to BETA     
      ********************************************)
     xCOMclass: COM
       (* Interface to external COM class *)
       (# f1:< 
            (# n: @integer; ch: @char
            enter n   
            exit ch      
            #);  
          f2:<   
            (# a,b,c: @integer; ch: @char
            enter(a,b,c)
            exit ch
            #);
          f3:<
            (# t: [1] @char; ix: @integer; ch: @char
            enter(t,ix)
            exit ch
            #);
          f4:<
            (# t,s: [1] @char; ix: @integer
            enter(ix,t)
            exit s
            #);
          f5:<
            (# S: ^myData; ch: @char;
            enter S[]
            exit ch
            #);
          f6:<  
            (# q: @myData; c: @char
            enter q
            exit c
            #);
          f7:<
            (# a: @integer; b: @integer; c: @integer;   
               res: @myData;
            enter(a,b,c)
            exit res 
            #);
          f8:< 
            (# a: @integer; b: @integer; c: @integer;   
               res: @myBigData;
            enter(a,b,c)
            exit res 
            #);
          f9:<
            (# a,b: @integer; S: @myData; c: @char
            enter(a,S,b)
            exit c
            #)
       #);
     GetXobj:   
       (* external function to import instance of xXOMclass *)
       external (# xR: ^xCOMclass exit xR[] #);
          
     (******************************************
      * definitions of COMclass implemented in 
      * BETA and exported to external language 
      * *****************************************)
     bCOMclass: COM 
       (* COM class implemented in BETA *)
       (# g0:<    
            (#    
            do 'g'-> chx -> put;
            #);
          g1:<  
            (# c: @integer (* char dont work - stores long instead of byte*)
            enter c 
            do (if test then 
                   '  bCOMclass::g1: '->puttext; c -> putint; newline if); 
               c -> put; (* 'h' *)
            #);
          g2:< 
            (# a,b,c: @integer     
            enter(a,b,c)
            do (if test then '  bCOMclass::g2'->putline if);
               a+b+c -> val;
               (if val = 111 then ch (* 'i' *) -> put else '!' -> put if);
            exit 117
            #);
          g3:< 
            (# s: [1] @char; r: @integer 
            enter s 
            do (if test then '  bCOMclass::g3'->putline if); 
               s -> puttext; 
               S -> str;
               str.range -> r (* 'jk' *)
            exit r 
            #);
          g4:<
            (# a,b,c,d,e,f,g,h: @integer
            enter(a,b,c,d,e,f,g,h)
            do (if (a = 111) and (h = 118) then
                   ch -> put (* 'l' *)
                else '!' -> put    
               if); 
               (if test then
                   '\n   '->puttext; a -> putint; 
                   ' '->put; b -> putint;    
                   ' '->put; c -> putint; 
                   ' '->put; d -> putint; 
                   ' '->put; e -> putint; 
                   ' '->put; f -> putint; 
                   ' '->put; g -> putint; 
                   ' '->put; h -> putint; 
               if)
            #);
          foo: data 
            (# x: @integer; y,z: @int16; v: @integer; w: @char #);
          g5:<
            (* prints 'm' and 'n' *)
            (# V: @foo
            enter V
            do (if test then 
                   '\nG5:   '->puttext; V.x -> putint;
                   ' ' -> put; v.z -> putint; 
                   ' ' -> put; V.w -> put;
                   newline
               if);
               (if V.x = 999 then ch -> put (* 'm' *) else '!' -> put if);
               (if (V.y = 77) and (V.z = -88) 
                   and (V.v = 1010) and (V.w = '*') then
                   ch -> put (* 'n' *)
                else '!' -> put
               if);
            #);
          QQ: @myData;
          g6:<
            (# S: ^bComClass; x: @char
            enter(S[],x)
            do (if x = '%' then
                   ch -> put
                else 
                   '!'->put 
               if);
               S.ch -> put;
               1199 -> QQ.x;
               
               (# x: @char do QQ[] -> xR.f5 -> x ; x -> put#)
            #);  
          g7:< (# <<SLOT tstcom_g7:doPart>> #);
          ch:<   
            (# c: @char  
            do chx + 1 -> chx -> c -> c 
            exit c  
            #);
          chx: @char;
          val: @integer;
          str: [1] @ char
       #);
     PutBobj:  
       (* external function to export instance of bCOMclass *)
       external(# bR: ^bCOMclass enter bR[]  #);
       
     (********** using xCOMclass and bCOMclass *******)
     xR: ^xCOMclass;
     ch: @char;
     T: [1] @char;
     mD: @myData;
     II: @integer;
     koks: (# a: @integer do 1013 -> a exit a #);
     
     IfragClass: COM
       (# h1:< (# do inner #);
          h2:< (# <<SLOT tstcom_h2:doPart >> #);
          h3:< (# <<SLOT tstcom_h3a:doPart >> #);
       #);
     fragClass: IfragClass
       (# h1::< (# <<SLOT tstcom_h1:doPart>>#);
          h2::< (# do 'x'->put #);
          h3::< (# <<SLOT tstcom_h3b:doPart>> #)
       #);
     fc: ^IfragClass
  do GetXobj -> xR[]; 
     1013 -> xR.f1 -> ch;           ch -> put;    (* 'a' *)
     (* koks -> xR.f1 -> ch;           ch -> put;    (* 'a' *)
     (10,20,2) -> xR.f2 -> ch;      ch -> put;    (* 'b' *)
     (* (koks,20,2) -> xR.f2 -> ch;      ch -> put;    (* 'b' *)
     ('!$c?d#',2) -> xR.f3 -> ch;   ch -> put;    (* 'c' *)
     (4,'....d....') -> xR.f4 -> T; T -> puttext; (* 'def' *)

     &bCOMclass[] -> PutBobj;       (* 'ghijklmnopqr' *)
     6060-> mD.x;  
     7070-> mD.s;
     's' -> mD.c;   
     (if false (*isBigEndian*) then
         '[!]'-> puttext
      else
         (# x: @char do   mD -> xR.f6 -> put; #) (* 's' *)  
     if);
     
     (if not isBigEndian then
         (# cc: @Char;
            mDB: @myBigData;
         do
            (# x: @char 
            do (8080,9090,'#') -> xR.f8 -> mDB;
            #);
            (if (mDB.x=8080+1234)  
                and (mDB.y=0x87654321) 
                and (mDB.s=321) then
                mDB.c->put;
             else 
                '!'->put;
            if); 
            (8080,9090,'#') -> xR.f7 -> mD;
         #);  
     if);
         
     (if test then
         mD.x -> putint; ' ' -> put;  
         mD.s -> putint; ' ' -> put;
         mD.c -> put;
         newline;   
     if);
     (if (mD.x = 8080+1234) and (mD.s = 321) then
         mD.c -> put
      else 
         '!'->put
     if);
     &fragClass[] -> fc[];
     fc.h1;
     fc.h2;
     fc.h3;
     6060 -> mD.x;
     7070 -> mD.s;
     '0' -> mD.c;
     (6060,mD,7070) -> xR.f9 -> put;
     '1' -> fill;
  #)
---tstcom_g7:dopart---
do 'r'->put
    
---tstcom_h1:doPart---
do 'v' -> put; 'w'->ch;
---tstcom_h2:doPart---
do ch -> put; inner h2
---tstcom_h3a:doPart---
do 'y' -> put; 'z' -> ch; inner h3
---tstcom_h3b:doPart---
do ch -> put
   
