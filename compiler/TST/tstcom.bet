ORIGIN 'tstenv';       
INCLUDE 'tstlib';
INCLUDE 'tstholder';
BUILD 
default '$$/ctstcom.o' 'ctstcom.c' '\$CC -g -c -o $0 $1'     
linux   '$$/ctstcom.o' 'ctstcom.c' 'gcc -O6 -Wall -g -c -o $0 $1'     
nti     '$$/ctstcom.obj' 'ctstcom.c' 'betacc $0 $1'
ppcmac	':$$:ctstcom.obj' 'ctstcom.c'  'mrc -w 35 -o $0 $1'
---lib:attributes---

test: (# exit false #); 

tstComAndHolder:
  (# 
  do (if true
      // isHpux9pa AND NOT SafeMode then
         '\n****** tstcom/holder does NOT work for hpux9pa' -> puttext;
      // isSun4s  then
         (if not SafeMode then
             '****** tstcom does not work completely for sun4s' -> puttext;
             dotstcom;
             '   Error in "...qr!tu..."' -> puttext;
         if);
         (if not safeMode then
             (* fails with unconditional GC *)
             'Tstholder' -> newl; tstholder
         if);
      // isSgi AND NOT SafeMode then
         '****** tstcom does not work for sgi' -> puttext;
      // isPpcmac AND NOT SafeMode then
         '****** tstcom/holder does NOT work for ppc' -> puttext;
      // isLinux then
         dotstcom;
         (if safeMode then
             (* tstholder gives segmentation fault with
              * unconditional GC 
              *)
          else
             'Tstholder' -> newl; tstholder          
         if);
      // isNTI then
         dotstcom;
         'Tstholder' -> newl; tstholder          
     if);
  #);

myData: data
  (# x: @int32;
     s: @int16;     
     c: @char
  enter(x,s,c)
  exit(x,s,c)   
  #);
myBigData: data
  (# x: @int32;
     y: @int32;
     s: @int16;     
     c: @char
  enter(x,s,c)
  exit(x,s,c)   
  #);
(******************************************** 
 * Definitions for interfacing to external 
 * COM class imported to BETA     
 ********************************************)
xCOMclass: COM
  (* Interface to external COM class *)
  (# f1:< 
       (# n: @integer; ch: @char
       enter n   
       exit ch      
       #);  
     f2:<   
       (# a,b,c: @integer; ch: @char
       enter(a,b,c)
       exit ch
       #);
     f3:<
       (# t: [1] @char; ix: @integer; ch: @char
       enter(t,ix)
       exit ch
       #);
     f4:<
       (# t,s: [1] @char; ix: @integer
       enter(ix,t)
       exit s
       #);
     f5:<
       (# S: ^myData; ch: @char;
       enter S[]
       exit ch
       #);
     f6:<  
       (# q: @myData; c: @char
       enter q
       exit c
       #);
     f7:<
       (# a: @integer; b: @integer; c: @integer;   
          res: @myData;
       enter(a,b,c)
       exit res 
       #);
     f8:< 
       (# a: @integer; b: @integer; c: @integer;   
          res: @myBigData;
       enter(a,b,c)
       exit res 
       #);
     f9:<
       (# a,b: @integer; S: @myData; c: @char
       enter(a,S,b)
       exit c
       #);
     f10:<
       (# a: @integer; S: ^myData; c: @char
       enter(a,S[])
       exit c
       #)
  #);
GetXobj:   
  (* external function to import instance of xXOMclass *)
  external (# xR: ^xCOMclass exit xR[] #);

dotstCOM:
  (* tst patterns for COM interface *)
  (# 
     (******************************************
      * definitions of COMclass implemented in 
      * BETA and exported to external language 
      * *****************************************)
     bCOMclass: COM  
       (* COM class implemented in BETA *)
       (# g0:<    
            (#       
            do 'g'-> chx -> put;
            #);
          g1:<  
            (# c: @integer (* char dont work - stores long instead of byte*)
            enter c 
            do (if test then 
                   '  bCOMclass::g1: '->puttext; c -> putint; newline if); 
               c -> put; (* 'h' *) 
            #);
          g2:< 
            (# a,b,c: @integer     
            enter(a,b,c)
            do (if test then '  bCOMclass::g2'->putline if);
               a+b+c -> val;
               (if val = 111 then ch (* 'i' *) -> put else error if);
            exit 117
            #);
          g3:< 
            (# s: [1] @char; r: @integer  
            enter s 
            do (if test then '  bCOMclass::g3'->putline if); 
               s -> puttext; 
               S -> str;
               str.range -> r (* 'jk' *)
            exit r 
            #);
          g4:<
            (# a,b,c,d,e,f,g,h: @integer
            enter(a,b,c,d,e,f,g,h)
            do (if (a = 111) and (h = 118) then
                   ch -> put (* 'l' *)
                else error    
               if); 
               (if test then
                   '\n   '->puttext; a -> putint; 
                   ' '->put; b -> putint;    
                   ' '->put; c -> putint; 
                   ' '->put; d -> putint; 
                   ' '->put; e -> putint; 
                   ' '->put; f -> putint; 
                   ' '->put; g -> putint; 
                   ' '->put; h -> putint; 
               if)
            #);
          foo: data 
            (# x: @integer; y,z: @int16; v: @integer; w: @char #);
          g5:<
            (* prints 'm' and 'n' *)
            (# V: @foo
            enter V
            do (if test then 
                   '\nG5:   '->puttext; V.x -> putint;
                   ' ' -> put; v.z -> putint; 
                   ' ' -> put; V.w -> put;
                   newline
               if);
               (if V.x = 999 then ch -> put (* 'm' *) else error if);
               (if (V.y = 77) and (V.z = -88) 
                   and (V.v = 1010) and (V.w = '*') then
                   ch -> put (* 'n' *)
                else error
               if);
            #);
          QQ: @myData;
          g6:<
            (# S: ^bComClass; x: @char
            enter(S[],x)
            do (if x = '%' then
                   ch -> put (* 'o' *)
                else 
                   error 
               if);
               S.ch -> put;  (* 'p' *)
               1199 -> QQ.x;
               
               (# x: @char do QQ[] -> xR.f5 -> x ; x -> put (* 'q' *)#)
            #);  
          g7:< (# <<SLOT tstcom_g7:doPart>> #);
          ch:<   
            (# c: @char  
            do chx + 1 -> chx -> c -> c 
            exit c  
            #);
          chx: @char;
          val: @integer;
          str: [1] @ char
       #);
     PutBobj:  
       (* external function to export instance of bCOMclass *)
       external(# bR: ^bCOMclass enter bR[]  #);
     
     (********** using xCOMclass and bCOMclass *******)
     xR: ^xCOMclass;
     ch: @char;
     T: [1] @char;
     wrap: @COM(# mD: @myData;#);
     II: @integer;
     koks: (# a: @integer do 1013 -> a exit a #);
     
     IfragClass: COM
       (# h1:< (# do inner #);
          h2:< (# <<SLOT tstcom_h2:doPart >> #);
          h3:< (# <<SLOT tstcom_h3a:doPart >> #);
          h4a:< 
            (# m1,m2,m3: @myData; i: @integer
            enter(m1,i,m2)
            do 
               (# x: @char do
                  (*   '['->put; newline; 
                   m1.x -> putint; newline;
                   m1.s -> putint; newline;
                   m2.x -> putint; newline;
                   m2.s -> putint; newline;
                   i -> putint;  newline;
                   *)
                  (if m1.x + m1.s = i then '2' -> put if);
                  (if m2.s - m2.x = 1 then '3' -> put if);
                  (*  exit m3*)
               #)
            #); 
          h4:<  
            (# m1,m2,m3: @myData; i: @integer
            enter(m1,i,m2) do (#<<SLOT tstcom_h4:doPart>>#)
            exit i (* m3: OBS!	return of dataByValue from BETA 
		    * does NOT work changes needed in dobody
                    *)
            #);  
       #);
     fragClass: IfragClass 
       (* Implementation of interface in BETA *) 
       (# h1::< (# <<SLOT tstcom_h1:doPart>>#); 
          h2::< (# do 'x'->put #);
          h3::< (# <<SLOT tstcom_h3b:doPart>> #)
       #);
     fc: ^IfragClass  
  do GetXobj -> xR[]; 
     1013 -> xR.f1 -> ch;           ch -> put;    (* 'a' *)
     (* koks -> xR.f1 -> ch;        ch -> put;    (* 'a' *)
     (10,20,2) -> xR.f2 -> ch;      ch -> put;    (* 'b' *)
     (* (koks,20,2) -> xR.f2 -> ch; ch -> put;    (* 'b' *)
     ('!$c?d#',2) -> xR.f3 -> ch;   ch -> put;    (* 'c' *)
     (4,'....d....') -> xR.f4 -> T; T -> puttext; (* 'def' *)

     (# dummy:@char do
        &bCOMclass[] (* AlloCOM *) -> PutBobj;    (* 'ghijklmnopqr' *)
     #);
     (# dummy:@char do
        6060-> wrap.mD.x;  
        7070-> wrap.mD.s;
        's' -> wrap.mD.c;    
     #);
     (if false (*isBigEndian*) then
         '[!]'-> puttext
      else
         (# x: @char do   wrap.mD -> xR.f6 -> put; #) (* 's' *)  
     if);
     
     (if not isBigEndian then
         (# cc: @Char;  
            mDB: @myBigData;
         do
            (# x: @char 
            do (8080,9090,'#') -> xR.f8 -> mDB;
            #);
            (if (mDB.x=8080+1234)    
                and (mDB.y=0x87654321)   
                and (mDB.s=321) then
                mDB.c->put;
             else 
                error;
            if); 
            (8080,9090,'#') -> xR.f7 -> wrap.mD;
         #);  
     if);
     (# dummy:@char do  
        (if test then
            wrap.mD.x -> putint; ' ' -> put;  
            wrap.mD.s -> putint; ' ' -> put;
            wrap.mD.c -> put;
            newline;   
        if);
        (if (wrap.mD.x = 8080+1234) and (wrap.mD.s = 321) then
            wrap.mD.c -> put
         else 
            error
        if); 
     #);
     &fragClass[] (* AlloCOM *) -> fc[];
     fc.h1;
     fc.h2;
     fc.h3;
     (# dummy:@char do
        6060 -> wrap.mD.x;
        7070 -> wrap.mD.s;  
        '0' -> wrap.mD.c; 
     #);
     
     (6060,wrap.mD,7070) -> xR.f9 -> put;  
     8899 -> wrap.mD.x;
     '1' -> wrap.mD.c;  

     (# dummy:@char 
     do        
        (8899,wrap.mD[]) -> xR.f10 -> put;
     #);
     (# m1,m2,m3: @myData; V: @integer
     do 1111 -> m1.x;
        2222 -> m1.s;
        4444 -> m2.x;
        4445 -> m2.s;
        (*   (m1,3333,m2) -> fc.h4a(* -> m3 *);
        (m1,3333,m2) -> fc.h4 -> V; 
        (if V = 3334 then '4'-> put if)
     #);
     '5' -> fill;
  #)
---tstcom_g7:dopart---  
do 'r'->put
   
---tstcom_h1:doPart---
do 'v' -> put; 'w'->ch;
---tstcom_h2:doPart---
do ch -> put; inner h2 
---tstcom_h3a:doPart---
do 'y' -> put; 'z' -> ch; inner h3
---tstcom_h3b:doPart---
do ch -> put
---tstcom_h4:doPart---   
do (if test then
       newline; 
       m1.x -> putint; newline;
       m1.s -> putint; newline;  
       m2.x -> putint; newline;
       m2.s -> putint; newline;
       i -> putint;  newline;
   if);
   
   (if m1.x + m1.s = i then '2' -> put if);
   (if m2.s - m2.x = 1 then '3' -> put if);
   

   i+1 -> i
   
   
   
   
