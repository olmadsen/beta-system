origin 'tstenv' 
---lib:attributes---
systemenv:
  (# csys:
       (* 24+O:  item-proto
        * 24+4:  gc-felt
        * 24+8:  origin
        * 24+12: returnLink
        * 24+16: returnAdr
        * 24+20: savedOrigin
        * 24+24: savedReturn1
        * 24+28: savedReturn2
        * 24+32: savedSize
        * 24+36: TentryPoint
        *)
       (# savedOrigin: ^object;
          savedReturn1,savedReturn2: @integer;
          savedSize,TentryPoint: @integer;
          id: @integer;
       do INNER
       #);
     
     SH_RUNNING: (# exit 1 #);
     SH_READY:   (# exit 2 #);
     SH_WAITING: (# exit 3 #);
     SH_DONE:    (# exit 4 #);
     
     sysHead: csys
       (# status: @Integer;
       do INNER;
          SH_DONE->status;
          'DONE'->putText
       #);
          
     SetupVirtualTimer: external
       (# n: @integer
       enter n
       #);
     semaphore:
       (# private: @<<SLOT SemaphorePrivate:descriptor>>;
          P: (# do private.P #);
          V: (# do private.V #);
       #);
     
     CyclicQueue:
       (# elmType:< object;
          Q: [1] ^| elmtype;
          mask: @Integer;
          putpos, getpos: @ integer;
          m: @ (* spinlock protecting all data *)
            (# l: @Integer; 
               P:(# do l.%disablePreemption; l.%lock #);
               V:(# do l.%unlock; l.%enablePreemption #);
            #);
          extendBuffer: @
            (# 
            do (if mask=0 then (* Init if first use. *)
                   15 -> mask; mask+1->Q.new;
                else (* DOES NOT WORK YET! You have to move some elms! *)
                   'FATAL: extendBuffer called' -> putLine;
                   mask*2+1->mask;   
                   mask+1-Q.range->Q.extend;
               if)
            #);
          isEmpty: @(# exit (getpos=putpos) #);
          append: @
            (# S: ^| elmType
            enter S[]
            do m.P;
               (if ((putpos+1) %Band mask)=getpos then extendBuffer if);
               S[] -> Q[putpos+1][];
               (putpos+1) %Band mask -> putpos;
               m.V;
            #);
          getFirst: @
            (# S: ^| elmType
            do m.P;
               (if (putpos=getpos) then 
                   NONE->S[];
                else
                   Q[getpos+1][]->S[]; NONE->Q[getpos+1][];
                   (getpos+1) %Band mask -> getpos
               if);
               m.V
            exit S[]
            #);
       #);
     
     SQS: @CyclicQueue(# elmType::<sysHead #);
     fork: (# S: ^| sysHead enter S[] do S[] -> SQS.append #);
     EnablePreemption: (# l: @Integer do l.%enablePreemption #);
     scheduler: @ |
       (# active: ^| sysHead
       do L: (# 
             do SQS.getFirst -> active[];
                (if active[]<>NONE then
                    SH_RUNNING -> active.status;
                    active;
                    (if (active.status)=SH_RUNNING then
                        '!'->put;
                        SH_READY -> active.status;
                        active[]->SQS.append;
                    if);
                    restart L
                if)
             #)
       #);
     main:< sysHead;
  do EnablePreemption;
     1000 -> SetUpVirtualTimer; 
     &|main[] -> fork;
     L: (# 
        do scheduler; 
           (if not SQS.isEmpty then 
               '-Scheduler was suspended-' -> putText;
               restart L 
           if)
        #);
     '---COMPLETED---'->putLine;
  #)

-- SemaphorePrivate:descriptor --
(# mutex: @Integer;
   cnt: @Integer;
   Q: @cyclicQueue(# elmType::<sysHead #); (* Should not need init! *)
   P:(# self: ^| sysHead;
     do mutex.%disablePreemption;
        mutex.%lock;
        (if (cnt < 1) then
            'P'->put;
            cnt-1->cnt;
            
            (* Should be someway to get "this|(sysHead)[]" *)
            scheduler.active[] -> self[] -> Q.append;
            
            SH_WAITING -> self.status;
            mutex.%unlock;
            mutex.%enablePreemption;
            SUSPEND (* To scheduler level *)
         else
            'p'->put;
            cnt-1->cnt;
            mutex.%unlock;
            mutex.%enablePreemption
        if)
     #);
   V:(# next: ^| sysHead;
     do mutex.%disablePreemption;
        mutex.%lock;
        (if (cnt < 0) then
            'V'->put;
            cnt+1->cnt;
            Q.getFirst -> next[];
            mutex.%unlock;
            mutex.%enablePreemption;
            SH_READY -> next.status;
            next[] -> SQS.append
         else
            'v'->put;
            cnt+1->cnt;
            mutex.%unlock;
            mutex.%enablePreemption
        if)
     #);
#)

---program:descriptor---
(#  eat:
     (# n: @integer
     enter n
     do (if N > 0 then n-1 -> eat if)
     #)
do
   systemenv
   (# m: @Semaphore;
      
      S1: sysHead
        (# p: @put; 
        do (for i: 100 repeat 
                m.P;
                1000->eat;
                '.'->&put; 
                m.V;
                1000->eat 
           for); 
           ')'->put; 
        #);
      S2: sysHead
        (# p:@put; 
        do (for i: 100 repeat 
                m.P;
                1000->eat; 
                ','->&put;
                m.V;
                1000->eat 
           for);
           ']' -> put; 
        #); 
      main:: 
        (#
        do m.V;
           &|S1[] -> fork;
           &|S2[] -> fork;
           (* L: (#do  '*'->put; suspend; restart L #) *)
        #)
   #)
#)


