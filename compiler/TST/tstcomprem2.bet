ORIGIN 'tstenv';
INCLUDE 'tstlib'
---lib:attributes---
tstcomprem2:      
  (* test program made out of error reports for computed remote*)
  (# (*compRem1: not fixed - use computedReomte to define part object.
      * The following patterns corresponds to the test programs in
      * ~olm/beta/system/v5.1/TST/FEJL/COMPREM
      *)
     compRem2:
       (# P:(# v:< object; vi: @v; n: @char enter n do inner exit vi[] #);
          PP: P(# v::< (# fisk: @char #)do n->vi.fisk #);
       do ('a'->PP).fisk->put
       #);
     compRem3:
       (# set: (# init:<(#do 'b'->put #)#); s: ^set do (&set[]->s[]).init #);
     (* no comprem4 exists*)
     compRem4:
       (# list: 
            (# set: (# X: ^Q do &Q[]->X[]; inner exit X[] #);
               Q: (# W: (#do 'c'->ch #)#);
               locate: (# S: ^T do &T[]->S[]; exit S[] #);
               T: (# go: (#do ch->put #)#)
            do inner
            #);
          xlist: list
            (# xset: set(#do inner #);
               lookup: (# do (&locate(# #)).go #) 
            do (# do (xset(##)).W; lookup #) 
            #);
          ch: @char
       do '!'->ch; xlist
       #);
     compRem5:
       (# p: (# kill: (# do 'd'-> put #)#);
          qua:
            (# as:< object; R: ^object; thisObj: ^as;
            enter R[]
            do (if R## <=as## // true then 
                   R[]->thisObj[]; 
                   INNER 
                else '!?!'->puttext; R[]->thisObj[]
               if);
            exit thisObj[]
            #);
          x: @p 
       do (&p[] -> qua (# as:: p #)).kill  
       #);
     compRem6:
       (# R: @ (# A: (# foo: (# S: ^ P do &P[]->S[] exit S[] #)#)#);
          P: (# bar: (# do 'e'->put #) #);
          X:  @R.A(# #)
       do (X.foo).bar
       #);
     compRem7:
       (# A: (# AA: (# AAA: (# ch: @char #)#)#);
          anA: ^A; anAA: ^anA.AA;
          dyt: (# x: ^anAA.AAA do &anAA.AAA[]->X[]; 'f'->x.ch exit x[] #);
       do &A[]->anA[]; &anA.AA[]->anAA[];
          (dyt).ch->put
       #);
     compRem8:
       (# A: (# B: (# do exit (# s: ^C do &C[]->s[] exit s[] #) #);
                C: (# foo: (#do 'g'->put #)#)
             #);
          x: @A
       do  (x.B).foo
       #);
     compRem9:
       (# A: (# foo: (# bar: (# do 'h'->put #) #);
             do (&foo(# yyy: @integer #)[]).bar;
             #);
          B: (# foo: (# bar:< (# do inner #) #)
             do (&foo(# bar:: (# do 'i'->put #) #)[]).bar
             #)
       do  A; B;
       #);
     compRem10:
       (# A: (# W:< object; V:< (# elm: ^W #);  
                head: (# R: ^ V do &V[]->R[]; &W[]->R.elm[] exit R[] #);
             #);
          X: @A(# W::(#do 'j'->put #) #);  
       do (X.head).elm
       #);
     array:
       (# element:< object;
          low:< (# value: @integer do INNER exit value #);
          high:< (# value: @integer do INNER exit value #);
          put: (# e: ^element enter e[] do e[]->ee[] #);
          get: (# index: @integer; e: ^element
               enter index do ee[]->e[] exit e[] #);
          ee: ^element
       #);
     comprem11:
       (# vers2:
            (* version 2 of double array *)
            (# A: @array
                 (# low::(#do 13->value #); high::(#do 17->value #);
                    element::<array
                      (# element::text; 
                         low::(#do 12->value#); high::(#do 15->value#);
                      #);
                 #)  ;
               E: @A.element; T: ^text
            do 'kl'->E.put; E[]->A.put; 14->(13->A.get).get->T[];; T->puttext
            #)
       do vers2;
       #);
     comprem12:
       (# dataType: (# help:< (# do inner exit 'no'#)#);
          fieldType:
            (# typeSpec:< dataType;
               length:< integerValue;
               type: @typeSpec; 
            #);
          Record: 
            (# fieldSpec:< 
                 (# inx: @integer;
                    spec: ^fieldType;
                 enter inx
                 do &fieldType(# length::(#do inx->value#)#)[]->spec[]
                 exit spec[]
                 #);
               fieldLength:< 
                 (# inx: @integer;
                 enter inx  
                 exit (inx -> fieldSpec).length 
                 #);
               
            do 'm'->fieldlength->put;
            #);
          R: @record
       do R; (12->R.fieldSpec).type.help->putText
       #);
     compRem13: (* FEJL/compremsb2.bet*)
       (# ObjPool: @ 
            (# get:(# type:< object; obj: ^type 
                   do &type[]->obj[]; obj
                   exit obj[] 
            #)#);
          GUI: 
            (# window: (# getMoveableList: ObjPool.get(# type::list#)#)
            do inner 
            #);
          list: (# c: @char; 
                   scan: (# ch: @char do c->ch; inner #);
                do 'p'->c
                #)
       do GUI
          (# main: @window(##);
          do (main.getMoveableList).scan(# do ch->put #)  
          #)
       #)
  do compRem2;
     compRem3;
     compRem4;
     compRem5;
     compRem6;
     compRem7;
     compRem8;
     compRem9;
     compRem10;
     compRem11;
     compRem12;
     compRem13;
     'q'->fill
  #)
