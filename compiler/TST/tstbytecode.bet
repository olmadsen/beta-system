origin 'tstenv';
include 'tstlib'
(* misc. tests for bytecode *)
---lib:attributes---
tstbytecode:
  (# multiple1: (* abcde' *)
       (# multiple:
            (# t1,t2,t3: ^text
            enter t1[]
            do &text[] -> t2[];
               &text[] -> t3[];
               t1 -> t2; 'de'-> t3;
            exit(t2[],t3[])
            #);
          s1,s2,s3: ^text 
       do 'abc' -> multiple -> (s1[],s2[] -> s3[]);
          s1 -> puttext;
          s3 -> puttext; 
       #);
     multiple2: 
       (# TTT: (# t4,t5: ^text enter(T4[],t5[]) exit(T4[],t5[])#);
          multiple:
            (# t1,t2: ^text;
               t3: @TTT;
            enter t1[]
            do &text[] -> t2[];
               t1 -> t2; 
               &text[] -> t3.t4[];
               &text[] -> t3.t5[];
               'h' -> t3.t4; 
               'ij' -> t3.t5
            exit(t2[],t3)
            #);
          s1: ^text; S2,S3: @TTT
       do 'fg' -> multiple -> (s1[],s2->s3);
          s1 -> puttext;
          s3.t4 -> puttext;
          s3.t5 -> puttext
       #); 
     
     doNamedVirt:
       (# pcre: (# replace: (# do 'k' -> put; inner #)#);
          namedvirt:
            (# 
               editPre: pcre
                 (# eReplace:< replace
                 #);
               betaEditPre: editPre
                 (# eReplace::< (# do 'l' -> put #)
                 #)     
            #);
          N: @namedVirt; B: @N.betaEditPre
       do B.eReplace
       #);
     doInt8:
       (# R: [3] @int8;
          S: [3] @int8u;
          a: @int8;
          b: @int8u;
       do 3 -> a; 117 -> B;
          a -> R[2];
          b -> S[3]; 
          12 -> R.extend;
          14 -> S.extend;
          (R[2],a,'m') -> chk;
          (S[3],b,'n') -> chk;
          (R.range,15,'o') -> chk;
          (S.range,17,'p') -> chk;
       #);
     doRepMultiple:
       (# Stext: text
            (# asT: (# T: ^text do &Stext[] -> T[] exit T[] #);
               go: (# do ch -> put #);
            #);
          ch: @char;
          S: @Stext; R,R1: ^Stext; V: @integer;
          W: [3] ^text
       do 'q' -> ch;
          (S.asT-> R[]).go;
          ch+1 -> ch; 
          S.asT -> R[] -> R1[];
          R1.go;
          'st' -> W[1][];
          W[1][] -> W[2][] -> W[3][];
          W[3] -> puttext
       #);
     doVirt:
       (# xvirt: (# V:< (# f,g: @char do 'u'->f; inner  exit(f,g)#)#);
          xxvirt: xvirt(# V::< (# do 'v' -> g #) #);
          x: ^xvirt; q,w: @char
       do &xxvirt[] -> x[];
          x.V -> (q,w);
          q -> put; w -> put
       #);
     doNewInCompuRem:
       (# dir:
            (# touch: (# do 'w' -> put; inner #);
            #)
       do (&dir[]).touch(#  do 'x' -> put #)
       #);
     inxsuper:
       (# T: [3] ^foo;
          foo:
            (# bar: (# do 'y' -> put; inner #)
            #);
          i: @integer
       do &foo[] -> T[2][];
          2 -> i;
          T[i].bar(# do 'z' -> put #)

       #);
     thisRemoteSuper:
       (# scan:
            (# current: @char
            do ch -> current;
               inner;
               ch+1->ch
            #);
          ythis:
            (# scanx:
                 (# current: @char
                 do ch -> current;
                    inner;
                    ch+1->ch
                 #);
            #);
          ch: @char;
          R: ^ythis;
          foo:
            (#
            do <<SLOT foo:descriptor>>
            #)
       do '0' -> this(thisRemoteSuper).ch;
          this(thisRemoteSuper).scan(#do current -> put #); 
          (# dum: @char 
          do this(thisRemoteSuper).scan(#do current -> put #); 
          #);
          &ythis[] -> R[];
          this(thisRemoteSuper).R.scanx(# do current -> put; #); 
          (# d: @char
          do this(thisRemoteSuper).R.scanx(# do current -> put; #);
          #);
          foo
       #)
  do multiple1;       (* 'abcde' *)
     multiple2;       (* 'fghij' *)
     doNamedVirt;     (* 'kl'    *)
     (if false then
         '####'->puttext
      else
         doInt8;          (* 'mnop'  *)
     if);
     doRepMultiple;   (* 'qrst'  *)
     doVirt;          (* 'uv'    *)
     doNewInCompuRem; (* 'wx'    *)
     inxSuper;        (* 'yz'    *)
     thisRemoteSuper; (* '01234' *)
     '5' -> fill
  #);
---foo:descriptor---
(# 
do this(thisRemoteSuper).R.scanx(# do current -> put; #);
#)
