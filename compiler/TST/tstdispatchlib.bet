origin 'tstenv'; 
basic idispatch BSTR;
(*origin '~beta/basiclib/betaenv';*)
build default '$$/cdispatch.o'    'cdispatch.c'  '\$CC -c -o $0 $1'
      nti     '$$/BETA_Invoke.obj'  'BETA_Invoke.cpp' 'betacc $0 $1'
      ppcmac  ':$$:cdispatch.obj' 'cdispatch.c'  'mrc -w 35 -o $0 $1'
---lib:attributes---
trace: (#exit true #); 

struct_tagDISPPARAMS: DATA 
  (# rgvarg: @int32 (* (Build argument array in ExternalRecord) *);
     rgdispidNamedArgs: @int32 (* (Build argument array in ExternalRecord) *);
     cArgs: @int32u (* UINT *);
     cNamedArgs: @int32u (* UINT *);
     
  #);
   
getArg: external(# args,N,arg: @integer enter(args,N) exit arg#);
getRefArg: external(# args,N,rArg: @integer enter(args,N) exit rArg#);
getTextArg: 
  external(# args,N: @integer; arg: [0]@char enter(args,N) exit arg#);
getCOMrefArg:  
  external (# args,N: @integer;xR: ^COM  enter(args,N) exit xR[] #);
getType: external(# args,N,arg: @integer enter(args,N) exit arg#);
textLen: external(# name,len: @int32 enter name exit len #);
copyText: external(# name,dest,len: @int32 enter(name,dest,len)#);
PutDispId: external(# dispId,ResList: @int32 enter(dispId,ResList)#);
 
printArgs:   
  (# A: ^  struct_tagDISPPARAMS; V: @integer; T: [0]@char
  enter A[]
  do  
     (if A[] <> none then   
         ' cArgs=' -> puttext; A.cArgs->putint; newline; 
         (for i: A.cArgs repeat
              'argument '->puttext; i -> putint; ':'->put;
              (A.rgvarg,i) -> getType ->V;
              ' type='->puttext; V -> putint;
              ' arg='->puttext; 
              (if V
               // 3 then
                  (A.rgvarg,i) -> getArg ->V;
                  V -> putint;
               // 4 then
                  (A.rgvarg,i) -> getTextArg ->T;
                  T -> puttext
               // 14 then 
                  (A.rgvarg,i) -> getRefArg ->V;
                  V -> putint
              if);
              newline
         for);
      else
         '\nprintArgs: A[] = none' -> putline
     if)
     
  #);  


int32uHolder: Holder
  (# value: @int32u enter value exit value #);
RefHolder: Holder
  (# type:< COM;
     ref: ^type;
  enter ref[] 
  exit ref[]
  #); 
ITYpeInfo: COM(# #); (* juts a dummy decl *)
ITypeInfoHolder: refHolder
    (# type:: ITypeInfo #);
GUIDdata: DATA (# #);
VARIANT: DATA(# #);
struct_tagEXCEPINFO: DATA(# #);

IUnknown: COM
  (# QI:< (# #); 
     AddRef:< (# #);
     DeleteRef:< (# #);
  #);
iDispatch: IUnknown
  (# GetTypeInfoCount:<
       (# result: @int32 (* HRESULT *);
          pctinfo: ^int32uHolder (* UINT* *); 
       enter pctinfo[]
       do INNER;
       exit result
       #);    
     GetTypeInfo:<
       (# result: @int32 (* HRESULT *);
          iTInfo: @int32u (* UINT *); 
          _lcid: @int32u (* LCID *); 
          ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
       enter (iTInfo, _lcid, ppTInfo[])
       do INNER;
       exit result
       #);
     GetIDsOfNames:<
       (# result: @int32; (* HRESULT *)
          riid: ^GUIDdata;
          rgzNames: @int32u;
          cNames: @int32u;
          _lcid: @int32u;
          rgDispId: @int32; (*[0]@char;*)
       enter(riid[],rgzNames,cNames,_lcid,rgDispId)
       do inner 
       exit result 
       #);        
   
     Invoke:<
       (# dispIdMember: @int32;
          riid: ^GUIDdata (* REFIID* *);
          _lcid: @int32u (* LCID *);
          wFlags: @int16u (* WORD *);
          pDispParams: ^struct_tagDISPPARAMS; (* DISPPARAMS* *)
          pVarResult: ^VARIANT (* VARIANT* *); 
          pExcepInfo: ^struct_tagEXCEPINFO (* EXCEPINFO* *); 
          puArgErr: ^int32uHolder (* UINT* *); 
          result: @int32 (* HRESULT *)    
       enter(dispIdMember,riid[],_lcid,wFlags,pDispParams[]
          ,pVarResult[], pExcepInfo[], puArgErr[])
       do INNER
       exit result
       #);          
  #);

BSTR: data (# wcharPtr: @integer enter wcharPtr exit wCharPtr #);
