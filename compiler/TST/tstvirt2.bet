ORIGIN 'tstenv'; 
INCLUDE 'tstlib' 
---lib:attributes---
tstvirt2:
  (# a1: @char; foo: @ (# b: @char #); 
     A: (# do a1->put; foo.b->put; INNER #);
     W: (# V: < A do INNER #);
     WW: W(# c2: @char;
	     V::< (# c1: @char do 'c'->put #); X: @V 
	  do X 
          #); 
     B: (# C: (# W2: W(# do INNER #);
	         D: (# W3: W2(#  V::< (# do 'f'->put #) do V #) do W3 #)
              do D  
              #)
	 do C  
	#); 
 
     T: (# P: (#  V: < F do 'g'->ch1; 'h'->ch2; V #); 
           F: (# do ch1->put; ch2->put; INNER #);
           ch2: @char 
        #); 
     ch1,ch3: @char;
     R: ^T;
     QQQ:   
       (# P: (# q3: @ char do inner; 's'->c6 #);
          c6: @char; 
          T: (# A: (# q1: @ char; f: ^D;  do &A[]->f[]; inner; 'q'->c4 #);
                c4,c5: @char;  
                D:<A; 
                X1: (#  B: (# q2: @ char; g: @ D do inner ; 'r'->c5 #);
	               X2: (# V:<A ; W:<B; U:<P do V; W; U; Inner #)
                    do inner 
                    #);
                B1: (# c1: @ char 
                    DO (# c2: @ char
	               do X1(# c3: @ char
		            do (# 
         		       do (#
		 	          do X2(# V::<(# q3: @char 
				              do 'k'->f.q1->put; 'n'->c1 #);
			                  W::<(# q4: @char 
					      do 'l'->g.q1->put; 'o'->c2 #);
                                          U::<(# q5: @char 
		 			      do 'm'->q3->put; 'p'->c3 #)
			               do c1->put; c2->put; c3->put; c4->put
	            #)#)#)#)#)#)  
             do '!'->c4->c5; B1; c5->put
             #)
       do '!'->c6; T; c6->put
       #);
     madsn: 
       (# theA: @
            (# B: (# C: (# V:< charValue
                        do ch->put; V->put; inner; ch->put
                        #)
                  #)
            #);
          theB: @theA.B(##);
          theC: @theB.C
            (# V::< (# do 'u'->value #) 
            do 'v'->ch; 
            #);
          ch: @integer
       do 't'->ch; 
          theC;
       #);
     final1:
       (# PO: (# TTT:< (# #) do inner#);
          qqq: (# P: PO
                    (# aaa: (# V:<object; i,j: @integer; #);
                       bbb: aaa (# x,y: @integer;  V::TTT #);
                       TTT::(# t: @text enter t exit t #);
                       b: @bbb;
                       t: ^TTT
                    do &b.V[]->t[]; 'w'->t;
                       t.t->puttext;   
                       (# x: @char do 'xy'->&b.v->puttext; #);
                    #)
               do p 
               #) 
       do qqq  
       #);
     final2: 
       (# T: (# do ch->put;#); 
          A: (# V:<object do inner #); 
          AA: A(# c: @char; V::T do ;'!'->c; V #);
          ch: @char; 
       do 'z'->ch; AA;   
       #);
     final3: 
       (# l: (# e:< object #);
          ll: l 
            (# e:: A;
               ane: @e
            #); 
          A: (#do '0'-> put #)
       do (if true then 
              '#'->put
           else
              (&ll[]).ane 
          if)
       #); 
     final2virt:
       (# ch: @char;  
          P: (# do ch -> put; ch+1->ch; INNER;  #);
          Q: (# V:< P; W:< P do V; W #);
          R: Q(# V::< (# do ch -> put; ch+1->ch; INNER #) #);
          S: R(# W:: V #);
          T: S(# V:: (# do ch -> put; ch+1->ch #)#)
       do 'a'->ch;   
          Q; (*a-b*)   
          R; (*c-e*)
          S; (*V:f-g; W:h-i*) 
          T; (*j-n?*) 
       exit ch
       #);
     final2b:
       (# booleanValue: (# b: @ boolean do INNER exit b #);
          trueObject: booleanValue(# enter b do INNER; ch->put; #);   
          Y: @
            (# X: @
                 (# TkInterpreter: (# interactive:< booleanValue #);
                    userInterface: @TkInterpreter
                      (# interactive:: trueObject;
                         mainLoop: (# do interactive #); 
                      #);
                 do userInterface.mainloop
                 #)
            do X 
            #);
          ch: @char; 
       enter ch
       do Y.X.userInterface.interactive;
          ch+1->ch; 
          Y;
          ch+1->ch;
       exit ch 
       #);
     final2virtY:
       (* prints 'rs' *)
       (# l: (# e:< A #);
          ll: @l (# e:: v; ane: @e #); 
          v:< A(#  do ch+1 -> put; INNER #);
          A: (# do ch -> put; INNER #);
          ch: @char
       enter ch
       do ll.e; 
          ch+3 -> ch; 
          ll.ane;
       exit ch+3
       #);
     final2virtYY: final2virtY
       (# v::< (# do ch+2 -> put#)
       #); 
     final2virtZ:
       (#
          Xqua:
            (# as:< object; R: ^object; thisObj: ^as;
            enter R[]
            do (if R## <= as## then 
                   R[]->thisObj[];
                   INNER Xqua
                else 
                   error
               if)
            exit thisObj[]
            #);
          xlist:
            (# element:<object;
               theCellType:< (# do 'Hello'->putline; ch->put; #); 
               append:
                 (# S: ^element
                 enter S[]
                 do S[] -> theElm[]
                 #);
               at:
                 (# S: ^element 
                 enter S[] 
                 exit theCell[]    
                 #);
               theElm: ^element;
               theCell: @theCellType ;
            #);  
          ch: @char;
          Pip:        
            (# C: @ (# aList: @xList (# element:: integerValue #);  #);
               D: ^C.aList.theCellType;
               E: @integerValue;   
            do E[]->C.aList.append;
               E[]->C.aList.at->D[]; 
               (if true then '##' -> puttext
                   else
               (if D## <= C.aList.theCellType## then
                   'x'->put
                else 
                   '?' -> put
               if);
               (* hvis ::< fås en checker fejl besked *)
                   D[]->Xqua (# as:: C.aList.theCellType do 'y' -> put #); 
               if)
            #) 
       do Pip
       #);
     future:
       (# Future:
            (# resultType:< object;
               result: ^resultType;
            enter result[] 
            exit result[]
            #);
          FutureComputation:
            (# type:< object;
               futureType: future(# resultType:: type #);
               future_res: ^FutureType;
               result: ^type;
            do &FutureType[] -> future_res[]; &type[] -> result[]; 
            exit future_res[]
            #);
          SmallComputation: FutureComputation
            (# type::< IntegerObject;
            #);
          small: @SmallComputation;
          smallresult: ^small.FutureType; 
          ro: ^integerobject;
       do small -> smallresult[];  
          &smallResult.ResultType[] -> smallResult.result[];
          'z' -> smallResult.result;
          smallresult -> ro[]; 
          ro -> put
       #);
     nestedFinal: 
       (# smallTable: (# element:< object #);
          yyy:
            (# id: (# #);
               theTable: @smallTable
                 (# element:: id;
                    insert:
                      (#  anIdElm: ^element;
                      do &element[] -> anIdElm[]; 
                         (* used to fail due to extra pop*)
                         '0'->put
                      #);
                 #)
            do theTable.insert
            #)
       do yyy
       #);
     ch: @char;
     QQ: (# do inner #);
     QT: QQ(# do ch -> put #);
     QP: (# V:< QQ do V; inner #);
     QX: (# QY:
              (# QPP: QP(# V:: QT do #) 
              do QPP
              #)
         do '1' -> ch; QY
         #) 
  do 'a'->a1; 'b'->foo.b; WW; 
     'd'->a1; 'e'->foo.b; B;
     &T[]->R[]; 'j'->ch3;
     R.P(# V::< (*R.F*)(# do 'i'->put; ch3->put #) #);
     QQQ;
     madsn;    
     final1;
     final2;
     final3; 
     '123456789'->putText;
     'Virtual2b' -> newL;
     final2virt      (* a-o by final2virt *)
       -> final2b
       -> final2virtYY;
     final2virtZ; 
     (if false then
         future;
      else
         '########' -> puttext
     if);
     (if true then
         nestedFinal;
      else
         (if safeMode then 
             '0' -> put
          else
             '-nestedFinal-'->puttext
     if)if);
     QX; (* '1' *)
     '2' -> Fill; 
  #)



