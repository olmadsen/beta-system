ORIGIN 'tstenv';         
INCLUDE 'tstlib'
---lib:attributes---
tstnxoff2:
  (# test16:   
       (# A:
            (# n: @integer; s: ^B
            enter(n,s[])
            exit(n,s[])
            #); 
          B: (# m: @integer#); 
          newA:  
            (# v: @integer; Q: @A; bb: ^B
            enter v
            do &B[] -> bb[]; v*v-> bb.m;
               (v,bb[]) -> Q
            exit Q
            #);
          foo:
            (# Q1,Q2,Q3,Q4,Q5: @A; i,j,k: @integer;
            enter(Q1,Q2,Q3,Q4,Q5,i,j,k)
            do 'a'-1 -> ch;
               Q1 -> check;
               Q4 -> check;
               Q5 -> check;
            #);
          ch: @integer;
          check:  
            (# Q: @A
            enter Q
            do (if (Q.n*Q.n) = Q.s.m then
                   ch+1 -> ch -> put
                else error
               if)
            #); 
          W1,W2,W3,W4,W5: @A; 
          bar:
            (# X: @A
            enter X   
            do
            exit X   
            #);  
          genDesc:
            (# bool: @boolean; s: ^text 
            enter(W1,bool,s[]) 
            do W1->check  
            #);
          i,j,k: @integer; 
          W: ^A;
       do 11 -> newA -> W1; 
          22 -> newA -> W2;
          33 -> newA -> W3;  
          44 -> newA -> W4; 
          55 -> newA -> W5; 
          (# x: @char
          do 'a' -> x; (W1,W2,W3,(W4->bar),w5->bar,i,j,k) -> foo    
          #); 
          'd'-1->ch;
          (# yyy: @real  
          do &A[] -> W[]; 
             66->newA -> W;
             W -> W2;
             W -> Check; (* 'a' *)  
             (W,(k<>0),'qwerty') -> gendesc ; (* 'b' *)
          #) 
       #); 
     test17:
       (# stext:  
            (# T: [100]@char; top: @integer;
               setT: (# enter T do T.range -> top #)
            enter setT
            exit t[1:top]
            #);
          index: 
            (# a: @integer; f: ^ index;
               R: [12]@integer;
               son:
                 (#exit
                    (#exit (f.R[a+1]->tos'%getshort[1]'->tos'%shiftleft[1]',f[])#)
                 #);
               init: (#do &index[] -> f[]; 9->f.a; 0x00020002 -> f.R[a+1]#)
            enter(a,f[])  
            exit(a,f[]) 
            #);
          extCall:
            (# xName: @stext; desc: ^index; extType: @integer;es: @index
            enter(xName,desc[],extType,es)
            do xName -> puttext;
             (if isByteCodeMode then
                 '#' -> put
              else
                 (if es.a = 4 then 'p' -> put else '!' -> put if)
             if)
            #);
          desc,ev: ^index;
          kind: @integer;
          sematt: ^semattType;
          semattType: (# virtExt: (#exit 9 #)#)
       do (# CP: @extCall; callId: ^stext;
          do &stext[] -> callId[]; 'mno' -> CallId; 
             &index[] -> ev[]; ev.init; &semattType[] -> sematt[];
             (# x: @char 
             do (callID,desc[],sematt.virtExt -> kind,ev.son) -> CP 
             #)
          #)
       #);
     testVirt: 
       (# userData:
            (# write:< (# do inner #);
               read:< (# do inner #);
               c: @char
            enter write
            do inner;
               c -> put;
               c+3 -> c;
            exit read 
            #);
          myUserData: userData
            (# write:: 
                 (# a,b: @char 
                 enter(a,b) 
                 do a -> put; b->put; 
                    b+1->cx 
                 #);
               read:: (# c: @char do ch-1-> c exit c#);
               ch,cx: @char
            enter ch
            do cx-> put;
               ch -> put;
               ch + 1 -> c;
               c+1 -> cx;
               cx+1 -> ch;
            #);
          Y: @userData;
          X: @myUserData;

          XuserData:
            (# write:< (# a: @char enter a do a -> c; inner #);
               read:< (# c: @char do inner exit c #);
               c,q,W: @char
            enter(write,q)
            do inner
            exit(read,W)
            #);
          XmyUserData: XuserData
            (# write:: 
                 (# a,b: @char 
                 enter(a,b) 
                 do a -> c1;
                    b-> c2;
                 #);
               read:: (# c: @char do ch -> c exit c#);
               ch,c1,c2: @char
            enter ch
            do c -> put; q -> put; ch -> put; c1->put; c2->put
            #);
          yY: @XuserData;
          xX: @XmyUserData;
       do (if isByteCodeMode then
              (* the problem is userData which has enter/exit parts
               * calling virtuals with no enter/exit
               * we need to regenerate the enter/exit-method
               * in e.g. myUserData
               *)
              '##############'->puttext
           else
              (('q','r'),'t') -> X; 
              X -> put;
              (('z','2','3'),'0','1') -> xX  ;
          if)
       #);
     funny:
       (# descKind: 
            (# D: @INDEX; z: @integer enter D exit D.kind->TOS'%getByte[0]' #);
          getPossibleSlot:
            (# n,val: @integer
            enter n
            do (if isBigEndian then
                   0x34232425 -> val 
                else
                   0x25242334 -> val
               if);
            exit val
            #);
          index:    
            (# v: @integer;
               kind: 
                 (#  fool:< (#do ch -> put #)
                 do (if R[] = none then this(kind)[] -> R[] if)
                 exit 5 -> getPossibleSlot 
                 #);
            enter v
            exit v
            #);
          D: @ index; ch: @char; S: @index; R: ^S.kind 
       do '5' -> ch; D -> descKind -> put; R.fool
       #);
     realAndPtnVar:
       (# F: (# x: @real 
             enter x 
             do (if x = 1.123 then '6' -> put if);
             exit x
             #);
          S: (# P: ##TT 
             enter P##
             do (if P## = none then TT## -> P## else P if)
             exit P##
             #);
          Q: (# X: @F
             enter(F,S)
             do 2.123 -> X;
             exit(X,S)
             #);
          PP: ##TT; TT: (# do ch -> put #);
          x: @real; ch: @char
       do TT## -> PP##; '7' -> ch; 
          (# zzz: @char do  (1.123,PP##) -> Q -> (x,PP##); #);
          (if x = 2.123 then '8' -> put if);
          '9' -> ch; PP;    
       #)
  do test16;      (* 'abcde' *) 
     'fghijkl' -> puttext;
     test17;      (* 'mnop' *) 
     testVirt; 
     funny;
     (if isByteCodeMode then
         '####' -> puttext
      else         
         realAndptnVar;  (* '6-9' *)
     if)
  #)

