ORIGIN 'tstenv';
--PROGRAM: descriptor--
(# 
   thread:
     (* General thread pattern.
      * Should be instantiated as a component 
      *)
     (# spawn:
          (# attToThread: external
               (# comp: @integer;
                  tid: @integer;
               enter comp
               exit tid
               #);
             my_tid: @integer;
             thisthread: ^thread;
          do THIS(thread)[] -> thisthread[];
             (%getLongAt @@thisthread)-24->attToThread->my_tid;
          exit my_tid
          #);
     do INNER
     #);
   
   (* NoOfArguments, Arguments and getint missing in tstenv *)
   Argc: External(# noOfArgs: @integer exit noOfArgs #);
   Argv: External
     (# argNo: @integer;
        theArg: [1]@char
     enter argNo
     do CallC
     exit theArg
     #);
   NoOfArguments:
     (# exit Argc #);
   Arguments:
     (# argNo: @integer;
        theArg: ^text;
     enter argNo
     do (if ((1<=argNo) and (argNo<=ArgC)) then
            &text[]->theArg[]; argNo->Argv->theArg
        if);
     exit theArg[]
     #);
   txt2int:
     (# t: ^text;
        value: @integer;
        ch: @char
     enter t[]
     do (for i:t.t.range (* t.lgth is 0 *) repeat
             t.t[i]->ch;
             (if ('0'<=ch) and (ch<='9') then
                 value*10+(ch-'0')->value;
             if)
        for)
     exit value
     #);
   
   numthreads: @integer;
   mythread: thread
     (# howLong: @Integer;
        tid: @Integer;
        t:@Integer;
        ch: @char
     do L: 
          (# 
          do (for i:1000000 repeat 
                  1->t;
                  (if (i %Band 127)=127 then (# a: @Char #)if) 
             for);
             ch->put;
             howLong-1->howLong;
             (if howLong>0 then restart L if)
          #);
        '\nThread t@'->putText; tid->putInt; ' completed'->putLine;
     #);
do (if NoOfArguments<>2 then
       'Usage: manythreads <number of threads>' -> putline;
    else
       2->Arguments->txt2int->numthreads;
       'Starting '->puttext; numthreads->putint; ' threads.'->putline;
       (# thread_ids: [numthreads]@integer;
          threads:    [numthreads]^|mythread;
          (* FIXME: cannot use static repetitions - not yet implemented *)
       do 
          (for i:numthreads repeat
               &|mythread[]->threads[i][];
               '0'+i-1 ->threads[i].ch;
               50+10*i->threads[i].howLong;
               threads[i].spawn -> thread_ids[i] -> threads[i].tid; 
               '[t@1:spawning '->putText; threads[i].tid->putInt; 
               ']\n'->putLine;
          for);
       #);
       '\nThread t@1 completed' -> putline;
   if)
#)
