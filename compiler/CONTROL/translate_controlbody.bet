ORIGIN 'transDepGraph';
LIB_ITEM 'betacompiler';
INCLUDE '../CHECKER/sematt';
INCLUDE '~beta/newmps/compact';

(*INCLUDE '../GENERATOR/machine';*)
(* The controller controls calling of 
 *  AST-interface, checker, codegenerator,
 *  assembly and linking.
 *)
---xDependencyLib:attributes---
CreateLstFileName: 
  (# g: ^FragmentGroup; t: ^Text;
  enter g[]
  do common.LstExt -> (g.NameT.copy).append -> t[];
  exit t[]
  #);
ControlSetGroupID: 
  (# g: ^fragmentGroup;
  enter g[]
  do <<SLOT ControlSetGroupID:descriptor>> 
  #);
DoRealOpen: 
  (# g: ^FragmentGroup;
     isRealOpen: 
       (# isOpen: @Boolean;
       do scanner: g.fragmentList.scan
            (#  ff: ^fragmentForm
            do (if current.type = formType then 
                   (if current.form <> NONE  then
                       true->isOpen;
                       current.form-> ff[];     
                       (if ff.root[] = NONE then 
                           false -> isOpen; 
                           (if common.switch[396] then
                               '\n*** root was NONE: '->puttext;
                               g.name->putline;
                           if);
                           leave scanner 
                       if)
                    else
                       (if common.switch[396] then 
                           '\n*** current.f was NONE:'->puttext;
                           g.name->putline;
                       if)
                   if)
            if)#)
       exit isOpen
       #)
  enter g[]
  do (if not isRealOpen then (* open g real *)
         (if verboseLevel < verboseLevel.actions then
             'Open: '->infostream.puttext; g[]->printFN; infostream.newline;
         if);
         (if (g.controller.status >= DoCodeGen)
             (* WE MUST realOpen if checking here !*)
             (* and not common.switch[5]*)
             then
             (if common.switch[396] then 'real open'->tracestream.putline if);
             g.realOpen
             (# OpenError:
                  (# msg: ^text
                  enter msg[]
                  do NONE -> theCatcher[];
                     msg[] -> thisTranslate.MPSexception
                  #);                     
                astOverflow:: (#do msg[] -> OpenError #);
                fragmentNotExisting:: (#do msg[] -> OpenError #);
                badFormat:: (#do msg[] -> OpenError #);
                grammarNotFound:: (#do msg[] -> OpenError #);
                doubleFormDeclaration:: (#do msg[] -> OpenError #);
                readAccessError:: (#do msg[] -> OpenError #);
                noSuchFileError:: (#do msg[] -> OpenError #);
                otherFileError:: (#do msg[] -> OpenError #);
             #)
          else
             (if common.switch[396] then 
                 'compact open'->tracestream.putline 
             if);
             g[]->CompactOpen;
         if);
      else
         (* If donecheck is true and the group is real open then we 
          * re-access the same group.
          * If donecheck is false and the group is real open the group
          * is just parsed up. Don't write anything.
          *)
         (if verboseLevel<verboseLevel.actions then
             (if (This(AstInterface)[],g[])->getDoneCheckProperty then
                 'Re-access: '->infostream.puttext;
                 g[]->printFN; infostream.newline;
         if)if);
     if);
     g[]->ScanForms
     (# sysForm: @ASTindex;
     do (if current[] = NONE then
            '\n*** current is NONE '->bugstream.putline;
            g.realOpen
        if);
        (if current.root[] = NONE then
            '\n***root is NONE'->putline
        if);
        (if current.grammar[] = NONE then
            '\n**grammar is NONE'->putline
        if);
        current.theGSForm->sysForm; 
        (if current.Category
         //gram.doPart
         //gram.mainPart then
            (* do not initialize decsNo *)
         else
            0->sysForm.descNo;
        if);

        (* descNo contains the index of the search cash
         * for this form; must be zero initially.
         * this is also done by the checker; however is also
         * necessary for fragments that are NOT checked
         * but used when checking other fragments;
         * should be cleaned up *)
     #);
  #);

DoTheChecking: 
  (* Perform static semantic check of THIS fragment *)
  (# g: ^FragmentGroup; error,fatalError: @boolean;
     lstFile: @File
       (# AccessError:: (#do FN -> thisTranslate.TransAccessException #);
          NoSuchFileError:: (#do FN -> thisTranslate.NotExistingException #);
          NoSpaceError:: (#do thisTranslate.NoSpaceException #);
          OtherError:: 
            (#
            do (FN,msg[]) -> thisTranslate.otherFileError 
            #);
          FN: 
            (# T: ^text do '.lst'-> (g.nameT.Copy).Append -> T[] exit T[] #);
          init: 
            (# 
            do g[]->CreateLstFileName->Name; openWrite;
               lstFile[]->lst[];
            #);
       #);
     Prepare:
       (#
       do LstFile.init;
          (if verboseLevel<=verboseLevel.actions then
              '!Checking'->infostream.puttext;
          if);
       #);
     Conclude:
       (#
       do g.name -> thisTranslate.checkedFragment;
          (not fatalError,this(AstInterface)[],g[])->setDoneCheckProperty;
          g[]->ControlSetGroupID;
          g.MarkAsChanged
          (# writeAccessError::< 
               (#
               do (* cleanUpAfterException;*)
                  astFileExtension
                    -> (G.nameT.Copy).Append
                    -> thisTranslate.TransAccessException;
               #);
          #);
          g[]-> thisTranslate.groupSavedNotification;
          (if fatalError  and (not common.switch[21]) then 
              (g[],14) -> thisTranslate.msgException 
          if);
          (if lstFile.entry.exists then
              (* Another BETA compilation may have closed it!
               * Be careful with running concurrent BETA compilations!
               *)
              lstFile.close; 
              (if lstFile.entry.exists and (lstFile.length = 0) then 
                  lstFile.delete 
              if)
          if);
          none->lst[]; (* a call of msg will do lst.close otherwise *)
          (if verboseLevel<=verboseLevel.actions then
              '!'->infostream.put;
          if);
       #)
  enter g[]
  do Prepare;
     
     (G[],not ((this(AstInterface)[],g[])->getDoneCheckProperty))
       -> SemAtt.Checker
       -> (error,fatalError);
     
     Conclude
  #); (* DoTheChecking *)


----handleFragmentsLib:attributes----
(* Is here because of createAsmFileName *)
DoTheCodeGen: 
  (* Generate code for g fragment. *) 
  (# g: ^FragmentGroup;
  enter g[]
  <<SLOT translate_doTheCodeGen:doPart>>
  #);

---TranslateDo:doPart---
   (* Translate is called if a fragment group MUST be compiled.
    * This is the case if doCheck or doCodeGen are true for THIS
    * fragment OR if the fragment is an ancestor of a
    * fragment where doCheck or doCodeGen are true. ``Ancestor''
    * is defined by means of ORIGIN and INCLUDE relations.  
    * So, whenever translate is called, THIS fragment must be
    * real opened, and the slots in THIS fragment and its ancestors
    * must be bound. 
    *)   
do (# switchList: @singleLinkedList
        (* Used to store information about switches defined locally in 
         fragment groups by means of ON/OFF properties. Note that such
         switches only have the fragment group in which they are defined
         as scope. The slot oldValue is used to push global switch values
         while the local ones are valid. I.e. during check and codeGen.
         For details confer the translate pattern.
         *)
        (# insert::< 
             (# theSwitch: @integer;
                theValue: @boolean;
             enter(theSwitch,theValue)
             do theSwitch->E.switch;
                theValue->E.newValue;
             #);
           readSwitches: 
             (#
             do fg.prop.ScanProp
                (# doProp::< 
                     (# 
                     do prop.makelc;
                        (if true 
                         // 'on'->prop.equal then
                            ScanParameters
                            (# doConst::< 
                                 (# 
                                 do (if ((1 <= C) 
                                        and (C <= common.switch.range))  then 
                                        (C,True)->switchList.insert;
                            if)#)#);
                         // 'off'->prop.equal then 
                            ScanParameters
                            (# doConst::< 
                                 (# 
                                 do (if ((1 <= C) and (C <= common.switch.range))  then 
                                        (C,False)->switchList.insert;
                     if)#)#)if)#);
                #);
             #);
           defineLocalSwitches: 
             (* Save global switches and define local switches *)
             (#
             do readSwitches;
                scan
                (#
                do common.switch[thisElm.switch]->thisElm.oldValue; 
                   (thisElm.newValue,thisElm.switch)->setSwitch;
                   (*thisElm.newValue->common.switch[thisElm.switch];*)
                   (if common.switch[392] then
                       'defining local switch '->tracestream.puttext;
                       (if thisElm.newValue then 'true'->tracestream.puttext
                        else 'false'->tracestream.puttext
                       if);
                       ' in fragment: '->tracestream.puttext;
                       fg.nameT[]->tracestream.putline;
             if)#)#); 
           restoreGlobalSwitches: 
             (* restore global switches *)
             (#
             do scan(# do (thisElm.oldValue,thisElm.switch)->SetSwitch #);
             #); 
           elm::< (# switch: @integer; newValue,oldValue: @boolean; #);
        #);
      verB,hasBasicPatterns: @ boolean;
      Prepare:
        (#
        do NONE->lst[]; (*avoid closing a closed/non-existing' file*)
           fg[]->DoRealOpen;
           (if fg.origin <> NONE then
               fg.origin -> &Translate
           if);
           fg[]->ScanLinks
           (# FN,ext: ^ text
           do (current[](*.name*),fg.nameT[]->stripPathName)
                ->thePathHandler.convertFilePath
                ->FN[];
              (if FN.length > 4 then
                  (FN.length-3,FN.length) -> FN.sub -> ext[];
                  (if common.SrcExt -> ext.equalNCS then
                      (FN.length-3,FN.length) -> FN.delete
              if)if);
              FN[] 
                -> (*DGP.groupList.*)findgroup
                -> Translate;
           #);
           fg.nameT[] -> common.theGroupName[];  
           (verboseLevel < verboseLevel.actions)            (* verbose *)
           or ((verboseLevel <= verboseLevel.actions)       (* normal *)
               and ((fg.controller.status >= doCheck)       (* if checking *)
                    or ((fg.controller.status >= doCodeGen) (* or codegen *)
                        and not common.switch[5]))) 
             -> verB;
           (if fg.origin = NONE then (* betaenv *) 
               (if verB then 
                   'Basic BETA environment: ' -> infostream.puttext; 
                   fg[] -> printFN;
               if);
               (* OBS! BindSlots is called even for BETAENV which has no
                * origin, i.e. the form BETAENV cannot be bound.
                * BindSlots is, however, called to build up the property
                * 'SLOTS' which is used to check for unbound slots; otherwise
                * unbound slots in betaenv will not be reported! Note, that
                * the enter parameter reBind is TRUE. This is used to indicate
                * that BindSlots should NOT produce an error message for the 
                * unbound slot BETAENV. In BindSlots reBind should be renamed
                * to indicate that it is only used to suppress error messages
                *)
               (fg[],true) -> SemAtt.BindSlots;
               (if common.switch[135] then
                   (* for some unknown reason, if betaenv i a descriptor slot
                    * then BindSlots does not bind the form name, if it
                    * is an attributesSlot, it is bound?
                    *)
                   (*none -> fg.binding[]*)
               if)
            else (* origin exists *)
               (if verB then
                   'Bind fragments in: '->infostream.puttext; 
                   fg[]->printFN
               if);
               
               (************** BINDING SLOTS ***************
                * when binding slots for groups compiled with a 
                * compilation context, no error messages should 
                * be given for unbound slots
                *)
               (fg[],common.switch[72]) -> SemAtt.BindSlots
               (# fragErr::
                    (#
                    do (fg[],FF[],slot[],errNo
                       ,msg[],CloseGroup(#do fg[] -> g[]#))
                         -> thisTranslate.fragmentException
                    #)
               #)
           if);
           switchList.defineLocalSwitches;
        #);
      Conclude:
        (#
        do (if verB then infostream.newline if);
           switchList.restoreGlobalSwitches;
           doneTranslate->fg.controller.status;
        #)
   do (if common.switch[398] then
          'Translate: '->tracestream.puttext; fg[]->printFN;
          tracestream.newline;
      if);
      (if fg.controller.status > doneTranslate then 
          Prepare;
          (if not common.switch[7] then
              (******** semantic checking *********)
              (if fg.controller.status >= doCheck  then
                  fg[] -> doTheChecking;
               else
                  (fg[],(fg.origin<>NONE)) -> sematt.InitWithoutCheck
              if);
              
              (******** code generation ***********)
              (if not common.switch[5] then
                  (if fg.controller.status >= doCodeGen  then
                      fg[] -> doTheCodeGen
                  if)
               else 33 -> switchOn
              if);
           else
              33 -> switchOn;
              '\nNo checking and code generation is performed'->putline
          if);
          Conclude;
      if)
   #)
---translateAddVirtualSuper:dopart---
   (* used for compacting AST's Notice, the FragmentGroup must 
    * also be checked before closed in order to be compacted
    *)
do FG[]->ScanForms
   (# R: ^Expanded; S: @ASTindex; B,BS,BSpre: @ASTindex
   do current.root[] -> R[];
      R.scan
      (#
      do current[] -> AstAsAstIndex -> S; '.'->infostream.put;
         (if S.label
          // gram.bindingDecl // gram.finalDecl then
             infostream.newline;
             S.son->B; B.brother->BS; 
             (if BS.label = gram.objectDescriptor then
                 BS.son->BSpre; 
                 (if BSpre.label = gram.empty then
                     BS->addPrefix
                     (# astOverflow:: 
                          (#do msg[]->thisTranslate.MPSexception #) 
                     #)
      if)if)if)#)
   #)
