ORIGIN '~beta/basiclib/betaenv';
LIB_ITEM 'betacompiler';
INCLUDE '~beta/basiclib/texthash';
BODY 'combody'
-- LIB: Attributes --
CommonDef:
  (# 
     verboseLevel: @ (* Level of output during compilation: *)
       (# v: @Integer;
          verbose: (# exit 0 #); (* more than default? *)
          default: (# exit 1 #); (* normal, the old way, open, bind, etc. *)
          actions: (# exit 2 #); (* only if somthing happens, parse, etc.*)
          nothing: (# exit 3 #); (* nothing, only errors *)
       enter v
       exit v
       #);
     
     betaenv: @
       (* Info about actual betaenv *)
       (# private: @<<SLOT com_betaenv_private:descriptor>>;
          groupname:
            (# g: ^text;
            <<SLOT com_betaenv_group:dopart>>
            exit g[]
            #);
          formname:
            (# f: ^text;
            <<SLOT com_betaenv_form:dopart>>
            exit f[]
            #);
          packagename:
            (# p: ^text;
            <<SLOT com_betaenv_package:dopart>>
            exit p[]
            #);
          set:
            (# g, f: ^text;
            enter (g[], f[])
            <<SLOT com_betaenv_set:dopart>>
            #);
          is_set: @boolean;
       #);
     TextValue: (* should be in betaenv *)
       (# value: ^text
       do inner
       exit value[]
       #);
     BetaPackage: TextValue
       (* Name og java package BETA patterns are put into *)
       (# <<SLOT BetaPackage:dopart>> #);
     BetaArrayLocation: TextValue
       (* Used by clr bytecode *)
       (# <<SLOT BetaArrayLocation:dopart>> #);
     StructureLocation: TextValue
       (* Used by clr bytecode *)
       (# <<SLOT StructureLocation:dopart>> #);
     ComponentLocation: TextValue
       (* Used by clr bytecode *)
       (# <<SLOT ComponentLocation:dopart>> #);
     ComponentClass: TextValue
       (* Name of class defining Components *)
       (# <<SLOT ComponentClass:dopart>> #);
     BetaObjectClass: TextValue
       (* Name of class defining BetaObject *)
       (# <<SLOT BetaObjectClass: dopart>> #);
     BetaArrayClass: TextValue
       (* Name of class defining BetaArray *)
       (# <<SLOT BetaArrayClass: dopart>> #);
     StructureClass: TextValue
       (* Name of class defining Structure *)
       (# <<SLOT StructureClass: dopart>> #);
     doMethod: TextValue(# <<SLOT doMethod:doPart>> #);
     enterMethod: TextValue(# <<SLOT enterMethod:doPart>> #);
     exitMethod: TextValue(# <<SLOT exitMethod:doPart>> #);
       
     priv: @ <<SLOT comPrivate:descriptor>>;
     count: (# key: @integer enter key <<SLOT comCount:dopart>> #);
     print: <<SLOT comPrint:descriptor>>;
     
     init:< (#  do honeyM.init; INNER #);
     theGroupName: ^text; (* group file currently being translated*)
     
     SrcExt: (# exit '.bet' #);
     LstExt: (# exit '.lst' #);

     symbMax,prodMax: @integer;
     standard: (#  exit - 1 #);
     
     nameManglingCh: (# ch: @char <<SLOT nameManglingCh:doPart>> exit ch #);
     (* standard and preDefined means the same *)
     preDefined: (#  exit - 1 #);
     unDefined: (#  exit - 2 #);
     beingChecked: (#  exit - 3 #);
     rangeOff: (#  exit 3 #);
     
     (* external parameter types *)
     byteXpar: (#exit 1 #);
     shortXpar: (#exit 2 #);
     longXpar: (#exit 3 #);
     textXpar: (#exit 4 #);
     repetitionXpar: (#exit 5 #); (* is this type still used? *)
     cStructXpar: (#exit 6 #);
     doubleXpar: (#exit 7 #);
     varPtnCXpar: (#exit 8 #);
     varPtnPascalXpar: (#exit 9 #);
     dataXpar: (#exit 10 #);
     varPtnStdXpar: (#exit 11 #);(* Currently only relevant for Windows NT*)
     COMobjectXpar: (#exit 12 #);
     wtextXpar: (#exit 13 #);
     holderXpar: (#exit 14 #);
     dataXPartPar: (#exit 15 #);
     int64Xpar: (#exit 16#);
     BSTRXpar: (#exit 17 #);
     externalClassXpar: (# exit 18 #); (* used to be externalString
                                        * but no longer so *)
     externalStringXpar: (# exit 19 #);
     real32Xpar: (# exit 20 #);
     
     (* Logical conditions for e.g. mch.cmpToBool *)
     cond_always: (# exit 0 #);
     cond_eq:     (# exit 1 #);
     cond_ne:     (# exit 2 #);
     cond_lt:     (# exit 3 #);
     cond_le:     (# exit 4 #);
     cond_gt:     (# exit 5 #);
     cond_ge:     (# exit 6 #);
     cond_gtu:    (# exit 7 #);
     cond_leu:    (# exit 8 #);
     cond_geu:    (# exit 9 #);
     cond_ltu:    (# exit 10 #);
     cond_pos:    (# exit 11 #);
     cond_neg:    (# exit 12 #);
     cond_vc:     (# exit 13 (* overflow clear *) #);
     cond_vs:     (# exit 14 (* overflow set *) #);
     cond_never:  (# exit 15 #);
     
     (* constants from constant.h in C betarun *)
     (* Prototype constants *)
     ComponentPTValue: (#  exit - 1 #);
     StackObjectPTValue: (#  exit - 2 #);
     StructurePTValue: (#  exit - 3 #);
     RefRepPTValue: (#  exit - 4 #);
     LongRepPTValue: (#  exit - 5 #);
     ByteRepPTValue: (#  exit - 6 #);
     ShortRepPTValue: (#  exit - 7 #);
     DoubleRepPTValue: (#  exit - 8 #);
     DopartObjectPTValue: (#  exit - 9 #);
     DynItemRepPTValue: (#  exit - 10 #);
     DynCompRepPTValue: (#  exit - 11 #);
     MaxPTValue: (#  exit - 1 #);
     MinPTValue: (#  exit - 11 #);
     IOAMinAge: (# exit 0 #);
     IOAMaxAge: (# exit 128 #);
     (* Max number of bytes in Cpk* operations *)
     MAXCTEXTPOOL: (#  exit 1000 #);
     (* Max range for value repetitions in IOA *)
     LARGE_REP_SIZE: (#  exit 256 #);
     ;
     (* Beta.dump error codes *)
     RefNoneErr: (# exit -1 #) (* Reference is none *) ;
     CompTerminatedErr: (# exit -2 #) (* Executing terminated component *) ;
     RepRangeErr: (# exit -3 #) (* Repetition index out of range *) ;
     ArithExceptErr: (# exit -4 #) (* Arithmetic exception *) ;
     RepSubRangeErr: (# exit -5 #) (* Repetition subrange out of range *) ;
     RepLowRangeErr: (# exit -6 #) (* Repetition subrange out of range (low) *) ;
     RepHighRangeErr: (# exit -7 #) (* Repetition subrange out of range (high) *) ;
     StopCalledErr: (# exit -8 #) (* Stop is called *) ;
     LVRAfullErr: (# exit -9 #) (* LVRA is full *) ;
     ZeroDivErr: (# exit -10 #) (* Integer division by zero *) ;
     CompCallBackErr: (# exit -13 #) (* Suspending component involving call backs *) ;
     LeaveBasicCompErr: (# exit -14 #) (* Illegal leave/restart *) ;
     QuaErr: (# exit -15 #) (* Qualification error in reference assignment *) ;
     RecursiveAttErr: (# exit -17 #) (* Attempt to attach a component that is already attached *);
     DumpStackErr: (# exit -39 #) (* User requested stack dump and program continuation *)
     ;
     (***** object kinds: *********)
     itemKind: (# exit 1 #);
     compKind: (# exit 2 #);
     prefKind: (# exit 3 #);
     strucKind: (# exit 4 #);
     comKind: (# exit 5 #);
     comVirtualKind: (# exit 6 #);
     holderKind: (# exit 7 #);
     ;
     (***** size of structural attributes ******)
     preStrucsize: (#  exit 8 #);
     refSize: (#  exit 1 #);
     compHeadSize: (#  exit 6 #);
     (* must be 8-byte aligned *)
     repDopeSize: (#  exit 1 #);
     forSize: (#  exit 2 #);
     labelSize: (#  exit 1 #);
     direct: (#  exit 0 #);
     cstInd: (#  exit 1 #);
     varInd: (#  exit 2 #);
     two8: (#  exit 256 #);
     two11: (#  exit 2048 #);
     two15: (#  exit 32768 #);
     two16: (#  exit 65536 #);
     two24: (#  exit 16777216 #);
     noneVal: (#  exit 0 #);
     
     (********************* target platforms ********************)
     sun3: (#  exit 1 #);                           (* not used *)
     sun4: (#  exit 2 #);                           (* not used *)
     sun4s: (#  exit 3 #);                          
     hp: (#  exit 4 #);                             (* not used *)
     hpux8: (#  exit 5 #);                          (* not used *)
     snake: (#  exit 6 #);                          (* not used *)
     apollo: (#  exit 7 #);                         (* not used *)
     mac: (#  exit 8 #);                            (* not used *)
     linux: (#  exit 9 #);
     nti: (#  exit 10 #);                           (* not used *)
     dx200: (#  exit 11 #);                         (* not used *)
     sgi: (#  exit 12 #);
     hpux9mc: (#  exit 13 #);                       (* not used *)
     hpux9pa: (#  exit 14 #);
     (* ppc:    Macintosh b2c based compiler;
      * ppcmac: Macintosh native compiler;
      * ppcos2: OS/2 native compiler
      *)
     ppc: (#  exit 15 #);                           (* not used *)
     (* ppc: kjm 20/10/94 *)
     ppcmac: (#  exit 16 #);
     ppcos2: (#  exit 17 #);                        (* not used *)
     nti_ms: (# exit 18 #);
     nti_gnu: (# exit 19 #);
     nti_bor: (# exit 20 #);                        (* not used *)
     x86sol: (# exit 21 #);
     jvm: (# exit 22 #); (* Java bytecode *)
     clr: (# exit 23 #); (* .NET bytecode *)
     macosx: (# exit 24 #);
     
     b2c: (#  exit 123 #);                          (* not used *)
     (* Variables representing targetMachine *)
     targetDirectory: @text; (* directory for asm- and obj-files *)
     targetMachine: ^text;
     targetMachineId: @integer;
     isIntel: booleanValue
       (# 
       do (if targetMachineId 
           // linux
           // nti_gnu
           // nti_ms
           // x86sol
              then true -> value;
          if);
       #);
     isRisc: booleanValue
       (# 
       do (if targetMachineId 
           // sun4s
           // sgi
           // ppcmac
           // macosx
           // hpux9pa
              then true -> value;
          if);
       #);
     SetTargetMachineId: integerValue
       (# targetMach: ^text
       enter targetMach[]
       do targetMach[]->targetMachine[];
          (if true
           // 'sun4s'->targetMachine.equal then
              sun4s->value
           // 'hpux9pa'->targetMachine.equal then
              hpux9pa->value
           // 'linux'->targetMachine.equal then
              linux->value
           // 'x86sol'->targetMachine.equal then
              x86sol->value
           // 'nti'->targetMachine.equal then
              nti->value
           // 'nti_ms'->targetMachine.equal then
              nti_ms->value
           // 'nti_gnu'->targetMachine.equal then
              nti_gnu->value              
           // 'sgi'->targetMachine.equal then
              sgi->value
           // 'ppcmac'->targetMachine.equal then
              ppcmac->value
           // 'jvm'->targetMachine.equal then
              jvm->value
           // 'clr'->targetMachine.equal then
              clr->value
           //'macosx' -> targetMachine.equal then
              macosx -> value;
           else
              '\n\n**** The platform: "'->puttext;
              targetMach[] -> puttext;
              '" is not supported!\n'->putline;
          if);
          value->targetMachineId          
       #);
     RshSupport: booleanValue
       (# machine: ^text
       enter machine[]
       do (if true
           // ('sun4s'->Machine.equal)
           // ('hpux9pa'->Machine.equal) 
           // ('linux'->Machine.equal)
           // ('sgi'->Machine.equal)  then
              true->value
          if)
       #);
     (* The following patterns are used for passing exceptions from
      * machine.bet to the compiler pattern in system.bet
      *)
     PassCodeFileAccessError:< (# FN: ^text enter FN[] do INNER #);
     PassNoSpaceError:< object;  (* disk is full *)
     PassOtherError:< (# FN,msg: ^text enter(FN[],msg[]) do INNER #);

     infostream, (* see system.bet *) tracestream,messagestream,bugstream:
       ^stream;
     honeyM: @honeyMan;
     
     (* switch handling *)
     switch: [500] @boolean;

  #);
exact_log2:
  (* Exit the logarithm of X, base 2, considering X unsigned,
   * if X is a power of 2.  Otherwise, returns -1.
   *)
  (# x,log: @integer; 
  enter x
  do
     calc: (* Test for 0 or a power of 2. *)
       (if x = 0 then
           -1->log;
        else
           (if (x <> ((x) %Band (-x))) then - 1->log; leave calc; if);
           shift:
             (if ((x %srl 1)->x) = 0 then
                 leave shift
              else
                 log+1->log; 
                 restart shift; 
             if);
           
       if)
  exit log
  #);


