ORIGIN 'translate_controlbody';
INCLUDE '../GENERATOR/machine';
INCLUDE '../GENERATOR/asmlink';
BODY   'translate_libsbody';
---xDependencyLib:attributes---

PutInJobfile: 
  (# asm,inLink: @boolean;   (* asm=true: do assemble file
                              * inLink=true: object file in library
                              *)
     kind: @integer;  (* See Asmlink for def. of the kinds. *)
     fullname: ^Text;
  enter(fullname[],asm,kind,inLink)
  do (* 'PutInJobfile: '->puttext; fullname[]->putline; *)
     (if kind 
      // asmlink.BetaKind 
      // asmLink.BetaEnvKind 
      // asmLink.BetaDataKind 
      // asmLink.ByteCodeKind 
      // asmLink.ByteCodeFileKind then
         ((fullname.copy,false)->insertSubDir,kind,asm,inLink)
           -> AsmLink.TX.insert;
      else
         (fullname[],kind,false,false) -> AsmLink.TX.insert;
     if);
     (fullname[],kind,asm,inLink) -> thisTranslate.addedToJobfile
  #);
checkCodeSubDir: 
  (* Checks whether or not the code sub directory denoted by
   targetDirectory has already been created. If not then
   it is created now ! 
   *)
  (# g: ^FragmentGroup; asmDir: @boolean
  enter(g[],asmDir)
  do <<SLOT CheckCodeSubDir: descriptor>>
  #);

calcGroupID: (* calculate 'unique' hash value for filename *)
  (# g:^FragmentGroup; id: @text
  enter g[]
  <<SLOT calcGroupId:doPart>>
  exit id[]
  #);
MakeBetaDataFile: (#do <<SLOT MakeBetaDataFile:descriptor>> #);

---translateAfterGroup:dopart---
do (# inLib: @boolean
   do (fg[],doAsm) ->sharedLibs.scanLibraryProp -> inLib;
      (if switch182 then
          (if fg.controller.status < 5 (*doAsm*) then
              (* File not generated now, but must be 
               * included in link including all classes defined by it *)
              (fg.NameT[],doAsm,asmlink.ByteCodeFileKind,inLib)
                -> PutInJobfile;
           else
              (* File generated now *)
              (if common.switch[184] or common.switch[189] then
                  (* .NET *)
                  (if fg.origin = none then (* betaenv *)
                      (* skip - added by SetFileName *)
                   else
                      (* Add file itself *)
                      (fg.NameT[],doAsm,asmlink.ByteCodeKind,inLib)
                        -> PutInJobfile
                  if)
               else
                  (* Java - nothing needed *)
              if)
          if);
       else
          (if fg.origin = none then (* betaenv *)
              (fg.NameT[],doAsm,asmlink.BetaEnvKind,inLib)->PutInJobfile
           else
              (fg.NameT[],doAsm,asmlink.BetaKind,inLib)->PutInJobfile
          if);
      if)
   #)
---BuildProperty:doPart--
do (if command[] <> NONE then
       (directory[],command[]) -> asmlink.build.insert
   if);
   (objFile[],false,asmLink.objKind,false) -> putInJobFile;
   
---currentProperty:doPart---
do (if propKind
    // makeProperty then 
       (arg[],false,asmLink.MakeKind,false) -> putInJobFile
    // objfileProperty then
       (arg[],false,asmLink.objKind,false) -> putInJobFile
    // libFileProperty then
       (arg[],false,asmLink.libKind,false) -> putInJobFile
    // linkoptProperty then
       (arg[],false,asmLink.linkOptKind,false) -> putInJobFile
    // resourceProperty then
       (arg[],false,asmLink.ResourceKind,false) -> putInJobFile
    // betarunProperty then
       (if asmlink.betarun.length=0 then
           (if b2c then
               arg[]-> expandEnvVar -> arg[];
               rundkoersel: '$' -> arg.findAll
               (# bt: @Text;
               do (* Delete the '$'. *)
                  (inx,inx) -> arg.Delete;
                  'b2c'->bt;
                  thePathHandler.directoryChar->bt.put;
                  (bt[],inx) -> arg.Insert;
                  inx+4->inx;
                  (TargetDirectory[],inx) -> arg.Insert;
                  (* Necessary? *)
                  restart rundkoersel
               #);
           if);
           (arg[],theGroup.nameT[]->stripPathName) 
             -> thePathHandler.convertFilePath
             -> arg[]
             -> isFile;
       if);
       arg -> asmLink.betarun;
    else
       '\n**** unknown property!'->putline 
   if)
---handleFragmentsdo:doPart---
do rootFragment[] -> asmlink.rootFragment[];   
   (if (asmLink.jobFileMachine[] <> NONE) and (outputFile[] = NONE) then
       (* ensure that full path is used for output file
        * when using remote shell
        *)
       rootFragment[] -> outputFile[];
       true -> clearOutputFile;
   if);
   397->trace(#do 'Root:'->xT; rootFragment[]->xT #);
   (if outputFile[] = NONE then
       (* objName is same name as rootFragment *)
       rootfragment[] -> asmLink.ObjName[]
    else 
       (outputFile[],'')
         -> thePathHandler.ConvertFilePath
         -> asmLink.ObjName[]; 
   if);
   (if clearOutputFile then NONE -> outputFile[] if);
   397->trace(#do 'ObjName:'->xT;asmLink.objName[]->xT #);
   
   (if asmlink.hasSharedLibs then SharedLibs.Make if);
   
   (*do not link if no program SLOT*)
   (common.switch[6]) or (not DGP.hasProgramSlot)->common.switch[6];
   (* no betadata if nolink or nocode *)
   (if not common.switch[6] and not common.switch[5] 
       or common.switch[372] then
       common.switch[390] ->
       CheckSlots
       (# unBoundSlots: @boolean;
          UnboundSlot::
            (#
            do (if common.switch[198] or hasProgramSlot then
                   (* It should be discussed when the  message below
                    * should be given
                    *)
                   '\n**** The slot: "'->puttext;
                   slot[] -> puttext;
                   '" defined in fragment:\n\t'->puttext;
                   FG.fullname->putline;
                   'is not bound by any fragment!'->putline
               if);
               true -> unBoundSlots;
            #);
          DoubleDeclaration::
            (#
            do '\n**** The slot: "'->puttext;
               slot[] -> puttext; (* ':'->put; category[] -> puttext; *)
               '" is defined in the following two fragments:\n\t'
                 -> puttext;
               FG1[] -> putline; '\t'->puttext;
               FG2[] -> putline
            #);
          PerhapsMissingBinds::
            (#
            do '\n**** Warning!\n     The slot: "'->puttext;
               slot[] -> puttext;
               '" is defined in '->puttext;
               noOfDefs->putint;
               ' fragment(s),\n     but only bound in '->puttext;
               noOfbinds->putint;
               ' fragment(s)!'->puttext;
               '\n     This may cause an "Undefined symbol"'->puttext;
               '\n     error message from the linker!\n'->puttext
            #)
          
       do (if unBoundSlots then 
              (* we override the value of hasProgramSlot;
               * i.e. hasProgramSlot now means that the program
               * may be linked; if false it means that there
               * are unbound slots
               *)              
              false -> DGP.hasProgramSlot 
          if);
       #);

       MakeBetaDataFile 
   if);
   (common.switch[6]) or (not DGP.hasProgramSlot)->common.switch[6];
   (* see MakeBetaDataFile, where hasProgramSlot may be overwritten *)
   (* <<SLOT analyzeHeap:descriptor>>;*)
   
--CalcGroupId:doPart--
do (# hash: @integer; localPath: ^text;
   do (this(AstInterface)[],g.fullName) -> BetaLibLocalName -> localPath[];
      386->trace(#do 'CalcGroupId: LocalPath: ' -> xT; localPath[] -> xT #);
                   (* localPath.scanAll(# do (ch*517)+hash->hash #);  
                    * hash->id.putint;
                    *)
      localPath[] -> common.honeyM.hash -> id.putint;
      '_'->id.put; 
      g.modtime->id.putint;
   #)
--ControlSetGroupID:descriptor--
(# T: ^Text; hash: @integer;
do g[] -> CalcGroupId -> T[];
   (T[],this(AstInterface)[],g[])->setGroupIDProperty;
#)
---- CheckCodeSubDir: descriptor ----
(# codeDir: @directory
     (# doCreateDir: createDir
          (# error::< 
               (* createDir can fail (UNIX only?) if path is empty 
                * or for one of the following reasons (from "man 2 mkdir"):
                * [EACCES] A component of the path prefix denies search
                *          permission.                
                * [EACCES] The parent directory of the new directory 
                *          denies write permission.                
                * [EEXIST] The named file already exists.                
                * [EFAULT] path points outside the process's allocated address
                *          space.  The reliable detection of this error is
                *          implementation dependent.                
                * [EIO] An I/O error occurred while writing to the file system.
                * [ELOOP] Too many symbolic links are encountered in 
                *         translating the path name.                
                * [EMLINK] The maximum number of links to the parent directory,
                *          {LINK_MAX}, would be exceeded.                
                * [ENAMETOOLONG] The length of the specified path name 
                *                exceeds PATH_MAX bytes, or the length of a 
                *                component of the path name exceeds NAME_MAX 
                *                bytes while _POSIX_NO_TRUNC is in effect.
                * [ENOENT] A component of the path prefix does not exist.
                * [ENOSPC] Not enough space on the file system.
                * [ENOTDIR] A component of the path prefix is not a directory.
                * [EROFS] The named file resides on a read-only file system.
                *)               
               (# 
               do (*cleanUpAfterException;*) 
                  codeDirPath[]->thisTranslate.transCreateDirException
               #)
          #)
     #);
   codeDirEntry: @diskEntry
     (# doExists: exists
          (# error::< 
               (* exists can fail for the following reasons (UNIX only?):
                *   1. path is empty
                *   or (from "man lstat")
                *   2. A component of the path prefix is not a directory.
                *   3. Search permission is denied for a component of 
                *      the path prefix.
                *   4. Too many symbolic links were encountered in 
                *       translating the path name.
                *   5. The length of the specified path name exceeds PATH_MAX 
                *      (255 or 1023 machine dependent) bytes
                *)
               (# T: @text
               do (*cleanUpAfterException; *)
                  (* the *** in order to distingusihthis exception from
                   * the above one
                   *)
                  '      ***'-> (codeDirPath.copy).Append
                    -> thisTranslate.transCreateDirException
     #)#)#);
   asmFileName,FullFN,codeDirPath,codeSubDir: ^text; 
   dirCh: @char; lastslash: @integer;
   
   (* NOTE: a change has been made to also handle b2c compiler variants.
    * checkCodeSubDir has been extended with an additional parameter
    *    subDir
    * which for non b2c compilers is asmLin.asmExt.
    * For b2c compilers the procedure is called twice:
    *    1.  subDir = 'b2c'
    *    2.  subDir = asmLink.asmExt
    *)
do (*g[]-> createAsmFileName -> asmFileName[];*)
   (g.nameT.copy,asmDir)->insertSubDir(#do asmLink.asmExt->path.append #)
     ->asmFileName[];
   thePathHandler.DirectoryChar->asmFilename.findAll(#do inx->lastSlash #);
   
   (0,lastSlash-1)->asmFilename.sub->codeDirPath[]->codeDirEntry.path;
   (* codeDirPath = (users/borge/mycode/foo/sun4s (e.g.) *)   
   thePathHandler.DirectoryChar
     ->codeDirPath.findAll(# do inx -> lastSlash #);
   
   (0,lastSlash-1)->codeDirPath.sub->codeDir.name;
   (lastSlash+1,codeDirPath.length)->codeDirPath.sub->codeSubDir[];

   
   (* codeDir = /users/borge/mycode/foo *)

   (if common.switch[397] then 
       '\nChekCodeSubDir:\n'->tracestream.puttext; 
       codeDir.name->tracestream.putline;
       codeDirEntry.path->tracestream.putline;
       codeSubDir[]->tracestream.putline
   if);
   (if not codeDirEntry.doexists then
       (if common.switch[397] then
           'Does NOT exists: '->tracestream.puttext;
           codeDirEntry.path->tracestream.putline
       if);
       codeSubDir[]->codeDir.docreateDir
   if);

#)

--MakeBetaDataFile:descriptor--
(# f: @File;
   noOfFiles,i:@Integer;
   betaenv: ^FragmentGroup;
   name,c_file_name,id: ^Text;
   mchFactory: @machineFactory;
   mch: ^mchFactory.abstractMachine;
   checkConsistency:
     (# fg: ^fragmentGroup;
        noneC,defC: @integer;
        msg:
          (# n: @integer
          enter n
          do (if n < 4 then
                 '\n\n**** Inconsistent fragment group:\n\t'
                   -> bugstream.puttext;
              else
                 '\nConsistencey check for:\n\t'-> messagestream.puttext
             if);
             fg.name->bugstream.puttext;
             (if n
              // 1 then '\nMix of open and closed forms' -> bugstream.putline
              // 2 then '\nOpen forms and prop[]=NONE' 
                   -> bugstream.putline
              // 3 then
                 '\ngrammar is NONE!'-> bugstream.putline;
              // 4then
                 '\ndefC='->messageStream.puttext; defC->messageStream.putint;
                 ' noneC='->messageStream.puttext; noneC->messageStream.putint;
                 ' prop[] '->messageStream.puttext; 
                 (if fg.prop[] = NONE then '= NONE\n'->messagestream.puttext
                  else
                     '<> NONE\n'->messagestream.puttext
                 if)
             if)
          #)
     enter fg[]
     do fg.fragmentlist.scan
        (# ff: ^fragmentForm
        do (if current.type = formType then
               (if current.form = NONE then noneC + 1 -> noneC
                else defC + 1 -> defC;
                   current.form -> ff[];
                   (if ff.grammar[] = NONE then 3 -> msg if);
               if);

           if)
        #);
        (if verboseLevel <= verboseLevel.verbose then 
            4 -> msg
        if);
        (if (noneC > 0) and (defC > 0) then 1 -> msg if);
        (if (defC > 0) and (fg.prop[] = NONE) then 2 -> msg if);
     #);
do (if b2c then
       'Creating betadata file...'->infostream.puttext;
       asmLink.ObjName.copy->expandToFullPath->name[];
       thePathHandler.DirectoryChar->name.findAll(# do inx->i #);
       (i+1,name.length)->name.delete; 
       name.copy->c_file_name[];'b2c'->c_file_name.append; 
       thePathHandler.DirectoryChar->c_file_name.put;
       'betadata'->c_file_name.append;
       '.c'->c_file_name.append;
       'betadata'->name.append;
       c_file_name[]->f.name;
       f.openwrite;
       '\n/* auto-generated BETA_DATA file */\n\n'->f.puttext;
       DGP.groupList.scan
       (#
       do (if current.g.controller.status>justOpen then
              'extern long BETA_DATA_'->f.puttext;
              (this(AstInterface)[],current.g[])->getGroupIDProperty->id[];
              (if id[] = NONE then current.g[]->calcGroupID->id[] if);
              id[]->f.puttext;
              ';\n'->f.puttext;
              noOfFiles+1->noOfFiles;
              (if current.g.origin = NONE then current.g[]->betaenv[] if);
          if)
       #);
       'long *BETA_data1['->f.puttext; noOfFiles+1->f.putint;
       '] = {\n\t&BETA_DATA_'->f.puttext;
       (this(astInterface)[],betaenv[])->getGroupIDProperty->id[];
       (if id[] = NONE then betaenv[]->calcGroupID->id[] if);
       id[]->f.puttext;
       ',\n\t'->f.puttext;
       DGP.groupList.scan
       (#
       do (if current.g.controller.status>justOpen then
              (if current.g.origin<>NONE then 
                  '&BETA_DATA_'->f.puttext;
                  (this(AstInterface)[],current.g[])->getGroupIDProperty->id[];
                  (if id[] = NONE then current.g[]->calcGroupID->id[] if);
                  id[]->f.puttext; 
                  ', /*'->f.puttext; 
                  current.g.fullname->f.puttext;
                  '*/\n\t'->f.puttext;
              if);
          if)
       #);
       '0\n};\n'->f.puttext;
       f.close;
       (name[],true,asmlink.BetaKind,false)->PutInJobfile;
       infostream.newline;
    else
       (* MUST be unified with the b2c case;
        * In addition to creation of BETA_DATA, a check for dublicate
        * and unbound slots is made.
        *)
       (if verboseLevel <= verboseLevel.verbose then 
           'Creating betadata file...'->infostream.puttext
       if);
       (# F: @file
       do astFileExtension 
            -> (asmLink.rootFragment.copy
            -> expandToFullPath).append 
            -> f.name;  
          (*'\nbeta-data1: ' -> puttext; f.name -> putline;*)
          f.entry.path.head -> name[];
          (*'head: "' -> puttext; name[] -> puttext; '"'->put;newline;*)
          thePathHandler.directoryChar -> name.put;
          f.entry.modtime -> name.putint;
          (*'\nbeta-data2: ' -> puttext; name[] -> putline;*)
       #);
       common[] -> mchFactory -> mch[];
       ((name.copy,(not nti))
         ->InsertSubDir(#do Asmlink.asmExt->path.append #)
       ,common[]) 
         -> mch.createDataFile
       (#
       do DGP.groupList.scan
          (# idx: ^text
          do (if common.switch[67] then current.g[]->CheckConsistency if);
             (if current.g.controller.status > justOpen then
                 (this(AstInterface)[],current.g[])->getGroupIDProperty->id[];
                 391->trace(#do 'id: '-> xT; id[] -> xT #);
                 (if id[] = NONE then 
                     current.g[]->calcGroupID->id[];
                     391->trace(#do ' NONE: '-> xT; id[]-> xT #);
                 if);
                 id.copy -> idx[];
                 'BETA_DATA_'->idx.prepend;
                 (idx[],current.g.fullName,current.g.origin=NONE) 
                   -> mch.NextGroup;
                 386->trace
                 (#do idx[]->xT; ' '->put; 
                    (this(AstInterface)[],current.g.fullName) -> BetaLibLocalname->xT 
                 #);
             if);
             
       #)#);

       (name[],true,asmlink.BetaDataKind,false)->PutInJobfile;
       (if verboseLevel <= verboseLevel.verbose then infostream.newline if);
   if)
#)

---translate_doTheCodeGen:doPart---
do (#     (* theSynthesizer: ^Synthesizer;*)
      Prepare:
        (#
        do (if verboseLevel <= verboseLevel.actions then
               'Code generation'->infostream.puttext;
           if);
           (if b2c or nti then
               (g[],true)->checkCodeSubDir;
               (g[],false)->checkCodeSubDir;
               (if ((this(AstInterface)[],g[])->getGroupIDProperty) = NONE then
                   (* temporary set GroupID, it must not be saved on disk! *)
                   g[]->ControlSetGroupID;
               if)
            else 
               (g[],false)->checkCodeSubDir;
               (if ((this(AstInterface)[],g[])->getGroupIDProperty)= NONE then
                   (* temporary set GroupID, it must not be saved on disk! *)
                   g[]->ControlSetGroupID;
               if)
           if);
        #);
      Conclude:
        (#
        do G.name -> thisTranslate.codegenFragment;
           (*none->theSyntheSizer[];*)
        #)
   do Prepare;
      
      (* &Synthesizer[]->theSynthesizer[];*)
      (if (G[],g[]->CreateAsmFileName)->(*the*)Synthesizer then 
          (g[],16)-> thisTranslate.msgException
      if);
      
      Conclude; 
   #)
