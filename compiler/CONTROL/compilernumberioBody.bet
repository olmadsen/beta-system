ORIGIN 'compilernumberio';
INCLUDE '~beta/basiclib/v1.5/math';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-95
 *       All rights reserved.
 *)   
--- compilernumberIoGetNumberBody: descriptor ---
(#
do readNumber:
     (# ch: @char; negative, noLeadingInt: @boolean;
        eosTest: @eos; getC: @get; peekC: @peek;
        nextch: @
          (#
          do (if not eosTest then getC if);
             (if eosTest then ascii.nul->ch else peekC->ascii.upCase->ch if)
          #);
        skip: @
          (#
          do (if eosTest then
                 ascii.nul->ch
              else (if ((peekC->ascii.upCase->ch) <= ' ') then
                       getC; restart skip if)
             if)
          #);
        sign: @
          (# do (if ch
                 // '-' then true->negative; nextch
                 // '+' then nextch
                if)
          #);
        leadingInt: @
          (#
          do (if not (ch->ascii.isDigit) then true->noLeadingInt if);
             ReadDigits:
               (if (ch->ascii.isDigit) then
                   V * 10 + ( ch - '0')->V;
                   nextch;
                   restart readDigits
               if)
          #);
        Digits: @
          (# lz: @integer (* number of leading zero's *) 
          do 1->accuracy; 0->lz;
             (if (ch->ascii.isDigit) then 
                 0->V;
                 L: (if ch = '0' then
                        1+lz->lz; accuracy*10->accuracy;
                        nextch; restart L
                    if);
                 L:(if (ch->ascii.isDigit) then
                       accuracy*10->accuracy;
                       V*10+(ch-'0')->V;
                       nextch; restart L 
                   if)
              else (if not eosTest then peekC->syntaxError if);
                 leave readNumber
             if)
          exit lz
          #);
        Exponent: @
          (# neg: @boolean
          do false->neg;
             (if ch
              // '+' then nextch
              // '-' then true->neg; nextch
             if);
             Digits; (if neg then -V->V if)
          #);
        toReal: @
          (# value: @real;
          do (* '\ntoReal:'->screen.puttext;
              * ' A: '->screen.puttext; A -> screen.putint;
              * ' B: '->screen.puttext; B -> screen.putint;
              * ' C: '->screen.puttext; C -> screen.putint;
              * ' D: '->screen.puttext; D -> screen.putint;
              *)
             A->value;
             (if (D<>0)//true then
                 (if (B<>0)//true then
                 value+(B div D)->value;
             if)if);
             (if true
              // C<0 then
                 value div ((10,-C)->pow) -> value
              // C>0 then
                 value * ((10,C)->pow) -> value
             if)
          exit value
          #);
        BasedNumber: @
          (# log, digit: @integer;
             exact_log2: @
               (* Exit the logarithm of X, base 2, considering X unsigned,
                * if X is a power of 2.  Otherwise, returns -1.
                *)
             (# x: @integer;
             enter x
             do calc:
                  (* Test for 0 or a power of 2. *)
                  (if x=0 then
                      -1->log; 
                   else
                      (if x <> ((x,-x)->TOS'%and') then
                          -1 -> log;
                          leave calc;
                      if);
                      shift:
                        (if (x div 2 -> x)=0 then
                            leave shift;
                         else
                            log+1->log; restart shift;
                        if);
                  if)
             #)
          do (if negative then -V->base else V->base if);
             (if (base>126) then base->baseError; leave readNumber
              else
                 (if eosTest then syntaxError if);
                 (if base = 0 then 16->base if);
                 0->N; base->exact_log2; 
                 (if log<>-1 then
                     (* base is a power of 2 *)
                     L: (if true
                         // ch->ascii.isDigit then 
                            (if (ch-'0'->digit) >= base then
                                ch->valueerror; leave readNumber if);
                            (N * base)+digit->N; nextch; restart L; 
                         // ch->ascii.isLetter then 
                            (if (ch-'A'+10->digit) >= base then
                                ch->valueerror; leave readNumber if);
                            (N * base)+digit->N; nextch; restart L
                        if)
                  else
                     L: (if true
                         // ch->ascii.isDigit then 
                            (if (ch-'0'->digit) >= base then
                                ch->valueerror; leave readNumber if);
                            N*base+digit->N; nextch; restart L; 
                         // ch->ascii.isLetter then 
                            (if (ch-'A'+10->digit) >= base then
                                ch->valueerror; leave readNumber if);
                            N*base+digit->N; nextch; restart L
             if)if)if);
             (if negative then -N->N if);
          #);
        V,A,B,C,D,accuracy: @real;
        N,lz,base: @integer
     do 0->V; false->negative;
        10->base;
        skip;
        (if ch = ascii.nul then EOSerror if);
        sign;
        leadingInt;
        (if negative then -V->V if);
        (if ch
         // '.' then
            (if true
             // realValue##<realValuePtn## then
                V->A; nextch; Digits->lz;
                (if negative then -V->V if);
                V->B; accuracy->D;
                (if ch = 'E' then nextch; Exponent; V->C if);
                (A,B,lz,C,toReal)->realValue
             // integerValue##<integerValuePtn## then
                V->integerValue
             // basedValue##<basedValuePtn## then
                peekC->syntaxError
             else leave readNumber
            if)
         // 'E' then
            (if true
             // realValue##<realValuePtn## then
                V->A; nextch; Exponent; V->C;
                (A,B,0,C,toReal)->realValue
             // integerValue##<integerValuePtn## then
                V->integerValue
             // basedValue##<basedValuePtn## then
                peekC->syntaxError
             else leave readNumber
            if)
         // 'X' then
            (if true
             // basedValue##<basedValuePtn## then
                nextch; BasedNumber;
                (base,N)->basedValue
             // integerValue##<integerValuePtn## then
                V->integerValue
             // realValue##<realValuePtn## then
                (V,0,0,0,V)->realValue
             else leave readNumber
            if)
         else
            (if noLeadingInt then 
                (if not eosTest then peekC->syntaxError if);
                leave readNumber
            if);
            (if true
             // integerValue##<integerValuePtn## then V->integerValue
             // realValue##<realValuePtn## then (V,0,0,0,V)->realValue
             // basedValue##<basedValuePtn## then peekC->syntaxError (*(10,V)->basedValue *)
             else leave readNumber
            if)
        if)
     #)
   #)

--- compilernumberIoGetRadixRadixErrorDopart: dopart ---
do 'getRadix: Illegal radix: "'->msg.append; 
   radix->msg.putInt; '"'->msg.put;
   INNER radixError
   
--- compilernumberIoGetRadixBody: descriptor ---
(# ch: @char; negative: @boolean; eosTest: @eos; getC: @get; peekC: @peek;
   nextch: @
     (#
     do (if not eosTest then getC if);
        (if eosTest then ascii.nul->ch else peekC->ascii.upCase->ch if)
     #);
   skip: @
     (#
     do (if eosTest then
            ascii.nul->ch
         else (if ((peekC->ascii.upCase->ch) <= ' ') then
                  getC; restart skip if)
        if)
     #);
   sign: @
     (# do (if ch
            // '-' then true->negative; nextch
            // '+' then nextch
           if)
     #)
do  (if true
      // (radix=0) then 16->radix;
      // (radix<0) // (radix=1) // (126<radix) then radix->radixError
     if);
     skip;
     sign;
     0->value;
     L: (if true
         // ch->ascii.isDigit then 
            (if (ch-'0') >= radix then leave L if);
            value*radix+(ch-'0')->value; nextch; restart L; 
         // ch->ascii.isLetter then 
            (if (ch-'A') >= radix then leave L if);
            value*radix+(ch-'A')+10->value; nextch; restart L
        if);
   (if negative then -value->value if)
#)

--- compilernumberIoPutRealBody: descriptor ---
(# sprintf: External
     (# str: @integer;
        fmt: @integer;
        r: @real;
     enter (str, fmt, r)
     #);
   control: @text;
   controlput: @control.put; controlputint: @control.putint;
   buffer: [400]@char; (* Make room for sprintf to write to *)
   result: @text;
   putchar: @result.put;
do (* Set up format string for sprintf *)
   format; control.clear; result.clear;
   '%' -> control;
   (if width<>0 then
       (if adjustLeft  then '-' -> controlput if);
       (if signed      then '+' -> controlput if);
       (if blankSign   then ' ' -> controlput if);
       (if zeroPadding then '0' -> controlput if);
       width -> controlputint;
   if);
   '.'->controlput;
   precision -> controlputint;
   (if style
    // noexp then
       'f' -> controlput
    // exp then
       (if upcase then  'E' -> controlput
        else 'e' -> controlput
       if)
    // plain then
       (if upcase then  'G' -> controlput
        else 'g' -> controlput
       if)
   if);
   0 -> controlput; (* Null-terminate control-string *)
   (@@buffer[1], @@control.T[1], r) -> sprintf;
   copy:
     (# 
     do (for i: buffer.range repeat
             (if buffer[i] = 0 then
                 leave copy (* sprintf NULL-terminates result *)
              else
                 buffer[i]-> putchar
             if)
        for);
        (* NULL termination not reached !! *)
        'PutReal: Error in buffer, sprintf may have destroyed objects!'
          -> screen.putline
     #);
   result[]->puttext
#)
--- compilernumberIoAsRealDopart: dopart ---
do getReal(# syntaxError::(# do peekCh->this(asReal).syntaxError; true->continue #);
             baseError::(# do base->this(asReal).baseError; true->continue #);
             valueError::(# do peekCh->this(asReal).valueError; true->continue #)
          #)->r;
   INNER asReal
--- compilernumberIoAsBasedDopart: dopart ---
do getBased
   (# syntaxError::(# do peekCh->this(asBased).syntaxError; true->continue #);
      baseError::(# do base->this(asBased).baseError; true->continue #);
      valueError::(# do peekCh->this(asBased).valueError; true->continue #)
   #)
     ->(b,i);
   INNER asBased
--- compilernumberIoAsRadixDopart: dopart ---
do radix->getRadix
   (# radixError::(# do radix->this(asRadix).baseError; true->continue #) #)
     ->value;
   INNER asRadix
--- compilernumberIoAsIntegerDopart: dopart ---
do getInteger
   (# syntaxError::(# do peekCh->this(asInteger).syntaxError; true->continue #);
      baseError::(# do base->this(asInteger).baseError; true->continue #);
      valueError::(# do peekCh->this(asInteger).valueError; true->continue #)
   #)
     ->i;
   INNER asInteger
   


(*--- compilernumberioPutHex: descriptor --- in numberio{Little|Big}Endian.bet*)

(*--- compilernumberioPutByteHex: descriptor --- in numberio{Little|Big}Endian.bet*)

(*--- compilernumberioPutByteBinary: descriptor --- in numberio{Little|Big}Endian.bet*)

--- compilernumberioGetHex: descriptor ---
(# ch: @char;
   eosTest: @eos; getC: @get; peekC: @peek;
   nextch: @
     (#
     do (if not eosTest then getC if);
        (if eosTest then ascii.nul->ch else peekC->ascii.upCase->ch if)
     #);
   skip: @
     (#
     do (if eosTest then
            ascii.nul->ch
         else (if ((peekC->ascii.upCase->ch) <= ' ') then
                  getC; restart skip if)
        if)
     #)
do skip; (if ch = ascii.nul then EOSerror if);
   (if ch
    //'0'//'1'//'2'//'3'//'4'//'5'//'6'//'7'//'8'//'9'
    //'A'//'B'//'C'//'D'//'E'//'F' then
       l: (if ch
           //'0'//'1'//'2'//'3'//'4'//'5'//'6'//'7'//'8'//'9' then
              x*16+ch-'0'->x; nextch;  restart l
           //'A'//'B'//'C'//'D'//'E'//'F' then
              x*16+ch-'A'+10->x; nextch;  restart l
          if)
    else peekC->noNumberError
   if)
#)

--- compilernumberioGetBinary: descriptor ---
(# ch: @char;
   eosTest: @eos; getC: @get; peekC: @peek;
   nextch: @
     (#
     do (if not eosTest then getC if);
        (if eosTest then ascii.nul->ch else peekC->ascii.upCase->ch if)
     #);
   skip: @
     (#
     do (if eosTest then
            ascii.nul->ch
         else (if ((peekC->ascii.upCase->ch) <= ' ') then
                  getC; restart skip if)
        if)
     #)
do skip; (if ch = ascii.nul then EOSerror if);
   (if ch
    //'0'//'1' then
       l: (if ch
           //'0'//'1' then
              x*2+ch-'0'->x; nextch;  restart l
          if)
    else peekC->noNumberError
   if)
#)
