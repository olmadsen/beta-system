ORIGIN '~beta/basiclib/betaenv';
---lib:attributes--
SplayTree:
  (#
     init:<
       (# 
       do
          &SplayNode[] -> root[]; 
          inner;
       #);
     Elm:<
       (# 
          infinety,minusinfinety:@boolean;
          init:<
            (# 
            do
               false -> infinety -> minusinfinety;
               inner;
            #);
          equal:<
            (# 
               e:^Elm;
               
               res:@boolean;
            enter e[]
            do 
               (if ((infinety or e.infinety) or (minusinfinety or e.minusinfinety)) then
                   (if ((infinety and e.infinety) or (minusinfinety and e.minusinfinety)) then
                       true -> res;
                    else
                       false -> res;
                   if);
                else
                   inner;
               if);
            exit res
            #);
          lessOrEqual:<
            (# 
               e:^Elm;
               res:@boolean;
            enter e[]
            do 
               (if ((infinety or e.infinety) or (minusinfinety or e.minusinfinety)) then
                   (if ((infinety and e.infinety) or (minusinfinety and e.minusinfinety)) then
                       true -> res;
                    else
                       (if (minusinfinety) then
                           true -> res;
                        else
                           (if e.minusinfinety then
                               false -> res;
                            else
                               (if e.infinety then
                                   true -> res;
                                else
                                   false -> res;
                               if);
                           if);
                       if);
                   if);
                else
                   inner;
               if);
            exit res
            #);
          printElm:<
            (#
            do
               inner;
            #);
       #);
     SplayNode:<
       (# 
          Splay:
            (# 
               isRotateRight:
                 (# 
                    tempelm:^Elm
                 enter tempelm[]
                 do
                 exit ((tempelm[] -> right.e.equal) or (((tempelm[] -> right.e.lessOrEqual) and (right.right[] = none)) or ((not (tempelm[] -> right.e.lessOrEqual)) and (right.left[] = none))))
                 #);
               isRotateLeft:
                 (# 
                    tempelm:^Elm
                 enter tempelm[]
                 do
                 exit ((tempelm[] -> left.e.equal) or (((tempelm[] -> left.e.lessOrEqual) and (left.right[] = none)) or ((not (tempelm[] -> left.e.lessOrEqual)) and (left.left[] = none))))
                 #);
               newelm:^Elm;
               tmp:^SplayNode;
            enter newelm[]
            do
               (if newelm[] <> none then
                   (if ((not (newelm[] -> e.equal)) and (((newelm[] -> e.lessOrEqual) and (right[] <> none)) or ((not (newelm[] -> e.lessOrEqual)) and (left[] <> none )))) then
                       (if (newelm[] -> e.lessOrEqual) then
                           (if (not (newelm[] -> isRotateRight)) then
                               newelm[] -> right.splay;
                           if);
                           &SplayNode[] -> tmp[];
                           e[] -> tmp.e[];
                           left[] -> tmp.left[];
                           right.left[] -> tmp.right[];
                           right.e[] -> e[];
                           tmp[] -> left[];
                           right.right[] -> right[];
                        else
                           (if (not (newelm[] -> isRotateLeft)) then
                               newelm[] -> left.splay;
                           if);
                           &SplayNode[] -> tmp[];
                           e[] -> tmp.e[];
                           right[] -> tmp.right[];
                           left.right[] -> tmp.left[];
                           left.e[] -> e[];
                           tmp[] -> right[];
                           left.left[] -> left[];
                           
                       if)
                   if);
               if);
            #);
          e:^Elm;
          left,Right:^Splaynode;
          printElms:
            (#
            enter s[]
            do
               (if e[] <> none then
                   (if left[] <> none then
                       left.printElms;
                   if);
                   e.printElm;
                   (if right[] <> none then
                       right.printElms;
                   if);
               if);
            #);
       #);
     insert:
       (#
          newnode:^SplayNode;
          newelm:^Elm;
       enter newelm[]
       do
          (if newelm[] <> none then
              (if root.e[] = none then
                  newelm[] -> root.e[];
               else
                  newelm[] -> root.splay;
                  &SplayNode[] -> newnode[];
                  root.e[] -> newnode.e[];
                  (if newelm[] -> root.e.lessOrEqual then
                      root.left[] -> newnode.left[];
                      none -> newnode.right[];
                      newnode[] -> root.left[];
                   else
                      none -> newnode.left[];
                      root.right[] -> newnode.right[];
                      newnode[] -> root.right[];
                  if);
                  newelm[] -> root.e[]
              if);
          if);
       #);
     isEmpty:
       (# 
       exit (root.e[] = none)
       #);
     isntEmpty:
       (# 
       exit (root.e[] <> none)
       #);
     get:(# 
            getelm:^Elm;
         enter getelm[]
         do
            (if isntEmpty then
                getelm[] -> root.splay;
            if);
         exit root.e[]
         #);
     getanddelete:
       (# 
          retElm:^Elm
       enter retElm[]
       do
          retElm[] -> get -> retElm[];
          delRootElm;
       exit retElm[]
       #);
     memberGet:
       (# 
          getelm,retelm:^Elm
       enter getelm[]
       do
          none -> retelm[];
          (if root.e[] <> none then
              getelm[] -> root.splay;
              (if (getelm[] -> root.e.equal) then
                  root.e[] -> retelm[]
              if);
          if);
       exit retelm[]
       #);
     memberGetandDelete:
       (# 
          retElm:^Elm;
       enter retElm[]
       do
          retElm[] -> memberGet -> retElm[];
          (if retElm[] <> none then
              delRootElm;
          if);
       exit retElm[]
       #);
     delRootElm:
       (#
       do
          (if (isntEmpty) then
              (if root.left[] <> none then
                  infinety -> root.left.splay;
                  root.left.e[] -> root.e[];
                  root.left.left[] -> root.left[];
               else
                  (if root.right[] <> none then
                      minusinfinety -> root.right.splay;
                      root.right.e[] -> root.e[];
                      root.right.right[] -> root.right[];
                   else
                      none -> root.e[];
                  if);
              if);
          if);
       #);
     min:
       (#
       do 
          (if (isntEmpty) then
              minusinfinety -> root.splay;     
          if);
       exit root.e[]
       #);
     max:
       (# 
       do
          (if (isntEmpty) then
              infinety -> root.splay;     
          if);
       exit root.e[]
       #);
     infinety:
       (# 
          e:^Elm;
       enter e[]
       do
          (if e[] = none then
              &Elm[] -> e[];
          if);
          e.init;
          true -> e.infinety;
       exit e[]
       #);
     minusinfinety:
       (# 
          e:^Elm;
       enter e[]
       do
          (if e[] = none then
              &Elm[] -> e[];
          if);
          e.init;
          true -> e.minusinfinety;
       exit e[]
       #);
     s:^stream;
     printDepthFirst:
       (# 
       enter s[]
       do root.printElms
       #);
     root:^Splaynode;
  #);


smallList:
  (# type:<object;
     initialRange:<IntegerObject(# do 8->value; inner #);
     r:[initialRange]^type;
     top:@integer;
     append:
       (# e:^type
       enter e[]
       do top+1->top;
          e[]->r[top][];
          (if top>=r.range then
              top->r.extend
          if);
       #);
     scan:
       (# current:^type;
       do (for i:top repeat
               r[i][]->current[];
               inner
          for);
       #);
  #);
          



inoutset:
  (# r:[10]@integer;
     bound:@integer;
     insert:
       (# i:@integer;
       enter i
       do bound+1->bound;
          i->r[bound];
       #);
     remove:
       (# i:@integer
       enter i
       do (for k:10 repeat
             (if r[k]=i then
                 r[k]->i;
                 r[bound]->r[k];
                 i->r[bound];
                 bound-1->bound;
                 leave remove;
             if);
          for)
       #);
     printsets:
       (# 
       do 'in:'->puttext;
          (if bound=0 then
              'out:'->puttext;
          if);
          (for i:10 repeat
             r[i]->putint;
             ' '->put;
             (if i=bound then
                 'out:'->puttext;
             if);
          for);
       #);
  #);
          
HashTable:
  (# 
     init:<
       (# 
       do
          INNER;
          prime->elms.new;
       #);
     elm:<
       (# 
          next:^elm;
       #);
     equalfunction:<
       (# 
          e1,e2:^elm;
          result:@boolean
       enter (e1[],e2[])
       do
          INNER;
       exit result
       #);
     equal:@equalfunction;
     elms:[1]^elm;
     prime:@integer;
     Hashfunction:<
       (# 
          e:^elm;
          index:@integer;
       enter e[]
       do
          INNER;
       exit (((index mod prime)->abs)+1)
       #);
     Hash:@Hashfunction;
     insert:@
       (# 
          e,insertplace:^elm;
          i:@integer;
          inserted:@boolean;
       enter e[]
       do
          false->inserted;
          e[]->Hash->i;
          (if i < 0 then
              'WHAT' -> putline;
          if);
          elms[i][]->insertplace[];
          (if insertplace[] = none then
              e[]->elms[i][];
              e[]->insertplace[];
              true->inserted;
           else
              l:(if (insertplace.next[] <> none) then 
                    (if not ((e[],insertplace[])->equal) then
                        insertplace.next[]->insertplace[];
                        restart l;
                    if)
                 else
                    (if not ((insertplace[],e[])->equal) then
                        e[]->insertplace.next[];
                        e[]->insertplace[];
                        true->inserted;
                    if);
                if);
          if);
          exit (inserted,insertplace[])
       #);
     scan:
       (# 
          current:^elm;
       do
          (for i:prime repeat
               elms[i][]->current[];
               l:(if current[]<>none then
                     INNER;
                     current.next[]->current[];
                     restart l;
                 if);
          for);
       #);
  #);
