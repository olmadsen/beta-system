ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/numberio';
INCLUDE '~beta/basiclib/formatio';
INCLUDE 'OPTdatastructures'
-- lib: Attributes --
b2i:
  (# b: @boolean; i: @integer
  enter b
  do (if b then 1 -> i if)
  exit i
  #);
Information: 
  (# Itype:<Information;
     print:< (# s: ^stream enter s[] do INNER #);
     copy:< (# i:^Itype do INNER exit i[] #)
  #);

BooleanInf: Information
  (#
     b: @boolean;
     print:: 
       (#  do (if b then 'true'->s.puttext else 'false'->s.puttext if) #)
  #);
IntegerInf: Information
  (# i: @integer; print::  (#  do i->s.putint #);  #);
i234:Information
  (# regs:@int32;
     Itype::i234;
     print::
       (#  
          hasput:@boolean;
          cnt:@int32u;
       do '(%d,%d,%d)'->s.putformat
          (# 
          do (regs %Band (1 %sll 26))>0->b2i->d;
             (regs %Band (1 %sll 27))>0->b2i->d;
             (regs %Band (1 %sll 28))>0->b2i->d
           #)
       #);
     copy::
       (#do &i234[]->i[];
          regs->i.regs
       #)
  #);
BooleanTriple:Information
  (# 
     i2,i3,i4:@boolean;
     Itype::<BooleanTriple;
     print::<
       (# do '(%b,%b,%b)'->s.putformat
          (# 
          do
             i2->b2i->b;i3->b2i->b;i4->b2i->b;
          #);
       #);
     copy::<
       (# 
       do
          &BooleanTriple[]->i[];
          i2->i.i2;
          i3->i.i3;
          i4->i.i4;
       #);
  #);
ISetInf: Information (* this one is stupid *)
  (#
     r: [1] @integer;
     top: @integer;
     print:: 
       (# 
       do
          '{'->s.put;
          (for i: top-1 repeat r[i]->s.putint; ','->s.put;  for);
          r[top]->s.putint;
          '}'->s.puttext;
          
       #);
     append:
       (# i: @integer; 
       enter i
       do top+1->top; i->r[top]; (if top = r.range then top->r.extend if); 
       #);
     
  #);

BoundedSets:
  (#
     init:<(# do &settype[] -> theset[]; theset.init;inner;#);
     settype:SplayTree
       (# 
          count:@integer;
          counts:[1]^elmtype;
          insertcount:
            (# e:^elmtype
            enter e[]
            do
               e[]->counts[count][];
               (if count>=counts.range then
                   count->counts.extend
               if);
            #);
          elm:: 
            (# et:^elmtype;
               bit:@integer;
               equal::(# do e.et[] -> et.equal -> res; #);
               lessOrEqual:: (# do e.et[] -> et.lessOrEqual #);
               printelm::
                 (# 
                 do et.printelm;
                 #);
            #);
          insertelmtype:
            (#
               t:^elmtype;
               e,rete:^elm;
               ret:@integer;
            enter t[]
            do
               &elm[]->e[];
               t[]->e.et[];
               e.init;
               e[]->memberget->rete[];
               (if (rete[] = none) then
                   count + 1 -> count -> e.bit;
                   e[]->insert;
                   t[]->insertcount;
                   count -> ret;
                else
                   rete.bit -> ret;
               if);
            exit ret
            #);
       #);
     theSet:^settype;
     elmtype:<object
       (#
          equal:<(# e:^elmtype;res:@boolean enter e[] do  inner exit res #);
          lessOrEqual:<(#  e:^elmtype;res:@boolean enter e[] do  inner exit res #);
          printelm:<(# do inner; #);
       #);
     
     insertElmtype:
       (# 
          elm:^elmtype;
       enter elm[]
       do elm[] -> theSet.insertelmtype;
       #);
     BiSet:<extendedBIset;
     extendedBIset:information
       (# 
          Itype::<extendedBIset;
          rep:[1]@integer;
          copy::
            (# do &Itype[]->i[]; rep->i.rep 
            #)
       #);
     insertInBIset:
       (#
          et:^elmtype;
          ext:^BIset;
       enter (et[],ext[])
       do
          ((et[]->theSet.insertElmtype),ext[])->extinsert->ext[]
          exit ext[]
       #);
     makesingleton:
       (# 
          et:^elmtype;
          ext:^BIset;
       enter et[]
       do
          et[] -> theSet.insertelmtype -> makesingletonFromint -> ext[];
       exit ext[]
       #);
     makesingletonFromint:
       (# 
          i,wordno,bitno,tmp:@integer;
          ext:^BIset;
       enter i
       do
          &BIset[] -> ext[];
          (if (i > 32) then
              (i div 32) -> ext.rep.extend;
          if);
          ((i-1) div 32)+1->wordNO;
          i mod 32-1->bitNO;
          1->tmp;
          ext.rep[wordno] %Bor (tmp %sll bitNO)->ext.rep[wordNO];
          exit ext[]
       #);
     makeEqual:
       (# 
          e1,e2:^BIset;
       enter (e1[],e2[])
       do
          (if e1.rep.range > e2.rep.range then
              e1.rep.range - e2.rep.range -> e2.rep.extend;
           else
              (if e1.rep.range < e2.rep.range then
                  e2.rep.range - e1.rep.range -> e1.rep.extend;
              if);
          if);
       exit (e1[],e2[])
       #);
     extUnion:
       (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
       do
          (e1[],e2[])->makeequal->(e1[],e2[]);
          &BIset[] -> res[];
          (if e1.rep.range > 1 then
              e1.rep.range - 1 -> res.rep.extend;
          if);
          (for i: e1.rep.range repeat (e1.rep[i] %Bor e2.rep[i])->res.rep[i] for);
          exit res[]
       #);
     extDiff:
       (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
       do
          (e1[],e2[])->makeequal->(e1[],e2[]);
          &BIset[] -> res[];
          (if e1.rep.range > 1 then
              e1.rep.range - 1 -> res.rep.extend;
          if);
          (for i: e1.rep.range repeat (e1.rep[i] %Band (%Bnot e2.rep[i]))->res.rep[i] for);
          exit res[]
       #);
     extIntersection:
      (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
      do (if e1[]=none then
             e2.copy->res[];
             leave extIntersection
         if);
         (if e2[]=none then
             e1.copy->res[];
             leave extIntersection
         if);
         (e1[],e2[])->makeequal->(e1[],e2[]);
         &BIset[] -> res[];
         (if e1.rep.range > 1 then
             e1.rep.range -> res.rep.new;
         if);
         (for i: e1.rep.range repeat (e1.rep[i] %Band e2.rep[i])->res.rep[i] for);
      exit res[]
      #); 
     extEqual:
       (# 
          e1,e2:^BIset;
          res:@boolean
       enter (e1[],e2[])
       do
          true -> res;
          (e1[],e2[])->makeequal->(e1[],e2[]);
          (for i: e1.rep.range repeat (e1.rep[i] = e2.rep[i]) and res -> res for);
       exit res
       #); 
     extinsert:
       (# 
          i,wordno,bitno,tmp:@integer;
          ext:^BIset;
          enter (i,ext[])
       do
          (if ((i div 32) + 1 > ext.rep.range) then
              ((i div 32) + 1) - ext.rep.range -> ext.rep.extend;
          if);
          ((i-1) div 32)+1->wordNO;
          i mod 32-1->bitNO;
          1->tmp;
          ext.rep[wordno] %Bor (tmp %sll bitNO)->ext.rep[wordNO];
          exit ext[]
       #);
     typelist:smalllist
            (#
               type::elmtype;
            #);
     thetypes:^typelist;
     intList:smalllist
       (#
          type::integerObject;
       #);
     getTypeFrombits:
       (# 
          ext:^BIset;
          cnt:@integer;
       enter ext[]
       do
          &typelist[]->thetypes[];
         (for i: ext.rep.range repeat
             1->cnt;
             (for j: 32 repeat
                (if ext.rep[i] %Band cnt then 
                    theset.counts[(i-1)*32+j][]->thetypes.append;if);
                cnt*2->cnt
             for)
         for);
          exit thetypes[]
       #);
     getCountFrombits:
       (# (* will not work on none values *)
          ext:^BIset;
          cnt:@integer;
          iobj:^integerobject;
          ilist:^intlist;
       enter ext[]
       do
          &intlist[]->ilist[];
          (for i: ext.rep.range repeat
              1->cnt;
             (for j: 32 repeat
                  (if ext.rep[i] %Band cnt then 
                      &integerobject[]->iobj[];
                      (i-1)*32+j->iobj;
                      iobj[]->ilist.append;if);
                  cnt*2->cnt
             for)
         for);
       exit ilist[]
       #);
     
  #);



BITvektor32: Information
  (# (* bounded IntegerSet, from 0 to 31 !!!!
      *)
     Itype::BIset;
     data:@int32u;
     clear:
       (# do 0->data #);
     
     insert:
       (# val: @integer; wordNo,bitNo,tmp: @integer; 
       enter val
       do 
          data %Bor (1 %sll val)->data
       #);
     
     has:
       (# val:@integer; wordNo,bitNo,tmp: @int32u;
       enter val
       do 
          data %Band (1 %sll val)->tmp;
          (* if tmp = MININT (ie. first bit set only) tmp>0 
           * will generate sub minint,0,register.
           * which will generate SIGFPE on SGI.
           *)
          (if tmp=MININT then 1->tmp if)
       exit (tmp>0)
       #);
  #);

scanBitvektor32:
  (# bs:^bitvektor32;
     current,cnt,cnint:@integer; 
  enter bs[]
  do 1->cnt;
     bs.data->cnint;
     (for j: 32 repeat
          (if cnint %Band cnt then 
              j-1->current;
              INNER
          if);
          cnt*2->cnt
     for)
  #);

bit1: (#  exit 0x0001 #);
BIset: Information
(* bounded IntegerSet, from 1 to bound !!!!
 *)
  (# Itype::BIset;
     rep: [(bound div 32)+1] @int32u;
     bound:< (# value: @integer do 32->value; INNER exit value #);
     clear:
       (# do (for i:rep.range repeat 0->rep[i] for) #);
     printBinary:
       (# 
       do
          '['->put;
          (for i: rep.range repeat
            rep[i]->putBinary (#  do 32->width; true->zeropadding #);
            ','->put;
            
          for);
          ']'->putline;
          
       #);
     print:: 
       (# cnt: @integer; 
          hasput:@boolean;
       do
          '{'->s.put;
          (for i: rep.range repeat
             1->cnt;
             (for j: 32 repeat
                (if rep[i] %Band cnt then 
                    (if hasput then ','->s.put; false->hasput if);
                    (i-1)*32+j->s.putint; true->hasput if);
                cnt*2->cnt
             for)
          for);
          '}'->s.put
       #);
      toList:
       (# r:[0]@integer;
          cnt,top:@integer;
       do (* count bits *)
          (for i: rep.range repeat
               1->cnt;
               (for j: 32 repeat
                    (if rep[i] %Band cnt then 
                        1+top->top;
                    if);
                    cnt*2->cnt;
             for)
          for);
          top->r.new;0->top;
          (for i: rep.range repeat
               1->cnt;
               (for j: 32 repeat
                    (if rep[i] %Band cnt then 
                        1+top->top;
                        (i-1)*32+j->r[top]
                    if);
                    cnt*2->cnt
               for)
          for);
       exit r
       #);
     insert:
       (# val: @integer; wordNo,bitNo,tmp: @integer; 
       enter val
       do (if val=0 then 'AE inserted zero!'->screen.putline; (failuretrace,'')->stop if);

          ((val-1) div 32)+1->wordNO;
          (val-1) mod 32->bitNO;
          1->tmp;
          rep[wordno] %Bor (tmp %sll bitNO)->rep[wordNO];
       #);
     has:
       (# val:@integer; wordNo,bitNo,tmp: @int32u;
       enter val
       do ((val-1) div 32)+1->wordNO;
          (val-1) mod 32->bitNO;
          1->tmp;
          rep[wordno] %Band (tmp %sll bitNO)->tmp;
          (* if tmp = MININT (ie. first bit set only) tmp>0 
           * will generate sub minint,0,register.
           * which will generate SIGFPE on SGI.
           *)
          (if tmp=MININT then 1->tmp if)
       exit (tmp>0)
       #);
     findFree32:
       (# tmp,cnt: @integer;
       do 1->tmp;
          (for i:32 repeat
               (if not (tmp %Band rep[1]) then
                   i->cnt;
                   leave findFree32
               if);
               tmp * 2 -> tmp;
          for)
       exit cnt
       #);
     union:
       (# other: ^BIset; 
       enter other[]
       do
          (if other[] <> none then
              (for i: rep.range repeat (other.rep[i] %Bor rep[i])->rep[i] for)
          if)
       #);
     intersection:
       (# other: ^BIset; 
       enter other[]
       do
          (if other[] <> none then
              (for i: rep.range repeat (other.rep[i] %Band rep[i])->rep[i] for)
          if)
       #);
     equal:
       (# other: ^BIset; equal: @boolean; 
       enter other[]
       do
          true->equal;
          (for i: rep.range repeat
            equal and (rep[i] = other.rep[i])->equal; 
          for)
       exit equal
       #);
     delete:
       (# val: @integer; wordNo,bitNo,tmp: @integer; 
       enter val
       do
          ((val-1) div 32)+1->wordNO;
          (val-1) mod 32->bitNO;
          1->tmp;
          tmp  %sll bitNO ->tmp;
          rep[wordno] %Band (%Bnot tmp)->rep[wordNO];
       #);
     copy::
       (# 
       do this(biset)._new->i[];
          this(BIset)[]->i.union
       #);
     setminus:
       (# 
          other: ^BIset; 
       enter other[]
       do
          (if other[] <> none then
              (for i: rep.range repeat ((%Bnot(other.rep[i])) %Band rep[i])->rep[i] for)
          if)
       #);
     max:
       (# 
       do
          (for i:rep.range repeat
               -1 -> rep[i];
          for);
       #);
  #);

examineBIset:
  (# bs:^biset;
     current,cnt,cnint:@integer; 
     value:@int32;
  enter bs[]
  do (for i: bs.rep.range repeat
        1->cnt;
        bs.rep[i]->cnint;
        (for j: 32 repeat
             cnint %Band cnt->value;
             (i-1)*32+j->current;
             INNER;
             cnt*2->cnt
        for)
     for)
  #);

scanBIset:
  (# bs:^biset;
     current,cnt,cnint:@integer; 
  enter bs[]
  do (for i: bs.rep.range repeat
        1->cnt;
        bs.rep[i]->cnint;
        (for j: 32 repeat
           (if cnint %Band cnt then 
               (i-1)*32+j->current;
               INNER
           if);
           cnt*2->cnt
        for)
     for)
  #);

AnalysisInformation:
  (# 
     rep:[16]^information;
     top:@integer;
     isForward:@boolean;
     appendinf:
       (# inf:^information;
          place,newinf:@integer;
       enter (inf[],place)
       do
          (if place = 0 then
              top + 1 -> top;
              (if top > rep.range then
                  top->rep.extend;
              if);
              inf[]->rep[top][];
              top->place;
           else
              (if place > rep.range then
                  place -> rep.extend;
              if);
              inf[]->rep[place][];
          if)
          exit place
       #);
     append:@appendinf;
     find:
       (# 
          i:@integer;
          result:^information;
       enter i
       do
          (if ((i <= rep.range) And (i > 0)) then
              rep[i][]->result[]
           else
              none->result[];
          if);
       exit result[]
       #);
     get:@find;
     new:
     (# 
        enter top
     #);
  #);

pair:(# r1,const:@integer enter (r1,const) do exit (r1,const) #);
triple:(# r1,const,r2:@integer enter (r1,const,r2) do exit (r1,const,r2) #);


pairs:boundedsetshash
  (# 
     localExtBiSet:extendedBIset 
       (# print::
            (# t:^intlist;
               tr:^pair;
            do this(extendedBIset)[]->getcountFrombits->t[];
               '['->s.put;
               t.scan(# do theset.counts[current].t[]->tr[];
                        '(%d,%d)'->s.putformat 
                        (#  do tr.r1->d; tr.const->d; #);
                     #);
               ']'->s.put
            #);
          iType::localExtBiSet;
       #);
     settype::
       (# 
          Hashfunction::
            (# 
               t:^pair;
            do
               e.et.t[]->t[];
               t.r1*t.const->index;
            #);
          init::
            (# 
            do
               33->prime;
            #);
       #);
     BIset::<localExtBiSet;
     elmtype::
       (# t:^pair;
          equal::(# do ((e.t.r1 = t.r1) and (e.t.const = e.t.const)) -> res; #);
          lessOrEqual::
            (#  
            do 
               (if t.r1 < e.t.r1 then
                   true -> res;
                else
                   (if t.r1 = e.t.r1 then
                       (t.const <=e.t.const) -> res;
                    else
                       false -> res;
                   if);
               if);
            #);
          printelm::
            (# s:^stream do 
               &stream[] -> s[]; 
               '(%d,%d)'->s.putformat (#  do t.r1->d; t.const->d; #); 
            exit s[]
            #);
       #);
     kill:
       (# 
          carr:^extendedBIset;
          ext:^BISet;
          t:^intlist;
          p:@pair;
       enter (p,carr[])
       do
          &BIset[] -> ext[];
          carr[] ->getcountFrombits->t[];
          t.scan
          (# 
          do
             (if  ((p.r1<>theset.counts[current].t.r1) or (p.const<>theset.counts[current].t.const)) then 
                 (current,ext[])->extinsert->ext[];
             if);
          #);
          exit ext[]
       #);
     killmany:
       (# 
          carr:^extendedBIset;
          ext:^BISet;
          r1:@integer;
          t:^intlist;
       enter (r1,carr[])
       do
          &BIset[] -> ext[];
          carr[] ->getcountFrombits->t[];
          t.scan
          (# 
          do
             (if r1<>theset.counts[current].t.r1 then 
                 (current,ext[])->extinsert->ext[];
             if);
          #);
          exit ext[]
       #);
     gen:
       (#
          e:^elmtype;
          t:^pair;
          ext:^extendedBIset;
       enter (t[],ext[])
       do
          &elmtype[]->e[];
          t[]->e.t[];
          (e[],ext[])->insertInBIset->ext[];
          exit ext[]
       #);
     
     findsubstitute:
       (# info:^BIset;
          min,reg:@integer;
          t:^intlist;
          tr:^pair;
          enter (reg,info[])
       do 
       exit min
       #)
  #);

triples:boundedsetshash
  (# 
     localExtBiSet:extendedBIset 
       (# print::
            (# t:^intlist;
               tr:^triple;
            do this(extendedBIset)[]->getcountFrombits->t[];
               '['->s.put;
               t.scan(# do theset.counts[current].t[]->tr[];
                        '(%d,%d,%d)'->s.putformat 
                        (#  do tr.r1->d; tr.const->d;tr.r2->d #);
                     #);
               ']'->s.put
            #);
          iType::localExtBiSet;
       #);
      settype::
       (# 
          Hashfunction::
            (# 
               t:^triple;
            do
               e.et.t[]->t[];
               t.r1*t.const*t.r2->index;
            #);
          init::
            (# 
            do
               33->prime;
            #);
       #);
     BIset::<localExtBiSet;
     elmtype::
       (# t:^triple;
          equal::(# do ((e.t.r1 = t.r1) and (e.t.r2 = t.r2) and (e.t.const = e.t.const)) -> res; #);
          lessOrEqual::
            (#  
            do 
               (if t.r1 < e.t.r1 then
                   true -> res;
                else
                   (if t.r1 = e.t.r1 then
                       (if t.const < e.t.const then
                           (if t.const = e.t.const then
                               (t.r2 <= e.t.r2) -> res;
                           if)
                        else
                           false -> res;
                       if)
                   if);
               if);
            #);
          printelm::
            (# s:^stream do 
               &stream[] -> s[]; 
               '(%d,%d,%d)'->s.putformat (#  do t.r1->d; t.const->d;t.r2->d #); 
            exit s[]
            #);
       #);
     kill:
       (# 
          carr:^extendedBIset;
          ext:^BISet;
          r1:@integer;
          t:^intlist;
       enter (r1,carr[])
       do
          &BIset[] -> ext[];
          carr[] ->getcountFrombits->t[];
          t.scan
          (# 
          do
             (if ((r1 <> theset.counts[current].t.r1) and (r1 <> theset.counts[current].t.r2)) then
                 (current,ext[])->extinsert->ext[];
             if);
          #);
          exit ext[]
       #);
     killnotorigin:
       (# 
          carr:^extendedBIset;
          ext:^BISet;
          off:@integer;
          t:^intlist;
       enter (off,carr[])
       do
          &BIset[] -> ext[];
          carr[] ->getcountFrombits->t[];
          t.scan
          (# 
          do
             (if ((1 = theset.counts[current].t.r1) 
                 and (off = theset.counts[current].t.const)) then
                 (current,ext[])->extinsert->ext[]
             if)
          #)
          exit ext[]
       #);
     killnotorgoff:
       (# 
          carr:^extendedBIset;
          ext:^BISet;
          off:@integer;
          t:^intlist;
       enter (off,carr[])
       do
          &BIset[] -> ext[];
          carr[] ->getcountFrombits->t[];
          t.scan
          (# 
          do (* remove not org(=8) or nof off *)
             (if ((1 = theset.counts[current].t.r1) and 
                 ((8 = theset.counts[current].t.const) or 
                 (off <> theset.counts[current].t.const)))
                 then
                 (current,ext[])->extinsert->ext[]
             if)
          #)
          exit ext[]
       #);
     gen:
       (#
          e:^elmtype;
          t,t2:^triple;
          subst:@integer;
          ext:^extendedBIset;
       enter (t[],ext[])
       do
          &elmtype[]->e[];
          t[]->e.t[];
          (t.r1,ext[])->findSubstitute->subst; (* had eq. class *)
          (if t.r1<>subst then
              subst->t.r1
          if);
          (e[],ext[])->insertInBIset->ext[];
          (t.r2,ext[])->findSubstitute->subst;
              (* 'insert found subst: %d for %d\n'->putformat(# do subst->d;t.r2->d#); *)
          (if subst<>t.r2 then
              &elmtype[]->e[];
              &triple[]->t2[]->e.t[];
              (subst,-1,t.r2)->t2;
              (e[],ext[])->insertInBiset->ext[]
          if)
          exit ext[]
       #);
     (***lookupcopies:
       (# 
          tr:^triple;
          ext:^extendedBIset;
          t:^typelist;
          res:@integer;
       enter (tr[],ext[])
       do
          ext[]-> getTypeFrombits->t[];
          t.scan
          (#
          do
             (if ((current.t.r1 = tr.r1) and (current.t.const = tr.const) and (current.t.r2 <> tr.r2)) then
                 current.t.r2 -> res;
             if);
          #)
          exit res
       #);***)
     findsubstitute:
       (# 
          info:^BIset;
          min,reg:@integer;
          t:^intlist;
          tr:^triple;
          enter (reg,info[])
       do info[]->getCountFrombits->t[];
          l:t.scan
            (# ct:^triple;
            do theset.counts[current].t[]->ct[];
               (if reg=ct.r2 then 
                   (if ct.const=-1 then 
                       ct.r1->min;
                       leave l
                    else
                       theset.counts[current].t[]->tr[]
                   if)
               if)
            #);
          (if min>0 then 
              leave findSubstitute
           else
              reg->min
          if);
          
          (if tr[]<>none then
              t.scan
              (# 
              do (if (theset.counts[current].t.r1=tr.r1) and
                     (theset.counts[current].t.const=tr.const) then
                     (if theset.counts[current].t.r2<min then
                         theset.counts[current].t.r2->min 
                     if);
                 if);
              #);
          if);
       exit min
       #);
     has:
       (# e:^elmtype;
          t:^intlist;
          tr:@triple;
          info:^BIset;
          result:@boolean;
       enter (info[],tr)
       do info[]->getCountFromBits->t[];
          t.scan
          (# 
          do theset.counts[current][]->e[];
             (if (e.t.r1=tr.r1) and (e.t.const=tr.const) and (e.t.r2=tr.r2) then
                 true->result
             if);
          #)
       exit result
       #)
  #);

BoundedSetsHash:
  (#
     init:<(# do &settype[] -> theset[]; theset.init;inner;#);
     settype:<Hashtable
       (# 
          count:@integer;
          counts:[1]^elmtype;
          insertcount:
            (# e:^elmtype
            enter e[]
            do
               e[]->counts[count][];
               (if count>=counts.range then
                   count->counts.extend
               if);
            #);
          equalfunction::(# do e1.et[] -> e2.et.equal -> result; #);
          elm:: 
            (# et:^elmtype;
               bit:@integer;
            #);
          insertelmtype:
            (#
               t:^elmtype;
               e,rete:^elm;
               inserted:@boolean;
               ret:@integer;
            enter t[]
            do
               &elm[]->e[];
               t[]->e.et[];
               e[]->insert->(inserted,rete[]);
               (if inserted then
                   count + 1 -> count -> e.bit;
                   t[]->insertcount;
                   count -> ret;
                else
                   rete.bit -> ret;
               if);
            exit ret
            #);
       #);
     theSet:^settype;
     elmtype:<object
       (#
          equal:<(# e:^elmtype;res:@boolean enter e[] do  inner exit res #);
          lessOrEqual:<(#  e:^elmtype;res:@boolean enter e[] do  inner exit res #);
          printelm:<(# do inner; #);
       #);
     
     insertElmtype:
       (# 
          elm:^elmtype;
       enter elm[]
       do elm[] -> theSet.insertelmtype;
       #);
     BiSet:<extendedBIset;
     extendedBIset:information
       (# 
          Itype::<extendedBIset;
          rep:[1]@integer;
          copy::
            (# do &Itype[]->i[]; rep->i.rep 
            #);
          
       #);
     insertInBIset:
       (#
          et:^elmtype;
          ext:^BIset;
       enter (et[],ext[])
       do
          ((et[]->theSet.insertElmtype),ext[])->extinsert->ext[]
          exit ext[]
       #);
     makesingleton:
       (# 
          et:^elmtype;
          ext:^BIset;
       enter et[]
       do
          et[] -> theSet.insertelmtype -> makesingletonFromint -> ext[];
       exit ext[]
       #);
     makesingletonFromint:
       (# 
          i,wordno,bitno,tmp:@integer;
          ext:^BIset;
       enter i
       do
          &BIset[] -> ext[];
          (if (i > 32) then
              (i div 32) -> ext.rep.extend;
          if);
          ((i-1) div 32)+1->wordNO;
          i mod 32-1->bitNO;
          1->tmp;
          ext.rep[wordno] %Bor (tmp %sll bitNO)->ext.rep[wordNO];
          exit ext[]
       #);
     makeEqual:
       (# 
          e1,e2:^BIset;
       enter (e1[],e2[])
       do
          (if e1.rep.range > e2.rep.range then
              e1.rep.range - e2.rep.range -> e2.rep.extend;
           else
              (if e1.rep.range < e2.rep.range then
                  e2.rep.range - e1.rep.range -> e1.rep.extend;
              if);
          if);
       exit (e1[],e2[])
       #);
     extUnion:
       (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
       do
          (e1[],e2[])->makeequal->(e1[],e2[]);
          &BIset[] -> res[];
          (if e1.rep.range > 1 then
              e1.rep.range - 1 -> res.rep.extend;
          if);
          (for i: e1.rep.range repeat (e1.rep[i] %Bor e2.rep[i])->res.rep[i] for);
          exit res[]
       #);
     extDiff:
       (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
       do
          (e1[],e2[])->makeequal->(e1[],e2[]);
          &BIset[] -> res[];
          (if e1.rep.range > 1 then
              e1.rep.range - 1 -> res.rep.extend;
          if);
          (for i: e1.rep.range repeat (e1.rep[i] %Band (%Bnot e2.rep[i]))->res.rep[i] for);
          exit res[]
       #);
     extIntersection:
      (# 
          e1,e2,res:^BIset;
       enter (e1[],e2[])
      do (if e1[]=none then
             e2.copy->res[];
             leave extIntersection
         if);
         (if e2[]=none then
             e1.copy->res[];
             leave extIntersection
         if);
         (e1[],e2[])->makeequal->(e1[],e2[]);
         &BIset[] -> res[];
         (if e1.rep.range > 1 then
             e1.rep.range -> res.rep.new;
         if);
         (for i: e1.rep.range repeat (e1.rep[i] %Band e2.rep[i])->res.rep[i] for);
      exit res[]
      #); 
     extEqual:
       (# 
          e1,e2:^BIset;
          res:@boolean
       enter (e1[],e2[])
       do
          true -> res;
          (e1[],e2[])->makeequal->(e1[],e2[]);
          (for i: e1.rep.range repeat (e1.rep[i] = e2.rep[i]) and res -> res for);
       exit res
       #); 
     extinsert:
       (# 
          i,wordno,bitno,tmp:@integer;
          ext:^BIset;
          enter (i,ext[])
       do
          (if ((i div 32) + 1 > ext.rep.range) then
              ((i div 32) + 1) - ext.rep.range -> ext.rep.extend;
          if);
          ((i-1) div 32)+1->wordNO;
          i mod 32-1->bitNO;
          1->tmp;
          ext.rep[wordno] %Bor (tmp %sll bitNO)->ext.rep[wordNO];
          exit ext[]
       #);
     typelist:smalllist
            (#
               type::elmtype;
            #);
     thetypes:^typelist;
     intList:smalllist
       (#
          type::integerObject;
       #);
     getTypeFrombits:
       (# 
          ext:^BIset;
          cnt:@integer;
       enter ext[]
       do
          &typelist[]->thetypes[];
         (for i: ext.rep.range repeat
             1->cnt;
             (for j: 32 repeat
                (if ext.rep[i] %Band cnt then 
                    theset.counts[(i-1)*32+j][]->thetypes.append;if);
                cnt*2->cnt
             for)
         for);
          exit thetypes[]
       #);
     scanSet:
       (# 
          ext:^BIset;
          cnt:@integer;
          current:^elmtype;
       enter ext[]
       do
         (for i: ext.rep.range repeat
             1->cnt;
             (for j: 32 repeat
                (if ext.rep[i] %Band cnt then 
                    theset.counts[(i-1)*32+j][]->current[];
                    inner
                if);
                cnt*2->cnt
             for)
         for);
          exit thetypes[]
       #);
     getCountFrombits:
       (# (* will not work on none values *)
          ext:^BIset;
          cnt:@integer;
          iobj:^integerobject;
          ilist:^intlist;
       enter ext[]
       do
          &intlist[]->ilist[];
          (for i: ext.rep.range repeat
              1->cnt;
             (for j: 32 repeat
                  (if ext.rep[i] %Band cnt then 
                      &integerobject[]->iobj[];
                      (i-1)*32+j->iobj;
                      iobj[]->ilist.append;if);
                  cnt*2->cnt
             for)
         for);
       exit ilist[]
       #);
     
  #);


