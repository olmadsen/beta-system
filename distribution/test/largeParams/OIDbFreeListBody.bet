ORIGIN 'OIDbFreeList';
(* 
 * $RCSfile: OIDbFreeListBody.bet,v $ $Revision: 1.2 $ $Date: 1997-06-02 13:31:11 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE '~beta/containers/v1.6/list';

---freeListInit: descriptor---
(# 
do FLpriv.intervalList.init;
   0 -> noOfFree;
#)

---freeListInsert: descriptor---
(# 
do (if (freeValues.max > freeValues.min) // TRUE  then 
       freeValues.max - freeValues.min + noOfFree -> noOfFree;
       freeValues[] -> FLpriv.intervalList.append;
    else 
       'ERROR, interval with negative size entered in freeListInsert' -> putLine;
   if);
#)

---freeListPutFreeList: descriptor---
(#
do aFreeList.FLpriv.intervalList.scan
   (# 
   do current[] -> this(freeList).insert;
   #);
#)

---freeListGetFreeValue: descriptor---
(# 
do (if noOfFree // 0 then 0 -> freeValue;
    else 
       FLpriv.intervalList.getFreeValue -> freeValue;
       noOfFree - 1 -> noOfFree; 
   if);
#)

---freeListGetFreeList: descriptor---
(# 
do (if (wantedNoOfFree > noOfFree) // TRUE then 
       wantedNoOfFree -> FLpriv.intervalList.getFreeList -> newFreeList[];
    else NONE -> newFreeList[];
   if);
#)

---freeListScan: descriptor---
(# 
do FLpriv.intervalList.scan(# do current[] -> thisInterval[]; INNER scan; #);
#)

---freeListSize: descriptor---
(# 
do FLpriv.intervalList.size -> noOfIntervals;
#)

---freeListPrivate: descriptor---
(# 
   intervalList: @list
     (# element::< interval;
        
        getFreeValue: 
          (# aCellType: ^theCellType; 
             theInterval: ^interval;
             freeValue: @integer;
          do head -> aCellType[];
             aCellType.elm[] -> theInterval[];
             theInterval.min + 1  -> theInterval.min;
             theInterval.min -> freeValue;
             (if (theInterval.min = theInterval.max) // TRUE then 
                 aCellType[] -> delete;
             if);
          exit freeValue
          #);
        
        getFreeList:
          (# wantedNoOfFree: @integer;
             newFreeList: ^freeList;
          enter wantedNoOfFree
          do &freeList[] -> newFreeList[];
             newFreeList.init;
             L: iterate
               (# 
               do (if (newFreeList.noOfFree > wantedNoOfFree) // TRUE then LEAVE L if);
                  current.elm[] -> newFreeList.insert;
                  current[] -> delete;
               #);
          exit newFreeList[]
          #);
     #);
#)
   






