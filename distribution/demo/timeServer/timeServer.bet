(* File timeServer.bet
 * =================== 
 *
 * Example implementation of the timeServer shell.
 *
 * timeClients are kept in a clientList and called each second.
 * If a timeClient fails to answer the request within 2 seconds,
 * it times out, and is removed from the local list. Likewise in
 * case of connectionBroken errors.
 *
 * Calling the updateClock of the different clients each second is
 * done concurrently to ensure that a client failing to respond does
 * not affect the update of the other clients. *)

ORIGIN '~beta/distribution/v1.6/shell';
INCLUDE '~beta/basiclib/v1.6/file';
INCLUDE 'timeLib';
INCLUDE '~beta/sysutils/v1.6/time';

--- program:descriptor ---
shellEnv
(#
   shellType:: timeServer
     (# registerClientImpl:: (# do theClient[] -> clientList.insert #);
        withdrawClientImpl:: (# do theClient[] -> clientList.delete #);
        duringKill: @boolean;
        onKill::
          (#
          do (if duringKill then
                 (* ns.remove failed; avoid infinite recursion *)
              else
                 true->duringKill;
                 'timeServer' -> myEnsemble.ns.remove;
             if);
          #)
     #);
   
   
   globalErrorHandler::
     (# onFailure:
          (# theError: ^error;
          enter theError[]
          do
             (if theError.theObj## <= timeClient## then
                 (* Get rid of the failing timeClient. *)
                 theError.theObj[] -> clientList.delete;
                 'client failed' -> putLine;
                 theError.ignore;
              else
                 (* This can only be the initial communication with
                  * myEnsemble. It failed, so we just give up. *)
                 theError.abort;
             if)
          #);
        
        connectionBroken:: (# do THIS(connectionBroken)[] -> onFailure #);
        connectionFailed:: (# do THIS(connectionFailed)[] -> onFailure #);
        timeOut:: (# do THIS(timeOut)[] -> onFailure #);
        timeOutValue:: (# do 2 -> sec #);
     #);

   clientList: @Monitor
     (# theList: @list(# element:: timeClient; #);

        insert: entry
          (# theClient: ^timeClient
          enter theClient[]
          do theClient[] -> theList.append;
          #);

        delete: entry
          (# theClient: ^timeClient
          enter theClient[]
          do (if theList.empty // false then
                 theClient[] -> theList.at -> theList.delete;
             if);
          #);

        scanClients: entry
          (# curClient: ^timeClient;
          do theList.scan
             (#
             do current[] -> curClient[];
                INNER scanClients
             #);
          #);

        init:: (# do theList.init #);
     #);

   async:
     (# theThread: @|System (# do THIS(async) #);
        forked: @Boolean;
     do
        (if forked then
            INNER
         else
            true -> forked;
            theThread[] -> fork;
        if)
     #);

   updateClocks: @|System
     (# timeNow: ^Text;
     do
        Cycle 
        (# 
        do 
           1 -> sleep;
           systemTime -> formatTime -> timeNow[];
           clientList.scanClients
           (#
           do curClient[] -> async
              (# myClient: ^timeClient
              enter myClient[]
              do timeNow[] -> myClient.updateClock;
              #)
           #);
        #)
     #);
   
do clientList.init; updateClocks[] -> fork;
#)
