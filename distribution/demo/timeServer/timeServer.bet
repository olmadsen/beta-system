(* File timeServer.bet
 * ===================
 *
 * $RCSfile: timeServer.bet,v $ $Revision: 1.1.1.1 $ $Date: 1994-08-22 08:37:08 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *
 *  Example implementation of the timeServer shell.
 *
 * timeClients are kept in a clientList and called each second.
 * If a timeClient fails to answer the request within 2 seconds,
 * it times out, and is removed from the local list. Likewise in
 * case of connectionBroken errors.
 *
 * Calling the updateClock of the different clients each second is
 * done concurrently to ensure that a client failing to respond does
 * not affect the update of the other clients. *)

ORIGIN '~beta/distribution/v1.0/shell';
INCLUDE '~beta/basiclib/v1.4/file';
INCLUDE 'timeLib';

--- program:descriptor ---
shellEnv
(#
   shellType::< timeServer
     (# registerClientImpl::< (# do theClient[] -> clientList.insert #);
        withdrawClientImpl::< (# do theClient[] -> clientList.delete #);
        duringKill: @boolean;
        onKill::<
          (#
          do (if duringKill // true then
                 (* ns.remove failed; avoid infinite recursion *)
              else
                 true->duringKill;
                 'timeServer' -> myEnsemble.ns.remove;
             if);
          #)
     #);

   globalErrorHandler::<
     (# connectionBroken::< (# do theObj[] -> onFailure -> toDo #);
        connectionFailed::< (# do theObj[] -> onFailure -> toDo #);
        timeOut::< (# do theObj[] -> onFailure -> toDo #);
        timeOutValue::< (# do 25 -> sec #);

        onFailure: IntegerValue
          (# failing: ^remoteable;
          enter failing[]
          do
             (if failing.struc <= timeClient## //true then
                 (* Get rid of the failing timeClient. *)
                 failing[] -> clientList.delete;
                 EH_ignore -> value;
                 'Client failed' -> screen.putLine;
              else
                 (* This can only be the initial communication with
                  * myEnsemble. It failed, so we just give up. *)
                 EH_kill -> value;
             if)
          #);
     #);

   clientList: @Monitor
     (# theList: @list(# element::< timeClient; #);

        insert: entry
          (# theClient: ^timeClient
          enter theClient[]
          do theClient[] -> theList.append;
          #);

        delete: entry
          (# theClient: ^timeClient
          enter theClient[]
          do (if theList.empty // false then
                 theClient[] -> theList.at -> theList.delete;
             if);
          #);

        scanClients: entry
          (# curClient: ^timeClient;
          do theList.scan
             (#
             do current[] -> curClient[];
                INNER scanClients
             #);
          #);

        init::< (# do theList.init #);
     #);

   async:
     (# theThread: @|System (# do THIS(async) #);
        forked: @Boolean;
     do
        (if forked //true then
            INNER
         else
            true -> forked;
            theThread[] -> fork;
        if)
     #);

   updateClocks: @|System
     (# timeNow: ^Text;
     do
        L:
          (if 1//1 then
              1 -> sleep;
              gettime -> timeNow[];
              clientList.scanClients
              (#
              do curClient[] -> async
                 (# myClient: ^timeClient
                 enter myClient[]
                 do timeNow[] -> myClient.updateClock;
                 #)
              #);
              restart L;
          if);
     #);

do clientList.init; updateClocks[] -> fork;
#)

(* The code below is simply low level stuff interfacing to procedures
 * found in the header file <time.h>.
 * You may pretend as if it is not there. *)

--- lib:attributes ---
gettime:
  (# time: external (* <time.h> *)
       (# timeloc: @Integer;
          time: @Integer;
       enter timeloc
       exit time
       #);
     strftime: external (* <time.h> *)
       (# strloc: @Integer;
          strsize: @Integer;
          format: [1]@Char;
          tmptr: @Integer;
          ressize: @Integer;
       enter (strloc,strsize,format,tmptr)
       exit ressize
       #);
     localtime: external (* <time.h> *)
       (# timeloc: @Integer;
          tmloc: @Integer;
       enter timeloc
       exit tmloc
       #);
     timenow: @Integer;
     tmloc: @Integer;
     timet: @Text;
  do
     (if timet.t.range < 25 //true then 25 -> timet.t.new if);
     0 -> time -> timenow;
     @@timenow -> localtime -> tmloc;
     (@@timet.t[1],25,'%a %b %d %H:%M:%S',tmloc) -> strftime -> timet.lgth;
  exit timet.copy
  #);
