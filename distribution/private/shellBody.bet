ORIGIN '../basicshell';
(* 
 * $RCSfile: shellBody.bet,v $ $Revision: 1.2 $ $Date: 1994-08-31 14:54:35 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
OBJFILE default '$/getUser.o';

BODY 'remoteExecuteBody'
     'shellEnvPrivateBody'
     'shellCreatorBody'
     'shellRPCbody'
     'typeAllocatorBody'
     'OIDhandlerBody'
     'remoteObjectsBody'
     'protoTableBody';

INCLUDE '~beta/objectserver/v2.1/ObjectSerializer';
INCLUDE '~beta/objectserver/v2.1/groupList';
INCLUDE '~beta/objectserver/v2.1/execGroupTable';
INCLUDE '~beta/objectserver/v2.1/ptOffsetTable';
INCLUDE 'shellTypes';
INCLUDE 'rpc_interface';
INCLUDE '../remoteRefAsText';

--- senvPrivBody:descriptor ---
(# 
   <<SLOT shellPrivateAttributes: attributes>>;
   
   
   (* RPC
    * ===
    * 
    * Handles communication from and to this shell. *)
   
   RPC: @rpcHandler
     (# localAddress:  ^portablePortAddress;
        localHostName: ^Text;
        
        localEnsembleAdrAsText: ^Text;
        
        receiver: @rpc_receiver
          (# onReceive::< (# <<SLOT shellOnReceive:dopart>> #)#);
        
        init::<
          (# 
          do 0 -> receiver.init -> localAddress[];
             <<SLOT shellRPCinit:descriptor>>
          #);
        
        rpcPrivate: @<<SLOT rpcPrivate:descriptor>>
     #);
   
   
   
   (* THEOBJECTGETTER
    * ===============
    * 
    * See shellEnvLib below for a description. *)
   
   theObjectGetter: @ObjectGetter;
   
   
   
   (* OIDHANDLER
    * ==========
    * 
    * Handles assignment of OID`s to local objects by communicating with 
    * the local ensemble.
    * 
    * assignOID assigns an OID to the remoteAble entered and creates its 
    * remoteInfo. The remoteAble is finally put into the localObjects table.
    * If the remoteAble has already been assigned an OID (ri[] is not none), 
    * nothing happens.
    * 
    * Only one assignOID at the time may be in progress as the same
    * object could otherwise be assigned two OID's. This is ensured by
    * the assignOIDmutex semaphore.
    * 
    * shellOID returns the OID of theShell, assigning one if necessary.
    * shellOID can be a static object as it has no local state and so 
    * being a static object does not interfere with exclusive execution. *)
   
   OIDhandler: @
     (# assignOIDmutex: @semaphore;
        gp: @GetProtoType;
        
        assignOID: 
          (# ra: ^remoteAble; 
          enter ra[]
          <<SLOT assignOIDBody:dopart>>
          #);
        
        shellOID: @
          (# 
          do theShell[] -> assignOID;
          exit theShell.ri.OID
          #);
        
        oidhprivate: @<<SLOT OIDHandlerPrivate:descriptor>>;
        
        (* localObjects
         * ============ 
         * 
         * A table of local objects remotely accessible.
         * Only assignOID should insert objects into this table. *)
        
        localObjects: @ObjectTable
          (# element:< remoteInfo;
             OIDhash::< (# element::< remoteInfo #);
             protoHash::< (# element::< remoteInfo #);
             init::< (# do mutex.V; INNER #);
        
             findObjectByReference::<
               (# ra: ^remoteable;
               do (if o[] -> typeAllocator.isRemoteAble //true then 
                      o[] -> ra[];
                      ra.ri.OID -> fobo -> e[];
                      true -> doneInInner;
                  if)
               #);
        
             mutex: @Semaphore; (* For indivisible access *)
        
             exclFindByRef:
               (# o: ^Object; 
                  e: ^remoteInfo;
               enter o[]
               do mutex.P; (o[],NONE) -> fobr -> e[]; mutex.V;
               exit e[]
               #);
        
             exclFindByOID:
               (# OID: @OIDtype;
                  e: ^remoteInfo;
               enter OID
               do mutex.P; OID -> fobo -> e[]; mutex.V;
               exit e[]
               #);
        
             exclInsert:
               (# elm: ^element;
               enter elm[]
               do mutex.P; elm[] -> ins; mutex.V;
               #);
             
             exclDelete:
               (# elm: ^element;
               enter elm[]
               do mutex.P; elm[] -> delete; mutex.V;
               #)
          #);
        
        init:
          (# 
          do localObjects.init; assignOIDmutex.V;  
          #)
     #);
   
      
   
   (* SHELLCREATOR
    * ============
    * 
    * Handles creation of new shells.
    * 
    * createShell creates new shells. It calls the exceptions of the
    * ensemble.createShell instance directly. It is NOT an entry to avoid 
    * trouble with exceptions leaving the monitor closed. Critical regions 
    * are handled internally in startShell.
    * 
    * shellCallback is called by a worker handling a callback report from 
    * a newly created shell.
    * 
    * report is called by this shell if instantiated remotely by a 
    * createShell call in another shell. In that case remotelyInstantiated
    * returns TRUE, otherwise FALSE. Report does not return until the
    * shell has been successfully registered with its instantiator. *)
   
   shellCreator: @Monitor
     (# 
        createShell: 
          (# es: ^ensemble; cs: ^es.createShell;
             sh: ^Shell;
          enter (es[],cs[])
          do <<SLOT createShellBody:descriptor>>
          exit sh[]
          #);
        
        shellCallback: entry
          (# newShell: ^Shell; shellNmb: @Integer;
          enter (newShell[], shellNmb)
          do <<SLOT shellCallback:descriptor>>
          #);
        
        remotelyInstantiated: BooleanValue
          (# <<SLOT remotelyInstantiated:dopart>> #);
        
        screenName:
          (# name: ^Text;
          <<SLOT shellCreatorScreenName:dopart>>
          exit name[]
          #);
        
        report: entry
          (# do <<SLOT startShellReport:descriptor>> #);
        
        init::< (# do <<SLOT scInit:descriptor>> #);
        
        scPrivate: @<<SLOT scPrivate:descriptor>>
     #);
   
   
   
   
   (* REMOTEEXECUTOR
    * ==============
    * 
    * Handles the execution of remote procedure calls.
    * 
    * remoteExecute performs a remote procedure call. In case
    * of failure the relevant exception is raised. If notification
    * is TRUE, no answer is expected. *)
   
   remoteExecutor: @
     (#
        remoteExecute:
          (# theProxy: ^remoteAble;
             theEntry: ^theProxy.entry;
             notification: @Boolean;
          enter (theProxy[],theEntry[],notification)
          do <<SLOT remoteExecuteBody:descriptor>>
          #);
        
        init: (# do <<SLOT remoteExecutorInit:descriptor>> #);
        
        rePrivate: @<<SLOT remoteExecutorPrivate:descriptor>>;
     #);
   
   
   
      
   (* REMOTEOBJECTS
    * =============
    * 
    * A table of remote objects known to this shell. The objects contained 
    * in this table are the local proxies representing the remote object. 
    * 
    * If found, exclFindByOID returns a reference to a remoteInfo that is
    * *a copy* of the remoteInfo in the table. The copy should be discarded
    * when it is no longer needed to ensure automatic GC of proxy objects.
    * 
    * exclInsert makes a copy of the remoteInfo entered. To ensure automatic
    * GC of proxies, the remoteInfo entered should be discarded when not
    * needed.
    *
    * exclCreateEnsemble creates a remoteInfo corresponding to the ensemble
    * for which information is entered. If ensembleAdrAsText is NONE,
    * ensembleName is used to lookup the necessary information on the 
    * ensemble. If this fails, NONE is returned. *)
   
   remoteObjectsElement: (# ri: ^remoteInfo; dotinx: @Integer #);
   
   remoteObjects: @OIDhashTable
     (# element::< remoteObjectsElement;
        
        remoteObjectsMutex: @semaphore;
        
        exclFindByOID: 
          (# ensembleName:< (# name: ^Text do INNER exit name[] #);
             OID: @OIDtype; 
             ri: ^remoteInfo;
          enter OID
          do <<SLOT remoteObjectsFOBO:descriptor>>
          exit ri[]
          #);
        
        exclInsert:
          (# ri: ^remoteInfo;
          enter ri[]
          do <<SLOT remoteObjectsInsert:descriptor>>
          #);
        
        exclCreateEnsemble:
          (# ensembleName: ^Text; 
             ensembleAdrAsText: ^Text; 
             ensembleOID: @OIDtype;
             ri: ^remoteInfo;
          enter (ensembleName[],ensembleAdrAsText[],ensembleOID)
          do <<SLOT remoteObjectsCreateEnsemble:descriptor>>
          exit ri[]
          #);
        
        init::< (# do <<SLOT remoteObjectsInit:descriptor>> #);
        
        roPrivate: @<<SLOT remoteObjectsPrivate:descriptor>>;
     #);
   
   
   
   
   (* PROTOTABLE
    * ==========
    * 
    * Table performing mapping between groupNames and prototype 
    * addresses. Local prototype addresses are cached.
    * 
    * getProtoId maps a local prototype address into group,proto,
    * and groupName.
    * 
    * getProtoByGroupName maps a (groupName,proto) pair into a local
    * prototype address.
    * 
    * getLocalProtoId does the same as getProtoByGroupName, but also
    * returns the local (group,proto) pair.
    *)
   
   protoTable: @
    (# egt: ^execGroupTable;
        
       cache: @IntegerHashTable
          (# element::<
               (# ptAdr: @Integer;
                  group, proto: @Integer;
                  groupName: ^Text;
               #)
          #);
        
        getProtoId: @ 
          (# pt: @ProtoType;
             egte: ^execGroupTableElement; celm: ^cache.element;
          enter pt
          do 
             pt -> cache.find -> celm[];
             (if celm[] //NONE then
                 &cache.element[] -> celm[];
                 pt -> egt.findGroupByAdr -> egte[];
                 egte.groupName[] -> celm.groupName[];
                 pt -> egte.PTtoInx -> celm.proto;
                 egte.inx -> celm.group;
                 (celm[],pt) -> cache.insert;
             if);
          exit (celm.group, celm.proto, celm.groupName[])
          #);
   
        getProtoByGroupName: @
          (* Returns the prototype with id inx within the group groupName. 
           * Returns -1 in case of error. *)
          (# groupName: ^Text; proto, group: @Integer;
             ptAdr: @Integer; egte: ^execGroupTableElement;
          enter (groupName[], proto)
          do groupName[] -> egt.findGroupByName -> egte[];
             (if egte[] //NONE then 
                 -1 -> ptAdr -> group;
              else
                 proto -> egte.inxToPT -> ptAdr;
                 egte.inx -> group
             if);
          exit (ptAdr,group)
          #);
       
        getLocalProtoId: @
          (# groupName: ^Text; 
             group, proto, ptAdr: @Integer;
             egte: ^execGroupTableElement;
          enter (groupName[], proto)
          do groupName[] -> egt.findGroupByName -> egte[];
             (if egte[] //NONE then
                 -1 -> group -> proto -> ptAdr;
              else
                 egte.inx -> group;
                 proto -> egte.inxToPT -> ptAdr;
             if);
          exit (group, proto, ptAdr)
          #);
       
       init: (# do <<SLOT protoTableInit:descriptor>> #);
    #);
   
   
   
   (* TYPEALLOCATOR
    * =============
    *
    * Creates and manages instances of remoteAbleType.
    * 
    * initFromObj makes a network representation from a local object.
    * network representations are cached for reuse.
    *
    * initFromNet initializes from a network representation.
    * 
    * save saves the remoteAble type to the entered RepetitionObject and
    * outgoingNames table.
    *
    * is___ checks whether the pattern of the entered object is a subpattern
    * of remoteAble, shell, nameServer of ensemble.
    *)
   

   typeAllocator: @
     (#
        initFromObj: @
          (# ra: ^remoteAble; rat: ^remoteAbleType
          enter ra[]
          <<SLOT typeAllocatorInitFromObj:dopart>>
          exit rat[]
          #);
        
        initFromNet: @
          (# rep: ^RepetitionObject; groups: ^incomingNames;
             rat: ^remoteAbleType
          enter (rep[],groups[])
          <<SLOT typeAllocatorInitFromNet:dopart>>
          exit rat[]
          #);
        
        save: @
          (# rat: ^remoteAbleType;
             rep: ^RepetitionObject; 
             groups: ^outgoingNames;
          enter (rat[],rep[],groups[])
          <<SLOT typeAllocatorSave:dopart>>
          #);
        
        isRemoteAble: @
          (# obj: ^Object; value: @Boolean;
          enter obj[]
          <<SLOT typeAllocatorIsRemoteAble:dopart>>
          exit value
          #);
        
        isShell: @
          (# obj: ^Object; value: @Boolean;
          enter obj[]
          <<SLOT typeAllocatorIsShell:dopart>>
          exit value
          #);
        
        isNameServer: @
          (# obj: ^Object; value: @Boolean;
          enter obj[]
          <<SLOT typeAllocatorIsNameServer:dopart>>
          exit value
          #);
        
        isEnsemble: @
          (# obj: ^Object; value: @Boolean;
          enter obj[]
          <<SLOT typeAllocatorIsEnsemble:dopart>>
          exit value
          #);
        
        init: (# <<SLOT typeAllocatorInit:dopart>> #);
        
        taPrivate: @<<SLOT typeAllocatorPrivate:descriptor>>;
     #);
   
   
   (* PTOFFSETS
    * =========
    * 
    * Used by ObjectSerializers. *)
   
   ptOffsets: @ptOffsetTable; 
#)



(* REMOTEABLECALLREMOTE
 * ==================== *)

--- remoteAbleCallremote:descriptor ---
(# 
do (this(remoteAble)[], this(entry)[], false) 
     -> senvPriv.remoteExecutor.remoteExecute;
#)

(* REMOTEABLEPING
 * ============== *)

--- remoteablePing:descriptor ---
(# 
do
   true -> value;
   errorHandler
   (# connectionFailed:: (# do  false -> value; ignore #);
      connectionBroken:: (# do false -> value; ignore #);
      unknownObject:: (# do false -> value; ignore #);
      unknownPattern:: (# do false -> value; ignore #);
      timeOut:: (# do false -> value; ignore #);
      serverOverLoad:: (# do false -> value; ignore #);
      wrongAnswer:: (# do false -> value; ignore #);
   do pingEntry;
   #);
#)

--- remoteablePrivateEntries:attributes ---
pingEntry: entry (# #);
   
   
   
(* SHELLPRIVATE
 * ============ *)
   
--- shellPrivateBody:descriptor ---
(# 
   started: @Boolean;
   shellThread: @| system (# do INNER shell #);
   
   start: 
     (# 
     do 
        (if started //true then
            (failure,'Attempt to restart shell.')
              -> stop;
         else
            true ->  started;
            shellThread[] -> fork;
        if);
     #);  
#)


(* SHELLKILLBODY
 * ============= *)

--- shellKillBody:descriptor ---
(# 
do 
   (if isProxy //true then
       (THIS(shell)[],&killEntry[],true) 
         -> senvPriv.remoteExecutor.remoteExecute;
    else
       onKill; 
       senvPriv.RPC.shutDown; 
       stop;
   if)
#)

(* SHELLPRIVATEENTRIES
 * =================== *)

--- shellPrivateEntries:attributes ---

(* REGISTERCALLBACK
 * ================ 
 * 
 * Newly created shells should register with their creators.
 * This is done by calling back to registerCallback as soon
 * as they are started, handing a reference to themselves. *)

registerCallback: entry
  (# newShell: ^Shell;
     shellNmb: @Integer;
  enter (newShell[], shellNmb)
  do
     (newShell[], shellNmb) -> senvPriv.shellCreator.shellCallback;
  #);

(* KILLENTRY
 * ========= *)

killEntry: entry (# do kill #);


(* SHELLENVWITHDRAW
 * ================ *)

--- shellEnvWithDraw:descriptor ---
(# 
do (if ra.ri[] //NONE then else
       (if ra.isProxy //false then
           ra.ri[] -> senvPriv.OIDhandler.localObjects.exclDelete;
       if);
   if);
#)


(* ERRORHANDLERLIB
 * =============== *)

--- errorHandlerLib:attributes ---

RemoteSpecFailedInfo:
  (# t: ^Text; pt: @ProtoType;
     theObj: ^remoteAble;
     es: ^ensemble;
     theEntry: ^theObj.entry;
     msg: ^Text;
  enter (theObj[], theEntry[], msg[])
  do
     msg[] -> screen.putText;
     
     (if theEntry[] //NONE then
         
         ' on request to ' -> screen.putText;
         theObj[] -> es[];
         es.hostName[] -> screen.putText;
         ' ensemble.' -> screen.putLine;
         
      else
         
         ' on request ' -> screen.putText;
         
         theObj[] -> getProtoType -> pt; pt.labId -> t[];
         (1,t.length-1) -> t.sub -> screen.putText;
         
         '.' -> screen.put;
         
         theEntry[] -> getProtoType -> pt; pt.labId -> t[];
         (1,t.length-1) -> t.sub -> screen.putText;
         
         ' to shell (' -> screen.putText;
         theObj.ri.shellAdr.asText -> screen.putText;
         ') ' -> screen.putLine;
     if);
  #)

--- EHcontinue:dopart ---
do 
   (if callInner //true then
       (* Do nothing. Hopefully we never get here. *)
    else
       TRUE -> callInner;
       (EH_continue,THIS(continue)[]) -> cleanup;
   if)
   
--- EHabort:dopart ---
do (if callInner then
       leaveHandler; 
       INNER;
       (theObj[],theEntry[],'abort') -> remoteSpecFailedInfo;
       theShell.kill;
    else
       true -> callInner;
       (EH_kill,THIS(abort)[]) -> cleanup;
   if)

--- EHignore:dopart ---
do (if callInner then
       (* Do nothing. Control flow continues after failed remote call. *)
    else
       true -> callInner;
       (EH_kill,THIS(ignore)[]) -> cleanup;
   if)


(* ERRORHANDLERONENTRY
 * =================== *)

--- errorHandlerOnEntry:descriptor ---
(# lcOnEntry: ^errorHandler;
do 
   theActive.lc[] -> lcOnEntry[];
   (if prevHandler[] //NONE then lcOnEntry[] -> prevHandler[] if);
   THIS(errorHandler)[] -> theActive.lc[];
#)


(* ERRORHANDLERONLEAVE
 * =================== *)

--- errorHandlerOnLeave:dopart ---
do enterHandler.lcOnEntry[] -> theActive.lc[]; INNER leaveHandler;
   

(* EFAILEDBODY
 * =========== *)

--- EfailedBody:descriptor ---
(# msg: ^Text;
do
   (if THIS(E_failed)## // E_failed## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'connectionFailed') -> remoteSpecFailedInfo;
              theShell.kill;
           #);
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.connectionFailed
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.connectionFailed
       if);
       
    else
       INNER E_failed;
   if);
#)

(* EBROKENBODY
 * =========== *)

--- EbrokenBody:descriptor ---
(# 
do
   (if THIS(E_broken)## //E_broken## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'connectionBroken') -> remoteSpecFailedInfo;
              theShell.kill;
           #);
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.connectionBroken
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.connectionBroken
       if);
       
    else
       INNER E_broken;
   if)
#)

(* ETIMEOUTBODY
 * ============ *)

--- EtimeOutBody:descriptor ---
(# 
do
   (if THIS(E_timeOut)## //E_timeOut## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'timeOut') -> remoteSpecFailedInfo;
              theShell.kill;
           #)
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.timeOut
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.timeOut
       if);
       
    else
       INNER E_timeOut;
   if)
#)

(* EOVERLOADBODY
 * ============= *)

--- EoverloadBody:descriptor ---
(# 
do
   (if THIS(E_overload)## //E_overload## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'serverOverload') -> remoteSpecFailedInfo;
              theShell.kill;
           #)
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.serverOverload;
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.serverOverload;
       if);
       
    else
       INNER E_overload;
   if)
#)

(* EUNKNOWNOBJBODY
 * =============== *)

--- EunknownObjBody:descriptor ---
(# 
do
   (if THIS(E_unknownObj)## //E_unknownObj## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'unknown Object (dangling remote reference)')
                -> remoteSpecFailedInfo;
              theShell.kill;
           #)
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.unknownObject
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.unknownObject
       if);
       
    else
       INNER E_unknownObj; 
   if)
#)

(* EUNKNOWNPATBODY
 * =============== *)

--- EunknownPatBody:descriptor ---
(# t: ^Text;
do
   (if THIS(E_unknownPat)## //E_unknownPat## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (if local //true then
                  'locally unknown Pattern' -> t[];
               else
                  'remotely unknown Pattern' -> t[];
              if);
              
              (theObj[],theEntry[],t[]) -> remoteSpecFailedInfo;
              theShell.kill;
           #)
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[],local) -> globalHandler.unknownPattern
           
        else
           (theObj[],theEntry[],cleanup[],local) -> prevHandler.unknownPattern
       if);
       
    else
       INNER E_unknownPat; 
   if)
#)

(* EANSWERBODY
 * =========== *)

--- EanswerBody:descriptor ---
(# 
do
   (if THIS(E_answer)## //E_answer## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then
           
           abort
           (# 
           do (theObj[],theEntry[],'wrongAnswer') -> remoteSpecFailedInfo;
              theShell.kill;
           #)
           
        //(prevHandler[]=NONE) then
           
           (theObj[],theEntry[],cleanup[]) -> globalHandler.wrongAnswer
           
        else
           (theObj[],theEntry[],cleanup[]) -> prevHandler.wrongAnswer
       if);
       
    else
       INNER E_answer; 
   if)
#)

--- VtimeOutBody:descriptor ---
(# 
do
   (if THIS(V_timeOut)## //V_timeOut## then
       (if true
        //(THIS(errorHandler)[]=globalHandler[]) then -1 -> sec;
        //(prevHandler[]=NONE) then globalHandler.timeOutValue -> sec;
        else prevHandler.timeOutValue -> sec;
       if);
    else
       -1 -> sec;
       INNER V_timeOut
   if)
#)
   
(* USERNAMEGETUSER
 * =============== *)

--- userNamegetUser:descriptor ---
(# getUser: external (# name: [1]@Char exit name #);
do &Text[] -> t[]; getUser -> t 
#)

(* SHELLENVLIB
 * =========== *)

--- shellEnvLib:attributes ---

(* OBJECTGETTER
 * ============
 * 
 * An instance of objectGetter is used by remoteRefAsText in order to
 * transform textual object references into real references. The reason
 * for not simply making getObject an entry of shell, is an optimization
 * in shellComm, treating the current proxy special. This means that a
 * request for the reference to the shell object itself via a fake proxy
 * does not work. See remoteRefAsTextBody.bet. *)

objectGetter: remoteable
  (# getObject: entry
       (# OID: @OIDtype;
          ra: ^remoteable;
       enter OID
       do 
          (# ri: ^remoteInfo;
          do OID -> senvPriv.OIDhandler.localObjects.exclFindByOID -> ri[];
             (if ri[] //NONE then else
                 ri.o[] -> ra[];
             if);
          #)
       exit ra[]
       #)
  #);
     
(* errorHandler.error exit values. *)
     
EH_kill:   (# exit -1 #);
EH_continue:  (# exit -2 #);
     
