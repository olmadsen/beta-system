ORIGIN 'shellBody';
LIB_ITEM 'basicshell';
(* 
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)
INCLUDE 'dottable';
INCLUDE '~beta/sysutils/objinterface';

--- remoteObjectsFOBO:descriptor ---
(# 
do remoteObjectsMutex.P;
   OID -> roPrivate.fobo -> ri[];
   remoteObjectsMutex.V;
#)

--- remoteObjectsCreateEnsemble:descriptor ---
(# 
do remoteObjectsMutex.P;
   
   lookup:
     (# procAddr: ^portablePortAddress;
        tcp_addr: ^tcpPortAddress;
     do 
        (if ensembleAdrAsText[] //NONE then
            ensembleName[] -> RPC.otherEnsemble
            (# notFound::< (# do leave lookup #)
            #) -> portableCommAddressFromText -> procAddr[];
            procAddr.asText -> ensembleAdrAsText[];

            (* !!! This assumes that an internet (TCP/IP)
             * address exists for this host *)
            procAddr.getTcpPort->tcp_addr[];
            (tcp_addr.inetAddr,0) -> ensembleOID;
        if);
        
        (if (ensembleOID -> roPrivate.fobo -> ri[]) //NONE then
            (* Create a local proxy for the ensemble *)
            create:
              (# es: ^ensemble;
              do
                 &ensemble[] -> es[];
                 
                 ensembleName[] -> es.hostName[];
                 true -> es.isProxy -> es.ns.isProxy;
                 
                 &remoteInfo[] -> es.ri[];
                 
                 ensembleAdrAsText[]
                   -> es.ri.ensembleAdrAsText[]
                   -> portableCommAddressFromText
                   -> es.ri.shellAdr[];
                 
                 es[] -> typeAllocator.initFromObj -> es.ri.netType[];
                 es.hostName[] -> es.ri.ensembleName[];
                 
                 ensembleOID -> es.ri.OID -> es.ri.shellOID;
                 
                 es.ri[] -> es.ns.ri[];
                 
                 es[] -> es.ri.o[];
                 
                 es.ri[] -> roPrivate.Insert;
                 
                 &remoteInfo[] -> ri[]; es.ri -> ri;
                 NONE -> es.ri.o[];
              #);
        if);
     #);
   
   remoteObjectsMutex.V;
#)

--- remoteObjectsInsert:descriptor ---
(# 
do
   remoteObjectsMutex.P;
   ri[] -> roPrivate.insert;
   remoteObjectsMutex.V;
#)

--- remoteObjectsInit:descriptor ---
(# 
do 
   DOTinit;
   roPrivate.onDelete## -> makeCBF -> roPrivate.onDeleteAdr;
   roPrivate.dotinxTable.init;
   remoteObjectsMutex.V
#)

--- remoteObjectsPrivate:descriptor ---
(# dotinxTable: @IntegerHashTable (# element:: remoteObjectsElement #);
   
   onDeleteAdr: @Integer;
   onDelete: DOTonDelete
     (# elm: ^remoteObjectsElement
     do handle -> dotinxTable.delete -> elm[];
        elm.ri.OID -> remoteObjects.delete;
     #);
   
   insert:
     (# elm: ^remoteObjectsElement;
        ri: ^remoteInfo;
     enter ri[]
     do 
        &remoteObjectsElement[] -> elm[];
        &remoteInfo[] -> elm.ri[];
        ri -> elm.ri; (* Make a copy so it is up to caller to get rid of his
                       * own ri. *)
        NONE -> elm.ri.o[];
        loop:
          (if ((%GetLongAt(@@ri.o), onDeleteAdr,1)->DOThandleInsert->elm.dotinx)=-1 then
              0->DOThandlePerformCompaction;
              restart loop;
          if);
        
        (elm[],ri.OID) -> THIS(remoteObjects).insert; 
        (elm[],elm.dotinx) -> dotinxTable.insert;
     #);
   
   fobo:
     (# elm: ^remoteObjectsElement;
        ato: @addressToObject;
        ra: ^remoteable;OID: @OIDtype; 
        ri: ^remoteInfo;
     enter OID
     do OID -> find -> elm[];
        (if elm[]<>NONE then
            NONE -> elm.ri.o[];
            elm.dotinx -> DOThandleLookup -> ato -> ra[];
            (if ra[]<>NONE then 
                (* If NONE, then this element has been deleted. *)
                (if false (* Check for COM proto errors *) then
                    (if not (ra[]->getProtoField->IsPrototypeOfProcess) then
                        'fobo: Got proto that is not '
                        'IsPrototypeOfProcess'->screen.putLine;
                        %getLongAt(4)->screen.putInt; (* Trigger Seg.fault. *)
                    if);
                if);
                &remoteInfo[] -> ri[];
                elm.ri -> ri;(* Make a copy that can be discarded by caller. *)
                ra[] -> ri.o[];
            if);
        if);
     exit ri[]
     #);
#)
