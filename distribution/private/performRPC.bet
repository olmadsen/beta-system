ORIGIN 'shellBody';
(* 
 * $RCSfile: performRPC.bet,v $ 
 * $Revision: 1.4 $ 
 * $Date: 1996-06-21 10:49:56 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE 'rpc_interface';
INCLUDE '~beta/sysutils/v1.5/RepetitionObject';
INCLUDE 'commFormats';

--- shellPrivateAttributes:attributes ---

performRPC:
  (# theProxy: ^remoteAble;
     theEntry: ^theProxy.entry;
     timeOut: @Integer;
     protSpec: ^protocolSpec;
     msg: ^RepetitionObject; 
     (* Messages sent. Overwritten with answer. *)
     messages: ^RepetitionObjectsTable; 
     eh: ^errorHandler;
     notification: @Boolean;
     
     error: @Integer;
     
     fa: ^eh.failureAction;
     
     
     
  enter (theProxy[],theEntry[],timeOut,protSpec[],
         msg[],messages[],eh[],notification)
  do
     doRPC:
       (# 
       do
          NONE -> fa[];
          
          (theProxy.ri.shellAdr[],0,msg[],
          messages[],timeOut,protSpec[],notification) -> 
          RPC.rpc_send 
          (# timedOut::<
               (# 
               do handle:
                    (# EH_toDo: @eh.EH_cleanup
                       (# (* Called by abort, ignore and continue patterns
                           * in eh.error. *)
                       do (if toDo
                           //EH_kill then 
                              true -> THIS(timedOut).value;
                           //EH_continue 
                              then false -> THIS(timedOut).value
                          if);
                          fa[] -> THIS(performRPC).fa[];
                          leave handle;
                       #);
                    do (theProxy[], theEntry[], EH_toDo[]) -> eh.timeOut;
                       (* If we get here, the user did not call either
                        * abort, fatal or continue in the errorHandler. *)
                       'FATAL!! errorHandler.timeOut further bound without calling "abort", "ignore" or "continue"' -> putLine;
                       
                       theShell.kill;
                    #);
               #);
             connBroken::<
               (# 
               do handle:
                    (# EH_toDo: @eh.EH_cleanup
                       (# 
                       do (if toDo
                           //EH_kill then 
                              true -> THIS(connBroken).value;
                           //EH_continue 
                              then false -> THIS(connBroken).value
                          if);
                          fa[] -> THIS(performRPC).fa[];
                          leave handle;
                       #);
                    do (theProxy[],theEntry[],EH_toDo[])->eh.connectionBroken;
                       'FATAL!! errorHandler.connectionBroken further bound without calling "abort", "ignore" or "continue"' -> putLine;
                       theShell.kill;
                    #);
               #);
          #) -> (error,msg[]);
          
          (if error
           //rpcError_OK then
              
              (* Nothing. *)
              
           //rpcError_noHost
           //rpcError_connRefused
           //rpcError_nomoreSockets then
              
              (# EH_toDo: @eh.EH_cleanup
                 (# 
                 do (if toDo
                     //EH_kill then fa; leave doRPC
                     //EH_continue then restart doRPC
                    if);
                 #);
              do (theProxy[],theEntry[],EH_toDo[]) -> eh.connectionFailed; 
                 'FATAL!! errorHandler.connectionFailed further bound without calling "abort", "ignore" or "continue"' -> putLine;
                 theShell.kill (* default action *)
              #);
          
           //rpcError_serverOverload then
              
              (# EH_toDo: @eh.EH_cleanup
                 (# 
                 do (if toDo
                     //EH_kill then fa; leave doRPC
                     //EH_continue then restart doRPC
                    if);
                 #);
              do (theProxy[],theEntry[],EH_toDo[]) -> eh.serverOverLoad;
                 'FATAL!! errorHandler.serverOverLoad further bound without calling "abort", "ignore" or "continue"' -> putLine;
                 theShell.kill (* default action *)
              #)
              
           //rpcError_timeOut
           //rpcError_connBroken then
              
              (* Must have given up. *)
              fa; leave doRPC;

           //rpcError_formatError then
              
              (# EH_toDo: @eh.EH_cleanup
                 (# 
                 do (if toDo
                     //EH_kill then fa; leave doRPC
                     //EH_continue then restart doRPC
                    if);
                 #);
              do (theProxy[],theEntry[],EH_toDo[]) -> eh.wrongAnswer;
                 'FATAL!! errorHandler.wrongAnswer further bound without calling "abort", "ignore" or "continue"' -> putLine;
                 theShell.kill (* default action *)
              #)

          if);
          
           
          (* Check answer format. *)
          
          (if true
           //notification then
              
              (* No answer. *)
              
           //(msg.size < 6)
           //(msg.r[BetaRequestTypeInx] <> BetaAnswer) then
               
              (# EH_toDo: @eh.EH_cleanup
                 (# 
                 do (if toDo
                     //EH_kill then fa; leave doRPC
                     //EH_continue then restart doRPC
                    if);
                 #);
              do (theProxy[],theEntry[],EH_toDo[]) -> eh.wrongAnswer;
                 'FATAL!! errorHandler.wrongAnswer further bound without calling "abort", "ignore" or "continue"' -> putLine;
                 theShell.kill (* default action *)
              #)

              
           //(msg.r[errCodeInx] <> 0) then
               
              (if msg.r[errCodeInx]
               //EUnknownProxy then
                  
                  (# EH_toDo: @eh.EH_cleanup
                     (# 
                     do (if toDo
                         //EH_kill then fa; leave doRPC;
                         //EH_continue then
                            'Fatal error: continue not allowed on "unknownObject" errors!' -> putLine;
                            theShell.kill;
                        if);
                     #);
                  do (theProxy[],theEntry[],EH_toDo[]) -> eh.unknownObject;
                     'FATAL!! errorHandler.unknownObject further bound without calling "abort" or "ignore"' -> putLine;
                     theShell.kill (* default action *)
                  #)
                  
               //EUnknownGroup then
                  
                  (# EH_toDo: @eh.EH_cleanup
                     (# 
                     do (if toDo
                         //EH_kill then fa; leave doRPC;
                         //EH_continue then 
                            'Fatal error: continue not allowed on "unknownPattern" errors!' -> putLine;
                            theShell.kill;
                        if);
                     #);
                  do (theProxy[],theEntry[],EH_toDo[],false) 
                       -> eh.unknownPattern;
                     'FATAL!! errorHandler.unknownPattern further bound without calling "abort", "ignore" or "continue"' -> putLine;
                     theShell.kill (* default action *)
                  #)
                  
              if);
          if);
       #);
     
  exit error<>rpcError_OK
  #)
