ORIGIN '~beta/basiclib/basicsystemenv';

(* 
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

INCLUDE '~beta/containers/list';
INCLUDE '~beta/sysutils/RepetitionObject';
INCLUDE '~beta/process/binarygenerator';
INCLUDE 'RepetitionObjectsTable';

BODY 'rpc_interfaceBody';

--- systemlib:attributes ---

rpcError_OK:		 (# exit  0 #);
rpcError_noHost: 	 (# exit -1 #);
rpcError_connRefused:	 (# exit -2 #);
rpcError_serverOverload: (# exit -4 #);
rpcError_timeOut:        (# exit -5 #);
rpcError_connBroken:     (# exit -6 #);
rpcError_formatError:    (# exit -7 #);
rpcError_nomoreSockets:  (# exit -8 #);
(* etc *)

rpcHandler:
  (# 
     rpc_send: (* execute any remote procedure *)
       (# 
          dest: ^portablePortAddress; (* specifies who plays the server role *)
          rpc_id: @integer;	      (* selects which rpc within server *)
          msg: ^RepetitionObject;    
          (* Primary message to be sent. !!! Not reused for the answer. 
           * Three longs are reserved for the rpcHandler. 
           * See commformats.bet. *)
          messages: ^RepetitionObjectsTable; 
          (* Extra messages to be sent. May be empty. *)
          timeout: @integer;	      (* Call timedOut if no answer arrives in 
                                       * 'timeout' seconds. If timedOut returns
                                       * false, wait another timeout seconds.
                                       * Otherwise return rpcError_timeOut. *)
          protocol: ^protocolSpec;    (* selects communication type/parms *)
          error: @integer;	      (* one of 'rpcError_.*' *)
          notification: @Boolean;     (* If true, do not wait for answer. *)
          
          timedOut:< BooleanValue;    (* false: Try again.
                                       * true: Give up with rpcError_timeOut. *)
          connBroken:< BooleanValue;  (* false: Try again.
                                       * true: Give up with rpcError_connBroken *)
          
       enter (dest[],rpc_id,msg[],messages[],
              timeout,protocol[],notification)
       do <<SLOT rpcSend:descriptor>>
       exit (error,msg[])
       #);
     
     rpc_receiver: 
       (* accept remote requests for execution of a specific procedure *)
       (# 
          init:< 
            (# rpc_id: @integer; (* identifies this rpc_receiver 
                                  * within this server *)
               thisProcess: ^portablePortAddress; (* gathered during
                                                   * initialization of
                                                   * communication *)
            enter rpc_id
            do <<SLOT rpcReceiverInit:descriptor>>; INNER
            exit thisProcess[]
            #);
          onReceive:< 
            (# msg: ^RepetitionObject; 
               (* Message received. proxyRefs may be NONE. Answer is saved
                * in these repetitions. *)
               messages: ^RepetitionObjectsTable;  
               (* Extra messages received. *)
               error: @integer;		  (* one of 'rpcError_.*' *)
            enter (msg[],messages[])
            do INNER
            exit error
            #);
       #);
     
     ensemblePort: @Integer;       (* The TCP port number to use when
                                    * contacting the ensemble shell. *)
     
     init:<
       (# isEnsemble: @Boolean;		(* True if this process is to be
                                         * the local ensemble *)
       enter (isEnsemble,ensemblePort)
       do <<SLOT rpcHandlerInit:descriptor>>; INNER
       #);
     
     localEnsemble:
       (# eadrAsText: ^Text; 
          eadr: @tcpPortAddress;
          hostName: ^Text; 
          inadr: @Integer;
       do 
          thisHost -> (hostName[],eadr.inetAddr);
          ensemblePort -> eadr.portNo;
          eadr.asText -> eadrAsText[];
          
       exit (eadrAsText[], hostName[])
       #);
     
     otherEnsemble:
       (# eadrAsText: ^Text; 
          hostName: ^Text; 
          eadr: @tcpPortAddress;
          notFound:< Notification;
          
       enter hostName[]
       do 
          hostName[] -> 
          gethostbyname(# notFound::< (# do this(otherEnsemble).notFound #)
                       #) -> eadr.inetAddr;
          ensemblePort->eadr.portNo;
          eadr.asText->eadrAsText[];
          
       exit eadrAsText[]
       #);
     
     shutDown: (# do <<SLOT rpcHandlerShutDown:descriptor>> #);
     
     rpcPrivate: @<<SLOT rpcHandlerPrivate:descriptor>>
     
  #);
