ORIGIN 'shellRPCbody';
(* 
 * $RCSfile: workerBody.bet,v $ 
 * $Revision: 1.3 $ 
 * $Date: 1997-06-30 13:55:29 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE 'shellComm';
INCLUDE '~beta/sysutils/v1.6/endian';

(* WORKERINIT
 * ========== *)

--- WorkerInit:dopart ---
do workerPrivate.dos.init;

(* WORKERREINIT
 * ============ *)

--- WorkerReInit:dopart ---
do workerPrivate.dos.reinit;

(* WORKERPRIVATEBODY
 * ================= *)

--- Workerprivatebody: descriptor ---
(# dos: @DistrObjectSerializer
     (# reinit::<
          (# 
          do NONE -> msg[]; 
             NONE -> messages[];
          #);
     #);
   
   clearOnError:
     (# req: ^RPC.receiver.onReceive;
     enter req[]
     do req.messages.reInit;
        req.msg.init;
     #);
   
   handleExecRequest:
     (# OID: @OIDtype;   (* OID of local remoteable. *)
        execObj: ^Object;
        msg: ^RepetitionObject; (* Short for req.msg *)
        req: ^RPC.receiver.onReceive;
        index: @Integer;
        ri: ^remoteInfo;
        
     enter req[]
     do
        req.msg[] -> msg[];
        
        execute:
          (if msg.size < 9 //true then
              req[] -> clearOnError;
              rpcError_formatError -> req.error;
           else
              BetaAnswer -> htonl -> msg.r[BetaRequestTypeInx];
              0 -> msg.r[errCodeInx];
              
              msg.getLong -> OID.a;
              msg.getLong -> OID.b;
              
              (if OID -> OIDhandler.localObjects.exclFindByOID -> ri[]
               //NONE then 
                  req[] -> clearOnError;
                  errCodeInx -> msg.size -> msg.pos;
                  EUnknownProxy -> msg.putLong;
                  rpcError_OK -> req.error;
                  leave execute 
               else
                  ri[] -> dos.curProxy[];
              if);
              
              (msg[],req.messages[]) -> dos.get
              (# unknownProtoType::<
                   (# 
                   do req[] -> clearOnError;
                      errCodeInx -> msg.size -> msg.pos;
                      EUnknownGroup -> msg.putLong;
                      rpcError_OK -> req.error;
                      leave execute 
                   #);
                 unknownObject::<
                   (# 
                   do req[] -> clearOnError;
                      errCodeInx -> msg.size -> msg.pos;
                      EUnknownProxy -> msg.putLong;  
                      rpcError_OK -> req.error;
                      leave execute 
                   #);
              #) -> execObj[]; 
              
              (* execute the object. *)
              execObj;
              
              msg.init;
              
              (* The objects table contains the transient OID's of the 
               * objects present in the request. The objects should keep 
               * their transient OID's when sent back to let the caller 
               * update the original objects correctly. *)
              
              (execObj[],msg[],req.messages[]) -> dos.put;
              
              rpcError_OK -> req.error;
          if);
     #);
   
   handleObjStateRequest:
     (# req: ^RPC.receiver.onReceive;
     enter req[]
     do 
     #);
#)


--- workerHandleRequest:dopart ---
do
   req.msg.reset;
   (if req.msg.size < 6 //true then
       req.messages.reInit; 
       req.msg.init;
       rpcError_formatError -> req.error;
    else
       BetaRequestTypeInx -> req.msg.pos;
       (if req.msg.getLong
        //BetaRequest then
           
           (if req.msg.getLong 
            //ObjExecRequest then
               req[] -> workerPrivate.handleExecRequest
            //ObjStateRequest then
               req[] -> workerPrivate.handleObjStateRequest
            else
               req.messages.reInit;  
               rpcError_formatError -> req.error;
           if);       
           
        else
           req.messages.reInit; 
           rpcError_formatError -> req.error;
       if);
   if);
   
