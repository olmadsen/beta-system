ORIGIN 'shellBody';
(* 
 * $RCSfile: OIDhandlerBody.bet,v $ $Revision: 1.1.1.1 $ $Date: 1994-08-22 08:37:09 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
--- include 'ensembleBody'

-- OIDHandlerPrivate:descriptor ---
(# 
   OIDa: @Integer;
   nextFree: @Integer;
   freeCount: @Integer;
   request: @Integer;
     
   newOID:@errorHandler
     (# connectionFailed::< 
          (# 
          do 'FATAL ERROR!! Communication with ' -> screen.putText;
             theShell.myEnsemble.hostName[] -> screen.putText;
             ' ensemble failed. (connectionFailed)' -> screen.putLine;
             theShell.kill;
          #);
        connectionBroken::< 
          (# 
          do 'FATAL ERROR!! Communication with ' -> screen.putText;
             theShell.myEnsemble.hostName[] -> screen.putText;
             ' ensemble failed. (connectionBroken)' -> screen.putLine;
             theShell.kill;
          #);
        timeOut::< 
          (# 
          do theShell.myEnsemble.hostName[] -> screen.putText;
             (if timeOutCount //10 then
                 ' ensemble not responding. Passing error to next handler.'
                   -> screen.putLine;
                 (theShell.myEnsemble[],NONE) -> prevHandler.timeOut -> toDo;
              else
                 timeOutCount+1 -> timeOutCount;
                 ' ensemble not responding. Still trying.' -> screen.putLine;
                 EH_retry -> toDo;
             if)
          #);
        wrongAnswer::< 
          (#
          do 'FATAL ERROR!! Communication with ' -> screen.putText;
             theShell.myEnsemble.hostName[] -> screen.putText;
             ' ensemble failed. (wrongAnswer)' -> screen.putLine;
             theShell.kill;
          #);
        timeOutCount: @Integer;
     do 
        0 -> timeOutCount;
        (if freeCount //0 then
            (if request //0 then
                1 -> request
             else
                (if request < 8 //true then 2*request -> request if)
            if);
            request -> freeCount
              -> theShell.myEnsemble.newOIDs 
              -> (OIDa,nextFree);
        if);
        freeCount-1 -> freeCount;
        nextFree+1 -> nextFree;
     exit (OIDa,nextFree-1)
     #);
   
   assign: 
     (# ra: ^remoteAble
     enter ra[]
     do
        &RemoteInfo[] -> ra.ri[];
        
        newOID -> ra.ri.OID;
   
        ra[] -> ra.ri.o[];
        RPC.localAddress[] -> ra.ri.shellAdr[];
        
        ra[] -> typeAllocator.initFromObj -> ra.ri.netType[];
        
        (if ra[] //theShell[] then
            RPC.localHostName[] -> ra.ri.ensembleName[];
            RPC.localEnsembleAdrAsText[] -> ra.ri.ensembleAdrAsText[];
        if);
        
        theShell.ri.OID -> ra.ri.shellOID;
        
        ra.ri[] -> localObjects.exclInsert;
     #);
#)

--- assignOIDBody:dopart ---  
do
   assignOIDmutex.P; 
   (if ra.ri[] //NONE then
       
       (if theShell.ri[] //NONE then
           (* theShell needs an OID in any case. *)
           theShell[] -> oidhprivate.assign;
       if);
   
       (if ra[] // theShell[] then 
           (* We already handled theShell. *)
        else
           ra[] -> oidhprivate.assign;
       if);
   if);
   assignOIDmutex.V;
