ORIGIN '../basicshell';
(* 
 * $RCSfile: ensembleBody.bet,v $ 
 * $Revision: 1.2 $ 
 * $Date: 1996-06-21 10:49:56 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE 'shellBody';
INCLUDE 'performRPC';
INCLUDE 'commFormats';
INCLUDE 'shellComm';
INCLUDE 'ensembleInterface';

--- EnsemblePutBody:descriptor --- 
(# 
do  
   (if obj[] -> senvPriv.typeAllocator.isEnsemble //false then
       
       (if (name[],obj[],FALSE) -> saveReference 
        //ES_exists then
           (if overWrite //true then
               (name[],obj[],TRUE) -> saveReference;
           if);
       if);
       
   if);
   
#)

--- EnsembleGetBody:descriptor ---
(# ri: ^remoteInfo;
   res: @Integer;
do
   (if type## //ensemble## then
       
       (name[],NONE,(0,0))
         -> senvPriv.remoteObjects.exclCreateEnsemble -> ri[];
       (if ri[] //NONE then
           notFound
        else
           ri.o[] -> obj[]
       if);
       
    else
       name[] -> getReference -> (obj[],res);
       (if res
        //ES_ok then
           (if obj## <= type## //false then none -> obj[]; quaError if);
           
           (* Check whether the object is still alive. *)
           (if obj.ping //false then
               name[] -> remove; none -> obj[]; notFound;
           if);
           
        //ES_notfound then
           none -> obj[]; notFound
       if); 
   if)
#)

--- EnsembleRemoveBody:descriptor ---
(#
do 
   (if name[] -> removeReference //ES_notfound then
       notFound;
   if);   
#)

--- EnsemblePrivateBody:descriptor ---
(# ei: ^ensembleInterface;
#)

--- ensembleCreateShellBody:descriptor ---
(# 
do
   hardPing; (* No reason to create process if no ensemble is present. *)
   (THIS(ensemble)[], THIS(createShell)[]) 
     -> senvPriv.shellCreator.createShell -> sh[];
#)

--- EnsembleScanNames:descriptor ---
(# names: [0]^Text;
do
   getNames -> names;
   (for i:names.range repeat
        names[i][] -> current[];
        INNER scanNames;
   for);
#)


--- ensembleAttributes:attributes ---

hardPing: entry
  (# 
  do (* Simply used to check the presense of the ensemble and raise
      * the relevant exceptions in case of trouble. *)
  #);

getNames: entry
  (# names: [1]^Text
  do ensemblePrivate.ei.getNamesImpl -> names;
  exit names
  #);

saveReference: entry 
  (# name: ^Text; r: ^remoteable; force: @Boolean;
     res: @Integer;
  enter (name[],r[],force)
  do (name[],r[],force) -> ensemblePrivate.ei.saveReferenceImpl -> res;
     (NONE,NONE) -> (name[],r[]);
  exit res
  #);
     
getReference: entry
  (# name: ^Text; r: ^remoteable; 
     res: @Integer;
  enter name[]
  do name[] -> ensemblePrivate.ei.getReferenceImpl -> (r[],res); 
     NONE -> name[];
  exit (r[],res)
  #);

removeReference: entry
  (# name: ^Text; 
     res: @Integer;
  enter name[]
  do name[] -> ensemblePrivate.ei.removeReferenceImpl -> res; NONE -> name[]
  exit res
  #);

newOIDs: entry
  (# requested: @Integer;
     OIDa, nextFree: @Integer;
  enter requested
  do requested -> ensemblePrivate.ei.newOIDsImpl -> (OIDa,nextFree)
  exit (OIDa,nextFree)
  #);
