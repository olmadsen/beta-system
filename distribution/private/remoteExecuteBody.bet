ORIGIN 'shellBody';
(* 
 * $RCSfile: remoteExecuteBody.bet,v $ 
 * $Revision: 1.3 $ 
 * $Date: 1996-06-21 10:49:56 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE 'shellComm';
INCLUDE 'commFormats';
INCLUDE 'performRPC';


(* REMOTEEXECUTEBODY
 * ================= *)

--- remoteExecuteBody:descriptor ---
(# er: ^rePrivate.execResource;
   eh: ^errorHandler;
   msg: ^RepetitionObject; (* Same as er.msg *)
   protSpec: @protocolSpec;
   commError: @Boolean;
   
   curEntry, curProxy: @ObjectTableElement;
   
do
   rePrivate.resourcePool.getResource -> er[];
   er.dos.msg[] -> msg[]; 
   
   doexecute:
     (# 
     do
        BetaRequestTypeInx -> msg.pos;
        BetaRequest -> msg.cheapPut;
        ObjExecRequest -> msg.cheapPut;
        theProxy.ri.OID.a -> msg.cheapPut;
        theProxy.ri.OID.b -> msg.cheapPut;
        msg.pos+3 -> msg.pos;
        msg.checkSize;
        
        (* As we already has all available information about the entry and
         * the proxy, we might as well tell the objects table: *)
        (theEntry[],(0,1)) -> curEntry; 
        curEntry[] -> er.dos.curEntry[];
        (theProxy[],theProxy.ri.OID) -> curProxy; 
        curProxy[] -> er.dos.curProxy[];

        (theEntry[],msg[],er.dos.messages[]) -> er.dos.put;
        
        (* Get active errorHandler: *)
        (if theActive.lc[] -> eh[] //NONE then globalHandler[] -> eh[] if);
        
        (* Select protocol. *)
        (commProtocol_dontcare, commRely_dontcare) -> protSpec;
        
        (* Perform RPC. *)
        (theProxy[], theEntry[], eh.timeOutValue, protSpec[],
        msg[], er.dos.messages[], eh[], notification) 
          -> performRPC 
          -> commError;
        
        (if true //notification//commError then
            (* Some communication error was ignored or it was a notification *)
            leave doexecute;
        if);
        
        (* Unserialize the answer updating the original objects with the 
         * state contained in the answer: *)
        (msg[],er.dos.messages[]) -> er.dos.get
        (# unknownProtoType::<
             (# 
             do (# EH_toDo: @eh.EH_cleanup
                   (# 
                   do (if toDo
                       //EH_kill then fa; leave doexecute;
                       //EH_continue then 
                          'Fatal error: continue not allowed on "unknownPattern" errors!' -> putLine;
                          theShell.kill;
                      if);
                   #);
                do (theProxy[],theEntry[],EH_toDo[],true) 
                     -> eh.unknownPattern;
                   'FATAL!! errorHandler.unknownPattern further bound without calling "abort", "ignore" or "continue"' -> putLine;
                   theShell.kill (* default action *)
                #)
             #);
           UnknownObject::<
             (# 
             do (* This should not happen. *)
                (failure, 'remoteExecute: Unexpected: UnknownObject')
                  -> stop;
             #);
        #);
     #);
   
   er[] -> rePrivate.resourcePool.releaseResource;
#)

--- remoteExecutorInit:descriptor ---
(#
do rePrivate.resourcePool.Init;
#)

--- remoteExecutorPrivate:descriptor ---
(# minimumRep: RepetitionObject (# initialRange::< (# do 50 -> value #)#);
   
   execResource:
     (# dos: @DistrObjectSerializer
          (# init::<
               (# 
               do &minimumRep[] -> msg[]; msg.init;
                  &repetitionObjectsTable[] -> messages[];
               #);
             reInit::<
               (# 
               do messages.reInit; msg.init;
               #);
          #);
        init: 
          (#
          do dos.init;
          #);
        reInit: @
          (# 
          do dos.reinit;
          #);
     #);
   
   resourcePool: @Monitor
     (# poolSize: (# exit 5 #);
        
        pool: [poolSize]^execResource;
        last: @Integer;
        
        getResource: entry
          (# er: ^execResource;
          do 
             (if last > 0 //true then
                 pool[last][] -> er[];
                 last-1 -> last;
              else
                 &execResource[] -> er[];
                 er.init;
             if);
          exit er[]
          #);
        
        releaseResource: entry
          (# er: ^execResource;
          enter er[]
          do
             (if last < poolSize //true then
                 last+1 -> last;
                 er[] -> pool[last][];
                 er.reInit;
             if);
          #);
     #);
#)
