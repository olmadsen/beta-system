ORIGIN '~beta/basiclib/v1.6/betaenv';
(* 
 * $RCSfile: ObjectSerializerTables.bet,v $ $Revision: 1.7 $ $Date: 1997-06-02 13:30:06 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE 'betaOID';

--- lib:attributes ---

myHashTable: 
  (# element:< Object;
     
     range:< (# value: @Integer; do 101 -> value; INNER exit value #);
     theRange: @Integer;
     
     collisionRange:< 
       (# value: @Integer; 
       do 10 -> value; INNER; (value, 2) -> max -> value
       exit value
       #);
     theColRange: @Integer;
     
     collisionList:< 
       (# elms:  [theColRange]^element;
          last: @Integer;
          deleteElm:<
            (* Should be specialized to delete the inx'th element in 
             * list by moving the element with index last to the 
             * inx'th position. *)
            (# inx: @Integer;
            enter inx
            do
               elms[last][] -> elms[inx][];
               NONE -> elms[last][];
               INNER;
               last-1 -> last; 
               size-1 -> size;
            #);
       #);
     
     size: @Integer;
     
     index: [1]^collisionList;
     
     init:<
       (# 
       do range -> theRange -> index.new; 0 -> size; 
          collisionRange -> theColRange; INNER
       #);
     
     reinit: @reInitImpl;
     reInitImpl:<
       (# 
       do theRange -> index.new; 0 -> size; INNER;
       #);
     
     scan:
       (# cl: ^collisionList;
          current: ^element;
          clear: @Boolean;
          count: @Integer;
       enter clear
       do 0 -> count;
          doscan:
            (for i: theRange repeat
                 (if index[i][] -> cl[] //NONE then else
                     (for j: cl.last repeat
                          cl.elms[j][] -> current[];
                          count+1 -> count;
                          INNER;
                     for);
                     (if clear //true then none -> index[i][] if);
                     (if count //size then leave doscan if);
                 if);
            for);
          (if clear //true then 0 -> size if);
       #);
     
     scanAndDelete:
       (# cl: ^collisionList;
          current: ^element;
          deleteThis: @Boolean;
          j: @Integer;
       do false -> deleteThis;
          doscan:
            (for i: theRange repeat
                 (if index[i][] -> cl[] //NONE then else
                     1 -> j;
                     while:
                       (if j <= cl.last //true then
                           cl.elms[j][] -> current[];
                           INNER;
                           (if deleteThis //true then
                               j -> cl.deleteElm;
                            else
                               j+1 -> j;
                           if);
                           restart while;
                       if)
                 if);
            for);
       #);
     
     
  #);

OIDhashTable: myHashTable
  (# collisionList::< 
       (# OIDas: [theColRange]@Integer; 
          OIDbs: [theColRange]@Integer;
          deleteElm::<
            (# 
            do
               OIDas[last] -> OIDas[inx];
               OIDbs[last] -> OIDbs[inx];
               INNER;
            #);
       #);
     
     find: @
       (# OID: @OIDtype;
          elm: ^element;
          cl: ^collisionList;
          inx: @Integer;
       enter OID
       do
          (if ((OID.b mod theRange) + 1 -> inx) < 0 //true then
              -inx -> inx;
          if);
          
          none -> elm[];
          (if index[inx][] -> cl[] //NONE then else
              (if cl.last //1 then
                  (if OID.b //cl.OIDbs[1] then
                      (if OID.a //cl.OIDas[1] then
                          cl.elms[1][] -> elm[];
                      if)
                  if);
               else
                  loop:
                    (for i:cl.last repeat
                         (if cl.OIDbs[i]=OID.b then
                             (if cl.OIDas[i]=OID.a then
                                 cl.elms[i][] -> elm[];
                                 leave loop;
                             if)
                         if);
                    for);
              if);
          if);
       exit elm[]
       #);
     
     find2: @
       (* Using find2, it is possible to differentiate the
        * cases where an OID was not found in the table, and the case
        * where the OID was found, but the corresponding element was 
        * NONE.  *)
       (# OID: @OIDtype;
          elm: ^element;
          cl: ^collisionList;
          inx, i, ofs, OIDb: @Integer;
          found: @Boolean;
       enter OID
       do
          (if ((OID.b mod theRange) + 1 -> inx) < 0 //true then
              -inx -> inx;
          if);
          false -> found;
          none -> elm[];
          (if index[inx][] -> cl[] //NONE then else
              (if cl.last //1 then
                  (if OID.b //cl.OIDbs[1] then
                      (if OID.a //cl.OIDas[1] then
                          cl.elms[1][] -> elm[];
                          true -> found;
                      if)
                  if);
               else
                  loop:
                    (for i:cl.last repeat
                         (if cl.OIDbs[i]=OID.b then
                             (if cl.OIDas[i]=OID.a then
                                 cl.elms[i][]->elm[];
                                 true->found;
                                 leave loop;
                             if);
                         if);
                    for);
              if);
          if)
       exit (elm[],found)
       #);
     
     overridePosElement: @
       (# newElm: ^element;
          inx1, inx2: @Integer;
       enter (newElm[],inx1,inx2)
       do newElm[] -> index[inx1].elms[inx2][]
       #);
     
     deletePosElement: @
       (# inx1, inx2: @Integer;
          cl: ^collisionList;
       enter (inx1,inx2)
       do index[inx1][] -> cl[];
          inx2 -> cl.deleteElm;
       #);
     
     delete: @
       (# OID: @OIDtype;
          elm: ^element;
          cl: ^collisionList;
          inx: @Integer;
       enter OID
       do
          (if ((OID.b mod theRange) + 1 -> inx) < 0 //true then
              -inx -> inx;
          if);
          
          none -> elm[];
          search:
            (if index[inx][] -> cl[] //NONE then else
                loop:
                  (for i:cl.last repeat
                       (if cl.OIDbs[i]=OID.b then
                           (if cl.OIDas[i]=OID.a then
                               cl.elms[i][]->elm[];
                               i->cl.deleteElm;
                               leave loop;
                           if);
                       if);                       
                  for);
            if);
       exit elm[]
       #);
     
     insert: @
       (* Exits position of the newly inserted element.
        * This position is only valid until a delete operation
        * has been performed. *)
       (# elm: ^element;
          OID: @OIDtype;
          cl: ^collisionList;
          inx, ie: @Integer;
       enter (elm[], OID)
       do
          (if ((OID.b mod theRange) + 1 -> inx) < 0 //true then
              -inx -> inx;
          if);
          
          (if index[inx][] -> cl[] //NONE then
              &collisionList[] -> cl[] -> index[inx][];
              1 -> cl.last;
           else
              (if (cl.last + 1 -> cl.last) //cl.elms.range then
                  cl.elms.range -> ie;
                  ie -> cl.elms.extend;
                  ie -> cl.OIDas.extend;
                  ie -> cl.OIDbs.extend;
              if);
          if);
          
          cl.last -> ie;
          elm[] -> cl.elms[ie][];
          OID.a -> cl.OIDas[ie];
          OID.b -> cl.OIDbs[ie];
          size+1 -> size;
       exit (inx,ie) 
       #);
  #);

ObjectHashTable: myHashTable
  (# collisionList::< 
       (# objs: [theColRange]^Object;
          deleteElm::<
            (# 
            do objs[last][] -> objs[inx][];
               NONE -> objs[last][];
               INNER;
            #)
       #);
               
     find: @
       (# obj: ^Object;
          elm: ^element;
          cl: ^collisionList;
          proto, inx: @Integer;
       enter obj[]
       do
          @@obj -> tos'%adrGetLong' -> tos'%adrGetLong' -> proto;
          (proto mod theRange) + 1 -> inx;
          
          none -> elm[];
          search:
            (if (index[inx][]->cl[])<>NONE then
                (for i:cl.last repeat
                     (if cl.objs[i][]=obj[] then
                         cl.elms[i][]->elm[];
                         leave search;
                     if);
                for);
            if);
       exit elm[]
       #);
     
     insert: @
       (# elm: ^element;
          obj: ^object;
          cl: ^collisionList;
          proto, inx, ie: @Integer;
       enter (elm[], obj[])
       do
          @@obj -> tos'%adrGetLong' -> tos'%adrGetLong' -> proto;
          (proto mod theRange) + 1 -> inx;
          
          (if index[inx][] -> cl[] //NONE then
              &collisionList[] -> cl[] -> index[inx][];
              1 -> cl.last;
           else
              (if (cl.last + 1 -> cl.last) //cl.elms.range then
                  (* Need to make sure that there is always a free position
                   * to use for find. *)
                  cl.elms.range -> ie;
                  ie -> cl.elms.extend;
                  ie -> cl.objs.extend;
              if);
          if);
          
          cl.last -> ie;
          elm[] -> cl.elms[ie][];
          obj[] -> cl.objs[ie][];
          size+1 -> size;
       #);
               
     delete: @
       (# obj: ^Object;
          cl: ^collisionList;
          proto, inx: @Integer;
       enter obj[]
       do
          @@obj -> tos'%adrGetLong' -> tos'%adrGetLong' -> proto;
          (proto mod theRange) + 1 -> inx;
          
          search:
            (if (index[inx][]->cl[])<>NONE then
                (for i:cl.last repeat
                     (if cl.objs[i][]=obj[] then
                         i->cl.deleteElm;
                         leave search;
                     if);
                for);
            if);
       #);
  #);

IntegerHashTable: myHashTable
  (# collisionList::< 
       (# ints: [theColRange]@Integer;
          deleteElm::<
            (# 
            do ints[last] -> ints[inx];
               INNER;
            #)
       #);
    
     find: @
       (# int, inx: @Integer;
          elm: ^element;
          cl: ^collisionList;
       enter int
       do
          (if int < 0 //true then -int -> inx else int -> inx if);
          (inx mod theRange) + 1 -> inx;
          
          none -> elm[];
          search:
            (if (index[inx][]->cl[])<>NONE then
                (for i:cl.last repeat
                     (if cl.ints[i]=int then
                         cl.elms[i][]->elm[];
                         leave search;
                     if);
                for);
            if);
       exit elm[]
       #);
     
     delete: @
       (# int, inx, i: @Integer;
          elm: ^element;
          cl: ^collisionList;
       enter int
       do
          (if int < 0 //true then -int -> inx else int -> inx if);
          (inx mod theRange) + 1 -> inx;
          
          none -> elm[];
          search:
            (if (index[inx][]->cl[])<>NONE then
                (for i:cl.last repeat
                     (if cl.ints[i]=int then
                         cl.elms[i][]->elm[];
                         i->cl.deleteElm;
                         leave search;
                     if);
                for);
            if);
       exit elm[]
       #);
     
     insert: @
       (# elm: ^element;
          cl: ^collisionList;
          int, inx, ie: @Integer;
       enter (elm[], int)
       do
          (if int < 0 //true then -int -> inx else int -> inx if);
          (inx mod theRange) + 1 -> inx;
          
          (if index[inx][] -> cl[] //NONE then
              &collisionList[] -> cl[] -> index[inx][];
              1 -> cl.last;
           else
              (if (cl.last + 1 -> cl.last) //cl.elms.range then
                  cl.elms.range -> ie;
                  ie -> cl.elms.extend;
                  ie -> cl.ints.extend;
              if);
          if);
          
          cl.last -> ie;
          elm[] -> cl.elms[ie][];
          int -> cl.ints[ie];
          size+1 -> size;
       #);
  #);


myQueue:
  (# element:< Object;
     
     link:
       (# elm: ^element;
          next: ^link;
       #);
     
     first, last: ^link;
     
     empty: @(# exit last[] = NONE #);
     
     insert: @
       (# elm: ^element;
       enter elm[]
       do
          (if last[] //NONE then
              &link[] -> first[] -> last[];
           else
              &link[] -> last.next[] -> last[];
          if);
          elm[] -> last.elm[];
       #);
     
     remove: @
       (# elm: ^element;
       do first.elm[] -> elm[];
          first.next[] -> first[];
          (if first[] //NONE then NONE -> last[] if);
       exit elm[]
       #);
     
     init: @(# do none -> first[] -> last[] #);
     
  #);

myStack:
  (# element:< Object;
     
     link:
       (# elm: ^element;
          next: ^link;
       #);
     
     top: ^link;
     
     empty: @(# exit top[] = NONE #);
     
     push: @
       (# elm: ^element;
          l: ^link;
       enter elm[]
       do
          (if top[] //NONE then
              &link[] -> top[];
           else
              &link[] -> l[];
              top[] -> l.next[];
              l[] -> top[];
          if);
          elm[] -> top.elm[];
       #);
     
     pop: @
       (# elm: ^element;
       do top.elm[] -> elm[];
          top.next[] -> top[];
       exit elm[]
       #);
     
     scan:
       (# cl: ^link; current: ^element;
       do 
          top[] -> cl[];
          loop:
            (if cl[] //NONE then else
                cl.elm[] -> current[];
                INNER;
                cl.next[] -> cl[];
                restart loop;
            if);
       #);
     
     init: @(# do none -> top[] #);
     
  #)
