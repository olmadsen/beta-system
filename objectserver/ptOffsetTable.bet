ORIGIN '~beta/basiclib/v1.6/betaenv';
(* 
 * $RCSfile: ptOffsetTable.bet,v $ $Revision: 1.11 $ $Date: 1997-10-06 12:31:54 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE 'ObjectSerializerTables';
INCLUDE '~beta/sysutils/v1.6/objinterface';

MDBODY linux   'private/ptoffsettable_littlebody'
       nti     'private/ptoffsettable_littlebody'
       default 'private/ptoffsettable_bigbody';

--- lib:attributes ---

(* PTOFFSETTABLE
 * =============
 * Used internally by the ObjectSerializer, but given as a parameter
 * to serialize and unserialize as any number of ObjectSerializers
 * can share a single ptOffsetTable. *)

offsetTableElement:
  (# ptAdr: @Integer;        (* Absolute address of the prototype     *)
     
     dynCount: @Integer;     (* Number of non-static references, including 
                              * origin references and static offline       
                              * references.                                *)
     dynRefs: [1]@Integer;   (* Byte offsets of dynamic references.        *)
     refTypes: [1]@Integer;  (* REFYPE_DYNAMIC, REFTYPE_OFFLINE or         
                              * REFTYPE_ORIGIN                             *)
     
     simpleCount: @Integer;    (* Number of simple value fields. *)
     simpleVals: [1]@Integer;  (* Byte offsets of simple values. *)
     simpleTypes: [1]@Integer; (* SIMPLETYPE_<something>. 
                                * See objinterface *)
     
     partCount: @Integer;  (* Number of static inlined partobjects.       *)
     parts: [1]@Integer;   (* Byte offsets of static inlined partobjects. *)
     protos: [1]@Integer;  (* Prototypes of static inlined partobjects.   *)
  #);

ptOffsetTable: integerHashTable
  (# element::< offsetTableElement;
     
     lookup: @
       (* Looks up pt in the table. If pt is not found, the corresponding
        * element is calculated, inserted, and returned. *)
       (# ptAdr: @Integer; 
          elm: ^element;
       enter ptAdr
       do (if (ptAdr -> find -> elm[])=NONE then 
              (ptAdr -> makeElement -> elm[], ptAdr) -> insert
          if)
       exit elm[]
       #);
     
     makeElement: @
       (# ofs: [1]@Integer;
          (* ofs[i] contains the meaning of the i'th long within 
           * objects that are instances of proto. The 1'st long is
           * the GC field as the prototype is not considered here.
           * Possible offsetTable values: 
           *)
          i: @Integer;
          staticPart: (# exit 10 #);
          gcInfo:     (# exit 20 #);
          
          protos: @
            (* protos.table[i] contains the prototype of the i'th 
             * inlined static part object. *)
            (# table: [1]@Integer;
               count: @Integer;
               append: @
                 (# proto: @Integer;
                 enter proto
                 do
                    (if count=0 then
                        1 -> count;
                     else
                        1 -> table.extend;
                        count + 1 -> count;
                    if);
                    proto -> table[count];
                 #);
               
               reset: @(# do 0 -> count; 1 -> table.new #);
            #);
          
                    
          fillOutOfs: 
            (# pt: @ProtoType; inx: @Integer;
            enter (pt, inx)
            do gcInfo -> ofs[inx+1]; 
               
               (* Fill out dynamic reference fields and call recursively
                * on static references (inlined objects): *)
               pt.scanRefs
               (# thisInx: @Integer;
               do inx + (thisOffset div 4) -> thisInx;
                  (if isStatic then 
                      (* The static table, tab[0], tab[1], 0,
                       * contains all static objects on all levels.
                       * Here we only need to perform fillOutOfs on static objects
                       * on 1 level. The recursion in fillOutOfs handle other
                       * levels. 
                       * The way to determine the level of an static object is to 
                       * compare the Offset (StaticOff) and the
                       * Distance_To_Inclosing_Object (OrigOff).
                       *)     
                      (if (-thisOriginOff)=thisOffset then 
                          staticPart -> ofs[thisInx];
                          thisProto -> protos.append;
                          (thisProto, thisInx) -> fillOutOfs;
                      if)
                   else 
                      refType -> ofs[thisInx];
                  if);
               #);
               <<SLOT ptOTscanSimpleTypesBody:descriptor>>;
            #);
          
          pt: @ProtoType;
          elm: ^element;
          
       enter pt
       do &element[] -> elm[];
          pt -> elm.ptAdr;
          
          (* 'makeElement: Prototype is ' -> screen.putText;
           * pt.labid -> screen.putLine; 
           *)
          
          (if ofs.range < pt.size - 1  then
              pt.size - 1 -> ofs.new;
          if);
          (* ofs.range >= pt.size - 1, as the proto field is ignored. *)
          
          (for i:pt.size - 1 repeat SIMPLETYPE_BIN32 -> ofs[i] for);
          
          (pt,0) -> fillOutOfs;
          
          (for i: pt.size - 1 repeat
               (if ofs[i] 
                //REFTYPE_DYNAMIC
                //REFTYPE_ORIGIN
                //REFTYPE_OFFLINE then
                   elm.dynCount+1->elm.dynCount;
                   (if elm.dynCount > elm.dynRefs.range then
                       elm.dynRefs.range -> elm.dynRefs.extend;
                       elm.refTypes.range -> elm.refTypes.extend;
                   if);
                   i*4 -> elm.dynRefs[elm.dynCount];
                   ofs[i] -> elm.refTypes[elm.dynCount];
                   
                //staticPart then
                   elm.partCount+1->elm.partCount;
                   (if elm.partCount > elm.parts.range then
                       elm.parts.range -> elm.parts.extend;
                   if);
                   i*4 -> elm.parts[elm.partCount];
                   
                // SIMPLETYPE_BIN32
                // SIMPLETYPE_INT32 
                // SIMPLETYPE_REAL64
                // SIMPLETYPE_HANDLED
                // SIMPLETYPE_INT16INT16 
                // SIMPLETYPE_INT16BIN16 then
                   elm.simpleCount+1->elm.simpleCount;
                   (if elm.simpleCount > elm.simpleVals.range then
                       elm.simpleVals.range -> elm.simpleVals.extend;
                       elm.simpleTypes.range -> elm.simpleTypes.extend;
                   if);
                   i*4 -> elm.simpleVals[elm.simpleCount];
                   ofs[i] -> elm.simpleTypes[elm.simpleCount];
                   
                // gcInfo then
                   (* Do nothing *)
                else
                   'Unhandled ofs in ptOffsetTable at '->putText;
                   i->putInt; ': '->putText; ofs[i] -> putInt;newLine;
                   Stop;
               if); 
          for);
          
          (if elm.partCount<>0 then
              protos.table -> elm.protos;
              protos.reset;
          if);
       exit elm[]
       #);
  #);
