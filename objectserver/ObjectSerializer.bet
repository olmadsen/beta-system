ORIGIN '~beta/basiclib/v1.4/betaenv';
(* 
 * $RCSfile: ObjectSerializer.bet,v $ $Revision: 1.7 $ $Date: 1996-05-31 12:00:18 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
BODY 'private/serializeBody' 'private/unserializeBody';

(* This fragment contains the interface to ObjectSerializer
 * and ObjectUnSerializer used in the implementation of 
 * persistentstore, OODB, and the packing and unpacking (marshalling)
 * of objects sent across the network to handle distributed objects.
 * 
 * An object is saved in the following format: 
 * 
 * Format of a saved object reference:
 * (!!)  Object references are saved as an offset followed by an object OID.
 *       Objects not physically inlined in other objects have their own OID.
 *       In that case the offset is zero. Objects inlined in other objects do 
 *       not have their own OID, and in that case the reference is saved as 
 *       the OID of the enclosing object and a non-negative offset into that 
 *       object.
 *       As offsets are always 8-byte aligned, the three (actually only two)
 *       low-order bits of the offset field is used for information about the 
 *       type of reference. There are three different reference types as 
 *       declared in ~beta/sysutils/v1.4.2/objinterface.bet:
 * 
 *            REFTYPE_DYNAMIC: (# exit 0 #);
 *            REFTYPE_OFFLINE: (# exit 1 #);
 *            REFTYPE_ORIGIN:  (# exit 2 #);
 * 
 *       That is: "offset bitand 7" is the reference type.
 *                "offset bitand not 7" is the offset value..
 *
 *       An object reference thus takes up 3 longs in the serialization.
 *       If the reference is NONE, noneOID is stored instead of the 
 *       object OID.
 * 
 * Each object is put in the following format. (proto, group) information is
 * not saved in the serialization, but somewhere else defined by the user of
 * the ObjectSerializer.
 *
 * 0: Number of simple values in the list (1) below.
 * 1: Simple values in order of appearance, including statically inlined
 *    part objects. (1 long per value)
 * 2: List of all references within the object in order of appearance. 
 *    This includes origin references, static offline references, dynamic
 *    references, repetition object references and structure references.
 *    Note that references contained in statically inlined objects are also 
 *    in the the list, as statically inlined objects are simply treated as 
 *    part of the enclosing object (recursively).
 *    a: Object references are saved as described above. 
 *    b: Value repetitions have no OID and are saved as (3 longs + substance):
 *        (i)   Prototype (ValRepPTValue, ByteRepPTValue, 
 *                         WordRepPTValue or DoubleRepPTValue)
 *        (ii)  LowRange
 *        (iii) HighRange
 *        (iv)  The longs necessary to save the contents of the repetition.
 *    c: Reference repetitions have no OID and are saved as (3 longs + refs)
 *        (i)   Prototype (RefRepPTValue)
 *        (ii)  LowRange
 *        (iii) HighRange
 *        (iv)  Each object reference contained in the repetition is stored 
 *              as explained under (!!). The reference type is REFTYPE_DYNAMIC.
 *    d: Pattern variable references are saved as (6 longs)
 *        (i)   ProtoType  (StructurePTValue)
 *        (ii)  Group id.     (Group containing the prototype)
 *        (iii) ProtoType id. (Id of prototype within the group)
 *        (iv)  Identification of origin object. (REFTYPE_ORIGIN)
 *       This means that a pattern variable is saved in as many copies as
 *       there are objects referencing it. As pattern variables are constant
 *       (once created they never change) this has no logical consequences,
 *       but if the same pattern variable is pointed out many times,
 *       it may mean some waste of memory. This is probably no serious
 *       problem. The alternative is that ObjectTable, ObjectSerializer and
 *       ObjectUnserializer below would have to handle pattern references
 *       explicitly, making them twice as complex.
 * 
 *)

--- include '~beta/sysutils/v1.4.2/objinterface'
--- include 'betaOID'
--- include 'RepetitionObject'
--- include 'danglingtable'
--- include 'objecttable'
--- include 'ptOffsetTable'

--- lib: attributes ---

(* SERIALIZE
 * ========= 
 * 
 * Execute serialize to serialize an object. When INNER serialize is called,
 * call forEachRoot for each root to be serialized.
 * 
 * serialize will call doPutObject on each object to query whether that 
 * specific object should be serialized. 
 * If putObject returns false, the object will not be serialized, and neither
 * will objects only reachable through this one.
 * 
 * Upon return from serialize, the objects table will contain all objects 
 * serialized and objects directly reachable from these. It may later be 
 * used when unserializing objects to achieve update of the objects instead of
 * creating new instances.
 * 
 * getRepetition is called just before the serialization of an object
 * begins. The repetition object returned is used to save the object. 
 * If needed, the user may save the object his own special way, and return 
 * TRUE in putSpecial. In that case the object is simply assumed to have been 
 * saved, and serialize does not save it. In that case, putDone is not called.
 * 
 * doPutObject is called to query whether the object in e is to be serialized.
 * 
 *    doPutObject is not called for objects whose OID was set to noneOID in
 *    objects.newOID, or objects reached through a REFTYPE_OFFLINE reference. 
 * 
 *    If TRUE is returned, the object is put into a queue for future
 *    serialization. Before the actual serialization starts, getRepetition
 *    is called to obtain a RepetitionObject to put the serialization into.
 *
 *    If FALSE is returned, the object or pattern will not be serialized.
 *    BEWARE that objects already serialized contains references to this 
 *    object. It might therefore, in some cases, be impossible to unserialize 
 *    these unless this is ensured in some other way.
 * 
 *    If FALSE is returned, doPutObject may be called again if refType is 
 *    REFTYPE_DYNAMIC or REFTYPE_ORIGIN, and later the opposite is found. 
 *    In that case doPutObject is queried again to make it possible to regret 
 *    the first decision.
 * 
 *    If FALSE is returned, and a REFTYPE_OFFLINE to the object is later found 
 *    from an object that _should_ be put, this object is put into the 
 *    serialization queue without calling doPutObject again. Immediately before
 *    serialization, getRepetition is called to obtain a repetitionObject, as
 *    usual. The first call to doPutObject is simply ignored.
 * 
 * putDone is called when e.o has been serialized.
 * 
 * forEachRefSaved is called for each reference saved in an object 
 *    serialization. 
 * 
 * unknownProtoType is raised if pt was not found by 
 *    objects.getGroupAndProtoId. It is not possible to 
 *    continue serialization after this.
 *)

serialize:
  (# 
     doPutObject:<
       (# e: ^objects.element;
          fromOID: @OIDtype; (* OID of object first referencing e.o. *)
          refType: @Char;
          isRoot: @Boolean;
          value: @Boolean;
       enter (e[], fromOID, refType, isRoot)
       do true -> value; INNER;
       exit value
       #);
     
     putDone:< 
       (# e: ^objects.element;
          rep: ^repetitionObject; (* The serialization of e *)
          firstPos: @Integer;     (* First position in rep of the 
                                   * serialization of e.o. *)
          afterPos: @Integer;     (* First position in rep after the 
                                   * serialization of e.o. *)
          group, proto: @Integer; (* External prototype representation. *)
       enter (e[],rep[],firstPos,afterPos,group,proto)
       do INNER;
       #);
     
     forEachRefSaved:<
       (# fromOID, toOID: @OIDtype;
       enter (fromOID, toOID)
       do INNER
       #);
     
     getRepetition:<
       (# e: ^objects.element;
          rep: ^RepetitionObject;
          putSpecial: @Boolean;
       enter e[]
       do FALSE -> putSpecial; INNER
       exit (rep[],putSpecial)
       #);
     
     unknownProtoType:< Exception
       (# pt: ^ProtoType enter pt[] do INNER; false -> continue #);
     
     stateTableRange:< IntegerValue (# do 101 -> value; INNER #);
     stateTableCollisionRange:< IntegerValue (# do 10 -> value; INNER #);
     (* These are the ranges used when initializing the internal 
      * stateTable. Furtherbind if it is more efficient with another
      * size of these tables. *)
     
     (* In INNER serialize, call forEachRoot for each root object. 
      * If objElm is not NONE, it is assumed to be the ObjectTableElement 
      * corresponding to thisRoot. *)
     
     forEachRoot: @
       (# thisRoot: ^Object;
          fromOID: @OIDtype;
          objElm: ^ObjectTableElement;
          OID: @OIDtype;
          offset: @Integer;
       enter (thisRoot[],fromOID,objElm[])
       <<SLOT forEachRootImpl:dopart>>
       exit (OID,offset)
       #);
          
     objectsType:< ObjectTable;
     objects: ^objectsType;
     danglers: ^danglingTable;
     ptOffsets: ^ptOffsetTable;
     
     osPrivate: @<<SLOT osPrivateBody:descriptor>>;
     
  enter (objects[], danglers[], ptOffsets[])
  <<SLOT osSerializeBody:dopart>>
  #);


(* UNSERIALIZE
 * =========== 
 * 
 * Calls INNER and expects forEachRoot to be called for each root object
 * that should be unserialized. Upon return the objects table
 * given as parameter contains all the objects unserialized.
 * 
 * doGetObject is called to ask whether the object with OID should 
 *    be unserialized.
 * 
 *    If the object is contained in the objects table, found will 
 *    contain the corresponding ObjectTableElement, and doGetObject 
 *    can be used to control whether the object state should be 
 *    updated or the object should be left untouched. 
 * 
 *    fromOID is the OID of the object containing the reference that
 *    triggered this call to doGetObject. The type of reference is
 *    given by refType.
 *
 *    If isRoot is TRUE, the object is on eof the roots given to ForEachRoot.
 * 
 *    If FALSE is returned, neither the object, nor objects only 
 *    reachable from this one will be unserialized/updated.
 * 
 *    An object not contained in the objects table, (found will be 
 *    NONE) but referenced from an object being unserialized has to 
 *    be unserialized to avoid dangling references. In that case, 
 *    if FALSE is returned, the step taken depends on the value 
 *    returned from allowDanglingRefs. 
 *    If allowDanglingRefs is TRUE, danglers is consulted to get a 
 *    value to use instead of the real reference.
 *    If allowDanglingRefs is FALSE, the UnknownObject exception is 
 *    raised. 
 * 
 *    If the object is needed as origin of another object being 
 *    unserialized, and found[] is NONE, the object MUST be 
 *    unserialized. In that case the origin is unserialized without 
 *    asking, and in case doGetObject was called before it was known 
 *    that the object was needed as origin, the answer returned then
 *    is simply ignored.
 * 
 *    When unserializing/updating objects having static parts 
 *    allocated offline, these parts are always read together with 
 *    the enclosing object, without asking.
 * 
 * 
 * allowDanglingRefs decides whether doGetObject is allowed to return 
 *    FALSE on objects not found in the objects table. If FALSE, the 
 *    UnknownObject exception is raised. If TRUE the dangling 
 *    reference is set up as described in doGetObject. The setup of
 *    dangling references is not done until all calls to ForEachRoot have 
 *    been finished.
 * 
 * getSerialization is called to get the serialization of the object to be 
 *    unserialized. Upon return, rep.pos must point out the first element of 
 *    the serialization.
 * 
 *    It is allowed to return the same repetitionObject several times
 *    with different positions. If none is returned, the getSerFailed 
 *    exception is raised. 
 * 
 *    If the object was saved specially (putSpecial in 
 *    serialize.getSerialization), it may be necessary to read it specially.
 *    In that case, if getSpecial is TRUE upon return, it is assumed that the
 *    object was read, and that objElm.o now refers the object.
 * 
 * 
 * getDone is called immediately after objElm.o has been read and updated.
 * 
 * unknownProtoType is Raised if (group,proto) was not found by 
 *    objects.getProto. Unserialization cannot continue after this.
 * 
 * 
 *)

unserialize:
  (# doGetObject:<
       (# OID, fromOID: @OIDtype;
          found: ^objects.element;
          refType: @Integer;
          isRoot: @Boolean;
          value: @Boolean;
       enter (OID, found[], fromOID, refType, isRoot)
       do true -> value; INNER
       exit value
       #);
     
     allowDanglingRefs:< BooleanValue 
       (# do false -> value; INNER #);
     
     getSerialization:<
       (# OID, fromOID: @OIDtype;
          objElm: ^objects.element;
          rep: ^repetitionObject;
          proto,group: @Integer;
          getSpecial: @Boolean;
       enter (OID,fromOID,objElm[])
       do FALSE -> getSpecial; INNER
       exit (rep[],proto,group,getSpecial)
       #);
     
     getDone:<
       (# objElm: ^objects.element;
       enter objElm[]
       do INNER
       #);
     
     unknownProtoType:< Exception
       (# group, proto: @Integer 
       enter (group, proto) 
       do INNER; false -> continue;
       #);
     
     UnknownObject:< Exception 
       (* See allowDanglingRefs and doGetObject *)
       (# OID: @OIDtype enter OID do INNER; false -> continue; #);
     
     getSerFailed:< Exception
       (* See getSerialization. *)
       (# OID: @OIDtype enter OID do INNER; false -> continue; #);
     
     stateTableRange:< IntegerValue (# do 101 -> value; INNER #);
     stateTableCollisionRange:< IntegerValue (# do 10 -> value; INNER #);
     (* These are the ranges used when initializing the internal 
      * stateTable. Furtherbind if it is more efficient with another
      * size of these tables. *)
     
     objectsType:< ObjectTable;
     objects: ^objectsType;
     danglers: ^danglingTable;
     ptOffsets: ^ptOffsetTable;
     
     
     (* When INNER serialize is called, forEachRoot should be called
      * for each root object to be serialized. If objElm is not NONE, it is 
      * assumed to be the objectTableElement corresponding to OID. This may 
      * save a findByOID call to the objects table if the objElm is known
      * by the caller already. *)
     
     forEachRoot: @
       (# OID: @OIDtype;
          offset: @Integer;
          fromOID: @OIDtype;
          objElm: ^ObjectTableElement;
          thisRoot: ^Object;
          doIt: @<<SLOT forEachUnserRootImpl:descriptor>>
       enter (OID,offset,fromOID,objElm[])
       do doIt
       exit thisRoot[]
       #);

     ousPrivate: @<<SLOT ousPrivateBody:descriptor>>;
     
  enter (objects[], danglers[], ptOffsets[])
  <<SLOT ousUnserializeBody:dopart>>
  #);

(* GROUP and PROTO packing
 * =======================
 * 
 * Since the group and proto values used for representing types are currently
 * only 16 bit values, they may be packed in a single integer. This can be
 * done using the following operations. Notice that the operations allow
 * negative values for group and proto. *)

packGroupProto:
  (# group,proto,packed: @Integer;
  enter (group,proto)
  exit (group -> TOS'%ShiftLeft[16]', (proto,16x0000FFFF) -> TOS'%and') 
       -> TOS'%or'
  #);

unpackGroupProto:
  (# packed: @Integer;
  enter packed
  exit (packed->TOS'%aritShiftRight[16]',
     packed->TOS'%ShiftLeft[16]'->TOS'%aritShiftRight[16]')
  #);
   
