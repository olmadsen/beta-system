ORIGIN '../execGroupTable';
(* 
 * $RCSfile: execGroupTableBody.bet,v $ $Revision: 1.5 $ $Date: 1996-02-09 13:44:54 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE '~beta/sysutils/v1.4.1/objinterface';
INCLUDE '~beta/basiclib/v1.4/external';
INCLUDE '../ObjectSerializerTables';
INCLUDE '../objectserverdiradds';

--- initGroupTable:descriptor ---
(#
   strippath:
     (# tmp: @Integer;
        fname,stripped: ^Text;
     enter fname[]
     do
        0 -> tmp;
        directoryChar -> fname.findCh (# do inx -> tmp #);
        (if tmp //0 then
            fname.copy -> stripped[]
         else
            (tmp+1,fname.lgth) -> fname.sub -> stripped[]
        if)
     exit stripped[]
     #);
   
   getGroups:
     (# elm: ^standardEGTE;
        current: @group_header;
        name: @Text;
     do loop:
          (if current.ptr -> NextGroup -> current.ptr //0 then else
              &standardEGTE[] -> elm[];
              (* &Text[] -> elm.groupName[]; *)
              
              current.ptr -> NameOfGroup -> elm.address 
                -> extGetCstring -> name; (* elm.groupName; *)
			  (*******) 'Found: '->puttext; name[]->puttext; ' '->put;
              name[] -> strippath -> elm.groupName[];
              nextInx -> elm.inx;
              
              (if elm.groupName[] -> findGroupByName //NONE then
                  elm[] -> nameHash.insert;
                  (elm[], elm.address) -> adrHash.insert;
                  
                  current.NoOfPrototypes -> elm.len;
                  current.protoTableAdr  -> elm.ptListAdr;
				  (*******) elm.len->putint; ' '->put; elm.ptListAdr->putint; newline;
               else
                  'ERROR!! This executable contains two source files named "' 
                    -> screen.putText; elm.groupName[] -> screen.putText;
                  '".\nThis is currenly not allowed when using persistence or distribution libraries.' -> screen.putLine;
                  (failure,'') -> stop;
              if);
              restart loop;
          if);
     #);
do 
   nameHash.init; 
   adrHash.init;
   getGroups;
#)


--- execGroupTableInsert:dopart ---
do egte[] -> nameHash.insert;
   (egte[], address) -> adrHash.insert;
   
--- findGroupByAdr:dopart ---
do (address,false) -> GroupName -> adrHash.find -> found[];
   
--- lib:attributes ---
GroupName: external (* in outpattern.c *)
  (# address: @Integer;
     isCode: @Integer;
     groupNameAdr: @Integer;
  enter (address, isCode)
  exit groupNameAdr
  #);

--- segteInxToPt:dopart ---
do ptListAdr + 4*inx -> tos'%adrGetLong' -> ptAdr

--- segtePTtoInx:dopart ---
do
   (if len > 0 //true then
       0 -> low;
       len-1 -> high;
       
       loop:
         (if high//low then
             (if (ptListAdr + 4*low -> tos'%adrGetLong') //ptAdr then
                 low -> inx;
              else
                 -1 -> inx;
             if);
          else
             (low+high) div 2 -> mid;
             (if (ptListAdr + 4*mid -> tos'%adrGetLong') < ptAdr
              //true then
                 mid + 1 -> low;
              else
                 mid -> high;
             if);
             restart loop;
         if);
              
    else
       -1 -> inx;
   if)
   
