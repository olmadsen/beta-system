ORIGIN '../execGroupTable';
(* 
 * $RCSfile: execGroupTableBody.bet,v $ $Revision: 1.4 $ $Date: 1994-08-22 13:57:08 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
INCLUDE '~beta/sysutils/v1.4/objinterface';
INCLUDE '~beta/basiclib/v1.4/external';
INCLUDE '../ObjectSerializerTables';
INCLUDE '~beta/sysutils/v1.4/pathhandler';

--- initGroupTable:descriptor ---
(# ph: @pathHandler;
   
   strippath:
     (# tmp: @Integer;
        fname,stripped: ^Text;
     enter fname[]
     do
        0 -> tmp;
        ph.directoryChar -> fname.findCh (# do inx -> tmp #);
        (if tmp //0 then
            fname.copy -> stripped[]
         else
            (tmp+1,fname.lgth) -> fname.sub -> stripped[]
        if)
     exit stripped[]
     #);
   
   getGroups:
     (# elm: ^standardEGTE;
        current: ^group_header;
        name: @Text;
     do 
        loop:
          (if current[] -> NextGroup -> current[] //NONE then else
              &standardEGTE[] -> elm[];
              (* &Text[] -> elm.groupName[]; *)
              
              current[] -> NameOfGroup -> elm.address 
                -> extGetCstring -> name; (* elm.groupName; *)
              name[] -> strippath -> elm.groupName[];
              
              nextInx -> elm.inx;
              
              (if elm.groupName[] -> findGroupByName //NONE then
                  elm[] -> nameHash.insert;
                  (elm[], elm.address) -> adrHash.insert;
                  
                  current.protoTableAdr -> tos'%adrGetLong' -> elm.len;
                  current.protoTableAdr + 4 -> elm.ptListAdr;
               else
                  'ERROR!! This executable contains two source files named "' 
                    -> screen.putText; elm.groupName[] -> screen.putText;
                  '".\nThis is currenly not allowed when using persistence or distribution libraries.' -> screen.putLine;
                  (failure,'') -> stop;
              if);
              restart loop;
          if);
     #);
do 
   ph.init;
   nameHash.init; 
   adrHash.init;
   getGroups;
#)


--- execGroupTableInsert:dopart ---
do egte[] -> nameHash.insert;
   (egte[], address) -> adrHash.insert;
   
--- findGroupByAdr:dopart ---
do (address,false) -> GroupName -> adrHash.find -> found[];
   
--- lib:attributes ---
GroupName: external (* in outpattern.c *)
  (# address: @Integer;
     isCode: @Integer;
     groupNameAdr: @Integer;
  enter (address, isCode)
  exit groupNameAdr
  #);

--- segteInxToPt:dopart ---
do ptListAdr + 4*inx -> tos'%adrGetLong' -> ptAdr

--- segtePTtoInx:dopart ---
do
   (if len > 0 //true then
       0 -> low;
       len-1 -> high;
       
       loop:
         (if high//low then
             (if (ptListAdr + 4*low -> tos'%adrGetLong') //ptAdr then
                 low -> inx;
              else
                 -1 -> inx;
             if);
          else
             (low+high) div 2 -> mid;
             (if (ptListAdr + 4*mid -> tos'%adrGetLong') < ptAdr
              //true then
                 mid + 1 -> low;
              else
                 mid -> high;
             if);
             restart loop;
         if);
              
    else
       -1 -> inx;
   if)
   
