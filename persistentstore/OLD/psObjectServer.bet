ORIGIN '~beta/objectserver/objectserver';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
--- lib: attributes ---

getPSObjectServer:
  (* There can be at most one instance of PSobjectServer in a program
   * execution. This pattern returns it if it already exists, and
   * creates a new one if not. *)
  (# os: ^objectServer;
  do PSobjectServer## -> objectPool.strucGet 
     (# init::< (# do obj[] -> os[]; os.init #)
     #) -> os[];     
  exit os[]
  #);

PSObjectServer: objectserver
  (#
     RegetWithoutLazyFetch: 
       (#
          doUnserializeImpl:< unserialize
            (# getSerialization::<
                 (# 
                 do (if lastlocation[] //NONE then
                        (OID.a, fromOID.a) -> setLocation;
                     else
                        (if OID.a //lastLocation.creationTime then else
                            (OID.a, fromOID.a) -> setLocation;
                        if);
                    if);

                    OID -> lastLocation.locationObjects.findSer
                      -> (rep[], proto, group);
                    INNER;
                 #);
               allowDanglingRefs::<(# do false->value #);
               doGetObject::< 
                 (# 
                 do 
                    true -> value;
                    INNER;
                 #);
               getSerFailed::<
                 (# txt: ^Text;
                 do 'Fatal Error:objectserver.getClosure:getSerFailed on OID ('
                      -> txt[];
                    OID.a -> txt.putInt; ',' -> txt.append;
                    OID.b -> txt.putInt; ')\n' -> txt.append;
                    txt[] -> msg.prepend;
                    INNER;
                 #);
               unknownProtoType::<
                 (# 
                 do 'Fatal Error: objectserver.getClosure: Prototype not found'
                      -> msg.prepend;
                    INNER;
                 #);
            do INNER
            #);
          doIt: @doUnserializeImpl;
       
       do INNER;
          true -> checkDanglers;
          (objects[],danglers[],ptOffsets[]) -> doIt;
          false -> checkDanglers;
          danglers.setupNew;
       #);
     
     regetSingleObjectWithWholeClosure:regetWithoutLazyFetch
       (#     
          doUnserializeImpl::
            (# do (OID,offset,fromOID,none)->foreachroot->theObject[];
            #);
          OID:@OIDtype;
          offset: @Integer;
          fromOID: @OIDtype;
          theObject: ^Object
       enter (OID,offset,fromOID)
       exit theObject[]
       #);
     
     
     regetObjectsWithWholeClosure:regetWithoutLazyFetch
       (#     
          doUnserializeImpl::
            (# do 
               objects.oh.scan 
               (# do 
                  (if current.OID.a // lastlocation.creationtime
                      then
                      (current.OID,0,current.OID, NONE)->forEachRoot
                      
                  if);    
               #);
            #);
          OID:@OIDtype;
          theObject:^Object;
       enter OID
       exit theObject[]
       #);
     
     
     RegetWithLazyFetch:
       (#
          doUnserializeImpl:< unserialize
            (# getSerialization::<
                 (# 
                 do (if lastlocation[] //NONE then
                        (OID.a, fromOID.a) -> setLocation;
                     else
                        (if OID.a //lastLocation.creationTime then else
                            (OID.a, fromOID.a) -> setLocation;
                        if);
                    if);
                    OID -> lastLocation.locationObjects.findSer
                      -> (rep[], proto, group);
                    INNER;
                 #);
               allowDanglingRefs::<(# do true->value#);
               doGetObject::< 
                 (# 
                 do 
                    (if found[]=NONE
                     // false then true -> value; (*Object in ObjectTable*)
                     // true then false->value (*Object not in ObjectTable*)
                    if);
                    INNER;
                 #);
               getSerFailed::<
                 (# txt: ^Text;
                 do 'Fatal Error:objectserver.getClosure:getSerFailed on OID ('
                      -> txt[];
                    OID.a -> txt.putInt; ',' -> txt.append;
                    OID.b -> txt.putInt; ')\n' -> txt.append;
                    txt[] -> msg.prepend;
                    INNER;
                 #);
               unknownProtoType::<
                 (# 
                 do 'Fatal Error: objectserver.getClosure: Prototype not found'
                      -> msg.prepend;
                    INNER;
                 #);
            do INNER
            #);
          doIt: @doUnserializeImpl;
       
       do INNER;
          true -> checkDanglers;
          (objects[],danglers[],ptOffsets[]) -> doIt;
          false -> checkDanglers;
          danglers.setupNew;
       #);
     
     regetSingleObjectWithPartialClosure:regetWithLazyFetch
       (#     
          doUnserializeImpl::
            (# do (OID,offset,fromOID,none)->foreachroot->theObject[];
            #);
          OID:@OIDtype;
          offset: @Integer;
          fromOID: @OIDtype;
          theObject: ^Object
       enter (OID,offset,fromOID)
       exit theObject[]
       #);
     
     
     regetObjectsWithPartialClosure:regetWithLazyFetch
       (#     
          doUnserializeImpl::
            (# do 
               objects.oh.scan 
               (# do 
                  (if current.OID.a // lastlocation.creationtime
                      then
                      (current.OID,0,current.OID, NONE)->forEachRoot
                      
                  if);    
               #);
            #);
          OID:@OIDtype;
          theObject:^Object;
       enter OID
       exit theObject[]
       #);
  #);
