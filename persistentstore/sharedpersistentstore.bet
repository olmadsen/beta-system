ORIGIN '~beta/distribution/basicshell';
INCLUDE '~beta/basiclib/private/betaenvbody'
        '~beta/sysutils/pathhandler'
        '~beta/basiclib/binfile'
        '~beta/basiclib/directory'
        'persistentstore'
        'lockmanagerinterface'
        'serverinterface'
        'sharedpsnotifications';
BODY 'private/sharedpersistentstorebody';
(* File sharedpersistentstore.bet
 * ===================
 * 
 * The sharedpersistentstore has the same interface as the persistent 
 * store except from the following:
 * - init has to be called in the beginning with references to the client 
 * and the server as input parameters.
 * - disconnect has to be called in the end, when the shared ps is no 
 * longer needed. If the persistent store is stil open, disconnect closes
 * it.
 * - Virtuals for closure control and for crossreferences have not 
 * been implemented yet.
 * 
 * Before a shared persisstent store creates (and thereby opens)
 * or opens a persistent store, the shared persistent store has to
 * lock the persistent store. This is done by calling server.getlock.
 * If it succeeds in getting the lock, a persistent store can be created
 * or opened. Otherwise the shared persistent store waits a second, checks
 * if some dead client is holding the lock and then makes another attempt-
 * until it succeeds.
 * When the persistent store is closed, the lock is released.
 *)
-- shellEnvLib: Attributes --
shellErrorHandler: errorhandler (#  do INNER #);
SharedPersistentStore:
  (#
     PS: @persistentstore;
     nm: ^notificationmanagement;
     fullname: ^text;
     shortname: ^text;
     lockServer: ^LockmanagerInterface;
     client: ^PSclient;
     notificationServer: ^notificationmanager;
     serverEnsemblename: ^text;
     serverEnsemble: ^ensemble;
     (* ref to server host *)
     notificationserverensemble: ^ensemble;
     writelock: @boolean;
     readlock: @boolean;
     haslock: @boolean;
     committed: @boolean;
     LockErrorhandler: errorhandler
       (#
          successful: @boolean;
          onFailure:
            (# theError: ^error; 
            enter theError[]
            <<SLOT SharedPersistentStoreLockErrorOnFailure:DoPart>>
            #);
          connectionBroken::<
            (# 
            do false->successful; INNER ; THIS(connectionBroken)[]->onFailure
            #);
          connectionFailed::<
            (# 
            do false->successful; INNER ; THIS(connectionFailed)[]->onFailure
            #);
          timeOut::<
            (# 
            do false->successful; INNER ; THIS(timeOut)[]->onFailure
            #);
          timeOutValue::< (#  do INNER #);
          
       do INNER
       #);
     <<SLOT sharedpersistentstoreLib:Attributes>>;
     (* initialization of the shared persistent store *)
     open:
       (#
          name: ^text;
          c: ^PSclient;
          theEnsemble: ^ensemble;
          notFound:< PSexception
            (#  <<SLOT SharedPersistentStoreOpenNotFound:DoPart>> #);
          alreadyOpen:<
           PSexception
            (#  <<SLOT SharedPersistentStoreOpenAlreadyOpen:DoPart>> #)
       enter
       (name[],c[],
        theEnsemble[])
       <<SLOT sharedpersistentstoreOpen:DoPart>>
       #);
     Create:
       (#
          name: ^text;
          alreadyOpen:< PSexception
            (# 
            <<SLOT SharedPersistentStoreCreateAlreadyOpen:DoPart>>
            #);
          exists:< PSexception
          (* The old store is deleted if exists returns. 
           *) (#  <<SLOT SharedPersistentStoreCreateExists:DoPart>> #);
          creationError:<
           PSexception
            (#  <<SLOT SharedPersistentStoreCreationError:DoPart>> #)
       enter name[]
       <<SLOT sharedpersistentstoreCreate:DoPart>>
       #);
     getlock:
       (#
          timeOutValue:< IntegerValue (#  do - 1->value; INNER #);
          LockMode:< IntegerValue (#  do Read->value; INNER #);
          LockPolicy:< IntegerValue (#  do exclusive->value; INNER #)
       <<SLOT sharedpersistentstoreGetlock:DoPart>>
       exit haslock
       #);
     releaselock:
       (# 
       <<SLOT sharedpersistentstoreReleaselock:DoPart>>
       #);
     access:
       (# doreget:< BooleanValue (#  do true->value; INNER #); 
       <<SLOT sharedpersistentstoreAccess:DoPart>>
       #);
     (* only for clients with read-only access *)
     reget:
       (# theObject: ^Object; 
       enter theObject[]
       <<SLOT sharedpersistentstoreReget:DoPart>>
       #);
     commit:
       (#
          doUpdateInMemoryObjects:<
           Booleanvalue (#  do false->value; INNER #);
          doCheckpoint:< BooleanValue (#  do true->value; INNER #);
          
       <<SLOT sharedpersistentstoreCommit:DoPart>>
       #);
     Checkpoint:
       (#
          NoAccessRight:<
           PSexception
            (# 
            <<SLOT SharedPersistentStoreCheckpointNoAccessRight:DoPart>>
            #);
          
       <<SLOT SharedPersistentStoreCheckpoint:DoPart>>
       #);
     (* close may be call just after or replacing a commit *)
     Close:
       (#
          danglersExists:<
            (#
               toDo: @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do ignore->toDo; INNER
            exit toDo
            #);
          doCheckpoint:< BooleanValue (#  do true->value; INNER #);
          
       <<SLOT sharedpersistentstoreClose:DoPart>>
       #);
     Get:
       (#
          quaError:< Exception
            (# 
            <<SLOT SharedPersistentStoreGetQuaError:DoPart>>
            #);
          notFound:< Exception
            (#  <<SLOT SharedPersistentStoreGetNotFound:DoPart>> #);
          name: ^Text;
          type: ##Object;
          theObject: ^object
       enter (name[],type##)
       <<SLOT sharedpersistentstoreGet:DoPart>>
       exit theObject[]
       #);
     Put:
       (#
          dooverwrite:< BooleanValue (#  do false->value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       <<SLOT sharedpersistentstorePut:DoPart>>
       #);
     scanRootNames:
     (* Iterates over the names of the persistent roots in this
      * persistent store.
      *)
       (# current: ^Text; 
       <<SLOT sharedpersistentstoreScanRootNames:DoPart>>
       #);
     deletesharedpersistentstore:
     (* Deletes an existing persistentstore. It is not possible to
      * delete a persistentstore that is open either in this process
      * or in another one.
      * If tried anyway, the "alreadyOpen" exception is
      * raised. In case the process does not have sufficient access
      * priviliges to delete the store, the "accessError" exception is
      * raised.
      *)
       (#
          alreadyOpen:< PSexception
            (#  <<SLOT SharedPersistentStoreDeletePSAlreadyOpen:DoPart>> #);
          accessError:<
           PSexception
            (#  <<SLOT SharedPersistentStoreDeletePSAccessError:DoPart>> #);
          notFound:<
           PSexception
            (#  <<SLOT SharedPersistentStoreDeletePSNotFound:DoPart>> #);
          noConnection:<
           PSexception
            (#  <<SLOT SharedPersistentStoreDeletePSNoConnection:DoPart>> #);
          name: ^Text;
          ok: @boolean;
          fullname: ^text;
          serverensemble: ^ensemble;
          lockserver: ^lockmanagerInterface;
          
       enter (name[],serverensemble[])
       <<SLOT SharedPersistentStoreDelete:DoPart>>
       #);
     
  #);
makeFileNames:
  (# name,fullname: ^Text; dirName: ^Text; ph: @PathHandler; 
  enter name[]
  <<SLOT SharedPersistentStoreMakeFileNames:DoPart>>
  exit (dirName[])
  #);
getfullname:
  (#
     name,fullname: ^Text;
     dirname: ^text;
     ph: @PathHandler;
     
  enter name[]
  <<SLOT SharedPersistentStoreGetfullname:DoPart>>
  exit dirname[]
  #);
  

