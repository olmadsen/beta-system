ORIGIN '~beta/basiclib/betaenv';
-- lib: Attributes --
dictionary:
  (#
     contentsType:< Object;
     contentsBox: (# contents: ^contentsType; word: ^Text #);
     node: (# c: @char; contents: ^contentsBox; down,right: ^node;  #);
     root: @node;
     entries: @integer;
     insert:
       (#
          word: ^text;
          contents: ^contentsType;
          insertFunc:<
            (# current: ^contentsType
            enter current[]
            do INNER insertFunc
            #);
          insertNode:
            (#
               word: ^Text;
               current: ^Node;
               insertDown:
                 (# 
                 do
                    (if current.down[] = none then
                        &node[]->current.down[]
                    if);
                    (word[],current.down[])->insertNode
                 #);
               insertRight:
                 (# 
                 do
                    (if current.right[] = none then
                        &node[]->current.right[]
                    if);
                    (word[],current.right[])->insertNode
                 #)
            enter (word[],current[])
            do
               (if word.getPos < word.length-1 then
                   (if current.c = 0 then
                       word.get->current.c; insertDown
                    else
                       (if word.peek = current.c then
                           word.get; insertDown
                        else
                           (if word.peek < current.c then
                                 (# new: ^node
                                 do
                                    &node[]->new[];
                                    current.right[]->new.right[];
                                    current.down[]->new.down[];
                                    current.c->new.c;
                                    current.contents[]->new.contents[];
                                    word.peek->current.c;
                                    new[]->current.right[];
                                    none ->current.down[];
                                    none ->current.contents[];
                                    word.get;
                                    insertDown;
                                    
                                 #)
                            else
                               insertRight
                           if)
                       if)
                   if)
                else
                   (if current.c = 0 then
                       1+entries->entries;
                       word.get->current.c;
                       &contentsBox[]->current.contents[];
                       contents[]->current.contents.contents[];
                       word[]->current.contents.word[]
                    else
                       (if word.peek = current.c then
                           (if current.contents[] = none then
                               1+entries->entries;
                               &contentsBox[]->current.contents[];
                               contents[]->current.contents.contents[];
                               word[]->current.contents.word[]
                            else
                               contents[]->current.contents.contents[]
                           if)
                        else
                           insertRight
                       if)
                   if)
               if)
            #);
          
       enter (word[],contents[])
       do
          (if word.length > 0 then
              0->word.setpos;
              (word[],root[])->insertNode;
              contents[]->insertFunc
          if)
       #);
     member:
       (#
          word: ^text;
          result: ^contentsType;
          lastNode:< (# foundAt: ^node enter foundAt[] do INNER #);
          memberNode:
            (#
               word: ^text;
               current: ^node;
               downMember:
                 (# 
                 do
                    (if current.down[] <> none then
                        (word[],current.down[])->memberNode
                    if)
                 #);
               rightMember:
                 (# 
                 do
                    (if current.right[] <> none then
                        (word[],current.right[])->memberNode
                    if)
                 #)
            enter (word[],current[])
            do
               (if word.getPos < word.length-1 then
                   (if word.peek = current.c then
                       word.get; downMember
                    else
                       rightMember
                   if)
                else
                   (if word.peek = current.c then
                       (if current.contents[] <> none then
                           current.contents.contents[]->result[]
                       if);
                       current[]->lastNode;
                       
                    else
                       rightMember
                   if)
               if)
            #);
          
       enter word[]
       do
          (if word.length > 0 then
              0->word.setpos; (word[],root[])->memberNode
          if)
       exit result[]
       #);
     visit:
       (#
          maxVisit: integerObject (#  do 100->value; INNER #);
          visitCount: @integer;
          visitFunc:<
            (# current: ^contentsBox
            enter current[]
            do INNER visitFunc
            #);
          visitNode:
            (#
               current: ^node;
               downVisit:
                 (# 
                 do
                    (if current.down[] <> none then
                        current.down[]->visitNode; 
                    if)
                 #);
               rightVisit:
                 (# 
                 do
                    (if current.right[] <> none then
                        current.right[]->visitNode; 
                    if)
                 #)
            enter current[]
            do
               (if current.contents[] <> none then
                   visitCount+1->visitCount; current.contents[]->visitFunc
               if);
               downVisit;
               rightVisit
            #);
          start: ^Node
       do
          root[]->start[];
          INNER ;
          (if start[] <> none then start[]->visitNode if)
       #);
     visitFrom: visit
       (# prefix: ^Text
       enter prefix[]
       do
          none ->start[];  (* Otherwise finds all words instead of none for
                            * prefixes that don't happen
                            *)
          prefix[]
            ->member
              (#
                 lastNode:: 
                   (# 
                   do
                      (if foundAt.contents[] <> none then
                          visitCount+1->visitCount;
                          foundAt.contents[]->visitFunc
                      if);
                      foundAt.down[]->start[];
                      
                   #)
              #)
       #)
  #);
  

