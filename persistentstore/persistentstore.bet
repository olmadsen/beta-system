ORIGIN '~beta/basiclib/v1.6/betaenv';
(* 
 * $RCSfile: persistentstore.bet,v $ $Revision: 1.9 $ $Date: 1997-06-02 13:31:28 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
BODY 'private/persistentstoreBody';

---- lib: attributes ----

persistentstore:
  (# <<SLOT persistentstoreLib: attributes>>;
          
     openRead:
       (* Opens THIS(persistentstore) for reading, i.e. it is not
        * allowed to write objects to the store.  Checkpoint
        * operations will be ignored.
        * 
        * The name parameter is the name of the directory containing
        * the store and is interpreted as a path relative to the
        * current directory of the process.
        *)
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.openRead: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          notFound:< PSexception 
            (# 
            do 'persistentstore.openRead: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" not found' -> msg.putText; 
               INNER
            #);
          accessError:< PSexception
            (# 
            do 'persistentstore.openRead: No access to "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" ' -> msg.putText; 
               INNER 
            #);
          name: ^Text;
       enter name[]
       do <<SLOT PersistentOpenRead: descriptor>>;
       #);
    
     openWrite:
       (* Opens THIS(persistentstore) for writing, i.e. it is allowed
        * to update the objects saved in the store.
        * 
        * The name parameter is the name of the directory containing
        * the store and is interpreted as a path relative to the
        * current directory of the process.
        *)
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.openWrite: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          notFound:< PSexception 
            (# 
            do 'persistentstore.openWrite: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" not found' -> msg.putText; 
               INNER
            #);
          accessError:< PSexception
            (# 
            do 'persistentstore.openWrite: No access to"' 
                 -> msg.putText;  fullName[] -> msg.putText; 
               '"' -> msg.putText;
               INNER
            #);
          name: ^Text;
       enter name[]
       do <<SLOT PersistentOpenWrite: descriptor>>;
       #);
     
     create:
       (* Creates a new persistentstore. The name entered is
        * interpreted as a path relative to the current directory of
        * the process. The new store is opened with write permission.
        *)
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.create: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          exists:< PSexception 
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already exists' -> msg.putText; 
               INNER
            #);
          creationError:< PSexception
            (# 
            do 'persistentstore.create: Failed creating "'
                 -> msg.putText; fullName[] -> msg.putText; 
               '"' -> msg.putText;
               INNER
            #);
          name: ^Text;
       enter name[]
       do <<SLOT PersistentCreate: descriptor>>
       #);
     
     checkpoint:
       (* Saves the state of all objects in the transitive closure of
        * objects made persistent roots or fetched from this
        * persistentStore since open.  Checkpoint has no effect if the
        * store was opened by openRead.
        *)
       (# <<SLOT PersistentCheckpoint:dopart>> #);
     
     close:
       (* Performs a checkpoint, unless the doCheckpoint virtual
        * returns false, and then closes
        * THIS(persistentStore). Objects fetched from
        * THIS(persistentStore) will now turn into copies of the
        * objects saved in the store. This means that the fact that
        * the objects originally came from this store, is forgotten.
        * 
        * If allowLazyFetch is TRUE, dangling references may exist to
        * objects not yet fetched from this persistentstore. If this
        * is the case, the danglersExists virtual is called. Default
        * action is to kill the process, but other possibilities are
        * to either fetch the missing objects before closing, or
        * simply ignore the warning and close the store anyway. In the
        * latter case, usage of the objects mfetched could be fatal
        * when trying to access an object that was newer fetched from
        * the store. Ignoring should thus only be done if you are not
        * going to access the object (copies) fetched during the
        * "transaction" about to end.
        *)
       (# danglersExists:< 
            (# toDo: @Integer;
               kill:   (# exit 0 #); 
               (* Kill the process. Default action. *)
               fetch:  (# exit 1 #); 
               (* Fetch the missing objects.        *)
               ignore: (# exit 2 #); 
               (* Ignore the dangling references.   *)
            do kill -> toDo; INNER
            exit toDo
            #);
          doCheckpoint:< BooleanValue 
            (# do true -> value; INNER #);
       do <<SLOT PersistentClose: descriptor>>
       #);
     
     get:
       (* Reads the persistent root named "name" into memory and
        * returns a reference. If the object is already in memory, a
        * reference to the in-memory object is returned. In that case,
        * the state of the object is left untouched.
        *)
       (# quaError:< Exception
            (# 
            do 'persistentstore.get: Qua error getting "' 
                 -> msg.putText; name[] -> msg.putText;
               '"' -> msg.putText;
               INNER 
            #);
          notFound:< Exception
            (# 
            do 'persistentstore.get: "' -> msg.putText; 
               name[] -> msg.putText;
               '" not found' -> msg.putText;
               INNER
            #);
          allowLazyFetch:< BooleanValue
            (# 
            do THIS(persistentstore).allowLazyFetch 
                 -> value;
               INNER
            #);
          name: ^Text; type: ##Object;
          theObject: ^Object;
       enter (name[],type##)
       do <<SLOT PersistentGet: descriptor>>;
       exit theObject[]
       #);
    
     put:
       (* Turns obj into a persistent root with textual name
        * "name". The state of obj is not saved until a checkpoint
        * operation is performed.
        *)
       (# obj: ^Object; name: ^text;
       enter (obj[],name[])
       do <<SLOT PersistentPut: descriptor>>
       #);
     
     scanRootNames:
       (* Iterates over the names of the persistent roots in this
        * persistent store.
        *)
       (# current: ^Text;
       do <<SLOT scanRootNamesBody:descriptor>>
       #);
     
     
     (* CLOSURE CONTROL
      * ===============
      * 
      * These attributes are used to limit the part of the
      * object graph saved during the checkpoint operation.
      * On the interface level of a persistentstore, there
      * is currently two ways of limiting the object graph:
      * 
      * 1. Special objects.
      * 
      *    Special objects are objects whose state is 
      *    NEVER saved persistently. However, references 
      *    to these objects should be saved so that they 
      *    may be setup correctly when saved objects 
      *    referencing special objects are reinstantiated 
      *    in another process. Typical examples or special
      *    objects are application framework objects that 
      *    are known to be present in the program 
      *    executions exchanging persistent objects, but 
      *    should not be saved themselves. Examples of 
      *    application framework objects are instances of 
      *    UIenv, systemEnv and shellEnv. (betaEnv is 
      *    always treated as a special object.)
      * 
      *    Special objects are registered once in the 
      *    lifetime of a persistent store by supplying 
      *    name and type of the object to the 
      *    "registerSpecialObject" method. The type is 
      *    saved in this persistentstore to be used for 
      *    type checking when registering special object 
      *    instances as described below. 
      * 
      *    In addition to the initial registration, an 
      *    instance of the special object must be supplied
      *    by each process using the persistent store by 
      *    calling the "registerSpecialInstance" method 
      *    when the persistentstore has been opened, but 
      *    before any get operations are made. The instance
      *    given to the registerSpecialInstance method must
      *    be a subtype of the type given to the 
      *    registerSpecialObject operation.
      * 
      * 2. Runtime types.
      * 
      *    Runtime types types of objects that are used at
      *    runtime, but should not persist across program
      *    executions. An example of this is user interface
      *    objects such as windows. Registering a 
      *    runtimeType means that instances of subtypes 
      *    are not saved, and the corresponding references
      *    saved as NONE references. As runtime types 
      *    registered using registerRuntimeType are not 
      *    saved persistently in the store, 
      *    'registerRuntimeType' must be called for each 
      *    runtime type in each session. It is of course
      *    possible to save a table of runtime types in a 
      *    persistent store if needed.
      * 
      * It is a selfcontradiction to register the type of 
      * a special object as a runtime type or vice versa. 
      * Doing so results in a runtime error.
      * 
      * Furthermore it is necessary to ensure that 
      * instances of runtime types are not origins of 
      * other objects saved. This is because it is not
      * possible to save an object without the knowledge 
      * that all its origins will be available when the 
      * object is to be reinstantiated.
      * 
      * Although it probably makes no sense, different 
      * instances of persistentstore may have different 
      * sets of specialObjects and runtimeTypes registered.
      *)
     
     registerSpecialObject:
       (* Special objects are registered once in the lifetime of a
        * persistent store by supplying name and type of the object to
        * this method. The type is saved in this persistentstore to be
        * used for type checking when registering special object
        * instances as described above.
        *)
        (# alreadyThere:< Exception
            (# 
            do 'registerSpecialObject: Special object "' 
                 -> msg.putText; name[] -> msg.putText; 
               '" already exists: ' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          name: ^Text; type: ##Object;
       enter (name[],type##)
       do <<SLOT registerSpecialObject:descriptor>>
       #);
     
     registerSpecialInstance:
       (* In addition to the initial registration, an instance of the
        * special object must be supplied by each process using the
        * persistent store by calling this method when the
        * persistentstore has been opened, but before any 'get'
        * operations are made. The instance given to this method must
        * be a subtype of the type given to the 'registerSpecialObject'
        * operation.
        *)
       (# quaError:< Exception
            (#
            do 'registerSpecialInstance: Qua error on "'
                 -> msg.putText; name[] -> msg.putText;
               '" instance' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          notFound:< Exception
            (# 
            do 'registerSpecialInstance: Special object "'
                 -> msg.putText; name[] -> msg.putText;
               '" not registered.' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          o: ^Object; name: ^Text;
       enter (o[],name[])
       do <<SLOT registerSpecialInstance:descriptor>>
       #);
    
     registerRuntimeType:
       (* Runtime types types of objects that are used at runtime,
        * but should not persist across program
        * executions. Registering a runtimeType means that instances
        * of subtypes are not saved, and the corresponding references
        * saved as NONE references. As runtime types registered using
        * registerRuntimeType are not saved persistently in the store,
        * 'registerRuntimeType' must be called for each runtime type
        * in each session.
        *)
       (# type: ##Object
       enter type##
       do <<SLOT runtimeObjectsRegister:descriptor>>
       #);
     
     
     (* LAZY OPTIONS
      * ============
      * 
      * Attributes in this section are concerned with the 
      * lazy fetch of persistent objects. If used, object 
      * fetch from secondary storage may be delayed until 
      * the objects are actually needed. By using a trap
      * mechanism, fetching takes place transparently 
      * without applications being aware of it. *)
    
     allowLazyFetch:<
       (* If not further specified, all objects in the transitive
        * closure of an object requested in a get operation are always
        * fetched at once. This default may be changed by
        * furtherbinding "allowLazyFetch" and setting "value" to
        * "true".  Default may be overridden "per get" by using the
        * allowLazyFetch virtual of get.
        *)
       BooleanValue;
     
     maxCountOnDanglerHit:< IntegerValue
       (* When a reference to an object not yet fetched from
        * secondary storage is encountered, some number of objects
        * reachable from the object referred are fetched too. The
        * objects fetched are the 'value' first unfetched objects
        * encountered during a breadth-first traversal of the object
        * graph, using the object referred by the original dangling
        * reference as a root.
        * 
        * Object fetch continues until:
        * 
        *    1: No more unfetched objects are reachable from the root
        *       object.  or 2: maxCountOnDanglerHit objects have been
        *       fetched.
        *)
       (# do 100 -> value; INNER #);
     
     OnDanglerHit:<
       (* OnDanglerHit is called when a dangling reference is hit.
        *)
       Object;
     AfterDanglerHit:< 
       (* When the object referred has been fetched, AfterDanglerHit
        * is called with the newly fetched object as parameter.
        *)
       (# theObject: ^Object;
       enter theObject[]
       do INNER
       #);
    
     openpstore:<
       (* If this persistentstore contains references to objects in
        * other persistent stores, it may be necessary to open the
        * stores to be able to follow these references. When this
        * happens, the openpstore virtual is called. If the persistent
        * store named is not opened and returned in ps, the program
        * will terminate.
        *)
       (# psname: ^Text;
          ps: ^persistentstore;
       enter psname[]
       do INNER
       exit ps[]
       #);
     
     pspriv: @<<SLOT psprivate: descriptor>>;
     
  do INNER;
  #);

deletePersistentStore: 
  (* Deletes an existing persistentstore. It is not possible to
   * delete a persistentstore that is open in this program
   * execution. If tried anyway, the "alreadyOpen" exception is
   * raised. In case the process does not have sufficient access
   * priviliges to delete the store, the "accessError" exception is
   * raised.
   *)
  (# alreadyOpen:< PSexception
       (# 
       do 'persistentstore.delete: "' -> msg.putText;
          fullName[] -> msg.putText;
          '" is currently open' -> msg.putText;
          INNER;
       #);
     accessError:< PSexception
       (# 
       do 'persistetstore.delete: Unable to delete "' -> msg.putText; 
          fullName[] -> msg.putText; '"' -> msg.putText;
          INNER;
       #);
     notFound:< PSexception
       (# 
       do 'persistetstore.delete: "' -> msg.putText; 
          fullName[] -> msg.putText; '" not found' -> msg.putText;
          INNER;
       #);
     name: ^Text;
  enter name[]
  do <<SLOT PersistentDelete: descriptor>>
  #);



PSexception: exception
  (* PSexception is used in several exceptional situations where the
   * files making up an persistent store are not accessable. The
   * fullName parameter is the full path of the directory expected to
   * be a persistent store.
   *)
  (# fullName: ^Text;
  enter fullName[]
  do INNER
  #)
