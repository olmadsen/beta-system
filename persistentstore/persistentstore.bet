ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface';

-- lib: Attributes --

persistentstore:
  (#
     host, path: ^text;
     
     numberOfUpdates: 
       (# 
          result: @integer
       do assertOpen(# notOpen :: (# do true -> continue #);
                    do (host,path) -> getNumberOfUpdates -> result
                    #)
       exit result
       #);
     lastupdate: @integer;
     
     hostName: (#  exit 'localhost' #);
     rebinderItem: ^rebindSpecialReference;
     openCrossStoreItem: ^openpstore;
     
     assertOpen:
       (# notOpen:< PSException
            (# 
            do 'persistentstore.assertOpen: Store is not open'
                 -> msg.putText;
               false -> continue;
               INNER;
            #);
       do 
          (if host[] <> none then
              (if path[] <> none then
                  INNER;
               else
                  notOpen;
              if);
           else
              notOpen;
          if);
       #);
     
     assertInit:
       (# notInitialized:< PSException
            (# 
            do 'persistentstore.assertInitialized: Store is not initialized'
                 -> msg.putText;
               false -> continue;
               INNER;
            #);
       do 
          (if rebinderItem[] <> none then
              (if openCrossStoreItem[] <> none then
                  INNER;
               else
                  notInitialized;
              if);
           else
              notInitialized;
          if);
       #);
     
     markSpecialObject: external (* defined in P/misc.c *)
       (# tag,theObj: @integer enter (tag,theObj) #);
     putExt: external (* defined in P/PStoreServer.c *)
       (#
          dooverwrite: @boolean;
          host,path,name: [1] @Char;
          obj,rcode: @integer
       enter (dooverwrite,host,path,name,obj)
       exit rcode
       #);
     setForceAOAGC: external (* defined in ioa.c *) 
       (#  #);
     forceObjectToAOA: external (* defined in P/misc.c *)
       (# theObj: @integer;  enter theObj #);
     getNumberOfUpdates: external (* defined in P/PStore.c *)
       (# host,path: [1] @Char; numUpdates:@integer
       enter (host,path)
       exit numUpdates
       #);
     openReadExt: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     openWriteExt: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     createExt: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     closeExt: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       #);
     getExt: external (* defined in P/PStoreServer.c *)
       (# host,path,name: [1] @Char; theObj: @integer
       enter (host,path,name)
       exit theObj
       #);
     
     ACCESSERRORERROR: (#  exit 1 #);
     NOTFOUNDERROR: (#  exit 2 #);
     ALREADYOPENERROR: (#  exit 3 #);
     EXISTSERROR: (#  exit 4 #);
     CREATIONERRORERROR: (#  exit 5 #);
     
     registerRebinderFunc: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callRebinder enter rebinderFunc## #);
     
     registerOpenCrossStoreFunc: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callOpenCrossStore enter rebinderFunc## #);
     
     registerBETAENVandPROGRAM: external
       (# theProgram:@integer
       enter theProgram
       #);
     
     
     init:
       (# 
       do callRebinder## -> registerRebinderFunc;
          &rebindSpecialReference[] -> rebinderItem[];
          callOpenCrossStore## -> registerOpenCrossStoreFunc;
          &openpstore[] -> openCrossStoreItem[];
          (%getLongAt (@@ theProgram))-> registerBETAENVandPROGRAM;
          INNER
       #);
     
     callRebinder: external
       (# objectTag,typeTag: @integer; target: ^Object; targetAbs: @integer
       enter (objectTag,typeTag)
       do
          CExternalentry;
          (objectTag,typeTag)->rebinderItem->target[];
          (%getLongAt (@@ target))->targetAbs
       exit targetAbs
       #);
     
     callOpenCrossStore: external
       (# host, path: [1] @Char; newps: ^persistentstore;
          hostText, pathText: ^text;
          
       enter (host, path)
       do
          CExternalentry;
          &text[]-> hostText[];
          &text[]-> pathText[];
          
          host -> hostText;
          path -> pathText;
          pathText[] -> openCrossStoreItem -> newps[];
          (* newps is not currently used by the system *)
       #);
     
     UNKNOWNTAG: (#  exit 0 #);
     rebindSpecialReference:<
       (#
          target: ^Object;
          toSpecialObject:<
            (#
               objectTag: @integer;
               NotHandled:< PSException
                 (# 
                 do
                    'persistentstore.rebindSpecialReference: tag "'
                      ->msg.putText;
                    objectTag->msg.putInt;
                    '" has not been rebound (returning NULL)'->msg.putText;
                    msg[]->putline;
                    true->continue;
                    INNER
                 #)
            enter objectTag
            do INNER
            #);
          toSpecialType:<
            (# typeTag: @integer enter typeTag do INNER #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       do
          (if objectTag <> UNKNOWNTAG then
              objectTag->toSpecialObject
           else
              (if typeTag <> UNKNOWNTAG then typeTag->toSpecialType if)
          if);
          (* At this point it is assumed that 'target' now contains the 
           * reference to the object this special reference is 
           * to be rebound to *)
          (if target[] = none then
              PSexception
              (# 
              do
	         'handleSpecialReference: User code failed to rebind' 
                   -> msg.putLine;
	         'reference to special object tagged '
                   -> msg.putText;
                 objectTag -> msg.putInt;
                 '.' -> msg.putLine;
                 'Make sure the \'rebindSpecialReference\' virtual'           
                   -> msg.putLine;
	         'has been implemented correctly.'
                   -> msg.putLine;
                 false -> continue;
              #)
          if);
       exit target[]
       #);
     commit: assertInit
       (#
          doUpdateInMemoryObjects:< BooleanValue
            (#  do false->value; INNER #);
          doCheckpoint:< BooleanValue (#  do true->value; INNER #);
          
       do INNER
       #);
     reget: assertInit
       (#
          NotFound:< PSException
            (# 
            do
               'persistentstore.reget: Root "'->msg.putText;
               fullname[]->msg.putText;
               '" has been overwritten by another client.'->msg.putText;
               'Your references are not longer valid.'->msg.puttext;
               msg[]->putline;
               true->continue;
               INNER
            #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     
     open: assertInit
       (#
          alreadyOpenMessage:< (# msg: ^text do inner exit msg[] #);
          notFoundMessage:< (# msg: ^text do inner exit msg[] #);
          accessErrorMessage:< (# msg: ^text do inner exit msg[] #);
          
          alreadyOpen:< PSexception
            (# 
            do
               alreadyOpenMessage->msg.putText;
               fullName[]->msg.putText;
               '" already open'->msg.putText;
               true -> continue;
               INNER
            #);
          notFound:< PSexception
            (# 
            do
               notFoundMessage->msg.putText;
               fullName[]->msg.putText;
               '" not found'->msg.putText;
               INNER
            #);
          accessError:< PSexception
            (# 
            do
               accessErrorMessage ->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               INNER
            #);
          name: ^Text;
          openFunc:<
            (# host,path: [1] @Char; rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
          
       enter name[]
       do          
          (if path[] = none then
              (if (hostName,name)->openFunc
               // (NOTFOUNDERROR) then
                  name[]->notFound
               // (ACCESSERRORERROR) then
                  name[]->accessError
               else
                  name[]->path[]; hostName->host[]; 
                  INNER
              if)
           else
              name[]->alreadyOpen; 
          if);
       #);
     
     openRead: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openRead: "' -> msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openRead: "'->msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openRead: No access to "'->msg[]; #);
          openFunc :: (# do (host, path) -> openReadExt -> rcode #);
       do INNER
       #);
     
     openWrite: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openWrite: "' -> msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openWrite: "' ->msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openWrite: No access to"'->msg[]; #);
          openFunc :: (# do (host, path) -> openWriteExt -> rcode #);
       do INNER
       #);
     
     create: assertInit
       (#
          alreadyOpen:< PSexception
            (# 
            do
               'persistentstore.create: "'->msg.putText;
               fullName[]->msg.putText;
               '" already open'->msg.putText;
               INNER
            #);
          exists:< PSexception
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do
               'persistentstore.create: "'->msg.putText;
               fullName[]->msg.putText;
               '" already exists'->msg.putText;
               INNER
            #);
          creationError:< PSexception
            (# 
            do
               'persistentstore.create: Failed creating "'->msg.putText;
               fullName[]->msg.putText;
               '"'->msg.putText;
               INNER
            #);
          name: ^Text;
          
       enter name[]
       do
          (if path[] = none then
              (if (hostName,name)->createExt
               // (EXISTSERROR) then
                  name[]->exists; 
               // (CREATIONERRORERROR) then
                  name[]->creationError
               else
                  hostName->host[]; name[]->path[]; 
              if)
           else
              name[]->alreadyOpen; 
          if);
          INNER
       #);
     
     checkpoint: assertInit (#  do setForceAOAGC; doGC;  #);
     
     close: assertInit
       (#
          danglersExists:<
            (#
               toDo: @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill->toDo; INNER
            exit toDo
            #);
          doCheckpoint:< BooleanValue (#  do false->value; INNER #);
          
       do
          INNER;
          checkpoint;
          (host, path) -> closeExt;
          none ->path[];
          none ->host[];
          
       #);
     
     get: assertInit
       (#
          quaError:< Exception
            (# 
            do
               'persistentstore.get: Qua error getting "'->msg.putText;
               name[]->msg.putText;
               '"'->msg.putText;
               INNER
            #);
          notFound:< Exception
            (# 
            do
               'persistentstore.get: "'->msg.putText;
               name[]->msg.putText;
               '" not found'->msg.putText;
               INNER
            #);
          allowLazyFetch:< BooleanValue
            (#  do THIS(persistentstore).allowLazyFetch->value; INNER #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type##)
       do
          (@@ theObject,((host,path,name)->getExt))->assignRef;
          (if theObject[] = none then notFound if);
          INNER
       exit theObject[]
       #);
     ALREADYTHEREERROR: (#  exit 6 #);
     HASOVERWRITTENERROR: (#  exit 7 #);
     put: assertInit
       (#
          AlreadyThere:< PSexception
            (# 
            do
               'persistentstore.put: Root "'->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               'already there.'->msg.puttext;
               true->continue;
               INNER
            #);
          HasOverWritten:< PSexception
            (# 
            do
               'persistentstore.put: Root "'->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               'will overwrite an already existing root with same name at checkpoint time.'
                 ->msg.puttext;
               true->continue;
               INNER
            #);
          dooverwrite:< BooleanValue (#  do true->value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       do
          (%getLongAt (@@ obj))->forceObjectToAOA;
          doGC;
          (if ((dooverwrite,host,path,name,(%getLongAt (@@ obj)))->putExt)
           // (ALREADYTHEREERROR) then
              AlreadyThere; (if dooverwrite then HasOverWritten if)
          if);
          INNER
       #);
     scanRootNames: assertInit (# current: ^Text;  do INNER #);
     registerSpecialObject: assertInit
       (#
          alreadyThere:< Exception
            (# 
            do
               'registerSpecialObject: Special object "'->msg.putText;
               name[]->msg.putText;
               '" already exists: '->msg.putText;
               INNER ;
               false->continue;
               
            #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type##)
       do 'registerSpecialObject: Registering of special objects and instances'-> screen.putLine;
          'is implemented differently in the new persistence implementation.'-> screen.putLine;
          'This call has no effect, and should be removed.' -> screen.putLine;
          INNER
       #);
     registerRuntimeType: assertInit
       (# type: ##Object enter type## 
       do 
          'registerRuntimeType: This function is not implemented in the new'
            -> screen.putLine;
          'persistent store, and the call should be removed.' -> screen.putLine;
          
       #);
     allowLazyFetch:< BooleanValue;
     maxCountOnDanglerHit:< IntegerValue (#  do 100->value; INNER #);
     OnDanglerHit:< Object;
     AfterDanglerHit:<
       (# theObject: ^Object;  enter theObject[] do INNER #);
     openpstore:<
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     deletePersistentStore: assertInit
       (#
          alreadyOpen:< PSexception
            (# 
            do
               'persistentstore.delete: "'->msg.putText;
               fullName[]->msg.putText;
               '" is currently open'->msg.putText;
               INNER ;
               
            #);
          accessError:< PSexception
            (# 
            do
               'persistetstore.delete: Unable to delete "'->msg.putText;
               fullName[]->msg.putText;
               '"'->msg.putText;
               INNER ;
               
            #);
          notFound:< PSexception
            (# 
            do
               'persistetstore.delete: "'->msg.putText;
               fullName[]->msg.putText;
               '" not found'->msg.putText;
               INNER ;
               
            #);
          name: ^Text;
          storeDir: @directory; 
          
       enter name[]
       do 
          assertOpen
          (# do 
             path[] -> storeDir.name;
             storeDir.delete
             (# 
                nosuch:: (# do PSexception
                            (# do 
                               'delete error: ' -> msg.putText;
                               path[] -> msg.putText;
                               ' does not exist' -> msg.putText;
                               true -> continue;
                            #);
                         #);
                
                error:: (# do PSexception
                           (# do
                              'delete error: ' -> msg.putText;
                              path[] -> msg.putText;
                              ' could not be deleted (unknown error)' -> msg.putText;
                              true -> continue;
                           #);
                        #);
             #);
          #);
       #);
     registerSpecialInstance: assertInit
       (#
          quaError:< Exception
            (# 
            do
               'registerSpecialInstance: Qua error on "'->msg.putText;
               tag->msg.putInt;
               '" instance'->msg.putText;
               INNER ;
               false->continue;
               
            #);
          notFound:< Exception
            (# 
            do
               'registerSpecialInstance: Special object "'->msg.putText;
               tag->msg.putInt;
               '" not registered.'->msg.putText;
               INNER ;
               false->continue;
               
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
       enter (o[],tag)
       do (if tag < 256 then
              (tag,%getLongAt (@@ o))->markSpecialObject;
           else
              PSexception
              (# do 
                 'registerSpecialInstance: ' -> msg.putText;
                 ' tag (' -> msg.putText;
                 tag -> msg.putInt;
                 ') must be less than 256' -> msg.putText;
                 false -> continue;
              #);
          if);
       #);
  do INNER ; 
  #);
deletePersistentStore:
  (#
     alreadyOpen:< PSexception(# do INNER #);
     accessError:< PSexception(# do INNER #);
     notFound:< PSexception(# do INNER #);
     name: ^Text;
     
  enter name[]
  do PSexception
     (# do 
        'delete error: deletePersistentStore has been moved' ->msg.putLine;
        'to reside within the persistentstore pattern.' ->msg.putLine;
        'See the gcdemo demo for further details.' -> msg.putLine;
        false -> continue;
     #);
  #);

PSexception: exception (# fullName: ^Text;  enter fullName[] do INNER #)  

