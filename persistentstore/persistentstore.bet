ORIGIN '~beta/basiclib/betaenv' (* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
;
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface'
        '~beta/containers/list';
BODY 'private/psbody';
-- lib: Attributes --
(* PSEXCEPTION
 * ===========
 * 
 * PSexception is used in several exceptional situations where the files
 * making up an persistent store are not accessable. The fullName parameter
 * is the full path of the directory expected to be a persistent store. *)
PSexception: exception (# fullName: ^Text;  enter fullName[] do INNER #);

PSroot:
  (# name: ^text; type: ##object; obj: ^Object
  enter (name[],type##,obj[])
  #);
PSrootsList: list (# element:: PSroot #);

(* PERSISTENTSTORE
 * ===============
 *)
persistentstore:
  (#
     <<SLOT PSlib:Attributes>>;
     PSroots: ^PSrootsList;
     PSstoreID: @integer;
     assertOpen:
       (#
          notOpen:< PSException
            (# 
            <<SLOT PSassertOpennotOpen:DoPart>>
            #);
          
       <<SLOT PSassertOpen:DoPart>>
       #);
     assertInit:
       (#
          notInitialized:< PSException
            (#  <<SLOT PSassertInitnotInitialized:DoPart>> #);
          
       <<SLOT PSassertInit:DoPart>>
       #);
     numberOfUpdates:
       (# result: @integer <<SLOT PSNumberOfUpdates:DoPart>> exit result #);
     lastupdate: @integer;
     hostName: (#  exit 'localhost' #);
     openCrossStoreItem: ^openpstore;
     UNKNOWNTAG: (#  exit 0 #);
     rebinderItem: ^rebindSpecialReference;
     rebindSpecialReference:<
       (#
          target: ^Object;
          toSpecialObject:<
            (#
               objectTag: @integer;
               NotHandled:< PSException
                 (#  <<SLOT PSRebindSpecRefNotHandled:DoPart>> #)
            enter objectTag
            do INNER
            #);
          toSpecialType:<
            (# typeTag: @integer
            enter typeTag
            do INNER
            #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       <<SLOT PSRebindSpecialReference:DoPart>>
       exit target[]
       #);
     commit: assertInit
       (#
          doUpdateInMemoryObjects:< BooleanValue
            (#  do false->value; INNER #);
          doCheckpoint:< BooleanValue (#  do true->value; INNER #);
          
       do INNER
       #);
     reget: assertInit
       (#
          NotFound:< PSException (#  <<SLOT PSregetNotFound:DoPart>> #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     init: (#  <<SLOT PStoreInit:DoPart>> #);
     create: assertInit
       (#
          alreadyOpen:< PSexception
            (#  <<SLOT PSCreateAlreadyOpen:DoPart>> #);
          exists:< PSexception
          (* The old store is deleted if exists returns. 
           *) (#  <<SLOT PSCreateExists:DoPart>> #);
          creationError:< PSexception
            (# 
            <<SLOT PSCreateCreationError:DoPart>>
            #);
          name: ^Text;
          
       enter name[]
       <<SLOT PStoreCreate:DoPart>>
       #);
     abstractOpenOperation: assertInit
       (#
          alreadyOpenMessage:<
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          notFoundMessage:<
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          accessErrorMessage:<
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          alreadyOpen:< PSexception
            (# 
            <<SLOT PSOpenOpTypeAlreadyOpen:DoPart>>
            #);
          notFound:< PSexception (#  <<SLOT PSOpenOpTypeNotFound:DoPart>> #);
          accessError:< PSexception
            (#  <<SLOT PSOpenOpTypeAccessError:DoPart>> #);
          name: ^Text;
          openFunc:<
            (#
               host,path: [1] @Char;
               rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
       enter name[]
       <<SLOT PStoreOpen:DoPart>>
       #);
     openRead: abstractOpenOperation
       (#
          alreadyOpenMessage:: 
            (#  <<SLOT PSOpenReadAlreadyOpenMessage:DoPart>> #);
          notFoundMessage:: 
            (# 
            <<SLOT PSOpenReadNotFoundMessage:DoPart>>
            #);
          accessErrorMessage:: 
            (#  <<SLOT PSOpenReadAccessErrorMessage:DoPart>> #);
          openFunc:: 
            (# 
            <<SLOT PSOpenReadOpenFunc:DoPart>>
            #);
          
       do INNER
       #);
     openWrite: abstractOpenOperation
       (#
          alreadyOpenMessage:: 
            (#  <<SLOT PSOpenWriteAlreadyOpenMessage:DoPart>> #);
          notFoundMessage:: 
            (# 
            <<SLOT PSOpenWriteNotFoundMessage:DoPart>>
            #);
          accessErrorMessage:: 
            (#  <<SLOT PSOpenWriteAccessErrorMessage:DoPart>> #);
          openFunc:: 
            (# 
            <<SLOT PSOpenWriteOpenFunc:DoPart>>
            #);
          
       do INNER
       #);
     checkpoint: assertInit (#  <<SLOT PStoreCheckpoint:DoPart>> #);
     close: assertInit
       (#
          danglersExists:<
            (#
               toDo: @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill->toDo; INNER
            exit toDo
            #);
          doCheckpoint:< BooleanValue (#  do false->value; INNER #);
          
       <<SLOT PStoreClose:DoPart>>
       #);
     get: assertInit
       (#
          quaError:< Exception
            (#  <<SLOT PSGetQuaError:DoPart>> #);
          notFound:<
           Exception (#  <<SLOT PSGetNotFound:DoPart>> #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type##)
       <<SLOT PStoreGet:DoPart>>
       exit theObject[]
       #);
     ALREADYTHEREERROR: (#  exit 6 #);
     HASOVERWRITTENERROR: (#  exit 7 #);
     put: assertInit
       (#
          AlreadyThere:< PSexception
            (# 
            <<SLOT PSPutAlreadyThere:DoPart>>
            #);
          HasOverWritten:< PSexception
            (#  <<SLOT PSPutHasOverWritten:DoPart>> #);
          dooverwrite:< BooleanValue
            (# 
            do true->value; INNER
            #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       <<SLOT PStorePut:DoPart>>
       #);
     scanRootNames: assertInit
       (# current: ^Text; 
       do
          PSroots.scan
            (#  do current.name[]->THIS(scanRootNames).current[] #);
          INNER
       #);
     registerSpecialObject: assertInit
       (#
          alreadyThere:< Exception
            (#  <<SLOT PSRegisterSpecialAlreadyThere:DoPart>> #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type##)
       <<SLOT PStoreRegisterSpecialObject:DoPart>>
       #);
     registerRuntimeType: assertInit
       (# type: ##Object
       enter type##
       do
          'registerRuntimeType: This function is not implemented in the new'
            ->screen.putLine;
          'persistent store, and the call should be removed.'->screen.putLine;
          
       #);
     allowLazyFetch:<
       BooleanValue;
     maxCountOnDanglerHit:< IntegerValue (#  do 100->value; INNER #);
     OnDanglerHit:< Object;
     AfterDanglerHit:<
       (# theObject: ^Object;  enter theObject[] do INNER #);
     openpstore:<
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     deletePersistentStore: assertInit
       (#
          alreadyOpen:< PSexception
            (#  <<SLOT PSDeletePSAlreadyOpen:DoPart>> #);
          accessError:< PSexception
            (# 
            <<SLOT PSDeletePSAccessError:DoPart>>
            #);
          notFound:< PSexception (#  <<SLOT PSDeletePSNotFound:DoPart>> #);
          name: ^Text;
          storeDir: @directory;
          
       enter name[]
       <<SLOT PSDeletePersistentStore:DoPart>>
       #);
     registerSpecialInstance: assertInit
       (#
          quaError:< Exception
            (#  <<SLOT PSRegSpecInstanceQuaError:DoPart>> #);
          notFound:< Exception
            (# 
            <<SLOT PSRegSpecInstanceNotFound:DoPart>>
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
          
       enter (o[],tag)
       <<SLOT PSRegisterSpecialInstance:DoPart>>
       #);
     
  do INNER ; 
  #)  

