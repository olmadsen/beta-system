ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/sysutils/objinterface';
---- lib: attributes ----

persistentstore:
  (# lastupdate:@integer;
     
     rebinderItem: ^rebindSpecialReference;
     
     registerRebinderFunc: external
       (# rebinderFunc: ##callRebinder
       enter rebinderFunc##
       #);

     init:
       (# 
       do callRebinder## -> registerRebinderFunc;
          &rebindSpecialReference[] -> rebinderItem[]
       #);
     
     UNKNOWNTAG: (# exit 0 #);
     
     rebindSpecialReference:<
       (# 
          target: ^Object;
          
          toSpecialObject :< 
            (# objectTag: @integer;
               NotHandled:< PSException
                 (# 
                 do 'persistentstore.rebindSpecialReference: tag "' -> msg.putText; 
                    objectTag -> msg.putInt;
                    '" has not been rebound (returning NULL)' -> msg.putText;
                    msg[]->putline;
                    true->continue;
                    INNER
                 #)
               
            enter objectTag
            do INNER
            #);
          
          toSpecialType :< 
            (# typeTag: @integer
            enter typeTag 
            do INNER   
            #);
          
          objectTag, typeTag: @integer
            
       enter (objectTag, typeTag)
       do (if objectTag <> UNKNOWNTAG then
              objectTag -> toSpecialObject
           else
              (if typeTag <> UNKNOWNTAG then
                  typeTag -> toSpecialType
              if)
          if)
          
          (* At this point it is assumed that 'target' now contains the 
           * reference to the object this special reference is 
           * to be rebound to *)
          
          exit target[]
       #);
     
     callRebinder: external
       (# objectTag, typeTag: @integer;
          target: ^Object;
          targetAbs: @integer
            
       enter (objectTag, typeTag)
       do CExternalentry;
          (objectTag, typeTag) -> rebinderItem -> target[];
          (%getLongAt (@@ target)) -> targetAbs
       exit targetAbs
       #);
            
     commit:
       (# doUpdateInMemoryObjects:< BooleanValue 
            (# do false-> value; INNER #);
          doCheckpoint:< BooleanValue 
            (# do true -> value; INNER #);
       do 
       #);
     
      reget:
       (# NotFound:< PSException
            (# 
            do 'persistentstore.reget: Root "' -> msg.putText; 
               fullname[] -> msg.putText;
               '" has been overwritten by another client.' -> msg.putText;
               'Your references are not longer valid.'->msg.puttext;
               msg[]->putline;
               true->continue;
               INNER
            #);
          theObject: ^Object;
       enter theObject[]   
       do 
       #);
     
     openReadExt: external (# name: [1]@Char; rcode: @integer enter name exit rcode #);
     
     ACCESSERRORERROR: (# exit 1#);
     NOTFOUNDERROR: (# exit 2 #);
     ALREADYOPENERROR: (# exit 3 #);
     
     openRead:
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.openRead: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          notFound:< PSexception 
            (# 
            do 'persistentstore.openRead: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" not found' -> msg.putText; 
               INNER
            #);
          accessError:< PSexception
            (# 
            do 'persistentstore.openRead: No access to "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" ' -> msg.putText; 
               INNER 
            #);
          name: ^Text;
       enter name[]
       do 
          (if name -> openReadExt
           // (ALREADYOPENERROR) then
              name[] -> alreadyOpen
           // (NOTFOUNDERROR) then
              name[] -> notFound
           // (ACCESSERRORERROR) then
              name[] -> accessError
          if)
       #);
     
     openWriteExt: external (# name: [1]@Char; rcode: @integer 
                            enter name exit rcode #);
     
     openWrite:
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.openWrite: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          notFound:< PSexception 
            (# 
            do 'persistentstore.openWrite: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" not found' -> msg.putText; 
               INNER
            #);
          accessError:< PSexception
            (# 
            do 'persistentstore.openWrite: No access to"' 
                 -> msg.putText;  fullName[] -> msg.putText; 
               '"' -> msg.putText;
               INNER
            #);
          name: ^Text
       enter name[]
       do (if name -> openWriteExt
           // (ALREADYOPENERROR) then
              name[] -> alreadyOpen
           // (NOTFOUNDERROR) then
              name[] -> notFound
           // (ACCESSERRORERROR) then
              name[] -> accessError
          if)
       #);
     
     createExt: external (# name: [1]@Char; rcode:@integer enter name exit rcode #);
     deleteExt: external (# name: [1]@Char; rcode:@integer enter name exit rcode #);

     EXISTSERROR: (# exit 4 #);
     CREATIONERRORERROR: (# exit 5 #);
     
     create:
       (# alreadyOpen:< PSexception
            (# 
            do 'persistentstore.create: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already open' -> msg.putText; 
               INNER
            #);
          exists:< PSexception 
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" already exists' -> msg.putText; 
               INNER
            #);
          creationError:< PSexception
            (# 
            do 'persistentstore.create: Failed creating "'
                 -> msg.putText; fullName[] -> msg.putText; 
               '"' -> msg.putText;
               INNER
            #);
          name: ^Text;
       enter name[]
       do (if name -> createExt
           // (ALREADYOPENERROR) then
              name[] -> alreadyOpen
           // (EXISTSERROR) then
              name[] -> exists;
              (if (name -> deleteExt) > 0 then
                  name[] -> creationError
               else
                  name[] -> create;
              if)
           // (CREATIONERRORERROR) then
              name[] -> creationError
          if)
       #);
     
     checkpoint:
       (# 
       do setForceAOAGG;
          doGC;
       #);
     
     setClosingGC: external (#  #);

     close:
       (# danglersExists:< 
            (# toDo: @Integer;
               kill:   (# exit 0 #); 
               (* Kill the process. Default action. *)
               fetch:  (# exit 1 #); 
               (* Fetch the missing objects.        *)
               ignore: (# exit 2 #); 
               (* Ignore the dangling references.   *)
            do kill -> toDo; INNER
            exit toDo
            #);
          doCheckpoint:< BooleanValue 
            (# do false -> value; INNER #);
       do INNER;
          (if doCheckpoint then
              checkpoint
          if);
          setClosingGC; doGC
       #);
     
     getExt: external
       (# name: [1]@Char;  
          theObj: @integer 
       enter name
       exit theObj
       #);
     
     get:
       (# quaError:< Exception
            (# 
            do 'persistentstore.get: Qua error getting "' 
                 -> msg.putText; name[] -> msg.putText;
               '"' -> msg.putText;
               INNER 
            #);
          notFound:< Exception
            (# 
            do 'persistentstore.get: "' -> msg.putText; 
               name[] -> msg.putText;
               '" not found' -> msg.putText;
               INNER
            #);
          allowLazyFetch:< BooleanValue
            (# 
            do THIS(persistentstore).allowLazyFetch 
                 -> value;
               INNER
            #);
          name: ^Text; type: ##Object;
          theObj: ^Object;
          
       enter (name[],type##)
       do (@@ theObj, (name -> getExt)) -> assignRef;
          (if theObj[] = none then
              notFound
          if)
       exit theObj[]
       #);
     
     ALREADYTHEREERROR: (# exit 6 #);
     HASOVERWRITTENERROR: (# exit 7 #);
     
     putExt: external
       (# dooverwrite:@boolean; name: [1]@Char;  obj, rcode:@integer
       enter (dooverwrite, name, obj)
       exit rcode
       #);
     
     markPersistentObject: external (# theObj: @integer enter theObj #);
     
     markObjectPersistent:
       (# theObj: ^Object
       enter theObj[]
       do (if true then (%getLongAt (@@ theObj))->markPersistentObject if)
       #);
     
     setForceAOAGG: external (#  #);
     
     put:
       (# 
          
         AlreadyThere:< PSexception 
            (# 
            do 'persistentstore.put: Root "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" ' -> msg.putText; 'already there.'->msg.puttext;
               true->continue;
               INNER
               
            #);
     
          HasOverWritten:< PSexception 
            (# 
            do 'persistentstore.put: Root "' 
                 -> msg.putText; fullName[] -> msg.putText;
               '" ' -> msg.putText; 'will overwrite an already existing root with same name at checkpoint time.'->msg.puttext;
               true->continue;
               INNER
               
            #); 
          dooverwrite:< BooleanValue 
            (# do true -> value; INNER #);
          obj: ^Object; name: ^text;
       enter (obj[],name[])
       do obj[] -> markObjectPersistent;
          setForceAOAGG;
          doGC;
          (if ((dooverwrite, name, (%getLongAt (@@ obj))) -> putExt)
           // (ALREADYTHEREERROR) then
              AlreadyThere;
              (if dooverwrite then
                  HasOverWritten
              if)
          if)
       #);
     
     
     scanRootNames:
       (# current: ^Text;
       do INNER
       #);
     
     registerSpecialObject:
       (# alreadyThere:< Exception
            (# 
            do 'registerSpecialObject: Special object "' 
                 -> msg.putText; name[] -> msg.putText; 
               '" already exists: ' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          name: ^Text; type: ##Object;
       enter (name[],type##)
       do 
       #);
     
     markSpecialObject: external
       (# tag, theObj: @integer
       enter (tag, theObj)
       #);
     
     registerSpecialInstance:
       (# quaError:< Exception
            (#
            do 'registerSpecialInstance: Qua error on "'
                 -> msg.putText; tag -> msg.putInt;
               '" instance' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          notFound:< Exception
            (# 
            do 'registerSpecialInstance: Special object "'
                 -> msg.putText; tag -> msg.putInt;
               '" not registered.' -> msg.putText;
               INNER; 
               false -> continue;
            #);
          o: ^Object; tag: @integer;
       enter (o[],tag)
       do (tag, %getLongAt (@@ o)) -> markSpecialObject
       #);
    
     registerRuntimeType:
       (# type: ##Object
       enter type##
       do 
       #);
     
     allowLazyFetch:<
       BooleanValue;
     
     maxCountOnDanglerHit:< IntegerValue
       (# do 100 -> value; INNER #);
     
     OnDanglerHit:<
       Object;
     AfterDanglerHit:< 
       (# theObject: ^Object;
       enter theObject[]
       do INNER
       #);
    
     openpstore:<
       (# psname: ^Text;
          ps: ^persistentstore;
       enter psname[]
       do INNER
       exit ps[]
       #);
     
  do INNER;
  #);

deletePersistentStore: 
  (# alreadyOpen:< PSexception
       (# 
       do 'persistentstore.delete: "' -> msg.putText;
          fullName[] -> msg.putText;
          '" is currently open' -> msg.putText;
          INNER;
       #);
     accessError:< PSexception
       (# 
       do 'persistetstore.delete: Unable to delete "' -> msg.putText; 
          fullName[] -> msg.putText; '"' -> msg.putText;
          INNER;
       #);
     notFound:< PSexception
       (# 
       do 'persistetstore.delete: "' -> msg.putText; 
          fullName[] -> msg.putText; '" not found' -> msg.putText;
          INNER;
       #);
     name: ^Text;
  enter name[]
  do 
  #);

PSexception: exception
  (# fullName: ^Text;
  enter fullName[]
  do INNER
  #)
