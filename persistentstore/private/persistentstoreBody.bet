ORIGIN '../persistentstore' (* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
;
INCLUDE '../psObjectServer'
        '../psLocation'
        '~beta/sysutils/v1.6/objinterface'
        '~beta/containers/v1.6/list'
        '~beta/objectserver/v2.5/runtimeTypesTable'
        '~beta/objectserver/v2.5/specialObjectsTable';
-- PersistentInit: Descriptor --
(# 
do
   getPSobjectServer->pspriv.os[];
   &pspriv.locationImpl[]->pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   pspriv.roots.init;
   pspriv.oldroots.init
#)  

-- PersistentCommit: Descriptor --
(# 
do
   (if doCheckpoint
    // true then checkpoint; 
    else
       (if doUpdateInMemoryObjects then - 1->lastUpdate;  if); 
   if);
   pspriv.location.commit;
   none ->pspriv.os.lastlocation[];
   
#)  

-- PersistentReget: Descriptor --
(# doreget: @boolean; foundOID: @OIDtype; 
do
   (if theObject[]
    // none then
       (if lastupdate = 0 then
           false->doreget; 
        else
           (if (pspriv.location.numberofUpdates > lastupdate) then
               true->doreget; 
            else
               false->doreget; 
           if);
           
       if);
       (if doreget
        // true then
           (if pspriv.printDebug then '=> REGETTING ....'->putline if);
           pspriv.location.numberofupdates->lastupdate;
           regetIt:
             (# 
             do
                (if allowLazyFetch
                 // true then pspriv.os.regetObjectsWithPartialClosure; ; 
                 else
                    pspriv.os.regetObjectsWithWholeClosure; 
                if);
                
             #);
           (*check if roots are still valid or have been overwritten by another client*)
           pspriv.oldroots.scan
             (# theObj: ^Object; newOID,oldOID: @OIDtype; name: ^text; 
             do
                current.obj[]->theObj[];
                current.name[]->name[];
                current.name[]
                  ->pspriv.location.rootNames.findName
                    (#
                       notfound::< 
                         (#  do '*** Error in scan old roots'->putline;  #);
                       found::<  (#  do OID->newOID;  #);
                       
                    #);
                pspriv.os.objects.oh.scan
                  (# 
                  do
                     (if (current.o[] = theObj[]) then
                         current.OID->oldOID; 
                     if);
                     
                  #);
                (if (newOID,oldOID)->equalOID
                 // false then
                    current.name[]->NotFound;
                    pspriv.oldroots.scan
                      (# 
                      do
                         (if current.name[]->name.equal
                          // true then
                             current[]->pspriv.oldroots.at
                               ->pspriv.oldroots.delete;
                             
                         if);
                         
                      #);
                    
                if);
                
             #);
           
        // false then
           (if pspriv.printDebug then '=> NO UPDATE NECESSARY'->putline if)
       if);
       
    else
       '=> REGET single object'->putline;
       pspriv.os.objects.oh.scan
         (# 
         do (if (current.o[] = theObject[]) then current.OID->foundOID if); 
         #);
       (if (foundOID,noneOID)->equalOID
        // true then '*** Error: object no persistent object'->putline; 
        else
           (if allowLazyFetch
            // true then
               (foundOID,0,foundOID)
                 ->pspriv.os.regetsingleObjectWithPartialClosure;
               ;
               
            else
               (foundOID,0,foundOID)
                 ->pspriv.os.regetsingleObjectWithWholeClosure;
               
           if);
           
       if);
       
   if);
   
#)  

-- PersistentOpenRead: Descriptor --
(# 
do
   getPSobjectServer->pspriv.os[];
   &pspriv.locationImpl[]->pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   &pspriv.os.specialObjectsTable[]->pspriv.specialObjects[];
   pspriv.specialObjects.init;
   open:
   (name[],read)
     ->pspriv.location.open
       (#
          notFound:: 
            (#  do fullName[]->THIS(openRead).notFound; leave open #);
          nonReadable::  (#  do fullName[]->accessError; leave open #);
          alreadyOpen:: 
            (#  do fullName[]->THIS(openRead).alreadyOpen; leave open #);
          
       #);
   false->pspriv.writeAllowed;
   
#)  

-- PersistentOpenWrite: Descriptor --
(# 
do
   getPSobjectServer->pspriv.os[];
   &pspriv.locationImpl[]->pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   &pspriv.os.specialObjectsTable[]->pspriv.specialObjects[];
   pspriv.specialObjects.init;
   open:
   (name[],readWrite)
     ->pspriv.location.open
       (#
          notFound:: 
            (#  do fullName[]->THIS(openWrite).notFound; leave open #);
          nonWritable::  (#  do fullName[]->accessError; leave open #);
          alreadyOpen:: 
            (#  do fullName[]->THIS(openWrite).alreadyOpen; leave open #);
          
       #);
   true->pspriv.writeAllowed;
   
#)  

-- PersistentCreate: Descriptor --
(# 
do
   getPSobjectServer->pspriv.os[];
   &pspriv.locationImpl[]->pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   pspriv.roots.init;
   &pspriv.os.specialObjectsTable[]->pspriv.specialObjects[];
   pspriv.specialObjects.init;
   docreate:
   (name[])
     ->pspriv.location.create
       (#
          alreadyThere::  (#  do fullName[]->THIS(create).exists #);
          alreadyOpen:: 
            (#  do fullName[]->THIS(create).alreadyOpen; leave docreate #);
          failed::  (#  do fullName[]->creationError; leave docreate #);
          
       #);
   true->pspriv.writeAllowed;
   pspriv.location.numberofUpdates->lastUpdate;
   
#)  

-- PersistentDelete: Descriptor --
(# 
do
   dodelete:
   name[]
     ->deleteLocation
       (#
          accessError:: 
            (#  do fullName[]->THIS(deletePersistentStore).accessError;  #);
          alreadyOpen:: 
            (#  do fullName[]->THIS(deletePersistentStore).alreadyOpen;  #);
          notFound:: 
            (#  do fullName[]->THIS(deletePersistentStore).notFound;  #)
       #);
   
#)  

-- PersistentCheckPoint: DoPart --
do
   (if pspriv.writeAllowed
    // true then
         (# 
         do (* Prepare for the put operation. *)
            pspriv.specialObjects.beforeputget;
            pspriv.location[]
              ->pspriv.os.putClosure
                (#
                   serializeImpl::< 
                     (# creationTime: @Integer; 
                     do
                        pspriv.location.locationObjects.resetSaved;
                        pspriv.location.creationTime->creationTime;
                        (* Save the closure of all the persistent roots 
                         * touched in this session. *)
                        pspriv.roots.scan
                          (# OID: @OIDtype; offset: @Integer; 
                          do
                             (current.obj[],(creationTime,0),none )->forEachRoot
                               ->(OID,offset);
                             (* offset is zero as this was checked put *)
                             (current.name[],OID)
                               ->pspriv.location.rootNames.saveName;
                             
                          #);
                        (* Then check that all objects originating from this 
                         * persistentstore have been saved. *)
                        pspriv.location.locationObjects.scanUnSaved
                          (# e: ^PSobjectServer.objects.element; 
                          do
                             (creationTime,current)->pspriv.os.objects.fobo
                               ->e[];
                             (e.o[],(creationTime,0),e[])->forEachRoot;
                             
                          #);
                        
                     #);
                   
                #);
            pspriv.location.numberofUpdates+1->pspriv.location.numberofUpdates
              ->lastUpdate;
            (* Finally save location tables. *)
            pspriv.location.rootNames.save;
            pspriv.location.crossLocRefs.save;
            pspriv.location.save;
            pspriv.specialObjects.afterputget;
            pspriv.roots.scan
              (# (* gem liste af persistente roedder*) 
              do (current.name[],current.obj[])->pspriv.oldroots.register
              #);
            
         #)
   if)  

-- PersistentClose: Descriptor --
(# 
do
   (if doCheckpoint // true then checkpoint if);
   pspriv.location.close
     (#
        danglersExists::< 
          (#
             creationTime,putId: @Integer;
             missing: @list (# element::< danglingData #);
             
          do
             (if THIS(close).danglersExists
              // 0 then (* kill *)
                 (failure,
                  'Attempt to close persistentstore with existing danglers.')
                   ->stop;
                 
              // 1 then
              (* Fetch the missing objects by scanning danglers table
               * and fetching objects belonging to this location. *)
                 pspriv.location.creationTime->creationTime;
                 missing.init;
                 pspriv.os.danglers.dtoo.scan
                   (# 
                   do
                      (if current.OID.a
                       // creationTime then current[]->missing.append; 
                      if);
                      
                   #);
                 (* Getting an object deletes dangling references to the object
                  * from the dangling table. For this reason we need to first
                  * collect the danglers, and then fetch them as fetching them
                  * while scanning the danglers table might not work. *)
                 pspriv.specialObjects.beforeputget;
                 pspriv.os.getClosure
                   (#
                      doUnserializeImpl:: 
                        (# 
                        do
                           missing.scan
                             (# 
                             do
                                (current.OID,0,(creationTime,0),none )
                                  ->forEachRoot;
                                
                             #);
                           
                        #);
                      
                   #);
                 pspriv.specialObjects.afterputget;
                 
              // 2 then (* Ignore. Simply return . *)
                 
             if);
             
          #)
     #);
   pspriv.clear;
   
#)  

-- PersistentGet: Descriptor --
(# 
do
   getIt:
     (# foundOID: @OIDtype; 
     do
        (if name[]->pspriv.roots.findName->theObject[]
         // none then
            name[]
              ->pspriv.location.rootNames.findName
                (#
                   notFound::<  (#  do THIS(get).notFound; leave getIt #);
                   found::<  (#  do OID->foundOID #);
                   
                #);
            (if (foundOID,noneOID)->equalOID
             // true then none ->theObject[]; leave getIt; 
             else
                pspriv.specialObjects.beforeputget;
                (if allowLazyFetch
                 // true then
                    (maxCountOnDanglerHit,foundOID,0,foundOID)
                      ->pspriv.os.SingleObjectGetPartialClosure->theObject[];
                    
                 else
                    (foundOID,0,foundOID)->pspriv.os.SingleObjectGetClosure
                      ->theObject[];
                    
                if);
                (if theObject[]
                 // none then
                    'FATAL ERROR: PersistentGet: theObject is NONE'->putLine; 
                if);
                pspriv.specialObjects.afterputget;
                
            if)
        if);
        (if theObject## <= type##
         // false then quaError; none ->theObject[]
         else
            (name[],theObject[])->pspriv.roots.register; 
        if)
     #)
#)  

-- PersistentPut: Descriptor --
(# OID: @OIDtype; gcf: @Integer; rootfound: @boolean; 
do
   (if obj[] // none then 0->gcf else obj[]->getGCField->gcf;  if);
   (if true
    // (gcf = - 1) then
       (failure,'PersistentStore.put: Attempt to put component  object')->stop; 
    // (gcf < 0) then
       (failure,'PersistentStore.put: Attempt to put inlined object')->stop; 
   if);
   false->rootfound;
   name[]
     ->pspriv.location.rootNames.findName
       (# found::<  (#  do true->rootfound;  #);  #);
   (if rootfound then
       (if (not dooverwrite) then
           name[]->AlreadyThere; 
        else
           name[]->HasOverWritten; (name[],obj[])->pspriv.roots.register; 
       if);
       
    else
       (name[],obj[])->pspriv.roots.register; 
   if);
   
#)  

-- lib: Attributes --
specialInfo: (# type: ##Object; OID: @OIDtype;  #);   

-- registerSpecialObject: Descriptor --
(# found: @Boolean; specialName: ^Text; 
do
   true->found;
   '##special##'->specialName[];
   name[]->specialName.append;
   (specialName[],specialInfo##)
     ->get
       (#
          notFound::< 
            (# si: ^specialInfo; 
            do
               false->found;
               (* Save the type for future qua checks: *)
               &specialInfo[]->si[]->theObject[];
               THIS(registerSpecialObject).type##->si.type##;
               si[]->pspriv.location.nextOID->si.OID;
               (* Special objects have zero OID.a: *)
               0->si.OID.a;
               (si[],specialName[])->put;
               true->continue;
               
            #);
          allowLazyFetch::<  (#  do false->value #);
          quaError::< 
            (# 
            do
               (failuretrace,'Unexpected quaError in registerSpecialObject')
                 ->stop;
               
            #);
          
       #);
   (if found // true then alreadyThere if);
   
#)  

-- registerSpecialInstance: Descriptor --
(# si: ^specialInfo; specialName: ^Text; 
do
   (if o[]
    // none then
       (failuretrace,'registerSpecialInstance: Object is NONE')->stop; 
   if);
   '##special##'->specialName[];
   name[]->specialName.append;
   (specialName[],specialInfo##)
     ->get
       (#
          notFound::<  (#  do THIS(registerSpecialInstance).notFound #);
          allowLazyFetch::<  (#  do false->value #);
          quaError::< 
            (# 
            do
               (failuretrace,'Unexpected quaError in registerSpecialInstance')
                 ->stop;
               
            #);
          
       #)->si[];
   (* Check that the registered object has the qualification 
    * given when this special object was registered. *)
   (if (o## <= si.type##) // false then quaError if);
   (* So far registration is valid. Insert object in specialObjects table
    * checking at the same time whether an inconsistency between 
    * special objects and runtimetypes exists. *)
   (o[],si.OID,pspriv.location.runtimeTypes[])->pspriv.specialObjects.register;
   
#)  

-- runtimeObjectsRegister: Descriptor --
(# 
do
   (if pspriv.location.runtimeTypes[]
    // none then
       &runtimeTypesTable[]->pspriv.location.runtimeTypes[];
       pspriv.location.runtimeTypes.init;
       
   if);
   type##->pspriv.location.runtimeTypes.register;
   (* check that no special object qualifies to a runtime type. *)
   pspriv.location.runtimeTypes[]->pspriv.specialObjects.check;
   
#)  

-- psprivate: Descriptor --
(#
   os: ^PSobjectServer;
   specialObjects: ^PSobjectServer.specialObjectsTable;
   name: ^text;
   locationImpl: psLocation
     (#
        crossLocRefsImpl::< 
          (#
             openPstore::< 
               (# 
               do
                  ((psname[]->THIS(persistentstore).openpstore) <> none )
                    ->value;
                  
               #)
          #);
        OnDanglerHit::< 
          (# theObject: ^Object; 
          do
             THIS(persistentStore).OnDanglerHit;
             specialObjects.beforeputget;
             (MaxCountOnDanglerHit,OID,offset,fromOID)
               ->os.singleObjectGetPartialClosure->theObject[];
             specialObjects.afterputget;
             theObject[]->THIS(persistentStore).AfterDanglerHit;
             none ->theObject[];
             
          #);
        
     #);
   location: ^locationImpl;
   writeAllowed: @Boolean;
   clear: (#  do none ->os[]; none ->location[];  #);
   roots: @list
     (#
        element::<  (# name: ^Text; obj: ^Object;  #);
        register: @
          (# name: ^Text; obj: ^Object; elm: ^element; found: @Boolean; 
          enter (name[],obj[])
          do
             false->found;
             find: scan
               (# 
               do
                  (if current.name[]->name.equal
                   // true then
                      obj[]->current.obj[]; true->found; leave find; 
                  if);
                  
               #);
             (if found
              // false then
                 &element[]->elm[];
                 name[]->elm.name[];
                 obj[]->elm.obj[];
                 elm[]->append;
                 
             if);
             
          #);
        findName: @
          (# name: ^Text; obj: ^Object; 
          enter name[]
          do
             none ->obj[];
             find: scan
               (# 
               do
                  (if current.name[]->name.equal
                   // true then current.obj[]->obj[]; leave find; 
                  if);
                  
               #);
             
          exit obj[]
          #);
        
     #);
   oldroots: @list
     (#
        element::<  (# name: ^Text; obj: ^Object;  #);
        register: @
          (# name: ^Text; obj: ^Object; elm: ^element; found: @Boolean; 
          enter (name[],obj[])
          do
             false->found;
             find: scan
               (# 
               do
                  (if current.name[]->name.equal
                   // true then
                      obj[]->current.obj[]; true->found; leave find; 
                  if);
                  
               #);
             (if found
              // false then
                 &element[]->elm[];
                 name[]->elm.name[];
                 obj[]->elm.obj[];
                 elm[]->append;
                 
             if);
             
          #);
        
     #);
   printDebug: (* introduced with sharedPS *) (#  exit false #)
#)  

-- scanRootNamesBody: Descriptor --
(#
   isspecial: @BooleanValue
     (# name,tmp: ^Text; 
     enter name[]
     do
        (if name.lgth < 11
         // true then false->value
         else
            (1,11)->name.sub->tmp[]; '##special##'->tmp.equal->value
        if)
     #);
   
do
   pspriv.location.rootNames.scan
     (#
        doInner::< 
          (# 
          do
             (if name[]->THIS(scanRootNames).current[]->isspecial
              // false then INNER scanRootNames
             if)
          #);
        
     #);
   pspriv.roots.scan
     (# 
     do
        current.name[]
          ->pspriv.location.rootNames.findName
            (#
               notfound::< 
                 (# 
                 do
                    (if
                    current.name[]->THIS(scanRootNames).current[]->isspecial
                     // false then INNER scanRootNames
                    if);
                    
                 #)
            #)
     #)
#)  

