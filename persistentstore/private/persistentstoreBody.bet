ORIGIN '../persistentstore';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
INCLUDE '../psObjectServer';
INCLUDE '../psLocation';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '~beta/containers/v1.6/list';
INCLUDE '~beta/objectserver/v2.5/runtimeTypesTable';
INCLUDE '~beta/objectserver/v2.5/specialObjectsTable';

--- PersistentInit: descriptor ---
(# 
do 
   getPSobjectServer ->  pspriv.os[];
   &pspriv.locationImpl[] -> pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
#)

--- PersistentCommit: descriptor ---
(#
do
   (if doCheckpoint //true then 
       checkpoint;
    else (if doUpdateInMemoryObjects then
             -1->lastUpdate;
         if);
   if);
   pspriv.location.commit;
   none->pspriv.os.lastlocation[];
#)

--- PersistentReget: descriptor ---
(# doreget:@boolean;
   foundOID: @OIDtype;
do
   (if theObject[] // NONE  then
       (if lastupdate = 0
           then false->doreget;
        else (if (pspriv.location.numberofUpdates > lastupdate)
                 then 
                 true->doreget;
              else false->doreget;
             if);
       if);
       (if doreget 
        // true
           then '=> REGETTING ....'->putline;
           pspriv.location.numberofupdates->lastupdate;
           regetIt:
             (# 
             do    
                (if allowLazyFetch //true then
                    pspriv.os.regetObjectsWithPartialClosure;;
                 else
                    pspriv.os.regetObjectsWithWholeClosure;
                if);
             #);
           
           (*check if roots are still valid or have been overwritten by another client*)
           pspriv.oldroots.scan
           (# theObj: ^Object;
              newOID,oldOID:@OIDtype;
              name:^text;
           do 
              current.obj[]->theObj[];
              current.name[]->name[];
              current.name[] -> pspriv.location.rootNames.findName
              (# notfound::<
                   (# 
                   do '*** Error in scan old roots'->putline;
                   #);
                 found::< (# 
                          do OID->newOID;
                          #);
              #);
              pspriv.os.objects.oh.scan(# do (if (current.o[] = theObj[]) then
                                                 current.OID->oldOID;
                                             if);    
                                       #);
              (if (newOID,oldOID) -> equalOID //false then 
                  current.name[]->NotFound;
                  pspriv.oldroots.scan
                  (# do (if current.name[] -> name.equal //true then
                            current[]->pspriv.oldroots.at->pspriv.oldroots.delete;
                        if);
                  #);
              if);
           #);
        // false then       
           '=> NO UPDATE NECESSARY'->putline;
       if);
    else '=> REGET single object'->putline;
       pspriv.os.objects.oh.scan(# do (if (current.o[] = theObject[]) then
                                          current.OID->foundOID
                                      if);    
                                #);
       (if (foundOID,noneOID) -> equalOID //true then 
           '*** Error: object no persistent object'->putline;
        else
           (if allowLazyFetch //true then
               (foundOID,0,foundOID) 
                 ->pspriv.os.regetsingleObjectWithPartialClosure;;
            else
               (foundOID,0,foundOID)      
                 ->pspriv.os.regetsingleObjectWithWholeClosure;
           if);     
       if);
   if);
   
#)

--- PersistentOpenRead: descriptor ---
(# 
do
   getPSobjectServer ->  pspriv.os[];
   &pspriv.locationImpl[] -> pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   pspriv.roots.init;
   &pspriv.os.specialObjectsTable[] -> pspriv.specialObjects[];
   pspriv.specialObjects.init;
   
   open: (name[], read) -> pspriv.location.open 
   (# notFound:: 
        (# do fullName[] -> THIS(openRead).notFound; leave open #);
      nonReadable:: 
        (# do fullName[] -> accessError; leave open #);
      alreadyOpen:: 
        (# do fullName[] -> THIS(openRead).alreadyOpen; leave open #);
   #);
   false -> pspriv.writeAllowed;
#)
  
--- PersistentOpenWrite: descriptor ---
(# 
do
   getPSobjectServer ->  pspriv.os[];
   &pspriv.locationImpl[] -> pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   pspriv.roots.init;
   &pspriv.os.specialObjectsTable[] -> pspriv.specialObjects[];
   pspriv.specialObjects.init;
   
   open: (name[], readWrite) -> pspriv.location.open 
   (# notFound:: 
        (# do fullName[] -> THIS(openWrite).notFound; leave open #);
      nonWritable:: 
        (# do fullName[] -> accessError; leave open #);
      alreadyOpen:: 
        (# do fullName[] -> THIS(openWrite).alreadyOpen; leave open #);
   #);
   true -> pspriv.writeAllowed;
#)

--- PersistentCreate: descriptor ---
(# 
do
   getPSobjectServer ->  pspriv.os[];
   &pspriv.locationImpl[] -> pspriv.location[];
   pspriv.location[]->pspriv.os.lastlocation[];
   name[]->pspriv.name[];
   pspriv.roots.init;
   &pspriv.os.specialObjectsTable[] -> pspriv.specialObjects[];
   pspriv.specialObjects.init;
   
   docreate: (name[]) -> pspriv.location.create
   (# alreadyThere:: 
        (# do fullName[] -> THIS(create).exists #);
      alreadyOpen:: 
        (# do fullName[] -> THIS(create).alreadyOpen; leave docreate #);
      failed:: 
        (# do fullName[] -> creationError; leave docreate #);
   #);
   true -> pspriv.writeAllowed;
   pspriv.location.numberofUpdates->lastUpdate;
#)

--- PersistentDelete: descriptor ---
(# 
do dodelete: name[] -> deleteLocation 
   (# accessError:: 
        (# do fullName[] -> THIS(deletePersistentStore).accessError; #);
      alreadyOpen:: 
        (# do fullName[] -> THIS(deletePersistentStore).alreadyOpen; #);
      notFound::
        (# do fullName[] -> THIS(deletePersistentStore).notFound; #)
   #);
#)

--- PersistentCheckPoint:dopart ---
do
   (if pspriv.writeAllowed //true then
       (# 
       do
          (* Prepare for the put operation. *)
          pspriv.specialObjects.beforeputget;
          
          pspriv.location[] -> pspriv.os.putClosure
          (# serializeImpl::<
               (# creationTime: @Integer;
               do
                  pspriv.location.locationObjects.resetSaved;
                  pspriv.location.creationTime -> creationTime;
                  
                  (* Save the closure of all the persistent roots 
                   * touched in this session. *)
                  pspriv.roots.scan
                  (# OID: @OIDtype;
                     offset: @Integer;
                  do 
                     (current.obj[],(creationTime,0),NONE)
                       -> forEachRoot 
                       -> (OID,offset);
                     (* offset is zero as this was checked put *)
                     (current.name[],OID) 
                       -> pspriv.location.rootNames.saveName;
                  #);
                  
                  (* Then check that all objects originating from this 
                   * persistentstore have been saved. *)
                  
                  pspriv.location.locationObjects.scanUnSaved
                  (# e: ^PSobjectServer.objects.element;
                  do (creationTime,current)->pspriv.os.objects.fobo->e[];
                     (e.o[],(creationTime,0),e[]) -> forEachRoot;
                  #);
               #);
          #);
          pspriv.location.numberofUpdates+1->pspriv.location.numberofUpdates->lastUpdate;
          
          (* Finally save location tables. *)
          pspriv.location.rootNames.save;
          pspriv.location.crossLocRefs.save;
          pspriv.location.save;
          
          pspriv.specialObjects.afterputget;
          pspriv.roots.scan
          (#
             (* gem liste af persistente roedder*)   
          do (current.name[], current.obj[])->pspriv.oldroots.register
          #);   
       #)
   if)

--- PersistentClose: descriptor ---
(#
do
   (if doCheckpoint //true then checkpoint if);
   
   pspriv.location.close
   (# danglersExists::< 
        (# creationTime, putId: @Integer;
           missing: @list (# element::< danglingData #);
        do 
           (if THIS(close).danglersExists
            //0 then (* kill *)
               
               (failure, 
               'Attempt to close persistentstore with existing danglers.')
                 -> stop;
               
            //1 then
               
               (* Fetch the missing objects by scanning danglers table
                * and fetching objects belonging to this location. *)
               
               pspriv.location.creationTime -> creationTime;
               missing.init;
               
               pspriv.os.danglers.dtoo.scan
               (#
               do (if current.OID.a //creationTime then
                      current[] -> missing.append;
                  if);
               #);
               
               (* Getting an object deletes dangling references to the object
                * from the dangling table. For this reason we need to first
                * collect the danglers, and then fetch them as fetching them
                * while scanning the danglers table might not work. *)
               
               pspriv.specialObjects.beforeputget;
               pspriv.os.getClosure
               (# doUnserializeImpl::
                    (# 
                    do missing.scan
                       (# 
                       do (current.OID,0,(creationTime,0),NONE) 
                            -> forEachRoot;
                       #);
                    #);
               #);
               pspriv.specialObjects.afterputget;
               
               
            //2 then (* Ignore. Simply return . *)
               
           if);
        #)
   #);
   pspriv.clear;
#)
  
--- PersistentGet: descriptor ---
(# 
do getIt:
     (# foundOID: @OIDtype;
     do
        (if name[] -> pspriv.roots.findName -> theObject[] //NONE then
            
            name[] -> pspriv.location.rootNames.findName
            (# notFound::< (# do this(get).notFound; leave getIt #);
               found::< (# do OID -> foundOID #);
            #);
         
            (if (foundOID,noneOID) -> equalOID //true then 
                NONE -> theObject[];
                leave getIt;
             else
                pspriv.specialObjects.beforeputget;
                (if allowLazyFetch //true then
                    (maxCountOnDanglerHit,foundOID,0,foundOID) 
                      -> pspriv.os.SingleObjectGetPartialClosure
                      -> theObject[]; 
                 else
                    (foundOID,0,foundOID) -> pspriv.os.SingleObjectGetClosure 
                      -> theObject[];
                if);
                (if theObject[] //NONE then
                    'FATAL ERROR: PersistentGet: theObject is NONE'
                      -> putLine;
                if);
                pspriv.specialObjects.afterputget;
            if)
        if);
        
        (if theObject## <= type## //false then 
            quaError; NONE -> theObject[]
         else
            (name[],theObject[]) -> pspriv.roots.register;
        if)
     #)
#)
  
--- PersistentPut: descriptor ---
(# OID: @OIDtype; gcf: @Integer; rootfound:@boolean;
do 
   (if obj[] //NONE then
       0 -> gcf
    else
       obj[] -> getGCField -> gcf;
   if);
       
   (if true
    // (gcf = -1) then
       (failure, 'PersistentStore.put: Attempt to put component  object') 
         -> stop;
    // (gcf < 0) then
       (failure, 'PersistentStore.put: Attempt to put inlined object') 
         -> stop;
   if);
   false->rootfound;
   name[] -> pspriv.location.rootNames.findName
   (# 
      found::< (# do true -> rootfound; #);
   #);
   (if rootfound then
       (if (not dooverwrite) then
           name[]->AlreadyThere;
        else
           name[]->HasOverWritten;
           (name[],obj[]) -> pspriv.roots.register;
       if);
    else 
       (name[],obj[]) -> pspriv.roots.register;
   if); 
#)

--- lib:attributes ---
specialInfo:
  (# type: ##Object;
     OID: @OIDtype;     
  #);

--- registerSpecialObject:descriptor ---
(# found: @Boolean;
   specialName: ^Text;
do
   true -> found;
   '##special##' -> specialName[]; name[] -> specialName.append;
   (specialName[],specialInfo##) -> get
   (# notFound::<
        (# si: ^specialInfo;
        do false -> found;
           (* Save the type for future qua checks: *)
           &specialInfo[] -> si[] -> theObject[];
           this(registerSpecialObject).type## -> si.type##;
           si[] -> pspriv.location.nextOID -> si.OID;
           (* Special objects have zero OID.a: *)
           0 -> si.OID.a;
           (si[],specialName[]) -> put;
           true -> continue;
        #);
      allowLazyFetch::< (# do false -> value #);
      quaError::<
        (# 
        do (failuretrace, 'Unexpected quaError in registerSpecialObject')
             -> stop;
        #);
   #);
   
   (if found //true then alreadyThere if);
#)

--- registerSpecialInstance:descriptor ---
(# si: ^specialInfo;
   specialName: ^Text;
do
   (if o[] //NONE then
       (failuretrace, 'registerSpecialInstance: Object is NONE') -> stop;
   if);
   
   '##special##' -> specialName[]; name[] -> specialName.append;
   (specialName[],specialInfo##) -> get
   (# notFound::< (# do THIS(registerSpecialInstance).notFound #);
      allowLazyFetch::< (# do false -> value #);
      quaError::<
        (# 
        do (failuretrace, 'Unexpected quaError in registerSpecialInstance')
             -> stop;
        #);
   #) -> si[];
   
   (* Check that the registered object has the qualification 
    * given when this special object was registered. *)
   (if (o## <= si.type##) //false then quaError if);
   
   (* So far registration is valid. Insert object in specialObjects table
    * checking at the same time whether an inconsistency between 
    * special objects and runtimetypes exists. *)
   (o[],si.OID,pspriv.location.runtimeTypes[]) 
     -> pspriv.specialObjects.register;
#)
    
--- runtimeObjectsRegister:descriptor ---
(# 
do
   (if pspriv.location.runtimeTypes[] //NONE then
       &runtimeTypesTable[] -> pspriv.location.runtimeTypes[];
       pspriv.location.runtimeTypes.init;
   if);
   
   type## -> pspriv.location.runtimeTypes.register;
   
   (* check that no special object qualifies to a runtime type. *)
   pspriv.location.runtimeTypes[] -> pspriv.specialObjects.check;
#)
   
  
--- psprivate: descriptor ---
(# os: ^PSobjectServer;
   
   specialObjects: ^PSobjectServer.specialObjectsTable;
   name:^text;   
   
   locationImpl: psLocation
     (# crossLocRefsImpl::<
          (# openPstore::<
               (# 
               do
                  ((psname[] -> THIS(persistentstore).openpstore) <> NONE)
                    -> value;
               #)
          #);
        OnDanglerHit::<
          (# theObject: ^Object;
          do THIS(persistentStore).OnDanglerHit;
             specialObjects.beforeputget;
             (MaxCountOnDanglerHit,OID,offset,fromOID) 
               ->os.singleObjectGetPartialClosure -> theObject[];
             specialObjects.afterputget;
             theObject[] -> THIS(persistentStore).AfterDanglerHit;
             NONE -> theObject[];
          #);
     #);
   location: ^locationImpl;
   
   writeAllowed: @Boolean;
   
   clear:
     (# 
     do none -> os[];
        none -> location[];
     #);
   
   roots: @list
     (# element::<
          (# name: ^Text;
             obj: ^Object;
          #);
        
        register: @
          (# name: ^Text; obj: ^Object;
             elm: ^element; found: @Boolean;
          enter (name[],obj[])
          do
             false -> found;
             find: scan
               (# 
               do (if current.name[] -> name.equal //true then
                      obj[] -> current.obj[];
                      true -> found;
                      leave find;
                  if);
               #);
             
             (if found //false then
                 &element[] -> elm[];
                 name[] -> elm.name[];
                 obj[] -> elm.obj[];
                 elm[] -> append;
             if);
             
          #);
        
        findName: @
          (# name: ^Text; obj: ^Object;
          enter name[]
          do
             NONE -> obj[];
             find: scan
               (# 
               do (if current.name[] -> name.equal //true then
                      current.obj[] -> obj[];
                      leave find;
                  if);
               #);
          exit obj[]
          #);
     #);
   oldroots: @list
     (# element::<
          (# name: ^Text;
             obj: ^Object;
          #);
        register: @
          (# name: ^Text; obj: ^Object;
             elm: ^element; found: @Boolean;
          enter (name[],obj[])
          do 
             false -> found;
             find: scan
               (# 
               do (if current.name[] -> name.equal //true then
                      obj[] -> current.obj[];
                      true -> found;
                      leave find;
                  if);
               #);
             
             (if found //false then
                 &element[] -> elm[];
                 name[] -> elm.name[];
                 obj[] -> elm.obj[];
                 elm[] -> append;
             if);
             
          #);
        
     #);
   
#)


--- scanRootNamesBody:descriptor ---
(# isspecial: @BooleanValue
     (# name, tmp: ^Text;
     enter name[]
     do 
        (if name.lgth < 11 //true then
            false -> value
         else
            (1,11) -> name.sub -> tmp[];
            '##special##' -> tmp.equal -> value
        if)
     #);
do 
   pspriv.location.rootNames.scan
   (# doInner::< 
        (# 
        do 
           (if name[] -> THIS(scanRootNames).current[] -> isspecial
            //false then
               INNER scanRootNames
           if)
        #);
   #);
   
   pspriv.roots.scan
   (#
   do current.name[] -> pspriv.location.rootNames.findName
      (# notfound::<
           (# 
           do (if current.name[] -> THIS(scanRootNames).current[] -> isspecial
               //false then
                  INNER scanRootNames
              if);
           #)
      #)
   #)
#)
