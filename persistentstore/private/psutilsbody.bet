ORIGIN '../psutils';
INCLUDE '~beta/basiclib/v1.6/file';
INCLUDE '~beta/basiclib/v1.6/directory';
INCLUDE '~beta/persistentstore/v1.6/private/persistentstoreBody';
INCLUDE '~beta/persistentstore/v1.6/private/psLocationBody';
MDBODY ppc 'psutils_macbody'
       ppcmac 'psutils_macbody'
       mac 'psutils_macbody'
       nti 'psutils_ntibody'
       default 'psutils_unixbody';

--- PersistentStoreExists: descriptor ---
(# locg, oinx, data: @file;
   dir: @directory;
do name[] -> makeFileNames
     -> (dir.name, locg.name, oinx.name, data.name);
   dir.entry.exists->value
#)

--- PersistentStoreDelete: descriptor ---
(#
do pspriv.location.fullname[] -> deleteLocation
   (# accessError::
        (# do fullName[] -> THIS(delete).accessError; #);
      alreadyOpen::
        (# do fullName[] -> THIS(delete).alreadyOpen; #);
      notFound::
        (# do fullName[] -> THIS(delete).notFound; #)
   #);
#)

--- PersistentStoreLock: descriptor ---
(# locg, oinx, data, lock: @file;
   dir: @directory; ph: @pathhandler; fn: ^text;
do pspriv.location.fullName[] -> makeFileNames
     -> (dir.name, locg.name, oinx.name, data.name);
   ph.init;locg.entry.path.head->fn[];ph.directoryChar->fn.put;'LOCK'->fn.puttext;
   fn[]->lock.name;
   
   (if lock.entry.exists then
       dir.name->alreadyLocked
    else
       lock.openwrite;
       msg[]->lock.puttext;
       lock.close;
   if)
#)

--- PersistentStoreUnlock: descriptor ---
(# locg, oinx, data, lock: @file;
   dir: @directory; ph: @pathhandler; fn: ^text;
do pspriv.location.fullName[] -> makeFileNames
     -> (dir.name, locg.name, oinx.name, data.name);
   ph.init;locg.entry.path.head->fn[];ph.directoryChar->fn.put;'LOCK'->fn.puttext;
   fn[]->lock.name;
   
   (if lock.entry.exists then
       lock.delete
   if)
#)

--- PersistentStoreLocked: descriptor ---
(# locg, oinx, data, lock: @file;
   dir: @directory; ph: @pathhandler; fn: ^text;
do pspriv.location.fullName[] -> makeFileNames
     -> (dir.name, locg.name, oinx.name, data.name);
   ph.init;locg.entry.path.head->fn[];ph.directoryChar->fn.put;'LOCK'->fn.puttext;
   fn[]->lock.name;
   
   (if lock.entry.exists then
       true->value;
       lock.openread;
       &text[]->msg[];
       loop: (if not lock.eos then lock.get->msg.put; restart loop if);
       INNER locked    
   if)    
#)

