ORIGIN '../persistentstore';
-- PSlib: Attributes --
markSpecialObject: external (* defined in P/misc.c *)
  (# tag,theObj: @integer enter (tag,theObj) #);
markPersistentObject: external (* defined in P/misc.c *)
  (# PSstoreID: @integer; obj: @integer enter (PSstoreID,obj) #);
putExt: external (* defined in P/PStoreServer.c *)
  (# dooverwrite: @boolean; host,path,name: [1] @Char; obj,rcode: @integer
  enter (dooverwrite,host,path,name,obj)
  exit rcode
  #);
setForceAOAGC: external (* defined in ioa.c *) (#  #);
setAllowLazyFetch: external (* defined in .c *) (# val: @Integer enter val #);
getNumberOfUpdates: external (* defined in P/storagemanager.c *)
  (# PSstoreID: @integer; numUpdates: @integer
  enter PSstoreID
  exit numUpdates
  #);
SBopen: external (* defined in P/PStoreServer.c *)
  (# host,path: [1] @Char; rcode: @integer
  enter (host,path)
  exit rcode
  #);
SBcreate: external (* defined in P/storageblock.c *)
  (# host,path: [1] @Char; rcode: @integer
  enter (host,path)
  exit rcode
  #);
SBclose: external (* defined in P/storageblock.c *)
  (# PSstoreID: @integer enter PSstoreID #);
USloadObject: external (* defined in P/storageblock.c *)
  (# PSstoreID,offset,inx,forced: @integer; obj: @integer
  enter (PSstoreID,offset,inx,forced)
  exit obj
  #);
getExt: external (* defined in P/PStoreServer.c *)
  (# host,path,name: [1] @Char; theObj: @integer
  enter (host,path,name)
  exit theObj
  #);
ACCESSERRORERROR: (#  exit 1 #);
NOTFOUNDERROR: (#  exit 2 #);
ALREADYOPENERROR: (#  exit 3 #);
EXISTSERROR: (#  exit 4 #);
CREATIONERRORERROR: (#  exit 5 #);
MULTIPLEOPENERROR: (# exit 6 #);
registerRebinderFunc: external (* defined in P/unswizzle.c *)
  (# rebinderFunc: ##callRebinder enter rebinderFunc## #);
registerBETAENVandPROGRAM: external
  (# theProgram: @integer enter theProgram #);
callRebinder: external
  (# objectTag,typeTag: @integer; target: ^Object; targetAbs: @integer
  enter (objectTag,typeTag)
  do
     CExternalentry;
     (objectTag,typeTag)->rebinderItem->target[];
     (%getLongAt (@@ target))->targetAbs
  exit targetAbs
  #);
callOpenCrossStore: external
  (#
     host,path: [1] @Char;
     newps: ^persistentstore;
     hostText,pathText: ^text;
     
  enter (host,path)
  do
     CExternalentry;
     &text[]->hostText[];
     &text[]->pathText[];
     host->hostText;
     path->pathText;
     pathText[]->openCrossStoreItem->newps[];
     (* newps is not currently used by the system *)
     
  #);
  

-- PSassertOpennotOpen: DoPart --
do
   'persistentstore.assertOpen: Store is not open'->msg.putText;
   false->continue;
   INNER  

-- PSassertOpen: DoPart --
do (if PSstoreID <> 0 then INNER ;  else notOpen;  if)  

-- PSassertInitnotInitialized: DoPart --
do
   'persistentstore.assertInitialized: Store is not initialized'->msg.putText;
   false->continue;
   INNER  

-- PSassertInit: DoPart --
do
   (if rebinderItem[] <> none then
       (if openCrossStoreItem[] <> none then
           INNER ; 
        else
           notInitialized; 
       if);
       
    else
       notInitialized; 
   if);
     

-- PStoreInit: DoPart --
do
   callRebinder##->registerRebinderFunc;
   &rebindSpecialReference[]->rebinderItem[];
   &openpstore[]->openCrossStoreItem[];
   (%getLongAt (@@ theProgram))->registerBETAENVandPROGRAM;
   INNER  

-- PStoreOpen: DoPart --
do
   (if PSstoreID = 0 then
       (if allowLazyFetch then
           '*******************************************************************'->screen.putline;
           'You have allowed lazy fetch. '->screen.putline;
           'This is not recommended, since there are know errors when using it.'->screen.putline;
           'You may encounter suspicious looking errors.'->putline;
           '*******************************************************************'->screen.putline;
           1->setAllowLazyFetch
        else
           0->setAllowLazyFetch
       if);           
       (if (hostName,name)->openFunc->PSstoreID
        // (NOTFOUNDERROR) then
           0->PSstoreID;
           name[]->notFound
        // (ACCESSERRORERROR) then
           0->PSstoreID;
           name[]->accessError
        // (MULTIPLEOPENERROR) then
           (# fail: ^text;
           do &text[]->fail[];
              '************************************************************'->fail.putline;
              'It is not allowed to open a persistent store more than once.'->fail.putline;
              'Open it, use it and close it at the end of the program.'->fail.putline;
              '************************************************************'->fail.putline;
              (Failure, fail[])->Stop;
           #);
        else
       (* Load root object containing the list of roots. It is assumed that 
        the root object is the first one created in the store and that it
        is placed at offset 4. 
        *)
           (# roots: @Integer;
           do (PSstoreID, 4, -1, 0)->USloadObject->roots;
              (@@PSroots, roots)->assignRef; INNER abstractOpenOperation;
           #)
       if)
    else
       name[]->alreadyOpen; 
   if);
     

-- PStoreCreate: DoPart --
do
   (if PSstoreID = 0 then
       (if (hostName,name)->SBcreate->PSstoreID
        // (EXISTSERROR) then
           0->PSstoreID;
           name[]->exists
        // (CREATIONERRORERROR) then
           0->PSstoreID;
           name[]->creationError
        else
           &PSrootsList[]->PSroots[];
           PSroots.init;
           (PSstoreID,%getLongAt (@@ PSroots))->markPersistentObject
       if)
    else
       screen.newline;
       name[]->alreadyOpen; 
   if);
   INNER  

-- PStoreCheckpoint: DoPart --
do setForceAOAGC; doGC;   

-- PStoreClose: DoPart --
do INNER ; checkpoint; PSstoreID->SBclose; 0->PSstoreID;   

-- PStoreGet: DoPart --
do
   PSroots.scan
     (# 
     do (if current.name[]->name.equalNCS then current.obj[]->theObject[] if)
     #);
   (if theObject[] = none then notFound else INNER if)  

-- PStorePut: DoPart --
do
     (# found: @boolean
     do
        PSroots.scan
          (# 
          do
             (if current.name[]->name.equalNCS then
                 true->found;
                 (if dooverwrite then
                     obj[]->current.obj[]; HasOverWritten
                  else
                     AlreadyThere
                 if)
             if)
          #);
        (if not found then
              (# newRoot: ^PSroot
              do
                 &PSroot[]->newRoot[];
                 (name[],obj##,obj[])->newRoot;
                 newRoot[]->PSroots.append
              #)
        if)
     #);
   INNER  

-- PStoreRegisterSpecialObject: DoPart --
do
   'registerSpecialObject: Registering of special objects and instances'
     ->screen.putLine;
   'is implemented differently in the new persistence implementation.'
     ->screen.putLine;
   'This call has no effect, and should be removed.'->screen.putLine;
   INNER  

-- PSNumberOfUpdates: DoPart --
do
   assertOpen
     (# notOpen::  (#  do true->continue #); 
     do PSstoreID->getNumberOfUpdates->result
     #)  

-- PSRebindSpecRefNotHandled: DoPart --
do
   'persistentstore.rebindSpecialReference: tag "'->msg.putText;
   objectTag->msg.putInt;
   '" has not been rebound (returning NULL)'->msg.putText;
   msg[]->putline;
   true->continue;
   INNER  

-- PSRebindSpecialReference: DoPart --
do
   (if objectTag <> UNKNOWNTAG then
       objectTag->toSpecialObject
    else
       (if typeTag <> UNKNOWNTAG then typeTag->toSpecialType if)
   if);
   (* At this point it is assumed that 'target' now contains the 
    * reference to the object this special reference is 
    * to be rebound to *)
   (if target[] = none then
       PSexception
         (# 
         do
            'handleSpecialReference: User code failed to rebind'->msg.putLine;
            'reference to special object tagged '->msg.putText;
            objectTag->msg.putInt;
            '.'->msg.putLine;
            'Make sure the \'rebindSpecialReference\' virtual'->msg.putLine;
            'has been implemented correctly.'->msg.putLine;
            false->continue;
            
         #)
   if);
     

-- PSregetNotFound: DoPart --
do
   'persistentstore.reget: Root "'->msg.putText;
   fullname[]->msg.putText;
   '" has been overwritten by another client.'->msg.putText;
   'Your references are not longer valid.'->msg.puttext;
   msg[]->putline;
   true->continue;
   INNER  

-- PSOpenOpTypeAlreadyOpen: DoPart --
do
   alreadyOpenMessage->msg.putText;
   fullName[]->msg.putText;
   '" already open'->msg.putText;
   true->continue;
   INNER  

-- PSOpenOpTypeNotFound: DoPart --
do
   notFoundMessage->msg.putText;
   fullName[]->msg.putText;
   '" not found'->msg.putText;
   INNER  

-- PSOpenOpTypeAccessError: DoPart --
do
   accessErrorMessage->msg.putText;
   fullName[]->msg.putText;
   '" '->msg.putText;
   INNER  

-- PSOpenReadAlreadyOpenMessage: DoPart --
do 'persistentstore.openRead: "'->msg[];   

-- PSOpenReadNotFoundMessage: DoPart --
do 'persistentstore.openRead: "'->msg[];   

-- PSOpenReadAccessErrorMessage: DoPart --
do 'persistentstore.openRead: No access to "'->msg[];   

-- PSOpenReadOpenFunc: DoPart --
do (host,path)->SBopen->rcode  

-- PSOpenWriteAlreadyOpenMessage: DoPart --
do 'persistentstore.openWrite: "'->msg[];   

-- PSOpenWriteNotFoundMessage: DoPart --
do 'persistentstore.openWrite: "'->msg[];   

-- PSOpenWriteAccessErrorMessage: DoPart --
do 'persistentstore.openWrite: No access to"'->msg[];   

-- PSOpenWriteOpenFunc: DoPart --
do (host,path)->SBopen->rcode  

-- PSCreateAlreadyOpen: DoPart --
do
   'persistentstore.create: "'->msg.putText;
   fullName[]->msg.putText;
   '" already open'->msg.putText;
   INNER  

-- PSCreateExists: DoPart --
do
   'persistentstore.create: "'->msg.putText;
   fullName[]->msg.putText;
   '" already exists'->msg.putText;
   INNER  

-- PSCreateCreationError: DoPart --
do
   'persistentstore.create: Failed creating "'->msg.putText;
   fullName[]->msg.putText;
   '"'->msg.putText;
   INNER  

-- PSGetQuaError: DoPart --
do
   'persistentstore.get: Qua error getting "'->msg.putText;
   name[]->msg.putText;
   '"'->msg.putText;
   INNER  

-- PSGetNotFound: DoPart --
do
   'persistentstore.get: "'->msg.putText;
   name[]->msg.putText;
   '" not found'->msg.putText;
   INNER  

-- PSPutAlreadyThere: DoPart --
do
   'persistentstore.put: Root "'->msg.putText;
   fullName[]->msg.putText;
   '" '->msg.putText;
   'already there.'->msg.puttext;
   true->continue;
   INNER  

-- PSPutHasOverWritten: DoPart --
do
   'persistentstore.put: Root "'->msg.putText;
   fullName[]->msg.putText;
   '" '->msg.putText;
   'will overwrite an already existing root with same name at checkpoint time.'
     ->msg.puttext;
   true->continue;
   INNER  

-- PSRegisterSpecialAlreadyThere: DoPart --
do
   'registerSpecialObject: Special object "'->msg.putText;
   name[]->msg.putText;
   '" already exists: '->msg.putText;
   INNER ;
   false->continue;
     

-- PSDeletePSAlreadyOpen: DoPart --
do
   'persistentstore.delete: "'->msg.putText;
   fullName[]->msg.putText;
   '" is currently open'->msg.putText;
   INNER ;
     

-- PSDeletePSAccessError: DoPart --
do
   'persistetstore.delete: Unable to delete "'->msg.putText;
   fullName[]->msg.putText;
   '"'->msg.putText;
   INNER ;
     

-- PSDeletePSNotFound: DoPart --
do
   'persistetstore.delete: "'->msg.putText;
   fullName[]->msg.putText;
   '" not found'->msg.putText;
   INNER ;
     

-- PSDeletePersistentStore: DoPart --
do
   assertOpen
     (# 
     do
        name[]->storeDir.name;
        storeDir.delete
          (#
             nosuch:: 
               (# 
               do
                  PSexception
                    (# 
                    do
                       'delete error: '->msg.putText;
                       name[]->msg.putText;
                       ' does not exist'->msg.putText;
                       true->continue;
                       
                    #);
                  
               #);
             error:: 
               (# 
               do
                  PSexception
                    (# 
                    do
                       'delete error: '->msg.putText;
                       name[]->msg.putText;
                       ' could not be deleted (unknown error)'->msg.putText;
                       true->continue;
                       
                    #);
                  
               #);
             
          #);
        
     #);
     

-- PSRegSpecInstanceQuaError: DoPart --
do
   'registerSpecialInstance: Qua error on "'->msg.putText;
   tag->msg.putInt;
   '" instance'->msg.putText;
   INNER ;
   false->continue;
     

-- PSRegSpecInstanceNotFound: DoPart --
do
   'registerSpecialInstance: Special object "'->msg.putText;
   tag->msg.putInt;
   '" not registered.'->msg.putText;
   INNER ;
   false->continue;
     

-- PSRegisterSpecialInstance: DoPart --
do
   (if tag < 256 then
       (tag,%getLongAt (@@ o))->markSpecialObject; 
    else
       PSexception
         (# 
         do
            'registerSpecialInstance: '->msg.putText;
            ' tag ('->msg.putText;
            tag->msg.putInt;
            ') must be less than 256'->msg.putText;
            false->continue;
            
         #);
       
   if);
     

