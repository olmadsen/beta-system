# Makefile-vpath
#
# Top level makefile for making BETA runtime.  This makefile 
# is designed to be called by Makefile-toplev and uses the vpath
# feature

# This makefile requires GNU make or compatible.  If your make
# program barfs on it then that may be the problem.  Set your
# GNUMAKE variable and try again.

# (c) 2000, 2001 Mjølner Informatics
# by Erik Corry


export ARCH
export MAJORARCH
export MINORARCH
export BETALIB
export BETARUN
export RUNTYPE
export PROF
export RTDEBUG
export ALLOC_TRACE
export CDEBUG
export VALHALLA
export UGC
export CFLAGS
export VARIANT
export GNUC
export CP
export RM
export MV
export EXE
export ECHO
export ECHON
export ECHOEND
export ECHONEND
export PWDCMD
export DOTO
export DEBUGOPT
export OPTIMISEOPT

VPATH=$(BETARUN)

.DELETE_ON_ERROR:

ifeq ($(ARCH), nti_ms)
  MAJORARCH=nti
  MINORARCH=ms
  DOTO=obj
  DEBUGOPT=/Yd
  OPTIMISEOPT=/O2
else
  DOTO=o
  DEBUGOPT=-g
  ifeq ($(ARCH), sgi)
    OPTIMISEOPT=-O2
  else
    OPTIMISEOPT=-O6
  endif
  ifeq ($(ARCH), nti_gnu)
    MAJORARCH=nti
    MINORARCH=gnu
  else
    MAJORARCH=$(ARCH)
    MINORARCH=$(ARCH)
  endif
endif

################################ RUN ###########################3
ifeq ($(RUNTYPE), run)

RUNDEPS= \
    RUN/AllocateComponent.run \
    RUN/AllocateDopartObject.run \
    RUN/AllocateItem.run \
    RUN/AllocateHeap.run \
    RUN/AllocateRefRep.run \
    RUN/AllocateStackObject.run \
    RUN/AllocateValRep.run \
    RUN/AllocateObjectRep.run \
    RUN/Attach.run \
    RUN/AttachBasicComponent.run \
    RUN/Basics.run \
    RUN/Callback.run \
    RUN/CInterface.run \
    RUN/CheckReferenceAssignment.run \
    RUN/COM.run \
    RUN/ComponentStack.run \
    RUN/Constant.run \
    RUN/CopyCText.run \
    RUN/CopyRefRep.run \
    RUN/CopySliceRefRep.run \
    RUN/CopySliceValRep.run \
    RUN/CopyText.run \
    RUN/CopyValRep.run \
    RUN/Declaration.run \
    RUN/ExitObjects.run \
    RUN/ExtendRefRep.run \
    RUN/ExtendValRep.run \
    RUN/MakeTextObj.run \
    RUN/Misc.run \
    RUN/NewRefRep.run \
    RUN/NewValRep.run \
    RUN/PerformGC.run \
    RUN/Structure.run \
    RUN/Qua.run \
    RUN/Suspend.run \
    RUN/$(MAINFILE)additions.run

ifeq ($(UGC), yes)
UGCFLAG = -ugc
endif

ifeq ($(RTDEBUG), yes)
DEBUGFLAG = -debug
endif

ifeq ($(ALLOC_TRACE), yes)
ALLOC_TRACEFLAG = -alloc-trace
endif

ifeq ($(CDEBUG), yes)
ifeq ($(ARCH), linux)
CDEBUGFLAG = -g
else
ifeq ($(ARCH), x86sol)
CDEBUGFLAG = -g
else
CDEBUGFLAG = /Zi
endif
endif
endif

ifeq ($(ARCH), linux)
MAINFILE=linux
BETARUNFILE=betarun.o
RUNFILE=run.o
else
ifeq ($(ARCH), x86sol)
MAINFILE=x86sol
BETARUNFILE=betarun.o
RUNFILE=run.o
else
MAINFILE=nti
ifeq ($(ARCH), nti_gnu)
BETARUNFILE=betarun.lib
RUNFILE=run.o
else
BETARUNFILE=betarun.lib
RUNFILE=run.obj
endif # gnu
endif # x86sol
endif # linux

$(BETARUNFILE): $(RUNFILE) C/c.common.o P/c.p.o GC/c.gc.o Makefile-toplev Makefile-vpath
ifeq ($(ARCH), linux)
	ld -x -r -o betarun.o C/c.common.o P/c.p.o GC/c.gc.o $(RUNFILE)
else
ifeq ($(ARCH), x86sol)
	ld -r -o betarun.o C/c.common.o P/c.p.o GC/c.gc.o $(RUNFILE)
else
ifeq ($(ARCH), nti_gnu)
	ar -r betarun.lib C/c.common.o GC/c.gc.o P/c.p.o $(RUNFILE)
else
	-unixrm $@
	unixpwd
	lib -verbose -out:$@ $(RUNFILE) C\\*.obj GC\\*.obj P\\*.obj
endif
endif
endif


$(RUNFILE): run.asm Makefile-vpath
	$(CP) run.asm run.c
ifeq ($(ARCH), linux)
	gcc $(CDEBUGFLAG) -E run.c > run.s
	as -o $(RUNFILE) run.s
else
ifeq ($(ARCH), x86sol)
	gcc $(CDEBUGFLAG) -E run.c > run.s
	gas -o $(RUNFILE) run.s
else
	ml $(CDEBUGFLAG) /c /coff /Cp /nologo /w /Fo$(RUNFILE) /Tarun.asm
endif
endif
#	$(RM) run.c run.s


run.asm: RUN/$(MAINFILE).run $(RUNDEPS) Makefile-vpath #$(BETALIB)/bin/$(ARCH)/rungen$(EXE)
	rungen $(DEBUGFLAG) $(ALLOC_TRACEFLAG) $(UGCFLAG) -o run.asm $(BETARUN)/RUN/$(MAINFILE)

$(BETALIB)/bin/$(ARCH)/rungen$(EXE): $(BETARUN)/GEN/GRAMMAR/runtime.astL $(BETARUN)/GEN/GRAMMAR/runtime-parser.btabL
	( cd $(BETARUN)/GEN/$(MAJORARCH); beta -o gen.$(ARCH)$(EXE) gen )
	$(MV) $(BETARUN)/GEN/$(MAJORARCH)/gen.$(ARCH)$(EXE) $(BETALIB)/bin/$(ARCH)/rungen$(EXE)

$(BETARUN)/GEN/GRAMMAR/runtime.astL:
	#(cd $(BETARUN); $(BETALIB)/boot/bin/$(ARCH)/generator -metagram $(BETALIB)/boot/grammars/metagrammar/metagrammar runtime )
	(cd $(BETARUN)/GEN/GRAMMAR/; generator runtime )

$(BETARUN)/GEN/GRAMMAR/runtime-parser.btabL:
	#(cd $(BETARUN); $(BETALIB)/boot/bin/$(ARCH)/bobsit -metagram $(BETALIB)/boot/grammars/metagrammar/metagrammar runtime )
	(cd $(BETARUN)/GEN/GRAMMAR/; bobsit runtime )



endif # run

################################ CRUN ###########################3
ifeq ($(RUNTYPE), crun)

betarun.$(BETARUN_SUFFIX): C/c.common.o CRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	-$(RM) betarun.a C/c.common.o CRUN/c.run.o GC/c.gc.o P/c.p.o
ifeq ($(BETARUN_SUFFIX), a)
	ar -r betarun.a C/*.o GC/*.o CRUN/*.o P/*.o
else
	ld -r -o betarun.o C/*.o GC/*.o CRUN/*.o P/*.o
endif

endif # crun

################################ NEWRUN ###########################3
ifeq ($(RUNTYPE), newrun)

ifeq ($(ARCH), sgi)
ABI = -32
export ABI
endif # sgi

betarun.o: C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	ld $(ABI) -r -o betarun.o C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o

betarun.a: C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	$(MV) C/end.o end.o
	$(RM) C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o betarun.a
	ar -r betarun.a C/*.o GC/*.o NEWRUN/*.o P/*.o

endif # newrun

################################ Common stuff ###########################3

C/c.common.o::
	@mbs_mkdir C
	@cd C; $(MAKE) -j2 -f $(BETARUN)/C/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS)

CRUN/c.run.o::
	@mbs_mkdir CRUN
	@cd CRUN; $(MAKE) -j2 -f $(BETARUN)/CRUN/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS)

NEWRUN/c.run.o::
	@mbs_mkdir NEWRUN
	@cd NEWRUN; $(MAKE) -j2 -f $(BETARUN)/NEWRUN/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS)

P/c.p.o::
	@mbs_mkdir P
	@cd P; $(MAKE) -j2 -f $(BETARUN)/P/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS)

GC/c.gc.o::
	@mbs_mkdir GC
	@cd GC; $(MAKE) -j2 -f $(BETARUN)/GC/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS)

# Unix-only at the moment.  TODO redo grep with perl
# Can we assume diff -u possible (GNU diff)? 
check::
	@$(ECHO) generating list of undefined labels $(ECHOEND)
	@nm betarun.o | grep ' U ' > .new-undefined
	@$(ECHO) find difference between .old-undefined and .new-undefined $(ECHOEND)
	@diff .old-undefined .new-undefined

gendef::
	@$(ECHO) generating list of undefined labels $(ECHOEND)
	@nm betarun.o | grep ' U ' > .old-undefined

clean::
ifeq ($(ARCH), nti_gnu)
	$(RM) *.obj
else
ifeq ($(ARCH), nti_ms)
	-$(RM) *.obj *.gen *.asm
else
	-$(RM) *.o *.a *.gen *.asm
endif
endif
	cd P; $(MAKE) -f $(BETARUN)/P/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) clean
	cd C; $(MAKE) -f $(BETARUN)/C/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) clean
	cd GC; $(MAKE) -f $(BETARUN)/GC/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) clean
	cd CRUN; $(MAKE) -f $(BETARUN)/CRUN/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) clean
	cd NEWRUN; $(MAKE) -f $(BETARUN)/CRUN/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) clean
