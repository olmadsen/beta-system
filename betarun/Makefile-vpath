# Top level makefile for making BETA runtime.  This makefile 
# is designed to be called by Makefile-toplev and uses the vpath
# feature

# This makefile requires GNU make or compatible.  If your make
# program barfs on it then that may be the problem.  Set your
# GNUMAKE variable and try again.

# (c) 2000, 2001 Mjølner Informatics
# by Erik Corry


export ARCH
export BETALIB
export BETARUN
export RUNTYPE
export PROF
export RTDEBUG
export CDEBUG
export VALHALLA
export UGC
export CFLAGS
export VARIANT
export GNUC
export CP
export RM
export MV
export EXE
export ECHO
export ECHON
export ECHOEND
export ECHONEND
export PWDCMD

VPATH=$(BETARUN)

.DELETE_ON_ERROR:

################################ RUN ###########################3
ifeq ($(RUNTYPE), run)

RUNDEPS= \
    RUN/AllocateComponent.run \
    RUN/AllocateDopartObject.run \
    RUN/AllocateItem.run \
    RUN/AllocateHeap.run \
    RUN/AllocateRefRep.run \
    RUN/AllocateStackObject.run \
    RUN/AllocateValRep.run \
    RUN/AllocateObjectRep.run \
    RUN/Attach.run \
    RUN/AttachBasicComponent.run \
    RUN/Basics.run \
    RUN/Callback.run \
    RUN/CInterface.run \
    RUN/CheckReferenceAssignment.run \
    RUN/COM.run \
    RUN/ComponentStack.run \
    RUN/Constant.run \
    RUN/CopyCText.run \
    RUN/CopyRefRep.run \
    RUN/CopySliceRefRep.run \
    RUN/CopySliceValRep.run \
    RUN/CopyText.run \
    RUN/CopyValRep.run \
    RUN/Declaration.run \
    RUN/ExitObjects.run \
    RUN/ExtendRefRep.run \
    RUN/ExtendValRep.run \
    RUN/MakeTextObj.run \
    RUN/Misc.run \
    RUN/NewRefRep.run \
    RUN/NewValRep.run \
    RUN/PerformGC.run \
    RUN/Structure.run \
    RUN/Qua.run \
    RUN/Suspend.run \
    RUN/$(ARCH)additions.run

ifeq ($(UGC), yes)
UGCFLAG = -ugc
endif

ifeq ($(RTDEBUG), yes)
DEBUGFLAG = -debug
endif

ifeq ($(CDEBUG), yes)
ifeq ($(ARCH), linux)
CDEBUGFLAG = -g
else
CDEBUGFLAG = /Zi
endif
endif

ifeq ($(ARCH), linux)
MAINFILE=linux
BETARUNFILE=betarun.o
RUNFILE=run.o
else
MAINFILE=nti
ifeq ($(ARCH), nti_gnu)
BETARUNFILE=betarun.o
RUNFILE=run.o
else
BETARUNFILE=betarun.lib
RUNFILE=run.obj
endif # gnu
endif # linux

$(BETARUNFILE): $(RUNFILE) C/c.common.o P/c.p.o GC/c.gc.o Makefile-toplev Makefile-vpath
ifeq ($(ARCH), linux)
	ld -x -r -o betarun.o C/c.common.o P/c.p.o GC/c.gc.o $(RUNFILE)
else
ifeq ($(ARCH), nti_gnu)
	ar -r betarun.o C/*.o GC/*.o P/*.o $(RUNFILE)
else
	lib -verbose -out:$@ $(RUNFILE) C\*.obj $(BASEDIR)\GC\*.obj  $(BASEDIR)\P\*.obj
endif
endif


run.o: run.asm Makefile-vpath
	$(CP) run.asm run.c
ifeq ($(ARCH), linux)
	gcc $(CDEBUGFLAG) -E run.c > run.s
	as -o run.o run.s
else
	ml $(CDEBUGFLAG) /c /coff /Cp /nologo /w /Forun.o /Tarun.asm
endif
#	$(RM) run.c run.s


run.asm: RUN/$(ARCH).run $(RUNDEPS) Makefile-vpath #$(BETALIB)/bin/$(ARCH)/rungen$(EXE)
	rungen $(DEBUGFLAG) $(UGCFLAG) -o run.asm $(BETARUN)/RUN/$(MAINFILE)

$(BETALIB)/bin/$(ARCH)/rungen$(EXE): $(BETARUN)/GEN/GRAMMAR/runtime.astL runtime-parser.btabL
	( cd $(BETARUN)/GEN/linux; bootbeta -o gen.$(ARCH) gen )
	( cd $(BETARUN)/GEN/linux; $(MV) gen.$(ARCH) $(BETALIB)/bin/$(ARCH)/rungen$(EXE) )

$(BETARUN)/GEN/GRAMMAR/runtime.astL:
	(cd $(BETARUN); $(BETALIB)/boot/bin/$(ARCH)/generator -metagram $(BETALIB)/boot/grammars/metagrammar/metagrammar runtime )

$(BETARUN)/GEN/GRAMMAR/runtime-parser.btabL:
	(cd $(BETARUN); $(BETALIB)/boot/bin/$(ARCH)/bobsit -metagram $(BETALIB)/boot/grammars/metagrammar/metagrammar runtime )



endif # run

################################ CRUN ###########################3
ifeq ($(RUNTYPE), crun)

betarun.$(BETARUN_SUFFIX): C/c.common.o CRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	-$(RM) betarun.a C/c.common.o CRUN/c.run.o GC/c.gc.o P/c.p.o
ifeq ($(BETARUN_SUFFIX), a)
	ar -r betarun.a C/*.o GC/*.o CRUN/*.o P/*.o
else
	ld -r -o betarun.o C/*.o GC/*.o CRUN/*.o P/*.o
endif

endif # crun

################################ NEWRUN ###########################3
ifeq ($(RUNTYPE), newrun)

ifeq ($(ARCH), sgi)
ABI = -32
export ABI
endif # sgi

betarun.o: C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	ld $(ABI) -r -o betarun.o C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o

betarun.a: C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o Makefile-vpath
	$(MV) C/end.o end.o
	$(RM) C/c.common.o NEWRUN/c.run.o GC/c.gc.o P/c.p.o betarun.a
	ar -r betarun.a C/*.o GC/*.o NEWRUN/*.o P/*.o

endif # newrun

################################ Common stuff ###########################3

C/c.common.o::
	@mbs_mkdir C
	@cd C; $(MAKE) -f $(BETARUN)/C/Makefile-vpath

CRUN/c.run.o::
	@mbs_mkdir CRUN
	@cd CRUN; $(MAKE) -f $(BETARUN)/CRUN/Makefile-vpath

NEWRUN/c.run.o::
	@mbs_mkdir NEWRUN
	@cd NEWRUN; $(MAKE) -f $(BETARUN)/NEWRUN/Makefile-vpath

P/c.p.o::
	@mbs_mkdir P
	@cd P; $(MAKE) -f $(BETARUN)/P/Makefile-vpath

GC/c.gc.o::
	@mbs_mkdir GC
	@cd GC; $(MAKE) -f $(BETARUN)/GC/Makefile-vpath

# Unix-only at the moment.  TODO redo grep with perl
# Can we assume diff -u possible (GNU diff)? 
check::
	@$(ECHO) generating list of undefined labels $(ECHOEND)
	@nm betarun.o | grep ' U ' > .new-undefined
	@$(ECHO) find difference between .old-undefined and .new-undefined $(ECHOEND)
	@diff .old-undefined .new-undefined

gendef::
	@$(ECHO) generating list of undefined labels $(ECHOEND)
	@nm betarun.o | grep ' U ' > .old-undefined

clean::
ifeq ($(ARCH), nti_gnu)
	$(RM) *.obj
else
ifeq ($(ARCH), nti_ms)
	-$(RM) *.obj *.gen *.asm
else
	-$(RM) *.o *.a *.gen *.asm
endif
endif
	cd P; $(MAKE) -f $(BETARUN)/P/Makefile-vpath clean
	cd C; $(MAKE) -f $(BETARUN)/C/Makefile-vpath clean
	cd GC; $(MAKE) -f $(BETARUN)/GC/Makefile-vpath clean
	cd CRUN; $(MAKE) -f $(BETARUN)/CRUN/Makefile-vpath clean
