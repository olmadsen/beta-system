/*
 * BETA RUNTIME SYSTEM, Copyright (C) 1991-94 Mjolner Informatics Aps.
 * data.gen
 * by Lars Bak, Peter Andersen, Peter Orbaek Tommy Thorn and S|ren Brandt
 */

/* Vars to cope with the Infant Object Area and ToSpace */

Var( AOAMaxSize, unsigned long, AOAMAXSIZE); /* Max size of AOA using mmap */
#ifdef sparc
Var( IOASize,  long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
#ifdef MT
Var( NumIOASlices, long, 0);
Var( IOASliceSize, long, 0);
Var( gIOALimit, long*, 0);
Var( gIOATop, long*, 0);
Var( gIOA, long*, 0);
/* synchronization variables */
UVar( tsd_lock, mutex_t);
UVar( lvra_lock, mutex_t);
UVar( aoa_lock, mutex_t);
UVar( aoatoioa_lock, mutex_t);
UVar( cbfa_lock, mutex_t);


#ifdef OURSEMAIMPL
 UVar( cond_pause_lock, mutex_t );
 UVar( cond_pause, cond_t);
#else
 UVar( GC_lock, mutex_t);
 UVar( ioa_lock, mutex_t);
 UVar( cond_startGC, cond_t);
 UVar( cond_startGC_lock, mutex_t);
 UVar( cond_GCdone, cond_t);
 UVar( cond_GCdone_lock, mutex_t);
#endif

#else
Var( IOALimit, long*, 0);
#endif /* MT */
#endif

#ifdef RUN
Var( IOASize,  long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
Var( IOA,          Cell *, 0); 
Var( IOATop,       Cell *, 0);
Var( IOALimit,     Cell *, 0);
#endif /* RUN */

#ifdef hppa
Var( IOA,          Cell *, 0); 
Var( IOATop,       Cell *, 0);
Var( IOALimit,     Cell *, 0);
Var( IOASize,      long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
#endif

#ifdef NEWRUN
Struct( _IOA,     Heap, 0, 0, 0, DEFAULT_IOASIZE);
#endif /* NEWRUN */

Var( ToSpace,      Cell *, 0);
Var( ToSpaceTop,   Cell *, 0);
Var( ToSpaceLimit, Cell *, 0);

Var( IOALooksFullCount, int, 0); /* consecutive unsuccessful IOAGc's */

/* Used to build AOAroots table. */
Var( AOArootsPtr,   Cell *, 0);

/* Used for temporary AOAroots table in case of overflow in ToSpace */
Var( tempAOAroots, Cell *, 0); 

/* Points to either end of tempAOAroots or end of ToSpace*/
Var( AOArootsLimit, Cell *, 0); 

Array( IOAAgeTable, IOAMaxAge+1, Cell);  /* +1 as objectage=MaxAge happens */
Var( IOAtoAOAtreshold, Cell, IOAMaxAge); /* Age to tenure objects in IOA. */
Var( IOAActive, Cell, FALSE);            /* Tells if IOAGc is active. */
Var( inIOAGc, Cell, FALSE);              
Var( DoUGC, Cell, 1);            
Var( BetaErrorString, char *, 0);        /* Last BetaError encountered */

Var( CBFA,      struct _CallBackArea *,  0);  /* Pointer to the first Call Back Functions Area. */
Var( CBFATop,   struct _CallBackEntry *, 0);  /* Pointer to the top of last CBFA heap. */
Var( CBFALimit, struct _CallBackEntry *, 0);  /* The upper bound of the last CBFA heap. */

Var( DOTSize,       long, 0); /* Number of elements in Debug Object Table */
Var( DOT,      Cell *, 0); /* Pointer to the Debugger Object Table. */
Var( DOTTop,   Cell *, 0); /* Pointer to the top of DOT. */
Var( DOTLimit, Cell *, 0); /* The upper bound of DOTTop. */

#ifdef RTVALHALLA
Var( valhallaID, char *, 0); 
/* Identifies valhalla process if this process is being debugged. */
Var( valhallaIsStepping, Cell, FALSE); 
/* TRUE iff valhalla should be informed on a number of occations. */
Var( valhalla_exelevel, int, 0);
/* Current number of active evaluators */
Var( ProfBetaStackTop, unsigned long, 0);

#endif /* RTVALHALLA */

Var( SimpleDump, int, 0);
Var( NoDumpDialog, int, 0);
Var( isMakingDump, int, 0);
Var( isHandlingException, int, 0);
/* Error-pc is used to remember original PC when the error happened */
Var( error_pc, unsigned long, 0);


Var( QuaDstOrigin, struct _Object *, 0);
Var( QuaDstProto, struct _ProtoType *, 0);
Var( QuaSrc, struct _Object *, 0);
Var( RangeErr, int, 0);
Var( SubRangeErrLow, int, 0);
Var( SubRangeErrHigh, int, 0);
Var( RangeMax, int, 0);

Var( mmapHeap,      void *, 0);
Var( mmapHeapTop,   void *, 0);
Var( mmapHeapLimit, void *, 0);
Var( IOABaseBlock, struct _Block *, 0);
Var( ToSpaceBaseBlock, struct _Block *, 0);
Var( AOABaseBlock, struct _Block *, 0);
Var( AOATopBlock,  struct _Block *, 0);

Var( AOAtoIOAtable, struct _Block *, 0);  /* Point out roots from AOA to IOA.  */
Var( AOAtoIOAtableSize, Cell, 0); /* The size of the table (prime).    */
Var( AOAtoIOACount, Cell, 0);

#ifdef intel
Var( pReg1, struct _Object *, 0);
Var( pReg2, struct _Object *, 0);
Var( pReg3, struct _Object *, 0);
Var( pReg4, struct _Object *, 0);
Var( pReg5, struct _Object *, 0);
Var( pReg6, struct _Object *, 0);
Var( a1, struct _Object *, 0);
Var( a2, struct _Object *, 0);
Var( a3, struct _Object *, 0);
Var( a4, struct _Object *, 0);
Var( a5, struct _Object *, 0);
Var( a6, struct _Object *, 0);
Var( a7, struct _Object *, 0);
Var( d0, struct _Object *, 0);
Var( d1, struct _Object *, 0);
Var( d2, struct _Object *, 0);
Var( d3, struct _Object *, 0);
Var( d4, struct _Object *, 0);
Var( d5, struct _Object *, 0);
Var( d6, struct _Object *, 0);
#endif /* intel */

Var( AOANeedCompaction,  unsigned long, 0);

Var( CBFABlockSize, long, DEFAULT_CBFASIZE);/* Size of each CBF block.  */

Var( AOABlocks, long, 0); /* Number of allocated blocks in AOA */
Var( LVRSizeSum, long, 0);
Var( sizeOfObjectsInAOA, long, 0);
Var( objectsInAOA, long, 0);
Var( collectedMem, long, 0);
Var( largestFreeChunk, long, 0);	
Var( totalAOASize, long,  0);

Var( IOAPercentage,  long, DEFAULT_IOAPERCENTAGE);

Var( AOAMinFree,     long, DEFAULT_AOAMINFREE);
Var( AOAPercentage,  long, DEFAULT_AOAPERCENTAGE);

#ifdef MT
Var( NumTSD, long, 0);
Var( TSDlistlen, long, 0);

Var( TSDlist, struct _TSD**, 0);
#else
Var( ActiveComponent, struct _Component *, 0); /* The Active component.    */
/* datpete 23/5/95: Changed declaration to use longs to ensure
 * long alignment
 */
#ifdef RUN /* Grouleff 12/3/2001 */
Var( CTextPoolSize, long, 1);
Var( Maxctextpool, long, 0);
#endif /* RUN */
Var( CTextPool, char*, 0);
Var( CTextPoolEnd, char *, 0);
#endif /* MT */

#if defined(NEWRUN) || defined(intel)
Var( ReferenceStack, struct _Object**, 0); 
Var( RefSP, struct _Object**, 0);
#endif /* NEWRUN || (RTVALHALLA && intel) */

#ifdef NEWRUN 
Var( CompStack, long*, 0); 
Var( CompSP, long*, 0);
#endif /* NEWRUN */

#ifdef NEWRUN
Array( BetaStackTop, 2, long *); 
#else
#ifndef MT
Var( BetaStackTop, long *, 0);
#endif
#endif /* NEWRUN */

#ifndef MT
Var( StackEnd,   long *, 0);
#endif /* MT */

#ifdef UseRefStack
Array( ReferenceStack, REFSTACKSIZE, void *); /* ugly const, should be malloced() */
Var( RefSP, long *, (long *)&ReferenceStack[0] );
#endif /* UseRefStack */

#ifdef NEWRUN
Var( StackStart, long *, 0);
Var( StackEndAtSignal, long *, 0);
#else
#ifndef MT
Var( ActiveCallBackFrame, struct _CallBackFrame *, 0);
Var( StackStart, Cell, 0);
#endif
#endif

Var( HandledInToSpace, Cell *, 0);     /* Used during scavenging.     */
Var( HandledInAOAHead,struct _Object *, 0);     /* Used during
                                            * scavenging. Is a pointer
                                            * to the last object
                                            * inserted in AOA, that
                                            * has been handled by
                                            * IOAGC */
Var( HandledInAOATail,struct _Object *, 0);     /* Used during
                                            * scavenging. Is a pointer
                                            * to the last object
                                            * inserted in AOA.
                                            */

Var( ReqObjectSize, unsigned long, 0);

#if !defined(NEWRUN) && !defined(MT)
Var( lastCompBlock, struct _ComponentBlock *, 0);
#endif

Var( BasicItem, struct _Item *, 0);

#ifdef NEWRUN
Var( BasicProto, struct _ProtoType *, 0);
Var( CurrentObject, struct _Object *, 0);
#endif

Var( TextProto, struct _ProtoType *, 0);

Var( ArgCount, Cell, 0);
Var( ArgVector, char **, 0);
Var( XcallName, char *, 0);
Var( XcallNum, long, 0);

#ifdef GATHERSTAT
struct _IOSStatistic IOAStat;
#endif

Var( QuaCont, Cell, FALSE);
Var( noAOAGC, Cell, FALSE);
Var( forceAOAGC, Cell, FALSE);

#ifdef sparc
Var( SuspCont, Cell, FALSE);
#endif

#ifdef RTINFO
#if defined(nti_gnu) || defined(linux)
Var( output, FILE *, 0);
#else
Var( output, FILE *, stderr);
#endif
Var( Info0, Cell, FALSE);
Var( InfoIOA, Cell, FALSE);
Var( InfoAOA, Cell, FALSE);
Var( InfoAOAUse, Cell, FALSE);
Var( InfoVars, Cell, FALSE);
Var( StatAOA, Cell, FALSE);
Var( InfoCBFA, Cell, FALSE);
Var( InfoHeapUsage, Cell, FALSE);
Var( DebugStrongIsObject, Cell, FALSE);
Var( isStatRecordOn, Cell, FALSE);
Var( InfoDOT, Cell, FALSE);
Var( InfoLabels, Cell, FALSE);
Var( NoCatchException, Cell, FALSE);
Var( SkipDumpStack, long, FALSE);
#endif
Var( TraceFindActivation, Cell, FALSE);
#ifdef PROTO_STATISTICS
Var( ProtoStatistics, Cell, TRUE);
#endif /* PROTOSTATISTICS */

#ifdef nti
Var (beta_instance, Cell, 0);
Var (beta_previnstance, Cell, 0);
Var (beta_cmdline, char *, 0);
Var (beta_show, Cell, 0);
#endif

#ifdef RTDEBUG
Var( DebugIOA,  Cell, FALSE);
Var( CheckHeap,  Cell, FALSE);
Var( PrintStackAtIllegal,  Cell, FALSE);
Var( StopAtIllegal,  Cell, FALSE);
Var( DebugAlloI,  Cell, FALSE);
Var( DebugCBFA,  Cell, FALSE);
Var( dump_aoa, long, 0);
Var( DumpAOA,  Cell, FALSE);
Var( DebugAOA,  Cell, FALSE);
Var( DebugAOAtoIOA,  Cell, FALSE);
Var( DebugLIN, Cell, FALSE);
Var( DebugStack, Cell, FALSE);
Var( DebugStackObj, Cell, FALSE);
Var( DebugSockets, Cell, FALSE);
Var( DebugLabels, Cell, FALSE);
Var( TraceGroup, Cell, FALSE);
Var( TraceDump, Cell, FALSE);
Var( TraceCodeentry, Cell, FALSE);
Var( FastIsObject, Cell, FALSE);
Var( NoHeapClear, Cell, FALSE);
#ifdef MT
Var( DebugMT, Cell, FALSE);
#endif
Var( DebugStackAtGcNum, long, 0);
Var( AOAcopied,  Cell, 0);
Var( IOAcopied,  Cell, 0);
#ifdef RTVALHALLA
Var( DebugValhalla, Cell, FALSE);
Var( TraceValhallaComm, Cell, FALSE);

#endif
#endif /* RTDEBUG */

Var( NumIOAGc,          long, 0);
Var( NumAOAGc,          long, 0);
Var( NumAOAtoIOAInsert, long, 0);

/* need to declare Num* always because RUN based routines
 * reference it even if it is not updated.
 */
#if (defined(RTDEBUG) || defined(RUN))
#ifndef MT
Var( NumAlloI,		long, 0);
Var( NumAlloCOM,	long, 0);
Var( NumAlloC,  	long, 0);
Var( NumAlloDO, 	long, 0);
Var( NumAlloRR, 	long, 0);
Var( NumAlloVR1,	long, 0);
Var( NumAlloVR2,	long, 0);
Var( NumAlloVR4,	long, 0);
Var( NumAlloVR8,	long, 0);
Var( NumAlloVRI,	long, 0);
Var( NumAlloVRC,	long, 0);
Var( NumCopyCT, 	long, 0);
Var( NumCopyRR,		long, 0);
Var( NumCopySRR,	long, 0);
Var( NumCopySVR1,	long, 0);
Var( NumCopySVR2,	long, 0);
Var( NumCopySVR4,	long, 0);
Var( NumCopySVR8,	long, 0);
Var( NumCopySVRI,	long, 0);
Var( NumCopySVRC,	long, 0);
Var( NumCopyT,		long, 0);
Var( NumCopyVR1,	long, 0);
Var( NumCopyVR2,	long, 0);
Var( NumCopyVR4,	long, 0);
Var( NumCopyVR8,	long, 0);
Var( NumCopyVRI,	long, 0);
Var( NumCopyVRC,	long, 0);
Var( NumExtRR,		long, 0);
Var( NumExtVR1,		long, 0);
Var( NumExtVR2,		long, 0);
Var( NumExtVR4,		long, 0);
Var( NumExtVR8,		long, 0);
Var( NumExtVRI,		long, 0);
Var( NumExtVRC,		long, 0);
Var( NumMkTO,		long, 0);
Var( NumNewRR,		long, 0);
Var( NumNewVR1,		long, 0);
Var( NumNewVR2,		long, 0);
Var( NumNewVR4,		long, 0);
Var( NumNewVR8,		long, 0);
Var( NumNewVRI,		long, 0);
Var( NumNewVRC,		long, 0);
Var( NumAlloS,		long, 0);
Var( NumThisS,		long, 0);
Var( NumObjS,		long, 0);
Var( NumAlloSICB,	long, 0);
Var( NumAlloSI,		long, 0);
Var( NumAlloSC,		long, 0);
Var( NumAlloSO,		long, 0);
Var( NumleS,		long, 0);
Var( NumgeS,		long, 0);
Var( NumgtS,		long, 0);
Var( NumltS,		long, 0);
Var( NumeqS,		long, 0);
Var( NumneS,		long, 0);
Var( NumQua,		long, 0);
Var( NumReturn,		long, 0);
Var( NumRefNone,	long, 0);
Var( NumCopyCPP,	long, 0);
Var( NumCinitT,		long, 0);
Var( NumCpkVT,		long, 0);
Var( NumCpkSVT,		long, 0);
#ifdef MAC
Var( NumPpkVT,		long, 0);
Var( NumPpkCT,		long, 0);
Var( NumPpkSVT,		long, 0);
Var( NumCopyPPP,	long, 0);
#endif
Var( NumChkRA,		long, 0);
Var( NumExO,		long, 0);
Var( NumSusp,		long, 0);
Var( NumAtt,		long, 0);
Var( NumTermComp,	long, 0);
Var( NumAOAAlloc,	long, 0);
#endif /* MT */
#endif /* RTDEBUG */

#ifdef PROTO_STATISTICS
Var( proto_list,        struct _ProtoValue **, NULL);
Var( proto_num_elems,   long, 0);
Var( proto_size,        long, 0);
#endif /* PROTO_STATISTICS */

#ifdef PERSIST
#ifdef RTINFO
Var(InfoPersistence, long, FALSE);
Var(numPF, int, 0);
Var(objectsLoaded, int, 0);
Var(objectsExported, int, 0);
#endif /* RTINFO */
Var( repeatIOAGc, int, 0);
Var( dontCheckProtoTypes, Cell, FALSE);
Var( BETAREENTERED, long, FALSE);
Func ( struct _Object *(*callRebinderC)(unsigned long tag), 0 );
Func ( void (*callOpenCrossStoreC)(char *host, char *path), 0 );
#endif /* PERSIST */

/* Persistence, but as RUN refers them, declare them unconditionally */
Var( PIT, void *, NULL);
Var( PITLimit, void *, NULL); 

Var(ioatime, int, 0);
Var(aoatime, int, 0);
Var(timeIOA, int, FALSE);
Var(timeAOA, int, FALSE);
