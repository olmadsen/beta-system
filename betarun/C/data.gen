/*
 * BETA RUNTIME SYSTEM, Copyright (C) 1991-94 Mjolner Informatics Aps.
 * data.gen
 * by Lars Bak, Peter Andersen, Peter Orbaek Tommy Thorn and S|ren Brandt
 */

/* Vars to cope with the Infant Object Area and ToSpace */

#ifdef sparc
Var( IOASize,  long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
#ifdef MT
Var( NumIOASlices, long, 0);
Var( IOASliceSize, long, 0);
Var( gIOALimit, long*, 0);
Var( gIOATop, long*, 0);
Var( gIOA, long*, 0);
/* synchronization variables */
UVar( tsd_lock, mutex_t);
UVar( ioa_lock, mutex_t);
UVar( lvra_lock, mutex_t);
UVar( aoa_lock, mutex_t);
UVar( aoatoioa_lock, mutex_t);
UVar( cbfa_lock, mutex_t);
UVar( GC_lock, mutex_t);

UVar( cond_startGC, cond_t);
UVar( cond_startGC_lock, mutex_t);
UVar( cond_GCdone, cond_t);
UVar( cond_GCdone_lock, mutex_t);
#else
Var( IOALimit, long*, 0);
#endif /* MT */
#endif

#ifdef RUN
Var( IOASize,  long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
#ifdef mac68k
/* This fucking macintosh mpw-c-compiler allocate variables in 
 * reverse order, so because we use cmp2.l IOA,ax in the 
 * compiler and runtimesystem, we need to reverse the order
 * in the source code. (bull shit)
 */
Var( IOALimit,     ptr(Cell), 0);
Var( IOATop,       ptr(Cell), 0);
Var( IOA,          ptr(Cell), 0); 
#else
/* RUN based other than mac */
Var( IOA,          ptr(Cell), 0); 
Var( IOATop,       ptr(Cell), 0);
Var( IOALimit,     ptr(Cell), 0);
#endif /* mac68k */
#endif /* RUN */

#ifdef hppa
Var( IOA,          ptr(Cell), 0); 
Var( IOATop,       ptr(Cell), 0);
Var( IOALimit,     ptr(Cell), 0);
Var( IOASize,      long, DEFAULT_IOASIZE); /* Size of IOA and ToSpace. */
#endif

#ifdef NEWRUN
Struct( _IOA,     Heap, 0, 0, 0, DEFAULT_IOASIZE);
#endif /* NEWRUN */

Var( ToSpace,      ptr(Cell), 0);
Var( ToSpaceTop,   ptr(Cell), 0);
Var( ToSpaceLimit, ptr(Cell), 0);

Var( AOArootsPtr,   ptr(Cell), 0); /* Used to build AOAroots table. */

/* Used for temporary AOAroots table in case of overflow in ToSpace */

Var( tempAOAroots, ptr(Cell), 0); 

/* Points to either end of tempAOAroots or end of ToSpace*/

Var( AOArootsLimit, ptr(Cell), 0); 

#ifdef KEEP_STACKOBJ_IN_IOA
Var( IOAStackObjectNum, long, 0 );
Var( IOAStackObjectSum, long, 0 );
#endif

Array( IOAAgeTable, IOAMaxAge, Cell);
Var( IOAtoAOAtreshold, Cell, IOAMaxAge); /* Age to tenure objects in IOA. */
Var( IOAActive, Cell, FALSE);            /* Tells if IOAGc is active. */
Var( BetaErrorString, char *, 0);            /* Last BetaError encountered */

Var( CBFA,      ref(CallBackArea),  0);  /* Pointer to the first Call Back Functions Area. */
Var( CBFATop,   ref(CallBackEntry), 0);  /* Pointer to the top of last CBFA heap. */
Var( CBFALimit, ref(CallBackEntry), 0);  /* The upper bound of the last CBFA heap. */

Var( DOTSize,       long, 0); /* Number of elements in Debug Object Table */
Var( DOT,      ptr(Cell), 0); /* Pointer to the Debugger Object Table. */
Var( DOTTop,   ptr(Cell), 0); /* Pointer to the top of DOT. */
Var( DOTLimit, ptr(Cell), 0); /* The upper bound of DOTTop. */

#ifdef RTVALHALLA
Var( valhallaID, char *, 0); 
/* Identifies valhalla process if this process is being debugged. */
Var( valhallaIsStepping, Cell, FALSE); 
/* TRUE iff valhalla should be informed on a number of occations. */
#endif /* RTVALHALLA */

Var( AOABaseBlock, ref(Block), 0);
Var( AOATopBlock,  ref(Block), 0);

Var( AOAtoLVRAtable, ptr(Cell), 0); /* Used to build LVRAtoIOA table. */
Var( AOAtoLVRAsize,  Cell, 0);

Var( AOAtoIOAtable, ref(Block), 0);  /* Point out roots from AOA to IOA.  */
Var( AOAtoIOAtableSize, Cell, 0); /* The size of the table (prime).    */
Var( AOAtoIOACount, Cell, 0);

#ifdef i386
Var( pReg1, ref(Object), 0);
Var( pReg2, ref(Object), 0);
Var( pReg3, ref(Object), 0);
Var( pReg4, ref(Object), 0);
Var( pReg5, ref(Object), 0);
Var( a2, ref(Object), 0);
Var( a3, ref(Object), 0);
Var( a4, ref(Object), 0);
Var( d0, ref(Object), 0);
Var( d1, ref(Object), 0);
Var( d2, ref(Object), 0);
Var( d3, ref(Object), 0);
Var( d4, ref(Object), 0);
Var( d5, ref(Object), 0);
#endif /* i386 */

#ifdef RTLAZY
/* Point out dangling references in AOA. This table is kept up-to-date
 * permanently by ChkRA, ProcessAOAReference, assignRef, AOAGc.
 */
Var( negAOArefs, ptr(Cell), 0);    
/* Point out dangling references NOT in AOA. This table is regenerated in
 * each IOAGc..
 */
Var( negAOAsize, Cell, 0); /* Size of negAOArefs table. */

Var( negIOArefs, ptr(Cell), 0);   

/* Function pointers for handling lazy references.
 * When a persistent store with lazy fetch is initialized, these are
 * set up to point to functions in lazyref_gc.c.
 */
#ifdef hppa
Func ( void (* negAOArefsINSERT) (), 0 );
Func ( int (* findDanglingProto) (), 0 );
Func ( void (* negIOArefsINSERT) (), 0 );
Func ( void (* negAOArefsRESET) (), 0 );
#else
Func ( void (* negAOArefsINSERT) (long), 0 );
Func ( int (* findDanglingProto) (int), 0 );
Func ( void (* negIOArefsINSERT) (long), 0 );
Func ( void (* negAOArefsRESET) (void), 0 );
#endif
Var ( LazyDangler, volatile int, 0 );
Var( lastDangler, long, -101); /* Must be less than least value in betaerror.h */
Var( LazyItem, ref(Item), 0); /* BETA object called to fetch objects. GC root. */
#endif

Var( LVRANeedCompaction, Cell, FALSE);
Var( AOANeedCompaction,  Cell, FALSE);

Var( AOABlockSize,  long, DEFAULT_AOASIZE); /* Size of each AOA  block. */
Var( LVRABlockSize, long, DEFAULT_LVRASIZE);/* Size of each LVRA block. */
Var( CBFABlockSize, long, DEFAULT_CBFASIZE);/* Size of each CBF block.  */

Var( IOAPercentage,  long, DEFAULT_IOAPERCENTAGE);

Var( AOAMinFree,     long, DEFAULT_AOAMINFREE);
Var( AOAPercentage,  long, DEFAULT_AOAPERCENTAGE);

Var( LVRAMinFree,    long, DEFAULT_LVRAMINFREE);
Var( LVRAPercentage, long, DEFAULT_LVRAPERCENTAGE);

#ifdef MT
Var( NumTSD, long, 0);
Var( TSDlistlen, long, 0);

Var( TSDlist, struct TSD**, 0);
#else
Var( MallocExhausted, long, FALSE);         /* Tells is malloc failed.  */
Var( ActiveComponent, ref(Component), 0); /* The Active component.       */
/* datpete 23/5/95: Changed declaration to use longs to ensure
 * long alignment
 */
Array( CTextPool, MAXCTEXTPOOL/4, long);
Var( CTextPoolEnd, ptr(char), 0);
#endif /* MT */

#ifdef UseRefStack
Array( ReferenceStack, REFSTACKSIZE, void *); /* ugly const, should be malloced() */
Var( RefSP, ptr(long), (long *)&ReferenceStack[0] );
#else
#ifdef NEWRUN /* both a ref stack and a runtime stack */
Var( ReferenceStack, struct Object**, 0); 
Var( RefSP, struct Object**, 0);
Var( CompStack, long*, 0); 
Var( CompSP, long*, 0);
Array( BetaStackTop, 2, long *); 
#else
#ifndef MT
Var( BetaStackTop, ptr(Cell), 0);
#endif
#endif /* NEWRUN */
#ifndef MT
Var( StackEnd,   long *, 0);
#endif /* MT */
#endif

#ifdef NEWRUN
Var( StackStart, long *, 0);
#else
#ifndef MT
Var( ActiveCallBackFrame, ref(CallBackFrame), 0);
Var( StackStart, Cell, 0);
#endif
#endif


#ifdef crts
Var(baseRefSP, ptr(long), (long *)0);
Array(CIntstack, 100, long);
Array(CFloatStack, 100, double); 
Var(cIntStackPtr, long *, (long *)0);
Var(cFloatStackPtr, double *, (double *)0);

Var(baseStackPtr, long *, (long *)0);
#endif


Var( HandledInToSpace, ptr(Cell), 0);     /* Used during scavenging.     */
Var( HandledInAOA,     ptr(Cell), 0);     /* Used during scavenging.     */
Var( HandledAOABlock,  ref(Block), 0);    /* Used during scavenging.     */

Var( ReqObjectSize, unsigned long, 0);

#if !defined(NEWRUN) && !defined(MT)
Var( lastCompBlock, ref(ComponentBlock), 0);
#endif

Var( BasicItem, ref(Item), 0);

#ifdef NEWRUN
Var( BasicProto, ref(ProtoType), 0);
Var( CurrentObject, ref(Object), 0);
#endif
Array( InterpretItem, 2, ref(Item));

Var( TextProto, ref(ProtoType), 0);

Var( ArgCount, Cell, 0);
Var( ArgVector, ptr(ptr(char)), 0);
Var( XcallName, ptr(char), 0);
Var( XcallNum, long, 0);

#ifdef GATHERSTAT
struct IOSStatistic IOAStat;
#endif

Var( QuaCont, Cell, FALSE);

#ifdef sparc
Var( SuspCont, Cell, FALSE);
#endif

#ifdef RTINFO
Var( output, ptr(FILE), stderr);
Var( Info0, Cell, FALSE);
Var( InfoIOA, Cell, FALSE);
Var( InfoAOA, Cell, FALSE);
Var( InfoLVRA, Cell, FALSE);
Var( InfoCBFA, Cell, FALSE);
Var( InfoLVRAAlloc, Cell, FALSE);
Var( isStatRecordOn, Cell, FALSE);
Var( InfoDOT, Cell, FALSE);
#endif

#ifdef RTDEBUG
Var( DebugIOA,  Cell, FALSE);
Var( CheckHeap,  Cell, FALSE);
Var( StopAtIllegal,  Cell, FALSE);
Var( DebugAlloI,  Cell, FALSE);
Var( DebugCBFA,  Cell, FALSE);
Var( DebugAOA,  Cell, FALSE);
Var( DebugLVRA, Cell, FALSE);
Var( DebugStack, Cell, FALSE);
#ifdef MT
Var( DebugMT, Cell, FALSE);
#endif
Var( DebugStackAtGcNum, long, 0);
Var( AOAcopied,  Cell, 0);
Var( IOAcopied,  Cell, 0);
#ifdef RTVALHALLA
Var( DebugValhalla, Cell, FALSE);
#endif
#endif /* RTDEBUG */

Var( NumIOAGc,          long, 0);
Var( NumAOAGc,          long, 0);
Var( NumLVRAGc,         long, 0);

/* need to declare Num* always because RUN based routines
 * reference it even if it is not updated.
 */
#if (defined(RTDEBUG) || defined(RUN))
#ifndef MT
Var( NumAlloI,		long, 0);
Var( NumAlloC,  	long, 0);
Var( NumAlloDO, 	long, 0);
Var( NumAlloRR, 	long, 0);
Var( NumAlloVR1,	long, 0);
Var( NumAlloVR2,	long, 0);
Var( NumAlloVR4,	long, 0);
Var( NumAlloVR8,	long, 0);
Var( NumAlloVRI,	long, 0);
Var( NumAlloVRC,	long, 0);
Var( NumCopyCT, 	long, 0);
Var( NumCopyRR,		long, 0);
Var( NumCopySRR,	long, 0);
Var( NumCopySVR1,	long, 0);
Var( NumCopySVR2,	long, 0);
Var( NumCopySVR4,	long, 0);
Var( NumCopySVR8,	long, 0);
Var( NumCopySVRI,	long, 0);
Var( NumCopySVRC,	long, 0);
Var( NumCopyT,		long, 0);
Var( NumCopyVR1,	long, 0);
Var( NumCopyVR2,	long, 0);
Var( NumCopyVR4,	long, 0);
Var( NumCopyVR8,	long, 0);
Var( NumCopyVRI,	long, 0);
Var( NumCopyVRC,	long, 0);
Var( NumExtRR,		long, 0);
Var( NumExtVR1,		long, 0);
Var( NumExtVR2,		long, 0);
Var( NumExtVR4,		long, 0);
Var( NumExtVR8,		long, 0);
Var( NumExtVRI,		long, 0);
Var( NumExtVRC,		long, 0);
Var( NumMkTO,		long, 0);
Var( NumNewRR,		long, 0);
Var( NumNewVR1,		long, 0);
Var( NumNewVR2,		long, 0);
Var( NumNewVR4,		long, 0);
Var( NumNewVR8,		long, 0);
Var( NumNewVRI,		long, 0);
Var( NumNewVRC,		long, 0);
Var( NumAlloS,		long, 0);
Var( NumThisS,		long, 0);
Var( NumObjS,		long, 0);
Var( NumAlloSICB,	long, 0);
Var( NumAlloSI,		long, 0);
Var( NumAlloSC,		long, 0);
Var( NumAlloSO,		long, 0);
Var( NumleS,		long, 0);
Var( NumgeS,		long, 0);
Var( NumgtS,		long, 0);
Var( NumltS,		long, 0);
Var( NumeqS,		long, 0);
Var( NumneS,		long, 0);
Var( NumQua,		long, 0);
Var( NumReturn,		long, 0);
Var( NumRefNone,	long, 0);
Var( NumCopyCPP,	long, 0);
Var( NumCinitT,		long, 0);
Var( NumCpkVT,		long, 0);
Var( NumCpkSVT,		long, 0);
#ifdef MAC
Var( NumPpkVT,		long, 0);
Var( NumPpkCT,		long, 0);
Var( NumPpkSVT,		long, 0);
Var( NumCopyPPP,	long, 0);
#endif
Var( NumChkRA,		long, 0);
Var( NumExO,		long, 0);
Var( NumSusp,		long, 0);
Var( NumAtt,		long, 0);
Var( NumTermComp,	long, 0);
Var( NumAOAAlloc,	long, 0);
#endif /* MT */
#endif /* RTDEBUG */



