[[
------- macadditions: System ----

ArgCount:  cvar;
ArgVector: cvar;

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
  (#
     stackPointer: StackArea = SP;
     theVector:    StackArea = AddrReg1
  do
     stackPointer[20]   -> ArgCount;
     stackPointer[24][] -> theVector;
     theVector -> ArgVector;
     return
  #);

IndexError: public
  (#
     CurrentObject: Object = RegObj
  do
     push CurrentObject;
     push -3;              { Error number for Repetition index error! }
     call BetaError
  #);

FailureExit: public
  (#
     { Called from betaenvbody: (FailureTrace,'') -> Stop }
     CurrentObject: Object = RegObj
  do
     push CurrentObject;
     push -8;
     call BetaError
  #)


------- CallBack: System ----

{ Routines for invoking beta objects from C or Pascal. }

{ Handle used from C. }
HandleCB: proc;

{ Handle used from Pascal. }
HandlePCB: proc;

ActiveCallBackFrame: cvar;
BetaStackTop:        cvar;

CopyCPP: public
  (#
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     
     stackTop: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2
  do
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one! }
         { NYI }
         call CBFArelloc;
         goto CopyCPP
     if);
     
     newTop -> CBFATop;
     
     stackTop[4] -> theCBStruct[0];
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction 4eb9.}
     HandleCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     20085 -> theCBStruct[10]!w; { Write the rts instruction 4e75.}
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stackTop[4];
     
     return
  #);

HandleCB: public
  (#
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = RegAdr;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     theObj: Object = RegObj
  do
     (code '	movem.l	d2-d7/a1-a6,-(sp)' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
     
     return
  #);


CopyPPP: public
  (#
     { Stack on entry:  0: [ return address         ]!l  }
     {                  4: [ pascal parametre value ]!w  }
     {                  6: [ pointer to struc       ]!l  }
     
     { Stack on exit:   0: [ entry to CBFA block    ]!l  }
     
     theCBStruct:   DataArea  = AddrReg1;
     newTop:        DataArea  = AddrReg2;
     
     stackTop:      StackArea = SP;
     theRoutine:    CodeArea  = AddrReg2;
     returnAddress: CodeArea  = AddrReg2
  do
     { Find a free block in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one! }
         { if Not call Error. }
         push RegObj;
         push -11;
         call BetaError     
     if);
     newTop -> CBFATop;
     
     { Initialize the block. } 
     stackTop[6] -> theCBStruct[0]; { Initialise the struc part of the block. }
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction 4eb9.}
     HandlePCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     stackTop[4]!w -> theCBStruct[10]!w;
     theCBStruct[4][] -> theRoutine;
     
     { Contents of the CBFA block: }
     {               0: [ pointer to struct in beta-heap ]!l }
     { theRoutine -> 4: [ jsr HandlePascalCallBack       ]!l }
     {              10: [ pascal parametre value         ]!w }
     
     theRoutine -> stackTop[6];
     pop returnAddress;
     2 -> stackTop+;
     goto returnAddress
  #);

HandlePCB: public
  (#
     { Stack on entry:  0: [ return address (CBFA block) ]!l        }
     {                  4: [ return address (extern)     ]!w        }
     {                  8: [ pascal parametre block      ]!?        }
     {                  ?: [ slot for return value       ]!(0,2,4)  }
     
     { Stack on exit:   0: [ slot for return value       ]!(0,2,4)  }
     
     { The size of 'pascal parametre block' and 'slot for return value'  }
     { are described in the coresponding CBFA block.                     }
     
     { NOTE: Pascal register conventions (MPW C, Appendix C): }
     { d0, d1, d2, a0, and a1 are scratch registers.          }
     
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = RegAdr;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     resultValue: Long      = DataRegA;
     
     paramBlockSize: Long    = DataRegB;
     returnBlockSize: Long   = DataRegB;
     
     table:         DataArea  = RegArg;
     returnAddress: CodeArea  = RegObj;
     
     theObj: Object = RegObj
  do
     (code '	movem.l	d2-d7/a1-a6,-(sp)' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
     
     { Remove the parametre block. }
     { The return address stackPointer[0] points out }
     { the 'pascal parametre value'.                 }
     pop table;
     pop returnAddress;
     
     0 -> paramBlockSize;
     table[0]!b -> paramBlockSize;
     paramBlockSize -> stackPointer+;
     
     
     { Determine how to to return the result value from beta }
     table[1]!b -> returnBlockSize;
     
     (if returnBlockSize = 0 then goto exit if);
     (if returnBlockSize = 2 then
         resultValue!w -> stackPointer[0]!w;
         goto exit
     if);
     (if returnBlockSize = 4 then 
         resultValue!l -> stackPointer[0]!l;
         goto exit
     if);
     
     push 0; 
     push -12; 
     call BetaError;    
  exit:
     goto returnAddress
  #)

----- PascalInterface: system -----

PPackCT: public
  (#
     { RegAdr points to a ascii string }
     stack:  StackArea = SP;
     theText: DataArea = RegAdr;
     Size: Long = DataReg2;
     index: Long = DataRegA;
     theTextAddr: DataArea = RegArg;
     Value: Byte = DataReg1;
     nextText: DataArea = AddrReg1;
     RetAddr:  CodeArea = AddrReg1
  do 
     stack[4] -> theText;
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Compute the text size. }
     0 -> Size;
     goto LoopB;
     LoopA: 1  -> Size+;
     LoopB: (if theText[Size]!b <> 0 then goto LoopA if);
     
     { Set the first byte in the pascal string eq the length. }
     Size!b -> theTextAddr[0]!b;
     
     { Copy the contents of the repetition to the CTextPool. }
     (if Size <> 0 then
         0 -> index;
         loop:
         theText[index]!b -> Value; Value -> theTextAddr[1+index]!b;
         1 -> index+;
         (if index < Size then goto loop if)
     if);
     
     { Update CTextPool. }
     theTextAddr[1+Size][] -> nextText;
     nextText -> CTextPoolEnd;
     
     pop  RetAddr;
     theTextAddr -> stack[0];
     goto RetAddr
  #);

PPackVT: public
  (#
     theRep: Repetition = RegAdr;
     Size: Long = DataReg2;
     index: Long = DataRegA;
     theTextAddr: DataArea = RegArg;
     Value: Byte = DataReg1;
     nextText: DataArea = AddrReg1;
     RetAddr:  CodeArea = AddrReg1
  do 
     theRep[0] -> theRep;
     theRep.HighBorder -> Size;
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Set the first byte in the pascal string eq the length. }
     Size!b -> theTextAddr[0]!b;
     
     { Copy the contents of the repetition to the CTextPool. }
     (if Size <> 0 then
         0 -> index;
         loop:
         theRep[16+index*4]!l -> Value!l; { Get as long to avoid byte-ordering. }
         Value -> theTextAddr[1+index]!b;
         1 -> index+;
         (if index < Size then goto loop if)
     if);
     
     { Update CTextPool. }
     theTextAddr[1+Size][] -> nextText;
     nextText -> CTextPoolEnd;
     
     pop  RetAddr;
     push theTextAddr;
     goto RetAddr
  #)

---]]
