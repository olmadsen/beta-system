RUNDEPS= \
../GEN/linux/linux/gen \
RUN/AllocateComponent.run \
RUN/AllocateDopartObject.run \
RUN/AllocateItem.run \
RUN/AllocateRefRep.run \
RUN/AllocateStackObject.run \
RUN/AllocateValRep.run \
RUN/AllocateObjectRep.run \
RUN/Attach.run \
RUN/AttachBasicComponent.run \
RUN/Basics.run \
RUN/CInterface.run \
RUN/CheckReferenceAssignment.run \
RUN/ComponentStack.run \
RUN/Constant.run \
RUN/CopyCText.run \
RUN/CopyRefRep.run \
RUN/CopySliceRefRep.run \
RUN/CopySliceValRep.run \
RUN/CopyText.run \
RUN/CopyValRep.run \
RUN/DataRegs.run \
RUN/Declaration.run \
RUN/ExitObjects.run \
RUN/ExtendRefRep.run \
RUN/ExtendValRep.run \
RUN/MakeTextObj.run \
RUN/Misc.run \
RUN/NewRefRep.run \
RUN/NewValRep.run \
RUN/PerformGC.run \
RUN/Structure.run \
RUN/Qua.run \
RUN/Suspend.run

betarun.o: linux.o C/c.common.o GC/c.gc.o 
	ld -x -r -o betarun.o C/c.common.o GC/c.gc.o linux.o

betarun_pe.o: C/c.common.o GC/c.gc.o linux.o
	ld -x -r -o betarun_pe.o C/c.common.o GC/c.gc.o linux.o

betarun_debug.o: C/c.common.debug GC/c.gc.debug linux-debug.o
	ld -r -o betarun_debug.o C/c.common.debug GC/c.gc.debug linux-debug.o

linux.o: linux.asm
	cp linux.asm linux.c
	gcc -E linux.c > linux.s
	as -o linux.o linux.s
	rm linux.c linux.s


linux-debug.o: linux-debug.asm
	cp linux-debug.asm linux-debug.c
	gcc -E linux-debug.c > linux-debug.s
	as -o linux-debug.o linux-debug.s
	rm linux-debug.c linux-debug.s

linux.asm: RUN/linux.run RUN/linuxadditions.run $(RUNDEPS)
	../GEN/linux/linux/gen -o linux.asm RUN/linux

linux-debug.asm: RUN/linux.run RUN/linuxadditions.run $(RUNDEPS)
	../GEN/linux/linux/gen -debug -o linux-debug.asm RUN/linux

pe:
	rm -f C/c.common.o C/initialize.o
	PE="-DPE"; export PE; make betarun_pe.o
	rm -f C/c.common.o C/initialize.o

debug: betarun_debug.o

asm: linux-debug.asm

gen:
	cd ../GEN/linux; make --no-print-directory

C/c.common.debug: ALWAYS
	cd C; make debug

GC/c.gc.debug: ALWAYS
	cd GC; make debug

C/c.common.o: ALWAYS
	cd C; make

GC/c.gc.o: ALWAYS
	cd GC; make

######### betarun_v.o / betarunv.a  #########

betarun_v.o: C/c.common.valhalla GC/c.gc.valhalla linux.o
	ld -dn -r -o betarun_v.o C/c.common.valhalla GC/c.gc.valhalla linux.o

betarunv.a: C/c.common.valhalla GC/c.gc.valhalla linux.o
	mv C/end.o end.o
	rm C/c.common.valhalla GC/c.gc.valhalla betarunv.a 
	ar -r betarunv.a C/*.o GC/*.o linux.o

C/c.common.valhalla: ALWAYS
	cd C;  make valhalla PROF="$(PROF)" PE=$(PE)

CRUN/c.run.valhalla: ALWAYS
	cd CRUN; make valhalla PROF="$(PROF)"

GC/c.gc.valhalla: ALWAYS
	cd GC; make valhalla PROF="$(PROF)"

valhalla: betarun_v.o

########## All ###########

all:
	make clean
	make
	make pe 
	make clean
	make valhalla
	make clean
	make debug

tags:
	etags RUN/*.run GC/*.[hc] C/*.[hc] C/data.gen

check:
	@echo generating list of undefined labels
	@nm betarun.o | grep ' U ' > .new-undefined
	@echo find difference between .old-undefined and .new-undefined
	@diff .old-undefined .new-undefined

gendef:
	@echo generating list of undefined labels
	@nm betarun.o | grep ' U ' > .old-undefined

clean: ALWAYS
	-rm -f *.group *.lst core *.asm *~ linux.s linux-debug.s *.dump
	cd C; make --no-print-directory clean MAIN=dummy
	cd GC; make --no-print-directory clean MAIN=dummy
	@sh -c 'if [ -d TST ]; then cd TST; make clean; fi'

ALWAYS:

