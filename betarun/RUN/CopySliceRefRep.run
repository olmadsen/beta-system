---- CopySliceRefRep: System ----

CopySRR: public
  (#
     { Copy a slice of a Reference Repetition. }
     { stack on entry [return(0),...] }
     
     { input parameters }
     { Repetition: DataRegA; (pReg1 on intel) }
     { Object:     DataRegB; (pReg2 on intel) }
     { Offset:     DataRegC; (pReg3 on intel) }
     { Low:        DataRegD; (pReg4 on intel) }
     { High:       DataRegE; (pReg5 on intel) }
     
     { Used variables. }
     low:    Long      = DataReg1; 
     high:   Long      = DataReg2; 
     stack:  StackArea  = SP;    
     theRep: Repetition = AddrReg1;
     theObj: Object     = RegThis;
     newRep: Repetition = AddrReg2;
     newTop: DataArea   = AddrReg1;
     value:  Long       = DataReg1;
     offset: Long       = DataReg1;
     theItem: Item      = AddrReg1;
     theCell: DataArea  = AddrReg1
  do
     (if debug then 1 -> NumCopySRR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <Intel: AddrReg2>   Intel: +0
       <Intel: AddrReg1>   Intel: +4
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +8    Mac: +4    Default: +0
     }

     pReg1 -> DataReg1; pReg2 -> DataReg2;
     
     push AddrReg1, AddrReg2;
     
     pReg1 -> theRep;
     pReg4 -> low;
     pReg5 -> high;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         12 -> stack+; push theObj; push RepLowRangeErr; call BetaError 
     if);
     (if high > theRep.HighBorder then 
         12 -> stack+; push theObj; push RepHighRangeErr; call BetaError 
     if);
 
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if); { OBS: low>high confuses chk2 }
     { high is now converted to the range of the resulting repetition. }
     
     again:
     
     IOATop -> newRep;
     newRep[16+high*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { Restore theRep; it was destroyed by newTop }
     pReg1 -> theRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     RefRepPTValue    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     1 -> low-;
     theRep[low*4][] -> theRep; { Start at low. }
     
     (if high <> 0 then
         1 -> high-;
         loop:
         theRep[16+high*4] -> value;
         value -> newRep[16+high*4];
         1 -> high-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pReg2 -> theItem;
     pReg3 -> offset;
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA                { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     high -> ReqObjectSize+;
     pop AddrReg2, AddrReg1;
     call doGC;              { Call the Garbage Collector.               }
     push AddrReg1, AddrReg2;
     goto again              { Go back to the beginning of this routine. }
  #)
