------- CopyRefRep: System ----
CopyRR: public
  (#
     { Copy a reference repetition. }
     { stack on entry [return(0),....] }
     
     stack: StackArea = SP;
     
     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
 
     { Used variables. }
     theRep: Repetition = AddrReg1;
     theItem: Object    = AddrReg1;
     theCell: DataArea  = AddrReg1;

     newTop: DataArea   = AddrReg2;
     newRep: Repetition = AddrReg2;

     range:  Long       = DataReg1;

     tmp:    Long       = DataReg2;
     value:  Long       = DataReg2;
     offset: Long       = DataReg2;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumCopyRR+ if); 
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16
     }
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     IOATop -> newTop;
     newTop[16+range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     RefRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1     -> newRep.LowBorder;
     range -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if range <> 0 then
         1 -> range-;
         loop:
         theRep[16+range*4] -> value;
         value -> newRep[16+range*4];
         1 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);

     pReg2 -> theItem;
     pReg3 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     range -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto CopyRR             { Go back to the beginning of this routine. }
  #)
