------- Qua: System ----
{ Qua check.
  The reference assignment src[]->dst[] has just been made. dst resides in theCell.
  Perform.
  1. CheckReferenceAssigment
  2. Qua Check: Check if the actual qualification of src is less than or equal to
  qualification of dst, as given by dstQuaProto and dstQuaOrigin.
}

{ Qua: Gentle qua check, don't worry about origins }
Qua: public
  (#
     { Input variables. }
     dstQuaProto:  ProtoType = RegCall {edi};
     theCell:      Long      = DataReg2; {pReg2 in Intel version}
     theCellReg:   Object    = DataReg2 {ebx};
     { Used variables. }
     src:          Object    = AddrReg1;
     srcStruc:     Structure = AddrReg1;
     srcComp:      Component = AddrReg1;
     srcProto:     ProtoType = AddrReg2;
     proto1:       ProtoType = AddrReg1;
     argument:     Structure = RegCall;
     newObject:    Object    = RegCall  
  do
     {
       General stack layout:
       <AddrReg2> +0
       <AddrReg1> +4
       <DataReg2> +8
       <return>   +12
       ...
     }
     
     { Cannot call Ck here: heaps are not consistent until ChkRA has been done }
     (if debug then 1 -> NumQua+ if); 
     
     { Fetch pReg2 }
     push DataReg2;     { for theCellReg }
     pReg2 -> DataReg2;
     
     {Check for None}
     (if theCellReg[0] = 0 then 
         pop DataReg2;
         return; 
     if);
     
     push AddrReg1 { for src, AddrReg2 coming up...};
     theCellReg[0] -> src;

     { Corresponds to the following C-code:                  }
     { #ifdef PERSIST                                        }
     {   if (inPIT((void *)src))                             }
     {     *theCell = src = unswizzleReference((void *)src); }
     { #endif                                                }
     (if PERSIST then
         { FIXME: theObj inside PIT? }
         (if PIT <= src then {FIXME: signed compare}
             (if src < PITLimit {FIXME: signed compare} then
                 push RegEax;
                 push RegEcx;
                 push RegEdx;
                 push RegEbx;
                 push RegEsi;
                 push RegEdi;
                 push src;
		 call unswizzleReference;
                 pop src; { remove parameter }
		 RegEax -> src;
                 pop RegEdi;
                 pop RegEsi;
                 pop RegEbx;
                 pop RegEdx;
                 pop RegEcx;
                 pop RegEax;
		 src -> theCellReg[0];
             if);
         if);
     if);

     { 1. Check reference assignment }
     theCell->AddrReg1;
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     theCellReg[0] -> src;
     {AddrReg1 already pushed} 
     push AddrReg2;
     
     { Stack: <General Stack Layout> }
     
     { 2. Qua Check }
     src.ProtoType -> srcProto;
     
     doCheck:
     (if srcProto = StructurePTValue then
         { It was a pattern variable assignment: src is a struc-object }
         srcStruc.iProto  -> srcProto;
         goto eqCheck
     if);
     (if srcProto = ComponentPTValue then
         { It was a component-reference assignment; src points to a component }
         srcComp.Item[] -> src;
         src.ProtoType -> srcProto;
         { goto eqCheck  (Fall through is faster) }
     if);
     { It was a normal reference assignment: src is normal object }
     
     eqCheck: { Check for eqS }
     (if srcProto = dstQuaProto then
         { Structures are identical. All is OK }
         goto success
     if);
     
     { Inlined version of ltS without struc objects }
     
     (if dstQuaProto = dstQuaProto.Prefix then
         { dstQuaProto is Object## }
         goto success
     if);
     
     { Prefix of srcProto is the first try }
     srcProto -> proto1;
     proto1.Prefix -> proto1;
     loop:
     (if proto1 = proto1.Prefix then { proto1 = Object## }
         goto failure 
     if); 
     (if proto1 = dstQuaProto then
         { dstQuaProto is a prefix of srcProto; all is OK }
         goto success
     if);
     proto1.Prefix -> proto1;
     goto loop;
     
     success:
     pop AddrReg2, AddrReg1, DataReg2;
     return;
     
     failure:
     theCellReg[0] -> src;
     src -> QuaSrc;
     dstQuaProto -> QuaDstProto;
     pop AddrReg2, AddrReg1, DataReg2;
     { Stack: <return> }
     { save registers in case of QuaCont }
     PushAll; { 8 registers }
     { Stack: 
       <8 regs>
       <return>
     }
     push RegThis; 
     { Stack: 
       <this>   +0    0 longs
       <8 regs> +4    1 long
       <return> +36   9 longs
     }
     push QuaErr; 
     { Stack: 
       <QuaErr>
       <this>   +0    0 longs
       <8 regs> +4    1 long
       <return> +36   9 longs
     }
     call BetaError;
     
     { in case of QuaCont: }
     8 -> SP+ { Pop this and QuaErr};
     PopAll;
     
     (if debug then call Ck if);
     return
  #)
