------- ExtendValRep: System ----

ExtVR: public
  (#
     { Extend a value repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:  StackArea  = SP;
     newRep: Repetition = AddrReg2;
     
     newTop: DataArea   = AddrReg1;
     theRep: Repetition = AddrReg1;
     theCell: DataArea  = AddrReg1;
     
     newRange: Long     = DataReg2;
     BodySize: Long     = DataReg4; { Saved and restored. }
     offset:   Long     = DataReg2;
     
     oldBodySize: Long  = DataReg1;
     value:    Long     = DataReg3  { Saved and restored. }
  do
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     (if newRange<0 then 0->newRange if);
     
     (if newRange > 256 then
         (if intel then
             push RegArg, RegObj;
          else
             push RegArg, RegObj, DataRegA, DataRegB;
         if);
         push addSize; {Save addSize}
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAAlloc. }
         push theRep.ProtoType;  { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         DataRegA -> newRep;
         
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then
                 stack[40{16+(4+2)*4}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[44{20+(4+2)*4}] -> DataRegA+; {item}
              else
                 (if MacOS then
                     stack[40{8+(4+4)*4}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[44{12+(4+4)*4}] -> DataRegA+; {item}
                  else
                     stack[36{4+(4+4)*4}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40{8+(4+4)*4}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         
         4 -> SP+; {Discard prototype parameter}
         pop  newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop addSize; {Restore addSize}
         (if intel then
             pop  RegObj, RegArg;
          else
             pop  DataRegB, DataRegA, RegObj, RegArg;
         if);
         (if newRep <> 0 then
             push newRange; { save newRange }
             { recalculate theRep, it may have been moved by LVRACompaction }
             (if intel then
                 stack[24{20+4}] -> theRep;
                 stack[20{16+4}]  -> offset; { invalidates newRange }              
              else
                 (if MacOS then
                     stack[16{12+4}] -> theRep;
                     stack[12{8+4}]  -> offset; { invalidates newRange }              
                  else
                     stack[12{8+4}] -> theRep;
                     stack[8{4+4}] -> offset; { invalidates newRange }
                 if);
             if);
             theRep[offset*4] -> theRep;
             pop newRange; { restore Newrange }
             
             { Calculate BodySize of new repetition }
             push DataReg4; { save DataReg4 }
             
             newRange -> BodySize; { invalidates DataReg4 }
             (if theRep.ProtoType = -8 then { double rep }
                 2 -> BodySize*; 
                 goto BodySizeOK
             if);
             (if theRep.ProtoType = -7 then { word rep }
                 2 -> BodySize*;
                 3 -> BodySize+;
                 4 -> BodySize/; 
                 goto BodySizeOK
             if);
             (if theRep.ProtoType = -6 then { byte rep }
                 4 -> BodySize+;
                 4 -> BodySize/; 
                 {goto BodySizeOK} {No need, save a jump}
             if);
             BodySizeOK:
             4 -> BodySize*;
             goto copyBody 
         if)
     if);
     
     { Calculate BodySize of new repetition }
     push DataReg4; { save DataReg4 }
     
     newRange -> BodySize; { invalidates DataReg4 }
     (if theRep.ProtoType = -8 then { double rep }
         2 -> BodySize*; 
         goto IOAalloc
     if);
     (if theRep.ProtoType = -7 then { word rep }
         2 -> BodySize*;
         3 -> BodySize+;
         4 -> BodySize/; 
         goto IOAalloc
     if);
     (if theRep.ProtoType = -6 then { byte rep }
         4 -> BodySize+;
         4 -> BodySize/; 
         {goto IOAalloc} {No need, save a jump}
     if);
     
     IOAalloc:
     
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { recalculate theRep, it has been invalidated above }
     push newRange;
     (if intel then
         stack[28{20+2*4}] -> theRep;
         stack[24{16+2*4}] -> offset; { invalidates newRange }
      else
         (if MacOS then
             stack[20{12+2*4}] -> theRep;
             stack[16{8+2*4}] -> offset; { invalidates newRange }
          else
             stack[16{8+2*4}] -> theRep;
             stack[12{4+2*4}] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange;
     
     { Initialize the structual part of the repetition. }
     theRep.ProtoType -> newRep.ProtoType;
     1                -> newRep.Age;
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
         
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         (if theRep.ProtoType = -8 then { double rep }
             2 -> oldBodySize*;
             goto oldBodyOK
         if);
         (if theRep.ProtoType = -7 then { word rep }
             2 -> oldBodySize*;
             3 -> oldBodySize+;
             4 -> oldBodySize/; 
             goto oldBodyOK
         if);
         (if theRep.ProtoType = -6 then { byte rep }
             4 -> oldBodySize+;
             4 -> oldBodySize/; 
             {goto oldBodyOK} {No need, save a jump}
         if);
         oldBodyOK:
         4->oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         pop oldBodySize
     if);
          
     { Clear the extension part of newRep, pointed out by theRep. }
     { first clear the bytes from newRep[theRep.highborder+1..oldBodySize]
       if it is a valrep.
     }
     (if theRep.ProtoType = -6 then
         push oldBodySize;
         push newRep;
         theRep.HighBorder -> oldBodySize-;
         2 -> oldBodySize-;
         (if oldBodySize>=0 then
             { clear <oldBodySize> bytes from newRep[theRep.highBorder+1] }
             theRep.HighBorder -> newRep+; 
             17 -> newRep+; { 16 + 1 }
             loop3:
             0 -> newRep[oldBodySize]!b;
             1 -> oldBodySize-;
             (if FLAGS >= 0 then goto loop3 if)
         if);
         pop newRep;
         pop oldBodySize
     if);
     
     { calculate difference in actual size }
     oldBodySize -> BodySize-; { invalidates BodySize }
     
     { Calculate the address of the extension part into theRep. }
     newRep[16+oldBodySize][] -> theRep;
     
     (if BodySize > 0 then
         4 -> BodySize-;
         loop2:
         0 -> theRep[BodySize];
         4 -> BodySize-;
         (if FLAGS >= 0 then goto loop2 if)
     if);
     
     pop DataReg3; { restore DataReg3 }
     pop DataReg4; { restore DataReg4 }
     
     { calculate the cell to store new rep in }
     (if intel then
         stack[20] -> theCell;
         stack[16]  -> offset;
      else
         (if MacOS then 
             stack[12] -> theCell;
             stack[8]  -> offset;
          else
             stack[8] -> theCell;
             stack[4] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg4; { Restore DataReg4 }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)
