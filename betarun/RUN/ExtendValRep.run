------- ExtendValRep: System ----

ExtVR1: public
  (#
     { Extend a byte repetition. }
     { stack on entry [return(0)...] }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
	
     { Used variables. }
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR1+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <RegAdr>     
       <DataReg2>   
       <AddrReg2>   
       <AddrReg1>   
     }
     
     (if do_unconditional_GC then
	 (if DoUGC<>0 then
	     { See general comment in AllocateItem.run }
	     push AddrReg1, AddrReg2, DataReg2 ;
	     push RegAdr;
	     pReg1 -> theItem;
	     pReg2 -> offset;
	     pReg3 -> addSize;
	     theItem[offset*4] -> theRep;
	     theRep.HighBorder -> newRange; { invalidates offset }
	     addSize  -> newRange+;
	     (if newRange < 0 then 0 -> newRange if);
	     newRange -> BodySize; { invalidates RegAdr }
	     1 -> BodySize+;
	     ObjectAlign -> BodySize|; 
	     goto GC;
	 if);
     if);

     again:
     
     push AddrReg1, AddrReg2, DataReg2 ;
     push RegAdr;
     
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if);
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > LARGE_REP_SIZE then
         
         { STACK:
           <General stack layout>
         }
         
         push RegCall, RegThis; 
         push theRep; {Save theRep}
         
         push newRange;  { Parameter to LVRAXAlloc. }
         push theRep.HighBorder; { Parameter to LVRAXAlloc. }
         push ByteRepPTValue;  { Parameter to LVRAXAlloc. }
         call LVRAXAlloc;
         DataReg1 -> newRep;
         
         8 -> SP+; {Discard prototype and oldrange parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop  RegThis, RegCall;
         pReg3 -> addSize;
         
         { STACK:
           <General stack layout>
         }
         
         { Calculate BodySize of new repetition }
         newRange -> BodySize; { invalidates RegAdr }
         1 -> BodySize+;
         ObjectAlign -> BodySize|; 
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBody 
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     newRange -> BodySize; { invalidates RegAdr }
     1 -> BodySize+;
     ObjectAlign -> BodySize|; 
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 31 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
          
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     ByteRepPTValue   -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
    
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         1 -> oldBodySize+;
         {ObjectAlign -> oldBodySize|; NO, NO, NO! May copy up to 7 bytes too much! }
         4 -> oldBodySize|; { We copy longs below }
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         { Copying of old elements DONE }
     if);
     
     AssignReference: 
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop RegAdr; { restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;

     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegAdr; { Restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR2: public
  (#
     { Extend a short repetition. }
     { stack on entry [return(0)...] }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
	
     { Used variables. }
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR2+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <RegAdr>     
       <DataReg2>   
       <AddrReg2>   
       <AddrReg1>   
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg2 ;
                 push RegAdr;
                 pReg1 -> theItem;
                 pReg2 -> offset;
                 pReg3 -> addSize;
                 theItem[offset*4] -> theRep;
                 theRep.HighBorder -> newRange;
                 addSize  -> newRange+;
                 (if newRange < 0 then 0 -> newRange if);
                 newRange -> BodySize;
                 2 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2 ;
     push RegAdr;
     
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if);
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > LARGE_REP_SIZE then
         
         { STACK:
           <General stack layout>
         }
         push RegCall, RegThis; 
         push theRep; {Save theRep}
         
         push newRange;  { Parameter to LVRAXAlloc. }
         push theRep.HighBorder; { Parameter to LVRAXAlloc. }
         push ShortRepPTValue;  { Parameter to LVRAXAlloc. }
         call LVRAXAlloc; 
         DataReg1 -> newRep;
         8 -> SP+; {Discard prototype and oldrange parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop  RegThis, RegCall;
         pReg3 -> addSize;
         
         { STACK:
           <General stack layout>
         }
         
         { Calculate BodySize of new repetition }
         newRange -> BodySize; { invalidates RegAdr }
         2 -> BodySize*;
         ObjectAlign -> BodySize|;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBody 
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     newRange -> BodySize; { invalidates RegAdr }
     2 -> BodySize*;
     ObjectAlign -> BodySize|;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 32 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
          
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     ShortRepPTValue  -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }

     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         2 -> oldBodySize*;
         { ObjectAlign -> oldBodySize|; NO, NO, NO! May copy up to 3 shorts too much! }
         4 -> oldBodySize|; { We copy longs below }
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         { Copying of old elements DONE }
     if);
     
     AssignReference: 
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop RegAdr; { restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;

     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegAdr; { Restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR4: public
  (#
     { Extend a long repetition. }
     { stack on entry [return(0)...] }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
	
     { Used variables. }
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR4+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <RegAdr>     
       <DataReg2>   
       <AddrReg2>   
       <AddrReg1>   
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg2 ;
                 push RegAdr;
                 pReg1 -> theItem;
                 pReg2 -> offset;
                 pReg3 -> addSize;
                 theItem[offset*4] -> theRep; 
                 theRep.HighBorder -> newRange; 
                 addSize  -> newRange+;
                 (if newRange < 0 then 0 -> newRange if);
                 newRange -> BodySize; 
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);

     again:
     
     push AddrReg1, AddrReg2, DataReg2 ;
     push RegAdr;
     
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep; { invalidates theItem }
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if);
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > LARGE_REP_SIZE then
         
         { STACK:
           <General stack layout>
         }
         
         push RegCall, RegThis; 
         push theRep; {Save theRep}
         
         push newRange;  { Parameter to LVRAXAlloc. }
         push theRep.HighBorder; { Parameter to LVRAXAlloc. }
         push LongRepPTValue;  { Parameter to LVRAXAlloc. }
         call LVRAXAlloc; 
         DataReg1 -> newRep;
         8 -> SP+; {Discard prototype and oldrange parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop  RegThis, RegCall;
         pReg3 -> addSize;
         
         { STACK:
           <General stack layout>
         }
         
         { Calculate BodySize of new repetition }
         newRange -> BodySize; { invalidates RegAdr }
         4 -> BodySize*;
         ObjectAlign -> BodySize|;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBody 
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     newRange -> BodySize; { invalidates RegAdr }
     
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 33 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
          
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     LongRepPTValue   -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4->oldBodySize*;
         { ObjectAlign -> oldBodySize|; NO, NO, NO! May copy one long too much! }
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         { Copying of old elements DONE }
     if);
     
     AssignReference: 
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop RegAdr; { restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;

     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegAdr; { Restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR8: public
  (#
     { Extend a double repetition. }
     { stack on entry [return(0)...] }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
	
     { Used variables. }
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR8+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <RegAdr>     
       <DataReg2>   
       <AddrReg2>   
       <AddrReg1>   
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg2 ;
                 push RegAdr;
                 pReg1 -> theItem;
                 pReg2 -> offset;
                 pReg3 -> addSize;
                 theItem[offset*4] -> theRep;
                 theRep.HighBorder -> newRange; 
                 addSize  -> newRange+;
                 (if newRange < 0 then 0 -> newRange if); 
                 newRange -> BodySize; { invalidates RegAdr }
                 8 -> BodySize*;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2 ;
     push RegAdr;
     
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); 
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > LARGE_REP_SIZE then
         
         { STACK:
           <General stack layout>
         }
         push RegCall, RegThis; 
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAXAlloc. }
         push theRep.HighBorder; { Parameter to LVRAXAlloc. }
         push DoubleRepPTValue;  { Parameter to LVRAXAlloc. }
         call LVRAXAlloc;
         DataReg1 -> newRep;
         8 -> SP+; {Discard prototype and oldrange parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop  RegThis, RegCall;
         pReg3 -> addSize;
         
         { STACK:
           <General stack layout>
         }
         
         { Calculate BodySize of new repetition }
         newRange -> BodySize; { invalidates RegAdr }
         8 -> BodySize*;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBody 
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     newRange -> BodySize; { invalidates RegAdr }
     
     8 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 34 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
          
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     DoubleRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         8 -> oldBodySize*;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         { Copying of old elements DONE }
     if);
     
     AssignReference: 
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);

     
     pop RegAdr; { restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;

     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegAdr; { Restore RegAdr }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again             { Go back to the beginning of this routine. }
  #);

ExtVRI: public
  (#
     { Extend an item repetition. }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
     
     { stack on entry [return(0),...] }
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      ObjectRepetition = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      ObjectRepetition = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVRI+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <tag2>       +0
       <Offset>     +4
       <RegAdr>     +8
       <Item>       +12
       <tag1>       +16
       <DataReg2>   +20
       <AddrReg2>   +24
       <AddrReg1>   +28
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg2, Protect1Tag;
                 pReg1 -> theItem;
                 pReg2 -> offset;
                 pReg3 -> addSize;
                 push theItem;
                 push RegAdr;
                 push offset;
                 push Protect2Tag;
                 theItem[offset*4] -> theRep;
                 theRep.HighBorder -> newRange; { invalidates offset }
                 addSize  -> newRange+;
                 (if newRange < 0 then 0 -> newRange if);
                 newRange -> BodySize; { destroys RegAdr }
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2, Protect1Tag;
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     push theItem;
     push RegAdr;
     push offset;
     push Protect2Tag { FIXME: could wait until after repetition allocation };

     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if);
     
     newRange -> BodySize; { destroys RegAdr }
     IOATop -> newRep;
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[24+BodySize][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 35 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     { No need to clear newTop since AddrReg1 is assigned to theRep below }
          
     { The new Object is now allocated, but not assigned yet!}
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     DynItemRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     newRange          -> newRep.HighBorder;
     theRep.iProto  -> newRep.iProto;
     theRep.iOrigin -> newRep.iOrigin;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4 -> oldBodySize*;
         push oldBodySize;
         push BodySize;
         ObjectAlign -> oldBodySize|;
         4 -> oldBodySize-;
         loop1:
         theRep[24+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[24+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop BodySize;
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { Initialize the extension part of newRep, pointed out by theRep. }
     
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     { calculate difference in actual size }
     push oldBodySize;
     oldBodySize -> BodySize-; { invalidates BodySize }
     
     { STACK:
       <oldBodySize>
       <General stack layout>
     }
     
     (if BodySize > 0 then
         4 -> BodySize-;
         
         initloop:
         
         push BodySize;
         push Protect2Tag; { protect BodySize, oldBodySize }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <General stack layout>
         }
         
         { setup parameters for AlloI }
         newRep.iProto  -> RegCall;
         newRep.iOrigin -> pReg1; { invalidates original pReg1 }
         
         { Allocate item }
         clear AddrReg1; { clear (theRep, theCell) before AlloI }
         call AlloI; { Destroys: RegCall(output), DataReg1, DataReg2, AddrReg1,
                       AddrReg2. 
                       May also destroy pReg1,2,3,4,5 via G-parts.
                     }
         { AlloI returns item in RegCall }
         
         { recalculate newRep - may have moved in GC caused by AlloI }
         { STACK:
           <tag>         +0
           <BodySize>    +4
           <oldBodySize> +8
           <General stack layout>
         } 
         
         stack[24] -> theItem;
         stack[16] -> offset;
         theItem[offset*4] -> newRep;
         
         { Calculate the address of the extension part using theRep register 
           (not newRep). 
         }
         stack[8] -> oldBodySize;
         newRep[24+oldBodySize][] -> theExt;
         
         { assign }
         4 -> SP+; { pop tag }
         pop BodySize;
         
         { STACK:
           <oldBodySize>
           <General stack layout>
         }
         
         theExt[BodySize][] -> theCell;
         RegCall { new item } -> theCell[0];

         (if call_chkra_unconditionally then
             call ChkRA_EBP;
          else
             (if theCell outside IOA then
                 { The theCell resides in AOA and the item in IOA }
                 push theCell;
                 call ChkRA { No need to remove parameter. }
             if);
         if);
         
         4 -> BodySize-;
         (if FLAGS >= 0 then goto initloop if);
         
         { STACK:
           <oldBodySize>
           <General stack layout>
         } 
     if);
     
     { STACK:
       <oldBodySize>
       <General stack layout>
     }

     pop oldBodySize;
     
     Finished:
              
     { STACK:
       <General stack layout>
     }
     
     { skip offset and tag }
     pop AddrReg1; { skip }
     pop AddrReg2; { skip }
     pop RegAdr; { restore RegAdr }
     { skip saved item }
     pop AddrReg1; { skip }
     { skip tag }
     pop AddrReg2; { skip }
     pop DataReg2, AddrReg2, AddrReg1 ;

     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     { skip offset and tag }
     pop AddrReg1; { skip }
     pop AddrReg2; { skip }
     pop RegAdr; { restore RegAdr }
     { skip saved item }
     pop AddrReg1; { skip }
     { skip tag }
     pop AddrReg2; { skip }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again            { Go back to the beginning of this routine. }
  #);
  
ExtVRC: public 
  (#
     { Extend a component repetition. }
     
     { Input variable. }
     { Object:     pReg1 }
     { Offset:     pReg2 }
     { Add:        pReg3 }
     
     { stack on entry [return(0),...] }
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      ObjectRepetition = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theItem:     Object           = AddrReg1;
     theRep:      ObjectRepetition = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     addSize:     Long             = DataReg1;
     oldBodySize: Long             = DataReg1;
     
     newRange:    Long             = DataReg2;
     offset:      Long             = DataReg2;
     
     BodySize:    Long             = RegAdr; { Saved and restored. }
     value:       Long             = RegAdr  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVRC+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <tag>        +0
       <Offset>     +4
       <RegAdr>     +8
       <Item>       +12
       <tag>        +16
       <DataReg2>   +20
       <AddrReg2>   +24
       <AddrReg1>   +28
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg2, Protect1Tag;
                 pReg1 -> theItem;
                 pReg2 -> offset;
                 pReg3 -> addSize;
                 push theItem;
                 push RegAdr;
                 push offset;
                 push Protect2Tag;
                 theItem[offset*4] -> theRep;
                 theRep.HighBorder -> newRange; { invalidates offset }
                 addSize  -> newRange+;
                 (if newRange < 0 then 0 -> newRange if);
                 newRange -> BodySize; { destroys RegAdr }
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2, Protect1Tag;
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     push theItem;
     push RegAdr;
     push offset;
     push Protect2Tag { FIXME: could wait until after repetition allocation };
     
     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if);
     
     newRange -> BodySize; { destroys RegAdr }
     IOATop -> newRep;
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[24+BodySize][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 36 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     { No need to clear newTop since AddrReg1 is assigned to theRep below }
          
     { The new Object is now allocated, but not assigned yet!}
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <General stack layout>
     } 
     pReg1 -> theItem;
     pReg2 -> offset;
     pReg3 -> addSize;
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     DynCompRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     newRange          -> newRep.HighBorder;
     theRep.iProto  -> newRep.iProto;
     theRep.iOrigin -> newRep.iOrigin;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4 -> oldBodySize*;
         push oldBodySize;
         push BodySize;
         ObjectAlign -> oldBodySize|;
         4 -> oldBodySize-;
         loop1:
         theRep[24+oldBodySize] -> value; { invalidates BodySize }
         value -> newRep[24+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop BodySize;
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { Initialize the extension part of newRep, pointed out by theRep. }
     
     { calculate the cell to store new rep in }
     pReg1 -> theItem;
     pReg2 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     { calculate difference in actual size }
     push oldBodySize;
     oldBodySize -> BodySize-; { invalidates BodySize }
     
     { STACK:
       <oldBodySize>
       <General stack layout>
     }
     
     (if BodySize > 0 then
         4 -> BodySize-;
         
         initloop:
         
         push BodySize;
         push Protect2Tag; { protect BodySize, oldBodySize }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <General stack layout>
         }
         
         { setup parameters for AlloC }
         newRep.iProto  -> RegCall;
         newRep.iOrigin -> pReg1; { destroys original pReg1 }
         
         { Allocate component }
         clear AddrReg1; { clear(theRep, theCell) before AlloC }
         call AlloC; { Destroys: RegCall(output), DataReg1, DataReg2, AddrReg1,
                       AddrReg2. 
                       May also destroy pReg1,2,3,4,5 via G-parts.
                     }
         { AlloC returns component in RegCall }
         
         { recalculate newRep - may have moved in GC caused by AlloC }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <General stack layout>
         } 
         
         stack[24] -> theItem;
         stack[16] -> offset;
         theItem[offset*4] -> newRep;
         
         { Calculate the address of the extension part using theRep register 
           (not newRep). 
         }
         stack[8] -> oldBodySize;
         newRep[24+oldBodySize][] -> theExt;
         
         { assign }
         4 -> SP+; { pop tag }
         pop BodySize;
         
         { STACK:
           <oldBodySize>
           <General stack layout>
         }
         
         theExt[BodySize][] -> theCell;
         RegCall { new comp } -> theCell[0];

         (if call_chkra_unconditionally then
             call ChkRA_EBP;
          else
             (if theCell outside IOA then
                 { The theCell resides in AOA and the comp in IOA }
                 push theCell;
                 call ChkRA { No need to remove parameter. }
             if);
         if);
         
         4 -> BodySize-;
         (if FLAGS >= 0 then goto initloop if);
         
         { STACK:
           <oldBodySize>
           <General stack layout>
         } 
     if);
     
     { STACK:
       <oldBodySize>
       <General stack layout>
     }

     pop oldBodySize;
     
     Finished:
              
     { STACK:
       <General stack layout>
     }
     
     { skip offset and tag }
     pop AddrReg1; { skip }
     pop AddrReg2; { skip }
     pop RegAdr; { restore RegAdr }
     { skip saved item }
     pop AddrReg1; { skip }
     { skip tag }
     pop AddrReg2; { skip }
     pop DataReg2, AddrReg2, AddrReg1 ;
     
     (if debug then call Ck; if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     { skip offset and tag }
     pop AddrReg1; { skip }
     pop AddrReg2; { skip }
     pop RegAdr; { restore RegAdr }
     { skip saved item }
     pop AddrReg1; { skip }
     { skip tag }
     pop AddrReg2; { skip }
     pop DataReg2, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     { Stack:
       <pReg1> (Object)
       - data registers are tagged properly.
     }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg1;
     goto again            { Go back to the beginning of this routine. }
  #)
