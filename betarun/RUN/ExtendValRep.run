------- ExtendValRep: System ----

ExtVR1: proc;
ExtVR2: proc;
ExtVR4: proc;
ExtVR8: proc;
ExtORR: proc;
ExtORRC: proc;

ExtVR: public { FIXME: Compiler should call specific functions directly }
  (#
     { Extend a value repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     theRep:      Repetition       = AddrReg2; { saved and restored }
     offset:      Long             = DataReg2;
     proto:       Long             = DataReg2;
  do 
     push AddrReg2;
     stack[12] -> theRep;
     stack[8] -> offset;
     theRep[offset*4] -> theRep;
     theRep.ProtoType -> proto;
     pop AddrReg2;
     (if proto = -6 then { ByteRepetition }
         goto ExtVR1;
     if);
     (if proto = -5 then { IntegerRepetition }
         goto ExtVR4;
     if);
     (if proto = -7 then { ShortRepetition }
         goto ExtVR2;
     if);
     (if proto = -8 then { DoubleRepetition }
         goto ExtVR8;
     if);
     (if proto = -10 then { ItemRepetition }
         goto ExtORR;
     if);
     (if proto = -11 then { CompRepetition }
         goto ExtORRC;
     if);
     (if debug then
         push RegThis;
         push -200;
         call BetaError;
     if);
     return;
  #);

ExtVR1: public
  (#
     { Extend a byte repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > 256 then
         
         { STACK:
           <General stack layout>
         }
         
         (if intel then
             push RegCall, RegThis; { 8 }
          else
             push RegCall, RegThis, DataRegA, DataRegB; { 16 }
         if);
         push addSize; {Save addSize}
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAAlloc. }
         push -6;  { Parameter to LVRAAlloc. }
         { 4 push: 16 }
         call LVRAAlloc;
         DataRegA -> newRep;
         
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then
                 stack[40 {16+8+16}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[44 {20+8+16}] -> DataRegA+; {item}
              else
                 (if MacOS then
                     stack[40 {8+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[44 {12+16+16}] -> DataRegA+; {item}
                  else
                     stack[36 {4+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40 {8+16+16}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         
         4 -> SP+; {Discard prototype parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop addSize; {Restore addSize}
         (if intel then
             pop  RegThis, RegCall;
          else
             pop  DataRegB, DataRegA, RegThis, RegCall;
         if);
         
         { STACK:
           <General stack layout>
         }
         
         (if newRep <> 0 then
             { recalculate theRep, it may have been moved by LVRACompaction }
             push newRange; { save newRange }
             { STACK:
               <newRange>
               <General stack layout>
             }
             { recalculate theRep, it may have been moved by LVRACompaction }
             (if intel then
                 stack[24] -> theRep;
                 stack[20]  -> offset; { invalidates newRange }              
              else
                 (if MacOS then
                     stack[16] -> theRep;
                     stack[12]  -> offset; { invalidates newRange }              
                  else
                     stack[12] -> theRep;
                     stack[8] -> offset; { invalidates newRange }
                 if);
             if);
             theRep[offset*4] -> theRep;
             pop newRange; { restore Newrange }
             
             { Calculate BodySize of new repetition }
             push RegCall; { save RegCall }
             
             { STACK:
               <RegCall>
               <General stack layout>
             }
             
             newRange -> BodySize; { invalidates RegCall }
             4 -> BodySize+;
             4 -> BodySize/; 
             4 -> BodySize*;
             goto copyBody 
         if)
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     push RegCall; { save RegCall }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { invalidates RegCall }
     4 -> BodySize+;
     4 -> BodySize/; 
     
     IOAalloc:
     
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -6               -> newRep.ProtoType;
     1                -> newRep.Age;
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4 -> oldBodySize+;
         4 -> oldBodySize/; 
         4->oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     push theRep;
     (if intel then
         stack[32] -> theCell;
         stack[28]  -> offset;
      else
         (if MacOS then 
             stack[24] -> theCell;
             stack[20]  -> offset;
          else
             stack[20] -> theCell;
             stack[16] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     pop theRep;
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR2: public
  (#
     { Extend a short repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > 256 then
         
         { STACK:
           <General stack layout>
         }
         
         (if intel then
             push RegCall, RegThis; { 8 }
          else
             push RegCall, RegThis, DataRegA, DataRegB; { 16 }
         if);
         push addSize; {Save addSize}
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAAlloc. }
         push -7;  { Parameter to LVRAAlloc. }
         { 4 push: 16 }
         call LVRAAlloc;
         DataRegA -> newRep;
         
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then
                 stack[40 {16+8+16}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[44 {20+8+16}] -> DataRegA+; {item}
              else
                 (if MacOS then
                     stack[40 {8+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[44 {12+16+16}] -> DataRegA+; {item}
                  else
                     stack[36 {4+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40 {8+16+16}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         
         4 -> SP+; {Discard prototype parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop addSize; {Restore addSize}
         (if intel then
             pop  RegThis, RegCall;
          else
             pop  DataRegB, DataRegA, RegThis, RegCall;
         if);
         
         { STACK:
           <General stack layout>
         }
         
         (if newRep <> 0 then
             { recalculate theRep, it may have been moved by LVRACompaction }
             push newRange; { save newRange }
             { STACK:
               <newRange>
               <General stack layout>
             }
             { recalculate theRep, it may have been moved by LVRACompaction }
             (if intel then
                 stack[24] -> theRep;
                 stack[20]  -> offset; { invalidates newRange }              
              else
                 (if MacOS then
                     stack[16] -> theRep;
                     stack[12]  -> offset; { invalidates newRange }              
                  else
                     stack[12] -> theRep;
                     stack[8] -> offset; { invalidates newRange }
                 if);
             if);
             theRep[offset*4] -> theRep;
             pop newRange; { restore Newrange }
             
             { Calculate BodySize of new repetition }
             push RegCall; { save RegCall }
             
             { STACK:
               <RegCall>
               <General stack layout>
             }
             
             newRange -> BodySize; { invalidates RegCall }
             2 -> BodySize*;
             3 -> BodySize+;
             4 -> BodySize/; 
             4 -> BodySize*;
             goto copyBody 
         if)
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     push RegCall; { save RegCall }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { invalidates RegCall }
     2 -> BodySize*;
     3 -> BodySize+;
     4 -> BodySize/; 
     
     IOAalloc:
     
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -7               -> newRep.ProtoType;
     1                -> newRep.Age;
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         2 -> oldBodySize*;
         3 -> oldBodySize+;
         4 -> oldBodySize/; 
         4 -> oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     (if intel then
         stack[28] -> theCell;
         stack[24]  -> offset;
      else
         (if MacOS then 
             stack[20] -> theCell;
             stack[16]  -> offset;
          else
             stack[16] -> theCell;
             stack[12] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR4: public
  (#
     { Extend an integer repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > 256 then
         
         { STACK:
           <General stack layout>
         }
         
         (if intel then
             push RegCall, RegThis; { 8 }
          else
             push RegCall, RegThis, DataRegA, DataRegB; { 16 }
         if);
         push addSize; {Save addSize}
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAAlloc. }
         push -5;  { Parameter to LVRAAlloc. }
         { 4 push: 16 }
         call LVRAAlloc;
         DataRegA -> newRep;
         
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then
                 stack[40 {16+8+16}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[44 {20+8+16}] -> DataRegA+; {item}
              else
                 (if MacOS then
                     stack[40 {8+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[44 {12+16+16}] -> DataRegA+; {item}
                  else
                     stack[36 {4+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40 {8+16+16}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         
         4 -> SP+; {Discard prototype parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop addSize; {Restore addSize}
         (if intel then
             pop  RegThis, RegCall;
          else
             pop  DataRegB, DataRegA, RegThis, RegCall;
         if);
         
         { STACK:
           <General stack layout>
         }
         
         (if newRep <> 0 then
             { recalculate theRep, it may have been moved by LVRACompaction }
             push newRange; { save newRange }
             { STACK:
               <newRange>
               <General stack layout>
             }
             { recalculate theRep, it may have been moved by LVRACompaction }
             (if intel then
                 stack[24] -> theRep;
                 stack[20]  -> offset; { invalidates newRange }              
              else
                 (if MacOS then
                     stack[16] -> theRep;
                     stack[12]  -> offset; { invalidates newRange }              
                  else
                     stack[12] -> theRep;
                     stack[8] -> offset; { invalidates newRange }
                 if);
             if);
             theRep[offset*4] -> theRep;
             pop newRange; { restore Newrange }
             
             { Calculate BodySize of new repetition }
             push RegCall; { save RegCall }
             
             { STACK:
               <RegCall>
               <General stack layout>
             }
             
             newRange -> BodySize; { invalidates RegCall }
             4 -> BodySize*;
             goto copyBody 
         if)
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     push RegCall; { save RegCall }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { invalidates RegCall }
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -5               -> newRep.ProtoType;
     1                -> newRep.Age;
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4->oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     (if intel then
         stack[28] -> theCell;
         stack[24]  -> offset;
      else
         (if MacOS then 
             stack[20] -> theCell;
             stack[16]  -> offset;
          else
             stack[16] -> theCell;
             stack[12] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #);

ExtVR8: public
  (#
     { Extend a double repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     LVRAcheck:
     (if newRange > 256 then
         
         { STACK:
           <General stack layout>
         }
         
         (if intel then
             push RegCall, RegThis; { 8 }
          else
             push RegCall, RegThis, DataRegA, DataRegB; { 16 }
         if);
         push addSize; {Save addSize}
         push theRep; {Save theRep}
         push newRange;  { Parameter to LVRAAlloc. }
         push -8;  { Parameter to LVRAAlloc. }
         { 4 push: 16 }
         call LVRAAlloc;
         DataRegA -> newRep;
         
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then
                 stack[40 {16+8+16}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[44 {20+8+16}] -> DataRegA+; {item}
              else
                 (if MacOS then
                     stack[40 {8+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[44 {12+16+16}] -> DataRegA+; {item}
                  else
                     stack[36 {4+16+16}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40 {8+16+16}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         
         4 -> SP+; {Discard prototype parameter}
         pop newRange; {Restore newRange}
         pop theRep; {Restore theRep}
         pop addSize; {Restore addSize}
         (if intel then
             pop  RegThis, RegCall;
          else
             pop  DataRegB, DataRegA, RegThis, RegCall;
         if);
         
         { STACK:
           <General stack layout>
         }
         
         (if newRep <> 0 then
             { recalculate theRep, it may have been moved by LVRACompaction }
             push newRange; { save newRange }
             { STACK:
               <newRange>
               <General stack layout>
             }
             { recalculate theRep, it may have been moved by LVRACompaction }
             (if intel then
                 stack[24] -> theRep;
                 stack[20]  -> offset; { invalidates newRange }              
              else
                 (if MacOS then
                     stack[16] -> theRep;
                     stack[12]  -> offset; { invalidates newRange }              
                  else
                     stack[12] -> theRep;
                     stack[8] -> offset; { invalidates newRange }
                 if);
             if);
             theRep[offset*4] -> theRep;
             pop newRange; { restore Newrange }
             
             { Calculate BodySize of new repetition }
             push RegCall; { save RegCall }
             
             { STACK:
               <RegCall>
               <General stack layout>
             }
             
             newRange -> BodySize; { invalidates RegCall }
             8 -> BodySize*; 
             goto copyBody 
         if)
     if);
     { end LVRAcheck }
     
     { Calculate BodySize of new repetition }
     push RegCall; { save RegCall }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { invalidates RegCall }
     8 -> BodySize*; 
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -8               -> newRep.ProtoType;
     1                -> newRep.Age;
     1                -> newRep.LowBorder;
     newRange         -> newRep.HighBorder;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         8 -> oldBodySize*;
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[16+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[16+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     (if intel then
         stack[28] -> theCell;
         stack[24]  -> offset;
      else
         (if MacOS then 
             stack[20] -> theCell;
             stack[16]  -> offset;
          else
             stack[16] -> theCell;
             stack[12] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #);

ExtORR: public
  (#
     { Extend an item repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     newObjRep:   ObjectRepetition = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theObjRep:   ObjectRepetition = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     push RegCall;
         
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { destroys bodysize/RegCall }
     IOATop -> newRep;
     4 -> BodySize*;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -10               -> newRep.ProtoType;
     1                 -> newRep.Age;
     1                 -> newRep.LowBorder;
     newRange          -> newRep.HighBorder;
     theObjRep.iProto  -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4->oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[24+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[24+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { Initialize the extension part of newRep, pointed out by theRep. }
     
     { AssignObjReference: not reached for ordinary repetitions }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     (if intel then
         stack[28] -> theCell;
         stack[24]  -> offset;
      else
         (if MacOS then 
             stack[20] -> theCell;
             stack[16]  -> offset;
          else
             stack[16] -> theCell;
             stack[12] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { calculate difference in actual size }
     push oldBodySize;
     oldBodySize -> BodySize-; { invalidates BodySize }
     
     { STACK:
       <oldBodySize>
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if BodySize > 0 then
         4 -> BodySize-;
         
         initloop:
         
         push BodySize;
         push -7; { protect BodySize, oldBodySize, DataReg3, but NOT RegCall }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         }
         
         { setup parameters for AlloI/AlloC }
         
         (if intel then
             newObjRep.iProto  -> RegCall;
             newObjRep.iOrigin -> pReg1;
          else
             newObjRep.iProto  -> RegCall;
             newObjRep.iOrigin -> DataReg1; { destroys oldBodySize, addSize }
         if);
         
         { Allocate item/component }
         
         (if hp then
             AddrReg1 -> AddrReg1-; { clear AddrReg1 (theRep, theCell) before AlloI/C }
          else
             0 -> AddrReg1; { clear AddrReg1 (theRep, theCell) before AlloI/C }
         if);

         call AlloI; { Destroys: RegCall(output), DataReg1, DataReg2, AddrReg1, AddrReg2. 
                       On intel DataReg1 is DataRegA, and DataReg2 is DataRegB.
                     }
         { AlloI returns item in RegCall }
         
         { recalculate newObjRep - may have moved in GC caused by AlloI/C }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         } 
         
         (if intel then
             stack[40] -> newObjRep;
             stack[36]  -> offset; { invalidates newRange }              
          else
             (if MacOS then
                 stack[32] -> newObjRep;
                 stack[28]  -> offset; { invalidates newRange }              
              else
                 stack[28] -> newObjRep;
                 stack[24] -> offset; { invalidates newRange }
             if);
         if);
         newObjRep[offset*4] -> newObjRep;
         
         { Calculate the address of the extension part using theRep register (not newRep). }
         stack[8] -> oldBodySize;
         newObjRep[24+oldBodySize][] -> theExt;
         
         { assign }
         4 -> SP+; { pop tag }
         RegCall -> DataReg2; { save the newly allocated item/component }
         pop BodySize;
         
         { STACK:
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         }
         
         theExt[BodySize][] -> theCell;
         DataReg2 { new item/comp } -> theCell[0];
         (if theCell outside IOA then  { The theCell resides in AOA and the item in IOA  }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
         4 -> BodySize-;
         (if FLAGS >= 0 then goto initloop if);
         
         { STACK:
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         } 
     if);
     
     { STACK:
       <oldBodySize>
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     4 -> SP+; { pop oldBodySize }
     
     Finished:
              
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #);

ExtORRC: public
  (#
     { Extend a component repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     {                           ^ in longs             }
     
     { Input variable. }
     addSize: Long      = DataReg1; { The size (in range units) by which }
                                    { to extend the repetition }
                                    {pReg1 in Intel version}
     
     { Used variables. }
     stack:       StackArea        = SP;
     newRep:      Repetition       = AddrReg2;
     newObjRep:   ObjectRepetition = AddrReg2;
     
     newTop:      DataArea         = AddrReg1;
     theRep:      Repetition       = AddrReg1;
     theExt:      Repetition       = AddrReg1;
     theObjRep:   ObjectRepetition = AddrReg1;
     theCell:     DataArea         = AddrReg1;
     
     newRange:    Long             = DataReg2;
     BodySize:    Long             = RegCall; { Saved and restored. }
     offset:      Long             = DataReg2;
     
     oldBodySize: Long             = DataReg1;
     value:       Long             = DataReg3  { Saved and restored. }
  do
     (if debug then 1 -> NumExtVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +12   Mac: +4    Default: +0
       <offset>            Intel: +16   Mac: +8    Default: +4
       <item>              Intel: +20   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         stack[20] -> theRep;
         stack[16] -> offset;
      else
         (if MacOS then
             stack[12] -> theRep;
             stack[8] -> offset;
          else
             stack[8] -> theRep;
             stack[4] -> offset;
         if);
     if);
     theRep[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange; { invalidates offset }
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }
     
     { STACK:
       <General stack layout>
     }
     
     push RegCall;
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     newRange -> BodySize; { destroys bodysize/RegCall }
     IOATop -> newRep;
     4 -> BodySize*;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated, but not assigned yet!}
     
     { STACK:
       <RegCall>
       <General stack layout>
     } 
     
     { recalculate theRep, it has been invalidated above }
     push newRange; { save newRange }
     { STACK:
       <newRange/DataReg2>
       <RegCall>
       <General stack layout>
     } 
     (if intel then
         stack[28] -> theRep;
         stack[24]  -> offset; { invalidates newRange }              
      else
         (if MacOS then
             stack[20] -> theRep;
             stack[16]  -> offset; { invalidates newRange }              
          else
             stack[16] -> theRep;
             stack[12] -> offset; { invalidates newRange }
         if);
     if);
     theRep[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     { STACK:
       <RegCall>
       <General stack layout>
     }
     
     { Initialize the structual part of the repetition. }
     -11               -> newRep.ProtoType;
     1                 -> newRep.Age;
     1                 -> newRep.LowBorder;
     newRange          -> newRep.HighBorder;
     theObjRep.iProto  -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
     
     copyBody: { Copy the body part of theRep to newRep. }
     
     { calculate bodysize of old repetition }
     (if addSize > 0 then			
         theRep.HighBorder -> oldBodySize; { invalidates addSize }
	 goto calcBody				
     if);							
     newRange -> oldBodySize; 
     calcBody:						
     (if oldBodySize > 0 then
         4->oldBodySize*
     if);
     
     push DataReg3; { save DataReg3 }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if oldBodySize > 0 then
         push oldBodySize;
         4 -> oldBodySize-;
         loop1:
         theRep[24+oldBodySize] -> value; { invalidates DataReg3 }
         value -> newRep[24+oldBodySize];
         4 -> oldBodySize-;
         (if FLAGS >= 0 then goto loop1 if);
         
         { Copying of old elements DONE }
         pop oldBodySize;
     if);
     
     AssignReference: 
     
     { Initialize the extension part of newRep, pointed out by theRep. }
     
     { AssignObjReference: not reached for ordinary repetitions }
     
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     { calculate the cell to store new rep in }
     (if intel then
         stack[28] -> theCell;
         stack[24]  -> offset;
      else
         (if MacOS then 
             stack[20] -> theCell;
             stack[16]  -> offset;
          else
             stack[16] -> theCell;
             stack[12] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { calculate difference in actual size }
     push oldBodySize;
     oldBodySize -> BodySize-; { invalidates BodySize }
     
     { STACK:
       <oldBodySize>
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     (if BodySize > 0 then
         4 -> BodySize-;
         
         initloop:
         
         push BodySize;
         push -7; { protect BodySize, oldBodySize, DataReg3, but NOT RegCall }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         }
         
         { setup parameters for AlloI/AlloC }
         
         (if intel then
             newObjRep.iProto  -> RegCall;
             newObjRep.iOrigin -> pReg1;
          else
             newObjRep.iProto  -> RegCall;
             newObjRep.iOrigin -> DataReg1; { destroys oldBodySize, addSize }
         if);
         
         { Allocate item/component }
         
         (if hp then
             AddrReg1 -> AddrReg1-; { clear AddrReg1 (theRep, theCell) before AlloI/C }
          else
             0 -> AddrReg1; { clear AddrReg1 (theRep, theCell) before AlloI/C }
         if);

         call AlloC; { Destroys: RegCall(output), DataReg1, DataReg2, AddrReg1, AddrReg2. 
                       On intel DataReg1 is DataRegA, and DataReg2 is DataRegB.
                     }
         { AlloC returns item in RegCall }
         
         { recalculate newObjRep - may have moved in GC caused by AlloI/C }
         
         { STACK:
           <tag>
           <BodySize>
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         } 
         
         (if intel then
             stack[40] -> newObjRep;
             stack[36]  -> offset; { invalidates newRange }              
          else
             (if MacOS then
                 stack[32] -> newObjRep;
                 stack[28]  -> offset; { invalidates newRange }              
              else
                 stack[28] -> newObjRep;
                 stack[24] -> offset; { invalidates newRange }
             if);
         if);
         newObjRep[offset*4] -> newObjRep;
         
         { Calculate the address of the extension part using theRep register (not newRep). }
         stack[8] -> oldBodySize;
         newObjRep[24+oldBodySize][] -> theExt;
         
         { assign }
         4 -> SP+; { pop tag }
         RegCall -> DataReg2; { save the newly allocated item/component }
         pop BodySize;
         
         { STACK:
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         }
         
         theExt[BodySize][] -> theCell;
         DataReg2 { new item/comp } -> theCell[0];
         (if theCell outside IOA then  { The theCell resides in AOA and the item in IOA  }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
         4 -> BodySize-;
         (if FLAGS >= 0 then goto initloop if);
         
         { STACK:
           <oldBodySize>
           <DataReg3>
           <RegCall>
           <General stack layout>
         } 
     if);
     
     { STACK:
       <oldBodySize>
       <DataReg3>
       <RegCall>
       <General stack layout>
     }

     4 -> SP+; { pop oldBodySize }
     
     Finished:
              
     { STACK:
       <DataReg3>
       <RegCall>
       <General stack layout>
     }
     
     pop DataReg3; { restore DataReg3 }
     pop RegCall; { restore RegCall }
     
     { STACK:
       <General stack layout>
     }
          
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop RegCall; { Restore RegCall }
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)
