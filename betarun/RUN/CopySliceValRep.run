---- CopySliceValRep: System ----

CopySVR1: public
  (#
     { Copy a slice of a Byte Repetition. }

     { stack on entry [return(0),...] }

     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
     { Low:        pReg4 }
     { High:       pReg5 }
     
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
     low:       Long             = DataReg1; 
     high:      Long             = DataReg2; 
  do
     (if debug then 1 -> NumCopySVR1+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8  
     }
     
     push AddrReg1, AddrReg2;
     
     pReg1 -> theRep;
     pReg4 -> low;
     pReg5 -> high;
     
     { Check that low and high are usable. }
     (if low < theRep.LowBorder then 
         12 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         12 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if); 
     { high is now converted to the range of the resulting repetition. }     
     
     { FIXME: LVRA missing }
     
     again:
     
     push RegAdr;
     
     high -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     pReg1 -> theRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     ByteRepPTValue    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if high <> 0 then
         1 -> low-;
         theRep[low][] -> theRep; { Start at low. }
         0 -> newRep[16+high]!b; { terminating 0-byte }
         1 -> high-;
         loop1:
         theRep[16+high]!b -> value!b;
         value!b -> newRep[16+high]!b;
         1 -> high-;
         (if FLAGS >= 0 then goto loop1 if);
     if);

     pReg2 -> theItem;
     pReg3 -> offset;
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     pReg1 -> theRep;

     goto again
  #);

CopySVR2: public
  (#
     { Copy a slice of a Short Repetition. }
     { stack on entry [return(0),...] }

     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
     { Low:        pReg4 }
     { High:       pReg5 }
     
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
     low:       Long             = DataReg1; 
     high:      Long             = DataReg2; 

  do
     (if debug then 1 -> NumCopySVR2+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8
     }
     
     push AddrReg1, AddrReg2;
     
     pReg1 -> theRep;
     pReg4 -> low;
     pReg5 -> high;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         12 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         12 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }     
     
     { FIXME: LVRA missing }
     
     again:
     
     push RegAdr;
     
     high -> BodySize;
     2 -> BodySize*;
     3 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     pReg1 -> theRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     ShortRepPTValue    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if high <> 0 then
         1 -> low-;
         theRep[low*2][] -> theRep; { Start at low*2. }
         1 -> high-;
         loop2:
         theRep[16+high*2]!w -> value!w;
         value!w -> newRep[16+high*2]!w;
         1 -> high-;
         (if FLAGS >= 0 then goto loop2 if);
     if);
     
     pReg2 -> theItem;
     pReg3 -> offset;
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     pReg1 -> theRep;

     goto again
  #);

CopySVR4: public
  (#
     { Copy a slice of an Integer Repetition. }
     { stack on entry [return(0),...] }

     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
     { Low:        pReg4 }
     { High:       pReg5 }
     
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
     low:       Long             = DataReg1; 
     high:      Long             = DataReg2; 

  do
     (if debug then 1 -> NumCopySVR4+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8
     }
     
     push AddrReg1, AddrReg2;
     
     pReg1 -> theRep;
     pReg4 -> low;
     pReg5 -> high;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         12 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         12 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }     
     
     { FIXME: LVRA missing }
     
     again:
     
     push RegAdr;
     
     high -> BodySize;
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     pReg1 -> theRep;
    
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     LongRepPTValue    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if high <> 0 then
         push newRep;
         1 -> low-;
         theRep[low*4][] -> theRep; { Start at low*4. }
         1 -> high-;
         loop3:
         theRep[16+high*4] -> value;
         value -> newRep[16+high*4];
         1 -> high-;
         (if FLAGS >= 0 then goto loop3 if);
         pop newRep;
     if);
     
     pReg2 -> theItem;
     pReg3 -> offset;
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     pReg1 -> theRep;

     goto again
  #);

CopySVR8: public
  (#
     { Copy a slice of a Double Repetition. }
     { stack on entry [return(0),...] }

     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
     { Low:        pReg4 }
     { High:       pReg5 }
     
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
     low:       Long             = DataReg1; 
     high:      Long             = DataReg2; 

  do
     (if debug then 1 -> NumCopySVR8+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8
     }
     
     push AddrReg1, AddrReg2;
     
     pReg1 -> theRep;
     pReg4 -> low;
     pReg5 -> high;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         12 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         12 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }     
     
     { FIXME: LVRA missing }
     
     again:
     
     push RegAdr;
     
     high -> BodySize;
     8 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     pReg1 -> theRep;
    
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DoubleRepPTValue    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if high <> 0 then
         1 -> low-;
         theRep[low*8][] -> theRep; { Start at low*8. }
         1 -> high-;
         loop4:
         theRep[16+high*8] -> value;
         value -> newRep[16+high*8];
         theRep[20+high*8] -> value;
         value -> newRep[20+high*8];
         1 -> high-;
         (if FLAGS >= 0 then goto loop4 if);
     if);
     
     pReg2 -> theItem;
     pReg3 -> offset;
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     pReg1 -> theRep;

     goto again
  #);

CopySVRI: public { FIXME: parameters }
  (#
     { Copy a slice of an Item Repetition. }
     { stack on entry [return(0),offset(4),Item(8),ValRep(12),...] }
     
     { Input variable.  }
     low:     Long    = DataReg1; {pReg1 in Intel version}
     high:    Long    = DataReg2; {pReg2 in Intel version}
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     theObjRep: ObjectRepetition = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     newObjRep: ObjectRepetition = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
  do
     (if debug then 1 -> NumCopySVRI+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8 
       <offset>            +12
       <item>              +16
       <valrep>            +20
     }
     
     pReg1 -> DataReg1; pReg2 -> DataReg2;
     
     push AddrReg1, AddrReg2;
     
     stack[20] -> theRep;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         24 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         24 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }     
     
     
     again:
     
     push RegAdr;
     
     high -> BodySize;
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     stack[20] -> theRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DynItemRepPTValue   -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { set up iProto and iOrigin }
     theObjRep.iProto -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
     
     (if high <> 0 then
         push newRep;
         8 -> theRep+; { larger header }
         8 -> newRep+; { larger header }
         1 -> low-;
         theRep[low*4][] -> theRep; { Start at low*4. }
         1 -> high-;
         loop3:
         theRep[16+high*4] -> value;
         value -> newRep[16+high*4];
         1 -> high-;
         (if FLAGS >= 0 then goto loop3 if);
         pop newRep;
         { goto assign no need - save a jump }
     if);
     
     assign:
     
     stack[16] -> theItem;
     stack[12] -> offset;
     
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return 12;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     {... and by popping the original value}
     stack[20] -> theRep;
     
     goto again
  #);

CopySVRC: public { FIXME: parameters }
  (#
     { Copy a slice of a Component Repetition. }
     { stack on entry [return(0),offset(4),Item(8),ValRep(12),...] }
     
     { Input variable.  }
     low:     Long    = DataReg1; {pReg1 in Intel version}
     high:    Long    = DataReg2; {pReg2 in Intel version}
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     theObjRep: ObjectRepetition = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegThis;
     
     newRep:    Repetition       = AddrReg2;
     newObjRep: ObjectRepetition = AddrReg2;
     
     BodySize:  Long             = RegAdr; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
  do
     (if debug then 1 -> NumCopySVRC+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <AddrReg2>          +0
       <AddrReg1>          +4
       <return address>    +8 
       <offset>            +12 
       <item>              +16 
       <valrep>            +20
     }
     
     pReg1 -> DataReg1; pReg2 -> DataReg2;
     
     push AddrReg1, AddrReg2;
     
     stack[20] -> theRep;
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         24 -> stack+; push theObj; push RepLowRangeErr; call BetaError; 
     if);
     (if high > theRep.HighBorder then 
         24 -> stack+; push theObj; push RepHighRangeErr; call BetaError; 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }     
      
     again:
     
     push RegAdr;
     
     high -> BodySize;
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop RegAdr;
     
     { Restore theRep; it was destroyed by newTop }
     stack[20] -> theRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DynItemRepPTValue               -> newRep.ProtoType;
     1                 -> newRep.Age;
     1                 -> newRep.LowBorder;
     high              -> newRep.HighBorder;
     theObjRep.iProto  -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
     
     { Copy the body part of the repetition. }
     (if high <> 0 then
         push newRep;
         8 -> theRep+; { larger header }
         8 -> newRep+; { larger header }
         1 -> low-;
         theRep[low*4][] -> theRep; { Start at low*4. }
         1 -> high-;
         loop3:
         theRep[16+high*4] -> value;
         value -> newRep[16+high*4];
         1 -> high-;
         (if FLAGS >= 0 then goto loop3 if);
         pop newRep;
     if);
     
     stack[16] -> theItem;
     stack[12] -> offset;
     
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return 12;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop RegAdr; {Finished using BodySize; restore RegAdr}
     
     pop AddrReg2, AddrReg1;
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     call doGC;              { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     push AddrReg1, AddrReg2;
     
     {Restore theRep; it was destroyed by newtop}
     {... and by popping the original value}
     stack[20] -> theRep;

     goto again
  #)
