---- CopySliceValRep: System ----

CopySVR: public
  (#
     { Copy a slice of a Value Repetition. }
     { stack on entry [return(0),offset(4),Item(8),ValRep(12),...] }
     { and registers DataReg1=low, DataReg2=high. }
     
     { Input variable.  }
     low:     Long    = DataReg1;
     high:    Long    = DataReg2;
     
     { Used variable.  }
     stack:  StackArea  = SP;    
     theRep: Repetition = AddrReg1;
     theObj: Object     = RegObj;
     newRep: Repetition = AddrReg2;
     newTop: DataArea   = AddrReg1;
     BodySize: Long     = DataRegA;
     value:  Long       = DataReg1;
     offset: Long       = DataReg1;
     theItem: Item      = AddrReg1;
     theCell: DataArea  = AddrReg1
  do
     stack[12] -> theRep;
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder   then push theObj; push -6; call BetaError if);
     (if high > theRep.HighBorder  then push theObj; push -7; call BetaError if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     { high is now converted to the range of the resulting repetition. }
     
     (if MacOS then push AddrReg2 if);
     
     again:
     
     high -> BodySize;
     (if theRep.ProtoType = -8 then { double rep }
         2 -> BodySize*;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -7 then { word rep }
         2 -> BodySize*;
         3 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -6 then { byte rep }
         4 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     IOAalloc:
     4 -> BodySize*;
     IOATop -> newRep;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     (if MacOS then
         { AddrReg2 is on the stack. }
         stack[16] -> theRep
      else
         stack[12] -> theRep
     if);
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     theRep.ProtoType -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     { Copy the body part of the repetition. }
     (if theRep.ProtoType = -6 then { byte rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low][] -> theRep; { Start at low. }
             0 -> newRep[16+high]!b; { terminating 0-byte }
             1 -> high-;
             loop1:
             theRep[16+high]!b -> value;
             value!b -> newRep[16+high];
             1 -> high-;
             (if FLAGS >= 0 then goto loop1 if);
             goto assign
         if)
     if);
     (if theRep.ProtoType = -7 then { word rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low][] -> theRep; { Start at low. }
             2 -> high-;
             loop2:
             theRep[16+high*2]!w -> value;
             value!w -> newRep[16+high*2];
             1 -> high-;
             (if FLAGS >= 0 then goto loop2 if);
             goto assign
         if)
     if);
     (if theRep.ProtoType = -5 then { long rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low][] -> theRep; { Start at low. }
             1 -> high-;
             loop3:
             theRep[16+high*4] -> value;
             value -> newRep[16+high*4];
             1 -> high-;
             (if FLAGS >= 0 then goto loop3 if);
             goto assign
         if)
     if);
     (if theRep.ProtoType = -8 then { double rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low][] -> theRep; { Start at low. }
             1 -> high-;
             loop4:
             theRep[16+high*4] -> value;
             value -> newRep[16+high*4];
             theRep[20+high*4] -> value;
             value -> newRep[20+high*4];
             1 -> high-;
             (if FLAGS >= 0 then goto loop4 if);
             goto assign
         if)
     if);
     
     assign:
     (if MacOS then
         { AddrReg2 is on the stack. }
         stack[12] -> theItem;
         stack[8] -> offset
      else
         stack[8] -> theItem;
         stack[4] -> offset
     if);
     
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     (if MacOS then pop AddrReg2 if);
     return 12;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     call DoGC;              { Call the Garbage Collector.               }
     { restore theRep; it was destroyed by newtop: }
     (if MacOS then
         { AddrReg2 is on the stack. }
         stack[16] -> theRep
      else
         stack[12] -> theRep
     if);
     goto again              { Go back to the beginning of this routine. }
  #)
