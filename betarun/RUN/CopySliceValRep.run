---- CopySliceValRep: System ----

CopySVR: public
  (#
     { Copy a slice of a Value Repetition. }
     { stack on entry [return(0),offset(4),Item(8),ValRep(12),...] }
     
     {*** PROBLEM: GC MAY BE TRIGGERED WITH VALREP REFERENCE ON STACK ***}
     {*** IN WHICH CASE IT IS *NOT* UPDATED! (FORTUNATELY, IT IS      ***}
     {*** USUALLY SAFE TO READ DATA FROM THE OLD FROM-SPACE COPY.     ***}
     {*** ONLY IF THE IOA COLLECTION TRIGGERS AN AOA COLLECTION, THE  ***}
     {*** FROM-SPACE COPY MAY BE OVERWRITTEN (BY RootsToAOATable) IN  ***}
     {*** WHICH CASE THE ROUTINE WILL FAIL!!!)                        ***}
     
     {*** SOLUTION: PASS REFERENCE TO AND OFFSET WITHIN (UNIQUE)      ***}
     {*** OBJECT CONTAINING VALREP REFERENCE, RATHER THAN VALREP      ***}
     {*** REFERENCE ITSELF.                                           ***}
     
     { Input variable.  }
     low:     Long    = DataReg1; {pReg1 in Intel version}
     high:    Long    = DataReg2; {pReg2 in Intel version}
     
     { Used variable.  }
     stack:     StackArea        = SP;    
     theRep:    Repetition       = AddrReg1;
     theObjRep: ObjectRepetition = AddrReg1;
     newTop:    DataArea         = AddrReg1;
     theItem:   Item             = AddrReg1;
     theCell:   DataArea         = AddrReg1;
     
     theObj:    Object           = RegObj;
     
     newRep:    Repetition       = AddrReg2;
     newObjRep: ObjectRepetition = AddrReg2;
     
     BodySize:  Long             = DataReg3; { saved and restored }
     
     value:     Long             = DataReg1;
     offset:    Long             = DataReg1;
  do
     (if debug then 1 -> NumCopySVR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <Intel: AddrReg2>   Intel: +0
       <Intel: AddrReg1>   Intel: +4
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +8    Mac: +4    Default: +0
       <offset>            Intel: +12   Mac: +8    Default: +4
       <item>              Intel: +16   Mac: +12   Default: +8
       <valrep>            Intel: +20   Mac: +16   Default: +12
     }
     
     (if intel then pReg1 -> DataReg1; pReg2 -> DataReg2; if);
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2 if);
     
     (if intel then
         stack[20] -> theRep;
      else 
         (if MacOs then
             stack[16] -> theRep;
          else
             stack[12] -> theRep;
         if);
     if);
     
     { Check that low and high are usable. }
     (if low  < theRep.LowBorder then 
         (if intel then 
             24 -> stack+ 
          else
             16-> stack+;
         if);
         (if MacOS then 4 -> stack+ if);
         push theObj; push -6; call BetaError 
     if);
     (if high > theRep.HighBorder then 
         (if intel then 
             24 -> stack+ 
          else
             16-> stack+;
         if);
         (if MacOS then 4 -> stack+ if); 
         push theObj; push -7; call BetaError 
     if);
     
     { Calculate the range of the new repetition. }
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if); { OBS: low>high confuses chk2 }
     { high is now converted to the range of the resulting repetition. }     
     
     { LVRA missing }
     
     again:
     
     push DataReg3;
     
     high -> BodySize;
     (if theRep.ProtoType = -8 then { double rep }
         2 -> BodySize*;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -7 then { word rep }
         2 -> BodySize*;
         3 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -6 then { byte rep }
         4 -> BodySize+;
         4 -> BodySize/;
         {goto IOAalloc} {No need, save a jump}
     if);
     { fall through: LongRep, ItemRep, CompRep }
     
     IOAalloc:
     
     4 -> BodySize*;
     IOATop -> newRep;
     (if theRep.ProtoType <= -10 then { ObjectRepetition }
         newRep[24+BodySize][] -> newTop;
         goto CheckGC;
     if);
     newRep[16+BodySize][] -> newTop;
     
     CheckGC:
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     pop DataReg3;
     
     { Restore theRep; it was destroyed by newTop }
     (if intel then 
         stack[20] -> theRep;
      else 
         (if MacOS then 
             stack[16] -> theRep;
          else 
             stack[12] -> theRep 
         if) 
     if);
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     theRep.ProtoType -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     high  -> newRep.HighBorder;
     
     (if theRep.ProtoType <= -10 then { ObjectRepetition }
         { set up iProto and iOrigin }
         theObjRep.iProto -> newObjRep.iProto;
         theObjRep.iOrigin -> newObjRep.iOrigin;
     if);
     
     { Copy the body part of the repetition. }
     (if theRep.ProtoType = -6 then { byte rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low][] -> theRep; { Start at low. }
             0 -> newRep[16+high]!b; { terminating 0-byte }
             1 -> high-;
             loop1:
             theRep[16+high]!b -> value!b;
             value!b -> newRep[16+high]!b;
             1 -> high-;
             (if FLAGS >= 0 then goto loop1 if);
             goto assign
         if)
     if);
     (if theRep.ProtoType = -7 then { word rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low*2][] -> theRep; { Start at low*2. }
             1 -> high-;
             loop2:
             theRep[16+high*2]!w -> value!w;
             value!w -> newRep[16+high*2]!w;
             1 -> high-;
             (if FLAGS >= 0 then goto loop2 if);
             goto assign
         if)
     if);
     (if theRep.ProtoType = -8 then { double rep }
         (if high <> 0 then
             1 -> low-;
             theRep[low*8][] -> theRep; { Start at low*8. }
             1 -> high-;
             loop4:
             theRep[16+high*8] -> value;
             value -> newRep[16+high*8];
             theRep[20+high*8] -> value;
             value -> newRep[20+high*8];
             1 -> high-;
             (if FLAGS >= 0 then goto loop4 if);
             goto assign
         if)
     if);
     
     { fall through: LongRep, ItemRep, CompRep }
     (if high <> 0 then
         push newRep;
         (if theRep.ProtoType <= -10 then { ObjectRep }
             8 -> theRep+; { larger header }
             8 -> newRep+; { larger header }
         if);
         1 -> low-;
         theRep[low*4][] -> theRep; { Start at low*4. }
         1 -> high-;
         loop3:
         theRep[16+high*4] -> value;
         value -> newRep[16+high*4];
         1 -> high-;
         (if FLAGS >= 0 then goto loop3 if);
         pop newRep;
         { goto assign no need - save a jump }
     if);
     
     assign:
     
     (if intel then
         stack[16] -> theItem;
         stack[12] -> offset;
      else
         (if MacOS then
             stack[12] -> theItem;
             stack[8] -> offset;
          else
             stack[8] -> theItem;
             stack[4] -> offset;
         if);
     if);
     
     newRep -> theItem[offset*4];
     
     theItem[offset*4][] -> theCell;
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         (if hp then
             theCell -> theCell-; { clear AddrReg1 before ChkRA }
          else
             0 -> theCell; { clear AddrReg1 before ChkRA }
         if);         
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if debug then call Ck if);
     return 12;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop DataReg3; {Finished using BodySize; restore DataReg3}
     
     (if intel then pop AddrReg2, AddrReg1 if);
     call doGC;              { Call the Garbage Collector.               }
     (if intel then push AddrReg1, AddrReg2 if);
     
     {Restore theRep; it was destroyed by newtop}
     (if intel then {... and by popping the original value}
         stack[20] -> theRep
      else
         (if MacOS then
             stack[16] -> theRep
          else
             stack[12] -> theRep
         if);
     if);

     goto again
  #)
