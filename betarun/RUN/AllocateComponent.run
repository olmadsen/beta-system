------- AllocateComponent: System ----
AlloC: public
  (#
     { Allocate an Component. }
     
     { Input variable.  }
     protoType: ProtoType  = RegCall;
     { origin in pReg1 }
     
     { Output variable. }
     Argument:      DataArea   = RegCall;
     
     { Used variable.   }
     Size:          Word       = DataReg2;
     Offset:        Word       = DataReg2;
     DataReg2Long:  Long       = DataReg2; 
     TmpData:       Long      = DataReg1;
     Entry:         CodeArea   = DataReg1;
     TmpAddr:       Long      = { AddrReg1 } RegThis;
     initTab:       GCEntry   = { AddrReg1 } RegThis; { index in GC table of prototype }
     newTop:        DataArea   = { AddrReg1 } RegThis;
     theComp:       Component  = AddrReg2;
     stack:         StackArea  = SP;
     
  do
     (if alloc_trace then stack[0] -> AllocCallPoint if);
     (if debug then 1 -> NumAlloC+ if); 
     (if debug then call Ck if);
     
     { General Stack Layout:
       <DataReg2>
       <AddrReg2>
       <RegThis>
     }
     
     (if do_unconditional_GC then
	 (if DoUGC<>0 then
	     (if ActiveComponent<>0 then
		 { Don't do this before AttBC }
		 { See general comment in AllocateItem.run }
		 push { AddrReg1 } RegThis, AddrReg2, DataReg2Long;
		 0 -> Size!l;
		 protoType.Size -> Size;
		 goto GC;
	     if);
	 if);
     if);
     
     again:
     
     push { AddrReg1 } RegThis, AddrReg2, DataReg2Long;
     
     0 -> Size!l;
     protoType.Size -> Size;
     IOATop -> theComp;
     theComp[24+Size*4][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 2 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Component is now allocated, but not initialized yet!}
     
     { Initialize the structual part; prototype, age etc. }
     ComponentPTValue -> theComp.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theComp.GCAttr;
     if);
     
     { Initialize the item.protoType of the component. }
     protoType -> theComp[24]!l;
     (if COM then
         DISP_OFF -> theComp[24]+;
     if);
     { Initialize the item.GCAttr of the component. }
     -6        -> theComp[28]!l;
     
     { Initialize the body part of the item, according to the genTable. }
     0 -> initTab!l;
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     loop:
     0->Offset!l;
     initTab.StaticOff -> Offset;
     (if Offset!l<>0 then
         { Insert the distance to the autonomous object. }
         -1 -> TmpData;
         initTab.OrigOff -> TmpData!w;
         TmpData!l -> theComp[28+Offset*4];
         { Insert the protoType from the initTab. }
         initTab.Proto -> TmpData!l;
         (if COM then
             DISP_OFF -> TmpData+; { SETPROTO }
         if);
         TmpData!l -> theComp[24+Offset*4]!l;
         8 -> initTab+;
         goto loop
     if);
     
     { Store origin }
     0 -> Offset!l;
     pReg1 -> TmpAddr!l;
     protoType.OrigOff -> Offset;
     TmpAddr!l -> theComp[24+Offset*4];
     
     protoType.GenPart -> Entry;
     (if Entry=0 then 
         theComp->Argument; 
         goto CleanUp; 
     if);
     
     theComp[24][] -> Argument; { let argument point to the item part }
     clear AddrReg2; {Invalidate GC register}
     push Protect1Tag; {Protect DataReg2}
     { Stack:
       <tag1>
       <General Stack Layout>
       - data registers are tagged properly.
     }
     call Entry; { May cause GC }
     { Discard GC protection }
     pop TmpData!l { skip }; 
     Argument[-24][] -> Argument; { make argument point to the comp part }
     
     CleanUp:
     pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection. }
     Size!l -> ReqObjectSize; { Set the requested Object Size.}
     6      -> ReqObjectSize+;
     pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
     { Stack: as on entry }
     push pReg1; { update origin }
     { Stack:
       <pReg1>
       - data registers are tagged properly.
     }
     call doGC;  { Call the Garbage Collector. }
     pop pReg1;
     goto again;
  #)
