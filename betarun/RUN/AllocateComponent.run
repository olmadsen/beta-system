------- AllocateComponent: System ----
AlloC: public
  (#
     { Allocate an Component. }
     
     { Input variable.  }
     protoType: ProtoType = RegArg;
     origin:    Object    = RegAdr;
     
     Size:  Word = DataRegA;
     Tmp: Word = DataReg1;
     
     theObj: Item = RegObj;
     
     initTab: CodeArea = AddrReg1;
     genTab:  CodeArea = RegArg;
     
     Argument: DataArea = RegArg;
     
     Entry:   CodeArea = AddrReg1;
     
     Index: Word  = DataRegB;
     
     { Used variable.   }
     newTop:  DataArea   = AddrReg1;
     theComp: Component  = AddrReg2
  do
     0 -> Size!l;
     protoType.Size -> Size;
     IOATop -> theComp;
     theComp[24+Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Component is now allocated, but not initialized yet!}
     
     { Initialize the structual part; prototype, age etc. }
     -1 -> theComp.ProtoType;
     1  -> theComp.Age;
     0  -> theComp.StackObj;
     0  -> theComp.CallerObj;
     0  -> theComp.CallerComp;
     0  -> theComp.CallerLSC;
     
     protoType -> theComp[24]!l; { Initialize the item.protoType of the component. }
     -6        -> theComp[28]!l; { Initialize the item.age of the component. }
     
     { Initialize the body part of the item, according to the genTable. }
     protoType -> initTab;
     protoType.GCTabel -> initTab+;
     
     { initTab is now pointing to the static GCTable.                            }
     { This table has zero or more elements terminated with a zero word.         }
     { Each element looks like:                                                  }
     {   WORD  Offset in the generated object, where this static object begins.  }
     {   WORD  Signed distance to inclosing object.                              }
     {   LONG  Prototype of this static object.                                  }
     
     2 -> Index;
     loop:
     (if Index <= Size then
         (if Index = initTab[0]!w then
             2 -> initTab+;
             { Insert the offset to the autonomous object. }
             initTab[0]!w -> Tmp;
             extend Tmp;
             Tmp!l -> theComp[28+Index*4];
             2 -> initTab+;
             { Insert the protoType from the initTab. }
             initTab[0]!l -> Tmp!l; Tmp!l -> theComp[24+Index*4]!l;
             4 -> initTab+;
             2 -> Index+;     
             goto loop
         if);
         0 -> theComp[24+Index*4]!l;
         1 -> Index+;
         goto loop
     if);
     
     protoType.OrigOff -> Index;
     origin -> theComp[24+Index*4];
     
     protoType.GenPart -> Entry;
     theComp[24][] -> Argument;
     call Entry;
     Argument[-24][] -> Argument;
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     Size!l -> ReqObjectSize; { Set the requested Object Size.            }
     7      -> ReqObjectSize+;
     call DoGC;               { Call the Garbage Collector.               }
     goto AlloC               { Go back to the beginning of this routine. }
  #)

