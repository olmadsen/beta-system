------- NewValRep: System ----

NewVR1: public 
  (# { Allocate a byte repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR1+; if);
     push RegThis;
     pReg1 -> RegThis; { object }
     pReg2 -> pReg1;   { offset }
     4     -> pReg1*;
     pReg3 -> pReg2;   { range }
     call AlloVR1;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR2: public 
  (# { Allocate a short repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
    
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR2+; if);
     push RegThis;
     pReg1 -> RegThis; { object }
     pReg2 -> pReg1;   { offset }
     4     -> pReg1*;
     pReg3 -> pReg2;   { range }
     call AlloVR2;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR4: public 
  (# { Allocate a long repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR4+; if);
     push RegThis;
     pReg1 -> RegThis; { object }
     pReg2 -> pReg1;   { offset }
     4     -> pReg1*;
     pReg3 -> pReg2;   { range }
     call AlloVR4;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR8: public 
  (# { Allocate a double repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR8+; if);
     push RegThis;
     pReg1 -> RegThis; { object }
     pReg2 -> pReg1;   { offset }
     4     -> pReg1*;
     pReg3 -> pReg2;   { range }
     call AlloVR8;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRI: public
  (# { Allocate an item repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
     
     { Used variables }
     theObj:       Item             = RegThis;
     offset:       Long             = RegCall;
     theObjectRep: ObjectRepetition = RegCall;
     proto:        ProtoType        = RegCall;
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRI+; if);
     push RegThis;
     pReg1 -> RegThis;              { object }
     pReg2 -> offset;
     theObj[offset*4] -> theObjectRep;
     theObjectRep.iOrigin -> pReg1; { origin of the elements }
     theObjectRep.iProto -> proto;  { prototype of the elements }
     
     pReg3 -> pReg4;                { range }
     pReg2 -> pReg3;                { offset }
     4     -> pReg3*;
     call AlloVRI;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRC: public
  (# { Allocate a component repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  pReg1 }
     { Offset:  pReg2 }
     { Range:   pReg3 }
     
     { Used variables }
     theObj:       Item             = RegThis;
     offset:       Long             = RegCall;
     theObjectRep: ObjectRepetition = RegCall;
     proto:        ProtoType        = RegCall;
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRC+; if);
     push RegThis;
     pReg1 -> RegThis;              { object }
     pReg2 -> offset;
     theObj[offset*4] -> theObjectRep;
     theObjectRep.iOrigin -> pReg1; { origin of the elements }
     theObjectRep.iProto -> proto;  { prototype of the elements }
     
     pReg3 -> pReg4;                { range }
     pReg2 -> pReg3;                { offset }
     4     -> pReg3*;
     call AlloVRC;
     pop RegThis;
     (if debug then call Ck if);
     return;

  #)
