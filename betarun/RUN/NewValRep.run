------- NewValRep: System ----
NewVR: public
  (#
     { Allocate a value repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     { Input register range = DataReg1.                 }
     
     { Input variable. }
     range:   Long       = DataReg1; { The range of the valRep. }
     
     { Used variables. }
     stack:   StackArea = SP;
     theRep:  Repetition = AddrReg1;
     newTop:  DataArea   = AddrReg2;
     theCell: DataArea   = AddrReg2;
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     offset:  Long       = DataReg2
  do
     {
       General stack layout:
       <Linux: DataReg2>   Linux: +0
       <Linux: AddrReg2>   Linux: +4
       <Linux: AddrReg1>   Linux: +8
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Linux: +12   Mac: +4    Default: +0
       <offset>            Linux: +16   Mac: +8    Default: +4
       <item>              Linux: +20   Mac: +12   Default: +8
     }
     
     (if linux then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2, DataReg2 if);
     
     { stack: [return,offset,Item,...]          }
     { mac:   [AddrReg2,return,offset,Item,...] }
     
     (if range<0 then 0 -> range if);
     
     { find the (special) prototype of the val rep }
     (if linux then 
         stack[20] -> theCell;
         stack[16]  -> offset;
      else
         (if MacOS then 
             stack[12] -> theCell;
             stack[8]  -> offset;
          else
             stack[8] -> theCell;
             stack[4] -> offset;
         if);
     if);
     theCell[offset*4] -> theRep;
     push theRep.ProtoType;
     
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }

     (if range > 256 then
         (if linux then
             push RegObj, RegAdr;
          else
             push RegObj, RegAdr, DataRegA, DataRegB;
         if);
         push range;     { Parameter to LVRACAlloc. }
         push theRep.ProtoType; { Proto-Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataRegA -> theRep; {Fetch LVRACalloc result}
         (if theRep <> 0 then
             { Make the LVRA-cycle: theCell -> theRep.Age }
             (if linux then
                 stack[36{16+(3+2)*4}] -> DataRegA; {offset}
                 4 -> DataRegA*;
                 stack[40{20+(3+2)*4}] -> DataRegA+; { item }
              else
                 (if MacOS then
                     stack[36{8+(3+4)*4}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[40{12+(3+4)*4}] -> DataRegA+; { item }
                  else
                     stack[32{4+(3+4)*4}] -> DataRegA; {offset}
                     4 -> DataRegA*;
                     stack[36{8+(3+4)*4}] -> DataRegA+; {item}
                 if);
             if);
             DataRegA -> theRep.Age
         if); 
         4 -> SP+; {Discard proto parameter}
         pop range; {Restore range}
         (if linux then
             pop RegAdr, RegObj;
          else
             pop DataRegB, DataRegA, RegAdr, RegObj;
         if);
         
         { stack: [Proto,return,offset,Item,...]          }
         { mac:   [Proto,AddrReg2,return,offset,Item,...] }

         (if theRep <> 0 then
             goto assign
         if)
     if);
     
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }     

     range -> BodySize; { destroys bodysize }
     IOATop -> theRep;
     (if stack[0] = -6 then { byte rep }
         4 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if stack[0] = -7 then { word rep }
         2 -> BodySize*;
         3 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if stack[0] = -8 then { double rep }
         2 -> BodySize*;
         goto IOAalloc
     if);
     
     IOAalloc:
     
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }

     4 -> BodySize*;
     theRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     stack[0] -> theRep.ProtoType;
     1        -> theRep.Age;
     1        -> theRep.LowBorder;
     range    -> theRep.HighBorder;
     
     clearBody: { Clear the body part of the repetition. }
     4 -> BodySize-;
     loop:
     0 -> theRep[16+BodySize]!l;
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     assign:
     
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }
     
     { Now BodySize is no longer used }
     (if linux then
         stack[24{20+4}] -> theCell;
         stack[20{16+4}] -> offset; { destroys BodySize }
      else
         (if MacOS then 
             stack[16{12+4}] -> theCell;
             stack[12{8+4}] -> offset; { destroys BodySize }
          else
             stack[12{8+4}] -> theCell;
             stack[8{4+4}] -> offset; { destroys BodySize }
         if);
     if);
     
     theCell[offset*4][] -> theCell;
     theRep -> theCell[0];
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }

     4 -> SP+; { remove proto }
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return 8;
     
     GC:
     { stack: [Proto,return,offset,Item,...]          }
     { mac:   [Proto,AddrReg2,return,offset,Item,...] }

     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     4 -> SP+; { remove proto }
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call DoGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)
