------- NewValRep: System ----

NewVR: public 
  (# { FIXME: Compiler should call specific functions directly }
     { Allocate a value repetition based on existing repetition }
     { stack on entry [return(0),offset(4),Item(8),...] }
     { Input register new range = DataReg1 (pReg1 in intel version) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     
     push AddrReg2; { stack: [AddrReg2(0),return(4),offset(8),Item(12),...] }
     stack[12] -> theRep;
     stack[8] -> offset;
     theRep[offset*4] -> theRep;
     push RegThis, DataRegA, DataRegB, -6;
     { stack: 
       [tag(0),DataRegB(4),DataRegA(8),RegThis(12),AddrReg2(16),return(20),offset(24),Item(28),...]
     }
     stack[28]    -> RegThis;  { Item parameter }
     stack[24]    -> DataRegA; { offset parameter }
     4            -> DataRegA*;
     (if intel then
         pReg1    -> DataRegB; { Range parameter }
      else
         DataReg1 -> DataRegB; { Range parameter }
     if);
     
     (if theRep.ProtoType = -6 then { ByteRepetition }
         call AlloVR1;
         goto Finish;
     if);
     (if theRep.ProtoType = -5 then { IntegerRepetition }
         call AlloVR4;
         goto Finish;
     if);
     (if theRep.ProtoType = -7 then { ShortRepetition }
         call AlloVR2;
         goto Finish;
     if);
     (if theRep.ProtoType = -8 then { DoubleRepetition }
         call AlloVR8;
         goto Finish;
     if);
     
     { Only reached for Object Repetitions }
     push RegCall;
     theObjectRep.iProto  -> RegCall;      { iProto parameter }
     (if intel then
         theObjectRep.iOrigin -> pReg1;    { iProto parameter }
      else 
         theObjectRep.iOrigin -> DataReg1; { iProto parameter }
     if);
     
     (if theRep.ProtoType = -10 then { ItemRepetition }
         call AlloORR;
         goto popRegCall;
     if);
     (if theRep.ProtoType = -11 then { CompRepetition }
         call AlloORRC;
     if);
     
     popRegCall:
     pop RegCall;

     Finish:
     
     4 -> SP+; { pop tag }
     pop DataRegB, DataRegA, RegThis, AddrReg2;
     (if debug then call Ck if);
     return 8;
  #)

