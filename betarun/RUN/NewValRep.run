------- NewValRep: System ----

NewVR1: public 
  (# { Allocate a byte repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR1+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVR1;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR2: public 
  (# { Allocate a short repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR2+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVR2;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR4: public 
  (# { Allocate a long repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR4+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVR4;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR8: public 
  (# { Allocate a double repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR8+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVR8;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRI: public { FIXME: parameters }
  (# { Allocate an item repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRI+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVRI;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRC: public { FIXME: parameters }
  (# { Allocate a component repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { Offset:  DataRegA (pReg1 on intel) }
     { Range:   DataRegB (pReg2 on intel) }
     { theObj:  DataRegC (pReg3 on intel) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     theObjectRep: ObjectRepetition = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRC+; if);
     push RegThis;
     (if intel then
         pReg3 -> RegThis;
      else
         DataRegC -> RegThis;
     if);
     call AlloVRC;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #)
