------- NewValRep: System ----

NewVR1: public 
  (# { Allocate a byte repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR1+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVR1;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR2: public 
  (# { Allocate a short repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
    
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR2+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVR2;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR4: public 
  (# { Allocate a long repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR4+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVR4;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVR8: public 
  (# { Allocate a double repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVR8+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVR8;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRI: public { FIXME: parameters }
  (# { Allocate an item repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
    
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRI+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVRI;
     pop RegThis;
     (if debug then call Ck if);
     return;
  #);
     
NewVRC: public { FIXME: parameters }
  (# { Allocate a component repetition based on existing repetition }
     { stack on entry [return(0),...] }
     
     { Input variables. }
     { theObj:  DataRegA (pReg1 on intel) }
     { Offset:  DataRegB (pReg2 on intel) }
     { Range:   DataRegC (pReg3 on intel) }
     
  do 
     (if debug then call Ck if);
     (if debug then 1 -> NumNewVRC+; if);
     push RegThis;
     (if intel then
         pReg1 -> RegThis; { object }
         pReg2 -> pReg1;   { offset }
         4     -> pReg1*;
         pReg3 -> pReg2;   { range }
      else
         DataRegA -> RegThis;  { object }
         DataRegB -> DataRegA; { offset }
         4        -> DataRegA*;
         DataRegC -> DataRegB; { range }
     if);
     call AlloVRC;
     pop RegThis;
     (if debug then call Ck if);
     return;

  #)
