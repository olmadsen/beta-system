------- CopyValRep: System ----

CopyVR: public
  (#
     { Copy a Value Repetition. }
     { stack on entry [return(0),Offset(4),Item(8),ValRep(12),....] }
     
     stack: StackArea = SP;
     
     { Used variable.  }
     theRep: Repetition  = AddrReg1;
     newTop: DataArea    = AddrReg2;
     newRep: Repetition  = AddrReg2;
     theCell: DataArea   = AddrReg1;
     proto: DataArea     = DataRegA;
     zero: DataArea      = DataRegB; { saved and restored }
     cycleCell: DataArea = AddrReg2;
     
     range:  Long        = DataReg1;
     BodySize: Long      = DataReg1; { number of bytes to allocate }
     tmp:    Long        = DataReg2;
     value:  Long        = DataReg2;
     offset: Long        = DataReg2
  do
     stack[12] -> theRep;
     theRep.HighBorder -> range;
     
     (if MacOS then push AddrReg2 if);
     
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }
     
     (if range > 200 then
         push RegArg, RegObj, DataRegA, DataRegB;
         
         { stack: [DataRegB,DataRegA,RegObj,RegArg,return,offset,Item,ValRep...]          }
         { mac:   [DataRegB,DataRegA,RegObj,RegArg,AddrReg2,return,offset,Item,ValRep...] }

         theRep.ProtoType -> proto;
         0 -> zero;
         zero -> cycleCell;
         (if theRep outside IOA then { theRep is in LVRA }
             theRep.Age -> cycleCell { save pointer to cell refering theRep }
         if);
         
         push cycleCell;
         { stack: [cycleCell,DataRegB,DataRegA,RegObj,RegArg,return,offset,Item,ValRep...]          }
         { mac:   [cycleCell,DataRegB,DataRegA,RegObj,RegArg,AddrReg2,return,offset,Item,ValRep...] }

         push range; { Parameter to LVRAAlloc. }
         push proto; { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         4 -> SP+;
         pop range;
         pop cycleCell;
         (if cycleCell <> 0 then
             { restore theRep from pointer to cell. The reason for this is that 
               theRep may have been moved by an LVRACompaction 
             }
             cycleCell[0] -> theRep
         if);
         DataRegA -> newRep;
         
         { stack: [DataRegB,DataRegA,RegObj,RegArg,return,offset,Item,ValRep...]          }
         { mac:   [DataRegB,DataRegA,RegObj,RegArg,AddrReg2,return,offset,Item,ValRep...] }

         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if MacOS then
                 stack[24 { =  4 + 4 + 4*4 } ] -> DataRegA; 4 -> DataRegA*;
                 stack[28 { =  4 + 8 + 4*4 } ] -> DataRegA+
              else
                 stack[20 { =  4 + 4*4 } ] -> DataRegA; 4 -> DataRegA*;
                 stack[24 { =  8 + 4*4 } ] -> DataRegA+
             if);
             DataRegA -> newRep.Age
         if);
         pop  DataRegB, DataRegA, RegObj, RegArg;
         
         { stack: [return,offset,Item,ValRep...]          }
         { mac:   [AddrReg2,return,offset,Item,ValRep...] }

         (if newRep <> 0 then
             { range -> BodySize; // no need; it is the same register }
             (if theRep.ProtoType = -5 then { long rep }
                 4 -> BodySize*;
                 goto copyBody
             if);
             (if theRep.ProtoType = -7 then { word rep }
                 2 -> BodySize*;
                 3 -> BodySize+;
                 4 -> BodySize/;
                 4 -> BodySize*;
                 goto copyBody
             if);
             (if theRep.ProtoType = -6 then { byte rep }
                 4 -> BodySize+;
                 4 -> BodySize/;
                 4 -> BodySize*;
                 goto copyBody
             if);
             (if theRep.ProtoType = -8 then { double rep }
                 2 -> BodySize*;
                 4 -> BodySize*;
                 goto copyBody
             if)
         if)
     if);
     
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }
     
     IOATop -> newTop;
     { range -> BodySize; // no need; it is the same register }
     (if theRep.ProtoType = -7 then { word rep }
         2 -> BodySize*;
         3 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -6 then { byte rep }
         4 -> BodySize+;
         4 -> BodySize/;
         goto IOAalloc
     if);
     (if theRep.ProtoType = -8 then { double rep }
         2 -> BodySize*;
         goto IOAalloc
     if);
     
     
     IOAalloc:
     
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }

     4 -> BodySize*;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     theRep.ProtoType  -> newRep.ProtoType;
     1                 -> newRep.Age;
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     
     copyBody:
     
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }

     (if MacOS then
         { AddrReg2 in on the stack. }
         stack[16] -> theRep
      else
         stack[12] -> theRep
     if);
     
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[16+BodySize] -> value;
         value -> newRep[16+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     (if MacOS then 
         stack[12] -> theCell;
         stack[8]  -> offset
      else
         stack[8] -> theCell;
         stack[4] -> offset
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }

     (if MacOS then pop AddrReg2 if);
     return 12;
     
     GC:
     { stack: [return,offset,Item,ValRep...]          }
     { mac:   [AddrReg2,return,offset,Item,ValRep...] }

     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     (if MacOS then pop AddrReg2 if);
     call DoGC;         { Call the Garbage Collector.               }
     goto CopyVR         { Go back to the beginning of this routine. }
  #)

