------- CopyValRep: System ----

CopyVR1: public
  (#
     { Copy a Byte Repetition. }

     { stack on entry [return(0),...] }
     
     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
        
     stack: StackArea = SP;
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theItem:   Object            = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVR1+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 1 -> BodySize+;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     (if range > LARGE_REP_SIZE then
         push RegCall, RegThis;

         push range; { Parameter to LVRAAlloc. }
         push ByteRepPTValue; { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep; {Fetch LVRAAlloc result}
         {Restore theRep, may have been destroyed by LVRAAlloc}
         pReg1 -> theRep;
         
         4 -> SP+; {Discard proto}
         pop range; {Restore range}
         
         pop RegThis, RegCall;
         
         { range -> BodySize; // no need; it is the same register }
         1 -> BodySize+;
         ObjectAlign -> BodySize|;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBodyPush
     if);
     
     IOATop -> newTop;
     { range -> BodySize; // no need; it is the same register }
     1 -> BodySize+;
     ObjectAlign -> BodySize|;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     ByteRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[16+BodySize] -> value;
         value -> newRep[16+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     pReg2 -> theItem;
     pReg3 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again        { Go back to the beginning of this routine. }
  #);

CopyVR2: public
  (#
     { Copy a Short Repetition. }

     { stack on entry [return(0),...] }
     
     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
        
     stack: StackArea = SP;
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theItem:   Object            = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVR2+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16 
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 2 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);

     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     (if range > LARGE_REP_SIZE then
         push RegCall, RegThis;
         push range; { Parameter to LVRAAlloc. }
         push ShortRepPTValue; { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep; {Fetch LVRAAlloc result}
         {Restore theRep, may have been destroyed by LVRAAlloc}
         pReg1 -> theRep;
         
         4 -> SP+; {Discard proto}
         pop range; {Restore range}
         pop RegThis, RegCall;
         
         { range -> BodySize; // no need; it is the same register }
         2 -> BodySize*;
         ObjectAlign -> BodySize|;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBodyPush
     if);
     
     IOATop -> newTop;
     { range -> BodySize; // no need; it is the same register }
     2 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     ShortRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[16+BodySize] -> value;
         value -> newRep[16+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     pReg2 -> theItem;
     pReg3 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again        { Go back to the beginning of this routine. }
  #);

CopyVR4: public
  (#
     { Copy a Long Repetition. }

     { stack on entry [return(0),...] }
     
     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
        
     stack: StackArea = SP;
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theItem:   Object            = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVR4+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16 
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     (if range > LARGE_REP_SIZE then
         push RegCall, RegThis;
         push range; { Parameter to LVRAAlloc. }
         push LongRepPTValue; { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep; {Fetch LVRAAlloc result}
         {Restore theRep register, may have been destroyed by LVRAAlloc}
         pReg1 -> theRep;
         
         4 -> SP+; {Discard proto}
         pop range; {Restore range}
         pop RegThis, RegCall;
         
         { range -> BodySize; // no need; it is the same register }
         4 -> BodySize*;
         ObjectAlign -> BodySize|;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBodyPush
     if);
     
     IOATop -> newTop;
     { range -> BodySize; // no need; it is the same register }
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     LongRepPTValue  -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[16+BodySize] -> value;
         value -> newRep[16+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     pReg2 -> theItem;
     pReg3 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again       { Go back to the beginning of this routine. }
  #);

CopyVR8: public
  (#
     { Copy a Douoble Repetition. }

     { stack on entry [return(0),...] }
     
     { input parameters }
     { Repetition: pReg1 }
     { Object:     pReg2 }
     { Offset:     pReg3 }
        
     stack: StackArea = SP;
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theItem:   Object            = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVR8+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16 
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 8 -> BodySize*;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     (if range > LARGE_REP_SIZE then
         push RegCall, RegThis;
         push range; { Parameter to LVRAAlloc. }
         push DoubleRepPTValue; { Parameter to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep; {Fetch LVRAAlloc result}
         {Restore theRep, may have been destroyed by LVRAAlloc}
         pReg1 -> theRep;
         
         4 -> SP+; {Discard proto}
         pop range; {Restore range}
         pop RegThis, RegCall;
         
         { range -> BodySize; // no need; it is the same register }
         8 -> BodySize*;
	 (if newRep = 0 then 
	      goto GC; { FIXME: Should fall through to IOAAlloc }
	 if);
         goto copyBodyPush
     if);
     
     IOATop -> newTop;
     { range -> BodySize; // no need; it is the same register }
     8 -> BodySize*;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DoubleRepPTValue  -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[16+BodySize] -> value;
         value -> newRep[16+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     pReg2 -> theItem;
     pReg3 -> offset;
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again       { Go back to the beginning of this routine. }
  #);

CopyVRI: public
  (#
     { Copy an Item Repetition. }
     
     { Input variables: }
     { theRep = pReg1 }
     { theObj = pReg2 }
     { offset = pReg3 }
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theObjRep: ObjectRepetition  = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     newObjRep: ObjectRepetition  = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVRI+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16 
       <offset>            +20
       <item>              +24 
       <valrep>            +28
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);

     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     IOATop -> newRep;
     { range -> BodySize; // no need; it is the same register }
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     { No need to clear newTop since AddrReg2 is assigned to newRep below }
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DynItemRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     theObjRep.iProto  -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
     
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[24+BodySize] -> value;
         value -> newRep[24+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     
     pReg2 -> theCell;
     pReg3 -> offset;
     
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again        { Go back to the beginning of this routine. }
  #);

CopyVRC: public
  (#
     { Copy a Component Repetition. }
     
     { Input variables: }
     { theRep = pReg1 }
     { theObj = pReg2 }
     { offset = pReg3 }
     
     { Used variable.  }
     theRep:    Repetition        = AddrReg1;
     theObjRep: ObjectRepetition  = AddrReg1;
     theCell:   DataArea          = AddrReg1;

     newTop:    DataArea          = AddrReg2;
     newRep:    Repetition        = AddrReg2;
     newObjRep: ObjectRepetition  = AddrReg2;
     
     range:     Long              = DataReg1;
     BodySize:  Long              = DataReg1; { number of bytes to allocate }
     
     tmp:       Long              = DataReg2;
     value:     Long              = DataReg2;
     offset:    Long              = DataReg2;
  do
     (if debug then 1 -> NumCopyVRC+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <DataReg2>          +0
       <DataReg1>          +4
       <AddrReg2>          +8
       <AddrReg1>          +12
       <return address>    +16 
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
                 pReg1 -> theRep;
                 theRep.HighBorder -> range;
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);

     again:
     
     push AddrReg1, AddrReg2, DataReg1, DataReg2 ;
     
     pReg1 -> theRep;
     theRep.HighBorder -> range;
     
     IOATop -> newRep;
     { range -> BodySize; // no need; it is the same register }
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[24+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     
     IOATop -> tmp;
     newTop -> IOATop;
     { No need to clear newTop since AddrReg2 is assigned to newRep below }
     tmp    -> newRep;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     DynCompRepPTValue -> newRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1                 -> newRep.LowBorder;
     theRep.HighBorder -> newRep.HighBorder;
     theObjRep.iProto  -> newObjRep.iProto;
     theObjRep.iOrigin -> newObjRep.iOrigin;
    
     copyBodyPush:
     push newRep;

     copyBody:
     { Copy the body part of the repetition. }
     (if BodySize <> 0 then
         4 -> BodySize-;
         loop:
         theRep[24+BodySize] -> value;
         value -> newRep[24+BodySize];
         4 -> range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     pop newRep; { pop unmodified newRep }
     
     AssignReference:
     
     pReg2 -> theCell;
     pReg3 -> offset;
     
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop DataReg2, DataReg1, AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push pReg1; { force update of pReg1 during GC }
     push pReg2; { force update of pReg2 during GC }
     { Stack:
       <pReg2> (Object)
       <pReg1> (Repetition)
       - data registers are tagged properly.
     }
     call doGC;         { Call the Garbage Collector.               }
     pop pReg2;
     pop pReg1;
     goto again        { Go back to the beginning of this routine. }
  #)
