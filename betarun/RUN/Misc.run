------- Misc: System ----
RefNonePC: cvar;
RefNoneStackEnd: cvar;
LazyItem: cvar;

RefNone: public
  (#
     stack: StackArea = SP;
  do
     (if debug then 
         call Ck;
         1 -> NumRefNone+;
     if); 
     
     stack[0] -> RefNonePC; {get PC of caller}
     
     { Push address registers. Current object (%edx) is pushed as a }
     { parameter to BetaError, and will be updated by GC in case this }
     { RefNone is really a dangling persistent reference. }
     
     push AddrReg1;
     push AddrReg2;
     push RegCall;
     push a2;
     push a3;
     push a4;
     
     { Push data registers. One of these may contain a dangler. }
     { If so, this will be taken care of in BetaError by clearing the }
     { "Protect1Tag" corresponding to the dangler, thus ensuring  }
     { that the dangler is located during IOA GC. }
     
     push DataReg1;
     push Protect1Tag; { Tell GC to skip previous stack-entry }
     push RegAdr;
     push Protect1Tag;
     push DataReg2;
     push Protect1Tag;
     SP -> RefNoneStackEnd;
     
     { To avoid confusing the GC, clear registers that may be pushed onto }
     { the stack by the C compiler on entry to BetaError. We clear more }
     { registers than really necessary, just to minimize the risk that }
     { changes in the C compiler has fatal consequences for lazy fetch. }
     
     clear RegEbp;
     clear RegEsi;
     clear RegEdi;
     clear RegEax;
     clear RegEcx;
     clear RegEbx;
     
     push RegThis;
     push RefNoneErr;
     call BetaError;
     4 -> stack+;
     pop RegThis;
          
     4 -> stack+;
     pop DataReg2;
     4 -> stack+;
     pop RegAdr;
     4 -> stack+;
     pop DataReg1;
     pop a4;
     pop a3;
     pop a2;
     pop RegCall;
     pop AddrReg2;
     pop AddrReg1;
     
     (if debug then call Ck if);
     return;
  #)
;

Ck: public
  (#
     stack:  StackArea  = SP;
  do
     (if debug then
         push RegAdr;
         stack[4] -> RegAdr; { get PC of caller of Ck }
         RegAdr -> CkPC1;
         stack[8] -> RegAdr; { get PC of caller of caller of Ck }
         RegAdr -> CkPC2;
         pop RegAdr;
         
         AddrReg1 -> CkP1;
         AddrReg2 -> CkP2;
         RegThis  -> CkP3;
         RegCall  -> CkP4;
         
         PushAll;
         call CheckRegisters;
         PopAll;
         
         0 -> CkPC1;
         0 -> CkPC2;
         
     if);
     
     return;
  #)


