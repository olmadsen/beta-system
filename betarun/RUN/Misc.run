------- Misc: System ----
RefNonePC: cvar;
RefNoneStackEnd: cvar;
LazyItem: cvar;
RefNone: public
  (#
     CurrentObject: Object = RegThis;
     stack: StackArea = SP;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumRefNone+ if); 

     (if linux then
         stack[0] -> RefNonePC; {get PC of caller}
         
         { Push address registers. Current object (%edx) is pushed as a }
         { parameter to BetaError, and will be updated by GC in case this }
         { RefNone is really a dangling persistent reference. }
         
         (code '	pushl	%ebp' code);
         (code '	pushl	%esi' code);
         (code '	pushl	%edi' code);
         (code '	pushl	a2' code);
         (code '	pushl	a3' code);
         (code '	pushl	a4' code);
         
         { Push data registers. One of these may contain a dangler. }
         { If so, this will be taken care of in BetaError by clearing the }
         { "Protect1Tag" corresponding to the dangler, thus ensuring that the dangler }
         { is located during IOA GC. }
         
         (code '	pushl	%eax' code);
         push Protect1Tag; { Tell garbage collector to skip previous stack-entry }
         (code '	pushl	%ecx' code);
         push Protect1Tag;
         (code '	pushl	%ebx' code);
         push Protect1Tag;
         stack -> RefNoneStackEnd;
         
         { To avoid confusing the GC, clear registers that may be pushed onto }
         { the stack by the C compiler on entry to BetaError. We clear more }
         { registers than really necessary, just to minimize the risk that }
         { changes in the C compiler has fatal consequences for lazy fetch. }
           
         (code '	xorl	%ebp,%ebp' code); 
         (code '	xorl	%esi,%esi' code); 
         (code '	xorl	%edi,%edi' code);  
         (code '	xorl	%eax,%eax' code);  
         (code '	xorl	%ecx,%ecx' code);  
         (code '	xorl	%ebx,%ebx' code); 
         
     if);
     
     (if nti then
         stack[0] -> RefNonePC; {get PC of caller}
         
         { Push address registers. Current object (%edx) is pushed as a }
         { parameter to BetaError, and will be updated by GC in case this }
         { RefNone is really a dangling persistent reference. }
         
         (code '	push	ebp' code);
         (code '	push	esi' code);
         (code '	push	edi' code);
         (code '	push	_a2' code);
         (code '	push	_a3' code);
         (code '	push	_a4' code);
         
         { Push data registers. One of these may contain a dangler. }
         { If so, this will be taken care of in BetaError by clearing the }
         { "Protect1Tag" corresponding to the dangler, thus ensuring that the dangler }
         { is located during IOA GC. }
         
         (code '	push	eax' code);
         push Protect1Tag; { Tell garbage collector to skip previous stack-entry }
         (code '	push	ecx' code);
         push Protect1Tag;
         (code '	push	ebx' code);
         push Protect1Tag;
         stack -> RefNoneStackEnd;
         
         { To avoid confusing the GC, clear registers that may be pushed onto }
         { the stack by the C compiler on entry to BetaError. We clear more }
         { registers than really necessary, just to minimize the risk that }
         { changes in the C compiler has fatal consequences for lazy fetch. }
           
         (code '	xor	ebp, ebp' code); 
         (code '	xor	esi, esi' code); 
         (code '	xor	edi, edi' code);  
         (code '	xor	eax, eax' code);  
         (code '	xor	ecx, ecx' code);  
         (code '	xor	ebx, ebx' code); 
         
     if);
     
     push CurrentObject;
     push RefNoneErr;
     call BetaError;
     4 -> stack+;
     pop CurrentObject;
          
     (if linux then
         4 -> stack+;
         (code '	popl	%ebx' code);
         4 -> stack+;
         (code '	popl	%ecx' code);
         4 -> stack+;
         (code '	popl	%eax' code);
         (code '	popl	a4' code);
         (code '	popl	a3' code);
         (code '	popl	a2' code);
         (code '	popl	%edi' code);
         (code '	popl	%esi' code);
         (code '	popl	%ebp' code);
     if);
     
     (if nti then
         4 -> stack+;
         (code '	pop	ebx' code);
         4 -> stack+;
         (code '	pop	ecx' code);
         4 -> stack+;
         (code '	pop	eax' code);
         (code '	pop	_a4' code);
         (code '	pop	_a3' code);
         (code '	pop	_a2' code);
         (code '	pop	edi' code);
         (code '	pop	esi' code);
         (code '	pop	ebp' code);
     if);
     
     (if debug then call Ck if);
     return;
  #)
;

Ck: public
  (#
     stack:  StackArea  = SP;
  do
     (if debug then
         push RegAdr;
         stack[4] -> RegAdr; { get PC of caller of Ck }
         RegAdr -> CkPC1;
         stack[8] -> RegAdr; { get PC of caller of caller of Ck }
         RegAdr -> CkPC2;
         pop RegAdr;
         
         (if linux then
             (code 'movl %ebp,CkP1' code);
             (code 'movl %esi,CkP2' code);
             (code 'movl %edx,CkP3' code);
             (code 'movl %edi,CkP4' code);
             (code 'pushal' code);
             call CheckRegisters;
             (code 'popal' code);
         if);
         
         (if nti then
             (code '	mov	dword ptr _CkP1,ebp' code);
             (code '	mov	dword ptr _CkP2,esi' code);
             (code '	mov	dword ptr _CkP3,edx' code);
             (code '	mov	dword ptr _CkP4,edi' code);
             (code '	pushad' code);
             call CheckRegisters;
             (code '	popad' code);
         if);
     if);
     
     return;
  #)


