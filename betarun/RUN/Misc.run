------- Misc: System ----
RefNonePC: cvar;
RefNoneStackEnd: cvar;
LazyItem: cvar;
RefNone: public
  (#
     CurrentObject: Object = RegThis;
     stack: StackArea = SP;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumRefNone+ if); 

     (if linux then
         stack[0] -> RefNonePC; {get PC of caller}
         
         { Push address registers. Current object (%edx) is pushed as a }
         { parameter to BetaError, and will be updated by GC in case this }
         { RefNone is really a dangling persistent reference. }
         
         (code '	pushl	%ebp' code);
         (code '	pushl	%esi' code);
         (code '	pushl	%edi' code);
         (code '	pushl	a2' code);
         (code '	pushl	a3' code);
         (code '	pushl	a4' code);
         
         { Push data registers. One of these may contain a dangler. }
         { If so, this will be taken care of in BetaError by clearing the }
         { "-5" corresponding to the dangler, thus ensuring that the dangler }
         { is located during IOA GC. }
         
         (code '	pushl	%eax' code);
         push -5; { Tell garbage collector to skip previous stack-entry }
         (code '	pushl	%ecx' code);
         push -5;
         (code '	pushl	%ebx' code);
         push -5;
         stack -> RefNoneStackEnd;
         
         { To avoid confusing the GC, clear registers that may be pushed onto }
         { the stack by the C compiler on entry to BetaError. We clear more }
         { registers than really necessary, just to minimize the risk that }
         { changes in the C compiler has fatal consequences for lazy fetch. }
           
         (code '	movl	$0,%ebp' code); 
         (code '	movl	$0,%esi' code); 
         (code '	movl	$0,%edi' code);  
         (code '	movl	$0,%eax' code);  
         (code '	movl	$0,%ecx' code);  
         (code '	movl	$0,%ebx' code); 
         
     if);
     
     (if nti then
         stack[0] -> RefNonePC; {get PC of caller}
         
         { Push address registers. Current object (%edx) is pushed as a }
         { parameter to BetaError, and will be updated by GC in case this }
         { RefNone is really a dangling persistent reference. }
         
         (code '	push	ebp' code);
         (code '	push	esi' code);
         (code '	push	edi' code);
         (code '	push	_a2' code);
         (code '	push	_a3' code);
         (code '	push	_a4' code);
         
         { Push data registers. One of these may contain a dangler. }
         { If so, this will be taken care of in BetaError by clearing the }
         { "-5" corresponding to the dangler, thus ensuring that the dangler }
         { is located during IOA GC. }
         
         (code '	push	eax' code);
         push -5; { Tell garbage collector to skip previous stack-entry }
         (code '	push	ecx' code);
         push -5;
         (code '	push	ebx' code);
         push -5;
         stack -> RefNoneStackEnd;
         
         { To avoid confusing the GC, clear registers that may be pushed onto }
         { the stack by the C compiler on entry to BetaError. We clear more }
         { registers than really necessary, just to minimize the risk that }
         { changes in the C compiler has fatal consequences for lazy fetch. }
           
         (code '	mov	ebp, 0' code); 
         (code '	mov	esi, 0' code); 
         (code '	mov	edi, 0' code);  
         (code '	mov	eax, 0' code);  
         (code '	mov	ecx, 0' code);  
         (code '	mov	ebx, 0' code); 
         
     if);
     
     (if MacOS then
         stack[0] -> RefNonePC; {get PC of caller}
         
         { Push address registers. Current object (%edx) is pushed as a }
         { parameter to BetaError, and will be updated by GC in case this }
         { RefNone is really a dangling persistent reference. }
         
         (code '        movem.l  a1-a4,-(sp)' code);
         
         { Push data registers. One of these may contain a dangler. }
         { If so, this will be taken care of in BetaError by clearing the }
         { "-5" corresponding to the dangler, thus ensuring that the dangler }
         { is located during IOA GC. }
         
         (code '        move.l d7,-(sp)' code);
         push -5;
         (code '        move.l d6,-(sp)' code);
         push -5;
         (code '        move.l d5,-(sp)' code);
         push -5;
         (code '        move.l d4,-(sp)' code);
         push -5;
         (code '        move.l d3,-(sp)' code);
         push -5;
         (code '        move.l d2,-(sp)' code);
         push -5;
         (code '        move.l d1,-(sp)' code);
         push -5;
         (code '        move.l d0,-(sp)' code);
         push -5;
         
         stack -> RefNoneStackEnd;
         
         { To avoid confusing the GC, clear registers that may be pushed onto }
         { the stack by the C compiler on entry to BetaError. We clear more }
         { registers than really necessary, just to minimize the risk that }
         { changes in the C compiler has fatal consequences for lazy fetch. }
         
         (code '        suba.l  a6,a6' code);
         (code '        moveq.l  #0,d7' code);
         (code '        moveq.l  #0,d6' code);
         (code '        moveq.l  #0,d5' code);
         (code '        moveq.l  #0,d4' code);
         (code '        moveq.l  #0,d3' code);
         (code '        moveq.l  #0,d2' code);
         (code '        moveq.l  #0,d1' code);
         (code '        moveq.l  #0,d0' code);
         
     if);
     
     push CurrentObject;
     push -1;              { Error number for Reference is none! }
     call BetaError;
     4 -> stack+;
     pop CurrentObject;
     
     (if MacOS then
         4 -> stack+;
         (code '	move.l  (sp)+,d0' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d1' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d2' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d3' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d4' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d5' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d6' code);
         4 -> stack+;
         (code '	move.l  (sp)+,d7' code);
         
         (code '        movem.l  (sp)+,a1-a4' code);
     if);
     
     (if linux then
         4 -> stack+;
         (code '	popl	%ebx' code);
         4 -> stack+;
         (code '	popl	%ecx' code);
         4 -> stack+;
         (code '	popl	%eax' code);
         (code '	popl	a4' code);
         (code '	popl	a3' code);
         (code '	popl	a2' code);
         (code '	popl	%edi' code);
         (code '	popl	%esi' code);
         (code '	popl	%ebp' code);
     if);
     
     (if nti then
         4 -> stack+;
         (code '	pop	ebx' code);
         4 -> stack+;
         (code '	pop	ecx' code);
         4 -> stack+;
         (code '	pop	eax' code);
         (code '	pop	_a4' code);
         (code '	pop	_a3' code);
         (code '	pop	_a2' code);
         (code '	pop	edi' code);
         (code '	pop	esi' code);
         (code '	pop	ebp' code);
     if);
     
     (if debug then call Ck if);
     return;
  #)
;

Ck: public
  (#
     stack:  StackArea  = SP;
  do
     (if debug then
         push RegAdr;
         stack[4] -> RegAdr; { get PC of caller of Ck }
         RegAdr -> CkPC1;
         stack[8] -> RegAdr; { get PC of caller of caller of Ck }
         RegAdr -> CkPC2;
         pop RegAdr;
         
         (if hp then {*** Not verified ***}
             (code 'mov.l %a0,_CkP1' code);
             (code 'mov.l %a1,_CkP2' code);
             (code 'mov.l %a2,_CkP3' code);
             (code 'mov.l %a3,_CkP4' code);
             (code 'mov.l %a4,_CkP5' code);
             (code 'movm.l %a0-%a4,-(%sp)' code);
             (code 'movm.l %d0-%d7,-(%sp)' code);
             call CheckRegisters;
             (code 'movm.l (%sp)+,%d0-%d7' code);
             (code 'movm.l (%sp)+,%a0-%a4' code);
         if);
         
         (if MacOS then {*** Not verified ***}
             (code '	move.l a0,((CkP1).L,a5)' code);
             (code '	move.l a1,((CkP2).L,a5)' code);
             (code '	move.l a2,((CkP3).L,a5)' code);
             (code '	move.l a3,((CkP4).L,a5)' code);
             (code '	move.l a4,((CkP5).L,a5)' code);
             (code '	movem.l a0-a4,-(sp)' code);
             (code '	movem.l d0-d7,-(sp)' code);
             call CheckRegisters;
             (code '	movem.l (sp)+,d0-d7' code);
             (code '	movem.l (sp)+,a0-a4' code);
         if);
                  
         (if linux then
             (code 'movl %ebp,CkP1' code);
             (code 'movl %esi,CkP2' code);
             (code 'movl %edx,CkP3' code);
             (code 'movl %edi,CkP4' code);
             (code 'pushal' code);
             call CheckRegisters;
             (code 'popal' code);
         if);
         
         (if nti then {*** Not verified ***}
             (code '	mov	dword ptr _CkP1,ebp' code);
             (code '	mov	dword ptr _CkP2,esi' code);
             (code '	mov	dword ptr _CkP3,edx' code);
             (code '	mov	dword ptr _CkP4,edi' code);
             (code '	pushad' code);
             call CheckRegisters;
             (code '	popad' code);
         if);
     if);
     
     return;
  #)


