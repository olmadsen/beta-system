------- ExtendRefRep: System ----
ExtRR: public
  (#
     { Extend a value repetition. }
     { stack on entry [return(0),...] }
     
     { Input variable. }
     { Object:     DataRegA; (pReg1 on intel) }
     { Offset:     DataRegB; (pReg2 on intel) }
     { Add:        DataRegC; (pReg3 on intel) }
     
     { Used variable.  }
     stack:  StackArea  = SP;
     newRep: Repetition = AddrReg2;
     newTop: DataArea   = AddrReg1;
     theItem: Object    = AddrReg1;
     theRep: Repetition = AddrReg1;
     theCell: DataArea  = AddrReg1;
     
     oldRange: Long     = DataReg2;
     newRange: Long     = DataReg2;
     offset:   Long     = DataReg2;

     addSize:  Long     = DataReg1;
     value:    Long     = DataReg1;
  do
     (if debug then 1 -> NumExtRR+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0    
     }
     
     again:
     
     (if intel then push AddrReg1, AddrReg2, DataReg2 if);
     
     (if intel then
         pReg1 -> theItem;
         pReg2 -> offset;
         pReg3 -> addSize;
      else
         DataRegA -> theItem;
         DataRegB -> offset;
         DataRegC -> addSize;
     if);
     theItem[offset*4] -> theRep;
     
     theRep.HighBorder -> newRange;
     addSize  -> newRange+;
     
     (if newRange < 0 then 0 -> newRange if); { OBS: low>high confuses chk2 }

     IOATop -> newRep;
     newRep[16+newRange*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not assigned yet!}
     
     { Initialize the structual part of the repetition. }
     RefRepPTValue -> newRep.ProtoType;
     1             -> newRep.Age;
     1             -> newRep.LowBorder;
     newRange      -> newRep.HighBorder;
     
     { Reload theRep, was overwritten by newTop }
     push newRange; { save newRange }
     (if intel then
         pReg1 -> theItem;
         pReg2 -> offset;
      else
         DataRegA -> theItem;
         DataRegB -> offset;
     if);
     theItem[offset*4] -> theRep;
     pop newRange; { restore Newrange }
     
     (if addSize > 0 then			
         theRep.HighBorder -> oldRange;
         goto copyBody;
     if);							
     {newRange -> oldRange}; { Assignment is void. Skip it! }
	  
     copyBody:
     { Copy the body part of theRep to newRep. }
     push oldRange; { Used to cycle through theRep }
     push addSize; { Assignment to value destroys addSize }
     (if oldRange > 0 then
         1 -> oldRange-;
         loop1:
         theRep[16+oldRange*4] -> value;
         value -> newRep[16+oldRange*4];
         1 -> oldRange-;
         (if FLAGS >= 0 then goto loop1 if)
     if);
     pop addSize; { Restore addSize }
     pop oldRange; { Restore original oldRange }
     
     { Calculate the address of the extension part into theRep. }
     newRep[16+oldRange*4][] -> theRep;
     
     (if intel then
         pReg1 -> theItem;
         pReg2 -> offset;
      else
         DataRegA -> theItem;
         DataRegB -> offset;
     if);
     theItem[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     newRange -> ReqObjectSize+;
     (if intel then pop DataReg2, AddrReg2, AddrReg1 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)


