------- COM: System ----
AlloCOM: public
  (#
     { Allocate a COM-item.
       Destroys: RegCall (output), DataReg1.
       May cause GC.
     }
     
     { Input variables. }
     protoType:     ProtoType = RegCall;
     { origin in pReg1 }
     
     { Output variable. }
     Argument:      DataArea  = RegCall;
     
     { Used variables. }
     Size:          Word      = DataReg2;
     Offset:        Word      = DataReg2;
     DataReg2Long:  Long      = DataReg2; 
     TmpData:       Long      = DataReg1;
     TmpAddr:       Long      = { AddrReg1 } RegThis;
     initTab:       CodeArea  = { AddrReg1 } RegThis; { index in GC table in prototype }
     Entry:         CodeArea  = { AddrReg1 } RegThis; 
     theItem:       Item      = AddrReg2;
     theCell:       DataArea  = AddrReg1;
          
  do
     (if debug then 1 -> NumAlloCOM+ if); 
     (if debug then call Ck if);
     
     { General Stack Layout:
       <DataReg2>
       <AddrReg2>
       <RegThis>
     }
     
     again:
     
     push { AddrReg1 } RegThis, AddrReg2, DataReg2Long;
     
     { Save registers before calling C }
     { push RegThis; }
     push a2;
     push a3;
     push a4;
     SP -> StackEnd; { Not really needed, AOAcalloc cannot trigger IOAGc }
     push RegAdr;
     push DataReg2;
     push protoType;

     0 -> Size!l;
     protoType.Size -> Size;
     4 -> Size!l*;
     Size!l -> ReqObjectSize; { Set the requested Object Size. }
     push Size!l; {numbytes}
     call AOAcalloc;
     RegEax -> theItem;
     pop RegEax; {remove param}

     pop protoType;
     pop DataReg2;
     pop RegAdr;
     pop a4;
     pop a3;
     pop a2;
     { pop RegThis; }

     (if theItem=0 then
         pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
         { Stack: as on entry }
         push pReg1; { update origin }
         { Stack:
           <pReg1>
           - data registers are tagged properly.
         }
         call doGC;  { Call the Garbage Collector. }
         pop pReg1;
         goto again;
     if); 

     { The new Object is now allocated, but not initialized yet!}
     { initialize initTab here to increase pentium pairability }
     0 -> initTab!l;
     
     { Initialize the structual part; prototype and GCAttr. }
     protoType    -> theItem.ProtoType;
     (if COM then
         { ProtoType is adjusted by generator }
      else
         24 -> theItem.ProtoType+;
     if);
     { 0 -> theItem.GCAttr; NO GcAttr set by AOAAlloc }
     
     { Initialize the body part of the item, according to the genTable. }
     { inittab initialized to 0 above }
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     (if HandOptimizedAlloI then
         AsmComment 'Optimized loop for partobj init (COM)';
         (if gas then
             (code '	testl	$0xffff,(%edx)		#u 1	' code);
             (code '	je	L5c			#v 1	' code);
             (code 'L4c:					' code);
             (code '	movl	(%edx),%eax		#u 2	' code);
             (code '	movl	(%edx),%ebx		#v 2	' code);
             (code '	sarl	$16,%eax		#u 3	' code);
             (code '	andl	$0xffff,%ebx		#v 3	' code);
             (code '	addl	$8,%edx			#u 4	' code);
             (code '	movl	%eax,4(%esi,%ebx,4)	#v 4	' code);
             (code '	movl	-4(%edx),%eax		#u 5	' code);
             (code '	testl	$0xffff,(%edx)		#v 5	' code);
             (if COM then
                 (code'	leal	DISP_OFF(%eax),%eax     #u 6 SETPROTO' code);
                 (code'	nop				#v 6	' code);
             if);
             (code '	movl	%eax,(%esi,%ebx,4)	#u 6/7	' code);
             (code '	jne	L4c			#v 6/7	' code);
             (code 'L5c:					' code);
         if);
         (if ml then
             (code '	test	dword ptr [edx],0ffffh	;u 1	' code);
             (code '    je	L5c			;v 1	' code);
             (code 'L4c:mov	eax,[edx]		;u 2	' code);
             (code '    mov	ebx,[edx]		;v 2	' code);
             (code '    sar	eax,16			;u 3	' code);
             (code '    and	ebx,0ffffh		;v 3	' code);
             (code '    add	edx,8			;u 4	' code);
             (code '    mov	4[esi+4*ebx],eax	;v 4	' code);
             (code '    mov	eax,[edx-4]		;u 5	' code);
             (code '    test	dword ptr [edx],0ffffh	;v 5	' code);
             (if COM then
                 (code'	lea	eax,DISP_OFF[eax]       ;u 6 SETPROTO' code);
                 (code'	nop				;v 6	' code);
             if);
             (code '    mov	[esi+4*ebx],eax		;u 6/7	' code);
             (code '    jne	L4c			;v 6/7	' code);
             (code 'L5c:					' code);
         if);
      else
         loop:
         0->Offset!l;
         initTab[0]!w -> Offset;
         (if Offset!l<>0 then
             { Insert the distance to the autonomous object. }
             -1 -> TmpData;
             initTab[2]!w -> TmpData!w;
             TmpData!l -> theItem[4+Offset*4];
             { Insert the protoType from the initTab. }
             initTab[4]!l -> TmpData!l; 
             TmpData!l -> theItem[Offset*4]!l;
             8 -> initTab+;
             goto loop
         if);
     if);
     
     { Store origin }
     pReg1 -> TmpAddr!l;
     0 -> Offset!l;
     protoType.OrigOff -> Offset;
     TmpAddr!l -> theItem[Offset*4];
     { Now since theItem is allocated OUTSIDE IOA, we need to do
       a ChkRA here after having stored origin.
     }
     push AddrReg1;
     theItem[Offset*4][] -> theCell;
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         { No need to check theCell outside IOA - we know that! }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     pop AddrReg1;
     
     { Get the G-part }
     protoType.GenPart -> Entry; { Must be before theItem -> Argument }
     theItem -> Argument;

     (if Entry<>0 then
         clear AddrReg2; {Invalidate GC register}
         push Protect1Tag; {Protect DataReg2}
         { Stack:
           <tag1>
           <General Stack Layout>
           - data registers are tagged properly.
         }
         call Entry; { May cause GC }
         pop TmpData!l; {Discard Protect1Tag tag (to dummy DataReg)}
     if);
     
     pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
     (if debug then call Ck if);
     return;
  #)
