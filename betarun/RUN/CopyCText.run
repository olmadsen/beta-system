------- CopyCText: System ----

CopyCT: public
  (#
     { Allocate a (byte)ValueRepetition and initialize it with some text.    }
     
     { Input variable.  }
     textPtr: Long       = DataReg1; { Address to the ascii text. }
     
     { Output variable. }
     theRep:  Repetition = DataReg1; { The allocated repetition. }
     
     { Used variable.  }
     theText: CodeArea   = AddrReg1; { The ascii text. }
     Range:  Long 	 = DataReg1; { The range of the valRep. }
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     Value: Long         = DataReg1;
     newTop: DataArea    = AddrReg1;
     newRep: Repetition  = AddrReg2
  do
     (if linux then ; else DataRegA -> DataReg1 if); {*** TO BE REMOVED ***}
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2, DataReg2 if);
     
     push textPtr; {Save original input parameter}
     
     textPtr -> theText;
     { Calculate the length of the text. }
     0 -> Range;
     (if theText=0 then goto NULL if);
     goto LoopB;
     LoopA: 1  -> Range+;
     LoopB: (if theText[Range]!b <> 0 then goto LoopA if);
     NULL:
     
     { LVRA missing }
     { Cannot allocate in LVRA since we don't know the cell to assign to }

     { Allocate a value repetition with bodysize = ((range+1+3)/4)*4*size (size here 1) bytes }
     IOATop -> newRep;
     Range -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     newRep[16+BodySize][] -> newTop; { destroys theText }
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the valrep.             }
     -6   -> newRep.ProtoType; { byte rep }
     1    -> newRep.Age;
     1    -> newRep.LowBorder;
     Range -> newRep.HighBorder;
     
     copyBody:
     
     pop theText; { Restore theText (that is, load original input value) }
     
     { Assign the text to the body part of the repetition. }
     0 -> Value;
     4 -> BodySize-;
     loop:
     theText[BodySize] -> Value;
     Value -> newRep[16+BodySize];
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     (if linux then
         newRep -> pReg1;
      else
         newRep -> theRep;
     if);
     
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop textPtr; {restore textPtr; was overwritten by Range}
     (if Linux then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     
     call DoGC;              { Call the Garbage Collector.               }
     goto again             { Go back to the beginning of this routine. }
  #)
