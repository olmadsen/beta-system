------- CopyCText: System ----

CopyCT: public
  (#
     { Allocate a (byte)ValueRepetition and initialize it with some text. }
     
     { FIXME: Should be eliminated: Use CopyT instead }
     
     { Input variable. }
     textPtr: Long       = DataReg1; { eax Address to the ascii text. }
     
     { Output variable. }
     theRep:  Repetition = DataReg1; { The allocated repetition. }
                                     { pReg1/esi in Intel version }
     
     { Used variable.  }
     theText: CodeArea   = AddrReg1; { ebp The ascii text. }
     Range:  Long 	 = DataReg1; { eax The range of the valRep. }
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     Value: Long         = DataReg1; { eax }
     newTop: DataArea    = AddrReg1;
     newRep: Repetition  = AddrReg2
  do
     (if debug then 1 -> NumCopyCT+ if); 
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <DataReg2>
       <AddrReg2>
       <AddrReg1>
       ... 
     }
     
     push AddrReg1, AddrReg2, DataReg2;
     push textPtr; {Save original input parameter}
     
     { stack:
       <textPtr>
       <general stack layout>
     }
     
     textPtr -> theText;
     { Calculate the length of the text. }
     0 -> Range;
     (if theText = 0 then goto NULL if);
     goto LoopB;
     LoopA: 1  -> Range+;
     LoopB: (if theText[Range]!b <> 0 then goto LoopA if);
     NULL:
     
     (if do_unconditional_GC then
	 (if DoUGC<>0 then
	     { See general comment in AllocateItem.run }
	     IOATop -> newRep;
	     Range -> BodySize;
	     1 -> BodySize+;
	     ObjectAlign -> BodySize|;
	     newRep[16+BodySize][] -> newTop;
	     goto GC;
	 if);
     if);

     again:
     
     (if Range > LARGE_REP_SIZE then
         push RegThis, RegCall; { save registers }
         push Range; { Parameters to LVRAAlloc. }
         push ByteRepPTValue; { Parameters to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep;
         4 -> SP+;
         pop  Range;
         pop  RegCall, RegThis;
	 (if newRep = 0 then 
             Range -> BodySize;
             1 -> BodySize+;
             ObjectAlign -> BodySize|;
	     goto GC;
	 if);
         goto copyBody
     if);

     IOAAlloc:

     { Allocate a value repetition with bodysize = ((range+1+3)/4)*4*size (size here 1) bytes }
     IOATop -> newRep;
     Range -> BodySize;
     1 -> BodySize+;    { For zero termination }
     ObjectAlign -> BodySize|;
     newRep[16+BodySize][] -> newTop; { destroys theText }
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 13 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the valrep.             }
     ByteRepPTValue -> newRep.ProtoType; { byte rep }
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1    -> newRep.LowBorder;
     Range -> newRep.HighBorder;


     copyBody:

     { We need the real Range to avoid overrunning the source buffer }
     Range -> BodySize;

     1 -> BodySize+; { Don't forget to copy terminating zero! }
     
     { stack:
       <textPtr>
       <general stack layout>
     }    
     pop theText; { Restore theText (that is, load original input value) }
     { Stack: 
       <general stack layout>
     }
      
     newRep -> pReg1;

     (if Range>0 then
	 { Assign the text to the body part of the repetition. }
         push BodySize;            { We need the last 2 bits later }
         4 -> BodySize/;           { And with ~3 }
         4 -> BodySize*;
         (if FLAGS = 0 then goto ByteCopy if);
         
         loop:
         4 -> BodySize-;
         theText[BodySize] -> Value;
         Value -> newRep[16+BodySize];
         (if FLAGS <> 0 then goto loop if);
         
         ByteCopy:
         
         pop BodySize;             { We get the last 2 bits now }
         BodySize -> Value;
         4 -> Value/;              { And with ~3 }
         4 -> Value*;
         Value -> BodySize-;
         (if FLAGS = 0 then goto NoByteCopy if);
         Value -> newRep+;
         Value -> theText+;
         
         loopbytecopy:
         1 -> BodySize-;
         theText[BodySize]!b -> Value!b;
         Value!b -> newRep[16+BodySize]!b;
         (if FLAGS <> 0 then goto loopbytecopy if)
     if);
     NoByteCopy:
     pop DataReg2, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     
     { stack:
       <textPtr>
       <general stack layout>
     }
     
     { The IOA heap is full, so we need a garbage collection.            }
     { Set the requested Object Size.            }
     4 -> BodySize/;
     4 -> BodySize+;
     BodySize -> ReqObjectSize;
     { Save calculated Range during GC }
     push Range;
     { Protect Range, textPtr, DataReg2 during GC }
     push Protect3Tag;
     { Stack:
       <tag3>
       <Range>
       <textPtr>
       <general stack layout>
       - data registers are tagged properly.
     }
     { newTop, newRep points inside IOA to unallocated chunk }
     0 -> newTop;
     0 -> newRep;
     { Call the garbage collector }
     call doGC;
     { Skip pushed tag }
     pop DataReg2 { skip };
     { Restore calculated range }
     pop Range;
     { stack:
       <textPtr>
       <general stack layout>
     }
     goto again
  #);

CopyCT_W: public
  (#
     { Allocate a (short)ValueRepetition and initialize it with some wide text. }
     
     { FIXME: Should be eliminated: Use CopyT_W instead }
     
     { Input variable. }
     textPtr: Long       = DataReg1; { Address to the ascii text. }
     
     { Output variable. }
     theRep:  Repetition = DataReg1; { The allocated repetition. }
                                     {pReg1 in Intel version}
     
     { Used variable.  }
     theText: CodeArea   = AddrReg1; { The ascii text. }
     Range:  Long 	 = DataReg1; { The range of the valRep. }
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     Value: Long         = DataReg1;
     newTop: DataArea    = AddrReg1;
     newRep: Repetition  = AddrReg2
  do
     (if debug then 1 -> NumCopyCT+ if); 
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <DataReg2>
       <AddrReg2>
       <AddrReg1>
       ... 
     }
     
     push AddrReg1, AddrReg2, DataReg2;
     push textPtr; {Save original input parameter}
     
     { stack:
       <textPtr>
       <general stack layout>
     }
     
     textPtr -> theText;
     { Calculate the length of the text. }
     0 -> Range;
     (if theText=0 then goto NULL if);
     goto LoopB;
     LoopA: 1  -> Range+;
     LoopB: (if theText[Range]!b <> 0 then goto LoopA if);
     NULL:
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 IOATop -> newRep;
                 Range -> BodySize;
                 2 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 newRep[16+BodySize][] -> newTop;
                 goto GC;
             if);
         if);
     if);

     again:

     (if Range > LARGE_REP_SIZE then
         push RegThis, RegCall; { save registers }
         push Range; { Parameters to LVRAAlloc. }
         push ShortRepPTValue; { Parameters to LVRAAlloc. }
         call LVRAAlloc;
         DataReg1 -> newRep;
         4 -> SP+;
         pop  Range;
         pop  RegCall, RegThis;
	 (if newRep = 0 then 
             Range -> BodySize;
             2 -> BodySize*;
             ObjectAlign -> BodySize|;
	     goto GC;
	 if);
         goto copyBody
     if);
     
     { Allocate a value repetition }
     IOATop -> newRep;
     Range -> BodySize;
     2 -> BodySize*;
     ObjectAlign -> BodySize|;
     newRep[16+BodySize][] -> newTop; { destroys theText }
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 12 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the valrep.             }
     ShortRepPTValue -> newRep.ProtoType; { byte rep }
     (if IOAMinAge<>0 then
         IOAMinAge -> newRep.GCAttr;
     if);
     1    -> newRep.LowBorder;
     Range -> newRep.HighBorder;
     
     copyBody:
     
     { stack:
       <textPtr>
       <general stack layout>
     }    
     pop theText; { Restore theText, i.e, load original input value) }
     { Stack: 
       <general stack layout>
     }
     
     newRep -> pReg1;
     
     Range -> BodySize;
     { Assign the text to the body part of the repetition. }
     (if BodySize <> 0 then
         0 -> Value;
         1 -> BodySize-;
         loop:
         theText[BodySize]!b -> Value!b;
         Value!w -> newRep[16+BodySize*2]!w;
         1 -> BodySize-;
         (if FLAGS >= 0 then goto loop if)
     if);

     pop DataReg2, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     
     { stack:
       <textPtr>
       <general stack layout>
     }
     
     { The IOA heap is full, so we need a garbage collection.            }
     { Set the requested Object Size.            }
     4 -> BodySize/;
     4 -> BodySize+;
     BodySize -> ReqObjectSize;
     { Save calculated Range during GC }
     push Range;
     { Protect Range, textPtr, DataReg2 during GC }
     push Protect3Tag;
     { Stack:
       <tag3>
       <Range>
       <textPtr>
       <general stack layout>
       - data registers are tagged properly.
     }
     { newTop, newRep points inside IOA to unallocated chunk }
     0 -> newTop;
     0 -> newRep;
     { Call the garbage collector }
     call doGC;
     { Skip pushed tag }
     pop DataReg2 { skip };
     { Restore calculated range }
     pop Range;
     { stack:
       <textPtr>
       <general stack layout>
     }
     goto again
  #)

