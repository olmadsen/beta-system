------- CopyCText: System ----

CopyCT: public
  (#
     { Allocate a (byte)ValueRepetition and initialize it with some text. }
     
     { FIXME: Should be eliminated: Use CopyT instead }
     
     { Input variable. }
     textPtr: Long       = DataReg1; { Address to the ascii text. }
                                     {DataRegA in non-Intel versions}
     
     { Output variable. }
     theRep:  Repetition = DataReg1; { The allocated repetition. }
                                     {pReg1 in Intel version}
     
     { Used variable.  }
     theText: CodeArea   = AddrReg1; { The ascii text. }
     Range:  Long 	 = DataReg1; { The range of the valRep. }
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     Value: Long         = DataReg1;
     newTop: DataArea    = AddrReg1;
     newRep: Repetition  = AddrReg2
  do
     (if debug then 1 -> NumCopyCT+ if); 
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <Intel: DataReg2>
       <Intel: AddrReg2>
       <Intel: AddrReg1>
       <Mac: AddrReg2>
       ... 
     }
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2;
     
     push textPtr; {Save original input parameter}
     
     textPtr -> theText;
     { Calculate the length of the text. }
     0 -> Range;
     (if theText=0 then goto NULL if);
     goto LoopB;
     LoopA: 1  -> Range+;
     LoopB: (if theText[Range]!b <> 0 then goto LoopA if);
     NULL:
     
     { FIXME: LVRA missing }
     { Cannot allocate in LVRA since we don't know the cell to assign to }

     { Allocate a value repetition with bodysize = ((range+1+3)/4)*4*size (size here 1) bytes }
     IOATop -> newRep;
     Range -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     newRep[16+BodySize][] -> newTop; { destroys theText }
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the valrep.             }
     ByteRepPTValue   -> newRep.ProtoType; { byte rep }
     1    -> newRep.Age;
     1    -> newRep.LowBorder;
     Range -> newRep.HighBorder;
     
     copyBody:
     
     pop theText; { Restore theText (that is, load original input value) }
     
     { Assign the text to the body part of the repetition. }
     0 -> Value;
     4 -> BodySize-;
     loop:
     theText[BodySize] -> Value;
     Value -> newRep[16+BodySize];
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     newRep -> pReg1;
     
     pop DataReg2, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     
     pop textPtr; {restore textPtr; was overwritten by Range}
     pop DataReg2, AddrReg2, AddrReg1;
     
     call doGC;              { Call the Garbage Collector.               }
     goto again             { Go back to the beginning of this routine. }
  #)
