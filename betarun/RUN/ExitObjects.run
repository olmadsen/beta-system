----- ExitObjects:system ------

ExO: public
  (#
     { Input variables. }
     theObj:  Item     = RegThis;  { the object we are leaving }
     exitObj: Item     = RegCall;  { the object to exit to. }
     exitAdr: CodeArea = DataReg2; { Code address to jump to. }
                                   { pReg1 in Intel version}
     offset:  Long     = DataReg1; { Offset in theObj where to get to 
                                     old sp-value
                                   }
     
     { Used variables. }
     stackPointer: StackArea = SP;
     theComp:      Component = AddrReg1;
     stackValue:   DataArea  = AddrReg1;
     tempSp:       DataArea  = AddrReg1;
     addr:         CodeArea  = AddrReg1;
  do
     (if debug then 1 -> NumExO+ if); 
     (if debug then call Ck if);
     
     pReg1 -> exitAdr;
     
     again:
     
     (if theObj = exitObj then 
         { found the object to exit to }
         goto exitLabel
     if);
     
     pop stackValue;
     (if stackValue = exitObj then goto exitLabel if);
     
     ActiveComponent -> theComp;
     (if theObj {stackValue} = theComp.Item then
         { passing component. terminate it as in AttachComponent }

         (if theComp.CallerComp = 0 then 
             { attempt to leave basic component! }
             { FIXME: What about PC for BetaError? }
             push theObj; 
             push LeaveBasicCompErr; 
             call BetaError;
         if);
         
         theComp.CallerComp -> ActiveComponent; 
         theComp.CallerObj  -> theObj;         
         0 -> theComp.StackObj;
         0 -> theComp.CallerComp;
         0 -> theComp.CallerObj;
         
         { Pop the component block }
         pop ActiveCallBackFrame;
         pop lastCompBlock;
         4 -> SP+ { level not used ? }
     if);
     goto again;
     
     exitLabel:
     exitObj -> theObj;
     exitObj[offset]!l -> tempSp;
     lastCompBlock -> tempSp+;
     tempSp -> stackPointer;
     exitAdr -> addr;
     (if debug then call Ck if);
     goto addr; {AddrRegs ok; stack ok, too}
  #)
