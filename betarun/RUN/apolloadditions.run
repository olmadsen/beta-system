[[

------- ApolloAdditions: System ----

ArgCount:  cvar;
ArgVector: cvar;

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
  (#
     stackPointer: StackArea = SP;
     theVector:    StackArea = AddrReg1
  do
     stackPointer[12] -> ArgCount;
     stackPointer[16] -> theVector;
     theVector -> ArgVector;
     return
  #);

oldCStack: cvar;
exit: cproc;

AsmExit: public
  (# { Because the APOLLO can't restore the stack when calling exit, }
     { we help it a little bit, by restoring the link register       }
     { Before calling exit. The link register is saved in main,      }
     { generated by the compiler.                                    }
     { BetaExit in misc.c calls AsmExit instead of exit.             }
     chain:  StackArea = SB;
     stack:  StackArea = SP;
     number: Long     = DataRegA
  do
     oldCStack -> chain;
     stack[4] -> number;
     push number;
     call exit;
     return
  #);

{ Routine called from betaenvbody in case of detected failure. }
FailureExit: public 
  (#
     { Called from betaenvbody: (FailureTrace,'') -> Stop }
     CurrentObject: Object = RegObj
  do
     push CurrentObject;
     push -8;
     call BetaError
  #);

Ret: public = 'Return' (# do return #)

------- CallBack: System ----

HandleCB: proc;
ActiveCallBackFrame: cvar;
BetaStackTop:        cvar;

CopyCPP: public
  (#
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     
     stackTop: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2
  do
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one! }
         { NYI }
         (code '	movem.l	a0-a4,-(sp)' code);
         (code '	movem.l	d0-d7,-(sp)' code);
         call CBFArelloc;
         (code '	movem.l	(sp)+,d0-d7' code);
         (code '	movem.l	(sp)+,a0-a4' code);
         goto CopyCPP
     if);
     
     newTop -> CBFATop;
     
     stackTop[4] -> theCBStruct[0];
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction 4eb9.}
     HandleCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     20085 -> theCBStruct[10]!w; { Write the rts instruction 4e75.}
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stackTop[4];
     
     return
  #);

HandleCB: public
  (#
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = DataReg1;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     theObj: Object = RegObj
  do
     (code '	movem.l	d2-d7/a1-a6,-(sp)' code);
     
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     
     (if theStruct=0 then
         pop ActiveCallBackFrame;
         pop BetaStackTop;
         4 -> SP+;
         call freeCallbackCalled;
         (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
         return;
     if);

     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
     
     return
  #)

--]]
