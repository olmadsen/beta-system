[[------- linuxadditions: System ----

ArgCount:  cvar;
ArgVector: cvar;

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
(#
  stackPointer: StackArea = SP;
  theVector:    StackArea = AddrReg1
do
   push AddrReg1;
   stackPointer[12]  -> ArgCount;
   stackPointer[16] -> theVector;
   theVector -> ArgVector;
   pop AddrReg1;
   return
#);

{ Routine called from betaenvbody in case of detected failure. }
FailureExit: public = '_FailureExit'
(#
  { Called from betaenvbody: (FailureTrace,'') -> Stop }
  CurrentObject: Object = RegObj
do
  push CurrentObject;
  push -8;
  call BetaError
#)

------- CallBack: System ----

HandleCB: proc;
ActiveCallBackFrame: cvar;
BetaStackTop:        cvar;

CopyCPP: public
  (#
     { Used variables. }
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     stack: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2;
     tmpCalc: DataArea = DataReg1;
  do
     {
       Stack layout:
       <AddrReg2>         +0
       <AddrReg1>         +4
       <DataReg1>         +8
       <return address>   +12
       <struct>           +16
     }
          
     push DataReg1, AddrReg1, AddrReg2;
     
     again:
     
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[10][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one.
           Not yet implemented: No one are ever freed 
         }
	 (code '	pushal' code);
         call CBFArelloc;
         (code '	popal' code);
         goto again;
     if);
     
     newTop -> CBFATop;
     
     stack[16] -> theCBStruct[0];
     232 -> theCBStruct[4]!b;  {Write call opcode: 0xe8}
     HandleCB[] -> theRoutine; 
     theCBStruct[9][] -> tmpCalc; 
     tmpCalc -> theRoutine-;
     theRoutine -> theCBStruct[5]; {Write call argument: relative offset to HandleCB[]}
     195 -> theCBStruct[9]!b; { Write ret opcode: 0xcb}
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stack[16];
     
     pop AddrReg2, AddrReg1, DataReg1;
     {(code '	invd' code);} {Flush cache -- i486 only}
     return
  #);



HandleCB: public
  (#
     { Output variable. }
     { C call returns result i eax }
     
     { Used variables. }
     stack: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     theOrigin:   Object    = DataReg1;
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     theObj: Object = RegObj
  do
     (code '	pushl %ecx' code);
     (code '	pushl %edx' code);
     (code '	pushl %ebx' code);
     (code '	pushl %ebp' code);
     (code '	pushl %esi' code);
     (code '	pushl %edi' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stack -> ActiveCallBackFrame;
     
     stack[36{(3+6)*4}] -> dataPointer;
     dataPointer[-9{sizeof(struct)+sizeof(call)=4+5}] -> theStruct;
     
     (if theStruct=0 then
         pop ActiveCallBackFrame;
         pop BetaStackTop;
         4 -> SP+;
         call freeCallbackCalled;
         (code '	popl %edi' code);
         (code '	popl %esi' code);
         (code '	popl %ebp' code);
         (code '	popl %ebx' code);
         (code '	popl %edx' code);
         (code '	popl %ecx' code);
         return;
     if);

     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer; {Returns result in eax}
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stack+;
     
     (code '	popl %edi' code);
     (code '	popl %esi' code);
     (code '	popl %ebp' code);
     (code '	popl %ebx' code);
     (code '	popl %edx' code);
     (code '	popl %ecx' code);
     
     return;
  #)

----]]
