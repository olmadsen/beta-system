[[------- hpadditions: System ----
{ WARNING: This is the HP specific part of the runtime-system. }
{ WARNING: Instructions are machine and assembler dependent.   }


ArgCount:  cvar;
ArgVector: cvar;

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
(#
  stackPointer: StackArea = SP;
  theVector:    StackArea = AddrReg1
do
  stackPointer[8]  -> ArgCount;
  stackPointer[12] -> theVector;
  theVector -> ArgVector;
  return
#);

{ Routine called from betaenvbody in case of detected failure. }
FailureExit: public = '_FailureExit'
(#
  { Called from betaenvbody: (FailureTrace,'') -> Stop }
  CurrentObject: Object = RegObj
do
  push CurrentObject;
  push -8;
  call BetaError
#)

------- CallBack: System ----

HandleCB: proc;
ActiveCallBackFrame: cvar;
BetaStackTop:        cvar;

CopyCPP: public
  (#
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     
     stackTop: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2
  do
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one.
           Not yet implemented: No one are ever freed 
         }
         (code '      movm.l  %a0-%a4,-(%sp)' code);
         (code '      movm.l  %d0-%d7,-(%sp)' code);
         call CBFArelloc;
         (code '      movm.l  (%sp)+,%d0-%d7' code);
         (code '      movm.l  (%sp)+,%a0-%a4' code);
         goto CopyCPP
     if);
     
     newTop -> CBFATop;
     
     stackTop[4] -> theCBStruct[0];
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction 4eb9.}
     HandleCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     20085 -> theCBStruct[10]!w; { Write the rts instruction 4e75.}
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stackTop[4];
     
     return
  #);

HandleCB: public
  (#
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = DataReg1;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     theObj: Object = RegObj
  do
     (code '	movm.l	%d2-%d7/%a1-%a6,-(%sp)' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     
     (if theStruct=0 then
         pop ActiveCallBackFrame;
         pop BetaStackTop;
         4 -> SP+;
         call freeCallbackCalled;
         (code '	movm.l	(%sp)+,%d2-%d7/%a1-%a6' code);
         return;
     if);

     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movm.l	(%sp)+,%d2-%d7/%a1-%a6' code);
     
     return
  #)

----]]
