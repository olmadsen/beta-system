------- Attach: System ----
Att: public
  (#
     { Attach a component. }
     
     { Used variables. }
     comp: Component = RegArg;
     compObj: Object    = RegArg;
     theObj:  Item      = RegObj;
     stackPointer: StackArea = SP;
     theProto: ProtoType = AddrReg2;
     theAddr:  CodeArea  = AddrReg1;
     theEntry: CodeArea = AddrReg1;
     theCell:  DataArea = AddrReg1;
     tmpComp: Component = AddrReg1
  do
     (if debug then call Ck if);
     
     (if comp.CallerLSC = 0 then goto FirstAttach if);
     
     (if comp.StackObj =  -1    then goto RecursiveAttach; if);
     (if comp = ActiveComponent then goto RecursiveAttach; if);

     pop comp.CallerLSC; { Save the return address }
     
     ActiveComponent -> comp.CallerComp;
     { comp.CallerComp[] -> CheckReferenceAssignment. }
     comp -> theCell; theCell[16][] -> theCell;
     (if theCell outside IOA then
         push theCell;
         call ChkRA; { No need to remove parameter }
     if);
     
     theObj -> comp.CallerObj;
     { comp.CallerObj -> CheckReferenceAssignment. }
     comp -> theCell; theCell[12][] -> theCell;
     (if theCell outside IOA then
         push theCell;
         call ChkRA; { No need to remove parameter }
     if);
     
     { -1 -> ActiveComponent.StackObj. }
     { Tells that ActiveComponent is active.     }
     ActiveComponent -> tmpComp;
     -1 -> tmpComp.StackObj;
     
     (if comp.StackObj = 0 then goto IsTerminated if);
     
     { Push a new component block. }
     push 0;
     push lastCompBlock;
     push ActiveCallBackFrame;
     
     stackPointer -> lastCompBlock;
     0            -> ActiveCallBackFrame;  
     
     comp -> ActiveComponent;
     
     call UnpkCS;
     
     pop theObj;
     label AttSecond; { For Valhalla }
     (if intel then 
         0 -> AddrReg2; {Invalidate GC register; AddrReg1 invalidated by UnpkCS}
     if);
     return;
     
     FirstAttach:
     
     pop comp.CallerLSC; { Save the return address }
     ActiveComponent -> comp.CallerComp;
     { comp.CallerComp -> CheckReferenceAssignment. }
     comp -> theCell; theCell[16][] -> theCell;
     (if theCell outside IOA then
         push theCell;
         call ChkRA; { No need to remove parameter }
     if);
     
     theObj -> comp.CallerObj;
     { comp.StackObj -> CheckReferenceAssignment. }
     comp -> theCell; theCell[12][] -> theCell;
     (if theCell outside IOA then
         push theCell;
         call ChkRA; { No need to remove parameter }
     if);
     
     { -1 -> ActiveComponent.StackObj. }
     { Tells that ActiveComponent is active.     }
     ActiveComponent -> tmpComp;
     -1 -> tmpComp.StackObj;
     
     { Push a new component block. }
     push 0;
     push lastCompBlock;
     push ActiveCallBackFrame;
     
     stackPointer -> lastCompBlock;
     0            -> ActiveCallBackFrame;  
     
     comp -> ActiveComponent;
     comp[24][] -> compObj;
     compObj.ProtoType -> theProto;  
     TerminateComponent[] -> theAddr;
     push theAddr;
     
     theProto.EntryPoint -> theEntry;
     label AttFirst; { For Valhalla }
     goto theEntry; {AddrRegs ok; stack ok, too}
     
     TerminateComponent:
     ActiveComponent -> comp;
     0 -> comp.StackObj;
     comp.CallerComp -> ActiveComponent; 0 -> comp.CallerComp;
     comp.CallerObj  -> theObj;          0 -> comp.CallerObj;
     
     { Pop the Component Block. }
     pop ActiveCallBackFrame;
     pop lastCompBlock;
     pop theEntry;
     
     comp.CallerLSC -> theEntry;
     (if intel then
         0 -> AddrReg2; {Invalidate GC register}
     if);
     label AttEnd; { For Valhalla }     
     goto theEntry;
     
     IsTerminated:
     push theObj;
     push -2;
     call BetaError;
     
     RecursiveAttach:
     push theObj;
     push -17; { RecursiveAttErr }
     call BetaError;
  #)

