------- Attach: System ----
TerminateComponent: proc;

Att: public
  (#
     { Attach a component. }
     
     { Input variables. }
     comp: Component = RegCall;
     theObj:  Item      = RegThis;
     
     { Used variables. }
     compObj:      Object      = RegCall;
     stackPointer: StackArea   = SP;
     theProto:     ProtoType   = AddrReg2;
     theAddr:      CodeArea    = AddrReg1;
     theEntry:     CodeArea    = AddrReg1;
     theCell:      DataArea    = AddrReg1;
     tmpComp:      Component   = AddrReg1;
     theStackObj:  StackObject = AddrReg2;
     Size:         Long        = DataReg1;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumAtt+ if); 
     
     (if comp.CallerLSC = 0 then goto FirstAttach if);

     pop comp.CallerLSC; { Save the return address }
     
     (if comp.StackObj =  -1    then goto RecursiveAttach; if);
          
     ActiveComponent -> comp.CallerComp;
     { comp.CallerComp[] -> CheckReferenceAssignment. }
     comp -> theCell; theCell[16][] -> theCell;
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then
             push theCell;
             call ChkRA; { No need to remove parameter }
         if);
     if);

     theObj -> comp.CallerObj;
     { comp.CallerObj -> CheckReferenceAssignment. }
     comp -> theCell; theCell[12][] -> theCell;
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then
             push theCell;
             call ChkRA; { No need to remove parameter }
         if);
     if);

     { -1 -> ActiveComponent.StackObj. }
     { Tells that ActiveComponent is active.     }
     { Cannot assign directly to ActiveComponent.StackObj since
       ActiveComponent is not declared as a Component in RUN, but
       simply as a C variable (which currently cannot be typed)
     }
     ActiveComponent -> tmpComp;
     -1 -> tmpComp.StackObj;
     
     (if comp.StackObj = 0 then goto IsTerminated if);
     
     { Push a new component block. }
     push 0;
     push lastCompBlock;
     push ActiveCallBackFrame;
     
     stackPointer -> lastCompBlock;
     0            -> ActiveCallBackFrame;  
     
     comp -> ActiveComponent;
     
     { Unpack comp.StackObj }
     comp.StackObj -> theStackObj;
     theStackObj.StackSize -> Size;
     1 -> Size-;
     loop:
     push theStackObj[16+Size*4];
     1 -> Size-;
     (if FLAGS >= 0 then goto loop if);
     -1 -> comp.StackObj;
     
     pop theObj; { Current object was pushed by Suspend before 
                   packing stack part.
                 }
     (if debug then call Ck if);
     return;
     
     FirstAttach:
     
     pop comp.CallerLSC; { Save the return address }
     ActiveComponent -> comp.CallerComp;
     { comp.CallerComp -> CheckReferenceAssignment. }
     comp -> theCell; theCell[16][] -> theCell;

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then
             push theCell;
             call ChkRA; { No need to remove parameter }
         if);
     if);
     
     theObj -> comp.CallerObj;
     { comp.StackObj -> CheckReferenceAssignment. }
     comp -> theCell; theCell[12][] -> theCell;

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then
             push theCell;
             call ChkRA; { No need to remove parameter }
         if);
     if);
     
     { -1 -> ActiveComponent.StackObj. }
     { Tells that ActiveComponent is active.     }
     ActiveComponent -> tmpComp;
     -1 -> tmpComp.StackObj;
     
     { Push a new component block. }
     push 0;
     push lastCompBlock;
     push ActiveCallBackFrame;
     
     stackPointer -> lastCompBlock;
     0            -> ActiveCallBackFrame;  
     
     comp -> ActiveComponent;
     comp[24][] -> compObj;
     compObj.ProtoType -> theProto;  
     TerminateComponent[] -> theAddr;
     push theAddr;
     
     theProto.TopMpart -> theEntry;
     goto theEntry; {AddrRegs ok; stack ok, too}
     
     IsTerminated:
     4 -> SP+; { Pop comp, which compiler saves around call of Att }
     push comp.CallerLSC; { return address for BetaError }
     push theObj; push CompTerminatedErr; call BetaError;
     
     RecursiveAttach:
     4 -> SP+; { Pop one, since compiler saves comp around call of Att }
     push comp.CallerLSC; { return address for BetaError }
     push theObj; push RecursiveAttErr; call BetaError;
#);

TerminateComponent: public
  (#
     { Used variables. }
     comp: Component    = RegCall;
     theObj:  Item      = RegThis;
     theEntry: CodeArea = AddrReg1;
     
  do (if debug then 1 -> NumTermComp+ if);
     ActiveComponent -> comp;
     0 -> comp.StackObj;
     comp.CallerComp -> ActiveComponent; 0 -> comp.CallerComp;
     comp.CallerObj  -> theObj;          0 -> comp.CallerObj;
     
     { Pop the Component Block. }
     pop ActiveCallBackFrame;
     pop lastCompBlock;
     pop theEntry;
     
     comp.CallerLSC -> theEntry;
     clear AddrReg2; {Invalidate GC register}
     (if debug then call Ck if);
     goto theEntry;
  #)
