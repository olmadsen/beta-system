----- CInterface: system -----

CinitT: public
  (# 
     { Used variable. }
     thePoolAddr: DataArea = AddrReg1;
  do
     push AddrReg1;
     CTextPool[] -> thePoolAddr;
     thePoolAddr -> CTextPoolEnd;
     pop AddrReg1;
     return
  #);



CpkVT: public
  (#
     { Input variable. }
     repArg:      Repetition = DataReg1; {pReg1 in Intel version}
     
     { Used variables. }
     a1:          Long       = RegCall;
     theRep:      Repetition = RegCall;
     theTextAddr: DataArea   = AddrReg2;
     FreeSpace:   Long       = DataReg1;
     nextText:    DataArea   = AddrReg1;
     BodySize:    Long       = DataReg2;
     index:       Long       = DataReg3; { Saved/restored }
     Value:       Long       = DataReg1;
     stack:   StackArea  = SP;
  do 
     {
       General stack layout:
       <a1>                Intel: +0    Mac: +0    Default: +0
       <Intel: DataReg2>   Intel: +4
       <Intel: AddrReg2>   Intel: +8
       <Intel: AddrReg1>   Intel: +12
       <Mac: AddrReg2>                  Mac: +4    
       <return address>    Intel: +16   Mac: +8    Default: +4
       <C argument>        Intel: +20   Mac: +12   Default: +8
     }
     
     (if debug then call Ck if);
     (if debug then 1 -> NumCpkVT+ if); 

     pReg1 -> DataReg1;
     
     {Reserve room for C argument below return address}
     4 -> stack-; 
     stack[4] -> stack[0]; 
     
     push AddrReg1, AddrReg2, DataReg2;
     
     push a1;
     repArg -> theRep;
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Check range overflow on CTextPool.                               }
     { nextText is used as a tmp. register only.                        }
     { Size_left_in_CTextPool = (Adr(CTextPool) + MAXCTEXTPOOL) - CTextPoolEnd. }
     CTextPool[] -> nextText;
     nextText -> FreeSpace;
     MAXCTEXTPOOL -> FreeSpace+;
     CTextPoolEnd -> FreeSpace-;
     
     theRep.HighBorder -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     
     (if FreeSpace < BodySize then
         24 -> stack+; push RegThis; push CTextPoolErr; call BetaError;
     if);
     
     push DataReg3;
     
     { Copy the contents of the repetition to the CTextPool. }
     (if BodySize <> 0 then
         0 -> index;
         loop:
         theRep[16+index] -> Value; { copy as longs, the repetition is mult. of 4 }
         Value -> theTextAddr[index];
         4 -> index+;
         (if index < BodySize then goto loop if)
     if);
     
     pop DataReg3;
     
     { Update CTextPool. }
     theTextAddr[BodySize][] -> nextText;
     nextText -> CTextPoolEnd;
     
     {Install C argument}
     theTextAddr -> stack[20];
     
     pop a1;
     pop DataReg2, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
  #);



CpkSVT: public
  (#
     { Input variables. }
     repArg:      Repetition = DataReg1; {pReg1 in Intel version}
     low:         Long       = DataReg2; {pReg2 in Intel version}
     high:        Long       = DataReg3; {pReg3 in Intel version}
     
     { Used variables. }
     a1:          Long       = RegCall;
     theRep:      Repetition = RegCall;
     theTextAddr: DataArea   = AddrReg2;
     FreeSpace:   Long       = DataReg2;
     nextText:    DataArea   = AddrReg1;
     BodySize:    Long       = DataReg1; 
     index:       Long       = DataReg2;
     Value:       Byte       = DataReg1;
     stack:   StackArea  = SP;
  do 
     {
       General stack layout:
       <a1>                Intel: +0    Mac: +0    Default: +0
       <Intel: DataReg3>   Intel: +4
       <Intel: AddrReg2>   Intel: +8
       <Intel: AddrReg1>   Intel: +12
       <Mac: AddrReg2>                  Mac: +4    
       <return address>    Intel: +16   Mac: +8    Default: +4
       <C argument>        Intel: +20   Mac: +12   Default: +8
     }
     
     (if debug then 1 -> NumCpkSVT+ if); 
     (if debug then call Ck if);
     
     {Reserve room for C argument below return address}
     4 -> stack-; 
     stack[4] -> stack[0]; 
     
     push AddrReg1, AddrReg2, DataReg3;
     
     pReg1 -> DataReg1; pReg2 -> DataReg2; pReg3 -> DataReg3;

     push a1;
     repArg -> theRep;
     
     { Check bounds and transform high into number of bytes to copy }
     (if low  < theRep.LowBorder then 
         24 -> stack+; push RegThis; push RepLowRangeErr; call BetaError;
     if);
     (if high > theRep.HighBorder then 
         24 -> stack+; push RegThis; push RepHighRangeErr; call BetaError;
     if);
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Check range overflow on CTextPool.                               }
     { nextText is used as a tmp. register only.                        }
     { Size_left_in_CTextPool = (Adr(CTextPool) + MAXCTEXTPOOL) - CTextPoolEnd. }
     
     push low; {Save low; is about to be destroyed by FreeSpace assignment}
     
     CTextPool[] -> nextText;
     nextText -> FreeSpace;
     MAXCTEXTPOOL -> FreeSpace+;
     CTextPoolEnd -> FreeSpace-;
     
     high -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     (if FreeSpace < BodySize then
         28 -> stack+; push RegThis; push CTextPoolErr; call BetaError;
     if);
     
     pop low; {Restore low; finished using FreeSpace}
     
     { Copy the contents of the repetition to the CTextPool. }
     (if high <> 0 then
         1 -> low-;
         theRep[low][] -> theRep; { Start at low. }
         0 -> index;
         push BodySize; {Save BodySize; is about to be destroyed by Value assignment}
         loop:
         theRep[16+index]!b -> Value; { copy as bytes }
         Value -> theTextAddr[index]!b;
         1 -> index+;
         (if index < high then goto loop if);
         pop BodySize; {Restore Bodysize; finished using Value}
     if);
     0 -> theTextAddr[high]!b; { NULL termination }
     
     { Update CTextPool. }
     theTextAddr[BodySize][] -> nextText;
     nextText -> CTextPoolEnd;
     
     {Install C argument}
     theTextAddr -> stack[20];
     
     pop  a1;
     pop DataReg3, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
  #)
