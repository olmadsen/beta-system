------- CheckReferenceAssignment: System ----
{ CheckReferenceAssignment is called with an argument on the stack, }
{ which is the address of a cell (the target of the assignment).     }
{ For the current being this address is always inserted in a hash-  }
{ table. This table is used during IOAGc, because it points out the  }
{ roots in AOA, which refer objects in IOA.                          }

{ Do NOT call Ck in this routine! TheCell points into the middle of }
{ an object }


ChkRA: public
  (#
     { Used variables. }
     stack:      StackArea = SP;
     theCell:    DataArea  = DataReg1;  { eax }
     theObj:     DataArea  = AddrReg1;  { ebp }
  do 
     {
       General stack layout:
       <DataReg1>          +0
       <AddrReg1>          +4
       <return address>    +8
       <theCell>           +12
     }
     
     (if debug then 1 -> NumChkRA+ if); 

     push AddrReg1, DataReg1;
     stack[12] -> theCell; 
     theCell[0] -> theObj;
     
     (if theObj>=IOA then
         (if theObj<IOATop then
             { theObj is in IOA }
             goto TableInsert;
         if)
     if);
     
     { theObj is outside IOA and should not go into AOAtoIOATable. }
     
     { NEW PERSISTENSE: }
     { If *cell is inPIT, then it should be registrered. }
     { For efficiency, the check should be here, but for now, }
     { we'll just call C and let that check it. }
     (if PERSIST then
         (if PIT <= theObj then
             (if theObj < PITLimit then
	         push AddrReg2;
	         push RegThis;
	         push RegCall;
	         push RegAdr;
	         push DataReg2;
	         { arguments }
	         push theCell;
	         push theObj;
	         call newAOAcell;
	         pop theObj;
	         pop theCell;
	         pop DataReg2;
	         pop RegAdr;
	         pop RegCall;
	         pop RegThis;
	         pop AddrReg2;   
	     if);    
	 if);
     if);
     
     { theObj is outside IOA and PIT and should not go into AOAtoIOATable. }
     goto Exit;

     TableInsert:
     { theObj is in IOA. Put theCell into AOAtoIOATable }
     { Save remaining registers before entering c-world }
     push AddrReg2;
     push RegThis;
     push RegCall;
     push RegAdr;
     push DataReg2;
     { argument }
     push theCell;
     call AOAtoIOAInsert;
     pop theCell;
     pop DataReg2;
     pop RegAdr;
     pop RegCall;
     pop RegThis;
     pop AddrReg2;
     
  Exit:
     pop DataReg1, AddrReg1;
     return 4;
  #);

ChkRA_EBP: public
  (#
     { Used variables. }
     stack:      StackArea = SP;
     theCell:    DataArea  = AddrReg1;  { ebp }
     theObj:     DataArea  = DataReg1;  { eax }
  do 
     
     (if debug then 1 -> NumChkRA+ if); 
     
     (if call_chkra_unconditionally then
         { Check if theCell (EBP) is outside IOA - if not: return }
         (if gas then
           (if underscore then
             (code '	cmpl	_IOA,%ebp     	' code);
             (code '	jb	L5000	     	' code); 
             (code '	cmpl	_IOATop,%ebp  	' code); 
             (code '	jae	L5000	     	' code); 
             (code '	xorl	%ebp,%ebp    	' code); 
             (code '	ret		     	' code); 
           else
	     (code 'L5000:     		     	' code); 
             (code '	cmpl	IOA,%ebp     	' code);
             (code '	jb	L5000	     	' code); 
             (code '	cmpl	IOATop,%ebp  	' code); 
             (code '	jae	L5000	     	' code); 
             (code '	xorl	%ebp,%ebp    	' code); 
             (code '	ret		     	' code); 
             (code 'L5000:     		     	' code); 
           if);
         else { ml }
             (code '	cmp	ebp, _IOA	' code);
             (code '	jb	L5000		' code);
             (code '	cmp	ebp,_IOATop	' code);
             (code '	jae	L5000		' code);
             (code '	xor	ebp,ebp		' code);
             (code '	ret		 	' code); 
             (code 'L5000:     		  	' code); 
         if);
      else
         AsmComment 'Not checking if theCell is outside IOA';
     if);
     
     push DataReg1;
     {
       stack:
       <DataReg1>          +0
       <return address>    +4
     }
     
     theCell[0] -> theObj;
     
     { Check if theObj (EAX) is inside IOA - if not: lazycheck }
     (if gas then
       (if underscore then
         (code '        cmpl	_IOA,%eax     	' code);
         (code '        jb	L5010	     	' code); 
         (code '        cmpl	_IOATop,%eax  	' code); 
         (code '        jb	L5011	     	' code); 
         (code 'L5010:        		     	' code); 
        else
         (code '        cmpl	IOA,%eax     	' code);
         (code '        jb	L5010	     	' code); 
         (code '        cmpl	IOATop,%eax  	' code); 
         (code '        jb	L5011	     	' code); 
         (code 'L5010:        		     	' code); 
        if);
      else
         (code '	cmp	eax, _IOA	' code);
         (code '	jb	L5010		' code);
         (code '	cmp	eax,_IOATop	' code);
         (code '	jb	L5011		' code);
         (code 'L5010:        		  	' code); 
     if);
     
     (code 'L5011: ' code); 
     { TableInsert: }
     { theObj is in IOA. Put theCell into AOAtoIOATable }
     { Save remaining registers before entering c-world }
     push AddrReg1;
     push AddrReg2;
     push RegThis;
     push RegCall;
     push RegAdr;
     push DataReg2;
     { argument }
     push theCell;
     call AOAtoIOAInsert;
     pop theCell;
     pop DataReg2;
     pop RegAdr;
     pop RegCall;
     pop RegThis;
     pop AddrReg2;
     pop AddrReg1;
     
     0->theCell; 
     pop DataReg1;
     return;
  #);

ChkRA_ESI: public
  (#
     { Used variables. }
     stack:      StackArea = SP;
     theCell:    DataArea  = AddrReg2;  { esi }
     theObj:     DataArea  = DataReg1;  { eax }
  do 
     { FIXME: Apparently this is called VERY seldomly - maybe it should
       be eliminated and parameter should be fixed at call site.
     }
     
     (if debug then 1 -> NumChkRA+ if); 
     
     (if call_chkra_unconditionally then
         { Check if theCell (ESI) is outside IOA - if not: return }
         (if gas then
            (if underscore then
             (code '	cmpl	_IOA,%esi     ' code);
             (code '	jb	L5001	     ' code); 
             (code '	cmpl	_IOATop,%esi  ' code); 
             (code '	jae	L5001	     ' code); 
             (code '	xorl    %esi,%esi    ' code); 
             (code '	ret		     ' code); 
             (code 'L5001:     		     ' code); 
            else 
             (code '	cmpl	IOA,%esi     ' code);
             (code '	jb	L5001	     ' code); 
             (code '	cmpl	IOATop,%esi  ' code); 
             (code '	jae	L5001	     ' code); 
             (code '	xorl    %esi,%esi    ' code); 
             (code '	ret		     ' code); 
             (code 'L5001:     		     ' code); 
	    if);
          else { ml }
             (code '	cmp	esi, _IOA	' code);
             (code '	jb	L5001		' code);
             (code '	cmp	esi,_IOATop	' code);
             (code '	jae	L5001		' code);
             (code '	xor	esi,esi		' code);
             (code ' 	ret		 	' code); 
             (code 'L5001:     		  	' code); 
         if);
      else
         AsmComment 'Not checking if theCell is outside IOA';
     if);
     
     push DataReg1;
     {
       stack:
       <DataReg1>          +0
       <return address>    +4
     }
     
     theCell[0] -> theObj;
     
     { Check if theObj (EAX) is inside IOA - if not: lazycheck }
     (if gas then
       (if underscore then
         (code '        cmpl	_IOA,%eax     	' code);
         (code '        jb	L5012	     	' code); 
         (code '        cmpl	_IOATop,%eax  	' code); 
         (code '        jb	L5013	     	' code); 
         (code 'L5012:        		     	' code); 
        else
         (code '        cmpl	IOA,%eax     	' code);
         (code '        jb	L5012	     	' code); 
         (code '        cmpl	IOATop,%eax  	' code); 
         (code '        jb	L5013	     	' code); 
         (code 'L5012:        		     	' code); 
	if);
      else
         (code '	cmp	eax, _IOA	' code);
         (code '	jb	L5012		' code);
         (code '	cmp	eax,_IOATop	' code);
         (code '	jb	L5013		' code);
         (code 'L5012:        		  	' code); 
     if);
     
     (code 'L5013: ' code); 
     { TableInsert: }
     { theObj is in IOA. Put theCell into AOAtoIOATable }
     { Save remaining registers before entering c-world }
     push AddrReg1;
     push AddrReg2;
     push RegThis;
     push RegCall;
     push RegAdr;
     push DataReg2;
     { argument }
     push theCell;
     call AOAtoIOAInsert;
     pop theCell;
     pop DataReg2;
     pop RegAdr;
     pop RegCall;
     pop RegThis;
     pop AddrReg2;
     pop AddrReg1;
     
     0->theCell; 
     pop DataReg1;
     return;
  #)
