------- CheckReferenceAssignment: System ----
{ CheckReferenceAssignment is called with an argument on the stack, }
{ which is the address of a cell (the target of the assignment).     }
{ For the current being this address is allways inserted in a hash-  }
{ table. This table is used during IOAGc, because it points out the  }
{ roots in AOA, which refer objects in IOA.                          }
AOAtoIOAtableSize: cvar;
AOAtoIOAtable:     cvar;
{ CheckAOAtoIOAtableSize: cproc; }

ChkRA: public
  (#
     { Used variables. }
     stack:   StackArea = SP;
     address: Long = DataReg1;  { d7/eax }
     value:   Long = DataReg2;  { d6 } {Not used in Intel version}
     IntelValue: Long = RegThis; { edx } {Only used in Intel version}
     tmp:     DataArea = AddrReg1;
     table:   DataArea = AddrReg1;
     index:   Long     = DataReg3; { Saved and restored. }
  do 
     {
       General stack layout:
       <Intel: RegThis>     Intel: +0
       <Intel: DataReg1>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <return address>    Intel: +12   Default: +0
       <address>           Intel: +16   Default: +4
     }
     
     { (if debug then call Ck if); }
     (if debug then 1 -> NumChkRA+ if); 

     (if intel then push AddrReg1, DataReg1, RegThis if);
     
     again:
     
     (if intel then
         stack[16] -> tmp; 
      else
         stack[4] -> tmp; 
     if);
     tmp -> address; 
     tmp[0] -> tmp;
     
     (if tmp outside IOA then 
         (if tmp < -101 then 
             { Save registers before entering c-world }
             (if linux then
                 (code '	pushal' code);
             if);
             (if nti then
                 (code '	pushad' code);
             if);
             (if hp then
                 (code '      movm.l  %a0-%a4,-(%sp)' code);
                 (code '      movm.l  %d0-%d7,-(%sp)' code);
             if);
             (if MacOS then
                 (code '      movem.l  a0-a4,-(sp)' code);
                 (code '      movem.l  d0-d7,-(sp)' code);
             if);
             push address;
             (if MacOS then
                 (code '      IMPORT negAOArefsINSERT:DATA' code);
                 (code '      move.l negAOArefsINSERT,a0' code);
                 (code '      jsr (a0)' code);
             if);
             (if hp then
                 (code '      mov.l _negAOArefsINSERT,%a0' code);
                 (code '      jsr (%a0)' code);
             if);
             (if linux then
                 (code '    movl negAOArefsINSERT,%esi' code);
                 (code '    call *%esi' code);
             if);
             (if nti then
                 (code 'extrn	_negAOArefsINSERT:dword' code);
                 (code '	mov	esi, _negAOArefsINSERT' code);
                 (code '	call	esi' code);
             if);
             pop address;
             (if linux then
                 (code '	popal' code);
             if);
             (if nti then
                 (code '	popad' code);
             if);
             (if hp then
                 (code '      movm.l  (%sp)+,%d0-%d7' code);
                 (code '      movm.l  (%sp)+,%a0-%a4' code);
             if);
             (if MacOS then
                 (code '      movem.l  (sp)+,d0-d7' code);
                 (code '      movem.l  (sp)+,a0-a4' code);
             if);
         if);
         (if intel then pop RegThis, DataReg1, AddrReg1 if);
         {(if debug then call Ck if);}
         return 4;
     if);
     
     (if debug then
         {
         (if intel then
             push stack[12];
          else
             push stack[0];
         if);
         push address;
         call CheckAOAtoIOAtableSize;
         }
     if);
          
     { Compute hash1.                                  }
     { hash1(address) = address MOD AOAtoIOAtableSize. }
     (if hp then
         (code '	divul.l	_AOAtoIOAtableSize,%d6:%d7' code)
     if);
     (if MacOS then
         (code '	tdivu.l	((AOAtoIOAtableSize).L,a5),d6:d7' code)
     if);
     (if intel then
         0 -> IntelValue; {Clear MSB in EDX:EAX register pair}
         (if linux then 
             (code '	div	AOAtoIOAtableSize,%eax' code) 
         if);
         (if nti then 
             (code '	div	dword ptr _AOAtoIOAtableSize' code) 
         if);
     if);
     
     { If the table entry is free insert it!.    }
     AOAtoIOAtable -> table;
     (if intel then
         (if table[16+IntelValue*4] = 0 then goto insert if);
      else
         (if table[16+value*4] = 0 then goto insert if);
     if);
     
     { So the hash1 entry is occupied, check if the entry }
     { matches the address. In case of match the address  }
     { is already inserted, leave the function.           }
     (if intel then
         stack[16] -> address;
         (if table[16+IntelValue*4] = address then 
             pop RegThis, DataReg1, AddrReg1;
             {(if debug then call Ck if);}
             return 4;
         if);
      else
         stack[4] -> address;
         (if address = table[16+value*4] then
             {(if debug then call Ck if);}
             return 4 
         if);
     if);
     
     { Compute hash2.                                      }
     { hash2(address) = (address*16) MOD AOAtoIOAtableSize. }
     (if hp then
         (code '	lsl.l	&4,%d7                  ' code);
         (code '	divul.l	_AOAtoIOAtableSize,%d6:%d7' code)
     if);
     (if MacOS then
         (code '	lsl.l	#4,d7                  ' code);
         (code '	tdivu.l	((AOAtoIOAtableSize).L,a5),d6:d7' code)
     if);
     (if intel then
         0 -> IntelValue; {Clear MSB in EDX:EAX register pair}
         (if linux then
             (code '	shl	$4,%eax' code);
             (code '	div	AOAtoIOAtableSize,%eax' code);
         if);
         (if nti then
             (code '	shl	eax,4' code);
             (code '	div	dword ptr _AOAtoIOAtableSize' code);
         if);
     if);
     
     { If the table entry is free, insert it!. }
     (if intel then
         (if table[16+IntelValue*4] = 0 then goto insert if);
      else
         (if table[16+value*4] = 0 then goto insert if);
     if);
     
     { So the hash2 entry is occupied, check if the entry }
     { matches the address. In case of match the address  }
     { is already inserted, leave the function.           }
     (if intel then
         stack[16] -> address;
         (if table[16+IntelValue*4] = address then 
             pop RegThis, DataReg1, AddrReg1;
             {(if debug then call Ck if);}
             return 4;
         if);
      else
         stack[4] -> address;
         (if address = table[16+value*4] then return 4 if);
     if);
     
     { Both the hash1(address) and hash2(address) entries are }
     { occupied with others addresses.                        }
     
     { Try to find an entry after hash2(address). }
     push index;
     0 -> index;
     loop:
     (if index < 100 then
         1 -> index+; index -> address+;
         { value MOD AOAtoIOAtableSize -> value. }
         {******************************************************}
         {*  GROSSLY INEFFICIENT: NO NEED TO USE MODULO HERE!  *}
         {*  THIS REALLY OUGHT TO BE OPTIMIZED - EASY, TOO...  *}
         {******************************************************}
         (if hp then
             (code '	divul.l	_AOAtoIOAtableSize,%d6:%d7' code)
         if);
         (if MacOS then
             (code '	tdivu.l	((AOAtoIOAtableSize).L,a5),d6:d7' code)
         if);
         (if intel then
             0 -> IntelValue; {Clear MSB in EDX:EAX register pair}
             (if linux then 
                 (code '	div	AOAtoIOAtableSize,%eax' code) 
             if);
             (if nti then 
                 (code '	div	dword ptr _AOAtoIOAtableSize' code) 
             if);
         if);
         
         (if intel then
             (if table[16+IntelValue*4] = 0 then
                 pop index;
                 goto insert
             if);
             stack[20{16+4}] -> address;
             (if table[16+IntelValue*4] = address then 
                 pop index; 
                 pop RegThis, DataReg1, AddrReg1;
                 {(if debug then call Ck if);}
                 return 4; 
             if);
          else
             (if table[16+value*4] = 0 then
                 pop index;
                 goto insert;
             if);
             stack[8{4+4}] -> address;
             (if address = table[16+value*4] then 
                 pop index; 
                 {(if debug then call Ck if);}
                 return 4; 
             if);
         if);
         
         goto loop
     if);
     pop index;
     
     { Since the hash table is pretty full let's extend the table size       }
     { and rehash the entries.                                               }
     (if intel then
         (if linux then (code '	pushal' code) if);
         (if nti   then (code '	pushad' code) if);
      else
         push RegThis, RegCall, DataRegA; { Save registers before entering c-world }
     if);
     call AOAtoIOAReAlloc;
     (if intel then
         (if linux then (code '	popal' code) if);
         (if nti   then (code '	popad' code) if);
      else
         pop  DataRegA, RegCall, RegThis;
     if);
     goto again;
     
     insert:
     (if intel then     
         stack[16] -> address;
         address -> table[16+IntelValue*4];
         pop RegThis, DataReg1, AddrReg1;
      else
         stack[4] -> address;
         address -> table[16+value*4];
     if);
     {(if debug then call Ck if);}
     return 4;
  #)
