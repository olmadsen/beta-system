------- CheckReferenceAssignment: System ----
{ CheckReferenceAssignment is called with an argument on the stack, }
{ which is the address of a cell (the target of the assignment).     }
{ For the current being this address is always inserted in a hash-  }
{ table. This table is used during IOAGc, because it points out the  }
{ roots in AOA, which refer objects in IOA.                          }

lastDangler:       cvar;
AOAtoIOAInsert:    cproc;
negAOArefsINSERT:  cvar;
AOAtoIOAtableSize: cvar;
AOAtoIOAtable:     cvar;

ChkRA: public
  (#
     { Used variables. }
     stack:      StackArea = SP;
     theCell:    Long = DataReg1;  { d7/eax }
     value:      Long = DataReg2;  { d6 } {Not used in Intel version}
     IntelValue: Long = RegThis; { edx } {Only used in Intel version}
     theObj:     DataArea = AddrReg1;
     table:      DataArea = AddrReg1;
     index:      Long     = DataReg3; { Saved and restored. }
  do 
     {
       General stack layout:
       <Intel: RegThis>    Intel: +0
       <Intel: DataReg1>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <return address>    Intel: +12   Default: +0
       <theCell>           Intel: +16   Default: +4
     }
     
     { (if debug then call Ck if); }
     (if debug then 1 -> NumChkRA+ if); 

     (if intel then push AddrReg1, DataReg1, RegThis if);
     
     again:
     
     (if intel then
         stack[16] -> theObj; 
      else
         stack[4] -> theObj; 
     if);
     theObj -> theCell; 
     theObj[0] -> theObj;
     
     (if theObj outside IOA then 
         { Should not go into AOAtoIOATable. Check if
           it should go into negAOArefs table.
         }
         (if theObj >= -101 then goto Exit if);
         (if intel then
             (if lastDangler > theObj then goto Exit if);
          else
             { Stupid HP assembler will not allow comparison of memory and 
               address register.
             }
             theObj -> value;
             (if lastDangler > value then goto Exit if);
         if);
         
         { Put into negAOArefs table }
         { Save registers before entering c-world }
         (if linux then
             (code '	pushal' code);
         if);
         (if nti then
             (code '	pushad' code);
         if);
         
         push theCell;
         negAOArefsINSERT -> AddrReg1;
         call AddrReg1;
         pop theCell;
         
         (if linux then
             (code '	popal' code);
         if);
         (if nti then
             (code '	popad' code);
         if);
         
         Exit:
         (if intel then pop RegThis, DataReg1, AddrReg1 if);
             {(if debug then call Ck if);}
         return 4;
     if);
     
     { Insert in hash table }
     { ALTERNATIVE: Could call AOAtoIOAInsert }
     
     { Compute hash1.                                  }
     { hash1(theCell) = theCell MOD AOAtoIOAtableSize. }
     (if intel then
         clear IntelValue; {Clear MSB in EDX:EAX register pair}
         (if linux then 
             (code '	div	AOAtoIOAtableSize,%eax' code) 
         if);
         (if nti then 
             (code '	div	dword ptr _AOAtoIOAtableSize' code) 
         if);
     if);
     
     { If the table entry is free insert it!.    }
     AOAtoIOAtable -> table;
     (if intel then
         (if table[16+IntelValue*4] = 0 then goto insert if);
      else
         (if table[16+value*4] = 0 then goto insert if);
     if);
     
     { So the hash1 entry is occupied, check if the entry }
     { matches the theCell. In case of match the theCell  }
     { is already inserted, leave the function.           }
     (if intel then
         stack[16] -> theCell;
         (if table[16+IntelValue*4] = theCell then 
             pop RegThis, DataReg1, AddrReg1;
             {(if debug then call Ck if);}
             return 4;
         if);
      else
         stack[4] -> theCell;
         (if theCell = table[16+value*4] then
             {(if debug then call Ck if);}
             return 4 
         if);
     if);
     
     { Compute hash2.                                      }
     { hash2(theCell) = (theCell*16) MOD AOAtoIOAtableSize. }
     (if intel then
         clear IntelValue; {Clear MSB in EDX:EAX register pair}
         (if linux then
             (code '	shl	$4,%eax' code);
             (code '	div	AOAtoIOAtableSize,%eax' code);
         if);
         (if nti then
             (code '	shl	eax,4' code);
             (code '	div	dword ptr _AOAtoIOAtableSize' code);
         if);
     if);
     
     { If the table entry is free, insert it!. }
     (if intel then
         (if table[16+IntelValue*4] = 0 then goto insert if);
      else
         (if table[16+value*4] = 0 then goto insert if);
     if);
     
     { So the hash2 entry is occupied, check if the entry }
     { matches the theCell. In case of match the theCell  }
     { is already inserted, leave the function.           }
     (if intel then
         stack[16] -> theCell;
         (if table[16+IntelValue*4] = theCell then 
             pop RegThis, DataReg1, AddrReg1;
             {(if debug then call Ck if);}
             return 4;
         if);
      else
         stack[4] -> theCell;
         (if theCell = table[16+value*4] then return 4 if);
     if);
     
     { Both the hash1(theCell) and hash2(theCell) entries are }
     { occupied with others theCelles.                        }
     
     { Try to find an entry after hash2(theCell). }
     push index;
     0 -> index;
     loop:
     (if index < 100 then
         1 -> index+; index -> theCell+;
         { value MOD AOAtoIOAtableSize -> value. }
         {******************************************************}
         {*  GROSSLY INEFFICIENT: NO NEED TO USE MODULO HERE!  *}
         {*  THIS REALLY OUGHT TO BE OPTIMIZED - EASY, TOO...  *}
         {******************************************************}
         (if intel then
             clear IntelValue; {Clear MSB in EDX:EAX register pair}
             (if linux then 
                 (code '	div	AOAtoIOAtableSize,%eax' code) 
             if);
             (if nti then 
                 (code '	div	dword ptr _AOAtoIOAtableSize' code) 
             if);
         if);
         
         (if intel then
             (if table[16+IntelValue*4] = 0 then
                 pop index;
                 goto insert
             if);
             stack[20{16+4}] -> theCell;
             (if table[16+IntelValue*4] = theCell then 
                 pop index; 
                 pop RegThis, DataReg1, AddrReg1;
                 {(if debug then call Ck if);}
                 return 4; 
             if);
          else
             (if table[16+value*4] = 0 then
                 pop index;
                 goto insert;
             if);
             stack[8{4+4}] -> theCell;
             (if theCell = table[16+value*4] then 
                 pop index; 
                 {(if debug then call Ck if);}
                 return 4; 
             if);
         if);
         
         goto loop
     if);
     pop index;
     
     { Since the hash table is pretty full let's extend the table size       }
     { and rehash the entries.                                               }
     (if intel then
         (if linux then (code '	pushal' code) if);
         (if nti   then (code '	pushad' code) if);
      else
         push RegThis, RegCall, DataRegA; { Save registers before entering c-world }
     if);
     call AOAtoIOAReAlloc;
     (if intel then
         (if linux then (code '	popal' code) if);
         (if nti   then (code '	popad' code) if);
      else
         pop  DataRegA, RegCall, RegThis;
     if);
     goto again;
     
     insert:
     (if intel then     
         stack[16] -> theCell;
         theCell -> table[16+IntelValue*4];
         pop RegThis, DataReg1, AddrReg1;
      else
         stack[4] -> theCell;
         theCell -> table[16+value*4];
     if);
     {(if debug then call Ck if);}
     return 4;
  #)
