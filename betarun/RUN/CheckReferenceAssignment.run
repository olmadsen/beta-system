------- CheckReferenceAssignment: System ----
{ CheckReferenceAssignment is called with an argument on the stack, }
{ which is the address of a cell (the target of the assignment).     }
{ For the current being this address is always inserted in a hash-  }
{ table. This table is used during IOAGc, because it points out the  }
{ roots in AOA, which refer objects in IOA.                          }

{ Do NOT call Ck in this routine! TheCell points into the middle of }
{ an object }

lastDangler:       cvar;
IOATop:            cvar;
AOAtoIOAInsert:    cproc;
negAOArefsINSERT:  cvar;

ChkRA: public
  (#
     { Used variables. }
     stack:      StackArea = SP;
     theCell:    Long      = DataReg1;  { eax }
     theObj:     DataArea  = AddrReg1;  { ebp }
  do 
     {
       General stack layout:
       <DataReg1>          +0
       <AddrReg1>          +4
       <return address>    +8
       <theCell>           +12
     }
     
     (if debug then 1 -> NumChkRA+ if); 

     push AddrReg1, DataReg1;
     stack[12] -> theCell; 
     theCell[0] -> theObj;
     
     (if theObj>=IOA then
         (if theObj<IOATop then
             { theObj is in IOA }
             goto TableInsert;
         if)
     if);
     
     { theObj is outside IOA and should not go into AOAtoIOATable. }
     { Check if it should go into negAOArefs table.} 
     (if theObj >= -101 then goto Exit if);
     (if lastDangler > theObj then goto Exit if);
     { lastDangler <= theObj < -101 }
     
     LazyInsert:
     { Put into negAOArefs table }
     { Save remaining registers before entering c-world }
     push AddrReg2;
     push RegThis;
     push RegCall;
     push RegAdr;
     push DataReg2;
     { argument }
     push theCell;
     negAOArefsINSERT -> AddrReg1;
     call AddrReg1;
     pop theCell;
     pop DataReg2;
     pop RegAdr;
     pop RegCall;
     pop RegThis;
     pop AddrReg2;
     goto Exit;
     
     TableInsert:
     { theObj is in IOA. Put theCell into AOAtoIOATable }
     { Save remaining registers before entering c-world }
     push AddrReg2;
     push RegThis;
     push RegCall;
     push RegAdr;
     push DataReg2;
     { argument }
     push theCell;
     call AOAtoIOAInsert;
     pop theCell;
     pop DataReg2;
     pop RegAdr;
     pop RegCall;
     pop RegThis;
     pop AddrReg2;
     
     Exit:
     pop DataReg1, AddrReg1;
     return 4;
  #)
