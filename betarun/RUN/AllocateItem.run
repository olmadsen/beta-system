------- AllocateItem: System ----
AlloI: public
  (#
     { Allocate an item. }
     
     { Input variables. }
     protoType: ProtoType = RegArg;
     origin:    Object    = DataReg1; {pReg1 in Intel version}
     
     { Output variable. }
     Argument:  DataArea  = RegArg;
     
     { Used variables. }
     Size:      Word      = DataReg2;
     SavedDR2:  Long      = DataReg2; { needed to save and restore DR2 as long }
     Tmp:       Long      = DataReg1;
     initTab:   CodeArea  = AddrReg1; { index in GC table in prototype }
     Entry:     CodeArea  = AddrReg1;
     Index:     Word      = DataReg3; { saved and restored }
     SavedDR3:  Long      = DataReg3; { needed to save and restore DR3 as long }
     newTop:    DataArea  = AddrReg1;
     theItem:   Item      = AddrReg2;
          
     stack:     StackArea = SP;
     
  do
     (if debug then 1 -> NumAlloI+ if);
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <origin>            Intel: +12   Mac: +0   Default: +0
       <Mac: AddrReg2>                  Mac: +4
       ... 
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     (if MacOS then push AddrReg2 if);
     push origin; { save (and force GC update of) origin }
     (if intel then push AddrReg1, AddrReg2, SavedDR2 if);
     
     again:
     
     0 -> Size!l;
     protoType.Size -> Size;
     IOATop -> theItem;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     1            -> theItem.Age;
     
     { Initialize the body part of the item, according to the genTable. }
          
     initTab -> initTab-; {Stupid MC680x0 assembler!}
     protoType.GCTabel -> initTab!w+;
     protoType -> initTab+;
     
     { initTab is now pointing to the static GCTable. }
     { This table has zero or more elements terminated with a zero word. }
     { Each element looks like: }
     { WORD Offset in the generated object, where this static object begins }
     { WORD Signed distance to enclosing object }
     { LONG Prototype of this static object }
     
     push SavedDR3;
     
     2 -> Index; { relative index in object }
     loop:
     (if Index < Size then
         (if Index = initTab[0]!w then
             2 -> initTab+;
             { Insert the distance to the autonomous object. }
             initTab[0]!w -> Tmp!w;
             extend Tmp;
             Tmp!l -> theItem[4+Index*4];
             2 -> initTab+;
             { Insert the protoType from the initTab. }
             initTab[0]!l -> Tmp!l; Tmp!l -> theItem[Index*4]!l;
             4 -> initTab+;
             2 -> Index+;     
             goto loop
         if);
         0 -> theItem[Index*4]!l;
         1 -> Index+;
         goto loop
     if);
     
     protoType.OrigOff -> Index;
     (if intel then 
         stack[16{12+4}] -> origin;
      else
         stack[4{0+4}] -> origin;
     if);
     origin -> theItem[Index*4];
     
     pop SavedDR3;
     
     protoType.GenPart -> Entry;
     theItem -> Argument;

     (if intel then
         0 -> AddrReg2; {Invalidate GC register}
         push -5; {Protect DataReg2}
         call Entry;
         4 -> stack+; {Discard GC protection}
         pop SavedDR2, AddrReg2, AddrReg1;
         4 -> stack+; {Discard origin}
         return;
      else
         (if MacOS then pop AddrReg2 if);
         pop origin;
         goto Entry;
     if);
     
     GC:
     { The IOA heap is full, so we need a garbage collection.    }
     Size!l -> ReqObjectSize; { Set the requested Object Size.   }
     (if intel then 
         pop SavedDR2, AddrReg2, AddrReg1;
     if);
     call doGC;    { Call the Garbage Collector.               }
     (if intel then
         push AddrReg1, AddrReg2, SavedDR2;
     if);
     goto again;
  #);



AlloH: public {*** Intel warning: Not tested yet! ***}
  (#
     { Like AlloI, but does not set up an origin, and does not 
       call G-entry ("AllocateHeap")
     }
     
     { Input variables. }
     protoType: ProtoType = RegArg;
     origin:    Object    = DataReg1; { currently unused }
                                      { pReg1 in intel version }
     
     { Output variable. }
     Argument:  DataArea  = RegArg;
     
     { Used variables. }
     Size:      Word      = DataReg2;
     SavedDR2:  Long      = DataReg2; { needed to save and restore DR2 as long }
     Tmp:       Long      = DataReg1;
     initTab:   CodeArea  = AddrReg1; { index in GC table in prototype }
     Entry:     CodeArea  = AddrReg1;
     Index:     Word      = DataReg3; { saved and restored }
     SavedDR3:  Long      = DataReg3; { needed to save and restore DR3 as long }
     newTop:    DataArea  = AddrReg1;
     theItem:   Item      = AddrReg2;
     
     stack:     StackArea = SP;
  do
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <Intel: DataReg2>   Intel: +0
       <Intel: AddrReg2>   Intel: +4
       <Intel: AddrReg1>   Intel: +8
       <Mac: AddrReg2>                  Mac: +0
       ... 
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     (if MacOS then push AddrReg2 if);
     { 
       push origin; (* save (and force GC update of) origin *)
     }
     (if intel then push AddrReg1, AddrReg2, SavedDR2 if);
     
     again:
     
     0 -> Size!l;
     protoType.Size -> Size;
     IOATop -> theItem;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     1            -> theItem.Age;
     
     { Initialize the body part of the item, according to the genTable. }
          
     initTab -> initTab-; {Stupid MC680x0 assembler!}
     protoType.GCTabel -> initTab!w+;
     protoType -> initTab+;
     
     { initTab is now pointing to the static GCTable. }
     { This table has zero or more elements terminated with a zero word. }
     { Each element looks like: }
     { WORD Offset in the generated object, where this static object begins }
     { WORD Signed distance to inclosing object }
     { LONG Prototype of this static object }
     
     push SavedDR3;
     
     2 -> Index; { relative index in object }
     loop:
     (if Index < Size then
         (if Index = initTab[0]!w then
             2 -> initTab+;
             { Insert the distance to the autonomous object. }
             initTab[0]!w -> Tmp!w;
             extend Tmp;
             Tmp!l -> theItem[4+Index*4];
             2 -> initTab+;
             { Insert the protoType from the initTab. }
             initTab[0]!l -> Tmp!l; Tmp!l -> theItem[Index*4]!l;
             4 -> initTab+;
             2 -> Index+;     
             goto loop
         if);
         0 -> theItem[Index*4]!l;
         1 -> Index+;
         goto loop
     if);
     
     { 
       protoType.OrigOff -> Index;
       (if intel then 
           stack[16(*12+4*)] -> origin;
        else
           stack[4(*0+4*)] -> origin;
       if);
       origin -> theItem[Index*4];
     }
     
     pop SavedDR3;
     
     { 
       protoType.GenPart -> Entry;
       theItem -> Argument;

       (if intel then
           push -5; (*Protect DataReg2*)
           call Entry;
           4 -> stack+; (*Discard GC protection*)
           pop SavedDR2, AddrReg2, AddrReg1;
           4 -> stack+; (*Discard origin*)
           return;
        else
           (if MacOS then pop AddrReg2 if);
           pop origin;
           goto Entry;
       if);
     }
     theItem -> Argument;
     (if intel then pop SavedDR2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.    }
     Size!l -> ReqObjectSize; { Set the requested Object Size.   }
     (if intel then pop SavedDR2, AddrReg2, AddrReg1 if);
     call doGC;    { Call the Garbage Collector.               }
     (if intel then push AddrReg1, AddrReg2, SavedDR2 if);
     goto again;
  #)
