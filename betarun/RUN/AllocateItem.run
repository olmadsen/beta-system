------- AllocateItem: System ----
AlloI: public
  (#
     { Allocate an item.
       Destroys: RegCall (output), DataReg1.
       May cause GC.
     }
     
     { Input variables. }
     protoType:     ProtoType = RegCall;
     { origin in pReg1 }
     
     { Output variable. }
     Argument:      DataArea  = RegCall;
     
     { Used variables. }
     Size:          Word      = DataReg2;
     Offset:        Word      = DataReg2;
     DataReg2Long:  Long      = DataReg2; 
     Tmp:           Long      = DataReg1;
     initTab:       CodeArea  = AddrReg1; { index in GC table in prototype }
     Entry:         CodeArea  = AddrReg1;
     newTop:        DataArea  = AddrReg1;
     theItem:       Item      = AddrReg2;
          
  do
     (if debug then 1 -> NumAlloI+ if); 
     (if debug then call Ck if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2Long;
     
     IOATop -> theItem;
     0 -> Size!l;
     protoType.Size -> Size;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     { initialize initTab here to increase pentium pairability }
     0 -> initTab!l;
     
     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theItem.GCAttr;
     if);
     
     { Initialize the body part of the item, according to the genTable. }
     { inittab initialized to 0 above }
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     { Better loop:!
L4:	
       testl	0xffff,(%ebp)		u 1
       je	L5			v 1
L4a:   movl	(%ebp),eax		u 2
       movl	(%ebp),ebx		v 2
       sarl	16,eax			u 3
       andl	0xffff,ebx		v 3
       addl	$8,%ebp			u 4
       movl	%eax,4(%esi,%ebx,4)	v 4
       movl	-4(%ebp),%eax		u 5
       test	0xffff,(%ebp)		v 5
       movl	%eax,(%esi,%ebx,4)	u 6
       jne	L4a			v 6
L5:       
     }

     loop:
     0->Offset!l;
     initTab[0]!w -> Offset;
     (if Offset!l<>0 then
         { Insert the distance to the autonomous object. }
         -1 -> Tmp;
         initTab[2]!w -> Tmp!w;
         Tmp!l -> theItem[4+Offset*4];
         { Insert the protoType from the initTab. }
         initTab[4]!l -> Tmp!l; 
         Tmp!l -> theItem[Offset*4]!l;
         8 -> initTab+;
         goto loop
     if);
     
     pReg1 -> Tmp!l;
     0 -> Offset!l;
     protoType.OrigOff -> Offset;
     protoType.GenPart -> Entry; { Must be before theItem -> Argument }
     Tmp!l -> theItem[Offset*4];
     theItem -> Argument;

     (if Entry<>0 then
         clear AddrReg2; {Invalidate GC register}
         push Protect1Tag; {Protect DataReg2}
         call Entry;
         pop RegEax; {Discard Protect1Tag tag (to dummy eax)}
     if);
     
     pop DataReg2Long, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.  }
     Size!l -> ReqObjectSize; { Set the requested Object Size. }
     pop DataReg2Long, AddrReg2, AddrReg1;
     push pReg1; { update origin }
     call doGC;  { Call the Garbage Collector. }
     pop pReg1;
     goto again;
  #);



AlloH: public
  (#
     { Like AlloI, but does not set up an origin, and does not 
       call G-entry ("AllocateHeap")
     }
     
     { Input variables. }
     protoType:     ProtoType = RegCall;
     
     { Output variable. }
     Argument:      DataArea  = RegCall;
     
     { Used variables. }
     Size:          Word      = DataReg2;
     Offset:        Word      = DataReg2;
     DataReg2Long:  Long      = DataReg2; 
     Tmp:           Long      = DataReg1;
     initTab:       CodeArea  = AddrReg1; { index in GC table in prototype }
     Entry:         CodeArea  = AddrReg1;
     newTop:        DataArea  = AddrReg1;
     theItem:       Item      = AddrReg2;
     
  do
     (if debug then call Ck if);
     
     { 
       General stack layout:
       <DataReg2>: +0
       <AddrReg2>: +4
       <AddrReg1>: +8
       ... 
     }
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2Long;
     
     0 -> Size!l;
     protoType.Size -> Size;
     IOATop -> theItem;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     { initialize initTab here to increase pentium pairability }
     0 -> initTab!l;

     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theItem.GCAttr;
     if);
     
     { Initialize the body part of the item, according to the genTable. }
     { initTab initialized to 0 above }
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     loop:
     0 -> Offset!l;
     initTab[0]!w -> Offset;
     (if Offset!l<>0 then
         { Insert the distance to the autonomous object. }
         -1 -> Tmp;
         initTab[2]!w -> Tmp!w;
         Tmp!l -> theItem[4+Offset*4];
         { Insert the protoType from the initTab. }
         initTab[4]!l -> Tmp!l; 
         Tmp!l -> theItem[Offset*4]!l;
         8 -> initTab+;
         goto loop
     if);
     
     theItem -> Argument;
     pop DataReg2Long, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.    }
     Size!l -> ReqObjectSize; { Set the requested Object Size.   }
     pop DataReg2Long, AddrReg2, AddrReg1;
     call doGC;    { Call the Garbage Collector.               }
     goto again;
  #)
