------- AllocateItem: System ----
AlloI: public
  (#
     { Allocate an item.
       Destroys: RegCall (output), DataReg1.
       May cause GC.
     }
     
     { Input variables. }
     protoType:     ProtoType = RegCall;
     { origin in pReg1 }
     
     { Output variable. }
     Argument:      DataArea  = RegCall;
     
     { Used variables. }
     Size:          Word      = DataReg2;
     Offset:        Word      = DataReg2;
     DataReg2Long:  Long      = DataReg2; 
     TmpData:       Long      = DataReg1;
     Entry:         CodeArea  = DataReg1;
     TmpAddr:       Long      = AddrReg1;
     initTab:       CodeArea  = AddrReg1; { index in GC table in prototype }
     newTop:        DataArea  = AddrReg1;
     theItem:       Item      = AddrReg2;
          
  do
     (if debug then 1 -> NumAlloI+ if); 
     (if debug then call Ck if);
     
     { General Stack Layout:
       <DataReg2>
       <AddrReg2>
       <AddrReg1>
     }
     
     (if debug then
         (if do_unconditional_GC then
             { The stuff for do_unconditional_GC has to be
               *before* the again label, since we go to the again
               label after having called garbage collector.
               So we have to ensure that the Size register and the
               stack look the same to this artificial GC.
             }
             { Don't do this before AttBC }
             (if ActiveComponent<>0 then
                 push AddrReg1, AddrReg2, DataReg2Long;
                 0 -> Size!l;
                 protoType.Size -> Size;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2, DataReg2Long;
     
     IOATop -> theItem;
     0 -> Size!l;
     protoType.Size -> Size;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     { initialize initTab here to increase pentium pairability }
     0 -> initTab!l;
     
     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theItem.GCAttr;
     if);
     
     { Initialize the body part of the item, according to the genTable. }
     { inittab initialized to 0 above }
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     (if HandOptimizedAlloI then
         AsmComment 'Optimized loop for partobj init';
         (if linux then
             (code '	testl	$0xffff,(%ebp)		#u 1	' code);
             (code '	je	L5a			#v 1	' code);
             (code 'L4a:					' code);
             (code '	movl	(%ebp),%eax		#u 2	' code);
             (code '	movl	(%ebp),%ebx		#v 2	' code);
             (code '	sarl	$16,%eax		#u 3	' code);
             (code '	andl	$0xffff,%ebx		#v 3	' code);
             (code '	addl	$8,%ebp			#u 4	' code);
             (code '	movl	%eax,4(%esi,%ebx,4)	#v 4	' code);
             (code '	movl	-4(%ebp),%eax		#u 5	' code);
             (code '	testl	$0xffff,(%ebp)		#v 5	' code);
             (code '	movl	%eax,(%esi,%ebx,4)	#u 6	' code);
             (code '	jne	L4a			#v 6	' code);
             (code 'L5a:					' code);
         if);
         (if nti then
             (code '	test	dword ptr [ebp],0ffffh	;u 1	' code);
             (code '    je	L5a			;v 1	' code);
             (code 'L4a:mov	eax,[ebp]		;u 2	' code);
             (code '    mov	ebx,[ebp]		;v 2	' code);
             (code '    sar	eax,16			;u 3	' code);
             (code '    and	ebx,0ffffh		;v 3	' code);
             (code '    add	ebp,8			;u 4	' code);
             (code '    mov	4[esi+4*ebx],eax	;v 4	' code);
             (code '    mov	eax,[ebp-4]		;u 5	' code);
             (code '    test	dword ptr [ebp],0ffffh	;v 5	' code);
             (code '    mov	[esi+4*ebx],eax		;u 6	' code);
             (code '    jne	L4a			;v 6	' code);
             (code 'L5a:					' code);
         if);
      else
         loop:
         0->Offset!l;
         initTab[0]!w -> Offset;
         (if Offset!l<>0 then
             { Insert the distance to the autonomous object. }
             -1 -> TmpData;
             initTab[2]!w -> TmpData!w;
             TmpData!l -> theItem[4+Offset*4];
             { Insert the protoType from the initTab. }
             initTab[4]!l -> TmpData!l; 
             TmpData!l -> theItem[Offset*4]!l;
             8 -> initTab+;
             goto loop
         if);
     if);
     
     { Store Origin }
     pReg1 -> TmpAddr!l;
     0 -> Offset!l;
     protoType.OrigOff -> Offset;
     TmpAddr!l -> theItem[Offset*4];
     protoType.GenPart -> Entry; { Must be before theItem -> Argument }
     theItem -> Argument;

     (if Entry<>0 then
         clear AddrReg2; {Invalidate GC register}
         push Protect1Tag; {Protect DataReg2}
         { Stack:
           <tag1>
           <General Stack Layout>
           - data registers are tagged properly.
         }
         call Entry; { May cause GC }
         pop TmpData!l; {Discard Protect1Tag tag (to dummy DataReg)}
     if);
     
     pop DataReg2Long, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.  }
     Size!l -> ReqObjectSize; { Set the requested Object Size. }
     pop DataReg2Long, AddrReg2, AddrReg1;
     { Stack: as on entry }
     push pReg1; { update origin }
     { Stack:
       <pReg1>
       - data registers are tagged properly.
     }
     call doGC;  { Call the Garbage Collector. }
     pop pReg1;
     goto again;
  #)
