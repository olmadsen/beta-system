------- AllocateItem: System ----
AlloI: public
  (#
     { Allocate an item.
       Destroys: RegCall (output), DataReg1.
       May cause GC.
     }
     
     { Input variables. }
     protoType:     ProtoType = RegCall;
     { origin in pReg1 }
     
     { Output variable. }
     Argument:      DataArea  = RegCall;
     
     { Used variables. }
     Size:          Word      = DataReg2;
     Offset:        Word      = DataReg2;
     DataReg2Long:  Long      = DataReg2; 
     TmpData:       Long      = DataReg1;
     Eax:           CodeArea  = DataReg1;
     Entry:         CodeArea  = DataReg1;
     TmpAddr:       Long      = { AddrReg1 } RegThis;
     initTab:       GCEntry   = { AddrReg1 } RegThis; { index in GC table in prototype }
     newTop:        DataArea  = { AddrReg1 } RegThis;
     theItem:       Item      = AddrReg2;
          
  do
     (if debug then 1 -> NumAlloI+ if); 
     (if debug then call Ck if);
     
     { General Stack Layout:
       <DataReg2>  +8
       <AddrReg2>  +4
       <RegThis>   +0
       <PC>        -4
       It is vital to beta.dump/valhalla that RegThis is pushed as the first
       thing here: Then the stack will contain the necessary (Object, PC) pair.
       This is, of course, only a subject when stack traversal is needed during
       allocation, e.g. when errors occur in G-parts.
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { The stuff for do_unconditional_GC has to be
                   *before* the again label, since we go to the again
                   label after having called garbage collector.
                   So we have to ensure that the Size register and the
                   stack look the same to this artificial GC.
                 }
                 { Don't do this before AttBC }
                 (if ActiveComponent<>0 then
                     push { AddrReg1 } RegThis, AddrReg2, DataReg2Long;
                     0 -> Size!l;
                     protoType.Size -> Size;
                     goto GC;
                 if);
             if);
         if);
     if);
     
     again:
     
     push { AddrReg1 } RegThis, AddrReg2, DataReg2Long;
     
     IOATop -> theItem;
     0 -> Size!l;
     protoType.Size -> Size;
     theItem[Size*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;

     (if linux then
	 { Here we do a prefetch ahead of the current position.  theItem is in }
	 { address register 2.  See page 3-543 (P 583) of the Intel            }
	 { Architecture Software Developer's Manual, Order/PDF number 243191   }
	 { theItem is AddrReg2 is ESI is register 6.  Prefetch0 is a modr/m of }
	 { 1 use 1-byte:  magic byte is disp8-1-esi ie 1-1-6 ie 01-001-110 ie  }
	 { 0x4e                                                                }
	 { On an Athlon 550 this gives just over 10% improvement, as           }
	 { processors increase in speed I expect the advantage to increase     }
	 { Todo:  This should be done on Windows too.  You need to make sure   }
	 { the fixup code in initialize.c is also done for Windows.            }
	 { -EC                                                                 }

	 (code 'AlloIPrefetch:                                   ' code);
	 (code '.globl AlloIPrefetch                             ' code);
	 (code '    .byte 0x0f           # two-byte opcode prefix ' code);
	 (code '    .byte 0x18           # prefetch0 96(%esi)     ' code);
	 (code '    .byte 0x4e                                    ' code);
	 (code '    .byte 96                                      ' code);
	 (code '    .byte 0x0f           # two-byte opcode prefix ' code);
	 (code '    .byte 0x18           # prefetch2 1024(%esi)   ' code);
	 (code '    .byte 0x9e                                    ' code);
	 (code '    .byte 0                                       ' code);
	 (code '    .byte 4                                       ' code);
	 (code '    .byte 0                                       ' code);
	 (code '    .byte 0                                       ' code);
	 (code 'AlloIPrefetchEnd:                                 ' code);
	 (code '.globl AlloIPrefetchEnd                           ' code);
     if);

     { The new Object is now allocated, but not initialized yet!}
     { initialize initTab here to increase pentium pairability }
     0 -> initTab!l;
     
     { Initialize the structual part; prototype and age. }
     protoType    -> theItem.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theItem.GCAttr;
     if);
     
     { Initialize the body part of the item, according to the genTable. }
     { inittab initialized to 0 above }
     protoType.GCTabel!w -> initTab!w;
     protoType -> initTab!l+;
     
     { initTab is now pointing to the static GCTable. 
       This table has zero or more elements terminated with a zero word. 
       Each element looks like: 
       
       WORD Offset in the generated object, where this static object begins 
       WORD Signed distance to enclosing object 
       LONG Prototype of this static object 
     }
     
     (if HandOptimizedAlloI then
         AsmComment 'Optimized loop for partobj init';
         (if gas then
             (code '	testl	$0xffff,(%edx)		#u 1	' code);
             (code '	je	.L5a			#v 1	' code);
             (code '.L4a:					' code);
             (code '	movl	(%edx),%eax		#u 2	' code);
             (code '	movl	(%edx),%ebx		#v 2	' code);
             (code '	sarl	$16,%eax		#u 3	' code);
             (code '	andl	$0xffff,%ebx		#v 3	' code);
             (code '	addl	$8,%edx			#u 4	' code);
             (code '	movl	%eax,4(%esi,%ebx,4)	#v 4	' code);
             (code '	movl	-4(%edx),%eax		#u 5	' code);
             (code '	testl	$0xffff,(%edx)		#v 5	' code);
             (if COM then
                 (code'	leal	DISP_OFF(%eax),%eax     #u 6 SETPROTO' code);
                 (code'	nop				#v 6	' code);
             if);
             (code '	movl	%eax,(%esi,%ebx,4)	#u 6/7	' code);
             (code '	jne	.L4a			#v 6/7	' code);
             (code '.L5a:					' code);
         if);
         (if nti then
             (code '	test	dword ptr [edx],0ffffh	;u 1	' code);
             (code '    je	L5a			;v 1	' code);
             (code 'L4a:mov	eax,[edx]		;u 2	' code);
             (code '    mov	ebx,[edx]		;v 2	' code);
             (code '    sar	eax,16			;u 3	' code);
             (code '    and	ebx,0ffffh		;v 3	' code);
             (code '    add	edx,8			;u 4	' code);
             (code '    mov	4[esi+4*ebx],eax	;v 4	' code);
             (code '    mov	eax,[edx-4]		;u 5	' code);
             (code '    test	dword ptr [edx],0ffffh	;v 5	' code);
             (if COM then
                 (code'	lea	eax,DISP_OFF[eax]       ;u 6 SETPROTO' code);
                 (code'	nop				;v 6	' code);
             if);
             (code '    mov	[esi+4*ebx],eax		;u 6/7	' code);
             (code '    jne	L4a			;v 6/7	' code);
             (code 'L5a:					' code);
         if);
      else
         loop:
         0->Offset!l;
         initTab.StaticOff -> Offset;
         (if Offset!l<>0 then
             { Insert the distance to the autonomous object. }
             -1 -> TmpData;
             initTab.OrigOff -> TmpData!w;
             TmpData!l -> theItem[4+Offset*4];
             { Insert the protoType from the initTab. }
             initTab.Proto -> TmpData!l; 
             (if COM then
                 DISP_OFF -> TmpData+; { SETPROTO }
             if);
             TmpData!l -> theItem[Offset*4]!l;
             8 -> initTab+;
             goto loop
         if);
     if);
     
     { Store Origin }
     pReg1 -> TmpAddr!l;
     0 -> Offset!l;
     protoType.OrigOff -> Offset;
     TmpAddr!l -> theItem[Offset*4];
     protoType.GenPart -> Entry; { Must be before theItem -> Argument }
     theItem -> Argument;

     (if Entry<>0 then
         clear AddrReg2; {Invalidate GC register}
         push Protect1Tag; {Protect DataReg2}
         { Stack:
           <tag1>
           <General Stack Layout>
           - data registers are tagged properly.
         }
         call Entry; { May cause GC }
         pop TmpData!l; {Discard Protect1Tag tag (to dummy DataReg)}
     if);
     
     pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
     (if alloc_trace then call RunTraceAlloc if);
     (if debug then call Ck if);
     return;

     { This marks the lower end of the code that is moved up when we          }
     { are removing prefetch instructions (for processors that don't          }
     { support them.  We can't move the GC label because the relative         }
     { branches above would miss.  If you add gotos to the GC label you       }
     { may want to switch to use JMP instead of block copy - see initialise.c }

     (if linux then
	 (code 'AlloIEnd:                                 ' code);
	 (code '.globl AlloIEnd                           ' code);
     if);

     GC:
     { The IOA heap is full, so we need a garbage collection.  }
     Size!l -> ReqObjectSize; { Set the requested Object Size. }
     pop DataReg2Long, AddrReg2, { AddrReg1 } RegThis;
     { Stack: as on entry }
     push pReg1; { update origin }
     { Stack:
       <pReg1>
       - data registers are tagged properly.
     }
     call doGC;  { Call the Garbage Collector. }
     pop pReg1;
     goto again;
     
#)
