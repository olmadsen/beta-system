------- AllocateRefRep: System ----
AlloRR: public
  (#
     { Allocate a reference repetition. }
     
     { Input variable.  }
     theObj: Item  = RegObj;   { The object, which refer the refrep.}
     Offset: Long  = DataReg1; { Offset in the theObj.              }
                               {DataRegA in non-Intel versions}
     Range:  Long  = DataReg2; { The range of the refRep.           }
                               {DataRegB in non-Intel versions}
     stack: StackArea = SP;
     
     { Used variables. }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = RegArg;
  do
     { 
       General stack layout:
       <Intel: AddrReg1>
       ... 
     }
     
     (if debug then 1 -> NumAlloRR+ if); 
     (if debug then call Ck if);

     
     {*** TO BE REMOVED ***}
     (if intel then ; else DataRegA -> DataReg1; DataRegB -> DataReg2; if);
     
     again:
     
     (if intel then push AddrReg1 if);
     
     (if Range < 0 then 0 -> Range if); { OBS: low>high confuses chk2 }
     IOATop -> theRep;
     theRep[16+Range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -4    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     1 -> Range-;
     loop:
     0 -> theRep[16+Range*4];
     1 -> Range-;
     (if FLAGS >= 0 then goto loop if);
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         (if hp then
             theCell -> theCell-; { clear AddrReg1 before ChkRA }
          else
             0 -> theCell; { clear AddrReg1 before ChkRA }
         if);         
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop AddrReg1 if);
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     Range -> ReqObjectSize+;
     (if intel then pop AddrReg1 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)

