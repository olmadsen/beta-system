[[------- ntiadditions: System ----

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
(#
  stackPointer: StackArea = SP;
  theVector:    StackArea = AddrReg1
do
   push AddrReg1;
   stackPointer[12]  -> ArgCount;
   stackPointer[16] -> theVector;
   theVector -> ArgVector;
   pop AddrReg1;
   return
#);

{ Routine called from betaenvbody in case of detected failure. }
FailureExit: public = '_FailureExit'
(#
  { Called from betaenvbody: (FailureTrace,'') -> Stop }
  CurrentObject: Object = RegThis
do
  push CurrentObject;
  push StopCalledErr;
  call BetaError;
#);

DumpStack: public = '_DumpStack'
(#
  { Called from betaenvbody: (FailureTrace,'') -> Stop }
  CurrentObject: Object = RegThis
do
  push CurrentObject;
  push DumpStackErr;
  call BetaError;
  pop CurrentObject; pop CurrentObject;   { must remove pushed values, to be able to continue (ie. find return addr)}
  return;
#);

Ret: public = '_Return' (# do return #)

---- CallbackAdditions: system ----
CopyPPP: public
  (#
     { Used variables. }
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     stack: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2;
     tmpCalc: DataArea = DataReg1;
     SavedDR1: long = DataReg1;
  do
     {
       Stack layout:
       <AddrReg2>               +0
       <AddrReg1>               +4
       <DataReg1>               +8
       <return address>         +12
       <256+entersize+exitsize> +16
       <struct>                 +20
     }
          
     push SavedDR1, AddrReg1, AddrReg2;
     
     again:
     
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one.
           Not yet implemented: No one are ever freed 
         }
         PushAll;
         call CBFArelloc;
         PopAll;
         goto again;
     if);
     
     newTop -> CBFATop;
     
     stack[20] -> theCBStruct[0];
     232 -> theCBStruct[4]!b;  {Write "call" opcode: 0xe8}
     HandleCB[] -> theRoutine; 
     theCBStruct[9][] -> tmpCalc; 
     tmpCalc -> theRoutine-;
     theRoutine -> theCBStruct[5]; {Write call argument: relative offset to HandleCB[]}
     194 -> theCBStruct[9]!b; { Write "ret xxx" opcode: 0xc2 }
     0 -> theCBStruct[11]!b; { Write high byte of size-word }
     stack[17]!b -> tmpCalc!b;
     tmpCalc!b -> theCBStruct[10]!b; { complete size-word }
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stack[20];
     
     pop AddrReg2, AddrReg1, SavedDR1;
     {(code '	invd' code);} {Flush cache -- i486 only}
     return 4;
  #);

CopySPP: public
  (#
     { Used variables. }
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     stack: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2;
     tmpCalc: DataArea = DataReg1;
     SavedDR1: long = DataReg1;
  do
     {
       Stack layout:
       <AddrReg2>               +0
       <AddrReg1>               +4
       <DataReg1>               +8
       <return address>         +12
       <256+entersize+exitsize> +16
       <struct>                 +20
     }
          
     push SavedDR1, AddrReg1, AddrReg2;
     
     again:
     
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one.
           Not yet implemented: No one are ever freed 
         }
         PushAll;
         call CBFArelloc;
         PopAll;
         goto again;
     if);
     
     newTop -> CBFATop;
     
     stack[20] -> theCBStruct[0];
     232 -> theCBStruct[4]!b;  {Write "call" opcode: 0xe8}
     HandleCB[] -> theRoutine; 
     theCBStruct[9][] -> tmpCalc; 
     tmpCalc -> theRoutine-;
     theRoutine -> theCBStruct[5]; {Write call argument: relative offset to HandleCB[]}
     194 -> theCBStruct[9]!b; { Write "ret xxx" opcode: 0xc2 }
     0 -> theCBStruct[11]!b; { Write high byte of size-word }
     stack[17]!b -> tmpCalc!b;
     tmpCalc!b -> theCBStruct[10]!b; { complete size-word }
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stack[20];
     
     pop AddrReg2, AddrReg1, SavedDR1;
     {(code '	invd' code);} {Flush cache -- i486 only}
     return 4;
  #);

{ Used by valhalla DYN object evaluation (callback from betarun) }
_HandleCB: public
  (#
  do goto HandleCB;
  #);
_VAlloS: public
  (#
  do goto VAlloS;
  #);

_AttBC: proc;
beta_main: cproc;

AttBC: public
  (#
     { Input variable. }
     theComp: Component = RegCall;
  do
         push theComp;
         (code '	push	OFFSET FLAT:_AttBC' code);
         { beta_main will install exception handler for nti, and then }
         { call _AttBC(theComp) }
         call beta_main;
         return;
  #)

----]]
