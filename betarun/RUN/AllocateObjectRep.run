------- AllocateObjectRep: System ----

{ Parameters:
                     generelt        sparc  Snake   Ix86   MC68          
					                 		   
     object          this            %i0    %r3     %edx   %a0 RegThis     
     offset in this  primReg1        %l0    %r9     %eax   %d0 DataRegA  
     range           primReg2        %l1    %r10    %ebx   %d1 DataRegB  
     prototype       callReg         %i1    %r4     %edi   %a1 RegCall    
     origin          originReg       %o0    %r26    pReg1  %d7 DataReg1  
}

AlloVRI: public
  (#
     { AllocateObjectRepetitionReference: Allocate repetition of offline items.
       Destroys: RegCall, DataReg1, DataReg2, AddrReg1, AddrReg2.
       May cause GC.
     }
     
     { Input variable.  }
     theObj: Item      = RegThis;   { The object, which refer the objrep }
     Offset: Long      = DataRegA; { Offset in the theObj.              
                                     Same phys reg as DataReg1 on intel.
                                   }
     Range:  Long      = DataRegB; { The range of the refRep.           }
     Proto:  ProtoType = RegCall;   { The Prototype for the elements     }
     Origin: Item      = DataReg1; { The Origin for the elements.
                                     pReg1 in Intel version
                                   }
     { Used variables. }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: ObjectRepetition = AddrReg2;

  do
     { 
       General stack layout:
       <Intel: tag>        <Mac: tag>        <default: tag>
       <Intel: Offset>     <Mac: offset>     <default: offset>
       <Intel: AddrReg1>   <Mac: AddrReg2> 
       <Intel: AddrReg2>
       
       ... 
     }     
     (if debug then call Ck; if);
     (if debug then 1 -> NumAlloVRI+ if); 
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then 
         push AddrReg2, AddrReg1;
         push Offset;
         pReg1 -> DataReg1;
      else
         push Offset;
     if);
     push -5; { tag }

     (if Range < 0 then 0 -> Range if); { OBS: low>high confuses chk2 }
     IOATop -> theRep;
     
     theRep[24+Range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated in IOA, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -10    -> theRep.ProtoType; { DynItemRepPTValue }
     1      -> theRep.Age;
     1      -> theRep.LowBorder;
     Range  -> theRep.HighBorder;
     Proto  -> theRep.iProto;
     Origin -> theRep.iOrigin; { ChkRA not needed: theRep is in IOA }
     
     { Initialize the body part of the repetition. }
     1 -> Range-;
     loop:
     push Origin; { save DataReg1 across AlloI call }
     push Proto;  { save RegCall across AlloI call }
     push Range;  { save DataRegB/DataReg2 across AlloI call } 
     push -6;     { tag }
     { intel: no need to save _preg1 during AlloI }
     push theRep; { save AddrReg2 across AlloI call }
     
     { STACK:
       <theRep>
       <tag>
       <Range>
       <Proto>
       <Origin>
       <tag>
       <Offset>
       <general stack layout>
     }
     
     { Allocate item }
     { Origin and Proto are already in the right registers for AlloI }
     call AlloI; { Destroys: RegCall (output), DataReg1, DataReg2, AddrReg1, AddrReg2. 
                   On intel DataReg1 is DataRegA, and DataReg2 is DataRegB.
                 }
     { AlloI returns item in RegCall }
     
     { theRep may now have been moved to AOA }
     
     { AssignReference }
     pop theRep; { restore AddrReg2 }
     4 -> SP+; { pop tag };
     pop Range;
     theRep[24+Range*4][] -> theCell;
     RegCall -> theCell[0];
     (if theCell outside IOA then  { theCell resides in AOA and the item in IOA  }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     pop Proto;   { restore Proto before next AlloI in loop }
     (if hp then
         theCell -> theCell-; { clear AddrReg1 before next AlloI in loop }
      else
         0 -> theCell; { clear AddrReg1 before next AlloI in loop }
     if);         
     pop Origin;
     1 -> Range-;
     (if FLAGS >= 0 then goto loop if);
     
     { STACK:
       <tag>
       <Offset>
       <general stack layout>
     }
     
     { AssignReference }
     4 -> SP+; { pop tag }
     pop Offset;
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     (if theCell outside IOA then  { theCell resides in AOA and theRep in IOA or AOA }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { Finished }
     (if intel then pop AddrReg1, AddrReg2 if);
     (if MacOS then pop AddrReg2 if);
     
     (if debug then call Ck; if);

     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     Range -> ReqObjectSize+;
     4 -> SP+; { pop tag }
     pop Offset;
     (if intel then pop AddrReg1, AddrReg2 if);
     (if MacOS then pop AddrReg2 if);
     push Origin;   { Reference in DataReg needs to be updated during GC }
     call doGC;     { Call the Garbage Collector.               }
     pop Origin;
     goto again     { Go back to the beginning of this routine. }
  #);

AlloVRC: public
  (#
     { AllocateObjectRepetitionReferenceComponent: 
       Allocate repetition of offline components.
       Destroys: RegCall (output), DataReg1, DataReg2, AddrReg1, AddrReg2.
       May cause GC.
     }
     
     { Input variable.  }
     theObj: Item      = RegThis;   { The object, which refer the objrep }
     Offset: Long      = DataRegA; { Offset in the theObj.              
                                     Same phys reg as DataReg1 on intel.
                                   }
     Range:  Long      = DataRegB; { The range of the refRep.           }
     Proto:  ProtoType = RegCall;   { The Prototype for the elements     }
     Origin: Item      = DataReg1; { The Origin for the elements.
                                     pReg1 in Intel version
                                   }
     { Used variables. }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: ObjectRepetition = AddrReg2;

  do
     { 
       General stack layout:
       <Intel: tag>        <Mac: tag>        <default: tag>
       <Intel: Offset>     <Mac: offset>     <default: offset>
       <Intel: AddrReg1>   <Mac: AddrReg2> 
       <Intel: AddrReg2>
       
       ... 
     }
     
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloVRC+ if); 
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then 
         push AddrReg2, AddrReg1;
         push Offset;
         pReg1 -> DataReg1;
      else
         push Offset;
     if);
     push -5; { tag }
     
     (if Range < 0 then 0 -> Range if); { OBS: low>high confuses chk2 }
     IOATop -> theRep;
     
     theRep[24+Range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
          
     { The new Object is now allocated in IOA, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -11    -> theRep.ProtoType; { DynCompRepPTValue }
     1      -> theRep.Age;
     1      -> theRep.LowBorder;
     Range  -> theRep.HighBorder;
     Proto  -> theRep.iProto;
     Origin -> theRep.iOrigin; { ChkRA not needed: theRep is in IOA }
     
     { Initialize the body part of the repetition. }
     1 -> Range-;
     loop:
     push Origin; { save DataReg1 across AlloC call }
     push Proto;  { save RegCall across AlloC call }
     push Range;  { save DataRegB/DataReg2 across AlloC call } 
     push -6;     { tag }
     { intel: no need to save _preg1 during AlloC }
     push theRep; { save AddrReg2 across AlloC call }
     
     { STACK:
       <theRep>
       <tag>
       <Range>
       <Proto>
       <Origin>
       <tag>
       <Offset>
       <general stack layout>
     } 
     
     { Allocate item }
     { Origin and Proto are already in the right registers for AlloC }
     call AlloC; { Destroys: RegCall (output), DataReg1, DataReg2, AddrReg1, AddrReg2. 
                   On intel DataReg1 is DataRegA, and DataReg2 is DataRegB.
                 }
     { AlloC returns item in RegCall }
     
     { theRep may now have been moved to AOA }
     
     { AssignReference }
     pop theRep; { restore AddrReg2 }
     4 -> SP+; { pop tag };
     pop Range;
     theRep[24+Range*4][] -> theCell;
     RegCall -> theCell[0];
     (if theCell outside IOA then  { The theCell resides in AOA and the item in IOA  }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     pop Proto;   { restore Proto before next AlloI in loop }
     (if hp then
         theCell -> theCell-; { clear AddrReg1 before next AlloI in loop }
      else
         0 -> theCell; { clear AddrReg1 before next AlloI in loop }
     if);
     pop Origin;
     1 -> Range-;
     (if FLAGS >= 0 then goto loop if);
     
     { STACK:
       <tag>
       <Offset>
       <general stack layout>
     }
     
     { AssignReference }
     4 -> SP+; { pop tag }
     pop Offset;
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     (if theCell outside IOA then  { The theCell resides in AOA and theRep in IOA }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     { Finished }
     (if intel then pop AddrReg1, AddrReg2 if);
     (if MacOS then pop AddrReg2 if);

     (if debug then call Ck; if);

     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     6 -> ReqObjectSize;     { Set the requested Object Size.            }
     Range -> ReqObjectSize+;
     4 -> SP+; { pop tag }
     pop Offset;
     (if intel then pop AddrReg1, AddrReg2 if);
     (if MacOS then pop AddrReg2 if);
     push Origin;   { Reference in DataReg needs to be updated during GC }
     call doGC;     { Call the Garbage Collector.               }
     pop Origin;
     goto again     { Go back to the beginning of this routine. }
  #)
