------- AllocateDopartObject: System ----
AlloDO: public
  (#
     { Allocate a DopartObject. }
     
     { Input variables. }
     Size:      Long          = DataReg1; { The Size of the body part in BYTES }
                                          {pReg1 in Intel version}
     ArgOrigin: Object        = RegThis;   { Origin for new object }
     
     { Output variable. }
     theObj:    DopartObject  = RegThis;   { New object }
     
     { Used variables.  }
     newTop:    DataArea      = AddrReg1;
     Origin:    Object        = AddrReg2;
     tmp:       DataArea      = DataReg2;
  do
     { 
       General stack layout:
       <AddrReg2>
       <AddrReg1>
       ... 
     }
     
     (if debug then 1 -> NumAlloDO+ if); 
     (if debug then call Ck if);
     
     pReg1 -> DataReg1;
     
     again:
     push AddrReg1, AddrReg2, DataReg2;
     ArgOrigin -> Origin;
     IOATop -> newTop;
     newTop -> tmp;
     newTop[16+Size][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     tmp -> theObj;
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the DopartObject. }
     
     DopartObjectPTValue -> theObj.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theObj.GCAttr;
     if);
     Origin -> theObj.Origin;
     Size   -> theObj.Size;
     
     { The DopartObject is not zeroed. }
     
     pop DataReg2, AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection. }
     Size -> tmp; { Set the requested Object Size.         }
     4 -> tmp/;
     4 -> tmp+;
     tmp -> ReqObjectSize;
     pop DataReg2, AddrReg2, AddrReg1;
     call doGC;               { Call the Garbage Collector.               }
     goto again;              { Go back to the beginning of this routine. }
  #)
