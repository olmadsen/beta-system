------- AllocateDopartObject: System ----
AlloDO: public
  (#
     { Allocate a DopartObject. }
     
     { Input variables. }
     Size:      Long          = DataReg1;     { The Size of the body part in BYTES }
     ArgOrigin: Object        = RegObj;       { Origin for new object }
     
     { Output variable. }
     theObj:    DopartObject  = RegObj;       { New object }
     
     { Used variables.  }
     newTop:    DataArea      = AddrReg1;
     Origin:    Object        = AddrReg2;
     tmp:       DataArea      = DataReg2;
  do
     (if linux then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2, DataReg2 if);
     
     ArgOrigin -> Origin;
     
     IOATop -> newTop;
     newTop -> tmp;
     newTop[16+Size][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     tmp -> theObj;
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the DopartObject. }
     
     -9     -> theObj.ProtoType;
     1      -> theObj.Age;
     Origin -> theObj.Origin;
     Size   -> theObj.Size;
     
     { The DopartObject is not zeroed. }
     
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection. }
     Size -> tmp; { Set the requested Object Size.         }
     4 -> tmp/;
     4 -> tmp+;
     tmp -> ReqObjectSize;
     (if MacOS then pop AddrReg2 if);
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     call DoGC;               { Call the Garbage Collector.               }
     goto again;              { Go back to the beginning of this routine. }
  #)
