------- Structures: System ----
AlloS: public
  (#
     { Allocate a StructObject. }
     
     { Input variables. }
     origin: Object    = DataReg1; { pReg1 }
     proto:  ProtoType = RegCall;
     
     { Output variable. }
     theStruct: Structure = RegCall;
     
     { Used variables. }
     newStruct: Structure = AddrReg2;
     newTop: DataArea     = AddrReg1
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloS+ if); 
     
     { General Stack Layout:
       <AddrReg2>
       <AddrReg1>
     }
     
     pReg1 -> DataReg1 ;
     
     (if do_unconditional_GC then
	 (if DoUGC<>0 then
	     { See general comment in AllocateItem.run }
	     push AddrReg1, AddrReg2 ;
	     goto GC;
	 if);
     if);
     
     again:
     
     push AddrReg1, AddrReg2 ;
     
     IOATop -> newStruct;
     newStruct[16][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 37 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     StructurePTValue -> newStruct.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newStruct.GCAttr;
     if);
     origin  -> newStruct.iOrigin;
     proto   -> newStruct.iProto;
     
     newStruct -> theStruct;
     
     pop AddrReg2, AddrReg1 ;
     
     (if debug then call Ck if);
     return;
     
     GC:
     pop AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     push origin;             { save (and force GC update of) origin }
     { Stack:
       <origin>
       <General Stack Layout>
       - data registers are tagged properly.
     }
     call doGC;               { Call the Garbage Collector.               }
     pop origin;              { restore (updated) origin }
     goto again               { Go back to the beginning of this routine. }
  #);

VAlloS: public
  (#
     { Called from valhalla stub of debuggee (i.e. from C).
       The task is to allocate a structure object in a GC safe
       way.
       Debuggee is typically standing in a signalhandler and
       was thus not "left" in a GC safe way.
       A GC caused by the allocation in here must thus be handled
       specially: This is done via 
     }
     
     { Stack at entry: 
       <return>:        +0
       <proto>          +4
       <SP to GC to>:   +8
       <PC (not used)>: +12
     }
     
     { Output variable. }
     { C call returns result i eax }
     
     { Used variables. }
     stack: StackArea     = SP;
     proto: ProtoType     = RegCall;
     newStruct: Structure = RegEax {=DataReg1};
     newTop: DataArea     = AddrReg1;
     stackend: StackArea  = DataReg2;
  do
     { calling Ck does not give meaning here: registers are undefined from C }
     
     { Save all regs but eax (6) }
     push RegEcx;
     push RegEdx;
     push RegEbx;
     push RegEbp;
     push RegEsi;
     push RegEdi;
     
     stack[28 {4*6+4}] -> proto;
     stack[32 {4*6+8}] -> stackend;
     
     { clear unused GC registers }
     clear RegEbp;
     clear RegEsi;
     clear RegEdx;
     clear RegEcx;
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     IOATop -> newStruct;
     newStruct[16][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 38 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     StructurePTValue -> newStruct.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> newStruct.GCAttr;
     if);
     { newStruct.iOrigin is set up in valhallaComm.c }
     proto   -> newStruct.iProto;
     { Resulting struc object now in RegEax }
     
     { Restore regs except eax for C }
     pop RegEdi;
     pop RegEsi;
     pop RegEbp;
     pop RegEbx;
     pop RegEdx;
     pop RegEcx;
     
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     push 0;        { doGCtoSP arg1: PC }
     push stackend; { doGCtoSP arg0: SP }
     call doGCtoSP;           { Call the Garbage Collector.               }
     8 -> SP+;
     goto again               { Go back to the beginning of this routine. }
  #);

ObjS: public
  (#
     { Allocate a structObject for theObject. }
     
     { Input variable. }
     theObjArg: Long      = DataReg1; {pReg1 in Intel version}
     
     { Output variable. }
     result: Long         = DataReg1; 
     
     { Used variables. }
     theStruct: Structure = AddrReg2;
     theObj:    Object    = AddrReg1;
     newTop:    DataArea  = AddrReg1;
     proto:     ProtoType = RegCall; { saved and restored }
     origin:    Object    = AddrReg1;
     Index:     Word      = DataReg1;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumObjS+ if); 
     
     pReg1 -> DataReg1 ;
     
     { General Stack Layout:
       <AddrReg2>
       <AddrReg1>
     }
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push AddrReg1, AddrReg2 ;
                 goto GC;
             if);
         if);
     if);

     again:
     
     push AddrReg1, AddrReg2 ;
     
     IOATop -> theStruct;
     theStruct[16][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 39 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { Initialize the structual part of the StrucObject. }
     
     StructurePTValue -> theStruct.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theStruct.GCAttr;
     if);
     
     push RegCall; { save RegCall }
     
     theObjArg        -> theObj;
     theObj.ProtoType -> proto;
     proto            -> theStruct.iProto;
     
     0 -> Index!l;
     proto.OrigOff    -> Index;
     theObj[Index*4]  -> origin; { destroys theObj }

     origin           -> theStruct.iOrigin;
     
     theStruct -> result;
     
     pop RegCall; { restore RegCall }
     
     pop AddrReg2, AddrReg1 ;
     
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     pop AddrReg2, AddrReg1 ;
     { Stack: as on entry }
     push theObjArg;
     { Stack:
       <theObjArg>
       <General Stack Layout>
       - data registers are tagged properly.
     }
     call doGC;               { Call the Garbage Collector.               }
     pop theObjArg;
     goto again               { Go back to the beginning of this routine. }
  #);


AlloSI: public
  (#
     { Allocate item given struc object }
     
     { Input variable. }
     theStruct: Structure = RegCall;
     
     { Output variable. }
     Implicit:  DataArea  = RegCall;

     { Used variables. }
     proto:     ProtoType = RegCall;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloSI+ if); 
    
     theStruct.iOrigin -> pReg1;
     theStruct.iProto  -> proto;
     (if debug then call Ck if);
     goto AlloI;
  #);



AlloSC: public
  (#
     { Allocate component given struc object }
     
     { Input variable. }
     theStruct: Structure = RegCall;
     
     { Output variable. }
     Implicit:  DataArea  = RegCall;
     
     { Used variables. }
     proto:     ProtoType = RegCall
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloSC+ if); 
     
     theStruct.iOrigin -> pReg1;
     theStruct.iProto  -> proto;
     (if debug then call Ck if);
     goto AlloC;
  #);



gtS: proc;



ltS: proc;



eqS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel version}
     input2: Structure = DataReg2; {pReg2 in Intel version}
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if debug then 1 -> NumeqS+ if); 
     (if debug then call Ck if);
     
     pReg1 -> DataReg1; pReg2 -> DataReg2 ;
     
     push AddrReg1, AddrReg2 ;
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then
         goto failure
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto failure if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     1 -> result;
     pop AddrReg2, AddrReg1 ;
     return;
     
     failure:
     0 -> result;
     pop AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return
  #);



neS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel versions}
     input2: Structure = DataReg2; {pReg2 in Intel versions}
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if debug then 1 -> NumneS+ if); 
     (if debug then call Ck if);
     
     pReg1 -> DataReg1; pReg2 -> DataReg2 ;
     
     push AddrReg1, AddrReg2 ;
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto failure if);
         goto success
     if);
     (if arg2 = 0 then
         goto success
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto success if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     pop AddrReg2, AddrReg1 ;
     0 -> result;
     return;
     
     success:
     pop AddrReg2, AddrReg1 ;
     1 -> result;
     (if debug then call Ck if);
     return
  #);



ltS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel version}
     input2: Structure = DataReg2; {pReg2 in Intel version}

     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     proto1: ProtoType = AddrReg1;
     proto2: ProtoType = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     wordIndex: Word = DataReg2;
     longValue: Long = DataReg2;
     offset2: Word = DataReg1;
     newObject: Object    = RegCall;
     argument:  Structure = RegCall;
     stack:   StackArea = SP;
  do
     { 
       General stack layout:
       <AddrReg2>
       <AddrReg1>
       ... 
     }
     
     (if debug then call Ck if);
     (if debug then 1 -> NumltS+ if); 
     
     pReg1 -> DataReg1; pReg2 -> DataReg2 ;
         
     push AddrReg1, AddrReg2 ;
     
     input1 -> arg1;
     input2 -> arg2;
     push arg1, arg2;
     
     (if arg1 = 0 then goto failure if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> proto1;
     arg2.iProto -> proto2;
     
     (if proto1 = proto2 then goto failure if);

     (if proto2 = proto2.Prefix then goto success if);
     
     { Prefix of proto1 is the first try }
     proto1.Prefix -> proto1;
     loop:
     (if proto1 = proto1.Prefix then goto failure if); { proto1 = Object## }
     (if proto1 = proto2 then
         { Now there is some hope, now we need to check is origin are equal. }
         proto2.OrigOff -> offset2;
         stack[4] -> arg1;
         arg1.iProto -> proto1;
         (if offset2 = proto1.OrigOff then
             { The prototypes have same origin offset, so   }
             { the result is (arg1.iOrigin = arg1.iOrigin). }
             stack[4] -> arg1;
             stack[0] -> arg2;
             arg1.iOrigin -> value1;
             arg2.iOrigin -> value2;
             (if value1 = value2 then goto success if);
             goto failure
         if);
         { If proto1 and proto2 has different Origin Prefix }
         { We need to generate an object fra arg2 an then   }
         { test the resulting origin fra the new object.    }
         stack[4] -> argument;
         clear AddrReg1; clear AddrReg2; {Invalidate GC registers; 
                                           stack OK, though }
         call AlloSI;

         { Return (newObject[offset*4] = arg2.iOrigin) . }
         
         stack[0] -> arg2;
         arg2.iOrigin -> value2;
         arg2.iProto -> proto2;
         0 -> wordIndex!l;
         proto2.OrigOff -> wordIndex;
         
         newObject[wordIndex*4] -> longValue;
         (if value2 = longValue then goto success if);    
         goto failure
     if);
     proto1.Prefix -> proto1;
     goto loop;
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     0 -> result;
     8 -> SP+;
     pop AddrReg2, AddrReg1 ;
     return;
     
     success:
     1 -> result;
     8 -> SP+;
     pop AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     return
  #);



gtS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel version}
     input2: Structure = DataReg2; {pReg2 in Intel version}
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumgtS+ if); 
     
     pReg1 -> DataReg1;
     pReg2 -> DataReg2;
     DataReg1 -> pReg2;
     DataReg2 -> pReg1;
     (if debug then call Ck if);
     goto ltS
  #);



leS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel version}
     input2: Structure = DataReg2; {pReg2 in Intel version}
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumleS+ if); 
     
     pReg1 -> DataReg1; pReg2 -> DataReg2 ;
     
     push AddrReg1, AddrReg2 ;
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1; arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1; arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     pop AddrReg2, AddrReg1 ;
     1 -> result;
     return;
     
     failure:
     pop AddrReg2, AddrReg1 ;
     0 -> result;
     return;
     
     nextTry:
     { Perform a less than test on the two struc. }
     pop AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     goto ltS
  #);



geS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1; {pReg1 in Intel version}
     input2: Structure = DataReg2; {pReg2 in Intel version}

     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumgeS+ if); 
     
     pReg1 -> DataReg1; pReg2 -> DataReg2 ;
     
     push AddrReg1, AddrReg2 ;
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     pop AddrReg2, AddrReg1 ;
     1 -> result;
     return;
     
     failure:
     pop AddrReg2, AddrReg1 ;
     0 -> result;
     return;
     
     nextTry:
     { Perform a greater than test on the two struc. }
     pop AddrReg2, AddrReg1 ;
     (if debug then call Ck if);
     goto gtS
  #)
