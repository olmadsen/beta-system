------- Structures: System ----
AlloS: public
  (#
     { Allocate a StructObject. }
     
     { Input variable. }
     origin: Object    = RegAdr;
     proto:  ProtoType = RegArg;
     
     { Output variable. }
     entryPoint: Long = RegAdr;
     
     { Used variable.  }
     newStruct: Structure = AddrReg2;
     theStruct: Structure = RegArg;
     newTop: DataArea      = AddrReg1
  do
     IOATop -> newStruct;
     newStruct[16][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the StackObject.             }
     
     -3      -> newStruct.ProtoType;
     1       -> newStruct.Age;
     origin  -> newStruct.iOrigin;
     proto   -> newStruct.iProto;
     
     newStruct -> theStruct;
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     call DoGC;               { Call the Garbage Collector.               }
     goto AlloS               { Go back to the beginning of this routine. }
  #);

ThisS: public
  (#
     { Allocate a structObject for thisObject. }
     
     { Output variable.  }
     result: Long   = DataRegA;
     
     { Used variable.  }
     theObj: Object    = RegObj;
     theStruct: Structure = RegArg;
     origin: Object    = RegAdr;
     proto:  ProtoType = RegAdr;
     Index:  Word      = DataReg1;
     newTop: DataArea  = AddrReg1;
     newObj: Object  = AddrReg1
  do
     IOATop -> theStruct;
     theStruct[16][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { Initialize the structual part of the StackObject.             }
     
     -3      -> theStruct.ProtoType;
     1       -> theStruct.Age;
     
     theObj.ProtoType -> proto;
     
     proto.OrigOff -> Index;
     theObj[Index*4] -> newObj;
     newObj.ProtoType -> proto;
     proto.OrigOff -> Index;
     proto   -> theStruct.iProto;
     newObj[Index*4] -> origin;
     origin  -> theStruct.iOrigin;
     
     theStruct -> result;
     
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     call DoGC;               { Call the Garbage Collector.               }
     goto ThisS               { Go back to the beginning of this routine. }
  #);

AlloSI: public
  (#
     { Input variable. }
     theStruct: Structure = RegArg;
     
     { Used variable. }
     origin:    Object    = RegAdr;
     proto:     ProtoType = RegArg
  do
     theStruct.iOrigin -> origin;
     theStruct.iProto  -> proto;
     call AlloI;
     return
  #);

AlloSC: public
  (#
     { Input variable. }
     theStruct: Structure = RegArg;
     
     { Used variable. }
     origin:    Object    = RegAdr;
     proto:     ProtoType = RegArg
  do
     theStruct.iOrigin -> origin;
     theStruct.iProto  -> proto;
     call AlloC;
     return
  #);

gtS: proc;
ltS: proc;

eqS: public
  (#
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     
     result: Long = DataRegA
     
  do
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then
         goto failure
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto failure if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     1 -> result;
     return;
     
     failure:
     0 -> result;
     return
  #);

neS: public
  (#
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     
     result: Long = DataRegA
     
  do
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto failure if);
         goto success
     if);
     (if arg2 = 0 then
         goto success
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto success if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     0 -> result;
     return;
     
     success:
     1 -> result;
     return
  #);
     
ltS: public
  (#
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;

     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     
     proto1: ProtoType = AddrReg1;
     proto2: ProtoType = AddrReg2;
     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     
     wordIndex: Word = DataReg2;
     longValue: Long = DataReg2;
     
     offset1: Word = DataReg1;
     
     newObject: Object    = RegArg;
     argument:  Structure = RegArg;
     
     stack:   StackArea = SP;
     
     result: Long = DataRegA
     
  do
     input1 -> arg1;
     input2 -> arg2;
     push arg1, arg2;
     
     (if arg1 = 0 then goto failure if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> proto1;
     arg2.iProto -> proto2;
     
     (if proto1 = proto2 then goto failure if);

     (if proto2 = proto2.Prefix then goto success if);
     
     { Prefix of proto1 is the first try }
     proto1.Prefix -> proto1;
     loop:
     (if proto1 = proto1.Prefix then goto failure if); { proto1 = Object## }
     (if proto1 = proto2 then
         { Now there is some hope, now we need to check is origin are equal. }
         0 -> offset2;
         proto2.OrigOff -> offset2;
         stack[4] -> arg1;
         arg1.iProto -> proto1;
         (if offset2 = proto1.OrigOff then
             { The prototypes have same origin offset, so   }
             { the result is (arg1.iOrigin = arg1.iOrigin). }
             stack[4] -> arg1;
             stack[0] -> arg2;
             arg1.iOrigin -> value1;
             arg2.iOrigin -> value2;
             (if value1 = value2 then goto success if);
             goto failure
         if);
         { If proto1 and proto2 has different Origin Prefix }
         { We need to generate an object fra arg2 an then   }
         { test the resulting origin fra the new object.    }
         stack[4] -> argument;
         call AlloSI;
         
         { Return (newObject[offset*4] = arg2.iOrigin) . }
         
         stack[0] -> arg2;
         arg2.iOrigin -> value2;
         arg2.iProto -> proto2;
         proto2.OrigOff -> wordIndex;
         
         newObject[wordIndex*4] -> longValue;
         (if value2 = longValue then goto success if);    
         goto failure
     if);
     proto1.Prefix -> proto1;
     goto loop;
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     0 -> result;
     8 -> SP+;
     return;
     
     success:
     1 -> result;
     8 -> SP+;
     return
  #);

gtS: public
  (# 
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     tmp:    Structure = AddrReg1
  do
     input1 -> tmp;
     input2 -> input1;
     tmp -> input2;
     goto ltS
  #);

leS: public
  (#
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;

     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     
     value1: Long = DataReg1;
     value2: Long = DataReg2;

     result: Long = DataRegA
  do
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1; arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1; arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     1 -> result;
     return;
     
     failure:
     0 -> result;
     return;
     
     nextTry:
     { Please perform a less than test on the two struc. }
     arg1 -> input1;
     arg2 -> input2;
     goto ltS
  #);

geS: public
  (#
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;

     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     
     result: Long = DataRegA
  do
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     1 -> result;
     return;
     
     failure:
     0 -> result;
     return;
     
     nextTry:
     { Please perform a greater than test on the two struc. }
     arg1 -> input1;
     arg2 -> input2;
     goto gtS
  #)
