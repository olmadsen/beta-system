------- Structures: System ----
AlloS: public
  (#
     { Allocate a StructObject. }
     
     { Input variables. }
     origin: Object    = DataReg1;
     proto:  ProtoType = RegArg;
     
     { Output variable. }
     theStruct: Structure = RegArg;
     
     { Used variables. }
     newStruct: Structure = AddrReg2;
     newTop: DataArea      = AddrReg1
  do
     (if linux then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     IOATop -> newStruct;
     newStruct[16][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the StackObject.             }
     
     -3      -> newStruct.ProtoType;
     1       -> newStruct.Age;
     origin  -> newStruct.iOrigin;
     proto   -> newStruct.iProto;
     
     newStruct -> theStruct;
     
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     
     return;
     
     GC:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     push origin; { save (and force GC update of) origin }
     call DoGC;               { Call the Garbage Collector.               }
     pop origin;              { restore (updated) origin }
     goto again               { Go back to the beginning of this routine. }
  #);



ThisS: public
  (#
     { Allocate a structObject for thisObject. }
     
     { Output variable. }
     result: Long   = DataReg1;
     
     { Used variables. }
     theStruct: Structure = AddrReg2;
     newTop:    DataArea  = AddrReg1;
     newObj:    Object    = AddrReg1;
     theObj:    Object    = RegObj; { Current Object }
     proto:     ProtoType = RegArg; { saved and restored }
     origin:    Object    = DataReg2;
     Index:     Word      = DataReg1;
  do
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2, DataReg2 if);
     
     IOATop -> theStruct;
     theStruct[16][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { Initialize the structual part of the StrucObject. }
     
     -3      -> theStruct.ProtoType;
     1       -> theStruct.Age;
     
     push RegArg; { save RegArg }
     
     theObj.ProtoType -> proto;
     
     proto.OrigOff    -> Index;
     theObj[Index*4]  -> newObj; { Find origin = THIS }
     newObj.ProtoType -> proto;
     proto            -> theStruct.iProto;
     
     proto.OrigOff    -> Index;
     newObj[Index*4]  -> origin; { Find origin = origin of THIS }
     origin           -> theStruct.iOrigin;
     
     theStruct -> result;
     
     pop RegArg; { restore RegArg }
     
     (if MacOS then pop AddrReg2 if);
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
         
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     (if MacOS then pop AddrReg2 if);
     (if linux then pop DataReg2, AddrReg2, AddrReg1 if);
     call DoGC;               { Call the Garbage Collector.               }
     goto ThisS               { Go back to the beginning of this routine. }
  #);



Struc: public
  (#
     { Allocate a structObject for theObject. }
     
     { Input variable. }
     theObjArg: Long      = DataReg1;
     
     { Output variable. }
     result: Long         = DataReg1;
     
     { Used variables. }
     theStruct: Structure = AddrReg2;
     theObj:    Object    = AddrReg1;
     newTop:    DataArea  = AddrReg1;
     proto:     ProtoType = RegArg; { saved and restored }
     origin:    Object    = AddrReg1;
     Index:     Word      = DataReg1;
  do
     (if linux then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     IOATop -> theStruct;
     theStruct[16][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { Initialize the structual part of the StrucObject. }
     
     -3      -> theStruct.ProtoType;
     1       -> theStruct.Age;
     
     push RegArg; { save RegArg }
     
     theObjArg        -> theObj;
     theObj.ProtoType -> proto;
     proto            -> theStruct.iProto;
     
     proto.OrigOff    -> Index;
     theObj[Index*4]  -> origin; { destroys theObj }

     origin           -> theStruct.iOrigin;
     
     theStruct -> result;
     
     pop RegArg; { restore RegArg }
     
     (if MacOS then pop AddrReg2 if);
     (if linux then pop AddrReg2, AddrReg1 if);
     
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     (if MacOS then pop AddrReg2 if);
     (if linux then pop AddrReg2, AddrReg1 if);
     push theObjArg;
     call DoGC;               { Call the Garbage Collector.               }
     pop theObjArg;
     goto again               { Go back to the beginning of this routine. }
  #);



AlloSI: public
  (#
     { Allocate item given struc object }
     
     { Input variable. }
     theStruct: Structure = RegArg;
     
     { Output variable. }
     Implicit:  DataArea  = RegArg;

     { Used variables. }
     origin:    Object    = DataReg1; { Not used in Linux version }
     proto:     ProtoType = RegArg;
  do
     (if linux then
         theStruct.iOrigin -> pReg1;
      else
         theStruct.iOrigin -> origin;
     if);
     theStruct.iProto  -> proto;
     goto AlloI;
  #);



AlloSC: public
  (#
     { Allocate component given struc object }
     
     { Input variable. }
     theStruct: Structure = RegArg;
     
     { Output variable. }
     Implicit:  DataArea  = RegArg;
     
     { Used variables. }
     origin:    Object    = DataReg1; { Not used in Linux version }
     proto:     ProtoType = RegArg
  do
     (if linux then
         theStruct.iOrigin -> pReg1;
      else
         theStruct.iOrigin -> origin;
     if);
     theStruct.iProto  -> proto;
     goto AlloC;
  #);



gtS: proc;



ltS: proc;



eqS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if linux then pReg1 -> DataReg1; pReg2 -> DataReg2 if);
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then
         goto failure
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto failure if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     1 -> result;
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     return;
     
     failure:
     0 -> result;
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     return
  #);



neS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if linux then pReg1 -> DataReg1; pReg2 -> DataReg2 if);
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto failure if);
         goto success
     if);
     (if arg2 = 0 then
         goto success
     if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto success if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     0 -> result;
     return;
     
     success:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     1 -> result;
     return
  #);



ltS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;

     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     proto1: ProtoType = AddrReg1;
     proto2: ProtoType = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
     wordIndex: Word = DataReg2;
     longValue: Long = DataReg2;
     offset2: Word = DataReg1;
     newObject: Object    = RegArg;
     argument:  Structure = RegArg;
     stack:   StackArea = SP;
  do
     (if linux then pReg1 -> DataReg1; pReg2 -> DataReg2 if);
         
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     input1 -> arg1;
     input2 -> arg2;
     push arg1, arg2;
     
     (if arg1 = 0 then goto failure if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> proto1;
     arg2.iProto -> proto2;
     
     (if proto1 = proto2 then goto failure if);

     (if proto2 = proto2.Prefix then goto success if);
     
     { Prefix of proto1 is the first try }
     proto1.Prefix -> proto1;
     loop:
     (if proto1 = proto1.Prefix then goto failure if); { proto1 = Object## }
     (if proto1 = proto2 then
         { Now there is some hope, now we need to check is origin are equal. }
         0 -> offset2;
         proto2.OrigOff -> offset2;
         stack[4] -> arg1;
         arg1.iProto -> proto1;
         (if offset2 = proto1.OrigOff then
             { The prototypes have same origin offset, so   }
             { the result is (arg1.iOrigin = arg1.iOrigin). }
             stack[4] -> arg1;
             stack[0] -> arg2;
             arg1.iOrigin -> value1;
             arg2.iOrigin -> value2;
             (if value1 = value2 then goto success if);
             goto failure
         if);
         { If proto1 and proto2 has different Origin Prefix }
         { We need to generate an object fra arg2 an then   }
         { test the resulting origin fra the new object.    }
         stack[4] -> argument;
         call AlloSI;

         { Return (newObject[offset*4] = arg2.iOrigin) . }
         
         stack[0] -> arg2;
         arg2.iOrigin -> value2;
         arg2.iProto -> proto2;
         proto2.OrigOff -> wordIndex;
         
         newObject[wordIndex*4] -> longValue;
         (if value2 = longValue then goto success if);    
         goto failure
     if);
     proto1.Prefix -> proto1;
     goto loop;
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto success if);
     
     failure:
     0 -> result;
     8 -> SP+;
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     return;
     
     success:
     1 -> result;
     8 -> SP+;
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     return
  #);



gtS: public
  (# 
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     tmp:    Structure = AddrReg1
  do
     (if linux then push AddrReg1 if);
     pReg1 -> tmp;
     pReg2 -> pReg1;
     tmp -> pReg2;
     (if linux then pop AddrReg1 if);
     goto ltS
  #);



leS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;
     
     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;     
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if linux then pReg1 -> DataReg1; pReg2 -> DataReg2 if);
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1; arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1; arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     1 -> result;
     return;
     
     failure:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     0 -> result;
     return;
     
     nextTry:
     { Please perform a less than test on the two struc. }
     (if linux then 
         ; { No need to restore DataRegs 1&2, since input is taken from pRegs 1&2 }
      else 
         arg1 -> input1;
         arg2 -> input2;
     if);
     (if MacOS then pop AddrReg2 if);
     (if linux then pop AddrReg2, AddrReg1 if);
     goto ltS
  #);



geS: public
  (#
     { Input variables. }
     input1: Structure = DataReg1;
     input2: Structure = DataReg2;

     { Output variable. }
     result: Long = DataReg1;
     
     { Used variables. }
     arg1: Structure = AddrReg1;
     arg2: Structure = AddrReg2;
     value1: Long = DataReg1;
     value2: Long = DataReg2;
  do
     (if linux then pReg1 -> DataReg1; pReg2 -> DataReg2 if);
     
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2 if);
     
     input1 -> arg1;
     input2 -> arg2;
     
     (if arg1 = 0 then
         (if arg2 = 0 then goto success if);
         goto failure
     if);
     (if arg2 = 0 then goto failure if);
     
     arg1.iProto -> value1;
     arg2.iProto -> value2;
     (if value1 <> value2 then goto nextTry if);
     
     arg1.iOrigin -> value1;
     arg2.iOrigin -> value2;
     (if value1 <> value2 then goto failure if);
     
     success:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     1 -> result;
     return;
     
     failure:
     (if linux then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if linux then ; else DataReg1 -> DataRegA if); {*** TO BE REMOVED ***}
     0 -> result;
     return;
     
     nextTry:
     { Please perform a greater than test on the two struc. }
     (if linux then 
         ; { No need to restore DataRegs 1&2, since input is taken from pRegs 1&2 }
      else 
         arg1 -> input1;
         arg2 -> input2;
     if);
     (if MacOS then pop AddrReg2 if);
     (if linux then pop AddrReg2, AddrReg1 if);
     goto gtS
  #)
