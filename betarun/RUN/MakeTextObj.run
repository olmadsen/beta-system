------- MakeTextObj: System ----

MkTO: public
  (#
     { Allocate a Text Object, initialize it with some text and assign it to }
     { the Text reference at position offset in item. }
     { Stack on entry [return(0),offset(4),item(8),asciiz(12),...]  }
     
     { Used variables: }
     stack:   StackArea  = SP;
     theCell: DataArea   = AddrReg1; { 1: item containing textreference to assign to 
                                       2: textobject to assign to
                                       3: address of newly created text object }
     offset:  Long       = DataReg2;  { offset in item }
     range:   Long       = DataReg1;  { The range of the valrep in the new text }
     theRep:  DataArea   = AddrReg2;  { address of repetition after CopyText }
  do
     (if debug then call Ck if);
     
     {
       Stack layout:
       <Intel: DataReg2>   Intel: +0
       <Intel: DataReg1>   Intel: +4
       <Intel: AddrReg2>   Intel: +8
       <Intel: AddrReg1>   Intel: +12
       <Mac: AddrReg2>                  Mac: +0    
       <RegAdr>            Intel: +16   Mac: +4    Default: +0
       <RegArg>            Intel: +20   Mac: +8    Default: +4
       <return address>    Intel: +24   Mac: +12   Default: +8
       <offset>            Intel: +28   Mac: +16   Default: +12
       <item>              Intel: +32   Mac: +20   Default: +16
       <asciiz>            Intel: +36   Mac: +24   Default: +20
     }
     
     push RegArg;
     push RegAdr;
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg1, DataReg2; if);
     
     { find address of betaenv object: saved on stack in AttachBasicComponent }
     (if intel then 
         BasicItem  -> pReg1;    { origin of text constant is the betaenv object }
      else
         BasicItem  -> DataReg1; { origin of text constant is the betaenv object }
     if);
     TextProto -> RegArg; { prototype for Text }
     call AlloI;
     push RegArg; { save address of newly created text object }
     (if intel then
         stack[36{32+4}] -> theCell; { 1: cell containing textreference to assign to }
         stack[32{28+4}] -> offset; { offset in item }
      else
         (if MacOS then
             stack[24{20+4}] -> theCell; { 1: cell containing textreference to assign to }
             stack[20{16+4}] -> offset;	{ offset in item }
          else
             stack[20{16+4}] -> theCell;{ 1: cell containing textreference to assign to }
             stack[16{12+4}] -> offset;	{ offset in item }
         if);
     if);
     theCell[offset*4][] -> theCell; { 2: textobject to assign to }
     RegArg -> theCell[0]; { newly created text object is stored: ref. assignment }
     (if theCell outside IOA then { The theCell resides in AOA. }
         push theCell;	
         call ChkRA { No need to remove parameter. }
     if);
     { prepare for copying of the asciz into the repetition of the text object }
     (if intel then
         push stack[40{36+4}]; { address of asciz }
      else
         (if MacOS then
             push stack[28{24+4}]; { address of asciz }
          else
             push stack[24{20+4}]; { address of asciz }
         if);
     if);
     push RegArg; { address of newly created text object }
     push 3; { long offset of rep. within text obj. 
               TEXT ATTRIBUTE HARDCODED:3. }
     (if intel then
         0 -> AddrReg1; 0 -> AddrReg2; {Invalidate GC registers}
     if);
     call CopyT;
     pop theCell; { 3: address of newly created text object }
     theCell[12] -> theRep; { repetition within text object.
                              TEXT ATTRIBUTE HARDCODED:12. }
     theRep[12] -> range; { range of repetition }
     range -> theCell[16]; { store range in lgth. TEXT ATTRIBUTE HARDCODED:16. }
     range -> theCell[20]; { store range in pos. TEXT ATTRIBUTE HARDCODED:20. }
     
     (if intel then pop DataReg2, DataReg1, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     pop RegAdr;
     pop RegArg;

     return 12
  #)
