------- MakeTextObj: System ----

MkTO: public
  (#
     { Allocate a Text Object, initialize it with some text and assign it to }
     { the Text reference at position offset in item. }
     { Stack on entry [return(0),offset(4),item(8),asciiz(12),...]  }
     
     { Used variables: }
     stack:   StackArea  = SP;
     theCell: DataArea   = AddrReg1; 	{ 1: item containing textreference to assign to 
                                          2: textobject to assign to
                                          3: address of newly created text object }
     offset:  Long       = DataReg2;	{ offset in item }
     range:   Long       = DataReg1;    { The range of the valrep in the new text }
     theRep:  DataArea   = AddrReg2	{ address of repetition after CopyText }
  do
     {
       Stack layout:
       <Linux: DataReg2>   Linux: +0
       <Linux: DataReg1>   Linux: +4
       <Linux: AddrReg2>   Linux: +8
       <Linux: AddrReg1>   Linux: +12
       <Mac: AddrReg2>                  Mac: +0    
       <RegAdr>            Linux: +16   Mac: +4    Default: +0
       <RegArg>            Linux: +20   Mac: +8    Default: +4
       <return address>    Linux: +24   Mac: +12   Default: +8
       <offset>            Linux: +28   Mac: +16   Default: +12
       <item>              Linux: +32   Mac: +20   Default: +16
       <asciiz>            Linux: +36   Mac: +24   Default: +20
     }
     
     push RegArg;
     push RegAdr;
     (if MacOS then push AddrReg2 if);
     (if linux then push AddrReg1, AddrReg2, DataReg1, DataReg2; if);
     
     { find address of betaenv object: saved on stack in AttachBasicComponent }
     (if linux then 
         BasicItem  -> pReg1;		{ origin of text constant is the betaenv object }
      else
         BasicItem  -> DataReg1;	{ origin of text constant is the betaenv object }
     if);
     TextProto -> RegArg;               { prototype for Text }
     call AlloI;
     push RegArg;			{ save address of newly created text object }
     (if linux then
         stack[36{32+4}] -> theCell;	{ 1: cell containing textreference to assign to }
         stack[32{28+4}] -> offset;	{ offset in item }
      else
         (if MacOS then
             stack[24{20+4}] -> theCell;{ 1: cell containing textreference to assign to }
             stack[20{16+4}] -> offset;	{ offset in item }
          else
             stack[20{16+4}] -> theCell;{ 1: cell containing textreference to assign to }
             stack[16{12+4}] -> offset;	{ offset in item }
         if);
     if);
     theCell[offset*4][] -> theCell;	{ 2: textobject to assign to }
     RegArg -> theCell[0];		{ newly created text object is stored: ref. assignment }
     (if theCell outside IOA then       { The theCell resides in AOA. }
         push theCell;	
         call ChkRA                     { No need to remove parameter. }
     if);
     { prepare for copying of the asciz into the repetition of the text object }
     (if linux then
         push stack[40{36+4}];		{ address of asciz }
      else
         (if MacOS then
             push stack[28{24+4}];		{ address of asciz }
          else
             push stack[24{20+4}];		{ address of asciz }
         if);
     if);
     push RegArg;			{ address of newly created text object }
     push 3;				{ long offset of rep. within text obj. 
                                          TEXT ATTRIBUTE HARDCODED:3. }
     call CopyT;
     pop theCell;			{ 3: address of newly created text object }
     theCell[12] -> theRep;		{ repetition within text object.
                                          TEXT ATTRIBUTE HARDCODED:12. }
     theRep[12] -> range;	        { range of repetition }
     range -> theCell[16];		{ store range in lgth. TEXT ATTRIBUTE HARDCODED:16. }
     range -> theCell[20];		{ store range in pos. TEXT ATTRIBUTE HARDCODED:20. }
     
     (if linux then pop DataReg2, DataReg1, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     pop RegAdr;
     pop RegArg;

     return 12
  #)





