------- MakeTextObj: System ----

MkTO: public
  (#
     { Allocate a Text Object, initialize it with some text and assign it to }
     { the Text reference at position offset in item. }
     
     { Used variables: }
     stack:   StackArea  = SP;
     theCell: DataArea   = AddrReg1; { 1: item containing textreference to assign to 
                                       2: textobject to assign to
                                       3: address of newly created text object }
     offset:  Long       = DataReg2;  { offset in item }
     range:   Long       = DataReg1;  { The range of the valrep in the new text }
     theRep:  DataArea   = AddrReg2;  { address of repetition after CopyText }
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumMkTO+ if); 
     
     {
       Stack layout:
       <Intel: AddrReg2>   Intel: +0
       <Intel: AddrReg1>   Intel: +4
       <Intel: -7>         Intel: +8
       <Intel: DataReg2>   Intel: +12
       <Intel: DataReg1>   Intel: +16
       <Mac: AddrReg2>                  Mac: +0    
       <RegAdr>            Intel: +20   Mac: +4    Default: +0
       <RegArg>            Intel: +24   Mac: +8    Default: +4
       <return address>    Intel: +28   Mac: +12   Default: +8
       <offset>            Intel: +32   Mac: +16   Default: +12
       <item>              Intel: +36   Mac: +20   Default: +16
       <asciiz>            Intel: +40   Mac: +24   Default: +20
     }
     
     push RegArg;
     push RegAdr;
     (if MacOS then push AddrReg2 if);
     (if intel then 
         push DataReg1, DataReg2;
         push -7; {GC may be triggered at AlloI and CopyT calls; 
                    protect DataReg2, DataReg1, and RegAdr}
         push AddrReg1, AddrReg2 
     if);
     
     { find address of betaenv object: saved on stack in AttachBasicComponent }
     (if intel then 
         BasicItem  -> pReg1;    { origin of text constant is the betaenv object }
      else
         BasicItem  -> DataReg1; { origin of text constant is the betaenv object }
     if);
     TextProto -> RegArg; { prototype for Text }
     call AlloI;
     push RegArg; { save address of newly created text object }
     (if intel then
         stack[40{36+4}] -> theCell; { 1: cell containing text reference to assign to }
         stack[36{32+4}] -> offset; { offset in item }
      else
         (if MacOS then
             stack[24{20+4}] -> theCell; { 1: cell containing text reference to assign to }
             stack[20{16+4}] -> offset;	{ offset in item }
          else
             stack[20{16+4}] -> theCell;{ 1: cell containing text reference to assign to }
             stack[16{12+4}] -> offset;	{ offset in item }
         if);
     if);
     theCell[offset*4][] -> theCell; { 2: text object to assign to }
     RegArg -> theCell[0]; { newly created text object is stored: ref. assignment }
     (if theCell outside IOA then { The theCell resides in AOA. }
         push theCell;	
         (if hp then
             theCell -> theCell-; { clear AddrReg1 before ChkRA }
          else
             0 -> theCell; { clear AddrReg1 before ChkRA }
         if);         
         call ChkRA { No need to remove parameter. }
     if);
     { prepare for copying of the asciz into the repetition of the text object }
     (if intel then
         push stack[44{40+4}]; { address of asciiz }
      else
         (if MacOS then
             push stack[28{24+4}]; { address of asciiz }
          else
             push stack[24{20+4}]; { address of asciiz }
         if);
     if);
     push RegArg; { address of newly created text object }
     push 3; { long offset of rep. within text obj. 
               TEXT ATTRIBUTE HARDCODED:3. }
     (if intel then
         0 -> AddrReg1; 0 -> AddrReg2; {Invalidate GC registers}
     if);
     call CopyT; { No need to remove parameters }
     pop theCell; { 3: address of newly created text object }
     theCell[12] -> theRep; { repetition within text object.
                              TEXT ATTRIBUTE HARDCODED:12. }
     theRep[12] -> range; { range of repetition }
     range -> theCell[16]; { store range in lgth. TEXT ATTRIBUTE HARDCODED:16. }
     range -> theCell[20]; { store range in pos. TEXT ATTRIBUTE HARDCODED:20. }
     
     (if intel then 
         pop AddrReg2, AddrReg1;
         4 -> stack+; {Discard GC Protection constant}
         pop DataReg2, DataReg1;
     if);
     (if MacOS then pop AddrReg2 if);
     pop RegAdr;
     pop RegArg;

     (if debug then call Ck if);
     return 12
  #)
