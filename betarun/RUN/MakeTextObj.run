------- MakeTextObj: System ----

MkTO: public
  (#
     { Allocate a Text Object, initialize it with some text and assign it to }
     { the Text reference at position offset in item. }
     
     { FIXME: Currently calls AlloI and CopyT. }
     { Should allocate all in one chunk as in NEWRUN/CRUN }
     
     { Used variables: }
     stack:   StackArea  = SP;
     theCell: DataArea   = AddrReg1; { 1: item containing textreference to assign to 
                                       2: textobject to assign to
                                       3: address of newly created text object }
     offset:  Long       = DataReg2;  { offset in item }
     range:   Long       = DataReg1;  { The range of the valrep in the new text }
     theRep:  DataArea   = AddrReg2;  { address of repetition after CopyText }
  do
     (if debug then call Ck if);
     (if debug then 1 -> NumMkTO+ if); 
     
     {
       Stack layout:
       <Intel: AddrReg2>   Intel: +0
       <Intel: AddrReg1>   Intel: +4
       <Intel: Protect3Tag>         Intel: +8
       <Intel: DataReg2>   Intel: +12
       <Intel: DataReg1>   Intel: +16
       <Mac: AddrReg2>                  Mac: +0    
       <RegAdr>            Intel: +20   Mac: +4    Default: +0
       <RegCall>            Intel: +24   Mac: +8    Default: +4
       <return address>    Intel: +28   Mac: +12   Default: +8
       <offset>            Intel: +32   Mac: +16   Default: +12
       <item>              Intel: +36   Mac: +20   Default: +16
       <asciiz>            Intel: +40   Mac: +24   Default: +20
     }
     
     push RegCall;
     push RegAdr;
     push DataReg1, DataReg2;
     push Protect3Tag; {GC may be triggered at AlloI and CopyT calls; 
                         protect DataReg2, DataReg1, and RegAdr}
     push AddrReg1, AddrReg2 
     
     { find address of betaenv object: saved on stack in AttachBasicComponent }
     BasicItem  -> pReg1;    { origin of text constant is the betaenv object }
     TextProto -> RegCall; { prototype for Text }
     call AlloI;
     push RegCall; { save address of newly created text object }
     stack[40{36+4}] -> theCell; { 1: cell containing text reference to assign to }
     stack[36{32+4}] -> offset; { offset in item }
     theCell[offset*4][] -> theCell; { 2: text object to assign to }
     RegCall -> theCell[0]; { newly created text object is stored: ref. assignment }
     (if theCell outside IOA then { The theCell resides in AOA. }
         push theCell;	
         call ChkRA { No need to remove parameter. }
     if);
     { prepare for copying of the asciz into the repetition of the text object }
     push stack[44{40+4}]; { address of asciiz }
     push RegCall; { address of newly created text object }
     push 3; { long offset of rep. within text obj. 
               TEXT ATTRIBUTE HARDCODED:3. }
     clear AddrReg1; clear AddrReg2; {Invalidate GC registers};
     call CopyT; { No need to remove parameters }
     pop theCell; { 3: address of newly created text object }
     theCell[12] -> theRep; { repetition within text object.
                              TEXT ATTRIBUTE HARDCODED:12. }
     theRep[12] -> range; { range of repetition }
     range -> theCell[16]; { store range in lgth. TEXT ATTRIBUTE HARDCODED:16. }
     range -> theCell[20]; { store range in pos. TEXT ATTRIBUTE HARDCODED:20. }
     
     pop AddrReg2, AddrReg1;
     4 -> stack+; {Discard GC Protection constant}
     pop DataReg2, DataReg1;
     pop RegAdr;
     pop RegCall;

     (if debug then call Ck if);
     return 12
  #)
