------- AllocateValRep: System ----

AlloVR1: public
  (#
     { Allocate a byte repetition and assign it to the reference at theObj[offset] }
     
     { Input variable.  }
     theObj: Item     = RegObj;   { The object, which refer the valrep. }
     Offset: Long     = DataRegA; { Offset in the theObj.               }
     Range:  Long     = DataRegB; { The range of the valRep.            }
     
     { Used variable.   }
     BodySize:  Long    = DataReg1; { the number of bytes to allocate     }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg1
  do
     (if Range < 0 then 0 -> Range if);
     (if Range > 200 then 
         push DataRegA, RegObj, RegArg; { save registers }
         push Range; { Parameters to LVRACAlloc. }
         push -6; { Parameters to LVRACAlloc. }
         call LVRACAlloc;
         DataRegA -> theRep;
         4 -> SP+;
         pop  Range;
         pop  RegArg, RegObj, DataRegA;
         (if theRep <> 0 then
             { Make the LVRA-cycle: theCell -> theRep.Age }
             Offset -> Value; theObj -> Value+;
             Value -> theRep.Age;
             theRep -> theObj[Offset]; 
             return
         if)
     if);
     allocIOA: { allocate 16+((range+1+3)/4)*4 bytes }
     IOATop -> theRep;
     Range -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     theRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -6    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     clearBody:
     4 -> BodySize-;
     loop:
     0 -> theRep[16+BodySize]!l;
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     call DoGC;              { Call the Garbage Collector.               }
     goto AlloVR1            { Go back to the beginning of this routine. }
  #);

AlloVR2: public
  (#
     { Allocate a word repetition and assign it to the reference at theObj[offset] }
     
     { Input variable.  }
     theObj: Item     = RegObj;   { The object, which refer the valrep. }
     Offset: Long     = DataRegA; { Offset in the theObj.               }
     Range:  Long     = DataRegB; { The range of the valRep.            }
     
     { Used variable.   }
     BodySize:  Long    = DataReg1; { the number of bytes to allocate     }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg1
  do
     (if Range < 0 then 0 -> Range if);
     (if Range > 200 then 
         push DataRegA, RegObj, RegArg; 
         push Range; { Parameter to LVRACAlloc. }
         push -7;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataRegA -> theRep;
         4 -> SP+;
         pop  Range;
         pop  RegArg, RegObj, DataRegA;
         (if theRep <> 0 then
             { Make the LVRA-cycle: theCell -> theRep.Age }
             Offset -> Value; theObj -> Value+;
             Value -> theRep.Age;
             
             theRep -> theObj[Offset];   
             return
         if)
     if);
     allocIOA: { allocate 16+((2*range+3)/4)*4 bytes }
     IOATop -> theRep;
     Range -> BodySize;
     2 -> BodySize*;
     3 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     theRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -7    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     clearBody:
     4 -> BodySize-;
     loop:
     0 -> theRep[16+BodySize]!l;
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     call DoGC;              { Call the Garbage Collector.               }
     goto AlloVR2            { Go back to the beginning of this routine. }
  #);


AlloVR4: public
  (#
     { Allocate a value repetition of longs. }
     
     { Input variable.  }
     theObj: Item  = RegObj;   { The object, which refer the valrep.}
     Offset: Long  = DataRegA; { Offset in the theObj.              }
     Range:  Long  = DataRegB; { The range of the valRep.           }
     
     { Used variable.   }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg1
  do
     (if Range < 0 then 0 -> Range if);
     (if Range > 200 then
         push DataRegA, RegObj, RegArg; 
         push Range; { Parameter to LVRACAlloc. }
         push -5;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataRegA -> theRep;
         4 -> SP+;
         pop  Range;
         pop  RegArg, RegObj, DataRegA;
         (if theRep <> 0 then
             { Make the LVRA-cycle: theCell -> theRep.Age }
             Offset -> Value; theObj -> Value+;
             Value -> theRep.Age;
             theRep -> theObj[Offset];   
             return
         if)
     if);
     allocIOA:
     IOATop -> theRep;
     theRep[16+Range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -5    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     clearBody:
     1 -> Range-;
     loop:
     0 -> theRep[16+Range*4];
     1 -> Range-;
     (if FLAGS >= 0 then goto loop if);
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     Range -> ReqObjectSize+;
     call DoGC;              { Call the Garbage Collector.               }
     goto AlloVR4            { Go back to the beginning of this routine. }
  #);


AlloVR8: public
  (#
     { Allocate a double repetition and assign it to the reference at theObj[offset] }
     
     { Input variable.  }
     theObj: Item     = RegObj;   { The object, which refer the valrep. }
     Offset: Long     = DataRegA; { Offset in the theObj.               }
     Range:  Long     = DataRegB; { The range of the valRep.            }
     
     { Used variable.   }
     BodySize:  Long    = DataReg1; { the number of bytes to allocate     }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg1
  do
     (if Range < 0 then 0 -> Range if);
     (if Range > 200 then 
         push DataRegA, RegObj, RegArg; 
         push Range; { Parameter to LVRACAlloc. }
         push -8;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataRegA -> theRep;
         4 -> SP+;
         pop  Range;
         pop  RegArg, RegObj, DataRegA;
         (if theRep <> 0 then
             { Make the LVRA-cycle: theCell -> theRep.Age }
             Offset -> Value; theObj -> Value+;
             Value -> theRep.Age;
             theRep -> theObj[Offset];   
             return
         if)
     if);
     allocIOA: { allocate 16+range*8 bytes }
     IOATop -> theRep;
     Range -> BodySize;
     8 -> BodySize*;
     theRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -8    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     clearBody:
     4 -> BodySize-;
     loop:
     0 -> theRep[16+BodySize]!l;
     4 -> BodySize-;
     (if FLAGS >= 0 then goto loop if);
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;    
     BodySize -> ReqObjectSize+;
     call DoGC;              { Call the Garbage Collector.               }
     goto AlloVR8            { Go back to the beginning of this routine. }
  #)
