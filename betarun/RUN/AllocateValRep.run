------- AllocateValRep: System ----

AlloVR1: public
  (#
     { Allocate a byte repetition and assign it to }
     { the reference at theObj[offset]. }
     
     { Input variables. }
     theObj: Item     = RegThis;  { The object, which refer the valrep. }
     Offset: Long     = DataReg1; { Offset in the theObj. } 
     Range:  Long     = DataReg2; { The range of the valRep. }
     
     { Used variables. }
     BodySize:  Long    = DataReg1; { The number of bytes to allocate. }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg2;
     stack:  StackArea  = SP;
  do
     (if alloc_trace then stack[0] -> AllocCallPoint if);
     (if debug then 1 -> NumAlloVR1+ if); 
     (if debug then call Ck if);

     { 
       General stack layout:
       <AddrReg2>
       <AddrReg1>
       ... 
     }
     
     push AddrReg1, AddrReg2;
     
     (if do_unconditional_GC then
	 (if DoUGC<>0 then
	     { Don't do this before AttBC }
	     (if ActiveComponent<>0 then
		 { See general comment in AllocateItem.run }
		 pReg1 -> DataReg1;
		 pReg2 -> DataReg2;
		 push Offset; 
		 Range -> BodySize;
		 1 -> BodySize+;
		 ObjectAlign -> BodySize|;
		 goto GC;
	     if);
	 if);
     if);
     
     again: 

     pReg1 -> DataReg1;
     pReg2 -> DataReg2;
     
     (if Range < 0 then 0 -> Range if);
     
     (if Range > LARGE_REP_SIZE then 
         push RegThis, RegCall, Offset; { save registers }
         push Range; { Parameters to LVRACAlloc. }
         push ByteRepPTValue; { Parameters to LVRACAlloc. }
         call LVRACAlloc;
         DataReg1 -> theRep;
         pop Offset;  {Discard ByteRepPTValue (to dummy Offset)}
         pop Range;
         pop Offset, RegCall, RegThis;
	 (if theRep = 0 then 
	      push Offset;
	      0->Range;
	      goto GC;
	 if);
         theRep -> theObj[Offset]; 
         pop AddrReg2, AddrReg1;
         return
     if);
     
     IOAAlloc:
     
     { allocate 16+((range+1+7)/8)*8 bytes in IOA. }
     IOATop -> theRep;
     
     push Offset; { BodySize assignment destroys Offset. }
     
     Range -> BodySize;
     1 -> BodySize+; { NULL termination }
     ObjectAlign -> BodySize|;
     theRep[16+BodySize][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 8 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet! }
     
     { Initialize the structual part of the repetition. }
     ByteRepPTValue -> theRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theRep.GCAttr;
     if);
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     pop Offset; { We're finished using BodySize, so restore Offset. }
     
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection. }
     4 -> ReqObjectSize;     { Set the requested Object Size. }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop Offset; {Restore Offset}
     pop AddrReg2, AddrReg1;
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;              { Call the Garbage Collector.               }
     push AddrReg1, AddrReg2;
     goto again
  #);



AlloVR2: public
  (#
     { Allocate a word repetition and assign it to }
     { the reference at theObj[offset] }
     
     { Input variables. }
     theObj: Item     = RegThis;  { The object, which refer the valrep. }
     Offset: Long     = DataReg1; { Offset in the theObj. }
     Range:  Long     = DataReg2; { The range of the valRep. }
     
     { Used variables. }
     BodySize:  Long    = DataReg1; { the number of bytes to allocate }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg2;
     stack:  StackArea  = SP;
  do
     (if alloc_trace then stack[0] -> AllocCallPoint if);
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloVR2+ if); 
     
     push AddrReg1, AddrReg2;
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 pReg1 -> DataReg1;
                 pReg2 -> DataReg2;
                 push Offset; 
                 Range -> BodySize;
                 2 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     pReg1 -> DataReg1;
     pReg2 -> DataReg2;
     
     (if Range < 0 then 0 -> Range if);
     
     (if Range > LARGE_REP_SIZE then 
         push RegThis, RegCall, Offset; { save registers }
         push Range; { Parameter to LVRACAlloc. }
         push ShortRepPTValue;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataReg1 -> theRep;
         pop Offset;  {Discard ShortRepPTValue (to dummy Offset)}
         pop Range;
         pop Offset, RegCall, RegThis;
	 (if theRep = 0 then 
	      push Offset;
	      0->Range;
	      goto GC;
	 if);
         theRep -> theObj[Offset];
         pop AddrReg2, AddrReg1;
         return
     if);
     
     IOAAlloc:
     
     { allocate 16+((2*range+7)/8)*8 bytes in IOA }
     IOATop -> theRep;
     
     push Offset; {BodySize assignment destroys Offset}
     
     Range -> BodySize;
     2 -> BodySize*;
     ObjectAlign -> BodySize|;
     theRep[16+BodySize][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 9 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     ShortRepPTValue -> theRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theRep.GCAttr;
     if);
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     pop Offset; {We're finished using BodySize, so restore Offset}
          
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     pop Offset; {Restore Offset}
     pop AddrReg2, AddrReg1;
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;              { Call the Garbage Collector.               }
     push AddrReg1, AddrReg2;
     goto again
  #);



AlloVR4: public
  (#
     { Allocate a value repetition of longs. }
     
     { Input variables. }
     theObj: Item  = RegThis;   { The object, which refer the valrep.}
     Offset: Long  = DataReg1; { Offset in the theObj.              }
     Range:  Long  = DataReg2; { The range of the valRep.           }
     
     { Used variables. }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     BodySize:  Long    = DataReg1; { the number of bytes to allocate     }
     Value:  Long       = DataReg2;
     stack:  StackArea  = SP;
  do
     (if alloc_trace then stack[0] -> AllocCallPoint if);
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloVR4+ if); 
     
     push AddrReg1, AddrReg2;
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 pReg1 -> DataReg1;
                 pReg2 -> DataReg2;
                 push Offset; 
                 Range -> BodySize;
                 4 -> BodySize*;
                 ObjectAlign -> BodySize|;
                 goto GC;
             if);
         if);
     if);
     
     again:

     pReg1 -> DataReg1;
     pReg2 -> DataReg2;
     
     (if Range < 0 then 0 -> Range if);
     
     (if Range > LARGE_REP_SIZE then
         push RegThis, RegCall, Offset; { save registers }
         push Range; { Parameter to LVRACAlloc. }
         push LongRepPTValue;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataReg1 -> theRep;
         pop Offset;  {Discard LongRepPTValue (to dummy Offset)}
         pop Range;
         pop Offset, RegCall, RegThis;
	 (if theRep = 0 then 
	      push Offset;
	      0->Range;
	      goto GC;
	 if);
         theRep -> theObj[Offset];  
         pop AddrReg2, AddrReg1;
         return
     if);
     
     IOAAlloc:
     
     { allocate 16+Range*4 bytes in IOA }
     
     IOATop -> theRep;
     
     push Offset; {BodySize assignment destroys Offset}
     
     Range -> BodySize;
     4 -> BodySize*;
     ObjectAlign -> BodySize|;
     theRep[16+BodySize][] -> newTop;

     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 10 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     LongRepPTValue -> theRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theRep.GCAttr;
     if);
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
     
     pop Offset; {We're finished using BodySize, so restore Offset}

     theObj[Offset][] -> theCell;
     theRep -> theCell[0];
     
     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);

     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     Range -> ReqObjectSize+;
     pop Offset; {Restore Offset}
     pop AddrReg2, AddrReg1;
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;              { Call the Garbage Collector.               }
     push AddrReg1, AddrReg2;
     goto again
  #);



AlloVR8: public
  (#
     { Allocate a double repetition and assign it to the reference at theObj[offset] }
     
     { Input variables. }
     theObj: Item     = RegThis;   { The object, which refer the valrep. }
     Offset: Long     = DataReg1; { Offset in the theObj.               }
     Range:  Long     = DataReg2; { The range of the valRep.            }
     
     { Used variables. }
     BodySize:  Long    = DataReg1; { the number of bytes to allocate     }
     newTop: DataArea   = AddrReg1;
     theCell: DataArea  = AddrReg1;
     theRep: Repetition = AddrReg2;
     Value:  Long       = DataReg2;
     stack:  StackArea  = SP;
  do
     (if alloc_trace then stack[0] -> AllocCallPoint if);
     (if debug then call Ck if);
     (if debug then 1 -> NumAlloVR8+ if); 
     
     push AddrReg1, AddrReg2;
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 pReg1 -> DataReg1;
                 pReg2 -> DataReg2;
                 push Offset; 
                 Range -> BodySize;
                 8 -> BodySize*;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     pReg1 -> DataReg1;
     pReg2 -> DataReg2;
     
     (if Range < 0 then 0 -> Range if);
     
     (if Range > LARGE_REP_SIZE then 
         push RegThis, RegCall, Offset; { save registers }
         push Range; { Parameter to LVRACAlloc. }
         push DoubleRepPTValue;    { Parameter to LVRACAlloc. }
         call LVRACAlloc;
         DataReg1 -> theRep;
         pop Offset;  {Discard DoubleRepPTValue (to dummy Offset)}
         pop Range;
         pop Offset, RegCall, RegThis;
	 (if theRep = 0 then 
	      push Offset;
	      0->Range;
	      goto GC;
	 if);
         theRep -> theObj[Offset];
         pop AddrReg2, AddrReg1;
         return
     if);
     
     IOAAlloc: 
     
     { allocate 16+range*8 bytes in IOA }
     IOATop -> theRep;
          
     push Offset; {BodySize assignment destroys Offset}
     
     Range -> BodySize;
     8 -> BodySize*;
     theRep[16+BodySize][] -> newTop;
     (if newTop above IOALimit then goto GC if);
     (if alloc_trace then 11 -> AllocPlace; call RunTraceAlloc; if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     DoubleRepPTValue -> theRep.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theRep.GCAttr;
     if);
     1     -> theRep.LowBorder;
     Range -> theRep.HighBorder;
          
     pop Offset; {We're finished using BodySize, so restore Offset}
          
     theObj[Offset][] -> theCell;
     theRep -> theCell[0];

     (if call_chkra_unconditionally then
         call ChkRA_EBP;
      else
         (if theCell outside IOA then  { The theCell resides in AOA. }
             push theCell;
             call ChkRA { No need to remove parameter. }
         if);
     if);
     
     pop AddrReg2, AddrReg1;
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;    
     BodySize -> ReqObjectSize+;
     pop Offset; {Restore Offset}
     pop AddrReg2, AddrReg1;
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;              { Call the Garbage Collector.               }
     push AddrReg1, AddrReg2;
     goto again
  #)
