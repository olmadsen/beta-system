------- NewRefRep: System ----

NewRR: public 
  (# { FIXME: Compiler should call AlloRR directly }
     { Allocate a reference repetition based on existing repetition }
     { stack on entry [return(0),offset(4),Item(8),...] }
     { Input register new range = DataReg1 (pReg1 in intel version) }
     
     { Used variables. }
     stack:        StackArea        = SP;
     theRep:       Repetition       = AddrReg2; { saved and restored }
     offset:       Long             = DataReg2;
     proto:        Long             = DataReg2;
  do 
     (if debug then call Ck if);
     push AddrReg2;   { stack: [AddrReg2(0),return(4),offset(8),Item(12),...] }
     stack[12] -> theRep;
     stack[8] -> offset;
     theRep[offset*4] -> theRep;
     theRep.ProtoType -> proto;
     pop AddrReg2;    { stack: [return(0),offset(4),Item(8),...] }
     
     push RegThis, DataRegA, DataRegB, -6;
     { stack: [tag(0),DataRegB(4),DataRegA(8),RegThis(12),return(16),offset(20),Item(24),...] }
     stack[24]    -> RegThis;  { Item parameter }
     stack[20]    -> DataRegA; { offset parameter }
     4            -> DataRegA*;
     (if intel then
         pReg1    -> DataRegB; { Range parameter }
      else
         DataReg1 -> DataRegB; { Range parameter }
     if);
     call AlloRR;
     4 -> SP+; { pop tag }
     pop DataRegB, DataRegA, RegThis;
     (if debug then call Ck if);
     return 8;
  #)
