------- NewRefRep: System ----

NewRR: public
  (#
     { Allocate a value repetition. }
     { stack on entry [return(0),offset(4),Item(8),...] }
     { Input register range = DataReg1.                 }
     
     { Input variable. }
     range:   Long       = DataReg1; { The range of the valRep. }
                                     {pReg1 in Intel version}
     
     { Used variables. }
     stack:   StackArea = SP;
     theRep:  Repetition = AddrReg1;
     newTop:  DataArea   = AddrReg2;
     theCell: DataArea   = AddrReg2;
     offset:  Long       = DataReg1
  do
     (if debug then call Ck if);
     
     {
       General stack layout:
       <Intel: AddrReg2>   Intel: +0
       <Intel: AddrReg1>   Intel: +4
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +8    Mac: +4    Default: +0
       <offset>            Intel: +12   Mac: +8    Default: +4
       <item>              Intel: +16   Mac: +12   Default: +8
     }
     
     (if intel then pReg1 -> DataReg1 if);
     
     again:
     
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2 if);
     
     (if range<0 then 0 -> range if);
     IOATop -> theRep;
     theRep[16+range*4][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the repetition. }
     -4    -> theRep.ProtoType;
     1     -> theRep.Age;
     1     -> theRep.LowBorder;
     range -> theRep.HighBorder;
     
     { Clear the body part of the repetition. }
     clearBody:
     1 -> range-;
     loop:
     0 -> theRep[16+range*4]!l;
     1 -> range-;
     (if FLAGS >= 0 then goto loop if);
     
     (if intel then 
         stack[16] -> theCell;
         stack[12]  -> offset;
      else
         (if MacOS then 
             stack[12] -> theCell;
             stack[8]  -> offset;
          else
             stack[8] -> theCell;
             stack[4] -> offset;
         if);
     if);
          
     theCell[offset*4][] -> theCell;
     theRep -> theCell[0];
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     return 8;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     range -> ReqObjectSize+;
     (if intel then pop AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto again              { Go back to the beginning of this routine. }
  #)
