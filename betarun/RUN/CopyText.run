------- CopyText: System ----

CopyT: public
  (#
     { Allocate a (byte)ValueRepetition and initialize it with some text.    }
     { Stack on entry: <return address>,<offset>,<item>,<asciiz> }
     
     { Used variables. }
     stack:   StackArea  = SP;
     theText: CodeArea   = AddrReg1; { Address to the ascii text. }
     newTop:  DataArea   = AddrReg1;
     theCell: DataArea   = AddrReg1;
     newRep:  Repetition = AddrReg2;
     Range:   Long       = DataReg1; { The range of the valRep. }
     BodySize: Long      = DataReg2; { number of bytes to allocate }
     Value:   Long       = DataReg2;
     offset:  Long       = DataReg2
  do
     (if debug then 1 -> NumCopyT+ if); 
     (if debug then call Ck if);
     
     {
       General stack layout:
       <Intel: DataReg2>   Intel: +0
       <Intel: DataReg1>   Intel: +4
       <Intel: AddrReg2>   Intel: +8
       <Intel: AddrReg1>   Intel: +12
       <Mac: AddrReg2>                  Mac: +0    
       <return address>    Intel: +16   Mac: +4    Default: +0
       <offset>            Intel: +20   Mac: +8    Default: +4
       <item>              Intel: +24   Mac: +12   Default: +8
       <asciiz>            Intel: +28   Mac: +16   Default: +12
     }
          
     (if MacOS then push AddrReg2 if);
     (if intel then push AddrReg1, AddrReg2, DataReg1, DataReg2 if);
     
     { Calculate the length of the text. }
     (if intel then
         stack[28] -> theText;
      else 
         (if MacOS then
             stack[16] -> theText;
          else
             stack [12] -> theText;
         if)
     if);
     
     0 -> Range;
     goto LoopB;
     LoopA: 1  -> Range+;
     LoopB: (if theText[Range]!b <> 0 then goto LoopA if);
     
     (if Range > 256 then
         (if intel then
             push RegObj, RegArg; { save registers }
          else
             push DataRegA, DataRegB, RegObj, RegArg; { save registers }
         if);
         push Range; { Parameters to LVRAAlloc. }
         push -6; { Parameters to LVRAAlloc. }
         call LVRAAlloc;
         DataRegA -> newRep;
         (if newRep <> 0 then
             { Make the LVRA-cycle: theCell -> newRep.Age }
             (if intel then 
                 stack[36{20+(2+2)*4}] -> DataRegA; 
                 4 -> DataRegA*;
                 stack[40{24+(2+2)*4}] -> DataRegA+
              else
                 (if MacOS then
                     stack[32{8+(2+4)*4}] -> DataRegA; 
                     4 -> DataRegA*;
                     stack[36{12+(2+4)*4}] -> DataRegA+
                  else
                     stack[28{4+(2+4)*4}] -> DataRegA; 
                     4 -> DataRegA*;
                     stack[32{8+(2+4)*4}] -> DataRegA+
                 if);
             if);
             DataRegA -> newRep.Age
         if);
         4 -> SP+;
         pop  Range;
         (if intel then
             pop  RegArg, RegObj;
          else
             pop  RegArg, RegObj, DataRegB, DataRegA;
         if);
         (if newRep <> 0 then
             goto copyBody
         if)
     if);
     
     { Allocate a value repetition with bodysize = ((range+1+3)/4)*4 bytes }
     IOATop -> newRep;
     Range -> BodySize;
     4 -> BodySize+;
     4 -> BodySize/;
     4 -> BodySize*;
     newRep[16+BodySize][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the valrep.             }
     -6    -> newRep.ProtoType;
     1     -> newRep.Age;
     1     -> newRep.LowBorder;
     Range -> newRep.HighBorder;
     
     copyBody:
     
     (if intel then
         stack[28] -> theText
      else 
         (if MacOS then 
             stack[16] -> theText
          else
             stack[12] -> theText
         if);
     if);     
     
     { Assign the text to the body part of the repetition. }
     (if Range <> 0 then
         0 -> Value;
         4 -> Range+;
         4 -> Range/;
         1 -> Range-;
         4 -> Range*;
         loop:
         theText[Range] -> Value;
         Value -> newRep[16+Range];
         4 -> Range-;
         (if FLAGS >= 0 then goto loop if)
     if);
     
     (if intel then
         stack[24] -> theCell;
         stack[20]  -> offset;
      else
         (if MacOS then 
             stack[12] -> theCell;
             stack[8]  -> offset;
          else
             stack[8] -> theCell;
             stack[4] -> offset;
         if);
     if);
     theCell[offset*4][] -> theCell;
     newRep -> theCell[0];
     
     (if theCell outside IOA then  { The theCell resides in AOA. }
         push theCell;
         (if hp then
             theCell -> theCell-; { clear AddrReg1 before ChkRA }
          else
             0 -> theCell; { clear AddrReg1 before ChkRA }
         if);
         call ChkRA { No need to remove parameter. }
     if);
     
     (if intel then pop DataReg2, DataReg1, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     (if debug then call Ck if);
     return 12;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.            }
     4 -> ReqObjectSize;     { Set the requested Object Size.            }
     4 -> BodySize/;
     BodySize -> ReqObjectSize+;
     (if intel then pop DataReg2, DataReg1, AddrReg2, AddrReg1 if);
     (if MacOS then pop AddrReg2 if);
     call doGC;              { Call the Garbage Collector.               }
     goto CopyT              { Go back to the beginning of this routine. }
  #)

