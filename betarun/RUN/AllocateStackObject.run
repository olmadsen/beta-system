------- AllocateStackObject: System ----
AlloSO: public
  (#
     { Allocate a StackObject.                         }
     {Called only from PackCS}
     
     { Input variable. }
     Size: Value = DataReg2; { Size of the body part in longs. }
     
     { Output variable. }
     theStack: StackObject = AddrReg2;
     
     { Used variable. }
     newTop: DataArea = AddrReg1
  do
     (if debug then call Ck if);
     
     (if debug then
         (if do_unconditional_GC then
             { See general comment in AllocateItem.run }
             goto GC;
         if);
     if);
     
     again:
     
     IOATop -> theStack;
     push Size;
     4->Size*;
     7->Size+;
     8->Size/;
     8->Size*;
     theStack[16+Size][] -> newTop;
     pop Size;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structual part of the StackObject.             }
     
     StackObjectPTValue -> theStack.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theStack.GCAttr;
     if);
     Size               -> theStack.ObjectSize;
     0                  -> theStack.StackSize;
     
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     push Size;
     4->Size*;
     7->Size+;
     8->Size/;
     8->Size*;
     Size -> ReqObjectSize+;
     pop Size;
     clear AddrReg1; clear AddrReg2; {Invalidate GC registers}
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;               { Call the Garbage Collector.               }
     goto again               { Go back to the beginning of this routine. }
  #)
