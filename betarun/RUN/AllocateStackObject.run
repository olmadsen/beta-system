------- AllocateStackObject: System ----
AlloSO: public
  (#
     { Allocate a StackObject.                         }
     { Invalidates: AddrReg1, AddrReg2                 }
     { Called only from PackCS }
     
     { Input variable. }
     Size: Value = DataReg2; { Size of the body part in bytes }
     
     { Output variable. }
     theStack: StackObject = AddrReg2;
     
     { Used variable. }
     newTop: DataArea = AddrReg1
  do
     (if debug then call Ck if);
     
     (if debug then
         (if do_unconditional_GC then
             (if DoUGC<>0 then
                 { See general comment in AllocateItem.run }
                 push Size; { free DataReg2 }
                 ObjectAlign -> Size|;
                 goto GC;
             if);
         if);
     if);
     
     again:
     
     IOATop -> theStack;
     push Size; { free DataReg2 }
     ObjectAlign -> Size|;
     theStack[16+Size][] -> newTop;
     (if newTop > IOALimit then goto GC if);
     newTop -> IOATop;
     
     { The new Object is now allocated, but not initialized yet!}
     
     { Initialize the structural part of the StackObject.             }
     
     StackObjectPTValue -> theStack.ProtoType;
     (if IOAMinAge<>0 then
         IOAMinAge -> theStack.GCAttr;
     if);
     4                  -> Size/;
     Size               -> theStack.ObjectSize;
     { No need: IOA is memset(0) 0 -> theStack.StackSize; }
     
     pop Size; { Restore DataReg2 }
     
     (if debug then call Ck if);
     return;
     
     GC:
     { The IOA heap is full, so we need a garbage collection.             }
     4 -> ReqObjectSize;      { Set the requested Object Size.            }
     Size -> ReqObjectSize+;
     pop Size; { Restore DataReg2 }
     clear AddrReg1; clear AddrReg2; { Clear GC registers }
     { Stack: as on entry - data registers are tagged properly. }
     call doGC;               { Call the Garbage Collector.               }
     goto again               { Go back to the beginning of this routine. }
  #)
