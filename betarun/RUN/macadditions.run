[[
------- macadditions: System ----

ArgCount:  cvar;
ArgVector: cvar;

{ SetArgValues sets to runtime variable which makes it posible   }
{ to retrieve the arguments from the command line.               }
SetArgValues: public
  (#
     stackPointer: StackArea = SP;
     theVector:    StackArea = AddrReg1
  do
     stackPointer[20]   -> ArgCount;
     stackPointer[24][] -> theVector;
     theVector -> ArgVector;
     return
  #);

IndexError: public
  (#
     CurrentObject: Object = RegObj
  do
     push CurrentObject;
     push -3;              { Error number for Repetition index error! }
     call BetaError
  #);

FailureExit: public
  (#
     { Called from betaenvbody: (FailureTrace,'') -> Stop }
     CurrentObject: Object = RegObj
  do
     push CurrentObject;
     push -8;
     call BetaError
  #)


------- CallBack: System ----

{ Routines for invoking beta objects from C or Pascal. }

{ Handle used from C. }
HandleCB: proc;

{ Handle used from Pascal. }
HandlePCB: proc;

ActiveCallBackFrame: cvar;
BetaStackTop:        cvar;

CopyCPP: public
  (#
     theCBStruct: DataArea = AddrReg1;
     newTop:      DataArea = AddrReg2;
     
     stackTop: StackArea  = SP;
     theRoutine: CodeArea = AddrReg2
  do
     { Find a free entry in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one! }
         { NYI }
         call CBFArelloc;
         goto CopyCPP
     if);
     
     newTop -> CBFATop;
     
     stackTop[4] -> theCBStruct[0];
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction $4eb9.}
     HandleCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     20085 -> theCBStruct[10]!w; { Write the rts instruction $4e75.}
     
     { Flush the three words in datacache, c.f. Tech. Note #261 }
     push RegObj, RegArg, DataRegA;    { save registers used for flush }
     theCBStruct[4][] -> RegObj;       { base of range to flush }
     6 -> RegArg;                      { Range to flush: 6 bytes (or is it longs) }
     9 -> DataRegA;                    { Selector for FlushCodeCacheRange }
     (code '	DC.W	$A198' code);    { _HwPriv (is assumed implemented) }
     (if DataRegA!w = -502 then        { FlushCodeCacheRange not implemented }
         (code '	DC.W	$A0BD' code) { FlushCodeCache }
     if);
     pop DataRegA, RegArg, RegObj;
     
     { return pointer to the jsr-instruction }
     theCBStruct[4][] -> theCBStruct;
     theCBStruct -> stackTop[4];
     
     return
  #);

HandleCB: public
  (#
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = RegAdr;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     theObj: Object = RegObj
  do
     (code '	movem.l	d2-d7/a1-a6,-(sp)' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
     
     return
  #);


CopyPPP: public
  (#
     { Stack on entry:  0: [ return address         ]!l  }
     {                  4: [ pascal parametre value ]!w  }
     {                  6: [ pointer to struc       ]!l  }
     
     { Stack on exit:   0: [ entry to CBFA block    ]!l  }
     
     theCBStruct:   DataArea  = AddrReg1;
     newTop:        DataArea  = AddrReg2;
     
     stackTop:      StackArea = SP;
     theRoutine:    CodeArea  = AddrReg2;
     returnAddress: CodeArea  = AddrReg2
  do
     { Find a free block in the Call Back Functions Area. }
     { This area is defined by [ CBFA <= CBFATop <= CBFALimit ]. }
     CBFATop -> theCBStruct;
     theCBStruct[12][] -> newTop;
     (if newTop > CBFALimit then
         { Search through the area to find a free one! }
         { NYI }
         call CBFArelloc;
         goto CopyPPP     
     if);
     newTop -> CBFATop;
     
     { Initialize the block. } 
     stackTop[6] -> theCBStruct[0]; { Initialise the struc part of the block. }
     20153 -> theCBStruct[4]!w;  { Write the first word of the jsr instruction 4eb9.}
     HandlePCB[] -> theRoutine;
     theRoutine -> theCBStruct[6];
     
     { Flush the two words in datacache, c.f. Tech. Note #261 }
     push RegObj, RegArg, DataRegA;    { save registers used for flush }
     theCBStruct[4][] -> RegObj;       { base of range to flush }
     4 -> RegArg;                      { Range to flush: 4 bytes (or is it longs) }
     9 -> DataRegA;                    { Selector for FlushCodeCacheRange }
     (code '	DC.W	$A198' code);    { _HwPriv (is assumed implemented) }
     (if DataRegA!w = -502 then        { FlushCodeCacheRange not implemented }
         (code '	DC.W	$A0BD' code) { FlushCodeCache }
     if);
     pop DataRegA, RegArg, RegObj;

     stackTop[4]!w -> theCBStruct[10]!w;
     theCBStruct[4][] -> theRoutine;
     
     { Contents of the CBFA block: }
     {               0: [ pointer to struct in beta-heap ]!l }
     { theRoutine -> 4: [ jsr HandlePascalCallBack       ]!l }
     {              10: [ pascal parametre value         ]!w }
     
     theRoutine -> stackTop[6];
     pop returnAddress;
     2 -> stackTop+;
     goto returnAddress
  #);

HandlePCB: public
  (#
     { Stack on entry:  0: [ return address (CBFA block) ]!l        }
     {                  4: [ return address (extern)     ]!w        }
     {                  8: [ pascal parametre block      ]!?        }
     {                  ?: [ slot for return value       ]!(0,2,4)  }
     
     { Stack on exit:   0: [ slot for return value       ]!(0,2,4)  }
     
     { The size of 'pascal parametre block' and 'slot for return value'  }
     { are described in the corresponding CBFA block.                    }
     
     { NOTE: Pascal register conventions (MPW C, Appendix C): }
     { d0, d1, d2, a0, and a1 are scratch registers.          }
     
     stackPointer: StackArea = SP;
     dataPointer: DataArea = RegArg;
     theStruct:   Structure = RegArg;
     theProto:    ProtoType = RegArg;
     resObj:      Object    = RegArg;
     
     theOrigin:   Object    = RegAdr;
     
     newProto:    ProtoType = RegAdr;
     codePointer: CodeArea  = RegAdr;
     
     resultValue: Long      = DataRegA;
     
     paramBlockSize: Long    = DataRegB;
     returnBlockSize: Long   = DataRegB;
     
     table:         DataArea  = RegArg;
     returnAddress: CodeArea  = RegObj;
     
     theObj: Object = RegObj
  do
     (code '	movem.l	d2-d7/a1-a6,-(sp)' code);
     
     { Push CallBackFrame = (next, betaTop, tmp). }
     push 0;
     push BetaStackTop;
     push ActiveCallBackFrame;
     
     stackPointer -> ActiveCallBackFrame;
     
     stackPointer[60] -> dataPointer; { 16 = Offset after the previous push. }
     dataPointer[-10] -> theStruct;
     theStruct.iOrigin -> theOrigin;
     theStruct.iProto -> theProto;
     call AlloI;
     resObj -> theObj;
     resObj.ProtoType ->  newProto;
     newProto.CallBackRoutine -> codePointer;
     call codePointer;
     
     pop ActiveCallBackFrame;
     pop BetaStackTop;
     4 -> stackPointer+;
     
     (code '	movem.l	(sp)+,d2-d7/a1-a6' code);
     
     { Remove the parametre block. }
     { The return address stackPointer[0] points out }
     { the 'pascal parametre value'.                 }
     pop table;
     pop returnAddress;
     
     0 -> paramBlockSize;
     table[0]!b -> paramBlockSize;
     paramBlockSize -> stackPointer+;
     
     
     { Determine how to to return the result value from beta }
     table[1]!b -> returnBlockSize;
     
     (if returnBlockSize = 0 then goto exit if);
     (if returnBlockSize = 2 then
         resultValue!w -> stackPointer[0]!w;
         goto exit
     if);
     (if returnBlockSize = 4 then 
         resultValue!l -> stackPointer[0]!l;
         goto exit
     if);
     
     push 0; 
     push -12; 
     call BetaError;    
  exit:
     goto returnAddress
  #)

----- PascalInterface: system -----

PpkCT: public
  (#
     { stack on entry: return[0], ascii[4] }
     stack:       StackArea = SP;
     a1:          Long      = RegArg;
     theText:     DataArea  = RegArg;
     Size:        Long      = DataReg2;
     index:       Long      = DataRegA;
     theTextAddr: DataArea  = RegAdr;
     Value:       Byte      = DataReg1;
     nextText:    DataArea  = AddrReg1;
     RetAddr:     CodeArea  = AddrReg1
  do 
     push a1;
     stack[8] -> theText;
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Compute the text size. }
     0 -> Size;
     goto LoopB;
     LoopA: 1  -> Size+;
     LoopB: (if theText[Size]!b <> 0 then goto LoopA if);
     
     { Set the first byte in the pascal string eq the length. }
     Size!b -> theTextAddr[0]!b;
     
     { Copy the contents of the ascii to the CTextPool. }
     (if Size <> 0 then
         0 -> index;
         loop:
         theText[index]!b -> Value; 
         Value -> theTextAddr[1+index]!b;
         1 -> index+;
         (if index < Size then goto loop if)
     if);
     
     { Update CTextPool. }
     theTextAddr[1+Size][] -> nextText;
     nextText -> CTextPoolEnd;
     
     pop a1;
     pop  RetAddr;
     theTextAddr -> stack[0];
     goto RetAddr
  #);

PpkVT: public
  (#     
     { input parameters }
     repArg:      Repetition = DataReg1;
     
     { variables }
     theRep:      Repetition = RegArg;
     a1:          Long       = RegArg;
     theTextAddr: DataArea   = RegAdr;
     FreeSpace:   Long       = DataReg1;
     nextText:    DataArea   = AddrReg1;
     
     Range:       Long       = DataReg2;
     index:       Long       = DataRegA;
     Value:       Byte       = DataReg1;

     RetAddr:     CodeArea   = AddrReg1
  do 
     push a1;
     repArg -> theRep;
    
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Check range overflow on CTextPool.                               }
     { nextText is used as a tmp. register only.                        }
     { Size_left_in_CTextPool = (Adr(CTextPool) + 1000) - CTextPoolEnd. }
     CTextPool[] -> nextText;
     nextText -> FreeSpace;
     1000 -> FreeSpace+;
     CTextPoolEnd -> FreeSpace-;

     { Calculate BodySize of theRep }
     theRep.HighBorder -> Range;
          
     (if FreeSpace <= Range then
         push RegObj;
         push -35;
         call BetaError
     if);
     
     { Set the first byte in the pascal string eq the length. }
     Range!b -> theTextAddr[0]!b;
     
     { Copy the contents of the repetition to the CTextPool. }
     (if Range <> 0 then
         0 -> index;
         loop:
         theRep[16+index]!b -> Value!b;
         Value -> theTextAddr[1+index]!b;
         1 -> index+;
         (if index < Range then goto loop if)
     if);
     
     { Update CTextPool. }
     theTextAddr[1+Range][] -> nextText;
     nextText -> CTextPoolEnd;
     
     pop  a1;
     pop  RetAddr;
     push theTextAddr;
     goto RetAddr
  #);

PpkSVT: proc;
PpkVTS: public
(# do goto PpkSVT #);

PpkSVT: public
  (#
     { input parameters }
     repArg:      Repetition = DataReg1;
     low:         Long       = DataReg2;
     high:        Long       = DataReg3;

     { variables }
     theRep:      Repetition = RegArg;
     a1:          Repetition = RegArg;
     theTextAddr: DataArea   = RegAdr;
     FreeSpace:   Long       = DataRegA;
     nextText:    DataArea   = AddrReg1;
     
     index:       Long       = DataReg2; { same as low }
     Value:       Byte       = DataRegA; { same as FreeSpace }
     
     RetAddr:     CodeArea   = AddrReg1
  do 
     push a1;
     repArg -> theRep;
     
     { Check bounds and transform high into number of bytes to copy }
     (if low  < theRep.LowBorder   then push RegObj; push -6; call BetaError if);
     (if high > theRep.HighBorder  then push RegObj; push -7; call BetaError if);
     
     low  -> high-; 1 -> high+;
     (if high < 0 then 0 -> high if);     
     
     { Compute the text start point. }
     CTextPoolEnd -> theTextAddr;
     
     { Set the first byte in the pascal string eq the length. }
     high!b -> theTextAddr[0]!b;
     
     { Check range overflow on CTextPool.                               }
     { nextText is used as a tmp. register only.                        }
     { Size_left_in_CTextPool = (Adr(CTextPool) + 1000) - CTextPoolEnd. }
     CTextPool[] -> nextText;
     nextText -> FreeSpace;
     1000 -> FreeSpace+;
     CTextPoolEnd -> FreeSpace-;
     
     (if FreeSpace <= high then
         push RegObj;
         push -35;
         call BetaError
     if);
     
     { Copy the contents of the repetition to the CTextPool. }
     (if high <> 0 then
         1 -> low-;
         theRep[low][] -> theRep; { Start at low. }
         0 -> index;
         loop:
         theRep[16+index]!b -> Value;
         Value -> theTextAddr[1+index]!b;
         1 -> index+;
         (if index < high then goto loop if)
     if);
      
     { Update CTextPool. }
     theTextAddr[1+high][] -> nextText;
     nextText -> CTextPoolEnd;
     
     pop a1;
     pop  RetAddr;
     push theTextAddr;
     goto RetAddr
  #)


---]]
