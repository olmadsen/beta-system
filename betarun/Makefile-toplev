# Top level makefile for making BETA runtime.  This makefile 
# is designed to be used by the mbs_make script using the vpath
# feature.

# This makefile requires GNU make or compatible.  If your make
# program barfs on it then that may be the problem.  Set your
# GNUMAKE variable and try again.

# (c) 2000,2001 Mjølner Informatics
# by Erik Corry

export ARCH
export BETALIB
export BETARUN
export RUNTYPE
export PROF
export GNUC
export RM
export MV
export CP
export GCC
export BETARUN_SUFFIX
export EXE
export ECHO
export ECHON
export ECHOEND
export ECHONEND
export PWDCMD

VPATH=$(BETARUN)

ifeq ($(ARCH), nti_gnu)
    # No echo command on DOS
    # You will find this command in bin (not r5.x\bin) if you cvs update
    ECHO=unixecho
    ECHON=unixecho -n
    ECHOEND=
    ECHONEND=
    PWDCMD=unixpwd
else
    ifeq ($(ARCH), nti_ms)
	# No echo command on DOS
        # You will find this command in bin (not r5.x\bin) if you cvs update
	ECHO=unixecho
	ECHON=unixecho -n
	ECHOEND=
	ECHONEND=
	PWDCMD=unixpwd
    else
	# Echo is faster on Unix
	ECHO=echo 
	ifeq ($(ARCH), sun4s)
	    ECHON=/usr/ucb/echo -n 
        else
	    ECHON=/bin/echo -n 
	endif
	# GNU echo is only guaranteed to be present on Linux
	ifeq ($(ARCH), linux)
	    ECHOEND=| fmt -t -w 78
	else
	    ECHOEND=| fmt -w 78
	endif
	ifeq ($(ARCH), macosx)
            ECHOEND=
        endif
	ECHONEND=
	PWDCMD=pwd
	#ECHO=perl -e 'print "
	#ECHON=perl -e 'print "
	#ECHOEND=\n";'
	#ECHONEND=";'
    endif
endif

# When doing inline perl programs in make rules:
# Dollars need to be escaped as \$$$$  (perhaps only two dollars if you use
#     the command in the current makefile, may be MAKEFLAGS related bug)
# Spaces, () and ; must be escaped with \
# For some reason this has stopped working again, so if you need MV you
#     will have to hack a new unixmv or something :-(

ifeq ($(ARCH), nti_gnu)
#CP=perl -e use\ File::Copy\;copy\(\$$$$ARGV[0],\$$$$ARGV[1]\)\|\|die\(\$$$$ARGV[0]\)
CP=unixcp
MV=perl -e use\ File::Copy\;move\(\$$$$ARGV[0],\$$$$ARGV[1]\)\|\|die\(\$$$$ARGV[0]\)
#MV=dumpargs -e "asda asda"
RM=delete
EXE=.exe
else
ifeq ($(ARCH), nti_ms)
#CP=perl -e use\ File::Copy\;copy\(\$$$$ARGV[0],\$$$$ARGV[1]\)\|\|die\(\$$$$ARGV[0]\)
CP=unixcp
MV=perl -e use\ File::Copy\;move\(\$$$$ARGV[0],\$$$$ARGV[1]\)\|\|die\(\$$$$ARGV[0]\)
RM=delete
EXE=.exe
else
CP=cp
MV=mv
RM=rm -f
EXE=
endif
endif

ifeq ($(ARCH), nti_ms)
  BETARUN_SUFFIX=lib
else
  ifeq ($(ARCH), nti_gnu)
    BETARUN_SUFFIX=lib
  else
    ifeq ($(ARCH), sun4s)
      BETARUN_SUFFIX=a
    else
      BETARUN_SUFFIX=o
    endif
  endif
endif

ifeq ($(GNUC), yes)
all: nodebug debug nodebug_g novalhalla ugc nodebug_pg
else
all: nodebug debug nodebug_g novalhalla ugc
endif

clean: nodebug_clean debug_clean ugc_clean nodebug_g_clean nodebug_pg_clean novalhalla_clean alloc_trace_clean
	$(RM) *.a *.o


# Normal betarun, which includes hooks for BETA debugging

nodebug::
	@mbs_mkdir nodebug
	cd nodebug; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ UGC=no VALHALLA=yes RTDEBUG=no CDEBUG=no
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
# datpete: 2002/09/02: Still need to copy to old location, since boot
# compiler uses this.
	$(CP) nodebug/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_v.$(BETARUN_SUFFIX)
	$(CP) nodebug/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_v.$(BETARUN_SUFFIX)


nodebug_clean::
	@mbs_mkdir nodebug
	@cd nodebug; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ -f $(BETARUN)/Makefile-vpath clean

# Debugging betarun, which is very slow.  Use -s 13 for compiler

debug::
	@mbs_mkdir debug
	@cd debug; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ UGC=no VALHALLA=yes RTDEBUG=yes CDEBUG=yes
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
	$(CP) debug/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_debug.$(BETARUN_SUFFIX)
	$(CP) debug/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_debug.$(BETARUN_SUFFIX)

debug_clean::
	@mbs_mkdir debug
	@cd debug; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ clean

# Debugging betarun, which is very slow, with unconditional GC.  Use -s 80

ugc::
	@mbs_mkdir ugc
	@cd ugc; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ UGC=yes VALHALLA=yes RTDEBUG=yes CDEBUG=yes
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
	$(CP) ugc/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_ugc.$(BETARUN_SUFFIX)
	$(CP) ugc/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_ugc.$(BETARUN_SUFFIX)

ugc_clean::
	@mbs_mkdir ugc
	@cd ugc; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ clean

# Nondebugging betarun, which is fast but has symbols for C debugger. Use -s 88

nodebug_g::
	@mbs_mkdir nodebug_g
	@cd nodebug_g; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ UGC=no VALHALLA=yes RTDEBUG=no CDEBUG=yes
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
	$(CP) nodebug_g/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_sym.$(BETARUN_SUFFIX)
	$(CP) nodebug_g/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_sym.$(BETARUN_SUFFIX)

nodebug_g_clean::
	@mbs_mkdir nodebug_g
	@cd nodebug_g; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ clean

# Nondebugging betarun with profiling info for gprof. Use -s 31 on compiler

nodebug_pg::
	@mbs_mkdir nodebug_pg
	@cd nodebug_pg; $(MAKE) VARIANT=$@ UGC=no VALHALLA=yes RTDEBUG=no CDEBUG=no PROF=-pg -f $(BETARUN)/Makefile-vpath
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
	$(CP) nodebug_pg/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_pg.$(BETARUN_SUFFIX)
	$(CP) nodebug_pg/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_pg.$(BETARUN_SUFFIX)

nodebug_pg_clean::
	@mbs_mkdir nodebug_pg
	@cd nodebug_pg; $(MAKE) VARIANT=$@ -f $(BETARUN)/Makefile-vpath clean

# Nondebugging betarun, no symbols for C debugger, no valhalla support

novalhalla::
	@mbs_mkdir novalhalla
	@cd novalhalla; $(MAKE) -f $(BETARUN)/Makefile-vpath MAKEFLAGS=$(MAKEFLAGS) VARIANT=$@ UGC=no VALHALLA=no RTDEBUG=no CDEBUG=no
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
# datpete: 2002/09/02: Still need to copy to old location, since boot
# compiler uses this.
	$(CP) novalhalla/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun.$(BETARUN_SUFFIX)
	$(CP) novalhalla/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun.$(BETARUN_SUFFIX)

novalhalla_clean::
	@mbs_mkdir novalhalla
	@cd novalhalla; $(MAKE) VARIANT=$@ -f $(BETARUN)/Makefile-vpath clean

# Nondebugging betarun, symbols for C debugger, valhalla support, trace allocs
# Only tested on Linux x86

alloc_trace::
	@mbs_mkdir alloc_trace
	@cd alloc_trace; $(MAKE) VARIANT=$@ UGC=yes VALHALLA=yes RTDEBUG=no ALLOC_TRACE=yes CDEBUG=yes -f $(BETARUN)/Makefile-vpath
	@mbs_mkdir $(BETALIB)/betarun
	@mbs_mkdir $(BETALIB)/betarun/$(ARCH)
	$(CP) alloc_trace/betarun.$(BETARUN_SUFFIX) $(BETALIB)/betarun/$(ARCH)/betarun_alloc_trace.$(BETARUN_SUFFIX)
	$(CP) alloc_trace/betarun.$(BETARUN_SUFFIX) $(BETALIB)/lib/$(ARCH)/betarun_alloc_trace.$(BETARUN_SUFFIX)

alloc_trace_clean::
	@mbs_mkdir alloc_trace
	@cd alloc_trace; $(MAKE) VARIANT=$@ -f $(BETARUN)/Makefile-vpath clean

tags::
	cd $(BETARUN); etags GC/*.[hc] P/*.[hc] NEWRUN/*.[hc] CRUN/*.[hc] C/*.[hc] C/data.gen Makefile-vpath C/Makefile-vpath GC/Makefile-vpath P/Makefile-vpath NEWRUN/Makefile-vpath CRUN/Makefile-vpath RUN/*.run

# vim:sw=2
