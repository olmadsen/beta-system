ORIGIN '../GENERATOR/asmfile'
[[
---- OutConstant:descriptor ----
(# do value -> putInt #)

---- OutRegister:descriptor ----
(# do
   (if size
    // 1 then  outByte[] -> putText 
    // 2 then  outWord[] -> putText 
    // 4 then  outLong[] -> putText
    else 'OutRegister: wrong size specified' -> putText
   if)
#)

---- ClearRegister:descriptor ----
(* 
 * Quick hack:
 * 8 and 16 bit register operands must have (the most significant) bits cleared
 * before use. Otherwise OutDispIndirect may not be safe, since registers are 
 * always output as 32-bit entities.
 *)
(# s: @integer
do 
   (if size<>4 // true then
       'mov\t' -> putText;
       size -> s; 4 -> size; out; s -> size; ',0'->putText;
       ' ; QH: Clear MSB in surrounding 32-bit register' -> putText;
       newline; '\t' -> putText;
   if)
#)

---- OutLabel:descriptor ----
(# do name[] -> putText #)

---- OutIndirect:descriptor ----
(# do 
   (if size
    // 1 then 'byte ptr ' -> putText;
    // 2 then 'word ptr ' -> putText;
    // 4 then 'dword ptr '-> putText;
    else 'null ptr ' ->putText;
   if);
   '[' -> put;
   (if offset <> 0 // true then
       offset -> putInt;
       '+' -> put;
   if);
   reg.out;
   ']' -> put 
#)

---- OutDispIndirect:descriptor ----
(# tmpSize: @integer;
do 
   (if size
    // 1 then 'byte ptr ' -> putText;
    // 2 then 'word ptr ' -> putText;
    // 4 then 'dword ptr '-> putText;
    else 'null ptr ' ->putText;
   if);
   (if offset <> 0 // true then offset->putInt; if);
   '['->put; 
   baseRegister.out; 
   '+' -> put;
   
   (* Quick hack - base and disp sizes must match. *)
   dispRegister.size -> tmpSize;
   4 -> dispRegister.Size;
   dispRegister.out;
   tmpSize -> dispRegister.Size;
   
   (if scale <> 1 // true then '*' -> put; scale -> putInt; if);
   ']'->put;
#)
----]]
