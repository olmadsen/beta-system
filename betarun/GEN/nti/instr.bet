ORIGIN '../GENERATOR/asmfile'
[[
---- INCLUDE './nop'
---- INCLUDE './sop'
---- INCLUDE './dop'
---- PrivatePart: descriptor ----
(##)

---- InstrLib:attributes ----
sep:(# do ',' -> put #);
tab:(# do ascii.ht -> put #);
isUsingMemory:
  (# result: @boolean; op:^operand
  enter op[]
  do
     (if op.type
      //LabelType//IndirectType//DispIndirectType
      //ExternVar then
         true -> result
      else
         false -> result
     if)
  exit result
  #);

---- ExtendInstr:descriptor ----
(# 
do 
   'movsx' -> putInstr; 4 -> op.size; op.out; sep; 2 -> op.size; op.out;
#)

---- MoveInstr:descriptor ----
(# s1, s2: @integer;
do 
   (if ((op1[] -> isUsingMemory) AND (op2[] -> isUsingMemory))//true then
       (* IS THIS SAFE??? Check putInstr comments for warnings!!! *)
       (if op2.size<>4 then op2.clear; if); 
       'push' -> putInstr; tab; op1.out; newline; tab; 
       'pop'  -> putInstr; tab; op2.out
    else
       (if true
        // FALSE AND (* not using these instructions - not pairable *)
           (op1[]->isUsingMemory) then
           op2.size -> s2;
           4 -> op2.size;
           (if s2
            // 1 then 
               'movzx\t' -> putText; op2.out; sep; op1.out
            // 2 then 
               'movzx\t' -> putText; op2.out; sep; op1.out
            // 4 then 
               'mov' -> putInstr; op2.out; sep; op1.out
           if);
           s2 -> op2.size;
        // op1.type = ConstantType then
           op2.size -> s2;
           4 -> op2.size;
           op1.size -> s1;
           4 -> op1.size;
           'mov' -> putInstr; op2.out; sep; op1.out;
           s1 -> op1.size;
           s2 -> op2.size;
        else
           (if op2.size<>4 then 
               '; Not clearing here - do it in source if needed!\n\t' 
                 -> puttext;
               (*op2.clear; *)
           if);
           'mov' -> putInstr; op2.out; sep; op1.out;
       if);
       
   if)
#)

---- LeaInstr:descriptor ----
(# 
do (if op2.size<>4 then op2.clear; if);
   'lea' -> putText; tab; op2.out; sep; op1.out (**)
#)

---- AddInstr:descriptor ----
(# do 'add' -> putInstr; op2.out; sep; op1.out #) (**)

---- SubtractInstr:descriptor ----
(# do 'sub' -> putInstr; op2.out; sep; op1.out #) (**)

---- IncInstr:descriptor ----
(# do 'inc' -> putInstr; op.out;  #)

---- DecInstr:descriptor ----
(# do 'dec' -> putInstr; op.out;  #)

---- shiftRightInstr:descriptor ----
(# do 'shr' -> putInstr; op2.out; sep; op1.out #) (**)

---- shiftLeftInstr:descriptor ----
(# do 'shl' -> putInstr; op2.out; sep; op1.out #) (**)

---- DivideInstr:descriptor ----
(# do 'DivideInstr NYI(tm)' -> putText; (* Not used yet! *) #)

----MultiplyInstr:descriptor ----
(# do 'MultiplyInstr NYI(tm)' -> putText; (* Not used yet! *) #)

---- JumpInstr:descriptor ----
(# do 'jmp' -> putText; tab; op.out #)

---- BranchInstr:descriptor ----
(# do 'jmp' -> putText; tab; op.out #)

---- BranchEqualInstr:descriptor ----
(# do 'je' -> putText; tab; op.out #)

---- BranchNotEqualInstr:descriptor ----
(# do 'jne' -> putText; tab; op.out #)

---- BranchLessThanInstr:descriptor ----
(# do 'jl' -> putText; tab; op.out #)

---- BranchLessThanOrEqualInstr:descriptor ----
(# do 'jle' -> putText; tab; op.out #)

---- BranchGreaterThanInstr:descriptor ----
(# do 'jnle' -> putText; tab; op.out #)

---- BranchGreaterThanOrEqualInstr:descriptor ----
(# do 'jge' -> putText; tab; op.out #)

---- BranchCCInstr:descriptor ----
(# do 'jnc' -> putText; tab; op.out #)

---- BranchCSInstr:descriptor ----
(# do 'jc' -> putText; tab; op.out #)

---- CallInstr:descriptor ----
(# do 'call' -> putText; tab; op.out #)

---- PopInstr:descriptor ----
(# 
do (if op.size<>4 then op.clear; if);
   'pop' -> putInstr; op.out
#)

---- PushInstr:descriptor ----
(# do 'push' -> putInstr; op.out #)

---- ClearInstr:descriptor ----
(# 
do (if op.type = RegisterType then
       op.clear; 
    else
       'mov' -> putinstr; op.out; sep; '0' -> put;
   if)
#)

---- TestInstr:descriptor ----
(# 
do (if op.type = RegisterType then
       'test' -> putInstr; op.out; sep; op.out;
    else
       'cmp' -> putInstr; op.out; sep; '0' -> put; 
   if)
#)


---- CmpInstr:descriptor ---- 
(# op2I: ^Indirect 
do (* the following is a size fix! Must be verified *)
   (*4->op1; 4->op2;*)
   (if op2.type=IndirectType then 
       op2[]->op2I[]; 4->op2I.reg
   if);
   'cmp' -> putInstr; op1.out; sep; op2.out (**)
#)
---- CmpRangeInstr:descriptor ----
(# 
   failLabel, endLabel: ^Label;
do 
   (* 'boundl'-> putText; tab; op1.out; sep; op2.out; -- wrong: calls interrupt 5 *)
   
   (* Outrageously inefficient bound check coming up... *)
   newLocalLabel -> failLabel[];
   newLocalLabel -> endLabel[];
   'cmp' -> putInstr; op1.out; ',' -> putText; op2.out; newline; tab; (**)
   'jb' -> putText; tab; failLabel.name[] -> putText; newline; tab;
   'cmp' -> putInstr; op1.out; sep; op2.out; '+4\n'->putText; tab; (**)
   'jae\t' -> putText; failLabel.name[] -> putText; newline; tab;
   'clc' -> putText; newline; tab;
   'jmp' -> putText; tab; endLabel.name[] -> putText; newline;
   failLabel.name[] -> putText; ':' -> putText; tab; 'stc' -> putText; newline;
   endlabel.name[] -> putText; ':' -> putText;
#)

---- PushAll:descriptor ----
(# do 'pushad' -> putText #)

---- PopAll:descriptor ----
(# do 'popad' -> putText #)

---- Return:descriptor ----
(# do 'ret' -> putText #)

---- ReturnDisp:descriptor ----
(# do 'ret' -> putText; tab; disp->putInt  #)
 
---- OutCode:descriptor ----
(# do line[] -> putText; newLine #)

----]]
