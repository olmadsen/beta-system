ORIGIN '../GENERATOR/asmfile'
[[

---- Machine:descriptor ----
(# do 'nti' -> name[] #)

---- ToCName:descriptor ----
(# do '_'-> name.prepend #)

---- Prolog:descriptor ----
(# i : @integer;
do
   '\tTITLE\tBetaRuntimeSystem\n'->putText;
   '.386P\n'->putText;
   '.model\tflat\n'->putText;
   'smart\n'->putText;
      
   '.data\n'->puttext;
   (for i:5 repeat
        'public\t_pReg'->putText; i->putInt;
        '\n_pReg'->putText; i->putInt; '\tdd\t0\n'->putText;
   for);
   (for i:3 repeat
        'public\t_a'->putText; i+1->putInt;
        '\n_a'->putText; i+1->putInt; '\tdd\t0\n'->putText;
   for);
   (for i:6 repeat
        'public\t_d'->putText; i-1->putInt;
        '\n_d'->putText; i-1->putInt; '\tdd\t0\n'->putText;
   for);
#)

---- EndRoutine:descriptor ----
(# do newLine #)

---- BeginCode:descriptor ----
(# do '.code\n'->putText #)

---- EndCode:descriptor ----
(# #)

---- BeginData:descriptor ----
(# do '.data\n'->putText #)

---- EndData:descriptor ----
(# do '.code\n'->putText #)

---- Epilog: descriptor ----
(# do '\tend\n'->putText #)

---- DefinePublic:descriptor ----
(# do 
   'Public routine' -> CommentLine;
   labOp[] -> ExportLabel; labOp[] -> DefineLabel;
#)

---- DefineLocalLabel:descriptor ----
(# do op.out; ':' -> put; newLine #)

---- NewLocalLabel:descriptor ----
(# name:@text
do
   'L' -> name.put; LabelNo + 1 -> LabelNo -> name.putInt;
   (4, name[],0) -> NewLabel -> op[]
#)

---- ExportLabel:descriptor ----
(# do 'public\t' -> putText; labOp.out; newLine #)

---- ImportLabel:descriptor ----
(# do 'extrn\t' -> putText; labOp.out;
   (if labOp.subtype
    //ExternFunc then ':proc'->putText;
    //ExternVar then ':dword'->putText;
   if);
   newLine
#)

---- DefineLabel:descriptor ----
(# do labOp.out; ':' -> put; newLine #)

---- CommentLine:descriptor ----
(# do '; ' -> putText; comment[] -> putText; newLine #)

----]]
