ORIGIN '../GENERATOR/asmfile'
[[
---- INCLUDE './nop'
---- INCLUDE './sop'
---- INCLUDE './dop'
---- PrivatePart: descriptor ----
(#

#)
---- InstrLib:attributes ----

  sep:(# do ',' -> put #);
  tab:(# do ascii.ht -> put #);

---- MoveInstr:descriptor ----
  (# do 'move' -> putInstr; op1.out; sep; op2.out #)

---- LeaInstr:descriptor ----
  (# do 'lea	' -> putText; op1.out; sep; op2.out #)

---- AddInstr:descriptor ----
  (# do 'add' -> putInstr; op1.out; sep; op2.out #)

---- SubtractInstr:descriptor ----
  (# do 'sub' -> putInstr; op1.out; sep; op2.out #)

---- shiftRightInstr:descriptor ----
  (# do 'asr' -> putInstr; op1.out; sep; op2.out #)

---- shiftLeftInstr:descriptor ----
  (# do 'asl' -> putInstr; op1.out; sep; op2.out #)

---- DivideInstr:descriptor ----
  (# do (* Not used yet! *) #)

----MultiplyInstr:descriptor ----
  (# do (* Not used yet! *) #)

---- JumpInstr:descriptor ----
  (# newOp:^Operand
  do
    'jmp	' -> putText;
    (if op.type//RegisterType then
      (4,op[],0,CodeArea) -> NewIndirect -> newOp[];
      newOp.out;
    else
      op.out 
    if)
  #)

---- ExtendInstr:descriptor ----
  (# do 'ext.l	' -> putText; op.out #)

---- BranchInstr:descriptor ----
  (# do 'bra	' -> putText; op.out #)

---- BranchEqualInstr:descriptor ----
  (# do 'beq	' -> putText; op.out #)

---- BranchNotEqualInstr:descriptor ----
  (# do 'bne	' -> putText; op.out #)

---- BranchLessThanInstr:descriptor ----
  (# do 'blt	' -> putText; op.out #)

---- BranchLessThanOrEqualInstr:descriptor ----
  (# do 'ble	' -> putText; op.out #)

---- BranchGreaterThanInstr:descriptor ----
  (# do 'bgt	' -> putText; op.out #)

---- BranchGreaterThanOrEqualInstr:descriptor ----
  (# do 'bge	' -> putText; op.out #)

---- BranchCCInstr:descriptor ----
  (# do 'bcc	' -> putText; op.out #)

---- BranchCSInstr:descriptor ----
  (# do 'bcs	' -> putText; op.out #)

---- CallInstr:descriptor ----
  (# newOp: ^Operand
  do 'jsr	' -> putText;
    (if op.type//RegisterType then
      (4,op[],0,CodeArea) -> NewIndirect -> newOp[];
      newOp.out;
    else
      op.out 
    if)
  #)

---- PopInstr:descriptor ----
  (# do 'move' -> putInstr; '(sp)+' -> putText; sep; op.out #)

---- PushInstr:descriptor ----
  (# do 'move' -> putInstr; op.out; sep; '-(sp)' -> putText #)

---- ClearInstr:descriptor ----
  (# do 'clr' -> putInstr; op.out #)

---- TestInstr:descriptor ----
  (# do 'tst' -> putInstr; op.out #)

---- CmpInstr:descriptor ----
  (# do 'cmp' -> putInstr; op2.out; sep; op1.out #)

---- CmpRangeInstr:descriptor ----
  (# do 'cmp2' -> putInstr; op2.out; sep; op1.out #)

---- Return:descriptor ----
  (# do 'rts' -> putText #)

---- ReturnDisp:descriptor ----
  (# do 'rtd' -> putText; tab; '#' -> put; disp ->putInt  #)

---- OutCode:descriptor ----
  (# do line[] -> putText; newLine #)

----]]
