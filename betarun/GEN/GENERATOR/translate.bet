ORIGIN './control';
BODY   './object';
BODY   './address';
INCLUDE '../GRAMMAR/runsematt';
INCLUDE './symboltable';
---- Translate: Descriptor ----
(#
   maxfragments: (# exit 100 #);
   
   trace: (# exit false #);
   
   BobsTab: (# exit '~beta/betarun/v3.0/GEN/GRAMMAR/runtime-parser.btab' #);
   
   ast: @astInterface
     (* An instance of the AST interface *)
     (# defaultGrammarFinder:: findGrammar #);
   
   runtime : @ast.runtime;    (* The MPS interface to the BETA grammar/ASTs *)
   
   SystemName: 
     @ (# 
	  t: [1]^Text;
	  cnt: @integer;
	  insert: 
	    (# 
	       symbol: ^text;
	    enter symbol[]
	    do 
	       cnt+1 -> cnt; 
	       (if cnt>t.range//true then t.range -> t.extend if);
	       symbol[] -> t[cnt][];
	    #);
	  contains: 
	    (# 
	       symbol: ^text;
	       success: @boolean;
	    enter symbol[]
	    do 
	       false -> success;
	       (for i:cnt repeat
		    (if (symbol[]->t[i].equalNCS)//true then true -> success if);
	       for);
	    exit success
	    #);
       enter insert
       #);
   
   NameApplToText: (# na:^ast.NameAppl enter na[]  exit na.getText #);
   NameDeclToText: (# nd:^ast.NameDecl enter nd[]  exit nd.getText #);
   ConstToInteger: (# con:^ast.Const   enter con[] exit con.getValue #);
   
   NameToText:
     (# na:^runtime.Name
     enter na[]
     exit na.getNameAppl -> NameApplToText
     #);
   
   NumberToInteger:
     (# nu:^runtime.Number; opt:^ast.ast; result:@integer
     enter nu[]
     do nu.getConst -> ConstToInteger -> result;
	nu.getMinusOpt -> opt[];
	(if opt.kind//ast.kinds.optional then else -result -> result if)
     exit result
     #);
   
   isOptionalPresent:
     (# opt:^ast.ast; result:@boolean
     enter opt[]
     do (if opt.kind//ast.kinds.optional then false -> result
	 else true -> result if)
     exit result
     #);
   
   RegisterType:   (# exit 1 #);
   CVariableType:  (# exit 2 #);
   CFunctionType:  (# exit 3 #);
   ConstantType:   (# exit 4 #);
   
   NoArea:(# exit 0 #); CodeArea:(# exit 1 #); DataArea:(# exit 2 #);
   StackArea:(# exit 3 #); AllArea:(# exit 4 #);
   
   ByteSize: (# exit 1 #); WordSize: (# exit 2 #); LongSize: (# exit 4 #);
   
   GlobalBase:@SymbolTable
     (# element::< (# op:^AsmFile.Operand #);
	AddRegister: AddPre
	  (# OutLong, OutWord, OutByte: @text; AreaType: @integer
	  enter (OutLong,OutWord,OutByte,AreaType)
	  do (longSize, OutLong[], OutWord[], OutByte[], AreaType)
	       -> AsmFile.NewRegister -> e.op[]; 
	  #);
	AddConst:AddPre
	  (# value: @integer;
	  enter value
	  do value -> AsmFile.NewConstant -> e.op[];
	  exit e.op[]
	  #);
	AddCVar:AddPre
	  (# OutLine: ^text; Size: @integer
	  enter (OutLine[],Size)
	  do (Size, OutLine[], AsmFile.ExternVar) ->  AsmFile.NewLabel -> e.op[]
	  exit e.op[]
	  #);
	AddCFunc:AddPre
	  (# OutLine: ^text
	  enter OutLine[]
	  do (longSize,OutLine[],AsmFile.ExternFunc) -> AsmFile.NewLabel -> e.op[]
	  exit e.op[]
	  #);      
	AddInternalFunc:AddPre
	  (# OutLine: ^text
	  enter OutLine[]
	  do (longSize,OutLine[],AsmFile.InternalFunc) -> AsmFile.NewLabel -> e.op[]
	  #);      
	ScanLab: scan
	  (# labOp:^AsmFile.Label
	  do (if current.op.type//AsmFile.LabelType then
		 current.op[] -> labOp[]; inner if)
	  #);
	Init:
	  (# do <<SLOT GlobalBaseInit: descriptor>>;
	  #)
     #);
   OffsetBase: SymbolTable
     (# element::< (# Size, Offset: @integer #);
	Add::<
	  (# Offset, Size: @integer
	  enter ( Offset, Size)
	  do Offset -> e.Offset; Size -> e.Size
	  #)
     #);
   ObjectBase: @SymbolTable
     (# element::< (# list: ^OffsetBase; AreaType:@integer #);
	Add::< 
	  (# List:^OffsetBase; AreaType:@integer
	  enter (List[],AreaType)
	  do list[] -> e.list[]; AreaType -> e.AreaType
	  #)
     #);
   
   AstError: 
     (# M: @text 
     enter M 
     do (if asmfile.entry.exists then
	    asmfile.delete;
	if);
	'\n\'' -> M.append;
	asmfile.name -> M.append;
	'\' removed.' -> M.append;
	(failure, M[]) -> Stop 
     #);
   
   InitAstEnv:
     (* Initialization of the meta programming system *)
     (# do 
	(* (ast.trace.topOpen,true) -> ast.trace.set;
	 (ast.trace.fragmentOpen,true) -> ast.trace.set;
	 (ast.trace.grammars,true) -> ast.trace.set;
	 (ast.trace.compactOpen,true) -> ast.trace.set;
	 (ast.trace.onParse,true) -> ast.trace.set;
	 (ast.trace.parser,true) -> ast.trace.set;
	 (ast.trace.getBinding,true) -> ast.trace.set;
	 (ast.trace.getBindingMark,true) -> ast.trace.set;
	 *)
	ast; runtime.init; 
	BobsTab -> ast.expandToFullPath  -> runtime.parser.initialize;
     #);
   
   DoSystem:
     (# s: ^runtime.System;
	DoConstDecl:
	  (# decl: ^runtime.ConstDecl;
	  enter decl[]
	  do 
	     (decl.getName->NameDeclToText, decl.getValue->NumberToInteger)
	       -> GlobalBase.AddConst;
	  #);
     enter s[]
     do s.newscan
	(# 
	do 
	   (if current.symbol
	    // runtime.attr then current[] -> DoAttr;
	    // runtime.constdecl then current[] -> DoConstDecl;
	    else
	       '\nERROR: DoSystem: illegal current.symbol: ' -> puttext;
	       current.symbol -> putint;
	       newline;
	   if);
	   (* Reset register sizes *)
	   GlobalBase.scan
	   (# regOp:^AsmFile.Register
	   do (if current.op.type//AsmFile.RegisterType then
		  current.op[] -> regOp[];
		  longSize -> regOp.size;
	      if)
	   #);
	#)
     #);
   
   isOperandZero:
     (# op:^AsmFile.Operand; conOp:^AsmFile.Constant; result: @boolean
     enter op[]
     do
	(op.type = AsmFile.ConstantType) -> result;
	(if result then 
	    op[] -> conOp[];
	    (conOp.value = 0) -> result
	if)
     exit result
     #);
   isOperandOne:
     (# op:^AsmFile.Operand; conOp:^AsmFile.Constant; result: @boolean
     enter op[]
     do
	(op.type = AsmFile.ConstantType) -> result;
	(if result then 
	    op[] -> conOp[];
	    (conOp.value = 1) -> result
	if)
     exit result
     #);
   
   
   DoAttr:
     (# 
	LocalBase:@SymbolTable
	  (# element::< (# Type:@text; op:^AsmFile.Operand  #);
	     Add::<
	       (# Type: ^text; op:^AsmFile.Operand
	       enter (Type[], op[])
	       do Type -> e.Type; Op[]  -> e.Op[]
	       #)
	  #);
	LabelBase:@SymbolTable
	  (# element::< (# label:^AsmFile.Label; Defined:@boolean #);
	     Add::<
	       (# label:^AsmFile.Label; Defined: @boolean
	       enter (label[], Defined)
	       do label[] -> e.label[]; Defined -> e.Defined;
		  (* (if defined//true then 
		   *     name[] -> puttext; '/'->put; label.name[] -> puttext; ' defined.'->putline;
		   * if)
		   *)
	       #)
	  #);
	
	DoDeclaration:
	  (# decl: ^runtime.Declaration; e:^GlobalBase.element
	  enter decl[] 
	  do 
	     decl.getRegister -> NameApplToText -> GlobalBase.find -> e[];
	     (if e[]//NONE then
		 'DoDeclaration: Register = ' -> putText; 
		 decl.getRegister -> NameApplToText -> putText;
		 ' is not defined!' -> AstError
	      else
		 (if e.op.type//Asmfile.RegisterType then
		     (decl.getName -> NameDeclToText, decl.getType -> NameApplToText,
		     e.op[]) -> LocalBase.Add
		  else
		     'DoDeclaration: ' -> putText; 
		     decl.getRegister -> NameApplToText -> putText;
		     ' is not defined as a register!' -> AstError
		 if)
	     if) ;
	  #);
	
	DoImperative: 
	  (# 
	     
	     AddressToOperand:
	       (# addr:^runtime.Address; op:^AsmFile.Operand;
	       enter addr[]
	       do <<SLOT AddressToOperand: descriptor>>
	       exit op[]
	       #);
	     
	     
	     DoTransaction:
	       (# 
		  ObjectOfSource:
		    (# s:^runtime.Source;
		    do trans.getSource -> s[];
		    exit s.getReferenceOpt -> isOptionalPresent
		    #);
		  
		  DestinationOperation:
		    (# instruction: @integer; d: ^runtime.Destination;
		       op: ^runtime.Operation;
		    do
		       trans.getDestination -> d[];
		       (if (d.getOperationOpt -> isOptionalPresent)//true then
			   d.getOperationOpt -> op[];
			   (if op.symbol
			    // runtime.Plus     then 1 -> instruction
			    // runtime.Minus    then 2 -> instruction
			    // runtime.Division then 3 -> instruction
			    // runtime.Mult     then 4 -> instruction
			   if)
		       if)
		    exit instruction
		    #);
		  
		  SourceToOperand:
		    (# s:^runtime.Source
		    do trans.getSource -> s[]
		    exit s.getAddress -> AddressToOperand
		    #);
		  
		  DestinationToOperand:
		    (# d:^runtime.Destination
		    do trans.getDestination -> d[];
		    exit d.getAddress -> AddressToOperand
		    #);
		  
		  TwoPotens:
		    (# op:^AsmFile.Operand; conOp:^AsmFile.Constant;
		       result, value: @integer
		    enter op[]
		    do (if op.Type//AsmFile.ConstantType then
			   op[] -> conOp[]; conOp.value -> value;
			   loop: (if (value mod 2)//0 then
				     result + 1 -> result;
				     
				     value div 2 -> value;
				     restart loop
				  else
				     (if (value<>1)//true then -1 -> result if)
				 if)
			else
			   -1 -> result
		       if)
		    exit result
		    #);
		  
		  op1,op2:^AsmFile.Operand; result:@integer;
		  
		  trans: ^runtime.Transaction
	       enter trans[]
	       do
		  SourceToOperand -> op1[]; DestinationToOperand -> op2[];
		  (if ((op1.size=0) and (op2.size=0))// true then
		      'Size for next statement is not defined' -> AsmFile.CommentLine;
		      LongSize -> Op1.Size; LongSize -> Op2.Size
		   else
		      (if 0
		       //op1.size then op2.size -> op1.Size
		       //op2.size then op1.size -> op2.Size
		      if);
		      (if (op1.Size <> op2.Size)//true then
			  asmFile.newLine;
			  'Error: operand size mismatch' -> asmFile.putLine;
			  (*op1.Size -> op2.Size;
			  'Size for next instruction is based on source' -> AsmFile.CommentLine*)
		      if)
		  if);
		  (if ObjectOfSource// true then
		      (if DestinationOperation // 0 then
			  (op1[], op2[]) -> AsmFile.Lea
		       else
			  'error in operand use [] and operation.' -> putText; newLine
		      if);
		   else
		      (if DestinationOperation
		       // 0 then
			  (if (op1[] -> isOperandZero) then
			      op2[] -> AsmFile.Clear
			   else
			      (op1[], op2[]) -> AsmFile.Move
			  if)
		       // 1 then
			  (if (op1[] -> isOperandOne) then
			      op2[] -> AsmFile.Inc
			   else
			      (op1[], op2[]) -> AsmFile.Add
			  if)
		       // 2 then 
			  (if (op1[] -> isOperandOne) then
			      op2[] -> AsmFile.Dec
			   else
			      (op1[], op2[]) -> AsmFile.Subtract
			  if)
		       // 3 then                   
			  op1[] -> TwoPotens -> result;
			  (if true
			   // (result > 0) then result ->AsmFile.NewConstant -> op1[];
			      op2.size -> op1.size; (op1[],op2[]) -> AsmFile.ShiftRight
			   // (result < 0) then
			      (op1[], op2[]) -> AsmFile.Divide
			  if)
		       // 4 then
			  op1[] -> TwoPotens -> result;
			  (if true
			   // (result > 0) then result ->AsmFile.NewConstant -> op1[];
			      op2.size -> op1.size; (op1[],op2[]) -> AsmFile.ShiftLeft
			   // (result < 0) then
			      (op1[], op2[]) -> AsmFile.Multiply
			  if)
		      if)               
		  if);
	       #);
	     
	     GiveMeTheOnlyGoto:
	       (#
		  (* If there is only one imperative in the imperative-list and
		   * the imperatives is a goto statement, then return a
		   * reference to the gotoImp.
		   *)
		  imps:^runtime.Imperatives; goimp:^runtime.GotoImp;
		  imp:^runtime.Imperativ;
	       enter imps[]
	       do
		  (if imps.NoOfSons//1 then
		      imps.scan
		      (# do
			 current[] -> imp[];
			 (if imp.symbol//runtime.GotoImp then
			     imp[] -> goimp[]
			 if)
		      #)
		  if)
	       exit goimp[]
	       #);
	     
	     DoIfImp:
	       (# ifImp:^runtime.IfImp; exp:^runtime.IfExp; 
		  ge:^GlobalBase.element; goImp:^runtime.GotoImp;
		  op:^AsmFile.Operand; Comp:^runtime.Comp; CompOp:^runtime.CompOp;
		  sn:^runtime.SystemName; op1,op2:^AsmFile.Operand;
		  
		  flagcomp:
		    (* Return true if op1=FLAGS & op2=0 *)
		    (# op1,op2:^AsmFile.Operand; result: @boolean;
		       constOp:^AsmFile.Constant; LabelOp:^AsmFile.Label
		    enter (op1[],op2[])
		    do false -> result;
		       blok:
			 (# do
			    (if (op2.type<>AsmFile.ConstantType)//true then leave blok if);
			    op2[] -> constOp[];
			    (if (constOp.Value<>0)//true then leave blok if);
			    (if (op1.type<>AsmFile.LabelType)//true then leave blok if);
			    op1[] -> LabelOp[];
			    (if ('FLAGS'->LabelOp.name.equal)//false then leave blok if);
			    true -> result
			 #)
		    exit result
		    #);
		  ep:^runtime.ElsePart;
		  
	       enter ifImp[]
	       do 
		  ifImp.getIfExp -> exp[];
		  (if exp.symbol
		   //runtime.Systemname then
		      exp[] -> sn[]; 
		      (if (sn.getNameAppl -> NameApplToText -> SystemName.contains)//TRUE then
			  ifImp.getImperatives -> DoImperatives;
		       else
			  (if (ifImp.getElsePartOpt -> isOptionalPresent)//true then
			      ifImp.getElsePartOpt -> ep[];
			      ep.getImperatives -> DoImperatives;
			  if)
		      if)
		   //runtime.Comp then
		      (if (ifImp.getElsePartOpt -> isOptionalPresent)//true then
			  newLine;
			  'Warning: else part is only allowed using directives' 
			    -> putText; newLine;
		      if);
		      exp[] -> Comp[]; Comp.getCompOp -> CompOp[];
		      Comp.getOp1 -> AddressToOperand -> op1[];
		      Comp.getOp2 -> AddressToOperand -> op2[];
		      (if not ((op1[], op2[]) -> flagComp) then
			  (if (op2[] -> isOperandZero) then
			      op1[] -> AsmFile.Test
			   else
			      (if CompOp.symbol//runtime.InOp//runtime.OutOp then
				  (op1[], op2[]) -> AsmFile.CmpRange
			       else
				  (op1[], op2[]) -> AsmFile.Cmp
			      if)
			  if)
		      if);
		      ifImp.getImperatives -> GiveMeTheOnlyGoto -> goimp[];
		      (if goimp[]//NONE then
			  AsmFile.NewLocalLabel -> op[];
			  (if CompOp.symbol
			   //runtime.EqOp then op[] -> AsmFile.BranchNotEqual
			   //runtime.LtOp then op[] -> AsmFile.BranchGreaterThanOrEqual
			   //runtime.LeOp then op[] -> AsmFile.BranchGreaterThan
			   //runtime.GtOp then op[] -> AsmFile.BranchLessThanOrEqual
			   //runtime.GeOp then op[] -> AsmFile.BranchLessThan
			   //runtime.NeOp then op[] -> AsmFile.BranchEqual
			   //runtime.InOp then op[] -> AsmFile.BranchCS
			   //runtime.OutOp then op[] -> AsmFile.BranchCC
			  if);
			  Ifimp.getImperatives -> DoImperatives;              
			  op[] -> AsmFile.DefineLocalLabel
		       else
			  goImp.getAddress -> AddressToOperand -> op[];
			  (if CompOp.symbol
			   //runtime.EqOp then op[] -> AsmFile.BranchEqual
			   //runtime.LtOp then op[] -> AsmFile.BranchLessThan
			   //runtime.LeOp then op[] -> AsmFile.BranchLessThanOrEqual
			   //runtime.GtOp then op[] -> AsmFile.BranchGreaterThan
			   //runtime.GeOp then op[] -> AsmFile.BranchGreaterThanOrEqual
			   //runtime.NeOp then op[] -> AsmFile.BranchNotEqual
			   //runtime.InOp then op[] -> AsmFile.BranchCC
			   //runtime.OutOp then op[] -> AsmFile.BranchCS
			  if)
		      if)
		   else
		      (* Skip it for the moment. *)
		  if);
	       #);
	     
	     DoInstruction:
	       (# instr: ^runtime.Instruction;
		  gi:^runtime.GotoImp; 
		  popi:^runtime.PopImp;
		  pushi:^runtime.PushImp;
		  codei:^runtime.CodeImp;
		  str:^ast.string; 
		  calli:^runtime.CallImp; 
		  labi:^runtime.LabelImp; 
		  exti: ^runtime.ExtendImp; 
		  clri: ^runtime.ClearImp; 
		  op: ^AsmFile.Operand; 
		  ri:^runtime.return; 
		  di:^runtime.disp;
		  labOp:@AsmFile.Label;
	       enter instr[]
	       do
		  (if instr.symbol
		   // runtime.pushall then
		      AsmFile.PushAll;
		   // runtime.popall then
		      AsmFile.PopAll;
		   // runtime.return then
		      instr[] -> ri[];
		      (if (ri.getDispOpt -> isOptionalPresent)//true then
			  ri.getDispOpt -> di[];
			  di.getConst -> ConstToInteger -> AsmFile.ReturnDisp;
		       else
			  AsmFile.Return
		      if)
		   // runtime.Transaction then
		      instr[] -> DoTransaction
		   // runtime.IfImp then
		      instr[] -> DoIfImp
		   // runtime.GotoImp then
		      instr[] -> gi[];
		      gi.GetAddress -> AddressToOperand -> op[];
		      (if op.Type//AsmFile.RegisterType then
			  op[] -> AsmFile.Jump
		       else
			  op[] -> AsmFile.Branch
		      if)
		   // runtime.PopImp then
		      instr[] -> popi[];
		      (# theList:^runtime.AddressList
		      do popi.GetAddressList -> theList[];
			 theList.scan(# do current[] -> AddressToOperand -> AsmFile.pop #)
		      #)
		   // runtime.PushImp then
		      instr[]->pushi[];
		      (# theList:^runtime.AddressList
		      do pushi.GetAddressList -> theList[];
			 theList.scan(# do current[] -> AddressToOperand -> op[];
					(if op.Size//0 then 4 -> op.Size if); op[] -> AsmFile.push 
				     #)
		      #)
		   // runtime.CodeImp then
		      instr[] -> codei[];
		      codei.getString -> str[];
		      str.getText -> AsmFile.OutCode
		   // runtime.CallImp then
		      instr[] -> calli[];
		      calli.GetAddress -> AddressToOperand -> AsmFile.Call
		   // runtime.LabelImp then
		      instr[] -> labi[];
		      labi.getNameAppl -> NameApplToText -> labOp.name[];
		      labOp[] -> asmfile.exportlabel; labOp[] -> asmfile.definelabel;
		   // runtime.ExtendImp then
		      instr[] -> exti[];
		      exti.GetAddress -> AddressToOperand -> op[];
		      (if op.type//AsmFile.RegisterType then
			  op[] -> AsmFile.Extend
		       else
			  'Wrong type to extend, use only registers' -> putText; newLine
		      if)
		   // runtime.ClearImp then
		      instr[] -> clri[];
		      clri.GetAddress -> AddressToOperand -> op[];
		      (if op.type//AsmFile.RegisterType then
			  op[] -> AsmFile.Clear
		       else
			  'Wrong type to clear, use only registers' -> putText; newLine
		      if)
		   else
		      'Some thing is wrong: instruction kind do not match!' -> putText;
		      newLine
		  if)
	       #);
	     
	     i: ^runtime.Imperativ; labInstr: ^runtime.LabelInstruction;
	     ld: ^runtime.LabelDef; nd: ^ast.NameDecl; le:^LabelBase.element;
	     NameOp:^AsmFile.Label;
	  enter i[]
	  do
	     (if i.symbol
	      // runtime.LabelInstruction then
		 i[] -> labInstr[]; 
		 
		 (* Generate the label definition. *)
		 labInstr.getLabelDef -> ld[]; ld.getName -> nd[];
		 nd.getText -> LabelBase.find -> le[];
		 (if le[]//NONE then
		     AsmFile.NewLocalLabel -> NameOp[];
		     (nd.getText, NameOp[], true) -> LabelBase.Add;
		     NameOp[] -> AsmFile.DefineLocalLabel
		  else
		     le.label[] -> AsmFile.DefineLocalLabel; true -> le.Defined
		 if);
		 
		 (* Generate code for the instruction *)
		 labInstr.getInstruction -> DoInstruction
	      else
		 i[] -> DoInstruction           
	     if);
	  #);
	
	DoImperatives:
	  (# imps:^runtime.Imperatives
	  enter imps[]
	  do imps.scan
	     (# 
	     do (if current[] -> isOptionalPresent then 
		    current[] -> DoImperative
		if)
	     #)
	  #);
	
	DoDeclarations:
	  (# decls:^runtime.Declarations
	  enter decls[]
	  do decls.scan
	     (# 
	     do (if current[] -> isOptionalPresent then
		    (*current.kind -> putint; newline;*)
		    current[] -> DoDeclaration
		if)
	     #)
	  #);
	
	attribute: ^runtime.Attr; NameOp, labOp:^AsmFile.Label;
	ext:^runtime.ExtName; str: ^ast.String;
	desc:^runtime.descriptor;
	comment:^text;
	externalName: ^text
	  
     enter attribute[]
     do (if (attribute.getDescriptorOpt -> isOptionalPresent)//TRUE then
	    
	    AsmFile.newLine;
	    (if (attribute.getExtNameOpt -> isOptionalPresent)//TRUE then
		attribute.getExtNameOpt -> ext[];
		ext.getString -> str[]; str.getText -> externalName[]
	     else
		attribute.getName -> NameDeclToText -> externalName[]
	    if);
	    (4, externalName[], 0) -> AsmFile.NewLabel -> AsmFile.DefinePublic;
	    
	    (* define a local label at the entry point. *)
	    AsmFile.NewLocalLabel -> NameOp[];
	    (externalName[], NameOp[], true) -> LabelBase.Add;
	    NameOp[] -> AsmFile.DefineLocalLabel;
	    
	    attribute.getDescriptorOpt -> desc[];
	    
	    'Type is ' -> comment[];
	    attribute.getType -> NameApplToText -> comment.putText;
	    comment[] -> AsmFile.CommentLine;
	    
	    desc.getDeclarations -> DoDeclarations;
	    desc.getImperatives  -> DoImperatives;
	    
	    (* Check is local used labels are defined, otherwise report errors. *)
	    LabelBase.scan
	    (# do
	       (if Current.Defined//FALSE then
		   newLine; '# local label ' -> putText; Current.Name[] -> putText; 
		   ' in ' -> putText; attribute.getName -> NameDeclToText -> putText;
		   ' is used, but not defined ! ' -> putText; newLine
	       if)
	    #);
	    attribute.getName -> NameDeclToText -> AsmFile.EndRoutine;
	 else
	    (# declType, declName, extName: ^text;
	    do
	       (* this Attribute is a declaration of a CPROC or the like. *)
	       attribute.getType -> NameApplToText -> declType[];
	       attribute.getName -> NameDeclToText -> declName[];
	       (if (attribute.getExtNameOpt -> isOptionalPresent)//TRUE then
		   attribute.getExtNameOpt -> ext[];
		   ext.getString -> str[]; str.getText -> extName[]
		else
		   (if ('proc'  -> declType.equalNCS)//TRUE then
		       declName[] -> extName[];
		    else
		       declName[] -> asmfile.ToCName -> extName[]
		   if)
	       if);
	       (if TRUE
		// 'cproc' -> declType.equalNCS then
		   (declName[], extName[])    -> GlobalBase.AddCFunc -> AsmFile.ImportLabel
		// 'cvar'  -> declType.equalNCS then
		   AsmFile.BeginData;
		   (declName[], extName[], 4) -> GlobalBase.AddCVar -> AsmFile.ImportLabel;
		   AsmFile.EndData
		// 'proc'  -> declType.equalNCS then
		   (declName[], extName[]) -> GlobalBase.AddInternalFunc
	       if)
	    #)
	if);
     #);
   
   DoFragment:
     (#
	fg: ^ast.fragmentGroup; ff : ^ast.fragmentForm;
	List: [maxfragments]^text; End: @integer; NodeName: ^text;
	
	PleaseInsert:
	  (# path, basis: ^text; strippedbasis: @text;
	     i: @integer;
	  enter (path[], basis[])
	  do end+1 -> end;
	     basis -> strippedbasis;
	     ast.thepathhandler.directorychar
	       -> strippedbasis.findall(# do inx -> i #);
	     (i,strippedbasis.length) -> strippedbasis.delete;
	     (path[],strippedbasis[]) -> ast.thePathHandler.convertFilePath 
	       -> List[End][]
	  #);
	
	Target: @text;
	Found: @boolean;
	
     enter NodeName[]
     do
	'Opening '''->puttext; 
	(NodeName[], '') -> ast.thePathhandler.localpath -> puttext; 
	'''...'->putline;
	(NodeName[], screen[]) 
	  -> ast.top.open(# StartingParsing::< (# do 'Parsing...'->putline #)#)
	  -> fg[];
	(if fg[]//NONE then
	    'Not able to open: ' -> puttext; NodeName[] -> putText; newLine; Stop
	if);
	(fg[],'mdinclude') -> handleMDProp -> (Target, Found);
	(if Found// TRUE then (AsmFile.Machine, fg.Fullname) -> PleaseInsert if);
	
	(if trace then 'scanincludes: ' -> putline; if);
        fg.scanIncludes
	(# 
        do (if trace then
               'current.linkname: ' -> puttext; current.linkname[]->putline;
           if);
	   (current.linkname[], fg.FullName) -> PleaseInsert;
	#);
	fg.fragmentList.scan
	(# do
	   (if Current.type
	    // ast.groupType then (failure,'Groups not supported.') -> STOP
	    // ast.formType  then
	       '  translate: ' -> putText; Current.name[] -> putText;
	       Current.f[] -> ff[]; ff.root[] -> DoSystem;
	       newLine
	if) #);
	fg.close;
	(for i: End repeat List[i][] -> DoFragment for)
     #);

   HandleMDProp:
     (* Example:     objfile sun     './vaffel.o'
      hp      './filur.o'
      default './andre.o'
      (here theProp='objfile' is assummed).
      When the property value ('./vaffel.o' etc. depending on TargetMachine)
      is determined, PropertyAction.doString is called.
      *)
     (# FG: ^AST.FragmentGroup;
	theProp, TargetString: @text;
	foundSomething,machineMatch: @boolean;
	PropertyAction:< (# doString:< (# s: @text; enter s do inner #); #);
     enter(FG[],theProp)
     do
	tandem:
	  (for iteration:2 repeat     (* On first iteration look for exact matching
				       machine name. If not found try a second
				       round, looking for 'default'.
				       *)
	       FG.prop.ScanProp
	       (# doProp::<
		    (#
		    do prop.makelc;
		       (if true // theProp[] -> prop.equal then
			   (# thisMachine: @boolean;
			   do
			      ScanParameters
			      (# doName::<
				   (#
				   do
				      (if iteration//1 then
					  AsmFile.Machine->n.equal->thisMachine;
				       else
					  n.makeLC;
					  'default'->n.equal->thisMachine;
				      if);
				      machineMatch or thisMachine -> machineMatch;
				   #);
				 doString::<
				   (# R: ^propertyAction;
				   do
				      (if true//thisMachine then
					  S    -> TargetString;
					  true -> foundSomething;
				      if);
				   #);
			      #);
			      (if true//((not foundSomething) and
				  ((iteration=2) or machineMatch)) then
				  '**** Warning: '   -> puttext;
				  AsmFile.Machine -> puttext;
				  ' '           -> put;
				  theProp[]       -> puttext;
				  ' has no value in file' -> putline;
				  FG.fullname   -> putline;
			      if);
			   #);
		       if);
		    #);
	       #);
	       (if true//machineMatch then leave tandem if);
	  for);
     exit (TargetString, foundSomething)
     #);

   ExpandFileName:
     (# Name, ExpandedName: ^text
     enter Name[]
     do (Name[], '') -> ast.thePathHandler.convertFilePath -> ExpandedName[];
     exit ExpandedName[]
     #);

do
   InitAstEnv;
   GlobalBase.init;
   (if debug//true then 'debug' -> SystemName; 'With DEBUG.' -> screen.putline; if);
   'Using parser: ' -> screen.puttext;
   BobsTab -> screen.putline;
   <<SLOT ObjectBaseInit: descriptor>>;
   AsmFile.BeginCode;
   FileName[] -> ExpandFileName -> DoFragment
#)
