ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '~beta/basiclib/v1.5/file';
-- Lib:Attributes --

AssemblerFile: file
  (#
     ConstantType: (# exit 1 #);
     RegisterType: (# exit 2 #);
     LabelType:    (# exit 3 #);
     IndirectType: (# exit 4 #);
     DispIndirectType: (# exit 5 #);
     
     NoArea:(# exit 0 #); CodeArea:(# exit 1 #); DataArea:(# exit 2 #);
     StackArea:(# exit 3 #); AllArea:(# exit 4 #);
     
     ExternVar:  (# exit 111 #);
     ExternFunc: (# exit 222 #);
     InternalFunc: (# exit 333 #);
     
     private: @<<Slot PrivatePart:descriptor>>;
     
     Machine:
       (# name: ^text
       do <<SLOT Machine:descriptor>>
       exit name[]
       #);
     
     ToCName:
       (# t, name: ^text
       enter t[]
       do &text[]->name[]; t -> name;
          <<SLOT ToCName:descriptor>>
       exit name[]
       #);
     
     <<SLOT InstrLib:attributes>>;
     
     Operand:
       (# size,type:@integer;
          out:< object;
          clear:< object
       enter size
       do inner
       #);
     
     Constant: Operand
       (#
          value:@integer;
          out::<(# do <<SLOT OutConstant:descriptor>> #);
       #);
     
     NewConstant:
       (# conOp:^Constant; value:@integer
       enter value
       do &Constant[] -> conOp[]; value -> conOp.value; 
          ConstantType -> conOp.type
       exit conOp[]
       #);
     
     Register: Operand
       (#
          OutLong, OutWord, OutByte :^text; AreaType:@integer;
          usedAsIndex:@boolean;
          out::< (# do <<SLOT OutRegister:descriptor>> #);
          clear::<(#do <<SLOT clearRegister:descriptor>>#);
          clone:
            (# theCopy: ^Register
            do
               &Register[] -> theCopy[];
               size -> theCopy.size;
               type -> theCopy.Type;
               OutLong[] -> theCopy.OutLong[];
               OutWord[] -> theCopy.OutWord[];
               OutByte[] -> theCopy.OutByte[];
               AreaType -> theCopy.AreaType;
               usedAsIndex -> theCopy.usedAsIndex
            exit theCopy[]
            #)
       #);
     
     NewRegister:
       (# regOp:^Register; Size, areaType:@integer;
          OutLong, OutWord, OutByte:^text
       enter ( Size, OutLong[], OutWord[], OutByte[], areaType)
       do &Register[] -> regOp[];
          (if regop[] // none then 'Oops' -> putline; if);
          OutLong[] -> regOp.OutLong[];
          OutWord[] -> regOp.OutWord[]; 
          OutByte[] -> regOp.OutByte[]; 
          areaType -> regOp.areaType;
          size -> regOp.Size; 
          RegisterType -> regOp.type; 
       exit regOp[]
       #);
     
     Label: Operand
       (#
          name: ^text; subType:@integer; imported, exported:@ boolean;
          out::< (# do <<SLOT OutLabel:descriptor>> #)
       #);
     
     NewLabel:
       (# labOp:^Label; Size, subType:@integer; name:^text
       enter ( Size, name[], subType)
       do &Label[] -> labOp[]; name[] -> labOp.name[]; subType -> labOp.subType;
          size -> labOp.Size; LabelType -> labOp.type
       exit labOp[]
       #);
     
     Indirect: Operand
       (#
          reg: ^Register; offset, areaType:@integer;
          out::< (# do <<SLOT OutIndirect:descriptor>> #)
       #);
     
     NewIndirect:
       (# indOp:^Indirect; reg:^register; offset,size, areaType:@integer
       enter ( size, reg[], Offset, areaType)
       do &Indirect[] -> indOp[]; size -> indOp.size;
          reg.clone -> indOp.reg[];
          offset -> indOp.Offset; IndirectType -> indOp.type;
          areaType -> indOp.areaType;
       exit indOp[]
       #);
     
     DispIndirect: Operand
       (#
          baseRegister, dispRegister: ^Register;
          offset, scale, areaType: @integer;
          out::<(# do <<SLOT OutDispIndirect:descriptor>> #)
       #);
     
     NewDispIndirect:
       (# baseRegister, dispRegister: ^Register; size, offset,scale:@integer;
          dispOp:^DispIndirect; areaType:@integer;
       enter (size, baseRegister[], offset, dispRegister[], scale, areaType)
       do &DispIndirect[] -> dispOp[]; size -> dispOp.size;
          baseRegister.clone -> dispOp.baseRegister[];
          dispRegister.clone -> dispOp.dispRegister[];
          offset -> dispOp.offset; scale -> dispOp.scale;
          areaType -> dispOp.areaType;DispIndirectType -> dispOp.type
       exit dispOp[]
       #);
     
     NulOperator:
       (# do
          <<SLOT NulOperatorBeforeInner:descriptor>>;
          inner; 
          <<SLOT NulOperatorAfterInner:descriptor>>
       #);
     
     SingleOperator:
       (# op:^Operand;
          <<SLOT SingleOperatorLib:attributes>>
       enter op[]
       do <<SLOT SingleOperatorBeforeInner:descriptor>>;
          inner;
          <<SLOT SingleOperatorAfterInner:descriptor>>
       #);
     
     DualOperator:
       (# op1,op2:^Operand;
          <<SLOT DualOperatorLib:attributes>>
       enter (op1[],op2[])
       do <<SLOT DualOperatorBeforeInner:descriptor>>;
          inner;
          <<SLOT DualOperatorAfterInner:descriptor>>
       #);
     
     move:     DualOperator(# do <<SLOT MoveInstr:descriptor>> #);
     lea:      DualOperator(# do <<SLOT LeaInstr:descriptor>> #);
     add:      DualOperator(# do <<SLOT AddInstr:descriptor>> #);
     subtract: DualOperator(# do <<SLOT SubtractInstr:descriptor>> #);
     inc:      SingleOperator(# do <<SLOT IncInstr:descriptor>> #);
     dec:      SingleOperator(# do <<SLOT DecInstr:descriptor>> #);
     divide:   DualOperator(# do <<SLOT DivideInstr:descriptor>> #);
     multiply: DualOperator(# do <<SLOT MultiplyInstr:descriptor>> #);
     shiftRight: DualOperator(# do <<SLOT shiftRightInstr:descriptor>> #);
     shiftLeft:  DualOperator(# do <<SLOT shiftLeftInstr:descriptor>> #);
     
     extend: SingleOperator
       (# do <<SLOT ExtendInstr:descriptor>> #);
     
     jump: SingleOperator
       (# do <<SLOT JumpInstr:descriptor>> #);
     
     branch: SingleOperator
       (# do <<SLOT BranchInstr:descriptor>> #);
     
     branchEqual:  SingleOperator
       (# do <<SLOT BranchEqualInstr:descriptor>> #);
     
     branchNotEqual:  SingleOperator
       (# do <<SLOT BranchNotEqualInstr:descriptor>> #);
     
     branchLessThan:  SingleOperator
       (# do <<SLOT BranchLessThanInstr:descriptor>> #);
     
     branchLessThanOrEqual:  SingleOperator
       (# do <<SLOT BranchLessThanOrEqualInstr:descriptor>> #);
     
     branchGreaterThan:  SingleOperator
       (# do <<SLOT BranchGreaterThanInstr:descriptor>> #);
     
     branchGreaterThanOrEqual:  SingleOperator
       (# do <<SLOT BranchGreaterThanOrEqualInstr:descriptor>> #);
     
     branchCC:  SingleOperator
       (# do <<SLOT BranchCCInstr:descriptor>> #);
     
     branchCS:  SingleOperator
       (# do <<SLOT BranchCSInstr:descriptor>> #);
     
     Call:  SingleOperator(# do <<SLOT CallInstr:descriptor>> #);
     
     pop:  SingleOperator(# do <<SLOT PopInstr:descriptor>> #);
     
     push:  SingleOperator(# do <<SLOT PushInstr:descriptor>> #);
     
     clear:  SingleOperator(# do <<SLOT ClearInstr:descriptor>> #);
     
     test:  SingleOperator(# do <<SLOT TestInstr:descriptor>> #);
     
     Cmp:  DualOperator
       (# do <<SLOT CmpInstr:descriptor>> #);
     
     CmpRange:  DualOperator
       (# do <<SLOT CmpRangeInstr:descriptor>> #);
     
     PushAll: NulOperator
       (# do <<SLOT PushAll:descriptor>> #);
     
     PopAll: NulOperator
       (# do <<SLOT PopAll:descriptor>> #);
     
     return: NulOperator
       (# do <<SLOT Return:descriptor>> #);
     
     returnDisp: NulOperator
       (# disp: @integer enter disp do <<SLOT ReturnDisp:descriptor>> #);
     
     OutCode:
       (# line: ^text;
       enter line[]
       do <<SLOT OutCode:descriptor>>
       #);
     
     Prolog:(# do <<SLOT Prolog:descriptor>> #);
     Epilog:(# do <<SLOT Epilog:descriptor>> #);
     
     DefinePublic:
       (# labOp:^Label enter labOp[] do <<SLOT DefinePublic:descriptor>> #);
     
     LabelNo:@integer;
     
     DefineLocalLabel:
       (# op:^Operand enter op[] do <<SLOT DefineLocalLabel:descriptor>> #);
     
     NewLocalLabel:
       (# op:^Label do <<SLOT NewLocalLabel:descriptor>> exit op[] #);
     
     ExportLabel:
       (# labOp:^Label enter labOp[] do <<SLOT ExportLabel:descriptor>> #);
     
     ImportLabel:
       (# labOp:^Label enter labOp[] do <<SLOT ImportLabel:descriptor>> #);
     
     DefineLabel:
       (# labOp:^Label enter labOp[] do <<SLOT DefineLabel:descriptor>> #);
     
     CommentLine:
       (# comment: ^text enter comment[] do <<SLOT CommentLine:descriptor>> #);
     
     BeginCode: (# do <<SLOT BeginCode:descriptor>> #);
     EndCode:   (# do <<SLOT EndCode:descriptor>> #);
     
     BeginData: (# do <<SLOT BeginData:descriptor>> #);
     EndData:   (# do <<SLOT EndData:descriptor>> #);
     
     EndRoutine: (# name: ^text; enter name[] do <<SLOT EndRoutine:descriptor>> #);
  #)
