ORIGIN 'runtimetraverse';

--LIB: attributes--

GrammarPath: (# exit '~beta/betarun/GEN/GRAMMAR/runtime' #);
BobsTab:     (# exit '~beta/betarun/GEN/GRAMMAR/runtime-parser.btab' #);

-- do_System_body: DoPart --
do S.newscan
   (#
   do current[] -> do_Att;
   #);

-- do_Att_body: DoPart --
do (if A.symbol
    // runtime.Attr then
       A[] -> do_Attr;
    // runtime.ConstDecl then
       A[] -> do_ConstDecl;
    // runtime.DefineDecl then
       A[] -> do_DefineDecl;
    if);

-- do_Attr_body: DoPart --
do A.getName -> do_NameDecl;
   A.getType -> do_NameAppl;
   A.getExtNameOpt -> do_ExtNameOpt;
   A.getDescriptorOpt -> do_DescriptorOpt;

-- do_ConstDecl_body: DoPart --
do C.getName -> do_NameDecl;
   C.getvalue -> do_Number;

-- do_DefineDecl_body: DoPart --
do D.getName -> do_NameDecl;

-- do_ExtNameOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_ExtName;
   if);

-- do_ExtName_body: DoPart --
do E.getstring -> do_string;

-- do_DescriptorOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Descriptor;
   if);

-- do_Descriptor_body: DoPart --
do D.getDeclarations -> do_Declarations;
   D.getImperatives -> do_Imperatives;

-- do_Declarations_body: DoPart --
do D.newscan
   (#
   do current[] -> do_Declaration;
   #);

-- do_DeclarationOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Declaration;
   if);

-- do_Declaration_body: DoPart --
do D.getName -> do_NameDecl;
   D.getType -> do_NameAppl;
   D.getRegister -> do_NameAppl;

-- do_Imperatives_body: DoPart --
do I.newscan
   (#
   do current[] -> do_Imperativ;
   #);

-- do_ImperativOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Imperativ;
   if);

-- do_Imperativ_body: DoPart --
do (if I.symbol
    // runtime.LabelInstruction then
       I[] -> do_LabelInstruction;
       (* sub-alternation <Instruction>: *)
    // runtime.Transaction then
       I[] -> do_Transaction;
    // runtime.IfImp then
       I[] -> do_IfImp;
    // runtime.GotoImp then
       I[] -> do_GotoImp;
    // runtime.CallImp then
       I[] -> do_CallImp;
    // runtime.LabelImp then
       I[] -> do_LabelImp;
    // runtime.PushImp then
       I[] -> do_PushImp;
    // runtime.PopImp then
       I[] -> do_PopImp;
    // runtime.CodeImp then
       I[] -> do_CodeImp;
    // runtime.Return then
       I[] -> do_Return;
    // runtime.ExtendImp then
       I[] -> do_ExtendImp;
    // runtime.ClearImp then
       I[] -> do_ClearImp;
    // runtime.PushAll then
       I[] -> do_PushAll;
    // runtime.PopAll then
       I[] -> do_PopAll;
    // runtime.AsmComment then
       I[] -> do_AsmComment;
       (* End sub-alternation <Instruction> *)
    if);

-- do_LabelInstruction_body: DoPart --
do L.getLabelDef -> do_LabelDef;
   L.getInstruction -> do_Instruction;

-- do_LabelDef_body: DoPart --
do L.getName -> do_NameDecl;

-- do_Instruction_body: DoPart --
do (if I.symbol
    // runtime.Transaction then
       I[] -> do_Transaction;
    // runtime.IfImp then
       I[] -> do_IfImp;
    // runtime.GotoImp then
       I[] -> do_GotoImp;
    // runtime.CallImp then
       I[] -> do_CallImp;
    // runtime.LabelImp then
       I[] -> do_LabelImp;
    // runtime.PushImp then
       I[] -> do_PushImp;
    // runtime.PopImp then
       I[] -> do_PopImp;
    // runtime.CodeImp then
       I[] -> do_CodeImp;
    // runtime.Return then
       I[] -> do_Return;
    // runtime.ExtendImp then
       I[] -> do_ExtendImp;
    // runtime.ClearImp then
       I[] -> do_ClearImp;
    // runtime.PushAll then
       I[] -> do_PushAll;
    // runtime.PopAll then
       I[] -> do_PopAll;
    // runtime.AsmComment then
       I[] -> do_AsmComment;
    if);

-- do_IfImp_body: DoPart --
do I.getIfExp -> do_IfExp;
   I.getImperatives -> do_Imperatives;
   I.getElsePartOpt -> do_ElsePartOpt;

-- do_ElsePartOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_ElsePart;
   if);

-- do_ElsePart_body: DoPart --
do E.getImperatives -> do_Imperatives;

-- do_GotoImp_body: DoPart --
do G.getAddress -> do_Address;

-- do_PushImp_body: DoPart --
do P.getAddressList -> do_AddressList;

-- do_PopImp_body: DoPart --
do P.getAddressList -> do_AddressList;

-- do_CallImp_body: DoPart --
do C.getAddress -> do_Address;

-- do_LabelImp_body: DoPart --
do L.getNameAppl -> do_NameAppl;

-- do_ExtendImp_body: DoPart --
do E.getAddress -> do_Address;

-- do_ClearImp_body: DoPart --
do C.getAddress -> do_Address;

-- do_CodeImp_body: DoPart --
do C.getstring -> do_string;

-- do_PushAll_body: DoPart --
do 

-- do_PopAll_body: DoPart --
do 

-- do_AsmComment_body: DoPart --
do A.getString -> do_String;

-- do_Return_body: DoPart --
do R.getDispOpt -> do_DispOpt;

-- do_DispOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Disp;
   if);

-- do_Disp_body: DoPart --
do D.getConst -> do_Const;

-- do_IfExp_body: DoPart --
do (if I.symbol
    // runtime.Conditional then
       I[] -> do_Conditional;
    // runtime.Comp then
       I[] -> do_Comp;
    if);

-- do_Comp_body: DoPart --
do C.getOp1 -> do_Address;
   C.getCompOp -> do_CompOp;
   C.getOp2 -> do_Address;

-- do_CompOp_body: DoPart --
do (if C.symbol
    // runtime.EqOp then
       C[] -> do_EqOp;
    // runtime.LtOp then
       C[] -> do_LtOp;
    // runtime.LeOp then
       C[] -> do_LeOp;
    // runtime.GtOp then
       C[] -> do_GtOp;
    // runtime.GeOp then
       C[] -> do_GeOp;
    // runtime.NeOp then
       C[] -> do_NeOp;
    // runtime.InOp then
       C[] -> do_InOp;
    // runtime.OutOp then
       C[] -> do_OutOp;
    // runtime.AboveOp then
       C[] -> do_AboveOp;
    // runtime.BelowOp then
       C[] -> do_BelowOp;
    if);

-- do_EqOp_body: DoPart --
do 

-- do_LtOp_body: DoPart --
do 

-- do_LeOp_body: DoPart --
do 

-- do_GtOp_body: DoPart --
do 

-- do_GeOp_body: DoPart --
do 

-- do_NeOp_body: DoPart --
do 

-- do_InOp_body: DoPart --
do 

-- do_OutOp_body: DoPart --
do 

-- do_AboveOp_body: DoPart --
do 

-- do_BelowOp_body: DoPart --
do 

-- do_Transaction_body: DoPart --
do T.getSource -> do_Source;
   T.getDestination -> do_Destination;

-- do_Source_body: DoPart --
do S.getAddress -> do_Address;
   S.getReferenceOpt -> do_ReferenceOpt;

-- do_Destination_body: DoPart --
do D.getAddress -> do_Address;
   D.getOperationOpt -> do_OperationOpt;

-- do_OperationOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Operation;
   if);

-- do_Operation_body: DoPart --
do (if O.symbol
    // runtime.Plus then
       O[] -> do_Plus;
    // runtime.Minus then
       O[] -> do_Minus;
    // runtime.Division then
       O[] -> do_Division;
    // runtime.Mult then
       O[] -> do_Mult;
    // runtime.Align then
       O[] -> do_Align;
    if);

-- do_Plus_body: DoPart --
do 

-- do_Minus_body: DoPart --
do 

-- do_Division_body: DoPart --
do 

-- do_Mult_body: DoPart --
do 

-- do_Align_body: DoPart --
do 

-- do_AddressList_body: DoPart --
do A.newscan
   (#
   do current[] -> do_Address;
   #);

-- do_ReferenceOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Reference;
   if);

-- do_Reference_body: DoPart --
do 

-- do_Address_body: DoPart --
do (if A.symbol
    // runtime.AddressNumber then
       A[] -> do_AddressNumber;
    // runtime.Name then
       A[] -> do_Name;
    // runtime.Remote then
       A[] -> do_Remote;
    // runtime.Indexed then
       A[] -> do_Indexed;
    if);

-- do_AddressNumber_body: DoPart --
do A.getNumber -> do_Number;

-- do_Name_body: DoPart --
do N.getNameAppl -> do_NameAppl;
   N.getSizeOpt -> do_SizeOpt;

-- do_Conditional_body: DoPart --
do C.getNameAppl -> do_NameAppl;

-- do_Remote_body: DoPart --
do R.getName -> do_NameAppl;
   R.getExtension -> do_NameAppl;
   R.getSizeOpt -> do_SizeOpt;

-- do_Indexed_body: DoPart --
do I.getNameAppl -> do_NameAppl;
   I.getIndexor -> do_Indexor;
   I.getSizeOpt -> do_SizeOpt;

-- do_SizeOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Size;
   if);

-- do_Size_body: DoPart --
do (if S.symbol
    // runtime.ByteSize then
       S[] -> do_ByteSize;
    // runtime.WordSize then
       S[] -> do_WordSize;
    // runtime.LongSize then
       S[] -> do_LongSize;
    if);

-- do_ByteSize_body: DoPart --
do 

-- do_WordSize_body: DoPart --
do 

-- do_LongSize_body: DoPart --
do 

-- do_Indexor_body: DoPart --
do (if I.symbol
    // runtime.IndexNumber then
       I[] -> do_IndexNumber;
    // runtime.IndexRegister then
       I[] -> do_IndexRegister;
    // runtime.IndexNumAndReg then
       I[] -> do_IndexNumAndReg;
    if);

-- do_IndexNumber_body: DoPart --
do I.getNumber -> do_Number;

-- do_IndexRegister_body: DoPart --
do I.getNameAppl -> do_NameAppl;
   I.getScaleOpt -> do_ScaleOpt;

-- do_IndexNumAndReg_body: DoPart --
do I.getNumber -> do_Number;
   I.getNameAppl -> do_NameAppl;
   I.getScaleOpt -> do_ScaleOpt;

-- do_ScaleOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_Scale;
   if);

-- do_Scale_body: DoPart --
do S.getConst -> do_Const;

-- do_Number_body: DoPart --
do N.getMinusOpt -> do_MinusOpt;
   N.getConst -> do_Const;

-- do_MinusOpt_body: DoPart --
do (if a.kind<>ast.kinds.optional then
       a[] -> do_MinusSign;
   if);

-- do_MinusSign_body: DoPart --
do 

-- runtime_init_body: DoPart --
do ast.astLevelInit;
   (* Alternative to using findGrammar: *)
   ('runtime', '.run', GrammarPath->ast.expandToFullPath)
     -> ast.registergrammar;
   runtime.init; 
   BobsTab -> ast.expandToFullPath -> runtime.parser.initialize
   (# #);
