ORIGIN 'runtimecfl';
BODY 'runtimetraversebody';

(* Skeleton file for traversal of ASTs based on
 * grammar 'runtime'.
 * Take a copy of this file and fill out the do-parts.
 * Do NOT edit this file directly as it will be overwritten
 * when the grammar is processed again.
 *)
--LIB: attributes--

runtime_traverse: 
  (# ast: @astInterface (* An instance of the AST interface *);
     runtime: @ast.runtime;

     do_System: (* list *)
       (# S: ^runtime.System
       enter S[]
       <<SLOT do_System_body: DoPart>>
       #);
     do_Att: (* alternation *)
       (# A: ^runtime.Att
       enter A[]
       <<SLOT do_Att_body: DoPart>>
       #);
     do_Attr: (* cons *)
       (# A: ^runtime.Attr
       enter A[]
       <<SLOT do_Attr_body: DoPart>>
       #);
     do_ConstDecl: (* cons *)
       (# C: ^runtime.ConstDecl
       enter C[]
       <<SLOT do_ConstDecl_body: DoPart>>
       #);
     do_DefineDecl: (* cons *)
       (# D: ^runtime.DefineDecl
       enter D[]
       <<SLOT do_DefineDecl_body: DoPart>>
       #);
     do_ExtNameOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ExtNameOpt_body: DoPart>>
       #);
     do_ExtName: (* cons *)
       (# E: ^runtime.ExtName
       enter E[]
       <<SLOT do_ExtName_body: DoPart>>
       #);
     do_DescriptorOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DescriptorOpt_body: DoPart>>
       #);
     do_Descriptor: (* cons *)
       (# D: ^runtime.Descriptor
       enter D[]
       <<SLOT do_Descriptor_body: DoPart>>
       #);
     do_Declarations: (* list *)
       (# D: ^runtime.Declarations
       enter D[]
       <<SLOT do_Declarations_body: DoPart>>
       #);
     do_DeclarationOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DeclarationOpt_body: DoPart>>
       #);
     do_Declaration: (* cons *)
       (# D: ^runtime.Declaration
       enter D[]
       <<SLOT do_Declaration_body: DoPart>>
       #);
     do_Imperatives: (* list *)
       (# I: ^runtime.Imperatives
       enter I[]
       <<SLOT do_Imperatives_body: DoPart>>
       #);
     do_ImperativOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ImperativOpt_body: DoPart>>
       #);
     do_Imperativ: (* alternation *)
       (# I: ^runtime.Imperativ
       enter I[]
       <<SLOT do_Imperativ_body: DoPart>>
       #);
     do_LabelInstruction: (* cons *)
       (# L: ^runtime.LabelInstruction
       enter L[]
       <<SLOT do_LabelInstruction_body: DoPart>>
       #);
     do_LabelDef: (* cons *)
       (# L: ^runtime.LabelDef
       enter L[]
       <<SLOT do_LabelDef_body: DoPart>>
       #);
     do_Instruction: (* alternation *)
       (# I: ^runtime.Instruction
       enter I[]
       <<SLOT do_Instruction_body: DoPart>>
       #);
     do_IfImp: (* cons *)
       (# I: ^runtime.IfImp
       enter I[]
       <<SLOT do_IfImp_body: DoPart>>
       #);
     do_ElsePartOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ElsePartOpt_body: DoPart>>
       #);
     do_ElsePart: (* cons *)
       (# E: ^runtime.ElsePart
       enter E[]
       <<SLOT do_ElsePart_body: DoPart>>
       #);
     do_GotoImp: (* cons *)
       (# G: ^runtime.GotoImp
       enter G[]
       <<SLOT do_GotoImp_body: DoPart>>
       #);
     do_PushImp: (* cons *)
       (# P: ^runtime.PushImp
       enter P[]
       <<SLOT do_PushImp_body: DoPart>>
       #);
     do_PopImp: (* cons *)
       (# P: ^runtime.PopImp
       enter P[]
       <<SLOT do_PopImp_body: DoPart>>
       #);
     do_CallImp: (* cons *)
       (# C: ^runtime.CallImp
       enter C[]
       <<SLOT do_CallImp_body: DoPart>>
       #);
     do_LabelImp: (* cons *)
       (# L: ^runtime.LabelImp
       enter L[]
       <<SLOT do_LabelImp_body: DoPart>>
       #);
     do_ExtendImp: (* cons *)
       (# E: ^runtime.ExtendImp
       enter E[]
       <<SLOT do_ExtendImp_body: DoPart>>
       #);
     do_ClearImp: (* cons *)
       (# C: ^runtime.ClearImp
       enter C[]
       <<SLOT do_ClearImp_body: DoPart>>
       #);
     do_CodeImp: (* cons *)
       (# C: ^runtime.CodeImp
       enter C[]
       <<SLOT do_CodeImp_body: DoPart>>
       #);
     do_PushAll: (* cons *)
       (# P: ^runtime.PushAll
       enter P[]
       <<SLOT do_PushAll_body: DoPart>>
       #);
     do_PopAll: (* cons *)
       (# P: ^runtime.PopAll
       enter P[]
       <<SLOT do_PopAll_body: DoPart>>
       #);
     do_AsmComment: (* cons *)
       (# A: ^runtime.AsmComment
       enter A[]
       <<SLOT do_AsmComment_body: DoPart>>
       #);
     do_Return: (* cons *)
       (# R: ^runtime.Return
       enter R[]
       <<SLOT do_Return_body: DoPart>>
       #);
     do_DispOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_DispOpt_body: DoPart>>
       #);
     do_Disp: (* cons *)
       (# D: ^runtime.Disp
       enter D[]
       <<SLOT do_Disp_body: DoPart>>
       #);
     do_IfExp: (* alternation *)
       (# I: ^runtime.IfExp
       enter I[]
       <<SLOT do_IfExp_body: DoPart>>
       #);
     do_Comp: (* cons *)
       (# C: ^runtime.Comp
       enter C[]
       <<SLOT do_Comp_body: DoPart>>
       #);
     do_CompOp: (* alternation *)
       (# C: ^runtime.CompOp
       enter C[]
       <<SLOT do_CompOp_body: DoPart>>
       #);
     do_EqOp: (* cons *)
       (# E: ^runtime.EqOp
       enter E[]
       <<SLOT do_EqOp_body: DoPart>>
       #);
     do_LtOp: (* cons *)
       (# L: ^runtime.LtOp
       enter L[]
       <<SLOT do_LtOp_body: DoPart>>
       #);
     do_LeOp: (* cons *)
       (# L: ^runtime.LeOp
       enter L[]
       <<SLOT do_LeOp_body: DoPart>>
       #);
     do_GtOp: (* cons *)
       (# G: ^runtime.GtOp
       enter G[]
       <<SLOT do_GtOp_body: DoPart>>
       #);
     do_GeOp: (* cons *)
       (# G: ^runtime.GeOp
       enter G[]
       <<SLOT do_GeOp_body: DoPart>>
       #);
     do_NeOp: (* cons *)
       (# N: ^runtime.NeOp
       enter N[]
       <<SLOT do_NeOp_body: DoPart>>
       #);
     do_InOp: (* cons *)
       (# I: ^runtime.InOp
       enter I[]
       <<SLOT do_InOp_body: DoPart>>
       #);
     do_OutOp: (* cons *)
       (# O: ^runtime.OutOp
       enter O[]
       <<SLOT do_OutOp_body: DoPart>>
       #);
     do_AboveOp: (* cons *)
       (# A: ^runtime.AboveOp
       enter A[]
       <<SLOT do_AboveOp_body: DoPart>>
       #);
     do_BelowOp: (* cons *)
       (# B: ^runtime.BelowOp
       enter B[]
       <<SLOT do_BelowOp_body: DoPart>>
       #);
     do_Transaction: (* cons *)
       (# T: ^runtime.Transaction
       enter T[]
       <<SLOT do_Transaction_body: DoPart>>
       #);
     do_Source: (* cons *)
       (# S: ^runtime.Source
       enter S[]
       <<SLOT do_Source_body: DoPart>>
       #);
     do_Destination: (* cons *)
       (# D: ^runtime.Destination
       enter D[]
       <<SLOT do_Destination_body: DoPart>>
       #);
     do_OperationOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_OperationOpt_body: DoPart>>
       #);
     do_Operation: (* alternation *)
       (# O: ^runtime.Operation
       enter O[]
       <<SLOT do_Operation_body: DoPart>>
       #);
     do_Plus: (* cons *)
       (# P: ^runtime.Plus
       enter P[]
       <<SLOT do_Plus_body: DoPart>>
       #);
     do_Minus: (* cons *)
       (# M: ^runtime.Minus
       enter M[]
       <<SLOT do_Minus_body: DoPart>>
       #);
     do_Division: (* cons *)
       (# D: ^runtime.Division
       enter D[]
       <<SLOT do_Division_body: DoPart>>
       #);
     do_Mult: (* cons *)
       (# M: ^runtime.Mult
       enter M[]
       <<SLOT do_Mult_body: DoPart>>
       #);
     do_Align: (* cons *)
       (# A: ^runtime.Align
       enter A[]
       <<SLOT do_Align_body: DoPart>>
       #);
     do_AddressList: (* list *)
       (# A: ^runtime.AddressList
       enter A[]
       <<SLOT do_AddressList_body: DoPart>>
       #);
     do_ReferenceOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ReferenceOpt_body: DoPart>>
       #);
     do_Reference: (* cons *)
       (# R: ^runtime.Reference
       enter R[]
       <<SLOT do_Reference_body: DoPart>>
       #);
     do_Address: (* alternation *)
       (# A: ^runtime.Address
       enter A[]
       <<SLOT do_Address_body: DoPart>>
       #);
     do_AddressNumber: (* cons *)
       (# A: ^runtime.AddressNumber
       enter A[]
       <<SLOT do_AddressNumber_body: DoPart>>
       #);
     do_Name: (* cons *)
       (# N: ^runtime.Name
       enter N[]
       <<SLOT do_Name_body: DoPart>>
       #);
     do_Conditional: (* cons *)
       (# C: ^runtime.Conditional
       enter C[]
       <<SLOT do_Conditional_body: DoPart>>
       #);
     do_Remote: (* cons *)
       (# R: ^runtime.Remote
       enter R[]
       <<SLOT do_Remote_body: DoPart>>
       #);
     do_Indexed: (* cons *)
       (# I: ^runtime.Indexed
       enter I[]
       <<SLOT do_Indexed_body: DoPart>>
       #);
     do_SizeOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_SizeOpt_body: DoPart>>
       #);
     do_Size: (* alternation *)
       (# S: ^runtime.Size
       enter S[]
       <<SLOT do_Size_body: DoPart>>
       #);
     do_ByteSize: (* cons *)
       (# B: ^runtime.ByteSize
       enter B[]
       <<SLOT do_ByteSize_body: DoPart>>
       #);
     do_WordSize: (* cons *)
       (# W: ^runtime.WordSize
       enter W[]
       <<SLOT do_WordSize_body: DoPart>>
       #);
     do_LongSize: (* cons *)
       (# L: ^runtime.LongSize
       enter L[]
       <<SLOT do_LongSize_body: DoPart>>
       #);
     do_Indexor: (* alternation *)
       (# I: ^runtime.Indexor
       enter I[]
       <<SLOT do_Indexor_body: DoPart>>
       #);
     do_IndexNumber: (* cons *)
       (# I: ^runtime.IndexNumber
       enter I[]
       <<SLOT do_IndexNumber_body: DoPart>>
       #);
     do_IndexRegister: (* cons *)
       (# I: ^runtime.IndexRegister
       enter I[]
       <<SLOT do_IndexRegister_body: DoPart>>
       #);
     do_IndexNumAndReg: (* cons *)
       (# I: ^runtime.IndexNumAndReg
       enter I[]
       <<SLOT do_IndexNumAndReg_body: DoPart>>
       #);
     do_ScaleOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_ScaleOpt_body: DoPart>>
       #);
     do_Scale: (* cons *)
       (# S: ^runtime.Scale
       enter S[]
       <<SLOT do_Scale_body: DoPart>>
       #);
     do_Number: (* cons *)
       (# N: ^runtime.Number
       enter N[]
       <<SLOT do_Number_body: DoPart>>
       #);
     do_MinusOpt: (* optional *)
       (# a: ^astinterface.ast;
       enter a[]
       <<SLOT do_MinusOpt_body: DoPart>>
       #);
     do_MinusSign: (* cons *)
       (# M: ^runtime.MinusSign
       enter M[]
       <<SLOT do_MinusSign_body: DoPart>>
       #);

     do_nameDecl: (* lexem *)
       (# n: ^astinterface.nameDecl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_nameAppl: (* lexem *)
       (# n: ^astinterface.nameAppl;
          getText: (# exit n.getText #);
       enter n[] 
       do INNER;
       #);
     do_const: (* lexem *)
       (# c: ^astinterface.const;
          getText: (# exit c.getText #);
          getValue: (# exit c.getValue #);
       enter c[] 
       do INNER;
       #);
     do_string: (* lexem *)
       (# s: ^astinterface.string;
          getText: (# exit s.getText #);
       enter s[] 
       do INNER;
       #);
     init: (* Initialization of astLevel and parser *)
       (# 
       <<SLOT runtime_init_body: DoPart>>
       #);
  #);
