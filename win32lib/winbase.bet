ORIGIN 'windef';
(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)
INCLUDE 
'errorhandling'
'~beta/sysutils/cstring'
'winnt';

-- Lib: Attributes --

FORMAT_MESSAGE_ALLOCATE_BUFFER: (#  exit 0x00000100 #);
FORMAT_MESSAGE_FROM_SYSTEM: (#  exit 0x00001000 #);
FormatMessage: external
  (# dwFlags: @integer; (* source and processing options *)
     lpSource: @integer; (* pointer to  message source *)
     dwMessageId: @integer; (* requested message identifier *)
     dwLanguageId: @integer; (* language identifier for requested message *)
     lpBuffer: @integer; (* pointer to message buffer *)
     nSize: @integer; (* maximum size of message buffer *)
     Arguments: @integer; (* address of array of message inserts *)
     result: @integer;
  enter (dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments)
  do 'FormatMessageA'->callStd; 
  exit result
  #);

getErrorMessage:
  (# errorNo: @integer;
     errorMsg: ^text;
     
     dwFlags: @integer;
     errorMsgCstr: @cString;
     formatRes: @integer;
  enter errorNo
  do 
     FORMAT_MESSAGE_FROM_SYSTEM->dwFlags;
     256->errorMsgCstr.init;
     (dwFlags,0,errorNo,(LANG_NEUTRAL,SUBLANG_DEFAULT)->MAKELANGID,
     errorMsgCstr,256,0)->FormatMessage->formatRes;
     (if formatRes = 0 then
         'FormatMessage failed. Error= '->screen.putText;
         GetLastError->screen.putInt;
         screen.newline;
         
     if);
     errorMsgCstr.get->errorMsg[];
     errorMsgCstr.free;
  exit errorMsg[]
  #);

(* BOOL WINAPI GetComputerNameA (LPSTR lpBuffer, LPDWORD nSize ); *)
GetComputerName: external
  (# name: @integer; 
     length: @integer;
     result: @boolean; 
  enter (name, length)
  do 'GetComputerNameA' -> callStd;
  exit result
  #);

(* BOOL WINAPI SetComputerNameA (LPCSTR lpComputerName ); *)
SetComputerName: external
  (# name: @integer;
     result: @boolean;
  enter name
  do 'SetComputerNameA' -> callStd;
  exit result
  #);
  
(* BOOL WINAPI GetUserNameA (LPSTR lpBuffer,LPDWORD nSize ); *)
GetUserName: external
  (# name: @integer; 
     length: @integer;
     result: @boolean; 
  enter (name, length)
  do 'GetUserNameA' -> callStd;
  exit result
  #);

(* #define MAX_COMPUTERNAME_LENGTH 15 *)
MAX_COMPUTERNAME_LENGTH: (# exit 15 #);

(* VOID WINAPI Sleep(    DWORD dwMilliseconds    ); *)
Sleep: external
  (# dwMilliseconds: @integer;
  enter dwMilliseconds
  do 'Sleep' -> callStd;
  #);

(* DWORD WINAPI SleepEx(    DWORD dwMilliseconds,    BOOL bAlertable ); *)
SleepEx: external
  (# dwMilliseconds: @integer;
     alertable: @boolean;
     result: @integer;
  enter (dwMilliseconds, alertable)
  do 'SleepEx' -> callStd;
  exit result
  #);

(* VOID WINAPI GetSystemTime(LPSYSTEMTIME lpSystemTime); *)
GetSystemTime: external
  (# theSystemTime: ^SYSTEMTIME;
  enter theSystemTime[]
  do 'GetSystemTime' -> callStd;
  #);


(* BOOL WINAPI SetSystemTime(CONST SYSTEMTIME *lpSystemTime ); *)


(* VOID WINAPI GetLocalTime(LPSYSTEMTIME lpSystemTime); *)
GetLocalTime: external
  (# theSystemTime: ^SYSTEMTIME;
  enter theSystemTime[]
  do 'GetLocalTime' -> callStd;
  #);


(* BOOL WINAPI SetLocalTime(CONST SYSTEMTIME *lpSystemTime); *)

(* VOID WINAPI GetSystemInfo(LPSYSTEM_INFO lpSystemInfo); *)

SYSTEMTIME: cstruct
  (# bytesize::< (# do  16 -> value; #);
     wYear: @short (# pos::< (# do 0 -> value; #); #); 
     wMonth: @short (# pos::< (# do 2 -> value; #); #); 
     wDayOfWeek: @short (# pos::< (# do 4 -> value; #); #); 
     wDay: @short (# pos::< (# do 6 -> value; #); #); 
     wHour: @short (# pos::< (# do 8 -> value; #); #); 
     wMinute: @short (# pos::< (# do 10 -> value; #); #); 
     wSecond: @short (# pos::< (# do 12 -> value; #); #); 
     wMilliseconds: @short (# pos::< (# do 14 -> value; #); #); 
  #);

(* WINBASEAPI BOOL WINAPI SetCurrentDirectoryA(LPCSTR lpPathName); *)
SetCurrentDirectory: external
  (# pathName: [1] @char;
     result: @integer;
  enter pathName
  do 'SetCurrentDirectoryA' -> callStd;
  exit result
  #);

(* WINBASEAPI DWORD WINAPI GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer); *)
GetCurrentDirectory: external
  (# bufferLength: @integer;
     ptrToBuffer: @integer;
     result: @integer;
  enter (bufferLength, ptrToBuffer)
  do 'GetCurrentDirectoryA' -> callStd;
  exit result
  #);



(* WINBASEAPI BOOL WINAPI CloseHandle( HANDLE hObject ); *)
CloseHandle: external
  (# hObject: @integer;
     res: @integer;
  enter hObject
  do 'CloseHandle' -> callStd;
  exit res
  #);
     

GetFileAttributes: external
  (# 
     fileName: [1]@char;
     result: @integer;
  enter fileName
  do 'GetFileAttributesA' -> callStd;
  exit result
  #);

INVALID_HANDLE_VALUE: (# exit -1 #);

WIN32_FIND_DATA: externalRecord
  (# dwFileAttributes: @long (# pos::< (# do 0 -> value; #); #);  
     ftCreationTime: @
       (# dwLowDateTime: @long (# pos::< (# do 4 -> value; #); #); 
          dwHighDateTime: @long (# pos::< (# do 8 -> value; #); #);
          
       #);
     ftLastAccessTime: @
       (# dwLowDateTime: @long (# pos::< (# do 12 -> value; #); #);
          
          dwHighDateTime: @long (# pos::< (# do 16 -> value; #); #)
          ; 
       #);
     ftLastWriteTime: @
       (# dwLowDateTime: @long (# pos::< (# do 20 -> value; #); #);
          
          dwHighDateTime: @long (# pos::< (# do 24 -> value; #); #)
          ; 
       #);
     nFileSizeHigh: @long (# pos::< (# do 28 -> value; #); #); 
     nFileSizeLow: @long (# pos::< (# do 32 -> value; #); #); 
     dwReserved0: @long (# pos::< (# do 36 -> value; #); #); 
     dwReserved1: @long (# pos::< (# do 40 -> value; #); #); 
     cFileName: @long (# pos::< (# do 44 -> value; #); #); 
     cAlternateFileName: @long (# pos::< (# do 46+MAX_PATH-> value; #)#); 
  #);
sizeOfWIN32_FIND_DATA: (# exit 320 #);

FindFirstFile: external
  (# lpFileName: [1]@char; (* pointer to name of file to search for
                            *)
     lpFindFileData: @integer; (* pointer to returned information *)
     sHandle: @integer;
  enter (lpFileName, lpFindFileData)
  do 'FindFirstFileA' -> callStd;
  exit sHandle
  #);
