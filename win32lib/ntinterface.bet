ORIGIN 'nterror';
BUILD nti '$$/ntInt.obj' 'private/external/ntInt.c' 'betacc $0 $1';

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1986-94
 *       All rights reserved.
 *)

INCLUDE '~beta/basiclib/v1.6/external';
INCLUDE 'windef';

---- LIB: attributes ----


(* This fragment specifies the interface to the underlying
 * nt operating system. 
 * Note that some of the Externals serve as a direct interfcae
 * to the functions in the standard C-library libc.a. Such functions
 * may differ in other nt-variants.
 *)

getenv: EXTERNAL  
  (* Get pointer to value of an environment variable *)
  (# var: [1]@char;
     Ccharpointer: @integer;
  enter var
  do callC
  exit Ccharpointer
  #);

getenvstring: external
  (* Get text value of an environment variable *)
  (# var: [1]@char;
     result: [1]@char
  enter var
  do 'getenv' -> callC
  exit result
  #);

clock: external (* <time.h> *)
  (# CPUtime: @Integer;
  exit CPUtime
  #);
time: external (* <time.h> *)
  (# timeloc: @Integer;
     time: @Integer;
  enter timeloc
  exit time
  #);
ctime:external (* <time.h> *)
  (# timeAdr: @Integer;
     str: [1]@Char;
  enter timeAdr
  exit str
  #);
ftime: external (* <timeb.h> *)
  (# timeb: @Integer;
     status: @Integer;
  enter timeb
  exit status
  #);
timeb: externalRecord
  (# time: @long(# pos::< (# do 0->value #) #);
     millitm: @short(# pos::< (# do 4->value #) #);
     timezone: @short(# pos::< (# do 6->value #) #);
     dstflag: @short(# pos::< (# do 8->value #) #);
  #);

malloc: external
  (# size: @Integer;
     ptr: @Integer;
  enter size
  exit ptr
  #);

getHostMachine: External(# t: [1]@char do 'machine_type' -> callC exit t #);

catchSIGPIPE: External(# #);

EOFvalue: External (* returns the EOF value *)
  (# N: @integer
  do CallC
  exit N
  #);

EOFfunction: External
  (# ntStream: @integer; 
     yes: @boolean; 
  enter ntStream
  do CallC
  exit yes
  #);

StreamError: External
  (# yes: @boolean 
  do CallC
  exit yes #);

GetTextFromStream: External
  (# ntStream: @integer;
     toEOL: @boolean;
     T: [1]@char;
  enter(ntStream,toEOL)
  do CallC
  exit T
  #);

(* Operations to read the arguments supplied to the calling
 * Beta program execution.
 *)

Argc: External
  (# noOfArgs: @integer;
  exit noOfArgs
  #);

Argv: External
  (# argNo: @integer;
     theArg: [1]@char;
  enter argNo
  exit theArg
  #);

(* File descriptor I/O *)

read: External (* From libc.a *)
  (# descriptor: @integer;
     bufAdr: @integer;
     nBytes: @integer;
     status: @integer;
  enter(descriptor,bufAdr,nBytes)
  exit status
  #);

write: External (* From libc.a *)
  (# descriptor: @integer;
     bufAdr: @integer;
     nBytes: @integer;
     status: @integer;
  enter(descriptor,bufadr,nBytes)
  exit status
  #);

close: External (* From libc.a *)
  (# descriptor: @integer;
     status: @integer; (* -1 => error, 0 => succes *)
  enter descriptor
  exit status
  #);

open: External (* From libc.a *)
  (# descriptor: @integer;
     mode: @integer;
     path: [1]@char;
     flags: @integer;
  enter(path,flags,mode)
  exit descriptor
  #);

closeFileDescriptor:
  (# status: @integer;
  enter(close -> status)
  exit status
  #);


(* File stream I/O. These operations are built on top of the
 * standard nt library for buffered I/O, stdio.h. 
 * They are mainly used to implement the fileStream located
 * in streamenv.bet
 *)

stat: External
  (# name: [1]@Char; statusBuf: ^CStruct; status:@integer
  enter(name,statusBuf[])
  do CallC
  exit status
  #);

unlink: External
  (# name: [1]@char; status: @integer
  enter name
  do CallC
  exit status
  #);

fputs: External
  (# ntStream: @integer;
     charptr: @integer;
     status: @integer;
  enter(charptr,ntStream)
  do CallC
  exit status
  #);

fseek: External
  (# ntStream,p,mode,status: @integer;
  enter(ntStream,p,mode)
  do CallC
  exit status
  #);

ftell: External
  (# ntStream,pos: @integer;
  enter ntStream
  do CallC
  exit pos
  #);

ungetc: External
  (# ntStream: @integer;
     ch: @char;
  enter (ch,ntStream)
  do CallC
  exit ch
  #);

fputc: External
  (# c: @char;
     ntStream: @integer;
     status: @integer; (* -1 => error *)
  enter(c,ntStream)
  exit status
  #);

fgetc: External
  (# c: @integer; (* -1 => eof *)
     ntStream: @integer;
  enter ntStream
  exit c
  #);

fopen: External
  (# path: [1]@char;
     mode: [1]@char;
     aNtStream: @integer; (* 0 => error *)
  enter(path,mode)
  exit aNtStream
  #);

fclose: External
  (# ntStream,status: @integer; 
  enter ntStream
  do CallC 
  exit status 
  #);

feos: External (* not in libc.a *)
  (# aNtStream: @integer;
     status: @integer; (* 0 => not end of stream *)
  enter aNtStream
  exit status
  #);

fread: External
  (# addr, size, n, ntStream: @integer; (* n is no of elems. to read. *)
     n1: @integer; (* The number of elements successfully read. *)
  enter(addr,size,n,ntStream)
  do CallC   
  exit n1
  #);

fwrite: External
  (# addr, size, n, ntStream: @integer; (* n is no of elems. to write. *)
     n1: @integer; (* The number of elements successfully written. *)
  enter(addr,size,n,ntStream)
  do CallC
  exit n1
  #);

fflush: External
  (# ntStream,status: @integer; 
  enter ntStream
  do CallC
  exit status 
  #);

perror: External
  (# msg: [1]@char;
  enter msg
  #);

errorstring: 
  (# errno: @integer;
     str: @text; 
     
     errstr: External
       (# errno: @integer;
          msg: [1]@char;
       enter errno
       exit msg
       #);
  enter errno
  do errno->errstr->str;
  exit str[]
  #);

fdopen: External
  (# fildes: @integer; type: [1]@char; ntStream: @integer;
  enter(fildes,type)
  do CallC
  exit(ntStream)
  #);

getErrno: External (* returns NT variable 'errno' *)
  (# N: @integer
  do CallC
  exit N
  #);

streamToDescriptor: External
  (# aNtStream: @integer;
     descriptor: @integer;
  enter aNtStream
  exit descriptor
  #);

stripAutoMounter:
  (* Strip off auto-mounting info. *)
  (# path: ^text; amd: @text;
  enter path[]
  do (if ('AUTOMOUNTDIR' -> getenv)<>0 // true then
         'AUTOMOUNTDIR' -> getenvstring -> amd;
         (if (amd.length->amd.inxget)
          // '\\' then (amd.length, amd.length) ->amd.delete
         if);
         (if ((1,amd.length) -> path.sub -> amd.equal) // true then
             (1,amd.length) -> path.delete;
         if);
     if);
  #);

getCurrentDir:
  (# getCurDir: External
       (# cwd: [1]@char;
       exit cwd
       #);
     cwd: ^text;
  do &text[]->cwd[];
     getCurDir->cwd;
  exit cwd[]
  #);



(* Operations directed towards nt processes *)
getpid: External (* This one is present in libc.a *)
  (# pid: @integer
  exit pid
  #);

argDecodeSeparator: (# exit 1 #);
(* The arguments to a process are encoded into a text. The 
 * arguments are separated by "argDecodeSeparator" in the 
 * resulting text. 
 *)

startNtProcess: External
  (# fileName: [1]@char;
     stdin,stdout: @integer;
     arguments: [1]@char; 
     (* A text decoding of the arguments *)
     pid: @integer; 
     (* The pid of the process just started, -1 => error *)
  enter(fileName,arguments,stdin,stdout)
  exit pid
  #);

stopNtProcess: External
  (# thePid: @integer;
     status: @integer; (* -1 => error *)
  enter thePid
  exit status
  #);

sleep: External (* present in libc.a *)
  (# time: @integer;
     status: @integer; (* -1 => error *)
  enter time
  exit status
  #);

suspendThisProcess:
  (# val: @integer;
  enter (&sleep -> val)
  exit val
  #);

stillExecuting: External
  (# thePid: @integer;
     status: @integer; (* -1 => error, 0 => not running 1 => running *)
  enter thePid
  exit status
  #);

awaitNotExecuting: External
  (# pid: @integer;
     status: @integer; (* -1 => error, 1 => exited, 2 => killed *)
  enter pid
  exit status
  #);


(* Operations for network comunication *)



selectIndex: External
  (# mode: @integer; 
     (* Saying whether or not the select call should block until
      * activity is discovered or simply check the file descriptors
      * in question.
      * 0 => poll, -1 => block
      *)
     active,candidates: @integer; 
     (* start addr. of reference repetitions. These repetitions
      * denote the bit masks supplied to select. The candidates
      * denote the file descriptors to be checked. If candidates[i]
      * is <> 0 means that filedescriptor i-1 should be checked.
      * The result of select is returned in active. If active[i] is
      * <> 0, the file descriptor i-1 is readable or exceptional.
      *)
     status: @integer; (* -1 => error *)
  enter(candidates,active,mode)
  exit status
  #);

getHostName: External
  (# host: [1]@char; (* '' => error *)
  exit host
  #);

bindPort: External
  (# port: @integer;
     listenIndex: @integer; (* -1 => error *)
  enter port
  exit listenIndex
  #);

acceptConnection: External
  (# listenIndex: @integer;
     talkIndex: @integer; (* -1 => error *)
  enter listenIndex
  exit talkIndex
  #);

openActive: External
  (* Open a socket connection to "port" on "host".
   * The resulting socket is returned by "index"
   *)
  (# host: [1]@char;
     port: @integer;
     index: @integer; (* -1 => error *)
  enter(host,port)
  exit index
  #);



openPipe: External
  (# p: ^ntPipe;
     status: @integer; (* -1 => error *)
  enter p[]
  exit status
  #);

ntPipe: CStruct
  (# byteSize::<(# do 8 -> value #);
     readIndex:  long(# pos::<(# do 0 -> value #) #);
     writeIndex: long(# pos::<(# do 4 -> value #) #);
  #);

CorrectFilenameCase:
  (* Accepts filenames on the form:
   *   "myFile.bet"
   *   "e:/beta/r4.1/myfile.bet"
   *   "e:/beta/r4.1"
   *   "e:/beta/r4.1/"
   *)
  (# origPath,correctPath: ^Text;
     lastinx: @Integer;
     lastChar, ch: @Char;
     part: ^Text;
  enter origPath[]
  do origPath.copy->origPath[];
     origPath.length->origPath.inxGet->lastChar;
     (if (lastChar<>'/') and (lastChar<>'\\') then
         '/'->origPath.put
     if);
     &Text[]->correctPath[];
     1->lastinx;
     (for inx: origPath.lgth repeat origPath.T[inx]->ch;
          (if (ch='/') or (ch='\\') then
              (1,inx)->origPath.sub->part[];
              '\\'->part.findAll(# do ('/',inx)->part.inxPut #);
              part->CCorrectFilenameCase->part;
              (lastinx, inx-part.length-1)->
              origPath.sub->
              correctpath.putText;
              part[]->correctPath.putText;
              inx->lastinx;
          if)
     for);
     (if (lastChar='/') or (lastChar='\\') then
         lastChar->correctPath.put
     if)
  exit correctPath[]
  #);
     
 

(* Correct the case of a given filename (may include path)
 * This is implemented in C, not by NT. 
 * The case of the path is NOT corrected! *)
CCorrectFilenameCase: external
  (# filename1, filename2: [1]@char;
  enter filename1
  do callC;
  exit filename2
  #);
