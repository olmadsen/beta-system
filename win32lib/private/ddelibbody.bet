ORIGIN 'ddelibprivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1994-95
 *       All rights reserved.
 *)

INCLUDE '../ddeml';
INCLUDE '../clipboardmanager';
INCLUDE '../winuserconsts';
INCLUDE '~beta/sysutils/v1.4/cstring';

(******* DDEML SUPPORT *******)
-- ddemlEventLib: attributes --
--  ddemlEventBody: descriptor --
(# 
do 
#)

-- errorHConvBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)

-- errorCodeBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.dwData1 -> value;
#)

-- adviseFmtBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.uFmt -> value;
#)

-- adviseHConvBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)

-- adviseHTopicBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)

-- adviseHDataBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hData -> value;
#)

-- adviseData1Body: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.dwData1 -> value;
#)

-- completeFmtBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.uFmt -> value;
#)

-- completeHConvBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)

-- completeHTopicBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)

-- completeHDataBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hData -> value;
#)

-- completeData1Body: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.dwData1 -> value;
#)

-- completeData2Body: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.dwData2 -> value;
#)

-- requestFmtBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.uFmt -> value;
#)
-- requestHConvBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)
-- requestHTopicBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)
-- requestHItemBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz2 -> value;
#) 
-- hConvBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)

-- hTopicbody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)

-- hDataBody: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hdata -> value;
#)

-- pokeEventHItem: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz2 -> value;
#) 

-- regEventHBaseName: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)

-- regEventHInstSpecName: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz2 -> value;
#)

-- connectEventHTopic: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz1 -> value;
#)

-- connectEventHService: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hsz2 -> value;
#)

-- disconnectEventHConv: descriptor --
(# info: ^ddemlMsgInfo;
do currentDdemlMsgInfo -> info[];
   info.hConv -> value;
#)

-- UIENVstandardDdemlCallback: descriptor --
(# hServer: @integerObject; hLocalData: @integer; cstr: @cstring; t: ^text;
   length, lengthOfItemString, lOfBaseSerStr: @integer; theItemString: ^text;
   info: ^ddemlMsgInfo;
do &ddemlMsgInfo[] -> info[] -> pushDdemlMsgInfo;
   (if uType
    //XTYP_ERROR then 
       'uType: XTYP_ERROR' -> writeMsg2Console; 
    //XTYP_ADVDATA then 
       'uType: XTYP_ ADVDATA' -> writeMsg2Console; 
       uFmt -> info.uFmt;
       hConv -> info.hConv;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       hData -> info.hData;
       theDdemlHandler.onXTYP_ADVDATA
    //XTYP_ADVREQ then 
       'uType: XTYP_ADVREQ ' -> writeMsg2Console; 
       uFmt -> info.uFmt;
       hConv -> info.hConv;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       dwData1 -> info.dwData1;
       theDdemlHandler.onXTYP_ADVREQ
       
    //XTYP_ADVSTART then 
       'uType: XTYP_ADVSTART' -> writeMsg2Console; 
       uFmt -> info.uFmt;
       hConv -> info.hConv;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       theDdemlHandler.onXTYP_ADVSTART
       
    //XTYP_ADVSTOP then 
       'uType: XTYP_ADVSTOP' -> writeMsg2Console;
       uFmt -> info.uFmt;
       hConv -> info.hConv;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       theDdemlHandler.onXTYP_ADVSTOP;
       
    //XTYP_EXECUTE then 
       (* uFmt: Not used.
        hconv: Identifies the conversationn.
        hsz1: Identifies the topic name.
        hsz2: Not used. 
        hdata: Identifies the command string.
        dwData1: not used.
        dwData2: not used.
        *)
       
       (# executeLength: @integer;
          accessRes: @integer;
       do '[XTYP_EXECUTE' -> writeMsg2Console; 
          
          (hData,0) -> DdeAccessData -> accessRes;
          (if accessRes//0 then 
              'DdeAccessData failed. Error: ' -> putText;
              (if idInst -> DdeGetLastError 
               //DMLERR_INVALIDPARAMETER then
                  'DMLERR_INVALIDPARAMETER' -> writeMsg2Console;
               //DMLERR_DLL_NOT_INITIALIZED then
                  'DMLERR_DLL_NOT_INITIALIZED' -> writeMsg2Console;
               //DMLERR_NO_ERROR then
                  'DMLERR_NO_ERROR' -> writeMsg2Console;
              if);
           else
              (hData, 0, 0, 0) -> DdeGetData -> executeLength;
              
              (if (executeLength>0)//true then 
                  hConv -> info.hConv;
                  hsz1 -> info.hsz1;
                  hdata -> info.hData;
                  theDdemlHandler.onXTYP_EXECUTE -> result;
               else 0 -> result;
              if);
              
              (if hData -> DdeUnaccessData//false then
                  'DdeUnaccessData failed. Error: ' -> putText;
                  (if idInst -> DdeGetLastError 
                   //DMLERR_INVALIDPARAMETER then
                      'DMLERR_INVALIDPARAMETER' -> writeMsg2Console;
                   //DMLERR_DLL_NOT_INITIALIZED then
                      'DMLERR_DLL_NOT_INITIALIZED' -> writeMsg2Console;
                   //DMLERR_NO_ERROR then
                      'DMLERR_NO_ERROR' -> writeMsg2Console;
                  if);
              if);
          if); 
          'execute.result: ' -> writeMsg2Console;
          (if result//DDE_FACK then 'DDE_FACK.' -> writeMsg2Console; 
           else 'DDE_FBUSY.' -> writeMsg2Console; 
          if);
          'XTYP_EXECUTE]' -> writeMsg2Console; 
       #);
       
    //XTYP_CONNECT then 
       (* uFmt: Not used.
        * hconv: Not used.
        * hsz1: Identifies the topic name.
        * hsz2: Identifies the service name. 
        * hdata: Not used.
        * dwData1: Points to a CONVCOONTEXT data structure that contains context 
        * information for the conversation. If the client is not a DDEML application
        * this parameter is set to 0.
        * dwData2: Specifies whether the client is the same application instance as the
        * server. If the parameter is 1, the client is the same instance. If the 
        * parameter is 0, the client is a different instance.
        *)
       
       (* 'uType: XTYP_CONNECT' -> writeMsg2Console; *)
       
       (if hsz1
        //hSysTopic then 
           
           hsz1 -> info.hsz1;
           hsz2 -> info.hsz2;
           dwData1 -> info.dwData1;
           dwData2 -> info.dwData2;
           theDdemlHandler.onXTYP_CONNECT;
           1 -> result;
           'accepting connect' -> writeMsg2Console;
        else 
           0 -> result;
           'refusing connect. ' -> writeMsg2Console;
       if);
    //XTYP_CONNECT_CONFIRM then 
       'uType: XTYP_CONNECT_CONFIRM' -> writeMsg2Console; 
    //XTYP_XACT_COMPLETE then 
       
       'uType: XTYP_COMPLETE' -> writeMsg2Console; 
       
       uFmt -> info.uFmt;
       hConv -> info.hConv;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       hData -> info.hData;
       dwData1 -> info.dwData1;
       dwData2 -> info.dwData2;
       theDdemlHandler.onXTYP_XACT_COMPLETE;
       
    //XTYP_POKE then 
       (* uFmt: Specifies the format of data sent from the client.
        hconv: Identifies the conversationn.
        hsz1: Identifies the topic name.
        hsz2: Identifies the item name.
        hdata: Identifies the data the client is sending to the server.
        dwData1: Not used.
        dwData2: Not used.
        *)
       
       '[XTYP_POKE' -> writeMsg2Console; 
       
       (if uFmt = CF_TEXT
        //false then 0 -> result;
        else
           (# pokeLength: @integer;
              accessRes: @integer;
           do (hData,0) -> DdeAccessData -> accessRes;
              (if accessRes//0 then 
                  'DdeAccessData failed. Error: ' -> putText;
                  (if idInst -> DdeGetLastError 
                   //DMLERR_INVALIDPARAMETER then
                      'DMLERR_INVALIDPARAMETER' -> writeMsg2Console;
                   //DMLERR_DLL_NOT_INITIALIZED then
                      'DMLERR_DLL_NOT_INITIALIZED' -> writeMsg2Console;
                   //DMLERR_NO_ERROR then
                      'DMLERR_NO_ERROR' -> writeMsg2Console;
                  if);
               else
                  (* Get the data object. *)
                  (hData, 0, 0, 0) -> DdeGetData -> pokeLength;
                  
                  (if (pokeLength>0)
                   //true then 
                      hConv -> info.hConv;
                      hsz1 -> info.hsz1;
                      hsz2 -> info.hsz2;
                      hdata -> info.hData;
                      theDdemlHandler.onXTYP_POKE -> result;
                   else 0 -> result;
                  if);
                  
                  (if hData -> DdeUnaccessData//false then
                      'DdeUnaccessData failed. Error: ' -> putText;
                      (if idInst -> DdeGetLastError 
                       //DMLERR_INVALIDPARAMETER then
                          'DMLERR_INVALIDPARAMETER' -> writeMsg2Console;
                       //DMLERR_DLL_NOT_INITIALIZED then
                          'DMLERR_DLL_NOT_INITIALIZED' -> writeMsg2Console;
                       //DMLERR_NO_ERROR then
                          'DMLERR_NO_ERROR' -> writeMsg2Console;
                      if);
                  if);
              if);
              'poke.result: ' -> writeMsg2Console;
              (if result//DDE_FACK then 'DDE_FACK' -> writeMsg2Console; 
               else 'DDE_FBUSY' -> writeMsg2Console; 
              if);
           #);
       if);
       'XTYP_POKE]' -> writeMsg2Console; 
       
    //XTYP_REGISTER then 
       (* uFmt: Not used.
        hconv: Not used.
        hsz1: Identifies the base service name being registered.
        hsz2: Identifies the instance-specific service name being registered.
        hdata: Not used.
        dwData1: Not used.
        dwData2: Not used.
        *)
       
       'uType: XTYP_REGISTER' -> writeMsg2Console; 
       
       hsz1 -> private.ddeServers.add;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       theDdemlHandler.onXTYP_REGISTER;
    //XTYP_REQUEST then 
       (* uFmt: Specifies the format in which the server should submit data to the the client.
        hconv: Identifies the conversation.
        hsz1: Identifies the topic name.
        hsz2: Identifies the item name.
        hdata: Not used.
        dwData1: Not used.
        dwData2: Not used.
        *)
       
       '[XTYP_REQUEST' -> writeMsg2Console; 
       (if uFmt = CF_TEXT
        //false then 0 -> result;
        else
           (# answer: ^text; hAnswer: @integer; reqCStr: ^cString;
              tempHItem2: @integer;
           do uFmt -> info.uFmt;
              hConv -> info.hConv;
              hsz1 -> info.hsz1;
              hsz2 -> info.hsz2;
              theDdemlHandler.onXTYP_REQUEST -> (answer[],tempHItem2);
              
              (if tempHItem2//0 then 
                  '***WARNING: No handle to item is returned from onXTYP_REQUEST.' -> writeMsg2Console;
              if);
              
              'answer from onXTYP_REQUEST: ' -> writeMsg2Console;
              
              (if answer[]//none then
                  0 -> hLocalData;
                  'answer from onXTYP_REQUEST is none' -> writeMsg2Console;
               else                  
                  answer[] -> writeMsg2Console;
                  
                  &cstring[] -> reqCStr[];
                  answer[] -> reqCStr.set;
                  
                  (uienvIdInst, reqCStr.charPtr, reqCStr.length + 1, 0, tempHItem2, uFmt, 0)
                    -> DdeCreateDataHandle -> hLocalData; 
                  (if hLocalData//0 then 'DdeCreateDataHandle failed in XTYP_REQUEST.' -> writeMsg2Console; if);

                  reqCStr.free;
              if);
           #);
           hLocalData -> result;
       if);
       
       'XTYP_REQUEST]' -> writeMsg2Console; 
       
    //XTYP_DISCONNECT then 
       '[XTYP_DISCONNECT' -> writeMsg2Console; 
       hConv -> info.hConv;
       dwData2 -> info.dwData2;
       1 -> result;
       theDdemlHandler.onXTYP_DISCONNECT;
       'XTYP_DISCONNECT]' -> writeMsg2Console; 
       
    //XTYP_UNREGISTER then 
       (* 'uType: XTYP_UNREGISTER' -> writeMsg2Console; *)
       
       hsz1 -> private.ddeServers.remove;
       hsz1 -> info.hsz1;
       hsz2 -> info.hsz2;
       theDdemlHandler.onXTYP_UNREGISTER;
    //XTYP_WILDCONNECT then 
       'uType: XTYP_WILDCONNECT' -> writeMsg2Console; 
       0 -> result;
    //XTYP_MASK then 
       'uType: XTYP_MASK' -> writeMsg2Console;  
       0 -> result;
    //XTYP_SHIFT then 
       'uType: XTYP_SHIFT' -> writeMsg2Console;  
       0 -> result;
       
   if);
   popDdemlMsgInfo;
#)
(****** DDEML SUPPORT END *********)

-- ddelibsetAppName: descriptor --
(#
do name -> uienvAppName;
#)

-- ddelibgetAppName: descriptor --
(#
do uienvAppName -> name;
#)
-- ddelibhApplName: descriptor --
(#
do uienvHAppName -> i;
#)
-- ddelibidInst: descriptor --
(#
do uienvIdInst -> i;
#)
-- ddelibhsysTopic: descriptor --
(#
do hSysTopic -> value;
#)
-- ddelibdeinstallDdeml: descriptor --
(# result: @integer;
do (if (uienvIdInst<>0)
    //true then 
       hConv -> DdeDisconnect;
       (uienvIdInst, 0, 0, DNS_UNREGISTER) -> DdeNameService; 
       (uienvIdInst, uienvHAppName) ->  DdeFreeStringHandle;
       (uienvIdInst, hSysTopic) ->  DdeFreeStringHandle;
       uienvIdInst -> DdeUninitialize -> result;
       (if result=0 then
           '**WARNING: DdeUninitialize failed!!!!!!!' -> writeMsg2Console;
       if);
   if);
#)
-- ddelibInit: descriptor --
(# initDdeml:
     (# idInst: @integer; idInstAddress: @integer;
        result: @integer; theApplName: @text;
     do standardDdemlCallback## -> stdDdeCallbackToInt -> standardDdemlCallbackAddress;
        (* 4 -> malloc -> idInstAddress;
         'idInstAddress: ' -> puttext; idInstAddress -> putint; newline;
         *)
        
        (@@idInst, standardDdemlCallbackAddress, CBF_FAIL_SELFCONNECTIONS, 0)
          -> DdeInitialize -> result; 
        
        (* (idInstAddress, standardDdemlCallbackAddress, CBF_FAIL_SELFCONNECTIONS, 0)
         -> DdeInitialize -> result;
         *)
        (if result
         //DMLERR_DLL_USAGE then 'dmlerr_dll_usage' -> writeMsg2Console;
         //DMLERR_INVALIDPARAMETER then 'dmlerr_invalidparameter' -> writeMsg2Console;
         //DMLERR_SYS_ERROR then 'dmlerr_sys_error' -> writeMsg2Console;
         else
            (* idInstAddress -> TOS'%adrGetLong' -> idInst;
             idInstAddress -> free;
             *)
            
            (* 'idInst: ' -> puttext;
             idInst -> putint; newline; *)
            
            
            idInst -> uienvIdInst;
            uienvAppName -> theApplName;
            (if theApplName.length//0 then 'uienvAppl' -> uienvAppName;
            if);
            uienvAppName -> theApplName;
            
            (* 'uienvAppName: ' -> puttext; theApplName[] -> writeMsg2Console; *)
            
            (idInst, uienvAppName,CP_WINANSI) ->  DdeCreateStringHandle -> uienvHAppName;
            (idInst, SZDDESYS_TOPIC,CP_WINANSI) ->  DdeCreateStringHandle -> hSysTopic;
            uienvAppName -> RegisterClipboardFormat ->  hFormat; 
            (* register service - causes DDEML to notify other clients 
             *  that a new DDE service is on line 
             *)
            (idInst, uienvHAppName, 0, DNS_REGISTER ) -> DdeNameService;
            (idInst, hSysTopic, 0, DNS_REGISTER ) -> DdeNameService;
        if);
     #);
do inner init;
   initDdeml;
#)
