ORIGIN '../registry';
INCLUDE
'../winbase';

-- lib: attributes --

ERROR_SUCCESS: (# exit 0 #);
ERROR_MORE_DATA: (# exit 234 #);


SYNCHRONIZE: (# exit 16x00100000 #);
READ_CONTROL: (# exit 16x00020000 #);
STANDARD_RIGHTS_READ: (# exit READ_CONTROL #);

(* From winnt.h *)
STANDARD_RIGHTS_ALL: (# exit 0x001F0000 #);
SPECIFIC_RIGHTS_ALL: (# exit 0x0000FFFF #);

REG_OPTION_RESERVED: (# exit 0x00000000 #);   (* Parameter is reserved *)
REG_OPTION_NON_VOLATILE: (# exit 0x00000000 #);   (* Key is preserved
                                                   * when system is rebooted *)
REG_OPTION_VOLATILE: (# exit 0x00000001 #);     (* Key is not preserved
                                                 * when system is rebooted *)
REG_OPTION_CREATE_LINK: (# exit 0x00000002 #);  (* Created key is a
                                                 * symbolic link *)
REG_OPTION_BACKUP_RESTORE: (# exit 0x00000004 #);   (* open for backup or restore
                                                     * special access rules
                                                     * privilege required *)

EG_OPTION_OPEN_LINK: (# exit 0x00000008 #);  (* Open symbolic link *)


KEY_ALL_ACCESS: (# exit 
                   ((STANDARD_RIGHTS_ALL %Bor
                   KEY_QUERY_VALUE            %Bor
                   KEY_SET_VALUE              %Bor
                   KEY_CREATE_SUB_KEY         %Bor
                   KEY_ENUMERATE_SUB_KEYS     %Bor
                   KEY_NOTIFY                 %Bor
                   KEY_CREATE_LINK)           
                   %Band                           
                   (%Bnot SYNCHRONIZE)) 
                #);


(* Registry Specific Access Rights.
 *)

KEY_QUERY_VALUE: (# exit 16x0001 #);
KEY_SET_VALUE: (# exit 16x0002 #);
KEY_CREATE_SUB_KEY: (# exit 16x0004 #);
KEY_ENUMERATE_SUB_KEYS: (# exit 16x0008 #);
KEY_NOTIFY: (# exit 16x0010 #);
KEY_CREATE_LINK: (# exit 16x0020 #);
KEY_READ: integerValue
  (# 
  do (STANDARD_RIGHTS_READ 
      %Bor KEY_QUERY_VALUE 
      %Bor KEY_ENUMERATE_SUB_KEYS 
      %Bor KEY_NOTIFY) 
     %Band (%Bnot SYNCHRONIZE) -> value;
  #);


SECURITY_ATTRIBUTES: CStruct
  (# ByteSize:: (# do 12 -> Value; #);
     nLength: @long (# pos::< (# do 0 -> value; #); #);
     lpSecurityDescriptor: @long (# pos::< (# do 4 -> value; #); #);
     bInheritHandle: @long (# pos::< (# do 8 -> value; #); #); 
  #);

RegCreateKeyEx: external
  (# hKey: @integer; (* handle of an open key  *)
     lpSubKey: [1] @char; (* address of subkey name *)
     Reserved: @integer; (* reserved *)
     lpClass: [1] @char; (* address of class string *)
     dwOptions: @integer; (* special options flag *)
     samDesired: @integer; (* desired security access *)
     lpSecurityAttributes: ^SECURITY_ATTRIBUTES; (* address of key security 
                                                  * structure *)
     phkResult: @integer; (* address of buffer for opened handle  *)
     lpdwDisposition: @integer; (* address of disposition value buffer *)
     result: @integer;
  enter (hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,
     lpSecurityAttributes[],phkResult,lpdwDisposition)
  do 'RegCreateKeyExA' -> callStd;
  exit result
  #);

(* Same as above but with different interface. *)
RegCreateKeyEx2: external
  (# hKey: @integer; (* handle of an open key  *)
     lpSubKey: [1] @char; (* address of subkey name *)
     Reserved: @integer; (* reserved *)
     lpClass: @integer; (* address of class string *)
     dwOptions: @integer; (* special options flag *)
     samDesired: @integer; (* desired security access *)
     lpSecurityAttributes: ^SECURITY_ATTRIBUTES; (* address of key security 
                                                  * structure *)
     phkResult: @integer; (* address of buffer for opened handle  *)
     lpdwDisposition: @integer; (* address of disposition value buffer *)
     result: @integer;
  enter (hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,
     lpSecurityAttributes[],phkResult,lpdwDisposition)
  do 'RegCreateKeyExA' -> callStd;
  exit result
  #);

RegSetValueExText: external
  (# hKey: @integer;           (* handle to key to set value for *)
     lpValueName: [1] @char;   (* name of the value to set *)
     Reserved: @integer;       (* reserved  *)
     dwType: @integer;         (* flag for value type *)
     lpData: [1] @char;        (* address of value data *)
     cbData: @integer;         (* size of value data *)
     res: @integer;
  enter (hKey, lpValueName, Reserved, dwType, lpData, cbData)
  do 'RegSetValueExA' -> callStd;
  exit res
  #);

RegSetValueExDword: external
  (# hKey: @integer;           (* handle to key to set value for *)
     lpValueName: [1] @char;   (* name of the value to set *)
     Reserved: @integer;       (* reserved  *)
     dwType: @integer;         (* flag for value type *)
     lpData: @integer;        (* address of value data *)
     cbData: @integer;         (* size of value data *)
     res: @integer;
  enter (hKey, lpValueName, Reserved, dwType, lpData, cbData)
  do 'RegSetValueExA' -> callStd;
  exit res
  #);

RegOpenKeyEx: external
  (# hKey: @integer; (* handle of open key *)
     lpSubKey: [1] @char; (* address of name of subkey to open *)
     ulOptions: @integer; (* reserved *)
     samDesired: @integer; (* security access mask *)
     phkResult: @integer; (* address of handle of open key *)
     result: @integer; (* If the function succeeds, the return value is 
                        * ERROR_SUCCESS.
                        * If the function fails, the return value is an 
                        * error value*)
  enter (hKey,lpSubKey,ulOptions,samDesired,phkResult)
  do 'RegOpenKeyExA' -> callStd;
  exit result
  #);

RegEnumKeyEx: external
  (# hKey: @integer; (* handle of key to enumerate *)
     dwIndex: @integer; (* index of subkey to enumerate *)
     lpName: @integer; (* address of buffer for subkey name *);
     lpcbName: @integer; (* address for size of subkey buffer *)
     lpReserved: @integer; (* Reserved *)
     lpClass: @integer; (* address of buffer for class string *)
     lpcbClass: @integer; (* address for size of class buffer *)
     lpftLastWriteTime: @integer; (* address for time key last written to *)
     res: @integer;
  enter (hKey, dwIndex, lpName, lpcbName, lpReserved, lpClass, lpcbClass, lpftLastWriteTime)
  do 'RegEnumKeyExA' -> callStd;
  exit res
  #);

RegQueryValueEx: external
  (# hKey: @integer; (* handle of key to query *)
     lpValueName: [1] @char; (* address of name of value to query *)
     lpReserved: @integer; (* reserved *)
     lpType: @integer; (* address of buffer for value type *)
     lpData: @integer; (* address of data buffer *)
     lpcbData: @integer; (* address of data buffer size *)
     result: @integer; (* If the function succeeds, the return value is 
                        * ERROR_SUCCESS.
                        * If the function fails, the return value is an 
                        * error value*)
  enter (hKey,lpValueName,lpReserved,lpType,lpData,lpcbData)
  do 'RegQueryValueExA' -> callStd;
  exit result
  #);


RegQueryInfoKey: external
  (# hKey: @integer;       (* handle of key to query *)
     lpClass: @integer;    (* address of buffer for class string *)
     lpcbClass: @integer;  (* address of size of class string buffer *)
     lpReserved: @integer; (* reserved *)
     lpcSubKeys: @integer; (* address of buffer for number of subkeys *)
     lpcbMaxSubKeyLen: @integer;  (* address of buffer for longest subkey 
                                   * name length *)
     lpcbMaxClassLen: @integer;  (* address of buffer for longest class string 
                                  * length *)
     lpcValues: @integer;        (* address of buffer for number of value 
                                  * entries *)
     lpcbMaxValueNameLen: @integer;   (* address of buffer for longest 
                                       * value name length *)
     lpcbMaxValueLen: @integer;   (* address of buffer for longest value 
                                   * data length  *)
     lpcbSecurityDescriptor: @integer; (* address of buffer for security 
                                        * descriptor length *)
     lpftLastWriteTime: @integer;    (* address of buffer for last write time *)
     res: @integer;
  enter (hKey, lpClass, lpcbClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen,
     lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, 
     lpcbSecurityDescriptor, lpftLastWriteTime)
  do 'RegQueryInfoKeyA' -> callStd;
  exit res
  #);

RegCloseKey: external
  (# hKey: @integer; (* handle of key to close  *)
     result: @integer; (* If the function succeeds, the return value is 
                        * ERROR_SUCCESS.
                        * If the function fails, the return value is an 
                        * error value *)
  enter hKey
  do callStd
  exit result
  #);


RegDeleteKey: external
  (# hKey: @integer; (* handle to open key *)
     subKey: [1] @char;   (* address of name of subkey to delete *)
     res: @integer;
  enter (hKey, subKey)
  do 'RegDeleteKeyA' -> callStd;
  exit res
  #);


--- ReadFromRegistryPriv:descriptor ---
(# phkResult: @Integer;
   result: @Integer;
   bufferSize: @Integer;
   valueType: @Integer;
   
do (HKEY_val, subKeyName, 0, KEY_READ,  @@phkResult) 
     -> RegOpenKeyEx -> result;
   (if result=ERROR_SUCCESS then
       &text[] -> value[];
       8 -> value.extend;
       0 -> bufferSize; (* Get buffersize *)
       (phkResult,valueName,0,0,@@value.T[1],@@bufferSize)
         -> RegQueryValueEx -> result; 
       (if result=ERROR_MORE_DATA then
           buffersize -> value.extend; (* Reserve mem, get value *)
           (phkResult,valueName,0,@@valueType,@@value.T[1],@@bufferSize)
             -> RegQueryValueEx -> result;
           (if result=ERROR_SUCCESS then
               bufferSize-1 -> value.lgth -> value.pos;
               (if not ((valueType=REG_SZ) or (valueType=REG_EXPAND_SZ)) then
                   'readFromRegistry: retrieved non-string value' 
                     -> screen.putLine; 
                   NONE -> value[]; otherError
               if)
            else
               'RegEnumValueEx failed.'
                 -> screen.putline;
               NONE -> value[]; otherError
           if);
        else
           NONE -> value[];
           noSuchValue;
       if);
       phkResult -> RegCloseKey -> result;
       (if not (result=ERROR_SUCCESS) then
           'RegCloseKey failed.' -> screen.putLine;
           otherError
       if)
    else
       noSuchKey
   if)
#)

(*************************************************************************

Eksempel på tidlige brug:
 ------------------
   
MAX_PATH: (# exit 260 #);
 
readFromRegistry:
     (# subKeyName: @text; 
        phkResult: @integer;
        key_read_val: @integer;
        result: @integer;
        valueName,value: @text; bufferSize: @integer;
     do KEY_READ -> key_read_val;
        'Software\\Mjolner Informatics\\Devise Hypermedia\\1.4\\DHM'
          -> subKeyName.putText;
        (HKEY_LOCAL_MACHINE, subKeyName,0, key_read_val,
        @@phkResult) -> RegOpenKeyEx -> result;
        (if result=ERROR_SUCCESS then
            MAX_PATH -> value.extend;
            MAX_PATH -> bufferSize;
            valueName.clear;
            'PathName' -> valueName.putText;
            (phkResult,valueName,0,0,@@value.T[1],@@bufferSize)
              -> RegQueryValueEx -> result;
            (if result=ERROR_SUCCESS then
                bufferSize-1 -> value.lgth -> value.pos;
             else
                'RegEnumValueEx failed.'
                  -> screen.putline;
                value.clear;
            if);
            phkResult -> RegCloseKey -> result;
            (if not (result=ERROR_SUCCESS) then
                'RegCloseKey failed.' -> screen.putLine;
            if);
         else
            'RegOpenKeyEx NOT Ok.' -> screen.putLine;
            value.clear;
        if);
     exit value.copy
     #);

*)

-- SetRegKeyValueImpl: doPart --
do 
   (if root
    //HKEY_CLASSES_ROOT
    //HKEY_CURRENT_USER
    //HKEY_LOCAL_MACHINE
    //HKEY_USERS
    //HKEY_PERFORMANCE_DATA
       then
       
       false -> res;
       
       (if key[]<>NONE then
           key.copy -> szKey[];
        else
           &text[] -> szKey[];
       if);
       
       (if (subkey[]<>NONE) then
           '\\' -> szKey.append;
           subkey[] -> szKey.append;
       if);
       
       (root, szKey, 0, 0, 
       REG_OPTION_NON_VOLATILE, 
       KEY_ALL_ACCESS,
       NONE,
       @@hKey,
       0)
         -> RegCreateKeyEx2 -> ec;
       
       (if (ERROR_SUCCESS = ec) then
           
           (if (value[]<>NONE) then
               (if valueName[]=NONE then &text[] -> valueName[]; if);
               
               (if valueType
                //REG_SZ then
                   (if value## <= text## then
                       value[] -> textValue[];
                       (hKey,valueName,0,valueType,textValue,textValue.length+1)
                         -> RegSetValueExText -> ec;
                    else
                       'valueType and value does not match.' -> setValueFailed;
                   if);
                //REG_DWORD then
                   (if value## <= integerObject## then
                       value[] -> intValue[];
                       intValue -> intVal;
                       (hKey,valueName,0,valueType,@@intVal,4)
                         -> RegSetValueExDword -> ec;
                    else
                       'valueType and value does not match.' -> setValueFailed;
                   if);
                   
                else
                   'Unsupported valueType.' -> setValueFailed;
               if);
               
           if);
           (if (ERROR_SUCCESS = ec) then
               TRUE -> res;
            else
               ec -> getErrorMessage -> setValueFailed;
           if);
           hKey -> RegCloseKey;
        else
           ec -> getErrorMessage -> createKeyFailed;
       if);
    else
       NoSuchRoot;
   if);
   
   
-- DeleteRegKeyImpl: doPart --
do (if subKey[]<>NONE then
       (hKey, subKey) -> RegDeleteKey -> ec;
       (if (ERROR_SUCCESS = ec) then
           TRUE -> res;
        else
           ec -> getErrorMessage -> failed;
       if);
   if);
   
   
-- EnumKeysImpl: doPart --
do (#                   
      subKeyNameCstr: @cstring;
      lpcbName: @integer;
      classNameCstr: @cstring;
      lpcbClass: @integer;
      fileTimePtr: @integer;
   do (if subKeyName[]<>NONE then
          100 -> lpcbName -> subKeyNameCstr.init;
          (if className[]<>NONE then
              100 -> lpcbClass -> classNameCstr.init;
           else
              0 -> lpcbClass;              
          if);
          8 -> malloc -> fileTimePtr;
          
          (if fileTimePtr<>0 then
              (hKey,index,
              subKeyNameCstr,@@lpcbName,
              0,
              classNameCstr,@@lpcbClass,
              fileTimePtr)
                -> RegEnumKeyEx -> res;
              
              fileTimePtr -> free;
              0 -> fileTimePtr;
          if);
          
          (if res=ERROR_SUCCESS then
              subKeyNameCstr.get -> subKeyName.putText;
              
              (if className[]<>NONE then
                  classNameCstr.get -> className.puttext;
              if);           
          if);
          (if subKeyNameCstr<>0 then
              subKeyNameCstr.free;
          if);
          (if classNameCstr<>0 then
              classNameCstr.free;
          if);
      if);
   #)
   
-- QueryRegInfoKeyImpl: doPart --
do outerL:
     (# hKey: @integer; (* handle of key to query *)
        classNameCstr: @cString;
        lpcbClass: @integer;
        result: @integer;
        didOpenKey: @boolean;
     do false -> didOpenKey;
        (if keyName[]<>NONE then
            (root, keyName, 0, KEY_READ,  @@hKey) 
              -> RegOpenKeyEx -> result;
            (if result=ERROR_SUCCESS then
                true -> didOpenKey;
            if);
         else
            root ->hKey;
            ERROR_SUCCESS -> result;
        if);
        (if result=ERROR_SUCCESS then
            0 -> lpcbClass;
            (if className[]<>NONE then
                150 -> lpcbClass -> classNameCstr.init;
            if);
            (hKey,
            classNameCstr, @@lpcbClass,
            0,
            @@cSubKeys,
            0,0,
            @@cValues,
            0,0,0,0)
              -> RegQueryInfoKey 
              -> res;
            
            (if res=ERROR_SUCCESS then
                (if className[]<>NONE then
                    classNameCstr.get -> className.puttext;
                if);           
            if);
            
            (if classNameCstr<>0 then
                classNameCstr.free;
            if);
        if);
        
        (if didOpenKey then
            hKey -> RegCloseKey -> result;
            (if not (result=ERROR_SUCCESS) then
                'RegCloseKey failed.' -> screen.putLine;
            if)
        if);
     #);
