ORIGIN 'astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/v1.6/private/filebody'
	'~beta/sysutils/v1.6/endian'
	'../metagramsematt'
	'../handle';

-- treeLevelVersion: DoPart --
do private.versionNo->value; INNER

-- treeLevelGrammarIdentification: DoPart --
do (if private.grammarName[] <> none then
       private.grammarName[]->theGrammarName[]
    else
       &text[]->theGrammarName[]; undefinedGrammarName->theGrammarName
   if);
   INNER

-- treeLevelSuffix: DoPart --
do (if private.applgramSuffix[] <> none then
       private.applgramSuffix[]->theSuffix[]
    else
       &text[]->theSuffix[]; '.text'->theSuffix
   if);
   INNER

-- treelevelInit: Descriptor --
(#
   meta: ^metagrammar;
   grammar: ^meta.Agrammar;
   p,NoOfSons,maxProd: @integer;
   root: ^meta.Agrammar;
   pl: ^meta.productionList;
   cns: ^meta.Constructor;
   clist: ^meta.ConsElemList;
   exp: ^expanded;
   ls: ^meta.LeftSide;
   gn: ^meta.grammarName;
   nd: ^nameDecl;
   opAst: ^ast;
   op: ^meta.optionPart;
   consGenerator,unExpGenerator,listGenerator,optGenerator:
     ^referenceGenerator;

do
   false->parser.haveBeenInitialized;
   grammarTable.meta[]->meta[];
   &referenceGenerator (#  do &cons[]->as[] #)[]->consGenerator[];
   genUnExpanded[]->unExpGenerator[];
   &referenceGenerator (#  do &list[]->as[] #)[]->listGenerator[];
   genOptional[]->optGenerator[];
   (if grammarAst[] <> none then
   (* this should always be the case, except for the metagrammar *)
       grammarAst.root[]->root[];
       root.getOptionOp->opAst[];
       (if opAst## <= cons## then
	   opAst[]->op[];
	   meta.optionElement
	     ->op.suffixWalkForProd
	       (#
		  oe: ^meta.optionElement;
		  on: ^meta.optionName;
		  na: ^nameAppl;
		  os: ^string;
		  t: ^text
	       do
		  current[]->oe[];
		  oe.getOptionName->on[];
		  on.getNameAppl->na[];
		  na.getText->t[];
		  t.copy->t[];
		  (if ('suffix'->t.equalNCS) then
		      String
			->oe.suffixWalkForProd
			  (#
			  do
			     current[]->os[];
			     os.getText->private.applGramSuffix[];
			     private.applGramSuffix.copy
			       ->private.applGramSuffix[];

			  #)
		  if)
	       #)
       if);
       grammarAst.root[]->grammar[];
       ('version',undefinedversion)->grammar.getOptionValue->private.versionNo;
       root.getProductionList->pl[];
       (* check if the arrays need extensions *)
       pl.noOfSons->maxProd;
       (if (maxProd > kindArray.range) then
	   maxProd+1-kindArray.range->kindArray.extend;
	   maxProd+1-nodeClassArray.range->nodeClassArray.extend;
	   maxProd+1-sonArray.range->sonArray.extend;
	   maxProd+1-roomArray.range->roomArray.extend;
	   maxProd+1-genRefArray.range->genRefArray.extend;

       if);
       root.getGrammarName->gn[];
       gn.getNameDecl->nd[];
       nd.getText->private.grammarName[];
       private.grammarName.copy->private.grammarName[];
       0->p;
       pl.scan
	 (#
	 do
	    p+1->p;
	    current[]->exp[];
	    exp.getson1->ls[];
	    2*(((2->ls.getAttribute)+1) div 2)->roomArray[p];
	    (if current.symbol
	     // meta.Constructor then
		kinds.interior->kindArray[p];
		kinds.cons->nodeClassArray[p];
		current[]->cns[];
		cns.getConsElemList->clist[];
		0->NoOfSons;
		clist.scan
		  (#
		  do
		     (if current.symbol
		      // meta.Syncat // meta.TaggedSyn then
			 NoOfSons+1->NoOfSons;
		     if);

		  #);
		NoOfSons->sonArray[p];
		consGenerator[]->genRefArray[p][];

	     // meta.Alternation then
		kinds.unExpanded->kindArray[p];
		kinds.unExpanded->nodeClassArray[p];
		unExpGenerator[]->genRefArray[p][];

	     // meta.ListOne // meta.ListZero then
		kinds.interior->kindArray[p];
		kinds.list->nodeClassArray[p];
		listGenerator[]->genRefArray[p][];

	     // meta.Dummy then
		0->nodeClassArray[p]
	     // meta.Opt then
		kinds.optional->kindArray[p];
		kinds.optional->nodeClassArray[p];
		optGenerator[]->genRefArray[p][];

	    if)
	 #);

   if);
   INNER init;
   THIS(treeLevel)[]->grammartable.insert
#)

-- treeLevelPrivateVariables: Descriptor --
(# grammarName,applGramSuffix: ^text; versionNo: @integer #)

-- fragmentFullName: DoPart --
do
   &text[]->N[];
   (if fatherR[] = none then
       FullNameT[]->N.append
    else
       fatherR.FullName->N.append;
       (if not fatherR.isDirectory then ffNameSeparatorChar->N.put;  if);
       NameT[]->N.append
   if)

-- fragmentMarkAsChangedCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- fragmentMarkAsChanged: Dopart --
do
   (if theCatcher[] = none then
       theCatcher[]->markAsChangedCatcher.oldCatcher[];
       markAsChangedCatcher[]->theCatcher[]
   if);
   pack;
   false->changed;
   (if theCatcher[] = markAsChangedCatcher[] then
       markAsChangedCatcher.oldCatcher[]->theCatcher[]
   if)

-- fragmentCheckDiskRepresentation: Descriptor --
(# diskFile: @file (# binary:: trueObject #);
do
   diskFileName->diskFile.name;
   (if
   ((diskFile.entry.modTime (# error::  (#  do true->continue #) #) > modTime)
      ->haveBeenChanged) then
       INNER checkDiskRepresentation
   if)
#)

-- fragmentBind: DoPart --
do
   (if not BindMark then
       True->BindMark;
       INNER bind;
       (* If not bound by INNER then try origin *)
       (if OP[] = none then
	   (if originR[] = none then (* try setting up origin *)
	       screen[]->setupOrigin
	   if);
	   (if originR[] <> none then
	       F[]->originR.Bind->OP[]
	   if);

       if)
   if);
   False->BindMark

-- fragmentBindToOrigin: DoPart --
do (if (originR[] <> none ) then F[]->originR.Bind->OP[] if)

-- fragmentSetupOrigin: Descriptor --
(# t: ^text;
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
	doProp::
	  (#
	  do
	     prop.makelc;
	     (if 'origin'->prop.equal then
		 ScanParameters
		   (#
		      doString::
			(#
			do
			   THIS(fragment).fullName->stripPathName->t[];
			   (if t[] = none then
			       ((S.copy,currentDirectory)
				  ->thePathHandler.convertFilePath,error[])
				 ->top.open->THIS(fragment).origin
			    else
			       ((S.copy,t[])->thePathHandler.convertFilePath,
				error[])->top.open->THIS(fragment).origin
			   if);
			   leave FindOrigin;

			#)
		   #)
	     if)
	  #)
     #)
#)

-- fragmentCatcher: DoPart --
do
   (if theCatcher[] = none then
       (if (fatherR[] <> none ) then
	   (no,msg[])->fatherR.catcher
	else
	   msg[]->AstInterfaceError
       if)
    else
       (no,msg[])->theCatcher
   if)

-- fragmentLinkUnpack: Descriptor --
(# n,t: ^text
do
   &text[]->n[];
   name->n.append;
   fatherR.fullName->stripPathName->t[];
   (if t[] = none then
       ((n.copy,currentDirectory)->thePathHandler.ConvertFilePath,error[])
	 ->top.open->f[]
    else
       ((n.copy,t[])->thePathHandler.ConvertFilePath,error[])->top.open->f[]
   if);
   (if f[] = none then
       (n[],error[])->top.open->f[]
   if)
#)

-- fragmentLinkInit: DoPart --
do linkType->fragType; none ->prop[]; nameT[]->fullNameOfLink[]

-- fragmentGroupScan: dopart --
do fragmentList.scan
     (#
     do (if current.f[]=none then
	    screen[]->current.open;
	if);
	current.f[]->THIS(scan).current[];
	INNER scan
     #)

-- fragmentGroupScanIncludes: dopart --
do prop.scanProp
     (# doProp::
	  (#
	  do (if 'include'->prop.equalNCS then
		 scanParameters
		   (# doString::
			(# t: ^text
			do fullName->stripPathName->t[];
			   (if t[] = none then
			       (s.copy,currentDirectory)
				 ->thePathHandler.ConvertFilePath
				 ->name[];
			    else
			       (s.copy,t[])
				 ->thePathHandler.ConvertFilePath
				 ->name[];
			   if);
			   INNER scanIncludes
			#)
		   #);
	     if);
	  #);
     #)

-- fragmentGroupScanSlots: dopart --
do fragmentList.scan
     (# ff: ^fragmentForm;
     do (if current.type=formType then
	    screen[]->current.open->ff[];
	    ff.scanSlots
	      (#
	      do current[]->THIS(scanSlots).current[];
		 INNER scanSlots
	      #)
	if)
     #)

-- fragmentGroupOpenOpenCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- fragmentGroupOpen: Dopart --
do (if trace.active and trace.d[trace.FragmentOpen] then
       trace.FragmentOpen->signalTrace
	 (# start::
	      (#
	      do 'group-open of '->msg.putText;
		 localPath[]->msg.putText;
		 ' in '->msg.putText;
		 fullName->msg.putText;
	      #)
	 #);
   if);
   (if theCatcher[] = none then
       theCatcher[]->openCatcher.oldCatcher[]; openCatcher[]->theCatcher[]
   if);
   0->localPath.pos;
   (if localPath.getNonBlank = ascii.fs then
	 (# msg: @text
	 do
	    'Fragment name is empty: '->msg;
	    localPath[]->msg.putLine;
	    (errorNumbers.notExisting,msg[])->catcher
	 #)
   if);
   l:
     (#
     do
	(if fatherR[] = none (* we are in the top *) then
	    localPath[]->expandToFullPath->localPath[];
	 else
	    (if (1->localPath.inxGet) = '~' then leave l if);
	if);
	0->dirInx->groupInx;
	ffNameSeparatorChar->localPath.findAll (#  do inx->groupInx #);
	thePathHandler.directoryChar
	  ->localPath.findAll (#  do inx->dirInx #);
	(if (groupInx > 0) then (* xx-yy *)
	    (if (dirInx < groupInx) then (* zz/xx-yy *)
		((1,groupInx-1)->localPath.sub,error[])->open->f[];
		(if f[] <> none then
		    (if f.type = groupType then
			f[]->g[];
			((groupInx+1,localPath.length)->localPath.sub,error[])
			  ->g.open->f[];
		     else
			none ->f[]
		    if)
		if);
		leave l
	    if)
	if);
	(localPath[],error[])->fragmentList.open->f[];

     #);
   (if f[] = none then
	 (# msg: @text
	 do
	    'Fragment not found in open: '->msg;
	    localPath[]->msg.putLine;
	    (errorNumbers.notExisting,msg[])->catcher
	 #)
    else
       true->f.isOpen;
       (if f.type=grouptype then f[]->signalGroupOpen if);
   if);
   (if theCatcher[] = openCatcher[] then
       openCatcher.oldCatcher[]->theCatcher[]
   if);
   (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
	 (# start::
	      (#
	      do (if f[] = none then
		     'FAILED: '->msg.putText
		  else
		     'SUCCEEDED: '->msg.putText;
		 if);
		 'group-open of '->msg.putText;
		 localPath[]->msg.putText;
		 ' in '->msg.putText;
		 fullName->msg.putText;
	      #)
	 #);
   if)

-- fragmentGroupAlreadyOpen: Descriptor --
(# dotInx,dirInx,groupInx: @integer
do
   0->localPath.pos;
   (if localPath.getNonBlank <> ascii.fs then
       localPath[]->expandToFullPath->localPath[];
       l:
	 (#
	 do scanIncludes
	      (#
	      do (if name[]->localPath.equal then
		     (name[],screen[])->top.open->f[];
		     true->value;
		     INNER alreadyOpen;
		     leave l
		 if)
	      #);
	    fragmentList.scan
	      (# found: @boolean
	      do
		 (if current.type = formType then
		     current.name[]->localPath.equalNCS->found
		  else
		     current.name[]->localPath.equal->found
		 if);
		 (if found then
		     screen[]->current.open;
		     current.f[]->f[];
		     true->value;
		     INNER alreadyOpen;
		     leave l
		 if)
	      #)
	 #)
   if)
#)

-- fragmentGroupClose: DoPart --
do (if trace.active and trace.d[trace.FragmentClose] then
       trace.FragmentClose->signalTrace
	 (# start::
	      (#
	      do 'group-close of '->msg.putText;
		 name->msg.putText;
		 ' in '->msg.putText;
		 fullName->msg.putText;
	      #)
	 #);
   if);
   (if this(fragmentGroup)[]->signalBeforeGroupClose then
       fragmentList.scan
	 (#
	 do (if current.type = formType then
		(if (current.f[] <> none ) then
		    current.f.close; none ->current.f[]
		if)
	    if);

	 #);
       THIS(FragmentGroup)[]->top.delete;
       none ->fragmentList[];
       none ->prop[];
       this(fragmentGroup)[]->signalGroupClose;
   if)

-- fragmentGroupFragmentListElementOpen: DoPart --
do
   (if f[] = none then
       (if type
	// formType then
	   newFragmentForm->f[];
	// groupType then
	   newFragmentGroup->f[];
	// linktype then
	     (# l: ^fragmentLink
	     do
		newFragmentLink->l[]->f[];
		&text[]->l.localName[];
		localName[]->l.localName.append;

	     #);

       if);
       name.copy->f.name;
       THIS(fragmentGroup)[]->f.father;
       (if type // linkType // groupType then error[]->f.unPack if)
   if)

-- fragmentGroupFragmentListDescriptorDeleteLocalName: DoPart --
do
   l: scan
     (#
     do (if (current.name[]->n.equal) then current[]->at->delete; leave l if)
     #)

-- fragmentGroupFragmentListDescriptorFind: DoPart --
do
   l: scan
     (#
     do (if (current.name[]->n.equal) then current.f[]->r[]; leave l if)
     #);


-- fragmentGroupFragmentListDescriptorOpen: DoPart --
do (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
	 (# start::
	      (#
	      do 'Fragment-list open of '->msg.putText;
		 n[]->msg.putText;
		 ' in '->msg.putText;
		 fullName->msg.putText;
	      #)
	 #);
   if);
   loop:
     (#
     do
	scan
	  (# l: ^fragmentlink; found: @boolean
	  do
	     (if current.type = formType then
		 current.name[]->n.equalNCS->found
	      else
		 current.name[]->n.equal->found
	     if);
	     (if found then
		 (if (current.f[]->f[]) = none then
		     error[]->current.open; current.f[]->f[]
		  else
		     (if current.type = linkType then
			 f[]->l[];
			 (if l.f[] = none then
			     error[]->current.open; current.f[]->f[]
			 if)
		     if)
		 if);
		 (if trace.active and trace.d[trace.fragmentOpen] then
		     trace.fragmentOpen->signalTrace
		       (# start::
			    (# do 'Found in list'->msg.putText #)
		       #);
		 if);
		 leave loop
	     if)
	  #);
	(* if we are here, the local name of the fragment could not be
	 * found in the fragmentList. We will newer the less try and see if
	 * we can find the fragment
	 *)
	  (#
	     g: ^fragmentGroup;
	     fName,origFName: ^text;
	     dirInx,groupInx,dotInx: @integer;
	     fileExist:
	       (# f: @file
	       enter f.name
	       exit f.entry.exists
		 (#
		    error::
		      (#
		      do
			 true->continue;
			 (errorNumbers.otherFileError,msg[])->catcher
		      #)
		 #)
	       #);
	     isFile:
	       (# f: @file
	       enter f.name
	       exit f.entry.isFile
		 (#
		    error::
		      (#
		      do
			 true->continue;
			 (errorNumbers.otherFileError,msg[])->catcher
		      #)
		 #)
	       #);
	     fileReadable:
	       (# f: @file
	       enter f.name
	       exit f.entry.readable
		 (#
		    error::
		      (#
		      do
			 true->continue;
			 (errorNumbers.otherFileError,msg[])->catcher
		      #)
		 #)
	       #)
	  do
	     &Element[]->e[];
	     none ->e.f[];
	     fullName->fName[];
	     fName.copy->fName[];
	     ffNameSeparatorChar->fName.put;
	     n[]->(fName.Copy).Append->fName[];
	     n.copy->e.name[];
	     fName.copy->origFName[];
	     try:
	     (if true
	      // (astFileExtension->(fName.Copy).Append->fileExist) then
	      (* o.k. we are in real group *)
		 groupType->e.type;
		 e[]->append;
		 error[]->e.open->f[];
		 MarkAsChanged;

	      // ('.text'->(fName.Copy).Append->fileExist) then
		 groupType->e.type; e[]->append; error[]->e.open->f[];
	      else
		 loop:
		   (#
		   do
		      grammarTable.scan
			(# name: ^text
			do
			   (if
			   (currentExtension[]->(fName.Copy).Append->name[]
			      ->fileExist) then
			       groupType->e.type;
			       e[]->append;
			       error[]->e.open->f[];
			       leave loop
			   if)
			#);
		      0->dotInx;
		      '.'->fName.findAll (#  do inx->dotInx #);
		      (if dotInx > 1 then
			  0->dirInx->groupInx;
			  ffNameSeparatorChar
			    ->fName.findAll (#  do inx->groupInx #);
			  thePathHandler.directoryChar
			    ->fName.findAll (#  do inx->dirInx #);
			  (if true
			   // (dirInx > groupInx) then (* xx-yy/zz *)
			      (if (dotInx > dirInx) then (* xx-yy/zz.rr *)
				  (dotInx,fName.length)->fName.delete;
				  restart try
			      if)
			   // (dirInx < groupInx) then (* xx/yy-zz *)
			      (if true
			       // (dotInx > groupInx) then (* xx/yy-zz.rr *)
				  (dotInx,fName.length)->fName.delete;
				  restart try
			       // (dotInx > dirInx) then (* xx/yy.rr-zz *)
				  (dotInx,groupInx-1)->fName.delete; restart try
			      if)
			   else
			  (* xx.rr *)
			      (dotInx,fName.length)->fName.delete; restart try
			  if)
		      if);
		      (* well. we did not find the file. If the file ifself
		       * exist, lets us try to parse it
		       *)
		      origFName[]->fName[];
		      (if (fName[]->fileExist) then
			  (if (fName[]->isFile) then
			      (if (fName[]->fileReadable) then
				    (# fg: ^fragmentGroup; dotInx: @integer
				    do
				       '.'
					 ->fName.findAll
					   (#  do inx->dotInx #);
				       (if (dotInx > 1) then
				       (* >1 to avoid empty filename before '.' *)
					   newFragmentGroup->fg[];
					   (1,dotInx-1)->fName.sub->e.name[];
					   e.name[]->fg.name;
					   e.name[]->fg.fullNameT[];
					   (notificationNumbers.startingParsing,
					    '')->catcher;
					   theParse:
					   (if
					   ((fName[],error[])
					      ->fg.parse
						(#
						   parseErrors::
						     (#
						     do
							(errorNumbers.
							   parseErrors,
							 ' Parse errors ')
							  ->catcher;
							false->ok;
							true->continue
						     #);
						   doubleFormDeclaration::
						     (#
						     do
							(errorNumbers.
							   doubleFormDeclaration,
							 ' Double declaration of form ')
							  ->catcher;
							true->continue
						     #);

						#)) then
					       fg[]->f[];
					       groupType->e.type;
					       e[]->append;

					   if)
				       if)
				    #)
			       else
				    (# t: @text
				    do
				       'No read access to the file: "'->t;
				       fName[]->t.append;
				       '"'->t.putline;
				       (errorNumbers.noReadAccess,t[])->catcher
				    #)
			      if)
			   else
				(# t: @text
				do
				   'Filename "'->t;
				   fName[]->t.append;
				   '" refers to a directory, not a file'
				     ->t.putline;
				   (errorNumbers.otherFileError,t[])->catcher
				#)
			  if)
		       else
			    (# t: @text
			    do
			       'Filename "'->t;
			       fName[]->t.append;
			       '" does not exist'->t.putline;
			       (errorNumbers.notExisting,t[])->catcher
			    #)
		      if)
		   #)
	     if)
	  #)
     #);
   (if f[] <> none then
       true->f.isOpen;
   if);
   (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
	 (# start::
	      (#
	      do (if f[] = none then
		     'FFAILED: '->msg.putText
		  else
		     'FSUCCEEDED: '->msg.putText;
		 if);
		 'Fragment-list open of '->msg.putText;
		 n[]->msg.putText;
		 ' in '->msg.putText;
		 fullName->msg.putText
	      #)
	 #);
   if)

-- fragmentGroupFragmentListDescriptorInsertFragment: Dopart --
do
   (if theCatcher[] = none then
       theCatcher[]->addFragmentHandler.oldCatcher[];
       addFragmentHandler[]->theCatcher[]
   if);
   l:
     (#
     do
	scan
	  (#
	  do
	     (if (f.name->current.name.equalNCS) then
		 current[]->newElement[];
		   (# t: @text
		   do
		      'Fragment: "'->t;
		      f.name->t.append;
		      '" is already in this fragment group: "'->t.append;
		      THIS(fragmentGroup).name->t.append;
		      '"'->t.append;
		      t[]->alreadyThere
		   #);
		 leave l
	     if)
	  #);
	&Element[]->newElement[];
	f.name->newElement.name[];
	INNER insertFragment;

     #);
   f[]->newElement.f[];
   f.type->newElement.type;
   (if f.type = linktype then
	 (# l: ^fragmentLink
	 do
	    f[]->l[];
	    l.fullNameOfLink[]->newElement.fullNameOfLink[];
	    l.localName[]->newElement.localName[];

	 #);

   if);
   THIS(fragmentGroup)[]->f.father;
   f.markAsChanged;
   (if theCatcher[] = addFragmentHandler[] then
       addFragmentHandler.oldCatcher[]->theCatcher[]
   if)

-- fragmentGroupFragmentListDescriptorInsertFragmentCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- fragmentSaveAsCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- FragmentGroupSaveAs: Descriptor --
(# savename1,savename2: ^text;
do
   (if theCatcher[] = none then
       theCatcher[]->saveAsCatcher.oldCatcher[]; saveAsCatcher[]->theCatcher[]
   if);
   fullnameT.copy->savename1[];
   nameT.copy->savename2[];
   fullname[]->fullnameT[];
   fullname[]->nameT[];
   pack;
   savename1.copy->fullnameT[];
   savename2.copy->nameT[];
   (if theCatcher[] = saveAsCatcher[] then
       saveAsCatcher.oldCatcher[]->theCatcher[]
   if);

#)

-- fragmentSaveBackupCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- FragmentGroupSaveBackup: dopart --
do
   (if theCatcher[] = none then
       theCatcher[]->saveBackupCatcher.oldCatcher[];
       saveBackupCatcher[]->theCatcher[]
   if);
   ext.copy->backUpExt[];
   pack;
   none ->backUpExt[];
   (if theCatcher[] = saveBackupCatcher[] then
       saveBackupCatcher.oldCatcher[]->theCatcher[]
   if)

-- fragmentRestoreBackupCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- FragmentGroupRestoreBackup: Descriptor --
(#
   diskFile: @file (# binary:: trueObject #);
   name: ^Text;
   oldDoRealOpen: @boolean;

do
   (if theCatcher[] = none then
       theCatcher[]->restoreBackupCatcher.oldCatcher[];
       restoreBackupCatcher[]->theCatcher[]
   if);
   diskFileName->name[];
   ext[]->(name.copy).append->name[];
   name[]->diskFile.name;
   init;
   ext.copy->backUpExt[];
   doRealOpen->oldDoRealOpen;
   true->doRealOpen;
   screen[]->unpack;
   oldDoRealOpen->doRealOpen;
   none ->backUpExt[];
   (if theCatcher[] = restoreBackupCatcher[] then
       restoreBackupCatcher.oldCatcher[]->theCatcher[]
   if);

#)

-- fragmentGroupDiskFullName: DoPart --
do
   astFileExtension->((fullName).copy).Append->t[];
   (if backUpExt[] <> none then backupExt[]->t.append if);


-- fragmentGroupTextFileName: DoPart --
do
   l:
   (if defaultGrammar[] = none then
       grammarTable.scan
	 (# name: @text; f: @file
	 do
	    fullName->t[];
	    t->t;
	    currentExtension[]->t.append;
	    t.copy->f.name;
	    (if f.entry.exists
	      (#
		 error::
		   (#
		   do
		      true->continue;
		      (errorNumbers.otherFileError,msg[])->catcher
		   #)
	      #) then
		current[]->defaultGrammar[]; leave l
	    if);

	 #);
       fullName->t[];
       t->t;
       '.text'->t.append;

    else
       fullName->t[]; t->t; defaultGrammar.suffix->t.append
   if);


-- fragmentGroupIsRealOpen: DoPart --
do
   (if isOpen then
       (if none
	// prop[] // fragmentList[] then false->opened
	else
	   scanner: fragmentList.scan
	     (# ff: ^astinterface.fragmentForm
	     do
		(if current.type
		 // formType then
		    (if current.f[] <> none then
			current.f[]->ff[];
			(if none
			 // ff.grammar[] // ff.root[] then
			    false->opened; leave scanner
			 else
			    true->opened
			if);

		     else
			false->opened; leave scanner
		    if)
		if)
	     #)
       if)
    else
       false->opened
   if)

-- fragmentRealOpenCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- fragmentGroupRealOpen: Descriptor --
(#
   f: @file
     (#
	accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #);
	binary:: trueObject
     #);
   getRep: @f.getRep;
   b: [2] @integer;
   garbagefl: ^fragmentListDescription;
   garbageProp: ^propertyList;

do
   (if theCatcher[] = none then
       theCatcher[]->realOpenCatcher.oldCatcher[];
       realOpenCatcher[]->theCatcher[]
   if);
   diskFileName->f.name;
   (if trace.active and trace.d[trace.FragmentOpen] then
       trace.FragmentOpen->signalTrace
	 (# start::
	      (# do 'OpenRead fragmentGroup-file: '->msg.puttext; f.name->msg.puttext #)
	 #);
   if);
   (if f.entry.isFile
     (#
	error::
	  (#
	  do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	  #)
     #) then
       (if f.entry.readable
	 (#
	    error::
	      (#
	      do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	      #)
	 #) then
	   f.openRead
	else
	     (# t: @text
	     do
		'No read access to the file: "'->t;
		f.name->t.append;
		'"'->t.putline;
		(errorNumbers.noReadAccess,t[])->catcher
	     #)
       if)
    else
	 (# t: @text
	 do
	    'Filename "'->t;
	    f.name->t.append;
	    '" refers to a directory, not a file'->t.putline;
	    (errorNumbers.otherFileError,t[])->catcher
	 #)
   if);
   (@@ b[1],b.range)->getRep;
   (if (b[2] > repS.r.range) then b[2]-repS.r.range->repS.extend;  if);
   0->repS.top;
   (@@ repS.r[1],b[2])->getRep;
   (* get r from f *)
   &fragmentListDescription[]->garbagefl[];
   repS[]->garbagefl.repRestore;
   none ->garbagefl[];
   &propertyList[]->garbageProp[];
   repS[]->garbageProp.repRestore;
   none ->garbageprop[];
   fragmentList.scan
     (# ff: ^fragmentForm
     do
	(if current.type = formType then
	    screen[]->current.open;
	    current.f[]->ff[];
	    repS[]->ff.repRestoreStruct
	if)
     #);
   fragmentList.scan
     (# ff: ^fragmentForm
     do
	(if current.type = formType then
	    current.f[]->ff[];
	    (@@ ff.a[1],ff.curTop)->getRep;
	    ff.rootInx->ff.indexToNode->ff.root[];

	if)
     #);
   f.close;
   (if theCatcher[] = realOpenCatcher[] then
       realOpenCatcher.oldCatcher[]->theCatcher[]
   if);

#)

-- fragmentGroupLock: dopart --
do true->locked.value;
   this(fragmentGroup)[]->signalGroupLock;

-- fragmentGroupUnlock: dopart --
do false->locked.value;
   this(fragmentGroup)[]->signalGroupUnlock;

-- fragmentGroupPack: DoPart --
do
   l:
     (#
	f: @file
	  (#
	     accessError::
	       (#
	       do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
	       #);
	     writeError::
	       (#
	       do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
	       #);
	     readError::
	       (#
	       do (errorNumbers.noReadAccess,msg[])->catcher; leave l
	       #);
	     EOSError::
	       (#  do (errorNumbers.EOSerror,msg[])->catcher; leave l #);
	     noSuchFileError::
	       (#  do (errorNumbers.noSuchFile,msg[])->catcher; leave l #);
	     fileExistsError::
	       (#  do (errorNumbers.fileExists,msg[])->catcher; leave l #);
	     noSpaceError::
	       (#  do (errorNumbers.noSpaceLeft,msg[])->catcher; leave l #);
	     otherError::
	       (#
	       do (errorNumbers.otherFileError,msg[])->catcher; leave l
	       #);
	     binary:: trueObject
	  #);
	putRep: @f.putRep;
	b: [2] @integer;
	dirWriteable:
	  (# f: @file
	  enter f.name
	  exit f.entry.writeable
	    (#
	       error::
		 (#
		 do
		    true->continue; (errorNumbers.otherFileError,msg[])->catcher
		 #)
	    #)
	  #)
     do
	(if not isDirectory then
	    0->repS.top;
	    repS[]->fragmentList.repSave;
	    repS[]->prop.repSave;
	    fragmentList.scan
	      (# ff: ^fragmentForm
	      do
		 (if current.type = formType then
		     current.f[]->ff[]; repS[]->ff.repSaveStruct
		 if)
	      #);
	    groupBlackNumber->b[1];
	    repS.top->b[2];
	    diskFileName->f.name;
	    (if trace.active and trace.d[trace.FragmentOpen] then
		trace.FragmentOpen->signalTrace
		  (# start::
		       (# do 'OpenWrite fragmentGroup-file: '->msg.puttext; f.name->msg.puttext #)
		  #);
	    if);
	    (if (f.entry.path.head->dirWriteable) then
		(if f.entry.writeable
		  (#
		     error::
		       (#
		       do
			  true->continue;
			  (errorNumbers.otherFileError,msg[])->catcher
		       #)
		  #) then
		    f.openWrite
		 else
		      (# t: @text
		      do
			 'No write access to the file: "'->t;
			 f.name->t.append;
			 '"'->t.putline;
			 (errorNumbers.noWriteAccess,t[])->catcher;
			 leave l
		      #)
		if)
	     else
		  (# t: @text
		  do
		     'No write access to the directory: "'->t;
		     f.entry.path.head->t.append;
		     '"'->t.putline;
		     (errorNumbers.noWriteAccess,t[])->catcher;
		     leave l
		  #)
	    if);
	    (@@ b[1],b.range)->putRep;
	    (@@ repS.r[1],repS.top)->putRep;
	    (* save r on f *)
	    fragmentList.scan
	      (# ff: ^fragmentForm
	      do
		 (if current.type = formType then
		     current.f[]->ff[]; (@@ ff.a[1],ff.curTop)->putRep
		 if)
	      #);
	    f.close;
	    (if backUpExt[] = none then
		f.entry.modTime (# error::  (#  do true->continue #) #)->modTime
	    if);
	    this(fragmentGroup)[]->signalGroupPack
	if)
     #)

-- fragmentGroupUnpack: Descriptor --
(#
   f: @file
     (#
	accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #);
	binary:: trueObject
     #);
   textFile: @file
     (#
	accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #)
     #);
   t,s: ^text;

do
   fragmentlist.clear;
   diskFileName->t[];
   t.copy->f.name;
   textFileName->t[];
   t.copy->textFile.name;
   (if
   ((textFile.entry.ModTime (# error::  (#  do true->continue #) #) >
     f.entry.ModTime (# error::  (#  do true->continue #) #)) or
    (options.forceParse)) then
       (if textFile.entry.exists
	 (#
	    error::
	      (#
	      do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	      #)
	 #) then
	   (if textFile.entry.isFile
	     (#
		error::
		  (#
		  do
		     true->continue;
		     (errorNumbers.otherFileError,msg[])->catcher
		  #)
	     #) then
	       (if textFile.entry.readable
		 (#
		    error::
		      (#
		      do
			 true->continue;
			 (errorNumbers.otherFileError,msg[])->catcher
		      #)
		 #) then
		   (notificationNumbers.startingParsing,'')->catcher;
		   (if trace.active and trace.d[trace.onParse] then
		       trace.onParse->signalTrace
			 (# start::
			      (#
			      do 'parsing "'->msg.putText;
				 fullName->msg.putText;
				 '"'->msg.put
			      #)
			 #);
		   if);
		   theParse:
		   (if
		   ((textfile.name,error[])
		      ->parse
			(#
			   parseErrors::
			     (#
			     do
				(errorNumbers.parseErrors,' Parse errors ')
				  ->catcher;
				false->ok;
				true->continue
			     #);
			   doubleFormDeclaration::
			     (#
			     do
				(errorNumbers.doubleFormDeclaration,
				 ' Double declaration of form ')->catcher;
				true->continue
			     #)
			#)) then
		       (if trace.active and trace.d[trace.onParse] then
			   trace.onParse->signalTrace
			     (# start::
				  (# do msg.newLine #)
			     #);
		       if);
		   if)
		else
		     (# t: @text
		     do
			'No read access to the file: "'->t;
			textFile.name->t.append;
			'"'->t.putline;
			(errorNumbers.noReadAccess,t[])->catcher
		     #)
	       if)
	    else
		 (# t: @text
		 do
		    'Filename "'->t;
		    textFile.name->t.append;
		    '" refers to a directory, not a file'->t.putline;
		    (errorNumbers.otherFileError,t[])->catcher
		 #)
	   if)
	else
	     (# t: @text
	     do
		'Filename "'->t;
		textFile.name->t.append;
		'" does not exist'->t.putline;
		(errorNumbers.noSuchFile,t[])->catcher
	     #)
       if)
    else
       (if f.entry.exists
	 (#
	    error::
	      (#
	      do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	      #)
	 #) then
	     (# getRep: @f.getRep; b: [2] @integer
	     do (if trace.active and trace.d[trace.FragmentOpen] then
		    trace.FragmentOpen->signalTrace
		      (# start::
			   (#
			   do 'OpenRead(unpack) fragmentGroup-file: '->msg.puttext;
			      f.name->msg.puttext
			   #)
		      #);
		if);
		(if f.entry.isFile
		  (#
		     error::
		       (#
		       do
			  true->continue;
			  (errorNumbers.otherFileError,msg[])->catcher
		       #)
		  #) then
		    (if f.entry.readable
		      (#
			 error::
			   (#
			   do
			      true->continue;
			      (errorNumbers.otherFileError,msg[])->catcher
			   #)
		      #) then
			f.openRead
		     else
			  (# t: @text
			  do
			     'No read access to the file: "'->t;
			     f.name->t.append;
			     '"'->t.putline;
			     (errorNumbers.noReadAccess,t[])->catcher
			  #)
		    if)
		 else
		      (# t: @text
		      do
			 'Filename "'->t;
			 f.name->t.append;
			 '" refers to a directory, not a file'->t.putline;
			 (errorNumbers.otherFileError,t[])->catcher
		      #)
		if);
		(@@ b[1],b.range)->getRep;
		(if (b[1] <> groupBlackNumber) then
		      (# t: @text
		      do
			 ' Trying to access a group file with wrong magic number "'
			   ->t;
			 fullName->t.append;
			 '"'->t.put;
			 (errorNumbers.badformat,t[])->catcher;

		      #);

		if);
		(if (b[2] > repS.r.range) then
		    b[2]-repS.r.range->repS.extend;
		if);
		0->repS.top;
		(@@ repS.r[1],b[2])->getRep;
		(* get r from f *)
		repS[]->fragmentList.repRestore;
		repS[]->prop.repRestore;
		(if linkList[]<>NONE then
		    linkList.scan
		      (# (* this code is to be removed, when no more ast's
			  * exist with the old fragmentlink storage format
			  *)
		      do l: (#
			    do prop.scanprop
				 (# doProp::
				      (#
				      do prop.makelc;
					 (if 'include'->prop.equal then
					     scanParameters
					       (# doString::
						    (#
						    do (if s[]->current.equal then
							   leave l
						       if)
						    #)
					       #)
					 if)
				      #)
				 #);
			       (* if here, not found in 'include' property - add it *)
			       'include'->prop.addprop
				 (# ifPropExist:: (# do false->delete #)
				 do current[]->addString
				 #);
			    #)
		      #)
		if);
		(if doRealOpen then
		    fragmentList.scan
		      (# ff: ^fragmentForm
		      do
			 (if current.type = formType then
			     current.f[]->ff[]; repS[]->ff.repRestoreStruct
			 if)
		      #);
		    fragmentList.scan
		      (# ff: ^fragmentForm
		      do
			 (if current.type = formType then
			     current.f[]->ff[];
			     (@@ ff.a[1],ff.curTop)->getRep;
			     ff.rootInx->ff.indexToNode->ff.root[];
			     (if defaultGrammar[] = none then
				 ff.grammar[]->defaultGrammar[]
			     if);

			 if)
		      #);

		if);
		f.close;
		f.entry.modTime (# error::  (#  do true->continue #) #)
		  ->modTime;
		this(fragmentGroup)[]->signalGroupUnpack
	     #)
       if)
   if);

#)

-- fragmentGroupInit: DoPart --
do
   GroupType->FragType;
   false->isDirectory;
   &fragmentListDescription[]->fragmentList[];
   fragmentList.init;


-- fragmentGroupBind: Descriptor --
(# fName: ^text
do
   F.name->fName[];
   L: scanSlots
     (#
     do
	(if (current.Name->fName.equalNCS) then
	    current[]->op[]->f.binding[]; leave l
	if)
     #)
#)

-- fragmentGroupGetBinding: DoPart --
do (if trace.active and trace.d[trace.GetBinding] then
       trace.GetBinding->signalTrace
	 (# start::
	      (#
	      do 'GetBinding of '->msg.putText;
		 (0,msg[])->sl.dump;
		 ' for '->msg.putText;
		 THIS(fragmentGroup).fullName->msg.putText;
	      #)
	 #);
   if);
   THIS(fragmentGroup)[]->markRelatedFragments;
   (* mark visible groups *)
   Mark.Scan (* scan visible groups for forms *)
     (#
	currentScan: current.Scan
	  (# F: ^FragmentForm; B: ^SlotDesc
	  do
	     (if current.FragType = FormType then
		 current[]->f[];
		 (if f.binding[] = none then
		     f[]->THIS(currentScan).current.bind
		 if);
		 f.binding[]->b[];
		 (if (b[] <> none ) then
		     (if (b[]->sl.equal) then current[]->found if)
		 if)
	     if)
	  #)
     do currentScan
     #)

-- fragmentGroupGetBindingMark: DoPart --
do
   Insert:
     (# R: ^Elm
     do
	false->inserted;
	head[]->R[];
	L:
	(if (R[] <> none ) then
	    (if R.F[] = F[] then leave insert if); R.succ[]->R[]; restart L
	if);
	(* not found *)
	&Elm[]->R[];
	F[]->R.F[];
	head[]->R.succ[];
	R[]->Head[];
	True->inserted;
	(if trace.active and trace.d[trace.GetBindingMark] then
	    trace.GetBindingMark->signalTrace
	      (# start::
		   (# do 'marked: '->msg.putText; f.fullname->msg.putText #)
	      #);
	if)
     #)

-- fragmentGroupGetBindingMarkScan: Descriptor --
(# R: ^Elm
do
   head[]->R[];
   L:
   (if (R[] <> none ) then
       R.F[]->current[]; INNER scan; R.succ[]->R[]; restart L
   if)
#)

-- fragmentGroupGetBindingFound: Dopart --
do (if trace.active and trace.d[trace.GetBinding] then
       trace.GetBinding->signalTrace
	 (# start::
	      (#
	      do 'binding found '->msg.puttext;
		 theBinding.fullName->msg.puttext
	      #)
	 #);
   if);
   INNER found

-- fragmentFormCategory: DoPart --
do (if root[] = none then 0->sy else root.symbol->sy if)

-- fragmentFormRecomputeSlotChain: Descriptor --
(# theExpanded: ^expanded
do
   0->firstSlot;
   (if root.kind = kinds.interior then
       root[]->theExpanded[];
       unExpanded
	 ->theExpanded.suffixWalkForProd
	   (# scanCat:: unExpanded; theSlot: ^slotDesc;
	   do
	      (if current.isSlot then
		  current.theSlot->theSlot[];
		  firstSlot->a[theSlot.index+offset.usage];
		  theSlot.index->firstSlot;

	      if);

	   #);

   if)
#)

-- fragmentFormScanSlots: DoPart --
do
   firstSlot->inx;
   loop:
   (if (inx <> 0) then
       inx->indexToNode->current[];
       current.usageInx->inx;
       INNER scanSlots;
       restart loop
   if);


-- fragmentFormIndexToNode: Descriptor --
(#
   symbol,val: @integer;
   errorMsg:
     (# t,msg: ^text
     enter t[]
     do
	'*** Error in IndexToNode: '->msg[];
	t[]->msg.append;
	'\nIndex='->msg.puttext;
	inx->msg.putint;
	'\nSymbol='->msg.puttext;
	symbol->msg.putint;
	'\nVal='->msg.puttext;
	val->msg.putint;
	'\nFragment='->msg.puttext;
	fullname->msg.puttext;
	'\nFragment is '->msg.puttext;
	(if (father).isRealOpen then
	    'open'->msg.puttext
	 else
	    'ONLY semiOpen'->msg.puttext
	if);
	msg.newline;
     exit msg[]
     #)
do
   l:
   (if true
    // (0 < inx) and (inx <= a.range) then
       a[inx]->val->tos'%GetSignedBits[4,12]'->symbol;
       (* inline expansion of inx -> getSymbol -> symbol *)
       (if (0 < symbol) and (symbol <= grammar.genRefArray.range) then
	   (if (grammar.genRefArray[symbol]->as[]) = none then
	   (* IndexToNode: genRefArray problem *)
	       'genRefArray problem'->errorMsg->grammarGenRefArrayError; leave l
	   if)
	else
	   (if symbol
	    // prodNo.unExpanded then
	       &UnExpanded[]->as[]
	    // prodNo.optional then
	       &Optional[]->as[]
	    // prodNo.nameDecl then
	       &NameDecl[]->as[]
	    // prodNo.nameAppl then
	       &NameAppl[]->as[]
	    // prodNo.string then
	       &String[]->as[];
	    // prodNo.Const then
	       &Const[]->as[];
	    // prodNo.Comment then
	       &Comment[]->as[]
	    // prodNo.SlotDesc then
	       &SlotDesc[]->as[]
	    else
	   (* IndexToNode: no match for symbol! *)
	       none ->as[]; 'no such symbol'->errorMsg->noSuchSymbol; leave l
	   if)
       if);
       inx->as.index;
       THIS(fragmentForm)[]->as.frag[]
    // (0 = inx) then (* Zero index is the same as a NONE ast *)
       none ->as[]
    else
   (* IndexToNode: index out of range *)
       none ->as[]; 'index out of range'->errorMsg->indexOutOfRange
   if)
#)

-- fragmentFormInit: DoPart --
do 2->curTop; formtype->fragtype; import.init; INNER init

-- fragmentFormReset: DoPart --
do import.makeNull; 'Semanticerrors'->prop.deleteProp

-- topTableOpen: DoPart --
do (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
	 (# start::
	      (#
	      do 'top-table open of '->msg.puttext;
		 fullname[]->msg.putline;
		 '\tOpen fragments:'->msg.putline;
		 scan
		   (# do '\t\t'->msg.puttext; current.fullname[]->msg.putline #);
	      #)
	 #);
   if);
   (* is the group already open? *)
   (# f: @file; t: ^text;
   do fullname[]->f.name;
      (if f.entry.path.name.suffix->grammarTable.legalExtension then
	  f.entry.path.head->t[];
	  directoryChar->t.put;
	  f.entry.path.name.prefix->t.append->fullname[];
      if)
   #);
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
       (# predicate::  (#  do fullname[]->current.fullname.equal->value #);
       do current.g[]->g[];
       #);
   none ->dummy.fullname[];
   (if g[] = none then
       (* if we are here, the fragment could not be found in the
	* fragmentList.  Try look at the disk for the file.
	*)
       (# fileExist:
	    (# f: @file
	    enter f.name
	    exit f.entry.exists
		 (# error::
		     (#
		     do true->continue;
			(errorNumbers.otherFileError,msg[])->catcher
		     #)
		 #)
	    #);
       do &Element[]->e[];
	  fullName.copy->e.fullName[];
	  (if true
	   // (astFileExtension->(fullName.Copy).Append->fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
		    (# start::
			 (# do 'opening .ast file...'->msg.puttext #)
		    #);
	      if);
	      (* o.k. we are in real group *)
	      error[]->e.open->g[];
	      e[]->insert;
	   // ('.bet'->(fullName.Copy).Append->fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
		    (# start::
			 (# do 'opening .bet file...'->msg.puttext #)
		    #);
	      if);
	      error[]->e.open->g[];
	      e[]->insert;
	   // ('.text'->(fullName.Copy).Append->fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
		    (# start::
			 (# do 'opening .text file...'->msg.puttext #)
		    #);
	      if);
	      error[]->e.open->g[];
	      e[]->insert;
	   else
	      loop: grammarTable.scan
		(#
		do (if (currentExtension[]->(fullName.Copy).Append->fileExist) then
		       (if trace.active and trace.d[trace.topOpen] then
			   trace.topOpen->signalTrace
			     (# start::
				  (#
				  do 'opening '->msg.puttext;
				     currentExtension[]->msg.puttext;
				     ' file...'->msg.puttext;
				  #)
			     #);
		       if);
		       error[]->e.open->g[];
		       e[]->insert;
		       leave loop
		   if)
		#);
	      (if g[] = none then
		  (# t: ^Text;
		     dotInx: @integer;
		     fg: ^FragmentGroup;
		     isFile:
		       (# f: @file
		       enter f.name
		       exit f.entry.isFile
			    (# error::
				 (#
				 do true->continue;
				     (errorNumbers.otherFileError,msg[])
				       ->catcher
				  #)
			     #)
		       #);
		     fileReadable:
		       (# f: @file
		       enter f.name
		       exit f.entry.readable
			    (# error::
				 (#
				 do true->continue;
				    (errorNumbers.otherFileError,msg[])
				      ->catcher
				 #)
			    #)
		       #)
		  do (if not (fullname[]->fileExist) then
			 'Filename "'->t[];
			 fullName[]->t.append;
			 '" could not be opened using any known grammar'
			   ->t.putline;
			 (errorNumbers.notExisting,t[])->catcher
		     if);
		     (if not (fullname[]->isFile) then
			 'Filename "'->t[];
			 fullName[]->t.append;
			 '" refers to a directory, not a file'->t.putline;
			 (errorNumbers.otherFileError,t[])->catcher
		     if);
		     (if not (fullname[]->fileReadable) then
			 'No read access to the file: "'->t[];
			 fullName[]->t.append;
			 '"'->t.putline;
			 (errorNumbers.noReadAccess,t[])->catcher
		     if);
		     (* ok. try parse the file *)
		     (*'ok. try parse the file'->screen.putline;*)
		     '.'->fullName.findAll (#  do inx->dotInx #);
		     (if (dotInx > 1) then
			 (* >1 to avoid empty filename before '.' *)
			 newFragmentGroup->fg[];
			 (1,dotInx-1)->fullName.sub->e.fullname[];
			 e.fullname[]->fg.fullnameT[]->fg.nameT[];
			 (notificationNumbers.startingParsing,'')->catcher;
			 theParse:
			   (if ((fullName[],error[])
				  ->fg.parse
				  (# parseErrors::
				       (#
				       do (errorNumbers.parseErrors,
					     ' Parse errors ')->catcher;
					  false->ok;
					  true->continue
				       #);
				     doubleFormDeclaration::
				       (#
				       do (errorNumbers.doubleFormDeclaration,
					   ' Double declaration of form ')
					    ->catcher;
					  true->continue
				       #);
				  #)) then
			       fg[]->e.g[]->g[]; e[]->insert;
			   if)
		     if)
		  #)
	      if);
	  if);
       #)
   if);
   (if g[] <> none then true->g.isOpen if);
   (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
	 (# start::
	      (#
	      do (if g[] = none then
		     'F_FAILED: '->msg.putText
		  else
		     'F_SUCCEEDED: '->msg.putText;
		 if);
		 'Top-Table open of '->msg.putText;
		 fullName[]->msg.putText;
	      #);
	 #)
   if)


-- topTableElementOpen: DoPart --
do (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
	 (# start::
	      (# do 'top-table-element-open of '->msg.putText; fullname[]->msg.putText #)
	 #);
   if);
   (if g[] = none then
       newFragmentGroup->g[];
       fullname.copy->g.fullnameT[]->g.nameT[];
       error[]->g.unPack;
       (if trace.active and trace.d[trace.topOpen] then
	   trace.topOpen->signalTrace
	     (# start::
		  (#
		  do 'top-table-element-unpack of '->msg.putText;
		     g.fullname->msg.putText
		  #)
	     #);
       if)
   if)

-- topTableFind: DoPart --
do
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
       (#
	  predicate::  (#  do fullname[]->current.fullname.equal->value #);
       do current.g[]->g[];
       #);


-- topOpenCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- topInit: DoPart --
do groupTable.init; &FragmentGroup[]->topGroup[];

-- topOpen: Descriptor --
(# fullName: ^Text;
do (if trace.active and trace.d[trace.TopOpen] then
       trace.TopOpen->signalTrace
	 (# start::
	      (# do 'top-open of '->msg.putText; filename[]->msg.putText #)
	 #);
   if);
   (if theCatcher[] = none then
       theCatcher[]->openCatcher.oldCatcher[]; openCatcher[]->theCatcher[]
   if);
   0->fileName.pos;
   (if fileName.getNonBlank = ascii.fs then
	 (# msg: @text
	 do
	    'Fragment file name is empty: '->msg;
	    fullname[]->msg.putLine;
	    (errorNumbers.notExisting,msg[])->theCatcher
	 #)
   if);
   (if (1->fileName.inxGet) <> '/' then
       fileName[]->expandToFullPath->fullName[];
    else
       fileName.copy->fullName[];
   if);
   (fullName[],error[])->groupTable.open->g[];
   (if g[] = none then
	 (# msg: @text
	 do
	    'Fragment file not found in open: '->msg;
	    fullName[]->msg.putLine;
	    (errorNumbers.notExisting,msg[])->theCatcher
	 #)
    else
       true->g.isOpen; topGroup[]->g.father;
   if);
   (if theCatcher[] = openCatcher[] then
       openCatcher.oldCatcher[]->theCatcher[]
   if);
   (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
	 (# start::
	      (#
	      do (if g[] = none then
		     'FAILED: '->msg.putText
		  else
		     'SUCCEEDED: '->msg.putText;
		 if);
		 'top-open of '->msg.putText;
		 fullName[]->msg.putText;
	      #)
	 #);
   if)
#)

-- topNewGroup: DoPart --
do
   (if (fullname[]->isOpen) = none then
       newFragmentGroup->fg[];
       fullname.copy->fg.name;
       fullname.copy->fg.fullnameT[];
       fg[]->insert;
       (* insert into top table *)

    else
	 (# msg: @text
	 do
	    'top.newGroup: '->msg.puttext;
	    fullname[]->msg.puttext;
	    'is already open'->msg.putline;
	    msg[]->alreadyOpen;

	 #);

   if);


-- topClose: dopart --
do fg.nameT[]->namedClose;

-- topNamedClose: Dopart --
do (if trace.active and trace.d[trace.TopClose] then
       trace.TopClose->signalTrace
	 (# start::
	      (# do 'top-close of '->msg.putText; fullname[]->msg.putText #)
	 #);
   if);
   fullname[]->groupTable.dummy.fullname[];
   groupTable.dummy[]->groupTable.hashfunction
     ->groupTable.findIndexed
       (#
	  predicate::  (#  do fullname[]->current.fullname.equal->value #);
       do current.g.close; current[]->groupTable.delete;
       #);


-- topDelete: Dopart --
do
   (if fg.fullnameT[] = none then
       'top.delete: fragmentgroup name is NONE'->screen.putline;
    else
       (if fg.fullnameT.length = 0 then
	   'top.delete: fragmentgroup name is empty'->screen.putline;
	else
	   fg.fullnameT[]->groupTable.dummy.fullname[];
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed
	       (#
		  predicate::
		    (#
		    do
		       groupTable.dummy.fullname[]->current.fullname.equal
			 ->value
		    #);

	       do current[]->groupTable.delete;
	       #);

       if)
   if)

-- topInsert: Descriptor --
(# e: ^groupTable.Element;
do
   (if fg.fullnameT[] = none then
       'top.delete: fragmentgroup name is NONE'->screen.putline;
    else
       (if fg.fullnameT.length = 0 then
	   'top.delete: fragmentgroup name is empty'->screen.putline;
	else
	   fg.fullnameT[]->groupTable.dummy.fullname[];
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed
	       (#
		  predicate::
		    (#
		    do
		       groupTable.dummy.fullname[]->current.fullname.equal
			 ->value
		    #);

	       do current[]->e[];
	       #);
	   (if e[] = none then
	       &groupTable.Element[]->e[];
	       fg.fullNameT.copy->e.fullname[];
	       fg[]->e.g[];
	       e[]->groupTable.insert;

	    else
	   (* fragmentgroup already exists *)
	       'WARNING: tried to insert fragmentgroup already in top-table: '
		 ->screen.puttext;
	       fg.fullname->screen.putline;

	   if);

       if)
   if);

#)

-- topIsOpen: DoPart --
do
   fullname[]->groupTable.dummy.fullname[];
   (if groupTable.dummy.fullname[] = none then
       'top.isOpen: fragmentgroup name is NONE'->screen.putline;
    else
       (if groupTable.dummy.fullname.length = 0 then
	   'top.isOpen: fragmentgroup name is empty'->screen.putline;
	else
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed

	     (#
		  predicate::
		    (#
		    do
		       groupTable.dummy.fullname[]->current.fullname.equal
			 ->value
		    #);

	       do current.g[]->fg[];
	       #);

       if)
   if)

-- topCatcher: DoPart --
do
   (if theCatcher[] = none then
       msg[]->AstInterfaceError
    else
       (no,msg[])->theCatcher
   if)

-- astLevelIsRefenced: DoPart --
do
   L: Top.groupTable.Scan
     (#
	testForm:
	  (# ff: ^fragmentForm
	  enter ff[]
	  do
	     ff.import.scan
	       (#
	       do (if current.g[] = fx[] then true->found; leave l if)
	       #)
	  #);
	testLink:
	  (# fl: ^fragmentLink
	  enter fl[]
	  do (if FL.F[] = FX[] then true->found; leave L if)
	  #);
	testGroup:
	  (# fg: ^fragmentGroup
	  enter fg[]
	  do
	     (if fg.origin = FX[] then True->found; leave L if);
	     fg.scanIncludes
	       (# do (name[],screen[])->top.open->testLink #);
	     fg.fragmentList.Scan
	       (#
	       do
		  (if (current.f[] <> none ) then
		      (if current.type
		       // linkType then
			  current.f[]->testLink
		       // formType then
			  current.f[]->testForm
		       // groupType then
			  current.f[]->testGroup
		      if)
		  if)
	       #)
	  #);

     do (if (current.g[] <> none ) then current.g[]->testGroup if)
     #)

-- AstInterfaceException: DoPart --
do
   (if m[] <> none then m->msg if);
   INNER AstInterfaceException;
   'Yggdrasil stops'->msg.putText

-- AstInterfaceNotification: DoPart --
do (if m[] <> none then m->msg if); INNER AstInterfaceNotification

-- astlevelInit: Descriptor --
(#
   theFirstErrorReporter: errorReporter
     (#
	forEachError::
	  (#
	     l: @text;
	     lastPos: @integer;
	     t,cd: ^text;
	     tabCount: @integer;
	     ch: @char
	  do
	     0->errorLines.pos;
	     loop:
	       (#
	       do
		  '#'->errorStream.put;
		  startLineNo
		    ->errorStream.putInt
		      (# format::  (#  do 4->width #) #);
		  ' '->errorStream.put;
		  startLineNo+1->startLineNo;
		  errorLines.pos->lastPos;
		  &text[]->t[];
		  L:
		  (if errorLines.eos then
		      leave L
		   else
		      (if ((errorLines.get->ch) <> ascii.newLine) then
			  ch->t.put; restart L
		      if)
		  if);
		  t[]->errorStream.putLine;
		  (if not errorLines.eos then restart loop if)
	       #);
	     0->tabCount;
	     ascii.ht->t.findAll (#  do 1+tabCount->tabCount #);
	     '# ****'->errorStream.putText;
	     (for tabCount repeat ascii.ht->errorStream.put for);
	     (for errorPos-lastPos-3-tabCount repeat '*'->errorStream.put for);
	     ' ^'->errorStream.putLine;
	     '#  Expected symbol'->errorStream.putText;
	     (if legalSymbols.terminals.range = 1 then
		 ': '->errorStream.putText;
	      else
		 's: '->errorStream.putText
	     if);
	     (for i: legalSymbols.terminals.range repeat
	       legalSymbols.terminals[i][]->errorStream.putText;
	       (if (i <> legalSymbols.terminals.range) then
		   ' '->errorStream.put
	       if)
	     for);
	     errorStream.newLine;
	     (if frag.fatherR[] = none then
	     (* we have a stand alone fragmentForm.  Do not write file and
	      * line-number information
	      *)

	      else
		 ' File "'->errorStream.putText;
		 frag.textFileName->t[];
		 currentDirectory->cd[];
		 (frag.textFileName,currentDirectory)
		   ->thePathHandler.convertFilePath->errorStream.putText;
		 '"; Line '->errorStream.putText;
		 startLineNo-1->errorStream.putInt;
		 errorStream.newLine;

	     if);

	  #);

     #);

do
   (if isBigEndian then
       '.ast'->astFileExt[];
       '.btab'->parserFileExt[];
       '.ptbl'->ppFileExt[];

    else
       '.astL'->astFileExt[]; '.btabL'->parserFileExt[]; '.ptblL'->ppFileExt[];
   if);
   true->doRealOpen;
   (for i: 256 repeat i->CommentSieve[i] for);
   32->CommentSieve[1];
   32->CommentSieve[2];
   32->CommentSieve[3];
   top.init;
   ''->top.topGroup.fullNameT[];
   true->top.topGroup.isDirectory;
   thePathHandler.init;
   (* installing a default grammarFinder *)
   &defaultGrammarFinder[]->grammarMissing[];
   &repetitionStream[]->repS[];
   &theFirstErrorReporter[]->theErrorReporter[];
   (* register the grammars known by default *)
   screen[]->grammarMissing.registerGrammars
#)

-- treelevelSymbolName: Descriptor --
(# exp: ^expanded
do
   (if (symbol > 0) then
       (if (grammarAst[] <> none ) then
	   grammarAst.root[]->exp[];
	   3->exp.get->exp[];
	   (* productionList *)
	   symbol->exp.get->exp[];
	   (* leftside *)
	   1->exp.get->exp[];
	   (* synDeclName *)
	   prodNo.nameDecl
	     ->exp.suffixWalkForProd
	       (# nd: ^nameDecl
	       do current[]->nd[]; &text[]->t[]; nd.getText->t[]
	       #);

       if)
   if)
#)

-- treelevelSymbolToAst: DoPart --
do
   (if (symbol < 0) then
       (if symbol
	// prodNo.unExpanded then
	   &UnExpanded[]->as[];
	// prodNo.optional then
	   &Optional[]->as[];
	// prodNo.nameDecl then
	   &NameDecl[]->as[];
	// prodNo.nameAppl then
	   &NameAppl[]->as[];
	// prodNo.string then
	   &String[]->as[];
	// prodNo.Const then
	   &Const[]->as[];
	// prodNo.Comment then
	   &Comment[]->as[];
	// prodNo.SlotDesc then
	   &SlotDesc[]->as[];
       if)
    else
       genRefArray[symbol]->as[];
   if);


-- treelevelGrammarTableFindCatcherBody: DoPart --
do (if no
    // errornumbers.noReadAccess // errornumbers.noWriteAccess
    // errornumbers.EOSError // errornumbers.noSuchFile
    // errornumbers.WriteAccessOnLstFileError // errornumbers.fileExists then
       msg[]->accessError
    // errornumbers.noSpaceLeft // errornumbers.otherFileError
    // errorNumbers.notExisting // errorNumbers.badFormat
    // errorNumbers.parseErrors // errorNumbers.doubleFormDeclaration
    // errorNumbers.grammarNotFound // errorNumbers.arrayTooBig then
       msg[]->mpsError
    // notificationNumbers.startingParsing then
       startParsing
    // notificationNumbers.noParserAvailable then
       noParserAvailable
    else
       (if no->errorNumbers.fatalParseError then msg[]->mpsError if)
   if)

-- treelevelGrammarTableIfNotFoundBody: DoPart --
do INNER ifNotFound;
   'Grammar "'->msg.puttext;
   grammarName[]->msg.puttext;
   '" not loaded'->msg.putline;
   'Going to stop'->msg.putline;

-- treelevelGrammarTableNoParserAvailableBody: DoPart --
do
   'No parser available for grammar: "'->msg;
   grammarName[]->msg.puttext;
   '"'->msg.putline;
   INNER noParserAvailable

-- treelevelGrammarTableFind: Descriptor --
(# doFind:
     (#
     do loop:
	  (for i: NoOfKnownGrammars repeat
	       (if trace.active and trace.d[trace.grammars] then
		   trace.grammars->signalTrace
		     (# start::
			  (#
			  do 'matching grammar: "'->msg.putText;
			     grammarName[]->msg.putText;
			     '" against grammarTable grammar: '->msg.putText;
			     table[i].name[]->msg.putText
			  #)
		     #);
	       if);
	       (if (table[i].name[]->grammarName.equalNCS) then
		   i->inx;
		   leave loop
	       if);
	  for);
     #);
   installed: @boolean
do (if theCatcher[] = none then
       theCatcher[]->treelevelGrammarTableFindCatcher.oldCatcher[];
       treelevelGrammarTableFindCatcher[]->theCatcher[]
   if);
   (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
	 (# start::
	      (#
	      do 'find grammar: "'->msg.putText;
		 grammarName[]->msg.putText;
		 '" in grammarTable'->msg.putText
	      #)
	 #);
   if);
   doFind;
   (if (inx=0) or (table[inx].gram[]=none) then
       (# savedRepS: ^repetitionStream
       do (* save rep *) repS[]->savedRepS[];
	  &repetitionStream[]->repS[];
	  install: (grammarName[],error[])->grammarMissing->installed;
	  savedRepS[]->repS[];

       #);
       (if installed then doFind if)
   if);
   (if (inx=0) or (table[inx].gram[]=none) then
       (if trace.active and trace.d[trace.grammars] then
	   trace.grammars->signalTrace
	     (# start::
		  (#
		  do 'FAILURE: find grammar: "'->msg.putText;
		     grammarName[]->msg.putText;
		     '" in grammarTable'->msg.putText
		  #)
	     #);
       if);
       'Could not find '->ifNotFound
    else
       (if trace.active and trace.d[trace.grammars] then
	   trace.grammars->signalTrace
	     (# start::
		  (#
		  do 'SUCCEEDED: find grammar: "'->msg.putText;
		     grammarName[]->msg.putText;
		     '" in grammarTable'->msg.putText
		  #)
	     #);
       if);
   if);
   (if theCatcher[] = treelevelGrammarTableFindCatcher[] then
       treelevelGrammarTableFindCatcher.oldCatcher[]->theCatcher[]
   if)
#)

-- treelevelGrammarTableInsert: Dopart --
do (# i: @integer
   do loop:
	(if (i+1->i)<= NoOfKnownGrammars then
	    (if theGrammar.grammarIdentification->table[i].name.equalNCS then
		(* grammar name found - install the proper grammar *)
		(if trace.active and trace.d[trace.grammars] then
		    trace.grammars->signalTrace
		      (# start::
			   (#
			   do 'installing (registered) grammar: "'->msg.putText;
			      theGrammar.grammarIdentification->msg.putText;
			      '" in grammarTable'->msg.putText
			   #)
		      #);
		if);
		theGrammar[]->table[i].gram[];
		leave loop;
	     else restart loop
	    if);
	 else
	    (if trace.active and trace.d[trace.grammars] then
		trace.grammars->signalTrace
		  (# start::
		       (#
		       do 'installing (unregistered) grammar: "'->msg.putText;
			  theGrammar.grammarIdentification->msg.putText;
			  '" in grammarTable'->msg.putText
		       #)
		  #);
	    if);
	    NoOfKnownGrammars+1->NoOfKnownGrammars;
	    (if NoOfKnownGrammars > grammarTable.table.range then
		10->grammarTable.table.extend
	    if);
	    (theGrammar.grammarIdentification).copy
	      ->grammarTable.table[NoOfKnownGrammars].name[];
	    (theGrammar.suffix).copy
	      ->grammarTable.table[NoOfKnownGrammars].extension[];
	    (theGrammar.grammarAst.fullname).copy
	      ->grammarTable.table[NoOfKnownGrammars].path[];
	    theGrammar[]->grammarTable.table[NoOfKnownGrammars].gram[];
	if);
   #)

-- treelevelGrammarTableInsertMetagrammar: DoPart --
do (# i: @integer
   do loop:
	(if (i+1->i)<= NoOfKnownGrammars then
	    (if 'metagrammar'->table[i].name.equalNCS then
		(* metagrammar name found - install the metagrammar *)
		(if trace.active and trace.d[trace.grammars] then
		    trace.grammars->signalTrace
		      (# start::
			   (#
			   do'installing (registered) metagrammar in grammarTable'
				->msg.putText
			   #)
		      #);
		if);
		meta[]->table[i].gram[];
		leave loop
	     else restart loop
	    if)
	 else
	    (if trace.active and trace.d[trace.grammars] then
		trace.grammars->signalTrace
		  (# start::
		       (#
		       do 'installing (unregistered) metagrammar in grammarTable'
			    ->msg.putText
		       #)
		  #);
	    if);
	    NoOfKnownGrammars+1->NoOfKnownGrammars;
	    (if NoOfKnownGrammars > grammarTable.table.range then
		10->grammarTable.table.extend
	    if);
	    (meta.grammarIdentification).copy
	      ->grammarTable.table[NoOfKnownGrammars].name[];
	    (meta.suffix).copy
	      ->grammarTable.table[NoOfKnownGrammars].extension[];
	    location.copy
	      ->grammarTable.table[NoOfKnownGrammars].path[];
	if);
     #);

-- astlevelGrammarFinderRegisterGrammars: DoPart --
do (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
	 (# start::
	      (# do 'registering  grammars'->msg.putText #)
	 #);
   if);
   INNER registerGrammars;
   (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
	 (# start::
	      (# do 'DONE: registering  grammars'->msg.putText #)
	 #);
   if)

-- astlevelGrammarFinderNoRegisteredGrammarsBody: DoPart --
do 'No grammars have been registered\n'->msg; INNER noRegisteredGrammars

-- astlevelGrammarFinder: DoPart --
do (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
	 (# start::
	      (# do 'GrammarMissing: grammar: "'->msg.putText; grammar[]->msg.putText #)
	 #);
   if);
   false->installed;
   INNER grammarFinder;
