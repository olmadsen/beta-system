ORIGIN 'astPrivate';
INCLUDE '~beta/basiclib/binfile';
LIB_ITEM 'mpsastlevel';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/file'
'~beta/sysutils/endian'
'~beta/sysutils/time'
'../metagramsematt'
'../notifications';

---lib:attributes---
getLongRep: (* REF2REP *)
  (# calculated_range: @integer;
     S: [0]@int32; num: @integer; F: ^binFile
  enter(calculated_range,num,F[])
  do (if use_ref2rep then
         num -> F.getLongRep -> S[];
         (if calculated_range > S.range then
             calculated_range - S.range -> S.extend
         if)
     if);
  exit S[]
  #);

-- treeLevelVersion: DoPart --
do private.versionNo->value; INNER

-- treeLevelGrammarIdentification: DoPart --
do (if private.grammarName[] <> none then
       private.grammarName[]->theGrammarName[]
    else
       &text[]->theGrammarName[]; undefinedGrammarName->theGrammarName
   if);
   INNER

-- treeLevelSuffix: DoPart --
do (if private.applgramSuffix[] <> none then
       private.applgramSuffix[]->theSuffix[]
    else
       &text[]->theSuffix[]; '.text'->theSuffix
   if);
   INNER

-- treelevelInit: Descriptor --
(#
   meta: ^metagrammar;
   grammar: ^meta.Agrammar;
   p,NoOfSons,maxProd: @integer;
   root: ^meta.Agrammar;
   pl: ^meta.productionList;
   cns: ^meta.Constructor;
   clist: ^meta.ConsElemList;
   exp: ^expanded;
   ls: ^meta.LeftSide;
   gn: ^meta.grammarName;
   nd: ^nameDecl;
   opAst: ^ast;
   op: ^meta.optionPart;
   (*consGenerator,unExpGenerator,listGenerator,optGenerator:
    ^referenceGenerator;*)

do
   false->parser.haveBeenInitialized;
   grammarTable.meta[]->meta[];
   (*    &referenceGenerator (#  do &cons[]->as[] #)[]->consGenerator[];
    *    genUnExpanded[]->unExpGenerator[];
    *    &referenceGenerator (#  do &list[]->as[] #)[]->listGenerator[];
    *    genOptional[]->optGenerator[];
    * 
    *)
   (if grammarAst[] <> none then
       (* this should always be the case, except for the metagrammar *)
       grammarAst.root[]->root[];
       root.getOptionOp->opAst[];
       (if opAst## <= cons## then
	   opAst[]->op[];
	   meta.optionElement
	     ->op.suffixWalkForProd
           (#
              oe: ^meta.optionElement;
              on: ^meta.optionName;
              na: ^nameAppl;
              os: ^string;
              t: ^text
           do
              current[]->oe[];
              oe.getOptionName->on[];
              on.getNameAppl->na[];
              na.getText->t[];
              t.copy->t[];
              (if ('suffix'->t.equalNCS) then
                  String
                    ->oe.suffixWalkForProd
                  (#
                  do
                     current[]->os[];
                     os.getText->private.applGramSuffix[];
                     private.applGramSuffix.copy
                       ->private.applGramSuffix[];

                  #)
              if)
           #)
       if);
       grammarAst.root[]->grammar[];
       ('version',undefinedversion)->grammar.getOptionValue->private.versionNo;
       root.getProductionList->pl[];
       (* check if the arrays need extensions *)
       pl.noOfSons->maxProd;
       (if (maxProd > kindArray.range) then
	   maxProd+1-kindArray.range->kindArray.extend;
	   maxProd+1-nodeClassArray.range->nodeClassArray.extend;
	   maxProd+1-sonArray.range->sonArray.extend;
	   maxProd+1-roomArray.range->roomArray.extend;
	   maxProd+1-genRefArray.range->genRefArray.extend;

       if);
       root.getGrammarName->gn[];
       gn.getNameDecl->nd[];
       nd.getText->private.grammarName[];
       private.grammarName.copy->private.grammarName[];
       0->p;
       pl.scan
       (#
       do
          p+1->p;
          current[]->exp[];
          exp.getson1->ls[];
          2*(((2->ls.getAttribute)+1) div 2)->roomArray[p];
          (if current.symbol
           // meta.Constructor then
              kinds.interior->kindArray[p];
              kinds.cons->nodeClassArray[p];
              current[]->cns[];
              cns.getConsElemList->clist[];
              0->NoOfSons;
              clist.scan
              (#
              do
                 (if current.symbol
                  // meta.Syncat // meta.TaggedSyn then
                     NoOfSons+1->NoOfSons;
                 if);

              #);
              NoOfSons->sonArray[p];
              (*consGenerator[]->genRefArray[p][];*)
              cons## -> genRefArray[p]##

           // meta.Alternation then
              kinds.unExpanded->kindArray[p];
              kinds.unExpanded->nodeClassArray[p];
              (*unExpGenerator[]->genRefArray[p][];*)
              unExpanded## -> genRefArray[p]##

           // meta.ListOne // meta.ListZero then
              kinds.interior->kindArray[p];
              kinds.list->nodeClassArray[p];
              (*listGenerator[]->genRefArray[p][];*)
              list## -> genRefArray[p]##

           // meta.Dummy then
              0->nodeClassArray[p]
           // meta.Opt then
              kinds.optional->kindArray[p];
              kinds.optional->nodeClassArray[p];
              (* optGenerator[]->genRefArray[p][]; *)
              optional## -> genRefArray[p]##

          if)
       #);

   if);
   INNER init;
   THIS(treeLevel)[]->grammartable.insert
#)

-- treeLevelPrivateVariables: Descriptor --
(# grammarName,applGramSuffix: ^text; versionNo: @integer #)

-- fragmentFullName: DoPart --
do
   &text[]->N[];
   (if fatherR[] = none then
       FullNameT[]->N.append
    else
       fatherR.FullName->N.append;
       (if not fatherR.isDirectory then ffNameSeparatorChar->N.put;  if);
       NameT[]->N.append
   if)

-- fragmentMarkAsChanged: Dopart --
do pack;
   false->changed;

-- fragmentCheckDiskRepresentation: Descriptor --
(# diskFile: @file (# binary:: trueObject #);
do
   diskFileName->diskFile.name;
   (if
       ((diskFile.entry.modTime (# error::  (#  do true->continue #) #) > modTime)
         ->haveBeenChanged) then
       INNER checkDiskRepresentation
   if)
#)

-- fragmentBind: DoPart --
do (if not BindMark then
       True->BindMark;
       INNER bind;
       (* If not bound by INNER then try origin *)
       (if OP[] = none then
	   (if originR[] = none then (* try setting up origin *)
	       screen[]->setupOrigin;
	   if);
	   (if originR[] <> none then
	       F[]->originR.Bind->OP[]
	   if);
       if)
   if);
   False->BindMark

-- fragmentBindToOrigin: DoPart --
do (if (originR[] <> none ) then F[]->originR.Bind->OP[] if)

-- fragmentSetupOrigin: Descriptor --
(# t: ^text;
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
	doProp::
	  (#
	  do
	     prop.makelc;
	     (if 'origin'->prop.equal then
		 ScanParameters
                 (#
                    doString::
                      (#
                      do
                         THIS(fragment).fullName->stripPathName->t[];
                         (if t[] = none then
                             ((S.copy,currentDirectory)
                               ->thePathHandler.convertFilePath,error[])
                               ->top.open->THIS(fragment).origin
                          else
                             ((S.copy,t[])->thePathHandler.convertFilePath,
                             error[])->top.open->THIS(fragment).origin
                         if);
                         leave FindOrigin;

                      #)
                 #)
	     if)
	  #)
     #)
#)

-- fragmentCatcher: DoPart --
do
   (if theCatcher[] = none then
       (if (fatherR[] <> none ) then
	   (no,msg[])->fatherR.catcher
	else
	   msg[]->AstInterfaceError
       if)
    else
       (no,msg[])->theCatcher
   if)

-- fragmentGroupScan: dopart --
do fragmentList.scan
   (# 
   do (if current.f[]=none then
          screen[]->current.open;
      if);
      current.f[]->THIS(scan).current[];
      INNER scan
   #)

-- fragmentGroupScanIncludes: dopart --
do (if linklist[]=NONE then
       loadIncludes;
   if);
   linklist.head[]->current[];
   scan:
     (if current[]<>NONE then
	 INNER scanIncludes;
	 current.next[]->current[];restart scan
     if)

-- fragmentGroupScanSlots: dopart --
do fragmentList.scan
   (# ff: ^fragmentForm;
   do (if current.type=formType then
          screen[]->current.open->ff[];
          ff.scanSlots
          (#
          do current[]->THIS(scanSlots).current[];
             INNER scanSlots
          #)
      if)
   #)

-- fragmentGroupOpen: Dopart --
do (if trace.active and trace.d[trace.FragmentOpen] then
       trace.FragmentOpen->signalTrace
       (# start::
            (#
            do 'group-open of '->msg.putText;
               localPath[]->msg.putText;
               ' in '->msg.putText;
               fullName->msg.putText;
            #)
       #);
   if);
   0->localPath.pos;
   (if localPath.getNonBlank = ascii.fs then
       (# msg: @text
       do
          'Fragment name is empty: '->msg;
          localPath[]->msg.putLine;
          (errorNumbers.notExisting,msg[])->catcher
       #)
   if);
   l:
     (#
     do
	(if fatherR[] = none (* we are in the top *) then
	    localPath[]->expandToFullPath->localPath[];
	 else
	    (if (1->localPath.inxGet) = '~' then leave l if);
	if);
	0->dirInx->groupInx;
	ffNameSeparatorChar->localPath.findAll (#  do inx->groupInx #);
	thePathHandler.directoryChar
	  ->localPath.findAll (#  do inx->dirInx #);
	(if (groupInx > 0) then (* xx-yy *)
	    (if (dirInx < groupInx) then (* zz/xx-yy *)
		((1,groupInx-1)->localPath.sub,error[])->open->f[];
		(if f[] <> none then
		    (if f.type = groupType then
			f[]->g[];
			((groupInx+1,localPath.length)->localPath.sub,error[])
			  ->g.open->f[];
		     else
			none ->f[]
		    if)
		if);
		leave l
	    if)
	if);
	(localPath[],error[])->fragmentList.open->f[];

     #);
   (if f[] = none then
       (# msg: @text
       do
          'Fragment not found in open: '->msg;
          localPath[]->msg.putLine;
          (errorNumbers.notExisting,msg[])->catcher
       #)
    else
       true->f.isOpen;
       (if f.type=grouptype then f[]->signalGroupOpen if);
   if);
   (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
       (# start::
            (#
            do (if f[] = none then
                   'FAILED: '->msg.putText
                else
                   'SUCCEEDED: '->msg.putText;
               if);
               'group-open of '->msg.putText;
               localPath[]->msg.putText;
               ' in '->msg.putText;
               fullName->msg.putText;
            #)
       #);
   if)

-- fragmentGroupClose: DoPart --
do (if trace.active and trace.d[trace.FragmentClose] then
       trace.FragmentClose->signalTrace
       (# start::
            (#
            do 'group-close of '->msg.putText;
               name->msg.putText;
               ' in '->msg.putText;
               fullName->msg.putText;
            #)
       #);
   if);
   (if this(fragmentGroup)[]->signalBeforeGroupClose then
       fragmentList.scan
       (#
       do (if current.type = formType then
              (if (current.f[] <> none ) then
                  current.f.close; none ->current.f[]
              if)
          if);

       #);
       THIS(FragmentGroup)[]->top.delete;
       none ->fragmentList[];
       none ->prop[];
       this(fragmentGroup)[]->signalGroupClose;
   if)

-- fragmentGroupFragmentListElementOpen: DoPart --
do
   (if f[] = none then
       (if type
	// formType then
	   newFragmentForm->f[];
	// groupType then
	   newFragmentGroup->f[]
       if);
       name.copy->f.name;
       THIS(fragmentGroup)[]->f.father;
       (if type=groupType then (none,error[])->f.unPack if)
   if)

-- fragmentGroupLinkListFullname: dopart --
do (if fn[]=NONE then
       this(fragmentGroup).fullName->stripPathName->fn[];
       (if fn[] = none then
	   (linkName[],currentDirectory)
	     ->thePathHandler.ConvertFilePath
	     ->fn[];
	else
	   (linkName[],fn[])
	     ->thePathHandler.ConvertFilePath
	     ->fn[];
       if)
   if);

-- fragmentGroupLinkListLoad: descriptor --
(* The code below reverses the order of includes!
 * (#
 * do &linkListType[]->linklist[];
 *    prop.scanProp
 *      (# doProp::
 * 	  (#
 * 	  do (if 'include'->prop.equalNCS then
 * 		 scanParameters
 * 		   (# doString::
 * 			(# l: ^linklisttype.link;
 * 			do &linklist.link[]->l[];
 * 			   s.copy->l.linkName[];
 * 			   linklist.head[]->l.next[];
 * 			   l[]->linklist.head[];
 * 			#)
 * 		   #);
 * 	     if);
 * 	  #);
 *      #)
 * #)
 *)
(# last: ^linklisttype.link;
do &linkListType[]->linklist[];
   prop.scanProp
   (# doProp::
        (#
        do (if 'include'->prop.equalNCS then
               scanParameters
               (# doString::
                    (# l: ^linklisttype.link;
                    do &linklist.link[]->l[];
                       s.copy->l.linkName[];
                       (if last[]=NONE then
                           l[]->linklist.head[];
                        else
                           l[]->last.next[];
                       if);
                       l[]->last[];
                    #)
               #);
           if);
        #);
   #)
#)

-- fragmentGroupFragmentListDescriptorDeleteLocalName: DoPart --
do
   l: scan
     (#
     do (if (current.name[]->n.equal) then current[]->at->delete; leave l if)
     #)

-- fragmentGroupFragmentListDescriptorFind: DoPart --
do
   l: scan
     (#
     do (if (current.name[]->n.equal) then current.f[]->r[]; leave l if)
     #);


-- fragmentGroupFragmentListDescriptorOpen: DoPart --
do (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
       (# start::
            (#
            do 'Fragment-list open of '->msg.putText;
               n[]->msg.putText;
               ' in '->msg.putText;
               fullName->msg.putText;
            #)
       #);
   if);
   loop:
     (#
     do
	scan
        (# found: @boolean
        do
           (if current.type = formType then
               current.name[]->n.equalNCS->found
            else
               current.name[]->n.equal->found
           if);
           (if found then
               (if (current.f[]->f[]) = none then
                   error[]->current.open; current.f[]->f[]
               if);
               (if trace.active and trace.d[trace.fragmentOpen] then
                   trace.fragmentOpen->signalTrace
                   (# start::
                        (# do 'Found in list'->msg.putText #)
                   #);
               if);
               leave loop
           if)
        #);
	(* if we are here, the local name of the fragment could not be
	 * found in the fragmentList. We will newer the less try and see if
	 * we can find the fragment
	 *)
        (#
           g: ^fragmentGroup;
           fName,origFName: ^text;
           dirInx,groupInx,dotInx: @integer;
           fgf: @file
             (# entryDesc:: (# (*cached:: (# do true->value #)*) #);
                fileExist:
                  (#
                  enter name
                  exit entry.exists
                     (# error::
                          (#
                          do true->continue;
                             (errorNumbers.otherFileError,msg[])->catcher
                          #)
                     #)
                  #);
                isFile:
                  (#
                  enter name
                  exit entry.isFile
                     (# error::
                          (#
                          do true->continue;
                             (errorNumbers.otherFileError,msg[])->catcher
                          #)
                     #)
                  #);
                fileReadable:
                  (#
                  enter name
                  exit entry.readable
                     (# error::
                          (#
                          do true->continue;
                             (errorNumbers.otherFileError,msg[])->catcher
                          #)
                     #)
                  #)
             #)
        do
           &Element[]->e[];
           none ->e.f[];
           fullName->fName[];
           fName.copy->fName[];
           ffNameSeparatorChar->fName.put;
           n[]->(fName.Copy).Append->fName[];
           n.copy->e.name[];
           fName.copy->origFName[];
           try:
	     (if true
	      // (astFileExtension->(fName.Copy).Append->fgf.fileExist) then
	         (* o.k. we are in real group *)
		 groupType->e.type;
		 e[]->append;
		 error[]->e.open->f[];
		 MarkAsChanged;

	      // ('.text'->(fName.Copy).Append->fgf.fileExist) then
		 groupType->e.type; e[]->append; error[]->e.open->f[];
	      else
		 loop:
		   (#
		   do
		      grammarTable.scan
                      (# name: ^text
                      do
                         (if
			     (currentExtension[]->(fName.Copy).Append->name[]
			       ->fgf.fileExist) then
                             groupType->e.type;
                             e[]->append;
                             error[]->e.open->f[];
                             leave loop
                         if)
                      #);
		      0->dotInx;
		      '.'->fName.findAll (#  do inx->dotInx #);
		      (if dotInx > 1 then
			  0->dirInx->groupInx;
			  ffNameSeparatorChar
			    ->fName.findAll (#  do inx->groupInx #);
			  thePathHandler.directoryChar
			    ->fName.findAll (#  do inx->dirInx #);
			  (if true
			   // (dirInx > groupInx) then (* xx-yy/zz *)
			      (if (dotInx > dirInx) then (* xx-yy/zz.rr *)
				  (dotInx,fName.length)->fName.delete;
				  restart try
			      if)
			   // (dirInx < groupInx) then (* xx/yy-zz *)
			      (if true
			       // (dotInx > groupInx) then (* xx/yy-zz.rr *)
				  (dotInx,fName.length)->fName.delete;
				  restart try
			       // (dotInx > dirInx) then (* xx/yy.rr-zz *)
				  (dotInx,groupInx-1)->fName.delete; restart try
			      if)
			   else
			      (* xx.rr *)
			      (dotInx,fName.length)->fName.delete; restart try
			  if)
		      if);
		      (* well. we did not find the file. If the file ifself
		       * exist, lets us try to parse it
		       *)
		      origFName[]->fName[]->fgf.name;
		      (if fgf.fileExist then
			  (if fgf.isFile then
			      (if fgf.fileReadable then
                                  (# fg: ^fragmentGroup; dotInx: @integer
                                  do
                                     '.'
                                       ->fName.findAll
                                     (#  do inx->dotInx #);
                                     (if (dotInx > 1) then
				         (* >1 to avoid empty filename before '.' *)
                                         newFragmentGroup->fg[];
                                         (1,dotInx-1)->fName.sub->e.name[];
                                         e.name[]->fg.name;
                                         e.name[]->fg.fullNameT[];
                                         'Warning - The fragment group: \n\t'->screen.puttext;
                                         fg.fullnameT[]->screen.putline;
                                         'is created by reading the file: \n\t'->screen.puttext;
                                         fName[]->screen.putline;
                                         'This may create problems in the later processing of the fragment group'->screen.putline;
                                         (notificationNumbers.startingParsing,
                                         '')->catcher;
                                         theParse:
					   (if
					         ((fName[],error[])
					         ->fg.parse
                                               (#
                                                  parseErrors::
                                                    (#
                                                    do
                                                       (errorNumbers.
                                                       parseErrors,
                                                       ' Parse errors ')
                                                         ->catcher;
                                                       false->ok;
                                                       true->continue
                                                    #);
                                                  doubleFormDeclaration::
                                                    (#
                                                    do
                                                       (errorNumbers.
                                                       doubleFormDeclaration,
                                                       ' Double declaration of form ')
                                                         ->catcher;
                                                       true->continue
                                                    #);

                                               #)) then
					       fg[]->f[];
					       groupType->e.type;
					       e[]->append;

					   if)
                                     if)
                                  #)
			       else
                                  (# t: @text
                                  do
                                     'No read access to the file: "'->t;
                                     fName[]->t.append;
                                     '"'->t.putline;
                                     (errorNumbers.noReadAccess,t[])->catcher
                                  #)
			      if)
			   else
                              (# t: @text
                              do
                                 'Filename "'->t;
                                 fName[]->t.append;
                                 '" refers to a directory, not a file'
                                   ->t.putline;
                                 (errorNumbers.otherFileError,t[])->catcher
                              #)
			  if)
		       else
                          (# t: @text
                          do
                             'Filename "'->t;
                             fName[]->t.append;
                             '" does not exist'->t.putline;
                             (errorNumbers.notExisting,t[])->catcher
                          #)
		      if)
		   #)
	     if)
        #)
     #);
   (if f[] <> none then
       true->f.isOpen;
   if);
   (if trace.active and trace.d[trace.fragmentOpen] then
       trace.fragmentOpen->signalTrace
       (# start::
            (#
            do (if f[] = none then
                   'FFAILED: '->msg.putText
                else
                   'FSUCCEEDED: '->msg.putText;
               if);
               'Fragment-list open of '->msg.putText;
               n[]->msg.putText;
               ' in '->msg.putText;
               fullName->msg.putText
            #)
       #);
   if)

-- fragmentGroupFragmentListDescriptorInsertFragment: Dopart --
do l:
     (#
     do
	scan
        (#
        do
           (if (f.name->current.name.equalNCS) then
               current[]->newElement[];
               (# t: @text
               do
                  'Fragment: "'->t;
                  f.name->t.append;
                  '" is already in this fragment group: "'->t.append;
                  THIS(fragmentGroup).name->t.append;
                  '"'->t.append;
                  t[]->alreadyThere
               #);
               leave l
           if)
        #);
	&Element[]->newElement[];
	f.name->newElement.name[];
	INNER insertFragment;

     #);
   f[]->newElement.f[];
   f.type->newElement.type;
   THIS(fragmentGroup)[]->f.father;
   f.markAsChanged

-- FragmentGroupSaveAs: Descriptor --
(# savename1,savename2: ^text;
do fullnameT.copy->savename1[];
   nameT.copy->savename2[];
   fullname[]->fullnameT[];
   fullname[]->nameT[];
   astFileExtension->fullName.append;
   fullName[]->pack;
   savename1.copy->fullnameT[];
   savename2.copy->nameT[]
#)

-- FragmentGroupSaveBackup: Descriptor --
(# fileName: ^text
do 
   astFileExtension->((fullName).copy).Append->fileName[];
   (if (ext[] <> none) then
       ext[]->fileName.append 
   if);
   fileName[]->pack;
#)

-- FragmentGroupRestoreBackup: Descriptor --
(#
   diskFile: @file (# binary:: trueObject #);
   name,fileName: ^Text;
   oldDoRealOpen: @boolean;

do 
   astFileExtension->((fullName).copy).Append->fileName[];
   (if (ext[] <> none) then
       ext[]->fileName.append 
   if);
   fileName[]->diskFile.name;
   init;
   doRealOpen->oldDoRealOpen;
   true->doRealOpen;
   (fileName[],screen[])->unpack;
   oldDoRealOpen->doRealOpen;
#)

-- fragmentGroupDiskFullName: DoPart --
do
   astFileExtension->((fullName).copy).Append->t[];

-- fragmentGroupTextFileName: DoPart --
do
   l:
     (if defaultGrammar[] = none then
         grammarTable.scan
	 (# name: @text; f: @file
	 do
	    fullName->t[];
	    t->t;
	    currentExtension[]->t.append;
	    t.copy->f.name;
	    (if f.entry.exists
	        (#
		   error::
		     (#
		     do
		        true->continue;
		        (errorNumbers.otherFileError,msg[])->catcher
		     #)
	        #) then
		current[]->defaultGrammar[]; leave l
	    if);

	 #);
         fullName->t[];
         t->t;
         '.text'->t.append;

      else
         fullName->t[]; t->t; defaultGrammar.suffix->t.append
     if);


-- fragmentGroupIsRealOpen: DoPart --
do
   (if isOpen then
       (if none
	// prop[] // fragmentList[] then false->opened
	else
	   scanner: fragmentList.scan
	     (# ff: ^astinterface.fragmentForm
	     do
		(if current.type=formType then
		    (if current.f[] <> none then
			current.f[]->ff[];
			(if none
			 // ff.grammar[] // ff.root[] then
			    false->opened; leave scanner
			 else
			    true->opened
			if);

		     else
			false->opened; leave scanner
		    if)
		if)
	     #)
       if)
    else
       false->opened
   if)

-- fragmentGroupRealOpen: Descriptor --
(#
   f: @binfile
     (# accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #);
        GB: @GetBytes;
     #);
   getRep: @
     (# adr, longs: @integer;
     enter (adr, longs)
     do (adr,4*longs) -> f.GB;
     #);
   
   b: [2] @integer;
   garbagefl: ^fragmentListDescription;
   garbageProp: ^propertyList;

do diskFileName->f.name;
   (if trace.active and trace.d[trace.FragmentOpen] then
       trace.FragmentOpen->signalTrace
       (# start::
            (# do 'OpenRead fragmentGroup-file: '->msg.puttext; f.name->msg.puttext #)
       #);
   if);
   (if f.entry.isFile
       (#
	  error::
	    (#
	    do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	    #)
       #) then
       (if f.entry.readable
	   (#
	      error::
	        (#
	        do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	        #)
	   #) then
	   f.openRead
	else
           (# t: @text
           do
              'No read access to the file: "'->t;
              f.name->t.append;
              '"'->t.putline;
              (errorNumbers.noReadAccess,t[])->catcher
           #)
       if)
    else
       (# t: @text
       do
          'Filename "'->t;
          f.name->t.append;
          '" refers to a directory, not a file'->t.putline;
          (errorNumbers.otherFileError,t[])->catcher
       #)
   if);
   (if use_ref2rep then
       b.range -> f.getLongRep -> b[];
    else
       (@@b[1],b.range)->getRep;
   if);
   (if (b[2] > repS.r.range) then b[2]-repS.r.range->repS.extend;  if);
   0->repS.top;
   (if use_ref2rep then
       (repS.r.range,b[2],f[]) -> getLongRep -> repS.r[]
    else
       (@@repS.r[1],b[2])->getRep;
   if);
   (* get r from f *)
   &fragmentListDescription[]->garbagefl[];
   repS[]->garbagefl.repRestore;
   none ->garbagefl[];
   &propertyList[]->garbageProp[];
   repS[]->garbageProp.repRestore;
   none ->garbageprop[];
   fragmentList.scan
   (# ff: ^fragmentForm
   do (if current.type = formType then
          screen[]->current.open;
          current.f[]->ff[];
          repS[]->ff.repRestoreStruct (* REF2REP: range for ff.a and ff.l
                                       * are set to be 50 larger than
                                       * curTop and lCurTop and sometimes
                                       * to other values
                                       *)
      if)
   #);
   fragmentList.scan
   (# ff: ^fragmentForm
   do (if current.type = formType then
          current.f[]->ff[];
          (if use_ref2rep then
              (ff.a_range,ff.curTop,f[]) -> getLongRep -> ff.a[]
           else
              (@@ff.a[1],ff.curTop)->getRep;
          if);
          (if ff.lcurtop>1 then 
              (if use_ref2rep then
                  (ff.l_range,ff.lcurTop,f[]) -> getLongRep -> ff.l[]
               else
                  (@@ff.l[1],ff.lcurTop)->getRep;
              if); 
          if);
          ff.rootInx->ff.indexToNode->ff.root[];

      if)
   #);
   f.close
#)

-- fragmentGroupLock: dopart --
do true->locked.value;
   this(fragmentGroup)[]->signalGroupLock;

-- fragmentGroupUnlock: dopart --
do false->locked.value;
   this(fragmentGroup)[]->signalGroupUnlock;

-- fragmentGroupPack: DoPart --
do
   l:
     (#
	f: @binfile
	  (#
	     accessError::
	       (#
	       do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
	       #);
	     writeError::
	       (#
	       do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
	       #);
	     readError::
	       (#
	       do (errorNumbers.noReadAccess,msg[])->catcher; leave l
	       #);
	     EOSError::
	       (#  do (errorNumbers.EOSerror,msg[])->catcher; leave l #);
	     noSuchFileError::
	       (#  do (errorNumbers.noSuchFile,msg[])->catcher; leave l #);
	     fileExistsError::
	       (#  do (errorNumbers.fileExists,msg[])->catcher; leave l #);
	     noSpaceError::
	       (#  do (errorNumbers.noSpaceLeft,msg[])->catcher; leave l #);
	     otherError::
	       (#
	       do (errorNumbers.otherFileError,msg[])->catcher; leave l
	       #);
             PB: @PutBytes;
	  #);
        putRep: @
          (# adr, longs: @integer;
          enter (adr, longs)
          do (adr,4*longs) -> f.PB;
          #);
	b: [2] @integer;
	dirWriteable:
	  (# f: @file
	  enter f.name
	  exit f.entry.writeable
	     (#
	        error::
		  (#
		  do
		     true->continue; (errorNumbers.otherFileError,msg[])->catcher
		  #)
	     #)
	  #);
        updateModtime: @boolean
     do
	(if not isDirectory then
	    0->repS.top;
	    repS[]->fragmentList.repSave;
	    repS[]->prop.repSave;
	    fragmentList.scan
            (# ff: ^fragmentForm
            do
               (if current.type = formType then
                   current.f[]->ff[]; repS[]->ff.repSaveStruct
               if)
            #);
	    groupBlackNumber->b[1];
	    repS.top->b[2];
	    (if fileName[]=none then 
                diskFileName->f.name;
                true->updateModTime
             else
                fileName[]->f.name
            if);
	    (if trace.active and trace.d[trace.FragmentOpen] then
		trace.FragmentOpen->signalTrace
                (# start::
                     (# do 'OpenWrite fragmentGroup-file: '->msg.puttext; f.name->msg.puttext #)
                #);
	    if);
	    (if (f.entry.path.head->dirWriteable) then
		(if f.entry.writeable
		    (#
		       error::
		         (#
		         do
			    true->continue;
			    (errorNumbers.otherFileError,msg[])->catcher
		         #)
		    #) then
		    f.openWrite
		 else
                    (if updateModTime then
                        (* setting modtime to systemtime to ensure
                         * that it is changed, eventhough the file
                         * cannot actually be written
                         *)
                        systemtime->modtime
                    if);
                    (# t: @text
                    do
                       'No write access to the file: "'->t;
                       f.name->t.append;
                       '"'->t.putline;
                       (errorNumbers.noWriteAccess,t[])->catcher;
                       leave l
                    #)
		if)
	     else
                (if updateModTime then
                    (* setting modtime to systemtime to ensure
                     * that it is changed, eventhough the file
                     * cannot actually be written
                     *)
                    systemtime->modtime
                if);
                (# t: @text
                do
                   'No write access to the directory: "'->t;
                   f.entry.path.head->t.append;
                   '"'->t.putline;
                   (errorNumbers.noWriteAccess,t[])->catcher;
                   leave l
                #)
	    if);
	    (if use_ref2rep then
                (b[],b.range) -> f.putLongRep;
             else
                (@@ b[1],b.range)->putRep;
            if);
            
	    (if use_ref2rep then
                (repS.r[],repS.top) -> f.putLongRep;
             else
                (@@repS.r[1],repS.top)->putRep;
            if);
            
	    (* save r on f *)
	    fragmentList.scan
            (# ff: ^fragmentForm
            do
               (if current.type = formType then
                   current.f[]->ff[];
                   (if use_ref2rep then
                       (ff.a[],ff.curTop) -> f.putLongRep;
                    else
                       (@@ff.a[1],ff.curTop)->putRep;
                   if);
                   (if ff.lcurtop>1 then 
                       (if use_ref2rep then
                           (ff.l[],ff.lcurTop) -> f.putLongRep;
                        else
                           (@@ff.l[1],ff.lcurTop)->putRep;
                       if); 
                   if)
               if)
            #);
	    f.close;
	    (* setting modtime to ensure that it is exactly
             * the modtime of the corresponding ast-file
             *)
            (if updateModTime then
		f.entry.modTime(# error:: (# do true->continue #) #)->modTime
	    if);
	    this(fragmentGroup)[]->signalGroupPack
	if)
     #)

-- fragmentGroupUnpack: Descriptor --
(#
   f: @binfile
     (#
	accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #);
        GB: @GetBytes;
     #);
   textFile: @file
     (#
	accessError::
	  (#
	  do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
	  #)
     #);
   t,s: ^text;

do
   fragmentlist.clear;
   (if fileName[]=none then 
       diskFileName->t[]
    else
       fileName[]->t[]
   if);
   t.copy->f.name;
   textFileName->t[];
   t.copy->textFile.name;
   (if
       ((textFile.entry.ModTime (# error::  (#  do true->continue #) #) >
       f.entry.ModTime (# error::  (#  do true->continue #) #)) or
       (options.forceParse)) then
       (if textFile.entry.exists
	   (#
	      error::
	        (#
	        do true->continue; (errorNumbers.otherFileError,msg[])->catcher
	        #)
	   #) then
	   (if textFile.entry.isFile
	       (#
		  error::
		    (#
		    do
		       true->continue;
		       (errorNumbers.otherFileError,msg[])->catcher
		    #)
	       #) then
	       (if textFile.entry.readable
		   (#
		      error::
		        (#
		        do
			   true->continue;
			   (errorNumbers.otherFileError,msg[])->catcher
		        #)
		   #) then
		   (notificationNumbers.startingParsing,'')->catcher;
		   (if trace.active and trace.d[trace.onParse] then
		       trace.onParse->signalTrace
                       (# start::
                            (#
                            do 'parsing "'->msg.putText;
                               fullName->msg.putText;
                               '"'->msg.put
                            #)
                       #);
		   if);
		   theParse:
		     (if
		           ((textfile.name,error[])
		           ->parse
			 (#
			    parseErrors::
			      (#
			      do
				 (errorNumbers.parseErrors,' Parse errors ')
				   ->catcher;
				 false->ok;
				 true->continue
			      #);
			    doubleFormDeclaration::
			      (#
			      do
				 (errorNumbers.doubleFormDeclaration,
				 ' Double declaration of form ')->catcher;
				 true->continue
			      #)
			 #)) then
		         (if trace.active and trace.d[trace.onParse] then
			     trace.onParse->signalTrace
			     (# start::
				  (# do msg.newLine #)
			     #);
		         if);
		     if)
		else
                   (# t: @text
                   do
                      'No read access to the file: "'->t;
                      textFile.name->t.append;
                      '"'->t.putline;
                      (errorNumbers.noReadAccess,t[])->catcher
                   #)
	       if)
	    else
               (# t: @text
               do
                  'Filename "'->t;
                  textFile.name->t.append;
                  '" refers to a directory, not a file'->t.putline;
                  (errorNumbers.otherFileError,t[])->catcher
               #)
	   if)
	else
           (# t: @text
           do
              'Filename "'->t;
              textFile.name->t.append;
              '" does not exist'->t.putline;
              (errorNumbers.noSuchFile,t[])->catcher
           #)
       if)
    else
       (if f.entry.exists(# error::
	                      (# do true->continue; (errorNumbers.otherFileError,msg[])->catcher
                              #)
                         #) 
           then
           (# getRep: @
                (# adr, longs: @integer;
                enter (adr, longs)
                do (adr,4*longs) -> f.GB;
                #);
              b: [2] @integer
           do (if trace.active and trace.d[trace.FragmentOpen] then
                  trace.FragmentOpen->signalTrace
                  (# start::
                       (#
                       do 'OpenRead(unpack) fragmentGroup-file: '->msg.puttext;
                          f.name->msg.puttext
                       #)
                  #);
              if);
              (if f.entry.isFile
		  (#
		     error::
		       (#
		       do
			  true->continue;
			  (errorNumbers.otherFileError,msg[])->catcher
		       #)
		  #) then
                  (if f.entry.readable
		      (#
			 error::
			   (#
			   do
			      true->continue;
			      (errorNumbers.otherFileError,msg[])->catcher
			   #)
		      #) then
                      f.openRead
                   else
                      (# t: @text
                      do
                         'No read access to the file: "'->t;
                         f.name->t.append;
                         '"'->t.putline;
                         (errorNumbers.noReadAccess,t[])->catcher
                      #)
                  if)
               else
                  (# t: @text
                  do
                     'Filename "'->t;
                     f.name->t.append;
                     '" refers to a directory, not a file'->t.putline;
                     (errorNumbers.otherFileError,t[])->catcher
                  #)
              if);
              (if use_ref2rep then
                  b.range -> f.getLongRep -> b[];
               else
                  (@@b[1],b.range)->getRep;
              if);
              (if (b[1] <> groupBlackNumber) then
                  (# t: @text
                  do
                     ' Trying to access a group file with wrong magic number "'
                       ->t;
                     fullName->t.append;
                     '"'->t.put;
                     (errorNumbers.badformat,t[])->catcher;
                     
                  #);
                  
              if);
              (if (b[2] > repS.r.range) then
                  b[2]-repS.r.range->repS.extend;
              if);
              0->repS.top;
              (if use_ref2rep then
                  (repS.r.range,b[2],f[]) -> getLongRep -> repS.r[]
               else
                  (@@repS.r[1],b[2])->getRep;
              if);
              (* get r from f *)
              repS[]->fragmentList.repRestore;
              repS[]->prop.repRestore;
              
              (if doRealOpen then
                  fragmentList.scan
                  (# ff: ^fragmentForm
                  do
                     (if current.type = formType then
                         current.f[]->ff[]; repS[]->ff.repRestoreStruct
                     if)
                  #);
                  fragmentList.scan
                  (# ff: ^fragmentForm
                  do
                     (if current.type = formType then
                         current.f[]->ff[];
                         (if use_ref2rep then
                             (ff.a_range,ff.curTop,f[]) -> getLongRep -> ff.a[]
                          else
                             (@@ff.a[1],ff.curTop)->getRep;
                         if);
                         (if ff.lcurtop>1 then 
                             (if use_ref2rep then
                                 (ff.l_range,ff.lcurTop,f[]) -> getLongRep -> ff.l[]
                              else
                                 (@@ff.l[1],ff.lcurTop)->getRep;
                             if); 
                         if);
                         ff.rootInx->ff.indexToNode->ff.root[];
                         (if defaultGrammar[] = none then
                             ff.grammar[]->defaultGrammar[]
                         if);
                         
                     if)
                  #);
              if);
              f.close;
              f.entry.modTime (# error::  (#  do true->continue #) #)
                ->modTime;
              this(fragmentGroup)[]->signalGroupUnpack
           #)
       if)
   if);

#)

-- fragmentGroupCheckDiskRepresentation: DoPart --
do init; (none,error[])->unpack 

-- fragmentGroupInit: DoPart --
do
   GroupType->FragType;
   false->isDirectory;
   &fragmentListDescription[]->fragmentList[];
   fragmentList.init;


-- fragmentGroupBind: Descriptor --
(# fName: ^text
do F.name->fName[];
   L: scanSlots
     (#
     do (if (current.Name->fName.equalNCS) then
	    current[]->op[]->f.binding[]; leave l
	if)
     #)
#)

-- fragmentFormCategory: DoPart --
do (if root[] = none then 0->sy else root.symbol->sy if)

-- fragmentFormRecomputeSlotChain: Descriptor --
(# theExpanded: ^expanded
do
   0->firstSlot;
   (if root.kind = kinds.interior then
       root[]->theExpanded[];
       unExpanded
	 ->theExpanded.suffixWalkForProd
       (# scanCat:: unExpanded; theSlot: ^slotDesc;
       do
          (if current.isSlot then
              current.theSlot->theSlot[];
              firstSlot->a[theSlot.index+offset.slotUsage];
              theSlot.index->firstSlot;

          if);

       #);

   if)
#)

-- fragmentFormScanSlots: DoPart --
do
   firstSlot->inx;
   loop:
     (if (inx <> 0) then
         inx->indexToNode->current[];
         current.slotUsageInx->inx;
         INNER scanSlots;
         restart loop
     if);


-- fragmentFormIndexToNode: Descriptor --
(#
   symbol,val: @integer;
   errorMsg:
     (# t,msg: ^text
     enter t[]
     do
	'*** Error in IndexToNode: '->msg[];
	t[]->msg.append;
	'\nIndex='->msg.puttext;
	inx->msg.putint;
	'\nSymbol='->msg.puttext;
	symbol->msg.putint;
	'\nVal='->msg.puttext;
	val->msg.putint;
	'\nFragment='->msg.puttext;
	fullname->msg.puttext;
	'\nFragment is '->msg.puttext;
	(if (father).isRealOpen then
	    'open'->msg.puttext
	 else
	    'ONLY semiOpen'->msg.puttext
	if);
	msg.newline;
     exit msg[]
     #)
do l:
     (if true
      // (0 < inx) and (inx <= a.range) then
         a[inx]->val;
         (4,12)->val.%GetSignedBits->symbol;
         (* inline expansion of inx -> getSymbol -> symbol *)
         (if (0 < symbol) and (symbol <= grammar.genRefArray.range) then
	     (if (&grammar.genRefArray[symbol][]->as[]) = none then
	         (* IndexToNode: genRefArray problem *)
	         'genRefArray problem'->errorMsg->grammarGenRefArrayError;
                 leave l
	     if)
	  else
	     (if symbol
	      // prodNo.unExpanded then
	         &UnExpanded[]->as[]
	      // prodNo.optional then
	         &Optional[]->as[]
	      // prodNo.nameDecl then
	         &NameDecl[]->as[]
	      // prodNo.nameAppl then
	         &NameAppl[]->as[]
	      // prodNo.string then
	         &String[]->as[];
	      // prodNo.Const then
	         &Const[]->as[];
	      // prodNo.Comment then
	         &Comment[]->as[]
	      // prodNo.SlotDesc then
	         &SlotDesc[]->as[]
	      else
	         (* IndexToNode: no match for symbol! *)
	         none ->as[]; 'no such symbol'->errorMsg->noSuchSymbol; leave l
	     if)
         if);
         inx->as.index;
         THIS(fragmentForm)[]->as.frag[]
      // (0 = inx) then (* Zero index is the same as a NONE ast *)
         none ->as[]
      else
         (* IndexToNode: index out of range *)
         none ->as[]; 'index out of range'->errorMsg->indexOutOfRange
     if)
#)

-- fragmentFormInit: DoPart --
do 2->curTop; 2->lcurtop; formtype->fragtype; import.init; INNER init

-- fragmentFormReset: DoPart --
do import.makeNull; 'Semanticerrors'->prop.deleteProp

-- topTableOpen: DoPart --
do (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
       (# start::
            (#
            do 'top-table open of '->msg.puttext;
               fullname[]->msg.putline;
               '\tOpen fragments:'->msg.putline;
               scan
               (# do '\t\t'->msg.puttext; current.fullname[]->msg.putline #);
            #)
       #);
   if);
   (* is the group already open? *)
   (# f: @file; t: ^text;
   do fullname[]->f.name;
      (if f.entry.path.name.suffix->grammarTable.legalExtension then
	  f.entry.path.head->t[];
	  directoryChar->t.put;
	  f.entry.path.name.prefix->t.append->fullname[];
      if)
   #);
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
   (# predicate::  (#  do fullname[]->current.fullname.equal->value #);
   do current.g[]->g[];
   #);
   none ->dummy.fullname[];
   (if g[] = none then
       (* if we are here, the fragment could not be found in the
	* fragmentList.  Try look at the disk for the file.
	*)
       (# fgf: @file
            (# entryDesc:: (# (*cached:: (# do true->value #)*) #);
               fileExist:
	         (#
	         enter name
	         exit entry.exists
		    (# error::
		         (#
		         do true->continue;
			    (errorNumbers.otherFileError,msg[])->catcher
		         #)
		    #)
	         #);
               isFile:
                 (#
                 enter name
                 exit entry.isFile
                    (# error::
                         (#
                         do true->continue;
                            (errorNumbers.otherFileError,msg[])
                              ->catcher
                         #)
                    #)
                 #);
               fileReadable:
                 (#
                 enter name
                 exit entry.readable
                    (# error::
                         (#
                         do true->continue;
                            (errorNumbers.otherFileError,msg[])
                              ->catcher
                         #)
                    #)
                 #)
            #)
       do &Element[]->e[];
	  fullName.copy->e.fullName[];
	  (if true
	   // (astFileExtension->(fullName.Copy).Append->fgf.fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
                  (# start::
                       (# do 'opening .ast file...'->msg.puttext #)
                  #);
	      if);
	      (* o.k. we are in real group *)
	      error[]->e.open->g[];
	      e[]->insert;
	   // ('.bet'->(fullName.Copy).Append->fgf.fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
                  (# start::
                       (# do 'opening .bet file...'->msg.puttext #)
                  #);
	      if);
	      error[]->e.open->g[];
	      e[]->insert;
	   // ('.text'->(fullName.Copy).Append->fgf.fileExist) then
	      (if trace.active and trace.d[trace.topOpen] then
		  trace.topOpen->signalTrace
                  (# start::
                       (# do 'opening .text file...'->msg.puttext #)
                  #);
	      if);
	      error[]->e.open->g[];
	      e[]->insert;
	   else
	      loop: grammarTable.scan
		(#
		do (if (currentExtension[]->(fullName.Copy).Append->fgf.fileExist) then
		       (if trace.active and trace.d[trace.topOpen] then
			   trace.topOpen->signalTrace
                           (# start::
                                (#
                                do 'opening '->msg.puttext;
                                   currentExtension[]->msg.puttext;
                                   ' file...'->msg.puttext;
                                #)
                           #);
		       if);
		       error[]->e.open->g[];
		       e[]->insert;
		       leave loop
		   if)
		#);
	      (if g[] = none then
		  (# t: ^Text;
		     dotInx: @integer;
		     fg: ^FragmentGroup;
		  do fullname[]->fgf.name;
                     (if not fgf.fileExist then
			 'Filename "'->t[];
			 fullName[]->t.append;
			 '" could not be opened using any known grammar'
			   ->t.putline;
			 (errorNumbers.notExisting,t[])->catcher
		     if);
		     (if not fgf.isFile then
			 'Filename "'->t[];
			 fullName[]->t.append;
			 '" refers to a directory, not a file'->t.putline;
			 (errorNumbers.otherFileError,t[])->catcher
		     if);
		     (if not fgf.fileReadable then
			 'No read access to the file: "'->t[];
			 fullName[]->t.append;
			 '"'->t.putline;
			 (errorNumbers.noReadAccess,t[])->catcher
		     if);
		     (* ok. try parse the file *)
		     (*'ok. try parse the file'->screen.putline;*)
		     '.'->fullName.findAll (#  do inx->dotInx #);
		     (if (dotInx > 1) then
			 (* >1 to avoid empty filename before '.' *)
			 newFragmentGroup->fg[];
			 (1,dotInx-1)->fullName.sub->e.fullname[];
			 e.fullname[]->fg.fullnameT[]->fg.nameT[];
                         'Warning - The fragment group: \n\t'->screen.puttext;
                         fg.fullnameT[]->screen.putline;
                         'is created by reading the file: \n\t'->screen.puttext;
                         fullName[]->screen.putline;
                         'This may create problems in the later processing of the fragment group'->screen.putline;
			 (notificationNumbers.startingParsing,'')->catcher;
			 theParse:
			   (if ((fullName[],error[])
                                 ->fg.parse
                               (# parseErrors::
                                    (#
                                    do (errorNumbers.parseErrors,
                                       ' Parse errors ')->catcher;
                                       false->ok;
                                       true->continue
                                    #);
                                  doubleFormDeclaration::
                                    (#
                                    do (errorNumbers.doubleFormDeclaration,
                                       ' Double declaration of form ')
                                         ->catcher;
                                       true->continue
                                    #);
                               #)) then
			       fg[]->e.g[]->g[]; e[]->insert;
			   if)
		     if)
		  #)
	      if);
	  if);
       #)
   if);
   (if g[] <> none then true->g.isOpen if);
   (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
       (# start::
            (#
            do (if g[] = none then
                   'F_FAILED: '->msg.putText
                else
                   'F_SUCCEEDED: '->msg.putText;
               if);
               'Top-Table open of '->msg.putText;
               fullName[]->msg.putText;
            #);
       #)
   if)


-- topTableElementOpen: DoPart --
do (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
       (# start::
            (# do 'top-table-element-open of '->msg.putText; fullname[]->msg.putText #)
       #);
   if);
   (if g[] = none then
       newFragmentGroup->g[];
       fullname.copy->g.fullnameT[]->g.nameT[];
       (none,error[])->g.unPack;
       (if trace.active and trace.d[trace.topOpen] then
	   trace.topOpen->signalTrace
           (# start::
                (#
                do 'top-table-element-unpack of '->msg.putText;
                   g.fullname->msg.putText
                #)
           #);
       if)
   if)

-- topTableFind: DoPart --
do
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
   (#
      predicate::  (#  do fullname[]->current.fullname.equal->value #);
   do current.g[]->g[];
   #);

-- topInit: DoPart --
do groupTable.init; &FragmentGroup[]->topGroup[];

-- topOpen: Descriptor --
(# fullName: ^Text;
do (if trace.active and trace.d[trace.TopOpen] then
       trace.TopOpen->signalTrace
       (# start::
            (# do 'top-open of '->msg.putText; filename[]->msg.putText #)
       #);
   if);
   0->fileName.pos;
   (if fileName.getNonBlank = ascii.fs then
       (# msg: @text
       do
          'Fragment file name is empty: '->msg;
          fullname[]->msg.putLine;
          (errorNumbers.notExisting,msg[])->theCatcher
       #)
   if);
   (if (1->fileName.inxGet) <> '/' then
       fileName[]->expandToFullPath->fullName[];
    else
       fileName.copy->fullName[];
   if);
   (fullName[],error[])->groupTable.open->g[];
   (if g[] = none then
       (# msg: @text
       do
          'Fragment file not found in open: '->msg;
          fullName[]->msg.putLine;
          (errorNumbers.notExisting,msg[])->theCatcher
       #)
    else
       true->g.isOpen; topGroup[]->g.father;
   if);
   (if trace.active and trace.d[trace.topOpen] then
       trace.topOpen->signalTrace
       (# start::
            (#
            do (if g[] = none then
                   'FAILED: '->msg.putText
                else
                   'SUCCEEDED: '->msg.putText;
               if);
               'top-open of '->msg.putText;
               fullName[]->msg.putText;
            #)
       #);
   if);
#)

-- topNewGroup: DoPart --
do
   (if (fullname[]->isOpen) = none then
       newFragmentGroup->fg[];
       fullname.copy->fg.name;
       fullname.copy->fg.fullnameT[];
       fg[]->insert;
       (* insert into top table *)

    else
       (# msg: @text
       do
          'top.newGroup: '->msg.puttext;
          fullname[]->msg.puttext;
          'is already open'->msg.putline;
          msg[]->alreadyOpen;

       #);

   if);


-- topClose: dopart --
do fg.nameT[]->namedClose;

-- topNamedClose: Dopart --
do (if trace.active and trace.d[trace.TopClose] then
       trace.TopClose->signalTrace
       (# start::
            (# do 'top-close of '->msg.putText; fullname[]->msg.putText #)
       #);
   if);
   fullname[]->groupTable.dummy.fullname[];
   groupTable.dummy[]->groupTable.hashfunction
     ->groupTable.findIndexed
   (#
      predicate::  (#  do fullname[]->current.fullname.equal->value #);
   do current.g.close; current[]->groupTable.delete;
   #);


-- topDelete: Dopart --
do
   (if fg.fullnameT[] = none then
       'top.delete: fragmentgroup name is NONE'->screen.putline;
    else
       (if fg.fullnameT.length = 0 then
	   'top.delete: fragmentgroup name is empty'->screen.putline;
	else
	   fg.fullnameT[]->groupTable.dummy.fullname[];
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed
           (#
              predicate::
                (#
                do
                   groupTable.dummy.fullname[]->current.fullname.equal
                     ->value
                #);

           do current[]->groupTable.delete;
           #);

       if)
   if)

-- topInsert: Descriptor --
(# e: ^groupTable.Element;
do
   (if fg.fullnameT[] = none then
       'top.delete: fragmentgroup name is NONE'->screen.putline;
    else
       (if fg.fullnameT.length = 0 then
	   'top.delete: fragmentgroup name is empty'->screen.putline;
	else
	   fg.fullnameT[]->groupTable.dummy.fullname[];
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed
           (#
              predicate::
                (#
                do
                   groupTable.dummy.fullname[]->current.fullname.equal
                     ->value
                #);

           do current[]->e[];
           #);
	   (if e[] = none then
	       &groupTable.Element[]->e[];
	       fg.fullNameT.copy->e.fullname[];
	       fg[]->e.g[];
	       e[]->groupTable.insert;

	    else
	       (* fragmentgroup already exists *)
	       'WARNING: tried to insert fragmentgroup already in top-table: '
		 ->screen.puttext;
	       fg.fullname->screen.putline;

	   if);

       if)
   if);

#)

-- topIsOpen: DoPart --
do
   fullname[]->groupTable.dummy.fullname[];
   (if groupTable.dummy.fullname[] = none then
       'top.isOpen: fragmentgroup name is NONE'->screen.putline;
    else
       (if groupTable.dummy.fullname.length = 0 then
	   'top.isOpen: fragmentgroup name is empty'->screen.putline;
	else
	   groupTable.dummy[]->groupTable.hashfunction
	     ->groupTable.findIndexed

           (#
              predicate::
                (#
                do
                   groupTable.dummy.fullname[]->current.fullname.equal
                     ->value
                #);

           do current.g[]->fg[];
           #);

       if)
   if)

-- topCatcher: DoPart --
do
   (if theCatcher[] = none then
       msg[]->AstInterfaceError
    else
       (no,msg[])->theCatcher
   if)

-- AstInterfaceException: DoPart --
do
   (if m[] <> none then m->msg if);
   INNER AstInterfaceException;
   'Yggdrasil stops'->msg.putText

-- AstInterfaceNotification: DoPart --
do (if m[] <> none then m->msg if);
   INNER AstInterfaceNotification
   
-- astlevelProtectCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)
   

-- astlevelProtect: dopart --
do (if theCatcher[] = none then
       theCatcher[]->protectCatcher.oldCatcher[];
       protectCatcher[]->theCatcher[]
   if);
   
   INNER protect;
   
   (if theCatcher[] = protectCatcher[] then
       protectCatcher.oldCatcher[]->theCatcher[]
   if)
   
-- astlevelInit: Descriptor --
(#
   theFirstErrorReporter: errorReporter
     (#
	forEachError::
	  (#
	     l: @text;
	     lastPos: @integer;
	     t,cd: ^text;
	     tabCount: @integer;
	     ch: @char
	  do
	     0->errorLines.pos;
	     loop:
	       (#
	       do
		  '#'->errorStream.put;
		  startLineNo
		    ->errorStream.putInt
                  (# format::  (#  do 4->width #) #);
		  ' '->errorStream.put;
		  startLineNo+1->startLineNo;
		  errorLines.pos->lastPos;
		  &text[]->t[];
		  L:
		    (if errorLines.eos then
		        leave L
		     else
		        (if ((errorLines.get->ch) <> ascii.newLine) then
			    ch->t.put; restart L
		        if)
		    if);
		  t[]->errorStream.putLine;
		  (if not errorLines.eos then restart loop if)
	       #);
	     0->tabCount;
	     ascii.ht->t.findAll (#  do 1+tabCount->tabCount #);
	     '# ****'->errorStream.putText;
	     (for tabCount repeat ascii.ht->errorStream.put for);
	     (for errorPos-lastPos-3-tabCount repeat '*'->errorStream.put for);
	     '  ^'->errorStream.putLine;
	     '#  Expected symbol'->errorStream.putText;
	     (if legalSymbols.terminals.range = 1 then
		 ': '->errorStream.putText;
	      else
		 's: '->errorStream.putText
	     if);
	     (for i: legalSymbols.terminals.range repeat
	          legalSymbols.terminals[i][]->errorStream.putText;
	          (if (i <> legalSymbols.terminals.range) then
		      ' '->errorStream.put
	          if)
	     for);
	     errorStream.newLine;
	     (if frag.fatherR[] = none then
	         (* we have a stand alone fragmentForm.  Do not write file and
	          * line-number information
	          *)

	      else
		 ' File "'->errorStream.putText;
		 frag.textFileName->t[];
		 currentDirectory->cd[];
		 (frag.textFileName,currentDirectory)
		   ->thePathHandler.convertFilePath->errorStream.putText;
		 '"; Line '->errorStream.putText;
		 startLineNo-1->errorStream.putInt;
		 errorStream.newLine;

	     if);

	  #);

     #);

do
   (if isBigEndian then
       '.ast'->astFileExt[];
       '.btab'->parserFileExt[];
       '.ptbl'->ppFileExt[];

    else
       '.astL'->astFileExt[]; '.btabL'->parserFileExt[]; '.ptblL'->ppFileExt[];
   if);
   true->doRealOpen;
   (for i: 256 repeat i->CommentSieve[i] for);
   32->CommentSieve[1];
   32->CommentSieve[2];
   32->CommentSieve[3];
   top.init;
   ''->top.topGroup.fullNameT[];
   true->top.topGroup.isDirectory;
   thePathHandler.init;
   (* installing a default grammarFinder *)
   &defaultGrammarFinder[]->grammarMissing[];
   &repetitionStream[]->repS[];
   &theFirstErrorReporter[]->theErrorReporter[];
   (* register the grammars known by default *)
   screen[]->grammarMissing.registerGrammars
#)

-- treelevelSymbolName: Descriptor --
(# exp: ^expanded
do
   (if (symbol > 0) then
       (if (grammarAst[] <> none ) then
	   grammarAst.root[]->exp[];
	   3->exp.get->exp[];
	   (* productionList *)
	   symbol->exp.get->exp[];
	   (* leftside *)
	   1->exp.get->exp[];
	   (* synDeclName *)
	   prodNo.nameDecl
	     ->exp.suffixWalkForProd
           (# nd: ^nameDecl
           do current[]->nd[]; &text[]->t[]; nd.getText->t[]
           #);

       if)
   if)
#)

-- treelevelSymbolToAst: DoPart --
do
   (if (symbol < 0) then
       (if symbol
	// prodNo.unExpanded then
	   &UnExpanded[]->as[];
	// prodNo.optional then
	   &Optional[]->as[];
	// prodNo.nameDecl then
	   &NameDecl[]->as[];
	// prodNo.nameAppl then
	   &NameAppl[]->as[];
	// prodNo.string then
	   &String[]->as[];
	// prodNo.Const then
	   &Const[]->as[];
	// prodNo.Comment then
	   &Comment[]->as[];
	// prodNo.SlotDesc then
	   &SlotDesc[]->as[];
       if)
    else
       &genRefArray[symbol][]->as[];
   if);
   
-- treelevelGrammarTableScan: dopart --
do (for i: noOfKnownGrammars repeat
        table[i].name.copy->currentName[];
        table[i].extension.copy->currentExtension[];
        table[i].path.copy->currentPath[];
        table[i].gram[]->current[];
        INNER scan
   for)
   
-- treelevelGrammarTableScanExtensions: dopart --
do astFileExtension->currentExtension[];
   INNER scanExtensions;
   '.text'->currentExtension[];
   INNER scanExtensions;
   (for i: noOfKnownGrammars repeat
        table[i].extension[]->currentExtension[];
        INNER scanExtensions;
   for)
   
-- treelevelGrammarTableLegalExtension: dopart --
do false->value;
   (if ext[]<>NONE then
       loop: scanExtensions
         (# 
         do (if currentExtension[]->ext.equalNCS then
                true->value; leave loop
            if)
         #)
   if)
   
-- treelevelGrammarTableFindCatcherBody: DoPart --
do (if no
    // errornumbers.noReadAccess // errornumbers.noWriteAccess
    // errornumbers.EOSError // errornumbers.noSuchFile
    // errornumbers.WriteAccessOnLstFileError // errornumbers.fileExists then
       msg[]->accessError
    // errornumbers.noSpaceLeft // errornumbers.otherFileError
    // errorNumbers.notExisting // errorNumbers.badFormat
    // errorNumbers.parseErrors // errorNumbers.doubleFormDeclaration
    // errorNumbers.grammarNotFound // errorNumbers.arrayTooBig then
       msg[]->mpsError
    // notificationNumbers.startingParsing then
       startParsing
    // notificationNumbers.noParserAvailable then
       noParserAvailable
    else
       (if no->errorNumbers.fatalParseError then msg[]->mpsError if)
   if)

-- treelevelGrammarTableIfNotFoundBody: DoPart --
do INNER ifNotFound;
   'Grammar "'->msg.puttext;
   grammarName[]->msg.puttext;
   '" not loaded'->msg.putline;
   'Going to stop'->msg.putline;

-- treelevelGrammarTableNoParserAvailableBody: DoPart --
do
   'No parser available for grammar: "'->msg;
   grammarName[]->msg.puttext;
   '"'->msg.putline;
   INNER noParserAvailable

-- treelevelGrammarTableFind: Descriptor --
(# doFind:
     (#
     do loop:
	  (for i: NoOfKnownGrammars repeat
	       (if trace.active and trace.d[trace.grammars] then
		   trace.grammars->signalTrace
                   (# start::
                        (#
                        do 'matching grammar: "'->msg.putText;
                           grammarName[]->msg.putText;
                           '" against grammarTable grammar: '->msg.putText;
                           table[i].name[]->msg.putText
                        #)
                   #);
	       if);
	       (if (table[i].name[]->grammarName.equalNCS) then
		   i->inx;
		   leave loop
	       if);
	  for);
     #);
   installed: @boolean
do (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
       (# start::
            (#
            do 'find grammar: "'->msg.putText;
               grammarName[]->msg.putText;
               '" in grammarTable'->msg.putText
            #)
       #);
   if);
   doFind;
   (if (inx=0) or (table[inx].gram[]=none) then
       (# savedRepS: ^repetitionStream
       do (* save rep *) repS[]->savedRepS[];
	  &repetitionStream[]->repS[];
	  install: (grammarName[],error[])->grammarMissing->installed;
	  savedRepS[]->repS[];

       #);
       (if installed then doFind if)
   if);
   (if (inx=0) or (table[inx].gram[]=none) then
       (if trace.active and trace.d[trace.grammars] then
	   trace.grammars->signalTrace
           (# start::
                (#
                do 'FAILURE: find grammar: "'->msg.putText;
                   grammarName[]->msg.putText;
                   '" in grammarTable'->msg.putText
                #)
           #);
       if);
       'Could not find '->ifNotFound
    else
       (if trace.active and trace.d[trace.grammars] then
	   trace.grammars->signalTrace
           (# start::
                (#
                do 'SUCCEEDED: find grammar: "'->msg.putText;
                   grammarName[]->msg.putText;
                   '" in grammarTable'->msg.putText
                #)
           #);
       if);
   if)
#)

-- treelevelGrammarTableCheck: descriptor --
(#
do (if NoOfKnownGrammars > grammarTable.table.range then
       10->grammarTable.table.extend;
       (for i: 10 repeat
	    &grammarTable.element[]->grammarTable.table[NoOfKnownGrammars+i-1][]
       for)
   if);
#)

-- treelevelGrammarTableInsert: Dopart --
do (# i: @integer
   do loop:
	(if (i+1->i)<= NoOfKnownGrammars then
	    (if theGrammar.grammarIdentification->table[i].name.equalNCS then
		(* grammar name found - install the proper grammar *)
		(if trace.active and trace.d[trace.grammars] then
		    trace.grammars->signalTrace
                    (# start::
                         (#
                         do 'installing (registered) grammar: "'->msg.putText;
                            theGrammar.grammarIdentification->msg.putText;
                            '" in grammarTable'->msg.putText
                         #)
                    #);
		if);
		theGrammar[]->table[i].gram[];
		leave loop;
	     else restart loop
	    if);
	 else
	    (if trace.active and trace.d[trace.grammars] then
		trace.grammars->signalTrace
                (# start::
                     (#
                     do 'installing (unregistered) grammar: "'->msg.putText;
                        theGrammar.grammarIdentification->msg.putText;
                        '" in grammarTable'->msg.putText
                     #)
                #);
	    if);
	    NoOfKnownGrammars+1->NoOfKnownGrammars;
	    grammarTable.tableCheck;
	    (theGrammar.grammarIdentification).copy
	      ->grammarTable.table[NoOfKnownGrammars].name[];
	    (theGrammar.suffix).copy
	      ->grammarTable.table[NoOfKnownGrammars].extension[];
	    (theGrammar.grammarAst.fullname).copy
	      ->grammarTable.table[NoOfKnownGrammars].path[];
	    theGrammar[]->grammarTable.table[NoOfKnownGrammars].gram[];
	if);
   #)

-- treelevelGrammarTableInsertMetagrammar: DoPart --
do (# i: @integer
   do loop:
	(if (i+1->i)<= NoOfKnownGrammars then
	    (if 'metagrammar'->table[i].name.equalNCS then
		(* metagrammar name found - install the metagrammar *)
		(if trace.active and trace.d[trace.grammars] then
		    trace.grammars->signalTrace
                    (# start::
                         (#
                         do'installing (registered) metagrammar in grammarTable'
                              ->msg.putText
                         #)
                    #);
		if);
		meta[]->table[i].gram[];
		leave loop
	     else restart loop
	    if)
	 else
	    (if trace.active and trace.d[trace.grammars] then
		trace.grammars->signalTrace
                (# start::
                     (#
                     do 'installing (unregistered) metagrammar in grammarTable'
                          ->msg.putText
                     #)
                #);
	    if);
	    NoOfKnownGrammars+1->NoOfKnownGrammars;
	    grammarTable.tableCheck;
	    (meta.grammarIdentification).copy
	      ->grammarTable.table[NoOfKnownGrammars].name[];
	    (meta.suffix).copy
	      ->grammarTable.table[NoOfKnownGrammars].extension[];
	    location.copy
	      ->grammarTable.table[NoOfKnownGrammars].path[];
	if);
   #);

-- astlevelRegisterGrammar: dopart --
do (# inx: @integer
   do (* grammar name *)
      grammarTable.noOfKnownGrammars+1
        ->grammarTable.noOfKnownGrammars->inx;
      grammarTable.tableCheck;
      name.copy->grammarTable.table[inx].name[];
      
      (* grammar extension *)
      ext.copy
        ->grammarTable.table[inx].extension[];
      
      (* Grammar path *)
      path.copy
        ->grammarTable.table[inx].path[];
      
      trace.grammars->signalTrace
      (# start::
           (#
           do 'Registered new grammar (manually): '->msg.puttext;
              grammarTable.table[inx].name[]->msg.putText;
              '\t'->msg.put;
              grammarTable.table[inx].extension[]->msg.putText;
              '\t'->msg.put;
              grammarTable.table[inx].path[]->msg.putLine;
           #)
      #)
   #)

-- astlevelGrammarFinderRegisterGrammars: DoPart --
do (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
       (# start::
            (# do 'registering  grammars'->msg.putText #)
       #);
   if);
   INNER registerGrammars;
   (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
       (# start::
            (# do 'DONE: registering  grammars'->msg.putText #)
       #);
   if)

-- astlevelGrammarFinderNoRegisteredGrammarsBody: DoPart --
do 'No grammars have been registered\n'->msg; INNER noRegisteredGrammars

-- astlevelGrammarFinder: DoPart --
do (if trace.active and trace.d[trace.grammars] then
       trace.grammars->signalTrace
       (# start::
            (# do 'GrammarMissing: grammar: "'->msg.putText; grammar[]->msg.putText; '"'->msg.put #)
       #);
   if);
   false->installed;
   INNER grammarFinder;
