ORIGIN '../findgrammar';
INCLUDE '../grammarinit'
        '../metagrammarcfl';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
-- findGrammarPrivate: Descriptor --
(#
   fileReadable: @
     (# f: @file
     enter f.name
     exit f.entry.readable
       (#
          error:: 
            (# 
            do true->continue; (errorNumbers.otherFileError,msg[])->theCatcher
            #)
       #)
     #)
#)  

-- findGrammarGrammarsPATHBody: DoPart --
do
   &text[]->grammars[];
   './MBSgrammars'->grammars.putline;
   '~/MBSgrammars'->grammars.putline;
   '$(BETALIB)/MBSgrammars'->grammars.putline;
   '~beta/configuration/MBSgrammars_STD'->grammars.putline;
   '~beta/configuration/MBSgrammars_DEMO'->grammars.putline;
   INNER grammarsPATH  

-- findGrammarMetaGrammarFileBody: DoPart --
do
   '~beta/grammars/metagram/v4.5/metagrammar'->metaGrammar[];
   INNER metagrammarFile  

-- findGrammarRegisterGrammarsBody: Descriptor --
(# gfNames,gfName: ^text
do
   grammarsPATH->gfNames[];
   0->gfNames.pos;
   loop
     (#
        while::  (#  do not gfNames.EOS->value #);
        t: ^text;
        alternativeGrammarDefsGroup: ^fragmentGroup
     do
        gfNames.getline->t[];
        t[]->expandToFullPath->gfName[];
        trace.grammars
          ->tracer
            (# 
            do
               'registering  grammars from: "'->dmp.putText;
               gfName[]->dmp.putText;
               '"'->dmp.put
            #);
        (if ('.text'->(gfName.copy).append)->private.fileReadable then
            (gfName[],error[])->top.open->alternativeGrammarDefsGroup[]
        if);
        (if alternativeGrammarDefsGroup[] <> none then
            (if grammarDefsGroup[] = none then
                newFragmentGroup->grammarDefsGroup[]
            if);
            alternativeGrammarDefsGroup.fragmentList.iterate
              (# 
              do
                 l:
                   (#
                      cell:
                        ^alternativeGrammarDefsGroup.fragmentList.theCellType
                   do
                      current[]->cell[];
                      grammarDefsGroup.fragmentList.scan
                        (# 
                        do
                           (if (cell.elm.name[]->current.name.equalNCS) then
                               leave l
                           if)
                        #);
                      trace.grammars
                        ->tracer
                          (# 
                          do
                             'registering new grammar: "'->dmp.putText;
                             current.elm.name[]->dmp.putText;
                             '"'->dmp.put
                          #);
                      (current.elm[],none )
                        ->grammarDefsGroup.fragmentList.insertBefore
                   #)
              #)
        if)
     #);
   
#)  

-- findGrammarRegisteredGrammarsBody: DoPart --
do grammarDefsGroup[]->grammarsGroup[]; INNER registeredGrammars  

-- findGrammarDoBody: Descriptor --
(#
   gfName: ^text;
   fl: ^fragmentLink;
   mg: ^FragmentGroup;
   grammarLocation: ^text
do l:
   (if grammar[] = none then
       '<NONE>'->grammar[];
       (errorNumbers.grammarNotFound,'Grammar name is NONE')->theCatcher;
       leave l
    else
       (if grammarTable.meta[] = none then
           &metagrammar[]->grammarTable.insertMetagrammar;
           grammarTable.meta.init;
           (metaGrammarFile->expandToFullPath,error[])->top.open->mg[];
           ('meta',error[])->mg.open->mg[];
           ('metagrammar',error[])->mg.open->grammarTable.meta.grammarAst[];
           
       if);
       &treelevel[]->newGrammar[];
       grammar.copy->expandToFullPath->gfName[];
       trace.grammars
         ->tracer
           (# 
           do
              'trying grammar: "'->dmp.putText;
              grammar[]->dmp.putText;
              '" in current directory: "'->dmp.puttext;
              gfName[]->dmp.putText;
              '"'->dmp.putLine
           #);
       '-meta'->gfName.append;
       astFileExtension->gfName.append;
       (if gfName[]->private.fileReadable then
           trace.grammars
             ->tracer
               (# 
               do
                  'SUCCEEDED: Trying to find grammar: "'->dmp.putText;
                  grammar[]->dmp.putText;
                  '" in current directory: "'->dmp.puttext;
                  gfName[]->putText;
                  '"'->dmp.putLine
               #);
           (grammar[],error[])->top.open->grammarGroup[];
           grammarGroup.fullName->grammarWithPath[];
           grammarWithPath.copy->grammarWithPath[]
        else
       (* try to find the grammar using grammarsPATH *)
           (if grammarDefsGroup[] = none then
               trace.grammars
                 ->tracer
                   (# 
                   do
                      'No grammars previously registered. '->dmp.putText;
                      'Trying to registerGrammars'->dmp.puttext
                   #);
               registerGrammars
           if);
           (if grammarDefsGroup[] = none then noRegisteredGrammars if);
           scanner: GrammarDefsGroup.fragmentList.scan
             (# 
             do
                (if current.type = linkType then
                    trace.grammars
                      ->tracer
                        (# 
                        do
                           'trying registered grammar: "'->dmp.putText;
                           current.localName[]->dmp.putText;
                           '"'->dmp.put
                        #);
                    (if (current.localName[]->grammar.equalNCS) then
                        error[]->current.open;
                        current.f[]->fl[];
                        error[]->fl.unPack;
                        (if fl.f[] = none then
                            (errorNumbers.grammarNotFound,'Error during unpack')
                              ->theCatcher;
                            leave scanner
                        if);
                        (if fl.f.type = groupType then
                            fl.f[]->grammarGroup[];
                            grammarGroup.fullName->grammarWithPath[];
                            grammarWithPath.copy->grammarWithPath[];
                            leave scanner
                         else
                            (errorNumbers.grammarNotFound,
                             'Illegal form type in grammar')->theCatcher;
                            leave scanner
                        if)
                    if)
                if)
             #)
       if)
   if);
   INNER findGrammar;
   l:
   (if grammarGroup[] = none then
       trace.grammars
         ->tracer
           (# 
           do
              'FAILURE: Trying to find grammar: "'->dmp.putText;
              grammar[]->dmp.putText;
              '" among the registered grammars (grammarGroup[]=NONE)'
                ->dmp.putText
           #);
       (errorNumbers.grammarNotFound,'No registered grammars')->theCatcher;
       leave l
    else
       grammarGroup.fullName->grammarLocation[];
       ('meta',error[])->grammarGroup.open->grammarGroup[];
       (if grammarGroup[] = none then
           trace.grammars
             ->tracer
               (# 
               do
                  'FAILURE: Trying to find grammar: "'->dmp.putText;
                  grammar[]->dmp.putText;
                  '" among the registered grammars(<grammar>-meta not found)'
                    ->dmp.putText
               #);
           (errorNumbers.grammarNotFound,'Not among registered grammars')
             ->theCatcher;
           leave l
        else
           trace.grammars
             ->tracer
               (# 
               do
                  'SUCCEEDED: Trying to find grammar: "'->dmp.putText;
                  grammar[]->dmp.putText;
                  '" among the registered grammars'->dmp.putText
               #);
           (grammarLocation[],none ,error[])
             ->newgrammar.grammarinit;
           true->installed;
           
       if)
   if);
   
#)  

