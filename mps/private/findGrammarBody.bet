ORIGIN '../findgrammar';
INCLUDE '../grammarinit'
	'../metagrammarcfl'
	'../handle';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
-- findGrammarPrivate: Descriptor --
(#
   fileReadable: @
     (# f: @file
     enter f.name
     exit f.entry.readable
       (#
	  error::
	    (#
	    do true->continue; (errorNumbers.otherFileError,msg[])->theCatcher
	    #)
       #)
     #)
#)

-- findGrammarGrammarsPATHBody: DoPart --
do
   &text[]->grammars[];
   './MBSgrammars'->grammars.putline;
   '~/MBSgrammars'->grammars.putline;
   '$(BETALIB)/MBSgrammars'->grammars.putline;
   '~beta/configuration/MBSgrammars_STD'->grammars.putline;
   '~beta/configuration/MBSgrammars_DEMO'->grammars.putline;
   INNER grammarsPATH

-- findGrammarMetaGrammarFileBody: DoPart --
do '~beta/grammars/metagram/v4.5/metagrammar'->metaGrammar[];
   INNER metagrammarFile  

-- findGrammarRegisterGrammarsBody: Descriptor --
(# gfNames,gfName: ^text
do grammarsPATH->gfNames[];
   0->gfNames.pos;
   loop
     (# while::  (#  do not gfNames.EOS->value #);
	t: ^text; inx: @integer;
	alternativeGrammarDefsGroup: ^fragmentGroup
     do NONE->alternativeGrammarDefsGroup[];
	gfNames.getline->t[];
	t[]->expandToFullPath->gfName[];
	(if trace.active and trace.d[trace.grammars] then
	    trace.grammars->signalTrace
	      (# start::
		   (#
		   do 'registering  grammars from: "'->msg.putText;
		      gfName[]->msg.putText;
		      '"'->msg.put
		   #)
	      #);
	if);
	(if ('.text'->(gfName.copy).append)->private.fileReadable then
	    (gfName[],error[])->top.open->alternativeGrammarDefsGroup[]
	if);
	(if alternativeGrammarDefsGroup[] <> none then
	    alternativeGrammarDefsGroup.prop.scanProp
	      (# doProp::<
		   (# pos: @integer;
		   do (if 'GRAMMAR'->prop.equalNCS then
			  scanParameters
			    (# doName::<
				 (#
				 do (if ((pos+1) mod 3)->pos
				     // 1 then (* grammar name *)
					grammarTable.noOfKnownGrammars+1
					  ->grammarTable.noOfKnownGrammars->inx;
					(if grammarTable.noOfKnownGrammars>grammarTable.table.range then
					    10->grammarTable.table.extend
					if);
					n.copy->grammarTable.table[inx].name[];
				     else(&LoadingError[]).nameError
				    if)
				 #);
			       doString::<
				 (#
				 do (if ((pos+1) mod 3)->pos
				     // 2 then (* grammar extension *)
					s.copy
					  ->grammarTable.table[inx].extension[]
				     // 0 then (* Grammar path *)
					s.copy
					  ->grammarTable.table[inx].path[]
				     else
					(&LoadingError[]).extensionPathError
				    if);
				 #);
			       doConst::<
				 (# do (&LoadingError[]).constError #);
			    #);
			  (if pos<>0 then
			      grammarTable.noOfKnownGrammars-1->grammarTable.noOfKnownGrammars->inx;
			      (&LoadingError[]).formatError
			   else (* new grammar found *)
			      (if trace.active and trace.d[trace.grammars] then
				  trace.grammars->signalTrace
				    (# start::
					 (#
					 do 'Registered new grammar: '->msg.puttext;
					    grammarTable.table[inx].name[]->msg.putText;
					    '\t'->msg.put;
					    grammarTable.table[inx].extension[]->msg.putText;
					    '\t'->msg.put;
					    grammarTable.table[inx].path[]->msg.putLine;
					 #)
				    #);
			      if);
			  if);
		      if);
		   #)
	      #);
	if);
	(if alternativeGrammarDefsGroup[]<>NONE then
	    alternativeGrammarDefsGroup.close;
	if)
     #)
#)

-- findGrammarRegisteredGrammarsBody: DoPart --
do INNER registeredGrammars

-- findGrammarDoBody: Descriptor --
(#
   gfName: ^text;
   fl: ^fragmentLink;
   mg: ^FragmentGroup;
   grammarLocation: ^text;
do l:
   (if grammar[] = none then
       '<NONE>'->grammar[];
       (errorNumbers.grammarNotFound,'Grammar name is NONE')->theCatcher;
       leave l
    else
       (if grammarTable.meta[] = none then
	   (&metagrammar[],metaGrammarFile)->grammarTable.insertMetagrammar;
	   grammarTable.meta.init;
	   (metaGrammarFile->expandToFullPath,error[])->top.open->mg[];
	   (if not mg.isRealOpen then mg.realOpen if);
	   ('meta',error[])->mg.open->mg[];
	   (if not mg.isRealOpen then mg.realOpen if);
	   ('metagrammar',error[])->mg.open->grammarTable.meta.grammarAst[];
       if);
       &treelevel[]->newGrammar[];
       grammar.copy->expandToFullPath->gfName[];
       (if trace.active and trace.d[trace.grammars] then
	   trace.grammars->signalTrace
	     (# start::
		  (#
		  do 'trying grammar: "'->msg.putText;
		     grammar[]->msg.putText;
		     '" in current directory: "'->msg.puttext;
		     gfName[]->msg.putText;
		     '"'->msg.putLine
		  #)
	     #);
       if);
       '-meta'->gfName.append;
       astFileExtension->gfName.append;
       (if gfName[]->private.fileReadable then
	   (if trace.active and trace.d[trace.grammars] then
	       trace.grammars->signalTrace
		 (# start::
		      (#
		      do 'SUCCEEDED: Trying to find grammar: "'->msg.putText;
			 grammar[]->msg.putText;
			 '" in current directory: "'->msg.puttext;
			 gfName[]->putText;
			 '"'->msg.putLine
		      #)
		 #);
	   if);
	   (grammar[],error[])->top.open->grammarGroup[];
	   grammarGroup.fullName->grammarWithPath[];
	   grammarWithPath.copy->grammarWithPath[]
	else
       (* try to find the grammar using grammarsPATH *)
	   (if grammarTable.noOfKnownGrammars=0 then
	       (if trace.active and trace.d[trace.grammars] then
		   trace.grammars->signalTrace
		     (# start::
			  (#
			  do 'No grammars previously registered. '->msg.putText;
			     'Trying to registerGrammars'->msg.puttext
			  #)
		     #);
	       if);
	       registerGrammars
	   if);
	   (if grammarTable.noOfKnownGrammars=0 then noRegisteredGrammars if);
	   scanner: grammarTable.scan
	     (#
	     do (if trace.active and trace.d[trace.grammars] then
		    trace.grammars->signalTrace
		      (# start::
			   (#
			   do 'trying registered grammar: "'->msg.putText;
			      currentName[]->msg.putText;
			      '"'->msg.put
			   #)
		      #);
		if);
		(if (currentName[]->grammar.equalNCS) then
		    (currentPath[],error[])->top.open->grammarGroup[];
		    (if grammarGroup.type = groupType then
			grammarGroup.fullName->grammarWithPath[];
			grammarWithPath.copy->grammarWithPath[];
			leave scanner
		     else
			(errorNumbers.grammarNotFound,
			   'Illegal form type in grammar')->theCatcher;
			leave scanner
		    if)
		if)
	     #)
       if)
   if);
   INNER findGrammar;
   l:
     (if grammarGroup[] = none then
	 (if trace.active and trace.d[trace.grammars] then
	     trace.grammars->signalTrace
	       (# start::
		    (#
		    do 'FAILURE: Trying to find grammar: "'->msg.putText;
		       grammar[]->msg.putText;
		       '" among the registered grammars (grammarGroup[]=NONE)'
			 ->msg.putText
		    #)
	       #);
	 if);
       (errorNumbers.grammarNotFound,'No registered grammars')->theCatcher;
       leave l
    else
       grammarGroup.fullName->grammarLocation[];
       ('meta',error[])->grammarGroup.open->grammarGroup[];
       (if grammarGroup[] = none then
	   (if trace.active and trace.d[trace.grammars] then
	       trace.grammars->signalTrace
		 (# start::
		      (#
		      do 'FAILURE: Trying to find grammar: "'->msg.putText;
			 grammar[]->msg.putText;
			 '" among the registered grammars(<grammar>-meta not found)'
			   ->msg.putText
		      #)
		 #);
	   if);
	   (errorNumbers.grammarNotFound,'Not among registered grammars')
	     ->theCatcher;
	   leave l
	else
	   (if trace.active and trace.d[trace.grammars] then
	       trace.grammars->signalTrace
		 (# start::
		      (#
		      do 'SUCCEEDED: Trying to find grammar: "'->msg.putText;
			 grammar[]->msg.putText;
			 '" among the registered grammars'->msg.putText
		      #)
		 #);
	   if);
	   (grammarLocation[],none ,error[])
	     ->newgrammar.grammarinit;
	   true->installed;
       if)
   if);

#)
