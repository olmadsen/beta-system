ORIGIN '../findgrammar'
[[
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
-- findGrammarPrivate: descriptor --
(# longLexems: falseObject
     (# fg : ^fragmentGroup
     do newGrammar.grammarAst.father -> fg[];
        (if fg.prop[]<>NONE then
            'longLexems'->fg.prop.getProp(# doProp:: (# do true->value #) #)
        if)
     #);
   dashNames: falseObject
     (# fg : ^fragmentGroup
     do newGrammar.grammarAst.father -> fg[];
        (if fg.prop[]<>NONE then
            'dashNames'->fg.prop.getProp(# doProp:: (# do true->value #) #)
        if)
     #);
   EOLasComEnd: falseObject
     (# fg : ^fragmentGroup
     do newGrammar.grammarAst.father -> fg[];
        (if fg.prop[]<>NONE then
            'EOLasComEnd'->fg.prop.getProp(# doProp:: (# do true->value #) #)
        if)
     #);
(*   caseSensitive: falseObject
 *    (# aGrammar: ^newgrammar.meta.aGrammar; t: @text
 *    do newGrammar.grammarAst.root[] -> aGrammar[];
 *       ('caseSensitive','false')->aGrammar.getOptionString->t;
 *       'true'->t.equalNCS->value
 *    #);
 *)
   caseSensitive: falseObject
     (# fg : ^fragmentGroup
     do newGrammar.grammarAst.father -> fg[];
        (if fg.prop[]<>NONE then
            'caseSensitive'->fg.prop.getProp(# doProp:: (# do true->value #) #)
        if)
     #);
   fileReadable: @
     (# f: @file
     enter f.name
     exit f.entry.readable
        (# error::
             (#
             do true->continue;
                (errorNumbers.otherFileError,msg[])->theCatcher
        #) #) 
     #)
#)

--- findGrammarNotFoundBody: dopart ---
do 'Grammar "' -> msg;
   grammar[] -> msg.puttext;
   '" not found ' -> msg.putline;
   INNER notFound
   
--- findGrammarNoRegisteredGrammarsBody: dopart ---
do 'No grammars have been registered\n'->msg;
   INNER noRegisteredGrammars
   
--- findGrammarNoParserAvailableBody: dopart ---
do 'No parser available ,for grammar: "'->msg;
   grammar[]->msg.puttext;
   '"'->msg.putline;
   INNER noParserAvailable

--- findGrammarGrammarsPATHBody: dopart ---
do &text[]->grammars[];
   './MBSgrammars'->grammars.putline;
   '~/MBSgrammars'->grammars.putline;
   '$(BETALIB)/MBSgrammars'->grammars.putline;
   '~beta/configuration/r4.0/MBSgrammars_STD'->grammars.putline;
   '~beta/configuration/r4.0/MBSgrammars_DEMO'->grammars.putline;
   INNER grammarsPATH

--- findGrammarMetaGrammarFileBody: dopart ---
do '~beta/grammars/metagram/v4.4/metagrammar'->metaGrammar[];
   INNER metagrammarFile

--- findGrammarRegisterGrammarsCatcherBody: dopart ---
do (if no
    //errornumbers.noReadAccess
    //errornumbers.noWriteAccess
    //errornumbers.EOSError
    //errornumbers.noSuchFile
    //errornumbers.fileExists
    //errornumbers.noSpaceLeft
    //errornumbers.otherFileError
    //errornumbers.WriteAccessOnLstFileError
    //errorNumbers.notExisting
    //errorNumbers.badFormat
    //errorNumbers.parseErrors
    //errorNumbers.doubleFormDeclaration
    //errorNumbers.grammarNotFound then
    //errorNumbers.arrayTooBig then msg[] -> accessError
    //notificationNumbers.startingParsing then startParsing
    else (if no->errorNumbers.fatalParseError then
             msg[] -> accessError
         if)
   if)

--- findGrammarRegisterGrammarsBody: descriptor ---
(# oldCatcher: ^handler;
   gfNames, gfName: ^text
do (if theCatcher[]=NONE then theCatcher[]->oldCatcher[]; registerGrammarsCatcher[] -> theCatcher[] if);
   grammarsPATH -> gfNames[]; 0->gfNames.pos;
   loop(# while:: (# do not gfNames.EOS -> value #); t: ^text;
          alternativeGrammarDefsGroup: ^fragmentGroup
       do gfNames.getline ->t[]; t[]-> expandToFullPath -> gfName[];
          trace.grammars
            -> tracer(# do
                        'registering  grammars from: "' ->  dmp.putText;
                        gfName[]->dmp.putText; '"'->dmp.put
                     #);
          (if ('.text'->(gfName.copy).append)->private.fileReadable then
              (gfName[], error[]) -> top.open -> alternativeGrammarDefsGroup[]
          if);
          (if alternativeGrammarDefsGroup[]<>NONE then
              (if grammarDefsGroup[]=NONE then
                  newFragmentGroup->grammarDefsGroup[]
              if);
              alternativeGrammarDefsGroup.fragmentList.iterate
              (#
              do l:(# cell: ^alternativeGrammarDefsGroup.fragmentList.theCellType
                   do current[]->cell[];
                      grammarDefsGroup.fragmentList.scan
                      (# 
                      do (if (cell.elm.name[]->current.name.equalNCS) then
                             leave l
                         if)
                      #);
                      trace.grammars
                        -> tracer(# do
                                    'registering new grammar: "' ->  dmp.putText;
                                    current.elm.name[]->dmp.putText; '"'->dmp.put
                                 #);
                      (current.elm[],NONE)->grammarDefsGroup.fragmentList.insertBefore
                   #)
              #)
          if)
       #);
   (if theCatcher[]=registerGrammarsCatcher[] then oldCatcher[] -> theCatcher[] if)
#)

--- findGrammarRegisteredGrammarsBody: dopart ---
do grammarDefsGroup[]->grammarsGroup[];
   INNER registeredGrammars

--- findGrammarCatcherBody: dopart ---
do (if no
    //errornumbers.noReadAccess
    //errornumbers.noWriteAccess
    //errornumbers.EOSError
    //errornumbers.noSuchFile
    //errornumbers.fileExists
    //errornumbers.noSpaceLeft
    //errornumbers.otherFileError
    //errornumbers.WriteAccessOnLstFileError
    //errorNumbers.notExisting
    //errorNumbers.badFormat
    //errorNumbers.parseErrors
    //errorNumbers.doubleFormDeclaration
    //errorNumbers.grammarNotFound then
    //errorNumbers.arrayTooBig then msg[] -> accessError
    //notificationNumbers.startingParsing then startParsing
    else (if no->errorNumbers.fatalParseError then
             msg[] -> accessError
         if)
   if)

--- findGrammarDoBody:descriptor ---
(# oldCatcher: ^handler;
   gfName: ^text; fl: ^fragmentLink;
   mg: ^FragmentGroup;
do (if theCatcher[]=NONE then theCatcher[]->oldCatcher[]; findGrammarCatcher[] -> theCatcher[] if);
   l: (if grammar[]=NONE then
          '<NONE>'->grammar[]; notFound; leave l
       else 
          (if grammarTable.meta[]=NONE then
              &metagrammar[] -> grammarTable.insertMetagrammar;
              (metaGrammarFile -> expandToFullPath,error[]) -> top.open -> mg[];
              ('meta',error[])->mg.open->mg[];
              ('metagrammar',error[])->mg.open->grammarTable.meta.grammarAst[]
          if);
          &applGram[] -> newGrammar[];
          (* try first to find the grammar directly in currentDirectory *)
          grammar.copy->expandToFullPath -> gfName[];
          trace.grammars
            -> tracer(# do
                        'trying grammar: "' ->  dmp.putText;
                        grammar[]->dmp.putText;
                        '" in current directory: "' -> dmp.puttext;
                        gfName[]->dmp.putText; '"'->dmp.putLine
                     #);
          '-meta'->gfName.append;
          astFileExtension->gfName.append;
          (if gfName[]->private.fileReadable then
              trace.grammars
                -> tracer(# do
                            'SUCCEEDED: Trying to find grammar: "'->dmp.putText;
                            grammar[] -> dmp.putText;
                            '" in current directory: "' -> dmp.puttext;
                            gfName[]->putText; '"'->dmp.putLine
                         #);
              (grammar[],error[])->top.open->grammarGroup[];
              grammarGroup.fullName -> grammarWithPath[];
              grammarWithPath.copy->grammarWithPath[]
           else
              (* try to find the grammar using grammarsPATH *)
              (if grammarDefsGroup[]=NONE then
                  trace.grammars
                    -> tracer(# do
                                'No grammars previously registered. ' -> dmp.putText;
                                'Trying to registerGrammars' -> dmp.puttext
                             #);
                  registerGrammars
              if);
              (if grammarDefsGroup[]=NONE then noRegisteredGrammars if);
              scanner: GrammarDefsGroup.fragmentList.scan
                (#
                do (if current.type=linkType then
                       trace.grammars
                         -> tracer(# do
                                     'trying registered grammar: "' ->  dmp.putText;
                                     current.localName[]->dmp.putText; '"'->dmp.put
                                  #);
                       (if (current.localName[] -> grammar.equalNCS) then
                           error[]->current.open;
                           current.f[] -> fl[];
                           error[]->fl.unPack;
                           (if fl.f[]=NONE then
                               notFound; leave scanner
                           if);
                           (if fl.f.type=groupType then
                               fl.f[] -> grammarGroup[];
                               grammarGroup.fullName -> grammarWithPath[];
                               grammarWithPath.copy->grammarWithPath[];
                               leave scanner
                            else notFound; leave scanner
                           if)
                       if)
                   if)
                #)
          if)
      if);
   
   INNER findGrammar;
   
   l: (if grammarGroup[]=NONE
          then trace.grammars
            -> tracer(# do
                        'FAILURE: Trying to find grammar: "' ->  dmp.putText;
                        grammar[] -> dmp.putText;
                        '" among the registered grammars' -> dmp.putText
                     #);
          notFound; leave l
       else
          ('meta',error[]) -> grammarGroup.open -> grammarGroup[];
          (if grammarGroup[]=NONE
              then trace.grammars
                -> tracer(# do
                            'FAILURE: Trying to find grammar: "'->dmp.putText;
                            grammar[] -> dmp.putText;
                            '" among the registered grammars' -> dmp.putText
                         #);
              notFound; leave l
           else
              trace.grammars
                -> tracer(# do
                            'FAILURE: Trying to find grammar: "'->dmp.putText;
                            grammar[] -> dmp.putText;
                            '" among the registered grammars' -> dmp.putText
                         #);
              firstFragment: grammarGroup.fragmentList.scan
                (# 
                do (if current.f.type=formType then
                       current.f[]->newGrammar.grammarAst[]; 
                       leave firstFragment 
                   if)
                #);
              (if (newGrammar.grammarAst[]<>NONE) then
                  trace.grammars
                    -> tracer(# do
                                'SUCCEEDED: Trying to find grammar: "'->dmp.putText;
                                grammar[] -> dmp.putText;
                                '" among the registered grammars' -> dmp.putText
                             #);
                  grammarTable.meta[] -> newgrammar.meta[];
                  newgrammar.init; true->installed;
                  (# btabFile: ^text
                  do grammarWithPath.copy->btabFile[];
                     '-parser'->btabFile.puttext; parserFileExtension->btabFile.puttext; 
                     btabFile[]->expandToFullPath
                       -> bobsFile.name
                  #);
                  (if bobsFile.entry.exists
                      (# error::
                           (#
                           do true->continue;
                              (errorNumbers.otherFileError,msg[])->theCatcher
                      #) #) then
                      bobsFile.name -> expandToFullPath
                        -> newGrammar.parser.initialize
                             (# longLexems:: private.longLexems;
                                dashNames:: private.dashNames;
                                caseSensitive:: private.caseSensitive;
                                EOLasComEnd:: private.EOLasComEnd
                             #)
                   else noParserAvailable
                  if)
               else trace.grammars
                    -> tracer(# do
                                'FAILURE: Trying to find grammar: "'->dmp.putText;
                                grammar[] -> dmp.putText;
                                '" among the registered grammars' -> dmp.putText
                             #);
                  notFound; leave l
              if)
          if)
      if);
   (if theCatcher[]=findGrammarCatcher[] then oldCatcher[] -> theCatcher[] if)
#)
---]]
