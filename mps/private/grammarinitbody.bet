ORIGIN '../grammarinit';
INCLUDE 'astparser'
        '../metagramsematt';
-- grammarinitCatcherBody: DoPart --
do
   (if no
    // errornumbers.noReadAccess // errornumbers.noWriteAccess
    // errornumbers.EOSError // errornumbers.noSuchFile
    // errornumbers.fileExists // errornumbers.noSpaceLeft
    // errornumbers.otherFileError // errornumbers.WriteAccessOnLstFileError
    // errorNumbers.notExisting // errorNumbers.badFormat
    // errorNumbers.parseErrors // errorNumbers.doubleFormDeclaration
    // errorNumbers.grammarNotFound // errorNumbers.arrayTooBig then
       msg[]->mpsError
    // notificationNumbers.noParserAvailable then
       msg[]->noParserAvailable
    // notificationNumbers.startingParsing then
       startParsing
    else
       (if no->errorNumbers.fatalParseError then msg[]->mpsError if)
   if)  

-- grammarinitgrammarinit: Descriptor --
(# grammarWithPath,help,name: ^text; gg,mg: ^fragmentGroup; bobsfile: @file
do
   (if theCatcher[] = none then
       theCatcher[]->grammarinitCatcher.oldCatcher[];
       grammarinitCatcher[]->theCatcher[]
   if);
   (if grammarTable.meta[] = none then
       &metagrammar[]->grammarTable.insertMetagrammar;
       grammarTable.meta.init;
       ('~beta/grammars/metagram/v4.4/metagrammar'->expandToFullPath,error[])
         ->top.open->mg[];
       ('meta',error[])->mg.open->mg[];
       ('metagrammar',error[])->mg.open->grammarTable.meta.grammarAst[];
       
   if);
   grammarLocation[]->expandToFullPath->grammarWithPath[];
   (grammarWithPath[],error[])->top.open->gg[];
   (if gg[] = none then
       'Could not open: '->help[];
       grammarWithPath[]->help.putLine;
       (errorNumbers.grammarNotFound,help[])->theCatcher;
       
   if);
   ('meta',error[])->gg.open->gg[];
   (if grammarName[] = none then
       firstFragment: gg.fragmentList.scan
         (# ff: ^fragmentForm
         do
            (if current.f.type = formType then
                current.name[]->grammarName[]
            if);
            leave firstFragment
         #)
   if);
   (if gg[] = none then
       'Could not open: '->help[];
       '-meta'->(grammarWithPath.copy).Append->help.putLine;
       (errorNumbers.grammarNotFound,help[])->theCatcher;
       
    else
       (grammarName[],error[])->gg.open->grammarAst[];
       (if grammarAst[] = none then
           'No grammarAst for '->help[];
           grammarWithPath[]->help.putLine;
           (errorNumbers.grammarNotFound,help[])->theCatcher;
           
       if);
       
   if);
   THIS(treeLevel).init;
   (* if we do this betagrammarinit can be avoided 
    * grammarIdentification->name[];
    * (if 'beta'->name.equal then
    *    this(treeLevel)[]->grammarTable.beta[]
    * if);
    *)
   (if grammarAst[] = none then
       'No grammarAst for '->help[];
       grammarWithPath[]->help.putLine;
       (errorNumbers.grammarNotFound,help[])->theCatcher;
       
    else
       '-parser'->help[];
       parserFileExtension->help.append;
       help[]->(grammarWithPath.copy).Append->expandToFullPath->bobsFile.name;
       (if bobsFile.entry.exists then
           bobsFile.name
             ->parser.initialize
               (#
                  longLexems:: THIS(grammarInit).longLexems;
                  dashNames:: THIS(grammarInit).dashNames;
                  caseSensitive:: THIS(grammarInit).caseSensitive;
                  EOLasComEnd:: THIS(grammarInit).EOLasComEnd
               #);
           (*  if we do this betagrammarinit can be avoided 
            * (if 'beta'->name.equal then
            * ('objectdescriptor','descriptor')
            * ->parser.privatePart.b.defineNonTAlias;
            * ('attributedecl','attributes')
            * ->parser.privatePart.b.defineNonTAlias
            * if);
            *)
           
        else
           'No parser available: '->help[];
           bobsFile.name->help.putLine;
           (notificationNumbers.noParserAvailable,help[])->theCatcher;
           
       if)
   if);
   (if theCatcher[] = grammarinitCatcher[] then
       grammarinitCatcher.oldCatcher[]->theCatcher[]
   if)
#)  

-- grammarinitbetagrammarinit: DoPart --
do
   THIS(treeLevel)[]->grammarTable.beta[];
   (if parser.HaveBeenInitialized then
       ('objectdescriptor','descriptor')->parser.privatePart.b.defineNonTAlias;
       ('attributedecl','attributes')->parser.privatePart.b.defineNonTAlias
   if);
     

-- grammarinitlib: Attributes --
longLexems: falseObject
  (# fg: ^fragmentGroup
  do
     grammarAst.father->fg[];
     (if fg.prop[] <> none then
         'longLexems'
           ->fg.prop.getProp (# doProp::  (#  do true->value #) #)
     if)
  #);
dashNames: falseObject
  (# fg: ^fragmentGroup
  do
     grammarAst.father->fg[];
     (if fg.prop[] <> none then
         'dashNames'
           ->fg.prop.getProp (# doProp::  (#  do true->value #) #)
     if)
  #);
EOLasComEnd: falseObject
  (# fg: ^fragmentGroup
  do
     grammarAst.father->fg[];
     (if fg.prop[] <> none then
         'EOLasComEnd'
           ->fg.prop.getProp (# doProp::  (#  do true->value #) #)
     if)
  #);
caseSensitive: falseObject
  (# fg: ^fragmentGroup
  do
     grammarAst.father->fg[];
     (if fg.prop[] <> none then
         'caseSensitive'
           ->fg.prop.getProp (# doProp::  (#  do true->value #) #)
     if)
  #);
  

