ORIGIN 'astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/v1.6/private/filebody'
	'~beta/sysutils/v1.6/endian'
	'../metagramsematt';

-- astSonNo: DoPart --
do
   findFatherInx->finx;
   (if finx = 0 then 'ERROR: trying to get sonNo for root'->stopYggdrasil if);
   (1,finx->frag.getSonInx)->(son,inx);
   loop:
   (if (inx <> index) then
       (if (inx->frag.isLastBrother) then
	   'ERROR: trying to access a nonexisting son in sonNo'->stopYggdrasil
       if);
       (son+1,inx->frag.getNextBrother)->(son,inx);
       restart loop
   if);


-- astSymbolEnterBody: DoPart --
do lab->symbolInx

-- astSymbolExit: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->lab

-- astFatherExit: DoPart --
do findFatherInx->frag.indexToNode->as[]

-- astEqual: DoPart --
do ((comparedAst.Index = index) and (comparedAst.frag[] = frag[]))->eq

-- astNextbrother: DoPart --
do
   (if lastBrother then
       none ->brother[]
    else
       brotherInx->frag.indexToNode->brother[]
   if)

-- astKind: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->frag.grammar.kindOfSymbol->kind

-- astLt: Descriptor --
(# dummy: ^Ast;
do testAst[]->nearestCommonAncestor->(dummy[],testSonNo,mySonNo)
#)

-- astPutAttribute: DoPart --
do
   attributNo->checkAttributNo;
   val->frag.a[index+offset.attribute+attributno-1];


-- astGetAttribute: DoPart --
do
   attributNo->checkAttributNo; frag.a[index+offset.attribute+attributno-1]->val

-- astPutNodeAttribute: DoPart --
do
   attributNo->checkAttributNo;
   val[]->frag.packAstToValue->frag.a[index+offset.attribute+attributNo-1]

-- astGetNodeAttribute: DoPart --
do
   attributNo->checkAttributNo;
   frag.a[index+offset.attribute+attributno-1]->frag.valueToAst->val[]

-- astPutSlotAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   val->frag.a[commentInx+offset.slotAttribute+attributno-1];


-- astGetSlotAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.SlotAttribute+attributno-1]->val

-- astPutSlotNodeAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   val[]->frag.packAstToValue
     ->frag.a[commentInx+offset.SlotAttribute+attributNo-1]

-- astGetSlotNodeAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.Slotattribute+attributno-1]->frag.valueToAst->val[]

-- astAddComment: DoPart --
do (if l[] = none then 0->realCommentInx else l.index->realCommentInx if)

-- astGetCommentExit: DoPart --
do realcommentInx->frag.indexToNode->as[]

-- printComment: DoPart --
do
   '<'->output.put;
   comment.scanAll
     (#
     do
	(if ch
	 // CommentSeparator1 then
	    'S'->output.put;
	 // CommentSeparator2 then
	    's'->output.put;
	 // CommentSeparator3 then
	    'p'->output.put;
	 else
	    ch->output.put;
	if);

     #);
   '>'->output.put;
   output.newLine;


-- astGetNextComment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; inx: @Integer; ch: @Char;
do (if realcommentInx = 0 then
       (if trace.active and trace.d[trace.getNextComment] then
	   trace.getNextComment->signalTrace
	     (# start::
		  (# do 'no comment '->msg.putText; index->msg.putInt; msg.newLine #)
	     #);
       if);
       (* no comment *)
       -2->n;
       none ->subcomment[];
    else
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       (if theComment[] <> none then
	   (if trace.active and trace.d[trace.getNextComment] then
	       trace.getNextComment->signalTrace
		 (# start::
		      (#
		      do '<'->msg.put;
			 theComment.scanAll
			   (#
			   do (if ch
			       // CommentSeparator1 then
				  'S'->msg.put;
			       // CommentSeparator2 then
				  's'->msg.put;
			       else
				  ch->msg.put;
			      if);

			   #);
			 '>'->msg.put;
			 msg.newLine;
			 ' [theComment.lgth:'->msg.putText;
			 theComment.lgth->msg.putInt;
			 ']'->msg.put;
			 msg.newLine;
		      #)
		 #)
	   if);
	   theComment.reset;
	   mainloop:
	     (if inx = theComment.lgth then (* end of comment *)
		 2->n;
		 none ->subcomment[];
		 0->inx;
		 (* finished2 *)
		 SUSPEND;
		 restart mainloop;
		 (* to avoid termination of component *)
		 (* end of getNextComment *)
	      else
		 (* read next comment *)
		 &Text[]->subcomment[];
		 loop:
		   (if ((inx+1->inx)->theComment.inxget->ch)
		    // CommentSeparator1 then
		       (if trace.active and trace.d[trace.getNextComment] then
			   trace.getNextComment->signalTrace
			     (# start::
				  (# do '(S1)'->msg.putLine #)
			     #);
		       if);
		       (if subcomment.lgth = 0 then (* no comments *)
			   - 1->n;
			else
			   (* one comment, or the last comment in a sub sequence *)
			   1->n;
		       if);

		    // CommentSeparator2 then
		       (if trace.active and trace.d[trace.getNextComment] then
			   trace.getNextComment->signalTrace
			     (# start::
				  (# do '(s1)'->msg.putLine #)
			     #);
		       if);
		       (if inx = theComment.lgth then
			   0->inx; 2->n; (*finished*)
			else
			   (if (inx+1->theComment.inxget) = CommentSeparator1 then
			       inx+1->inx; 0->n;
			    else
			       1->n
			   if);

		       if)
		else
		       (if inx+1 > theComment.lgth then
			   'GetNextComment: last subcomment not terminated properly, is ignored'
			     ->screen.putLine;
			   '<'->screen.put;
			   theComment.scanAll
			     (#
			     do
				(if ch
				 // CommentSeparator1 then
				    'S'->screen.put;
				 // CommentSeparator2 then
				    's'->screen.put;
				 else
				    ch->screen.put;
				if);

			     #);
			   '>'->screen.put;
			   screen.newLine;
			   ' [theComment.lgth:'->screen.putText;
			   theComment.lgth->screen.putInt;
			   ']'->screen.put;
			   screen.newLine;
			   none ->subcomment[];
			   0->inx;
			   2->n (* finished *)
			else
			   ch->subcomment.put; restart loop;
		       if)
		   if);
		 (if trace.active and trace.d[trace.getNextComment] then
		     trace.getNextComment->signalTrace
		       (# start::
			    (#
			    do '*** suspend '->msg.putText;
			       index->msg.putInt;
			       ' <'->msg.putText;
			       subComment[]->msg.putText;
			       '> '->msg.putText;
			       n->msg.putInt;
			       ' inx: '->msg.putText;
			       inx->msg.putInt;
			       msg.newLine
			    #)
		       #);
		 if);
		 SUSPEND;
		 (if trace.active and trace.d[trace.getNextComment] then
		     trace.getNextComment->signalTrace
		       (# start::
			    (#
			    do '*** restart '->msg.putText;
			       index->msg.putInt;
			       msg.newLine
			    #)
		       #);
		 if);
		 restart mainloop;
	     if);
	else
	   (if trace.active and trace.d[trace.getNextComment] then
	       trace.getNextComment->signalTrace
		 (# start::
		      (#
		      do 'no comment, should not happen '->msg.putText;
			 index->msg.putInt;
			 msg.newLine
		      #)
		 #);
	   if);
	   -2->n;
	   none ->subcomment[];

       if);

   if);

#)

-- astInsertSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded;
do
   (if (inx <= 0) then
       'InsertSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;

    else
       (if subcomments[] = none then
	   'InsertSubcomments: subcomments[] is none '->putLine;
	else
	   (if realcommentInx = 0 then (* no comment *)
	       'InsertSubcomments: No comment'->putLine;
	       'In node: '->putText;
	       index->putInt;
	       newLine;
	       'An empty comment must be created using the'->putLine;
	       'Prettyprinter operation: createEmptyComment'->putLine
	    else
	       realcommentInx->frag.indexToNode->commentAST[];
	       commentAST.getText->theComment[];

	   if);
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'InsertSubcomment: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.puttext;
				 inx->msg.putint;
				 msg.newLine;
				 'insertsubcomments.theComment:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 msg.newLine;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine;
				 'insertsubcomments.subComments:'->msg.putLine;
				 (subcomments[],msg[])->printComment;
				 msg.newLine;
				 'subComments.lgth:'->msg.putText;
				 subComments.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   (theComment[],inx)
		     ->findSubcomments
		       (# st: @integer
		       do
			  (Subcomments[],start)->theComment.insert;
			  theComment[]->commentAST.putText;
			  commentAST[]->addComment;
			  (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					' '->msg.put
				     #)
				#);
			  if);
		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'insertSubcomments.result:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if);

       if)
   if)
#)

-- astSetSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded;
do
   (if (inx <= 0) then
       'SetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;

    else
       (if subcomments[] = none then
	   'SetSubcomments: subcomments[] is none '->putLine;
	else
	   (if realcommentInx = 0 then (* no comment *)
	       'SetSubcomments: No comment'->putLine;
	       'In node: '->putText;
	       index->putInt;
	       newLine;
	       'An empty comment must be created using the'->putLine;
	       'Prettyprinter operation: createEmptyComment'->putLine
	    else
	       realcommentInx->frag.indexToNode->commentAST[];
	       commentAST.getText->theComment[];

	   if);
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'SetSubcomments: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.putText;
				 inx->msg.putint;
				 msg.newLine;
				 'setsubcomments.theComment:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 msg.newLine;
				 'theComment.lgth: '->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine;
				 'setsubcomments.subComments:'->msg.putLine;
				 (subcomments[],msg[])->printComment;
				 msg.newLine;
				 'subComments.lgth:'->msg.putText;
				 subComments.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   (theComment[],inx)
		     ->findSubcomments
		       (# st: @integer
		       do
			  (if (start <> end) then
			      (start,end)->theComment.delete;
			  if);
			  (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					' '->msg.put;
					'setSubcomments.afterDelete:'->msg.putLine;
					(theComment[],msg[])->printComment;
					'theComment.lgth:'->msg.putText;
					theComment.lgth->msg.putInt;
					msg.newLine
				     #)
				#);
			  if);
			  (Subcomments[],start)->theComment.insert;
			  theComment[]->commentAST.putText;
			  commentAST[]->addComment;

		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'setSubcomments.result: '->msg.putLine;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if)
       if)
   if)
#)

-- astGetSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text;
do
   (if (inx <= 0) then
       'GetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;

    else
       (if realcommentInx = 0 then (* no comment *)
	   ''->subcomments[];
	else
	   realcommentInx->frag.indexToNode->commentAST[];
	   commentAST.getText->theComment[];
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'GetSubcomments: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine;
		   ''->subcomments[]
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.putText;
				 inx->msg.putint;
				 msg.newLine;
				 'getsubcomments.theComment:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 msg.newLine;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   ''->Subcomments[];
		   (theComment[],inx)
		     ->findSubcomments
		       (# st: @integer
		       do
			  (if start <> end then
			      (start,end)->theComment.sub->Subcomments[];
			  if);
			  (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					' '->msg.put
				     #)
				#);
			  if);
		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'getsubcomments.subComments:'->msg.putLine;
				 (subComments[],msg[])->printComment;
				 'subcomments.lgth:'->msg.putText;
				 subcomments.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if);

       if)
   if)
#)

-- astScanComments: Descriptor --
(# n,n2: @integer
do (if trace.active and trace.d[trace.getNextComment] then
       trace.getNextComment->signalTrace
	 (# start::
	      (# do 'scanComments ---------'->msg.putLine #)
	 #);
   if);
   loop:
   (if 1 = 1 then
       getNextComment->(current[],n);
       (* 'current: '->putText;
	'<'->put;
	current[]->putText;
	'> '->putText;
	n->putInt;
	newLine;*)
       (if n
	// - 2 then (* empty comment *)

	// - 1 then (* empty subcomment *)
	   inx+1->inx; 1->subinx; INNER scanComments; restart loop
	// 0 then (* one subcomment' *)
	   inx+1->inx; 1->subinx; INNER scanComments; restart loop
	// 1 then (* subsequence *)
	   inx+1->inx;
	   1->subinx;
	   INNER scanComments;
	   loop2:
	   (if 1 = 1 then
	       getNextComment->(current[],n2);
	       subinx+1->subinx;
	       INNER scanComments;
	       (if n2 = 1 then restart loop2 if);

	   if);
	   (if n2 <> 2 then restart loop if)
	// 2 then (* finished *)
	   inx+1->inx; 1->subinx; INNER scanComments
       if)
   if)
#)

-- astInsertSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text;
do
   (if (inx <= 0) or (subinx <= 0) then
       'InsertSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;

    else
       (if subcomment[] = none then
	   'InsertSubcomment: subcomment[] is none '->putLine;
	else
	   (if realcommentInx = 0 then (* no comment *)
	       'InsertSubcomment: No comment'->putLine;
	       'In node: '->putText;
	       index->putInt;
	       newLine;
	       'An empty comment must be created using the'->putLine;
	       'Prettyprinter operation: createEmptyComment'->putLine
	    else
	       realcommentInx->frag.indexToNode->commentAST[];
	       commentAST.getText->theComment[];

	   if);
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'InsertSubcomment: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.putText;
				 inx->msg.putint;
				 msg.newLine;
				 'subinx: '->msg.putText;
				 subinx->msg.putint;
				 msg.newLine;
				 'InsertSubcomment.theComment:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine;
				 'InsertSubcomment.Subcomment:'->msg.putLine;
				 (Subcomment[],msg[])->printComment;
				 'Subcomment.lgth:'->msg.putText;
				 Subcomment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   (theComment[],inx,subinx)
		     ->findSubComment
		       (# st: @integer
		       do (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					' '->msg.put
				     #)
				#);
			  if);
			  Subcomment->help;
			  help.length->help.pos;
			  CommentSeparator2->help.put;
			  (help[],start)->theComment.insert;
			  theComment[]->commentAST.putText;
			  commentAST[]->addComment;

		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'InsertSubcomment.result:'->msg.putText;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if);

       if);

   if)
#)

-- astSetSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text;
do
   (if (inx <= 0) or (subinx <= 0) then
       'SetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;

    else
       (if subcomment[] = none then
	   'SetSubcomment: subcomment[] is none '->putLine;
	else
	   (if realcommentInx = 0 then (* no comment *)
	       'SetSubcomment: No comment'->putLine;
	       'In node: '->putText;
	       index->putInt;
	       newLine;
	       'An empty comment must be created using the'->putLine;
	       'Prettyprinter operation: createEmptyComment'->putLine
	    else
	       realcommentInx->frag.indexToNode->commentAST[];
	       commentAST.getText->theComment[];

	   if);
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'SetSubcomment: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.putText;
				 inx->msg.putint;
				 msg.newLine;
				 'subinx: '->msg.putText;
				 subinx->msg.putint;
				 msg.newLine;
				 'setSubcomment.theComment:'->msg.putLine;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine;
				 'setSubcomment.Subcomment:'->msg.putLine;
				 (Subcomment[],msg[])->printComment;
				 'Subcomment.lgth:'->msg.putText;
				 Subcomment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   (theComment[],inx,subinx)
		     ->findSubComment
		       (# st: @integer
		       do (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					' '->msg.put
				     #)
				#);
			  if);
			  (if (start <= end) then
			      (start,end+1)->theComment.delete;
			      (* the separator2 is also deleted *)
			      (if trace.active and trace.d[trace.editingComments] then
				  trace.editingComments->signalTrace
				    (# start::
					 (#
					 do 'setSubcomment.afterDelete:'->msg.putText;
					    (theComment[],msg[])->printComment;
					    'theComment.lgth:'->msg.putText;
					    theComment.lgth->msg.putInt;
					    msg.newLine
					 #)
				    #);
			      if);
			  if);
			  Subcomment->help;
			  help.length->help.pos;
			  CommentSeparator2->help.put;
			  (* the user of getSubcomment and setSubcomment
			   * does not have to worry about separators
			   *)
			  (help[],start)->theComment.insert;
			  theComment[]->commentAST.putText;
			  commentAST[]->addComment;

		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'setSubcomment.result:'->msg.putText;
				 (theComment[],msg[])->printComment;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if);

       if);

   if)
#)

-- astGetSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text;
do
   (if (inx <= 0) or (subinx <= 0) then
       'GetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;

    else
       (if realcommentInx = 0 then (* no comment *)
	   ''->subcomment[];
	else
	   realcommentInx->frag.indexToNode->commentAST[];
	   commentAST.getText->theComment[];
	   (if theComment[] <> none then
	       (if theComment.lgth = 0 then
		   'GetSubcomment: the comment is empty, not even any separators '
		     ->putLine;
		   'In node: '->putText;
		   index->putInt;
		   newLine;
		   ''->subcomment[]
		else
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'inx: '->msg.putText;
				 inx->msg.putint;
				 msg.newLine;
				 'subinx: '->msg.putText;
				 subinx->msg.putint;
				 msg.newLine;
				 'getSubComment.theComment: '->msg.putLine;
				 (theComment[],msg[])->printComment;
				 msg.newLine;
				 'theComment.lgth:'->msg.putText;
				 theComment.lgth->msg.putInt;
				 msg.newLine
			      #)
			 #);
		   if);
		   ''->subComment[];
		   (theComment[],inx,subinx)
		     ->findSubComment
		       (# st: @integer
		       do
			  (if start <= end then
			      (start,end)->theComment.sub->subComment[];
			  if);
			  (if trace.active and trace.d[trace.editingComments] then
			      start->st;
			      trace.editingComments->signalTrace
				(# start::
				     (#
				     do 'start,end: '->msg.putText;
					st->msg.putInt;
					' '->msg.put;
					end->msg.putInt;
					msg.newLine
				     #)
				#);
			  if);
		       #);
		   (if trace.active and trace.d[trace.editingComments] then
		       trace.editingComments->signalTrace
			 (# start::
			      (#
			      do 'getSubcomment.subComment: '->msg.putLine;
				 (subComment[],msg[])->printComment;
				 msg.newLine
			      #)
			 #);
		   if);
	       if)
	   if);

       if)
   if)
#)

-- astHascomment: DoPart --
do realcommentInx <> 0->has

-- astGetCommentProp: Descriptor --
(# c: ^comment; base: @integer;
do
   (if hasCommentProp then
       getComment->c[];
       c.curLength div 4->repS.extend;
       c.lexemInx->base;
       0->repS.top;
       (for i: c.curLength div 4 repeat c.frag.a[base+i]->repS.putInt for);
       0->repS.top;
       &propertyList[]->prop[];
       repS[]->prop.repRestore;

   if);

#)

-- astSetCommentProp: Descriptor --
(# c: ^comment; base: @integer;
do
   0->repS.top;
   repS[]->prop.repSave;
   (prodNo.comment,frag[])->frag.grammar.newAst->c[];
   repS.top*4->c.checkBase;
   c.lexemInx->base;
   (for i: repS.top repeat repS.r[i]->c.frag.a[base+i] for);
   repS.top*4->c.curLength;
   c[]->addComment;
   17->typeOfComment;

#)

-- astTypeOfCommentEnter: DoPart --
do
   (if hasComment then
       type->frag.a[realcommentInx+offset.commentType]
    else
       'node has no comment'->stopYggdrasil
   if)

-- astTypeOfCommentExit: DoPart --
do
   (if hasComment then
       frag.a[realcommentInx+offset.commentType]->type
    else
       - 1->type
   if);


-- astNCA: Descriptor --
(# myScanner: @|scanDown;
do
   (if not (testAst[]->equal) then
	 (# testScanner: ^|testAst.scanDown; myAs,testAs: ^Ast
	 do
	    &| testAst.scanDown[]->testScanner[];
	    loop:
	      (#
	      do
		 myScanner->myAs[];
		 testScanner->testAs[];
		 (if (myAs[]->testAs.equal) then
		     myAs[]->nca[];
		     (if true
		      // (nca[]->equal) then
			 testScanner->testAs[]; testAs.sonNo->testSonNo
		      // (nca[]->testAst.equal) then
			 myScanner->myAs[]; myAs.sonNo->mySonNo
		      else
			 restart loop
		     if)
		  else
		     testAs.sonNo->testSonNo; myAs.sonNo->mySonNo
		 if)
	      #)
	 #)
    else
       testAst[]->nca[]
   if)
#)

-- astScan: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;

do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       privateInx->privateIndexToNode->current[];
       currentSonNo+1->currentSonNo;
       INNER scan;
       (if not (privateInx->privateIsLastBrother) then
	   privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)

-- astSuffixWalk: Descriptor --
(#
   nextinx,firstson: @integer;
   theCutter: @cutIf;
   s: @stak;
   setNextInx:
     (#
     enter nextInx
     do
	(if not (nextInx->frag.isLastBrother) then
	    nextInx->frag.getNextBrother->s.push
	if)
     #);

do
   s.init;
   index->nextInx;
   stakscan:
     (#
     do
	(if not (nextInx->frag.getSymbol->theCutter) then
	    nextinx->frag.indexToNode->current[];
	    INNER suffixWalk;
	    (if (nextInx->frag.getSymbol->frag.grammar.kindOfSymbol) =
	    kinds.interior then
		(if ((nextInx->frag.getSonInx->firstSon) > 0) then
		    firstSon->setNextInx; restart stakScan
		if)
	    if)
	if);
	(if not s.empty then s.pop->setNextInx; restart stakScan if);

     #);

#)

-- astSuffixWalkForProd: Descriptor --
(#
   theCutter: @cutIf;
   s: @stak;
   nextInx,firstson: @integer;
   theSymbol: @integer;
   setNextInx:
     (#
     enter nextInx
     do
	(if not (nextInx->frag.isLastBrother) then
	    nextInx->frag.getNextBrother->s.push
	if)
     #);

do
   s.init;
   index->nextInx;
   stakscan:
     (#
     do
	(if not (nextInx->frag.getSymbol->theSymbol->theCutter) then
	    (if theSymbol = prod then
		nextinx->frag.indexToNode->current[]; INNER suffixWalkForProd
	    if);
	    (if (theSymbol->frag.grammar.kindOfSymbol) = kinds.interior then
		(if ((nextInx->frag.getSonInx->firstSon) > 0) then
		    firstSon->setNextInx; restart stakScan
		if)
	    if)
	if);
	(if not s.empty then s.pop->setNextInx; restart stakScan if);

     #)
#)

-- astCopyCopyCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
	   (msg[],no-100)->fatalParseError
       if)
   if)

-- astCopyExit: Dopart --
do
   (if theCatcher[] = none then
       theCatcher[]->copyCatcher.oldCatcher[]; copyCatcher[]->theCatcher[]
   if);
   copyFrag[]->copyPrivate->copyfrag.indexToNode->as[];
   (if theCatcher[] = copyCatcher[] then
       copyCatcher.oldCatcher[]->theCatcher[]
   if)

-- astDump: DoPart --
do
   (if dmp[] = none then screen[]->dmp[] if);
   '@'->dmp.put;
   (index)->dmp.putInt;
   (if hasComment then
       ' COMMENT '->dmp.putText;
       (if (commentInx >= frag.a.range) then
	   '_'->dmp.put
	else
	     (# l: ^lexemText; t: ^text;
	     do
		'"'->dmp.put;
		getComment->l[];
		l.gettext->t[];
		(t[],dmp[])->printComment;
		(* lexemtext.dump should also check the size of the text *)
		(* (1,(30,t.length) -> min ) -> t.sub -> dmp.puttext;
		 (if t.length>30 then
		 '...' -> dmp.puttext;
		 (((30,t.length) -> max) - 30,t.length) -> t.sub -> dmp.puttext;
		 if);
		 *)
		'"'->dmp.put
	     #);

       if)
   if);
   INNER dump;


-- astMatch: DoPart --
do
   (if not ((treeToMatch.symbol = unExpanded)->doesMatch) then
       (if ((treeToMatch.symbol = symbol)->doesMatch) then INNER match if)
   if)

-- astSemanticErrorEnter: DoPart --
do
   (if (errorNumber > 0) then
       true->hasSemanticError;
       'Semanticerrors'
	 ->frag.prop.addProp
	   (# ifPropExist::  (#  do false->delete #);
	   do index->addConst; errorNumber->addConst
	   #);

    else
       false->hasSemanticError
   if)

-- astSemanticExit: DoPart --
do
   (if hasSemanticError then
       'Semanticerrors'
	 ->frag.prop.getProp
	   (#
	      doProp::
		(# readIndex,indexFound: @boolean
		do
		   true->readIndex;
		   false->indexFound;
		   scanParameters
		     (#
			doConst::
			  (#
			  do
			     (if readIndex then
				 (c = index)->indexFound;
			      else
				 (if indexFound then c->errorNumber if)
			     if);
			     not readIndex->readIndex;

			  #);

		     #);

		#);

	   #)
   if)

-- astCopyPrivate: DoPart --
do
   (symbol,copyFrag[])->frag.grammar.newAstWithoutSons->theCopy[];
   (if (symbol <> comment) then
       (if hasComment then
	     (# theComment: ^comment;
	     do
		getComment->theComment[];
		copyFrag[]->theComment.copy->theCopy.addComment;

	     #);

       if)
   if);
   INNER copyPrivate;
   theCopy.index->theCopyInx;


-- newast: Descriptor --
(# unExp: ^unExpanded; lastInx: @integer; NoOfsons: @integer;
do
   (prod,frag[])->newAstWithOutSons->as[];
   (if (prod > 0) then
       (for i: (sonArray[prod]->noOfSons) repeat
	 (0,frag[])->newUnExpanded->unExp[];
	 (if i = 1 then
	     (as.index,unExp.index->lastInx)->frag.setSonInx
	  else
	     (lastInx,unExp.index)->frag.setNextBrother; unExp.index->lastInx;
	 if)
       for);
       (if (noOfSons > 0) then
	   (lastInx,true)->frag.setlastBrother;
	   (lastInx,as.index)->frag.setNextBrother;

       if)
   if)
#)

-- newAstWithoutSons: DoPart --
do
   (if (prod < 0) then
       (if prod
	// prodNo.unExpanded then
	   (0,frag[])->newUnExpanded->as[];
	// prodNo.optional then
	   (0,frag[])->newOptional->as[];
	// prodNo.NameDecl // prodNo.NameAppl // prodNo.String
	// prodNo.Comment then
	   (prod,4,frag[])->NewLexemText->as[];
	// prodNo.Const then
	   frag[]->newConst->as[];
	// prodNo.SlotDesc then
	   frag[]->newSlot->as[];
       if);

    else
       (if true
	// (prod = 0)
	// (prod > kindArray.range) (* changed by kjm from >= to > *)
	// (kindArray[prod] = 0) then
	     (# m: ^text
	     do
		&text[]->m[];
		'ERROR illegal syncatno for newAST:'->m.putText;
		prod->m.putInt;
		m[]->AstInterfaceError
	     #)
       if);
       (prod,frag[])->newAstForParser->frag.indexToNode->as[];

   if)

-- expandednoOfSons: Descriptor --
(# privateInx: @integer;
do
   0->sons;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       sons+1->sons;
       (if not (privateInx->frag.isLastBrother) then
	   privateInx->frag.getNextBrother->privateInx; restart l
       if)
   if)
#)

-- expandedGetExit: DoPart --
do i->findindex->frag.indexToNode->as[]

-- expandedPutEnter: Descriptor --
(# prevSonInx,NextSonInx: @integer
do
   (if (frag[] <> s.frag[]) then notSameFragment if);
   (if i = 1 then (* set the next brother of the inserted node *)
       (if true
	// (sonInx = 0) // (sonInx->frag.isLastBrother) then
	   true->s.lastBrother; index->s.brotherInx
	else
	   (s.index,sonInx->frag.getNextBrother)->frag.setNextBrother;
	   false->s.lastBrother;

       if);
       (* insert the node *)
       s.index->sonInx;

    else
   (* find where to insert the node *)
       i-1->findindex->prevSonInx;
       (* determine if the inserted node will be the last brother
	* and set nextBrother/father of the inserted node
	*)
       (if (prevSonInx->frag.isLastBrother) then
	   true->s.lastBrother;
	   index->s.brotherInx;
	   (prevSonInx,false)->frag.setLastBrother;

	else
	   (prevSonInx->frag.getNextBrother->nextSonInx->frag.isLastBrother)
	     ->s.lastBrother;
	   nextSonInx->frag.getNextBrother->s.brotherInx;

       if);
       (* insert the node *)
       (prevSonInx,s.index)->frag.setNextBrother;

   if)
#)

-- expandedInsert: Descriptor --
(#
   prevSonInx,NextSonInx: @integer; commentAST: ^comment; theComment: ^Text;
do
   (if (frag[] <> s.frag[]) then notSameFragment if);
   (if i = 1 then
       sonInx->s.BrotherInx;
       (if sonInx = 0 then
	   true->s.lastBrother; index->s.brotherInx
	else
	   false->s.lastBrother
       if);
       s.index->sonInx;

    else
       i-1->findindex->prevSonInx;
       (if (prevSonInx = 0) then
	   'ERROR: illegal index for insert '->AstInterfaceError;
       if);
       prevSonInx->frag.getNextBrother->nextSonInx;
       (prevSonInx,s.index)->frag.setNextBrother;
       nextSonInx->s.brotherInx;
       (if (prevSonInx->frag.isLastBrother) then
	   true->s.lastBrother; (prevSonInx,false)->frag.setlastBrother
	else
	   false->s.lastBrother
       if);

   if);
   (if realcommentInx <> 0 then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       (if trace.active and trace.d[trace.editingComments] then
	   trace.editingComments->signalTrace
	     (# start::
		  (#
		  do 'listInsert, before: '->msg.putText;
		     (theComment[],msg[])->printComment
		  #)
	     #);
       if);
       (i,theComment[])->insertSep1;
       (if trace.active and trace.d[trace.editingComments] then
	   trace.editingComments->signalTrace
	     (# start::
		  (#
		  do 'listInsert, after: '->msg.putText;
		     (theComment[],msg[])->printComment
		  #)
	     #);
       if);
       theComment[]->commentAST.putText;
       commentAST[]->addComment;

   if);

#)

-- expandedDump: Descriptor --
(# t: ^text
do
   dmp.newLine;
   (for level repeat ' '->dmp.put for);
   '('->dmp.put;
   (if (symbol->frag.grammar.symbolToName->t[]) = none then
       INNER dump; (symbol)->dmp.putint;
    else
       t[]->dmp.putText; '='->dmp.put; (symbol)->dmp.putint;
   if);
   ':'->dmp.put;
   (if (sonInx > frag.a.range) then
       '_'->dmp.put
    else
       (NoOfSons)->dmp.putint;
       (if
       ((frag.grammar.sonArray[symbol] <> 0) and
	(frag.grammar.sonArray[symbol] <> NoOfSons)) then
	     (# m: ^text
	     do
		&text[]->m[];
		' Number of sons wrong. Expected number of sons '->m.putText;
		(frag.grammar.sonArray[symbol])->m.putInt;
		'ERROR: consistency check failed.'->m.puttext;
		m[]->stopYggdrasil
	     #)
       if);

   if);
   (for i: frag.grammar.roomArray[symbol] repeat
	'['->dmp.put;
	(frag.a[index+offset.attribute-1+i])->dmp.putInt;
	']'->dmp.put;
   for);
   (if (sonInx <= frag.a.range) then
       scan (#  do (level+1,dmp[])->current.dump #);
   if);
   ')'->dmp.put;

#)

-- expandedMatch: Descriptor --
(# son: ^Ast; matchExp: ^expanded
do
   treeToMatch[]->matchExp[];
   (if noOfSons = matchExp.noOfSons then
       loop:
       (for i: NoOfSons repeat
	 i->get->son[];
	 i->matchExp.get->son.match->doesMatch;
	 (if not doesMatch then leave loop if)
       for)
   if);

#)

-- expandedCopyPrivate: Descriptor --
(# theExpCopy: ^expanded; fragInx,theCopyInx,symbolRoom: @integer
do
   theCopy[]->theExpCopy[];
   scan
     (#  do (currentSonNo,copyFrag[]->current.copy)->theExpCopy.put #);
   index+offset.attribute-1->fragInx;
   theCopy.index+offset.attribute-1->theCopyInx;
   frag.grammar.roomArray[symbol]->symbolRoom;
   (if (theCopyInx+symbolRoom >= copyFrag.a.range) then
       symbolRoom->copyFrag.extendA
   if);
   (for i: symbolRoom repeat frag.a[fragInx+i]->copyFrag.a[theCopyInx+i] for);

#)

-- consDelete: Descriptor --
(# nextSonInx,prevSonInx,deletedNode: @integer; unExp: ^unExpanded
do
   sonnr-1->findindex->prevSonInx;
   prevSonInx->frag.getNextBrother->deletedNode->frag.getNextBrother
     ->nextSonInx;
   (* create the node to insert *)
   (prodNo.unExpanded,frag[])->frag.grammar.newAst->unExp[];
   (* insert the node *)
   (prevSonInx,unExp.index)->frag.setNextBrother;
   nextSonInx->unExp.brotherInx;
   deletedNode->frag.isLastBrother->unExp.lastBrother;
   (* set the fathernode of the deleted node to NONE *)
   (deletedNode,0)->frag.setNextBrother;
   (*true->frag.isLastBrother;*)

#)

-- listDeleteBodyDescriptor: Descriptor --
(#
   prevSonInx,deletedNode,nextSonInx: @integer;
   commentAST: ^comment;
   theComment: ^Text;

do
   (if sonnr = 1 then
       sonInx->deletedNode;
       (if (sonInx->frag.isLastBrother) then
	   0->sonInx
	else
	   deletedNode->frag.getNextBrother->sonInx;
       if);

    else
       sonnr-1->findindex->prevSonInx->frag.getNextBrother->deletedNode
	 ->frag.getNextBrother->nextSonInx;
       (prevSonInx,deletedNode->frag.isLastBrother)->frag.setLastBrother;
       (prevSonInx,nextSonInx)->frag.setNextBrother;

   if);
   (deletedNode,0)->frag.setNextBrother;
   (deletedNode,true)->frag.setLastBrother;
   (if realcommentInx <> 0 then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       (if trace.active and trace.d[trace.editingComments] then
	   trace.editingComments->signalTrace
	     (# start::
		  (#
		  do 'listDelete, before: '->msg.putText;
		     (theComment[],msg[])->printComment
		  #)
	     #);
       if);
       (sonnr,theComment[])->deleteSep1;
       theComment[]->commentAST.putText;
       commentAST[]->addComment;
       (if trace.active and trace.d[trace.editingComments] then
	   trace.editingComments->signalTrace
	     (# start::
		  (#
		  do 'listDelete, after: '->msg.putText;
		     (theComment[],msg[])->printComment
		  #)
	     #);
       if);
   if);

#)

-- listNewScan: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;

do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       currentSonNo+1->currentSonNo;
       privateInx->privateIndexToNode->a[];
       (if a.kind = kinds.interior then
	   a[]->current[]; INNER newScan;
	else
	   a[]->predefined;
       if);
       (if not (privateInx->privateIsLastBrother) then
	   privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)

-- lexemTextGetText: Descriptor --
(# i: @integer; base: @integer;
do
   lexemInx*4->base;
   (for i: ((frag.a,base-2)->tos'%inxGetShort') repeat
     (frag.a,base+i-1)->tos'%inxGetByte'->t.put
   for);

#)

-- lexemTextPutText: Descriptor --
(# i,l: @integer; base: @integer;
do
   t.length->l->checkbase;
   lexemInx*4->base;
   (frag.a,base-2,l)->tos'%inxPutShort';
   1->i;
   t.scanAll
     (#  do (frag.a,base+i-1,ch)->tos'%inxPutByte'; i+1->i #);

#)

-- lexemTextClear: Descriptor --
(# base: @integer
do
   lexemInx*4-2->base;
   (if lexemInx = 0 then 1->checkbase if);
   (frag.a,base,0)->tos'%inxPutShort'
#)

-- lexemTextGetChar: Descriptor --
(# base: @integer;
do
   (if ((index >= 1) and (index <= curLength)) then
       lexemInx*4+index-1->base; (frag.a,base)->tos'%inxGetByte'->ch
    else
       'error in index in getChar'->stopYggdrasil;
   if)
#)

-- lexemTextPutChar: Descriptor --
(# base,length: @integer
do
   (if lexemInx = 0 then 1->checkbase;  else curLength+1->checkbase if);
   lexemInx*4->base;
   curLength+1->length->curLength;
   (frag.a,base+length-1,c)->tos'%inxPutByte'
#)

-- lexemTextCurLengthEnter: Descriptor --
(# base: @integer
do lexemInx*4-2->base; (frag.a,base,l)->tos'%inxPutShort'
#)

-- lexemTextCurLengthExit: DoPart --
do frag.a[lexemInx]->tos'%getShort[1]'->l

-- lexemTextMatch: DoPart --
do
   treeToMatch[]->theMatchLexem[];
   (if ((theMatchLexem.curLength = curLength)->doesMatch) then
       getText->theT[];
       theT.copy->theT[];
       theMatchLexem.getText->theMatchText[];
       theMatchText.copy->theMatchText[];
       loop:
       (for i: curLength repeat
	 ((i->theT.inxGet->ascii.UpCase) =
	  (i->theMatchText.inxGet->ascii.UpCase))->doesmatch;
	 (if not doesMatch then leave loop if)
       for)
   if);
   INNER match

-- newLexemTextEnter: DoPart --
do (prod,length,frag[])->newLexemTextForParser->(inx,base)

-- newLexemTextExit: DoPart --
do inx->frag.indexToNode->as[]

-- commentCommentTypeEnter: DoPart --
do type->commentTypeInx

-- commentCommentTypeExit: DoPart --
do commentTypeInx->type

-- commentCopyPrivate: DoPart --
do commentTypeInx->theCopy.commentTypeInx

-- constNewConstType: DoPart --
do (lexemInx <> 0)->b

-- constPutValue: Descriptor --
(# t: @text
do (if newConstType then val->t.putInt; t[]->putText else val->valueInx if);
#)

-- constGetValue: Descriptor --
(# t: ^text
do
   (if newConstType then (* signals new value-type *)
       getText->t[]; ' '->t.put; 0->t.pos; t.getInt->val
    else
       valueInx->val
   if);

#)

-- newConst: DoPart --
do (prodNo.const,4,frag[])->newLexemText->c[]

-- unExpandedTheSlotEnter: DoPart --
do o.index->commentInx; index->o.BrotherInx; true->o.lastBrother; true->bit7;

-- unExpandedTheSlotExit: DoPart --
do commentInx->frag.indexToNode->sd[]

-- unExpandedDump: DoPart --
do
   (if isSlot then
       (# o: ^SlotDesc do theSlot->o[]; (0,dmp[])->o.dump #)
    else
       INNER dump;
       '#['->dmp.putText;
       (nonterminalsymbol)->dmp.putInt;
       ']'->dmp.put
   if)

-- unExpandedCopyPrivate: Descriptor --
(# theUnExpCopy: ^unExpanded
do
   theCopy[]->theUnExpCopy[];
   (if isSlot then
	 (# op,copyOp: ^SlotDesc
	 do
	    theSlot->op[];
	    copyFrag[]->op.copyPrivate->CopyFrag.indexToNode->copyOp[];
	    copyOp[]->theUnExpCopy.theSlot;

	 #)
   if);
   nonterminalSymbol->theUnExpCopy.nonterminalSymbol;

#)

-- newUnexpanded: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range) then
       offset.sizePerUnExpanded->frag.extendA
   if);
   &UnExpanded[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.unExpanded)->frag.setSymbol;
   syncatNo->s.nonterminalSymbol;
   frag.curtop+offset.sizePerUnExpanded->frag.curtop

-- newOptional: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range) then
       offset.sizePerUnExpanded->frag.extendA
   if);
   &Optional[]->s[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (frag.curtop->s.index,prodNo.optional)->frag.setSymbol;
   frag[]->s.frag[];
   frag.curtop+offset.sizePerUnExpanded->frag.curtop;
   syncatNo->s.nonterminalSymbol

-- slotDescNameEnter: Descriptor --
(# c: ^comment
do (comment,frag[])->frag.grammar.newAst->c[]; t[]->c.putText; c.index->sonInx
#)

-- slotDescNameExit: DoPart --
do sonInx->frag.indexToNode->c[];

-- slotDescCopyPrivate: Descriptor --
(# c: ^comment
do sonInx->frag.indexToNode->c[]; copyFrag[]->c.copyPrivate->theCopy.sonInx
#)

-- slotDescDump: DoPart --
do
   dmp.newLine;
   'SLOT. Name = '->dmp.putText;
   name->dmp.putText;
   'Category = '->dmp.putText;
   (category (*,5*) )->dmp.putInt;
   dmp.newLine;
   (for i: offset.sizePerSlotDesc-offset.slotAttribute repeat
     '['->dmp.put;
     (frag.a[index+i-1+offset.slotAttribute])->dmp.putInt;
     ']'->dmp.put;

   for);
   INNER dump;
   dmp.newLine;


-- slotDescNode: DoPart --
do findFatherInx->father; frag[]->ff[]

-- newSlot: DoPart --
do
   (if (frag.curtop+offset.sizePerSlotDesc >= frag.a.range) then
       offset.sizePerSlotDesc->frag.extendA
   if);
   &SlotDesc[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.SlotDesc)->frag.setSymbol;
   frag.firstSlot->frag.a[frag.curtop+offset.usage];
   frag.curTop->frag.firstSlot;
   frag.curTop+offset.sizePerSlotDesc->frag.curtop
