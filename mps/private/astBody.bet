ORIGIN 'astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/v1.6/private/filebody'
        '~beta/sysutils/v1.6/endian'
        '../metagramsematt';
-- astSonNo: DoPart --
do
   findFatherInx->finx;
   (if finx = 0 then 'ERROR: trying to get sonNo for root'->stopYggdrasil if);
   (1,finx->frag.getSonInx)->(son,inx);
   loop:
   (if (inx <> index) then
       (if (inx->frag.isLastBrother) then
           'ERROR: trying to access a nonexisting son in sonNo'->stopYggdrasil
       if);
       (son+1,inx->frag.getNextBrother)->(son,inx);
       restart loop
   if);
     

-- astSymbolEnterBody: DoPart --
do lab->symbolInx  

-- astSymbolExit: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->lab  

-- astFatherExit: DoPart --
do findFatherInx->frag.indexToNode->as[]  

-- astEqual: DoPart --
do ((comparedAst.Index = index) and (comparedAst.frag[] = frag[]))->eq  

-- astNextbrother: DoPart --
do
   (if lastBrother then
       none ->brother[]
    else
       brotherInx->frag.indexToNode->brother[]
   if)  

-- astKind: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->frag.grammar.kindOfSymbol->kind  

-- astLt: Descriptor --
(# dummy: ^Ast; 
do testAst[]->nearestCommonAncestor->(dummy[],testSonNo,mySonNo)
#)  

-- astPutAttribute: DoPart --
do
   attributNo->checkAttributNo;
   val->frag.a[index+offset.attribute+attributno-1];
     

-- astGetAttribute: DoPart --
do
   attributNo->checkAttributNo; frag.a[index+offset.attribute+attributno-1]->val  

-- astPutNodeAttribute: DoPart --
do
   attributNo->checkAttributNo;
   val[]->frag.packAstToValue->frag.a[index+offset.attribute+attributNo-1]  

-- astGetNodeAttribute: DoPart --
do
   attributNo->checkAttributNo;
   frag.a[index+offset.attribute+attributno-1]->frag.valueToAst->val[]  

-- astPutSlotAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   val->frag.a[commentInx+offset.slotAttribute+attributno-1];
     

-- astGetSlotAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.SlotAttribute+attributno-1]->val  

-- astPutSlotNodeAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   val[]->frag.packAstToValue
     ->frag.a[commentInx+offset.SlotAttribute+attributNo-1]  

-- astGetSlotNodeAttribute: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.Slotattribute+attributno-1]->frag.valueToAst->val[]  

-- astAddComment: DoPart --
do (if l[] = none then 0->realCommentInx else l.index->realCommentInx if)  

-- astGetCommentExit: DoPart --
do realcommentInx->frag.indexToNode->as[]  

-- printComment: DoPart --
do
   '<'->output.put;
   comment.scanAll
     (# 
     do
        (if ch
         // CommentSeparator1 then
            'S'->output.put; 
         // CommentSeparator2 then
            's'->output.put; 
         // CommentSeparator3 then
            'p'->output.put; 
         else
            ch->output.put; 
        if);
        
     #);
   '>'->output.put;
   output.newLine;
     

-- astGetNextComment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; inx: @Integer; ch: @Char; 
do
   (if realcommentInx = 0 then
       trace.getNextComment
         ->tracer
           (#  do 'no comment '->dmp.putText; index->dmp.putInt; newLine #);
       (* no comment *)
       - 2->n;
       none ->subcomment[];
       
    else
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       (if theComment[] <> none then
           trace.getNextComment
             ->tracer
               (# 
               do
                  '<'->dmp.put;
                  theComment.scanAll
                    (# 
                    do
                       (if ch
                        // CommentSeparator1 then
                           'S'->dmp.put; 
                        // CommentSeparator2 then
                           's'->dmp.put; 
                        else
                           ch->dmp.put; 
                       if);
                       
                    #);
                  '>'->dmp.put;
                  dmp.newLine;
                  ' [theComment.lgth:'->dmp.putText;
                  theComment.lgth->dmp.putInt;
                  ']'->dmp.put;
                  dmp.newLine;
                  
               #);
           theComment.reset;
           mainloop:
           (if inx = theComment.lgth then (* end of comment *)
               2->n;
               none ->subcomment[];
               0->inx;
               (* finished2 *)
               SUSPEND;
               restart mainloop;
               (* to avoid termination of component *)
               (* old code:
                * -1->n;
                *  NONE->subcomment[];
                * leave mainloop; *)
               (* end of getNextComment *)
               
            else
           (* read next comment *)
               &Text[]->subcomment[];
               loop:
               (if ((inx+1->inx)->theComment.inxget->ch)
                // CommentSeparator1 then
                   trace.getNextComment
                     ->tracer (#  do '(S1)'->dmp.putLine;  #);
                   (if subcomment.lgth = 0 then (* no comments *)
                       - 1->n; 
                    else
                   (* one comment, or the last comment in a sub sequence *)
                       1->n; 
                   if);
                   
                // CommentSeparator2 then
                   trace.getNextComment
                     ->tracer (#  do '(s1)'->dmp.putLine;  #);
                   (if inx = theComment.lgth then
                       0->inx; 2->n; (*finished*) 
                    else
                       (if (inx+1->theComment.inxget) = CommentSeparator1 then
                           inx+1->inx; 0->n; 
                        else
                           1->n
                       if);
                       
                   if)
                else
                   (if inx+1 > theComment.lgth then
                       'GetNextComment: last subcomment not terminated properly, is ignored'
                         ->screen.putLine;
                       '<'->screen.put;
                       theComment.scanAll
                         (# 
                         do
                            (if ch
                             // CommentSeparator1 then
                                'S'->screen.put; 
                             // CommentSeparator2 then
                                's'->screen.put; 
                             else
                                ch->screen.put; 
                            if);
                            
                         #);
                       '>'->screen.put;
                       screen.newLine;
                       ' [theComment.lgth:'->screen.putText;
                       theComment.lgth->screen.putInt;
                       ']'->screen.put;
                       screen.newLine;
                       none ->subcomment[];
                       0->inx;
                       2->n (* finished *)
                    else
                       ch->subcomment.put; restart loop; 
                   if)
               if);
               trace.getNextComment
                 ->tracer
                   (# 
                   do
                      '*** suspend '->dmp.putText;
                      index->dmp.putInt;
                      ' <'->dmp.putText;
                      subComment[]->dmp.putText;
                      '> '->dmp.putText;
                      n->dmp.putInt;
                      ' inx: '->dmp.putText;
                      inx->dmp.putInt;
                      dmp.newLine
                   #);
               SUSPEND;
               trace.getNextComment
                 ->tracer
                   (# 
                   do
                      '*** restart '->dmp.putText;
                      index->dmp.putInt;
                      dmp.newLine
                   #);
               restart mainloop;
               
           if);
           
        else
           trace.getNextComment
             ->tracer
               (# 
               do
                  'no comment, should not happen '->dmp.putText;
                  index->dmp.putInt;
                  newLine
               #);
           - 2->n;
           none ->subcomment[];
           
       if);
       
   if);
   
#)  

-- astInsertSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; 
do
   (if (inx <= 0) then
       'InsertSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if subcomments[] = none then
           'InsertSubcomments: subcomments[] is none '->putLine; 
        else
           (if realcommentInx = 0 then (* no comment *)
               'InsertSubcomments: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'InsertSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.puttext;
                          inx->dmp.putint;
                          dmp.newLine;
                          'insertsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          'insertsubcomments.subComments:'->Dmp.putLine;
                          (subcomments[],dmp[])->printComment;
                          dmp.newLine;
                          'subComments.lgth:'->Dmp.putText;
                          subComments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (Subcomments[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'insertSubcomments.result:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astSetSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; 
do
   (if (inx <= 0) then
       'SetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if subcomments[] = none then
           'SetSubcomments: subcomments[] is none '->putLine; 
        else
           (if realcommentInx = 0 then (* no comment *)
               'SetSubcomments: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'SetSubcomments: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'setsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth: '->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          'setsubcomments.subComments:'->Dmp.putLine;
                          (subcomments[],dmp[])->printComment;
                          dmp.newLine;
                          'subComments.lgth:'->Dmp.putText;
                          subComments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (if (start <> end) then
                              (start,end)->theComment.delete; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 'setSubcomments.afterDelete:'->Dmp.putLine;
                                 (theComment[],dmp[])->printComment;
                                 'theComment.lgth:'->Dmp.putText;
                                 theComment.lgth->Dmp.putInt;
                                 Dmp.newLine;
                                 
                              #);
                          (Subcomments[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'setSubcomments.result: '->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if)
       if)
   if)
#)  

-- astGetSubcomments: Descriptor --
(# commentAST: ^comment; theComment: ^Text; 
do
   (if (inx <= 0) then
       'GetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if realcommentInx = 0 then (* no comment *)
           ''->subcomments[]; 
        else
           realcommentInx->frag.indexToNode->commentAST[];
           commentAST.getText->theComment[];
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'GetSubcomments: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine;
                   ''->subcomments[]
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'getsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   ''->Subcomments[];
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (if start <> end then
                              (start,end)->theComment.sub->Subcomments[]; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'getsubcomments.subComments:'->Dmp.putLine;
                          (subComments[],dmp[])->printComment;
                          'subcomments.lgth:'->Dmp.putText;
                          subcomments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astScanComments: Descriptor --
(# n,n2: @integer
do
   trace.getNextComment
     ->tracer (#  do 'scanComments ---------'->dmp.putLine #);
   loop:
   (if 1 = 1 then
       getNextComment->(current[],n);
       (* 'current: '->putText;
        '<'->put;
        current[]->putText;
        '> '->putText;
        n->putInt;
        newLine;*)
       (if n
        // - 2 then (* empty comment *)
           
        // - 1 then (* empty subcomment *)
           inx+1->inx; 1->subinx; INNER scanComments; restart loop
        // 0 then (* one subcomment' *)
           inx+1->inx; 1->subinx; INNER scanComments; restart loop
        // 1 then (* subsequence *)
           inx+1->inx;
           1->subinx;
           INNER scanComments;
           loop2:
           (if 1 = 1 then
               getNextComment->(current[],n2);
               subinx+1->subinx;
               INNER scanComments;
               (if n2 = 1 then restart loop2 if);
               
           if);
           (if n2 <> 2 then restart loop if)
        // 2 then (* finished *)
           inx+1->inx; 1->subinx; INNER scanComments
       if)
   if)
#)  

-- astInsertSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'InsertSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if subcomment[] = none then
           'InsertSubcomment: subcomment[] is none '->putLine; 
        else
           (if realcommentInx = 0 then (* no comment *)
               'InsertSubcomment: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'InsertSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'InsertSubcomment.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          'InsertSubcomment.Subcomment:'->Dmp.putLine;
                          (Subcomment[],dmp[])->printComment;
                          'Subcomment.lgth:'->dmp.putText;
                          Subcomment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 ' '->dmp.put;
                                 
                              #);
                          Subcomment->help;
                          help.length->help.pos;
                          CommentSeparator2->help.put;
                          (help[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'InsertSubcomment.result:'->dmp.putText;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if);
       
   if)
#)  

-- astSetSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'SetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if subcomment[] = none then
           'SetSubcomment: subcomment[] is none '->putLine; 
        else
           (if realcommentInx = 0 then (* no comment *)
               'SetSubcomment: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'SetSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'setSubcomment.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          'setSubcomment.Subcomment:'->Dmp.putLine;
                          (Subcomment[],dmp[])->printComment;
                          'Subcomment.lgth:'->dmp.putText;
                          Subcomment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 ' '->dmp.put;
                                 
                              #);
                          (if (start <= end) then
                              (start,end+1)->theComment.delete;
                              trace.editingComments
                                ->tracer
                                  (# 
                                  do
                                     'setSubcomment.afterDelete:'->dmp.putText;
                                     (theComment[],dmp[])->printComment;
                                     'theComment.lgth:'->dmp.putText;
                                     theComment.lgth->dmp.putInt;
                                     dmp.newLine;
                                     
                                  #);
                              (* the separator2 is also deleted *)
                              
                          if);
                          Subcomment->help;
                          help.length->help.pos;
                          CommentSeparator2->help.put;
                          (* the user of getSubcomment and setSubcomment 
                           * does not have to worry about separators
                           *)
                          (help[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'setSubcomment.result:'->dmp.putText;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if);
       
   if)
#)  

-- astGetSubcomment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'GetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if realcommentInx = 0 then (* no comment *)
           ''->subcomment[]; 
        else
           realcommentInx->frag.indexToNode->commentAST[];
           commentAST.getText->theComment[];
           (if theComment[] <> none then
               (if theComment.lgth = 0 then
                   'GetSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine;
                   ''->subcomment[]
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'getSubComment.theComment: '->dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   ''->subComment[];
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          (if start <= end then
                              (start,end)->theComment.sub->subComment[]; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 dmp.newLine;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'getSubcomment.subComment: '->dmp.putLine;
                          (subComment[],dmp[])->printComment;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astHascomment: DoPart --
do realcommentInx <> 0->has  

-- astGetCommentProp: Descriptor --
(# c: ^comment; base: @integer; 
do
   (if hasCommentProp then
       getComment->c[];
       c.curLength div 4->repS.extend;
       c.lexemInx->base;
       0->repS.top;
       (for i: c.curLength div 4 repeat c.frag.a[base+i]->repS.putInt for);
       0->repS.top;
       &propertyList[]->prop[];
       repS[]->prop.repRestore;
       
   if);
   
#)  

-- astSetCommentProp: Descriptor --
(# c: ^comment; base: @integer; 
do
   0->repS.top;
   repS[]->prop.repSave;
   (prodNo.comment,frag[])->frag.grammar.newAst->c[];
   repS.top*4->c.checkBase;
   c.lexemInx->base;
   (for i: repS.top repeat repS.r[i]->c.frag.a[base+i] for);
   repS.top*4->c.curLength;
   c[]->addComment;
   17->typeOfComment;
   
#)  

-- astTypeOfCommentEnter: DoPart --
do
   (if hasComment then
       type->frag.a[realcommentInx+offset.commentType]
    else
       'node has no comment'->stopYggdrasil
   if)  

-- astTypeOfCommentExit: DoPart --
do
   (if hasComment then
       frag.a[realcommentInx+offset.commentType]->type
    else
       - 1->type
   if);
     

-- astNCA: Descriptor --
(# myScanner: @|scanDown; 
do
   (if not (testAst[]->equal) then
         (# testScanner: ^|testAst.scanDown; myAs,testAs: ^Ast
         do
            &| testAst.scanDown[]->testScanner[];
            loop:
              (# 
              do
                 myScanner->myAs[];
                 testScanner->testAs[];
                 (if (myAs[]->testAs.equal) then
                     myAs[]->nca[];
                     (if true
                      // (nca[]->equal) then
                         testScanner->testAs[]; testAs.sonNo->testSonNo
                      // (nca[]->testAst.equal) then
                         myScanner->myAs[]; myAs.sonNo->mySonNo
                      else
                         restart loop
                     if)
                  else
                     testAs.sonNo->testSonNo; myAs.sonNo->mySonNo
                 if)
              #)
         #)
    else
       testAst[]->nca[]
   if)
#)  

-- astScan: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;
   
do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       privateInx->privateIndexToNode->current[];
       currentSonNo+1->currentSonNo;
       INNER scan;
       (if not (privateInx->privateIsLastBrother) then
           privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)  

-- astSuffixWalk: Descriptor --
(#
   nextinx,firstson: @integer;
   theCutter: @cutIf;
   s: @stak;
   setNextInx:
     (# 
     enter nextInx
     do
        (if not (nextInx->frag.isLastBrother) then
            nextInx->frag.getNextBrother->s.push
        if)
     #);
   
do
   s.init;
   index->nextInx;
   stakscan:
     (# 
     do
        (if not (nextInx->frag.getSymbol->theCutter) then
            nextinx->frag.indexToNode->current[];
            INNER suffixWalk;
            (if (nextInx->frag.getSymbol->frag.grammar.kindOfSymbol) =
            kinds.interior then
                (if ((nextInx->frag.getSonInx->firstSon) > 0) then
                    firstSon->setNextInx; restart stakScan
                if)
            if)
        if);
        (if not s.empty then s.pop->setNextInx; restart stakScan if);
        
     #);
   
#)  

-- astSuffixWalkForProd: Descriptor --
(#
   theCutter: @cutIf;
   s: @stak;
   nextInx,firstson: @integer;
   theSymbol: @integer;
   setNextInx:
     (# 
     enter nextInx
     do
        (if not (nextInx->frag.isLastBrother) then
            nextInx->frag.getNextBrother->s.push
        if)
     #);
   
do
   s.init;
   index->nextInx;
   stakscan:
     (# 
     do
        (if not (nextInx->frag.getSymbol->theSymbol->theCutter) then
            (if theSymbol = prod then
                nextinx->frag.indexToNode->current[]; INNER suffixWalkForProd
            if);
            (if (theSymbol->frag.grammar.kindOfSymbol) = kinds.interior then
                (if ((nextInx->frag.getSonInx->firstSon) > 0) then
                    firstSon->setNextInx; restart stakScan
                if)
            if)
        if);
        (if not s.empty then s.pop->setNextInx; restart stakScan if);
        
     #)
#)  

-- astCopyCopyCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- astCopyExit: Descriptor --
(# 
do
   (if theCatcher[] = none then
       theCatcher[]->copyCatcher.oldCatcher[]; copyCatcher[]->theCatcher[]
   if);
   copyFrag[]->copyPrivate->copyfrag.indexToNode->as[];
   (if theCatcher[] = copyCatcher[] then
       copyCatcher.oldCatcher[]->theCatcher[]
   if);
   
#)  

-- astDump: DoPart --
do
   (if dmp[] = none then screen[]->dmp[] if);
   '@'->dmp.put;
   (index)->dmp.putInt;
   (if hasComment then
       ' COMMENT '->dmp.putText;
       (if (commentInx >= frag.a.range) then
           '_'->dmp.put
        else
             (# l: ^lexemText; t: ^text; 
             do
                '"'->dmp.put;
                getComment->l[];
                l.gettext->t[];
                (t[],dmp[])->printComment;
                (* lexemtext.dump should also check the size of the text *)
                (* (1,(30,t.length) -> min ) -> t.sub -> dmp.puttext;
                 (if t.length>30 then
                 '...' -> dmp.puttext;
                 (((30,t.length) -> max) - 30,t.length) -> t.sub -> dmp.puttext;
                 if);
                 *)
                '"'->dmp.put
             #);
           
       if)
   if);
   INNER dump;
     

-- astMatch: DoPart --
do
   (if not ((treeToMatch.symbol = unExpanded)->doesMatch) then
       (if ((treeToMatch.symbol = symbol)->doesMatch) then INNER match if)
   if)  

-- astSemanticErrorEnter: DoPart --
do
   (if (errorNumber > 0) then
       true->hasSemanticError;
       'Semanticerrors'
         ->frag.prop.addProp
           (# ifPropExist::  (#  do false->delete #); 
           do index->addConst; errorNumber->addConst
           #);
       
    else
       false->hasSemanticError
   if)  

-- astSemanticExit: DoPart --
do
   (if hasSemanticError then
       'Semanticerrors'
         ->frag.prop.getProp
           (#
              doProp:: 
                (# readIndex,indexFound: @boolean
                do
                   true->readIndex;
                   false->indexFound;
                   scanParameters
                     (#
                        doConst:: 
                          (# 
                          do
                             (if readIndex then
                                 (c = index)->indexFound; 
                              else
                                 (if indexFound then c->errorNumber if)
                             if);
                             not readIndex->readIndex;
                             
                          #);
                        
                     #);
                   
                #);
              
           #)
   if)  

-- astCopyPrivate: DoPart --
do
   (symbol,copyFrag[])->frag.grammar.newAstWithoutSons->theCopy[];
   (if (symbol <> comment) then
       (if hasComment then
             (# theComment: ^comment; 
             do
                getComment->theComment[];
                copyFrag[]->theComment.copy->theCopy.addComment;
                
             #);
           
       if)
   if);
   INNER copyPrivate;
   theCopy.index->theCopyInx;
     

-- newast: Descriptor --
(# unExp: ^unExpanded; lastInx: @integer; NoOfsons: @integer; 
do
   (prod,frag[])->newAstWithOutSons->as[];
   (if (prod > 0) then
       (for i: (sonArray[prod]->noOfSons) repeat
         (0,frag[])->newUnExpanded->unExp[];
         (if i = 1 then
             (as.index,unExp.index->lastInx)->frag.setSonInx
          else
             (lastInx,unExp.index)->frag.setNextBrother; unExp.index->lastInx; 
         if)
       for);
       (if (noOfSons > 0) then
           (lastInx,true)->frag.setlastBrother;
           (lastInx,as.index)->frag.setNextBrother;
           
       if)
   if)
#)  

-- newAstWithoutSons: DoPart --
do
   (if (prod < 0) then
       (if prod
        // prodNo.unExpanded then
           (0,frag[])->newUnExpanded->as[]; 
        // prodNo.optional then
           (0,frag[])->newOptional->as[]; 
        // prodNo.NameDecl // prodNo.NameAppl // prodNo.String
        // prodNo.Comment then
           (prod,4,frag[])->NewLexemText->as[]; 
        // prodNo.Const then
           frag[]->newConst->as[]; 
        // prodNo.SlotDesc then
           frag[]->newSlot->as[]; 
       if);
       
    else
       (if true
        // (prod = 0)
        // (prod > kindArray.range) (* changed by kjm from >= to > *)
        // (kindArray[prod] = 0) then
             (# m: ^text
             do
                &text[]->m[];
                'ERROR illegal syncatno for newAST:'->m.putText;
                prod->m.putInt;
                m[]->AstInterfaceError
             #)
       if);
       (prod,frag[])->newAstForParser->frag.indexToNode->as[];
       
   if)  

-- expandednoOfSons: Descriptor --
(# privateInx: @integer; 
do
   0->sons;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       sons+1->sons;
       (if not (privateInx->frag.isLastBrother) then
           privateInx->frag.getNextBrother->privateInx; restart l
       if)
   if)
#)  

-- expandedGetExit: DoPart --
do i->findindex->frag.indexToNode->as[]  

-- expandedPutEnter: Descriptor --
(# prevSonInx,NextSonInx: @integer
do
   (if (frag[] <> s.frag[]) then notSameFragment if);
   (if i = 1 then (* set the next brother of the inserted node *)
       (if true
        // (sonInx = 0) // (sonInx->frag.isLastBrother) then
           true->s.lastBrother; index->s.brotherInx
        else
           (s.index,sonInx->frag.getNextBrother)->frag.setNextBrother;
           false->s.lastBrother;
           
       if);
       (* insert the node *)
       s.index->sonInx;
       
    else
   (* find where to insert the node *)
       i-1->findindex->prevSonInx;
       (* determine if the inserted node will be the last brother
        * and set nextBrother/father of the inserted node
        *)
       (if (prevSonInx->frag.isLastBrother) then
           true->s.lastBrother;
           index->s.brotherInx;
           (prevSonInx,false)->frag.setLastBrother;
           
        else
           (prevSonInx->frag.getNextBrother->nextSonInx->frag.isLastBrother)
             ->s.lastBrother;
           nextSonInx->frag.getNextBrother->s.brotherInx;
           
       if);
       (* insert the node *)
       (prevSonInx,s.index)->frag.setNextBrother;
       
   if)
#)  

-- expandedInsert: Descriptor --
(#
   prevSonInx,NextSonInx: @integer; commentAST: ^comment; theComment: ^Text; 
do
   (if (frag[] <> s.frag[]) then notSameFragment if);
   (if i = 1 then
       sonInx->s.BrotherInx;
       (if sonInx = 0 then
           true->s.lastBrother; index->s.brotherInx
        else
           false->s.lastBrother
       if);
       s.index->sonInx;
       
    else
       i-1->findindex->prevSonInx;
       (if (prevSonInx = 0) then
           'ERROR: illegal index for insert '->AstInterfaceError; 
       if);
       prevSonInx->frag.getNextBrother->nextSonInx;
       (prevSonInx,s.index)->frag.setNextBrother;
       nextSonInx->s.brotherInx;
       (if (prevSonInx->frag.isLastBrother) then
           true->s.lastBrother; (prevSonInx,false)->frag.setlastBrother
        else
           false->s.lastBrother
       if);
       
   if);
   (if realcommentInx <> 0 then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       trace.editingComments
         ->tracer
           (# 
           do
              'listInsert, before: '->dmp.putText;
              (theComment[],dmp[])->printComment;
              
           #);
       (i,theComment[])->insertSep1;
       trace.editingComments
         ->tracer
           (# 
           do
              'listInsert, after: '->dmp.putText;
              (theComment[],dmp[])->printComment;
              
           #);
       theComment[]->commentAST.putText;
       commentAST[]->addComment;
       
   if);
   
#)  

-- expandedDump: Descriptor --
(# t: ^text
do
   dmp.newLine;
   (for level repeat ' '->dmp.put for);
   '('->dmp.put;
   (if (symbol->frag.grammar.symbolToName->t[]) = none then
       INNER dump; (symbol)->dmp.putint;
    else
       t[]->dmp.putText; '='->dmp.put; (symbol)->dmp.putint; 
   if);
   ':'->dmp.put;
   (if (sonInx > frag.a.range) then
       '_'->dmp.put
    else
       (NoOfSons)->dmp.putint;
       (if
       ((frag.grammar.sonArray[symbol] <> 0) and
        (frag.grammar.sonArray[symbol] <> NoOfSons)) then
             (# m: ^text
             do
                &text[]->m[];
                ' Number of sons wrong. Expected number of sons '->m.putText;
                (frag.grammar.sonArray[symbol])->m.putInt;
                'ERROR: consistency check failed.'->m.puttext;
                m[]->stopYggdrasil
             #)
       if);
       
   if);
   (for i: frag.grammar.roomArray[symbol] repeat
        '['->dmp.put;
        (frag.a[index+offset.attribute-1+i])->dmp.putInt;
        ']'->dmp.put; 
   for);
   (if (sonInx <= frag.a.range) then
       scan (#  do (level+1,dmp[])->current.dump #); 
   if);
   ')'->dmp.put;
   
#)  

-- expandedMatch: Descriptor --
(# son: ^Ast; matchExp: ^expanded
do
   treeToMatch[]->matchExp[];
   (if noOfSons = matchExp.noOfSons then
       loop:
       (for i: NoOfSons repeat
         i->get->son[];
         i->matchExp.get->son.match->doesMatch;
         (if not doesMatch then leave loop if)
       for)
   if);
   
#)  

-- expandedCopyPrivate: Descriptor --
(# theExpCopy: ^expanded; fragInx,theCopyInx,symbolRoom: @integer
do
   theCopy[]->theExpCopy[];
   scan
     (#  do (currentSonNo,copyFrag[]->current.copy)->theExpCopy.put #);
   index+offset.attribute-1->fragInx;
   theCopy.index+offset.attribute-1->theCopyInx;
   frag.grammar.roomArray[symbol]->symbolRoom;
   (if (theCopyInx+symbolRoom >= copyFrag.a.range) then
       symbolRoom->copyFrag.extendA
   if);
   (for i: symbolRoom repeat frag.a[fragInx+i]->copyFrag.a[theCopyInx+i] for);
   
#)  

-- consDelete: Descriptor --
(# nextSonInx,prevSonInx,deletedNode: @integer; unExp: ^unExpanded
do
   sonnr-1->findindex->prevSonInx;
   prevSonInx->frag.getNextBrother->deletedNode->frag.getNextBrother
     ->nextSonInx;
   (* create the node to insert *)
   (prodNo.unExpanded,frag[])->frag.grammar.newAst->unExp[];
   (* insert the node *)
   (prevSonInx,unExp.index)->frag.setNextBrother;
   nextSonInx->unExp.brotherInx;
   deletedNode->frag.isLastBrother->unExp.lastBrother;
   (* set the fathernode of the deleted node to NONE *)
   (deletedNode,0)->frag.setNextBrother;
   (*true->frag.isLastBrother;*)
   
#)  

-- listDeleteBodyDescriptor: Descriptor --
(#
   prevSonInx,deletedNode,nextSonInx: @integer;
   commentAST: ^comment;
   theComment: ^Text;
   
do
   (if sonnr = 1 then
       sonInx->deletedNode;
       (if (sonInx->frag.isLastBrother) then
           0->sonInx
        else
           deletedNode->frag.getNextBrother->sonInx; 
       if);
       
    else
       sonnr-1->findindex->prevSonInx->frag.getNextBrother->deletedNode
         ->frag.getNextBrother->nextSonInx;
       (prevSonInx,deletedNode->frag.isLastBrother)->frag.setLastBrother;
       (prevSonInx,nextSonInx)->frag.setNextBrother;
       
   if);
   (deletedNode,0)->frag.setNextBrother;
   (deletedNode,true)->frag.setLastBrother;
   (if realcommentInx <> 0 then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       trace.editingComments
         ->tracer
           (# 
           do
              'listDelete, before: '->dmp.putText;
              (theComment[],dmp[])->printComment
           #);
       (sonnr,theComment[])->deleteSep1;
       theComment[]->commentAST.putText;
       commentAST[]->addComment;
       trace.editingComments
         ->tracer
           (# 
           do
              'listDelete, after: '->dmp.putText;
              (theComment[],dmp[])->printComment
           #);
       
   if);
   
#)  

-- listNewScan: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;
   
do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx <> 0) then
       currentSonNo+1->currentSonNo;
       privateInx->privateIndexToNode->a[];
       (if a.kind = kinds.interior then
           a[]->current[]; INNER newScan; 
        else
           a[]->predefined; 
       if);
       (if not (privateInx->privateIsLastBrother) then
           privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)  

-- lexemTextGetText: Descriptor --
(# i: @integer; base: @integer; 
do
   lexemInx*4->base;
   (for i: ((frag.a,base-2)->tos'%inxGetShort') repeat
     (frag.a,base+i-1)->tos'%inxGetByte'->t.put
   for);
   
#)  

-- lexemTextPutText: Descriptor --
(# i,l: @integer; base: @integer; 
do
   t.length->l->checkbase;
   lexemInx*4->base;
   (frag.a,base-2,l)->tos'%inxPutShort';
   1->i;
   t.scanAll
     (#  do (frag.a,base+i-1,ch)->tos'%inxPutByte'; i+1->i #);
   
#)  

-- lexemTextClear: Descriptor --
(# base: @integer
do
   lexemInx*4-2->base;
   (if lexemInx = 0 then 1->checkbase if);
   (frag.a,base,0)->tos'%inxPutShort'
#)  

-- lexemTextGetChar: Descriptor --
(# base: @integer; 
do
   (if ((index >= 1) and (index <= curLength)) then
       lexemInx*4+index-1->base; (frag.a,base)->tos'%inxGetByte'->ch
    else
       'error in index in getChar'->stopYggdrasil; 
   if)
#)  

-- lexemTextPutChar: Descriptor --
(# base,length: @integer
do
   (if lexemInx = 0 then 1->checkbase;  else curLength+1->checkbase if);
   lexemInx*4->base;
   curLength+1->length->curLength;
   (frag.a,base+length-1,c)->tos'%inxPutByte'
#)  

-- lexemTextCurLengthEnter: Descriptor --
(# base: @integer
do lexemInx*4-2->base; (frag.a,base,l)->tos'%inxPutShort'
#)  

-- lexemTextCurLengthExit: DoPart --
do frag.a[lexemInx]->tos'%getShort[1]'->l  

-- lexemTextMatch: DoPart --
do
   treeToMatch[]->theMatchLexem[];
   (if ((theMatchLexem.curLength = curLength)->doesMatch) then
       getText->theT[];
       theT.copy->theT[];
       theMatchLexem.getText->theMatchText[];
       theMatchText.copy->theMatchText[];
       loop:
       (for i: curLength repeat
         ((i->theT.inxGet->ascii.UpCase) =
          (i->theMatchText.inxGet->ascii.UpCase))->doesmatch;
         (if not doesMatch then leave loop if)
       for)
   if);
   INNER match  

-- newLexemTextEnter: DoPart --
do (prod,length,frag[])->newLexemTextForParser->(inx,base)  

-- newLexemTextExit: DoPart --
do inx->frag.indexToNode->as[]  

-- nameDeclAddUsage: Descriptor --
(# lastVal: @integer; lastAst: ^Ast
do
   usageInx->lastVal;
   (if (lastVal > 0) then
       lastVal->frag.valueToAst->lastAst[];
       lastAst[]->user.frag.packAstToValue->lastVal
   if);
   lastVal->user.usageInx;
   user[]->frag.packAstToValue->usageInx
#)  

-- nameDeclRemoveUsage: Descriptor --
(#
   userVal,userInxVal: @integer;
   thisNameAppl: ^nameAppl;
   user: @integer;
   thisFragmentForm: ^fragmentForm;
   lastAst: ^Ast;
   
do
   THIS(nameDecl)[]->lastAst[];
   usageInx->user;
   frag[]->thisFragmentForm[];
   loop:
   (if (user > 0) then
       user->thisFragmentForm.valueToAst->thisNameAppl[];
       thisNameAppl.frag[]->thisFragmentForm[];
       (if (thisNameAppl[]->userAppl.equal) then
           userAppl.usageInx->lastAst.usageInx; leave loop
       if);
       thisNameAppl[]->lastAst[];
       thisNameAppl.usageInx->user;
       restart loop
   if);
   - userAppl.index->userAppl.usageInx;
   
#)  

-- nameDeclScanUsage: DoPart --
do
   usageInx->user;
   frag[]->currentFragmentForm[];
   loop:
   (if (user > 0) then
       user->currentFragmentForm.valueToAst->current[];
       current.frag[]->currentFragmentForm[];
       INNER scanUsage;
       current.usageInx->user;
       restart loop
   if)  

-- nameApplGetDecl: Descriptor --
(# currentAst: ^Ast
do
   THIS(nameAppl)[]->currentAst[];
   currentAst.usageInx->user;
   loop:
   (if (user > 0) then
       user->currentAst.frag.valueToAst->currentAst[];
       currentAst.usageInx->user;
       restart loop
   if);
   - user->currentAst.frag.indexToNode->declAst[]
#)  

-- nameApplDeclSet: DoPart --
do (usageInx <> - index)->b  

-- nameApplNextUsage: DoPart --
do
   (if (usageInx > 0) then
       usageInx->frag.valueToAst->nextNameAppl[]; 
    else
       none ->nextNameAppl[]
   if)  

-- commentCommentTypeEnter: DoPart --
do type->commentTypeInx  

-- commentCommentTypeExit: DoPart --
do commentTypeInx->type  

-- commentCopyPrivate: DoPart --
do commentTypeInx->theCopy.commentTypeInx  

-- constNewConstType: DoPart --
do (lexemInx <> 0)->b  

-- constPutValue: Descriptor --
(# t: @text
do (if newConstType then val->t.putInt; t[]->putText else val->valueInx if); 
#)  

-- constGetValue: Descriptor --
(# t: ^text
do
   (if newConstType then (* signals new value-type *)
       getText->t[]; ' '->t.put; 0->t.pos; t.getInt->val
    else
       valueInx->val
   if);
   
#)  

-- newConst: DoPart --
do (prodNo.const,4,frag[])->newLexemText->c[]  

-- unExpandedTheSlotEnter: DoPart --
do o.index->commentInx; index->o.BrotherInx; true->o.lastBrother; true->bit7;   

-- unExpandedTheSlotExit: DoPart --
do commentInx->frag.indexToNode->sd[]  

-- unExpandedDump: DoPart --
do
   (if isSlot then
       (# o: ^SlotDesc do theSlot->o[]; (0,dmp[])->o.dump #)
    else
       INNER dump;
       '#['->dmp.putText;
       (nonterminalsymbol)->dmp.putInt;
       ']'->dmp.put
   if)  

-- unExpandedCopyPrivate: Descriptor --
(# theUnExpCopy: ^unExpanded
do
   theCopy[]->theUnExpCopy[];
   (if isSlot then
         (# op,copyOp: ^SlotDesc
         do
            theSlot->op[];
            copyFrag[]->op.copyPrivate->CopyFrag.indexToNode->copyOp[];
            copyOp[]->theUnExpCopy.theSlot;
            
         #)
   if);
   nonterminalSymbol->theUnExpCopy.nonterminalSymbol;
   
#)  

-- newUnexpanded: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range) then
       offset.sizePerUnExpanded->frag.extendA
   if);
   &UnExpanded[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.unExpanded)->frag.setSymbol;
   syncatNo->s.nonterminalSymbol;
   frag.curtop+offset.sizePerUnExpanded->frag.curtop  

-- newOptional: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range) then
       offset.sizePerUnExpanded->frag.extendA
   if);
   &Optional[]->s[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (frag.curtop->s.index,prodNo.optional)->frag.setSymbol;
   frag[]->s.frag[];
   frag.curtop+offset.sizePerUnExpanded->frag.curtop;
   syncatNo->s.nonterminalSymbol  

-- slotDescNameEnter: Descriptor --
(# c: ^comment
do (comment,frag[])->frag.grammar.newAst->c[]; t[]->c.putText; c.index->sonInx
#)  

-- slotDescNameExit: DoPart --
do sonInx->frag.indexToNode->c[];   

-- slotDescCopyPrivate: Descriptor --
(# c: ^comment
do sonInx->frag.indexToNode->c[]; copyFrag[]->c.copyPrivate->theCopy.sonInx
#)  

-- slotDescDump: DoPart --
do
   dmp.newLine;
   'SLOT. Name = '->dmp.putText;
   name->dmp.putText;
   'Category = '->dmp.putText;
   (category (*,5*) )->dmp.putInt;
   dmp.newLine;
   (for i: offset.sizePerSlotDesc-offset.slotAttribute repeat
     '['->dmp.put;
     (frag.a[index+i-1+offset.slotAttribute])->dmp.putInt;
     ']'->dmp.put;
     
   for);
   INNER dump;
   dmp.newLine;
     

-- slotDescNode: DoPart --
do findFatherInx->father; frag[]->ff[]  

-- newSlot: DoPart --
do
   (if (frag.curtop+offset.sizePerSlotDesc >= frag.a.range) then
       offset.sizePerSlotDesc->frag.extendA
   if);
   &SlotDesc[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.SlotDesc)->frag.setSymbol;
   frag.firstSlot->frag.a[frag.curtop+offset.usage];
   frag.curTop->frag.firstSlot;
   frag.curTop+offset.sizePerSlotDesc->frag.curtop  
