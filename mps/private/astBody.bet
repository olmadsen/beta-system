ORIGIN 'astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/v1.4/private/filebody'
        '~beta/sysutils/v1.4/endian';
-- astSonNoBody: DoPart --
do
   findFatherInx->finx;
   (if finx
    // 0 then 'ERROR: trying to get sonNo for root'->stopYggdrasil
   if);
   (1,finx->frag.getSonInx)->(son,inx);
   loop:
   (if (inx = index)
    // false then
       (if (inx->frag.isLastBrother)
        // true then
           'ERROR: trying to access a nonexisting son in sonNo'->stopYggdrasil
       if);
       (son+1,inx->frag.getNextBrother)->(son,inx);
       restart loop
   if);
     

-- astSymbolEnterBodyBody: DoPart --
do lab->symbolInx  

-- astSymbolExitBody: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->lab  

-- astFatherExitBody: DoPart --
do findFatherInx->frag.indexToNode->as[]  

-- astEqualBody: DoPart --
do ((comparedAst.Index = index) and (comparedAst.frag[] = frag[]))->eq  

-- astNextbrotherBody: DoPart --
do
   (if lastBrother
    // false then brotherInx->frag.indexToNode->brother[]
    else
       none ->brother[]
   if)  

-- astKindBody: DoPart --
do frag.a[index]->tos'%getSignedBits[4,12]'->frag.grammar.kindOfSymbol->kind  

-- astLtBody: Descriptor --
(# dummy: ^Ast; 
do testAst[]->nearestCommonAncestor->(dummy[],testSonNo,mySonNo)
#)  

-- astPutAttributeBody: DoPart --
do
   attributNo->checkAttributNo;
   val->frag.a[index+offset.attribute+attributno-1];
     

-- astGetAttributeBody: DoPart --
do
   attributNo->checkAttributNo; frag.a[index+offset.attribute+attributno-1]->val  

-- astPutNodeAttributeBody: DoPart --
do
   attributNo->checkAttributNo;
   val[]->frag.packAstToValue->frag.a[index+offset.attribute+attributNo-1]  

-- astGetNodeAttributeBody: DoPart --
do
   attributNo->checkAttributNo;
   frag.a[index+offset.attribute+attributno-1]->frag.valueToAst->val[]  

-- astPutSlotAttributeBody: DoPart --
do
   attributNo->checkSlotAttribute;
   val->frag.a[commentInx+offset.slotAttribute+attributno-1];
     

-- astGetSlotAttributeBody: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.SlotAttribute+attributno-1]->val  

-- astPutSlotNodeAttributeBody: DoPart --
do
   attributNo->checkSlotAttribute;
   val[]->frag.packAstToValue
     ->frag.a[commentInx+offset.SlotAttribute+attributNo-1]  

-- astGetSlotNodeAttributeBody: DoPart --
do
   attributNo->checkSlotAttribute;
   frag.a[commentInx+offset.Slotattribute+attributno-1]->frag.valueToAst->val[]  

-- astAddCommentBody: DoPart --
do
   (if l[] // none then 0->realCommentInx else l.index->realCommentInx if);
     

-- astGetCommentExitBody: DoPart --
do realcommentInx->frag.indexToNode->as[]  

-- printCommentBody: DoPart --
do
   '<'->output.put;
   comment.scanAll
     (# 
     do
        (if ch
         // CommentSeparator1 then
            'S'->output.put; 
         // CommentSeparator2 then
            's'->output.put; 
         // CommentSeparator3 then
            'p'->output.put; 
         else
            ch->output.put; 
        if);
        
     #);
   '>'->output.put;
   output.newLine;
     

-- astGetNextComment: Descriptor --
(# commentAST: ^comment; theComment: ^Text; inx: @Integer; ch: @Char; 
do
   (if realcommentInx <> 0
    // false then
       trace.getNextComment
         ->tracer
           (#  do 'no comment '->dmp.putText; index->dmp.putInt; newLine #);
       (* no comment *)
       - 2->n;
       none ->subcomment[];
       
    else
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       (if theComment[] <> none
        // true then
           trace.getNextComment
             ->tracer
               (# 
               do
                  '<'->dmp.put;
                  theComment.scanAll
                    (# 
                    do
                       (if ch
                        // CommentSeparator1 then
                           'S'->dmp.put; 
                        // CommentSeparator2 then
                           's'->dmp.put; 
                        else
                           ch->dmp.put; 
                       if);
                       
                    #);
                  '>'->dmp.put;
                  dmp.newLine;
                  ' [theComment.lgth:'->dmp.putText;
                  theComment.lgth->dmp.putInt;
                  ']'->dmp.put;
                  dmp.newLine;
                  
               #);
           theComment.reset;
           mainloop:
           (if inx
            // theComment.lgth then (* end of comment *)
               2->n;
               none ->subcomment[];
               0->inx;
               (* finished2 *)
               SUSPEND;
               restart mainloop;
               (* to avoid termination of component *)
               (* old code:
                * -1->n;
                *  NONE->subcomment[];
                * leave mainloop; *)
               (* end of getNextComment *)
               
            else
           (* read next comment *)
               &Text[]->subcomment[];
               loop:
               (if ((inx+1->inx)->theComment.inxget->ch)
                // CommentSeparator1 then
                   trace.getNextComment
                     ->tracer (#  do '(S1)'->dmp.putLine;  #);
                   (if subcomment.lgth
                    // 0 then (* no comments *) - 1->n; 
                    else
                   (* one comment, or the last comment in a sub sequence *)
                       1->n; 
                   if);
                   
                // CommentSeparator2 then
                   trace.getNextComment
                     ->tracer (#  do '(s1)'->dmp.putLine;  #);
                   (if inx = theComment.lgth then
                       0->inx; 2->n; (*finished*) 
                    else
                       (if (inx+1->theComment.inxget) = CommentSeparator1 then
                           inx+1->inx; 0->n; 
                        else
                           1->n
                       if);
                       
                   if)
                else
                   (if inx+1 > theComment.lgth then
                       'GetNextComment: last subcomment not terminated properly, is ignored'
                         ->screen.putLine;
                       '<'->screen.put;
                       theComment.scanAll
                         (# 
                         do
                            (if ch
                             // CommentSeparator1 then
                                'S'->screen.put; 
                             // CommentSeparator2 then
                                's'->screen.put; 
                             else
                                ch->screen.put; 
                            if);
                            
                         #);
                       '>'->screen.put;
                       screen.newLine;
                       ' [theComment.lgth:'->screen.putText;
                       theComment.lgth->screen.putInt;
                       ']'->screen.put;
                       screen.newLine;
                       none ->subcomment[];
                       0->inx;
                       2->n (* finished *)
                    else
                       ch->subcomment.put; restart loop; 
                   if)
               if);
               trace.getNextComment
                 ->tracer
                   (# 
                   do
                      '*** suspend '->dmp.putText;
                      index->dmp.putInt;
                      ' <'->dmp.putText;
                      subComment[]->dmp.putText;
                      '> '->dmp.putText;
                      n->dmp.putInt;
                      ' inx: '->dmp.putText;
                      inx->dmp.putInt;
                      dmp.newLine
                   #);
               SUSPEND;
               trace.getNextComment
                 ->tracer
                   (# 
                   do
                      '*** restart '->dmp.putText;
                      index->dmp.putInt;
                      dmp.newLine
                   #);
               restart mainloop;
               
           if);
           
        else
           trace.getNextComment
             ->tracer
               (# 
               do
                  'no comment, should not happen '->dmp.putText;
                  index->dmp.putInt;
                  newLine
               #);
           - 2->n;
           none ->subcomment[];
           
       if);
       
   if);
   
#)  

-- astInsertSubcommentsBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; 
do
   (if (inx <= 0) then
       'InsertSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if subcomments[] = none then
           'InsertSubcomments: subcomments[] is none '->putLine; 
        else
           (if realcommentInx <> 0
            // false then (* no comment *)
               'InsertSubcomments: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'InsertSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.puttext;
                          inx->dmp.putint;
                          dmp.newLine;
                          'insertsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          'insertsubcomments.subComments:'->Dmp.putLine;
                          (subcomments[],dmp[])->printComment;
                          dmp.newLine;
                          'subComments.lgth:'->Dmp.putText;
                          subComments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (Subcomments[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'insertSubcomments.result:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astSetSubcommentsBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; 
do
   (if (inx <= 0) then
       'SetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if subcomments[] = none then
           'SetSubcomments: subcomments[] is none '->putLine; 
        else
           (if realcommentInx <> 0
            // false then (* no comment *)
               'SetSubcomments: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'SetSubcomments: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'setsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth: '->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          'setsubcomments.subComments:'->Dmp.putLine;
                          (subcomments[],dmp[])->printComment;
                          dmp.newLine;
                          'subComments.lgth:'->Dmp.putText;
                          subComments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (if (start <> end)
                           // true then (start,end)->theComment.delete; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 'setSubcomments.afterDelete:'->Dmp.putLine;
                                 (theComment[],dmp[])->printComment;
                                 'theComment.lgth:'->Dmp.putText;
                                 theComment.lgth->Dmp.putInt;
                                 Dmp.newLine;
                                 
                              #);
                          (Subcomments[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'setSubcomments.result: '->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if)
       if)
   if)
#)  

-- astGetSubcommentsBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; 
do
   (if (inx <= 0) then
       'GetSubcomments: inx must be greater than 0: '->putText;
       inx->putInt;
       newLine;
       
    else
       (if realcommentInx <> 0
        // false then (* no comment *) ''->subcomments[]; 
        else
           realcommentInx->frag.indexToNode->commentAST[];
           commentAST.getText->theComment[];
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'GetSubcomments: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine;
                   ''->subcomments[]
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'getsubcomments.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->Dmp.putText;
                          theComment.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #);
                   ''->Subcomments[];
                   (theComment[],inx)
                     ->findSubcomments
                       (# 
                       do
                          (if start <> end
                           // true then
                              (start,end)->theComment.sub->Subcomments[]; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->Dmp.putText;
                                 start->Dmp.putInt;
                                 ' '->Dmp.put;
                                 end->Dmp.putInt;
                                 ' '->Dmp.put;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'getsubcomments.subComments:'->Dmp.putLine;
                          (subComments[],dmp[])->printComment;
                          'subcomments.lgth:'->Dmp.putText;
                          subcomments.lgth->Dmp.putInt;
                          Dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astScanComments: Descriptor --
(# n,n2: @integer
do
   trace.getNextComment
     ->tracer (#  do 'scanComments ---------'->dmp.putLine #);
   loop:
   (if 1 = 1 then
       getNextComment->(current[],n);
       (* 'current: '->putText;
        '<'->put;
        current[]->putText;
        '> '->putText;
        n->putInt;
        newLine;*)
       (if n
        // - 2 then (* empty comment *)
           
        // - 1 then (* empty subcomment *)
           inx+1->inx; 1->subinx; INNER scanComments; restart loop
        // 0 then (* one subcomment' *)
           inx+1->inx; 1->subinx; INNER scanComments; restart loop
        // 1 then (* subsequence *)
           inx+1->inx;
           1->subinx;
           INNER scanComments;
           loop2:
           (if 1 = 1 then
               getNextComment->(current[],n2);
               subinx+1->subinx;
               INNER scanComments;
               (if n2 // 1 then restart loop2 if);
               
           if);
           (if n2 <> 2 then restart loop if)
        // 2 then (* finished *)
           inx+1->inx; 1->subinx; INNER scanComments
       if)
   if)
#)  

-- astInsertSubcommentBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'InsertSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if subcomment[] = none then
           'InsertSubcomment: subcomment[] is none '->putLine; 
        else
           (if realcommentInx <> 0
            // false then (* no comment *)
               'InsertSubcomment: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'InsertSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'InsertSubcomment.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          'InsertSubcomment.Subcomment:'->Dmp.putLine;
                          (Subcomment[],dmp[])->printComment;
                          'Subcomment.lgth:'->dmp.putText;
                          Subcomment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 ' '->dmp.put;
                                 
                              #);
                          Subcomment->help;
                          help.length->help.pos;
                          CommentSeparator2->help.put;
                          (help[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'InsertSubcomment.result:'->dmp.putText;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if);
       
   if)
#)  

-- astSetSubcommentBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; exp: ^expanded; help: @text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'SetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if subcomment[] = none then
           'SetSubcomment: subcomment[] is none '->putLine; 
        else
           (if realcommentInx <> 0
            // false then (* no comment *)
               'SetSubcomment: No comment'->putLine;
               'In node: '->putText;
               index->putInt;
               newLine;
               'An empty comment must be created using the'->putLine;
               'Prettyprinter operation: createEmptyComment'->putLine
            else
               realcommentInx->frag.indexToNode->commentAST[];
               commentAST.getText->theComment[];
               
           if);
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'SetSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'setSubcomment.theComment:'->Dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          'setSubcomment.Subcomment:'->Dmp.putLine;
                          (Subcomment[],dmp[])->printComment;
                          'Subcomment.lgth:'->dmp.putText;
                          Subcomment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 ' '->dmp.put;
                                 
                              #);
                          (if (start <= end)
                           // true then
                              (start,end+1)->theComment.delete;
                              trace.editingComments
                                ->tracer
                                  (# 
                                  do
                                     'setSubcomment.afterDelete:'->dmp.putText;
                                     (theComment[],dmp[])->printComment;
                                     'theComment.lgth:'->dmp.putText;
                                     theComment.lgth->dmp.putInt;
                                     dmp.newLine;
                                     
                                  #);
                              (* the separator2 is also deleted *)
                              
                          if);
                          Subcomment->help;
                          help.length->help.pos;
                          CommentSeparator2->help.put;
                          (* the user of getSubcomment and setSubcomment 
                           * does not have to worry about separators
                           *)
                          (help[],start)->theComment.insert;
                          theComment[]->commentAST.putText;
                          commentAST[]->addComment;
                          
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'setSubcomment.result:'->dmp.putText;
                          (theComment[],dmp[])->printComment;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if);
       
   if)
#)  

-- astGetSubcommentBody: Descriptor --
(# commentAST: ^comment; theComment: ^Text; 
do
   (if (inx <= 0) or (subinx <= 0) then
       'GetSubcomment: inx and subinx must be greater than 0: '->putText;
       inx->putInt;
       ' '->put;
       subinx->putInt;
       newLine;
       
    else
       (if realcommentInx <> 0
        // false then (* no comment *) ''->subcomment[]; 
        else
           realcommentInx->frag.indexToNode->commentAST[];
           commentAST.getText->theComment[];
           (if theComment[] <> none
            // true then
               (if theComment.lgth = 0 then
                   'GetSubcomment: the comment is empty, not even any separators '
                     ->putLine;
                   'In node: '->putText;
                   index->putInt;
                   newLine;
                   ''->subcomment[]
                else
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'inx: '->dmp.putText;
                          inx->dmp.putint;
                          dmp.newLine;
                          'subinx: '->dmp.putText;
                          subinx->dmp.putint;
                          dmp.newLine;
                          'getSubComment.theComment: '->dmp.putLine;
                          (theComment[],dmp[])->printComment;
                          dmp.newLine;
                          'theComment.lgth:'->dmp.putText;
                          theComment.lgth->dmp.putInt;
                          dmp.newLine;
                          
                       #);
                   ''->subComment[];
                   (theComment[],inx,subinx)
                     ->findSubComment
                       (# 
                       do
                          (if start <= end
                           // true then
                              (start,end)->theComment.sub->subComment[]; 
                          if);
                          trace.editingComments
                            ->tracer
                              (# 
                              do
                                 'start,end: '->dmp.putText;
                                 start->dmp.putInt;
                                 ' '->dmp.put;
                                 end->dmp.putInt;
                                 dmp.newLine;
                                 
                              #)
                       #);
                   trace.editingComments
                     ->tracer
                       (# 
                       do
                          'getSubcomment.subComment: '->dmp.putLine;
                          (subComment[],dmp[])->printComment;
                          dmp.newLine;
                          
                       #)
               if)
           if);
           
       if)
   if)
#)  

-- astHascommentBody: DoPart --
do realcommentInx <> 0->has  

-- astGetCommentPropBody: Descriptor --
(# c: ^comment; base: @integer; 
do
   (if hasCommentProp
    // true then
       getComment->c[];
       c.curLength div 4->repS.extend;
       c.lexemInx->base;
       0->repS.top;
       (for i: c.curLength div 4 repeat c.frag.a[base+i]->repS.putInt for);
       0->repS.top;
       &propertyList[]->prop[];
       repS[]->prop.repRestore;
       
   if);
   
#)  

-- astSetCommentPropBody: Descriptor --
(# c: ^comment; base: @integer; 
do
   0->repS.top;
   repS[]->prop.repSave;
   (prodNo.comment,frag[])->frag.grammar.newAst->c[];
   repS.top*4->c.checkBase;
   c.lexemInx->base;
   (for i: repS.top repeat repS.r[i]->c.frag.a[base+i] for);
   repS.top*4->c.curLength;
   c[]->addComment;
   17->typeOfComment;
   
#)  

-- astTypeOfCommentEnterBody: DoPart --
do
   (if hasComment
    // true then
       type->frag.a[realcommentInx+offset.commentType]
    // false then
       'node has no comment'->stopYggdrasil
   if)  

-- astTypeOfCommentExitBody: DoPart --
do
   (if hasComment
    // true then
       frag.a[realcommentInx+offset.commentType]->type
    // false then
       - 1->type
   if);
     

-- astNCABody: Descriptor --
(# myScanner: @|scanDown; 
do
   (if (testAst[]->equal)
    // false then
         (# testScanner: ^|testAst.scanDown; myAs,testAs: ^Ast
         do
            &| testAst.scanDown[]->testScanner[];
            loop:
            (if 1
             // 1 then
                myScanner->myAs[];
                testScanner->testAs[];
                (if (myAs[]->testAs.equal)
                 // true then
                    myAs[]->nca[];
                    (if true
                     // (nca[]->equal) then
                        testScanner->testAs[]; testAs.sonNo->testSonNo
                     // (nca[]->testAst.equal) then
                        myScanner->myAs[]; myAs.sonNo->mySonNo
                     else
                        restart loop
                    if)
                 // false then
                    testAs.sonNo->testSonNo; myAs.sonNo->mySonNo
                if)
            if)
         #)
    else
       testAst[]->nca[]
   if)
#)  

-- astScanBody: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;
   
do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx = 0)
    // false then
       privateInx->privateIndexToNode->current[];
       currentSonNo+1->currentSonNo;
       INNER scan;
       (if (privateInx->privateIsLastBrother)
        // false then privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)  

-- astSuffixWalkBody: Descriptor --
(#
   nextinx,firstson: @integer;
   theCutter: @cutIf;
   s: @stak;
   setNextInx:
     (# 
     enter nextInx
     do
        (if (nextInx->frag.isLastBrother)
         // false then nextInx->frag.getNextBrother->s.push
        if)
     #);
   
do
   s.init;
   index->nextInx;
   stakscan:
   (if 0
    // 0 then
       (if (nextInx->frag.getSymbol->theCutter)
        // false then
           nextinx->frag.indexToNode->current[];
           INNER suffixWalk;
           (if (nextInx->frag.getSymbol->frag.grammar.kindOfSymbol)
            // kinds.interior then
               (if ((nextInx->frag.getSonInx->firstSon) > 0)
                // true then firstSon->setNextInx; restart stakScan
               if)
           if)
       if);
       (if s.empty // false then s.pop->setNextInx; restart stakScan if);
       
   if);
   
#)  

-- astSuffixWalkForProdBody: Descriptor --
(#
   theCutter: @cutIf;
   s: @stak;
   nextInx,firstson: @integer;
   theSymbol: @integer;
   setNextInx:
     (# 
     enter nextInx
     do
        (if (nextInx->frag.isLastBrother)
         // false then nextInx->frag.getNextBrother->s.push
        if)
     #);
   
do
   s.init;
   index->nextInx;
   stakscan:
   (if 0
    // 0 then
       (if (nextInx->frag.getSymbol->theSymbol->theCutter)
        // false then
           (if theSymbol
            // prod then
               nextinx->frag.indexToNode->current[]; INNER suffixWalkForProd
           if);
           (if (theSymbol->frag.grammar.kindOfSymbol)
            // kinds.interior then
               (if ((nextInx->frag.getSonInx->firstSon) > 0)
                // true then firstSon->setNextInx; restart stakScan
               if)
           if)
       if);
       (if s.empty // false then s.pop->setNextInx; restart stakScan if);
       
   if)
#)  

-- astCopyCopyCatcherBody: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if true
        // no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- astCopyExitBody: Descriptor --
(# oldCatcher: ^handler
do
   (if theCatcher[]
    // none then theCatcher[]->oldCatcher[]; copyCatcher[]->theCatcher[]
   if);
   copyFrag[]->copyPrivate->copyfrag.indexToNode->as[];
   (if theCatcher[] // copyCatcher[] then oldCatcher[]->theCatcher[] if);
   
#)  

-- astDumpBody: DoPart --
do
   (if dmp[] // none then screen[]->dmp[] if);
   '@'->dmp.put;
   (index)->putInt;
   (if hasComment
    // true then
       ' COMMENT '->dmp.putText;
       (if (commentInx >= frag.a.range)
        // true then '_'->dmp.put
        else
             (# l: ^lexemText; t: ^text; 
             do
                '"'->dmp.put;
                getComment->l[];
                l.gettext->t[];
                (t[],dmp[])->printComment;
                (* lexemtext.dump should also check the size of the text *)
                (* (1,(30,t.length) -> min ) -> t.sub -> dmp.puttext;
                 (if t.length>30 //true then
                 '...' -> dmp.puttext;
                 (((30,t.length) -> max) - 30,t.length) -> t.sub -> dmp.puttext;
                 if);
                 *)
                '"'->dmp.put
             #);
           
       if)
   if);
   INNER dump;
     

-- astMatchBody: DoPart --
do
   (if ((treeToMatch.symbol = unExpanded)->doesMatch)
    // false then
       (if ((treeToMatch.symbol = symbol)->doesMatch)
        // true then INNER match
       if)
   if)  

-- astSemanticErrorEnterBody: DoPart --
do
   (if (errorNumber > 0)
    // true then
       true->hasSemanticError;
       'Semanticerrors'
         ->frag.prop.addProp
           (# ifPropExist::<  (#  do false->delete #); 
           do index->addConst; errorNumber->addConst
           #);
       
    else
       false->hasSemanticError
   if)  

-- astSemanticExitBody: DoPart --
do
   (if hasSemanticError
    // true then
       'Semanticerrors'
         ->frag.prop.getProp
           (#
              doProp::< 
                (# readIndex,indexFound: @boolean
                do
                   true->readIndex;
                   false->indexFound;
                   scanParameters
                     (#
                        doConst::< 
                          (# 
                          do
                             (if readIndex
                              // true then (c = index)->indexFound; 
                              else
                                 (if indexFound
                                  // true then c->errorNumber
                                 if)
                             if);
                             not readIndex->readIndex;
                             
                          #);
                        
                     #);
                   
                #);
              
           #)
   if)  

-- astCopyPrivateBody: DoPart --
do
   (symbol,copyFrag[])->frag.grammar.newAstWithoutSons->theCopy[];
   (if (symbol = comment)
    // false then
       (if hasComment
        // true then
             (# theComment: ^comment; 
             do
                getComment->theComment[];
                copyFrag[]->theComment.copy->theCopy.addComment;
                
             #);
           
       if)
   if);
   INNER copyPrivate;
   theCopy.index->theCopyInx;
     

-- newastBody: Descriptor --
(# unExp: ^unExpanded; lastInx: @integer; NoOfsons: @integer; 
do
   (prod,frag[])->newAstWithOutSons->as[];
   (if (prod > 0)
    // true then
       (for i: (sonArray[prod]->noOfSons) repeat
         (0,frag[])->newUnExpanded->unExp[];
         (if i
          // 1 then (as.index,unExp.index->lastInx)->frag.setSonInx
          else
             (lastInx,unExp.index)->frag.setNextBrother; unExp.index->lastInx; 
         if)
       for);
       (if (noOfSons > 0)
        // true then
           (lastInx,true)->frag.setlastBrother;
           (lastInx,as.index)->frag.setNextBrother;
           
       if)
   if)
#)  

-- newAstWithoutSonsBody: DoPart --
do
   (if (prod < 0)
    // true then
       (if prod
        // prodNo.unExpanded then
           (0,frag[])->newUnExpanded->as[]; 
        // prodNo.optional then
           (0,frag[])->newOptional->as[]; 
        // prodNo.NameDecl // prodNo.NameAppl // prodNo.String
        // prodNo.Comment then
           (prod,4,frag[])->NewLexemText->as[]; 
        // prodNo.Const then
           frag[]->newConst->as[]; 
        // prodNo.SlotDesc then
           frag[]->newSlot->as[]; 
       if);
       
    else
       (if true
        // (prod = 0)
        // (prod > kindArray.range) (* changed by kjm from >= to > *)
        // (kindArray[prod] = 0) then
             (# m: ^text
             do
                &text[]->m[];
                'ERROR illegal syncatno for newAST:'->m.putText;
                prod->m.putInt;
                m[]->AstInterfaceError
             #)
       if);
       (prod,frag[])->newAstForParser->frag.indexToNode->as[];
       
   if)  

-- expandednoOfSonsBody: Descriptor --
(# privateInx: @integer; 
do
   0->sons;
   sonInx->privateInx;
   l:
   (if (privateInx = 0)
    // false then
       sons+1->sons;
       (if (privateInx->frag.isLastBrother)
        // false then privateInx->frag.getNextBrother->privateInx; restart l
       if)
   if)
#)  

-- expandedGetExitBody: DoPart --
do i->findindex->frag.indexToNode->as[]  

-- expandedPutEnterBody: Descriptor --
(# prevSonInx,NextSonInx: @integer
do
   (if (frag[] = s.frag[]) // false then notSameFragment if);
   (if i
    // 1 then (* set the next brother of the inserted node *)
       (if true
        // (sonInx = 0) // (sonInx->frag.isLastBrother) then
           true->s.lastBrother; index->s.brotherInx
        else
           (s.index,sonInx->frag.getNextBrother)->frag.setNextBrother;
           false->s.lastBrother;
           
       if);
       (* insert the node *)
       s.index->sonInx;
       
    else
   (* find where to insert the node *)
       i-1->findindex->prevSonInx;
       (* determine if the inserted node will be the last brother
        * and set nextBrother/father of the inserted node
        *)
       (if (prevSonInx->frag.isLastBrother)
        // true then
           true->s.lastBrother;
           index->s.brotherInx;
           (prevSonInx,false)->frag.setLastBrother;
           
        else
           (prevSonInx->frag.getNextBrother->nextSonInx->frag.isLastBrother)
             ->s.lastBrother;
           nextSonInx->frag.getNextBrother->s.brotherInx;
           
       if);
       (* insert the node *)
       (prevSonInx,s.index)->frag.setNextBrother;
       
   if)
#)  

-- expandedInsertBody: Descriptor --
(#
   prevSonInx,NextSonInx: @integer; commentAST: ^comment; theComment: ^Text; 
do
   (if (frag[] = s.frag[]) // false then notSameFragment if);
   (if i
    // 1 then
       sonInx->s.BrotherInx;
       (if sonInx
        // 0 then true->s.lastBrother; index->s.brotherInx
        else
           false->s.lastBrother
       if);
       s.index->sonInx;
       
    else
       i-1->findindex->prevSonInx;
       (if (prevSonInx = 0)
        // true then 'ERROR: illegal index for insert '->AstInterfaceError; 
       if);
       prevSonInx->frag.getNextBrother->nextSonInx;
       (prevSonInx,s.index)->frag.setNextBrother;
       nextSonInx->s.brotherInx;
       (if (prevSonInx->frag.isLastBrother)
        // true then
           true->s.lastBrother; (prevSonInx,false)->frag.setlastBrother
        else
           false->s.lastBrother
       if);
       
   if);
   (if realcommentInx <> 0
    // true then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       trace.editingComments
         ->tracer
           (# 
           do
              'listInsert, before: '->dmp.putText;
              (theComment[],dmp[])->printComment;
              
           #);
       (i,theComment[])->insertSep1;
       trace.editingComments
         ->tracer
           (# 
           do
              'listInsert, after: '->dmp.putText;
              (theComment[],dmp[])->printComment;
              
           #);
       theComment[]->commentAST.putText;
       commentAST[]->addComment;
       
   if);
   
#)  

-- expandedDumpBody: Descriptor --
(# t: ^text
do
   newLine;
   (for level repeat ' '->dmp.put for);
   '('->dmp.put;
   (if (symbol->frag.grammar.symbolToName->t[])
    // none then INNER dump; (symbol)->dmp.putint; 
    else
       t[]->dmp.putText; '='->dmp.put; (symbol)->dmp.putint; 
   if);
   ':'->dmp.put;
   (if (sonInx > frag.a.range)
    // true then '_'->dmp.put
    else
       (NoOfSons)->putint;
       (if
       ((frag.grammar.sonArray[symbol] <> 0) and
        (frag.grammar.sonArray[symbol] <> NoOfSons))
        // true then
             (# m: ^text
             do
                &text[]->m[];
                ' Number of sons wrong. Expected number of sons '->m.putText;
                (frag.grammar.sonArray[symbol])->m.putInt;
                'ERROR: consistency check failed.'->m.puttext;
                m[]->stopYggdrasil
             #)
       if);
       
   if);
   (for i: frag.grammar.roomArray[symbol] repeat
     '['->dmp.put; (frag.a[index+offset.attribute-1+i])->putInt; ']'->dmp.put; 
   for);
   (if (sonInx > frag.a.range)
    // false then scan (#  do (level+1,dmp[])->current.dump #); 
   if);
   ')'->dmp.put;
   
#)  

-- expandedMatchBody: Descriptor --
(# son: ^Ast; matchExp: ^expanded
do
   treeToMatch[]->matchExp[];
   (if noOfSons
    // matchExp.noOfSons then
       loop:
       (for i: NoOfSons repeat
         i->get->son[];
         i->matchExp.get->son.match->doesMatch;
         (if doesMatch // false then leave loop if)
       for)
   if);
   
#)  

-- expandedCopyPrivateBody: Descriptor --
(# theExpCopy: ^expanded; fragInx,theCopyInx,symbolRoom: @integer
do
   theCopy[]->theExpCopy[];
   scan
     (#  do (currentSonNo,copyFrag[]->current.copy)->theExpCopy.put #);
   index+offset.attribute-1->fragInx;
   theCopy.index+offset.attribute-1->theCopyInx;
   frag.grammar.roomArray[symbol]->symbolRoom;
   (if (theCopyInx+symbolRoom >= copyFrag.a.range)
    // true then symbolRoom->copyFrag.extendA
   if);
   (for i: symbolRoom repeat frag.a[fragInx+i]->copyFrag.a[theCopyInx+i] for);
   
#)  

-- consDeleteBody: Descriptor --
(# nextSonInx,prevSonInx,deletedNode: @integer; unExp: ^unExpanded
do
   sonnr-1->findindex->prevSonInx;
   prevSonInx->frag.getNextBrother->deletedNode->frag.getNextBrother
     ->nextSonInx;
   (* create the node to insert *)
   (prodNo.unExpanded,frag[])->frag.grammar.newAst->unExp[];
   (* insert the node *)
   (prevSonInx,unExp.index)->frag.setNextBrother;
   nextSonInx->unExp.brotherInx;
   deletedNode->frag.isLastBrother->unExp.lastBrother;
   (* set the fathernode of the deleted node to NONE *)
   (deletedNode,0)->frag.setNextBrother;
   true->frag.isLastBrother;
   
#)  

-- listDeleteBodyDescriptor: Descriptor --
(#
   prevSonInx,deletedNode,nextSonInx: @integer;
   commentAST: ^comment;
   theComment: ^Text;
   
do
   (if sonnr
    // 1 then
       sonInx->deletedNode;
       (if (sonInx->frag.isLastBrother)
        // true then 0->sonInx
        else
           deletedNode->frag.getNextBrother->sonInx; 
       if);
       
    else
       sonnr-1->findindex->prevSonInx->frag.getNextBrother->deletedNode
         ->frag.getNextBrother->nextSonInx;
       (prevSonInx,deletedNode->frag.isLastBrother)->frag.setLastBrother;
       (prevSonInx,nextSonInx)->frag.setNextBrother;
       
   if);
   (deletedNode,0)->frag.setNextBrother;
   (deletedNode,true)->frag.setLastBrother;
   (if realcommentInx <> 0
    // true then
       realcommentInx->frag.indexToNode->commentAST[];
       commentAST.getText->theComment[];
       trace.editingComments
         ->tracer
           (# 
           do
              'listDelete, before: '->dmp.putText;
              (theComment[],dmp[])->printComment
           #);
       (sonnr,theComment[])->deleteSep1;
       theComment[]->commentAST.putText;
       commentAST[]->addComment;
       trace.editingComments
         ->tracer
           (# 
           do
              'listDelete, after: '->dmp.putText;
              (theComment[],dmp[])->printComment
           #);
       
   if);
   
#)  

-- listNewScanBody: Descriptor --
(#
   privateInx: @integer;
   privateIsLastBrother: @frag.isLastBrother;
   privateGetNextBrother: @frag.getNextBrother;
   privateIndexToNode: @frag.indexToNode;
   predefined:< (# current: ^Ast enter current[] do INNER newScan #);
   
do
   0->currentSonNo;
   sonInx->privateInx;
   l:
   (if (privateInx = 0)
    // false then
       currentSonNo+1->currentSonNo;
       privateInx->privateIndexToNode->a[];
       (if a.kind
        // kinds.interior then a[]->current[]; INNER newScan; 
        else
           a[]->predefined; 
       if);
       (if (privateInx->privateIsLastBrother)
        // false then privateInx->privateGetNextBrother->privateInx; restart l
       if)
   if)
#)  

-- lexemTextGetTextBody: Descriptor --
(# i: @integer; base: @integer; 
do
   lexemInx*4->base;
   (for i: ((frag.a,base-2)->tos'%inxGetShort') repeat
     (frag.a,base+i-1)->tos'%inxGetByte'->t.put
   for);
   
#)  

-- lexemTextPutTextBody: Descriptor --
(# i,l: @integer; base: @integer; 
do
   t.length->l->checkbase;
   lexemInx*4->base;
   (frag.a,base-2,l)->tos'%inxPutShort';
   1->i;
   t.scanAll
     (#  do (frag.a,base+i-1,ch)->tos'%inxPutByte'; i+1->i #);
   
#)  

-- lexemTextClearBody: Descriptor --
(# base: @integer
do
   lexemInx*4-2->base;
   (if lexemInx // 0 then 1->checkbase if);
   (frag.a,base,0)->tos'%inxPutShort'
#)  

-- lexemTextGetCharBody: Descriptor --
(# base: @integer; 
do
   (if ((index >= 1) and (index <= curLength))
    // true then lexemInx*4+index-1->base; (frag.a,base)->tos'%inxGetByte'->ch
    else
       'error in index in getChar'->stopYggdrasil; 
   if)
#)  

-- lexemTextPutCharBody: Descriptor --
(# base,length: @integer
do
   (if lexemInx // 0 then 1->checkbase;  else curLength+1->checkbase if);
   lexemInx*4->base;
   curLength+1->length->curLength;
   (frag.a,base+length-1,c)->tos'%inxPutByte'
#)  

-- lexemTextCurLengthEnterBody: Descriptor --
(# base: @integer
do lexemInx*4-2->base; (frag.a,base,l)->tos'%inxPutShort'
#)  

-- lexemTextCurLengthExitBody: DoPart --
do frag.a[lexemInx]->tos'%getShort[1]'->l  

-- lexemTextMatchBody: DoPart --
do
   treeToMatch[]->theMatchLexem[];
   (if ((theMatchLexem.curLength = curLength)->doesMatch)
    // true then
       getText->theT[];
       theT.copy->theT[];
       theMatchLexem.getText->theMatchText[];
       theMatchText.copy->theMatchText[];
       loop:
       (for i: curLength repeat
         ((i->theT.inxGet->ascii.UpCase) =
          (i->theMatchText.inxGet->ascii.UpCase))->doesmatch;
         (if doesMatch // false then leave loop if)
       for)
   if);
   INNER match  

-- newLexemTextEnterBody: DoPart --
do (prod,length,frag[])->newLexemTextForParser->(inx,base)  

-- newLexemTextExitBody: DoPart --
do inx->frag.indexToNode->as[]  

-- nameDeclAddUsageBody: Descriptor --
(# lastVal: @integer; lastAst: ^Ast
do
   usageInx->lastVal;
   (if (lastVal > 0)
    // true then
       lastVal->frag.valueToAst->lastAst[];
       lastAst[]->user.frag.packAstToValue->lastVal
   if);
   lastVal->user.usageInx;
   user[]->frag.packAstToValue->usageInx
#)  

-- nameDeclRemoveUsageBody: Descriptor --
(#
   userVal,userInxVal: @integer;
   thisNameAppl: ^nameAppl;
   user: @integer;
   thisFragmentForm: ^fragmentForm;
   lastAst: ^Ast;
   
do
   THIS(nameDecl)[]->lastAst[];
   usageInx->user;
   frag[]->thisFragmentForm[];
   loop:
   (if (user > 0)
    // true then
       user->thisFragmentForm.valueToAst->thisNameAppl[];
       thisNameAppl.frag[]->thisFragmentForm[];
       (if (thisNameAppl[]->userAppl.equal)
        // true then userAppl.usageInx->lastAst.usageInx; leave loop
       if);
       thisNameAppl[]->lastAst[];
       thisNameAppl.usageInx->user;
       restart loop
   if);
   - userAppl.index->userAppl.usageInx;
   
#)  

-- nameDeclScanUsageBody: DoPart --
do
   usageInx->user;
   frag[]->currentFragmentForm[];
   loop:
   (if (user > 0)
    // true then
       user->currentFragmentForm.valueToAst->current[];
       current.frag[]->currentFragmentForm[];
       INNER scanUsage;
       current.usageInx->user;
       restart loop
   if)  

-- nameApplGetDeclBody: Descriptor --
(# currentAst: ^Ast
do
   THIS(nameAppl)[]->currentAst[];
   currentAst.usageInx->user;
   loop:
   (if (user > 0)
    // true then
       user->currentAst.frag.valueToAst->currentAst[];
       currentAst.usageInx->user;
       restart loop
   if);
   - user->currentAst.frag.indexToNode->declAst[]
#)  

-- nameApplDeclSetBody: DoPart --
do (usageInx <> - index)->b  

-- nameApplNextUsageBody: DoPart --
do
   (if (usageInx > 0)
    // true then usageInx->frag.valueToAst->nextNameAppl[]; 
    else
       none ->nextNameAppl[]
   if)  

-- commentCommentTypeEnterBody: DoPart --
do type->commentTypeInx  

-- commentCommentTypeExitBody: DoPart --
do commentTypeInx->type  

-- commentCopyPrivateBody: DoPart --
do commentTypeInx->theCopy.commentTypeInx  

-- constNewConstTypeBody: DoPart --
do (lexemInx <> 0)->b  

-- constPutValueBody: Descriptor --
(# t: @text
do
   (if newConstType
    // true then val->t.putInt; t[]->putText
    else
       val->valueInx
   if);
   
#)  

-- constGetValueBody: Descriptor --
(# t: ^text
do
   (if newConstType (* signals new value-type *)
    // true then getText->t[]; ' '->t.put; 0->t.pos; t.getInt->val
    else
       valueInx->val
   if);
   
#)  

-- newConstBody: DoPart --
do (prodNo.const,4,frag[])->newLexemText->c[]  

-- unExpandedTheSlotEnterBody: DoPart --
do o.index->commentInx; index->o.BrotherInx; true->o.lastBrother; true->bit7;   

-- unExpandedTheSlotExitBody: DoPart --
do commentInx->frag.indexToNode->sd[]  

-- unExpandedDumpBody: DoPart --
do
   (if isSlot
    // true then (# o: ^SlotDesc do theSlot->o[]; (0,dmp[])->o.dump #)
    else
       INNER dump;
       '#['->dmp.putText;
       (nonterminalsymbol)->dmp.putInt;
       ']'->dmp.put
   if)  

-- unExpandedCopyPrivateBody: Descriptor --
(# theUnExpCopy: ^unExpanded
do
   theCopy[]->theUnExpCopy[];
   (if isSlot
    // true then
         (# op,copyOp: ^SlotDesc
         do
            theSlot->op[];
            copyFrag[]->op.copyPrivate->CopyFrag.indexToNode->copyOp[];
            copyOp[]->theUnExpCopy.theSlot;
            
         #)
   if);
   nonterminalSymbol->theUnExpCopy.nonterminalSymbol;
   
#)  

-- newUnexpandedBody: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range)
    // true then offset.sizePerUnExpanded->frag.extendA
   if);
   &UnExpanded[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.unExpanded)->frag.setSymbol;
   syncatNo->s.nonterminalSymbol;
   frag.curtop+offset.sizePerUnExpanded->frag.curtop  

-- newOptionalBody: DoPart --
do
   (if (frag.curtop+offset.sizePerUnExpanded >= frag.a.range)
    // true then offset.sizePerUnExpanded->frag.extendA
   if);
   &Optional[]->s[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (frag.curtop->s.index,prodNo.optional)->frag.setSymbol;
   frag[]->s.frag[];
   frag.curtop+offset.sizePerUnExpanded->frag.curtop;
   syncatNo->s.nonterminalSymbol  

-- slotDescNameEnterBody: Descriptor --
(# c: ^comment
do (comment,frag[])->frag.grammar.newAst->c[]; t[]->c.putText; c.index->sonInx
#)  

-- slotDescNameExitBody: DoPart --
do sonInx->frag.indexToNode->c[];   

-- slotDescCopyPrivateBody: Descriptor --
(# c: ^comment
do sonInx->frag.indexToNode->c[]; copyFrag[]->c.copyPrivate->theCopy.sonInx
#)  

-- slotDescDumpBody: DoPart --
do
   dmp.newLine;
   'SLOT. Name = '->dmp.putText;
   name->dmp.putText;
   'Category = '->dmp.putText;
   (category (*,5*) )->dmp.putInt;
   dmp.newLine;
   (for i: offset.sizePerSlotDesc-offset.slotAttribute repeat
     '['->dmp.put;
     (frag.a[index+i-1+offset.slotAttribute])->dmp.putInt;
     ']'->dmp.put;
     
   for);
   INNER dump;
   dmp.newLine;
     

-- slotDescNodeBody: DoPart --
do findFatherInx->father; frag[]->ff[]  

-- newSlotBody: DoPart --
do
   (if (frag.curtop+offset.sizePerSlotDesc >= frag.a.range)
    // true then offset.sizePerSlotDesc->frag.extendA
   if);
   &SlotDesc[]->s[];
   frag.curTop->s.index;
   frag[]->s.frag[];
   0->frag.a[frag.curTop]->frag.a[frag.curTop+1];
   (s.index,prodNo.SlotDesc)->frag.setSymbol;
   frag.firstSlot->frag.a[frag.curtop+offset.usage];
   frag.curTop->frag.firstSlot;
   frag.curTop+offset.sizePerSlotDesc->frag.curtop  

-- fragmentFullNameBody: DoPart --
do
   &text[]->N[];
   (if fatherR[]
    // none then FullNameT[]->N.append
    else
       fatherR.FullName->N.append;
       (if fatherR.isDirectory
        // true then (*  '/' -> N.put *) 
        else
           directoryChar->N.put; 
       if);
       NameT[]->N.append
   if)  

-- fragmentMarkAsChangedCatcherBody: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if true
        // no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- fragmentMarkAsChangedBody: Descriptor --
(# oldCatcher: ^handler
do
   (if theCatcher[]
    // none then
       theCatcher[]->oldCatcher[]; markAsChangedCatcher[]->theCatcher[]
   if);
   pack;
   false->changed;
   (if theCatcher[]
    // markAsChangedCatcher[] then oldCatcher[]->theCatcher[]
   if);
   
#)  

-- fragmentCheckDiskRepresentationBody: Descriptor --
(# diskFile: @file (# binary::< trueObject #); 
do
   diskFileName->diskFile.name;
   (if
   ((diskFile.entry.modTime (# error::<  (#  do true->continue #) #) > modTime)
      ->haveBeenChanged)
    // true then INNER checkDiskRepresentation
   if)
#)  

-- fragmentBindBody: DoPart --
do
   (if BindMark
    // true then 
    else
       True->BindMark;
       INNER bind;
       (* If not bound by INNER then try origin *)
       (if OP[]
        // none then
           (if originR[]
            // none then (* try setting up origin *) screen[]->setupOrigin
           if);
           (if originR[] <> none then
               F[]->originR.Bind (*BindToOrigin*) ->OP[]
           if);
           
       if)
   if);
   False->BindMark  

-- fragmentBindToOriginBody: DoPart --
do (if (originR[] <> none ) // True then F[]->originR.Bind->OP[] if)  

-- fragmentSetupOriginBody: Descriptor --
(# t: ^text; 
do
   FindOrigin: THIS(fragment).prop.ScanProp
     (#
        doProp::< 
          (# 
          do
             prop.makelc;
             (if 'origin'->prop.equal then
                 ScanParameters
                   (#
                      doString::< 
                        (# 
                        do
                        (*** This exception is already handled in control-module
                         * (if originDefined//true then
                         * (# m: ^text
                         * do &text[]->m[];
                         * '*** Error: two or more origins in '-> m.putText;
                         * this(fragment).name -> m.putLine;
                         * '    ' -> m.puttext;
                         * this(fragment).originR.name ->m.putline;
                         * '    ' -> m.putText; S[] -> m.putline;
                         * 'Perhaps a missing '';'' after origin name'
                         * -> m.putline;
                         * m[]->AstInterfaceException(# do true->continue #)
                         * #)
                         * if);
                         *)
                           THIS(fragment).fullName->stripPathName->t[];
                           (if t[]
                            // none then
                               ((S.copy,thePathHandler.currentDirectory)
                                  ->thePathHandler.convertFilePath,error[])
                                 ->top.open->THIS(fragment).origin
                            else
                               ((S.copy,t[])->thePathHandler.convertFilePath,
                                error[])->top.open->THIS(fragment).origin
                           if);
                           leave FindOrigin;
                           
                        #)
                   #)
             if)
          #)
     #)
#)  

-- fragmentCatcherBody: DoPart --
do
   (if theCatcher[]
    // none then
       (if (fatherR[] = none )
        // false then (no,msg[])->fatherR.catcher
        else
           msg[]->AstInterfaceError
       if)
    else
       (no,msg[])->theCatcher
   if)  

-- fragmentLinkUnpackBody: Descriptor --
(# n,t: ^text
do
   &text[]->n[];
   name->n.append;
   fatherR.fullName->stripPathName->t[];
   (if t[]
    // none then
       ((n.copy,thePathHandler.currentDirectory)
          ->thePathHandler.ConvertFilePath,error[])->top.open->f[]
    else
       ((n.copy,t[])->thePathHandler.ConvertFilePath,error[])->top.open->f[]
   if);
   (if f[]
    // none then (n[],error[])->top.open->f[]
    else
   (* &text[] -> fullNameOfLink[]; f.fullName -> fullNameOfLink; *)
       
   if)
#)  

-- fragmentLinkInitBody: DoPart --
do linkType->fragType; none ->prop[]; nameT[]->fullNameOfLink[]  

-- fragmentGroupOpenOpenCatcherBody: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if true
        // no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- fragmentGroupOpenBody: Descriptor --
(# oldCatcher: ^handler
do
   trace.FragmentOpen
     ->tracer
       (# 
       do
          'group-open of '->dmp.putText;
          localPath[]->dmp.putText;
          ' in '->dmp.putText;
          fullName->dmp.putText;
          
       #);
   (if theCatcher[]
    // none then theCatcher[]->oldCatcher[]; openCatcher[]->theCatcher[]
   if);
   0->localPath.pos;
   (if localPath.getNonBlank
    // ascii.fs then
         (# msg: @text
         do
            'Fragment name is empty: '->msg;
            localPath[]->msg.putLine;
            (errorNumbers.notExisting,msg[])->catcher
         #)
   if);
   l:
     (# 
     do
        (if fatherR[]
         // none (* we are in the top *) then
            localPath[]->expandToFullPath->localPath[]; 
         else
            (if (1->localPath.inxGet) // '~' then leave l if); 
        if);
        0->dirInx->groupInx;
        directoryChar->localPath.findCh (#  do inx->groupInx #);
        thePathHandler.directoryChar
          ->localPath.findCh (#  do inx->dirInx #);
        (if (groupInx > 0)
         // true then (* xx-yy *)
            (if (dirInx < groupInx)
             // true then (* zz/xx-yy *)
                ((1,groupInx-1)->localPath.sub,error[])->open->f[];
                (if f[]
                 // none then 
                 else
                    (if f.type
                     // groupType then
                        f[]->g[];
                        ((groupInx+1,localPath.length)->localPath.sub,error[])
                          ->g.open->f[];
                        
                     else
                        none ->f[]
                    if)
                if);
                leave l
            if)
        if);
        (localPath[],error[])->fragmentList.open->f[];
        
     #);
   (if f[]
    // none then
         (# msg: @text
         do
            'Fragment not found in open: '->msg;
            localPath[]->msg.putLine;
            (errorNumbers.notExisting,msg[])->catcher
         #)
    else
       true->f.isOpen
   if);
   (if theCatcher[] // openCatcher[] then oldCatcher[]->theCatcher[] if);
   trace.fragmentOpen
     ->tracer
       (# 
       do
          (if f[]
           // none then 'FAILED: '->dmp.putText
           else
              'SUCCEEDED: '->dmp.putText; 
          if);
          'group-open of '->dmp.putText;
          localPath[]->dmp.putText;
          ' in '->dmp.putText;
          fullName->dmp.putText;
          
       #);
   
#)  

-- fragmentGroupAlreadyOpenBody: Descriptor --
(# dotInx,dirInx,groupInx: @integer
do
   0->localPath.pos;
   (if localPath.getNonBlank
    // ascii.fs then 
    else
       localPath[]->expandToFullPath->localPath[];
       l:
         (# 
         do
            fragmentList.scan
              (# found: @boolean
              do
                 (if current.type
                  // formType then current.name[]->localPath.equalNCS->found
                  else
                     current.name[]->localPath.equal->found
                 if);
                 (if found
                  // true then
                     screen[]->current.open;
                     current.f[]->f[];
                     true->value;
                     INNER alreadyOpen;
                     leave l
                 if)
              #)
         #)
   if)
#)  

-- fragmentGroupCloseBody: DoPart --
do
   fragmentList.scan
     (# 
     do
        (if current.type
         // formType then
            (if (current.f[] = none )
             // false then current.f.close; none ->current.f[]
            if)
        if);
        
     #);
   THIS(FragmentGroup)[]->top.delete;
   none ->fragmentList[];
   none ->prop[];
     

-- fragmentGroupNamedCloseBody: DoPart --
do
   0->localPath.pos;
   (if localPath.getNonBlank
    // ascii.fs then 
    else
       localPath[]->expandToFullPath->localPath[];
       theScan: fragmentList.scan
         (# found: @boolean
         do
            (if current.type
             // formType then current.name[]->localPath.equalNCS->found
             else
                current.name[]->localPath.equal->found
            if);
            (if found
             // true then
                (if current.type
                 // formtype then
                    (if current.f[]
                     // none then current.f.close; none ->current.f[]
                    if)
                if);
                current[]->fragmentList.at->fragmentList.delete;
                leave theScan
            if)
         #)
   if)  

-- fragmentGroupFragmentListElementOpenBody: DoPart --
do
   (if f[]
    // none then
       (if type
        // formType then
           newFragmentForm->f[]; 
        // groupType then
           newFragmentGroup->f[]; 
        // linktype then
             (# l: ^fragmentLink
             do
                newFragmentLink->l[]->f[];
                &text[]->l.localName[];
                localName[]->l.localName.append;
                
             #);
           
       if);
       name.copy->f.name;
       THIS(fragmentGroup)[]->f.father;
       (if type // linkType // groupType then error[]->f.unPack if)
   if)  

-- fragmentGroupFragmentListDescriptorDeleteLocalNameBody: DoPart --
do
   l: scan
     (# 
     do
        (if (current.name[]->n.equal)
         // true then current[]->at->delete; leave l
        if)
     #)  

-- fragmentGroupFragmentListDescriptorFindBody: DoPart --
do
   l: scan
     (# 
     do
        (if (current.name[]->n.equal)
         // true then current.f[]->r[]; leave l
        if)
     #);
     

-- fragmentGroupFragmentListDescriptorOpenBody: DoPart --
do
   trace.fragmentOpen
     ->tracer
       (# 
       do
          'Fragment-list open of '->dmp.putText;
          n[]->dmp.putText;
          ' in '->dmp.putText;
          fullName->dmp.putText;
          
       #);
   loop:
     (# 
     do
        scan
          (# l: ^fragmentlink; found: @boolean
          do
             (if current.type
              // formType then current.name[]->n.equalNCS->found
              else
                 current.name[]->n.equal->found
             if);
             (if found
              // true then
                 (if (current.f[]->f[])
                  // none then error[]->current.open; current.f[]->f[]
                  else
                     (if current.type
                      // linkType then
                         f[]->l[];
                         (if l.f[]
                          // none then
                             error[]->current.open; current.f[]->f[]
                         if)
                     if)
                 if);
                 trace.fragmentOpen
                   ->tracer (#  do 'Found in list'->dmp.putText;  #);
                 leave loop
             if)
          #);
        (* if we are here, the local name of the fragment could not be
         * found in the fragmentList. We will newer the less try and see if
         * we can find the fragment
         *)
          (#
             g: ^fragmentGroup;
             fName,origFName: ^text;
             dirInx,groupInx,dotInx: @integer;
             fileExist: (# f: @file enter f.name exit f.entry.exists #);
             isFile: (# f: @file enter f.name exit f.entry.isFile #);
             fileReadable:
               (# f: @file enter f.name exit f.entry.readable #)
          do
             &Element[]->e[];
             none ->e.f[];
             (*
              (if this(fragmentGroup)[]
              //top[] then 
              n.copy -> fName[]; fName[] -> e.name[];  
              else
              *)
             fullName->fName[];
             fName.copy->fName[];
             directoryChar->fName.put;
             n[]->fName.CopyAppend->fName[];
             n.copy->e.name[];
             (*if);*)
             fName.copy->origFName[];
             try:
             (if true
              // (astFileExtension->fName.CopyAppend->fileExist) then
              (* o.k. we are in real group *)
                 groupType->e.type;
                 e[]->append;
                 error[]->e.open->f[];
                 MarkAsChanged;
                 
              // ('.text'->fName.CopyAppend->fileExist) then
                 groupType->e.type; e[]->append; error[]->e.open->f[]; 
              else
                 loop:
                 (if 0
                  // 0 then
                     grammarTable.scan
                       (# name: ^text
                       do
                          (if
                          (current.suffix->fName.CopyAppend->name[]->fileExist)
                           // true then
                              groupType->e.type;
                              e[]->append;
                              error[]->e.open->f[];
                              leave loop
                          if)
                       #);
                     0->dotInx;
                     '.'->fName.findCh (#  do inx->dotInx #);
                     (if dotInx > 1
                      // true then
                         0->dirInx->groupInx;
                         directoryChar
                           ->fName.findCh (#  do inx->groupInx #);
                         thePathHandler.directoryChar
                           ->fName.findCh (#  do inx->dirInx #);
                         (if true
                          // (dirInx > groupInx) then (* xx-yy/zz *)
                             (if true
                              // (dotInx > dirInx) then (* xx-yy/zz.rr *)
                                 (dotInx,fName.length)->fName.delete;
                                 restart try
                             if)
                          // (dirInx < groupInx) then (* xx/yy-zz *)
                             (if true
                              // (dotInx > groupInx) then (* xx/yy-zz.rr *)
                                 (dotInx,fName.length)->fName.delete;
                                 restart try
                              // (dotInx > dirInx) then (* xx/yy.rr-zz *)
                                 (dotInx,groupInx-1)->fName.delete; restart try
                             if)
                          else
                         (* xx.rr *)
                             (dotInx,fName.length)->fName.delete; restart try
                         if)
                     if);
                     (* well. we did not find the file. If the file ifself
                      * exist, lets us try to parse it
                      *)
                     origFName[]->fName[];
                     (if (fName[]->fileExist)
                      // true then
                         (if (fName[]->isFile)
                          // true then
                             (if (fName[]->fileReadable)
                              // true then
                                   (# fg: ^fragmentGroup; dotInx: @integer
                                   do
                                      '.'
                                        ->fName.findCh
                                          (#  do inx->dotInx #);
                                      (if (dotInx > 1)
                                       // true then
                                       (* >1 to avoid empty filename before '.' *)
                                          newFragmentGroup->fg[];
                                          (1,dotInx-1)->fName.sub->e.name[];
                                          e.name[]->fg.name;
                                          e.name[]->fg.fullNameT[];
                                          (notificationNumbers.startingParsing,
                                           '')->catcher;
                                          theParse:
                                          (if
                                          ((fName[],error[])
                                             ->fg.parse
                                               (#
                                                  parseErrors::< 
                                                    (# 
                                                    do
                                                       (errorNumbers.
                                                          parseErrors,
                                                        ' Parse errors ')
                                                         ->catcher;
                                                       false->ok;
                                                       true->continue
                                                    #);
                                                  doubleFormDeclaration::< 
                                                    (# 
                                                    do
                                                       (errorNumbers.
                                                          doubleFormDeclaration,
                                                        ' Double declaration of form ')
                                                         ->catcher;
                                                       true->continue
                                                    #);
                                                  
                                               #))
                                           // true then
                                              fg[]->f[];
                                              groupType->e.type;
                                              e[]->append;
                                              
                                          if)
                                      if)
                                   #)
                              else
                                   (# t: @text
                                   do
                                      'No read access to the file: "'->t;
                                      fName[]->t.append;
                                      '"'->t.putline;
                                      (errorNumbers.noReadAccess,t[])->catcher
                                   #)
                             if)
                          else
                               (# t: @text
                               do
                                  'Filename "'->t;
                                  fName[]->t.append;
                                  '" refers to a directory, not a file'
                                    ->t.putline;
                                  (errorNumbers.otherFileError,t[])->catcher
                               #)
                         if)
                      else
                           (# t: @text
                           do
                              'Filename "'->t;
                              fName[]->t.append;
                              '" does not exist'->t.putline;
                              (errorNumbers.notExisting,t[])->catcher
                           #)
                     if)
                 if)
             if)
          #)
     #);
   (if f[] // none then  else true->f.isOpen if);
   trace.fragmentOpen
     ->tracer
       (# 
       do
          (if f[]
           // none then 'FFAILED: '->dmp.putText
           else
              'FSUCCEEDED: '->dmp.putText; 
          if);
          'Fragment-list open of '->dmp.putText;
          n[]->dmp.putText;
          ' in '->dmp.putText;
          fullName->dmp.putText
       #);
     

-- fragmentGroupFragmentListDescriptorInsertFragmentBody: Descriptor --
(# oldCatcher: ^handler
do
   (if theCatcher[]
    // none then
       theCatcher[]->oldCatcher[]; addFragmentHandler[]->theCatcher[]
   if);
   l:
   (if 0
    // 0 then
       scan
         (# 
         do
            (if (f.name->current.name.equalNCS)
             // true then
                current[]->newElement[];
                  (# t: @text
                  do
                     'Fragment: "'->t;
                     f.name->t.append;
                     '" is already in this fragment group: "'->t.append;
                     THIS(fragmentGroup).name->t.append;
                     '"'->t.append;
                     t[]->alreadyThere
                  #);
                leave l
            if)
         #);
       &Element[]->newElement[];
       f.name->newElement.name[];
       INNER insertFragment;
       
   if);
   f[]->newElement.f[];
   f.type->newElement.type;
   (if f.type
    // linktype then
         (# l: ^fragmentLink
         do
            f[]->l[];
            l.fullNameOfLink[]->newElement.fullNameOfLink[];
            l.localName[]->newElement.localName[];
            
         #);
       
   if);
   THIS(fragmentGroup)[]->f.father;
   f.markAsChanged;
   (if theCatcher[]
    // addFragmentHandler[] then oldCatcher[]->theCatcher[]
   if);
   
#)  

-- fragmentGroupFragmentListDescriptorInsertFragmentCatcherBody: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if true
        // no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- FragmentGroupSaveAs: Descriptor --
(# savename1,savename2: ^text; 
do
   fullnameT.copy->savename1[];
   nameT.copy->savename2[];
   fullname[]->fullnameT[];
   fullname[]->nameT[];
   pack;
   savename1.copy->fullnameT[];
   savename2.copy->nameT[];
   
#)  

-- FragmentGroupSaveBackup: Descriptor --
(#  do ext.copy->backUpExt[]; pack; none ->backUpExt[];  #)  

-- FragmentGroupRestoreBackup: Descriptor --
(#
   diskFile: @file (# binary::< trueObject #);
   name: ^Text;
   oldDoRealOpen: @boolean;
   
do
   diskFileName->name[];
   ext[]->name.copyappend->name[];
   name[]->diskFile.name;
   init;
   ext.copy->backUpExt[];
   doRealOpen->oldDoRealOpen;
   true->doRealOpen;
   screen[]->unpack;
   oldDoRealOpen->doRealOpen;
   none ->backUpExt[];
   
#)  

-- fragmentGroupDiskFullName: DoPart --
do
   astFileExtension->(fullName).copyAppend->t[];
   (if backUpExt[] <> none then backupExt[]->t.append if);
     

-- fragmentGroupTextFileNameBody: DoPart --
do
   l:
   (if defaultGrammar[]
    // none then
       grammarTable.scan
         (# name: @text; f: @file
         do
            fullName->t[];
            t->t;
            current.suffix->t.append;
            t.copy->f.name;
            (if f.entry.exists
             // true then current[]->defaultGrammar[]; leave l
            if);
            
         #);
       fullName->t[];
       t->t;
       '.text'->t.append;
       
    else
       fullName->t[]; t->t; defaultGrammar.suffix->t.append
   if);
     

-- fragmentGroupIsRealOpenBody: DoPart --
do
   scanner: fragmentList.scan
     (# 
     do
        (if current.type = formType then
            (if (current.f[] <> none ) then true->isOpen; leave scanner if)
        if)
     #)  

-- fragmentGroupRealOpenBody: Descriptor --
(#
   f: @file
     (#
        accessError::< 
          (# 
          do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
          #);
        binary::< trueObject
     #);
   getRep: @f.getRep;
   b: [2] @integer;
   garbagefl: ^fragmentListDescription;
   garbageProp: ^propertyList;
   
do
   diskFileName->f.name;
   trace.FragmentOpen
     ->tracer
       (# 
       do 'OpenRead fragmentGroup-file: '->dmp.puttext; f.name->dmp.puttext
       #);
   (if (f.entry.isFile)
    // true then
       (if (f.entry.readable)
        // true then f.openRead
        else
             (# t: @text
             do
                'No read access to the file: "'->t;
                f.name->t.append;
                '"'->t.putline;
                (errorNumbers.noReadAccess,t[])->catcher
             #)
       if)
    else
         (# t: @text
         do
            'Filename "'->t;
            f.name->t.append;
            '" refers to a directory, not a file'->t.putline;
            (errorNumbers.otherFileError,t[])->catcher
         #)
   if);
   (@@ b[1],b.range)->getRep;
   (if (b[2] > repS.r.range)
    // true then b[2]-repS.r.range->repS.extend; 
   if);
   0->repS.top;
   (@@ repS.r[1],b[2])->getRep;
   (* get r from f *)
   &fragmentListDescription[]->garbagefl[];
   repS[]->garbagefl.repRestore;
   none ->garbagefl[];
   &propertyList[]->garbageProp[];
   repS[]->garbageProp.repRestore;
   none ->garbageprop[];
   fragmentList.scan
     (# ff: ^fragmentForm
     do
        (if current.type
         // formType then
            screen[]->current.open;
            current.f[]->ff[];
            repS[]->ff.repRestoreStruct
        if)
     #);
   fragmentList.scan
     (# ff: ^fragmentForm
     do
        (if current.type
         // formType then
            current.f[]->ff[];
            (@@ ff.a[1],ff.curTop)->getRep;
            ff.rootInx->ff.indexToNode->ff.root[];
            
        if)
     #);
   f.close;
   
#)  

-- fragmentGroupPackBody: DoPart --
do
   l:
     (#
        f: @file
          (#
             accessError::< 
               (# 
               do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
               #);
             writeError::< 
               (# 
               do (errorNumbers.noWriteAccess,msg[])->catcher; leave l
               #);
             readError::< 
               (# 
               do (errorNumbers.noReadAccess,msg[])->catcher; leave l
               #);
             EOSError::< 
               (#  do (errorNumbers.EOSerror,msg[])->catcher; leave l #);
             noSuchFileError::< 
               (#  do (errorNumbers.noSuchFile,msg[])->catcher; leave l #);
             fileExistsError::< 
               (#  do (errorNumbers.fileExists,msg[])->catcher; leave l #);
             noSpaceError::< 
               (#  do (errorNumbers.noSpaceLeft,msg[])->catcher; leave l #);
             otherError::< 
               (# 
               do (errorNumbers.otherFileError,msg[])->catcher; leave l
               #);
             binary::< trueObject
          #);
        putRep: @f.putRep;
        b: [2] @integer;
        dirWriteable: (# f: @file enter f.name exit f.entry.writeable #)
     do
        (if isDirectory
         // false then
            0->repS.top;
            repS[]->fragmentList.repSave;
            repS[]->prop.repSave;
            fragmentList.scan
              (# ff: ^fragmentForm
              do
                 (if current.type
                  // formType then current.f[]->ff[]; repS[]->ff.repSaveStruct
                 if)
              #);
            groupBlackNumber->b[1];
            repS.top->b[2];
            diskFileName->f.name;
            trace.FragmentOpen
              ->tracer
                (# 
                do
                   'OpenWrite fragmentGroup-file: '->dmp.puttext;
                   f.name->dmp.puttext
                #);
            (if (f.entry.path.head->dirWriteable)
             // true then
                (if f.entry.writeable
                 // true then f.openWrite
                 else
                      (# t: @text
                      do
                         'No write access to the file: "'->t;
                         f.name->t.append;
                         '"'->t.putline;
                         (errorNumbers.noWriteAccess,t[])->catcher;
                         leave l
                      #)
                if)
             else
                  (# t: @text
                  do
                     'No write access to the directory: "'->t;
                     f.entry.path.head->t.append;
                     '"'->t.putline;
                     (errorNumbers.noWriteAccess,t[])->catcher;
                     leave l
                  #)
            if);
            (@@ b[1],b.range)->putRep;
            (@@ repS.r[1],repS.top)->putRep;
            (* save r on f *)
            fragmentList.scan
              (# ff: ^fragmentForm
              do
                 (if current.type
                  // formType then
                     current.f[]->ff[]; (@@ ff.a[1],ff.curTop)->putRep
                 if)
              #);
            f.close;
            (if backUpExt[] = none then f.entry.modTime->modTime if)
        if)
     #)  

-- fragmentGroupUnpackBody: Descriptor --
(#
   f: @file
     (#
        accessError::< 
          (# 
          do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
          #);
        binary::< trueObject
     #);
   textFile: @file
     (#
        accessError::< 
          (# 
          do (errorNumbers.noReadAccess,msg[])->catcher; true->continue
          #)
     #);
   t,s: ^text;
   
do
   fragmentlist.clear;
   diskFileName->t[];
   t.copy->f.name;
   textFileName->t[];
   t.copy->textFile.name;
   (if
   ((textFile.entry.ModTime (# error::<  (#  do true->continue #) #) >
     f.entry.ModTime (# error::<  (#  do true->continue #) #)) or
    (options.forceParse))
    // true then
       (if textFile.entry.exists
        // true then
           (if textFile.entry.isFile
            // true then
               (if textFile.entry.readable
                // true then
                   (notificationNumbers.startingParsing,'')->catcher;
                   trace.onParse
                     ->silentTracer
                       (# 
                       do
                          'parsing "'->dmp.putText;
                          fullName->dmp.putText;
                          '"'->dmp.put
                       #);
                   theParse:
                   (if
                   ((textfile.name,error[])
                      ->parse
                        (#
                           parseErrors::< 
                             (# 
                             do
                                (errorNumbers.parseErrors,' Parse errors ')
                                  ->catcher;
                                false->ok;
                                true->continue
                             #);
                           doubleFormDeclaration::< 
                             (# 
                             do
                                (errorNumbers.doubleFormDeclaration,
                                 ' Double declaration of form ')->catcher;
                                true->continue
                             #)
                        #))
                    // true then
                       trace.onParse->silentTracer (#  do dmp.newLine #)
                   if)
                else
                     (# t: @text
                     do
                        'No read access to the file: "'->t;
                        textFile.name->t.append;
                        '"'->t.putline;
                        (errorNumbers.noReadAccess,t[])->catcher
                     #)
               if)
            else
                 (# t: @text
                 do
                    'Filename "'->t;
                    textFile.name->t.append;
                    '" refers to a directory, not a file'->t.putline;
                    (errorNumbers.otherFileError,t[])->catcher
                 #)
           if)
        else
             (# t: @text
             do
                'Filename "'->t;
                textFile.name->t.append;
                '" does not exist'->t.putline;
                (errorNumbers.noSuchFile,t[])->catcher
             #)
       if)
    else
       (if f.entry.exists
        // true then
             (# getRep: @f.getRep; b: [2] @integer
             do
                trace.FragmentOpen
                  ->tracer
                    (# 
                    do
                       'OpenRead(unpack) fragmentGroup-file: '->dmp.puttext;
                       f.name->dmp.puttext
                    #);
                (if f.entry.isFile
                 // true then
                    (if (f.entry.readable)
                     // true then f.openRead
                     else
                          (# t: @text
                          do
                             'No read access to the file: "'->t;
                             f.name->t.append;
                             '"'->t.putline;
                             (errorNumbers.noReadAccess,t[])->catcher
                          #)
                    if)
                 else
                      (# t: @text
                      do
                         'Filename "'->t;
                         f.name->t.append;
                         '" refers to a directory, not a file'->t.putline;
                         (errorNumbers.otherFileError,t[])->catcher
                      #)
                if);
                (@@ b[1],b.range)->getRep;
                (if (b[1] <> groupBlackNumber)
                 // true then
                      (# t: @text
                      do
                         ' Trying to access a group file with wrong magic number "'
                           ->t;
                         fullName->t.append;
                         '"'->t.put;
                         (errorNumbers.badformat,t[])->catcher;
                         
                      #);
                    
                if);
                (if (b[2] > repS.r.range)
                 // true then b[2]-repS.r.range->repS.extend; 
                if);
                0->repS.top;
                (@@ repS.r[1],b[2])->getRep;
                (* get r from f *)
                repS[]->fragmentList.repRestore;
                repS[]->prop.repRestore;
                (if doRealOpen
                 // true then
                    fragmentList.scan
                      (# ff: ^fragmentForm
                      do
                         (if current.type
                          // formType then
                             current.f[]->ff[]; repS[]->ff.repRestoreStruct
                         if)
                      #);
                    fragmentList.scan
                      (# ff: ^fragmentForm
                      do
                         (if current.type
                          // formType then
                             current.f[]->ff[];
                             (@@ ff.a[1],ff.curTop)->getRep;
                             ff.rootInx->ff.indexToNode->ff.root[];
                             (if defaultGrammar[] = none then
                                 ff.grammar[]->defaultGrammar[]
                             if);
                             
                         if)
                      #);
                    
                if);
                f.close;
                f.entry.modTime->modTime;
                
             #)
       if)
   if);
   
#)  

-- fragmentGroupInitBody: DoPart --
do
   GroupType->FragType;
   false->isDirectory;
   &fragmentListDescription[]->fragmentList[];
   fragmentList.init;
     

-- fragmentGroupBindBody: Descriptor --
(# fName: ^text
do
   F.name->fName[];
   L: scanSlots
     (# 
     do
        (if (current.Name->fName.equalNCS)
         // true then current[]->op[]->f.binding[]; leave l
        if)
     #)
#)  

-- fragmentGroupGetBindingBody: DoPart --
do
   trace.GetBinding
     ->tracer
       (# 
       do
          'GetBinding of '->dmp.putText;
          (0,dmp[])->sl.dump;
          ' for '->dmp.putText;
          THIS(fragmentGroup).fullName->dmp.putText;
          
       #);
   THIS(fragmentGroup)[]->markRelatedFragments;
   (* mark visible groups *)
   Mark.Scan (* scan visible groups for forms *)
     (#
        currentScan: current.Scan
          (# F: ^FragmentForm; B: ^SlotDesc
          do
             (if current.FragType
              // FormType then
                 current[]->f[];
                 (if f.binding[]
                  // none then f[]->THIS(currentScan).current.bind
                 if);
                 f.binding[]->b[];
                 (if (b[] <> none )
                  // true then
                     (if (b[]->sl.equal) // true then current[]->found if)
                 if)
             if)
          #)
     do currentScan
     #)  

-- fragmentGroupGetBindingMark: DoPart --
do
   Insert:
     (# R: ^Elm
     do
        false->inserted;
        head[]->R[];
        L:
        (if (R[] <> none )
         // true then
            (if R.F[] // F[] then leave insert if); R.succ[]->R[]; restart L
        if);
        (* not found *)
        &Elm[]->R[];
        F[]->R.F[];
        head[]->R.succ[];
        R[]->Head[];
        True->inserted;
        trace.GetBindingMark
          ->tracer
            (#  do 'marked: '->dmp.putText; f.fullname->dmp.putText;  #);
        
     #)  

-- fragmentGroupGetBindingMarkScan: Descriptor --
(# R: ^Elm
do
   head[]->R[];
   L:
   (if (R[] <> none )
    // true then R.F[]->current[]; INNER scan; R.succ[]->R[]; restart L
   if)
#)  

-- fragmentGroupGetBetaBindingsBody: Descriptor --
(# G: ^FragmentGroup
do
   (if F.FragType
    // groupType then
       (if (F[]->G[]->mark)
        // true then
           G.Scan
             (# FL: ^FragmentLink
             do
                (if current.FragType
                 // LinkType then
                    current[]->FL[]; FL.F[]->markRelatedFragments
                if)
             #);
           (if g.origin // none then screen[]->g.setupOrigin if);
           G.origin->markRelatedFragments
       if)
   if)
#)  

-- fragmentFormCategoryBody: DoPart --
do (if root[] // none then 0->sy else root.symbol->sy if)  

-- fragmentFormRecomputeSlotChain: Descriptor --
(# theExpanded: ^expanded
do
   0->firstSlot;
   (if root.kind = kinds.interior then
       root[]->theExpanded[];
       unExpanded
         ->theExpanded.suffixWalkForProd
           (# scanCat:: unExpanded; theSlot: ^slotDesc; 
           do
              (if current.isSlot then
                  current.theSlot->theSlot[];
                  firstSlot->a[theSlot.index+offset.usage];
                  theSlot.index->firstSlot;
                  
              if);
              
           #);
       
   if)
#)  

-- fragmentFormScanSlotsBody: DoPart --
do
   firstSlot->inx;
   loop:
   (if (inx = 0)
    // false then
       inx->indexToNode->current[];
       current.usageInx->inx;
       INNER scanSlots;
       restart loop
   if);
     

-- fragmentFormIndexToNodeBody: Descriptor --
(#
   symbol,val: @integer;
   errorMsg:
     (# n: @integer; msg: ^text
     enter n
     do
        '*** Error in IndexToNode:'->msg[];
        '\nIndex='->msg.puttext;
        inx->msg.putint;
        '\nSymbol='->msg.puttext;
        symbol->msg.putint;
        '\nVal='->msg.puttext;
        val->msg.putint;
        msg.newline
     exit msg[]
     #)
do
   l:
   (if true
    // (0 < inx) and (inx <= a.range) then
       a[inx]->val->tos'%GetSignedBits[4,12]'->symbol;
       (* inline expansion of inx -> getSymbol -> symbol *)
       (if true
        // (0 < symbol) and (symbol <= grammar.genRefArray.range) then
           (if grammar.genRefArray[symbol]->as[]
            // none then (* IndexToNode: genRefArray problem *)
               errorMsg->grammarGenRefArrayError; leave l
           if)
        else
           (if symbol
            // prodNo.unExpanded then
               &UnExpanded[]->as[]
            // prodNo.optional then
               &Optional[]->as[]
            // prodNo.nameDecl then
               &NameDecl[]->as[]
            // prodNo.nameAppl then
               &NameAppl[]->as[]
            // prodNo.string then
               &String[]->as[]; 
            // prodNo.Const then
               &Const[]->as[]; 
            // prodNo.Comment then
               &Comment[]->as[]
            // prodNo.SlotDesc then
               &SlotDesc[]->as[]
            else
           (* IndexToNode: no match for symbol! *)
               none ->as[]; errorMsg->noSuchSymbol; leave l
           if)
       if);
       inx->as.index;
       THIS(fragmentForm)[]->as.frag[]
    // (0 = inx) then (* Zero index is the same as a NONE ast *)
       none ->as[]
    else
   (* IndexToNode: index out of range *)
       none ->as[]; errorMsg->indexOutOfRange
   if)
#)  

-- fragmentFormInitBody: DoPart --
do 2->curTop; formtype->fragtype; import.init; INNER init  

-- fragemntFormResetBody: DoPart --
do import.makeNull; 'Semanticerrors'->prop.deleteProp  

-- topTableOpenBody: DoPart --
do
   trace.topOpen
     ->tracer
       (# 
       do
          'top-table open of '->dmp.putText;
          fullname[]->dmp.putText;
          dmp.newline;
          scan
            (#  do current.fullname[]->dmp.putline #);
          
       #);
   (* is the group already open? *)
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
       (#
          predicate::<  (#  do fullname[]->current.fullname.equal->value #);
          
       do current.g[]->g[]; 
       #);
   none ->dummy.fullname[];
   (if g[]
    // none then
    (* if we are here, the fragment could not be
     * found in the fragmentList. 
     * Try look at the disk for the file.
     *)
         (# fileExist: (# f: @file enter f.name exit f.entry.exists #); 
         do
            &Element[]->e[];
            fullName.copy->e.fullName[];
            (if true
             // (astFileExtension->fullName.CopyAppend->fileExist) then
                trace.topOpen
                  ->tracer (#  do 'opening .ast file...'->dmp.puttext #);
                (* o.k. we are in real group *)
                error[]->e.open->g[];
                e[]->insert;
                
             // ('.bet'->fullName.CopyAppend->fileExist) then
                trace.topOpen
                  ->tracer (#  do 'opening .bet file...'->dmp.puttext #);
                error[]->e.open->g[];
                e[]->insert;
                
             // ('.text'->fullName.CopyAppend->fileExist) then
                trace.topOpen
                  ->tracer (#  do 'opening .text file...'->dmp.puttext #);
                error[]->e.open->g[];
                e[]->insert;
                
             else
                loop: grammarTable.scan
                  (# 
                  do
                     (if (current.suffix->fullName.CopyAppend->fileExist)
                      // true then
                         trace.topOpen
                           ->tracer
                             (# 
                             do
                                'opening '->dmp.puttext;
                                current.suffix->dmp.puttext;
                                ' file...'->dmp.puttext;
                                
                             #);
                         error[]->e.open->g[];
                         e[]->insert;
                         leave loop
                     if)
                  #);
                (if g[]
                 // none then
                      (#
                         t: ^Text;
                         dotInx: @integer;
                         fg: ^FragmentGroup;
                         isFile:
                           (# f: @file enter f.name exit f.entry.isFile #);
                         fileReadable:
                           (# f: @file
                           enter f.name
                           exit f.entry.readable
                           #)
                      do
                         (if not (fullname[]->fileExist) then
                             'Filename "'->t[];
                             fullName[]->t.append;
                             '" could not be opened using any known grammar'
                               ->t.putline;
                             (errorNumbers.notExisting,t[])->theCatcher
                         if);
                         (if not (fullname[]->isFile) then
                             'Filename "'->t[];
                             fullName[]->t.append;
                             '" refers to a directory, not a file'->t.putline;
                             (errorNumbers.otherFileError,t[])->theCatcher
                         if);
                         (if not (fullname[]->fileReadable) then
                             'No read access to the file: "'->t[];
                             fullName[]->t.append;
                             '"'->t.putline;
                             (errorNumbers.noReadAccess,t[])->theCatcher
                         if);
                         (* ok. try parse the file *)
                         (*'ok. try parse the file'->screen.putline;*)
                         '.'->fullName.findCh (#  do inx->dotInx #);
                         (if (dotInx > 1)
                          // true then
                          (* >1 to avoid empty filename before '.' *)
                             newFragmentGroup->fg[];
                             (1,dotInx-1)->fullName.sub->e.fullname[];
                             e.fullname[]->fg.fullnameT[]->fg.nameT[];
                             (notificationNumbers.startingParsing,'')
                               ->theCatcher;
                             theParse:
                             (if
                             ((fullName[],error[])
                                ->fg.parse
                                  (#
                                     parseErrors::< 
                                       (# 
                                       do
                                          (errorNumbers.parseErrors,
                                           ' Parse errors ')->theCatcher;
                                          false->ok;
                                          true->continue
                                       #);
                                     doubleFormDeclaration::< 
                                       (# 
                                       do
                                          (errorNumbers.doubleFormDeclaration,
                                           ' Double declaration of form ')
                                            ->theCatcher;
                                          true->continue
                                       #);
                                     
                                  #)) then
                                 fg[]->e.g[]->g[]; e[]->insert; 
                             if)
                         if)
                      #)
                if);
                
            if)
         #)
   if);
   (if g[] <> none then true->g.isOpen if);
   trace.topOpen
     ->tracer
       (# 
       do
          (if g[]
           // none then 'F_FAILED: '->dmp.putText
           else
              'F_SUCCEEDED: '->dmp.putText; 
          if);
          'Top-Table open of '->dmp.putText;
          fullName[]->dmp.putText;
          
       #);
     

-- topTableElementOpen: DoPart --
do
   trace.topOpen
     ->tracer
       (# 
       do 'top-table-element-open of '->dmp.putText; fullname[]->dmp.putText
       #);
   (if g[]
    // none then
       newFragmentGroup->g[];
       fullname.copy->g.fullnameT[]->g.nameT[];
       error[]->g.unPack;
       trace.topOpen
         ->tracer
           (# 
           do
              'top-table-element-unpack of '->dmp.putText;
              g.fullname->dmp.putText
           #)
   if)  

-- topTableFindBody: DoPart --
do
   fullname[]->dummy.fullname[];
   dummy[]->hashfunction
     ->findIndexed
       (#
          predicate::<  (#  do fullname[]->current.fullname.equal->value #);
          
       do current.g[]->g[]; 
       #);
     

-- topOpenCatcherBody: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if true
        // no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

-- topInitBody: DoPart --
do groupTable.init; &FragmentGroup[]->topGroup[];   

-- topOpenBody: Descriptor --
(# oldCatcher: ^handler; fullName: ^Text; 
do
   trace.TopOpen
     ->tracer
       (#  do 'top-open of '->dmp.putText; filename[]->dmp.putText #);
   (if theCatcher[]
    // none then theCatcher[]->oldCatcher[]; openCatcher[]->theCatcher[]
   if);
   0->fileName.pos;
   (if fileName.getNonBlank
    // ascii.fs then
         (# msg: @text
         do
            'Fragment file name is empty: '->msg;
            fullname[]->msg.putLine;
            (errorNumbers.notExisting,msg[])->theCatcher
         #)
   if);
   (if (1->fileName.inxGet) <> '/' then
       fileName[]->expandToFullPath->fullName[]; 
    else
       fileName.copy->fullName[]; 
   if);
   (fullName[],error[])->groupTable.open->g[];
   (if g[]
    // none then
         (# msg: @text
         do
            'Fragment file not found in open: '->msg;
            fullName[]->msg.putLine;
            (errorNumbers.notExisting,msg[])->theCatcher
         #)
    else
       true->g.isOpen; topGroup[]->g.father; 
   if);
   (if theCatcher[] // openCatcher[] then oldCatcher[]->theCatcher[] if);
   trace.topOpen
     ->tracer
       (# 
       do
          (if g[]
           // none then 'FAILED: '->dmp.putText
           else
              'SUCCEEDED: '->dmp.putText; 
          if);
          'top-open of '->dmp.putText;
          fullName[]->dmp.putText;
          
       #);
   
#)  

-- topNewGroup: DoPart --
do
   (if (fullname[]->isOpen)
    // none then
       newFragmentGroup->fg[];
       fullname.copy->fg.name;
       fullname.copy->fg.fullnameT[];
       fg[]->insert;
       (* insert into top table *)
       
    else
         (# msg: @text
         do
            'top.newGroup: '->msg.puttext;
            fullname[]->msg.puttext;
            'is already open'->msg.putline;
            msg[]->alreadyOpen;
            
         #);
       
   if);
     

-- topCloseBody: Descriptor --
(# 
do
   fg.nameT[]->groupTable.dummy.fullname[];
   groupTable.dummy[]->groupTable.hashfunction
     ->groupTable.findIndexed
       (#
          predicate::<  (#  do fg.nameT[]->current.fullname.equal->value #);
          
       do current.g.close; current[]->groupTable.delete; 
       #);
   
#)  

-- topDeleteBody: Descriptor --
(# 
do
   (if fg.fullnameT[]
    // none then 'top.delete: fragmentgroup name is NONE'->screen.putline; 
    else
       (if fg.fullnameT.length
        // 0 then 'top.delete: fragmentgroup name is empty'->screen.putline; 
        else
           fg.fullnameT[]->groupTable.dummy.fullname[];
           groupTable.dummy[]->groupTable.hashfunction
             ->groupTable.findIndexed
               (#
                  predicate::< 
                    (# 
                    do
                       groupTable.dummy.fullname[]->current.fullname.equal
                         ->value
                    #);
                  
               do current[]->groupTable.delete; 
               #);
           
       if)
   if);
   
#)  

-- topInsertBody: Descriptor --
(# e: ^groupTable.Element; 
do
   (if fg.fullnameT[]
    // none then 'top.delete: fragmentgroup name is NONE'->screen.putline; 
    else
       (if fg.fullnameT.length
        // 0 then 'top.delete: fragmentgroup name is empty'->screen.putline; 
        else
           fg.fullnameT[]->groupTable.dummy.fullname[];
           groupTable.dummy[]->groupTable.hashfunction
             ->groupTable.findIndexed
               (#
                  predicate::< 
                    (# 
                    do
                       groupTable.dummy.fullname[]->current.fullname.equal
                         ->value
                    #);
                  
               do current[]->e[]; 
               #);
           (if e[]
            // none then
               &groupTable.Element[]->e[];
               fg.fullNameT.copy->e.fullname[];
               fg[]->e.g[];
               e[]->groupTable.insert;
               
            else
           (* fragmentgroup already exists *)
               'WARNING: tried to insert fragmentgroup already in top-table: '
                 ->screen.puttext;
               fg.fullname->screen.putline;
               
           if);
           
       if)
   if);
   
#)  

-- topIsOpen: DoPart --
do
   fullname[]->groupTable.dummy.fullname[];
   (if groupTable.dummy.fullname[]
    // none then 'top.isOpen: fragmentgroup name is NONE'->screen.putline; 
    else
       (if groupTable.dummy.fullname.length
        // 0 then 'top.isOpen: fragmentgroup name is empty'->screen.putline; 
        else
           groupTable.dummy[]->groupTable.hashfunction
             ->groupTable.findIndexed
               (#
                  predicate::< 
                    (# 
                    do
                       groupTable.dummy.fullname[]->current.fullname.equal
                         ->value
                    #);
                  
               do current.g[]->fg[]; 
               #);
           
       if)
   if)  

-- astLevelIsRefencedBody: DoPart --
do
   L: Top.groupTable.Scan
     (#
        testForm:
          (# ff: ^fragmentForm
          enter ff[]
          do
             ff.import.scan
               (# 
               do (if current.g[] // fx[] then true->found; leave l if)
               #)
          #);
        testLink:
          (# fl: ^fragmentLink
          enter fl[]
          do (if FL.F[] // FX[] then true->found; leave L if)
          #);
        testGroup:
          (# fg: ^fragmentGroup
          enter fg[]
          do
             (if fg.origin // FX[] then True->found; leave L if);
             fg.fragmentList.Scan
               (# 
               do
                  (if (current.f[] = none )
                   // false then
                      (if current.type
                       // linkType then
                          current.f[]->testLink
                       // formType then
                          current.f[]->testForm
                       // groupType then
                          current.f[]->testGroup
                      if)
                  if)
               #)
          #);
        
     do (if (current.g[] = none ) // false then current.g[]->testGroup if)
     #)  

-- AstInterfaceExceptionBody: DoPart --
do
   (if m[] // none then  else m->msg if);
   INNER AstInterfaceException;
   'Yggdrasil stops'->msg.putText  

-- AstInterfaceNotificationBody: DoPart --
do (if m[] // none then  else m->msg if); INNER AstInterfaceNotification  

-- astlevelInitBody: Descriptor --
(#
   theFirstErrorReporter: errorReporter
     (#
        forEachError::< 
          (#
             l: @text;
             lastPos: @integer;
             t,cd: ^text;
             tabCount: @integer;
             ch: @char
          do
             0->errorLines.pos;
             loop:
             (if 1
              // 1 then
                 '#'->errorStream.put;
                 startLineNo
                   ->errorStream.putInt
                     (# format::<  (#  do 4->width #) #);
                 ' '->errorStream.put;
                 startLineNo+1->startLineNo;
                 errorLines.pos->lastPos;
                 &text[]->t[];
                 L:
                 (if errorLines.eos
                  // true then
                     leave L
                  // false then
                     (if ((errorLines.get->ch) = ascii.newLine)
                      // false then ch->t.put; restart L
                     if)
                 if);
                 (* Changed from the following by JLK (2/11/92)
                  * L: (if ((errorLines.get -> ch) = ascii.newLine) 
                  *     // false then 
                  *        ch -> t.put;
                  *        (if errorLines.eos//false then restart L if)
                  *    if);
                  *)
                 t[]->errorStream.putLine;
                 (if errorLines.eos // false then restart loop if)
             if);
             0->tabCount;
             ascii.ht->t.findCh (#  do 1+tabCount->tabCount #);
             '# ****'->errorStream.putText;
             (for tabCount repeat ascii.ht->errorStream.put for);
             (for errorPos-lastPos-3-tabCount repeat '*'->errorStream.put for);
             ' ^'->errorStream.putLine;
             '#  Expected symbol'->errorStream.putText;
             (if legalSymbols.terminals.range
              // 1 then ': '->errorStream.putText; 
              else
                 's: '->errorStream.putText
             if);
             (for i: legalSymbols.terminals.range repeat
               legalSymbols.terminals[i][]->errorStream.putText;
               (if (i = legalSymbols.terminals.range)
                // false then ' '->errorStream.put
               if)
             for);
             errorStream.newLine;
             (if frag.fatherR[]
              // none then
              (* we have a stand alone fragmentForm.  Do not write file and
               * line-number information
               *)
                 
              else
                 ' File "'->errorStream.putText;
                 frag.textFileName->t[];
                 thePathHandler.currentDirectory->cd[];
                 (frag.textFileName,thePathHandler.currentDirectory)
                   ->thePathHandler.convertFilePath->errorStream.putText;
                 '"; Line '->errorStream.putText;
                 startLineNo-1->errorStream.putInt;
                 errorStream.newLine;
                 
             if);
             
          #);
        
     #);
   
do
   (if isBigEndian
    // true then
       '.ast'->astFileExt[] (* used to be .group *) ;
       '.btab'->parserFileExt[];
       '.ptbl'->ppFileExt[];
       
    else
       '.astL'->astFileExt[]; '.btabL'->parserFileExt[]; '.ptblL'->ppFileExt[]; 
   if);
   true->doRealOpen;
   (*&text[] -> top.fullNameT[];
    * '' -> top.fullNameT;
    *)
   (for i: 256 repeat i->CommentSieve[i] for);
   32->CommentSieve[1];
   32->CommentSieve[2];
   32->CommentSieve[3];
   top.init;
   ''->top.topGroup.fullNameT[];
   true->top.topGroup.isDirectory;
   thePathHandler.init;
   (* installing a default grammarFinder *)
   ;
   &defaultGrammarFinder[]->grammarMissing[];
   &repetitionStream[]->repS[];
   &theFirstErrorReporter[]->theErrorReporter[];
   (* register the grammars known by default *)
   screen[]->grammarMissing.registerGrammars
#)  

-- treelevelSymbolNameBody: Descriptor --
(# exp: ^expanded
do
   (if (symbol > 0)
    // true then
       (if (grammarAst[] = none )
        // false then
           grammarAst.root[]->exp[];
           3->exp.get->exp[];
           (* productionList *)
           symbol->exp.get->exp[];
           (* leftside *)
           1->exp.get->exp[];
           (* synDeclName *)
           prodNo.nameDecl
             ->exp.suffixWalkForProd
               (# nd: ^nameDecl
               do current[]->nd[]; &text[]->t[]; nd.getText->t[]
               #);
           
       if)
   if)
#)  

-- treelevelSymbolToAstBody: DoPart --
do
   (if (symbol < 0)
    // true then
       (if symbol
        // prodNo.unExpanded then
           &UnExpanded[]->as[]; 
        // prodNo.optional then
           &Optional[]->as[]; 
        // prodNo.nameDecl then
           &NameDecl[]->as[]; 
        // prodNo.nameAppl then
           &NameAppl[]->as[]; 
        // prodNo.string then
           &String[]->as[]; 
        // prodNo.Const then
           &Const[]->as[]; 
        // prodNo.Comment then
           &Comment[]->as[]; 
        // prodNo.SlotDesc then
           &SlotDesc[]->as[]; 
       if)
    else
       genRefArray[symbol]->as[]; 
   if);
     

-- treelevelGrammarTableFindBody: Descriptor --
(#
   doFind:
     (#
        tgi,gn: @text;
        tgir: ^text (* only used to avoid an error in text.equalNCS !!!! *)
     do
        loop:
        (for i: NoOfKnownGrammars repeat
          t[i].grammarIdentification->tgir[];
          (if tgir[] // none then  else tgir->tgi if);
          (if grammarName[] // none then  else grammarName->gn if);
          (*(if (t[i].grammarIdentification -> grammarName.equalNCS)*)
          trace.grammars
            ->tracer
              (# 
              do
                 'matching grammar: "'->dmp.putText;
                 gn[]->dmp.putText;
                 '" against grammarTable grammar: '->dmp.putText;
                 tgir[]->dmp.putText
              #);
          (if (tgi[]->gn.equalNCS) // true then i->inx; leave loop if)
        for);
        
     #);
   installed: @boolean
do
   trace.grammars
     ->tracer
       (# 
       do
          'find grammar: "'->dmp.putText;
          grammarName[]->dmp.putText;
          '" in grammarTable'->dmp.putText
       #);
   doFind;
   (if inx
    // 0 then
         (# savedRepS: ^repetitionStream
         do (* save rep *)
            repS[]->savedRepS[];
            &repetitionStream[]->repS[];
            (grammarName[],error[])->grammarMissing->installed;
            (* restore rep *)
            savedRepS[]->repS[];
            
         #);
       (if installed // true then doFind if)
   if);
   (if inx
    // 0 then
       trace.grammars
         ->tracer
           (# 
           do
              'FAILURE: find grammar: "'->dmp.putText;
              grammarName[]->dmp.putText;
              '" in grammarTable'->dmp.putText
           #);
       'Could not find '->ifNotFound
    else
       trace.grammars
         ->tracer
           (# 
           do
              'SUCCEEDED: find grammar: "'->dmp.putText;
              grammarName[]->dmp.putText;
              '" in grammarTable'->dmp.putText
           #);
       
   if)
#)  

-- treelevelGrammarTableInsertBody: Descriptor --
(# help: @text
do
   (if noOfKnownGrammars < t.range // false then 10->t.extend if);
   (if theGrammar.grammarIdentification
    // none then
       trace.grammars
         ->tracer
           (# 
           do
              'insert grammar: "'->dmp.putText; '" in grammarTable'->dmp.putText
           #);
       theGrammar[]->t[noOfKnownGrammars+1->noOfKnownGrammars][];
       
    else
       theGrammar.grammarIdentification-> (# t: ^text enter t[] exit t #)->help;
       (if help.length
        // 0 then
           trace.grammars
             ->tracer
               (# 
               do
                  'insert grammar: "'->dmp.putText;
                  help[]->dmp.putText;
                  '" in grammarTable'->dmp.putText
               #);
           theGrammar[]->t[noOfKnownGrammars+1->noOfKnownGrammars][];
           
        else
           search:
           (theGrammar.grammarIdentification,screen[])
             ->find
               (#
                  ifNotFound::< 
                    (# 
                    do
                       trace.grammars
                         ->tracer
                           (# 
                           do
                              'insert grammar: "'->dmp.putText;
                              help[]->dmp.putText;
                              '" in grammarTable'->dmp.putText
                           #);
                       theGrammar[]
                         ->t[noOfKnownGrammars+1->noOfKnownGrammars][];
                       leave search
                    #)
               #)
       if)
   if)
#)  

-- treelevelGrammarTableMetagrammarInsertBody: DoPart --
do
   trace.grammars
     ->tracer (#  do 'insert metagrammar in grammarTable'->dmp.putText #);
   (if noOfKnownGrammars < t.range // false then 10->t.extend if);
   meta[]->t[noOfKnownGrammars+1->noOfKnownGrammars][];
   meta.init  

-- astlevelGrammarFinderRegisterGrammarsBody: DoPart --
do
   trace.grammars->tracer (#  do 'registering  grammars'->dmp.putText #);
   INNER registerGrammars;
   trace.grammars
     ->tracer (#  do 'DONE: registering  grammars'->dmp.putText #)  

-- astlevelGrammarFinderBody: DoPart --
do
   trace.grammars
     ->tracer
       (# 
       do 'GrammarMissing: grammar: "'->dmp.putText; grammar[]->dmp.putText
       #);
   false->installed;
   INNER grammarFinder  

