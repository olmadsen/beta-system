ORIGIN '../applgram'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
--- applGramInitBody: descriptor ---
(# root: ^meta.Agrammar; 
   p: @integer;
   NoOfSons: @integer;
   cns: ^meta.Constructor;
   clist: ^meta.ConsElemList;
   exp: ^expanded;
   ls: ^meta.LeftSide;
   gn: ^meta.grammarName;
   nd: ^nameDecl;
   opAst: ^ast;
   op: ^meta.optionPart;
   maxProd: @integer;
   consGenerator,unExpGenerator,listGenerator,optGenerator: ^referenceGenerator;
do &referenceGenerator(# do &cons[] -> as[] #)[] -> consGenerator[];
   genUnExpanded[] -> unExpGenerator[];
   &referenceGenerator(# do &list[] -> as[] #)[] -> listGenerator[];
   genOptional[]  -> optGenerator[];
   grammarAst.root[] -> root[]; 
   root.getOptionOp -> opAst[];
   (if opAst## <= cons## then
       opAst[]->op[];
       meta.optionElement -> op.suffixWalkForProd
       (# oe: ^meta.optionElement;
          on: ^meta.optionName;
          na: ^nameAppl;
          os: ^string;
          t: ^text
       do current[] -> oe[];
          oe.getOptionName -> on[];
          on.getNameAppl -> na[];
          na.getText -> t[]; t.copy->t[];
          (if ('suffix' -> t.equalNCS) then
              String -> oe.suffixWalkForProd
              (# do
                 current[] -> os[];
                 os.getText -> applGramSuffix[];
                 applGramSuffix.copy -> applGramSuffix[]; 
              #)
          if)
       #)      
   if);
   root.getProductionList -> pl[];
   (* check if the arrays need extensions *);
   pl.noOfSons -> maxProd;
   (if (maxProd>kindArray.range) then
       maxProd+1 - kindArray.range -> kindArray.extend;
       maxProd+1 - nodeClassArray.range -> nodeClassArray.extend;
       maxProd+1 - sonArray.range -> sonArray.extend;
       maxProd+1 - roomArray.range -> roomArray.extend;
       maxProd+1 - genRefArray.range -> genRefArray.extend;
   if);
   root.getGrammarName -> gn[];
   gn.getNameDecl -> nd[];
   nd.getText -> grammarName[]; grammarName.copy -> grammarName[];
   0 -> p;
   pl.scan(#
          do p+1 -> p;
             0 -> sonArray[p];
             current[] -> exp[];
             exp.getson1 -> ls[];
             2 * (((2 -> ls.getAttribute) + 1) div 2) -> roomArray[p];
             (if current.symbol
              //meta.Constructor then 
                 kinds.interior -> kindArray[p]; 
                 kinds.cons -> nodeClassArray[p];
                 current[] -> cns[];
                 cns.getConsElemList -> clist[];
                 0 -> NoOfSons;
                 clist.scan
                 (# do
                    (if current.symbol
                     //meta.Syncat
                     //meta.TaggedSyn then NoOfSons + 1 -> NoOfSons;
                    if);
                 #);
                 NoOfSons -> sonArray[p];
                 consGenerator[] -> genRefArray[p][];
              //meta.Alternation then kinds.unExpanded -> kindArray[p] -> nodeClassArray[p];
                 unExpGenerator[] -> genRefArray[p][];
              //meta.ListOne
              //meta.ListZero then 
                 kinds.interior -> kindArray[p];
                 kinds.list -> nodeClassArray[p];  
                 listGenerator[] -> genRefArray[p][];
              //meta.Dummy then 0 -> kindArray[p] -> nodeClassArray[p]
              //meta.Opt then kinds.optional -> kindArray[p] -> nodeClassArray[p];
                 optGenerator[] -> genRefArray[p][];
             if)
          #)
#)
