ORIGIN '../astlevel';
LIB_ITEM 'mpsastlevel';
INCLUDE '~beta/sysutils/endian';
INCLUDE  '../notifications'
        'indexPrivate'
        'propertyBody';
BODY 'astBody'
     'fragBody'
     'fragmentgroupparser'
     'astparser';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)

-- LIB: attributes --

use_ref2rep:
  (# exit false #);

--- astInterfaceLib:Attributes---

lexemHeaderSize: (# exit 1 #);

lexemAllocSize:
  (* calculating the number of words needed to containg a lexem of
   * length 'l'.  The allocation is such, that the allocated number of
   * words is odd. such that the total number of words allocated for a
   * lexem is even (since one word is allocated to contain the
   * header).  This allocation scheme is necessary to conform to the
   * index addressing (index addresses are always even)
   *)
  (# l: @integer
  enter l
  exit 1 + ((l + 3) div 8)*2
  #);

--- astPrivateLib:attributes ---

scanDown: (* Private *)
(* must be used as a component. Scans the path from the root down
 * to this Ast. Example of usage: see the implementation of
 * nearestCommonAncestor
 *)
  (#
     currentAst: ^Ast;
     OneLevelUp:
       (# as: ^Ast
       enter as[]
       do
          (if (as[] <> none ) then
              as.father->oneLevelUp; as[]->currentAst[]; SUSPEND
          if)
       #)
  do index->frag.indexToNode->oneLevelUp
  exit currentAst[]
  #);
checkSlotAttribute: (* Private *)
  (# attributeNo: @integer; 
  enter attributeNo
  do
     (if symbolInx = prodNo.unExpanded then
         (if
         ((attributeNo < 1) or
          (attributeNo > (offset.sizePerSlotDesc-offset.SlotAttribute))) then
               (# m: ^text
               do
                  &text[]->m[];
                  'ERROR: illegal slot-attributIndex. AttributIndex = '
                    ->m.putText;
                  (attributeNo)->m.putInt;
                  m[]->stopYggdrasil;
                  
               #)
         if)
      else
         'Error Slot-Attribute-operation on no slot '->stopYggdrasil
     if)
  #);
lastBrother: (* Private *)
  (# b: @boolean
  enter (#  enter b do (b,2,1)->frag.a[index].%PutBits #)
  exit (2,1)->frag.a[index].%GetBits->b
  #);
checkAttributNo: (* Private *)
  (#
     ERROR:
       (# m: ^text
       do
          &text[]->m[];
          'ERROR: illegal attributIndex. AttributIndex = '->m.putText;
          (attributNo)->m.putInt;
          m[]->stopYggdrasil;
          
       #);
     attributNo,symb: @integer
  enter attributNo
  do
     (if (attributNo <= 0) then ERROR if);
     symbol->symb;
     (if (symb >= 1) then
         (if not (attributNo <= frag.grammar.roomArray[symb]) then ERROR if);
         
      else
         ERROR
     if);
     
  #);
findSep:
  (#
  (* calls INNER if the n'th occurence of c in t is found
   * p is the position in t
   * prevP refers to the position of the n-1'th occurence
   *) c: @char; n,p,prevP,no: @integer; t: ^text; 
  enter (c,n,t[])
  do
     (if (n <> 0) then
         search: t.scan
           (# while::  (#  do true->value #); 
           do
              (if ch = c then
                  p->prevP;
                  t.pos->p;
                  no+1->no;
                  (if no = n then leave search if)
              if)
           #);
         (if (p <> 0) then INNER findSep if);
         
     if);
     
  #);
insertSep1:
(* Private. Inserts new CommentSeparator1 with index inx.
 * NOTICE! Is only used when a new son is added to an ast with a comment
 *)
  (# t,help: ^text; inx: @integer
  enter (inx,t[])
  do
     t.reset;
     (if inx = 1 then
         ''->help[]; CommentSeparator1->help.put; (help[],1)->t.insert
      else
         (CommentSeparator1,inx,t[])
           ->findSep
             (# 
             do
                ''->help[];
                CommentSeparator1->help.put;
                (help[],prevP)->t.insert
             #);
         
     if);
     
  #);
deleteSep1:
(* Private. Deletes the CommentSeparator1 with index inx.
 * NOTICE! Is only used when a son is deleted from an ast with a comment
 *)
  (# t: ^text; inx: @integer
  enter (inx,t[])
  do
     t.reset;
     (CommentSeparator1,inx,t[])->findSep (#  do (p,p)->t.delete #);
     
  #);
privateDumpComment:
  (# comment: ^text
  enter comment[]
  do
     '<'->put;
     comment.scanAll
       (# 
       do
          (if ch
           // CommentSeparator1 then
              'S'->put; 
           // CommentSeparator2 then
              's'->put; 
           // CommentSeparator3 then
              'p'->put; 
           else
              ch->put; 
          if);
          
       #);
     '>'->put;
     newLine;
     
  #);
findSubcomments:
  (#
     theComment: ^Text;
     inx: @integer;
     start,end: @integer;
     pos1start,pos1end: @integer;
     dumpComment:
       (# 
       do
          theComment[]->privateDumpComment;
          'length: '->putText;
          theComment.length->putInt;
          newLine;
          'inx: '->putText;
          inx->putInt;
          newLine;
          'start: '->putText;
          start->putInt;
          newLine;
          'end: '->putText;
          end->putInt;
          newLine;
          
       #)
  enter (theComment[],inx)
  do
     theComment.reset;
     1->pos1start;
     (if inx = 1 then (* get the subcomments before the first separator *)
         1->pos1end;
         (CommentSeparator1,1,theComment[])->findSep (#  do p->pos1end #);
         (if (pos1end <> 1) then
             (pos1start,pos1end-1)->(start,end); 
          else
             (if (1->theComment.inxget) = CommentSeparator1 then
             (* empty subcomments *)
                 1->start->end; 
              else
             (* there must at least be one separator1 *)
                 'mps.findSubcomments (1): no separator1 found, should not happen!!'
                   ->putLine;
                 1->start->end;
                 dumpComment;
                 
             if);
             
         if);
         
      else
     (* find the separator preceding the subcomments *)
         (CommentSeparator1,inx-1,theComment[])
           ->findSep (#  do p->pos1start #);
         (if pos1start = theComment.lgth then
         (* separator is last character, the subcomments are empty *)
             theComment.lgth+1->start->end; 
          else
             (if (pos1start+1->theComment.inxget) = CommentSeparator1 then
             (* the subcomments are empty *)
                 pos1start->start->end; 
              else
                 pos1start->pos1end->theComment.setPos;
                 (* find the next separator *)
                 (CommentSeparator1,1,theComment[])
                   ->findSep (#  do p->pos1end #);
                 (if pos1end = pos1start then
                 (* separator not found, the subcomments are the rest of the text *)
                     (pos1start+1,theComment.lgth)->(start,end); 
                  else
                     (pos1start+1,pos1end-1)->(start,end); 
                 if)
             if)
         if);
         
     if);
     INNER findSubcomments
  #);
findSubcomment:
  (#
     theComment: ^Text;
     inx,subinx: @integer;
     start,end: @integer;
     pos1start,pos1end: @integer;
     dumpComment:
       (# 
       do
          theComment[]->privateDumpComment;
          'length: '->putText;
          theComment.length->putInt;
          newLine;
          'inx: '->putText;
          inx->putInt;
          newLine;
          'subinx: '->putText;
          subinx->putInt;
          newLine;
          
       #);
     findSubSubComment:
       (#
          a,b,s,e: @integer;
          pos2start,pos2end: @integer;
          dumpSubcomment:
            (# 
            do
               dumpComment;
               'a: '->putText;
               a->putInt;
               newLine;
               'b: '->putText;
               b->putInt;
               newLine;
               's: '->putText;
               s->putInt;
               newLine;
               'e: '->putText;
               e->putInt;
               newLine;
               
            #)
       enter (a,b)
       do
          a->pos2start->theComment.setPos;
          (if subinx = 1 then
              (CommentSeparator2,1,theComment[])
                ->findSep (#  do p->pos2end #);
              (if pos2end <> pos2start then
                  (if pos2end <= b then
                      (pos2start,pos2end-1)->(s,e)
                   else
                      'mps.FindSubcomment (3): no separator2 found in '
                        ->putText;
                      subinx->putInt;
                      '. subcomment, should not happen!!'->putLine;
                      (pos2start,b)->(s,e);
                      dumpSubcomment;
                      
                  if)
               else
                  'mps.FindSubcomment (4): no separator2 found, should not happen!!'
                    ->putLine;
                  pos2start->s->e;
                  dumpSubcomment;
                  
              if)
           else
          (* find the separator preceding the subcomments *)
              (CommentSeparator2,subinx-1,theComment[])
                ->findSep (#  do p->pos2start #);
              (if pos2start <> a then
                  (if pos2start < b then
                      pos2start->pos2end->theComment.setPos;
                      (* find the next separator *)
                      (CommentSeparator2,1,theComment[])
                        ->findSep (#  do p->pos2end #);
                      (if pos2end <> pos2start then
                          (pos2start+1,pos2end-1)->(s,e)
                       else
                          'mps.FindSubcomment (5): no separator2 found, should not happen!!'
                            ->putLine;
                          pos2start->s->e;
                          dumpSubcomment;
                          
                      if)
                   else
                      'mps.FindSubcomment (6): no separator2 found, should not happen!!'
                        ->putLine;
                      pos2start->s->e;
                      dumpSubcomment;
                      
                  if);
                  
              if);
              
          if)
       exit (s,e)
       #);
     
  enter (theComment[],inx,subinx)
  do
     theComment.reset;
     1->pos1start;
     (if inx = 1 then (* get the subcomments before the first separator *)
         1->pos1end;
         (CommentSeparator1,1,theComment[])->findSep (#  do p->pos1end #);
         (if (pos1end <> 1) then
         (* Now look for subinx in: (pos1start,pos1end-1)->(start,end); *)
             (pos1start,pos1end-1)->findSubSubcomment->(start,end)
          else
             (if (1->theComment.inxget) = CommentSeparator1 then
             (* empty subcomments *)
                 1->start; 0->end; 
              else
             (* there must at least be one separator1 *)
                 'mps.FindSubcomment (1): no separator1 found, should not happen!!'
                   ->putLine;
                 1->start;
                 0->end;
                 dumpComment;
                 
             if);
             
         if);
         
      else
     (* find the separator preceding the subcomments *)
         (CommentSeparator1,inx-1,theComment[])
           ->findSep (#  do p->pos1start #);
         (if pos1start = theComment.lgth then
         (* separator is last character, the subcomments are empty *)
             theComment.lgth+1->start; start-1->end; 
          else
             (if (pos1start+1->theComment.inxget) = CommentSeparator1 then
             (* the subcomments are empty *)
                 pos1start->start; start-1->end; 
              else
                 pos1start->pos1end->theComment.setPos;
                 (* find the next separator *)
                 (CommentSeparator1,1,theComment[])
                   ->findSep (#  do p->pos1end #);
                 (if pos1end = pos1start then
                 (* separator not found, the subcomments are the rest of the text *)
                 (* Now look for subinx in: (pos1start+1,theComment.lgth)->(start,end); *)
                     (pos1start+1,theComment.lgth)->findSubSubcomment
                       ->(start,end)
                  else
                 (* Now look for subinx in: (pos1start+1,pos1end-1)->(start,end); *)
                     (pos1start+1,pos1end-1)->findSubSubcomment->(start,end)
                 if)
             if)
         if);
         
     if);
     INNER findSubcomment
  #);
  

--- lexemTextPrivate:attributes ---

checkbase: (* Private *)
  (# newWidth: @integer
  enter newWidth
  do (if frag.lcurtop>1 then
         newWidth->checkNewLexem
      else
         newWidth->checkOldLexem
     if)
  #);

checkNewLexem: (* Private *)
  (# newwidth,newWidthInLongs,lexemSize: @integer;
     base: @integer;
     allocatedLongs:
       (#
       enter
          (# l,base: @integer
          enter l
          do lexemInx*2-2 -> base;
             (l,base) -> frag.l.%putShort
          #)
       exit  0->frag.l[lexemInx].%getShort
       #);
     allocNewLexem:
       (# alloc: @integer
       do (if (frag.lcurtop + lexemSize >= frag.l.range) then
	      lexemSize->frag.extendL
	  if);
	  (if base=0 then
	      frag.lcurtop -> lexemInx;
	      0 -> curLength;
	      frag.lcurtop + lexemSize -> frag.lcurtop
	   else
	      allocatedLongs -> alloc;
              (if (base + alloc >= frag.lcurTop) then
		  frag.lcurTop + newWidthInLongs - alloc -> frag.lcurTop;
	       else
		  (for i: alloc+1 repeat frag.l[base+i-1] -> frag.l[frag.lcurtop+i-1] for);
		  frag.lcurtop -> lexemInx;
		  frag.lcurtop + lexemSize -> frag.lcurtop
	      if);
	  if);
	  newWidthInLongs -> allocatedLongs;
       #);
  enter newwidth
  do newWidth -> lexemAllocSize -> newWidthInLongs;
     lexemHeaderSize + newWidthInLongs -> lexemSize;
     lexemInx -> base;
     (if (base=0) or (allocatedLongs<newWidthInLongs) then
	 allocNewLexem
     if);
  #);

checkOldLexem: (* Private *)
  (# newwidth,newWidthInLongs: @integer;
     base: @integer;
     allocatedLongs:
       (#
       enter
          (# l,base: @integer
          enter l
          do lexemInx*2-2 -> base;
	     (l,base) -> frag.a.%putShort
          #)
       exit 0->frag.a[lexemInx].%getShort
       #);
     allocnewbase:
       (# alloc: @integer
       do
          (if (1+frag.curtop+newWidthInLongs >= frag.a.range) then
              (2+newWidthInLongs)->frag.extendA
          if);
          (if base = 0 then
              frag.curtop->lexemInx;
              0->curLength;
              1+frag.curtop+newWidthInLongs->frag.curtop
           else
              (if ((base+(allocatedLongs->alloc)+1) >= frag.curTop-1) then
                  frag.curTop+newWidthInLongs-alloc->frag.curTop; 
               else
                  (for i: alloc+1 repeat
                    frag.a[base+i-1]->frag.a[frag.curtop+i-1]
                  for);
                  frag.curtop->lexemInx;
                  1+frag.curtop+NewWidthInLongs->frag.curtop
              if);
              
          if);
          newWidthInLongs->allocatedLongs;
          
       #);
     
  enter newwidth
  do
     1+((newWidth+3) div 8)*2->newWidthInLongs;
     lexemInx->base;
     (if base = 0 then
         allocNewbase; 
      else
         (if (allocatedLongs < newWidthInLongs) then allocNewbase if); 
     if);
     
  #);
  

-- fragmentListElementPrivate: Attributes --
repSave: (* Private *)
  (# r: ^repetitionStream
  enter r[]
  do
     type->r.putInt;
     name[]->r.putText;
  #);
repRestore: (* Private *)
  (# r: ^repetitionStream; t: ^text
  enter r[]
  do
     r.getInt->type;
     r.getText->t[];
     &text[]->name[];
     t[]->name.append;
     (if type=formType then
         (if doRealOpen then screen[]->open if); 
     if)
  #);
  

-- fragmentListDescriptorPrivate: Attributes --
repSave: (* Private *)
  (# r: ^repetitionStream
  enter r[]
  do size->r.putInt; scan (#  do r[]->current.repSave #); 
  #);
repRestore: (* Private *)
  (# r: ^repetitionStream; e: ^element; no: @integer
  enter r[]
  do
     r.getInt->no;
     (for no repeat
          &element[]->e[];
          r[]->e.repRestore;
          l: scan
            (# 
            do 
               (if (e.name[]->current.name.equalNCS) then
                   (# t: @text
                   do
                      'Fragment: "'->t;
                      e.name.copy->t.append;
                      e.name.copy->offendingFormName[];
                      '" is already in this fragment group: "'->t.append;
                      THIS(fragmentGroup).name->t.append;
                      '"'->t.append;
                      (errorNumbers.doubleFormDeclaration,t[])->catcher
                   #);
                   leave l
               if)
            #);
          e[]->append
     for)
  #);
  

-- fragmentFormPrivate: Attributes --
maximumIndex:
(* NOTE: the constant 131071 is the maximum index, which can be represented
 * in any AST.  This restriction is fundamental, and cannot by removed
 * without major rewriting of the MPS code.
 *) (#  exit 131071 #);
extendA: (* Private *)
  (# minExtend,maxExtend: @integer; minimumAllocation: @integer; 
  enter minimumAllocation
  do
     (if minimumAllocation <= 0 then
           (# msg: ^text; 
           do
              'Should not happen.  Please report this error to support@mjolner.dk\n'
                ->msg.putline;
              'ExtendA called internally in MPS with illegal minimum allocation: '
                ->msg[];
              minimumAllocation->msg.putint;
              msg.newline;
              msg[]->astInterfaceError
           #)
     if);
     (if (a.range >= maximumIndex) then
           (# msg: ^text
           do
              'AST overflow in fragment: '->msg[];
              fullName->msg.putLine;
              (errorNumbers.arrayTooBig,msg[])->catcher
           #)
      else
         a.range+minimumAllocation->minExtend;
         maximumIndex-curTop->maxExtend;
         (minExtend,maxExtend)->min->minExtend;
         (if (minExtend < minimumAllocation) then
               (# msg: ^text; 
               do
                  'AST overflow in fragment: '->msg[];
                  fullName->msg.putLine;
                  (errorNumbers.arrayTooBig,msg[])->catcher
               #)
         if);
         minExtend->a.extend
     if)
  #);
setARange: (* Private: set the range of the array a *)
  (# theRange: @integer
  enter theRange
  do (if (a.range<theRange) then
	 (if (theRange>=maximumIndex) then
	     (# msg: @text
	     do 'AST overflow in fragment: ' -> msg;
		fullName -> msg.putLine;
		(errorNumbers.arrayTooBig,msg[])->catcher
	     #)
	  else
	     theRange-a.range -> a.extend
	 if)
     if)
  #);

setLRange: (* Private: set the range of the array l *)
  (# theRange: @integer
  enter theRange
  do (if (l.range<theRange) then
	 (if (theRange>=maximumIndex) then
	     (# msg: @text
	     do 'lexem overflow in fragment: ' -> msg;
		fullName -> msg.putLine;
		(errorNumbers.arrayTooBig,msg[])->catcher
	     #)
	  else
	     theRange-l.range -> l.extend
	 if)
     if)
  #);

extendL:  (* Private *)
  (# minExtend, maxExtend: @integer;
     minimumAllocation: @integer;
  enter minimumAllocation
  do (if minimumAllocation<=0 then
	 (# msg: ^text;
	 do 'Should not happen.  Please report this error to support@mjolner.dk\n'->msg.putline;
	    'ExtendL called internally in MPS with illegal minimum allocation: '->msg[];
	    minimumAllocation -> msg.putint; msg.newline;
	    msg[]->astInterfaceError
	 #)
     if);
     (if (l.range>=maximumIndex) then
	 (# msg: ^text
	 do 'lexem overflow in fragment: ' -> msg[];
	    fullName -> msg.putLine;
	    (errorNumbers.arrayTooBig,msg[])->catcher
	 #)
      else
	 l.range+minimumAllocation -> minExtend;
	 maximumIndex-lcurTop -> maxExtend;
	 (minExtend,maxExtend)->min->minExtend;
	 (if (minExtend<minimumAllocation) then
	     (# msg: ^text;
	     do 'lexem overflow in fragment: ' -> msg[];
		fullName -> msg.putLine;
		(errorNumbers.arrayTooBig,msg[])->catcher
	     #)
	 if);
	 minExtend -> l.extend
     if)
  #);
getNextBrother: (* Private *)
  (# inx,val: @integer
  enter inx
  exit (* (0->a[inx+1].%getShort)*2->val*)
      (0->a[inx+1].%getShort) %sll 1 -> val
      (* Above line tos_converted from: a[inx+1] -> TOS'%getShort[0]' -> TOS'%ShiftLeft[1]' -> val *)
  #);
setNextBrother: (* Private *)
  (# inx1,inx2: @integer; 
  enter (inx1,inx2)
  do (inx2 div 2,0)->a[inx1+1].%putShort
  #);
getComment: (* Private *)
  (# inx,val: @integer
  enter inx
  exit (* (1->a[inx].%getShort)*2->val*)
      (1->a[inx].%getShort) %sll 1 -> val
      (* Above line tos_converted from: a[inx] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> val *)
  #);
setComment: (* Private *)
  (# inx1,inx2: @integer; 
  enter (inx1,inx2)
  do (inx2 div 2,1)->a[inx1].%putShort
  #);
getSymbol: (* Private *)
  (# inx,val: @integer
  enter inx
  exit (4,12)->a[inx].%getSignedBits->val
  #);
setSymbol: (* Private *)
  (# inx,symbol: @integer; 
  enter (inx,symbol)
  do (symbol,4,12)->a[inx].%putBits
  #);
isLastBrother: (* Private *)
  (# inx: @integer; b: @boolean
  enter inx
  exit (2,1)->a[inx].%GetBits->b
  #);
setLastBrother: (* Private *)
  (# inx: @integer; bool: @boolean; 
  enter (inx,bool)
  do (bool,2,1)->a[inx].%PutBits
  #);
setBit7: (* Private *)
  (# inx: @integer; bool: @boolean; 
  enter (inx,bool)
  do (bool,0,1)->a[inx].%PutBits
  #);
packAstToValue: (* Private *)
  (# val,inx: @integer; a: ^Ast; 
  enter a[]
  do
     (if a[] = none then
         0->val
      else
         a.frag[]->import.getIndex->inx;
         (inx,0)->val.%putShort;
         (a.index div 2,1)->val.%putShort
     if)
  exit val
  #);
valueToAst: (* Private *)
  (# val: @integer; a: ^Ast; f: ^fragmentForm
  enter val
  do
     (if val = 0 then
         none ->a[]
      else
	 (0->val.%getShort) -> import.getGroup -> f[];
	 (* Above line tos_converted from: val -> TOS'%getShort[0]' -> import.getGroup -> f[]; *)
	 (if f[]<>NONE then
             (1->val.%getShort) %sll 1 -> f.indextoNode -> a[]
             (* Above line tos_converted from: val -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> f.indextoNode -> a[] *)
             (* 0->val.%getShort->import.getGroup->f[];
              (1->val.%getShort)*2->f.indextoNode->a[]*)
         if)    
     if)
  exit a[]
  #);
repSaveStruct: (* Private *)
  (# r: ^repetitionStream; t: @text; version,gramVersion: @integer;
  enter r[]
  do curTop -> r.putInt;
     (*lcurTop -> r.putInt;*)
     (if root[]=none then
	 0 -> r.putInt
      else
	 root.index -> r.putInt
     if);
     (if grammar[]=none then
	 undefinedVersion -> gramVersion(*r.putInt*);
	 undefinedGrammarName -> t; t[] -> r.putText
      else
	 grammar.version -> gramVersion(*r.putInt*);
	 grammar.grammarIdentification -> t.puttext; (*t[] -> r.putText*)
     if);
     (if isLittleEndian then
         (gramVersion,0) -> version.%putShort;
         (lcurtop div 2,1) -> version.%putShort;
      else
         (gramVersion,1) -> version.%putShort;
         (lcurtop div 2,0) -> version.%putShort;
     if);
     version -> r.putInt;
     t[] -> r.putText;
     firstSlot -> r.putInt;
     modificationStatus -> r.putInt;
     r[] -> prop.repSave;
     r[] -> import.repSave;
  #);
repRestoreStruct: (* Private *)
  (#
     r: ^repetitionStream;
     theGrammarName: ^text;
     gramVersion: @integer;
     t,msg: ^text;
     Error:
       (# errorText: ^text; errorNumber: @integer; t,s: @text; 
       enter (errorNumber,errorText[])
       do
          'The file\n  '->t;
          fatherR.diskFileName->t.putText;
          t.newLine;
          errorText[]->t.putText;
          t.newLine;
          (errorNumber,t[])->catcher
       #);
     version: @integer;
  enter r[]
  do r.getInt -> curTop;
     (*r.getInt -> lcurTop;*)
     r.getInt -> rootInx;
     (* rootInx -> indexToNode -> ... *)
     r.getInt -> version(*gramVersion*);
     (if isLittleEndian then
         0->version.%getShort->gramVersion;
         (1->version.%getShort)*2->lcurtop;
      else
         1->version.%getShort->gramVersion;
         (0->version.%getShort)*2->lcurtop;
     if);
     r.getText -> t[];
     r.getInt -> firstSlot;
     r.getInt -> modificationStatus;
     (if useModificationStatus then
	 (if (modificationStatus>10) then
	     modificationStatus -> setARange;
	     (if trace.active and trace.d[trace.compactopen] then
		 trace.compactopen->signalTrace
		   (# start::
			(#
			do 'compactopen of ' -> msg.putText;
			   fullName -> msg.putText;
			   '  ' -> msg.putText;
			   modificationStatus -> msg.putInt;
			   '/' -> msg.put;
			   curTop -> msg.putInt;
			   '/' -> msg.put;
			   lcurTop -> msg.putInt;
			   msg.newLine
			#)
		   #);
	     if);
	  else
	     curtop+50 -> setARange;
	     lcurtop+50 -> setLRange;
	     (if trace.active and trace.d[trace.compactopen] then
		 trace.compactopen->signalTrace
		   (# start::
			(#
			do  'compactopen of ' -> msg.putText;
			   fullName -> msg.putText;
			   curTop -> msg.putInt;
			   ' ! not saved wih compaction' -> msg.putLine
			#)
		   #);
	     if);
	 if);
      else
	 curtop+50 -> setARange;
	 lcurtop+50 -> setLRange;
     if);
     r[] -> prop.repRestore;
     r[] -> import.repRestore;
     (if grammar[]=none then
	 (t[],screen[]) -> grammarTable.find
	 (# ifNotFound::
	      (# m: ^text
	      do 'contains forms derived over the non-loaded grammar: ' -> m[];
		 t[] -> m.putText;
		 (errorNumbers.grammarNotFound,m[]) -> this(repRestoreStruct).error
	 #)#) -> grammar[];
     if);
     (if (grammar[]<>none) then
	 grammar.grammarIdentification -> theGrammarName[];
	 (if not ((thegrammarName[] -> t.equal) or
	     (undefinedGrammarName -> t.equal) or
	     (undefinedGrammarName -> theGrammarName.equal)) then
	     'contains an Ast derived over a wrong grammar'->msg[];
	     (errorNumbers.badFormat,msg[]) -> error
	 if);
	 (if not ((grammar.version=gramVersion) or (grammar.version=undefinedVersion)) then
	     'contains an Ast derived over a wrong version of the grammar\n'->msg[];
	     '  Expected grammar version: ' -> msg.puttext; grammar.version -> msg.putint;
	     msg.newline;
	     '  Grammar version found in file: ' -> msg.puttext; gramVersion -> msg.putint;
	     msg.newline;
	     (errorNumbers.badFormat,msg[]) -> error
	 if)
     if);
     
  #);
  

-- fragmentFormImportPrivate: Attributes --
repSave: (* Private *)
  (# s: ^repetitionStream
  enter s[]
  do inxC->s.putInt; (for i: inxC repeat impL.l[i].n[]->s.putText for)
  #);
repRestore: (* Private *)
  (# s: ^repetitionStream; e: ^element; i: @integer; t: ^text
  enter s[]
  do
     s.getInt->inxC;
     (if (inxC > impl.l.range) then
         &list (# noOfElements::  (#  do inxC+5->nu #) #)[]->impL[]
     if);
     (for i: inxC repeat
       &element[]->e[];
       s.getText->t[];
       &text[]->e.n[];
       t[]->e.n.append;
       e[]->impL.l[i][]
     for)
  #);

scan: (* Private *)
  (# thisElm: ^element
  do (for i: inxC repeat impl.l[i][] -> thisElm[]; INNER for)
  #);

init: (* Private *)
  (#
  do 0 -> inxC; &list[] -> impL[]
  #);

makeNull: (* Private *) 
  (# do init #);

--- treeLevelLib:attributes ---

newLexemTextForParser:
  (#
     length: @integer;
     prod: @integer;
     frag: ^fragmentForm;
     inx,lexInx: @integer;
  enter (prod,length,frag[])
  do (if frag.lcurtop>1 then
         (prod,length,frag[])->newNewLexemTextForParser->(inx,lexInx)
      else
         (prod,length,frag[])->oldNewLexemTextForParser->(inx,lexInx)
     if)
  exit (inx,lexInx)
  #);
newNewLexemTextForParser:
  (#
     length: @integer;
     prod: @integer;
     frag: ^fragmentForm;
     theSize: @integer;
     inx,newWidthInLongs,lexInx,lexemSize: @integer;
  enter (prod,length,frag[])
  do (if prod
      //prodNo.NameAppl then offset.sizePerNameAppl -> theSize;
      //prodNo.NameDecl then offset.sizePerNameDecl -> theSize;
      //prodNo.String then offset.sizePerString -> theSize;
      //prodNo.Comment then offset.sizePerComment -> theSize
      //prodNo.Const then offset.sizePerConst -> theSize
     if);
     (if length<0 then 0->length if);
     length -> lexemAllocSize -> newWidthInLongs;
     lexemHeaderSize + newWidthInLongs -> lexemSize;
     (if (frag.curtop + theSize(* + lexemSize*) >= frag.a.range) then
	 (theSize(* + lexemSize*))->frag.extendA
     if);
     frag.curTop -> inx;
     (if (frag.lcurtop + lexemSize >= frag.l.range) then
      	 lexemSize->frag.extendL
     if);
     frag.lcurtop ->lexinx; (*inx + theSize -> lexInx;*)
     0 -> frag.a[inx] -> frag.a[inx+1];
     (inx,prod) -> frag.setSymbol;
     (if prod=prodNo.Comment then
	 0 -> frag.a[inx+offset.commentType];
     if);
     (inx,lexInx) -> frag.setSonInx;
     0 -> frag.l[lexInx];
     (newWidthInLongs,0) -> frag.l[lexInx].%putShort;
     (length,1) -> frag.l[lexInx].%putShort;
     frag.curTop + theSize (*+ lexemSize*) -> frag.curTop;
     frag.lcurTop + lexemSize -> frag.lcurTop;

  exit (inx,lexInx*4)
  #);
oldNewLexemTextForParser:
  (#
     length: @integer;
     prod: @integer;
     frag: ^fragmentForm;
     theSize: @integer;
     inx,newWidthInLongs,lexInx: @integer;
     
  enter (prod,length,frag[])
  do
     (if prod
      // prodNo.NameAppl then
         offset.sizePerNameAppl->theSize; 
      // prodNo.NameDecl then
         offset.sizePerNameDecl->theSize; 
      // prodNo.String then
         offset.sizePerString->theSize; 
      // prodNo.Comment then
         offset.sizePerComment->theSize
      // prodNo.Const then
         offset.sizePerConst->theSize
     if);
     (* jlk:  Thu May  9, 1996: Trying to correct:
      *       Repetition index out of range error
      *       Inserted the following line to avoid negative extendA
      *)
     (if length < 0 then 0->length if);
     1+((length+3) div 8)*2->newWidthInLongs;
     (if (frag.curtop+theSize+newWidthInLongs+2 >= frag.a.range) then
         (theSize+newWidthInLongs+2)->frag.extendA
     if);
     frag.curTop->inx;
     0->frag.a[inx]->frag.a[inx+1];
     (inx,prod)->frag.setSymbol;
     (if prod = prodNo.Comment then
         0->frag.a[inx+offset.commentType];
         (* //prodNo.Const then (inx,true) -> frag.setSonInx; *)
         
     if);
     (inx,(inx+theSize->lexInx))->frag.setSonInx;
     0->frag.a[lexInx];
     (newWidthInLongs,0)->frag.a[lexInx].%putShort;
     (* jlk:  Thu May  9, 1996: Trying to correct:
      *       Repetition index out of range error
      * lexInx + newWidthInLongs + 1  -> frag.curTop;
      *)
     lexInx+newWidthInLongs+1->frag.curTop;
     
  exit (inx,lexInx*4)
  #);
newAstForParser: (* PRIVATE except for the parser *)
  (#
     prod: @nonterminalSymbol;
     predefined: @prod.predefined;
     inx,extraRoom: @integer;
     frag: ^fragmentForm;
     
  enter (prod,frag[])
  do frag.curTop -> inx;
     (if predefined then
	 0 -> extraRoom
      else
	 roomArray[prod] -> extraRoom;
     if);
     frag.curTop + extraroom + offset.sizePerNode -> frag.curTop;
     (if (frag.curtop >= frag.a.range) then
	 (extraroom + offset.sizePerNode)->frag.extendA
     if);
     0 -> frag.a[inx] -> frag.a[inx+1];
     (inx,prod) -> frag.setSymbol;
  exit inx
  #);
  

-- astInterfaceTracer: DoPart --
do
   (if trace.d[traceNo] then
       (if trace.private.str[] = none then
           screen[]->dmp[]
        else
           trace.private.str[]->dmp[]
       if);
       'Trace: '->dmp.puttext;
       (traceNo)->dmp.putInt;
       ' '->dmp.put;
       INNER ;
       dmp.newLine;
   if)

--- astInterfacePrivate: descriptor ---
(# handles: @containerList
     (* list containing all active handles on this MPS.  See the
      * file 'handle.bet' for more info on the use of handles in MPS
      *)
     (# element:: handle #);
  (* errMsg: @ <<SLOT errMsg:descriptor>>; (* contains dynamically created
                                          * compiler error messages
                                          *)
   errMsg: @
     (# msg: [10] ^text;
        isWarn: [10] @ boolean;
        top: @integer;
        clear: 
          (# 
          do 0 -> top;
             (for i: isWarn.range repeat false -> isWarn[i] for)
          #);
        addMsg:
          (# m: ^text
          enter m[]
          do (if (top+1 -> top) > msg.range then
                 msg.range -> msg.extend;
                 isWarn.range -> isWarn.extend;
             if);
             m[] -> msg[top][];
             inner addMsg
          exit (*lastMsgNo*) top
          #);
        addErrorMsg:  addMsg(##);
        addWarning: addMsg(# do true -> isWarn[top] #);
        getMsg:
          (# no: @integer; m: ^text
          enter no
          do (*no - lastStaticMsg  -> no;*)
             (if (0<no) and (no <= top) then
	         msg[no][] -> m[]
	     if)
          exit m[]
          #);
        isWarning: booleanValue
          (# no: @integer
          enter no
          do (*no - lastStaticMsg  -> no;*)
             (if (0<no) and (no<=top) then
                 isWarn[no] -> value
             if)
          #);
             (*lastMsgno: (# exit lastStaticMsg+top #)*)
     #)

#)

--- astInterfaceTracePrivate: descriptor ---
(# str: (* Private *) ^stream;
   traceHandle: (* Private *)  ^handle;
#)

--- astInterfaceTraceSet: dopart ---
do on->d[no];
   false->active;
   (for i: d.range repeat (active or d[i])->active for);
   (if private.traceHandle[] = none then
       (if active then
           getHandle
             (#
                handleType:: 
                  (# onTrace::  (#  do msg[]->private.str.putline #) #)
             #)->private.traceHandle[]
       if)
    else
       (if not active then
           private.traceHandle[]->ignoreHandle; none ->private.traceHandle[]
       if)
   if);
   (if private.str[] = none then screen[]->private.str[] if);
     

-- astInterfaceTraceOutput: DoPart --
do str[]->private.str[]  

