ORIGIN '../astlevel';
ON 19
[[
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
--- astPrivateLib:attributes ---

symbolInx: (* Private *)
  (# lab: @integer
  enter 
     (# val: @integer
     enter val do (@@frag.a[index],val) -> TOS'%putBits[4,12]'
     #)
  exit frag.a[index] -> TOS'%getSignedBits[4,12]' -> lab
  #);

brotherInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val 
     do (@@frag.a[index+1],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[0]'
     #)
  exit frag.a[index+1] -> TOS'%getShort[0]' -> TOS'%ShiftLeft[1]'
  #);

sonInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (@@frag.a[index+1],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
     #)
  exit frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]'
  #);

usageInx: (* Private *)
  (#
  enter frag.a[index+offset.usage]
  exit frag.a[index+offset.usage]
  #);

realCommentInx: (* Private *)
  (#
  enter 
     (# val: @integer; cinx: @integer 
     enter val 
     do (if (index -> frag.isSlot)
         //true then 
            commentInx -> cinx;
            (@@frag.a[cInx],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
         else (@@frag.a[index],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
        if);
     #)
  exit 
     (# val: @integer
     do (if (index -> frag.isSlot)
         //true then 
            frag.a[commentInx] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> val
         else frag.a[index] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> val
        if);
     exit val
               #)
  #);

commentInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (@@frag.a[index],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
     #)
  exit frag.a[index] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]'
  #);

lexemInx: (* Private: same as sonInx *)
  (# val: @integer
  enter 
     (# enter val
     do (@@frag.a[index+1],val -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
     #)
  exit frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]'
  #);

attributeInx1: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

commentTypeInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

valueInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

findFatherInx: (* Private *)
  (# i: @integer; b: @boolean
  do (* expansion of  
      *    index -> i;
      *    loop: (if true
      *           //(i=0) then
      *           //(i -> frag.isLastBrother) then
      *                       i -> frag.nextBrother -> i
      *           else i -> frag.nextBrother -> i;
      *                restart loop
      *          if);
      *)
     index -> i; 
     loop: (if true 
            //(i=0) then  
            //(frag.a[i] -> TOS'%GetBits[2,1]' -> b) then
               frag.a[i+1] -> TOS'%GetShort[0]' -> TOS'%ShiftLeft[1]' -> i
            else frag.a[i+1] -> TOS'%GetShort[0]' -> TOS'%ShiftLeft[1]' -> i; restart loop
           if)
  exit i
  #);
          
--- expandedPrivate:attributes ---
findIndex: (* Private: find index for son number 'sonnr' *)
  (# ERROR: 
       (# do
          'ERROR. sonnr = ' -> putText; (sonnr) -> putInt;
          ' trying to access a nonexistent son' -> stopYggdrasil;
       #);
     sonnr,i: @integer;
  enter sonnr
  do frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> i;
     (* inline-expansion of sonInx -> i *)
     (for sonnr-1 repeat 
          (if (0<i)
           //true then 
              frag.a[i+1] -> TOS'%getShort[0]' -> TOS'%ShiftLeft[1]' -> i
              (* optimalization of i -> frag.getNextBrother -> i *) 
           else error 
          if);
     for);
  exit i
  #);

--- fragmentFormPrivate:attributes ---

getSonInx:  (* Private *)
  (# inx,val: @integer
  enter inx
  exit a[inx+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]'
  #);

setSonInx:  (* Private *)
  (# inx1,inx2: @integer;
  enter (inx1,inx2)
  do (@@a[inx1+1],inx2 -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'
  #);

packInxToValue:  (* Private *)
  (# val,inx: @integer;
     index: @integer;
     f: ^fragmentForm;
  enter (index,f[])
  do (if index
      //0 then 0 -> val
      else
         f[] -> import.getIndex -> inx;
         (@@val,inx) -> TOS'%putShort[0]';
         (@@val,index -> TOS'%ShiftRight[1]') -> TOS'%putShort[1]'; 
     if)
  exit val   
  #);

valueToIndex:  (* Private *)
  (# val,inx,gInx: @integer;
     f: ^fragmentForm
  enter val
  do (if val
      //0 then 0 -> inx
      else
         val -> TOS'%GetShort[0]' -> gInx -> import.getGroup -> f[];
         val -> TOS'%GetShort[1]' -> TOS'%ShiftLeft[1]' -> inx
     if)
  exit (inx,f[])
  #);

isSlot:  (* Private *)
  (# inx: @integer;
     b: @boolean
  enter inx
  exit a[inx] -> TOS'%GetBits[0,1]' -> b
  #);

--- fragmentFormImportPrivate:attributes ---
GetIndex: 
  (* return the index of the fragmentForm f.  If f is not in
   * the collection, a new index is allocated
   *)
  (# f: ^FragmentForm; t: ^text;
     Index: @integer;
     insertNew: 
       (# e: ^element;
          newL: ^list;
       do &element[] -> e[];
          fullName->stripPathName->t[];
          (if t[]//none then 
              'Import error (should not happen): stripped fullname is none!' 
                -> screen.putline;
              (f.FullName,'') -> thePathHandler.localPath -> t[];
           else 
              (f.FullName,t[]) -> thePathHandler.localPath -> t[];
          if);
          (f[],t.copy) -> (e.f[],e.n[]);
          (if ((inxC+1 -> inxC)>impL.l.range)
           //true then
              &list(# noOfElements::< (# do inxC+5 -> nu #)#)[] -> newL[];
              (for i: impL.l.range repeat impL.l[i][] -> newL.l[i][] for);
              newL[] -> impL[];
          if);
          e[] -> impL.l[inxC -> index][]
       #);
  enter f[]
  do search: 
       (for i: InxC repeat
            (if impL.l[i].f[]//f[] then i -> index; leave search if)
       for);
     (if index//0 then insertNew if);
  exit index
  #);               

GetGroup:
  (* Private: The inverse of GetIndex; If the group is not open then open it *)
  (# f: ^FragmentForm; Index: @integer;
     importException:< AstInterfaceException; error: ^stream;
     openForm:
       (# fg: ^fragmentGroup;
          name: ^Text;
          i: @Integer;
       enter name[]
       do '-'->name.findch(# do inx->i #);
          ((1,i-1)->name.sub,screen[])->top.open->fg[];
          ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[];
       #);
  enter index
  do (if (impL.l[index].f[] -> f[])
      //NONE then
         (# t: ^text
         do fullName->stripPathName->t[];
            (if t[]//none then 
                (impL.l[index].n.copy,thePathHandler.currentDirectory)
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
             else 
                (impL.l[index].n.copy,t[])
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
            if);
         #);
         (if f[] 
          // NONE then 
             (# t: ^text
             do &text[]->t[];
                'Import error!! ' -> t.putLine;
                'There is something wrong with the file "' -> t.putText;
                diskFileName -> t.putText;
                '"\n. It refers to the fragment "' -> t.putText;
                impL.l[index].n[] -> t.putText;
                '" which was not found \n\n.' -> t.putText;
                t[]->ImportException
             #)
         if)
     if)
  exit f[]
  #);

--- treeLevelPrivate:attributes ---
kindOfSymbol: (* Private *)
  (# prod: @integer;
     knd: @integer
  enter prod
  do (if (prod<=0)
      //true then
         (if prod
          //prodNo.unExpanded then kinds.unexpanded -> knd;
          //prodNo.optional then kinds.optional -> knd;
          //prodNo.nameDecl then kinds.nameDecl -> knd;
          //prodNo.nameAppl then kinds.nameAppl -> knd;
          //prodNo.string then kinds.string -> knd;
          //prodNo.const then kinds.const -> knd;
          //prodNo.comment then kinds.comment -> knd;
          //prodNo.SlotDesc then kinds.SlotDesc -> knd;
         if);
      //false then kindArray[prod] -> knd 
     if);
  exit knd
  #); 

---]]
