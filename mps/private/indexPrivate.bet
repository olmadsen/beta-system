ORIGIN '../astlevel';
LIB_ITEM 'mpsastlevel';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
--- astPrivateLib:attributes ---

symbolInx: (* Private *)
  (# lab: @integer
  enter 
     (# val: @integer
     enter val do (val,4,12) -> frag.a[index].%putBits
     #)
  exit (4,12) -> frag.a[index].%getSignedBits -> lab
  #);

brotherInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val 
     do (val div 2,0) -> frag.a[index+1].%putShort
     #)
  exit (* (0->frag.a[index+1].%getShort)*2*)
     (0->frag.a[index+1].%getShort) %sll 1
     (* Above line tos_converted from: frag.a[index+1] -> TOS'%getShort[0]' -> TOS'%ShiftLeft[1]' *)
  #);

sonInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index+1].%putShort
     #)
  exit (* (1->frag.a[index+1].%getShort)*2*)
      (1->frag.a[index+1].%getShort) %sll 1
      (* Above line tos_converted from: frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' *)
  #);

slotUsageInx: (* Private *)
  (#
  enter frag.a[index+offset.slotUsage]
  exit frag.a[index+offset.slotUsage]
  #);

realCommentInx: (* Private *)
  (#
  enter 
     (# val: @integer; cinx: @integer 
     enter val 
     do (if (index -> frag.isSlot) then
            commentInx -> cinx;
            (val div 2,1) -> frag.a[cInx].%putShort
         else (val div 2,1) -> frag.a[index].%putShort
        if);
     #)
  exit 
     (# val: @integer
     do (if (index -> frag.isSlot) then
            (*(1->frag.a[commentInx].%getShort)*2 -> val *)
            (1->frag.a[commentInx].%getShort) %sll 1 -> val
            (* Above line tos_converted from: frag.a[commentInx] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> val *)
         else (* (1->frag.a[index].%getShort)*2 -> val*)
            (1->frag.a[index].%getShort) %sll 1 -> val
            (* Above line tos_converted from: frag.a[index] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> val *)
        if);
     exit val
     #)
  #);

commentInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index].%putShort
     #)
  exit (* (1 -> frag.a[index].%getShort)*2*)
      (1->frag.a[index].%getShort) %sll 1
      (* Above line tos_converted from: frag.a[index] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' *)
  #);

lexemInx: (* Private: same as sonInx *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index+1].%putShort
     #)
  exit (*  (1 -> frag.a[index+1].%getShort)*2 *)
      (1->frag.a[index+1].%getShort) %sll 1
      (* Above line tos_converted from: frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' *)
  #);

attributeInx1: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

commentTypeInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

valueInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

findFatherInx: (* Private *)
  (# i: @integer; b: @boolean
  do (* expansion of  
      *    index -> i;
      *    loop: (if true
      *           //(i=0) then
      *           //(i -> frag.isLastBrother) then
      *                       i -> frag.nextBrother -> i
      *           else i -> frag.nextBrother -> i;
      *                restart loop
      *          if);
      *)
     index -> i; 
     loop: 
       (if true 
        // (i=0) then  
        // ((2,1) -> frag.a[i].%GetBits -> b) then
           (* (0 -> frag.a[i+1].%GetShort)*2 -> i *)
            (0->frag.a[i+1].%getShort) %sll 1 -> i
            (* Above line tos_converted from: frag.a[i+1] -> TOS'%GetShort[0]' -> TOS'%ShiftLeft[1]' -> i *)
        else 
           (* (0 -> frag.a[i+1].%GetShort)*2 -> i;  *)
           (0->frag.a[i+1].%getShort) %sll 1 -> i;
           (* Above line tos_converted from: frag.a[i+1] -> TOS'%GetShort[0]' -> TOS'%ShiftLeft[1]' -> i; *)
           restart loop
       if)
  exit i
  #);
          
--- expandedPrivate:attributes ---
findIndex: (* Private: find index for son number 'sonnr' *)
  (# ERROR: 
       (# do
          'ERROR. sonnr = ' -> putText; (sonnr) -> putInt;
          ' trying to access a nonexistent son' -> stopYggdrasil;
       #);
     sonnr,i: @integer;
  enter sonnr
  do (* (1 -> frag.a[index+1].%getShort)*2 -> i; *)
     (1->frag.a[index+1].%getShort) %sll 1 -> i;
     (* Above line tos_converted from: frag.a[index+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' -> i; *)
     (* inline-expansion of sonInx -> i *)
     (for sonnr-1 repeat 
          (if (0<i) then
              (* (0 -> frag.a[i+1].%getShort)*2 -> i*)
               (0->frag.a[i+1].%getShort) %sll 1 -> i
               (* Above line tos_converted from: frag.a[i+1] -> TOS'%getShort[0]' -> TOS'%ShiftLeft[1]' -> i *)
              (* optimalization of i -> frag.getNextBrother -> i *) 
           else error 
          if);
     for);
  exit i
  #);

--- fragmentFormPrivate:attributes ---

getSonInx:  (* Private *)
  (# inx,val: @integer
  enter inx
  exit (* (1 -> a[inx+1].%getShort)*2 *)
     (1->a[inx+1].%getShort) %sll 1
     (* Above line tos_converted from: a[inx+1] -> TOS'%getShort[1]' -> TOS'%ShiftLeft[1]' *)
  #);

setSonInx:  (* Private *)
  (# inx1,inx2: @integer;
  enter (inx1,inx2)
  do (inx2 div 2,1) -> a[inx1+1].%putShort
  #);

packInxToValue:  (* Private *)
  (# val,inx: @integer;
     index: @integer;
     f: ^fragmentForm;
  enter (index,f[])
  do (if index=0 then
         0 -> val
      else
         f[] -> import.getIndex -> inx;
         (inx,0) -> val.%putShort;
         (index div 2,1) -> val.%putShort; 
     if)
  exit val   
  #);

valueToIndex:  (* Private *)
  (# val,inx,gInx: @integer;
     f: ^fragmentForm
  enter val
  do (if val=0 then
         0 -> inx
      else
         (* due to a compiler bug in r4.1, the code below must use
          * the old low level syntax. Can be changed to new syntax
          * when r4.2 has been frozen
          *)
         (0->val.%getShort) -> gInx -> import.getGroup -> f[];
         (* Above line tos_converted from: val -> TOS'%GetShort[0]' -> gInx -> import.getGroup -> f[]; *)
         (1->val.%getShort) %sll 1 -> inx
         (* Above line tos_converted from: val -> TOS'%GetShort[1]' -> TOS'%ShiftLeft[1]' -> inx *)
         (* 0 -> val.%GetShort -> gInx -> import.getGroup -> f[];*)
         (* (1 -> val.%GetShort)*2 -> inx *)
     if)
  exit (inx,f[])
  #);

isSlot:  (* Private *)
  (# inx: @integer;
     b: @boolean
  enter inx
  exit (0,1) -> a[inx].%GetBits -> b
  #);

--- fragmentFormImportPrivate:attributes ---
GetIndex: 
  (* return the index of the fragmentForm f.  If f is not in
   * the collection, a new index is allocated
   *)
  (# f: ^FragmentForm; t: ^text;
     Index: @integer;
     insertNew: 
       (# e: ^element;
          newL: ^list;
       do &element[] -> e[];
          fullName->stripPathName->t[];
          (if t[]=none then 
              'Import error (should not happen): stripped fullname is none!' 
                -> screen.putline;
              (f.FullName,'') -> thePathHandler.localPath -> t[];
           else 
              (f.FullName,t[]) -> thePathHandler.localPath -> t[];
          if);
          (f[],t.copy) -> (e.f[],e.n[]);
          (if ((inxC+1 -> inxC)>impL.l.range) then
              &list(# noOfElements:: (# do inxC+5 -> nu #)#)[] -> newL[];
              (for i: impL.l.range repeat impL.l[i][] -> newL.l[i][] for);
              newL[] -> impL[];
          if);
          e[] -> impL.l[inxC -> index][]
       #);
  enter f[]
  do search: 
       (for i: InxC repeat
            (if impL.l[i].f[]=f[] then i -> index; leave search if)
       for);
     (if index=0 then insertNew if);
  exit index
  #);               
GetGroup:
  (* Private: The inverse of GetIndex; If the group is not open then open it *)
  (# f: ^FragmentForm; Index: @integer;
     openForm:
       (# fg: ^fragmentGroup;
          name: ^Text;
          i: @Integer;
       enter name[]
       do '-'->name.findAll(# do inx->i #);
          thisOperation:
            ((1,i-1)->name.sub,screen[])
            ->top.open
          (# cleanup:
               (# msg: ^text;
               enter msg[]
               do 'getGroup error!! ' -> putLine;
                 'There is something wrong with the file "' -> puttext;
                  (1,i-1)->name.sub->puttext;
                 '"\n: ' -> puttext;
                  msg[]->puttext;
                  none ->f[];
                  none ->theCatcher[];
                  leave thisOperation
               #);
             readAccessError::< 
               (# do 'Read access error'->cleanup #);
             fragmentNotExisting::< 
               (# do 'Non-existent fragment file'->cleanup #);
             grammarNotFound::< 
               (# do 'Grammar not found for'->cleanup #);
             badFormat::<
               (#  do 'Bad AST format'->cleanup #);
             WriteAccessOnLstFileError::<
               (# do 'Access error on .lst file'->cleanup;  #);
             writeAccessError::<
               (# do 'No write access'->cleanup;  #);
             ParseErrors::<
               (#  do 'ParseErrors'->cleanup #);
             DoubleFormDeclaration::< 
               (# do 'Two forms are declared with the same name'->cleanup #);
             fatalParseError::<
               (# do 'Fatal parse errors'->cleanup #);
             OtherFileError::< 
               (# do 'Is a directory or other file errors'->cleanup #)
          #)->fg[];
          (if fg[]<>none then
              (if not fg.isRealOpen then fg.realOpen if);
              ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[];
          if)
       #);
  enter index
  do (if (impL.l[index].f[] -> f[])=NONE then
         (# t: ^text
         do fullName->stripPathName->t[];
            (if t[]=none then 
                (impL.l[index].n.copy,currentDirectory)
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
             else 
                (impL.l[index].n.copy,t[])
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
            if);
         #)
     if)
  exit f[]
  #);

--- treeLevelPrivate:attributes ---
kindOfSymbol: (* Private *)
  (# prod: @integer;
     knd: @integer
  enter prod
  do (if (prod<=0) then
         (if prod
          //prodNo.unExpanded then kinds.unexpanded -> knd;
          //prodNo.optional then kinds.optional -> knd;
          //prodNo.nameDecl then kinds.nameDecl -> knd;
          //prodNo.nameAppl then kinds.nameAppl -> knd;
          //prodNo.string then kinds.string -> knd;
          //prodNo.const then kinds.const -> knd;
          //prodNo.comment then kinds.comment -> knd;
          //prodNo.SlotDesc then kinds.SlotDesc -> knd;
         if);
      else kindArray[prod] -> knd 
     if);
  exit knd
  #); 
