ORIGIN '../astlevel';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
--- astPrivateLib:attributes ---

symbolInx: (* Private *)
  (# lab: @integer
  enter 
     (# val: @integer
     enter val do (val,4,12) -> frag.a[index].%putBits
     #)
  exit (4,12) -> frag.a[index].%getSignedBits -> lab
  #);

brotherInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val 
     do (val div 2,0) -> frag.a[index+1].%putShort
     #)
  exit (0->frag.a[index+1].%getShort)*2
  #);

sonInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index+1].%putShort
     #)
  exit (1->frag.a[index+1].%getShort)*2
  #);

slotUsageInx: (* Private *)
  (#
  enter frag.a[index+offset.slotUsage]
  exit frag.a[index+offset.slotUsage]
  #);

realCommentInx: (* Private *)
  (#
  enter 
     (# val: @integer; cinx: @integer 
     enter val 
     do (if (index -> frag.isSlot) then
            commentInx -> cinx;
            (val div 2,1) -> frag.a[cInx].%putShort
         else (val div 2,1) -> frag.a[index].%putShort
        if);
     #)
  exit 
     (# val: @integer
     do (if (index -> frag.isSlot) then
            (1->frag.a[commentInx].%getShort)*2 -> val
         else (1->frag.a[index].%getShort)*2 -> val
        if);
     exit val
     #)
  #);

commentInx: (* Private *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index].%putShort
     #)
  exit (1 -> frag.a[index].%getShort)*2
  #);

lexemInx: (* Private: same as sonInx *)
  (# val: @integer
  enter 
     (# enter val
     do (val div 2,1) -> frag.a[index+1].%putShort
     #)
  exit (1 -> frag.a[index+1].%getShort)*2
  #);

attributeInx1: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

commentTypeInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

valueInx: (* Private *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);

findFatherInx: (* Private *)
  (# i: @integer; b: @boolean
  do (* expansion of  
      *    index -> i;
      *    loop: (if true
      *           //(i=0) then
      *           //(i -> frag.isLastBrother) then
      *                       i -> frag.nextBrother -> i
      *           else i -> frag.nextBrother -> i;
      *                restart loop
      *          if);
      *)
     index -> i; 
     loop: (if true 
            //(i=0) then  
            //((2,1) -> frag.a[i].%GetBits -> b) then
               (0 -> frag.a[i+1].%GetShort)*2 -> i
            else (0 -> frag.a[i+1].%GetShort)*2 -> i; restart loop
           if)
  exit i
  #);
          
--- expandedPrivate:attributes ---
findIndex: (* Private: find index for son number 'sonnr' *)
  (# ERROR: 
       (# do
          'ERROR. sonnr = ' -> putText; (sonnr) -> putInt;
          ' trying to access a nonexistent son' -> stopYggdrasil;
       #);
     sonnr,i: @integer;
  enter sonnr
  do (1 -> frag.a[index+1].%getShort)*2 -> i;
     (* inline-expansion of sonInx -> i *)
     (for sonnr-1 repeat 
          (if (0<i) then
              (0 -> frag.a[i+1].%getShort)*2 -> i
              (* optimalization of i -> frag.getNextBrother -> i *) 
           else error 
          if);
     for);
  exit i
  #);

--- fragmentFormPrivate:attributes ---

getSonInx:  (* Private *)
  (# inx,val: @integer
  enter inx
  exit (1 -> a[inx+1].%getShort)*2
  #);

setSonInx:  (* Private *)
  (# inx1,inx2: @integer;
  enter (inx1,inx2)
  do (inx2 div 2,1) -> a[inx1+1].%putShort
  #);

packInxToValue:  (* Private *)
  (# val,inx: @integer;
     index: @integer;
     f: ^fragmentForm;
  enter (index,f[])
  do (if index=0 then
         0 -> val
      else
         f[] -> import.getIndex -> inx;
         (inx,0) -> val.%putShort;
         (index div 2,1) -> val.%putShort; 
     if)
  exit val   
  #);

valueToIndex:  (* Private *)
  (# val,inx,gInx: @integer;
     f: ^fragmentForm
  enter val
  do (if val=0 then
         0 -> inx
      else
         0 -> val.%GetShort -> gInx -> import.getGroup -> f[];
         (1 -> val.%GetShort)*2 -> inx
     if)
  exit (inx,f[])
  #);

isSlot:  (* Private *)
  (# inx: @integer;
     b: @boolean
  enter inx
  exit (0,1) -> a[inx].%GetBits -> b
  #);

--- fragmentFormImportPrivate:attributes ---
GetIndex: 
  (* return the index of the fragmentForm f.  If f is not in
   * the collection, a new index is allocated
   *)
  (# f: ^FragmentForm; t: ^text;
     Index: @integer;
     insertNew: 
       (# e: ^element;
          newL: ^list;
       do &element[] -> e[];
          fullName->stripPathName->t[];
          (if t[]=none then 
              'Import error (should not happen): stripped fullname is none!' 
                -> screen.putline;
              (f.FullName,'') -> thePathHandler.localPath -> t[];
           else 
              (f.FullName,t[]) -> thePathHandler.localPath -> t[];
          if);
          (f[],t.copy) -> (e.f[],e.n[]);
          (if ((inxC+1 -> inxC)>impL.l.range) then
              &list(# noOfElements:: (# do inxC+5 -> nu #)#)[] -> newL[];
              (for i: impL.l.range repeat impL.l[i][] -> newL.l[i][] for);
              newL[] -> impL[];
          if);
          e[] -> impL.l[inxC -> index][]
       #);
  enter f[]
  do search: 
       (for i: InxC repeat
            (if impL.l[i].f[]=f[] then i -> index; leave search if)
       for);
     (if index=0 then insertNew if);
  exit index
  #);               

GetGroup:
  (* Private: The inverse of GetIndex; If the group is not open then open it *)
  (# f: ^FragmentForm; Index: @integer;
     importException:< AstInterfaceException; error: ^stream;
     openForm:
       (# fg: ^fragmentGroup;
          name: ^Text;
          i: @Integer;
       enter name[]
       do '-'->name.findAll(# do inx->i #);
          ((1,i-1)->name.sub,screen[])->top.open->fg[];
          (if not fg.isRealOpen then (* open fg real *)
              fg.realOpen
          if);
          ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[];
       #);
  enter index
  do (if (impL.l[index].f[] -> f[])=NONE then
         (# t: ^text
         do fullName->stripPathName->t[];
            (if t[]=none then 
                (impL.l[index].n.copy,currentDirectory)
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
             else 
                (impL.l[index].n.copy,t[])
                  -> thePathHandler.convertFilePath -> openForm;
                f[] -> impL.l[index].f[]
            if);
         #);
         (if f[]=NONE then 
             (# t: ^text
             do &text[]->t[];
                'Import error!! ' -> t.putLine;
                'There is something wrong with the file "' -> t.putText;
                diskFileName -> t.putText;
                '"\n. It refers to the fragment "' -> t.putText;
                impL.l[index].n[] -> t.putText;
                '" which was not found \n\n.' -> t.putText;
                t[]->ImportException
             #)
         if)
     if)
  exit f[]
  #);

--- treeLevelPrivate:attributes ---
kindOfSymbol: (* Private *)
  (# prod: @integer;
     knd: @integer
  enter prod
  do (if (prod<=0) then
         (if prod
          //prodNo.unExpanded then kinds.unexpanded -> knd;
          //prodNo.optional then kinds.optional -> knd;
          //prodNo.nameDecl then kinds.nameDecl -> knd;
          //prodNo.nameAppl then kinds.nameAppl -> knd;
          //prodNo.string then kinds.string -> knd;
          //prodNo.const then kinds.const -> knd;
          //prodNo.comment then kinds.comment -> knd;
          //prodNo.SlotDesc then kinds.SlotDesc -> knd;
         if);
      else kindArray[prod] -> knd 
     if);
  exit knd
  #); 
