ORIGIN 'astPrivate';
LIB_ITEM 'mpsastlevel';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE 'astparser';
INCLUDE '../metagramsematt';
INCLUDE '../propertyparser';
INCLUDE '../utils/ast2asciiMap';
INCLUDE '~beta/basiclib/file';
--- fragmentgrouplib: attributes ---
fragmentGroupParser: propertyParser
  (* Recursive-descend parser for the grammar:
   *
   *   <group> ::= <propertyList> <fragmentOrGroup> EOF ;
   *   <propertyList> ::= <property> {';' property}* ;
   *   <property> ::| <predefined property>
   *                | <auxilary property> ;
   *   <predefined property> ::| <origin property> | <include property>
   *                           | <body property> | <mdbody property> ;
   *   <origin property>  ::= 'ORIGIN'  STRING                     ;
   *   <include property> ::= 'INCLUDE' STRING      {STRING}*      ;
   *   <body property>    ::= 'BODY'    STRING      {STRING}*      ;
   *   <mdbody property>  ::= 'MDBODY'  NAME STRING {NAME STRING}* ;
   *   <auxilary property>::= <propertyName> {NAME | STRING | CONST}* | EMPTY ;
   *
   *   <fragmentOrGroup> ::= <fragmentGroup> | <dash> {<fragment>}* ;
   *
   *   <fragmentGroup> ::= '[[' <dash> {<fragment>}* ']]' ;
   *   <fragment> ::= <fragmentForm> | <fragmentGroup> | <fragmentLink> ;
   *
   *   <fragmentForm> ::= <name:NAME> ':' <category:NAME> [':' <grammar:NAME>]
   *                      <dash> <GSF> <dash> ;
   *
   *   <fragmentLink> ::= 'INCLUDE' <formName:STRING> <dash> ;
   *
   * Lexical tokens: --(-)* [[ ]] ; : NAME STRING CONST EOF
   *
   *)
  (# parseFragmentOrGroup:
       (# EOL: @integer;gram: ^treelevel;
          
       do (if currentToken<>EOF then
	      (if currentToken=beginGroup then
		  beginGroup->accept; advance; endGroup->EOL;
	       else
		  EOF->EOL
	      if);
	      (* get the fragment form separator symbol and reset position for
	       * further parsing
	       *)
	      nextCh->EOSchar;
              (if EOSchar='<' then
                  (* '<<' is not allowed as fragment separator - to avoid
                   * confusion with nonterminal syntax
                   *)
                  0->EOSchar
              if);
	      inputPos-1->inputPos;
	      input.position-1->input.position;
	      advance;
              (if currentToken<>dash then
                  parseWithoutProperties
               else
	          advance;
	          (if currentToken=endGroup then
		      endGroup->accept; advance
	           else
		      EOL->parseFragmentList
	          if)
	      if)
          if)
       #);
     parseFragmentList:
       (# EOF: @integer
       enter EOF
       do loop:
	    (#
	    do parseFragment;
	       CommentSeparator1->fgComment.put;
	       (if currentToken<>EOF then restart loop if)
	    #);
	  advance
       #);
     parseFragmentGroup:
       (#
       do beginGroup->accept;
	  advance;
	  dash->accept;
	  advance;
	  endGroup->parseFragmentList
       #);
     parseFragment:
       (# errorText: @text
       do (if currentToken
	   // beginGroup then
	      parseFragmentGroup
	   // name then
	      parseFragmentForm
	   // include then
	      parseFragmentLink
	   else
	      'name include [['->errorText.puttext; (errorText,3)->markError
	  if)
       #);
     parseFragmentLink:
       (# propName: @text;
       do include->accept;
	  theText->propName;
	  advance;
	  string->accept;
	  propName.copy->prop.addProp
	    (# ifPropExist::  (# do false->delete #);
	    do theText.copy->addString;
	    #);
	  advance;
	  (if currentToken<>EOF then dash->accept; advance if);
       #);
     parseFragmentForm:
       (# fragmentName,category,grammar,errorText,t,tt: @text;
	  mg: ^metagrammar;
	  aGrammar: ^mg.Agrammar;
	  gram: ^treelevel;
       do name->accept;
	  theText->fragmentName;
	  advance;
	  colon->accept;
	  advance;
	  name->accept;
	  theText->category;
	  advance;
	  L:
	    (if currentToken=colon then
		advance;
		name->accept;
		theText->grammar;
		advance;
		(grammar[],error[])->grammartable.find
		  (# ifNotFound::
		       (# msg: @text;
		       do 'Could not find the grammar: '->msg;
			  grammar[]->msg.putline;
			  (errorNumbers.grammarNotFound,msg[])->catcher
		       #)
		  #)->gram[];
		gram[]->defaultGrammar[];
		(if gram[]=NONE then
                    (errorNumbers.grammarNotFound,'No defaultgrammar found.')
                      ->catcher
                if);
		(if (grammarTable.meta[]->mg[])=NONE then
                    (if 'metagrammar' -> grammar.equal then
			'\ngrammarTable.meta[]->mg is none (this is OK when booting metagrammar)\n' -> putline;
                        leave L;
                    else
		        (errorNumbers.grammarNotFound,'No metagrammar found.')
			  ->catcher
                    if);
		if);
		(if gram.grammarast[]=NONE then
                    (if 'metagrammar' -> grammar.equal then
			'\ngram.grammarast is none (this is OK when booting metagrammar)\n' -> putline;
                        leave L;
                    else
		        (errorNumbers.grammarNotFound,'defaultgrammar.grammarast not found.')
			  ->catcher
                    if);
		if);
		gram.grammarAst.root[]->aGrammar[];
		(if agrammar[]=NONE then
                    (if 'metagrammar' -> grammar.equal then
			'\nagrammar is none (this is OK when booting metagrammar)\n' -> putline;
                        leave L;
                    else
		        (errorNumbers.grammarNotFound,'defaultgrammar.grammarast.root not found.')
			  ->catcher
                    if);
		if);
		('EOSchar','-')->aGrammar.getOptionString->t;
		EOSchar->tt.put;
		(if not (tt[]->t.equal) then
		    '\nInconsistency between previously used'->errorText.puttext;
		    ' fragment separator symbol: "'->errorText.puttext;
		    EOSchar->errortext.put;
		    '" and grammar defined symbol: "'->errorText.puttext;
		    t[]->errorText.puttext;
		    '"'->errorText.put;
		    (errorText,13)->markError
		if)
	     else
                setupGrammar->gram[];
	    if);
          dash->accept;
          (fragmentName[],gram[],category[])->parseCodeFromCategory;
       #);
     parseCodeFromCategory: parseCode
       (# category: ^text;
       enter category[]
       do (* parse the actual source code in this fragment form *)
	  category.makeLC;
	  (if true
	   // ('attributes'->category.equal) then
	      'attributesForm'->category
	   // ('descriptor'->category.equal) then
	      'descriptorForm'->category
	  if);
          category[]->gram.parser.findSymbolNo->symbol;
          (if symbol=0 then
              (* This can happen if the start symbol is a zero-list '::*' *)
	      'MARKED'->(category.Copy).Append->gram.parser.findSymbolNo->symbol
	  if);
       #);
     parseCodeFromSymbol: parseCode
       (#
       enter symbol
       #);
     parseCode:
       (# fragmentName: ^text;
          gram: ^treelevel;
          checkNameAndCategory:<
            (# frag: ^fragmentForm enter frag[] do INNER #);
          symbol: @nonterminalSymbol;
          frag: ^fragmentForm;
          lstFile: @file
	    (# accessError::
		 (# 
                 do (errorNumbers.WriteAccessOnLstFileError,msg[])->catcher 
                 #);
               noSpaceError:: 
                 (# 
                 do (errorNumbers.noSpaceLeft,msg[])->catcher 
                 #);
               otherError:: 
                 (# 
                 do (errorNumbers.otherFileError,msg[])->catcher 
                 #)
	    #);
       enter (fragmentName[],gram[])
       do INNER;
	  (if symbol=0 then
	      ('"Name of construction nonterminal from the grammar expected as category"',
	       10)->markError;
	   else
	      gram[]->newfragmentForm->frag[];
	      THIS(fragmentGroup)[]->frag.fatherR[];
	      fragmentName.copy->frag.name;
	      inputPos->gram.parser.privatePart.initialPos;
              (symbol,input[],a2s[],error[],frag[])->gram.parser->ok;
              (if ok then
                  frag[]->checkNameAndCategory;
		  frag[]->fragmentList.addFragment
		    (# alreadyThere::
			 (#
			 do &text[]->offendingFormName[];
			    fragmentName->offendingFormName;
			    (errorNumbers.doubleFormDeclaration,msg[])
			      ->catcher
			 #)
		    #);
	       else
		  error.newLine;
		  'Parse errors '->error.putline;
		  input.reset;
		  (input[],error[])->gram.parser.ErrorReport;
		  input.reset;

                  '.lst'->((fullname).copy).append->lstFile.name;
		  (if (lstFile.entry.path.head->dirWriteable) then
		      (if lstFile.entry.writeable
			    (# error::
				 (#
				 do true->continue;
				    (errorNumbers.otherFileError,msg[])
				      ->catcher
				 #) #) then
                          lstFile.openWrite;
		          (input[],lstFile[])->gram.parser.ErrorReport;
		          lstFile.close
		       else
			  (# t: @text
			  do 'No write access to the file: "'->t;
			     lstFile.name->t.append; '"'->t.putline;
                             (input[],&text[]->parseErrorsLst[])
                               ->gram.parser.ErrorReport;
                             input.reset;
                             (errorNumbers.WriteAccessOnLstFileError,t[])
			       ->catcher;
			  #)
		      if)
		   else
		      (# t: @text
		      do 'No write access to the directory: "'->t;
			 lstFile.entry.path.head->t.append; '"'->t.putline;
                         (input[],&text[]->parseErrorsLst[])
                           ->gram.parser.ErrorReport;
                         input.reset;
                         (errorNumbers.WriteAccessOnLstFileError,t[])->catcher;
                      #)
		  if);
                  ''->parseErrors;
                  NONE->parseErrorsLst[];
	      if);
              (* update lexical scanner and position of stream *)
              gram.parser.parseEndPos+inputPos->inputPos;
              gram.parser.lastCh->nextCh;
              0->gram.parser.privatePart.initialPos;
              advance; 
              (* the bobs-parser actually did eat the dash, so
               * forget about accepting the dash
               *)
          if)
       exit frag[]
       #);
     parseWithoutProperties:
       (# gram: ^treelevel;
          frag: ^fragmentForm;
          f: @file; ext: ^text
       do (* try to parse directly, ignoring properties *)
          prop.proplist.clear;
          prop.init;
          none ->linklist[] (* to cancel cached INCLUDE's *);
          true->ok;
          0->inputPos;
          0->input.position;
          true->firstComment;
          fgComment.clear;	         
          textfileName->f.name;
          f.entry.path.name.suffix->ext[];
          l: grammarTable.scan
            (# 
            do (if ext[]->currentExtension.equalNCS then
                   (if current[]=NONE then
                       (currentName[],error[])->grammarTable.find
                       (# ifNotFound::
                            (# msg: @text;
                            do 'Could not find the grammar: '->msg;
                               currentName[]->msg.putline;
                               (errorNumbers.grammarNotFound,msg[])->catcher
                            #)
                       #)->current[]
                   if);
                   current[]->defaultGrammar[];
                   leave l
               if)
            #);
          setupGrammar->gram[];
          '_WITHOUT_FRAGMENT_SYNTAX'->prop.addProp;
          (if gram[]=grammarTable.beta[] then
              'ORIGIN'->prop.addProp
              (# do '~beta/basiclib/betaenv'->addString #);
              ('Untitled',gram[],'betaform')->
              parseCodeFromCategory
              (# checkNameAndCategory::
                   (#
                   do (if frag.root.symbol
                       // 'descriptorForm'->gram.parser.findSymbolNo then
                          'program'->frag.name
                       // 'attributesForm'->gram.parser.findSymbolNo then
                          'lib'->frag.name
                      if)
                   #)
              #)
           else
              ('Untitled',gram[],1(*startSymbol*))->parseCodeFromSymbol
          if)
       #);
     setupGrammar:
       (# gram: ^treelevel;
       do defaultGrammar[]->gram[];
          (if gram[]=NONE then
              (if grammarTable.beta[]=NONE then
                  ('beta',error[])->grammarTable.find
                  (# ifNotFound::
                       (# msg: @text;
                       do 'Could not find the grammar: '->msg;
                          'beta'->msg.putline;
                          (errorNumbers.grammarNotFound,msg[])->catcher
                       #)
                  #)->grammarTable.beta[]
              if);
              grammarTable.beta[]->gram[];
          if);
          gram[]->defaultGrammar[];
          (if gram[]=NONE then
              (errorNumbers.grammarNotFound,'No defaultgrammar found.')
                ->catcher
          if);
          (if gram.parser[]=NONE then
              (errorNumbers.grammarNotFound,'defaultgrammar.parser not found.')
                ->catcher
              
          if);
	  (if not gram.parser.haveBeenInitialized then
	      (# msg: @text;
	      do 'Error: Missing parse-tables for grammar: '->msg;
		 gram.grammarIdentification->msg.putLine;
		 (errorNumbers.grammarNotFound,msg[])->catcher
	      #)
	  if)
       exit gram[]
       #);
     a2s: ^ a2sHandle
  do &a2sHandle[] -> a2s[];
     a2s.openWrite;
     parsePropertyList;
     parseFragmentOrGroup;
     EOF->accept;
     a2s.close;
  #)

-- fragmentGroupParseGroupParser: Descriptor --
(# input: @file
do inputname[]->input.name; 
   (if input.entry.isFile
	 (# error::
	      (#
	      do true->continue;
		 (errorNumbers.otherFileError,msg[])->catcher
	      #) #) then
       (if input.entry.readable
	     (# error::
		  (#
		  do true->continue;
		     (errorNumbers.otherFileError,msg[])->catcher
		  #) #) then
	   input.openRead
	else
	   (# t: @text
	   do 'No read access to the file: "'->t;
	      input.name->t.append; '"'->t.putline;
	      (errorNumbers.noReadAccess,t[])->catcher
	   #)
       if)
    else
       (# t: @text
       do 'Filename "'->t;
	  input.name->t.append;
	  '" refers to a directory, not a file'->t.putline;
	  (errorNumbers.otherFileError,t[])->catcher
       #)
   if);

   (input[],error[])
     ->fragmentGroupParser
     (# parseErrors:: (# do msg[]->this(parse).parseErrors;true->continue #) #)
     ->ok;

   (if ok then markAsChanged if);

   input.close;
  
#)
