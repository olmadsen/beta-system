 ORIGIN 'astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
INCLUDE 'astparser';
INCLUDE '../metagramsematt';
INCLUDE '../propertyparser';
--- fragmentgrouplib: attributes ---
fragmentGroupParser: propertyParser
  (* Recursive-descend parser for the grammar:
   *
   *   <group> ::= <propertyList> <fragmentOrGroup> EOF ;
   *   <propertyList> ::= <property> {';' property}* ;
   *   <property> ::| <predefined property>
   *                | <auxilary property> ;
   *   <predefined property> ::| <origin property> | <include property>
   *                           | <body property> | <mdbody property> ;
   *   <origin property>  ::= 'ORIGIN'  STRING                     ;
   *   <include property> ::= 'INCLUDE' STRING      {STRING}*      ;
   *   <body property>    ::= 'BODY'    STRING      {STRING}*      ;
   *   <mdbody property>  ::= 'MDBODY'  NAME STRING {NAME STRING}* ;
   *   <auxilary property>::= <propertyName> {NAME | STRING | CONST}* | EMPTY ;
   *
   *   <fragmentOrGroup> ::= <fragmentGroup> | <dash> {<fragment>}* ;
   *
   *   <fragmentGroup> ::= '[[' <dash> {<fragment>}* ']]' ;
   *   <fragment> ::= <fragmentForm> | <fragmentGroup> | <fragmentLink> ;
   *
   *   <fragmentForm> ::= <name:NAME> ':' <category:NAME> [':' <grammar:NAME>]
   *                      <dash> <GSF> <dash> ;
   *
   *   <fragmentLink> ::= 'INCLUDE' <formName:STRING> <dash> ;
   *
   * Lexical tokens: --(-)* [[ ]] ; : NAME STRING CONST EOF
   *
   *)
  (# parseFragmentOrGroup:
       (# EOL: @integer
       do (if currentToken<>EOF then
	      (if currentToken=beginGroup then
		  beginGroup->accept; advance; endGroup->EOL;
	       else
		  EOF->EOL
	      if);
	      (* get the fragment form separator symbol and reset position for
	       * further parsing
	       *)
	      nextCh->EOSchar;
	      inputPos-1->inputPos;
	      input.position-1->input.position;
	      advance;
	      dash->accept;
	      advance;
	      (if currentToken=endGroup then
		  endGroup->accept; advance
	       else
		  EOL->parseFragmentList
	      if)
	  if)
       #);
     parseFragmentList:
       (# EOF: @integer
       enter EOF
       do loop:
	    (#
	    do parseFragment;
	       CommentSeparator1->fgComment.put;
	       (if currentToken<>EOF then restart loop if)
	    #);
	  advance
       #);
     parseFragmentGroup:
       (#
       do beginGroup->accept;
	  advance;
	  dash->accept;
	  advance;
	  endGroup->parseFragmentList
       #);
     parseFragment:
       (# errorText: @text
       do (if currentToken
	   // beginGroup then
	      parseFragmentGroup
	   // name then
	      parseFragmentForm
	   // include then
	      parseFragmentLink
	   else
	      'name include [['->errorText.puttext; (errorText,3)->markError
	  if)
       #);
     parseFragmentLink:
       (# propName: @text;
       do include->accept;
	  theText->propName;
	  advance;
	  string->accept;
	  propName.copy->prop.addProp
	    (# ifPropExist::  (# do false->delete #);
	    do theText.copy->addString;
	    #);
	  advance;
	  (if currentToken<>EOF then dash->accept; advance if);
       #);
     parseFragmentForm:
       (# fragmentName,category,grammar,errorText,t,tt: @text;
	  mg: ^metagrammar;
	  aGrammar: ^mg.Agrammar;
	  gram: ^treelevel;
	  frag: ^fragmentForm;
	  ch: @char;
	  lastPos: @integer;
	  symbol: @nonterminalSymbol;
	  lstFile: @file
	    (# accessError::
		 (# do (errorNumbers.WriteAccessOnLstFileError,msg[])->catcher #)
	    #);
       do name->accept;
	  theText->fragmentName;
	  advance;
	  colon->accept;
	  advance;
	  name->accept;
	  theText->category;
	  advance;
	  L:
	    (if currentToken
	     // colon then
		advance;
		name->accept;
		theText->grammar;
		advance;
		(grammar[],error[])->grammartable.find
		  (# ifNotFound::
		       (# msg: @text;
		       do 'Could not find the grammar: '->msg;
			  grammar[]->msg.putline;
			  (errorNumbers.grammarNotFound,msg[])->catcher
		       #)
		  #)->gram[];
		gram[]->defaultGrammar[];
		(if gram[]=NONE then 'gram is NONE'->putline; leave L if);
		(if (grammarTable.meta[]->mg[])=NONE then
		    'grammarTable.meta is NONE'->putline; leave L
		if);
		(if gram.grammarast[]=NONE then
		    'gram.grammarast is NONE'->putline; leave L
		if);
		gram.grammarAst.root[]->aGrammar[];
		(if agrammar[]=NONE then
		    'aGrammar is NONE'->putline; leave L
		if);
		('EOSchar','-')->aGrammar.getOptionString->t;
		EOSchar->tt.put;
		(if not (tt[]->t.equal) then
		    '\nInconsistency between previously used'->errorText.puttext;
		    ' fragment separator symbol: "'->errorText.puttext;
		    EOSchar->errortext.put;
		    '" and grammar defined symbol: "'->errorText.puttext;
		    t[]->errorText.puttext;
		    '"'->errorText.put;
		    (errorText,13)->markError
		if)
	     else
		defaultGrammar[]->gram[];
		(if gram[]=NONE then
		    (if grammarTable.beta[]=NONE then
			('beta',error[])->grammarTable.find
			  (# ifNotFound::
			       (# msg: @text;
			       do 'Could not find the grammar: '->msg;
				  'beta'->msg.putline;
				  (errorNumbers.grammarNotFound,msg[])->catcher
			       #)
			  #)->grammarTable.beta[];
		    if);
		    grammarTable.beta[]->gram[];
		    gram[]->defaultGrammar[]
		if);
		(if gram[]=NONE then
		    (errorNumbers.grammarNotFound,'No defaultgrammar found.')
		      ->catcher
		if);
	    if);
	  (* do the parse *)
	  (if gram.parser[]=NONE then 'gram.parser is NONE'->putline if);
	  (if not gram.parser.haveBeenInitialized then
	      (# msg: @text;
	      do 'Error: Missing parse-tables for grammar: '->msg;
		 grammar[]->msg.putLine;
		 (errorNumbers.grammarNotFound,msg[])->catcher
	      #)
	  if);
	  inputPos->lastPos->gram.parser.privatePart.initialPos;
	  category.makeLC;
	  (if true
	   // ('attributes'->category.equal) then
	      'attributesform'->category
	   // ('descriptor'->category.equal) then
	      'descriptorform'->category
	  if);
	  category[]->gram.parser.findSymbolNo->symbol;
	  (if symbol=0 then
	      'MARKED'->(category.Copy).Append->gram.parser.findSymbolNo->symbol
	  if);
	  (if symbol=0 then
	      ('name of construction nonterminal from the grammar expected as category',
	       10)->markError;
	   else
	      dash->accept;
	      gram[]->newfragmentForm->frag[];
	      THIS(fragmentGroup)[]->frag.fatherR[];
	      fragmentName.copy->frag.name;
	      (symbol,input[],error[],frag[])->gram.parser->ok;
	      (if ok then
		  frag[]->fragmentList.addFragment
		    (# alreadyThere::
			 (#
			 do &text[]->offendingFormName[];
			    fragmentName->offendingFormName;
			    (errorNumbers.doubleFormDeclaration,msg[])
			      ->catcher
			 #)
		    #);
	       else
		  error.newLine;
		  'Parse errors '->error.putline;
		  input.reset;
		  (input[],error[])->gram.parser.ErrorReport;
		  input.reset;
		  (# t: ^text
		  do fullName->t[]; '.lst'->(t.copy).Append->lstFile.name;
		  #);
		  (if (lstFile.entry.path.head->dirWriteable) then
		      (if lstFile.entry.writeable
			    (# error::
				 (#
				 do true->continue;
				    (errorNumbers.otherFileError,msg[])
				      ->theCatcher
				 #) #) then
			  lstFile.openWrite
		       else
			  (# t: @text
			  do 'No write access to the file: "'->t;
			     lstFile.name->t.append; '"'->t.putline;
			     (errorNumbers.WriteAccessOnLstFileError,t[])
			       ->catcher
			  #)
		      if)
		   else
		      (# t: @text
		      do 'No write access to the directory: "'->t;
			 lstFile.entry.path.head->t.append; '"'->t.putline;
			 (errorNumbers.WriteAccessOnLstFileError,t[])->catcher
		      #)
		  if);
		  (input[],lstFile[])->gram.parser.ErrorReport;
		  lstFile.close;
		  ''->parseErrors;
	      if);
	      (* update lexical scanner and position of stream *)
	      gram.parser.parseEndPos+inputPos->inputPos;
	      gram.parser.lastCh->nextCh;
	      0->gram.parser.privatePart.initialPos;
	      advance;
	      (* the bobs-parser actually did eat the dash, so forget about
	       * accepting the dash
	       *)
	  if)
       #);
  do parsePropertyList; parseFragmentOrGroup; EOF->accept
  #)

-- fragmentGroupParseGroupParser: Descriptor --
(#
do (if input.entry.isFile
	 (# error::
	      (#
	      do true->continue;
		 (errorNumbers.otherFileError,msg[])->theCatcher
	      #) #) then
       (if input.entry.readable
	     (# error::
		  (#
		  do true->continue;
		     (errorNumbers.otherFileError,msg[])->theCatcher
		  #) #) then
	   input.openRead
	else
	   (# t: @text
	   do 'No read access to the file: "'->t;
	      input.name->t.append; '"'->t.putline;
	      (errorNumbers.noReadAccess,t[])->catcher
	   #)
       if)
    else
       (# t: @text
       do 'Filename "'->t;
	  input.name->t.append;
	  '" refers to a directory, not a file'->t.putline;
	  (errorNumbers.otherFileError,t[])->catcher
       #)
   if);

   (input[],error[])
     ->fragmentGroupParser
     (# parseErrors:: (# do msg[]->this(parse).parseErrors;true->continue #) #)
     ->ok;

   (if ok then markAsChanged if);

   input.close;

#)
