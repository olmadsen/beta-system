ORIGIN 'metagrammarcfl'
[[
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
--- prodAttributes: attributes ---
(* idx: 1 *)
leftSide: 
  (# 
  enter putson1
  exit getson1
  #);
getSynDeclText: 
  (# ls: ^this(metagrammar).leftSide;
     sd: ^SynDeclName;
     n: ^NameDecl;
  do getson1 -> ls[];
     ls.GetSynDeclName -> sd[];
     sd.getNameDecl -> n[];
  exit n.getText
  #);
superValue: 
  (# ls: ^this(metagrammar).leftSide;
  do getson1 -> ls[];
  exit ls.superValue
  #);
superProd: 
  (# prodNo: @integer;
     theProd: ^prod;
     predefined:< object;
     f: ^productionList
  do superValue -> prodNo;
     (if (prodNo>0)//true then
         father -> f[];
         prodNo -> f.get -> theProd[]
      else predefined
     if)
  exit theProd[]
  #)

--- leftsideAttributes: attributes ---
getSynDeclText: 
  (# sd: ^SynDeclName;
     n: ^nameDecl;
  do GetSynDeclName -> sd[];
     sd.getNameDecl -> n[];
  exit n.getText
  #);
superValue: 
  (# value: @integer
  enter (# enter value do (value,1) -> putAttribute #)
  exit 1 -> getAttribute
  #);
attributeSize: 
  (# value: @integer
  enter (# enter value do (value,2) -> putAttribute #)
  exit 2 -> getAttribute
  #);

--- taggedSyncatAttributes: attributes ---
getSynText: 
  (# sn: ^synName;
     n: ^nameappl;
  do getSynName -> sn[];
     sn.getNameAppl -> n[];
  exit n.getText
  #);
getTagText: 
  (# tn: ^tagName;
     n: ^nameDecl;
  do getTagName -> tn[];
     tn.getNameDecl -> n[];
  exit n.getText
  #);

--- terminalAttributes: attributes ---
getText: 
  (# s: ^string
  do getString -> s[];
  exit s.getText
  #)

--- syncatAttributes: attributes ---
getSynText: 
  (# sn: ^synName;
     s: ^nameappl;
  do getSynName -> sn[];
     sn.getNameAppl -> s[];
  exit s.getText
  #);

--- synNameAttributes: attributes ---
dclRef: 
  (# value: @integer
  enter (# enter value do (value,1) -> putAttribute #)
  exit 1 -> getAttribute
  #);
dclRefProd: 
  (# prodNo: @integer;
     theProd: ^prod;
     predefined:< object;
     theGrammar: ^agrammar;
  do dclRef -> prodNo;
     (if (prodNo>0)//true then
         frag.root[] -> theGrammar[];
         prodNo -> theGrammar.getProd -> theProd[]
      else predefined
     if)
  exit theProd[] 
  #);
getSynText: 
  (# s: ^nameappl;
  do getNameAppl -> s[];
  exit s.getText
  #);

--- AGrammarAttributes: attributes ---
getProd: 
  (# prodNo: @integer;
     theProd: ^prod;
     pl: ^productionList;
  enter prodNo
  do getProductionList -> pl[];
     prodNo -> pl.get -> theProd[] 
  exit theProd[] 
  #);
OptionSet: 
  (# t: @text;
     optSpec: ^optionSpecification;
     opPart: ^optionPart;
     op: ^ast;
     optList: ^optionList;
  enter t
  do getOptionOp -> op[];
     (if (op.symbol=optionPart)
      //true then
         op[] -> opPart[];
         opPart.getOptionList -> optList[];
     if);
     (if (optList[]=none)
      //false then
         scan: optList.scan
           (#
              optionEl: ^optionElement;
              optName: ^optionName;
              ap: ^nameAppl;
           do
              current[] -> optionEl[];
              optionEl.getOptionName -> optName[];
              optName.getNameAppl -> ap[];
              (if (ap.getText -> t.equalNCS)
               //true then
                  optionEl.getOptionSpecification -> optSpec[];
                  leave scan;
              if);
           #)
     if)
  exit OptSpec[]
  #);
checkOption: 
  (# errortext: @text;
     spec: ^optionSpecification;
     checkedSymbol: @integer;
     as: ^ast;
  enter (spec[],errortext,checkedSymbol)
  do (if (spec.symbol=checkedSymbol)
      //false then
         'ERROR in option-Specification for ' -> putText;
         errorText[] -> putText;
         screen.newLine;
         'Expected symbol: ' -> screen.putText;
         checkedSymbol -> screen.putInt;
         screen.newLine;
         'Found symbol: ' -> screen.putText;
         spec.symbol -> screen.putInt;
         screen.newLine;
      //true then
         spec.getson1 -> as[];
     if)
  exit as[]
  #);
GetOptionValue: 
  (# value: @integer;
     optionName: @text;
     c: ^const;
     optSpec: ^optionSpecification;
  enter (optionName,value)
  do (if ((optionName -> optionSet -> optSpec[])=none)
      //false then
         (optSpec[],OptionName,optionConst) -> checkOption -> c[];
         c.getValue -> value;
     if);
  exit value
  #);
GetOptionName: 
  (# value: @text;
     theOptionName: @text;
     c: ^lexemText;
     optSpec: ^optionSpecification;
  enter (theOptionName,value)
  do (if ((theOptionName -> optionSet -> optSpec[])=none)
      //false then
         (optSpec[],theOptionName,optionName) -> checkOption -> c[];
         c.getText -> (# t: ^text enter t[] exit t #) -> value;
     if);
  exit value
  #);
GetOptionString: 
  (# value: @text;
     optionName: @text;
     c: ^lexemText;
     optSpec: ^optionSpecification;
  enter (optionName,value)
  do (if ((optionName -> optionSet -> optSpec[])=none)
      //false then
         (optSpec[],OptionName,optionString) -> checkOption -> c[];
         c.getText -> (# t: ^text enter t[] exit t #) -> value;
     if);
  exit value
  #);
---]]
