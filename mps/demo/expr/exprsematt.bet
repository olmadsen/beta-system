ORIGIN 'exprcfl';
INCLUDE '~beta/containers/v1.6/hashTable'
--- expressionAttributes: attributes ---
eval: 
  (# value: @integer ;
     n: ^number;
     cnst: ^const;
     m: ^multExpression;
     a: ^addExpression;
     anAst: ^ast;
     be: ^bracketExpression;
     e1,e2: ^expression;
     var: ^variable;
     na: ^nameAppl;
  do (if symbol
      //bracketExpression then 
         this(expression)[] -> be[]; be.getExpression -> e1[]; e1.eval -> value
      //multexpression then 
         this(expression)[] -> m[];
         m.getOperand1 -> e1[]; m.getoperand2 -> e2[];
         m.getMultOperator -> anAst[];
         (if anAst.symbol
          //timesop then e1.eval * e2.eval -> value
          //divop then e1.eval div e2.eval -> value
          //modOp then e1.eval mod e2.eval -> value
         if);
      //addexpression then
         this(expression)[] -> a[];
         a.getOperand1 -> e1[]; a.getOperand2 -> e2[];
         a.getAddOperator -> anAst[];
         (if anAst.symbol
          //plusOp then e1.eval + e2.eval -> value
          //minusOp then e1.eval - e2.eval -> value
         if)
      //number then this(expression)[] -> n[]; n.getConst -> cnst[]; cnst.getValue -> value
      //variable then this(expression)[] -> var[];
         var.getnameAppl -> na[];
         (# e: ^dcAtt.symbolTable.element
         do na[] -> dcAtt.symbolTable.findKey -> e[];
            (if e[]=none then
                na.getText -> screen.putText;
                ' is not declared ' -> screen.putLine;
             else e.e.eval -> value
            if);
         #);
     if)  
  exit value
  #)

--- dcAtt: descriptor ---
(# symbolTable: @hashTable
     (# element::< (# id: ^lexemText; e: ^expression #);
        hashFunction::< 
          (# t: ^text 
          do e.id.getText -> t[];
             t.scan(# do (ch->ascii.lowCase)+133*value -> value #);
          #);
        equal::< 
          (# equalText: (# t1,t2: ^text enter (t1[],t2[]) exit t1[] -> t2.equalNCS #)
          do (left.id.getText,right.id.getText) -> equalText -> value
          #);
        findKey: 
          (# e: @element; found: ^element
          enter e.id[]
          do scan(# where::< (# do (e[],current[]) -> equal -> value #)
                 do current[] -> found[] #)
          exit found[]
          #);
     #);
   init: (# do symbolTable.init #);
#)

------ statAttributes: attributes ------
run: 
  (# expr: ^expression;
     eval: ^evalStatement;
     let: ^assignment;
     elm: ^dcAtt.symbolTable.element
  do (if symbol
      //assignment then 
         this(stat)[] -> let[];
         &dcAtt.symbolTable.element[] -> elm[];
         let.getName -> elm.id[];
         let.getExpression -> elm.e[];
         elm[] -> dcAtt.symbolTable.insert;
      //evalStatement then
         this(stat)[] -> eval[];
         eval.getExpression -> expr[];
         expr.eval -> screen.putInt;
         screen.newLine 
      //quit then (normal,'') -> stop
     if);
  #);
