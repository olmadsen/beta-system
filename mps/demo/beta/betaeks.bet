ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/mps/findgrammar';
INCLUDE '~beta/betaast/betasematt'
--- program: descriptor ---
(* This fragment is an example of using the Mjolner BETA Metaprogramming
 * system on the BETA grammar.
 * 
 * For pretty printing use: ~beta/bin/pp
 *)
(# ast: @astInterface
     (# (* such that we can find the grammars mentioned in
	 * ~beta/configuration/MBSgrammars.text etc.
	 *)
	defaultGrammarFinder:: findGrammar
     #); (* An instance of the AST interface *)
   beta: @ast.beta;    (* The MPS interface to the BETA grammar/ASTs *)
   fg: ^ast.fragmentGroup; (* A group for inserting beta forms *)
   InitAstEnv: 
     (* Initialization of the meta programming system *)
     (# groupFileName, btabFile: @text (* the name of the .group file *)
     enter groupFileName
     do ast.astLevelInit;
        beta.init; 
        '~beta/grammars/beta/beta-parser' -> btabFile;
        ast.parserFileExtension->btabFile.puttext;
        btabFile[] -> ast.expandToFullPath 
	  -> beta.parser.initialize;
        ast.newFragmentGroup -> fg[];
        ast.top.topGroup[] -> fg.father;
        groupFileName[] -> ast.expandToFullPath -> fg.name;
     #);
   NewForm: 
     (* create a new fragment form in the group fg *)
     (# formName: @text; ff: ^ast.fragmentForm
     enter formName
     do beta[] -> ast.newFragmentForm -> ff[]; 
        formName.copy -> ff.name;
        ff[] -> fg.fragmentList.addFragment;
     exit ff[]
     #);
   TextToAst: 
     (* Parses the text T according to SyntaxticCategeory; the resulting AST
      * will belong to the fragmentForm 'ff'
      *)
     (# T: @text; SyntacticCategory: @Integer; ff: ^ast.fragmentForm
     enter(T,SyntacticCategory,ff[])
     do 0->T.setPos;
        (if ((SyntacticCategory,T[],screen[],ff[]) -> beta.parser)//false then
            'Parse error in: '-> puttext; T[]->puttext; newline
        if)
     exit ff.root[]
     #);
do (# myForm: ^ast.fragmentForm;
      df: ^beta.descriptorForm;
      obj: ^beta.objectDescriptor;
      aMainPart: ^beta.MainPart;
      pd: ^BETA.patternDecl;
      imp: ^beta.imp;
      imps: ^beta.imperatives;
      at: ^beta.attributes
   do 'Calro'->InitAstEnv;
      'abekat'->NewForm->myForm[];
      ('foo: (# a,b: @integer do INNER #)',beta.patternDecl,myForm[])
        -> &textToAST -> pd[];
      ('(# do <<SLOT pip: objectDescriptor>> #)',beta.DescriptorForm,myForm[])
        -> &TextToAST -> df[];
      df.getObjectDescriptor->obj[];
      obj.getMainPart->aMainPart[];
      aMainPart.getAttributes->at[];
      pd[]->at.append;
      ast.unexpanded -> obj.suffixWalkForProd
      (# unExp: ^ast.unExpanded;
         sl: ^ast.slotDesc;
         name: @text
      do current[] -> unExp[];
         (if unExp.isSlot
          //true then
             unExp.theSlot -> sl[];
             sl.name -> name.puttext;
             (if ('pip' -> name.equal)
              //true then 'pap' -> sl.name
         if)if)
      #);
      fg.markAsChanged
   #)
#)
