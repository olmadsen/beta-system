ORIGIN '~beta/mps/astlevel'; 
INCLUDE '~beta/basiclib/binfile';
INCLUDE '~beta/sysutils/endian';
BODY 'private/ast2asciiMapBody'
---fragmentGroupLib:attributes---
(* The a2sHandle keeps track of a mapping from 
 * AST-index to character positions in the .bet file
 * corresponding to the AST.
 * For a file foo.bet/foo.ast/foo.astL, the mapping is
 * saved in a file foo.a2s.
 * The astparser creates the mapping using a2sHandle
 * and operations such as openWrite, newForm, putPos and close.
 * The compiler (and others) may use the mapping
 * via operations such as openRead, getPos and close.
 * If no .a2s file exists, getPos returns (0,0)
 *)
a2sHandle: a2sInterface
  (# (* Note! The constants bigEndianValue and littleEndianValue 
      * are endian independent in the sense that their 4-byte 
      * value is the same on both a little- and big endian machine
      *)
     bigEndianValue: (# exit 0xffffffff #);
     littleEndianValue: (# exit 0x11111111 #);
     warning:<
       (# msg: ^text
       enter msg[]
       do INNER;          
       #);
     
     forms: [1] ^map; formsTop: @integer;
     
     head: [4] @integer; (* head[1] = range of astIndex, start and end
                          * head[2] = top
                          * head[3] = littleEndianValue or bigEndianValue
                          *)
     astIndex,start,end: [100]@integer;
     top: @integer;
     
     map:
       (# firstPos,lastPos: @integer;
          getPos:
            (# index,startPos,endPos,k: @integer
            enter index
            do L:
                 (for i: lastPos-firstPos+1 repeat
                      (if index = astIndex[firstPos + i - 1 -> k] then
                          start[k] -> startPos;
                          end[k] -> endPos;
                          leave L
                 if)for)
            exit(startPos,endPos)
            #)
       enter(firstPos,lastPos)
       exit this(map)[]
       #);
     dump:
       (#
       do '\n***' -> putline;
          (for i: head.range repeat
               i->putint; ':'->put; head[i] -> putint; newline
          for);
          (for i: top repeat 
               i->putint; ':'->put;
               astIndex[i] -> putint; ' ' -> put;
               start[i] -> putint;  ' ' -> put;
               end[i] -> putint;  ' ' -> put;
               newline
          for);
       #);
     openForWrite,openForRead,a2sFileExist: @boolean;
     
     a2sBinFile: binfile
       (# mkFileName: booleanValue
            (# fragName: ^text
            do fullName -> fragName[];
               
               '.a2s' -> fragName.append -> this(a2sBinFile).name;
               entry.exists -> a2sFileExist -> value;
               (* fragName[] -> puttext; value -> putint; newline*)
            #);
          accessError::< (#do 'Access error' -> a2serror #);
          noSpaceError::< (# do 'No more disk space'-> a2serror #);
          writeError::< (#do 'Write error' -> a2sError #);
          otherError::< (#do 'Unknown error'-> a2sError #);
          a2sError:<
            (# m,msg: ^text
            enter m[]
            do 'File error for: "' -> msg[];
               this(a2sBinFile).name -> msg.puttext;
               '"\n\t' -> msg.puttext; 
               m[] -> msg.putline;
               INNER
            #)
       #);
     openWrite:<
       (#
       do (*'\nOpenWrite a2sHandle:' -> puttext;*)
          true -> openForWrite
       #);
     openRead:<
       (# 
       <<SLOT ast2asciiMap_openRead:doPart>>
       #);
     close:< 
       (# 
       <<SLOT ast2asciiMap_close:doPart>>          
       #);
     newForm:
       (#
       do (if (top+1->top) >= astIndex.range then 
              astIndex.range -> astIndex.extend;
              start.range -> start.extend;
              end.range -> end.extend;
          if);
          -1 -> astIndex[top];
       #);
     putPos:
       (# index,startPos,endPos: @integer
       enter(startPos,endPos,index)
       do (if (top+1->top) >= astIndex.range then 
              astIndex.range -> astIndex.extend;
              start.range -> start.extend;
              end.range -> end.extend;
          if);
          startPos -> start[top];
          endPos -> end[top];
          index -> astIndex[top];
          (* 'put: ' -> puttext;
           top -> putint; ' '->put;
           index -> putint; ' ' -> put;
           startPos -> putint; ' ' -> put;
           endPos -> putint; newline
           *)
       #);
     getPos:
       (# frag: ^fragmentForm; index: @integer;
          startPos,endPos: @integer;
          fragNo: @integer
       enter(frag[],index)
       do (if not openForRead then openRead if);
          (if a2sFileExist then
              L:
                fragmentList.scan
                (#
                do fragNo+1 -> fragNo;
                   (if frag[] = current.open then leave L if)
                #);
              (*  '\nFragment form:' -> puttext; fragNo -> putint; *)
              (if (0 < fragNo) and (fragNo <= formsTop) then
                  index -> forms[fragNo].getPos -> (startPos,endPos)
              if)
          if)
       exit(startPos,endPos)
       #)
  #);
