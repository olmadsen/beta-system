ORIGIN '~beta/mps/astlevel'; 
INCLUDE '~beta/basiclib/binfile';
INCLUDE '~beta/sysutils/endian'
---fragmentGroupLib:attributes---
(* The a2sHandle keeps track of a mapping from 
 * AST-index to character positions in the .bet file
 * corresponding to the AST.
 * For a file foo.bet/foo.ast/foo.astL, the mapping is
 * saved in a file foo.a2s.
 * The astparser creates the mapping using a2sHandle
 * and operations such as openWrite, newForm, putPos and close.
 * The compiler (and others) may use the mapping
 * via operations such as openRead, getPos and close.
 * If no .a2s file exists, getPos returns (0,0)
 *)
a2sHandle: a2sInterface
  (# (* Note! The constants bigEndianValue and littleEndianValue 
      * are endian independent in the sense that their 4-byte 
      * value is the same on both a little- and big endian machine
      *)
     bigEndianValue: (# exit 0xffffffff #);
     littleEndianValue: (# exit 0x11111111 #);
     warning:<
       (# msg: ^text
       enter msg[]
       do INNER;          
       #);
     
     forms: [1] ^map; formsTop: @integer;
     
     head: [4] @integer; (* head[1] = range of astIndex, start and end
                          * head[2] = top
                          * head[3] = littleEndianValue or bigEndianValue
                          *)
     astIndex,start,end: [100]@integer;
     top: @integer;
     
     map:
       (# firstPos,lastPos: @integer;
          getPos:
            (# index,startPos,endPos,k: @integer
            enter index
            do L:
                 (for i: lastPos-firstPos+1 repeat
                      (if index = astIndex[firstPos + i - 1 -> k] then
                          start[k] -> startPos;
                          end[k] -> endPos;
                          leave L
                 if)for)
            exit(startPos,endPos)
            #)
       enter(firstPos,lastPos)
       exit this(map)[]
       #);
     dump:
       (#
       do '\n***' -> putline;
          (for i: head.range repeat
               i->putint; ':'->put; head[i] -> putint; newline
          for);
          (for i: top repeat 
               i->putint; ':'->put;
               astIndex[i] -> putint; ' ' -> put;
               start[i] -> putint;  ' ' -> put;
               end[i] -> putint;  ' ' -> put;
               newline
          for);
       #);
     openForWrite,openForRead,a2sFileExist: @boolean;
     
     a2sBinFile: binfile
       (# mkFileName: booleanValue
            (# fragName: ^text
            do fullName -> fragName[];
               
               '.a2s' -> fragName.append -> this(a2sBinFile).name;
               entry.exists -> a2sFileExist -> value;
               (* fragName[] -> puttext; value -> putint; newline*)
            #);
          accessError::< (#do 'Access error' -> a2serror #);
          noSpaceError::< (# do 'No more disk space'-> a2serror #);
          writeError::< (#do 'Write error' -> a2sError #);
          otherError::< (#do 'Unknown error'-> a2sError #);
          a2sError:<
            (# m,msg: ^text
            enter m[]
            do 'File error for: "' -> msg[];
               this(a2sBinFile).name -> msg.puttext;
               '"\n\t' -> msg.puttext; 
               m[] -> msg.putline;
               INNER
            #)
       #);
     openWrite:<
       (#
       do (*'\nOpenWrite a2sHandle:' -> puttext;*)
          true -> openForWrite
       #);
     openRead:<
       (#           
       do (*'\nOpenRead a2sHandle:' -> puttext;*)
          open:
            (# a2sFile: @a2sBinfile
                 (# a2sError::
                      (#
                      do msg[] -> warning; leave open
                      #)
                 #);
               getB: @a2sFile.getBytes;
               firstPos: @integer;
               Swap:
                 (#
                 do (for i: top repeat
                         astIndex[i].%byteSwapLong;
                         start[i].%byteSwapLong;
                         end[i].%byteSwapLong;
                    for)
                 #);
               endianSwap: @boolean
            do (if a2sFile.mkFileName then
                   a2sFile.openRead; (* check existence and exceptions *)
                   (if true then
                       (head.range,0) -> a2sFile.getInt32Rep -> head[]
                    else
                       (@@head[1],head.range*4) -> getB;
                   if);
                   (if true 
                    // isBigEndian then
                       (if head[3] <> bigEndianValue then 
                           true -> endianSwap
                       if)
                    // isLittleEndian then
                       (if head[3] <> littleEndianValue then 
                           true -> endianSwap;
                       if)
                   if);
                   (if endianSwap then
                       head[1].%byteSwapLong;
                       head[2].%byteSwapLong;
                   if);
                   
                   (if head[1] <> head.range then
                       '*** Invalid a2s-file ' -> warning
                   if); 
                   head[2] -> top;                   
                   top -> astIndex.new;
                   top -> start.new;
                   top -> end.new;
                   (if true then
                       (top,0) -> a2sFile.getInt32Rep -> astIndex[];
                       (top,0) -> a2sFile.getInt32Rep -> start[];
                       (top,0) -> a2sFile.getInt32Rep -> end[];
                    else
                       (@@astIndex[1],top*4) -> getB;
                       (@@start[1],top*4) -> getB;
                       (@@end[1],top*4) -> getB;
                   if);
                   (if endianSwap then swap if);

                   (*dump;*)
                   1 -> top;
                   L:
                     (if top < astIndex.range then
                         top + 1 -> top -> firstPos;;
                         (if (formsTop + 1 -> formsTop) > forms.range then
                             forms.range -> forms.extend
                         if);
                         L2:
                           (if astIndex[top+1->top] <> -1 then 
                               restart L2
                           if);
                         (firstPos,top-1) -> map -> forms[formsTop][];
                         (* astIndex[top] = -1 *)
                         restart L
                     if);
                   true -> openForRead;
                   a2sFile.close;
                else
                   '***No a2s-file' -> warning
               if)
            #)
       #);
     close:< 
       (# 
       do doClose:
            (if openForWrite then
                (# a2sFile: @a2sBinfile
                     (# a2sError::
                          (#do msg[] -> warning; leave doClose #)
                     #);
                   putB: @a2sFile.putBytes
                do newForm;
                   head.range -> head[1];
                   top -> head[2];
                   (if isBigEndian then
                       bigEndianValue -> head[3]
                    else
                       littleEndianValue -> head[3]
                   if);
                   (*dump;*)
                   a2sFile.mkFileName;        
                   a2sFile.openWrite; (* check existence and exceptions *)
                   
                   (if true then
                       (head[],head.range) -> a2sFile.putInt32Rep;
                       (astIndex[],top) -> a2sFile.putInt32Rep;
                       (start[],top) -> a2sFile.putInt32Rep;
                       (end[],top) -> a2sFile.putInt32Rep;
                    else
                       (@@head[1],head.range*4) -> putB;
                       (@@astIndex[1],top*4) -> putB;
                       (@@start[1],top*4) -> putB;
                       (@@end[1],top*4) -> putB;              
                   if);
                   a2sFile.close;
                #)
            if);
          false -> openForWrite -> openForRead
       #);
     newForm:
       (#
       do (if (top+1->top) >= astIndex.range then 
              astIndex.range -> astIndex.extend;
              start.range -> start.extend;
              end.range -> end.extend;
          if);
          -1 -> astIndex[top];
       #);
     putPos:
       (# index,startPos,endPos: @integer
       enter(startPos,endPos,index)
       do (if (top+1->top) >= astIndex.range then 
              astIndex.range -> astIndex.extend;
              start.range -> start.extend;
              end.range -> end.extend;
          if);
          startPos -> start[top];
          endPos -> end[top];
          index -> astIndex[top];
          (* 'put: ' -> puttext;
           top -> putint; ' '->put;
           index -> putint; ' ' -> put;
           startPos -> putint; ' ' -> put;
           endPos -> putint; newline
           *)
       #);
     getPos:
       (# frag: ^fragmentForm; index: @integer;
          startPos,endPos: @integer;
          fragNo: @integer
       enter(frag[],index)
       do (if not openForRead then openRead if);
          (if a2sFileExist then
              L:
                fragmentList.scan
                (#
                do fragNo+1 -> fragNo;
                   (if frag[] = current.open then leave L if)
                #);
              (*  '\nFragment form:' -> puttext; fragNo -> putint; *)
              (if (0 < fragNo) and (fragNo <= formsTop) then
                  index -> forms[fragNo].getPos -> (startPos,endPos)
              if)
          if)
       exit(startPos,endPos)
       #)
  #);
