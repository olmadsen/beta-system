ORIGIN '~beta/toollibs/preferences/v1.1/cmdOptions';
INCLUDE '~beta/basiclib/v1.6/regexp';
INCLUDE '~beta/sysutils/v1.6/envstring';
INCLUDE '~beta/mps/v5.2/astlevel';
INCLUDE '~beta/mps/v5.2/findgrammar';
INCLUDE '~beta/betaast/v5.2/index';
INCLUDE '~beta/dependency/v1.3/dependency';
INCLUDE '~beta/dependency/v1.3/private/dependencyBody';
INCLUDE '~beta/basiclib/v1.6/formatio';
INCLUDE '~beta/containers/v1.6/sets';

--- preferencesLib: attributes ---
registerBETAWCcmdOptions: registerCmdOptions
  (#
  do 'help'
       ->define(# type:: cmdOption
		    (# onShortcutAction:: onAction #)
	       do 'Print this help info'->pref.description[];
		  'h'->pref.shortCut;
	       #);
     'all'
       ->define(# type:: cmdOption
		    (# onShortcutAction:: onAction #)
	       do 'same as --conflict --full --list'->pref.description[];
		  'a'->pref.shortCut;
	       #);
     'conflict'
       ->define(# type:: cmdOption
		    (# onShortcutAction:: onAction #)
	       do 'check for version conflicts'->pref.description[];
		  'c'->pref.shortCut;
	       #);
     'full'
       ->define(# type:: cmdOption
		    (# onShortcutAction:: onAction #)
	       do 'include standard files \n(files located in $BETALIB)'->pref.description[];
		  'f'->pref.shortCut;
	       #);
     'ignore'
       ->define(# type:: cmdArgs
		    (# onShortcutAction:: onAction #)
	       do 'ignore all files with names containing "rexp". \nNote, that "rexp" may be any regexp pattern. \n"--ignore rexp" has precedence over all above options.'
		    ->pref.description[];
		  'x'->pref.shortCut;
	       #);
     'include'
       ->define(# type:: cmdArgs
		    (# onShortcutAction:: onAction #)
	       do 'include all files with names containing "rexp". \nNote, that "rexp" may be any regexp pattern. \n"--include rexp" has precedence over all above options.'
		    ->pref.description[];
		  'i'->pref.shortCut;
	       #);
     'list'
       ->define(# type:: cmdOption
		    (# onShortcutAction:: onAction #)
	       do 'list the fragment groups in the dependency graph.'->pref.description[];
		  'l'->pref.shortCut;
	       #);
  #);

help: getCmdOption(# #);
all: getCmdOption(# #);
conflict: getCmdOption(# #);
full: getCmdOption(# #);
ignore: getCmdArgs(# #);
include: getCmdArgs(# #);
list: getCmdOption(# #);

--- program: descriptor ---
(# ast: @astInterface(# defaultGrammarFinder:: findgrammar #);
   prefs: @preferences;
   regexp: ^text;
   regexpFilter:
     (# lst, regexp, l, res: ^text;
     enter (lst[],regexp[])
     do lst.reset; &text[]->res[];
	loop:
	  (if not lst.eos then
	      lst.getline->l[]; l.reset;
	      regexp[]->l.regexp_search
		(# noMatch:: (# do l[]->res.putline #) #);
	      restart loop;
	  if)
     exit res[]
     #);
   regexpMatch:
     (# lst, regexp, l, res: ^text;
     enter (lst[],regexp[])
     do lst.reset; &text[]->res[];
	loop:
	  (if not lst.eos then
	      lst.getline->l[]; l.reset;
	      regexp[]->l.regexp_search
		(# do l[]->res.putline #);
	      restart loop;
	  if)
     exit res[]
     #);

   ConflictSet: @set
     (#
	element::
	  (# lib: ^text;
	     v1,v2: ^text;
	  #);

	addConflict: find
	  (# lib: ^text;
	     v1,v2: ^text;
	     e: ^element;
	     predicate::
	       (#
	       do ((lib[]->current.lib.equalNCS) and
		  (v1[]->current.v1.equalNCS) and
		  (v2[]->current.v2.equalNCS))
		    ->value
	       #);
	     notFound::
	       (#
	       do &element[]->e[];
		  lib[]->e.lib[]; v1[]->e.v1[]; v2[]->e.v2[];
		  e[]->insert
	       #)
	  enter (lib[],v1[],v2[])
	  #);
     #);

   Module:
     (# Name, Version, Library, Path: ^text;

	isLibrary: (# exit (version[]<>NONE) and (Version.Length <> 0) #);

	Dump:
	  (# out: ^stream
	  enter out[]
	  do Name[]->out.putText;
	     out.newLine;
	  #);
	DumpProg:
	  (# out: ^stream
	  enter out[]
	  do Path[]->out.putText;
	     DirectoryChar->out.put; name[]->out.puttext;
	     out.newLine;
	  #);

	equal:
	  (# m: ^Module;
	  enter m[]
	  exit (name[]->m.name.equal) and
	     (version[]->m.version.equal) and
	     (library[]->m.version.equal)
	  #)
     #);

   Library:
     (# Name, Version, Path: ^text;

	ModList: [0]^Module;
	ModEnd: @integer;

	insert:
	  (# theModule: ^Module; isPresent: @boolean;
	  enter theModule[]
	  do false->isPresent;
	     loop:
	       (for i: ModEnd repeat
		    (if (theModule.name[]->ModList[i].name.equal) then
		    true->isPresent; leave loop if) for);
	      (if not isPresent then
		 (if (ModEnd=ModList.range) then
		     20->ModList.extend
		 if);
		 theModule[]->ModList[ModEnd+1->ModEnd][];
	     if)
	  exit isPresent
	  #);

	Dump:
	  (# out: ^stream
	  enter out[]
	  do (for i: ModEnd repeat
		  Path[]->out.putText;
		  DirectoryChar->out.put; Name[]->out.putText;
		  DirectoryChar->out.put; Version[]->out.putText;
		  DirectoryChar->out.put; out[]->ModList[i].Dump
	     for);
	  #);

	display:
	  (# out: ^stream
	  enter out[]
	  do '  %15s %10s (%s)\n'->out.putformat
	       (# do Name[]->s; Version[]->s; Path[]->s #)
	  #)
     #);

   System:
     (# LibList: [0]^Library;
	LibEnd: @integer;

	ProgList: [0]^Module;
	ProgEnd: @integer;

	Insert:
	  (#
	     conflict:<
	       (# lib,v1,v2: ^text;
	       enter (lib[],v1[],v2[])
	       do
		  INNER
	       #);

	     theModule: ^Module; isPresent, libFound: @boolean;
	  enter theModule[]
	  do false->isPresent->libFound;
	     (if theModule.isLibrary then
		 (* Check the LibList *)
		 loop:
		   (for i: LibEnd repeat
			(if (theModule.Library[]->LibList[i].name.equal) then
			    true->libFound;
			    (if not (LibList[i].version[]->theModule.version.equal) or not (LibList[i].path[]->theModule.path.equal) then
				(theModule.Library[],
				LibList[i].version[],
				theModule.version[])->conflict;
				false->libFound;
			    if);
			    theModule[]->LibList[i].insert->isPresent;
			    leave loop
			if)
		   for);
		 (if not libFound then
		     (if (LibEnd=LibList.range) then
			 20->LibList.extend
		     if);
		     &Library[]->LibList[LibEnd+1->LibEnd][];
		     theModule.Library[]->LibList[LibEnd].name[];
		     theModule.version[]->LibList[LibEnd].version[];
		     theModule.path[]->LibList[LibEnd].path[];
		     theModule[]->LibList[LibEnd].insert
		 if);
	      else
		 (* Check the ProgList *)
		 loop:
		   (for i: ProgEnd repeat
			(if (theModule.name[]->ProgList[i].name.equal) then
			true->isPresent; leave loop if) for);
		 (if not isPresent then
		     (if (ProgEnd=ProgList.range) then
			 20->ProgList.extend
		     if);
		     theModule[]->ProgList[ProgEnd+1->ProgEnd][];
		 if)
	     if)
	  exit isPresent
	  #);

	Dump:
	  (# out: ^stream
	  enter out[]
	  do
	     (if (ProgEnd>0) then
		 (for i: ProgEnd repeat out[]->ProgList[i].DumpProg for);
	     if);
	     (if (LibEnd>0) then
		 (for i: LibEnd  repeat out[]->LibList[i].Dump  for)
	     if)
	  #);

	display:
	  (# out: ^stream
	  enter out[]
	  do
	     (if (ProgEnd>0) then
		 (for i: ProgEnd repeat out[]->ProgList[i].DumpProg for);
	     if);
	     (if (LibEnd>0) then
		 (for i: LibEnd  repeat out[]->LibList[i].display  for)
	     if)
	  #)
     #);

   ParseModuleName:
     (# SplitName:
	  (# name: ^text; index: @integer
	  enter name[]
	  do DirectoryChar->name.FindAll(# do inx->index #);
	  exit ((1,index-1)->name.Sub, (index+1,name.Length)->name.Sub)
	  #);

	CheckVersion:
	  (# String: ^text; result: @boolean
	  enter String[]
	  do (if (string.Length >= 2) then
		 (string.T[1] = 'v') AND
		 (string.T[2] >= '0') AND
		 (string.T[2] <= '9')->result
	      else
		 false->result;
	     if);
	  exit result
	  #);

	theModule: ^Module; fileName, tryVersion, rest, path, name, loc: ^text
     enter fileName[]
     do &module[]->themodule[];
	&text[]->theModule.name[]->theModule.version[]
	  ->theModule.library[]->theModule.path[];
	filename[]->rest[];
	l: (if not rest.empty then
	       rest[]->SplitName->(path[], name[]);
	       path[]->SplitName->(loc[], tryVersion[]);
	       (if (tryVersion[]->CheckVersion) then
		   tryVersion[]->theModule.Version[];
		   loc[]->SplitName->(theModule.path[], theModule.library[]);
		   (if theModule.name.empty then
		       name[]->theModule.name[]
		    else
		       DirectoryChar->(&text[]).put -> theModule.name.prepend;
		       name[]->theModule.name.prepend;
		   if);
		else
		   (if theModule.name.empty then
		       name[]->theModule.name[]
		    else
		       DirectoryChar->(&text[]).put->theModule.name.prepend;
		       name[]->theModule.name.prepend;
		   if);
		   path[]->rest[];
		   restart L
	       if)
	    else
	       filename[]->splitName->(theModule.path[], theModule.name[]);
	   if)
     exit theModule[]
     #);

   announce:
     (#
     do 'Error during dependency analysis:\n\t'->puttext;
	INNER; stop
     #);

   ListGraph:
     (# fg: ^ast.fragmentGroup;
	List: [0]^text; End: @integer;
	NodeName: ^text;

	PleaseInsert:
	  (# Name, Path: ^text
	  enter (Name[], Path[])
	  do (if (End=List.range) then
		 20->List.extend
	     if);
	     &text[]->List[End+1->End][];
	     (Name[],Path[])->ast.thePathHandler.convertFilePath->List[End][];
	  #);
	Target: ^text;
	Found: @boolean;
	thisModule: ^Module;
	f: @file; filename: ^text;
     enter NodeName[]
     do ast.dependencyGraph
	(#
	do init; xverboselevel.nothing->xverboselevel;
	   machine_type->TargetMachine[];
	   machine_type->TargetDirectory[];

	   scan: nodename[]->scanextent
	     (# MPSexception::
		  (# do announce(# do T[]->puttext; ' too large (MPS overflow)'->putline #) #);
		DoubleFormException::
		  (# do announce(# do 'Double form declaration'->putline #) #);
		propertyException::
		  (# do announce(# do 'Error concerning property: '->puttext; p[]->putline #) #);
		circularDependencyException::
		  (# do announce(# do 'Circular dependency on: '->puttext; fg.name->putline #) #);
		unknownPropertyException::
		  (# do announce(# do 'Unknown property: '->puttext #) #);
		emptyFragmentException::
		  (# do announce(# do 'Empty fragment file: '->puttext; fg.name->putline #) #);
		transAccessException::
		  (# do announce(# do 'No read access to: '->puttext; FN[]->putline #) #);
		notExistingException::
		  (# do announce(# do 'Fragment file does not exist: '->puttext; fullFN[]->putline #); #);
		parseException::
		  (# do announce(# do 'Parse errors in: '->puttext; fullFN[]->putline #) #);
		transCreateDirException::
		  (# do announce(# do 'Unable to create directory: '->puttext; FN[]->putline #) #);
	     do
		current.fullname->ParseModuleName->thisModule[];
		thisModule[]->MySystem.insert
		  (# conflict::
		       (# do
			  (lib[],v1[],v2[])->ConflictSet.addConflict;
		       #)
		  #)
	     #);
	   (*DGP.groupList.statistics(# do screen[]->print #)*)
	#)
     #);

   ListConflicts:
     (#
	nodename: ^text; f: @file;
	FindIncludePlace:
	  (#
	     scanPropsAndFrags:
	       (# doDependOn:<
		    (# prop,filename: ^text
		    enter (prop[],filename[])
		    do INNER
		    #);

		  g: ^ast.fragmentGroup;
	       enter g[]
	       do g.prop.scanProp
		  (#
		     help: @text;
		     doProp::<
		       (#
		       do (* Ignore some properties. *)
			  (if true
			   // ('donecheck'->prop.equalNCS)
			   // ('ABSTRACTED'->prop.equal) then (* nothing *)
			   else
			      scanParameters
			      (#
				 doString::<
				   (#
				   do
				      (if true
				       // ('BODY'->prop.equalNCS)
				       // ('MDBODY'->prop.equalNCS)
				       // ('INCLUDE'->prop.equalNCS)
				       // ('ORIGIN'->prop.equalNCS) then
					  prop.makeUC;
					  (prop[],s[])->doDependOn;
				      if)
				   #);
			      #);
			  if);
		       #)
		  #);
	       #);

	     stripName:
	       (# t: ^text;
		  inx: @integer;
	       enter t[]
	       do
		  (* Find last DirectoryChar *)
		  1->inx;
		  L: (for i: t.length repeat
			  (t.length-i)->inx->t.pos;
			  (if t.get=DirectoryChar then inx+1->inx; leave  L if)
		     for);
	       exit (1,inx)->t.sub
	       #);

	     fg: ^ast.fragmentGroup;
	     NodeName,path,name,lib: ^text;
	     curModule,parentModule: ^Module;
	     firstDependency: @boolean;
	  enter (NodeName[],lib[])
	  do ast.dependencyGraph
	     (#
	     do init; xverboselevel.nothing->xverboselevel;
		machine_type->TargetMachine[];
		machine_type->TargetDirectory[];

		scan: nodename[]->scanextent
		(# MPSexception::
		     (# do announce(# do T[]->puttext; ' too large (MPS overflow)'->putline #) #);
		   DoubleFormException::
		     (# do announce(# do 'Double form declaration'->putline #) #);
		   propertyException::
		     (# do announce(# do 'Error concerning property: '->puttext; p[]->putline #) #);
		   circularDependencyException::
		     (# do announce(# do 'Circular dependency on: '->puttext; fg.name->putline #) #);
		   unknownPropertyException::
		     (# do announce(# do 'Unknown property: '->puttext #) #);
		   emptyFragmentException::
		     (# do announce(# do 'Empty fragment file: '->puttext; fg.name->putline #) #);
		   transAccessException::
		     (# do announce(# do 'No read access to: '->puttext; FN[]->putline #) #);
		   notExistingException::
		     (# do announce(# do 'Fragment file does not exist: '->puttext; fullFN[]->putline #); #);
		   parseException::
		     (# do announce(# do 'Parse errors in: '->puttext; fullFN[]->putline #) #);
		   transCreateDirException::
		     (# do announce(# do 'Unable to create directory: '->puttext; FN[]->putline #) #);
		do
		   current.fullname->stripName->path[];
		   current.fullname->parseModuleName->parentModule[];
		   true->firstDependency;
		   current[]->scanPropsAndFrags
		   (#
		      doDependOn::
			(# t: @text;
			do
			   (if (filename.T[1]<>'~') and
			       (filename.T[1]<>DirectoryChar) then
			       path[]->name[];
			       filename[]->name.append;
			       DirectoryChar->(&text[]).put -> name.prepend;
			    else
			       filename[]->name[];
			   if);
			   name[]->parseModuleName->curModule[];
			   (if curModule.library[]->lib.equalNCS then
			       (if not (
				   (curModule.isLibrary) and
				   (parentModule.isLibrary) and
				   (curModule.library[]->parentModule.library.equalNCS) and
				   (curModule.version[]->parentModule.version.equalNCS)) then

				   (if firstDependency then
				       '   %s:\n'->t.putformat
				       (# do current.fullname->s#);
				       false->firstDependency;
				   if);
				   '      %s %s\n'
				     ->t.putFormat(# do prop[]->s; name[]->s; #);
				   t[]->conflicts.puttext;
			  if);
			   if);
			#);
		   #);
		#);
		(*DGP.groupList.statistics(# do screen[]->print #)*)
	     #);
	  #);
     enter nodename[]
     do (if ConflictSet.size > 0 then
	    ConflictSet.scan
	    (#
	    do
	       '#### Conflict between: '->conflicts.puttext;
	       current.lib[]->conflicts.putText;
	       ' '->conflicts.put; current.v1[]->conflicts.putText;
	       ' and '->conflicts.putText; current.v2[]->conflicts.putLine;
	       (nodename[],current.lib[])->FindIncludePlace;
	    #);
	if)
     #);

   ExpandFileName:
     (#
	Name: ^text; ExpandedName: ^text
     enter Name[]
     do (Name[], ast.thePathHandler.currentDirectory)
	  -> ast.thePathHandler.convertFilePath->ExpandedName[];
    exit ExpandedName[]
     #);

   MySystem: @System;

   programFilename: ^text;
   f: @file;

   conflicts: @text;
   files, resfiles, frag, version, l: ^text;

   groups, forms, lines, atoms, chars: @integer;

do prefs.open(# do prefs.registerBETAWCcmdOptions #);

   ast.astLevelInit;

   &text[]->files[];

   prefs.readArguments;
   (if prefs.help then prefs.dumpCmds; stop if);
   (if noOfArguments<1 then
       'Missing file argument'->putline;
       prefs.dumpCmds; stop 
   if);
   prefs.scanArguments
     (#
     do (for i: noOfArguments repeat
	     current[]->ExpandFileName->ProgramFilename[];
	     ProgramFilename[]->&ListGraph;
	     ProgramFilename[]->listConflicts
	for);
     #);

   files[]->MySystem.Dump;
   files.copy->resfiles[];

   'Libraries used:'->putline;
   screen[]->mySystem.display;

   (if conflicts.length>0 then
       '  NOTE: version conflicts'->putline;
       (if prefs.conflict or prefs.all then
	   conflicts[]->puttext;
	else
	   '  Use "--conflict" to obtain more detailed conflict information'->putline;
       if);
   if);

   newline;

   (if not (prefs.full or prefs.all)
	 or ((prefs.ignore).noOfArgs>0)
	 or ((prefs.include).noOfArgs>0)
	 then
       '-------------------------------------------'->putline;
       'The following information is based on the  '->putline;
       'entire dependency graph with the following '->putline;
       'exceptions:'->putline;
   if);

   (if not (prefs.full or prefs.all) then
       '  Ignoring std. files...'->puttext;
       '\\(^'->regexp[];
       ('~beta','.')->ast.thePathHandler.convertFilePath->regexp.append;
       '\\|^$BETALIB\\)'->regexp.append;
       (resfiles[],regexp[]->expandEnvVar)
	 ->regexpFilter->resfiles[];
       'done'->putline;
   if);

   (if (prefs.ignore).noOfArgs>0 then
       '  Ignoring files with names containing regexp: '->putline;
       (prefs.ignore).scan
	 (#
	 do '    '->puttext; current[]->puttext; '...'->puttext;
	    (resfiles[],current[])->regexpFilter->resfiles[];
	    'done'->putline;
	 #);
   if);

   (if (prefs.include).noOfArgs>0 then
       '  Including files with names containing regexp: '->putline;
       (prefs.include).scan
	 (#
	 do '    '->puttext; current[]->puttext; '...'->puttext;
	    (files[],current[])->regexpMatch->resfiles.append;
	    'done'->putline;
	 #);
   if);

   (if not (prefs.full or prefs.all)
	 or ((prefs.ignore).noOfArgs>0)
	 or ((prefs.include).noOfArgs>0)
	 then
       '-------------------------------------------'->putline;
   if);

   newline;

   resfiles.reset;
   loop:
     (if not resfiles.eos then
	 groups+1->groups;
	 resfiles.getline->frag[];
	 ((frag[], screen[])->AST.top.open->qua(# as:: AST.fragmentGroup #)).fragmentList.scan
	   (# do (if current.type=ast.formType then forms+1->forms if) #);
	 '.bet'->frag.append;
	 frag[]->f.name; f.openread;
	 chars+f.length->chars;
	 loop:
	   (if not f.eos then
	       f.getline->l[]; lines+1->lines;
	       l.reset;
	       loop:
		 (if not l.eos then
		     l.getatom; atoms+1->atoms; restart loop
		 if);
	       restart loop
	   if);
	 f.close;

	 restart loop;
     if);

   'Number of:'->putline;
   '  Fragment groups: '->puttext;
   groups->putint(# format:: (# do 8->width #) #); newline;
   '  Fragment forms:  '->puttext;
   forms->putint(# format:: (# do 8->width #) #); newline;
   '  Lines:           '->puttext;
   lines->putint(# format:: (# do 8->width #) #); newline;
   '  Atoms:           '->puttext;
   atoms->putint(# format:: (# do 8->width #) #); newline;
   '  Chars:           '->puttext;
   chars->putint(# format:: (# do 8->width #) #); newline;

       newline;

       (if prefs.list or prefs.all then
       'List of fragment groups:'->putline;
       '-------------------------------------------'->putline;
       resfiles.reset;
       loop:
	 (if not resfiles.eos then
	    '  '->puttext;  resfiles.getline->putline;
	     restart loop
	 if);
       '-------------------------------------------'->putline;
   if)
    #)
