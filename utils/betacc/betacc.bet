ORIGIN '~beta/basiclib/systemenv';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/sysutils/envstring';
INCLUDE '~beta/process/processmanager';
INCLUDE '~beta/basiclib/directory';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/toollibs/utils/fileExtensions';

--- SDKlib:attributes ---
sdkType: 
  (# assemblerVersion: @Integer;
     executer:
       (# src, dst, c, a: ^Text; 
       enter (src[], dst[])
       do &Text[]->c[];
          &Text[]->a[];
          INNER
       exit (c[],a[]) #);
     cc:< executer;
     cpp:< executer;
     as:< executer;
     asText:<  (# T: ^Text; do INNER; exit T[] #);
     fixPath:< (# T: ^Text; enter T[] do INNER #);
     checkDst:<(# path: ^Text;
                  e: @diskentry;
               enter path[] 
               do path[] -> e.path;
                  e.path.head -> &ensureDirectory;
                  INNER; 
               #);
  #);


Borland: sdkType
  (# bcc32: executer
       (# 
       do 'bcc32'->c.putText;
          (if not theProgram.nodebug then '-v -y ' -> a.putText if);
          ('-D', a[], true) -> theProgram.defines.output;
          ('-I', a[], true) -> theProgram.includedirs.output;
          '-O2 -a4 -DWIN32 -Dnti -Dnti_bor -Iexternal -c -o' -> a.putText;
          dst[] -> a.putText; ' ' -> a.put; src[]-> a.putText
       #);
     cc::< bcc32;
     cpp::< bcc32;
     as::<
       (# 
       do 'tasm32'->c.putText;
          (if not theProgram.nodebug then '-zd ' -> a.putText if);
          ('-d', a[], true) -> theProgram.defines.output;
          ('-i', a[], true) -> theProgram.includedirs.output;
          '-w-res -t -m -ml -kh32768 ' -> a.putText;
          src[]->a.putText; ','->a.put;dst[]->a.putText;
       #);
     asText::< (# do 'bor' -> t #);
     fixPath::< (# do '/' -> T.findAll(# do ('\\',inx) -> T.inxPut #) #);
  #);

Microsoft: sdkType
  (# cl: executer
       (# 
       do 'cl'->c.putText;
          '-nologo ' -> a.puttext;
          (if not theProgram.nodebug then '-Zd ' -> a.putText if);
          ('-D', a[], true) -> theProgram.defines.output;
          ('-I', a[], true) -> theProgram.includedirs.output;
          '-DWIN32 -Dnti -Dnti_ms -Iexternal' -> a.puttext;
          '-O2 -Zp4 ' -> a.puttext;
          (if dynamic_library then
              '-LD -Fe' -> a.putText;
           else
              '-c -Fo' -> a.putText;
          if);
          dst[] -> a.putText; ' ' -> a.put; src[]-> a.putText
       #);
     cc::< cl;
     cpp::< cl;
     as::< 
       (# 
       do (if assemblerVersion=6 then
              'ml'->c.putText;
              (if not theProgram.nodebug then '-Zi ' -> a.putText if);
              ('-D', a[], true) -> theProgram.defines.output;
              ('-I', a[], true) -> theProgram.includedirs.output;
              '-w -nologo -coff -Cp -c -Fo' -> a.putText;
              dst[] -> a.putText; ' -Ta' -> a.putText;
              src[]-> a.putText
           else
              'masm386' ->c.putText;
              (if not theProgram.nodebug then '/Zd ' -> a.putText if);
              '/t /Ml ' -> a.putText;
              src[]->a.putText; ','->a.put;dst[]->a.putText
           if)
       #);
     asText::< (# do 'ms' -> t #);
     fixPath::< (# do '/' -> T.findAll(# do ('\\',inx) -> T.inxPut #) #);
  #);

Nti_gnu: sdkType
  (# options: 
       (# a: ^text;
       do &text[] -> a[];
          
          (if not theProgram.nodebug then '-g ' -> a.putText if);
          ('-D', a[], true) -> theProgram.defines.output;
          ('-I', a[], true) -> theProgram.includedirs.output;
          '-DWIN32 -Dnti -Dnti_gnu '->a.putText;
          (if dynamic_library then
              '-fpic -shared ' -> a.putText;
           else
              ' -c ' -> a.putText;
          if);
          '-O6 -o ' -> a.putText;
          dst[] -> a.putText; ' '->a.putText;
          src[] -> a.putText;
       exit a[]
       #);
     
     cc::< (# 
           do 'gcc' -> c.putText;
              options -> a.puttext;
           #);
     cpp::<(# 
           do 'g++' -> c.putText;
              options -> a.puttext;
           #);
     as::< (# do 'as' -> c.putText #);
     asText::< (# do 'Nti_gnu' -> t #);
     fixPath::< (# do '\\' -> T.findAll(# do ('/',inx) -> T.inxPut #) #);
  #);

Gnu: sdkType
  (# options: 
       (# a: ^text;
       do &text[] -> a[];
          (if not theProgram.nodebug then '-g ' -> a.putText if);
          ('-D', a[], false) -> theProgram.defines.output;
          ('-I', a[], false) -> theProgram.includedirs.output;
          '-D' -> a.putText; asText -> a.putText; ' '->a.putText;
          (if dynamic_library then
              '-fpic -shared ' -> a.putText;
           else
              ' -c ' -> a.putText;
          if);
          '-O6 -o ' -> a.putText;
          dst[] -> a.putText; ' '->a.putText;
          src[] -> a.putText;
       exit a[]
       #);
     
     prependPath:
       (# prog: ^text;
       enter prog[]
       do exeFileExtension -> prog.appendExtension;
          findpath: scanSearchPath
            (# e: @diskentry;
            do path.length->path.setpos;
               DirectoryChar -> path.put;
               prog[] -> (path.copy).append -> e.path;
               (if e.exists then e.path -> prog[]; leave findpath if);
            #);
       exit prog[] 
       #);
       
     cc::< (# 
           do 'gcc' -> prependPath -> c.putText;
              options -> a.puttext;
           #);
     cpp::<(# 
           do 'g++' -> prependPath -> c.putText;
              options -> a.puttext;
           #);
     as::< (# do 'as' -> c.putText #);
     asText::< (# do machine_type -> t[] #);
     fixPath::< (# do '\\' -> T.findAll(# do ('/',inx) -> T.inxPut #) #);
  #);

ensureDirectory:
  (# dir: ^text;
     d: @directory
  enter dir[]
  do dir[] -> d.name;
     (if d.entry.exists and d.entry.isDirectory then
         (* We're done *)
      else
         (* Recursively ensure father directory exists *)
         d.entry.path.head -> &ensureDirectory;
         (* Create this directory *)
         d.touch;
     if);
  #);

--- program:descriptor ---
systemenv
(# <<SLOT SDKlib:attributes>>;
   SDK: ^sdkType;
   sdktext,asmtext,tmptext: ^Text;
   src,dst: ^Text;
   cmd,arg: ^Text;
   proplist: list
     (# element::text;
        output:
          (# prefix: ^text; out: ^stream; quote: @boolean
          enter (prefix[], out[], quote)
          do scan
             (# 
             do prefix[] -> out.putText;
                (if quote then '"' -> out.puttext; if);
                current[] -> out.putText;
                (if quote then '"' -> out.puttext; if);
                ' '->out.put;
             #);
          #);
     #);
   defines, includedirs: @proplist;
   waitingfordefine,waitingforincludedir,verbose,nodebug,dynamic_library,trace: @boolean;
   startoffilenames: @integer;
   run: @Process;
   sf,df: @DiskEntry;
   
   usage:
     (# 
     do 'Usage: betacc [ -v ] [ -d ] [ -D symbol ] [ -I dir ] [ -G ] [ -T ] outputfile sourcefile'
          -> putline;
        '  -v          Verbose: echo commands before executing them.' -> putline;
        '  -d          Do not produce debug info in outputfile' -> putline;
        '  -D symbol   Pass symbol to preprocessor' -> putline;
        '  -I dir      Pass include directory to preprocessor' -> putline;
        '  -G          Build a dynamic shared library' -> putline;
        '  -T          Trace betacc' -> putline;
        (failure, 'betacc terminated.') -> stop;
     #);      
   
   getAssemblerVersion:
     (# 
     do '$(asm_version)' -> &expandEnvVar
        (# defaultValue::<
             (# 
             do (if true
                 // 'ms' -> sdktext.equalNCS then '6' -> envvarvalue[];
                 // 'bor' -> sdktext.equalNCS then '4' -> envvarvalue[];
                 // 'nti_gnu' -> sdktext.equalNCS then '1' -> envvarvalue[];
                if)
             #)
        #) -> asmtext[];
        
        asmtext.reset;
        asmtext.getInt -> SDK.assemblerversion;
     #);
   
   
do '$(MIASDK)' -> &expandEnvVar(# defaultValue::<
                                 (# Type: ^Text;
                                 do machine_type->Type[];
                                    (if true
                                     // 'nti'->Type.equal
                                     // 'nti_ms'->Type.equal then
                                        'ms' -> envvarvalue[] 
                                     // 'nti_gnu'->Type.equal then
                                        'nti_gnu' -> envvarvalue[] 
                                     // 'nti_bor'->Type.equal then
                                        'bor' -> envvarvalue[]
                                     else
                                        Type.copy -> envvarvalue[];
                                    if)
                                 #);
                            #) -> sdktext[];
   (if true
    // 'ms' -> sdktext.equalNCS then 
       &Microsoft[] -> SDK[]; getAssemblerVersion
    // 'bor' -> sdktext.equalNCS then 
       &Borland[] -> SDK[]; getAssemblerVersion
    // 'nti_gnu' -> sdktext.equalNCS then 
       &Nti_gnu[] -> SDK[]; getAssemblerVersion
    // 'sun4s' -> sdktext.equalNCS 
    // 'linux' -> sdktext.equalNCS 
       then &Gnu[] -> SDK[];
    else
       (failure, 'betacc: Error: Unknown Platform: '->sdktext.prepend) -> stop;
   if);       
   
   (* Parse arguments *)
   (if noOfArguments < 3 then usage if);
   2->startoffilenames;
   (for i:NoOfArguments repeat
        (if i>1 then (* argument 1 is program name *)
            i->Arguments->arg[];
            (if true
             // waitingforincludedir then
                arg.copy -> includedirs.append;
                false->waitingforincludedir;
                startoffilenames+1 -> startoffilenames;
              // waitingfordefine then
                arg.copy -> defines.append;
                false->waitingfordefine;
                startoffilenames+1 -> startoffilenames;
             // '-d'->arg.equal then 
                true->nodebug;
                startoffilenames+1 -> startoffilenames;
             // '-v' ->arg.equal then 
                true->verbose;
                startoffilenames+1 -> startoffilenames;
             // '-G' ->arg.equal then 
                true->dynamic_library;
                startoffilenames+1 -> startoffilenames;
             // '-D'->arg.equal then
                true->waitingfordefine;
                startoffilenames+1 -> startoffilenames;
             // '-T'->arg.equal then
                'betacc: trace enabled' -> screen.putline;
                true->trace;
                startoffilenames+1 -> startoffilenames;
             // '-I'->arg.equal then
                true->waitingforincludedir;
                startoffilenames+1 -> startoffilenames;
            if);
        if);
   for);
   (if waitingfordefine then usage if);
   (if waitingforincludedir then usage if);
   (if startoffilenames+1 <> NoOfArguments then usage if);
   startoffilenames   -> arguments -> dst[] -> &sdk.fixPath;
   startoffilenames+1 -> arguments -> src[] -> &sdk.fixPath;
   dst[] -> &sdk.checkDst;
   
   src[] -> sf.path;
   dst[] -> df.path;
   
   (if not sf.isFile then
       (failure, 'betacc: Sourcefile does not exist') -> stop;
   if);
   sf.path.name.extension -> tmptext[];
   (if tmptext[]=NONE then
       (failure, 'betacc: No source file extension.') -> stop;
   if);
   (if true
       // 'c' -> tmptext.equalNCS then 
       (src[],dst[]) -> &SDK.cc -> (cmd[], arg[]);
       // 'cpp' -> tmptext.equalNCS then 
       (src[],dst[]) -> &SDK.cpp -> (cmd[], arg[]);
       // 'asm' -> tmptext.equalNCS then 
       (src[],dst[]) -> &SDK.as -> (cmd[], arg[]);
    else
       (failure, 'betacc: Unknown source file extension.') -> stop;
   if);
   
   (if verbose then
       'betacc: ' -> puttext; cmd[] -> puttext; '  '->puttext; arg[] -> putline;
   if);
   
   (if trace then
       'betacc: command: ' -> screen.puttext;
       cmd[] -> screen.putline;
   if);
   cmd[] -> run.init;
   
   arg.reset;
   L: (# 
      do arg.getAtom -> tmptext[];
         (if not tmptext.empty then 
             (if trace then
                 'betacc: argument: ' -> screen.puttext;
                 tmptext[] -> screen.putline;
             if);
             tmptext[] -> run.argument.append;
             restart L
         if);
      #);
   
   run.start;
   run.awaitStopped;   
   
   (* Check if the command completed correctly by checking 
    * that the target-file really exist now. 
    *)
   (if not df.exists then
       (failure, 
       'betacc: Outputfile does not exist. (external compilation failed)')
         -> stop;
   if);
   (if df.modtime <= sf.modtime then
       (failure, 
       'betacc: Outputfile is older than sourcefile. (external compilation failed)') 
         -> stop;
   if);
#)
