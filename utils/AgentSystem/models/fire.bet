ORIGIN '../AgentSystem';
INCLUDE '~beta/basiclib/randomInteger';
(**********************************************************************
globals [
  initial-trees   ;; how many trees (green patches) we started with
  burned-trees    ;; how many have burned so far
]

breed [fires fire]    ;; bright red turtles -- the leading edge of the fire
breed [embers ember]  ;; turtles gradually fading from red to near black

to setup
  clear-all
  set-default-shape turtles "square"
  ;; make some green trees
  ask patches with [(random-float 100) < density]
    [ set pcolor green ]
  ;; make a column of burning trees
  ask patches with [pxcor = min-pxcor]
    [ ignite ]
  ;; set tree counts
  set initial-trees count patches with [pcolor = green]
  set burned-trees 0
  reset-ticks
end

to go
  if not any? turtles  ;; either fires or embers
    [ stop ]
  ask fires
    [ ask neighbors4 with [pcolor = green]
        [ ignite ]
      set breed embers ]
  fade-embers
  tick
end

;; creates the fire turtles
to ignite  ;; patch procedure
  sprout-fires 1
    [ set color red ]
  set pcolor black
  set burned-trees burned-trees + 1
end

;; achieve fading color effect for the fire as it burns
to fade-embers
  ask embers
    [ set color color - 0.3  ;; make red darker
      if color < red - 3.5     ;; are we almost at black?
        [ set pcolor color
          die ] ]
end


; Copyright 1997 Uri Wilensky.
; See Info tab for full copyright and license.
*)
---program:descriptor---
World
(# initial_trees,burned_trees: @integer;
   Fire: Breed
     (# mkGrey:
          (#
          do L:
               patches.scan
               (#
               do (if current.pos[] -> pos.equal then
                      theWorldW.grey -> current.setColor; 
                      (*current.print; newline;*)
                      leave L  
               if)#);
             theWorldW.grey -> setColor; 
          #);
     #);
   Fires: @ BreedSet(# element:: Fire #);
   (*Fires: @Breed(#do 'fire' -> name[] #);*)
   Embers: @Breed(#do 'ember' -> name[] #);
   setUp:
     (#
     do 'Fire'->putline;
        clear_all;
        'square' -> turtles.set_default_shape;
        fires.init;
        patches.ask
        (# with::(# do (((1,100) -> genunf) < 57) -> value #);
           i: @integer
        do 
           theWorldW.green -> current.setColor
        #);
        '  ;; make a column of burning trees\n' -> putline;
        '  ask patches with [pxcor = min-pxcor]\n'
        '    [ ignite ]'->putline;
        patches.ask
        (# with::(#do current.pos.x = 0 -> value #)
        do current[] -> ignite
        #);
        '  ;; set tree counts\n'->putline;
        patches.scan
        (# g: @color
        do (if theWorldW.green -> current.c.equal then
               initial_trees + 1 -> initial_trees
        if)#);
        '   initial_trees:' -> puttext; initial_trees -> putint; newline;
        0 -> burned_trees;
        fade.update;
        (* reset-ticks *)
        20-> guienvwait
     #);
   go:
     (# N: @integer
     do '**go: '->puttext; N + 1 -> N -> putint; newline;
        (if fires.empty then 
            'stop'->putline; 300 -> guienvwait; 
            (if get = ' ' then  stop  if)
        if);
        fires.ask
        (# N: @integer
        do (*'F:'->puttext; current.print; newline;*)
           0 -> N;
           current.neigbours4.ask
           (# with:: (#do theWorldW.green -> current.c.equal -> value #);      
           do (*'N:'->puttext; current.print; *)
              N + 1 -> N;
              (if N > 4 then '**** OBS:' -> puttext; current.print if);
              current[] -> ignite;
           #);
           (* set breed embers *)
           current.mkGrey;
           (current[],false) -> fade.add
        #);
        (* fade-embers *)
        fade.update;
        (* tick *)
        restart go
     #);
   fade: @set
     (# element::
          (# R: ^Fire;
             add: @boolean;
          enter(R[],add)
          exit this(element)[]
          #);
        add:
          (# R: ^Fire;
             add: @boolean;
          enter(R[],add)
          do (*'**** fade:add: ' -> puttext; R.print;*)
             (R[],add) -> element -> insert
          #);
        update:
          (# N: @integer
          do (*'**** update:fires.size: '->puttext; fires.size->putint;newline;
             '**   fade:size: '->puttext; size -> putint; 
             scan(#do (if current.add then N + 1 -> N if)#);
             ' add: ' -> puttext; N -> putint; 0 -> N;
             scan(#do (if not  current.add then N + 1 -> N if)#);
             ' delete: ' -> puttext; N -> putint; 0 -> N;
             newline; *)
             scan
             (#
             do (if current.add then
                   (* '**** fade:update:add:' -> puttext; current.R.print;*)
                    current.R[] -> fires.insert
                 else
                    (*'**** fade:update:delete:' -> puttext; current.R.print;*)
                    current.R[] -> fires.delete
             if)#);
             clear;
          #)
     #);
        
   ignite:
     (# p:^Patch; F: ^Fire
     enter p[]
     do (*fires.sprout
        (#
        do B.pos.print;
         theWorldW.red -> B.setColor; p.pos -> b.pos  #)*)
        fireId + 1 -> fireId -> Fire -> F[];
        p.pos -> F.pos;
        theWorldW.red -> F.setColor;
        (*theWorldW.grey -> p.setColor;*)
        (* P.T.close;*)
        (F[],true) -> fade.add
     #);
   fireId: @integer
do setUp;
   go;
   '***** done'->putline;
#)
