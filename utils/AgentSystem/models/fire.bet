ORIGIN '../AgentSystem';
INCLUDE '~beta/basiclib/random';
(* This program is a an implementation in Beta of the NetLogo fire-example
 * NetLogo fire-example, Copyright 1997 Uri Wilensky.
 * See NetLogo Info tab for fire for full copyright and license.
 *)
---program:descriptor---
World
(# (* globals [
    *    initial-trees   ;; how many trees (green patches) we started with
    *    burned-trees    ;; how many have burned so far
    *  ]
    *)
   initial_trees,burned_trees: @integer;
   (* breed [fires fire]   ;; bright red turtles -- the leading edge of the fire
    * breed [embers ember] ;; turtles gradually fading from red to near black
    *)   
   Fires: @BreedSet(# element:: Fire #);
   Embers: @BreedSet(# element:: Fire #); (* currently not used *)
   Fire: Breed
     (* Assuming Fire is a Breed, which is a Turtle *)
     (# mkGrey:
          (# ptch: ^Patch
          do (pos.x,pos.y) -> patches.get -> ptch[];
             grey -> ptch.setColor; 
             grey -> setColor; 
          #);
     #);

   setUp:
     (#
     do 'Fire'->putline;
        clear_all;  (* clear-all *)
        (* set-default-shape turtles "square" *)
        'square' -> turtles.set_default_shape; (* not used *)
        fires.init;
        (* ;; make some green trees
         * ask patches with [(random-float 100) < density]
         *    [ set pcolor green ]
         *)
        patches.ask
        (# with::(# do (((1,100) -> ignuin(*genunf*)) < 47) -> value #);
        do green -> current.setColor
        #);
        (* ;; make a column of burning trees
         * ask patches with [pxcor = min-pxcor]
         *   [ ignite ]
         *)
        patches.ask
        (# with::(#do current.pos.x = 0 -> value #)
        do current[] -> ignite
        #);
        (* ;; set tree counts
         * set initial-trees count patches with [pcolor = green]
         * set burned-trees 0
         *)
        patches.scan
        (#
        do (if green -> current.col.equal then
               initial_trees + 1 -> initial_trees
        if)#);
        '   initial_trees:' -> puttext; initial_trees -> putint; newline;
        0 -> burned_trees;
        fade.update;
        (* reset-ticks *)
        20-> guienvwait
     #);
   go:
     (# N: @integer
     do '**go: '->puttext; N + 1 -> N -> putint; newline;
        (* if not any? turtles  ;; either fires or embers
         *    [ stop ]
         *)
        (if fires.empty then 
            'stop'->putline;
            (* await typing a non-nul character before stop *)
            (if get <> ascii.nul then stop if)
        if);
        (* ask fires
         *    [ ask neighbors4 with [pcolor = green]
         *        [ ignite ]
         *      set breed embers ]
         *)
        fires.ask
        (# 
        do current.neigbours4.ask
           (# with:: (#do green -> current.col.equal -> value #);
           do current[] -> ignite;
           #);
           (* set breed embers *)
           embers[] -> current.breed[];
           (*current.mkGrey;*) (* perhaps not here! *)
           (current[],false) -> fade.add
        #);
        (* fade-embers *)
        fade_embers; 
        fade.update;
        (* tick *)
        restart go
     #);
   fade: @set
     (* Just preliminary! *)
     (# element::
          (# R: ^Fire;
             add: @boolean;
          enter(R[],add)
          exit this(element)[]
          #);
        add:
          (# R: ^Fire;
             add: @boolean;
          enter(R[],add)
          do (R[],add) -> element -> insert
          #);
        update:
          (# N: @integer
          do scan
             (#
             do (if current.add then
                    current.R[] -> fires.insert
                 else
                    current.R[] -> fires.delete
             if)#);
             clear;
          #)
     #);
        
   ignite:
     (* ;; creates the fire turtles
      * to ignite  ;; patch procedure
      *    sprout-fires 1
      *      [ set color red ]
      *    set pcolor black
      *    set burned-trees burned-trees + 1
      * end
      *)
     (# p:^Patch; F: ^Fire
     enter p[]
     do 1 -> fires.sprout
        (#
        do p.pos -> current.pos; 
           red -> current.setColor;
           current[] -> F[]
        #);
        (F[],true) -> fade.add;
        F[] -> embers.insert;
        burned_trees + 1 -> burned_trees;
     #);
   fade_embers:
     (* ;; achieve fading color effect for the fire as it burns
      * to fade-embers
      *    ask embers
      *       [ set color color - 0.3  ;; make red darker
      *         if color < red - 3.5     ;; are we almost at black?
      *            [ set pcolor color
      *              die ] ]
      * end
      *)
     (#
     do embers.ask
        (#
        do (*'**** before:' -> puttext; current.col.print;*)
           current.col -> mkDarker -> current.SetColor;
           (*current.col.print; newline;*)
           (if darkRed -> current.col.near then
               (* set pcolor color *)
               current.col -> (current.thePatch).setColor;
               (* die *)
               current.die(#do current[] -> embers.delete #);
           if)
        #)
     #)
           
do (*600 -> guienvwait;*)
   setUp;
   go;
   '***** done'->putline;
#)
