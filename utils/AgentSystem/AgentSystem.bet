ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/colorTable';
INCLUDE '~beta/containers/sets';
INCLUDE 'WorldWindow';
---lib:attributes---
Point:
  (# x,y: @integer;
     equal: BooleanValue
       (# P: ^Point
       enter P[]
       do (P.x = x) and (P.y = y) -> value
       #);
     print:
       (#
       do 'Point('->puttext; x -> putint; ','->put; y ->putint; ')'->put
       #)
  enter(x,y)
  exit(x,y)
  #);
World: guienv
  (# 
     BasicAgent:
       (# print:< (#do inner #);
       do inner
       exit  this(BasicAgent)[]
       #);
     Agent: BasicAgent
       (# pos: @Point;
          col: @color;
          setColor:
            (# sc: @color;                
               T: @theWorldW.tCanvas
                 (# open::
                      (#
                      do (patch_size,patch_size) -> size 
                 #)#);
            enter sc
            do sc -> col; 
               (none,pos.x,pos.y,sc) -> T.open;
            #);
          W,N,E,S: ^Patch;
          neigbours4: @
            (# ask:
                 (# with:< booleanValue(#do inner #);
                    current: ^Patch
                 do (*'ask:'->puttext;*)
                    patches.scan
                    (#
                    do (if current.pos[] -> pos.equal then
                           (*'**** found:patch:'->puttext;
                           current.print;*)
                           current.W[] -> this(ask).current[];
                           (if current.W[] <> none then (*'ask.W:'->puttext;')
                               (if with then 'w'->put;
                                   inner ask
                           if)if);
                           current.N[] -> this(ask).current[];
                           (if current.N[] <> none then (*'ask.N:'->puttext;*)
                               (if with then
                                   inner ask
                           if)if);
                           current.E[] -> this(ask).current[];
                           (if current.E[] <> none then (*'ask.E:'->puttext;*)
                               (if with then
                                   inner ask
                           if)if);
                           current.S[] -> this(ask).current[];
                           (if current.S[] <> none then 
                               (*'ask.S:'->puttext;  current.print;newline;
                               current.S.print; newline;*)
                               (if with then
                                   inner ask
                       if)if)if);    
                    #); (*
                    (if W[] <> none then 'W'->put;
                        W[] -> current[];
                        (if with then 'w'->put;
                            inner
                    if)if);
                    (if N[] <> none then
                        N[] -> current[];
                        (if with then
                            inner
                    if)if);
                    (if E[] <> none then 'E'->put;
                        E[] -> current[];
                        (if with then
                            inner
                    if)if);
                    (if S[] <> none then 'S'->put;
                        S[] -> current[];
                        (if with then 's'->put;
                            inner
                    if)if);*)
                 #)
            #);
          bred: ^BreedSet;
          print1:<
            (#
            do 'Agent:' -> puttext; inner; pos.print;
               ':color:'->puttext; col.red -> putint;','->put;
               col.green -> putint; ','->put; col.blue -> putint;';'->put;
               newline;
            #);
          print::<
            (#
            do print1;
               'E: ' -> puttext;
               (if E[] <> none then E.print1 else 'none' -> putline if);
            #);
          
       do inner
       #);
     Turtle: Agent
       (# who: @ integer;
          
          size: @integer;
          pen: @
            (# down: (# do  true -> isDown #);
               up: (# do  false -> isDown #);
               isDown: @boolean;
               draw:
                 (# l: @theWorldW.tLine; s1,s2: @integer;
                    out:
                      (# x,y: @integer
                      enter(x,y)
                      do '(' -> put; x -> putint; ','->put; y->putint; ')'->put
                      #)
                 enter(s1,s2)
                 do (pos.x,pos.y)->out; 
                    (pos.x + s1 * 4, pos.y + s2 *4) -> out;
                    newline;
                    (none,pos.x,pos.y,pos.x + s1 * 4, pos.y + s2 *4,col) -> l.open
                 #)
            #);
          fd:
            (# s: @integer
            enter s
            do (s,s) -> pen.draw;
               pos.x + s * 4 -> pos.x;
               pos.y + s * 4 -> pos.y;
            #);
          rd:
            (# d: @integer
            enter d
            do (d,0) -> pen.draw; pos.x + d * 4 -> pos.x
            #);
          ld:
            (# d: @integer
            enter d
            do (0,d) -> pen.draw; pos.y + d * 4 -> pos.y
            #);
          print1::<
            (# 
            do '[' -> put; who -> putint;  ']'->put; pos.print; 
            #);
       enter who
       do (who * 20, who) -> pos;
          inner
       #);
     Patch: Agent
       (# id,size: @integer;
          setSize: (# N: @integer enter n do n -> size #);
       enter id
       #);
     patch_size: @integer;
     setPatch_size: 
       (# n: @integer 
       enter n 
       do n -> patch_size  -> theWorldW.penSize;
       #);
     Breed: Turtle(# name: ^text do inner #);
     
     AgentSet: Set
       (# element::< Agent;
          set_default_shape:
            (# enter shape[]#);
          shape: ^Text;
          ask:
            (# with:< BooleanValue
                 (#
                 do true -> value; inner
                 #);
               current: ^Element
            do scan
               (#
               do current[] -> this(ask).current[];
                  (*'\n**** ask: ' -> puttext; current.pos.print;*)
                  (if with then
                      inner ask
                  if)
               #);
            #)
       #);
     TurtleSet: AgentSet(# element:: Turtle #);
     PatchSet: AgentSet
       (# element::< Patch;
          Ps: @
            (# row: (# R: [world_width] ^Patch #);
               cols: @
                 (# col: [world_height] @row #);
               insert:
                 (# x,y: @integer; P: ^Patch
                 enter(x,y,P[])
                 do P[] -> cols.col[x].R[y][]
                 #);
               get:
                 (# x,y: @integer; P: ^Patch
                 enter(x,y)
                 do (if (0 < x) and (x <= world_width)
                        and ((0 < y)  and (y <= world_height)) then
                        cols.col[x].R[y][] -> P[]
                    if);
                 exit P[]
                 #);
            #);
          init:
            (# p: ^Patch; pNo: @integer;
            do (for i: world_width repeat
                    (for j: world_height repeat
                         pNo + 1 -> pNo -> Patch -> p[];
                         ((i - 1) * patch_size,(j-1) * patch_Size) -> P.pos;
                         P[] -> insert;
                         (i,j,P[]) -> Ps.insert
               for)for);
               (for i: world_width repeat
                    (for j: world_height repeat
                         (i - 1,j) -> Ps.get -> ((i,j)->Ps.get).W[];
                         (i,j + 1) -> Ps.get -> ((i,j)->Ps.get).S[];
                         (i,j - 1) -> Ps.get -> ((i,j)->Ps.get).N[];
                         (i + 1,j) -> Ps.get -> ((i,j)->Ps.get).E[];
               for)for);
              (* '**** with neigbours:'->putline;
               (for i: world_width repeat
                    (for j: world_height repeat
                         ((i,j)->Ps.get).print;
               for)for);
               '**** scan: ' -> putline;
               scan(#do current.print #)*)
            #)
       #);
     BreedSet: AgentSet
       (# element::< Breed;
          sprout:
            (# n: @integer; B: ^element
            enter n
            do &element[] -> B[] -> insert;
               inner
            #);
       #);
     turtles: ^TurtleSet;
     patches: ^PatchSet;
     
     theWorldW: @WorldWindow;
     clear_all:
       (# 
       do turtles.clear
       #);
     world_width: @ (# w: @integer enter w exit w #);
     world_height: @ (# h: @integer enter h exit h #);
  do 100 -> world_width;
     100 -> world_height;
     4 -> setPatch_size;
     (world_width,world_height,patch_size) -> theWorldW.open;
     &TurtleSet[]  -> turtles[];
     &patchSet[] -> patches[];
     patches.init;
     inner World
  #);

     
