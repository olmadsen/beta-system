ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/colorTable';
INCLUDE '~beta/containers/sets';
INCLUDE 'WorldWindow';
INCLUDE 'colors'
---lib:attributes---
Point:
  (# x,y: @integer;
     equal: BooleanValue
       (# P: ^Point
       enter P[]
       do (P.x = x) and (P.y = y) -> value
       #);
     print:
       (#
       do 'Point('->puttext; x -> putint; ','->put; y ->putint; ')'->put
       #)
  enter(x,y)
  exit(x,y)
  #);
World: guienv
  (# 
     BasicAgent:
       (# print:< (#do inner #);
       do inner
       exit  this(BasicAgent)[]
       #);
     Agent: BasicAgent
       (# pos: @Point;
          col: @color;
          T: ^theWorldW.tCanvas;
          setColor:
            (# sc: @color;                
            enter sc
            do sc -> col; 
               (if T[] <> none then T.close if);
               &theWorldW.tCanvas[] -> T[];
               (none,pos.x,pos.y,sc) -> T.open;
            #);
          neigbours4: @
            (# ask:
                 (# with:< booleanValue(#do inner #);
                    current: ^Patch;
                 do (*'ask:neighbours:'->puttext; print;*)
                    (# try:
                         (# x,y: @integer
                         enter(x,y)
                         do (x,y) -> patches.get -> current[];
                            (if current[] <> none then 
                                (if with then
                                    inner ask
                                if);
                            if); 
                         #);
                    do (pos.x - patch_size,pos.y) -> try; (* west *)
                       (pos.x,pos.y - patch_size) -> try;
                       (pos.x + patch_size,pos.y) -> try;
                       (pos.x,pos.y + patch_size) -> try;   
                 #)#)
            #);
          breed: ^BreedSet;
          print1:<
            (#
            do 'Agent:' -> puttext; inner; pos.print;
               ':color:'->puttext; col.red -> putint;','->put;
               col.green -> putint; ','->put; col.blue -> putint;';'->put;
               newline;
            #);
          print::<
            (#
            do print1;
            #);
          
       do inner
       #);
     Turtle: Agent
       (# who: @ integer;
          size: @integer;
          pen: @
            (# down: (# do  true -> isDown #);
               up: (# do  false -> isDown #);
               isDown: @boolean;
               draw:
                 (# l: @theWorldW.tLine; s1,s2: @integer;
                    out:
                      (# x,y: @integer
                      enter(x,y)
                      do '(' -> put; x -> putint; ','->put; y->putint; ')'->put
                      #)
                 enter(s1,s2)
                 do (pos.x,pos.y)->out; 
                    (pos.x + s1 * 4, pos.y + s2 *4) -> out;
                    newline;
                    (none,pos.x,pos.y,pos.x + s1 * 4, pos.y + s2 *4,col)
                      -> l.open
                 #)
            #);
          fd:
            (# s: @integer
            enter s
            do (s,s) -> pen.draw;
               pos.x + s * 4 -> pos.x;
               pos.y + s * 4 -> pos.y;
            #);
          rd:
            (# d: @integer
            enter d
            do (d,0) -> pen.draw; pos.x + d * 4 -> pos.x
            #);
          ld:
            (# d: @integer
            enter d
            do (0,d) -> pen.draw; pos.y + d * 4 -> pos.y
            #);
          die:
            (* not ovious how to implement die; 
             * we probably must test before each method if the Turtle is dead
             *)
            (#
            do inner
            #);
          thePatch:
            (# ptch: ^Patch
            do (pos.x,pos.y) -> patches.get -> ptch[]
            exit ptch[]
            #);
          print1::<
            (# 
            do '[' -> put; who -> putint;  ']'->put;
            #);
       do (*(who * 20, who) -> pos;*)
          whoNo + 1 -> whoNo -> who;
          inner
       #);
     whoNo: @integer;
     Patch: Agent
       (# id,size: @integer;
          setSize: (# N: @integer enter n do n -> size #);
       enter id
       #);
     patch_size: @integer;
     setPatch_size: 
       (# n: @integer 
       enter n 
       do n -> patch_size  -> theWorldW.penSize -> theWorldW.patch_size;
       #);
     Breed: Turtle(# name: ^text do inner #);
     
     AgentSet: Set
       (# element::< Agent;
          set_default_shape:
            (# enter shape[]#);
          shape: ^Text;
          ask:
            (# with:< BooleanValue
                 (#
                 do true -> value; inner
                 #);
               current: ^Element
            do scan
               (#
               do current[] -> this(ask).current[];
                  (if with then
                      inner ask
                  if)
               #);
            #)
       #);
     TurtleSet: AgentSet
       (# element::< Turtle;       
          sprout:<
            (# n: @integer; B: ^element; TS: @TurtleSet; current: ^element
            enter n
            do (for i: n repeat
                    element -> TS.insert;
               for);
               TS.scan
               (#
               do current[] -> this(sprout).current[]; 
                  inner sprout 
               #)
            #)
       #);
     PatchSet: AgentSet
       (# element::< Patch;
          Ps: @
            (* matrix holding all patches
             * If patch_size = 4, then
             * Ps[1,1] = patch[0,0], Ps[1,2] = patch[0,4], Ps[1,3] = patch[0,8]
             * Ps[i,j] = patch[(i - 1) * 4, (j - 1) * 4]
             *)
            (# row: (# R: [world_width] ^Patch #);
               cols: @
                 (# col: [world_height] @row #);
               insert:
                 (# x,y: @integer; P: ^Patch
                 enter(x,y,P[])
                 do P[] -> cols.col[x].R[y][]
                 #);
               get:
                 (# x,y: @integer; P: ^Patch
                 enter(x,y)
                 do (if (0 < x) and (x <= world_width)
                        and ((0 < y)  and (y <= world_height)) then
                        cols.col[x].R[y][] -> P[]
                    if);
                 exit P[]
                 #);
            #);
          init:
            (# p: ^Patch; pNo: @integer;
            do (for i: world_width repeat
                    (for j: world_height repeat
                         pNo + 1 -> pNo -> Patch -> p[];
                         ((i - 1) * patch_size,(j-1) * patch_Size) -> P.pos;
                         P[] -> insert;
                         (i,j,P[]) -> Ps.insert
               for)for);
            #);
          get:
            (# x,y: @integer; thePatch: ^Patch
            enter(x,y)
            do ((x div patch_size) + 1,(y div patch_size) + 1)
                 -> Ps.get -> thePatch[]
            exit thePatch[]
            #);
       #);
     BreedSet: TurtleSet
       (# element::< Breed;
          sprout::
            (#
            do 
               inner
            #);
       #);
     turtles: ^TurtleSet;
     patches: ^PatchSet;
     
     theWorldW: @WorldWindow;
     clear_all:
       (# 
       do turtles.clear
       #);
     world_width: @ (# w: @integer enter w exit w #);
     world_height: @ (# h: @integer enter h exit h #);
  do 50 -> world_width;
     50 -> world_height;
     4 -> setPatch_size;
     (world_width,world_height,patch_size) -> theWorldW.open;
     &TurtleSet[]  -> turtles[];
     &patchSet[] -> patches[];
     patches.init;
     inner World
  #);

     
