ORIGIN '~beta/mps/astlevel';
LIB_DEF 'betaastindex' '../lib';
INCLUDE '~beta/mps/utils/getslotbinding';
INCLUDE '~beta/mps/private/indexPrivate';
INCLUDE 'gram';
BODY 'private/indexImpl';
-- astInterfaceLib: Attributes --
(* This form contains the patterns neccessary to interface the
 * ast-interface to the beta-Compiler. This is done via "index",
 * which gives an interface the ast's, which is functional equivalent
 * to the old interface used by the compiler.

 * This interface is only to be used by the compiler.
 * All other tools needing to access beta-ast's should use
 * the interface given in '~beta/betaast/betasematt'

 * Please do not look at the code. In the search of efficiency it is
 * some of the ugliest beta-code ever written
 *
 *
 * for people interested in the interiors of the ast-implementation,
 * here is the layout of an ast-node:
 *
 *   frag.a:       |   ..............   |
 *		   ----------------------
 *	 inx->     |   misc  |  comment |
 *		   ----------------------
 *		   | brother |  son     |
 *		   ----------------------
 *		   | attribute 1 of ast |
 *		   ----------------------
 *		   | attribute 2 of ast |
 *		   ----------------------
 *		   | .................. |
 *
 *
 *   misc is 16 bit describing:
 *		   byte 0           byte 1
 *		   0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
 *		   ---------------------------------
 *		   |S|E|F|       label             |
 *		   ---------------------------------
 *
 *	   F: 1 if this ast is last brother of the father.
 *		   then "brother" is used as father-link instead of brother
 *	    : 0 else
 *
 *	   E: 1 if this ast has an semantic error
 *	    : 0 else
 *
 *	   S: 1 if this ast is a slot
 *	    : 0 else
 *
 * son,brother,comment is known always to be even. Therefore the least
 * significant bit is not stored, and all index-value less than 2**17
 * can be saved
 *)
NULL: (#  exit (0,none ) #);
ASTindex: 
  (# <<SLOT ASTindexLib:attributes>>;
     index: @integer; frag: ^fragmentForm;
     
     asAST:
       (# theAst: ^ast
       do (if frag[] <> none then index->frag.indexToNode->theAst[] if)
       exit theAst[]
       #);
     a:
       (#
       enter (# as: ^ast enter as[] do as.index->index; as.frag[]->frag[] #)
       exit asAST
       #);
     f: (#  exit frag[] #);
     isNull: (#  exit (index = 0) #);
     nodeId: (#  exit index #);
     equal:
       (# inx1: @integer; frag1: ^fragmentForm
       enter (inx1,frag1[])
       exit ((index = inx1) and (frag[] = frag1[]))
       #);
     brother:
       (# brotherInx: @integer;
       do (if not (frag.a[index]->tos'%GetBits[2,1]') then
	      frag.a[index+1]->tos'%getShort[0]'->tos'%shiftLeft[1]'->brotherInx
	  if)
       exit (brotherInx,frag[])
       #);
     son:
       (#
       exit (frag.a[index+1]->tos'%getShort[1]'->tos'%shiftLeft[1]',frag[])
       #);
     sonRef:
       (# S: @ASTindex
       do son -> S
       exit S[]
       #);
     father:
       (# i: @integer; b: @boolean
       do (* expansion of
	   index->i;
	   loop: (if true
	    // (i=0) then
	    // (i->frag.isLastBrother) then
	        i->frag.nextBrother->i
	    else i->frag.nextBrother->i; restart loop
	   if);
	   *)
	  index->i;
	  loop:
	  (if true
	   // (i = 0) then

	   // (frag.a[i]->tos'%GetBits[2,1]'->b) then
	      frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i
	   else
	      frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i;
	      restart loop
	  if)
       exit (i,frag[])
       #);
     stringLengthOld:
       (#
       exit frag.a[index->frag.getSonInx->frag.getSonInx]->tos'%getShort[1]'
       #);
     stringLengthNew:
       (#
       exit frag.l[index->frag.getSonInx->frag.getSonInx]->tos'%getShort[1]'
       #);
     stringLength:
       (# l: @integer
       do (if frag.lcurtop > 1 then
              stringLengthNew -> l
           else
              stringLengthOld -> l
          if)
       exit l
       #);
     label:
       (#
       enter
	 (# theAst: ^ast; val: @integer
	 enter val
	 do a->theAst[]; val->theAst.symbolInx
	 #)
       exit frag.a[index]->tos'%getSignedBits[4,12]'
       #);
     isSlot: (#  exit frag.a[index]->tos'%GetBits[0,1]' #);
     theSlotName:
       (# un: ^unExpanded; sd: ^slotDesc
       do a->un[]; un.theSlot->sd[]
       exit sd.name
       #);
     getText:
       (# (*i: @ASTindex; l: ^lexemText;*)
          sonInx, lexeminx, base: @integer; t: ^text
       do (*son->i; i.a->l[];*)
          frag.a[index+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->sonInx;
          frag.a[sonInx+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->lexeminx;
          lexemInx*4->base; &text[]->t[];
          (if frag.lcurtop>1 then
              (for i: ((frag.l,base-2)->tos'%inxGetShort') repeat
                   (frag.l,base+i-1)->tos'%inxGetByte'->t.put
              for);
           else
              (for i: ((frag.a,base-2)->tos'%inxGetShort') repeat
                   (frag.a,base+i-1)->tos'%inxGetByte'->t.put
              for);
          if)
       exit t[]
       (*exit l.getText*)
       #);
     textEq: (# t: @text enter t exit (getText->t.equalNCS) #);
     getConst:
       (# i: @ASTindex
       enter
	 (# c: ^const; val: @integer
	 enter val
	 do son->i; i.a->c[]; val->c.valueInx;
	 #)
       exit (# c: ^const do son->i; i.a->c[] exit c.valueInx #)
       #);
     internal: (#  exit (label > 0) #);
     astKind: (#  exit label->frag.grammar.kindOfSymbol #);
     nodeClass: (#  exit grammarTable.beta.nodeClassArray[label] #);
     
     putAttribute:
       (# val,attributeNo: @integer
       enter (val,attributeNo)
       do val->frag.a[index+offset.attribute+attributeNo-1]
       #);
     getAttribute:
       (# attributeNo: @integer
       enter attributeNo
       exit frag.a[index+offset.attribute+attributeNo-1]
       #);
     putNodeAttribute:
       (# val: @ASTindex; attributeNo: @integer
       enter (val,attributeNo)
       do val->frag.packInxToValue->frag.a[index+offset.attribute+attributeNo-1]
       #);
     getNodeAttribute:
       (# attributeNo: @integer;
       enter attributeNo
       exit frag.a[index+offset.attribute+attributeNo-1]->frag.valueToIndex
       #);
     putPossibleSlot:
       (# val,attributeNo: @integer; theAst: ^ast
       enter (val,attributeNo)
       do
	  (if label = prodNo.unExpanded then
	      a->theAst[]; (val,attributeNo)->theAst.putSlotAttribute
	   else
	      val->frag.a[index+offset.attribute+attributeNo-1]
	  if);

       #);
     getPossibleSLot:
       (# attributeNo,val: @integer; theAst: ^ast
       enter attributeNo
       do (if label = prodNo.unExpanded then
	      a->theAst[]; attributeNo->theAst.getSlotAttribute->val
	   else
	      frag.a[index+offset.attribute+attributeNo-1]->val
	  if)
       exit val
       #);
     putNodePossibleSlot:
       (# val: @ASTindex; attributeNo: @integer; theAst: ^ast
       enter (val,attributeNo)
       do (if label = prodNo.unExpanded then
	      a->theAst[]; (val.a,attributeNo)->theAst.putSlotNodeAttribute
	   else
	      val->frag.packInxToValue
		->frag.a[index+offset.attribute+attributeNo-1]
	  if)
       #);
     getNodePossibleSlot:
       (# attributeNo: @integer;
	  theAst,val: ^ast;
	  inx1: @integer;
	  f: ^fragmentForm
       enter attributeNo
       do (if label = prodNo.unExpanded then
	      a->theAst[];
	      attributeNo->theAst.getSlotNodeAttribute->val[];
	      (if val[] <> none then val.index->inx1; val.frag[]->f[] if)
	   else
	      frag.a[index+offset.attribute+attributeNo-1]->frag.valueToIndex
		->(inx1,f[])
	  if)
       exit (inx1,f[])
       #);
     putSysAtt:
       (# b: @ASTindex; n: @integer
       enter (n,b)
       do (b,n)->putNodeAttribute
       #);
     getSysAtt: (# n: @integer enter n exit n->getNodeAttribute #);
     
  enter (index,frag[])
  exit (index,frag[])
  #);
addPrefix:
  (#
  (* desc must be a descriptor with empty prefix;
   * a non empty prefix node is inserted;
   * the name of the prefix is the empty string;
   * Is used for virtual categories like v::< (# ... #)
   *)
     desc: ^expanded;
     f: ^fragmentForm;
     pref: ^expanded;
     napl: ^expanded;
     na: ^nameAppl;
     gram: @grammar;
     descIndex: @ASTindex
  enter descIndex
  do
     descIndex.a->desc[];
     desc.frag[]->f[];
     (gram.Prefix,f[])->grammarTable.beta.newAst->pref[];
     (gram.NameApl,f[])->grammarTable.beta.newAst->napl[];
     (nameAppl,f[])->grammarTable.beta.newAst->na[];
     ''->na.putText;
     na[]->napl.putson1;
     napl[]->pref.putson1;
     pref[]->desc.putson1;

  exit (nApl.index,nApl.frag[])
  #);
adjustForm:
  (# f: ^fragmentForm; a: ^expanded; gram: @grammar
  enter f[]
  do
     (if f.root.symbol
      // gram.Attributes (* OLM: was AttributeL in old grammar/index *) then
	 (gram.AttributesForm,f[])->grammarTable.beta.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[];

      // gram.ObjectDescriptor then
	 (gram.DescriptorForm,f[])->grammarTable.beta.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[]
     if);

  #);
less: (#  exit 0 #);
equal: (#  exit 1 #);
greater: (#  exit 2 #);
CMP: (* compare two names *)
  (#
  (* this routines have been optimalized that much,
   that it is quite hard to understand,
   what is going on. There ought to be an
   unoptimalized description too *)
     n1inx,n2inx: @integer;
     (* of type nameDecl or NameAppl *)
     n1frag,n2frag: ^fragmentForm;
     res: @integer;
     l1,l2,lex1Inx,lex2Inx: @integer;
     c1,c2: @integer;
     n1addr: @integer;
     n2addr: @integer;
     lowerCaseDoesNotMatter: (#  exit 0xDFDFDFDF #);
     (* the hex-value dfdfdfdf:
      the bitvalue to be used to mask such that
      lower and upper case does not matter *)

  enter ((n1inx,n1frag[]),(n2inx,n2frag[]))
  <<SLOT CMP:DoPart>>
  exit res
  (*  exit (@@n1frag.a[1],n1Inx,@@n2frag.a[1],n2Inx)->TOS'ASTCmp'->res *)
  #);
EQS: (* compare two names *)
  (# n1,n2: @ASTindex enter (n1,n2) exit ((n1,n2)->CMP) = equal #);
scanList:
  (#
  (* scan the elements of the list;
   * currentNode wull exit t1, t2, ... Tn+1
   * tail will exit the tail of the list.
   *)
     currInx: @integer;
     label: @integer;
     currF: ^fragmentForm;
     currentNode: (#  exit (currInx,currF[]) #);
     tail: (# inx: @ASTindex do currentNode->inx exit inx.brother #);

  enter (currInx,currF[])
  do
     (if currInx <> 0 then
	 (if (currF.a[currInx]->tos'%getSignedBits[4,12]'->label) > 0 then
	     (if grammarTable.beta.nodeClassArray[label] = kinds.list then
		 currF.a[currInx+1]->tos'%getShort[1]'->tos'%shiftLeft[1]'
		   ->currInx;
		 scan:
		   (#
		   do
		      (if
		      ((currF.a[currInx]->tos'%getSignedBits[4,12]'->label) <>
		       prodNo.optional) then
			  INNER scanList
		      if);
		      (if (currF.a[currInx]->tos'%GetBits[2,1]')= 1 then leave scan
		       else
			  currF.a[currInx+1]->tos'%getShort[0]'
			    ->tos'%shiftLeft[1]'->currInx;
			  restart scan
		      if)
		   #)
	      else
		 INNER
	     if)
	 if)
     if)
  #);
prettyPrinter: 
  (# thePP: @<<SLOT prettyPrinterBody:Descriptor>>;
     st: ^stream;
     inx: @ASTindex;
     a: ^ast;
     level: @integer;
     editorMode: @boolean
  enter (inx,st[],level,editorMode)
  do inx.a->a[]; thePP
  #);


