ORIGIN '~beta/mps/v5.2/astlevel';
INCLUDE 'gram';
INCLUDE '~beta/mps/v5.2/private/indexPrivate';
BODY 'private/indexImpl';
-- astInterfaceLib: Attributes --
(* Modified by OLM 11.5.89
 *
 * This form contains the patterns neccessary to interface the
 * ast-interface to the beta-Compiler. This is done via "index",
 * which gives an interface the ast's, which is functional equivalent
 * to the old interface used by the compiler.

 * This interface is only to be used by the compiler.
 * All other tools needing to access beta-ast's should use
 * the interface given in '~beta/betaast/current/betasematt'

 * Please do not look at the code. In the search of efficiency it is
 * some of the ugliest beta-code ever written
 *
 * Number of semantic attributes for the differect syntactic categories of
 * beta as defined in '~beta/betaast/current/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    inDoPart	 1 bit  31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point to an ast
 * in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *
 *
 * for people interested in the interiors of the ast-implementation,
 * here is the layout of an ast-node:
 *
 *   frag.a:       |   ..............   |
 *		   ----------------------
 *	 inx->     |   misc  |  comment |
 *		   ----------------------
 *		   | brother |  son     |
 *		   ----------------------
 *		   | attribute 1 of ast |
 *		   ----------------------
 *		   | attribute 2 of ast |
 *		   ----------------------
 *		   | .................. |
 *
 *
 *   misc is 16 bit describing:
 *		   byte 0           byte 1
 *		   0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
 *		   ---------------------------------
 *		   |S|E|F|       label             |
 *		   ---------------------------------
 *
 *	   F: 1 if this ast is last brother of the father.
 *		   then "brother" is used as father-link instead of brother
 *	    : 0 else
 *
 *	   E: 1 if this ast has an semantic error
 *	    : 0 else
 *
 *	   S: 1 if this ast is a slot
 *	    : 0 else
 *
 * son,brother,comment is known always to be even. Therefore the least
 * significant bit is not stored, and all index-value less than 2**17
 * can be saved
 *)
NULL: (#  exit (0,none ) #);
Index:
  (#
     a:
       (#
       enter (# as: ^ast enter as[] do as.index->inx; as.frag[]->frag[] #)
       exit
	 (# theAst: ^ast
	 do (if frag[] <> none then inx->frag.indexToNode->theAst[] if)
	 exit theAst[]
	 #)
       #);
     f: (#  exit frag[] #);
     inx: @integer;
     frag: ^fragmentForm;
     equal:
       (# inx1: @integer; frag1: ^fragmentForm
       enter (inx1,frag1[])
       exit ((inx = inx1) and (frag[] = frag1[]))
       #);
     brother:
       (# brotherInx: @integer;
       do
	  (if not (frag.a[inx]->tos'%GetBits[2,1]') then
	      frag.a[inx+1]->tos'%getShort[0]'->tos'%shiftLeft[1]'->brotherInx
	  if)
       exit (brotherInx,frag[])
       #);
     errInx:
       (# err: @integer; theAst: ^ast;
       enter (#  enter err do a->theAst[]; err->theAst.semanticError #)
       exit (#  do a->theAst[] exit theAst.semanticError #)
       #);
     clearError: (#  do (@@ frag.a[inx],false)->tos'%PutBits[1,1]' #);
     son:
       (#
       exit (frag.a[inx+1]->tos'%getShort[1]'->tos'%shiftLeft[1]',frag[])
       #);
     isNull: (#  exit (inx = 0) #);
     nodeId: (#  exit inx #);
     stringLength:
       (#
       exit frag.a[inx->frag.getSonInx->frag.getSonInx]->tos'%getShort[1]'
       #);
     label:
       (#
       enter
	 (# theAst: ^ast; val: @integer
	 enter val
	 do a->theAst[]; val->theAst.symbolInx
	 #)
       exit frag.a[inx]->tos'%getSignedBits[4,12]'
       #);
     isSlot: (#  exit frag.a[inx]->tos'%GetBits[0,1]' #);
     theSlotDesc: (# un: ^unExpanded do a->un[] exit un.theSlot #);
     theSlotName:
       (# un: ^unExpanded; sd: ^slotDesc
       do a->un[]; un.theSlot->sd[]
       exit sd.name
       #);
     getText:
       (# i: @index; l: ^lexemText do son->i; i.a->l[] exit l.getText #);
     textEq: (# t: @text enter t exit (getText->t.equalNCS) #);
     nodeClass: (#  exit grammarTable.beta.nodeClassArray[label] #);
     getConst:
       (# i: @index
       enter
	 (# c: ^const; val: @integer
	 enter val
	 do son->i; i.a->c[]; val->c.valueInx;
	 #)
       exit (# c: ^const do son->i; i.a->c[] exit c.valueInx #)
       #);
     putAttribute:
       (# val,attributeNo: @integer
       enter (val,attributeNo)
       do val->frag.a[inx+offset.attribute+attributeNo-1]
       #);
     getAttribute:
       (# attributeNo: @integer
       enter attributeNo
       exit frag.a[inx+offset.attribute+attributeNo-1]
       #);
     putNodeAttribute:
       (# val: @index; attributeNo: @integer
       enter (val,attributeNo)
       do val->frag.packInxToValue->frag.a[inx+offset.attribute+attributeNo-1]
       #);
     getNodeAttribute:
       (# attributeNo: @integer;
       enter attributeNo
       exit frag.a[inx+offset.attribute+attributeNo-1]->frag.valueToIndex
       #);
     putPossibleSlot:
       (# val,attributeNo: @integer; theAst: ^ast
       enter (val,attributeNo)
       do
	  (if label = prodNo.unExpanded then
	      a->theAst[]; (val,attributeNo)->theAst.putSlotAttribute
	   else
	      val->frag.a[inx+offset.attribute+attributeNo-1]
	  if);

       #);
     getPossibleSLot:
       (# attributeNo,val: @integer; theAst: ^ast
       enter attributeNo
       do
	  (if label = prodNo.unExpanded then
	      a->theAst[]; attributeNo->theAst.getSlotAttribute->val
	   else
	      frag.a[inx+offset.attribute+attributeNo-1]->val
	  if)
       exit val
       #);
     putNodePossibleSlot:
       (# val: @index; attributeNo: @integer; theAst: ^ast
       enter (val,attributeNo)
       do
	  (if label = prodNo.unExpanded then
	      a->theAst[]; (val.a,attributeNo)->theAst.putSlotNodeAttribute
	   else
	      val->frag.packInxToValue
		->frag.a[inx+offset.attribute+attributeNo-1]
	  if)
       #);
     getNodePossibleSlot:
       (#
	  attributeNo: @integer;
	  theAst,val: ^ast;
	  inx1: @integer;
	  f: ^fragmentForm
       enter attributeNo
       do
	  (if label = prodNo.unExpanded then
	      a->theAst[];
	      attributeNo->theAst.getSlotNodeAttribute->val[];
	      (if val[] <> none then val.index->inx1; val.frag[]->f[] if)
	   else
	      frag.a[inx+offset.attribute+attributeNo-1]->frag.valueToIndex
		->(inx1,f[])
	  if)
       exit (inx1,f[])
       #);
     astKind: (#  exit label->frag.grammar.kindOfSymbol #);
     father:
       (# i: @integer; b: @boolean
       do
       (* expansion of
	inx->i;
	loop: (if true
	//(i=0) then
	//(i->frag.isLastBrother) then
	i->frag.nextBrother->i
	else i->frag.nextBrother->i; restart loop
	if);
	*)
	  inx->i;
	  loop:
	  (if true
	   // (i = 0) then

	   // (frag.a[i]->tos'%GetBits[2,1]'->b) then
	      frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i
	   else
	      frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i;
	      restart loop
	  if)
       exit (i,frag[])
       #);
     descNo:
       (#
       enter (# v: @integer enter v do (v,1)->putPossibleSlot #)
       exit 1->getPossibleSlot
       #);
     descId:
       (# inx1: @integer; f: ^fragment
       enter ((inx1,f[]),descNo)
       exit
	 (# t: ^text; p: @integer; gram: @grammar
	 do
	    &text[]->t[];
	    (if frag.root.symbolInx = gram.attributesForm then
		frag.father->f[];
		f.name->t[];
		thePathHandler.directoryChar->t.FindAll(#  do inx->P #);
		(P+1,t.length)->t.sub->t[]
	     else
	    (*//gram.DescriptorForm//doPart//mainPart*)
		frag.nameT->t
	    if)
	 exit (t[],descNo)
	 #)
       #);
     origin:
       (# f: ^fragmentForm
       enter (frag.a[inx+offset.attribute+1],f[])
       exit (frag.a[inx+offset.attribute+1],frag[])
       #);
     slotOrigin:
       (#
       enter
	 (# inx1: @integer; f: ^fragmentForm
	 enter (inx1,f[])
	 do (inx1,2)->putPossibleSlot
	 #)
       exit (2->getPossibleSlot,frag[])
       #);
     Xorigin:
       (#
       enter
	 (# inx1: @integer; f: ^fragmentForm
	 enter (inx1,f[])
	 do ((inx1,f[]),2)->putNodePossibleSlot
	 #)
       exit 2->getNodePossibleSlot
       #);
     size:
       (#
       enter (# v: @integer enter v do (v,3)->putPossibleSlot #)
       exit 3->getPossibleSlot
       #);
     attSize: (* must be eliminated *)
       (#
       enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
       exit 4->getPossibleSlot
       #);
     virtSize:
       (#
       enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
       exit 4->getPossibleSlot
       #);
     kind:
       (#
       enter (# v: @integer enter v do (v,5)->putPossibleSlot #)
       exit 5->getPossibleSlot
       #);
     dclRoot:
       (#
       enter
	 (# inx1: @integer; f: ^fragmentForm
	 enter (inx1,f[])
	 do (inx1,6)->putPossibleSlot
	 #)
       exit (6->getPossibleSlot,frag[])
       #);
     lib:
       (#
       enter
	 (# inx1: @integer; f: ^fragmentForm
	 enter (inx1,f[])
	 do (inx1,7)->putPossibleSlot
	 #)
       exit (7->getPossibleSlot,frag[])
       #);
     next:
       (#
       enter
	 (# inx1: @integer; f: ^fragmentForm
	 enter (inx1,f[])
	 do (inx1,1)->putPossibleSlot
	 #)
       exit (1->getPossibleSlot,frag[])
       #);
     originOff:
       (#
       enter (*(# v: @integer enter v do (v,8)->putPossibleSlot #)*)
	  (# v: @integer enter v
	  do (v,1)->frag.a[inx+offset.attribute+7].%putShort
	  #)
       exit (*8->getPossibleSlot*)
	  1 -> frag.a[inx+offset.attribute+7].%getShort
       #);
     returnOff:
       (#
       enter (*(# v: @integer enter v do (v,8)->putPossibleSlot #)*)
	  (# v: @integer enter v
	  do (v,0)->frag.a[inx+offset.attribute+7].%putShort
	  #)
       exit (*8->getPossibleSlot*)
	  0 -> frag.a[inx+offset.attribute+7].%getShort
       #);
     sort:
       (# s: @index
       enter s
       exit
	 (# gram: @grammar
	 do
	    father->s;
	    (* No. IT is not always the grandfather.
	     * In a labelledImp it is the father *)
	    (if s.label <> gram.labelledImp then s.father->s if)
	 exit s
	 #)
       #);
     evalKind: (* att no. 1!! *)
       (#
       enter frag.a[inx+offset.attribute]
       exit frag.a[inx+offset.attribute]
       #);
     insOff: (* att no. 2 !! *)
       (#
       enter frag.a[inx+offset.attribute+1]
       exit frag.a[inx+offset.attribute+1]
       #);
     NXoff:
       (#
       enter frag.a[inx+offset.attribute]
       exit frag.a[inx+offset.attribute]
       #);
     NXsize:
       (#
       enter frag.a[inx+offset.attribute+1]
       exit frag.a[inx+offset.attribute+1]
       #);
     access:
       (#
       enter
	 (# v: @integer
	 enter v
	 do (@@ frag.a[inx+offset.attribute],v)->tos'%putByte[0]'
	 #)
       exit frag.a[inx+offset.attribute]->tos'%getByte[0]'
       #);
     off:
       (#
       enter
	 (# v: @integer;
	 enter v
	 do (@@ frag.a[inx+offset.attribute],v)->tos'%putBits[8,24]'
	 #)
       exit frag.a[inx+offset.attribute]->tos'%getBits[8,24]'
       #);
     left:
       (# inx1: @integer
       enter
	 (# f: ^fragmentForm
	 enter (inx1,f[])
	 do
	    (@@ frag.a[inx+offset.attribute+1],inx1->tos'%shiftRight[1]')
	      ->tos'%putShort[0]'
	 #)
       exit
       (frag.a[inx+offset.attribute+1]->tos'%getShort[0]'->tos'%shiftLeft[1]',
	frag[])
       #);
     right:
       (# inx1: @integer
       enter
	 (# f: ^fragmentForm
	 enter (inx1,f[])
	 do
	    (@@ frag.a[inx+offset.attribute+1],inx1->tos'%shiftRight[1]')
	      ->tos'%putShort[1]'
	 #)
       exit
       (frag.a[inx+offset.attribute+1]->tos'%getShort[1]'->tos'%shiftLeft[1]',
	frag[])
       #);
     virtDcl:
       (#
       enter
	 (# b,f: @index
	 enter b
	 do father->f; f.father->f; ((b.inx,b.frag[]),1)->f.putNodeAttribute
	 #)
       exit
	 (# f: @index
	 do father->f; f.father->f
	 exit 1->f.getNodeAttribute
	 #)
       #);
     restartAdr:
       (#
       enter
	 (# v: @integer
	 enter v
	 do (@@ frag.a[inx+offset.attribute+1],v)->tos'%putShort[0]';
	 #)
       exit frag.a[inx+offset.attribute+1]->tos'%getShort[0]'
       #);
     leaveAdr:
       (#
       enter
	 (# v: @integer
	 enter v
	 do (@@ frag.a[inx+offset.attribute+1],v)->tos'%putShort[1]';
	 #)
       exit frag.a[inx+offset.attribute+1]->tos'%getShort[1]'
       #);
     dclRef:
       (#
       enter (frag.packInxToValue->frag.a[inx+offset.attribute])
       exit frag.a[inx+offset.attribute]->frag.valueToIndex
       #);
     on:
       (#
       enter frag.a[inx+offset.attribute+1]
       exit frag.a[inx+offset.attribute+1]
       #);
     pn:
       (# f: ^fragmentForm
       enter
	 (# V: @integer
	 enter V
	 do (@@ frag.a[inx+offset.attribute+2],V)->tos'%putBits[0,16]'
	 #)
       exit frag.a[inx+offset.attribute+2]->tos'%getbits[0,16]'
       #);
     inDoPart:
       (#
       enter
	 (# V: @boolean
	 enter V
	 do (@@ frag.a[inx+offset.attribute+2],V)->tos'%putBits[31,1]'
	 #)
       exit frag.a[inx+offset.attribute+2]->tos'%getbits[31,1]'
       #);
     descRef:
       (#
       enter (frag.packInxToValue->frag.a[inx+offset.attribute+3])
       exit frag.a[inx+offset.attribute+3]->frag.valueToIndex
       #);
     dscRef: (* to replace descRef *)
       (#
       enter (frag.packInxToValue->frag.a[inx+offset.attribute+3])
       exit frag.a[inx+offset.attribute+3]->frag.valueToIndex
       #);
     putSysAtt:
       (# b: @index; n: @integer
       enter (n,b)
       do (b,n)->putNodeAttribute
       #);
     getSysAtt: (# n: @integer enter n exit n->getNodeAttribute #);
     internal: (#  exit (label > 0) #);
     markError:
       (# errNo: @integer
       enter errNo
       do (if not localErr then errNo->errInx if)
       #);
     localErr:
       (# mark: @boolean; n: @index
       do
	  (if not (inError->mark) then
	      (if internal then
		  son->n; (if not n.isNull then 8->&n.errmarked->mark if)
	      if)
	  if)
       exit mark
       #);
     ErrMarked:
       (# level: @integer; mark: @boolean; n: @index
       enter level
       do
	  (if not (inError->mark) then
	      (if (0 < level) then
		  (if internal then
		      son->n;
		      (if not n.isNull then level-1->&N.errMarked->mark if)
		  if);
		  brother->n;
		  (if not n.isNull then
		      (level->&N.errMarked) or mark->mark
		  if)
	      if)
	  if)
       exit mark
       #);
     inError: (#  exit frag.a[inx]->tos'%getBits[1,1]' #);
     lispPrint:
       (# l: @integer; theAst: ^ast;
       enter l
       do 'Call of lisp-print '->screen.putText; a->theAst[]; theAst.dump;
       #);
     GetBinding:
     (* Get the bindings of this Slot within the group G.
      *  All bindings are delivered.
      *  For each binding, Found is called.
      *  The elements of G must be fragment forms or links to such. *)
       (#
	  Mark: @
	    (#
	       Scan:
		 (# thisGroup: ^FragmentGroup; R: ^Elm
		 do
		    head[]->R[];
		    L:
		    (if (R[] <> none ) then
			R.F[]->ThisGroup[]; INNER ; R.succ[]->R[]; restart L
		    if)
		 #);
	       elm: (# F: ^FragmentGroup; succ: ^Elm #);
	       head: ^Elm;
	       F: ^FragmentGroup;
	       inserted: @boolean
	    enter F[]
	    do
	       Insert:
		 (# R: ^Elm
		 do
		    false->inserted;
		    head[]->R[];
		    L:
		    (if (R[] <> none ) then
			(if R.F[] = F[] then leave insert if);
			R.succ[]->R[];
			restart L
		    if);
		    &Elm[]->R[];
		    F[]->R.F[];
		    head[]->R.succ[];
		    R[]->Head[];
		    True->inserted;
		    trace.GetBindingMark
		      ->tracer
			(#
			do
			   'marked: '->screen.putText;
			   f.fullname->screen.putText;

			#);

		 #)
	    exit inserted
	    #);
	  Find:
	    (# F: ^Fragment; G: ^FragmentGroup
	    enter F[]
	    do
	       (if (F[] <> none ) then
		   (if F.FragType = groupType then
		       (if (F[]->G[]->mark) then
			   G.scanIncludes
			     (# F1: ^Fragment; fn: ^text
			     do current.fullname->fn[];
				(if (fn[]->top.groupTable.find->F1[])=NONE then
				    (fn[],screen[])->top.open->F1[]
				if);
				F1[] -> &Find
			     #);
			     (*(# do (name[],screen[])->top.open->&Find #);*)
			   G.origin->&Find
		       if)
		   if)
	       if)
	    #);
	  Found:<
	    (# theBinding: ^FragmentForm
	    enter theBinding[]
	    do
	       trace.GetBinding
		 ->tracer
		   (#
		   do
		      'binding found '->screen.putText;
		      theBinding.fullName->screen.putText;

		   #);
	       INNER
	    #);
	  G: ^FragmentGroup;
	  un: ^unExpanded;
	  sl: ^slotDesc
       enter G[]
       do
	  trace.GetBinding
	    ->tracer
	      (#
	      do
		 'GetBinding of '->screen.putText;
		 ((inx,frag[]),screen[],3,false)->prettyPrinter;
		 ' for '->screen.putText;
		 g.fullName->screen.putText;

	      #);
	  G[]->&Find;
	  a->un[];
	  un.theSlot->sl[];
	  Mark.Scan (* scan visible groups for forms *)
	    (#
	    do
	       thisGroup.Scan
		 (# F: ^FragmentForm; B: ^SlotDesc
		 do
		    (if current.FragType = FormType then
			current[]->f[];
			f.binding[]->b[];
			(if (b[] <> none ) then
			    (if (b[]->sl.equal) then current[]->&found if)
			if)
		    if)
		 #)
	    #)
       #);

  enter (inx,frag[])
  exit (inx,frag[])
  #);
addPrefix:
  (#
  (* desc must be a descriptor with empty prefix;
   * a non empty prefix node is inserted;
   * the name of the prefix is the empty string;
   * Is used for virtual categories like v::< (# ... #)
   *)
     desc: ^expanded;
     f: ^fragmentForm;
     pref: ^expanded;
     napl: ^expanded;
     na: ^nameAppl;
     gram: @grammar;
     descIndex: @index
  enter descIndex
  do
     descIndex.a->desc[];
     desc.frag[]->f[];
     (gram.Prefix,f[])->grammarTable.beta.newAst->pref[];
     (gram.NameApl,f[])->grammarTable.beta.newAst->napl[];
     (nameAppl,f[])->grammarTable.beta.newAst->na[];
     ''->na.putText;
     na[]->napl.putson1;
     napl[]->pref.putson1;
     pref[]->desc.putson1;

  exit (nApl.index,nApl.frag[])
  #);
adjustForm:
  (# f: ^fragmentForm; a: ^expanded; gram: @grammar
  enter f[]
  do
     (if f.root.symbol
      // gram.Attributes (* OLM: was AttributeL in old grammar/index *) then
	 (gram.AttributesForm,f[])->grammarTable.beta.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[];

      // gram.ObjectDescriptor then
	 (gram.DescriptorForm,f[])->grammarTable.beta.newAst->a[];
	 f.root[]->a.putson1;
	 a[]->f.root[]
     if);

  #);
less: (#  exit 0 #);
equal: (#  exit 1 #);
greater: (#  exit 2 #);
CMP: (* compare two names *)
  (#
  (* this routines have been optimalized that much,
   that it is quite hard to understand,
   what is going on. There ought to be an
   unoptimalized description too *)
     n1inx,n2inx: @integer;
     (* of type nameDecl or NameAppl *)
     n1frag,n2frag: ^fragmentForm;
     res: @integer;
     l1,l2,lex1Inx,lex2Inx: @integer;
     c1,c2: @integer;
     n1addr: @integer;
     n2addr: @integer;
     lowerCaseDoesNotMatter: (#  exit 0xDFDFDFDF #);
     (* the hex-value dfdfdfdf:
      the bitvalue to be used to mask such that
      lower and upper case does not matter *)

  enter ((n1inx,n1frag[]),(n2inx,n2frag[]))
  <<SLOT CMP:DoPart>>
  exit res
  (*  exit (@@n1frag.a[1],n1Inx,@@n2frag.a[1],n2Inx)->TOS'ASTCmp'->res *)
  #);
EQS: (* compare two names *)
  (# n1,n2: @index enter (n1,n2) exit ((n1,n2)->CMP) = equal #);
scanList:
  (#
  (* scan the elements of the list;
   * currentNode wull exit t1, t2, ... Tn+1
   * tail will exit the tail of the list.
   *)
     currInx: @integer;
     label: @integer;
     currF: ^fragmentForm;
     currentNode: (#  exit (currInx,currF[]) #);
     tail: (# inx: @index do currentNode->inx exit inx.brother #);

  enter (currInx,currF[])
  do
     (if currInx <> 0 then
	 (if (currF.a[currInx]->tos'%getSignedBits[4,12]'->label) > 0 then
	     (if grammarTable.beta.nodeClassArray[label] = kinds.list then
		 currF.a[currInx+1]->tos'%getShort[1]'->tos'%shiftLeft[1]'
		   ->currInx;
		 scan:
		   (#
		   do
		      (if
		      ((currF.a[currInx]->tos'%getSignedBits[4,12]'->label) <>
		       prodNo.optional) then
			  INNER scanList
		      if);
		      (if (currF.a[currInx]->tos'%GetBits[2,1]')= 1 then leave scan
		       else
			  currF.a[currInx+1]->tos'%getShort[0]'
			    ->tos'%shiftLeft[1]'->currInx;
			  restart scan
		      if)
		   #)
	      else
		 INNER
	     if)
	 if)
     if)
  #);
prettyPrinter:
  (#
     thePP: @<<SLOT prettyPrinterBody:Descriptor>>;
     st: ^stream;
     inx: @index;
     a: ^ast;
     level: @integer;
     editorMode: @boolean
  enter (inx,st[],level,editorMode)
  do inx.a->a[]; thePP
  #);
