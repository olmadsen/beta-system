ORIGIN 'index'
(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---
descNo:
  (#
  enter (# v: @integer enter v do (v,1)->putPossibleSlot #)
  exit 1->getPossibleSlot
  #);
descId:
  (# inx1: @integer; f: ^fragment
  enter ((inx1,f[]),descNo)
  exit
     (# t: ^text; p: @integer; gram: @grammar
     do
        &text[]->t[];
        (if frag.root.symbolInx = gram.attributesForm then
            frag.father->f[];
            f.name->t[];
            thePathHandler.directoryChar->t.FindAll(#  do inx->P #);
            (P+1,t.length)->t.sub->t[]
         else
	    (*//gram.DescriptorForm//doPart//mainPart*)
            frag.nameT->t
        if)
     exit (t[],descNo)
     #)
  #);
origin:
  (# f: ^fragmentForm
  enter (frag.a[index+offset.attribute+1],f[])
  exit (frag.a[index+offset.attribute+1],frag[])
  #);
slotOrigin:
  (#
  enter
     (# inx1: @integer; f: ^fragmentForm
     enter (inx1,f[])
     do (inx1,2)->putPossibleSlot
     #)
  exit (2->getPossibleSlot,frag[])
  #);
Xorigin:
  (#
  enter
     (# inx1: @integer; f: ^fragmentForm
     enter (inx1,f[])
     do ((inx1,f[]),2)->putNodePossibleSlot
     #)
  exit 2->getNodePossibleSlot
  #);
size:
  (#
  enter (# v: @integer enter v do (v,3)->putPossibleSlot #)
  exit 3->getPossibleSlot
  #);
attSize: (* must be eliminated *)
  (#
  enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
  exit 4->getPossibleSlot
  #);
virtSize:
  (#
  enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
  exit 4->getPossibleSlot
  #);
kind:
  (#
  enter (# v: @integer enter v do (v,5)->putPossibleSlot #)
  exit 5->getPossibleSlot
  #);
dclRoot:
  (#
  enter
     (# inx1: @integer; f: ^fragmentForm
     enter (inx1,f[])
     do (inx1,6)->putPossibleSlot
     #)
  exit (6->getPossibleSlot,frag[])
  #);
lib:
  (#
  enter
     (# inx1: @integer; f: ^fragmentForm
     enter (inx1,f[])
     do (inx1,7)->putPossibleSlot
     #)
  exit (7->getPossibleSlot,frag[])
  #);
next:
  (#
  enter
     (# inx1: @integer; f: ^fragmentForm
     enter (inx1,f[])
     do (inx1,1)->putPossibleSlot
     #)
  exit (1->getPossibleSlot,frag[])
  #);
originOff:
  (#
  enter (*(# v: @integer enter v do (v,8)->putPossibleSlot #)*)
     (# v: @integer enter v
     do (v,1)->frag.a[index+offset.attribute+7].%putShort
     #)
  exit (*8->getPossibleSlot*)
     1 -> frag.a[index+offset.attribute+7].%getShort
  #);
returnOff:
  (#
  enter (*(# v: @integer enter v do (v,8)->putPossibleSlot #)*)
     (# v: @integer enter v
     do (v,0)->frag.a[index+offset.attribute+7].%putShort
     #)
  exit (*8->getPossibleSlot*)
     0 -> frag.a[index+offset.attribute+7].%getShort
  #);
sort:
  (# s: @ASTindex
  enter s
  exit
     (# gram: @grammar
     do father->s;
        (* No. it is not always the grandfather.
         * In a labelledImp it is the father *)
        (if s.label <> gram.labelledImp then s.father->s if)
     exit s
     #)
  #);
evalKind: (* att no. 1!! *)
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);
insOff: (* att no. 2 !! *)
  (#
  enter frag.a[index+offset.attribute+1]
  exit frag.a[index+offset.attribute+1]
  #);
NXoff:
  (#
  enter frag.a[index+offset.attribute]
  exit frag.a[index+offset.attribute]
  #);
NXsize:
  (#
  enter frag.a[index+offset.attribute+1]
  exit frag.a[index+offset.attribute+1]
  #);
access:
  (#
  enter
     (# v: @integer
     enter v
     do (v, (index+offset.attribute-1)*4) -> frag.a.%putByte
        (* Above line tos_converted from: do (@@frag.a[index+offset.attribute],v)->tos'%putByte[0]' *)
     #)
  exit (0->frag.a[index+offset.attribute].%getByte)
  (* Above line tos_converted from: exit frag.a[index+offset.attribute]->tos'%getByte[0]' *)
  #);
foroff:
  (# value: @integer;
  enter (# enter value do (value, 1) -> putattribute #)
  exit (# do 1 -> getattribute -> value exit value #)
  #);
eval1:
  (# value: @integer;
  enter (# enter value do (value, 1) -> putattribute #)
  exit (# do 1 -> getattribute -> value exit value #)
  #);
eval2:
  (# value: @integer;
  enter (# enter value do (value, 2) -> putattribute #)
  exit (# do 2-> getattribute -> value exit value #)
  #);
off:
  (#
  enter
     (# v: @integer;
     enter v
     do ((v,8,24)->frag.a[index+offset.attribute].%putBits)
     (* Above line tos_converted from: do (@@frag.a[index+offset.attribute],v)->tos'%putBits[8,24]' *)
     #)
  exit ((8,24)->frag.a[index+offset.attribute].%getBits)
  (* Above line tos_converted from: exit frag.a[index+offset.attribute]->tos'%getBits[8,24]' *)
  #);
left:
  (# inx1: @integer
  enter
     (# f: ^fragmentForm
     enter (inx1,f[])
     do
        (inx1 %srl 1, (index+offset.attribute)*2)->frag.a.%putShort
        (* Above line tos_converted from: (inx1 %srl 1) %putShortAt(@@frag.a[index+offset.attribute+1]+2*0) *)
        (* Above line tos_converted from: (@@frag.a[index+offset.attribute+1], inx1->tos'%shiftRight[1]') ->tos'%putShort[0]' *)
     #)
  exit
     (((0->frag.a[index+offset.attribute+1].%getShort)) %sll 1,
     (* Above line tos_converted from: ((frag.a[index+offset.attribute+1]->tos'%getShort[0]')->tos'%shiftLeft[1]', *)
     frag[])
  #);
right:
  (# inx1: @integer
  enter
     (# f: ^fragmentForm
     enter (inx1,f[])
     do
        (inx1 %srl 1, (index+offset.attribute)*2+1)->frag.a.%putShort
        (* Above line tos_converted from: (inx1 %srl 1) %putShortAt(@@frag.a[index+offset.attribute+1]+2*1) *)
        (* Above line tos_converted from: (@@frag.a[index+offset.attribute+1], inx1->tos'%shiftRight[1]') ->tos'%putShort[1]' *)
     #)
  exit
     (((1->frag.a[index+offset.attribute+1].%getShort)) %sll 1,
     (* Above line tos_converted from: ((frag.a[index+offset.attribute+1]->tos'%getShort[1]')->tos'%shiftLeft[1]', *)
     frag[])
  #);
virtDcl:
  (#
  enter
     (# b,f: @ASTindex
     enter b
     do father->f; f.father->f; ((b.index,b.frag[]),1)->f.putNodeAttribute
     #)
  exit
     (# f: @ASTindex
     do father->f; f.father->f
     exit 1->f.getNodeAttribute
     #)
  #);
restartAdr:
  (#
  enter
     (# v: @integer
     enter v
     do (v, (index+offset.attribute)*2)->frag.a.%putShort;
     (* Above line tos_converted from: do (v) %putShortAt(@@frag.a[index+offset.attribute+1]+2*0); *)
     (* Above line tos_converted from: do (@@frag.a[index+offset.attribute+1],v)->tos'%putShort[0]'; *)
     #)
  exit (0->frag.a[index+offset.attribute+1].%getShort)
  (* Above line tos_converted from: exit frag.a[index+offset.attribute+1]->tos'%getShort[0]' *)
  #);
leaveAdr:
  (#
  enter
     (# v: @integer
     enter v
     do (v, (index+offset.attribute)*2+1)->frag.a.%putShort;
     (* Above line tos_converted from: do (v) %putShortAt(@@frag.a[index+offset.attribute+1]+2*1); *)
     (* Above line tos_converted from: do (@@frag.a[index+offset.attribute+1],v)->tos'%putShort[1]'; *)
     #)
  exit (1->frag.a[index+offset.attribute+1].%getShort)
  (* Above line tos_converted from: exit frag.a[index+offset.attribute+1]->tos'%getShort[1]' *)
  #);
dclRef:
  (#
  enter (frag.packInxToValue->frag.a[index+offset.attribute])
  exit frag.a[index+offset.attribute]->frag.valueToIndex
  #);
on:
  (#
  enter frag.a[index+offset.attribute+1]
  exit frag.a[index+offset.attribute+1]
  #);
pn:
  (# f: ^fragmentForm
  enter
     (# V: @integer
     enter V
     do (V,0,16) -> frag.a[index+offset.attribute+2].%putBits
     #)
  exit (0,16) -> frag.a[index+offset.attribute+2].%getBits
  #);
onForThis:
  (* to put/get recomputed on for this(p) *)
  (#
  enter
     (# V: @integer
     enter V
     do (V,16,16) -> frag.a[index+offset.attribute+2].%putBits
     #)
  exit (16,16) -> frag.a[index+offset.attribute+2].%getBits
  #);
descRef:
  (#
  enter (frag.packInxToValue->frag.a[index+offset.attribute+3])
  exit frag.a[index+offset.attribute+3]->frag.valueToIndex
  #);

inSameFragment:
  (# N: @ASTindex
  enter N
  exit frag[] = N.frag[]
  #)
