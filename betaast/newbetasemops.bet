ORIGIN 'newindex'
(* Sematic operations for BETA; extracted from index.bet in order
 * to make it easier to distinguish index.bet from mps/astlevel.bet.
 * 
 * The number of semantic attributes for the differect syntactic 
 * categories of beta as defined in '~beta/betaast/beta-meta.gram':
 * OBS must be corrected
 *    <DescriptorForm>: 16
 *    <AttributesForm>: 16
 *    <ObjectDescriptor>: 8
 *    <ForImp>: 2
 *    <repetitionDecl>: 2
 *    <LabelledImp>: 2
 *    <nameDcl>: 2
 *    <nameApl>: 4
 *    <bindingDecl>: 2
 *
 * A SYNTACTIC CATEGORY MUST HAVE AN EVEN NUMBER OF SEMANTIC ATTRIBUTE!!!
 *
 * semantic attributes:
 *
 * syntactic category:	Name:	Location:
 *
 * attributesForm	*Xorigin      2
 *
 * descriptorForm        descNo       1
 *  	  		*Xorigin      2
 *			*sysAtt       3    hashIndex
 *			              4-10 standard descriptors
 *
 * objectDescriptor	 descNo       1
 * 			$origin       2
 * 			 size         3
 *			 attSize      4
 *			 kind         5
 *			$dclRoot      6
 *			$lib          7
 *                       returnOff    8  [bits  0-15]
 *			 originOff    8  [bits 16-31]
 *			 descId       computed
 *
 * slots                 descNo       1      (if slot is descriptor)
 *			*slotOrigin   2      (if slot is descriptor)
 *			 size         3      (if slot is descriptor)
 *			 attSize      4      (if slot is descriptor)
 *			 kind         5      (if slot is descriptor)
 *			$dclRoot      6      (if slot is descriptor)
 *		 	$lib          7      (if slot is descriptor)
 *			 originOff    8 (if descriptor slot)
 *		 	 descId    computed  (if slot is descriptor)
 *			$next         1      (if slot is attributes)
 *
 * repetitionDecl                  $origin       2
 *
 * forImp                          $origin       2
 *
 * MandatoryEnter
 * OptionalEnter
 * MandatoryExit
 * OptionalExit		 NXoff		1
 *			 NXsize		2
 * insertedObject	 insOff         2
 * objectEval 		 evalKind	1
 * 			 insOff		2 (if evalKind=insObj)
 * labelledImp                     $origin       2
 *
 * nameApl                         *dclRef       1
 *				    on           2
 *				    pn           3 bits 0-15
 *				    onForThis    3 bits 16-31
 *				   *descRef      4
 *
 * nameDcl                          accesss      1, first byte
 *				    off          1, last 3 bytes
 *				   $left         2, first 2 bytes
 *				   $right        2, last 2 bytes
 *				   $sort         computed
 *				   *virtDcl      only to be used for nameDcl
 *					      which are parts of bindingDecl.
 *					      attribute is found as attribute 1
 *					      of the bindingDecl
 *				 restartAdr   only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, first 2 bytes
 *				 leaveAdr     only to be used for the
 *					      namedcl-part of a labelledImp,
 *					      attribute 2, last 2 bytes
 *
 * attributes marked with an * are node-references which might point 
 * to an ast in another fragment.
 *
 * attributes marked with an $ are node-references which must point to an ast
 * in the same fragment
 *

 *)
---ASTindexLib:attributes---
descNo:
  (#
  enter (# v: @integer enter v do (v,1)->putPossibleSlot #)
  exit 1->getPossibleSlot
  #);
descId:
  (# inx1: @integer; f: ^fragment
  enter ((inx1,f[]),descNo)
  exit
     (# t: ^text; p: @integer; gram: @grammar
     do &text[]->t[];
        (if theAst.frag.root.symbolInx = gram.attributesForm then
            theAst.frag.father->f[];
            f.name->t[];
            thePathHandler.directoryChar->t.FindAll(#  do inx->P #);
            (P+1,t.length)->t.sub->t[]
         else
	    (* //gram.DescriptorForm//doPart//mainPart *)
            theAst.frag.nameT->t
         if)
     exit (t[],descNo)
     #)
  #);
origin:
  (# f: ^fragmentForm
  enter 
     (# N: ^AST
     enter N[]
     do (N[],2) -> theAst.putNodeAttribute
     #)
  exit 2 -> theAst.getNodeAttribute
  #);
slotOrigin:
  (#
  enter
     (# N: ^AST
     enter N[]
     do (N[],2) -> theAst.putSlotNodeAttribute
     #)
  exit 2 -> theAst.getSlotNodeAttribute
  #);
Xorigin:
  (#
  enter
     (# N: ^AST
     enter N[]
     do (N[],2) -> putNodePossibleSLot
     #)
  exit 2 -> getNodePossibleSlot
  #);
size:
  (#
  enter (# v: @integer enter v do (v,3)->putPossibleSlot #)
  exit 3->getPossibleSlot
  #);
attSize: (* must be eliminated *)
  (#
  enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
  exit 4->getPossibleSlot
  #);
virtSize:
  (#
  enter (# v: @integer enter v do (v,4)->putPossibleSlot #)
  exit 4->getPossibleSlot
  #);
kind:
  (#
  enter (# v: @integer enter v do (v,5)->putPossibleSlot #)
  exit 5->getPossibleSlot
  #);
dclRoot:
  (#
  enter
     (# N: ^AST
     enter N[]
     do (n[],6) -> putNodePossibleSlot
     #)
  exit 6 -> getNodePossibleSlot
  #);
lib:
  (#
  enter
     (#  N: ^AST
     enter N[]
     do (N[],7) -> putNodePossibleSlot
     #)
  exit 7 -> getNodePossibleSlot
  #);
next:
  (#
  enter
     (# N: ^AST
     enter N[]
     do (N[],1) -> putNodePossibleSlot
     #)
  exit 1 -> getNodePossibleSlot
  #);
originOff:
  (#
  enter (# v: @integer enter v do (v,8)->putPossibleSlot #)
  exit 8->getPossibleSlot
  #);
returnOff:
  (#
  enter (# v: @integer enter v do (v,8)->putPossibleSlot #)
  exit 8->getPossibleSlot
  #);
sort:
  (# 
  enter (# S: ^Ast enter S[] (* jus dummy? *) #)
  exit
     (# gram: @grammar; s: ^AST
     do theAST.father -> s[];
        (* No. IT is not always the grandfather.
         * In a labelledImp it is the father *)
        (if s.symbol <> gram.labelledImp then s.father->s[] if)
     exit s[]
     #)
  #);
evalKind: (* att no. 1!! *)
  (#
  enter (# V: @integer enter V do (V,1) -> theAst.putAttribute #)
  exit 1 -> theAst.getAttribute
  #);
insOff: (* att no. 2 !! *)
  (#
  enter (# V: @integer enter V do (V,2) -> theAst.putAttribute #)
  exit 2 -> theAST.getAttribute
  #);
NXoff:
  (#
  enter (# V: @integer enter V do (V,1) -> theAst.putAttribute #)
  exit 1 -> theAst.getAttribute
  #);
NXsize:
  (#
  enter (# V: @integer enter V do (V,2) -> theAst.putAttribute #)
  exit 2 -> theAst.getAttribute
  #);
access:
  (#
  enter
     (# v,w: @integer
     enter v
     do 1 -> theAST.getAttribute -> w;
        (V,0) -> w.%putByte;
        (w,1) -> theAst.putAttribute
     #)
  exit (# V : @integer 
       do 1 -> theAst.getAttribute -> V 
       exit 0 -> V.%getByte 
       #)
  #);
off:
  (#
  enter
     (# v,w: @integer;
     enter v
     do   1-> theAST.getAttribute -> w; 
        (v,8,24) -> w.%putBits; 
        (w,1) -> theAst.putAttribute
     #)
  exit (#v: @integer 
       do 1 -> theAst.getAttribute -> v 
       exit (8,24) -> v.%getBits 
       #)
  #);
left:
  (# inx1: @integer
  enter
     (# N: ^AST; IX: @integer
     enter N[]
     do (if N[] <> NONE then N.index -> IX if);
        (@@ theAst.frag.a[theAst.index+offset.attribute+1]
        ,IX ->tos'%shiftRight[1]')
         -> tos'%putShort[0]'
     #)
  exit 
     theAst.frag.a[theAst.index+offset.attribute+1]
       -> tos'%getShort[0]'
       -> tos'%shiftLeft[1]'
       -> theAst.frag.indexToNode
  #);
right:
  (# inx1: @integer
  enter
     (# N: ^AST; IX: @integer
     enter N[]
     do (if N[] <> NONE then N.index -> IX if);
        (@@ theAst.frag.a[theAst.index+offset.attribute+1]
        ,IX->tos'%shiftRight[1]')
        -> tos'%putShort[1]'
     #)
  exit theAst.frag.a[theAst.index+offset.attribute+1]
       -> tos'%getShort[1]'
       -> tos'%shiftLeft[1]'
       -> theAst.frag.indexToNode 
  #);
virtDcl:
  (#
  enter
     (# b,f: ^AST
     enter b[]
     do father -> f[]; 
        f.father -> f[]; 
        (b[],1) -> f.putNodeAttribute
     #)
  exit
     (# f: ^AST
     do father ->f[]; 
        f.father -> f[];
     exit 1 -> f.getNodeAttribute
     #)
  #);
restartAdr:
  (#
  enter
     (# v,w: @integer
     enter v
     do 2 -> theAst.getAttribute -> w;
        (v,0) -> w.%putShort; 
        (w,2) -> theAST.putAttribute 
     #)
  exit (# V: @integer 
       do 2 -> theAst.getAttribute -> V 
       exit 0 -> V.%getShort 
       #)
  #);
leaveAdr:
  (#
  enter
     (# v,w: @integer
     enter v
     do 2 -> theAst.getAttribute -> w; 
        (v,1) -> w.%putShort;
        (w,2) -> theAst.putAttribute 
     #)
  exit (# V: @integer 
       do 2 -> theAst.getAttribute -> V 
       exit 1 -> V.%getShort 
       #)
  #);
dclRef:
  (#
  enter (# N: ^AST enter N[] do (N[],1) -> theAst.putNodeAttribute #)
  exit 1 -> theAst.getNodeAttribute
  #);
on:
  (#
  enter (# V: @integer enter V do (V,2) -> theAst.putAttribute #)
  exit 2 -> theAst.getAttribute
  #);
pn:
  (# f: ^fragmentForm
  enter
     (# V,w: @integer
     enter V
     do 3 -> theAst.getAttribute -> w;
        (V,0,16) -> w.%putBits;
        (w,3) -> theAst.putAttribute
     #)
  exit (# V: @integer
       do 3 -> theAst.getAttribute -> V;
       exit (0,16) -> V.%getBits
       #)
  #);
onForThis:
  (* to put/get recomputed on for this(p) *)
  (#
  enter
     (# V,w: @integer
     enter V
     do 3 -> theAst.getAttribute -> w;
        (V,16,16) -> w.%putBits;
        (w,3) -> theAst.putAttribute
     #)
  exit (# V: @integer
       do 3 -> theAst.getAttribute -> V;
       exit (16,16) -> V.%getBits
       #)
  #);
descRef:
  (#
  enter (# N: ^Ast
        enter N[]
        do (N[],4) -> theAst.putNodeAttribute
        #)
  exit 4 -> theAst.getNodeAttribute
  #);

inSameFragment:
  (# N: ^AST
  enter N[]
  exit theAst.frag[] = N.frag[]
  #)
