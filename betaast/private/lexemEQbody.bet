ORIGIN '../lexemEQ';
---newIndexCMP:doPart---
do (# n2frag: ^fragmentForm;
      n2inx,lex1inx,lex2inx,l1,l2,c1,c2: @integer;
      lowerCaseDoesNotMatter: (#  exit 0xDFDFDFDF #);
      
   do N2.frag[] -> n2frag[]; N2.index -> n2inx;
      
      ((((index*2+1) -> frag.a.%getShort)*4+1) -> frag.a.%getShort)*8
      -> lex1inx;
      
      ((((n2inx*2+1) -> n2frag.a.%getShort)*4+1) -> n2frag.a.%getShort)*8
      -> lex2inx;
      
      (* lex1inx->putint; ','->put;   lex2inx->putint; ','->put; *)
      
      (* OBS!  the index for short index with new primitive syntax
       * is half the length of short index with old primitive syntax
       * This means that ALL short indexes below MUST be divided by
       * two when changing to new primitive syntax
       *)
      
      
      (lex1inx - 4)  -> lex1inx; (lex2inx - 4)  -> lex2inx;
      
      ((lex1Inx+2) div 2) -> frag.l.%getShort->l1; (* length of n1 *)
      (* Above line tos_converted from: (frag.l,lex1Inx+2)->TOS'%inxGetShort'->l1; *)

      ((lex2Inx+2) div 2) -> n2frag.l.%getShort->l2; (* length of n2 *)
      (* Above line tos_converted from: (n2frag.l,lex2Inx+2)->TOS'%inxGetShort'->l2; *)

      
      (*'length: ' -> puttext;      l1->putint; ','->put; l2->putint; *)

      (if l1=l2 then
          equal->res;
          elmCompare:
            (for i:((l1+3) %srl 2) repeat
                 (* Above line tos_converted from: (for i:((l1+3)->TOS'%shiftRight[2]') repeat *)
                 ((((4+lex1Inx->lex1Inx)) div 4) -> frag.l.%getLong) %Band (lowerCaseDoesNotMatter)
                 (* Above line tos_converted from: ((frag.l,(4+lex1Inx->lex1Inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' *)
                   ->c1;
                 
                 ((((4+lex2Inx->lex2Inx)) div 4) -> frag.l.%getLong) %Band (lowerCaseDoesNotMatter)
                 (* Above line tos_converted from: ((frag.l,(4+lex2Inx->lex2Inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' *)
                   ->c2;
                 
                 (* c1->putX; c2->putX;*)
                 
                 (if (c1<>c2) then
                     greater->res;
                     (if (c1<c2) then less->res if);
                     leave elmCompare
            if)for)
       else greater->res;
          (if (l1<l2) then less->res if)
      if)

      
   #)
   
---newindexGetText:doPart---
do (# lexemInx,sonInx,base: @integer
   do (1->frag.a[index+1].%getShort) %sll 1->sonInx;
   (* Above line tos_converted from: do frag.a[index+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->sonInx; *)
      (1->frag.a[sonInx+1].%getShort) %sll 1->lexeminx;
      (* Above line tos_converted from: frag.a[sonInx+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->lexeminx; *)
      lexemInx*4->base; 
      &text[]->t[];
      
      (for 
           i:((base-2) div 2) -> (frag.l.%getShort) repeat
           (* Above line tos_converted from: i:((frag.l,base-2)->tos'%inxGetShort') repeat *)
           base+i-1 -> frag.l.%getByte->t.put
           (* Above line tos_converted from: (frag.l,base+i-1)->tos'%inxGetByte'->t.put *)
      for);
   #)
   
   
  
