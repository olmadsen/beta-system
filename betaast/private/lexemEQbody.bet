ORIGIN '../lexemEQ';
---newIndexCMP:doPart---
do (# n2frag: ^fragmentForm;
      n2inx,lex1inx,lex2inx,l1,l2,c1,c2: @integer;
      lowerCaseDoesNotMatter: (#  exit 0xDFDFDFDF #);
      
   do N2.frag[] -> n2frag[]; N2.index -> n2inx;
      
      ((((index*2+1) -> frag.a.%getShort)*4+1) -> frag.a.%getShort)*8
      -> lex1inx;
      
      ((((n2inx*2+1) -> n2frag.a.%getShort)*4+1) -> n2frag.a.%getShort)*8
      -> lex2inx;
      
      (* lex1inx->putint; ','->put;   lex2inx->putint; ','->put; *)
      
      (* OBS!  the index for short index with new primitive syntax
       * is half the length of short index with old primitive syntax
       * This means that ALL short indexes below MUST be divided by
       * two when changing to new primitive syntax
       *)
      
      
      (lex1inx - 4)  -> lex1inx; (lex2inx - 4)  -> lex2inx;
      
      (frag.l,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)

      (n2frag.l,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)

      
      (*'length: ' -> puttext;      l1->putint; ','->put; l2->putint; *)

      (if l1=l2 then
          equal->res;
          elmCompare:
            (for i:((l1+3)->TOS'%shiftRight[2]') repeat

                 ((frag.l,(4+lex1Inx->lex1Inx))
                   ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                   ->TOS'%and'
                   ->c1;
                 
                 ((n2frag.l,(4+lex2inx->lex2inx))
                   ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                   ->TOS'%and'
                   ->c2;
                 
                 (* c1->putX; c2->putX;*)
                 
                 (if (c1<>c2) then
                     greater->res;
                     (if (c1<c2) then less->res if);
                     leave elmCompare
            if)for)
       else greater->res;
          (if (l1<l2) then less->res if)
      if)

      
   #)
   
---newindexGetText:doPart---
do (# lexemInx,sonInx,base: @integer
   do frag.a[index+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->sonInx;
      frag.a[sonInx+1]->TOS'%getShort[1]'->TOS'%ShiftLeft[1]'->lexeminx;
      lexemInx*4->base; 
      &text[]->t[];
      
      (for i: ((frag.l,base-2)->tos'%inxGetShort') repeat
           (frag.l,base+i-1)->tos'%inxGetByte'->t.put
      for);
   #)
   
   
  
