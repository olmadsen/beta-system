ORIGIN '../compact';
LIB_ITEM 'betaastcompact';
INCLUDE '~beta/mps/private/indexPrivate';
INCLUDE '~beta/mps/private/astPrivate';
INCLUDE '~beta/basiclib/binfile';
INCLUDE '../gram';

--- doCompact: descriptor ----
(* 
 *  <ActionPart>:: = <EnterPartOpt> <WithPartOpt> <DoPartOpt> <ExitPartOpt>;
 *  <DoPartOpt>:: ? <DoPart>;
 *  <DoPart>:: = 'do' <Imperatives>;
 *)
(# ff, newFf: ^fragmentForm;
   grm: @grammar;

   DoBetaForm: 
     (# slotFound: @boolean;
        ff,newff: ^fragmentForm;
        com: ^comment;
        theLex,theLexCopy: ^lexemText;
        theValue,theValueCopy: ^const;
        theUnExp,theUnExpCopy: ^unexpanded;
        anExp: ^expanded;
        op: ^slotDesc;
        anAst: ^ast;
        beta: ^treelevel;

        copyLater: 
          (# doit:< object;
             next: ^copyLater;
             init:< 
               (# 
               do INNER;
                  doItLater[]->next[];
                  this(copyLater)[]->doItLater[];
               #);
          #);
        
        copyComment: copyLater
          (# oldAst,newAst: ^ast;

             init::< (# enter (oldAst[],newAst[]) #);

             doit::< 
               (# 
               do oldAst.getComment->com[];
                  newFF[]->com.copy->newAst.addComment;
               #);
          #);

        copyDoPart: copyLater
          (# oldAst,newAst: ^Expanded; (* actually beta.dopart *)

             init::< (# enter (oldAst[],newAst[]) #);

             doit::< 
               (# 
               do 1->oldAst.get->anAst[];
                  (1,newff[]->anAst.copy)->newAst.put 
               #);
          #);

        doItLater: ^copyLater;

        ccp: ^copyComment;
        cdo: ^copyDoPart;
        t: ^text;

        copyCrunch: 
          (# theAst, theCopy: ^ast;
             symbol: @integer;
             handleDoPart: @boolean;
          enter(theAst[],handleDoPart)
          do (if (theAst.symbol->symbol)
              // prodNo.nameDecl
              // prodNo.nameAppl
              // prodNo.string
              // prodNo.comment then
                 theAst[]->theLex[];
                 (symbol,theLex.curLength,newff[])
                   -> beta.newLexemText
                   -> theCopy[]
                   -> theLexCopy[];
                 theLex.getText->theLexCopy.putText
              // prodNo.const then
                 theAst[]->theValue[];
                 (symbol,newff[])
                   -> beta.newAstWithOutSons
                   -> theCopy[]
                   -> theValueCopy[];
                 theValue.getValue->theValueCopy.putValue; 
              // prodNo.optional 
              // prodNo.unExpanded then
                 theAst[]->theUnExp[];
                 (symbol,newff[])
                   -> beta.newAstWithOutSons
                   -> theCopy[]
                   -> theUnExpCopy[];
                 (if theUnExp.isSLOT then
                     theUnExp.theSLOT->op[];
                     newff[]->op.copy->theUnExpCopy.theSLOT ;
                 if);
                 theUnExp.nonterminalSymbol->theUnExpCopy.nonterminalSymbol;
              else
                 (# theExp,theExpCopy: ^expanded; isExternal: @boolean
                 do theAst[]->theExp[];
                    (symbol,newff[])
                      ->beta.newAstWithOutSons
                      ->theCopy[]
                      ->theExpCopy[];
                    (if symbol
                     // grm.nameApl then
                        &copyDoPart[]->cdo[];
                        (theExp[],theExpCopy[])->cdo.init;
                     // grm.doPart then
                        false->slotFound;
                        loop: unexpanded->theExp.suffixWalkForProd
                        (# do true->slotFound; leave loop #);
                        (if (slotFound or not handleDoPart) then
                            (1,(1->theExp.get,true)
                              ->copyCrunch)
                              ->theExpCopy.put
                         else (* do something later *)
                            &copyDoPart[]->cdo[];
                            (theExp[],theExpCopy[])->cdo.init;
                        if);
                     // grm.objectDescriptor then
                        (* determine if we have a specialization of external *)
                        false -> isexternal;
                        (# a: ^ast; exp1: ^expanded; na: ^nameAppl;
                        do theexp.getson1->a[];
                           (if a.kind = kinds.interior then
                               a[]->exp1[]; (* prefix *)
                               exp1.getson1->exp1[]; (* attributeDenotation *)
                               (if exp1.symbol = grm.nameApl then
                                   exp1.getson1 -> na[];
                                   na.getText -> t[];
                                   'external' -> t.equalNCS -> isExternal
                           if)if)
                        #);
                        (if isExternal then
                            theExp.scan
                            (# 
                            do (currentSonNo,(current[],false)->copyCrunch)
                                 -> theExpCopy.put;
                            #);
                         else
                            theExp.scan
                            (# 
                            do (currentSonNo,(current[],true)->copyCrunch)
                                 -> theExpCopy.put;
                            #);
                        if)
                     else
                        theExp.scan
                        (# 
                        do (currentSonNo,(current[],true)
                             ->copyCrunch)
                             ->theExpCopy.put;
                        #);
                    if);
                 #)
             if); 
             (if theAst.hasComment then
                 &copyComment[] -> ccp[];
                 (theAst[],theCopy[]) -> ccp.init;
             if);
          exit theCopy[]
          #);
     enter ff[]
     do ff.grammar[]->beta[]->newFragmentForm->newff[];
        (ff.root[],true)->copyCrunch->newff.root[];
        newff.curtop->newff.modificationStatus;
        loop: (if doitLater[] <> none then
                  doitLater.doit;
                  doitLater.next[]->doitLater[];
                  restart loop
              if);
     exit newff[]
     #)
do fg.fragmentList.scan
   (# 
   do (if current.type = formType  then 
          current.f[]->ff[]->DoBetaForm->current.f[];
          fg[]->current.f.father;
          ff.name->current.f.name;
      if)
   #);
#)

-- compactOpenCatcher: DoPart --
do
   (if no
    // notificationNumbers.startingParsing then
       startingParsing
    // errorNumbers.notExisting then
       msg[]->fragmentNotExisting
    // errorNumbers.arrayTooBig then
       msg[]->astOverflow
    // errorNumbers.grammarNotFound then
       msg[]->grammarNotFound
    // errorNumbers.badFormat then
       msg[]->badFormat
    // errorNumbers.parseErrors then
       msg[]->parseErrors
    // errorNumbers.doubleFormDeclaration then
       msg[]->doubleFormDeclaration
    // errornumbers.noReadAccess then
       msg[]->readAccessError
    // errornumbers.noWriteAccess then
       msg[]->writeAccessError
    // errornumbers.writeAccessOnLstFileError then
       msg[]->writeAccessOnLstFileError
    // errornumbers.EOSError then
       msg[]->EOSError
    // errornumbers.noSuchFile then
       msg[]->noSuchFileError
    // errornumbers.fileExists then
       msg[]->fileExistsError
    // errornumbers.noSpaceLeft then
       msg[]->noSpaceLeftError
    // errornumbers.otherFileError then
       msg[]->otherFileError
    else
       (if no->errorNumbers.fatalParseError then
           (msg[],no-100)->fatalParseError
       if)
   if)  

--- doCompactOpen: descriptor ---
(# oldCatcher: ^handler;
   
   f: @binfile
     (# accessError::< (# do fileError #);
        GB: @GetBytes;
     #);
   getRep: @
     (# adr, longs: @integer;
     enter (adr, longs)
     do (adr,4*longs) -> f.GB;
     #);
   
   b: [2] @integer;

   garbagefl: ^fg.fragmentListDescription;
   garbageProp: ^propertyList;
do (if fg[] = none then 'fg[] is none'-> putline if);
   trace.compactOpen
     ->tracer
   (# 
   do 'group-compactOpen of '->dmp.putText;
      fg.name->dmp.putText;
      ' in '->dmp.putText;
      fg.fullName->dmp.putText          
   #);
   (if theCatcher[] = none then
       theCatcher[] -> oldCatcher[]; 
       compactOpenCatcher[] -> theCatcher[]
   if);
   fg.diskFileName->f.name;
   f.openRead;
   (if use_ref2rep then
       b.range -> f.getLongRep -> b[];
    else
       (@@b[1],b.range)->getRep;
   if);
   (if repS[] = none then 'repS is none' -> putline if);
   (if b[2] > repS.r.range then
       b[2]-repS.r.range -> repS.extend
   if);
   0->repS.top;
   (* get r from f *)
   (if use_ref2rep then
       b[2] -> f.getLongRep -> repS.r[];
    else
       (@@repS.r[1],b[2])->getRep;
   if);

   &fg.fragmentListDescription[]->garbagefl[];
   repS[]->garbagefl.repRestore;
   none->garbagefl[];
   &propertyList[]->garbageProp[];
   repS[]->garbageProp.repRestore;
   none->garbageprop[];

   true -> usemodificationStatus;
   fg.fragmentList.scan
   (# ff: ^fragmentForm
   do (if current.type = formType then
          current.open;
          current.f[] -> ff[];
          repS[] -> ff.repRestoreStruct
   if)#);

   false -> useModificationStatus;

   fg.fragmentList.scan
   (# ff: ^fragmentForm
   do (if current.type = formType then
          current.f []->ff[];
          (if ff.modificationStatus > 10  then
              (if use_ref2rep then
                  ff.modificationStatus -> f.getLongRep -> ff.a[];
               else
                  (@@ff.a[1],ff.modificationStatus)->getRep;
              if);
              (* position the file. 
               * Move ff.curtop-ff.modificationStatus longs forward 
               *)
              ((ff.curtop-ff.modificationStatus)*4,fromCurrent)->f.setPos;
           else
              (if use_ref2rep then
                  ff.curTop -> f.getLongRep -> ff.a[];
               else
                  (@@ff.a[1],ff.curTop)->getRep;
              if);
              (if ff.lcurtop>1 then 
                  (if use_ref2rep then
                      ff.lcurTop -> f.getLongRep -> ff.l[];
                   else
                      (@@ff.l[1],ff.lcurTop)->getRep;
                  if); 
              if);
          if);
          ff.rootInx -> ff.indexToNode -> ff.root[];
   if) #);


   f.close;
   
   (if theCatcher[] = compactOpenCatcher[] then 
       oldCatcher[] -> theCatcher[] 
   if);
   trace.compactOpen
     ->tracer
   (# 
   do (if f[] = none then
          'FAILED: '->dmp.putText
       else
          'SUCCEEDED: '->dmp.putText; 
      if);
      'group-compactOpen of '->dmp.putText;
      fg.name->dmp.putText;
      ' in '->dmp.putText;
      fg.fullName->dmp.putText          
   #)
#)
