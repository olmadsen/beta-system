ORIGIN '../index'; 
INCLUDE '~beta/mps/v5.1/private/astparser';
INCLUDE '~beta/pretty/v5.1/astviewer';
INCLUDE '../semanticerrortext';
-----prettyPrinterBody: descriptor-----
(# xx: @astViewer;
   outputStream: @xx.output
     (# put::< (# do ch->st.put #);
        putText::< (# do s[]->st.putText #);
        putInt::< (# do (n(*,w*))->st.putInt #);
        newLine::< (# do st.newLine #);
        printError::< 
        (# 
        do st.newLine; '***** '->st.putText;
           theAst.semanticError->semanticErrorText->st.putText;
           st.newLine;
        #)
     #);
   initialized: @ boolean; (* OLM 91121 *)
do (if not initialized then
       (* for grammar change, see the comment below;
        * here it is only pretty-printer tables that are defined.
        * Search for "'~beta/grammars/beta"
        *)
       '~beta/grammars/beta/v2.5/beta'->xx.pp.init;
       true->initialized
   if);
       
   (if a[] = none then 'NONE \n'->st.putText
   else
       outputStream[]->xx.out[]; 
       outputStream.init;
       editorMode->xx.pp.editorMode;
       80->xx.pp.width;
       (a[],level)->xx.pp.present;
   if)
#)

---CMP:doPart---
do(*
   (# Puthex:
            (# n: @integer;
            emit: @
              (# v: @integer;
                 put: @
                   (# c: @integer 
                   enter c 
                   do (if c < 10 then '0'+c->screen.put 
                       else 'A'+c-10->screen.put 
                      if)
                   #)
              enter v
              do v div 16 -> put;
                 v mod 16 -> put          
              #)
         enter n
         do '0x'->puttext;
            @@n->TOS'%adrGetByte[0]'->Emit;
            @@n->TOS'%adrGetByte[1]'->Emit;
            @@n->TOS'%adrGetByte[2]'->Emit;
            @@n->TOS'%adrGetByte[3]'->Emit;
            #);
      put: @
       (# v: @integer
        enter v
        do v->TOS'%getByte[0]'->put; ','->put;
           v->TOS'%getByte[1]'->put; ','->put;
           v->TOS'%getByte[2]'->put; ','->put;
           v->TOS'%getByte[3]'->put; ','->put;
        #)
   do 'CMP:'->puttext; lowerCaseDoesNotMatter->putHex; newline;
   *)
   
   (n1frag.a,
   ((n1frag.a,(n1Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex1inx;
   
   (n2frag.a,
   ((n2frag.a,(n2Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex2inx;
   
   (*   lex1inx->putint; ','->put;   lex2inx->putint; ','->put;*)
   
   lex1inx-4->lex1inx; lex2inx-4->lex2inx;
   (n1frag.a,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)
   (n2frag.a,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)

   (*   l1->putint; ','->put; l2->putint;*)

   (if l1=l2 then
       equal->res;
       elmCompare:
         (for i:((l1+3)->TOS'%shiftRight[2]') repeat
              ((n1frag.a,(4+lex1Inx->lex1Inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c1;
              ((n2frag.a,(4+lex2inx->lex2inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c2;
              
              (*              c1->putX; c2->putX;*)
              
              (if (c1<>c2) then
                  greater->res;
                  (if (c1<c2) then less->res if);
                  leave elmCompare
         if)for)
    else greater->res;
       (if (l1<l2) then less->res if)
   if)
