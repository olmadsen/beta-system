ORIGIN '../index'; 
LIB_ITEM 'betaastindex';
INCLUDE '~beta/mps/private/astparser';
INCLUDE '~beta/pretty/astviewer';
INCLUDE '../semanticerrortext';
-----prettyPrinterBody: descriptor-----
(# xx: @astViewer;
   outputStream: @xx.output
     (# errorBuffer: @text;
        mark: @integer;
        
        put::< 
          (# 
          do ch->st.put;
             mark+1 -> mark;
          #);
        putText::< 
          (# 
          do s[]->st.putText;
             mark + s.length -> mark;
          #);
        putInt::< 
          (# t: ^text;
          do &text[] ->t[];
             n -> t.putint;
             mark + t.length -> mark;
             t[]->st.puttext;
          #);
        newLine::< 
          (# 
          do (if errorBuffer.length > 0 then
                 errorBuffer[] -> st.putText;
                 errorBuffer.clear;
              else
                 st.newline;
             if);
             0 -> mark;
          #);
        printError::< 
        (# 
        do errorBuffer.newline;
           (for mark-1 repeat
                ' ' -> errorbuffer.put;
           for);
           '^' -> errorBuffer.put;
           errorBuffer.newLine;
           '***** ' -> errorBuffer.putText;
           theAst.semanticError->semanticErrorText->errorBuffer.putText;
           errorBuffer.newLine;
        #)
     #);
   initialized: @ boolean; (* OLM 91121 *)
do (if not initialized then
       (* for grammar change, see the comment below;
        * here it is only pretty-printer tables that are defined.
        * Search for "'~beta/grammars/beta"
        *)
       '~beta/grammars/beta/beta'->xx.pp.init;
       true->initialized
   if);
       
   (if a[] = none then 'NONE \n'->st.putText
   else
       outputStream[]->xx.out[]; 
       outputStream.init;
       editorMode->xx.pp.editorMode;
       80->xx.pp.width;
       (a[],level)->xx.pp.present;
   if)
#)

---CMP:doPart---
do(*
   (# Puthex:
            (# n: @integer;
            emit: @
              (# v: @integer;
                 put: @
                   (# c: @integer 
                   enter c 
                   do (if c < 10 then '0'+c->screen.put 
                       else 'A'+c-10->screen.put 
                      if)
                   #)
              enter v
              do v div 16 -> put;
                 v mod 16 -> put          
              #)
         enter n
         do '0x'->puttext;
            @@n->TOS'%adrGetByte[0]'->Emit;
            @@n->TOS'%adrGetByte[1]'->Emit;
            @@n->TOS'%adrGetByte[2]'->Emit;
            @@n->TOS'%adrGetByte[3]'->Emit;
            #);
      put: @
       (# v: @integer
        enter v
        do v->TOS'%getByte[0]'->put; ','->put;
           v->TOS'%getByte[1]'->put; ','->put;
           v->TOS'%getByte[2]'->put; ','->put;
           v->TOS'%getByte[3]'->put; ','->put;
        #)
   do 'CMP:'->puttext; lowerCaseDoesNotMatter->putHex; newline;
   *)
   
   (n1frag.a,
   ((n1frag.a,(n1Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex1inx;
   
   (n2frag.a,
   ((n2frag.a,(n2Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex2inx;
   
   (*   lex1inx->putint; ','->put;   lex2inx->putint; ','->put;*)
   
   lex1inx-4->lex1inx; lex2inx-4->lex2inx;
   (if n1frag.lcurtop>1 then
       (n1frag.l,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)
    else
       (n1frag.a,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)
   if);
   (if n2frag.lcurtop>1 then
       (n2frag.l,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)
    else
       (n2frag.a,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)
   if);
   
   (*   l1->putint; ','->put; l2->putint;*)

   (if l1=l2 then
       equal->res;
       elmCompare:
         (for i:((l1+3)->TOS'%shiftRight[2]') repeat
              (if n1frag.lcurtop>1 then
                  ((n1frag.l,(4+lex1Inx->lex1Inx))
                    ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                    ->TOS'%and'
                    ->c1;
               else
                  ((n1frag.a,(4+lex1Inx->lex1Inx))
                    ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                    ->TOS'%and'
                    ->c1;
              if);
              (if n2frag.lcurtop>1 then
                  ((n2frag.l,(4+lex2inx->lex2inx))
                    ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                    ->TOS'%and'
                    ->c2;
               else
                  ((n2frag.a,(4+lex2inx->lex2inx))
                    ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                    ->TOS'%and'
                    ->c2;
              if);
              
              (*              c1->putX; c2->putX;*)
              
              (if (c1<>c2) then
                  greater->res;
                  (if (c1<c2) then less->res if);
                  leave elmCompare
         if)for)
    else greater->res;
       (if (l1<l2) then less->res if)
   if)

-- slotDescTheNode: DoPart --
do findFatherInx->father; frag[]->ff[]
