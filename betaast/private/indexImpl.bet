ORIGIN '../index'; 
LIB_ITEM 'betaastindex';
INCLUDE '~beta/mps/private/astparser';
INCLUDE '~beta/pretty/astviewer';
INCLUDE '../semanticerrortext';
-----prettyPrinterBody: descriptor-----
(# xx: @astViewer;
   outputStream: @xx.output
     (# errorBuffer: @text;
        mark: @integer;
        
        put::< 
          (# 
          do ch->st.put;
             mark+1 -> mark;
          #);
        putText::< 
          (# 
          do s[]->st.putText;
             mark + s.length -> mark;
          #);
        putInt::< 
          (# t: ^text;
          do &text[] ->t[];
             n -> t.putint;
             mark + t.length -> mark;
             t[]->st.puttext;
          #);
        newLine::< 
          (# 
          do (if errorBuffer.length > 0 then
                 errorBuffer[] -> st.putText;
                 errorBuffer.clear;
              else
                 st.newline;
             if);
             0 -> mark;
          #);
        printError::< 
          (# 
          do errorBuffer.newline;
             (for mark-1 repeat
                  ' ' -> errorbuffer.put;
             for);
             '^' -> errorBuffer.put;
             errorBuffer.newLine;
             '***** ' -> errorBuffer.putText;
             theAst.semanticError->semanticErrorText->errorBuffer.putText;
             errorBuffer.newLine;
          #)
     #);
   initialized: @ boolean; (* OLM 91121 *)
do (if not initialized then
       (* for grammar change, see the comment below;
        * here it is only pretty-printer tables that are defined.
        * Search for "'~beta/grammars/beta"
        *)
       '~beta/grammars/beta/beta'->xx.pp.init;
       true->initialized
   if);
   
   (if a[] = none then 'NONE \n'->st.putText
    else
       outputStream[]->xx.out[]; 
       outputStream.init;
       editorMode->xx.pp.editorMode;
       80->xx.pp.width;
       (a[],level)->xx.pp.present;
   if)
#)

---ASTindex_father:doPart---
do (* expansion of
    index->i;
    loop: (if true
    // (i=0) then
    // (i->frag.isLastBrother) then
    i->frag.nextBrother->i
    else i->frag.nextBrother->i; restart loop
    if);
    *)
   index->i;
   loop:
     (if true
      // (i = 0) then

      // (((2,1)->frag.a[i].%getBits)->b) then
         (* Above line tos_converted from: 
          * // (frag.a[i]->tos'%GetBits[2,1]'->b) then *)
         (0->frag.a[i+1].%getShort) %sll 1->i
         (* Above line tos_converted from: 
          * frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i *)
      else
         (0->frag.a[i+1].%getShort) %sll 1->i;
         (* Above line tos_converted from: 
          * frag.a[i+1]->tos'%GetShort[0]'->tos'%shiftLeft[1]'->i; *)
         restart loop
     if)
   
---CMP:doPart---
do
   (if false then
       (# Puthex:
            (# n: @integer;
               emit: @
                 (# v: @integer;
                    put: @
                      (# c: @integer 
                      enter c 
                      do (if c < 10 then '0'+c->screen.put 
                          else 'A'+c-10->screen.put 
                         if)
                      #)
                 enter v
                 do v div 16 -> put;
                    v mod 16 -> put          
                 #)
            enter n
            do '0x'->puttext;
               (0->n.%getByte)->Emit;
               (* Above line tos_converted from: @@n->TOS'%adrGetByte[0]'->Emit; *)
               (1->n.%getByte)->Emit;
               (* Above line tos_converted from: @@n->TOS'%adrGetByte[1]'->Emit; *)
               (2->n.%getByte)->Emit;
               (* Above line tos_converted from: @@n->TOS'%adrGetByte[2]'->Emit; *)
               (3->n.%getByte)->Emit;
               (* Above line tos_converted from: @@n->TOS'%adrGetByte[3]'->Emit; *)
            #);
          put: @
            (# v: @integer
            enter v
            do (0->v.%getByte)->put; ','->put;
               (* Above line tos_converted from: do v->TOS'%getByte[0]'->put; ','->put; *)
               (1->v.%getByte)->put; ','->put;
               (* Above line tos_converted from: v->TOS'%getByte[1]'->put; ','->put; *)
               (2->v.%getByte)->put; ','->put;
               (* Above line tos_converted from: v->TOS'%getByte[2]'->put; ','->put; *)
               (3->v.%getByte)->put; ','->put;
               (* Above line tos_converted from: v->TOS'%getByte[3]'->put; ','->put; *)
            #)
       do 'CMP:'->puttext; lowerCaseDoesNotMatter->putHex; newline;
       #);
   if);
   
   ((((((((n1Inx %sll 2)+2) div 2) -> n1frag.a.%getShort) %sll 3)+2) div 2) -> n1frag.a.%getShort) %sll 3->lex1inx;
   (* Above line tos_converted from: (n1frag.a,(  (n1frag.a,(n1Inx->TOS'%shiftLeft[2]')+2)->TOS'%inxGetShort' ->TOS'%shiftLeft[3]')+2)->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex1inx; *)
    
   ((((((((n2Inx %sll 2)+2) div 2) -> n2frag.a.%getShort) %sll 3)+2) div 2) -> n2frag.a.%getShort) %sll 3->lex2inx;
   (* Above line tos_converted from: (n2frag.a,(  (n2frag.a,(n2Inx->TOS'%shiftLeft[2]')+2)->TOS'%inxGetShort' ->TOS'%shiftLeft[3]')+2)->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex2inx; *)
   
   (*  lex1inx->putint; ','->put;   lex2inx->putint; ','->put;*)
   
   lex1inx-4->lex1inx; lex2inx-4->lex2inx;
   (if n1frag.lcurtop>1 then
       ((lex1Inx+2) div 2) -> n1frag.l.%getShort->l1; (* length of n1 *)
       (* Above line tos_converted from: (n1frag.l,lex1Inx+2)->TOS'%inxGetShort'->l1; *)
    else
       ((lex1Inx+2) div 2) -> n1frag.a.%getShort->l1; (* length of n1 *)
       (* Above line tos_converted from: (n1frag.a,lex1Inx+2)->TOS'%inxGetShort'->l1; *)
   if);
   (if n2frag.lcurtop>1 then
       ((lex2Inx+2) div 2) -> n2frag.l.%getShort->l2; (* length of n2 *)
       (* Above line tos_converted from: (n2frag.l,lex2Inx+2)->TOS'%inxGetShort'->l2; *)
    else
       ((lex2Inx+2) div 2) -> n2frag.a.%getShort->l2; (* length of n2 *)
       (* Above line tos_converted from: (n2frag.a,lex2Inx+2)->TOS'%inxGetShort'->l2; *)
   if);
   
   (* l1->putint; ','->put; l2->putint;*)

   (if l1=l2 then
       equal->res;
       elmCompare:
         (for i:((l1+3) %srl 2) repeat
              (* Above line tos_converted from: (for i:((l1+3)->TOS'%shiftRight[2]') repeat *)
              (if n1frag.lcurtop>1 then
                  (((4+lex1Inx->lex1Inx) div 4) -> (n1frag.l.%getLong)) %Band (lowerCaseDoesNotMatter) ->c1;
                  (* Above line tos_converted from: ((n1frag.l,(4+lex1Inx->lex1Inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' ->c1; *)
               else
                  (((4+lex1Inx->lex1Inx) div 4) -> (n1frag.a.%getLong)) %Band (lowerCaseDoesNotMatter) ->c1;
                  (* Above line tos_converted from: ((n1frag.a,(4+lex1Inx->lex1Inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' ->c1; *)
              if);
              (if n2frag.lcurtop>1 then
                  (((4+lex2inx->lex2inx) div 4) -> (n2frag.l.%getLong)) %Band (lowerCaseDoesNotMatter) ->c2;
                  (* Above line tos_converted from: ((n2frag.l,(4+lex2inx->lex2inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' ->c2; *)
               else
                  (((4+lex2inx->lex2inx) div 4) -> (n2frag.a.%getLong)) %Band (lowerCaseDoesNotMatter) ->c2;
                  (* Above line tos_converted from: ((n2frag.a,(4+lex2inx->lex2inx))->TOS'%inxGetLong',lowerCaseDoesNotMatter) ->TOS'%and' ->c2; *)
              if);
              
              (* c1->putX; c2->putX;*)
              
              (if (c1<>c2) then
                  greater->res;
                  (if (c1<c2) then less->res if);
                  leave elmCompare
         if)for)
    else greater->res;
       (if (l1<l2) then less->res if)
   if)

-- slotDescTheNode: DoPart --
do findFatherInx->father; frag[]->ff[]
