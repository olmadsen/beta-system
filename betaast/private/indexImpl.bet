ORIGIN '../index';
INCLUDE '~beta/mps/v5.1/applgram';
INCLUDE '~beta/mps/v5.1/private/astparser';
INCLUDE '~beta/pretty/v5.1/astviewer';
INCLUDE '../semanticerrortext';
-----prettyPrinterBody: descriptor-----
(# xx: @astViewer;
   outputStream: @xx.output
     (# put::< (# do ch->st.put #);
        putText::< (# do s[]->st.putText #);
        putInt::< (# do (n(*,w*))->st.putInt #);
        newLine::< (# do st.newLine #);
        printError::< 
        (# 
        do st.newLine; '***** '->st.putText;
           theAst.semanticError->semanticErrorText->st.putText;
           st.newLine;
        #)
     #);
   initialized: @ boolean; (* OLM 91121 *)
do (if not initialized then
       (* for grammar change, see the comment below;
        * here it is only pretty-printer tables that are defined.
        * Search for "'~beta/grammars/beta"
        *)
       '~beta/grammars/beta/v2.5/beta'->xx.pp.init;
       true->initialized
   if);
       
   (if a[] = none then 'NONE \n'->st.putText
   else
       outputStream[]->xx.out[]; 
       outputStream.init;
       editorMode->xx.pp.editorMode;
       80->xx.pp.width;
       (a[],level)->xx.pp.present;
   if)
#)
----- IndexInitBody: descriptor -----
  (# mg:@ metagrammar;
     t: ^Text;
     beta: @applgram
       (# suffix::< (# do '.bet'->theSuffix #);
          version::< (# do (*6->value*) #);
          maxProductions::< (# do 113->value #);
       #);

     bg,bgm: ^fragmentGroup;
     betaParseTable: ^text;     (*betaParseTable: @text;*)

     fileMissing:
       (# prefix,suffix: ^text(*@text*)
       enter (prefix[],suffix[])
       do screen.newLine;
          'Error. Missing file: "'->screen.putText;
          prefix[]->screen.putText;
          suffix[]->screen.putText;
          '"'->screen.put;
          screen.newLine; 
          (Failure,'')->&stop
       #);

     checkFileExistence:
     (# f: @file
     enter f.name
     do (if f.entry.exists//false then (f.name,'')->fileMissing if)
     #);

  do
    (if noAstInit then &astLevelInit if);
    &mg.init;
    mg[]->grammarTable.meta[]->beta.meta[];
     (if (''->locationOfBetaGrammar.equal) then
         (* To make a grammar change, the path below MUST
          * be changed, but also the path used above for initializing
          * the pretty-printer tables must also be changed.
          * In addion consider the declaration of the grammar
          * variable 'beta'. Here the there is a virtual 
          * 'version'. The role of the virtual is currently 
          * NOT understood!
          *)
        '~beta/grammars/beta/v2.5/beta'->locationOfBetaGrammar
    if);

    (locationOfBetaGrammar[],screen[])->&top.open->bg[];
    (if bg[]//none then
      (locationOfbetagrammar[],astFileExtension)->fileMissing;
    if);
    ('meta',screen[])->&bg.open->bg[];
    (if bg[]//none then
        ('-meta'-> (locationOfbetagrammar.Copy).Append,astFileExtension)
          ->fileMissing;
    if);

     ('beta',screen[])->&bg.open->beta.grammarAst[];
     trace.grammars -> tracer
     (#
     do 'betaast:index: Beta grammar: '-> dmp.putText; 
        locationOfBetaGrammar[] -> dmp.putline;
        '          Grammar version: ' -> dmp.puttext; 
        beta.version -> dmp.putint; 
     #);
    (if beta.grammarAst[]//none then
        ('meta-'->(locationOfbetagrammar.Copy).Append,astFileExtension)
          ->fileMissing;
    if);
    (*beta[] ->*) &beta.init;
    '-parser'->t[]; parserFileExtension->t.append
	->(locationOfBetaGrammar.Copy).Append
	->expandToFullPath->betaParseTable[];
    betaParseTable[]->&checkFileExistence;
    betaParseTable[]-> &beta.parser.initialize;
    ('objectdescriptor','descriptor')->&beta.parser.privatePart.b.defineNonTAlias;
    ('attributedecl','attributes')->&beta.parser.privatePart.b.defineNonTAlias;
    beta[]->grammartable.beta[]
  #)
---CMP:doPart---
do(*
   (# Puthex:
            (# n: @integer;
            emit: @
              (# v: @integer;
                 put: @
                   (# c: @integer 
                   enter c 
                   do (if c < 10 then '0'+c->screen.put 
                       else 'A'+c-10->screen.put 
                      if)
                   #)
              enter v
              do v div 16 -> put;
                 v mod 16 -> put          
              #)
         enter n
         do '0x'->puttext;
            @@n->TOS'%adrGetByte[0]'->Emit;
            @@n->TOS'%adrGetByte[1]'->Emit;
            @@n->TOS'%adrGetByte[2]'->Emit;
            @@n->TOS'%adrGetByte[3]'->Emit;
            #);
      put: @
       (# v: @integer
        enter v
        do v->TOS'%getByte[0]'->put; ','->put;
           v->TOS'%getByte[1]'->put; ','->put;
           v->TOS'%getByte[2]'->put; ','->put;
           v->TOS'%getByte[3]'->put; ','->put;
        #)
   do 'CMP:'->puttext; lowerCaseDoesNotMatter->putHex; newline;
   *)
   
   (n1frag.a,
   ((n1frag.a,(n1Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex1inx;
   
   (n2frag.a,
   ((n2frag.a,(n2Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex2inx;
   
   (*   lex1inx->putint; ','->put;   lex2inx->putint; ','->put;*)
   
   lex1inx-4->lex1inx; lex2inx-4->lex2inx;
   (n1frag.a,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)
   (n2frag.a,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)

   (*   l1->putint; ','->put; l2->putint;*)

   (if l1=l2 then
       equal->res;
       elmCompare:
         (for i:((l1+3)->TOS'%shiftRight[2]') repeat
              ((n1frag.a,(4+lex1Inx->lex1Inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c1;
              ((n2frag.a,(4+lex2inx->lex2inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c2;
              
              (*              c1->putX; c2->putX;*)
              
              (if (c1<>c2) then
                  greater->res;
                  (if (c1<c2) then less->res if);
                  leave elmCompare
         if)for)
    else greater->res;
       (if (l1<l2) then less->res if)
   if)
