ORIGIN '../index';
INCLUDE '~beta/mps/v4.9.1/applgram';
INCLUDE '~beta/mps/v4.9.1/private/astparser';
INCLUDE '~beta/pretty/v4.9.1/astviewer';
INCLUDE '../semanticerrortext';
-----prettyPrinterBody: descriptor-----
(# xx: @astViewer;
   outputStream: @xx.output
     (# put::< (# do ch->st.put #);
        putText::< (# do s[]->st.putText #);
        putInt::< (# do (n(*,w*))->st.putInt #);
        newLine::< (# do st.newLine #);
        printError::< 
        (# 
        do st.newLine; '***** '->st.putText;
           theAst.semanticError->semanticErrorText->st.putText;
           st.newLine;
        #)
     #);
   initialized: @ boolean; (* OLM 91121 *)
do (if not initialized then
       '~beta/grammars/beta/v2.4/beta'->xx.pp.init;
       true->initialized
   if);
       
   (if a[] //none then 'NONE '->st.putText; st.newLine;
   else
       outputStream[]->xx.out[]; 
       outputStream.init;
       editorMode->xx.pp.editorMode;
       80->xx.pp.width;
       (a[],level)->xx.pp.present;
   if)
#)
----- IndexInitBody: descriptor -----
  (# mg:@ metagrammar;
     t: ^Text;
     beta: @applgram
       (# suffix::< (# do '.bet'->theSuffix #);
          version::< (# do 6->value #);
          maxProductions::< (# do 113->value #);
       #);

     bg,bgm: ^fragmentGroup;
     betaParseTable: ^text;     (*betaParseTable: @text;*)

     fileMissing:
       (# prefix,suffix: ^text(*@text*)
       enter (prefix[],suffix[])
       do screen.newLine;
          'Error. Missing file: "'->screen.putText;
          prefix[]->screen.putText;
          suffix[]->screen.putText;
          '"'->screen.put;
          screen.newLine; 
          (Failure,'')->&stop
       #);

     checkFileExistence:
     (# f: @file
     enter f.name
     do (if f.entry.exists//false then (f.name,'')->fileMissing if)
     #);

  do
    (if noAstInit then &astLevelInit if);
    &mg.init;
    mg[]->grammarTable.meta[]->beta.meta[];
    (if (''->locationOfBetaGrammar.equal) then
     '~beta/grammars/beta/v2.4/beta'->locationOfBetaGrammar
    if);
    (locationOfBetaGrammar[],screen[])->&top.open->bg[];
    (if bg[]//none then
      (locationOfbetagrammar[],astFileExtension)->fileMissing;
    if);
    ('meta',screen[])->&bg.open->bg[];
    (if bg[]//none then
        ('-meta'->locationOfbetagrammar.CopyAppend,astFileExtension)
          ->fileMissing;
    if);

    ('beta',screen[])->&bg.open->beta.grammarAst[];
    (if beta.grammarAst[]//none then
        ('meta-'->locationOfbetagrammar.CopyAppend,astFileExtension)
          ->fileMissing;
    if);
    (*beta[] ->*) &beta.init;
    '-parser'->t[]; parserFileExtension->t.append
	->locationOfBetaGrammar.CopyAppend
	->expandToFullPath->betaParseTable[];
    betaParseTable[]->&checkFileExistence;
    betaParseTable[]-> &beta.parser.initialize;
    ('objectdescriptor','descriptor')->&beta.parser.privatePart.b.defineNonTAlias;
    ('attributedecl','attributes')->&beta.parser.privatePart.b.defineNonTAlias;
    beta[]->grammartable.beta[]
  #)
---CMP:doPart---
do(*
   (# putX: @
        (# v: @integer
        enter v
        do v->TOS'%getByte[0]'->put; ','->put;
           v->TOS'%getByte[1]'->put; ','->put;
           v->TOS'%getByte[2]'->put; ','->put;
           v->TOS'%getByte[3]'->put; ','->put;
        #)
   do 'CMP:'->puttext;
   *)
   
   (n1frag.a,
   ((n1frag.a,(n1Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex1inx;
   
   (n2frag.a,
   ((n2frag.a,(n2Inx->TOS'%shiftLeft[2]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]')+2)
     ->TOS'%inxGetShort'->TOS'%shiftLeft[3]'->lex2inx;
   
   (*   lex1inx->putint; ','->put;   lex2inx->putint; ','->put;*)
   
   lex1inx-4->lex1inx; lex2inx-4->lex2inx;
   (n1frag.a,lex1Inx+2)->TOS'%inxGetShort'->l1; (* length of n1 *)
   (n2frag.a,lex2Inx+2)->TOS'%inxGetShort'->l2; (* length of n2 *)

   (*   l1->putint; ','->put; l2->putint;*)

   (if l1=l2 then
       equal->res;
       elmCompare:
         (for i:((l1+3)->TOS'%shiftRight[2]') repeat
              ((n1frag.a,(4+lex1Inx->lex1Inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c1;
              ((n2frag.a,(4+lex2inx->lex2inx))
                ->TOS'%inxGetLong',lowerCaseDoesNotMatter)
                ->TOS'%and'
                ->c2;
              
              (*              c1->putX; c2->putX;*)
              
              (if (c1<>c2) then
                  greater->res;
                  (if (c1<c2) then less->res if);
                  leave elmCompare
         if)for)
    else greater->res;
       (if (l1<l2) then less->res if)
   if)
