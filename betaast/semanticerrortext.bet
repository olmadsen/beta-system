ORIGIN '~beta/mps/private/astPrivate';
LIB_DEF 'betaastsemanticerr' '../lib';
-----astinterfacelib : attributes ----
lastStaticMsg: (# exit 133 #);
lastMsgNo: (# exit lastStaticMsg + private.errMsg.top
              (*private.errMsg.lastMsgNo *)
           #);
clearErrorMsgList: (# do private.errMsg.clear #);
addErrorMsg:
  (# m: ^text; no: @integer
  enter m[]
  do m[] -> private.errMsg.addErrorMsg -> no
  exit lastStaticMsg + no
  #);
addWarningMsg:
  (# m: ^text; no: @integer
  enter m[]
  do m[] -> private.errMsg.addWarning -> no
  exit lastStaticMsg + no
  #);
isWarning:
  (# no: @integer; boo: @boolean
  enter no
  do (if no 
      // 24 // 86 // 95  // 97 // 99 // 106 // 109  
      // 25 // 26 (*not used *)// 125 // 126 // 133 then
         true -> boo
      else
         no - lastStaticMsg
           -> this(astInterface).private.errMsg.isWarning 
           -> boo
     if)
  exit boo
  #);
semanticErrorText :
  (# noMsg:<
       (# skip: @boolean
       do INNER;
          (if not skip then
              'There is a semantic error here, but no error message!' ->T[] ;
              '\nThis is a compiler error! Sorry!'->T.append;
              '\nUnknown error messsage: '->screen.puttext; 
              no->screen.putInt; screen.newline;
           else
              '' ->T[] 
          if)
       #);
     no : @integer;
   T : ^text
enter no
do (if no
    // 1 then 'Name is declared more than once'->T[]
    // 2 then 'Name is not declared'->T[]       
    // 3 then 'Attribute is not declared'->T[]
    // 4 then 'A pattern is expected here'->T[]
    // 5 then 'An item is expected here'->T[]
    // 6 then 'A repetition is expected here '->T[]
    // 7 then 'A simple evaluation cannot be assigned'->T[]
    // 8 // 9  then 'The lists have different lengths'->T[]
    // 10 then 
       'In "leave P" or " restart P", "P" must be an enclosing label'->T[];
       '\n\tor enclosing pattern'->T.puttext
    // 11 then 
       'Illegal assignment/comparison of value, reference or repetition'->T[]
    // 12 then 'Only a single name is alloved here'->T[]
    // 13 then 'Attempt to bind V which is not virtual ( V ::< T)'->T[]
    // 14 then 'In V ::< T, T does not have a correct qualification'->T[]
    // 15 then 'An object is expected here'->T[]
    // 16 then 'A basic pattern cannot be used as a super-pattern'->T[]
    // 17 then 
       'A virtual pattern or a pattern defined as a descriptor slot cannot'->T[];
       '\n\tbe used as super-pattern'->T.append
    // 18 then 'A string of length 1 is a char - NOT a text'->T[]
    // 19 then 
       'Illegal recursion in the definition of a pattern.\n'->T[];
       '\tOne of the following type of errors have occured:\n'->T.append;
       '\t(1) There may be a circle in the super-pattern chain:\n'->T.append;
       '\t\tA: C(# ... #); B: A(# ... #); C: B(# ... #)\n\n'->T.append;
       '\t(2) The pattern may direct or indirectly contain a static instance'->T.append;
       '\n\tof itself:\n'->T.append;
       '\t\tP: (# ...; X: @P; ... do ... #)\n\n'->T.append;
       '\t(3) The pattern may directly or indirectly contain an inserted'->T.append;
       '\n\tinstance of itself:\n'->T.append;
       '\t\tP: (# ... do ...; P(# ... #); ... #)\tor\n'->T.append;
       '\t\tA: (# ... P: (# R: ^A; ... do ...; R.P(# ... #); ... #) ... #)\n'->T.append;
    // 20 then 'Incompatible qualifications in assignment/comparison'->T[]
    // 21 then 'Only simple values or references may be compared'->T[]
    // 22 then 'Only simple values may appear in unary expressions'->T[]
    // 23 then 'Fatal error: virtual binding not found'->T[]
    // 24 then 'A run-time qualification check will be generated here'->T[]
    // 25 then 'Repetition of static components is not implemented'->T[]
    // 26 then 'Repetition of non simple patterns is not implemented'->T[]
    // 27 then 'The descriptor is both used as item and component'->T[]
    // 28 then 'Static size of descriptor is larger than 32760 bytes'->T[]
    // 29 then 'Illegal recursion in object-description'->T[]
    // 30 then 'Illegal assignment to constant value/reference or repetition'->T[]
    // 31 then 'Only pattern-declarations may appear in a fragment of category \'attributes\''->T[]
    // 32 then 'A virtual qualification must be a pattern name or a descriptor'->T[]
    // 33 then 'A virtual pattern or descriptor-slot cannot be used as a component'->T[]
    // 34 then  
       'An enter/exit parameter of an "external" must be one of:\n\t'->T[];
       'integer,char,real,integer-repetitions,char-repetition,\n\t'->T.append;
       'subpattern of cstruct,variable-subpattern of external'->T.append;
    // 35 then 'An "external" can only have one exit parameter'->T
    // 36 then 'A sub-pattern of "external" cannot be used as super-pattern'->T[]
    // 37 then 'The DO-part of an "external" should be empty'->T[]
    // 38 then 
       'A repetition/for-imp range must be an integer, or char evaluation'->T[]
    // 39 then 'A simple pattern cannot be used here'->T[]
    // 40 then 'Unkown inline primitive'->T[]
    // 41 then 'The superpattern of this descriptor has no INNER'->T[]
    // 42 then
      'Attempt to bind a virtual in a descriptor with no superpattern'->T[]
    // 43 then 'The qualification of a variable pattern must be a pattern'->T[]
    // 44 then
        'A pattern-, virtual-, variable-pattern, or reference is expected here'->T[]
    // 45 then 'A repetition name is expected here'->T[]
    // 46 then 
       'In "this(P)" or "inner P", P must be the name of an enclosing pattern'->T[]
    // 47 then 'An unexpanded nonterminal must be a SLOT'->T[]
    // 48 then 
       'A super-pattern must be a simple pattern or a simple'->T[];
       '\n\tpattern attribute of a static object'->T.append
    // 49 then 
       'A simple pattern or virtual pattern cannot be assigned'->T[];
       '\n\ta structure reference'->T.append
    // 50 then 'A structure reference can only be assigned to/compared'->T[];
       '\n\twith another structure reference'->T.append
    // 51 then 
       'Only integer,char,boolean, real objects and references can be'->T[];
       '\n\tcompared in an if-imperative'->T.append
    // 52 then 'Rename declaration has NOT been implemented'->T[]
    // 53 then 'Syntax error in number'->T[]
    // 54 then 
        'Name not declared. There is no corresponding virtual declaration'->T[]
    // 55 then 
       'A pattern with a do-part slot cannot be used as a super-pattern'->T[]
    // 56 then 'The QUA construct has not been implemented'->T[]
    // 57 then 
       'A basic pattern like integer, real, char, boolean, false, and true'->T[];
       '\n\tcannot be used as a super-pattern'->T.append
    // 58 then
       'In a list being assigned to and being assigned from as in'->T[];
       '\n\t...->(E1,E2,...En)-> ...\n\tthe elements may not be patterns'->T.append
    // 59 then
       'The enter-parameters of an external call must be supplied'->T[]
    // 60 then
       'The left-side of the assignment/comparison has no (exit-)list'->T[];
       '\n\tor the right-side has no (enter-)list'->T.append
    // 61 then
       'An element of the left-side/right-side of the assignment/comparison'->T[];
       '\n\thas no (exit-)list or (enter-)list'->T.append
    // 62 then
       'The Left-side of the assignment/comparison has no (exit-)list'->T[]
    // 63 then
       'An element of the left-side of the assignment/comparison has no (exit-)list'->T[]
    // 64 then
       'The right-side of the assignment/comparison has no (enter-)list'->T[]
    // 65 then
       'An element of the right-side of the assignment/comparison has no (enter-)list'->T[]
    // 66 then
       'A simple value (integer,boolean,char,real) cannot be assigned/compared'->T[];
       '\n\tto/with a list'->T.append
       
    //67 then
       'An object with no exit-list is being assigned/compared to a reference.'->T[];
       '\n\tThe left-side may be missing a "[]" or the right-side may have a superflous "[]"'->T.append
       
    //68 then
       'An element with no exit-list in the left-side list is being'->T[];
       '\n\tassigned/compared to a reference on the right-side'->T.append;
       '\n\tThe left-side may be missing a "[]" or the right-side may have a superflous "[]"'->T.append
    //69 then 
       'A reference is being assigned/compared to an object with no enter-list'->T[];
       '\n\tThe right-side may be missing a "[]" or the left-side may have a superflous "[]"'->T.append       
    //70 then
       'A reference is being assigned/compared to an element on the right-side with no enter-list'->T[];
       '\n\tThe right-side may be missing a "[]" or the left-side may have a superflous "[]"'->T.append
    // 80 then
       '"inner P" is only legal in the do-part of the pattern "P"'->T[];
    // 81 then
       'In a computed-remote, "(EV).X","EV" cannot be an evaluation-list'->T[]
    // 82 then
       'In a computed-remote, "(EV).X", "EV" must have one exit-element,'->T;
       '\n\twhich must be a reference'->T.append
    // 83 then
       'In a computed-remote, "(EV).X", "EV" is not a legal evaluation'->T[]
    // 84 then
       '"Extend" and "new" must have an enter-parameter'->T[]
    // 85 then 
       '"leave P" or "restart P", where "P" is a pattern,'->T[];
       '\n\tis only legal in the do-part of "P"'->T.append
    // 86 then
       '"leave P" and "restart P", where "P" is a pattern,'->T[];
       '\n\tare currently not allowed in internal descriptors of "P"'->T.append
    // 87 then
       'A repetition index must be an integer-evaluation'->T[] 
    // 88 then
       'The base of this number is too large'->T[]    
    // 89 then
       'A subpattern of "data" may only have declarations of the forms:'->T[];
       '\n\t"X: ^T" where "T" is subpattern of "data", or'->T.append;
       '\n\t"X: @T" '->T.append;
       'where "T" is integer,shortint,char,boolean,real'->T.append;
       '\n\t\tor subpattern of "data"'->T.append; 
    // 90 then
       'A subpattern of "data" may not have a do-part'->T[]
    // 91 then
       'A boolean evaluation is expected here'->T[]
    // 92 then 'Primitive operation appears in wrong context'->T[]
    // 93 then 
       'It is not possible to obtain a structure reference for a basic pattern'->T[];
       '\n\tlike integer, real, char, boolean, false, and true or instances of these'->T.append
    // 94 then
       'A virtual pattern cannot be bound to a basic pattern like'->T[];
       '\n\tinteger, real, char, boolean, false, and true'->T.append
    // 95 then
       '\tIn  "X: ^R.P", "Y: @R.P", or "Z: @R.P(#...#),'->T[];
       '\n\t"R" should NOT be a dynamic reference!'->T.append;
       '\n\tFor "X: ^R.P", consider using "X: ^T.P",'->T.append;
       '\n\twhere "T" is the pattern qualifying "R" ("R: ^T").'->T.append;
       '\n\tA future release may consider this to be a semantic error.'->T.append;
    // 96 then
       'In  "X: ^<AD>.P", "Y: @<AD>.P", "<AD>" cannot be:'->T[];
       '\n\t\ta repetition element as in "R[e].P"'->T.append;
       '\n\t\ta computed remote as in"(R).P"'->T.append;
       '\n\tIt must be a static object'->T.append
    // 97 then
       'An "inner" in a singular object will never be executed'->T[]
    // 98 then 'A sub-pattern of "external" must be defined as a pattern'->T[]
    // 99 then 
       'Final binding to a virtual pattern is a new facility\n\tin this version of the compiler.'->T[];
       '\n\tPlease report any problems to support@mjolner.dk'->T.append;
    // 100 then 'In "V ::< T", "T" must be a non-virtual pattern'->T[]
    // 101 then 'In "V :: T", "T" must be a pattern'->T[]
    // 102 then 
       'A cycle has been detected in the super-chain of the virtual/final binding'->T[]
    // 103 then 'Incompatible types of binary operator'->T[]
    // 104 then 'Incompatible left- and right-side of assignment'->T[]
    // 105 then 'Illegal assignment to constant, literal or expression'->T[]
    // 106 then 'Assignment/comparison between boolean and integer'->T[]
    // 107 then 'A virtual cannot be bound to a slot'->T[]
    // 108 then 'Illegal use of the "&"-operator'->T[]
    // 109 then 'Text has a null-char. All chars after the null-char are ignored'->T[]
    // 110 then 
       'Illegal recursion in exit list: \n\t'->T[];
         'a pattern is referred direcly or indirectly in its own exit list'
	   ->T.puttext;
    // 111 then 'Illegal recursion in enter list: \n\t'->T[];
         'a pattern is referred direcly or indirectly in its own enter list'
	   ->T.puttext;
    // 112 then 
       'External entry point has a blank- or control chararacter'->T[]
    // 113 then 'There is a circle in the super-pattern chain'->T[]
    // 114 then 'Illegal operator "!"' ->T[] 
    // 115 then 
       'Use of "@@" in combination with object executions in external calls is insecure'
	->T[]
    // 116 then 
       'A DATA object can only be a part-object of a COM object or a DATA object'->T[]
    // 117 then
       'A COM virtual pattern cannot be a part object' ->T[]
    // 118 then
       '"Object" may NOT be used to specify a virtual in a COM pattern'->T[]
    // 119 then
       'A virtual COM pattern is used somewhere else as a non-virtual pattern-' ->T[]
    // 120 then
       'A DATA object can only be used as a part object in a COM- or DATA-object'->T[]
    // 121 then
       'Illegal recursion in computed remote like in:\n\t' ->T[] ;
       '    (&P).x\n\t' -> T.append;
       'where\n\t'-> T.append;
       '     P: (# ... exit P #)\n\t' -> T.append;
       'instead of\n\t' -> T.append;
       '     P: (# ... exit P[] #)' -> T.append
    // 122 then
       'It is not possible to obtain a reference to a basic pattern like integer, real, boolean and char' -> T[]
    // 123 then 'Underflow in number' -> T[]
    // 124 then 'Overflow in number' ->T[]
    // 125 then 'Enter/exit-parts are NOT implemented for mainPart forms'->T[]
    // 126 then 
       'Int64 numbers are NOT implemented as arguments/return values for external routines' ->T[]
    // 127 then
       'In a repetition assignment "R1 -> R2" the elements of "R1" and "R2" must have the same size' ->T[]
    // 128 then
       'In a repetition assignment "R1 -> R2", "R1" is a static item ("@"), but "R2" is not' ->T[]
    // 129 then
       'In a repetition assignment "R1 -> R2", "R1" is a basic pattern, but "R2" is not' ->T[]
    // 130 then
       'In a repetition assignment "R1 -> R2", "R2" is a basic pattern, but "R1" is not' ->T[]
    // 131 then
       'In a repetition assignment "R1 -> R2", "R1" is a dynamic item ("^"), but "R2" is not' ->T[]
    // 132 then
       'Repetition assignment is not implemented for variable patterns'->T[]
    // 133 then
       'Semantic checking of general repetition assignment is incomplete' -> T[]

    else 
       (if (no - lastStaticMsg
             ->this(astInterface).private.errMsg.getMsg 
             -> T[]) 
           = NONE then
           NoMsg
       if)
   if);
exit T[]
#)
