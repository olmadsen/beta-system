ORIGIN '../betadbc';
INCLUDE '../transactions'
        '~beta/basiclib/formatio';
-- program: Descriptor --
(#
   sqlCon: @connection;
   stmt: @sqlCon.directSqlStatement;
   studioName: @text;
   commit: ^text
do
   (2->arguments,3->arguments,4->arguments)->sqlCon.open;
   'CREATE TABLE navne (navn VARCHAR(55))'->stmt;
   stmt.execute;
   'studioName'
     ->sqlCon.declareText
       (#
          set::  (#  do value->studioName #);
          get::  (#  do studioName[]->value[] #)
       #);
   true->sqlCon.autoCommitMode;
   'AutoCommitMode = %s\n'
     ->putFormat
       (# 
       do (if sqlCon.autoCommitMode then 'true'->s else 'false'->s if)
       #);
   (if sqlCon.transactionsSupported then
       false->sqlCon.autoCommitmode;
       'AutoCommitMode = %s\n'
         ->putFormat
           (# 
           do (if sqlCon.autoCommitMode then 'true'->s else 'false'->s if)
           #);
       (if sqlCon.readUncommitted->sqlCon.transactionLevelSupported then
           'Setting transactionLevel to readUncommitted'->putline;
           'readUncommitted = %i, transactionLevel = %i\n'
             ->putFormat
               (# 
               do
                  sqlCon.readUncommitted->i;
                  sqlCon.readUncommitted->sqlCon.transactionLevel->i
               #)
        else
           'readUncommitted not supported'->putline
       if);
       (if sqlCon.readCommitted->sqlCon.transactionLevelSupported then
           'Setting transactionLevel to readCommitted'->putline;
           'readCommitted = %i, transactionLevel = %i\n'
             ->putFormat
               (# 
               do
                  sqlCon.readCommitted->i;
                  sqlCon.readCommitted->sqlCon.transactionLevel->i
               #)
        else
           'readCommitted not supported'->putline
       if);
       (if sqlCon.repeatableRead->sqlCon.transactionLevelSupported then
           'Setting transactionLevel to repeatableRead'->putline;
           'repeatableRead = %i, transactionLevel = %i\n'
             ->putFormat
               (# 
               do
                  sqlCon.repeatableRead->i;
                  sqlCon.repeatableRead->sqlCon.transactionLevel->i
               #)
        else
           'repeatableRead not supported'->putline
       if);
       (if sqlCon.serializable->sqlCon.transactionLevelSupported then
           'Setting transactionLevel to serializable'->putline;
           'serializable = %i, transactionLevel = %i\n'
             ->putFormat
               (# 
               do
                  sqlCon.serializable->i;
                  sqlCon.serializable->sqlCon.transactionLevel->i
               #)
        else
           'serializable not supported'->putline
       if);
       L:
         (# 
         do
            'Input a name: '->puttext;
            studioName.clear;
            getLine->studioName.puttext;
            'INSERT INTO Navne VALUES (:studioName)'->stmt;
            stmt.getExpanded->putline;
            stmt.execute;
            stmt.close;
            'Commit or rollback (c/r)? '->puttext;
            getline->commit[];
            (if true
             // 'c'->commit.equalNCS then
                'Committing'->putline; sqlCon.commit; restart L
             else
                'Rolling back'->putline; sqlCon.rollback
            if)
         #);
       'Press return to delete table'->puttext;
       getline;
       'DROP TABLE navne'->stmt;
       stmt.execute;
       stmt.execute
    else
       'Transactions not supported'->putline
   if);
   sqlCon.close
#)  

