ORIGIN '../../betadbc';
INCLUDE '../../transactions'
        '../betaunit/textbetaunit';
-- program: Descriptor --
(#
   testResultSet: testSuite
     (#
        sqlCon: @connection;
        stmt: ^connection.directSQLStatement;
        cur: ^connection.resultSet;
        startTestCase:: 
          (#  do &sqlCon.directSQLStatement[]->stmt[]; stmt.open #);
        endTestCase::  (#  do stmt.close #);
        start:: 
          (#
             stmt: @sqlCon.directSQLStatement;
             insertValue:
               (#
                  stmt: @sqlCon.directSQLStatement;
                  stmtTxt: @text;
                  t: @time;
                  i: @integer
               enter i
               do
                  stmt.open;
                  'INSERT INTO aTable VALUES ( %s , %s , %b , '->stmtTxt;
                  '%i , %f , %t , %d , %c )'->stmtTxt.append;
                  stmtTxt[]->stmt;
                  'varchar'->stmtTxt;
                  i->stmtTxt.putint;
                  stmtTxt[]->stmt.s;
                  'char'->stmt.s;
                  true->stmt.b;
                  i->stmt.i;
                  1.234567->stmt.f;
                  1974->t.year;
                  30->t.day;
                  11->t.month;
                  23->t.hour;
                  33->t.minute;
                  55->t.sec;
                  t->stmt.t;
                  t->stmt.d;
                  t->stmt.c;
                  stmt.execute;
                  stmt.close
               #);
             stmtTxt: @text
          do
             (2->arguments,3->arguments,4->arguments)->sqlCon.open;
             stmt.open;
             'CREATE TABLE aTable (t1 VARCHAR(55),'->stmtTxt;
             't2 CHAR(16) , t3 BIT,  t4 INTEGER, '->stmtTxt.append;
             't5 DOUBLE, t6 TIMESTAMP,  t7 DATE NOT NULL, t8 TIME )'
               ->stmtTxt.append;
             stmtTxt[]->stmt;
             stmt.execute;
             (for i: 10 repeat i->insertValue for);
             stmt.close
          #);
        end:: 
          (# stmt: @sqlCon.directSQLStatement
          do stmt.open; 'DROP TABLE aTable'->stmt; stmt.execute; stmt.close
          #);
        testResultSetName: testCase
          (#
             mystmt: @sqlCon.directSQLStatement
               (# cursorType::  (# name::  (#  do 'c1'->value[] #) #)
               #)
          do
             mystmt.open;
             'SELECT * FROM aTable'->mystmt.set;
             mystmt.execute->cur[];
             ('c1',cur.cursorName)->assertTextEqual;
             mystmt.close
          #);
        testColumnCount: testCase
          (# 
          do
             'SELECT * FROM aTable'->stmt.set;
             stmt.execute->cur[];
             (8,cur.columnCount)->assertIntegerEqual;
             ((cur.tuplecount = 10) or (cur.tuplecount = - 1))->assert;
             'UPDATE aTable SET t3 = FALSE'->stmt.set;
             stmt.execute->cur[];
             (0,cur.columnCount)->assertIntegerEqual;
             (cur.tuplecount = 10)->assert
          #);
        testColumn: testCase
          (#
             col: ^connection.resultSet.column;
             checkColumnsByName:
               (#
                  columnsEqual: booleanValue
                    (# c1,c2: ^connection.resultSet.column
                    enter (c1[],c2[])
                    do
                       true->value;
                       (if false
                        // c1.name[]->c2.name.equal // c1.no = c2.no
                        // c1.dataType## = c2.dataType##
                        // c1.dataTypeName[]->c2.dataTypeName.equal
                        // c1.dataTypeNo = c2.dataTypeNo
                        // c1.nullable = c2.nullable then
                           false->value
                       if)
                    #);
                  cur: ^connection.resultSet;
                  i: @integer;
                  t: @text
               enter cur[]
               do
                  (for i: 8 repeat
                    't'->t;
                    i->t.putint;
                    (t[]->cur.getColumnByName,i->cur.getColumn)->columnsEqual
                      ->assert
                  for)
               #)
          do
             'SELECT * FROM aTable'->stmt.set;
             stmt.execute->cur[];
             T1:
               (# 
               do
                  1->cur.getColumn->col[];
                  ('t1',col.name[])->assertTextEqual;
                  (1,col.no)->assertIntegerEqual;
                  (text## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T2:
               (# 
               do
                  2->cur.getColumn->col[];
                  ('t2',col.name[])->assertTextEqual;
                  (2,col.no)->assertIntegerEqual;
                  (text## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T3:
               (# 
               do
                  3->cur.getColumn->col[];
                  ('t3',col.name[])->assertTextEqual;
                  (3,col.no)->assertIntegerEqual;
                  (booleanObject## = col.dataType##)->assert;
                  (not col.nullAble)->assert
               #);
             T4:
               (# 
               do
                  4->cur.getColumn->col[];
                  ('t4',col.name[])->assertTextEqual;
                  (4,col.no)->assertIntegerEqual;
                  (integerObject## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T5:
               (# 
               do
                  5->cur.getColumn->col[];
                  ('t5',col.name[])->assertTextEqual;
                  (5,col.no)->assertIntegerEqual;
                  (realObject## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T6:
               (# 
               do
                  6->cur.getColumn->col[];
                  ('t6',col.name[])->assertTextEqual;
                  (6,col.no)->assertIntegerEqual;
                  (time## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T7:
               (# 
               do
                  7->cur.getColumn->col[];
                  ('t7',col.name[])->assertTextEqual;
                  (7,col.no)->assertIntegerEqual;
                  (time## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             T8:
               (# 
               do
                  8->cur.getColumn->col[];
                  ('t8',col.name[])->assertTextEqual;
                  (8,col.no)->assertIntegerEqual;
                  (time## = col.dataType##)->assert;
                  col.nullAble->assert
               #);
             cur[]->checkColumnsByName
          #);
        testNamedResultSetSet: testCase
          (# 
          do
             T1:
               (# failed: @boolean
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  'foo%f'
                    ->cur.set
                      (#
                         columnNotFound:: 
                           (#  do true->failed; true->continue #)
                      #);
                  failed->assert (#  do 'column not found'->msg #)
               #);
             T2:
               (#
                  varchar: @text;
                  char16: @text;
                  bit: @booleanObject;
                  int: @integer;
                  double: @real;
                  timestamp: @time;
                  date: @time;
                  t: @time;
                  txt: @text;
                  dt,tm,cl: @time
               do
                  'varchar'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->varchar #);
                         get::  (#  do varchar[]->value[] #)
                      #);
                  'char16'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->char16 #);
                         get::  (#  do char16->value #)
                      #);
                  'bit'
                    ->sqlCon.declareBoolean
                      (#
                         set::  (#  do value->bit #);
                         get::  (#  do bit->value #)
                      #);
                  'int'
                    ->sqlCon.declareInteger
                      (#
                         set::  (#  do value->int #);
                         get::  (#  do int->value #)
                      #);
                  'double'
                    ->sqlCon.declareReal
                      (#
                         set::  (#  do value->double #);
                         get::  (#  do double->value #)
                      #);
                  'timestamp'
                    ->sqlCon.declareTime
                      (#
                         set::  (#  do value->timestamp #);
                         get::  (#  do timestamp->value #)
                      #);
                  'date'
                    ->sqlCon.declareDate
                      (#
                         set::  (#  do value->date #);
                         get::  (#  do date->value #)
                      #);
                  't'
                    ->sqlCon.declareClock
                      (#
                         set::  (#  do value->t #);
                         get::  (#  do t->value #)
                      #);
                  'SELECT * FROM aTable'->stmt;
                  stmt.execute->cur[];
                  't2:char16 t5:double t1:varchar t7:date t3:bit t4:int t6:timestamp t8:t'
                    ->cur.set;
                  (for i: 10 repeat
                    cur.fetch;
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],varchar[])->assertTextEqual;
                    ('char            ',char16[])->assertTextEqual;
                    (not bit)->assert;
                    (int,i)->assertIntegerEqual;
                    (double = 1.234567)->assert;
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (cl->timestamp.equal)
                      ->assert (#  do 'clock equals'->msg #);
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (dt->date.equal)->assert (#  do 'date equals'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (tm->t.equal)->assert (#  do 'time equals'->msg #)
                  for)
               #);
             T3:
               (#
                  t: @time;
                  txt: @text;
                  dt,tm,cl: @time;
                  current: ^connection.resultSet.tuple
               do
                  'SELECT * FROM aTable'->stmt;
                  stmt.execute->cur[];
                  't2%s t5%f t1%s t7%d t3%b t4%i t6%t t8%c'->cur.set;
                  (for i: 10 repeat
                    cur.fetch->current[];
                    ('char            ',current.s)->assertTextEqual;
                    (current.f = 1.234567)->assert;
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],current.s)->assertTextEqual;
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (current.d->dt.equal)
                      ->assert (#  do 'date equals (2)'->msg #);
                    (not current.b)->assert;
                    (current.i,i)->assertIntegerEqual;
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (current.t->cl.equal)
                      ->assert (#  do 'clock equals (2)'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (current.c->tm.equal)
                      ->assert (#  do 'time equals (2)'->msg #)
                  for)
               #);
             T4:
               (#
                  t: @time;
                  txt: @text;
                  dt,tm,cl: @time;
                  char16: @text;
                  bit: @booleanObject;
                  int: @integer;
                  current: ^connection.resultSet.tuple
               do
                  'char16'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->char16 #);
                         get::  (#  do char16->value #)
                      #);
                  'bit'
                    ->sqlCon.declareBoolean
                      (#
                         set::  (#  do value->bit #);
                         get::  (#  do bit->value #)
                      #);
                  'int'
                    ->sqlCon.declareInteger
                      (#
                         set::  (#  do value->int #);
                         get::  (#  do int->value #)
                      #);
                  'SELECT * FROM aTable'->stmt;
                  stmt.execute->cur[];
                  't2:char16 t5%f t1%s t7%d t3:bit t4:int t6%t t8%c'->cur.set;
                  (for i: 10 repeat
                    cur.fetch->current[];
                    (not bit)->assert;
                    (int,i)->assertIntegerEqual;
                    ('char            ',char16[])->assertTextEqual;
                    (current.f = 1.234567)->assert;
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],current.s)->assertTextEqual;
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (current.d->dt.equal)
                      ->assert (#  do 'date equals (2)'->msg #);
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (current.t->cl.equal)
                      ->assert (#  do 'clock equals (2)'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (current.c->tm.equal)
                      ->assert (#  do 'time equals (2)'->msg #)
                  for)
               #)
          #);
        testUnNamedResultSetSet: testCase
          (# 
          do
             T1:
               (# failed: @boolean
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  ':bar'
                    ->cur.set
                      (#
                         varNotDeclared:: 
                           (#  do true->failed; true->continue #)
                      #);
                  failed->assert (#  do 'variable not declared'->msg #)
               #);
             T2:
               (#
                  dt,tm,cl: @time;
                  txt: @text;
                  current: ^connection.resultSet.tuple
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  '%s %s %b %i %f %t %d %c'->cur.set;
                  (for i: 10 repeat
                    cur.fetch->current[];
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],current.s)->assertTextEqual;
                    ('char            ',current.s)->assertTextEqual;
                    (not current.b)->assert;
                    (current.i,i)->assertIntegerEqual;
                    (current.f = 1.234567)->assert;
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (current.t->cl.equal)
                      ->assert (#  do 'clock equals'->msg #);
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (current.d->dt.equal)
                      ->assert (#  do 'date equals'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (current.c->tm.equal)
                      ->assert (#  do 'time equals'->msg #)
                  for)
               #);
             T3:
               (#
                  dt,tm,cl: @time;
                  txt: @text;
                  char16: @text;
                  bit: @booleanObject;
                  int: @integer;
                  current: ^connection.resultSet.tuple
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  'char16'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->char16 #);
                         get::  (#  do char16->value #)
                      #);
                  'bit'
                    ->sqlCon.declareBoolean
                      (#
                         set::  (#  do value->bit #);
                         get::  (#  do bit->value #)
                      #);
                  'int'
                    ->sqlCon.declareInteger
                      (#
                         set::  (#  do value->int #);
                         get::  (#  do int->value #)
                      #);
                  '%s :char16 :bit :int %f %t %d %c'->cur.set;
                  (for i: 10 repeat
                    cur.fetch->current[];
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],current.s)->assertTextEqual;
                    ('char            ',char16[])->assertTextEqual;
                    (not bit)->assert;
                    (int,i)->assertIntegerEqual;
                    (current.f = 1.234567)->assert;
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (current.t->cl.equal)
                      ->assert (#  do 'clock equals'->msg #);
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (current.d->dt.equal)
                      ->assert (#  do 'date equals'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (current.c->tm.equal)
                      ->assert (#  do 'time equals'->msg #)
                  for)
               #);
             T4:
               (#
                  varchar: @text;
                  char16: @text;
                  bit: @booleanObject;
                  int: @integer;
                  double: @real;
                  timestamp: @time;
                  date: @time;
                  t: @time;
                  txt: @text;
                  dt,tm,cl: @time
               do
                  'varchar'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->varchar #);
                         get::  (#  do varchar[]->value[] #)
                      #);
                  'char16'
                    ->sqlCon.declareText
                      (#
                         set::  (#  do value->char16 #);
                         get::  (#  do char16->value #)
                      #);
                  'bit'
                    ->sqlCon.declareBoolean
                      (#
                         set::  (#  do value->bit #);
                         get::  (#  do bit->value #)
                      #);
                  'int'
                    ->sqlCon.declareInteger
                      (#
                         set::  (#  do value->int #);
                         get::  (#  do int->value #)
                      #);
                  'double'
                    ->sqlCon.declareReal
                      (#
                         set::  (#  do value->double #);
                         get::  (#  do double->value #)
                      #);
                  'timestamp'
                    ->sqlCon.declareTime
                      (#
                         set::  (#  do value->timestamp #);
                         get::  (#  do timestamp->value #)
                      #);
                  'date'
                    ->sqlCon.declareDate
                      (#
                         set::  (#  do value->date #);
                         get::  (#  do date->value #)
                      #);
                  't'
                    ->sqlCon.declareClock
                      (#
                         set::  (#  do value->t #);
                         get::  (#  do t->value #)
                      #);
                  'SELECT * FROM aTable'->stmt;
                  stmt.execute->cur[];
                  ':varchar :char16 :bit :int :double :timestamp :date :t'
                    ->cur.set;
                  (for i: 10 repeat
                    cur.fetch;
                    'varchar'->txt;
                    i->txt.putint;
                    (txt[],varchar[])->assertTextEqual;
                    ('char            ',char16[])->assertTextEqual;
                    (not bit)->assert;
                    (int,i)->assertIntegerEqual;
                    (double = 1.234567)->assert;
                    1974->cl.year;
                    30->cl.day;
                    11->cl.month;
                    23->cl.hour;
                    33->cl.minute;
                    55->cl.sec;
                    (cl->timestamp.equal)
                      ->assert (#  do 'clock equals'->msg #);
                    1974->dt.year;
                    30->dt.day;
                    11->dt.month;
                    (dt->date.equal)->assert (#  do 'date equals'->msg #);
                    23->tm.hour;
                    33->tm.minute;
                    55->tm.sec;
                    (tm->t.equal)->assert (#  do 'time equals'->msg #)
                  for)
               #)
          #);
        testScan: testCase
          (# i: @integer
          do
             T1:
               (# 
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  cur.scan
                    (# dt,tm,cl: @time; txt: @text
                    do
                       i+1->i;
                       'varchar'->txt;
                       i->txt.putint;
                       (txt[],current.s)->assertTextEqual;
                       ('char            ',current.s)->assertTextEqual;
                       (not current.b)->assert;
                       (current.i,i)->assertIntegerEqual;
                       (current.f = 1.234567)->assert;
                       1974->cl.year;
                       30->cl.day;
                       11->cl.month;
                       23->cl.hour;
                       33->cl.minute;
                       55->cl.sec;
                       (current.t->cl.equal)
                         ->assert (#  do 'clock equals'->msg #);
                       1974->dt.year;
                       30->dt.day;
                       11->dt.month;
                       (current.d->dt.equal)
                         ->assert (#  do 'date equals'->msg #);
                       23->tm.hour;
                       33->tm.minute;
                       55->tm.sec;
                       (current.c->tm.equal)
                         ->assert (#  do 'time equals'->msg #)
                    #);
                  (i,10)->assertIntegerEqual
               #);
             T2:
               (#
                  current: ^connection.resultSet.tuple;
                  dt,tm,cl: @time;
                  txt: @text
               do
                  'SELECT * FROM aTable'->stmt.set;
                  stmt.execute->cur[];
                  0->i;
                  L:
                    (# 
                    do
                       cur.fetch->current[];
                       (if current[] <> cur.EOT then
                           i+1->i;
                           'varchar'->txt;
                           i->txt.putint;
                           (txt[],current.s)->assertTextEqual;
                           ('char            ',current.s)->assertTextEqual;
                           (not current.b)->assert;
                           (current.i,i)->assertIntegerEqual;
                           (current.f = 1.234567)->assert;
                           1974->cl.year;
                           30->cl.day;
                           11->cl.month;
                           23->cl.hour;
                           33->cl.minute;
                           55->cl.sec;
                           (current.t->cl.equal)
                             ->assert (#  do 'clock equals'->msg #);
                           1974->dt.year;
                           30->dt.day;
                           11->dt.month;
                           (current.d->dt.equal)
                             ->assert (#  do 'date equals'->msg #);
                           23->tm.hour;
                           33->tm.minute;
                           55->tm.sec;
                           (current.c->tm.equal)
                             ->assert (#  do 'time equals'->msg #);
                           restart L
                       if)
                    #);
                  (i,10)->assertIntegerEqual
               #)
          #)
     do
        &testResultSetName[]->addTest;
        &testColumnCount[]->addTest;
        &testColumn[]->addTest;
        &testNamedResultSetSet[]->addTest;
        &testUnNamedResultSetSet[]->addTest;
        &testScan[]->addTest
     #)
do &writingTestResult[]->testResultSet
#)  

