(x) Parser 
(x) To represent statements in the parse tree and unparse them when needed (probably using an instance of the Visitor pattern). 
	( ) better implementation of NodeVisitor (including recursion of trees)
(x) DirectSQLStatement in principle done (still missing c,... markers though)
( ) cursor pattern stuff

Statement/Cursor Patterns
=========================

The formal (extended BNF) grammar is:

	<StatementPatternString> ::=? '<StatementPattern>'
	<StatementPattern> ::=+ <StatementStringOrSpecifier>
	<StatementStringOrSpecifier> ::= <StatementString> | <StatementSpecifier>
	<StatementString> ::= <String> <EOW>
	<StatementSpecifier> ::= <Specifier> <EOW>

	<CursorPatternString> ::=? '<CursorPattern>'
	<CursorPattern> ::= <NamedCursorPattern> | <UnnamedCursorPattern>
	<NamedCursorPattern> ::=+ <NamedSpecifier> ' ' 
	<UnnamedCursorPattern> ::=+ <UnnamedSpecifier> ' '

	<Specifier> ::= <NamedSpecifier> | <UnnamedSpecifier>
	<NamedSpecifier> ::= <NameDecl> <UnnamedSpecifier>
	<UnnamedSpecifier> ::= <Variable> | <Placeholder>
	<Variable> ::= ':'<NameAppl>
	<Placeholder> ::= '%'<PlaceholderType>
	<PlaceholderType> ::= b | c | d | f | i | s | t 
	
in which <NameDecl>, <String>, and <NameAppl> are predefined.

Statements
==========

Suppose 'stmt' is an SQL statement. Then a statement pattern may be used as in 

	<StatementPatternString> -> stmt;

There are two forms of legal cursor pattern types: unnamed and named. 


Cursors
=======

Suppose 'crs' is an SQL cursor. Then a cursor pattern may be used as in

	<CursorPatternString> -> crs.open.

There are two forms of legal cursor pattern types: unnamed and named.

	Unnamed. Data from tuples are fetched according to the specification
	in the pattern and in increasing numerical order of columns. If, e.g.,
	a pattern is
		':variable; %i; %s',
	the first value of each tuple is fetched into the shared variable 'variable',
	the second value can be accessed by (current).i, and the third value by
	(current).s (after (current).i has been executed.)
	Order of specifiers is significant.

	Named. Data from tuples are fetched according to names of columns. If, e.g.,
	a pattern is
		'col1:variable; col2:%i; col3:%s',
	then for each tuple, the value of the column 'col1' is fetched into the 
	shared variable 'variable', the value of the column 'col2' may be accessed 
	through (current).i, and the value of the column 'col3' may be accessed through
	(current).s (after (current).i has been executed.)
	Order of specifiers is insignificant.
