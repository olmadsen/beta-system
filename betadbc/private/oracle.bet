ORIGIN '~beta/basiclib/betaenv';
-- lib: attributes --

(* sword OCIInitialize(
  ub4 mode, 
  CONST dvoid *ctxp,  
  CONST dvoid *(*malocfp) (dvoid *ctxp, size_t size),
  CONST dvoid *(*ralocfp) (dvoid *ctxp, dvoid *memp, size_t newsize ),
  * CONST void (*mfreefp) (dvoid *ctxp, dvoid *memptr));
*)

OCIInitialize: external
  (# mode, ctxp, ctxpsize, ctxpmempnewsize, ctxpmemptr, result: @integer;
  enter (mode, ctxp, ctxpsize, ctxpmempnewsize, ctxpmemptr)
  exit result
  #);



(* sword OCIEnvInit (OCIEnv **envp, ub4 mode, size_t xtramem_sz, dvoid **usrmempp); *)

OCIEnvInit: external
  (# envp, mode, xtramem_sz, usrmempp, result: @integer;
  enter (envp, mode, xtramem_sz, usrmempp)
  exit result
  #);



(*
 sword OCIHandleAlloc
 (CONST dvoid *parenth, dvoid **hndlpp, ub4 type, size_t xtramem_sz, dvoid **usrmempp);
 *)

OCIHandleAlloc: external
  (# parenth, hndlpp, type, xtramem_sz, usrmempp, result: @integer;
     enter(parenth, hndlpp, type, xtramem_sz, usrmempp)
     exit result
  #);



(*
 sword OCIServerAttach
 (OCIServer *srvhp, OCIError *errhp, CONST OraText *dblink, sb4 dblink_len, ub4 mode);
 *)

OCIServerAttach: external
  (# srvhp, errhp, dblink, dblink_len, mode, result: @integer;
  enter (srvhp, errhp, dblink, dblink_len, mode)
  exit result
  #);



(* sword OCIServerDetach(OCIServer *svrhp, OCIError *errhp, ub4 mode); *)

OCIServerDetach: external
  (# svrhp, errhp, mode, result: @integer;
  enter (svrhp, errhp, mode)
  exit result
  #);



(*
 sword OCIAttrSet
 (dvoid *trgthndlp, ub4 trghndltyp, dvoid *attributep, ub4 size, ub4 attrtype, OCIError *errhp);
 *)

OCIAttrSet: external
  (# trgthndlp, trghndltyp, attributep, size, attrtype, errhp, result: @integer;
  enter (trgthndlp, trghndltyp, attributep, size, attrtype, errhp)
  exit result
  #);



(*
 sword OCISessionBegin 
 (OCISvcCtx *svchp, OCIError *errhp, OCISession *usrhp, ub4 credt, ub4 mode);
 *)

OCISessionBegin: external
  (# svchp, errhp, usrhp, credt, mode, result: @integer;
  enter (svchp, errhp, usrhp, credt, mode)
  exit result
  #);



(* sword OCISessionEnd ( OCISvcCtx       *svchp,
                    OCIError        *errhp,
                    OCISession      *usrhp,
                    ub4             mode);
*)

OCISessionEnd: external
  (# svchp, errhp, usrhp, mode, result: @integer;
	enter (svchp, errhp, usrhp, mode)
	exit result
  #);



(*
 sword OCIStmtPrepare 
 (OCIStmt *stmtp, OCIError *errhp, CONST OraText *stmt, ub4 stmt_len, ub4 language, ub4 mode);
 *)

OCIStmtPrepare: external
  (# stmtp, errhp, stmt_len, language, mode, result: @integer;
     stmt: [0]@char;
  enter (stmtp, errhp, stmt, stmt_len, language, mode)
  exit result
  #);



(*
 sword OCIStmtExecute (
  OCISvcCtx *svchp, 
  OCIStmt *stmtp, 
  OCIError *errhp,
  ub4 iters, 
  ub4 rowoff, 
  CONST OCISnapshot *snap_in, 
  OCISnapshot *snap_out, 
  ub4 mode);
 *)

OCIStmtExecute: external
  (# svchp, stmtp, errhp, iters, rowoff, snap_in, snap_out, mode, result: @integer;
  enter (svchp, stmtp, errhp, iters, rowoff, snap_in, snap_out, mode)
  exit result
  #);


(*
sword OCITransCommit ( OCISvcCtx *srvcp, OCIError *errhp, ub4 flags );
 *)

OCITransCommit: external
  (# srvcp, errhp, flags, result: @integer
  enter (srvcp, errhp, flags)
     exit result
  #);



(* 
sword OCIDefineByPos(
 OCIStmt *stmtp, 
 OCIDefine **defnp, 
 OCIError *errhp,
 ub4 position, 
 dvoid *valuep, 
 sb4 value_sz, 
 ub2 dty,
 dvoid *indp, 
 ub2 *rlenp, 
 ub2 *rcodep, 
 ub4 mode);
 *)

OCIDefineByPos: external
  (# stmtp, defnp, errhp, position, valuep, value_sz, dty, indp, rlenp, rcodep, mode, result:@integer;
  enter (stmtp, defnp, errhp, position, valuep, value_sz, dty, indp, rlenp, rcodep, mode)
  exit result
  #);



(* sword OCIParamGet(CONST dvoid *hndlp, ub4 htype, OCIError *errhp, dvoid **parmdpp, ub4 pos); *)

OCIParamGet: external
  (# hndlp, htype, errhp, parmdpp, pos, result: @integer;
  enter (hndlp, htype, errhp, parmdpp, pos)
  exit result
  #);



(* sword OCIHandleFree(dvoid *hndlp, ub4 type); *)

OCIHandleFree: external
  (# hndlp, type, result: @integer;
  enter (hndlp, type)
  exit result
  #);



(* sword OCIAttrGet ( CONST dvoid    *trgthndlp,
                      ub4            trghndltyp,
                      dvoid          *attributep,
                      ub4            *sizep,
                      ub4            attrtype,
                      OCIError       *errhp ); *)

OCIAttrGet: external
  (# trgthndlp, trghndltyp, attributep, sizep, attrtype, errhp, result: @integer;
  enter (trgthndlp, trghndltyp, attributep, sizep, attrtype, errhp) 
  exit result
  #);



(* sword OCIErrorGet ( dvoid      *hndlp, 
                  ub4        recordno,
                  OraText       *sqlstate,
                  ub4        *errcodep, 
                  OraText       *bufp,
                  ub4        bufsiz,
                  ub4        type ); *)

OCIErrorGet: external
  (# hndlp, recordno, sqlstate, errcodep, bufp, bufsiz, type, result: @integer;
  enter (hndlp, recordno, sqlstate, errcodep, bufp, bufsiz, type)
  exit result
  #);



OracleGetColName: external
  (# paramhp, bufferp, maxsize, errhp, status: @integer
   enter (paramhp, bufferp, maxsize, errhp)
   exit status
  #);

OracleFetch: external
  (# stmthp, errhp, rowhandle: @integer;
  enter (stmthp, errhp)
  exit rowhandle
  #);

OracleNumOfRows: external
  (# rowhandle, numOfRows: @integer;
  enter rowhandle
  exit numOfRows
  #);

OracleNumOfCols: external
  (# rowhandle, numOfCols: @integer;
  enter rowhandle
  exit numOfCols
  #);

OracleGetInteger:external
  (# myrow,inx:@integer;
     result:@integer
  enter (myrow, inx)
  exit result
  #);

OracleGetText:external
  (# myrow,inx:@integer;
     ptr:@integer
  enter (myrow, inx)
  exit ptr
  #);

OracleGetReal:external
  (# myrow,inx:@integer;
     result:@real
  enter (myrow, inx)
  exit result
  #);

OracleGetBoolean:external
  (# myrow,inx:@integer;
     result:@char
  enter (myrow, inx)
  exit result
  #);

OracleGetRowAtIndex: external
  (# rowhandle, rownumber, result: @integer;
  enter (rowhandle, rownumber)
  exit result
  #);

OracleFreeResultSet: external
  (# rowhandle: @integer;
  enter (rowhandle)
  #);

OCI_DEFAULT:(# exit 0 #);

OCI_CRED_RDBMS:(# exit 1 #);            (* database username/password *)

OCI_HTYPE_FIRST:(# exit 1 #);           (* start value of handle type *)
OCI_HTYPE_ENV:(# exit 1 #);             (* environment handle *)
OCI_HTYPE_ERROR:(# exit 2 #);           (* error handle *)
OCI_HTYPE_SVCCTX:(# exit 3 #);          (* service handle *)
OCI_HTYPE_STMT:(# exit 4 #);            (* statement handle *)
OCI_HTYPE_BIND:(# exit 5 #);            (* bind handle *)
OCI_HTYPE_DEFINE:(# exit 6 #);          (* define handle *)
OCI_HTYPE_DESCRIBE:(# exit 7 #);        (* describe handle *)
OCI_HTYPE_SERVER:(# exit 8 #);          (* server handle *)
OCI_HTYPE_SESSION:(# exit 9 #);         (* authentication handle *)
OCI_HTYPE_TRANS:(# exit 10 #);          (* transaction handle *)
OCI_HTYPE_COMPLEXOBJECT:(# exit 11 #);  (* complex object retrieval handle *)
OCI_HTYPE_SECURITY:(# exit 12 #);       (* security handle *)
OCI_HTYPE_SUBSCRIPTION:(# exit 13 #);   (* subscription handle *)
OCI_HTYPE_DIRPATH_CTX:(# exit 14 #);    (* direct path context *)
OCI_HTYPE_DIRPATH_COLUMN_ARRAY:(# exit 15 #);   (* direct path column array *)
OCI_HTYPE_DIRPATH_STREAM:(# exit 16 #); (* direct path stream *)
OCI_HTYPE_PROC:(# exit 17 #);           (* process handle *)
OCI_HTYPE_LAST:(# exit 17 #);           (* last value of a handle type *)


OCI_COMMIT_ON_SUCCESS:(# exit 0x20 #);       (* commit, if successful execution *)

OCI_SUCCESS:(# exit 0 #);                     (* maps to SQL_SUCCESS of SAG CLI *)
OCI_SUCCESS_WITH_INFO:(# exit 1 #);            (* maps to SQL_SUCCESS_WITH_INFO *)
OCI_RESERVED_FOR_INT_USE:(# exit 200 #);           (* reserved for internal use *) 
OCI_NO_DATA:(# exit 100 #);                              (* maps to SQL_NO_DATA *)
OCI_ERROR:(# exit -1 #);                                   (* maps to SQL_ERROR *)
OCI_INVALID_HANDLE:(# exit -2 #);                 (* maps to SQL_INVALID_HANDLE *)
OCI_NEED_DATA:(# exit 99 #);                           (* maps to SQL_NEED_DATA *)
OCI_STILL_EXECUTING:(# exit -3123 #);                  (* OCI would block error *)
OCI_CONTINUE:(# exit -24200 #);   (* Continue with the body of the OCI function *)


OCI_DTYPE_PARAM:(# exit 53 #);      (* a parameter descriptor obtained from ocigparm *)


OCI_ATTR_DATA_SIZE:(# exit 1 #);                         (* maximum size of the data *)
OCI_ATTR_DATA_TYPE :(# exit 2 #);             (* the SQL type of the column/argument *)
OCI_ATTR_DISP_SIZE :(# exit 3 #);                                (* the display size *)
OCI_ATTR_NAME:(# exit 4 #);                       (* the name of the column/argument *)
OCI_ATTR_PRECISION:(# exit 5 #);                         (* precision if number type *)
OCI_ATTR_SCALE:(# exit 6 #);                                 (* scale if number type *)
OCI_ATTR_IS_NULL:(# exit 7 #);                                       (* is it null ? *)
OCI_ATTR_TYPE_NAME:(# exit 8#);

OCI_ATTR_FNCODE:(# exit  1 #);                              (* the OCI function code *)
OCI_ATTR_OBJECT:(# exit    2 #);    (* is the environment initialized in object mode *)
OCI_ATTR_NONBLOCKING_MODE:(# exit   3 #);                       (* non blocking mode *)
OCI_ATTR_SQLCODE :(# exit  4 #);                                     (* the SQL verb *)
OCI_ATTR_ENV  :(# exit 5 #);                              (* the environment handle *)
OCI_ATTR_SERVER:(# exit  6 #);                                  (* the server handle *)
OCI_ATTR_SESSION:(# exit  7 #);                           (* the user session handle *)
OCI_ATTR_TRANS  :(# exit  8 #);                            (* the transaction handle *)
OCI_ATTR_ROW_COUNT  :(# exit  9 #);                     (* the rows processed so far *)
OCI_ATTR_SQLFNCODE :(# exit 10 #);                  (* the SQL verb of the statement *)
OCI_ATTR_PREFETCH_ROWS  :(# exit 11 #);       (* sets the number of rows to prefetch *)
OCI_ATTR_NESTED_PREFETCH_ROWS :(# exit 12 #);    (* the prefetch rows of nested table*)
OCI_ATTR_PREFETCH_MEMORY :(# exit 13 #);            (* memory limit for rows fetched *)
OCI_ATTR_NESTED_PREFETCH_MEMORY :(# exit 14 #);      (* memory limit for nested rows *)
OCI_ATTR_CHAR_COUNT:(# exit 15 #);  (* this specifies the bind and define size in characters *)
OCI_ATTR_PDSCL :(# exit   16 #);                             (* packed decimal scale *)
OCI_ATTR_FSPRECISION :(# exit 16 #);    (* fs prec for datetime data types *)
OCI_ATTR_PDPRC   :(# exit 17 #);                            (* packed decimal format *)
OCI_ATTR_LFPRECISION:(# exit  17 #);    (* fs prec for datetime data types *)
OCI_ATTR_PARAM_COUNT:(# exit  18 #);          (* number of column in the select list *)
OCI_ATTR_ROWID   :(# exit 19 #);                                        (* the rowid *)
OCI_ATTR_CHARSET :(# exit  20 #);                         (* the character set value *)
OCI_ATTR_NCHAR  :(# exit  21 #);                                       (* NCHAR type *)
OCI_ATTR_USERNAME:(# exit  22 #);                              (* username attribute *)
OCI_ATTR_PASSWORD :(# exit 23 #);                              (* password attribute *)
OCI_ATTR_STMT_TYPE :(# exit   24 #);                               (* statement type *)
OCI_ATTR_INTERNAL_NAME :(# exit   25 #);                (* user friendly global name *)
OCI_ATTR_EXTERNAL_NAME :(# exit   26 #);         (* the internal name for global txn *)
OCI_ATTR_XID :(# exit     27 #);              (* XOPEN defined global transaction id *)
OCI_ATTR_TRANS_LOCK :(# exit 28 #);                                               (* *)
OCI_ATTR_TRANS_NAME :(# exit 29 #);       (* string to identify a global transaction *)
OCI_ATTR_HEAPALLOC :(# exit 30 #);                   (* memory allocated on the heap *)
OCI_ATTR_CHARSET_ID :(# exit 31 #);                              (* Character Set ID *)
OCI_ATTR_CHARSET_FORM :(# exit 32 #);                          (* Character Set Form *)
OCI_ATTR_MAXDATA_SIZE :(# exit 33 #);          (* Maximumsize of data on the server  *)
OCI_ATTR_CACHE_OPT_SIZE :(# exit 34 #);                 (* object cache optimal size *)
OCI_ATTR_CACHE_MAX_SIZE:(# exit  35 #);      (* object cache maximum size percentage *)
OCI_ATTR_PINOPTION :(# exit 36 #);                (* object cache default pin option *)
OCI_ATTR_ALLOC_DURATION:(# exit  37 #);  (* object cache default allocation duration *)
OCI_ATTR_PIN_DURATION:(# exit  38 #);           (* object cache default pin duration *)
OCI_ATTR_FDO      :(# exit     39 #);          (* Format Descriptor object attribute *)
OCI_ATTR_POSTPROCESSING_CALLBACK :(# exit 40 #); (* Callback to process outbind data *)
OCI_ATTR_POSTPROCESSING_CONTEXT :(# exit 41 #); 
                                         (* Callback context to process outbind data *)
OCI_ATTR_ROWS_RETURNED :(# exit 42
 #);                  (* Number of rows returned in current iter - for Bind handles *)
OCI_ATTR_FOCBK  :(# exit       43 #);                 (* Failover Callback attribute *)
OCI_ATTR_IN_V8_MODE :(# exit   44 #);    (* is the server/service context in V8 mode *)
OCI_ATTR_LOBEMPTY   :(# exit   45 #);                                 (* empty lob ? *)
OCI_ATTR_SESSLANG :(# exit     46 #);                     (* session language handle *)

OCI_ATTR_VISIBILITY:(# exit 		47		 #);          (* visibility *)
OCI_ATTR_RELATIVE_MSGID	:(# exit 	48  	 #);         (* relative message id *)
OCI_ATTR_SEQUENCE_DEVIATION:(# exit 	49	 #);          (* sequence deviation *)

OCI_ATTR_CONSUMER_NAME	:(# exit 	50		 #);       (* consumer name *)
OCI_ATTR_DEQ_MODE	:(# exit 	51		 #);        (* dequeue mode *)
OCI_ATTR_NAVIGATION	:(# exit	52		 #);          (* navigation *)
OCI_ATTR_WAIT		:(# exit	53			 #);        (* wait *)
OCI_ATTR_DEQ_MSGID	:(# exit	54	 #);          (* dequeue message id *)

OCI_ATTR_PRIORITY	:(# exit	55			 #);    (* priority *)
OCI_ATTR_DELAY		:(# exit	56			 #);       (* delay *)
OCI_ATTR_EXPIRATION	:(# exit	57		 #);          (* expiration *)
OCI_ATTR_CORRELATION	:(# exit	58		 #);      (* correlation id *)
OCI_ATTR_ATTEMPTS	:(# exit	59		 #);       (* # of attempts *)
OCI_ATTR_RECIPIENT_LIST		:(# exit 60		 #);      (* recipient list *)
OCI_ATTR_EXCEPTION_QUEUE	:(# exit 61	 #);        (* exception queue name *)
OCI_ATTR_ENQ_TIME	:(# exit	62 #);    (* enqueue time (only OCIAttrGet) *)
OCI_ATTR_MSG_STATE	:(# exit	63 #);   (* message state (only OCIAttrGet) *)
                                                         (* NOTE: 64-66 used below *)
OCI_ATTR_AGENT_NAME		:(# exit 64		 #);          (* agent name *)
OCI_ATTR_AGENT_ADDRESS		:(# exit 65		 #);       (* agent address *)
OCI_ATTR_AGENT_PROTOCOL		:(# exit 66		 #);      (* agent protocol *)

OCI_ATTR_SENDER_ID		:(# exit 68			#);   (* sender id *)
OCI_ATTR_ORIGINAL_MSGID		:(# exit 69	 #);         (* original message id *)

OCI_ATTR_QUEUE_NAME:(# exit		70		 #);          (* queue name *)
OCI_ATTR_NFY_MSGID :(# exit             71		 #);          (* message id *)
OCI_ATTR_MSG_PROP:(# exit               72	 #);          (* message properties *)

OCI_ATTR_NUM_DML_ERRORS :(# exit        73 #);          (* num of errs in array DML *)
OCI_ATTR_DML_ROW_OFFSET:(# exit         74 #);           (* row offset in the array *)

OCI_ATTR_DATEFORMAT :(# exit            75 #);        (* default date format string *)
OCI_ATTR_BUF_ADDR  :(# exit             76 #);                    (* buffer address *)
OCI_ATTR_BUF_SIZE :(# exit              77 #);                       (* buffer size *)
OCI_ATTR_DIRPATH_MODE :(# exit          78 #);     (* mode of direct path operation *)
OCI_ATTR_DIRPATH_NOLOG :(# exit         79 #);                  (* nologging option *)
OCI_ATTR_DIRPATH_PARALLEL:(# exit       80 #);        (* parallel (temp seg) option *)
OCI_ATTR_NUM_ROWS    :(# exit           81 #);    (* number of rows in column array *)
                   (* NOTE that OCI_ATTR_NUM_COLS is a column array attribute too. *)
OCI_ATTR_COL_COUNT :(# exit             82 #);           (* columns of column array
					             processed so far.       *)
OCI_ATTR_STREAM_OFFSET :(# exit         83 #);     (* str off of last row processed *)
OCI_ATTR_SHARED_HEAPALLOC:(# exit       84 #);       (* Shared Heap Allocation Size *)

OCI_ATTR_SERVER_GROUP:(# exit           85 #);                 (* server group name *)

OCI_ATTR_MIGSESSION:(# exit             86 #);      (* migratable session attribute *)

OCI_ATTR_NOCACHE  :(# exit              87 #);                    (* Temporary LOBs *)

OCI_ATTR_MEMPOOL_SIZE :(# exit          88 #);                         (* Pool Size *)
OCI_ATTR_MEMPOOL_INSTNAME :(# exit      89 #);                     (* Instance name *)
OCI_ATTR_MEMPOOL_APPNAME:(# exit        90 #);                  (* Application name *)
OCI_ATTR_MEMPOOL_HOMENAME :(# exit      91 #);               (* Home Directory name *)
OCI_ATTR_MEMPOOL_MODEL:(# exit          92 #);        (* Pool Model (proc,thrd,both)*)
OCI_ATTR_MODES :(# exit                 93 #);                             (* Modes *)

OCI_ATTR_SUBSCR_NAME  :(# exit          94 #);              (* name of subscription *)
OCI_ATTR_SUBSCR_CALLBACK :(# exit       95 #);               (* associated callback *)
OCI_ATTR_SUBSCR_CTX  :(# exit           96 #);       (* associated callback context *)
OCI_ATTR_SUBSCR_PAYLOAD :(# exit        97 #);                (* associated payload *)
OCI_ATTR_SUBSCR_NAMESPACE :(# exit      98 #);              (* associated namespace *)

OCI_ATTR_PROXY_CREDENTIALS :(# exit     99 #);            (* Proxy user credentials *)
OCI_ATTR_INITIAL_CLIENT_ROLES:(# exit  100 #);          (* Initial client role list *)

OCI_ATTR_UNK       :(# exit       101 #);                      (* unknown attribute *)
OCI_ATTR_NUM_COLS  :(# exit       102 #);                      (* number of columns *)
OCI_ATTR_LIST_COLUMNS :(# exit    103 #);           (* parameter of the column list *)
OCI_ATTR_RDBA       :(# exit      104 #);              (* DBA of the segment header *)
OCI_ATTR_CLUSTERED  :(# exit      105 #);         (* whether the table is clustered *)
OCI_ATTR_PARTITIONED:(# exit      106 #);       (* whether the table is partitioned *)
OCI_ATTR_INDEX_ONLY :(# exit      107 #);        (* whether the table is index only *)
OCI_ATTR_LIST_ARGUMENTS:(# exit   108 #);         (* parameter of the argument list *)
OCI_ATTR_LIST_SUBPROGRAMS:(# exit 109 #);       (* parameter of the subprogram list *)
OCI_ATTR_REF_TDO     :(# exit     110 #);             (* REF to the type descriptor *)
OCI_ATTR_LINK        :(# exit     111 #);                 (* the database link name *)
OCI_ATTR_MIN         :(# exit     112 #);                          (* minimum value *)
OCI_ATTR_MAX         :(# exit     113 #);                          (* maximum value *)
OCI_ATTR_INCR        :(# exit     114 #);                        (* increment value *)
OCI_ATTR_CACHE       :(# exit     115 #);      (* number of sequence numbers cached *)
OCI_ATTR_ORDER       :(# exit     116 #);        (* whether the sequence is ordered *)
OCI_ATTR_HW_MARK     :(# exit     117 #);                        (* high-water mark *)
OCI_ATTR_TYPE_SCHEMA :(# exit     118 #);                     (* type's schema name *)
OCI_ATTR_TIMESTAMP   :(# exit     119 #);                (* timestamp of the object *)
OCI_ATTR_NUM_ATTRS   :(# exit     120 #);                   (* number of sttributes *)
OCI_ATTR_NUM_PARAMS  :(# exit     121 #);                   (* number of parameters *)
OCI_ATTR_OBJID       :(# exit     122 #);          (* object id for a table or view *)
OCI_ATTR_PTYPE       :(# exit     123 #);              (* type of info described by *)
OCI_ATTR_PARAM       :(# exit     124 #);                   (* parameter descriptor *)
OCI_ATTR_OVERLOAD_ID :(# exit     125 #);        (* overload ID for funcs and procs *)
OCI_ATTR_TABLESPACE  :(# exit     126 #);                       (* table name space *)
OCI_ATTR_TDO         :(# exit     127 #);                          (* TDO of a type *)
OCI_ATTR_LTYPE       :(# exit     128 #);                              (* list type *)
OCI_ATTR_PARSE_ERROR_OFFSET:(# exit 129 #);                   (* Parse Error offset *)
OCI_ATTR_IS_TEMPORARY:(# exit     130 #);             (* whether table is temporary *)
OCI_ATTR_IS_TYPED    :(# exit     131 #);                 (* whether table is typed *)
OCI_ATTR_DURATION    :(# exit     132 #);            (* duration of temporary table *)
OCI_ATTR_IS_INVOKER_RIGHTS:(# exit 133 #);                     (* is invoker rights *)
OCI_ATTR_OBJ_NAME    :(# exit     134		#);   (* top level schema obj name *)
OCI_ATTR_OBJ_SCHEMA  :(# exit     135			 #);         (* schema name *)
OCI_ATTR_OBJ_ID      :(# exit     136 #);             (* top level schema object id *)

OCI_ATTR_DIRPATH_SORTED_INDEX :(# exit   137 #);    (* index that data is sorted on *)
                                  (* direct path index maint method (see oci8dp.h) *)
OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD:(# exit 138 #);       (* parallel load: db file, initial and next extent sizes *)

OCI_ATTR_DIRPATH_FILE    :(# exit        139 #);            (* DB file to load into *)
OCI_ATTR_DIRPATH_STORAGE_INITIAL:(# exit 140 #);             (* initial extent size *)
OCI_ATTR_DIRPATH_STORAGE_NEXT:(# exit    141 #);                (* next extent size *)


OCI_ATTR_TRANS_TIMEOUT  :(# exit         142 #);             (* transaction timeout *)
OCI_ATTR_SERVER_STATUS	:(# exit	 143 #);         (* state of the server hdl *)
OCI_ATTR_STATEMENT      :(# exit         144 #);       (* statement txt in stmt hdl *)
                                      (* statement should not be executed in cache *)
OCI_ATTR_NO_CACHE       :(# exit         145 #); 
OCI_ATTR_RESERVED_1     :(# exit         146 #);       (* reserved for internal use *)
OCI_ATTR_SERVER_BUSY    :(# exit         147 #);     (* call in progress on server? *)


OCI_NTV_SYNTAX:(# exit 1 #);    (* Use what so ever is the native lang of server *)



(* input data types *)
SQLT_CHR:(# exit 1 #);                        (* (ORANET TYPE) character string *)
SQLT_NUM:(# exit 2 #);                          (* (ORANET TYPE) oracle numeric *)
SQLT_INT:(# exit 3 #);                                 (* (ORANET TYPE) integer *)
SQLT_FLT:(# exit 4 #);                   (* (ORANET TYPE) Floating point number *)
SQLT_STR:(# exit 5 #);                                (* zero terminated string *)
SQLT_VNU:(# exit 6 #);                        (* NUM with preceding length byte *)
SQLT_PDN:(# exit 7 #);                  (* (ORANET TYPE) Packed Decimal Numeric *)
SQLT_LNG:(# exit 8 #);                                                  (* long *)
SQLT_VCS:(# exit 9 #);                             (* Variable character string *)
SQLT_NON:(# exit 10 #);                      (* Null/empty PCC Descriptor entry *)
SQLT_RID:(# exit 11 #);                                                (* rowid *)
SQLT_DAT:(# exit 12 #);                                (* date in oracle format *)
SQLT_VBI:(# exit 15 #);                                 (* binary in VCS format *)
SQLT_BIN:(# exit 23 #);                                  (* binary data(DTYBIN) *)
SQLT_LBI:(# exit 24 #);                                          (* long binary *)
SQLT_UIN:(# exit 68 #);                                     (* unsigned integer *)
SQLT_SLS:(# exit 91 #);                        (* Display sign leading separate *)
SQLT_LVC:(# exit 94 #);                                  (* Longer longs (char) *)
SQLT_LVB:(# exit 95 #);                                  (* Longer long binary  *) 
SQLT_AFC:(# exit 96 #);                                      (* Ansi fixed char *)
SQLT_AVC:(# exit 97 #);                                        (* Ansi Var char *)
SQLT_CUR:(# exit 102 #);                                        (* cursor  type *)
SQLT_RDD:(# exit 104 #);                                    (* rowid descriptor *)
SQLT_LAB:(# exit 105 #);                                          (* label type *)
SQLT_OSL:(# exit 106 #);                                        (* oslabel type *)

SQLT_NTY:(# exit 108 #);                                   (* named object type *)
SQLT_REF:(# exit 110 #);                                            (* ref type *)
SQLT_CLOB:(# exit 112 #);                                      (* character lob *)
SQLT_BLOB:(# exit 113 #);                                         (* binary lob *)
SQLT_BFILEE:(# exit 114 #);                                  (* binary file lob *)
SQLT_CFILEE:(# exit 115 #);                               (* character file lob *)
SQLT_RSET:(# exit 116 #);                                    (* result set type *)
SQLT_NCO:(# exit 122 #);      (* named collection type (varray or nested table) *)
SQLT_VST:(# exit 155 #);                                      (* OCIString type *)
SQLT_ODT:(# exit 156 #);                                        (* OCIDate type *)

(* datetimes and intervals *)
SQLT_DATE:(# exit 184 #);                                          (* ANSI Date *)
SQLT_TIME:(# exit 185 #);                                               (* TIME *)
SQLT_TIME_TZ:(# exit 186 #);                             (* TIME WITH TIME ZONE *)
SQLT_TIMESTAMP:(# exit 187 #);                                     (* TIMESTAMP *)
SQLT_TIMESTAMP_TZ:(# exit 188 #);                   (* TIMESTAMP WITH TIME ZONE *)
SQLT_INTERVAL_YM:(# exit 189 #);                      (* INTERVAL YEAR TO MONTH *)
SQLT_INTERVAL_DS:(# exit 190 #);                      (* INTERVAL DAY TO SECOND *)
SQLT_TIMESTAMP_LTZ:(# exit 232 #);                   (* TIMESTAMP WITH LOCAL TZ *)

