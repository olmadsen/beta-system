ORIGIN '../betadbc_odbc';
INCLUDE 'sql'
        '~beta/basiclib/texthash'
        '~beta/sysutils/objinterface'
        '~beta/sysutils/cstring'
        '~beta/basiclib/formatio'
        '~beta/basiclib/numberio'
        '~beta/containers/dictionary'
        '~beta/containers/list'
        'patternparser';
LINKOPT nti_ms 'odbc32.lib' 'odbccp32.lib'
       nti_gnu 'libodbc32.a' 'libodbccp32.a'
       default '/usr/local/lib/libiodbc.so';
-- lib: Attributes --
DBEnv: (# henv: @integer; init: (#  <<SLOT DBEnvInit:DoPart>> #) #);
getHenv:
  (# env: ^DBEnv; rc: @int16
  do
     objectPool.get (# type:: DBEnv; init::  (#  do obj.init #) #)->env[]
  exit env.henv
  #);
integerToText:
  (# i: @integer; res: ^text
  enter i
  do &text[]->res[]; res.reset; i->res.putint
  exit res[]
  #);
realToText:
  (# r: @real; res: ^text
  enter r
  do &text[]->res[]; res.reset; r->res.putreal
  exit res[]
  #);
booleanToText:
  (# b: @boolean; res: ^text
  enter b
  do
     &text[]->res[];
     res.reset;
     (if b // true then 'true'->res[] // false then 'false'->res[] if)
  exit res[]
  #);
columnNoList: list (# element::< integerObject #);
shortIntToSigned: integerValue
  (# k: (* 8 bit unsigned half *) @shortInt
  enter k
  do k->value; (if value >= 32768 then - (65536-value)->value if)
  #);
getErrors:
  (#
     HandleType,Handle: @integer;
     Message: [0] ^text;
     SQLState: [0] ^text;
     NativeError: [0] @integer
  enter (HandleType,Handle)
  do
       (#
          MAX_ERROR: (#  exit 255 #);
          Sqlst: @cString;
          NativeErrorNo: @integer;
          MessageText: @cString;
          BufferLength: @shortint;
          TextLength: @shortint;
          henv,hdbc,hstmt: @integer;
          rc: @int16;
          succeeded: @boolean
       do
          (if HandleType
           // SQL_HANDLE_ENV then
              Handle->henv; SQL_NULL_HDBC->hdbc; SQL_NULL_HSTMT->hstmt
           // SQL_HANDLE_DBC then
              SQL_NULL_HENV->henv; handle->hdbc; SQL_NULL_HSTMT->hstmt
           // SQL_HANDLE_STMT then
              SQL_NULL_HENV->henv; SQL_NULL_HDBC->hdbc; handle->hstmt
          if);
          loop:
            (# 
            do
               6->Sqlst.init;
               MAX_ERROR->MessageText.init;
               (henv,hdbc,hstmt,Sqlst,@@ NativeErrorNo,MessageText,MAX_ERROR,@@
                TextLength)->SQLError->rc;
               (if (rc = SQL_SUCCESS) or (rc = SQL_SUCCESS_WITH_INFO) then
                   1->SQLState.extend;
                   Sqlst.get->Sqlstate[SqlState.range][];
                   1->NativeError.extend;
                   NativeErrorNo->NativeError[NativeError.range];
                   1->Message.extend;
                   MessageText.get->Message[Message.range][];
                   Sqlst.free;
                   MessageText.free;
                   true->succeeded
               if)
            #);
          (if not succeeded then
              1->Message.extend;
              '[BetaDBC: Get error message failed!]'->Message[1][]
          if)
       #)
  exit (Message,SQLState,NativeError)
  #);
trueText: (#  exit 'true' #);
falseText: (#  exit 'false' #)  

-- ConnectionClose: DoPart --
do
     (# 
     do
          (#
             twiceClose:
               (# msg: ^text;
               do
                  'Attempt to close '->msg;
                  THIS(Connection)[]->getPatternName->msg.append;
                  ' that is not open.'->msg.append;
                  (msg[], 0, 0)->closeException;
               #);
             checkError:
               (# 
               do
                  (if rc <> SQL_SUCCESS then
                      (none, SQL_HANDLE_DBC, THIS(Connection).private.hdbc)
                        ->closeException
                  if)
               #);
             rc: @int16
          do
             (if not THIS(Connection).private.isOpen then twiceClose if);
             THIS(Connection).private.hdbc->SQLDisconnect->rc;
             checkError;
             THIS(Connection).private.hdbc->SQLFreeConnect->rc;
             checkError;
             false->THIS(Connection).private.isOpen
          #)
     #);
   INNER  

-- ConnectionOpen: DoPart --
do
     (#
        twiceOpen: 
          (# msg:^text
          do
             'Attempt to open '->msg;
             THIS(Connection)[]->getPatternName->msg.append;
             ' twice.'->msg.append;
             (msg[], 0, 0)->openConnectionException;
          #);
        allocateHDBC:
          (# rc: @int16; henv: @integer
          enter henv
          do
             (henv,@@ THIS(connection).private.hdbc)->SQLAllocConnect->rc;
             (if rc <> SQL_SUCCESS then
                 (none, SQL_HANDLE_ENV, henv)->openConnectionException
             if)
          #);
        openConnection:
          (# rc: @int16; henv: @integer
          enter henv
          do
             (if true
              // userName[] = none // userName.empty then
                 (THIS(connection).private.hdbc,@@ name.t[1],SQL_NTS,0,0,0,0)
                   ->SQLConnect->rc
              // password[] = none // password.empty then
                 (THIS(connection).private.hdbc,@@ name.t[1],SQL_NTS,@@
                  userName.t[1],SQL_NTS,0,0)->SQLConnect->rc
              else
                 (THIS(connection).private.hdbc,@@ name.t[1],SQL_NTS,@@
                  userName.t[1],SQL_NTS,@@ passWord.t[1],SQL_NTS)->SQLConnect
                   ->rc
             if);
             (if rc = SQL_SUCCESS then
                 true->THIS(connection).private.isOpen
              else
                 (none, SQL_HANDLE_DBC, THIS(connection).private.hdbc)
                   ->openConnectionException
             if)
          #);
        setAutoCommitMode:
          (# rc: @int16
          do
             (THIS(Connection).private.hdbc,SQL_ATTR_AUTOCOMMIT,
              SQL_AUTOCOMMIT_ON)->SQLSetConnectOption->rc;
             (if rc = SQL_SUCCESS then
                 true->THIS(connection).private.isOpen
              else
                 (none, SQL_HANDLE_DBC, THIS(connection).private.hdbc)
                   ->openConnectionException
             if)
          #);
        setResultSetCapabilities:
          (# rc: @int16
          do
          (*(private.hdbc,SQL_ATTR_ODBC_CURSORS,SQL_CUR_USE_ODBC,0)
           ->SQLSetConnectAttr->rc;*)
             (if rc <> SQL_SUCCESS then
                 (none, SQL_HANDLE_DBC, THIS(connection).private.hdbc)
                   ->openConnectionException
             if)
          #)
     do
        (if name[] = none then
            ('Name of connection is none in Open Connection',0,0) -> openConnectionException;
        if);
        (if THIS(connection).private.isOpen then
            twiceOpen
         else
            getHenv->allocateHDBC
        if);
        setResultSetCapabilities;
        getHenv->openConnection;
        setAutoCommitMode
     #);
   INNER  

-- DBEnvBDBCException: DoPart --
do
   THIS(exception)[]->getPatternName->msg.putLine;
     (# Messages,SQLStates: [0] ^text; NativeErrors: [0] @integer
     do
        (if (KnownErrorMsg[] = NONE) or (KnownErrorMsg.length = 0) then
            (HandleType,Handle)->getErrors->(Messages,SQLStates,NativeErrors);
            (for i: Messages.range repeat
                 Messages[i][]->msg.append; msg.newline
            for);
            (for i: SQLStates.range repeat
                 (if i > 1 then ','->SqlState.append if); SQLStates[i][]->msg.append
            for);
            (for i: NativeErrors.range repeat
                 (if i > 1 then ','->NativeError.append if);
                 NativeErrors[i]->msg.putint
            for);
         else 
            KnownErrorMsg[] -> msg.append;
        if);
     #);
   INNER  

-- DirectSQLStatementExecute: DoPart --
do
     (# rc: @int16; cont: ^text
     do
        getExpanded->cont[];
        (THIS(SQLStatement).private.hstmt,cont.t,SQL_NTS)->SQLExecDirect->rc;
        (if (rc = SQL_SUCCESS) or (rc<-1000000) then            
         else
            (if rc = SQL_SUCCESS_WITH_INFO then
                (none, SQL_HANDLE_STMT,THIS(SQLStatement).private.hstmt)
                  ->execDirectNotification
             else
                (none, SQL_HANDLE_STMT, THIS(SQLStatement).private.hstmt)
                  ->execDirectException
            if)
        if);
        1->currentMarker
     #)  

-- SQLStatementPrivate: Descriptor --
(#
   t: ^text;
   hstmt: @integer;
   isOpen: @boolean;
   theResultSet: @
   (* Assertion: A connected resultSet is (and should) only dropped via
    * - close of a statement, or
    * - re-execution of a statement
    *)
     (#
        ref: ^resultSet;
        exists: @boolean;
        set:
          (# 
          enter ref[]
          do (if ref[] <> none then true->exists else false->exists if)
          #);
        assertClosed: (#  do (if exists then close if) #);
        close:
          (# rc: @int16
          do
             (private.hstmt,SQL_CLOSE)->SQLFreeStmt->rc;
             (if rc <> SQL_SUCCESS then
                 (none, SQL_HANDLE_STMT,private.hstmt)->SQLStatementException
             if);
             false->exists;
             none ->ref[]
          #)
     #);
   assertNotOpened:
     (# 
     do
        (if isOpen then
            ('Attempt to open SQLStatement twice',0,0)->SQLStatementException;
        if)
     #);
   assertOpen:
     (# 
     do
        (if not isOpen then
            ('Attempt to use SQLStatement before calling open',0,0)->SQLStatementException;
        if)
     #);
   assertSet:
     (# 
     do
        (if t[] = none then
            ('Attempt to execute SQLStatement before set',0,0)->SQLStatementException;
        if)
     #)
#)  

-- SQLStatementGet: DoPart --
do private.t[]->t[]; INNER get  

-- SQLStatementSet: DoPart --
do
   private.assertOpen;
   (if t[] = none then &text[]->private.t[] else t.copy->private.t[] if);
   INNER set  

-- SQLStatementExecute: DoPart --
do
     (#
        tempStmtText: ^text;
        value: ^text;
        rc: @int16;
        theCursor: @cursorType
     do
        private.assertSet;
        private.theResultSet.assertClosed;
        (if (theCursor.name->value[]) <> none then
              (# rc,NameLengthPtr: @shortint
              do
                 (private.hstmt,@@ value.t[1],value.length)->SQLSetCursorName
                   ->rc;
                 (if rc
                  // SQL_SUCCESS then
                     
                  // SQL_SUCCESS_WITH_INFO then
                     (none, private.hstmt, SQL_HANDLE_STMT)->SQLStatementNotification
                  else
                     (none, private.hstmt, SQL_HANDLE_STMT)->SQLStatementException
                 if)
              #)
        if);
        (if theCursor.insensitive then
            (private.hstmt,SQL_ATTR_CURSOR_SENSITIVITY,SQL_INSENSITIVE)
              ->SQLSetStmtOption
         else
            (private.hstmt,SQL_ATTR_CURSOR_SENSITIVITY,SQL_SENSITIVE)
              ->SQLSetStmtOption
        if);
        (if not theCursor.readOnly then
            private.t[]->tempStmtText[];
            private.t.copy->private.t[];
            ' FOR UPDATE OF *'->private.t.append
        if);
        (if theCursor.scrollable then
            (private.hstmt,SQL_ATTR_CURSOR_TYPE,SQL_CURSOR_DYNAMIC)
              ->SQLSetStmtOption->rc;
            (if rc
             // SQL_SUCCESS then
                
             // SQL_SUCCESS_WITH_INFO then
                (none, SQL_HANDLE_STMT, private.hstmt)->SQLStatementNotification
             else
                (none, SQL_HANDLE_STMT, private.hstmt)->SQLStatementException
            if)
        if);
        &resultSetType[]->res[];
        private.hstmt->res.private.hstmt;
        INNER execute;
        res[]->private.theResultSet.set;
        (if not theCursor.readOnly then tempStmtText[]->private.t[] if)
     #)  

-- SQLStatementClose: DoPart --
do
     (# rc: @int16
     do
        private.theResultSet.assertClosed;
        (private.hstmt,SQL_CLOSE)->SQLFreeStmt->rc;
        (if rc <> SQL_SUCCESS then
            (none, SQL_HANDLE_DBC, THIS(Connection).private.hdbc)
              ->SQLStatementException
        if);
        false->private.isOpen;
        none ->private.t[]
     #)  

-- ResultSetInfoNoOfCols: DoPart --
do
     (# rc: @int16; theValue: @shortint
     do
        (private.hstmt,@@ theValue)->SQLNumResultCols->rc;
        (rc,private.hstmt)->private.checkError;
        theValue->value
     #)  

-- ResultSetInfoRowCount: DoPart --
do
     (# rc: @int16
     do
        (private.hstmt,@@ value)->SQLRowCount->rc;
        (rc,private.hstmt)->private.checkError
     #)  

-- ResultSetInfoGetColumnInfo: DoPart --
do i->private.theColInfos.getInfoByNo->res[]  

-- resultSetGetColumnByNameNameNotFound: DoPart --
do
   '\''->msg.append;
   name[]->msg.append;
   '\' not found in resultSet columns'->msg.append;
   msg.newline;
   INNER  

-- ResultSetInfogetColumnInfoByName: DoPart --
do
   name[]
     ->private.theColInfos.getInfoByName
       (#
          notFound:: 
            (# propagate::  (#  do true->value #) do nameNotFound #)
       #)->res[]  

-- textlib: Attributes --
findDelimited:
(* For txt:@text, txt.length = n, txt.pos = k, finds startPos and endPos such that
 *       txt[startPos]->start, for 1 <= i < startPos: not txt[i]->start
 *       txt[endPos+1]->end or endPos = n, for startPos < i <= endPos: not txt[i]->end
 * If for 1 <= i <= n: not txt[i]->start then endPos =0
 *)
  (#
     checkChar: booleanValue (# ch: @char enter ch do INNER #);
     start:< checkChar;
     end:< checkChar;
     startPos,endPos: @integer;
     started: @boolean
  do
     L: scan
       (# 
       do
          (if started then
              (if ch->end then pos-1->pos->endPos; false->started; leave L if)
           else
              (if ch->start then pos->startPos; true->started if)
          if)
       #);
     (if started then pos->endPos if);
     INNER
  exit (startPos,endPos)
  #);
findVars: findDelimited
  (#
     isVarChar: booleanValue
       (# ch: @char
       enter ch
       do ((ch->ascii.isDigit) or (ch->ascii.isLetter))->value; INNER
       #)
  do INNER
  #);
findName: findVars
  (#
     start::  (#  do (ch->ascii.isLetter)->value #);
     end::  (#  do (not (ch->isVarChar))->value #)
  #);
findVar: findVars
  (#
     isBetaVarChar: booleanValue
       (# ch: @char enter ch do ((ch->isVarChar) or (ch = '_'))->value #);
     start::  (#  do ((ch = ':') or (ch = '%'))->value #);
     end::  (#  do (not (ch->isBetaVarChar))->value #)
  #);
findMarker: findDelimited
  (#
     start::  (#  do (ch = '%')->value #);
     end::  (#  do (pos = startPos+1)->value #)
  #)  

-- resultSetScan: DoPart --
do
   L:
     (# 
     do
        pattern[]
          ->set
            (#
               varNotDeclared:: 
                 (# propagate::  (#  do true->value #)
                 do name[]->THIS(set).varNotDeclared
                 #);
               columnNotFound:: 
                 (# propagate::  (#  do true->value #)
                 do name[]->THIS(set).columnNotFound
                 #)
            #);
        fetch->current[];
        (if not (current[] = EOT) then INNER scan; restart L if)
     #)  

-- resultSetSet: DoPart --
do
     (# 
     do
        pattern[]
          ->private.p.parseResultSetPatternString
            (#
               varNotDeclared::  (#  do name[]->THIS(set).varNotDeclared #);
               columnNotFound::  (#  do name[]->THIS(set).columnNotFound #)
            #)
     #)  

-- DirectSQLStatementPrivate: Descriptor --
(#
   statement: @
     (#
        noStatement:
          (# 
          do ('Attempt to use DirectSQLStatement before calling set',0,0)->SQLStatementException;
          #);
        elm: ^PatternParser.StatementPattern;
        set: (#  enter elm[] #);
        get: (#  do (if elm[] = none then noStatement if) exit elm[] #)
     enter set
     exit get
     #);
   p: @PatternParser
     (#
        interpretNode: NodeVisitor
          (#
             t: ^text;
             visitVariable:: 
               (# var: ^declareVar
               do
                  (elm.value[]->THIS(connection).private.declareVars.lookup).
                  getAsText->t.puttext
               #);
             visitPlaceholder:: 
               (# 
               do
                  (if elm.mark = 's' then '\''->t.puttext if);
                  elm.value[]->t.puttext;
                  (if elm.mark = 's' then '\''->t.puttext if)
               #);
             visitStatementString::  (#  do elm.value[]->t.append #);
             theNode: ^node
          enter theNode[]
          do &text[]->t[]; THIS(visitor)[]->theNode.accept
          exit t[]
          #);
        setCurrentMarker: NodeVisitor
          (#
             visitPlaceholder:: 
               (# 
               do count+1->count; (if count = no then t[]->elm.value[] if)
               #);
             theNode: ^node;
             t: ^text;
             no: @integer;
             count: @integer
          enter (theNode[],t[],no)
          do THIS(visitor)[]->theNode.accept
          #);
        setPlaceholderByName: NodeVisitor
          (#
             visitNamedSpecifier:: 
               (# 
               do
                  (if name[]->elm.theNameDecl.value.equalNCS then
                      true->found->wasFound
                  if)
               #);
             visitVariable:: 
               (# 
               do
                  (if found then
                      t[]
                        ->
                          (
                          elm.value[]
                            ->THIS(connection).private.declareVars.lookup).
                          setAsText;
                      false->found
                  if)
               #);
             visitPlaceholder:: 
               (# 
               do (if found then t[]->elm.value[]; false->found if)
               #);
             found,wasFound: @boolean;
             theNode: ^node;
             name,t: ^text;
             nameNotFound:< object
          enter (theNode[],name[],t[])
          do
             THIS(visitor)[]->theNode.accept;
             (if not wasFound then nameNotFound if)
          #);
        parseStatementPatternString:: 
          (#
             checkDeclaredVars: NodeVisitor
               (#
                  visitVariable:: 
                    (# 
                    do
                       (if not
                       (elm.value[]
                          ->THIS(connection).private.declareVars.exists) then
                           elm.value[]->varNotDeclared
                       if)
                    #);
                  theNode: ^node
               enter theNode[]
               do THIS(visitor)[]->theNode.accept
               #);
             varNotDeclared:< (# name: ^text enter name[] do INNER #)
          do res[]->statement->checkDeclaredVars
          #)
     #);
   currentMarkerNo: @integer;
   getExpanded: (#  exit statement->p.interpretNode #);
   setCurrentMarker:
     (# value: ^text
     enter value[]
     do (statement,value[],currentMarkerNo)->p.setCurrentMarker
     #);
   setPlaceholderByName:
     (# name,value: ^text; nameNotFound:< object
     enter (name[],value[])
     do
        (statement,name[],value[])
          ->p.setPlaceholderByName
            (#
               nameNotFound:: 
                 (#  do THIS(setPlaceholderByName).nameNotFound #)
            #)
     #)
#)  

-- ConnectionPrivate: Descriptor --
(#
   hdbc: @integer;
   isOpen: @boolean;
   declareVars: @dictionary
     (#
        key:: text;
        keyEqual::  (#  do left[]->right.equalNCS->value #);
        element:: declareVar;
        assertInitialised:
          (# 
          do
             (if not private.initialised then
                 init; true->private.initialised
             if)
          #);
        init::  (#  do private.h.init #);
        hashFunction::  (#  do k[]->private.h.hash->value #);
        exists: booleanValue
          (# name: ^text
          enter name[]
          do ((name[]->lookup) <> none )->value
          #);
        private: @ (# initialised: @boolean; h: @honeyman #)
     #);
   checkError:
     (# rc: @int16; hdbc: @integer
     enter (rc,hdbc)
     do
        (if rc <> SQL_SUCCESS then
            (if rc = SQL_SUCCESS_WITH_INFO then
                (none, SQL_HANDLE_DBC, hdbc)->connectionNotification
             else
                (none, SQL_HANDLE_DBC, hdbc)->connectionException
            if)
        if)
     #);
   MAX_COL_TXT: (*Initial upper bound for texts *) (#  exit 256 #);
   SQLTypeToPattern:
     (# DataType: @integer; Pattern: ##Object
     enter DataType
     do
        (if DataType
         // SQL_CHAR // SQL_VARCHAR // SQL_LONGVARCHAR then
            text##->Pattern##
         // SQL_DECIMAL then
            Text##->Pattern##
         // SQL_NUMERIC then
            Text##->Pattern##
         // SQL_INTEGER // SQL_SMALLINT then
            integerObject##->Pattern##
         // SQL_REAL // SQL_FLOAT // SQL_DOUBLE then
            realObject##->Pattern##
         // SQL_BIT then
            booleanObject##->Pattern##
         // SQL_TINYINT then
            charObject##->Pattern##
         // SQL_BIGINT // SQL_BINARY // SQL_VARBINARY // SQL_LONGVARBINARY then
            text##->Pattern##
         // SQL_TIME // SQL_DATETIME // SQL_TIMESTAMP then
            time##->Pattern##
         // SQL_UNKNOWN_TYPE then (* Text can be anything in ODBC *)
            text##->Pattern##
        if)
     exit Pattern##
     #)
#)  

-- DBEnvInit: DoPart --
do
     (# rc: @int16
     do
        @@ henv->SQLAllocEnv->rc;
        (* (SQL_HANDLE_ENV,SQL_NULL_HANDLE,@@ henv)->SQLAllocHandle->rc;
         (henv,SQL_ATTR_ODBC_VERSION,SQL_OV_ODBC3,0)->SQLSetEnvAttr->rc; *)
        (if rc <> SQL_SUCCESS then
            ('Fatal error: Failed to allocate environment for connection',0,0)->betaDBCexception;
        if)
     #)  

-- resultSetResultPrivate: Descriptor --
(#
   currentMarkerNo: @integer;
   elm: ^columnNoList.theCellType;
   getByNo:
     (# i: @integer; rc: @int16; enterEvaluated: @boolean
     enter (#  enter i do true->enterEvaluated #)
     do
        (if not enterEvaluated then
            currentMarkerNo->THIS(resultSet).private.getColumnNoFromMarker->i
        if);
        INNER getByNo;
        (rc,THIS(resultSet).private.hstmt)->checkError
     #);
   getInteger: getByNo
     (# StrLen_or_IndPtr: @integer; res: @integer
     do
        (THIS(resultSet).private.hstmt,i,SQL_INTEGER,@@ res,4,@@
         StrLen_or_IndPtr)->SQLGetData->rc
     exit res
     #);
   getText: getByNo
     (# res: ^text; target: @cString; StrLen_or_IndPtr: @integer
     do
        &text[]->res[];
        THIS(Connection).private.MAX_COL_TXT->target.init;
        L:
          (# 
          do
             (THIS(resultSet).private.hstmt,i,SQL_CHAR,target,
              THIS(Connection).private.MAX_COL_TXT,@@ StrLen_or_IndPtr)
               ->SQLGetData->rc;
             (if rc
              // SQL_SUCCESS // SQL_SUCCESS_WITH_INFO then
                 target.get->res.append;
                 (if StrLen_or_IndPtr < THIS(connection).private.MAX_COL_TXT
                  then
                     leave L
                  else
                     restart L
                 if)
              // SQL_NO_DATA then
                 leave L
              else
                 (none, THIS(resultSet).private.hstmt, SQL_HANDLE_STMT)
                   ->resultSetException
             if)
          #);
        target.free;
        res.reset
     exit res[]
     #);
   getBoolean: getByNo
     (# StrLen_or_IndPtr: @integer; tmp: @integer; res: @boolean
     do
        (THIS(resultSet).private.hstmt,i,SQL_INTEGER,@@ tmp,4,@@
         StrLen_or_IndPtr)->SQLGetData->rc;
        (if tmp <> 0 then true->res if)
     exit res
     #);
   getReal: getByNo
     (# StrLen_or_IndPtr: @integer; res: @real
     do
        (THIS(resultSet).private.hstmt,i,SQL_DOUBLE,@@ res,4,@@
         StrLen_or_IndPtr)->SQLGetData->rc
     exit res
     #);
   getClock: getByNo
     (# StrLen_or_IndPtr: @integer; extRes: @TIME_STRUCT; res: @time
     do
        sizeOfTIME_STRUCT->malloc->extRes.ptr;
        (if extRes.ptr <> 0 then
            (THIS(resultSet).private.hstmt,i,SQL_TIME,extRes.ptr,
             sizeOfTIME_STRUCT,@@ StrLen_or_IndPtr)->SQLGetData->rc;
            extRes.hour->res.hour;
            extRes.minute->res.minute;
            extRes.second->res.sec;
            extRes.ptr->free
         else
            ('malloc exhausted: Failed to allocate TIME_STRUCT',0,0)->betaDBCexception;
        if)
     exit res
     #);
   getDate: getByNo
     (# StrLen_or_IndPtr: @integer; extRes: @DATE_STRUCT; res: @time
     do
        sizeOfDATE_STRUCT->malloc->extRes.ptr;
        (if extRes.ptr <> 0 then
            (THIS(resultSet).private.hstmt,i,SQL_DATE,extRes.ptr,
             sizeOfDATE_STRUCT,@@ StrLen_or_IndPtr)->SQLGetData->rc;
            extRes.year->res.year;
            extRes.month->res.month;
            extRes.day->res.day;
            extRes.ptr->free
         else
            ('malloc exhausted: Failed to allocate DATE_STRUCT',0,0)->betaDBCexception;
        if)
     exit res
     #);
   getTime: getByNo
     (# StrLen_or_IndPtr: @integer; extRes: @TIMESTAMP_STRUCT; res: @time
     do
        sizeOfTIMESTAMP_STRUCT->malloc->extRes.ptr;
        (if extRes.ptr <> 0 then
            (THIS(resultSet).private.hstmt,i,SQL_TIMESTAMP,extRes.ptr,
             sizeOfTIMESTAMP_STRUCT,@@ StrLen_or_IndPtr)->SQLGetData->rc;
            extRes.year->res.year;
            extRes.month->res.month;
            extRes.day->res.day;
            extRes.hour->res.hour;
            extRes.minute->res.minute;
            extRes.second->res.sec;
            extRes.ptr->free
         else
            ('malloc exhausted: Failed to allocate TIMESTAMP_STRUCT',0,0)->betaDBCexception;
        if)
     exit res
     #);
   checkError:
     (# rc: @int16; hstmt: @integer
     enter (rc,hstmt)
     do
        (if rc <> SQL_SUCCESS then
            (if rc = SQL_SUCCESS_WITH_INFO then
                (none, SQL_HANDLE_STMT, hstmt)->resultSetNotification
             else
                (none, SQL_HANDLE_STMT, hstmt)->resultSetException
            if)
        if)
     #)
#)  

-- resultSetCursorName: DoPart --
do
     (#
        getName:
          (#
             length: @integer;
             ResultSetName: @cString;
             NameLengthPtr: @integer;
             rc: @int16
          enter length
          do
             &text[]->value[];
             length->ResultSetName.init;
             L:
               (# 
               do
                  (private.hstmt,ResultSetName,length,@@ NameLengthPtr)
                    ->SQLGetCursorName->rc;
                  (if rc
                   // SQL_SUCCESS // SQL_SUCCESS_WITH_INFO then
                      ResultSetName.get->value.append
                   else
                  (*    (none, THIS(ResultSet).private.hstmt,SQL_HANDLE_STMT)
                   ->resultSetException *)
                      
                  if)
               #);
             ResultSetName.free;
             value.reset
          exit NameLengthPtr
          #);
        realLength: @integer
     do
        THIS(connection).private.MAX_COL_TXT->GetName->realLength;
        (if realLength > THIS(connection).private.MAX_COL_TXT then
            realLength+1->GetName
        if)
     #)  

-- resultSetTupleMarker: DoPart --
do private.currentMarkerNo+1->private.currentMarkerNo; INNER  

-- resultSetTupleI: DoPart --
do private.getInteger->value  

-- resultSetTupleR: DoPart --
do private.getReal->value  

-- resultSetTupleS: DoPart --
do private.getText->value[]  

-- resultSetTupleB: DoPart --
do private.getBoolean->value  

-- ConnectionDeclareVar: DoPart --
do
   private.declareVars.assertInitialised;
   (varName[],THIS(declareVar)[])->private.declareVars.associate;
   INNER  

-- resultSetFetch: DoPart --
do
     (# rc: @int16
     do
        THIS(resultSet).private.hstmt->SQLFetch->rc;
        (if rc
         // SQL_SUCCESS then
            private.setData->result[]
         // SQL_NO_DATA then
            EOT->result[]
         // SQL_SUCCESS_WITH_INFO then
            (none, SQL_HANDLE_STMT,THIS(resultSet).private.hstmt)
              ->resultSetNotification
         else
            (none, SQL_HANDLE_STMT, THIS(resultSet).private.hstmt)->resultSetException
        if);
        INNER fetch
     #)  

-- resultSetEOT: DoPart --
do private.EOT[]->value[]  

-- ResultSetPrivate: Descriptor --
(#
   hstmt: @integer;
   EOT: @tuple;
   p: @PatternParser
     (#
        setData: NodeVisitor
          (#
             isNamed: @boolean;
             name: ^text;
             columnNo: @integer;
             resultSetPtn: ^ResultSetPattern;
             visitNameDecl::  (#  do true->isNamed; elm.value[]->name[] #);
             visitVariable:: 
               (#
                  setValueByNumber:
                    (#
                       i: ^declareInteger;
                       s: ^declareText;
                       r: ^declareReal;
                       b: ^declareBoolean;
                       c: ^declareClock;
                       d: ^declareDate;
                       t: ^declareTime;
                       var: ^declareVar;
                       columnNo: @integer
                    enter (var[],columnNo)
                    do
                       (if true
                        // var## <= declareInteger## then
                           var[]->i[];
                           columnNo->result.private.getInteger->i.set
                        // var## <= declareReal## then
                           var[]->r[]; columnNo->result.private.getReal->r.set
                        // var## <= declareText## then
                           var[]->s[]; columnNo->result.private.getText->s.set
                        // var## <= declareBoolean## then
                           var[]->b[];
                           columnNo->result.private.getBoolean->b.set
                        // var## <= declareClock## then
                           var[]->c[]; columnNo->result.private.getClock->c.set
                        // var## <= declareDate## then
                           var[]->d[]; columnNo->result.private.getDate->d.set
                        // var## <= declareTime## then
                           var[]->t[]; columnNo->result.private.getTime->t.set
                        else
                           ('Unknown datatype in scan',0,0)->resultSetException;
                       if)
                    #);
                  setValueByName:
                    (# var: ^declareVar; name: ^text
                    enter (var[],name[])
                    do
                       (var[],name[]->theColInfos.getColumnByName)
                         ->setValueByNumber
                    #);
                  var: ^declareVar
               do
                  columnNo+1->columnNo;
                  elm.value[]->THIS(connection).private.declareVars.lookup
                    ->var[];
                  (if isNamed then
                      (var[],name[])->setValueByName
                   else
                      (var[],columnNo)->setValueByNumber
                  if)
               #);
             visitPlaceHolder::  (#  do columnNo+1->columnNo #);
             result: ^tuple
          enter resultSetPtn[]
          do &tuple[]->result[]; THIS(Visitor)[]->resultSetPtn.accept
          exit result[]
          #);
        getColumnNoFromMarker: NodeVisitor
          (#
             isNamed: @boolean;
             name: ^text;
             markerNo,currentMarkerNo,columnNo,currentColumnNo: @integer;
             visitNameDecl::  (#  do true->isNamed; elm.value[]->name[] #);
             visitVariable::  (#  do currentColumnNo+1->currentColumnNo #);
             visitPlaceHolder:: 
               (# 
               do
                  currentColumnNo+1->currentColumnNo;
                  currentMarkerNo+1->currentMarkerNo;
                  (if currentMarkerNo = markerNo then
                      (if isNamed then
                          name[]->theColInfos.getColumnByName->columnNo
                       else
                          currentColumnNo->columnNo
                      if)
                  if)
               #);
             resultSetPtn: ^ResultSetPattern
          enter (markerNo,resultSetPtn[])
          do markerNo->columnNo; THIS(Visitor)[]->resultSetPtn.accept
          exit columnNo
          #);
        parseResultSetPatternString:: 
          (#
             checkIt: NodeVisitor
               (#
                  visitNameDecl:: 
                    (# 
                    do
                       elm.value[]
                         ->getColumnByName
                           (#
                              nameNotFound:: 
                                (# propagate::  (#  do true->value #)
                                do name[]->columnNotFound
                                #)
                           #)
                    #);
                  visitVariable:: 
                    (# 
                    do
                       (if not
                       (elm.value[]
                          ->THIS(connection).private.declareVars.exists) then
                           elm.value[]->varNotDeclared
                       if)
                    #);
                  theNode: ^node
               enter theNode[]
               do THIS(visitor)[]->theNode.accept
               #);
             varNotDeclared:< (# name: ^text enter name[] do INNER #);
             columnNotFound:< (# name: ^text enter name[] do INNER #)
          do res[]->resultSetPtn->checkIt
          #)
     #);
   resultSetPtn: @
     (#
        noResultSetPtn:
          (# 
          do ('Attempt to use pattern in resultSet before setting it',0,0)->resultSetException;
          #);
        elm: ^PatternParser.ResultSetPattern;
        set: (#  enter elm[] #);
        get:
          (# 
          do (if elm[] = none then THIS(resultSet).set if)
          exit elm[]
          #)
     enter set
     exit get
     #);
   theColInfos: @
     (#
        elms: [0] ^Column;
        isInitialised: @boolean;
        assertInitialised:
          (# rc1,rc2: @shortint
          do
             (if not isInitialised then
                 init->(rc1,rc2);
                 (rc1,SQL_HANDLE_STMT)->checkError;
                 (rc2,SQL_HANDLE_STMT)->checkError
             if)
          #);
        getColumnByName:
          (# name: ^text; res: @integer
          enter name[]
          do
             assertInitialised;
             L:
             (for j: elms.range repeat
               (if elms[j].name[]->name.equalNCS then j->res; leave L if)
             for)
          exit res
          #);
        getInfoByName:
          (# name: ^text; res: ^column; col: @integer; notFound:< exception
          enter name[]
          do
             name[]->getColumnByName->col;
             (if col = 0 then notFound else col->getInfoByNo->res[] if)
          exit res[]
          #);
        getInfoByNo:
          (# i: @integer enter i do assertInitialised exit elms[i][] #);
        init:
          (#
             ColumnName: @cString;
             NameLength: @shortint;
             DataType: @shortint;
             DataTypeS: @integer;
             ColumnSize: @integer;
             DecimalDigits: @shortint;
             NullAble: @shortint;
             ColumnNo: @shortint;
             ColumnTypeName: @cString;
             StringLengthPtr: @shortint;
             rc1,rc2: @shortint;
             theInfo: ^column
          do
             columnCount->elms.new;
             (for i: elms.range repeat
               &column[]->theInfo[];
               THIS(Connection).Private.MAX_COL_TXT->ColumnName.init;
               i->ColumnNo;
               (hstmt,ColumnNo,ColumnName,THIS(Connection).Private.MAX_COL_TXT,
                @@ NameLength,@@ DataType,@@ ColumnSize,@@ DecimalDigits,@@
                NullAble)->SQLDescribeCol->rc1;
               ColumnName.get->theInfo.name[];
               ColumnName.free;
               ColumnNo->theInfo.no;
               DataType-> (* SIC! *) shortIntToSigned->DataTypeS;
               DataTypeS->THIS(Connection).private.SQLTypeToPattern
                 ->theInfo.DataType##;
               (if NullAble <> 0 then true->theInfo.NullAble if);
               THIS(Connection).Private.MAX_COL_TXT->ColumnTypeName.init;
               (hstmt,ColumnNo,SQL_DESC_TYPE_NAME,ColumnTypeName,
                THIS(Connection).Private.MAX_COL_TXT,@@ StringLengthPtr,NULL)
                 ->SQLColAttributes->rc2;
               ColumnTypeName.get->theInfo.DataTypeName[];
               ColumnTypeName.free;
               theInfo[]->elms[i][]
             for);
             true->isInitialised
          exit (rc1,rc2)
          #)
     #);
   checkError:
     (# rc: @int16; hstmt: @integer
     enter (rc,hstmt)
     do
        (if rc <> SQL_SUCCESS then
            (if rc = SQL_SUCCESS_WITH_INFO then
                (none, SQL_HANDLE_STMT, hstmt)->resultSetNotification
             else
                (none, SQL_HANDLE_STMT, hstmt)->resultSetException
            if)
        if)
     #);
   getColumnNoFromMarker: integerValue
     (# markerNo: @integer
     enter markerNo
     do (markerNo,resultSetPtn)->p.getColumnNoFromMarker->value
     #);
   setData: (#  exit resultSetPtn->p.setData #)
#)  

-- DirectSQLStatementSet: DoPart --
do
   THIS(SQLStatement).private.t.reset;
   THIS(SQLStatement).private.t[]
     ->private.p.parseStatementPatternString
       (# varNotDeclared::  (#  do name[]->THIS(set).varNotDeclared #)
       #);
   1->private.currentMarkerNo;
   INNER  

-- DirectSQLStatementCurrentMarkerSet: DoPart --
do no->private.currentMarkerNo;   

-- directSQLStatemenCurrentMarkerGet: DoPart --
do private.currentMarkerNo->no  

-- directSQLStatementMarker: DoPart --
do
   &text[]->t[];
   INNER ;
   t[]->private.setCurrentMarker;
   private.currentMarkerNo+1->private.currentMarkerNo  

-- directSQLStatementI: DoPart --
do value->t.putint  

-- directSQLStatementF: DoPart --
do value->t.putreal  

-- directSQLStatementS: DoPart --
do value[]->t.append  

-- directSQLStatementB: DoPart --
do (if value then trueText->t else falseText->t if)  

-- directSQLStatementGetExpanded: DoPart --
do private.getExpanded->value[]  

-- directSQLStatementC: DoPart --
do value->formatClock->t.puttext  

-- directSQLStatementD: DoPart --
do value->formatDate->t.puttext  

-- directSQLStatementT: DoPart --
do value->formatTime->t.puttext  

-- resultSetTupleD: DoPart --
do private.getDate->value  

-- resultSetTupleC: DoPart --
do private.getClock->value  

-- resultSetTupleT: DoPart --
do private.getTime->value  

-- resultSetScanVarNotDeclared: DoPart --
do
   'Variable named \''->msg.append;
   name[]->msg.append;
   '\' not declared in this connection'->msg.append;
   INNER  

-- resultSetScanUnknownColumn: DoPart --
do
   'Unknown column: \''->msg.append;
   name[]->msg.append;
   '\' is not in the resultSet'->msg.append;
   INNER  

-- declareVarSetAsText: DoPart --
do INNER  

-- declareVarGetAsText: DoPart --
do &text[]->value[]; INNER  

-- declareIntegerSet: DoPart --
do INNER  

-- declareIntegerSetAsText: DoPart --
do value.reset; value.getInt->set; INNER  

-- declareIntegerGetAsText: DoPart --
do value.clear; get->value.putInt; INNER  

-- declareRealSetAsText: DoPart --
do value.reset; value.getReal->set; INNER  

-- declareRealGetAsText: DoPart --
do value.clear; get->value.putReal; INNER  

-- declareTextSetAsText: DoPart --
do value[]->set; INNER  

-- declareTextGetAsText: DoPart --
do '\''->value.puttext; get->value.puttext; '\''->value.puttext; INNER  

-- declareBooleanSetAsText: DoPart --
do (if 'true'->value.equalNCS then true->set else false->set if); INNER  

-- declareBooleanGetAsText: DoPart --
do (if get then 'true'->value[] else 'false'->value[] if); INNER  

-- declareTimeSetAsText: DoPart --
do value.reset; value.getTime->set; INNER  

-- declareTimeGetAsText: DoPart --
do value.clear; get->formatTime->value.putText; INNER  

-- directSQLStatementSetByNameNameNotFound: DoPart --
do
   INNER ;
   'Cannot find placeholder with name \''->msg;
   name[]->msg.append;
   '\''->msg.put  

-- directSQLStatementSetByName: DoPart --
do
   &text[]->t[];
   INNER ;
   (name[],t[])
     ->private.setPlaceholderByName
       (# nameNotFound::  (#  do THIS(setByName).nameNotFound #) #)  

-- directSQLStatementSetBooleanByName: DoPart --
do (if value then trueText->t else falseText->t if)  

-- directSQLStatementSetClockByName: DoPart --
do value->formatClock->t.puttext  

-- directSQLStatementSetDateByName: DoPart --
do value->formatDate->t.puttext  

-- directSQLStatementSetFloatByName: DoPart --
do value->t.putreal  

-- directSQLStatementSetIntegerByName: DoPart --
do value->t.putint  

-- directSQLStatementSetTextByName: DoPart --
do value[]->t.append  

-- directSQLStatementSetTimeByName: DoPart --
do value->formatTime->t.puttext  

-- directSQLStatementSetVarNotDeclared: DoPart --
do
   'Variable \''->msg.append;
   name[]->msg.append;
   '\''->msg.append;
   ' used in DirectSQLStatement not declared'->msg.append;
   msg.putline;
   INNER  

-- SQLStatementOpen: DoPart --
do
     (# rc: @int16
     do
        private.assertNotOpened;
        (if not THIS(Connection).private.isOpen then 
            ('Trying to open a statement, but the connection is not open!',0,0)->BetaDBCException;
        if);
        (THIS(Connection).private.hdbc,@@ THIS(SQLStatement).private.hstmt)
          ->SQLAllocStmt->rc;
        (if rc <> SQL_SUCCESS then
            (none, SQL_HANDLE_DBC, THIS(Connection).private.hdbc)
              ->SQLStatementException
         else
            true->private.isOpen
        if)
     #);
   value[]->set  

-- resultSetSetVarNotDeclared: DoPart --
do
   'Variable named \''->msg.append;
   name[]->msg.append;
   '\' not declared in this connection'->msg.append;
   INNER  

-- resultSetSetUnknownColumn: DoPart --
do
   'Unknown column: \''->msg.append;
   name[]->msg.append;
   '\' is not in the resultSet'->msg.append;
   INNER  

-- formatTime: DoPart --
do
   &text[]->value[];
   '\''->value.put;
   t.year->value.putint;
   '-'->value.put;
   t.month->value.putint;
   '-'->value.put;
   t.day->value.putint;
   ascii.sp->value.put;
   t.hour->value.putint (#  do 2->width; true->zeroPadding #);
   ':'->value.put;
   t.minute->value.putint (#  do 2->width; true->zeroPadding #);
   ':'->value.put;
   t.sec->value.putint (#  do 2->width; true->zeroPadding #);
   '\''->value.put;
   INNER  

-- formatDate: DoPart --
do
   &text[]->value[];
   '\''->value.put;
   d.year->value.putint;
   '-'->value.put;
   d.month->value.putint;
   '-'->value.put;
   d.day->value.putint;
   '\''->value.put;
   INNER  

-- formatClock: DoPart --
do
   &text[]->value[];
   '\''->value.put;
   c.hour->value.putint (#  do 2->width; true->zeroPadding #);
   ':'->value.put;
   c.minute->value.putint (#  do 2->width; true->zeroPadding #);
   ':'->value.put;
   c.sec->value.putint (#  do 2->width; true->zeroPadding #);
   '\''->value.put;
   INNER  

