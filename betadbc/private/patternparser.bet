ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list'
        '~beta/basiclib/formatio';
-- textlib: Attributes --
getNextStatementStringOrSpecifier:
  (#
     value: ^text;
     isStatementString: @boolean;
     ch: @char;
     isVarChar: booleanValue
       (# ch: @char
       enter ch
       do ((ch->ascii.isDigit) or (ch->ascii.isLetter) or (ch = '_'))->value
       #);
     getVariable:
       (# 
       do
          false->isStatementString;
          get->value.put;
          scan
            (# while::  (#  do ch->isVarChar->value #)
            do ch->value.put
            #)
       #);
     getNonVariable:
       (# 
       do
          false->isStatementString;
          get->value.put;
          (if not eos then get->value.put if)
       #);
     getNamedPlaceholder:
       (# 
       do
          get->value.put;
          scan
            (# while::  (#  do ch->isVarChar->value #)
            do ch->value.put
            #);
          (if not eos then
              (if peek
               // ':' then getVariable // '%' then getNonVariable
              if)
          if)
       #);
     getNonPlaceholder:
       (# skip: @boolean
       do
          scan
            (#
               while:: 
                 (# 
                 do
                    (if ch->isVarChar then
                        false->value
                     else
                        (if not skip then
                            (if ch
                             // ':' // '%' then
                                false->value
                             // '\\' then
                                true->skip
                            if)
                         else
                            false->skip
                        if)
                    if)
                 #)
            do (if not skip then ch->value.put if)
            #)
       #)
  do
     true->isStatementString;
     &text[]->value[];
     (if not eos then
         peek->ch;
         (if true
          // ch->isVarChar then
             getNamedPlaceholder
          // ch = ':' then
             getVariable
          // ch = '%' then
             getNonVariable
          else
             getNonPlaceholder
         if)
     if)
  exit (value[],isStatementString)
  #);
hasNonWhiteSpace: booleanValue
  (# 
  do
     scanAll
       (#  do (if not (ch->ascii.isWhiteSpace) then true->value if) #)
  #)  

-- lib: Attributes --
PatternParser:
  (#
     tracer:
       (#
          value: @boolean;
          t: @text;
          s:<
            (# value: ^stream
            do screen[]->value[]; INNER
            exit value[]
            #);
          trace:
            (# format: t.putFormat (#  do INNER #)
            do (if value then t.clear; INNER ; t[]->(s).puttext if)
            #)
       enter value
       exit value
       #);
     theTracer: @tracer;
     trace: theTracer.trace (#  do INNER #);
     NodeVisitor: Visitor
       (#
          lastElm: @boolean;
          visitUnnamedResultSetPattern:< visit
            (# element::< UnnamedResultSetPattern
            do
               INNER ;
               elm.unnamedSpecifiers.scan
                 (# 
                 do
                    (if current[] = (elm.unnamedSpecifiers.last).elm[] then
                        true->lastElm
                     else
                        false->lastElm
                    if);
                    THIS(Visitor)[]->current.accept
                 #)
            #);
          visitNamedResultSetPattern:< visit
            (# element::< NamedResultSetPattern
            do
               INNER ;
               elm.namedSpecifiers.scan
                 (# 
                 do
                    (if current[] = (elm.namedSpecifiers.last).elm[] then
                        true->lastElm
                     else
                        false->lastElm
                    if);
                    THIS(Visitor)[]->current.accept
                 #)
            #);
          visitNamedSpecifier:< visit
            (# element::< NamedSpecifier
            do
               INNER ;
               THIS(Visitor)[]->elm.theNameDecl.accept;
               THIS(Visitor)[]->elm.theUnnamedSpecifier.accept
            #);
          visitVariable:< visit (# element::< Variable do INNER #);
          visitPlaceholder:< visit (# element::< Placeholder do INNER #);
          visitNameDecl:< visit (# element::< NameDecl do INNER #);
          visitStatementPattern:< visit
            (# element::< StatementPattern
            do
               INNER ;
               elm.StatementStringOrSpecifiers.scan
                 (# 
                 do
                    (if current[] = (elm.StatementStringOrSpecifiers.last).elm[]
                     then
                        true->lastElm
                     else
                        false->lastElm
                    if);
                    THIS(Visitor)[]->current.accept
                 #)
            #);
          visitStatementString:< visit
            (# element::< StatementString do INNER #);
          visitStatementSpecifier:< visit
            (# element::< StatementSpecifier
            do INNER ; THIS(Visitor)[]->elm.value.accept
            #)
       do INNER
       #);
     ;
     parseError:< exception
       (# t: ^text
       enter t[]
       do 'Parse Error! ('->msg; t[]->msg.append; ')'->msg.put
       #);
     unParseNode: NodeVisitor
       (#
          t: ^text;
          visitVariable::  (#  do ':'->t.append; elm.value[]->t.append #);
          visitPlaceholder::  (#  do '%'->t.put; elm.mark->t.put #);
          visitNameDecl::  (#  do elm.value[]->t.append #);
          visitStatementString:: 
            (# 
            do
               trace
                 (# 
                 do
                    'visitStatementString: "%s"\n'
                      ->format (#  do elm.value[]->s #)
                 #);
               elm.value[]->t.append
            #);
          theNode: ^node
       enter theNode[]
       do &text[]->t[]; THIS(visitor)[]->theNode.accept
       exit t[]
       #);
     parseResultSetPatternString:<
       (# t: ^text; res: ^ResultSetPattern
       enter t[]
       do
          (if t[] = none then
              &resultSetPattern[]->res[]
           else
              t.reset;
              t.scanWhiteSpace;
              (if not t.eos then
                  (if (':' = t.peek) or ('%' = t.peek) then
                      &UnnamedResultSetPattern[]->res[]
                   else
                      &NamedResultSetPattern[]->res[]
                  if);
                  t[]->res.parse
               else
                  &resultSetPattern[]->res[]
              if)
          if);
          INNER
       exit res[]
       #);
     parseStatementPatternString:<
       (# t: ^text; res: ^StatementPattern
       enter t[]
       do
          trace
            (# 
            do
               'parseStatementPatternString: "%s"\n'
                 ->format (#  do t[]->s #)
            #);
          &StatementPattern[]->res[];
          t[]->res.parse;
          INNER
       exit res[]
       #);
     ;
     Node:
       (#
          accept:<
            (# theVisitor: ^NodeVisitor enter theVisitor[] do INNER #);
          parse:< (# t: ^text enter t[] do INNER #);
          getVariableList: (#  #);
          getPlaceholderList: (#  #)
       #);
     ResultSetPattern: Node (#  #);
     UnnamedResultSetPattern: ResultSetPattern
       (#
          UnnamedSpecifiers: @list (# element:: UnnamedSpecifier #);
          accept:: 
            (# 
            do
               THIS(UnnamedResultSetPattern)[]
                 ->theVisitor.visitUnnamedResultSetPattern
            #);
          parse:: 
            (# atom: ^text
            do
               trace
                 (# 
                 do
                    'parseUnNamedResultSetPattern: "%s"\n'
                      ->format (#  do t[]->s #)
                 #);
               L:
                 (# elm: ^UnnamedSpecifier; isString: @boolean
                 do
                    t.getNextStatementStringOrSpecifier->(atom[],isString);
                    (if not atom.empty then
                        (if not isString then
                            atom.reset;
                            (if '%' = atom.peek then
                                &Placeholder[]->elm[]
                             else
                                &Variable[]->elm[]
                            if);
                            elm[]->UnnamedSpecifiers.append;
                            atom[]->elm.parse
                        if);
                        restart L
                    if)
                 #)
            #)
       #);
     NamedResultSetPattern: ResultSetPattern
       (#
          NamedSpecifiers: @list (# element:: NamedSpecifier #);
          accept:: 
            (# 
            do
               THIS(NamedResultSetPattern)[]
                 ->theVisitor.visitNamedResultSetPattern
            #);
          parse:: 
            (# atom: ^text
            do
               trace
                 (# 
                 do
                    'parseNamedResultSetPattern: "%s"\n'
                      ->format (#  do t[]->s #)
                 #);
               L:
                 (# elm: ^NamedSpecifier; isString: @boolean
                 do
                    t.getNextStatementStringOrSpecifier->(atom[],isString);
                    (if not atom.empty then
                        (if not isString then
                            &NamedSpecifier[]->elm[]->NamedSpecifiers.append;
                            atom.reset;
                            atom[]->elm.parse
                        if);
                        restart L
                    if)
                 #)
            #)
       #);
     Specifier: Node (#  #);
     NamedSpecifier: Specifier
       (#
          theNameDecl: ^NameDecl;
          theUnnamedSpecifier: ^UnnamedSpecifier;
          accept:: 
            (# 
            do THIS(NamedSpecifier)[]->theVisitor.visitNamedSpecifier
            #);
          parse:: 
            (# atom: ^text
            do
               trace
                 (# 
                 do 'parseNamedSpecifier: "%s"\n'->format (#  do t[]->s #)
                 #);
               t.scan
                 (#
                    while:: 
                      (#  do (not ((ch = ':') or (ch = '%')))->value #)
                 #);
               (1,t.pos)->t.sub->atom[];
               atom.reset;
               &NameDecl[]->theNameDecl[];
               atom[]->theNameDecl.parse;
               (t.pos+1,t.length)->t.sub->atom[];
               atom.reset;
               (if '%' = atom.peek then
                   &Placeholder[]->theUnnamedSpecifier[]
                else
                   &Variable[]->theUnnamedSpecifier[]
               if);
               atom[]->theUnnamedSpecifier.parse
            #)
       #);
     UnnamedSpecifier: Specifier (#  #);
     Variable: UnnamedSpecifier
       (#
          value: ^text;
          accept::  (#  do THIS(Variable)[]->theVisitor.visitVariable #);
          parse:: 
            (# 
            do
               trace
                 (# 
                 do 'parseVariable: "%s"\n'->format (#  do t[]->s #)
                 #);
               (if t.length < 2 then t[]->parseError if);
               (2,t.length)->t.sub->value[]
            #)
       #);
     Placeholder: UnnamedSpecifier
       (#
          mark: @char;
          value: ^text;
          accept:: 
            (#  do THIS(Placeholder)[]->theVisitor.visitPlaceholder #);
          parse:: 
            (# 
            do
               trace
                 (# 
                 do 'parsePlaceholder: "%s"\n'->format (#  do t[]->s #)
                 #);
               (if t.length < 2 then t[]->parseError if);
               (if 2->t.inxGet->mark
                // 'b' // 'c' // 'd' // 'f' // 'i' // 's' // 't' then
                   2->t.inxGet->mark
                else
                   t[]->parseError
               if)
            #)
       #);
     NameDecl: Node
       (#
          value: ^text;
          accept::  (#  do THIS(NameDecl)[]->theVisitor.visitNameDecl #);
          parse:: 
            (# 
            do
               trace
                 (# 
                 do 'parseNameDecl: "%s"\n'->format (#  do t[]->s #)
                 #);
               t.copy->value[]
            #)
       #);
     StatementPattern: Node
       (#
          StatementStringOrSpecifiers: @list
            (# element:: StatementStringOrSpecifier #);
          accept:: 
            (# 
            do THIS(StatementPattern)[]->theVisitor.visitStatementPattern
            #);
          parse:: 
            (# pos: @integer; atom: ^text; isStatementString: @boolean
            do
               trace
                 (# 
                 do 'statementPattern: "%s"\n'->format (#  do t[]->s #)
                 #);
               L:
                 (# 
                 do
                    t.pos->pos;
                    t.getNextStatementStringOrSpecifier
                      ->(atom[],isStatementString);
                    (if isStatementString then
                        &StatementString[]->StatementStringOrSpecifiers.append
                     else
                        &StatementSpecifier[]
                          ->StatementStringOrSpecifiers.append
                    if);
                    atom.reset;
                    atom[]->(StatementStringOrSpecifiers.last).elm.parse;
                    (if not t.eos then restart L if)
                 #)
            #)
       #);
     StatementStringOrSpecifier: Node (#  #);
     StatementString: StatementStringOrSpecifier
       (#
          value: ^text;
          accept:: 
            (# 
            do THIS(StatementString)[]->theVisitor.visitStatementString
            #);
          parse:: 
            (# 
            do
               trace
                 (# 
                 do 'statementString: "%s"\n'->format (#  do t[]->s #)
                 #);
               t.copy->value[]
            #)
       #);
     StatementSpecifier: StatementStringOrSpecifier
       (#
          value: ^Specifier;
          accept:: 
            (# 
            do THIS(StatementSpecifier)[]->theVisitor.visitStatementSpecifier
            #);
          parse:: 
            (# isNamed,isVariable: @boolean; pos: @integer
            do
               trace
                 (# 
                 do
                    'parseStatementSpecifier: "%s"\n'
                      ->format (#  do t[]->s #)
                 #);
               t.getPos->pos;
               t.scan
                 (# 
                 do
                    (if ((ch = ':') or (ch = '%')) then
                        (if t.getPos > 1 then
                            (if not (' ' = ((t.getPos-1)->t.inxGet)) then
                                true->isNamed
                            if)
                        if);
                        (if ch = ':' then true->isVariable if)
                    if)
                 #);
               pos->t.setPos;
               (if isNamed then
                   &NamedSpecifier[]->value[]
                else
                   (if isVariable then
                       &Variable[]->value[]
                    else
                       &Placeholder[]->value[]
                   if)
               if);
               t[]->value.parse
            #)
       #)
  #);
Visitor:
  (#
     visit: (# element:< object; elm: ^element enter elm[] do INNER #)
  do INNER
  #)  

