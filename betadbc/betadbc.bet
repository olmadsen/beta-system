ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/timedate';
-- lib: Attributes --
Connection: (* A connection to a relational DBMS *)
  (#
     <<SLOT ConnectionLib:Attributes>>;
     declareVar:
     (* Used to declare a wrapper of a BETA object so that
      * the object may be used in SQLStatements *)
       (#
          <<SLOT DeclareVarLib:Attributes>>;
          varName: ^text;
          set:<
          (* Furtherbind this to set the value of the object that you wrap *)
           object;
          get:<
          (* Furtherbind this to get the value of 
           * the object that you wrap *) object;
          setAsText:<
          (* Furtherbind in concrete subpatterns to set
           * the wrapped object's value to the value 'value' *)
            (# value: ^text
            enter value[]
            <<SLOT declareVarSetAsText:DoPart>>
            #);
          getAsText:<
          (* Furtherbind in concrete subpatterns to get
           * the wrapped object's value as a text *)
            (# value: ^text
            <<SLOT declareVarGetAsText:DoPart>>
            exit value[]
            #)
       enter varName[]
       <<SLOT ConnectionDeclareVar:DoPart>>
       exit varName[]
       #);
     declareInteger: (* Declares a wrapper around an integer *) declareVar
       (#
          <<SLOT DeclareIntegerLib:Attributes>>;
          set::< 
            (# value: @integer
            enter value
            <<SLOT declareIntegerSet:DoPart>>
            #);
          get::<  (# value: @integer do INNER exit value #);
          setAsText::<  (#  <<SLOT declareIntegerSetAsText:DoPart>> #);
          getAsText::< 
            (# 
            <<SLOT declareIntegerGetAsText:DoPart>>
            #)
       #);
     declareReal: (* Declares a wrapper around a real *) declareVar
       (#
          <<SLOT DeclareRealLib:Attributes>>;
          set::< 
            (# value: @real
            enter value
            do INNER
            #);
          get::< 
            (# value: @real
            do INNER
            exit value
            #);
          setAsText::< 
            (# 
            <<SLOT declareRealSetAsText:DoPart>>
            #);
          getAsText::<  (#  <<SLOT declareRealGetAsText:DoPart>> #)
       #);
     declareText:
     (* Declares a wrapper around a text *) declareVar
       (#
          <<SLOT DeclareTextLib:Attributes>>;
          set::< 
            (# value: ^text
            enter value[]
            do INNER
            #);
          get::< 
            (# value: ^text
            do INNER
            exit value[]
            #);
          setAsText::< 
            (# 
            <<SLOT declareTextSetAsText:DoPart>>
            #);
          getAsText::<  (#  <<SLOT declareTextGetAsText:DoPart>> #)
       #);
     declareBoolean:
     (* Declares a wrapper around a boolean *) declareVar
       (#
          <<SLOT DeclareBooleanLib:Attributes>>;
          set::< 
            (# value: @boolean
            enter value
            do INNER
            #);
          get::< 
            (# value: @boolean
            do INNER
            exit value
            #);
          setAsText::< 
            (# 
            <<SLOT declareBooleanSetAsText:DoPart>>
            #);
          getAsText::<  (#  <<SLOT declareBooleanGetAsText:DoPart>> #)
       #);
     declareTime: (* Declares a wrapper around a 'time' *) declareVar
       (#
          <<SLOT DeclareTimeLib:Attributes>>;
          set::< 
            (# value: @time
            enter value
            do INNER
            #);
          get::< 
            (# value: @time
            do INNER
            exit value
            #);
          setAsText::< 
            (# 
            <<SLOT declareTimeSetAsText:DoPart>>
            #);
          getAsText::<  (#  <<SLOT declareTimeGetAsText:DoPart>> #)
       #);
     declareDate:
     (* Declares a wrapper around a 'date'. Only the year, month and day 
      * attributes of the time value object are taken into account
      *) declareTime (# <<SLOT DeclareDateLib:Attributes>> #);
     declareClock:
     (* Declares a wrapper around a 'time'. Only the hour, minute and sec 
      * attributes of the time value object are taken into account *)
      declareTime (# <<SLOT DeclareClockLib:Attributes>> #);
     formatTime:<
     (* Called by BetaDBC to format 'time' values
      * Furtherbind this if a date format other than 
      * 'YYYY-MM-DD HH:MM:SS' is needed *)
       (# t: @time; value: ^text
       enter t
       <<SLOT formatTime:DoPart>>
       exit value[]
       #);
     formatDate:<
     (* Called by BetaDBC to format 'date' values
      * Furtherbind this if a date format other than 
      * 'YYYY-MM-DD' is needed *)
       (# d: @time; value: ^text
       enter d
       <<SLOT formatDate:DoPart>>
       exit value[]
       #);
     formatClock:<
     (* Called by BetaDBC to format 'clock' values
      * Furtherbind this if a clock format other than 
      * 'HH:MM:SS' is needed *)
       (# c: @time; value: ^text
       enter c
       <<SLOT formatClock:DoPart>>
       exit value[]
       #);
     SQLStatement:
     (* The abstract superpattern for all SQL statements.
      * To use an instance of a subclass of SQLStatement:
      *    1. Open the statement by calling 'open',
      *      1a. specifying an enter parameter to, or
      *      1b. setting the statement's SQL contents by evaluating the enter part.
      *    2. Call 'execute'. 
      *    3. Go to 1b., if necessary
      *    4. Call 'close'
      *)
       (#
          <<SLOT SQLStatementLib:Attributes>>;
          cursorType:<
          (* The type of cursor that is created when 
           * an SQLStatement is executed *)
            (#
               insensitive:<
               (* Should be furtherbound to set value to 'true'  
                * if the cursor should be insensitive to concurrent changes *)
                booleanValue;
               readOnly:<
               (* Furtherbind to to set value to 'false' if modification by cursor is needed *)
               booleanValue (#  do true->value; INNER #);
               scrollable:<
               (*
                Furtherbind this if the resulting resultSet should be scrollable
                
                *) booleanValue;
               name:<
               (* Furtherbind this to set the name of the cursor.                
                If setName is not furtherbound a default name will be generated. *)
               (# value: ^text do INNER exit value[] #)
            #);
          resultSetType:<
          (* The type of resultSet that will be opened
           * when executing this(SQLStatement) *) resultSet;
          execute:< (* Executes this(SQLStatement) *)
            (# res: ^resultSetType
            <<SLOT SQLStatementExecute:DoPart>>
            exit res[]
            #);
          open:
          (* Opens this(SQLStatement).
           * An SQLStatement must be opened before use *)
            (# value: ^text
            enter value[]
            <<SLOT SQLStatementOpen:DoPart>>
            #);
          close:
          (* Closes this(SQLStatement). 
           * Call close when done with this(SQLStatement) *)
            (#  <<SLOT SQLStatementClose:DoPart>> #);
          SQLStatementException:<
           BetaDBCException (#  do INNER #);
          SQLStatementNotification:< BetaDBCNotification (#  do INNER #);
          get:< (# t: ^text <<SLOT SQLStatementGet:DoPart>> exit t[] #);
          set:<
            (# t: ^text
            enter t[]
            <<SLOT SQLStatementSet:DoPart>>
            #);
          private: @<<SLOT SQLStatementPrivate:Descriptor>>
       enter set
       do INNER
       exit get
       #);
     directSQLStatement:
     (* Use this statement type if a statement will be executed at most 
      * a few times. The contents may contain variable placeholders in the form
      *    :varname
      * designating that the shared variable named 'varname' 
      * will be bound to that place. In addition, also
      *    %b for booleans
      *    %c for clocks
      *    %d for dates
      *    %f for reals
      *    %i for integers
      *    %s for texts
      *    %t for time
      * may be used when setting the contents of this(directSQLStatement)
      * Furthermore, placeholders may be named as in
      *    aname%f or aname:varname
      * signifying that the value of the %f or :varname placeholder may be set/get
      * by calling setByName/getByName 
      * with "aname" as parameter
      *) SQLStatement
       (#
          <<SLOT DirectSQLStatementLib:Attributes>>;
          currentMarker:
          (* The current marker decides which non-variable placeholder will be set
           * if one of the subpatterns of "marker" is used
           *)
            (#
               set:
                 (# 
                 enter no
                 <<SLOT directSQLStatementCurrentMarkerSet:DoPart>>
                 #);
               get:
                 (# 
                 <<SLOT directSQLStatemenCurrentMarkerGet:DoPart>>
                 exit no
                 #);
               no: @integer
            enter set
            exit get
            #);
          marker:
          (* Abstract superpattern for markers.
           * Advances currentMarker by 1
           *) (# t: ^text <<SLOT directSQLStatementMarker:DoPart>> #);
          b:
          (* Set placeholder number 'currentMarker' 
           * to the boolean 'value' *) marker
            (# value: @boolean
            enter value
            <<SLOT directSQLStatementB:DoPart>>
            #);
          c:
          (* Set placeholder number 'currentMarker' 
           * to the clock 'value' *) marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementC:DoPart>>
            #);
          d:
          (* Set placeholder number 'currentMarker' 
           * to the date 'value' *) marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementD:DoPart>>
            #);
          f:
          (* Set placeholder number 'currentMarker' 
           * to the real 'value' *) marker
            (# value: @real
            enter value
            <<SLOT directSQLStatementF:DoPart>>
            #);
          i:
          (* Set placeholder number 'currentMarker' 
           * to the integer 'value' *) marker
            (# value: @integer
            enter value
            <<SLOT directSQLStatementI:DoPart>>
            #);
          s:
          (* Set placeholder number 'currentMarker' 
           * to the text 'value' *) marker
            (# value: ^text
            enter value[]
            <<SLOT directSQLStatementS:DoPart>>
            #);
          t:
          (* Set placeholder number 'currentMarker' 
           * to the time 'value' *) marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementT:DoPart>>
            #);
          setByName:
          (* Abstract superpattern for patterns that
           * sets the value of a named placeholder *)
            (#
               name: ^text;
               t: ^text;
               nameNotFound:< exception
                 (# 
                 <<SLOT directSQLStatementSetByNameNameNotFound:DoPart>>
                 #)
            enter name[]
            <<SLOT directSQLStatementSetByName:DoPart>>
            #);
          setBooleanByName:
          (* Set placeholder named 'name' 
           * to the boolean 'value' *) setByName
            (# value: @boolean
            enter value
            <<SLOT directSQLStatementSetBooleanByName:DoPart>>
            #);
          setClockByName:
          (* Set placeholder named 'name' 
           * to the clock 'value' *) setByName
            (# value: @time
            enter value
            <<SLOT directSQLStatementSetClockByName:DoPart>>
            #);
          setDateByName:
          (* Set placeholder named 'name'            * to the date 'value' *)
           setByName
            (# value: @time
            enter value
            <<SLOT directSQLStatementSetDateByName:DoPart>>
            #);
          setFloatByName:
          (* Set placeholder named 'name' 
           * to the real 'value' *) setByName
            (# value: @real
            enter value
            <<SLOT directSQLStatementSetFloatByName:DoPart>>
            #);
          setIntegerByName:
          (* Set placeholder named 'name' 
           * to the integer 'value' *) setByName
            (# value: @integer
            enter value
            <<SLOT directSQLStatementSetIntegerByName:DoPart>>
            #);
          setTextByName:
          (* Set placeholder named 'name' 
           * to the text 'value' *) setByName
            (# value: ^text
            enter value[]
            <<SLOT directSQLStatementSetTextByName:DoPart>>
            #);
          setTimeByName:
          (* Set placeholder named 'name' 
           * to the time 'value' *) setByName
            (# value: @time
            enter value
            <<SLOT directSQLStatementSetTimeByName:DoPart>>
            #);
          execute:: 
            (# 
            <<SLOT directSQLStatementExecute:DoPart>>
            #);
          execDirectException:< BetaDBCException (#  do INNER #);
          execDirectNotification:< BetaDBCNotification (#  do INNER #);
          private: @<<SLOT directSQLStatementPrivate:Descriptor>>;
          set::< 
            (#
               varNotDeclared:<
                exception
                 (# name: ^text
                 enter name[]
                 <<SLOT directSQLStatementSetVarNotDeclared:DoPart>>
                 #)
            <<SLOT DirectSQLStatementSet:DoPart>>
            #);
          getExpanded:
          (* Get the contents of this(directSQLStatement)
           * as it would appear if the statement was executed now *)
            (# value: ^text
            <<SLOT directSQLStatementGetExpanded:DoPart>>
            exit value[]
            #)
       do INNER
       #);
     preparedSQLStatement:
     (* Use this statement type if a statement will be executed multiple 
      * times with different bindings.
      * ONLY IMPLEMENTED AS A DIRECT STATEMENT
      *) directSQLStatement
       (# <<SLOT preparedSQLStatementLib:Attributes>> do INNER #);
     resultSet:
     (* A result of an SQLStatement. 
      * If columnCount <> 0 then the resultSet is can be scanned or fetched from.
      * The tuples of a resultSet can be read at most once.
      *)
       (#
          <<SLOT resultSetLib:Attributes>>;
          columnCount:
          (* The number of columns in this(resultSet) *) integerValue
            (#  <<SLOT ResultSetInfoNoOfCols:DoPart>> #);
          tupleCount:
          (* If the statement that created this(resultSet) was a
           * 1. INSERT, DELETE or UPDATE statement 
           *     tupleCount yield the number of tuples 
           *     affected by the statement 
           * 2. SELECT statement
           *     tupleCount MAY (i.e. does not in all circumstances) yield 
           *     the number of rows selected 
           *) integerValue (#  <<SLOT ResultSetInfoRowCount:DoPart>> #);
          column:
          (* A column in this(resultSet) *)
            (#
               name: ^Text;
               no: @Integer;
               dataType:
               (* The BETA pattern corresponding to the SQL datatype 
                * for this column. If the SQL datatype is DATE, TIME or 
                * TIMESTAMP then the corresponding BETA pattern will 
                * be time 
                *) ##Object;
               dataTypeName: (* DBMS specific type name *) ^Text;
               dataTypeNo: (* ODBC specific numbering of SQL datatypes *)
                 @integer;
               nullAble: @Boolean
            #);
          getColumn: (* Gets the column number 'i' in this(resultSet) *)
            (# i: @Integer; res: ^column
            enter i
            <<SLOT ResultSetInfoGetColumnInfo:DoPart>>
            exit res[]
            #);
          getColumnByName:
          (* Gets the column designated by 'name' in this(resultSet) *)
            (#
               name: ^text;
               res: ^column;
               nameNotFound:< exception
                 (#  <<SLOT resultSetGetColumnByNameNameNotFound:DoPart>> #)
            enter name[]
            <<SLOT ResultSetInfogetColumnInfoByName:DoPart>>
            exit res[]
            #);
          cursorName:
          (* Gets the name of the cursor that points to this(resultSet) *)
            (# value: ^text
            <<SLOT resultSetCursorName:DoPart>>
            exit value[]
            #);
          tuple:
          (* A row in this(resultSet). If this(resultSet) has been set
           * with a value that contained non-variable placeholders,
           * the values may be retrieved by using the markers below 
           *)
            (#
               <<SLOT ResultLib:Attributes>>;
               marker:
               (* Gets the value of a non-variable placeholder and advances 
                * the placeholder currently referred to 
                *) (#  <<SLOT resultSetTupleMarker:DoPart>> #);
               b: marker
                 (# value: @boolean
                 <<SLOT resultSetTupleB:DoPart>>
                 exit value
                 #);
               c: marker
                 (# value: @time
                 <<SLOT resultSetTupleC:DoPart>>
                 exit value
                 #);
               d: marker
                 (# value: @time
                 <<SLOT resultSetTupleD:DoPart>>
                 exit value
                 #);
               f: marker
                 (# value: @real
                 <<SLOT resultSetTupleR:DoPart>>
                 exit value
                 #);
               i: marker
                 (# value: @integer
                 <<SLOT resultSetTupleI:DoPart>>
                 exit value
                 #);
               s: marker
                 (# value: ^text
                 <<SLOT resultSetTupleS:DoPart>>
                 exit value[]
                 #);
               t: marker
                 (# value: @time
                 <<SLOT resultSetTupleT:DoPart>>
                 exit value
                 #);
               private: @<<SLOT resultSetResultPrivate:Descriptor>>
            #);
          EOT:
          (* If current = EOT then no more tuples are
           * available in this(resultSet) *)
            (# value: ^tuple <<SLOT resultSetEOT:DoPart>> exit value[] #);
          set:
          (* May called before using fetch on this(resultSet)
           * The pattern entered may either 
           * contain
           * 1. Named columns of the form
           *          'name1:var1 name2:%i name3:var2'
           *     which means that the column named 'name1'('name3') 
           *     is bound to the variable named 'var1'('var2') and the 
           *     column named 'name2' may be retrieved from the 
           *     current tuple using the 'i'-marker,
           * or
           * 2. Consecutive columns of the form
           *          ':var1 %i :var2'
           *     which means that the first (third) column in each result 
           *     is bound to the variable named 'var1'('var3') and that 
           *     the value of the second column may be retrieved from the 
           *     current tuple using the 'i'-marker
           *)
            (#
               varNotDeclared:<
               (* Raised if variable used in the entered 
                * pattern was not found *) exception
                 (# name: ^text
                 enter name[]
                 <<SLOT resultSetSetVarNotDeclared:DoPart>>
                 #);
               columnNotFound:<
               (* Raised if this is a named scan and 
                * named column was not found *) exception
                 (# name: ^text
                 enter name[]
                 <<SLOT resultSetSetUnknownColumn:DoPart>>
                 #);
               pattern: ^text
            enter pattern[]
            <<SLOT resultSetSet:DoPart>>
            #);
          fetch:
          (* Get the current tuple of the relation over which the resultSet ranges.
           * If no more tuples exist, 'current' will be EOT 
           * Advance current tuple if possible *)
            (# result: ^tuple
            <<SLOT resultSetFetch:DoPart>>
            exit result[]
            #);
          scan:
          (* Scans over the tuples of this(resultSet) starting from the current tuple.
           * A text pattern may be entered. See 'set' for details.
           *)
            (#
               current: ^tuple;
               varNotDeclared:<
               (* Raised if variable used in the entered 
                * pattern was not found *) exception
                 (# name: ^text
                 enter name[]
                 <<SLOT resultSetScanVarNotDeclared:DoPart>>
                 #);
               columnNotFound:<
               (* Raised if this is a named scan and 
                * named column was not found *) exception
                 (# name: ^text
                 enter name[]
                 <<SLOT resultSetScanUnknownColumn:DoPart>>
                 #);
               pattern: ^text
            enter pattern[]
            <<SLOT resultSetScan:DoPart>>
            #);
          resultSetException:< BetaDBCException (#  do INNER #);
          resultSetNotification:< BetaDBCNotification (#  do INNER #);
          private: @<<SLOT ResultSetPrivate:Descriptor>>
       #);
     open:<
     (* Opens this(connection). The name of the connection 
      * to be opened must be supplied. 
      * Supplying userName and/or password is voluntary.
      *)
       (#
          name: ^text;
          userName: ^text;
          password: ^text;
          openConnectionException:< BetaDBCException (#  do INNER #);
          openConnectionNotification:< BetaDBCNotification (#  do INNER #)
       enter (name[],userName[],password[])
       <<SLOT ConnectionOpen:DoPart>>
       #);
     close:<
       (#
          closeException:< BetaDBCException
            (#  do INNER #);
          closeNotification:< BetaDBCNotification
            (#  do INNER #)
       <<SLOT ConnectionClose:DoPart>>
       #);
     connectionException:< BetaDBCException (#  do INNER #);
     connectionNotification:< BetaDBCNotification (#  do INNER #);
     private: @<<SLOT ConnectionPrivate:Descriptor>>
  #);
BetaDBCException:
(* Low level interface for catching exceptions.
 * A general exception message is supplied in msg,
 * SQL states and native error codes in SQLState, 
 * NativeError in a comma-separated list.
 *) Exception
  (#
     SQLState: @text;
     NativeError: @text;
     KnownErrorMsg: ^text;
     HandleType: @integer;
     Handle: @integer
  enter (KnownErrorMsg[],HandleType,Handle)
  <<SLOT DBEnvBDBCException:DoPart>>
  #);
BetaDBCNotification: BetaDBCException
  (#  do true->continue; INNER #)  

