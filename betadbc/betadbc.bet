ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/timedate';
BODY 'private/betadbcbody';
-- lib: Attributes --
Connection: (* A connection to a relational DBMS *)
  (#
     <<SLOT ConnectionLib:Attributes>>;
     declareVar:
     (* Used to declare a wrapper on a BETA object so that
      * object may be used in SQLStatements *)
       (#
          varName: ^text;
          set:<
          (* Furtherbind this to set the value of the declared
           * wrapper object to the value of the wrapped object *) object;
          get:< (* Furtherbind this to get the value of the variable defined *)
           object
       enter varName[]
       <<SLOT ConnnectionDeclareVar:DoPart>>
       exit varName[]
       #);
     declareInteger:
     (* Declares a wrapper around an integer *) declareVar
       (#
          set::<  (# value: @integer enter value do INNER #);
          get::<  (# value: @integer do INNER exit value #)
       #);
     declareReal: (* Declares a wrapper around a real *) declareVar
       (#
          set::<  (# value: @real enter value do INNER #);
          get::<  (# value: @real do INNER exit value #)
       #);
     declareText: (* Declares a wrapper around a text *) declareVar
       (#
          set::<  (# value: ^text enter value[] do INNER #);
          get::<  (# value: ^text do INNER exit value[] #)
       #);
     declareBoolean: (* Declares a wrapper around a boolean *) declareVar
       (#
          set::<  (# value: @boolean enter value do INNER #);
          get::<  (# value: @boolean do INNER exit value #)
       #);
     declareDate:
     (* Declares a wrapper around a 'date'. Only the year, month and day 
      * attributes of the time value object are taken into account
      *) declareVar
       (#
          set::<  (# value: @time enter value do INNER #);
          get::<  (# value: @time do INNER exit value #)
       #);
     declareClock:
     (* Declares a wrapper around a 'time'. Only the hour, minute and sec 
      * attributes of the time value object are taken into account *)
      declareVar
       (#
          set::<  (# value: @time enter value do INNER #);
          get::<  (# value: @time do INNER exit value #)
       #);
     declareTime: (* Declares a wrapper around a 'time' *) declareVar
       (#
          set::<  (# value: @time enter value do INNER #);
          get::<  (# value: @time do INNER exit value #)
       #);
     SQLStatement:
     (* The abstract superpattern for all SQL statements.
      * To use an instance of a subclass of SQLStatement:
      * 1. Set the statements SQL contents by evaluating the enter part
      * 2. Call 'execute'. Repeat 2, as necessary.
      * 3. Go to 1., if necessary
      * 4. Call 'close'
      *)
       (#
          <<SLOT SQLStatementLib:Attributes>>;
          execute:<
          (* Executes this(SQLStatement) *)
            (# res: ^ResultSet
            <<SLOT SQLStatementExecute:DoPart>>
            exit Res[]
            #);
          close:
          (* Closes this(SQLStatement). Call close when done with this(SQLStatement) *)
          (#  <<SLOT SQLStatementClose:DoPart>> #);
          execException:< BetaDBCException
            (#  do INNER #);
          execWarning:< BetaDBCWarning
            (#  do INNER #);
          private:
            @<<SLOT SQLStatementPrivate:Descriptor>>;
          get:< (# t: ^text <<SLOT SQLStatementGet:DoPart>> exit t[] #);
          set:<
            (# t: ^text
            enter t[]
            <<SLOT SQLStatementSet:DoPart>>
            #)
       enter set
       do INNER
       exit get
       #);
     directSQLStatement:
     (* Use this statement type if a statement will be executed at most a few times.
      * The contents may contain placeholders in the form
      *   - :name designating that the shared variable named "name" 
      *      will be bound to that place
      * In addition also
      * %b for booleans
      * %c for clocks
      * %d for dates
      * %f for reals
      * %i for integers
      * %s for texts
      * %t for time
      * may be used when setting the contents of this(directSQLStatement)
      *) SQLStatement
       (#
          <<SLOT DirectSQLStatementLib:Attributes>>;
          currentMarker:
          (* The current marker decides which placeholder will be set
           * if one of the subpatterns of "marker" is used
           *) @
            (#
               set:
                 (# 
                 enter no
                 <<SLOT DirectSQLStatementCurrentMarkerSet:DoPart>>
                 #);
               get:
                 (# 
                 <<SLOT directSQLStatemenCurrentMarkerGet:DoPart>>
                 exit no
                 #);
               no: @integer
            enter set
            exit get
            #);
          marker:
          (* Abstract superpattern for markers.
           * Advances currentMarker by 1
           *) (#  <<SLOT directSQLStatementMarker:DoPart>> #);
          b:
          (* Set placeholder number 'currentMarker' to the boolean 'value' *)
           marker
            (# value: @boolean
            enter value
            <<SLOT directSQLStatementB:DoPart>>
            #);
          c:
          (* Set placeholder number 'currentMarker' to the clock 'value' *)
           marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementC:DoPart>>
            #);
          d:
          (* Set placeholder number 'currentMarker' to the date 'value' *)
           marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementD:DoPart>>
            #);
          f:
          (* Set placeholder number 'currentMarker' to the real 'value' *)
           marker
            (# value: @real
            enter value
            <<SLOT directSQLStatementF:DoPart>>
            #);
          i:
          (* Set placeholder number 'currentMarker' to the integer 'value' *)
           marker
            (# value: @integer
            enter value
            <<SLOT directSQLStatementI:DoPart>>
            #);
          s:
          (* Set placeholder number 'currentMarker' to the text 'value' *)
           marker
            (# value: ^text
            enter value[]
            <<SLOT directSQLStatementS:DoPart>>
            #);
          t: (* Set placeholder number 'currentMarker' to the time 'value' *)
           marker
            (# value: @time
            enter value
            <<SLOT directSQLStatementT:DoPart>>
            #);
          execute:: 
            (# 
            <<SLOT DirectSQLStatementExecute:DoPart>>
            #);
          execDirectException:< BetaDBCException
            (#  do INNER execDirectException #);
          execDirectWarning:< BetaDBCWarning
            (#  do INNER execDirectWarning #);
          private: @<<SLOT DirectSQLStatementPrivate:Descriptor>>;
          set::< 
            (# 
            <<SLOT DirectSQLStatementSet:DoPart>>
            #);
          getExpanded:
          (* Get the contents of this(directSQLStatement)
           * as it would appear if the statement was executed now *)
            (# value: ^text
            <<SLOT directSQLStatementGetExpanded:DoPart>>
            exit value[]
            #)
       do INNER
       #);
     preparedSQLStatement:
     (* Use this statement type if a statement will be executed multiple 
      * times with different bindings.
      * ONLY IMPLEMENTED AS A DIRECT STATEMENT
      *) directSQLStatement
       (# <<SLOT PreparedSQLStatementLib:Attributes>> do INNER #);
     resultSet:
     (* A result of an SQLStatement. 
      * If columnCount <> 0 then the resultSet is scanable.
      * A resultSet can be scanned at most once.
      *)
       (#
          <<SLOT ResultSetLib:Attributes>>;
          columnCount:
          (* The number of columns in this(resultSet) *) integerValue
            (#  <<SLOT ResultSetInfoNoOfCols:DoPart>> #);
          rowCount:
          (* If the statement that created this(resultSet) was a
           * 1. INSERT, DELETE or UPDATE statement 
           *     rowCount yield the number of rows affected by the statement 
           * 2. SELECT statement
           *     rowCount MAY (i.e. does not in all circumstances) yield 
           *     the number of rows selected 
           *) integerValue (#  <<SLOT ResultSetInfoRowCount:DoPart>> #);
          column:
          (* A column in this(resultSet) *)
            (#
               name: ^Text;
               no: @Integer;
               dataType:
               (* The BETA pattern corresponding to the SQL datatype for this column.
                * If the SQL datatype is DATE, TIME or TIMESTAMP then the corresponding BETA pattern will be time 
                *) ##Object;
               dataTypeName: (* DBMS specific type name *) ^Text;
               dataTypeNo: (* ODBC specific numbering of SQL datatypes *)
                 @integer;
               nullAble: @Boolean
            #);
          getColumn: (* Gets the column number 'i' in this(resultSet) *)
            (# i: @Integer; res: ^column
            enter i
            <<SLOT ResultSetInfoGetColumnInfo:DoPart>>
            exit res[]
            #);
          getColumnByName:
          (* Gets the column designated by 'name' in this(resultSet) *)
            (# name: ^Text; res: ^Column; nameNotFound:< exception
            enter name[]
            <<SLOT ResultSetInfogetColumnInfoByName:DoPart>>
            exit res[]
            #);
          result:
          (* A row in this(resultSet)
           * If the enter parameter of the scan operation that created this result contained
           * %_ placeholders the values of these may be retrieved by using the markers below
           *)
            (#
               <<SLOT ResultLib:Attributes>>;
               marker:
               (* Gets the value of a %_ placeholder and advances the placeholder
                * referred to 
                *) (#  <<SLOT resultSetScanMarker:DoPart>> #);
               b: marker
                 (# value: @boolean
                 <<SLOT resultSetScanB:DoPart>>
                 exit value
                 #);
               c: marker
                 (# value: @time
                 <<SLOT resultSetScanC:DoPart>>
                 exit value
                 #);
               d: marker
                 (# value: @time
                 <<SLOT resultSetScanD:DoPart>>
                 exit value
                 #);
               f: marker
                 (# value: @real
                 <<SLOT resultSetScanR:DoPart>>
                 exit value
                 #);
               i: marker
                 (# value: @integer
                 <<SLOT resultSetScanI:DoPart>>
                 exit value
                 #);
               s: marker
                 (# value: ^text
                 <<SLOT resultSetScanS:DoPart>>
                 exit value[]
                 #);
               t: marker
                 (# value: @time
                 <<SLOT resultSetScanT:DoPart>>
                 exit value
                 #);
               private: @<<SLOT resultSetResultPrivate:Descriptor>>
            #);
          scan:
          (* Scans over the rows of this(resultSet).
           * A pattern may be entered. The pattern entered may either contain
           * 1. Named columns of the form
           *          'name1:var1 name2:%i name3:var2'
           *     which means that the column named 'name1'('name3') is bound
           *     to the variable named 'var1'('var2') and the column named 'name2' may be 
           *     retrieved from the current result using the 'i'-marker.
           * or
           * 2. Consecutive columns of the form
           *          'var1 %i var2'
           *     which means that the first (third) column in each result is bound to 
           *     the variable named 'var1'('var3') and that the value of the second column may be
           *     retrieved from the current result using the 'i'-marker
           * or
           * 3. Nothing
           *     which means that the values of the column may be retrieved from the current
           *     using the %_ markers corresponding to the types of the values
           *)
            (#
               current: @result;
               varNotDeclared:<
               (* Raised if variable used in the entered pattern was not found *)
               exception (# name: ^text enter name[] do INNER #);
               unknownColumn:<
               (* Raised if this is a named scan and named column was not found *)
               exception (# name: ^text enter name[] do INNER #);
               pattern: ^text
            enter pattern[]
            <<SLOT resultSetScan:DoPart>>
            #);
          resultSetException:< BetaDBCException
            (# 
            do INNER resultSetException
            #);
          resultSetWarning:< BetaDBCWarning
            (#  do INNER resultSetWarning #);
          private:
            @<<SLOT ResultSetPrivate:Descriptor>>
       #);
     open:<
     (* Opens this(connection). The name of the connection to be opened 
      * must be supplied. Supplying userName and/or password is voluntary.
      *)
       (#
          name: ^text;
          userName: ^text;
          password: ^text;
          openConnectionException:< BetaDBCException
            (#  do INNER openConnectionException #);
          openConnectionWarning:< BetaDBCWarning
            (#  do INNER openConnectionWarning #)
       enter (name[],userName[],password[])
       <<SLOT ConnectionOpen:DoPart>>
       #);
     close:<
       (#
          closeException:< BetaDBCException
            (#  do INNER closeException #);
          closeWarning:< BetaDBCWarning
            (#  do INNER closeWarning #)
       <<SLOT ConnectionClose:DoPart>>
       #);
     connectionException:< BetaDBCException
       (#  do INNER connectionException #);
     connectionWarning:< BetaDBCWarning (#  do INNER connectionWarning #);
     private: @<<SLOT ConnectionPrivate:Descriptor>>
  #);
BetaDBCException:
(* Low level interface for catching exceptions.
 * A general exception message is supplied in msg,
 * SQL states and native error codes in SQLState, 
 * NativeError in a comma-separated list.
 *) Exception
  (#
     SQLState: @text;
     NativeError: @text;
     HandleType: @integer;
     Handle: @integer
  enter (HandleType,Handle)
  <<SLOT DBEnvBDBCException:DoPart>>
  #);
BetaDBCWarning: BetaDBCException
  (#  do true->continue; INNER #)  

