ORIGIN '~beta/basiclib/betaenv';  
INCLUDE '~beta/sysutils/int64';
(* This demo program illustrates the curent (limited) support 
 * for 64 bit values. 
 * The basic pattern int64 represents 64 bit integers.
 * The current implementation supports:
 * - declaration of int64 objects:     a,b: @int64
 * - assignment of int64 objects:      a -> b;
 *   including int64 objects as enter/exit values;
 * - arguments/return values to external functions (C)
 *    foo: external(# a,b,c: @int64 enter(a,b) exit c #)
 * 
 * There is NO support for arithmetic and relational 
 * operations on int64 values.
 * 
 * There is, however, a basic library 'int64' that supplies 
 * functions for int64 arithmetic and relational operations
 *)
---program:descriptor---
(# a,b,c: @int64;
   x: @int32;
   R: [10] @ int64  
do (*** using int64 integers ***)
   111 -> a; 
   222 -> b;  
   (a,b) -> a64 -> c;
   (*  c -> x; x -> putint; newline;*)
   c -> putint64;
   newline;   
   (*** printing hex int64 values ***) 
   (0x0000aaaa,0x0000bbbb) -> c64 -> a;
   (0x000c0000,0x000d0000) -> c64 -> b;   
   a -> puthexint64; ' + ' -> puttext; b -> puthexint64;
   ' = ' -> puttext;
   (a,b) -> a64 -> c;  
   c -> puthexint64;  
   newline;   
      
   (*** use of relational operators *****)
   (if ((a,b) -> le64) then 'less equal' -> putline
    else 'greater' -> putline
   if);
   
   (*** passing int 32 expressions to int64 routines ***)
   222 -> x;
   (777,x+111) -> s64 -> putint64; newline;
   
   (**** use of int64 array ****)
   (#x: @char 
   do    (for i: R.range repeat '.'->put; (i,i) -> c64 -> R[i] for); #);
   0 -> b;
   (for i: R.range repeat (b,R[i]) -> a64 -> b for);  
   0 -> x;
   (for i: R.range repeat x + i -> x for);
   '1+2+...+' -> puttext; R.range -> putint;
   ' = (0x' -> puttext; x -> puthexint64; ',0x' -> puttext;
   x -> puthexint64; ') = 0x' -> puttext; 
   b -> puthexint64; newline  
#)





