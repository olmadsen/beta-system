ORIGIN '~beta/basiclib/v1.6/betaenv';
(* 
 * $RCSfile: RepetitionObject.bet,v $ $Revision: 1.6 $ $Date: 1997-08-15 10:51:38 $
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)

MDBODY linux   'private/RepetitionObject_little'
       nti     'private/RepetitionObject_little'
       default 'private/RepetitionObject_big';


--- lib:attributes ---
memcpy: external
  (# adrTarget: @Integer;
     adrSource: @Integer;
     byteCount: @Integer;
     out: @Integer;
  enter (adrTarget, adrSource, byteCount)
  exit out
  #);

RepetitionObject:
  (* Used to pass serialized objects around *)
  (# r: [InitialRange]@Integer;
     initialRange:< 
       (# value: @Integer; 
       do 10 -> value; INNER
       exit value
       #);
     
     <<SLOT RepetitionObjectAttributes:attributes>>;
     
     size: @ (# enter r[1] exit r[1] #);
     (* Index of last used entry in r. (Not the same as r.range *)
     
     pos: @(# enter r[2] exit r[2] #);
     (* next position to get or put *)
     
     get: @(# do r[2] + 1 -> r[2] exit r[r[2] - 1] #);
     
     getLong: @ (* Get a long, byteswapping it, if on little-endian. *)
       (# l: @Integer;
       <<SLOT RepObjGetLongDP:dopart>>
       exit l
       #);
                  
     put: @
       (# enter r[r[2]]
       do 
          (if (r[2] + 1 -> r[2]) > r.range then r.range -> r.extend if);
          (if r[2] > r[1] + 1 then r[2] - 1 -> r[1] if);
       #);
     
     (* Put a long, byteswapping it on little-endian machines. *)
     putLong: @
       (# enter r[r[2]]
          <<SLOT RepObjPutLongDP:dopart>>
       #);
     
     (* The user of cheapPut must ensure that space is available 
      * (using makeSpace) and that size is updated (using checkSize). *)
     cheapPut: @ (# enter r[r[2]] do r[2]+1 -> r[2] #);
     
     (* Put a long, byteswapping it on little-endian machines.
      * Comment on cheapPut applies, as they share the allocated space. *)
     cheapPutLong: @ 
       (# l: @Integer;
       enter l
       <<SLOT RepObjcheapPutLongDP:dopart>> 
       #);
     
     makeSpace: @
       (# nlongs: @Integer;
       enter nlongs
       do (if r[2] + nlongs > r.range then
              (r[2] + nlongs + 10 - r.range, r.range) -> max -> r.extend;
          if);
       #);
     
     checkSize: @
       (# 
       do (if r[2] > r[1] + 1 then r[2] - 1 -> r[1] if)
       #);
     
     getText: @
       (# t: ^Text; len, wsize: @Integer;
       do
          &Text[] -> t[];
          getLong -> len -> t.lgth -> t.pos;
          (if len > t.T.range then len - t.T.range -> t.T.extend if);
          (@@t.T[1], @@r[r[2]], len) -> memcpy;
          r[2] + ((len + 3) div 4) -> r[2];
       exit t[]
       #);   
     
     putText: @
       (# t: ^Text;
          len, wsize: @Integer;
       enter t[]
       do t.length -> len -> putLong;
          (len + 3) div 4 -> wsize -> makeSpace;
          (@@r[r[2]], @@t.t[1], len) -> memcpy;
          r[2] + wsize -> r[2];
          (if r[2] > r[1] + 1 then r[2] - 1 -> r[1] if)
       #);
     
     firstPos: (# exit 3 #);
     initialSize: (# exit 2 #);
     reset: (# do firstPos -> r[2] #);
              
     init: (# do (initialSize, firstPos) -> (r[1], r[2]) #)
  #);
