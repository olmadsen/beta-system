ORIGIN '~beta/basiclib/v1.6/basicsystemenv';

BODY 'private/iostatebody';

--- systemLib:attributes ---

(* Attributes for controlling non-blocking IO on UNIX filedescriptors.
 * 
 * As the operating system sees a BETA process as a single process, coroutines
 * cannot be allowed to make blocking system calls as this would block
 * all other coroutines as well. *)

(* IOMASK
 * ======
 * 
 * An IOmask defines parameters used when calling UNIX select (man select)
 * to decide whether a coroutine blocking on an IOmask is allowed to 
 * continue.
 * 
 * add<op>FD adds the fd to the set of filedescriptors in this IOmask. <op>
 * is either "read", "write" or "except" and specifies the conditions under
 * which a coroutine blocking on this IOmask should be allowed to continue.
 * 
 * del<op>FD undoes the corresponding add<op>FD operation.
 * 
 * scan iterates over the fd's currently in the mask. For each filedescriptor
 * it is reported whether "read", "write" and "except" conditions should allow
 * a blocked coroutine to continue.
 * 
 * block suspends the calling coroutine until one of the filedescriptors in
 * the mask are ready as specified in add<op>FD calls.  If a filedescriptor
 * is ready, block returns "isReady". Otherwise timeOut was called and the
 * return value from block is the enter parameter that was given to timeOut.
 * 
 * Between calls to "block" the state of the fileDescriptors when the last
 * block returned may be queried using "state". "state" returns what kind of 
 * activity was pending on the filedescriptor given as parameter when
 * "block" returned.
 * 
 * If timeOuts are needed, setup a timer (timeHandler.bet) and call timeOut 
 * when the timer goes of.
 * 
 * Only one coroutine is allowed to wait for activity on any given
 * file descriptor. *)

IOmask:
  (# <<SLOT IOmaskLib:attributes>>;
     addReadFD: @
       (# fd: @Integer; 
       enter fd
       <<SLOT iomAddReadFD:dopart>>
       #);
     addWriteFD: @
       (# fd: @Integer; 
       enter fd
       <<SLOT iomAddWriteFD:dopart>>
       #);
     addExceptFD: @
       (# fd: @Integer; 
       enter fd
       <<SLOT iomAddExceptFD:dopart>>
       #);
     delReadFD: @
       (# fd: @Integer;
       enter fd
       <<SLOT iomDelReadFD:dopart>>
       #);
     delWriteFD: @
       (# fd: @Integer;
       enter fd
       <<SLOT iomDelWriteFD:dopart>>
       #);
     delExceptFD: @
       (# fd: @Integer;
       enter fd
       <<SLOT iomDelExceptFD:dopart>>
       #);
     scan:
       (# curFD: @Integer;
          read,write,except: @Boolean;
       do <<SLOT iomScan:descriptor>>  
       #);
     block: @
       (# error: @Integer;
       <<SLOT iomBlock:dopart>>
       exit error
       #);
     state: @
       (# fd: @Integer;
          read,write,except: @Boolean;
       enter fd
       <<SLOT iomState:dopart>>
       exit (read,write,except)
       #);
     timeOut: 
       (# error: @Integer;
       enter error
       <<SLOT iomTimeOut:dopart>> 
       #);
     iomPrivate: @<<SLOT iomPrivate:descriptor>>;
     
     (* Private: *) 
     continue: @
       (# fd, cause: @Integer;
       enter (fd,cause)
       <<SLOT iomContinue:dopart>>
       #);
  #);

isReady: (# exit 0 #);
timeOutError: (# exit -1 #);



(* IOSTATE
 * =======
 * 
 * The IOstate pattern provides a simple interface to IOmask in case a
 * coroutine only needs to block on a single filedescriptor. 
 * 
 * readBlock blocks the calling coroutine until a non-blocking read on fd 
 * is possible or an exceptional state is pending. The timedOut exit parameter
 * is false unless timeOut was called. 
 * 
 * writeBlock blocks the calling coroutine until a non-blocking write on
 * fd is possible or an exceptional state is pending. 
 *
 * If timeOut is needed, setup a timer (timeHandler.bet) and call timeOut
 * when the timer goes off. *)

IOstate:
  (# fd: @IntegerValue (* UNIX file descriptor *)
       (# <<SLOT IOstateFD:dopart>> #); 
     
     
     readBlock: @ 
       (# timedOut: @Boolean;
       <<SLOT iosreadblock:dopart>>
       exit timedOut
       #);
     
     writeBlock: @
       (# timedOut: @Boolean;
       <<SLOT ioswriteBlock:dopart>>
       exit timedOut
       #);
     
     timeOut: (# <<SLOT iostimeOut:dopart>> #);
     
     init:< 
       (# fd: @Integer;
       enter fd 
       <<SLOT iosInit:dopart>>
       #);
     
     iosPrivate: @<<SLOT iosPrivate:descriptor>>;
  #);
