ORIGIN '../binarystream';
LIB_ITEM 'sysutilsbinstream';
INCLUDE '~beta/basiclib/binfile'
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

---BinaryStreamInit:doPart---
do 0 -> rep.top
   
---BinaryStreamRep:descriptor--
(# R: [2] @integer;  top: @integer; (* byte pointer: [0,...] *)
   inc: @
     (# N: @integer
     enter n
     do (if (n+top->top) >= (R.range*4)  then R.range->R.extend if)
     #);
   
   align2: @
     (#
     do (if (top mod 2) = 1 then 1->inc if)
     #);
   align4: @
     (#
     do (if top mod 4 
         // 1 then 3->inc
         // 2 then 2->inc
         // 3 then 1->inc
        if)
     #);
   F: @binfile 
     (# lastMsg: ^text;
        report:
          (# msg: ^text;
          enter msg[]
          do msg.copy -> lastMsg[];
             (if false then
                 '\nBinaryStream: ' -> screen.putline;
                 msg[] -> screen.putline;
             if)
          #);
             
        AccessError::< 
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).accessError;
             true -> failure -> continue 
          #);
        WriteError::< 
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).WriteError;
             true -> failure -> continue 
          #);
        ReadError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        EOSerror::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        NoSuchFileError::<
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        FileExistsError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        NoSpaceError::<
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).NoSpaceError;
             true -> failure -> continue 
          #);
        OtherError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        
        GB: @GetBytes;
        PB: @PutBytes;
     #); 
   failure: @boolean
#)
---BinaryStreamPut:dopart---
do (ch, rep.top) -> rep.R.%putByte; 1->rep.inc
(* Above line tos_converted from: do (rep.R,rep.top,ch) -> TOS'%inxPutByte'; 1->rep.inc *)
---BinaryStreamPutShort:dopart--
do rep.align2; (V, (rep.top) div 2) -> rep.R.%putShort; 2->rep.inc
(* Above line tos_converted from: do rep.align2; (rep.R,rep.top,V) -> TOS'%inxPutShort'; 2->rep.inc *)
---BinaryStreamPutLong:dopart--
do rep.align4; (V, (rep.top) div 4) -> rep.R.%putLong; 4->rep.inc
(* Above line tos_converted from: do rep.align4; (rep.R,rep.top,V) -> TOS'%inxPutLong'; 4->rep.inc *)
---BinaryStreamPutText:dopart--
do T.scanAll(#do ch->put #); 0->put
---BinaryStreamGet:dopart---
do rep.top -> rep.R.%getByte->ch; 1->rep.inc; 
(* Above line tos_converted from: do (rep.R,rep.top) -> TOS'%inxGetByte'->ch; 1->rep.inc; *)
---BinaryStreamGetShort:dopart--
do rep.align2; ((rep.top) div 2) -> rep.R.%getShort->V; 2->rep.inc
(* Above line tos_converted from: do rep.align2; (rep.R,rep.top) -> TOS'%inxGetShort'->V; 2->rep.inc *)
---BinaryStreamGetLong:dopart--
do rep.align4; ((rep.top) div 4) -> rep.R.%getLong->V; 4->rep.inc
(* Above line tos_converted from: do rep.align4; (rep.R,rep.top) -> TOS'%inxGetLong'->V; 4->rep.inc *)
---BinaryStreamGetText:dopart--
do &Text[]->T[];
   (# ch: @Char; tput: @T.put; 
   do L: (if (get->ch)<>0 then ch->tput; restart L if);
   #);
---BinaryStreamSave:descriptor---
(# error: @openFailed;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenWrite; 
   (if rep.failure then rep.F.lastMsg -> error.msg; error if);
   (if true then
       (rep.R[],(rep.top div 4)+1) -> rep.F.putInt32Rep
    else
       (@@rep.R[1],(rep.top+4))->rep.F.PB; 
   if);
   rep.F.close;
   0->rep.top; (* juts for bytecode generation *)
#)
---BinaryStreamRestore:descriptor---
(# size: @Integer;
   error: @notFound;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenRead;
   (if rep.failure then 
       rep.F.lastMsg -> error.msg; error 
    else
       rep.F.length-> size;
       (if size div 4 > rep.R.range  then
           size div 4-> rep.R.new;
       if);
       (if true then
           (size div 4,0) -> rep.F.getInt32Rep -> rep.R[]
        else
           (@@rep.R[1],size)->rep.F.GB;
       if);
       rep.F.close;
       0->rep.top
   if);
#)
---BinaryStreamFragRestore:descriptor ---
(# size: @Integer;
   error: @notFound;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenRead;
   (if rep.failure  then
        rep.F.lastMsg -> error.msg; error
    else
       (0,FromBeginning) -> rep.F.SetPos;
       (if true then
           (2,0)->rep.F.getInt32Rep -> rep.R[]
        else
           (@@rep.R[1],8)->rep.F.GB
       if);
       0->rep.top;
       getShort;
       getLong -> size;
       (size+8) -> size;
       (if true then 
           (0,FromBeginning) -> rep.F.SetPos;
           (size div 4,0)->rep.F.getInt32Rep -> rep.R[]
        else
           (if size div 4 > rep.R.range  then
               size div 4-> rep.R.new;
           if);
           (0,FromBeginning) -> rep.F.SetPos;      
           (@@rep.R[1],size)->rep.F.GB;
       if);
       rep.F.close;
       0->rep.top
   if);
#)
