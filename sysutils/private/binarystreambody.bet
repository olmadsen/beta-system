ORIGIN '../binarystream';
LIB_ITEM 'sysutilsbinstream';
INCLUDE '~beta/basiclib/binfile'
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

---BinaryStreamInit:doPart---
do 0 -> rep.top
   
---BinaryStreamRep:descriptor--
(# R: [2] @integer;  top: @integer; (* byte pointer: [0,...] *)
   inc: @
     (# N: @integer
     enter n
     do (if (n+top->top) >= (R.range*4)  then R.range->R.extend if)
     #);
   
   align2: @
     (#
     do (if (top mod 2) = 1 then 1->inc if)
     #);
   align4: @
     (#
     do (if top mod 4 
         // 1 then 3->inc
         // 2 then 2->inc
         // 3 then 1->inc
        if)
     #);
   F: @binfile 
     (# lastMsg: ^text;
        report:
          (# msg: ^text;
          enter msg[]
          do msg.copy -> lastMsg[];
             (if false then
                 '\nBinaryStream: ' -> screen.putline;
                 msg[] -> screen.putline;
             if)
          #);
             
        AccessError::< 
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).accessError;
             true -> failure -> continue 
          #);
        WriteError::< 
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).WriteError;
             true -> failure -> continue 
          #);
        ReadError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        EOSerror::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        NoSuchFileError::<
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        FileExistsError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
        NoSpaceError::<
          (# 
          do msg[] -> report;
             name -> this(BinaryStream).NoSpaceError;
             true -> failure -> continue 
          #);
        OtherError::< 
          (# 
          do msg[] -> report;
             true -> failure -> continue 
          #);
     #); 
   failure: @boolean
#)
---BinaryStreamPut:dopart---
do (rep.R,rep.top,ch) -> TOS'%inxPutByte'; 1->rep.inc
---BinaryStreamPutShort:dopart--
do rep.align2; (rep.R,rep.top,V) -> TOS'%inxPutShort'; 2->rep.inc
---BinaryStreamPutLong:dopart--
do rep.align4; (rep.R,rep.top,V) -> TOS'%inxPutLong'; 4->rep.inc
---BinaryStreamPutText:dopart--
do T.scanAll(#do ch->put #); 0->put
---BinaryStreamGet:dopart---
do (rep.R,rep.top) -> TOS'%inxGetByte'->ch; 1->rep.inc; 
---BinaryStreamGetShort:dopart--
do rep.align2; (rep.R,rep.top) -> TOS'%inxGetShort'->V; 2->rep.inc
---BinaryStreamGetLong:dopart--
do rep.align4; (rep.R,rep.top) -> TOS'%inxGetLong'->V; 4->rep.inc
---BinaryStreamGetText:dopart--
do &Text[]->T[];
   (# ch: @Char; tput: @T.put; 
   do L: (if (get->ch)<>0 then ch->tput; restart L if);
   #);
---BinaryStreamSave:descriptor---
(# PR: @ rep.F.PutRep;
   error: @openFailed;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenWrite; 
   (if rep.failure then rep.F.lastMsg -> error.msg; error if);
   (@@rep.R[1],(rep.top+4) div 4)->PR; 
   rep.F.close;
   0->rep.top; (* juts for bytecode generation *)
#)
---BinaryStreamRestore:descriptor---
(# FG: @ rep.F.GetRep; size: @Integer;
   error: @notFound;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenRead;
   (if rep.failure then 
       rep.F.lastMsg -> error.msg; error 
    else
       ((rep.F.length-1) div 4)+1-> size;
       (if size > rep.R.range  then
           size -> rep.R.new;
       if);
       (@@rep.R[1],size)->FG;
       rep.F.close;
       0->rep.top
   if);
#)
---BinaryStreamFragRestore:descriptor ---
(# FG: @ rep.F.GetRep; size: @Integer;
   error: @notFound;
do false -> rep.failure;
   (if FN[]=NONE then &text[]->FN[] if);
   FN[]->rep.F.name;
   rep.F.OpenRead;
   (if rep.failure  then
        rep.F.lastMsg -> error.msg; error
    else
       (0,FromBeginning) -> rep.F.SetPos;
       (@@rep.R[1],2)->FG;
       0->rep.top;
       getShort;
       getLong -> size;
       ((size+8) div 4) + 1 -> size;
       (if size > rep.R.range  then
           size -> rep.R.new;
       if);
       (0,FromBeginning) -> rep.F.SetPos;
       (@@rep.R[1],size)->FG;
       rep.F.close;
       0->rep.top
   if);
#)
