ORIGIN '../envstring';
INCLUDE '~beta/win32lib/registry';
(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

--- expandEnvVarBody: descriptor ---
(#
   RegistryKey: 
     (# exit 'SOFTWARE\\Mjolner Informatics\\Default Environment' #);
   GetEnvironmentVariable: external
     (# lpName: [0]@char;
        lpBuffer: @integer;
        nSize: @integer;
        resSize: @integer;
     enter (lpName, lpBuffer, nSize)
     do 'GetEnvironmentVariableA' -> callStd
     exit resSize
     #);
   
   getenvstringlength:   
     (* Get length of an environment variable (0 if not set) *)
     (# var, val: ^text;
        len: @integer;
     enter var[]
     do (var,0,0) -> GetEnvironmentVariable -> len -> requiredsize;
        (if len=0 then
            (* Check registry for predefined values *)
            (HKEY_LOCAL_MACHINE, RegistryKey, var[]) 
              -> readFromRegistry -> val[];
            (if val[] <> NONE then
                val.length->len;
            if)
        if)
     exit len
     #);
   
   getenvstring: 
     (* Get text value of an environment variable *)
     (# var: ^text;
        (* The requiredsize includes space for NULL character.
         * There is already allocated space in BETA charreps for this,
         * and if the range of result includes the NULL byte,
         * then when later copied to a text, the text will get a
         * NULL character in the middle, even after an append.
         * To avoid this, we subtract one before allocation.
         *)
        result: [requiredsize-1]@char;
        len: @Integer; 
        val: ^Text;
     enter var[]
     do (if requiredsize<=1 then
            1->result.new;
        if);
        (var,@@result[1],requiredsize) -> GetEnvironmentVariable -> len;
        (if len<=0 then
            (* Check registry for predefined values *)
            (HKEY_LOCAL_MACHINE, RegistryKey, var[])
              -> readFromRegistry -> val[];
            (if val[] <> NONE then
                (* val.length->result.new;*)
                val->result;
            if)
        if)
     exit result
     #);
   
   requiredsize: @integer;
   startInx,endInx: @integer;
   envVar,envvarvalue: ^text
     
do
   (if t[]<>NONE then
       theLoop: 
         (# 
         do  (* Find first '$' *)
             0 -> startInx;
             loop: '$' -> t.findAll(# do inx -> startInx; leave loop #);
             (if (startInx>0) then
                 (if (startInx+1<t.length) then
                     (if (startInx+1 -> t.inxGet) = '(' then
                         (* Find matching ')' *)
                         loop: ')' -> t.findAll
	                 (# 
	                 do (if (inx>startInx) then
	                        inx -> endInx; leave loop
	                    if);
	                 #);
                         (if (endInx>0) then
	                     (startInx+2,endinx-1) -> t.sub -> envVar[];
	                     (if (envVar[] -> getenvstringlength) = 0 then 
                                 envVar[] -> defaultValue -> envVarValue[];
                                 (if envVarValue[]=NONE then 
                                     &text[] -> envVarValue[] 
                                 if);
	                      else 
                                 &text[] -> envVarValue[];
                                 envVar[] -> getenvstring -> envvarvalue;
                             if);
                             (startInx,endInx) -> t.delete;
	                     (envvarvalue[],startInx) -> t.insert;
	                     0 -> startInx -> endInx;
	                     restart theloop
                         if)
                     if)
                 if)
             if)
         #)
   if)
#)



