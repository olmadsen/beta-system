ORIGIN 'pathhandlerbody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE '~beta/unixlib/v1.5/unixinterface'
        '~beta/containers/v1.5/hashTable'
        '~beta/unixlib/v1.5/unixfile'
        '~beta/unixlib/v1.5/passwdhome';
-- LIB: Attributes --
homeDirectories: (# exit 'configuration/r4.0/homeDirectories' #); 

-- PathHandlerDirectoryChar: DoPart --
do '/'->c  

-- PathhandlerSearchPath: DoPart --
do '$(PATH)'->path[]  

-- PathhandlerSearchPathDelimiter: DoPart --
do ':'->delimiter  

-- PathHandlerCurrentDirectory: DoPart --
do getCurrentDir->cwd[]; 

-- ConvertFilePathBody: Descriptor --
(#
   endedBySlash: @boolean;
   slashInx,index: @integer;
   path,basis: ^text;
   pathlength,basislength: @integer;
   trace:
     (# t: ^text; 
     do &text[]->t[];
        'Converter: path  = '''->puttext;
        path->t;
        t[]->puttext;
        ''' pathlength = '->puttext;
        pathlength->putint;
        newline;
        'Converter: basis = '''->puttext;
        basis->t;
        t[]->puttext;
        ''' basislength = '->puttext;
        basislength->putint;
        newline;
        
     #);
   
do &text[]->THIS(ConvertFilePath).convertedpath[];
   (if THIS(ConvertFilePath).path[] <> none
    // true then (* Copy path to avoid side-effects *)
       &text[]->path[];
       THIS(ConvertFilePath).path->path;
       path.length->pathlength;
       (if pathlength <> 0
        // true then
           (if (pathlength->path.inxget) // '/' then true->endedBySlash if);
           (if THIS(ConvertFilePath).basis[]
            // none then CurrentDirectory->basis[]; 
            else
           (* Copy basis to avoid side-effects *)
               &text[]->basis[]; THIS(ConvertFilePath).basis->basis; 
           if);
           (if basis.length // 0 then currentdirectory->basis[] if);
           basis.length->basislength;
           (if (pathlength->path.inxget) <> '/'
            // true then '/'->path.append; pathlength+1->pathlength; 
           if);
           (if (basislength->basis.inxget) <> '/'
            // true then '/'->basis.append; basislength+1->basislength; 
           if);
           path[]->expandEnvVar->path[];
           (* Expand environment variables *)
           (*trace;*)
           path.length->pathlength;
           converter:
             (#
                T: ^text;
                firstCh: @char;
                unknownPrefix:
                (* The prefix of path is unknown. It must be a local file *)
                  (# 
                  do (if './'->basis.equal // true then leave converter if);
                     ('./',1)->path.insert;
                     pathlength+2->pathlength;
                     restart converter
                  #);
                
             do (*trace;*)
                (if pathlength // 0 then leave converter if);
                (if basislength // 0 then leave converter if);
                (if (1->path.inxGet)
                 // '/' then (* absolute path *)
                    leave converter
                 // '~' then (* tilde expand path, disregarding basis *)
                    test: 
                      (if true then
                          Private.Nametable.Scan
                          (# 
                          do (if ((1,currentSize)->path.sub->thisHome.equal) then
                                 (1,currentSize)->path.delete;
                                 thisDir[]->path.prepend;
                                 path.length->pathlength;
                                 leave test
                             if)
                          #);
                          0->slashInx;
                          loop: '/' ->path.findAll(# do inx->slashInx; leave loop #);
                          (if slashInx=0 then
                              path[]->getpasswdhome->t[];
                              (# h,n: ^text
                              do &text[]->h[];
                                 &text[]->n[];
                                 path->h;
                                 (if t[] <> none then
                                     t->n;
                                     '/'->n.put;
                                     (h[],n[])->Private.nameTable.newHomeDir;
                                     t->path
                                 if)
                              #);
                           else
                              (1,slashInx)->path.sub->getpasswdhome->t[];
                              (# h,n: ^text
                              do &text[]->n[];
                                 (1,slashInx)->path.sub->h[];
                                 (if t[] <> none then
                                     t->n;
                                     '/'->n.put;
                                     (h[],n[])->Private.nameTable.newHomeDir;
                                     (1,slashinx-1)->path.delete;
                                     t[]->path.prepend;
                                     path.length->pathlength;
                                 if)
                              #);
                          if)
                      if)
                 // '.' then
                    (if './'->basis.equal // true then leave converter if);
                    (* path is a relative path starting with .
                     * since path is '/'-terminated, length >=2
                     *)
                    (if (2->path.inxGet)
                     // '.' then
                     (* path starts with '..'
                      * Since path is always terminated by '/', length is >=3
                      *)
                        (if (3->path.inxGet)
                         // '/' then
                         (* path starts with '../'
                          * delete prefix of path and last component of basis
                          * and rerun converter
                          *)
                            (1,3)->path.delete;
                            pathlength-3->pathlength;
                            0->index;
                            '/'
                              ->basis.findAll
                                (# 
                                do (if inx
                                    // basislength then
                                    (* found the terminating slash *)
                                       (if index <> 0
                                        // true then
                                        (* found slash before the last one in basis *)
                                           (index+1,basislength)->basis.delete;
                                           basis.length->basislength;
                                           (if pathlength
                                            // 0 then
                                               basis->path;
                                               basislength->pathlength;
                                               leave converter
                                           if);
                                           
                                        // false then
                                        (* only terminating slash in basis. *)
                                           (if inx
                                            // 1 then (* basis = '/' *)
                                               NoFather;
                                               (* in case NoFather continues: *)
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               leave converter;
                                               
                                            else
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               './'->basis.prepend;
                                               basislength+2->basislength;
                                               
                                           if)
                                       if);
                                       restart converter
                                    else
                                   (* save the position of this slash *)
                                       inx->index
                                   if)
                                #);
                            
                         else
                        (* path starts with ..something, it must be a local file/directory
                         * named '..something'
                         *)
                            unknownprefix; 
                        if)
                     // '/' then
                     (* Path starts with './', i.e. a path local to basis
                      * delete prefix of path, concatenate basis and path
                      * and return path 
                      *)
                        (1,2)->path.delete;
                        basis[]->path.prepend;
                        path.length->pathlength;
                        leave converter
                     else
                    (* path starts with .something, it must be a local file/directory *)
                        unknownPrefix
                    if);
                    
                 else
                (* path does not start with '/', '~' or'.' *)
                    unknownPrefix; 
                if);
                
             #);
           (*trace;*)
           path[]->removedoubleslash;
           path.length->pathlength;
           (*trace;*)
           (* Check that the path is ended by slash iff the original one was *)
           (if (pathlength->path.inxget)
            // '/' then
               (if endedBySlash
                // false then
                   (if pathlength
                    // 1 then (* special case: the result was '/' *) 
                    else
                       (pathlength,pathlength)->path.delete; 
                   if);
                   
               if)
            else
               (if endedBySlash // true then '/'->path.append; if)
           if);
           (*trace;*)
           path->THIS(ConvertFilePath).convertedpath;
           
       if)
   if)
#)  


-- PathHandlerInitNameTable: descriptor --
(# homes: @file; abb,fullName: ^text; 
do '/'->directoryChar; 
   '$(BETALIB)'->expandEnvVar->BetaLib[];
   (if BetaLib.length = 0 then
       '/usr/local/lib/beta/'->BetaLib[]; 
    else
       (if (private.BetaLib.length->private.BetaLib.inxGet) <> '/'
           then
           '/'->private.BetaLib.append; 
       if);
   if);
   getCurrentDir->private.CurrentDirectory[];
   '/'->private.CurrentDirectory.append;
   &text[]->abb[];
   '~beta/'->abb;
   (abb[],betalib[])->&newHomeDir;
   homeDirectories->(private.BetaLib.Copy).Append->homes.name;
   (if homes.entry.exists then
       homes.openRead;
       loop:
         (if not homes.eos then 
             (*'Homedir line: '->puttext;*)
             homes.getLine->abb[];
             (*abb[]->putline;*)
             homes.getLine->fullname[];
             (*fullname[]->putline;*)
             (if (1->fullName.inxget) <> '/' then
                 (fullName[],private.currentDirectory[])
                   ->convertFilePath->fullName[];
             if);
             (abb[],fullname[])->&newHomeDir;
             restart loop
         if);
       (*'No more homes'->putline;*)
       homes.close
   if);
   L: scan
     (# newCur: ^Text; 
     do (private.CurrentDirectory[],thisHome[])->localPath->newCur[];
        (if newCur.length < private.CurrentDirectory.length then
            newCur[]->private.CurrentDirectory[]; leave L; 
        if);
     #);
   (private.CurrentDirectory[],'.ignored')->convertfilepath
     ->private.CurrentDirectory[];
#)
  

-- fcPrivate: Descriptor --
(#
   directoryTable: @hashTable
     (#
        element::< (# dir: @text; inodeElem: ^inodeTable.element #);
        hashfunction::<
          (# do e.dir.scanall (# do value*10+ch->value #); #);
        equal::< (# do (left.dir[]->right.dir.equal)->value #);
        rangeInitial::< (# do 123->value #);
        insertValue:
          (# dir: @text; i: ^inodeTable.element; e: ^element
          enter (dir,i[])
          do (*'\nInsertValue: ' ->puttext; dir[] -> putline;
              *) &element[]->e[]; dir->e.dir; i[]->e.inodeElem[]; e[]->insert; 
          #);
        
     #);
   inodeTable: @hashTable
     (#
        element::<
          (# firstPathName: @text; inode: @integer; device: @integer; 
          #);
        hashfunction::< (# do ((e.inode*9+e.device)->abs)->value #);
        (* When running SUN OS 4.0, the 'device' may be a negative number *)
        equal::<
          (# 
          do ((left.inode = right.inode) and (left.device = right.device))
               ->value
          #);
        rangeInitial::< (# do 23->value #);
        insertInode:
          (# inode,device: @integer; firstPathName: @text; e: ^element
          enter (inode,device,firstPathName)
          do (*'\nInsertInode: ' ->puttext; inode -> putint; 
           *' '->put; device->putint; ' '->put; firstpathname[] -> putline;
           *)
             &element[]->e[];
             inode->e.inode;
             device->e.device;
             firstPathName->e.firstPathName;
             e[]->insert;
             
          exit e[]
          #);
        
     #);
   
#)  

-- fcInit: DoPart --
do fcPrivate.inodeTable.init; fcPrivate.directoryTable.init; 

-- fcConvertFilePath: Descriptor --
(#
   index: @integer;
   dir: ^text;
   trace:
     (# t: ^text; 
     do &text[]->t[];
        'FileNameConverter: convertedpath  = '''->puttext;
        convertedpath->t;
        t[]->puttext;
        ''''->putline;
        
     #);
   
do (* find directory of path *)
   '/'->convertedpath.findAll (# do inx->index #);
   (1,index-1)->convertedpath.sub->dir[];
   (*trace;*)
   FcPrivate.directoryTable.find
     (# (* directorytable.find *)
        predicate::< (# do dir[]->current.dir.equal->value #);
        notFound::<
          (# (* notfound *) 
          do (* add directory to table of directory names *)
             true->continue;
             test:
               (#
                  entry: @unixentry
                    (#
                       myinode: inode
                         (# error::< (# do fileNotFound; leave test #)
                         #);
                       mydevice: device
                         (# error::< (# do fileNotFound; leave test #)
                         #);
                       
                    #);
                  
               do dir[]->entry.path;
                  (if entry.isDirectory
                    (# error::< (# do fileNotFound; leave test #) #)
                   // false then fileNotFound
                   else
                      FcPrivate.inodeTable.find
                        (#
                           predicate::<
                             (# 
                             do (entry.myinode = current.inode) and
                                (entry.mydevice = current.device)->value
                             #);
                           notFound::< (* add directory to inode table *)
                             (# i: ^FCPrivate.inodeTable.element
                             do true->continue;
                                (entry.myinode,entry.mydevice,dir)
                                  ->FCPrivate.inodeTable.insertInode->i[];
                                (dir,i[])->FCPrivate.directoryTable.insertValue;
                                
                             #);
                           
                        do (* inodetable.find *) (*trace;*)
                           (if index > 1
                            // true then
                               (1,index-1)->convertedpath.delete;
                               (* delete directory of path *)
                               
                           if);
                           (*trace;*)
                           (* prepend the first found name of the path to the stripped path *)
                           current.firstPathName[]->convertedpath.prepend;
                           (*trace;*)
                           (dir,current[])
                             ->FCPrivate.directoryTable.insertValue;
                           
                        #);
                      
                  if)
               #);
             
          #);
        
     do (* directorytable.find *) (*trace;*)
        (if index > 1
         // true then
            (1,index-1)->convertedpath.delete;
            (* delete found directory from path *)
            
        if);
        (* prepend the first found name of the path to the stripped path *)
        current.inodeElem.firstPathName[]->convertedpath.prepend;
        (*trace;*)
        
     #);
   
#)  

