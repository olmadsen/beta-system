ORIGIN 'pathhandlerbody';

BUILD default ':$$/PathName.o' ':external/PathName.c' 'mrc -o $0 $1';

RESOURCE default 'external/pathhandler_macbody.r';
INCLUDE '~beta/maclib/v3.0/macdirectory'
	'~beta/maclib/v3.0/mactypes'
	'resstr_macbody';
(*
 *  COPYRIGHT
 *     Copyright Mjolner Informatics, 1989-96
 *     All rights reserved.
 *)
-- LIB: Attributes --
homeDirectories: (# exit 'configuration:homeDirectories' #); 

-- PathHandlerDirectoryChar: DoPart --
do ':'->c  

-- PathhandlerSearchPath: DoPart --
do '$(Commands)'->path[]  

-- PathhandlerSearchPathDelimiter: DoPart --
do ','->delimiter  

-- PathHandlerCurrentDirectory: DoPart --
do getCurrentDir->cwd[]; 

-- convertFilePathBody: Descriptor --
(#
   endedBySlash: @boolean;
   slashInx,index: @integer;
   pathlength,basislength: @integer;
   path,basis: ^Text;
   found: @boolean;
   ch: @char;
   isMacPath: BooleanValue
     (# p: ^Text; 
     enter p[]
     do ':'->p.FindAll (# do true->value #); 
     #);
   tildeExpand:
     (# 
     do 
	(* try look in table, we cannot expand usernames on MAC *)
	test: 
	  (if true then
	      Private.Nametable.Scan
	      (# 
	      do (if ((1,currentSize)->path.sub->thisHome.equal) then
		     (1,currentSize)->path.delete;
		     thisDir[]->path.prepend;
		     path.length->pathlength;
		     leave test;
		 if)
	      #);
	      (* not found in table: expand ~ as betalib *)
	      (1,1)->path.delete;
	      private.betalib[]->path.prepend;
	      path.length->pathlength;
	  if)
     #);

do (if THIS(ConvertFilePath).path[] <> none then
       &text[]->path[];
       THIS(ConvertFilePath).path->path;
       path.length->pathlength;
       (if pathlength <> 0 then
	   (if (pathlength->path.inxget) = '/' then true->endedBySlash if);
	   (if (pathlength->path.inxget) = ':' then true->endedBySlash if);
	   &text[]->basis[];
	   (if THIS(ConvertFilePath).basis[]=none then 
	       private.CurrentDirectory->basis; 
	    else
	       THIS(ConvertFilePath).basis->basis; 
	   if);
	   (if basis.length = 0 then private.CurrentDirectory->basis if);
	   basis.length->basislength;
	   (if ((pathlength->path.inxget) <> '/') and
	       ((pathlength->path.inxget) <> ':') then
	       (if path[]->isMacPath then 
		   ':'->path.append; 
		else
		   '/'->path.append; 
	       if);
	       pathlength+1->pathlength;
	   if);
	   (if ((basislength->basis.inxget) <> '/') and
	       ((basislength->basis.inxget) <> ':') then
	       (if basis[]->isMacPath then
		   ':'->basis.append; 
		else
		   '/'->basis.append; 
	       if);
	       basislength+1->basislength;
	   if);
	   path[]->expandEnvVar->path[] (* Expand environment variables *);
	   basis[]->expandEnvVar->basis[] (* Expand environment variables *);
	   path.length->pathlength;
	   converter:
	     (#
		unknownPrefix:
		  (#
		     (* the prefix of path is unknown.
		      * It must be a local file
		      *) 
		  do (':',1)->path.insert;
		     pathlength+1->pathlength;
		     restart converter
		  #);
	     do (if (1->path.inxGet)
		 // '/' then (* full path: remove first slash *)
		    (1,1)->path.delete;
		    pathlength-1->pathlength;
		    (if pathlength
		     // 0 then (* path is only '/' *)
			(* result should be volume of basis *)
			(if ((1->basis.inxGet) = '/') and (basislength = 1)
			 // true then (* basis is just '/' use CWD *)
			    getCurrentDir->path[]; 
			 else
			    (* convert basis to a full mac path if possible *)
			    (basis[],basis[])->&convertfilepath->path[]; 
			if);
			(* get volume of path: 
			 * find first ':' and get the name before
			 *)
			scanner:
			  (# 
			  do ':'
			       ->path.FindAll
			     (# do inx->index; leave scanner #)
			  #);
			(1,index)->path.sub->path[];
			path.length->pathlength;
			
		    if);
		    leave converter
		 // '~' then
		    tildeExpand;
		    leave converter;
		 // '.' then 
		    (if './'->basis.equal then leave converter if);
		    (* path is a relative path starting with .
		     * since path is '/'-terminated, length >=2
		     *)
		    (if (2->path.inxGet)
		     // '.' then
			(* path starts with '..'
			 * Since path is always terminated by '/', 
			 * length is >=3
			 *)
			(if (3->path.inxGet)
			 // '/' then
			    (* path starts with '../'
			     * delete prefix of path and last component 
			     * of basis and rerun converter
			     *)
			    (1,3)->path.delete;
			    pathlength-3->pathlength;
			    0->index;
			    '/'->basis.FindAll
			    (# 
			    do (if inx
				// basislength then
				   (* found the terminating slash *)
				   (if index <> 0 then
				       (* found slash before the last one in basis *)
				       (index+1,basislength)->basis.delete;
				       basis.length->basislength;
				       (if pathlength
					// 0 then
					   basis->path;
					   basislength->pathlength;
					   leave converter
				       if);
				    else
				       (* only terminating slash in basis. *)
				       (if inx=1 then (* basis = '/' *)
					   NoFather;
					   (* in case NoFather continues: *)
					   '../'->path.prepend;
					   pathlength+3->pathlength;
					   leave converter;
					else
					   '../'->path.prepend;
					   pathlength+3->pathlength;
					   './'->basis.prepend;
					   basislength+2->basislength;
				       if)
				   if);
				   restart converter
				else
				   (* save the position of this slash *)
				   inx->index
			       if)
			    #);
			    (if index=0 then
				(* did not find any '/' try ':' in basis *)
				':'->basis.FindAll
				(# 
				do (if inx=basislength then
				       (* found the terminating ':' *)
				       (if index <> 0 then
					   (* found ':' before the last one in basis *)
					   (index+1,basislength)
					     ->basis.delete;
					   basis.length->basislength;
					   (if pathlength=0 then
					       basis->path;
					       basislength->pathlength;
					       leave converter
					   if);
					else
					   (* only ':' last in basis
					    * basis is a volume name
					    *)
					   '../'->path.prepend;
					   pathlength+3->pathlength;
				       if);
				       restart converter
				    else
				       (* save the position of this ':' *)
				       inx->index
				   if)
				#);
			    if);
			 else
			    (* path starts with ..something, 
			     * it must be a local file/directory
			     * named '..something'
			     *)
			    unknownprefix; 
			if)
		     // '/' then
			(* Path starts with './', i.e. a path local to basis
			 * delete prefix of path, concatenate basis and path
			 * and return path 
			 *)
			(1,2)->path.delete;
			basis[]->path.prepend;
			path.length->pathlength;
			leave converter
		     else
			(* path starts with .something, 
			 * it must be a local file/directory 
			 *)
			unknownPrefix
		    if);
		 // ':' then (* this is old mac stuff *)
		    (1,1)->path.delete;
		    '/'->basis.FindAll (# do inx->index #);
		    (if index=0 then ':'->basis.FindAll (# do inx->index #)if);
		    ((1,index)->basis.sub,1)->path.insert;
		    path.length->pathlength;
		    leave converter
		 else
		    false->found;
		    ':'->path.findAll (# do true->found #);
		    (* if we have a colon, we have a global name on the mac *)
		    (if not found then unknownPrefix if);
		    leave converter
		if)
	     #);
	   (* Converter done *)
	   (* Check that the path is ended by slash iff the original one was *)
	   (if ((pathlength->path.inxget) = '/') or
	       ((pathlength->path.inxget) = ':') then
	       (if not endedBySlash then
		   (if pathlength=1 then 
		       (* special case: the result was '/' *) 
		    else
		       (pathlength,pathlength)->path.delete; 
		   if);
	       if)
	    else
	       (if endedBySlash then ':'->path.append; if)
	   if);
	   (* replace / with : *)
	   ('/',':',path[]) -> substChars;
	   (* Check that there are no '::' in the path unless first *)
	   - 1->slashInx;
	   ':'->path.FindAll
	   (# 
	   do (if inx > slashInx then
		  (if inx = slashInx+1 then
		      (if inx > 2  then
			  (inx,inx)->path.delete (* two consecutive ':' *)
		      if);
		   else
		      inx->slashInx; (* remember position of last ':' *) 
		  if)
	      if)
	   #);
	   path.copy -> convertedpath[] ;
       if)
   if)
#)

-- PathHandlerInitNameTable: descriptor --
(# t: @Text;
   f: @file;
   abb,fullName: ^text;
   getStandAlone: External
     (# isRunningAlone: @integer exit isRunningAlone #);
   getBetaLib: @stringGetter;
   GetBetaFolder: external (# a,b: [1] @char; enter a exit b #);

do ':'->directoryChar;
   getCurrentDir->CurrentDirectory[];
   (if CurrentDirectory[]=none then
       (failureTrace,'Failed to get CurrentDirectory')->stop;
   if);
   CurrentDirectory.makeLC;
   (if getStandAlone=1 then
       (*'This is standalone'->screen.putline;*)
       'betaLib'->getBetaLib.strName;
       &Text[]->betalib[];
       getBetaLib.getFromResourceFile->betalib;
       betalib->t;
       homeDirectories->t.append;
       (*'Trying: '->screen.puttext; t[]->screen.putline;*)
       t[]->f.entry.path;
       (if not (f.entry.exists(# error::<(# do true->continue #)#)) then
	   (*'did not exists'->screen.putline;*)
	   betalib->GetBetaFolder->pToC->betalib;
	   (if betalib.length=0 then
	       (normal,
	       'failed to get BETALIB: Program execution terminated')
		 ->stop
	    else
	       betalib->getBetaLib.updateResource;
	   if)
       if);
       (*'Done doing standalone...'->screen.putline;*)
    else
       (*'This is MPW tool'->screen.putline;*)
       '$(BETALIB)'
	 ->expandEnvVar
       (#
	  defaultValue::<
	    (#
	    do 'You have to set the MPW-environment variable {BetaLib}'
		 ->screen.putLine;
	       'to the homeDirectory of the Beta-System'
		 ->screen.putLine;
	       'before running any Beta-programs'->screen.putLine;
	       (Failure,'Program execution terminated')->stop
	    #)
       #)->betalib[];
       (if betalib[]=none then
	   (failureTrace,
	   'Failed to read MPW-environment variable {BetaLib}')
	     ->stop
       if);

   if);
   (*'BETALIB is: '->screen.puttext; betalib[]->screen.putline;*)
   betalib.makeLC;
   betalib->t;
   homeDirectories->t.append;
   t[]->f.entry.path;
   (if f.entry.exists then
       (*t[]->screen.puttext; ' exists, trying open: '->puttext;*)
       ('~beta/',betalib.copy)->&newHomeDir;
       f.openRead;
       (*'file open'->screen.putline;*)
       loop:
	 (if not f.eos then
	     f.getline->abb[];
	     f.getline->fullname[];
	     (if fullname[]<>none then
		 (fullName[],CurrentDirectory[])->convertFilePath
		   ->fullname[];
		 (if fullname[]=none then
		     (failureTrace,'Failed to convert file path')->stop
		 if);
		 (abb.copy,fullname.copy)->&newHomeDir;
	     if);
	     restart loop
	 if);
       f.close
    else
       'Cannot open homeDirectories file: '->t.prepend;
       (failureTrace,t[])->stop
   if);
#)

-- fcPrivate: Descriptor --
(# #)

-- fcInit: DoPart --
do
-- fcConvertFilePath: Descriptor --
(# #)
