ORIGIN 'pathhandlerbody';
INCLUDE '../envstring';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/javalib/betahelpers';
INCLUDE '~beta/javalib/java/lang/System';
INCLUDE '~beta/javalib/java/io/File';

-- LIB: Attributes --
homeDirectories: (#  exit 'configuration/homeDirectories' #);   
use_static_fields:
  (# exit false #);

upcase_drive_name:
     (#
        path: ^text;
        ch1: @char;
        isLowAlpha: (* Much cheaper than ascii.isUpper *)
          (# ch: @char enter ch exit ('a' <= ch) and (ch <= 'z') #);
        
     enter path[]
     do
        (if (path[] <> none ) and (path.lgth >= 2) and (path.T[2] = ':') and
        (path.T[1]->ch1->isLowAlpha) then
            ch1-('a'-'A')->path.T[1]; 
        if);
        
     #);

-- PathHandlerDirectoryChar: DoPart --
do (if use_static_fields then
       (*File.separatorChar -> value*)
    else
       1 -> ('file.separator'-> System.getProperty_String->String2Text).inxGet -> value
   if);

-- PathHandlerDirectoryCharRegExp: DoPart --
do  (if use_static_fields then
        (*File.separator -> t[]*)
     else
        'file.separator' -> System.getProperty_String->t[]  
    if);

-- PathHandlerIsDirectoryChar: DoPart --
do (if use_static_fields then
       (*c = File.separatorChar -> value*)
    else
       c = (1 -> ('file.separator'-> System.getProperty_String->String2Text).inxGet) -> value
   if);

-- PathhandlerSearchPath: DoPart --
do  ('java.library.path') -> System.getProperty_String -> path[]  

-- PathhandlerSearchPathDelimiter: DoPart --
do  (if use_static_fields then
        (*File.pathSeparatorChar -> value*)
     else
        1 -> ('path.separator'-> System.getProperty_String->String2Text).inxGet -> value
    if)

-- PathHandlerCurrentDirectory: DoPart --
do 'user.dir'-> System.getProperty_String->cwd[];
   
-- convertFilePathBody: Descriptor --
(#
   endedBySlash: @boolean;
   slashInx,index: @integer;
   pathlength,basislength: @integer;
   path,basis: ^Text;
   found: @boolean;
   ch: @char;
   isWin32Path: BooleanValue
     (# p: ^Text; 
     enter p[]
     do '\\'->p.findAll (#  do true->value #); 
     #);
   tildeExpand: 
     (* tilde expand path, disregarding basis.
      * That is: expand ~/... and ~user/...
      *)
     (# t,h,n: ^text; found: @boolean; 
     do
        Private.Nametable.Scan
          (# 
          do
             (if ((1,currentSize)->path.sub->thisHome.equal) then
                 (1,currentSize)->path.delete;
                 thisDir[]->path.prepend;
                 path.length->pathlength;
                 true->found;
                 (* leave not allowed here *)
                 
             if)
          #);
        (if found then leave tildeExpand if);
        (* find first slash *);
        0->slashInx;
        loop: '/'->path.findAll (#  do inx->slashInx; leave loop #);
        (*'tildeexpand: slashInx='->puttext; slashInx->putint; ' in ' ->puttext; path[] -> putline;*)
        (if true
         // slashInx=2 
            (* path = ~/... *)
         // (slashInx>2) 
            and ('user.name'->System.getProperty_String->((3,slashInx)->path.sub).equal)
            (* path = ~thisuser/... *)
            then
            (1,slashInx)->path.sub->h[];
            'user.home'->System.getProperty_String->n[];
            '/'->n.put;
            (h[],n[])->Private.nameTable.newHomeDir;
            (1,slashinx)->path.delete;
            n[]->path.prepend;
            path.length->pathlength;
            (*'expanding to ' -> puttext; path[]->putline;*)
         else
            (* We cannot handle ~someuser/... on JVM *)
            (*'NOT expanding' -> putline;*)
        if)
     #);
   os: ^String;
   isWindows: @boolean;
do 'Windows'->('os.name'-> System.getProperty_String->os[]).startsWith_String->isWindows;
   1 -> ('file.separator'-> System.getProperty_String->String2Text).inxGet -> directoryChar;
   (if THIS(ConvertFilePath).path[] <> none then
       THIS(ConvertFilePath).path.copy->path[];
       path.length->pathlength;
       (if pathlength <> 0 then
           (if (pathlength->path.inxget)
            // '/' // '\\' then true->endedBySlash
           if);
           (if THIS(ConvertFilePath).basis[] = none then
               CurrentDirectory->basis[]; 
            else
               THIS(ConvertFilePath).basis.copy->basis[]; 
           if);
           (if basis.length = 0 then CurrentDirectory->basis[] if);
           basis.length->basislength;
           (if ((pathlength->path.inxget) <> '/') and
           ((pathlength->path.inxget) <> '\\') then
               (if path[]->isWin32Path then
                   '\\'->path.put; 
                else
                   '/'->path.put; 
               if);
               pathlength+1->pathlength;
               
           if);
           (if ((basislength->basis.inxget) <> '/') and
           ((basislength->basis.inxget) <> '\\') then
               (if basis[]->isWin32Path then
                   '\\'->basis.put; 
                else
                   '/'->basis.put; 
               if);
               basislength+1->basislength;
               
           if);
           path[]->expandEnvVar->path[];
           (* Expand environment variables *)
           basis[]->expandEnvVar->basis[];
           (* Expand environment variables *)
           path.length->pathlength;
           basis.length->basislength;
           converter:
             (#
                unknownPrefix:
                  (#
                  (* The prefix of path is unknown.
                   * It must be a local file
                   *) 
                  do
                     (if './'->basis.equal then leave converter if);
                     (if '.\\'->basis.equal then leave converter if);
                     ('./',1)->path.insert;
                     pathlength+2->pathlength;
                     restart converter
                  #);
                
             do
                (if (1->path.inxGet)
                 // '/' // '\\' then (* absolute path *)
                    leave converter
                 // '~' then
                    tildeExpand; leave converter; 
                 // '.' then
                    (if ('./'->basis.equal) or ('.\\'->basis.equal) then
                        leave converter
                    if);
                    (* path is a relative path starting with .
                     * since path is '/'-terminated, length >=2
                     *)
                    (if (2->path.inxGet)
                     // '.' then
                     (* path starts with '..'
                      * Since path is always terminated by '/',
                      * length is >=3
                      *)
                        (if (3->path.inxGet)
                         // '/' // '\\' then
                         (* path starts with '../' or '..\'
                          * delete prefix of path
                          * and last component of basis
                          * and rerun converter
                          *)
                            (1,3)->path.delete;
                            pathlength-3->pathlength;
                            0->index;
                            '/'
                              ->basis.findAll
                                (# 
                                do
                                   (if inx = basislength then
                                   (* found the terminating slash *)
                                       (if index <> 0 then
                                       (* found slash before the last one
                                        * in basis
                                        *)
                                           (index+1,basislength)->basis.delete;
                                           basis.length->basislength;
                                           (if pathlength = 0 then
                                               basis->path;
                                               basislength->pathlength;
                                               leave converter
                                           if);
                                           
                                        else
                                       (* only terminating slash in basis. *)
                                           (if inx = 1 then (* basis='/' *)
                                               NoFather;
                                               (* in case NoFather continues: *)
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               leave converter;
                                               
                                            else
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               './'->basis.prepend;
                                               basislength+2->basislength;
                                               
                                           if)
                                       if);
                                       restart converter
                                    else
                                   (* save the position of this slash *)
                                       inx->index
                                   if)
                                #);
                            (if index = 0 then
                            (* Did not find any '/'.
                             * Try 'directoryChar' in basis
                             *)
                                '\\'
                                  ->basis.findAll
                                    (# 
                                    do
                                       (if inx = basislength then
                                       (* found the terminating
                                        * 'directoryChar'
                                        *)
                                           (if index <> 0 then
                                           (* found 'directoryChar'
                                            * before the last one in basis
                                            *)
                                               (index+1,basislength)
                                                 ->basis.delete;
                                               basis.length->basislength;
                                               (if pathlength = 0 then
                                                   basis->path;
                                                   basislength->pathlength;
                                                   leave converter
                                               if);
                                               
                                            else
                                           (* only 'directoryChar'
                                            * last in basis:
                                            * basis is a volume name
                                            *)
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               
                                           if);
                                           restart converter
                                        else
                                       (* save the position of this
                                        * 'directoryChar'
                                        *)
                                           inx->index
                                       if)
                                    #);
                                
                            if);
                            
                         else
                        (* path starts with ..something,
                         * it must be a local file/directory
                         * named '..something'
                         *)
                            unknownprefix; 
                        if)
                     // '/' // '\\' then
                        (* Path starts with './', i.e. a path local to basis
                         * delete prefix of path, concatenate basis and path
                         * and return path 
                         *)
                        (1,2)->path.delete;
                        basis[]->path.prepend;
                        path.length->pathlength;
                        leave converter
                     else
                    (* path starts with .something,
                     * it must be a local file/directory
                     *)
                        unknownPrefix
                    if);
                    
                 else
                    false->found;
                    ':' (* ':' separates the volume from the path *)
                      ->path.findAll (#  do true->found #);
                    (* if we have a 'directoryChar',
                     * we have a global name on Win32
                     *)
                    (if not found then unknownPrefix if);
                    leave converter
                if);
                
             #);
           (* Converter done *)
           (* Check that the path is ended by slash iff the original one was *)
           (if ((pathlength->path.inxget) = '/') or
               ((pathlength->path.inxget) = '\\') then
               (if not endedBySlash then
                   (if pathlength = 1 then (* special case: the result was '/' *)
                       
                    else
                       (pathlength,pathlength)->path.delete; 
                   if);
                   
               if)
            else
               (if endedBySlash then '\\'->path.put;  if)
           if);
           (if isWindows then
               (* replace / with \ *)
               ('/','\\',path[])->substChars;
               (* Check that there are no '\\' in the path unless first *)
               - 1->slashInx;
               '\\'
                 ->path.findAll
               (# 
               do
                  (if inx > slashInx then
                      (if inx = slashInx+1 then
                          (if inx > 2 then (* two consecutive 'directoryChar' *)
                              (inx,inx)->path.delete
                          if);
                          
                       else
                          (* remember position of last 'directoryChar' *)
                          inx->slashInx
                      if)
                  if)
               #);
            else
               (path[],'/',1)->removeDoubleCh;
           if)
       if);
       path[]->upcase_drive_name; path.copy->convertedpath[]
   if)
#)

-- PathHandlerInitNameTable: Descriptor --
(# os: ^String;
   isWindows: @boolean;
do 'Windows'->('os.name'-> System.getProperty_String->os[]).startsWith_String->isWindows;
   1 -> ('file.separator'-> System.getProperty_String->String2Text).inxGet -> directoryChar;
   '$(BETALIB)'
   ->expandEnvVar
   (# defaultValue::<  
        (#  
        do (if isWindows then
               'c:\\beta\\' -> envvarvalue[]; 
            else
               '/usr/local/lib/beta' -> envvarvalue[];
           if);
        #)
   #) -> BetaLib[];
   'user.dir'-> System.getProperty_String->private.CurrentDirectory[];
   'file.separator'-> System.getProperty_String->private.CurrentDirectory.append;
   
   (* Register ~beta *)
   (if isWindows then
       (if (BetaLib.length->BetaLib.inxGet) <> '\\' then
           '\\'->BetaLib.append; 
       if);
       BetaLib[] -> upcase_drive_name;
       ('~beta\\',betalib[])->&newHomeDir;
    else
       (if (BetaLib.length->BetaLib.inxGet) <> '/' then
           '/'->private.BetaLib.append; 
       if);
   if);
      (if trace_homedirectories then
       'File: '->puttext;
       homeDirectories->(private.BetaLib.Copy).Append->putline
      if);
   ('~beta/',betalib[])->&newHomeDir;
   
   (* Read homeDirectories file(s) *)
   (if trace_homedirectories then
       'File: '->puttext; '.homedirectories'->putline
   if);
   '.homedirectories'->readHomeDirectoriesFile;
   (if trace_homedirectories then
       'File: '->puttext;
       '$(HOME)/.homedirectories'->expandenvvar->putline
   if);
   '$(HOME)/.homedirectories'->expandenvvar->readHomeDirectoriesFile;
   (if trace_homedirectories then
       'File: '->puttext;
       homeDirectories->(private.BetaLib.Copy).Append->putline
   if);
   homeDirectories->(private.BetaLib.Copy).Append->readHomeDirectoriesFile;
#)  

-- fcPrivate: Descriptor --
(#  #)  

-- fcInit: DoPart --
do   

-- fcConvertFilePath: Descriptor --
(#  #)  

-- PathHandlerApplDirectory: DoPart --
do
   (#
      fullpath: @boolean;
      entry: @diskentry;
      fileName: ^text (* OBS! overrides the one declared in origin! *)
   do
      1->Arguments->fileName[];
      '/'->filename.findAll (#  do true->fullPath;  #);
      (if (fullpath) then
          filename[]->entry.path
       else
          scanSearchPath
          (# 
          do
             path.length->path.setpos;
             DirectoryChar->path.put;
             fileName[]->(path.copy).append->entry.path
          #)
      if);
      (if entry.exists then entry.path.head->path[]; '/'->path.append if)
   #)  
   
