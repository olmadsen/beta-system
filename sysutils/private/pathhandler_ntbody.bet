ORIGIN 'pathhandlerbody';

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)

INCLUDE '~beta/win32lib/v1.1/ntinterface';

-- LIB: attributes --

homeDirectories:
  (# exit 'configuration\\r4.0\\homeDirectories' #);

substChars:
  (# p: ^text;
     from, to: @char
  enter (from,to,p[])
  do
     (* replace 'from' with 'to' *)
     from->p.findCh(# do (to,inx)->p.inxPut #);
  #)


--PathHandlerCurrentDirectory: dopart--
do getCurrentDir->cwd[];
--PathHandlerCurDir: dopart--
do private.currentdirectory.copy->value[]
--PathHandlerBetaLib: dopart--
do private.betalib.copy->value[]

--PathHandlerDirectoryChar: dopart--
do '\'->c
   
--PathhandlerSearchPath: dopart--
do '$(PATH)' -> path[]
--PathhandlerSearchPathDelimiter: dopart--
do ';' -> delimiter

------ convertFilePathBody: descriptor -------
(# endedBySlash: @boolean;
   slashInx,index: @integer;
   pathlength, basislength: @integer;
   path,basis: ^Text;
   ch: @char;
   
   isWin32Path: BooleanValue
     (# p: ^Text; 
     enter p[]
     do '\'->p.findCh(# do true->value #);
     #);
   
do (if THIS(ConvertFilePath).path[]//NONE then
    else
       &text[]->path[]; 
       THIS(ConvertFilePath).path->path;
       path.length->pathlength;
       (if pathlength<>0//true then
           (if (pathlength->path.inxget)//'/'//'\'
               then true->endedBySlash if);
           &text[]->basis[]; 
           (if THIS(ConvertFilePath).basis[]//NONE then 
               private.CurrentDirectory->basis;
            else 
               THIS(ConvertFilePath).basis->basis;
           if);
           (if basis.length//0 then private.CurrentDirectory->basis if);
           basis.length->basislength;
           (if ((pathlength->path.inxget)<>'/') and
               ((pathlength->path.inxget)<>'\')//true
               then 
               (if path[]->isWin32Path//true then
                   '\'->path.put;
                else
                   '/'->path.put;
               if);
               pathlength+1->pathlength;
           if);
           (if ((basislength->basis.inxget)<>'/') and
               ((basislength->basis.inxget)<>'\')//true
               then 
               (if basis[]->isWin32Path//true then
                   '\'->basis.put;
                else
                   '/'->basis.put;
               if);
               basislength+1->basislength;
           if);
           path[]->expandEnvVar->path[];   (* Expand environment variables *)
           basis[]->expandEnvVar->basis[]; (* Expand environment variables *)
           path.length->pathlength;
           basis.length->basislength;
           converter: 
             (# T: ^text; index: @integer; firstCh: @char; found: @boolean;
                unknownPrefix: 
                  (# (* The prefix of path is unknown.
                      * It must be a local file
                      *)
                  do ('./',1)->path.insert; 
                     pathlength+2->pathlength;
                     restart converter
                  #);
             do 
                (if (1->path.inxGet)
                 // '/' 
                 // '\' then (* absolute path *)
                    leave converter
                 // '~' then
                    (* try look in table:
                     * We cannot expand usernames on Win32
                     *)
                    test: 
                      (if 1//1 then
                          private.nameTable.scan
                          (#
                          do (if ((1,currentSize)->path.sub->thisHome.equal)
                              // true then
                                 (1,currentSize)->path.delete;
                                 thisDir[]->path.prepend;
                                 path.length->pathlength;
                                 leave test;
                          if)#);
                          (* not found in table: expand ~ as betalib *)
                          (1,1)->path.delete;
                          private.betalib[]->path.prepend;
                          path.length->pathlength;
                      if);
                 // '.' then (* this is new from unix version *)
                    (if ('./'->basis.equal) or ('.\\'->basis.equal)
                        then leave converter
                    if);
                    (* path is a relative path starting with .
                     * since path is '/'-terminated, length >=2
                     *)
                    (if (2->path.inxGet)
                     // '.' then
                        (* path starts with '..'
                         * Since path is always terminated by '/',
                         * length is >=3
                         *)
                        (if (3->path.inxGet)
                         // '/'
                         // '\' then
                            (* path starts with '../' or '..\'
                             * delete prefix of path
                             * and last component of basis
                             * and rerun converter
                             *)
                            (1,3)->path.delete; pathlength-3->pathlength;
                            0->index; 
                            '/'->basis.findCh
                            (# 
                            do (if inx//basislength then
                                   (* found the terminating slash *)
                                   (if index<>0
                                    // true then 
                                       (* found slash before the last one
                                        * in basis
                                        *)
                                       (index+1,basislength)->basis.delete;
                                       basis.length->basislength;
                                       (if pathlength//0 then 
                                           basis->path;
                                           basislength->pathlength;
                                           leave converter
                                       if);
                                    // false then
                                       (* only terminating slash in basis. *)
                                       (if inx//1 then (* basis='/' *)
                                           NoFather;
                                           (* in case NoFather continues: *)
                                           '../'->path.prepend;
                                           pathlength+3->pathlength;
                                           leave converter; 
                                        else
                                           '../'->path.prepend;
                                           pathlength+3->pathlength;
                                           './'->basis.prepend;
                                           basislength+2->basislength;
                                       if)
                                   if);
                                   restart converter
                                else
                                   (* save the position of this slash *)
                                   inx->index
                               if)
                            #);
                            (if index//0 then
                                (* Did not found any '/'.
                                 * Try 'directoryChar' in basis
                                 *)
                                '\'->basis.findCh
                                (# 
                                do (if inx//basislength then
                                       (* found the terminating
                                        * 'directoryChar'
                                        *)
                                       (if index<>0
                                        // true then 
                                           (* found 'directoryChar'
                                            * before the last one in basis
                                            *)
                                           (index+1,basislength)->basis.delete;
                                           basis.length->basislength;
                                           (if pathlength//0 then 
                                               basis->path;
                                               basislength->pathlength;
                                               leave converter
                                           if);
                                        // false then
                                           (* only 'directoryChar'
                                            * last in basis:
                                            * basis is a volume name
                                            *)
                                           '../'->path.prepend;
                                           pathlength+3->pathlength;
                                       if);
                                       restart converter
                                    else
                                       (* save the position of this
                                        * 'directoryChar'
                                        *)
                                       inx->index
                                   if)
                                #);
                            if);
                         else 
                            (* path starts with ..something,
                             * it must be a local file/directory
                             * named '..something'
                             *)
                            unknownprefix;
                        if)
                     // '/'
                     // '\' then
                        (* Path starts with './', i.e. a path local to basis
                         * delete prefix of path, concatenate basis and path
                         * and return path 
                         *)
                        (1,2)->path.delete; 
                        basis[]->path.prepend; path.length->pathlength;
                        leave converter
                     else
                        (* path starts with .something,
                         * it must be a local file/directory
                         *)
                        unknownPrefix
                    if);
                 else 
                    false->found;
                    ':' (* ':' separates the volume from the path *)
                      ->path.findCh(# do true->found #);
                    (* if we have a 'directoryChar',
                     * we have a global name on Win32
                     *)
                    (if found//false then unknownPrefix if);
                    leave converter
             if)#);
           (* Converter done *)
           (* Check that the path is ended by slash iff the original one was *)
           (if ((pathlength->path.inxget)='/') OR
               ((pathlength->path.inxget)='\')//true
               then
               (if endedBySlash//false then 
                   (if pathlength//1 then
                       (* special case: the result was '/' *)
                    else
                       (pathlength, pathlength)->path.delete; 
                   if);
               if)
            else
               (if endedBySlash//true
                   then '\'->path.put; if)
           if);
           (* replace / with \ *)
           ('/','\',path[])->substChars;
           (* Check that there are no '\\' in the path unless first *)
           -1->slashInx;
           '\'->path.findCh
           (# 
           do (if inx > slashInx
               // true then
                  (if inx=slashInx+1
                   // true then 
                      (if inx>2//true then
                          (* two consecutive 'directoryChar' *)
                          (inx, inx)->path.delete
                      if);
                   // false then
                      (* remember position of last 'directoryChar' *)
                      inx->slashInx
                  if)
              if)
           #);
           &text[]->convertedpath[];
           path->convertedpath;
           loop: (* on Win32: case in file names is not significant *)
             (for i:convertedpath.length repeat
                  (if (convertedpath.T[i]->ch)
                   // '-' then leave loop
                   else ch->ascii.lowCase->convertedpath.T[i];
                  if)
             for)
if)if)#)

-- pathHandlerPrivate: descriptor --
(# t: @Text;
   betalib, currentdirectory: ^Text;
   NameTable: @
     (# Home,HomeDir: [100] ^text; top: @integer;
        NewHomeDir: 
          (# H,D: ^text;
             found: @boolean
          enter(H[],D[])
          do false->found;
             scanning: scan
               (# 
               do (if (thisHome[]->h.equal) then 
                      D->HomeDir[currentInx]; 
                      true->found; 
                      leave scanning
                  if);
               #);
             (if not found then
                 (if ((top+1->top)<=Home.range) then
                     &Text[]->Home[top][]; H->Home[top]; 
                     &Text[]->HomeDir[top][]; D->HomeDir[top]
                 if)
             if)
          #);
        Scan: 
          (# thisHome,thisDir: @text; currentInx,currentSize: @integer
          do (for i: top repeat
                  i->currentInx;
                  Home[i].length->currentSize;
                  Home[i]->thisHome;
                  HomeDir[i]->thisDir;
                  INNER
             for);
          #);
        Init: 
          (# homes: @file; abb,fullName : ^text;
          do '$(BETALIB)' 
               ->expandEnvVar(# defaultValue::< 
                                  (# do 'c:\\beta\\' -> envvarvalue[]; #);
                             #)
               ->betalib[];
             
             (if (private.BetaLib.length->private.BetaLib.inxGet) <> '\' then 
                 '\' -> private.BetaLib.append;
             if);
             
             betalib.makeLC;
             
             getCurrentDir -> private.CurrentDirectory[];
	     '\' -> private.CurrentDirectory.append;
             
             ('~beta\\',betalib[]) -> &newHomeDir;
             ('~beta/',betalib[]) -> &newHomeDir;
             
             homeDirectories -> private.BetaLib.CopyAppend 
               -> homes.name;
             (if homes.entry.exists then
                 homes.openRead;
                 loop:
                   (if homes.eos
                    // false then
                       (*'Homedir line: '->puttext;*)
                       homes.getLine -> abb[];
                       (*abb[]->putline;*)
                       homes.getLine -> fullname[];
                       (*fullname[]->putline;*)
                       (if (1 -> fullName.inxget) <> '/' then
                           (fullName[],private.currentDirectory[]) 
                             -> convertFilePath -> fullName[];
                       if);
                       (abb[],fullname[]) -> &newHomeDir;
                       restart loop
                   if);
                 (*'No more homes'->putline;*)
                 homes.close
             if);
             
          #);
     #);
#)

------ localPathBody: descriptor ------
(# path,basis: ^text;
   inx, slashinx, parents: @integer;
   tmp: ^text;
   rmdbl: @removedoubleslash;
do
   findpart:
     (if (this(LocalPath).path[]<>NONE) and
         (this(LocalPath).basis[]<>NONE)
      // true then
         (* copy paths to avoid side-effects *)
         this(LocalPath).path.copy->path[];
         this(LocalPath).basis.copy->basis[];
         (* check that basis can be used *)
         (if basis.length > 0 // true then 
             (if (basis.length -> basis.inxget) <> '/' 
              // true then '/' -> basis.append
             if);
          else currentdirectory -> tmp[]; tmp -> basis;
         if);
         path[] -> rmdbl;
         basis[] -> rmdbl;
         ('/','\',path[]) -> substChars;
         ('/','\',basis[]) -> substChars;
         
         (* Check if basis is a prefix of path *)
         (if (1,basis.lgth) -> path.sub -> basis.equal
          // true then
             &text[] -> localName[];
             path.t[basis.lgth+1:path.lgth] -> localName;
             leave findpart;
         if);
         
         (* Let us se if something in the pathhandler data-structure
          * of home directories (this includes the contents of 
          * $(BETALIB)/homeDirectories) is prefix of path. 
          *)
         (* Private.nameTable.scan {* home directories *}
          * (# 
          * do (if ((1,thisDir.lgth) -> path.sub -> thisDir.equal)
          *     // true then
          *        &text[] -> localName[];
          *        (thisDir.lgth+1,path.lgth) -> path.sub
          *          -> thisHome.CopyAppend -> localName[];
          *        leave findpart
          *    if)
          * #);
          *)
         
         (* Check if basis and path have a common prefix *)
         0 -> inx;
         0 -> slashinx;
         0 -> parents;
         common:
           (for i: (basis.lgth,path.lgth)->min repeat
                (if basis.T[i] <> path.T[i] // true then leave common if);
                i -> inx;
                (if basis.T[i] // directorychar then i -> slashinx if);
           for);

         (* inx points to last char common of the two paths, slashinx points
          * to last common directorychar.
          *)
         (if slashinx > 1 // true then
             (* There was a common prefix (in addition to '/') *)
             path.t[slashinx+1:path.lgth] -> path;
             basis.t[slashinx+1:basis.lgth] -> basis;
             (* find number of '../'s to prepend to path *)
             '\' -> basis.findCh(# do parents+1 -> parents #);
             (for parents repeat '..\' -> path.prepend for);
             path.copy -> localname[];
             leave findpart;
         if);
     if); (* findpart *)

   (if localName[]//NONE then 
       (if path[]//NONE then 
        else
           path.copy->localName[];
       if)
   if);
   
   (* Convert back to normal slashes *)
   ('\','/',localname[])->substChars;
#)

------ pathHandlerInit: dopart -----
do private.nameTable.init;
   '\'->directoryChar

----- fcPrivate: descriptor -----
(# #)
----- fcInit: dopart -------
do
----- fcConvertFilePath: descriptor ------
(# #)
