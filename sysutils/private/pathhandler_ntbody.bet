ORIGIN 'pathhandlerbody' (*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
;
INCLUDE '~beta/win32lib/ntinterface'
        '~beta/sysutils/cstring'
        '~beta/win32lib/winbase'
        '~beta/win32lib/windef'
        '~beta/win32lib/windowsmisc'
        '~beta/win32lib/win32apiinit';
-- LIB: Attributes --
homeDirectories: (#  exit 'configuration\\homeDirectories' #);   

upcase_drive_name:
  (#
     path: ^text;
     ch1: @char;
     isLowAlpha: (* Much cheaper than ascii.isUpper *)
       (# ch: @char enter ch exit ('a' <= ch) and (ch <= 'z') #);
     
  enter path[]
  do
     (if (path[] <> none ) and (path.lgth >= 2) and (path.T[2] = ':') and
         (path.T[1]->ch1->isLowAlpha) then
         ch1-('a'-'A')->path.T[1]; 
     if);
  exit path[]
  #);

-- PathHandlerCurrentDirectory: DoPart --
do getCurrentDir -> upcase_drive_name -> cwd[]; 

-- PathHandlerDirectoryChar: DoPart --
do '\\'->value

-- PathHandlerDirectoryCharRegExp: DoPart --
do '[\\\\/]'->t[]  

-- PathHandlerIsDirectoryChar: DoPart --
do ((c = '\\') or (c = '/'))->value  

-- PathhandlerSearchPath: DoPart --
do '$(PATH)' -> expandenvvar -> path[]  

-- PathhandlerSearchPathDelimiter: DoPart --
do ';'->value  

-- PathhandlerApplDirectory: DoPart --
do
     (# modulePath: @cstring; noOfChars: @integer; 
     do
        MAX_PATH->modulePath.init;
        (get_beta_instance,modulePath,MAX_PATH)->GetModuleFileName->noOfChars;
        (if noOfChars > 0 then
            &Text[]->path[];
            modulePath.get->path.puttext;
            modulePath.get;
            0->modulePath;
              (# lastSlash: @integer; 
              do
                 '\\'->path.findAll (#  do inx->lastSlash #);
                 (lastSlash+1,path.length)->path.delete;
                 
              #);
            
         else
            'GetModuleFileName failed.'->screen.putline;
            GetLastError->getErrorMessage->screen.putline;
            
        if)
     #)  

-- convertFilePathBody: Descriptor --
(#
   endedBySlash: @boolean;
   slashInx,index: @integer;
   pathlength,basislength: @integer;
   path,basis: ^Text;
   found: @boolean;
   ch: @char;
   isWin32Path: BooleanValue
     (# p: ^Text; 
     enter p[]
     do '\\'->p.findAll (#  do true->value #); 
     #);
   tildeExpand:
     (# 
     do (* try look in table:
         * We cannot expand usernames on Win32
         *)
        private.nameTable.scan
          (# 
          do
             (if ((1,currentSize)->path.sub->thisHome.equal) then
                 (1,currentSize)->path.delete;
                 thisDir[]->path.prepend;
                 path.length->pathlength;
                 true->found;
                 
             if)
          #);
        (if found then leave tildeExpand if);
        (* not found in table: expand ~ as betalib *)
        (1,1)->path.delete;
        private.betalib[]->path.prepend;
        path.length->pathlength;
        
     #);
   
do
   (if THIS(ConvertFilePath).path[] <> none then
       THIS(ConvertFilePath).path.copy->path[];
       path.length->pathlength;
       (if pathlength <> 0 then
           (if (pathlength->path.inxget)
            // '/' // '\\' then true->endedBySlash
           if);
           (if THIS(ConvertFilePath).basis[] = none then
               CurrentDirectory->basis[]; 
            else
               THIS(ConvertFilePath).basis.copy->basis[]; 
           if);
           (if basis.length = 0 then CurrentDirectory->basis[] if);
           basis.length->basislength;
           (if ((pathlength->path.inxget) <> '/') and
           ((pathlength->path.inxget) <> '\\') then
               (if path[]->isWin32Path then
                   '\\'->path.put; 
                else
                   '/'->path.put; 
               if);
               pathlength+1->pathlength;
               
           if);
           (if ((basislength->basis.inxget) <> '/') and
           ((basislength->basis.inxget) <> '\\') then
               (if basis[]->isWin32Path then
                   '\\'->basis.put; 
                else
                   '/'->basis.put; 
               if);
               basislength+1->basislength;
               
           if);
           path[]->expandEnvVar->path[];
           (* Expand environment variables *)
           basis[]->expandEnvVar->basis[];
           (* Expand environment variables *)
           path.length->pathlength;
           basis.length->basislength;
           converter:
             (#
                unknownPrefix:
                  (#
                  (* The prefix of path is unknown.
                   * It must be a local file
                   *) 
                  do
                     (if './'->basis.equal then leave converter if);
                     (if '.\\'->basis.equal then leave converter if);
                     ('./',1)->path.insert;
                     pathlength+2->pathlength;
                     restart converter
                  #);
                
             do
                (if (1->path.inxGet)
                 // '/' // '\\' then (* absolute path *)
                    leave converter
                 // '~' then
                    tildeExpand; leave converter; 
                 // '.' then
                    (if ('./'->basis.equal) or ('.\\'->basis.equal) then
                        leave converter
                    if);
                    (* path is a relative path starting with .
                     * since path is '/'-terminated, length >=2
                     *)
                    (if (2->path.inxGet)
                     // '.' then
                     (* path starts with '..'
                      * Since path is always terminated by '/',
                      * length is >=3
                      *)
                        (if (3->path.inxGet)
                         // '/' // '\\' then
                         (* path starts with '../' or '..\'
                          * delete prefix of path
                          * and last component of basis
                          * and rerun converter
                          *)
                            (1,3)->path.delete;
                            pathlength-3->pathlength;
                            0->index;
                            '/'
                              ->basis.findAll
                                (# 
                                do
                                   (if inx = basislength then
                                   (* found the terminating slash *)
                                       (if index <> 0 then
                                       (* found slash before the last one
                                        * in basis
                                        *)
                                           (index+1,basislength)->basis.delete;
                                           basis.length->basislength;
                                           (if pathlength = 0 then
                                               basis->path;
                                               basislength->pathlength;
                                               leave converter
                                           if);
                                           
                                        else
                                       (* only terminating slash in basis. *)
                                           (if inx = 1 then (* basis='/' *)
                                               NoFather;
                                               (* in case NoFather continues: *)
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               leave converter;
                                               
                                            else
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               './'->basis.prepend;
                                               basislength+2->basislength;
                                               
                                           if)
                                       if);
                                       restart converter
                                    else
                                   (* save the position of this slash *)
                                       inx->index
                                   if)
                                #);
                            (if index = 0 then
                            (* Did not find any '/'.
                             * Try 'directoryChar' in basis
                             *)
                                '\\'
                                  ->basis.findAll
                                    (# 
                                    do
                                       (if inx = basislength then
                                       (* found the terminating
                                        * 'directoryChar'
                                        *)
                                           (if index <> 0 then
                                           (* found 'directoryChar'
                                            * before the last one in basis
                                            *)
                                               (index+1,basislength)
                                                 ->basis.delete;
                                               basis.length->basislength;
                                               (if pathlength = 0 then
                                                   basis->path;
                                                   basislength->pathlength;
                                                   leave converter
                                               if);
                                               
                                            else
                                           (* only 'directoryChar'
                                            * last in basis:
                                            * basis is a volume name
                                            *)
                                               '../'->path.prepend;
                                               pathlength+3->pathlength;
                                               
                                           if);
                                           restart converter
                                        else
                                       (* save the position of this
                                        * 'directoryChar'
                                        *)
                                           inx->index
                                       if)
                                    #);
                                
                            if);
                            
                         else
                        (* path starts with ..something,
                         * it must be a local file/directory
                         * named '..something'
                         *)
                            unknownprefix; 
                        if)
                     // '/' // '\\' then
                     (* Path starts with './', i.e. a path local to basis
                      * delete prefix of path, concatenate basis and path
                      * and return path 
                      *)
                        (1,2)->path.delete;
                        basis[]->path.prepend;
                        path.length->pathlength;
                        leave converter
                     else
                    (* path starts with .something,
                     * it must be a local file/directory
                     *)
                        unknownPrefix
                    if);
                    
                 else
                    false->found;
                    ':' (* ':' separates the volume from the path *)
                      ->path.findAll (#  do true->found #);
                    (* if we have a 'directoryChar',
                     * we have a global name on Win32
                     *)
                    (if not found then unknownPrefix if);
                    leave converter
                if);
                
             #);
           (* Converter done *)
           (* Check that the path is ended by slash iff the original one was *)
           (if ((pathlength->path.inxget) = '/') or
               ((pathlength->path.inxget) = '\\') then
               (if not endedBySlash then
                   (if pathlength = 1 then (* special case: the result was '/' *)
                       
                    else
                       (pathlength,pathlength)->path.delete; 
                   if);
                   
               if)
            else
               (if endedBySlash then '\\'->path.put;  if)
           if);
           (* replace / with \ *)
           ('/','\\',path[])->substChars;
           (* Check that there are no '\\' in the path unless first *)
           - 1->slashInx;
           '\\'
             ->path.findAll
           (# 
           do
              (if inx > slashInx then
                  (if inx = slashInx+1 then
                      (if inx > 2 then (* two consecutive 'directoryChar' *)
                          (inx,inx)->path.delete
                      if);
                      
                   else
                      (* remember position of last 'directoryChar' *)
                      inx->slashInx
                  if)
              if)
           #);
       if);
       (if LowCaseFilenamesOnPC_Mac then
           path.copy->lowcasepath->convertedpath[]
        else
           path[]->upcase_drive_name; path.copy->convertedpath[]
       if);
   if)
#)  

-- PathHandlerInitNameTable: Descriptor --
(# 
do
   '\\'->directoryChar;
   '$(BETALIB)'
     ->expandEnvVar
       (# defaultValue::<  (#  do 'c:\\beta\\'->envvarvalue[];  #) #)
     ->betalib[];
   (1->betalib.inxGet->ascii.upcase,1)->betalib.inxPut;
   (if (private.BetaLib.length->private.BetaLib.inxGet) <> '\\' then
       '\\'->private.BetaLib.append; 
   if);
   (if LowCaseFilenamesOnPC_Mac then betalib.makeLC if);
   getCurrentDir->upcase_drive_name->private.CurrentDirectory[];
   '\\'->private.CurrentDirectory.append;
   (if LowCaseFilenamesOnPC_Mac then private.CurrentDirectory.makeLC if);
   ('~beta\\',betalib[])->&newHomeDir;
   ('~beta/',betalib[])->&newHomeDir;
   (if trace_homedirectories then
       'File: '->puttext; '.homedirectories'->putline
   if);
   '.homedirectories'->readHomeDirectoriesFile;
   (if trace_homedirectories then
       'File: '->puttext;
       homeDirectories->(private.BetaLib.Copy).Append->putline
   if);
   homeDirectories->(private.BetaLib.Copy).Append->readHomeDirectoriesFile;
   
#)  

-- fcPrivate: Descriptor --
(#  #)  

-- fcInit: DoPart --
do   

-- fcConvertFilePath: Descriptor --
(#  #)  

