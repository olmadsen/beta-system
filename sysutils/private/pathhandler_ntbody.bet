ORIGIN 'pathhandlerbody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE '~beta/win32lib/v1.6/ntinterface';
-- LIB: Attributes --
homeDirectories: (# exit 'configuration\\homeDirectories' #); 

-- PathHandlerCurrentDirectory: DoPart --
do getCurrentDir->cwd[]; 

-- PathHandlerDirectoryChar: DoPart --
do '\\'->c  

-- PathhandlerSearchPath: DoPart --
do '$(PATH)'->path[]  

-- PathhandlerSearchPathDelimiter: DoPart --
do ';'->delimiter  

-- convertFilePathBody: Descriptor --
(#
   endedBySlash: @boolean;
   slashInx,index: @integer;
   pathlength,basislength: @integer;
   path,basis: ^Text;
   found: @boolean;
   ch: @char;
   isWin32Path: BooleanValue
     (# p: ^Text; 
     enter p[]
     do '\\'->p.findAll (# do true->value #); 
     #);
   tildeExpand:
     (# 
     do (* try look in table:
	 * We cannot expand usernames on Win32
	 *)
	private.nameTable.scan
	(# 
	do (if ((1,currentSize)->path.sub->thisHome.equal) then
	       (1,currentSize)->path.delete;
	       thisDir[]->path.prepend;
	       path.length->pathlength;
	       true -> found;
	   if)
	#);
	(if found then leave tildeExpand if);
	(* not found in table: expand ~ as betalib *)
	(1,1)->path.delete;
	private.betalib[]->path.prepend;
	path.length->pathlength;
     #);
do (if THIS(ConvertFilePath).path[]<>none then 
       THIS(ConvertFilePath).path.copy->path[];
       path.length->pathlength;
       (if pathlength <> 0 then
	   (if (pathlength->path.inxget)
	    // '/' // '\\' then true->endedBySlash
	   if);
	   &text[]->basis[];
	   (if THIS(ConvertFilePath).basis[]=none then 
	       private.CurrentDirectory->basis; 
	    else
	       THIS(ConvertFilePath).basis->basis; 
	   if);
	   (if basis.length = 0 then private.CurrentDirectory->basis if);
	   basis.length->basislength;
	   (if ((pathlength->path.inxget) <> '/') and
	       ((pathlength->path.inxget) <> '\\') then
	       (if path[]->isWin32Path then 
		   '\\'->path.put; 
		else
		   '/'->path.put; 
	       if);
	       pathlength+1->pathlength;
	   if);
	   (if ((basislength->basis.inxget) <> '/') and
	       ((basislength->basis.inxget) <> '\\') then
	       (if basis[]->isWin32Path then 
		   '\\'->basis.put; 
		else
		   '/'->basis.put; 
	       if);
	       basislength+1->basislength;
	   if);
	   path[]->expandEnvVar->path[];
	   (* Expand environment variables *)
	   basis[]->expandEnvVar->basis[];
	   (* Expand environment variables *)
	   path.length->pathlength;
	   basis.length->basislength;
	   converter:
	     (#
		unknownPrefix:
		  (# (* The prefix of path is unknown.
		      * It must be a local file
		      *) 
		  do ('./',1)->path.insert;
		     pathlength+2->pathlength;
		     restart converter
		  #);
	     do (if (1->path.inxGet)
		 // '/' 
		 // '\\' then (* absolute path *)
		    leave converter
		 // '~' then
		    tildeExpand;
		    leave converter;
		 // '.' then 
		    (if ('./'->basis.equal) or ('.\\'->basis.equal) then
			leave converter
		    if);
		    (* path is a relative path starting with .
		     * since path is '/'-terminated, length >=2
		     *)
		    (if (2->path.inxGet)
		     // '.' then
			(* path starts with '..'
			 * Since path is always terminated by '/',
			 * length is >=3
			 *)
			(if (3->path.inxGet)
			 // '/' 
			 // '\\' then
			    (* path starts with '../' or '..\'
			     * delete prefix of path
			     * and last component of basis
			     * and rerun converter
			     *)
			    (1,3)->path.delete;
			    pathlength-3->pathlength;
			    0->index;
			    '/'->basis.findAll
			    (# 
			    do (if inx=basislength then
				   (* found the terminating slash *)
				   (if index <> 0 then
				       (* found slash before the last one
					* in basis
					*)
				       (index+1,basislength)->basis.delete;
				       basis.length->basislength;
				       (if pathlength=0 then
					   basis->path;
					   basislength->pathlength;
					   leave converter
				       if);
				    else
				       (* only terminating slash in basis. *)
				       (if inx=1 then (* basis='/' *)
					   NoFather;
					   (* in case NoFather continues: *)
					   '../'->path.prepend;
					   pathlength+3->pathlength;
					   leave converter;
					else
					   '../'->path.prepend;
					   pathlength+3->pathlength;
					   './'->basis.prepend;
					   basislength+2->basislength;
				       if)
				   if);
				   restart converter
				else
				   (* save the position of this slash *)
				   inx->index
			       if)
			    #);
			    (if index=0 then
				(* Did not find any '/'.
				 * Try 'directoryChar' in basis
				 *)
				'\\'->basis.findAll
				(# 
				do (if inx=basislength then
				       (* found the terminating
					* 'directoryChar'
					*)
				       (if index <> 0 then
					   (* found 'directoryChar'
					    * before the last one in basis
					    *)
					   (index+1,basislength)
					     ->basis.delete;
					   basis.length->basislength;
					   (if pathlength=0 then
					       basis->path;
					       basislength->pathlength;
					       leave converter
					   if);
					else
					   (* only 'directoryChar'
					    * last in basis:
					    * basis is a volume name
					    *)
					   '../'->path.prepend;
					   pathlength+3->pathlength;
				       if);
				       restart converter
				    else
				       (* save the position of this
					* 'directoryChar'
					*)
				       inx->index
				   if)
				#);
			    if);
			 else
			    (* path starts with ..something,
			     * it must be a local file/directory
			     * named '..something'
			     *)
			    unknownprefix; 
			if)
		     // '/' 
		     // '\\' then
			(* Path starts with './', i.e. a path local to basis
			 * delete prefix of path, concatenate basis and path
			 * and return path 
			 *)
			(1,2)->path.delete;
			basis[]->path.prepend;
			path.length->pathlength;
			leave converter
		     else
			(* path starts with .something,
			 * it must be a local file/directory
			 *)
			unknownPrefix
		    if);
		 else
		    false->found;
		    ':' (* ':' separates the volume from the path *)
		      ->path.findAll (# do true->found #);
		    (* if we have a 'directoryChar',
		     * we have a global name on Win32
		     *)
		    (if not found then unknownPrefix if);
		    leave converter
		if);
	     #)
       if);
       (* Converter done *)
       (* Check that the path is ended by slash iff the original one was *)
       (if ((pathlength->path.inxget) = '/')  or
	   ((pathlength->path.inxget) = '\\') then
	   (if not endedBySlash then
	       (if pathlength=1 then 
		   (* special case: the result was '/' *) 
		else
		   (pathlength,pathlength)->path.delete; 
	       if);
	   if)
	else
	   (if endedBySlash then '\\'->path.put; if)
       if);
       (* replace / with \ *)
       ('/','\\',path[])->substChars;
       (* Check that there are no '\\' in the path unless first *)
       -1->slashInx;
       '\\'->path.findAll
       (# 
       do (if inx > slashInx then
	      (if inx = slashInx+1 then
		  (if inx > 2 then (* two consecutive 'directoryChar' *)
		      (inx,inx)->path.delete
		  if);
	       else
		  (* remember position of last 'directoryChar' *)
		  inx->slashInx
	      if)
	  if)
       #);
       path.copy -> convertedpath[];
   if)
#)


-- PathHandlerInitNameTable: descriptor --
(# homes: @file; abb,fullName: ^text;
do '\\'->directoryChar;
   '$(BETALIB)'
     ->expandEnvVar
   (#
      defaultValue::<
	(# do 'c:\\beta\\'->envvarvalue[]; #);

   #)->betalib[];
   (if (private.BetaLib.length->private.BetaLib.inxGet) <> '\\' then
       '\\'->private.BetaLib.append;
   if);
   betalib.makeLC;
   getCurrentDir->private.CurrentDirectory[];
   '\\'->private.CurrentDirectory.append;
   ('~beta\\',betalib[])->&newHomeDir;
   ('~beta/',betalib[])->&newHomeDir;
   homeDirectories->(private.BetaLib.Copy).Append->homes.name;
   (if homes.entry.exists then
       homes.openRead;
       loop:
	 (if not homes.eos then
	     (*'Homedir line: '->puttext;*)
	     homes.getLine->abb[];
	     (*abb[]->putline;*)
	     homes.getLine->fullname[];
	     (*fullname[]->putline;*)
	     (if (1->fullName.inxget) <> '/' then
		 (fullName[],private.currentDirectory[])
		   ->convertFilePath->fullName[];

	     if);
	     (abb[],fullname[])->&newHomeDir;
	     restart loop
	 if);
       (*'No more homes'->putline;*)
       homes.close
   if);
#)

-- fcPrivate: Descriptor --
(# #)
-- fcInit: DoPart --
do
-- fcConvertFilePath: Descriptor --
(# #)
