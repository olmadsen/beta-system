ORIGIN '../pathhandler';
MDBODY   mac     'pathhandler_macbody'
	 ppc     'pathhandler_macbody'
	 ppcmac  'pathhandler_macbody'
	 nti     'pathhandler_ntbody'
	 default 'pathhandler_unixbody';

INCLUDE '~beta/basiclib/v1.5/file'
        '~beta/basiclib/v1.5/external'
        '../envstring';

--LIB: attributes--
searchPath: 
  (# path: ^text;
  <<SLOT PathhandlerSearchPath: dopart>>
  exit path[]
  #);
searchPathDelimiter: 
  (# delimiter: @char;
  <<SLOT PathhandlerSearchPathDelimiter: dopart>>
  exit delimiter
  #);
     
removedoubleslash:
  (# p: ^text;
     inx, slashinx: @integer;
     dirCh: @char;
  enter p[]
  do (* Check that there are no double slashes in p *)
     -2 -> slashInx;
     DirectoryChar -> dirCh;
     search:
       (for inx: p.lgth repeat
            (if inx>p.lgth // true then leave search if);
            (if p.T[inx] 
             // '/' 
             // dirCh then 
                (if inx > slashInx
                 // true then
                    (if inx = slashInx+1
                     // true then 
                        (* two consecutive slashes *)
                        (slashinx, slashinx) -> p.delete;
                        inx-1 -> inx; (* one less char ! *)
                     // false then 
                        (* remember position of last slash *)
                        inx -> slashInx;
                    if)
                if)
            if);
       for);
  #);

substChars:
  (* replace 'from' with 'to' in 'p' *)
  (# p: ^text; 
     from,to: @char;
  enter (from,to,p[])
  do from->p.findAll(# do (to,inx)->p.inxPut #); 
  #);

lowcasepath:
  (* Lowcase path, stoppping at a '-' *)
  (# path: ^text; ch: @char;
  enter path[]
  do loop:
       (for i: path.length repeat
            (if (path.T[i]->ch)='-' 
                then leave loop
             else
                ch->ascii.lowCase->path.T[i]; 
            if)
       for)
  exit path[]
  #);

-- PathHandlerPrivate: Descriptor --
(#
   betalib, currentdirectory: ^text;
   NameTable: @
     (# Home,HomeDir: [20] ^text;
        top: @integer;
        NewHomeDir:
          (# H,D: ^text;
          enter (H[],D[])
          do (if ((top+1->top) > Home.range) then
                 10->home.extend; 
                 10->homeDir.extend; 
             if);
             h.copy->Home[top][];
             d.copy->HomeDir[top][]
          #);
        Scan:
          (* Do not *change* thisHome or thisDir! *)
          (# currentInx, currentSize: @integer;
             thisHome,thisDir: ^text;
          do (for i: top repeat
                  i->currentInx;
                  Home[i][]->thisHome[];
                  thisHome.length -> currentSize;
                  HomeDir[i][]->thisDir[];
                  INNER
             for)
          #);
        Init: <<SLOT PathHandlerInitNameTable: descriptor>>
     #)
#)

-- pathHandlerInit: DoPart --
do private.nameTable.init; INNER; 

-- PathHandlerCurDir: DoPart --
do private.currentdirectory.copy->value[]  

-- PathHandlerBetaLib: DoPart --
do private.betalib.copy->value[]  

-- ConvertFileNameNoFather: dopart --
do 'Error in file path conversion in PathHandler:' -> msg.putline;
   'Too many ''..''s in the path\n\t''' -> msg.puttext;
   THIS(ConvertFilePath).path[] -> msg.puttext;
   '''\ncompared to the basis\n\t''' -> msg.puttext;
   THIS(ConvertFilePath).basis[] -> msg.puttext;
   '''\n'->msg.puttext;
   'Path not converted.' -> msg.putline;
   INNER;
   
--PathHandlerScanSearchPath: dopart--
do (if pathlist[]=NONE then
       searchPath -> expandenvvar -> pathlist[];
   if);
   (if delimiter=0 then
       searchPathDelimiter -> delimiter;
   if);
   (if pathlist.length>0 then
       (# start: @integer;
       do 1->start;
          pathlist.reset;
          delimiter->pathlist.findAll
          (#
          do (if (inx-1>start) then 
                 (start,inx-1)->pathlist.sub->path[];
                 INNER scanSearchPath;
             if);
             inx+1->start;
          #);
          (if start-1<pathlist.length then
              (start,pathlist.length)->pathlist.sub->path[];
              INNER scanSearchPath;
          if);
       #);
   if)
   
   
-- LocalPathException: dopart --
do true -> continue;
   'Error in localpath conversion of \n\t'''->msg.puttext;
   this(localpath).path[] -> msg.puttext;
   '''\nrelative to the basis\n\t''' -> msg.puttext;
   this(localpath).basis[] -> msg.puttext;
   ''''->msg.puttext;
   INNER;
   
   
   
-- LocalPathBody: Descriptor --
(#
   path,basis: ^text;
   inx,slashinx,parents: @integer;
   tmp: ^text;
   rmdbl: @removedoubleslash;
   
do findpart:
   (if (THIS(LocalPath).path[] <> none ) and (THIS(LocalPath).basis[] <> none )
    then (* copy paths to avoid side-effects *)
       THIS(LocalPath).path.copy->path[];
       THIS(LocalPath).basis.copy->basis[];
       (* check that basis can be used *)
       (if basis.length > 0 then
           (if (basis.length->basis.inxget) <> '/' then '/'->basis.append if);
           
        else
           currentdirectory->tmp[]; tmp->basis; 
       if);
       path[]->rmdbl;
       basis[]->rmdbl;
       (directorychar,'/',path[])->substChars;
       (directorychar,'/',basis[])->substChars;
       (* Check if basis is a prefix of path *)
       (if (1,basis.lgth)->path.sub->basis.equal then
           &text[]->localName[];
           path.t[basis.lgth+1:path.lgth]->localName;
           leave findpart;
           
       if);
       (* Check if basis and path have a common prefix *)
       0->inx;
       0->slashinx;
       0->parents;
       common:
       (for i: (basis.lgth,path.lgth)->min repeat
         (if (basis.T[i] <> path.T[i]) then leave common if);
         i->inx;
         (if basis.T[i] // '/' then i->slashinx if);
         
       for);
       (* inx points to last char common of the two paths, slashinx points
        * to last common '/'.
        *)
       (if slashinx > 1 then
       (* There was a common prefix (in addition to '/') *)
           path.t[slashinx+1:path.lgth]->path;
           basis.t[slashinx+1:basis.lgth]->basis;
           (* find number of '../'s to prepend to path *)
           '/'->basis.findAll (# do parents+1->parents #);
           (for parents repeat '../'->path.prepend for);
           path.copy->localname[];
           leave findpart;
           
       if);
       
   if);
   (* end findpart *)
   (if localName[] = none then
       LocalPathException;
       (* in case of continue: fall back on full path *)
       (if (path[] <> none ) then path.copy->localName[]; if)
   if);
   
#) 
