ORIGIN '../pathhandler';
MDBODY   mac     'pathhandler_macbody'
	 ppc     'pathhandler_macbody'
	 ppcmac  'pathhandler_macbody'
	 nti     'pathhandler_ntbody'
	 default 'pathhandler_unixbody';

INCLUDE '~beta/basiclib/v1.6/file'
	'~beta/basiclib/v1.6/external'
	'../envstring';

--LIB: attributes--
LowCaseFilenamesOnPC_Mac: (# exit true #);

searchPath: 
  (# path: ^text;
  <<SLOT PathhandlerSearchPath: dopart>>
  exit path[]
  #);
searchPathDelimiter: 
  (# delimiter: @char;
  <<SLOT PathhandlerSearchPathDelimiter: dopart>>
  exit delimiter
  #);
     
removeDoubleCh:
  (* Check that there are no double occurrences 
   * of ch in p, starting at position inx
   *)
  (# p: ^text;
     inx, chInx: @integer;
     ch: @char;
  enter (p[], ch, inx)
  do -2 -> chInx;
     search:
       (if inx <= p.lgth then
	   (if p.T[inx]=ch then 
	       (if inx > chInx then
		   (if inx = chInx+1 then 
		       (* two consecutive ch's *)
		       (chInx, chInx) -> p.delete;
		       inx-1 -> inx; (* one less char ! *)
		    else 
		       (* remember position of last slash *)
		       inx -> chInx;
		   if)
	       if)
	   if);
	   inx+1 -> inx;
	   restart search;
       if);
  #);

substChars:
  (* replace 'from' with 'to' in 'p' *)
  (# p: ^text; 
     from,to: @char;
  enter (from,to,p[])
  do from->p.findAll(# do (to,inx)->p.inxPut #); 
  #);

lowcasepath:
  (* Lowcase path, stoppping at a '-' *)
  (# path: ^text; ch: @char;
  enter path[]
  do (if LowCaseFilenamesOnPC_Mac then
         loop:
           (for i: path.length repeat
                (if (path.T[i]->ch)='-' 
                    then leave loop
                 else
                    ch->ascii.lowCase->path.T[i]; 
                if)
           for)
     if)
  exit path[]
  #);

-- PathHandlerPrivate: Descriptor --
(#
   betalib, currentdirectory: ^text;
   NameTable: @
     (# Home,HomeDir: [20] ^text;
	top: @integer;
	NewHomeDir:
	  (# H,D: ^text;
	  enter (H[],D[])
	  do (if ((top+1->top) > Home.range) then
		 10->home.extend;
		 10->homeDir.extend;
	     if);
	     h.copy->Home[top][];
	     d.copy->HomeDir[top][]
	  #);
	Scan:
	  (* Do not *change* thisHome or thisDir! *)
	  (# currentInx, currentSize: @integer;
	     thisHome,thisDir: ^text;
	  do (for i: top repeat
		  i->currentInx;
		  Home[i][]->thisHome[];
		  thisHome.length -> currentSize;
		  HomeDir[i][]->thisDir[];
		  INNER
	     for)
	  #);
	print: scan
	  (#
	  do 'Home: ' -> puttext; thishome[] -> putline;
	     'Dir:  ' -> puttext; thisdir[] -> putline;
	  #);

	Init: <<SLOT PathHandlerInitNameTable: descriptor>>
     #)
#)

-- pathHandlerInit: DoPart --
do private.nameTable.init; INNER;

-- PathHandlerCurDir: DoPart --
do private.currentdirectory.copy->value[]

-- PathHandlerBetaLib: DoPart --
do private.betalib.copy->value[]

-- ConvertFileNameNoFather: dopart --
do 'Error in file path conversion in PathHandler:' -> msg.putline;
   'Too many ''..''s in the path\n\t''' -> msg.puttext;
   THIS(ConvertFilePath).path[] -> msg.puttext;
   '''\ncompared to the basis\n\t''' -> msg.puttext;
   THIS(ConvertFilePath).basis[] -> msg.puttext;
   '''\n'->msg.puttext;
   'Path not converted.' -> msg.putline;
   INNER;

--PathHandlerScanSearchPath: dopart--
do (if pathlist[]=NONE then
       searchPath -> expandenvvar -> pathlist[];
   if);
   (if delimiter=0 then
       searchPathDelimiter -> delimiter;
   if);
   (if pathlist.length>0 then
       (# start: @integer;
       do 1->start;
	  pathlist.reset;
	  delimiter->pathlist.findAll
	  (#
	  do (if (inx-1>start) then
		 (start,inx-1)->pathlist.sub->path[];
		 INNER scanSearchPath;
	     if);
	     inx+1->start;
	  #);
	  (if start-1<pathlist.length then
	      (start,pathlist.length)->pathlist.sub->path[];
	      INNER scanSearchPath;
	  if);
       #);
   if)


-- LocalPathException: dopart --
do true -> continue;
   'Error in localpath conversion of \n\t'''->msg.puttext;
   this(localpath).path[] -> msg.puttext;
   '''\nrelative to the basis\n\t''' -> msg.puttext;
   this(localpath).basis[] -> msg.puttext;
   ''''->msg.puttext;
   INNER;



-- LocalPathBody: Descriptor --
(#
   path,basis: ^text;
   inx,slashinx,parents: @integer;
   tmp: ^text;
   rmdbl: @removeDoubleCh;

   (*    trace:
    *      (# prompt: ^text;
    *      enter prompt[]
    *      do (if prompt[] <> NONE then prompt[] -> puttext if);
    *         'LocalPath: path='''->puttext;
    *         path[] -> puttext;
    *         ''', basis='''->puttext;
    *         basis[] -> puttext;
    *         '''\n'->puttext;
    *      #)
    *)

do findpart:
   (if (THIS(LocalPath).path[] <> none ) and (THIS(LocalPath).basis[] <> none )
    then (* copy paths to avoid side-effects *)
       THIS(LocalPath).path.copy->path[];
       THIS(LocalPath).basis.copy->basis[];
       (*'Initial: '-> trace;*)
       (* check that basis can be used *)
       (if basis.length > 0 then
	   (if (basis.length->basis.inxget) <> '/' then '/'->basis.append if);
	else
	   currentdirectory->tmp[]; tmp->basis;
	   (*'new basis: '-> trace;*)
       if);
       (directorychar,'/',path[])->substChars;
       (directorychar,'/',basis[])->substChars;
       (path[], '/', 1)->rmdbl;
       (basis[], '/', 1)->rmdbl;

       (* 1. Check if basis is a prefix of path *)
       (if (1,basis.lgth)->path.sub->basis.equal then
	   &text[]->localName[];
	   path.t[basis.lgth+1:path.lgth]->localName;
	   leave findpart;
       if);

       (* 2. Check if something in the pathhandler data-structure
	* of home directories (this includes the contents of 
	* $(BETALIB)/homeDirectories) is prefix of path. 
	*)
       Private.nameTable.scan 
       (* home directories, e.g:
	*   thisDir:  '/users/beta/r4.0.3/'
	*   thisHome: '~beta/'
	*)
       (# canonicDir, canonicHome: ^text;
       do thisdir.copy -> canonicDir[];
	  (directorychar,'/',canonicDir[])->substChars;
	  (if ((1,canonicDir.lgth) -> path.sub -> canonicDir.equal) then
	      thisHome.copy -> canonicHome[];
	      (directorychar,'/',canonicHome[])->substChars;
	      (canonicDir.lgth+1,path.lgth) -> path.sub
		-> canonicHome.append -> localName[];
	      leave findpart
	  if)
       #);

       (* 3. Check if basis and path have a common prefix *)
       0->inx;
       0->slashinx;
       0->parents;
       common:
       (for i: (basis.lgth,path.lgth)->min repeat
	 (if (basis.T[i] <> path.T[i]) then leave common if);
	 i->inx;
	 (if basis.T[i] // '/' then i->slashinx if);
       for);
       (* inx points to last char common of the two paths, slashinx points
	* to last common '/'.
	*)
       (if slashinx > 1 then
       (* There was a common prefix (in addition to '/') *)
	   path.t[slashinx+1:path.lgth]->path;
	   basis.t[slashinx+1:basis.lgth]->basis;
	   (* find number of '../'s to prepend to path *)
	   '/'->basis.findAll (# do parents+1->parents #);
	   (for parents repeat '../'->path.prepend for);
	   path.copy->localname[];
	   leave findpart;
       if);

   if);
   (* end findpart *)
   (if localName[] = none then
       LocalPathException;
       (* in case of continue: fall back on full path *)
       (if (path[] <> none ) then path.copy->localName[]; if);
       (* 'Final: Localpath: '->puttext; localname[]->putline;*)
   if);
#)
