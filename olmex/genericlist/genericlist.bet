origin '~beta/basiclib/betaenv'
---lib:attributes---
List: 
  (# elm:< Object;
     item:< (# next: ^item #);
     head: ^item;
     insert:<
       (#  R: ^item;
       do &item[] -> R[];
          inner;
          head[] -> R.next[];
          R[] -> head[]
       #);
     remove:<
       (# index: @integer; R: ^item
       enter index
       do inner
       #);
     scan:
       (# current: ^item
       do head[] -> current[];
          L: 
            (#
            do (if current[] <> none then
                   inner scan; 
                   current.next[] -> current[];
                   restart L
               if)
            #)
       #);
  #);
Point:
  (# X,Y: @integer;
     print:
       (#
       do '(' -> put; X -> putint; ',' -> put; Y -> putint; ')' -> put 
       #)
  enter(X,Y)
  exit(X,Y)
  #)
---program:descriptor---
(# IL: @ List
     (# item::(# X: @integer #);
        insert::
          (# i: @integer
          enter i
          do I -> R.X
          #);
        remove::
          (# result: @integer
          do R.X -> result
          exit result
          #);
     #);
   
   PLV: @ List
     (# item::(# X: @Point #);
        insert::
          (# P: @Point
          enter P
          do P -> R.X
          #);
        remove::
          (# result: @Point
          do R.X -> result
          exit result
          #);
     #);
   
   PLR: @ List
     (# item::(# X: ^Point #);
        insert::
          (# P: ^Point
          enter P[]
          do P[] -> R.X[]
          #);
        remove::
          (# result: ^Point
          do R.X[] -> result[]
          exit result[]
          #);
     #);
   P: ^Point
do 
   (for i: 10 repeat
        I -> IL.insert
   for);
   IL.scan(# do current.X -> putint; ' ' -> put #);
   newline;
   (for i: 10 repeat
        &Point[] -> P[];
        (i,i+1) -> P;
        P -> PLV.insert
   for);
   (-1,-1) -> P;
   PLV.scan(# P1: @Point
           do current.X -> P1; P1.print; ' ' -> put
           #);
   newline;
   (for i: 10 repeat
        &Point[] -> P[];
        (i,i+1) -> P;
        P[] -> PLR.insert
   for);
   (-1,-1) -> P;
   PLR.scan(# P1: ^Point
           do current.X[] -> P1[]; P1.print; ' ' -> put
           #);
   
#)
