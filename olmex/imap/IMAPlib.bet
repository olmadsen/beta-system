ORIGIN '~beta/basiclib/basicsystemenv';
INCLUDE '~beta/basiclib/textUtils';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/process/streamgenerator';
INCLUDE 'IMAPparser';
(******************************************************************
 * A very simple IMAP client 
 *)
---systemlib:attributes---
IMAP: system
  (# log: @ logs;
     logs:< stream
       (# 
       #);
     listResp:<
       (# lst: ^listResponse
       enter lst[]
       do inner
       #);
     message:<
       (# msg: ^text
       enter msg[]
       do inner
       #);
     listCompleted:< object;
     outSocket: @StreamSocket;
     aText: ^Text;
     no: @Integer;
     getResponse:
       (# T: @text
       do L:
            cycle
            (# ch: @char
            do outSocket.get -> ch;
               (if ch = ascii.newline then leave L if);
               ch -> T.put
            #)
       exit T[]
       #);
     newID: @
       (# n: @integer; ID: ^text
       do 'A'-> ID[];
          n+1->n->ID.putint;
          ' '->ID.put;        
       exit ID[]
       #);
     currentID: ^text;
     wait:
       (#
       do L: (#
             do pause;
                (if currentID[] <> none then restart L if)
             #)
       #);
     command:
       (# done:< object
       do newID -> currentID[] -> outsocket.puttext;
          inner;
          wait;
          done;
       #);
     sendNOOP: command
       (#
       do 'NOOP:'->log.putline;
          'NOOP:'->putline;
          'NOOP\n' -> outsocket.puttext
       #);
     sendLOGIN: command
       (#
       do 'LOGIN:'->log.putline;
          'LOGIN olm mor,Efi.\n' -> outsocket.puttext
       #);        
     sendLOGOUT: command
       (#
       do 'LOGOUT:'->log.putline;
          'LOGOUT\n' -> outsocket.puttext
       #);
     sendSELECT: command
       (#
       do 'SELECT:'->log.putline;
          'SELECT INBOX\n' -> outSocket.puttext
       #);
     sendFETCH: command
       (#
       do 'FETCH:'->log.putline;
          (*'FETCH 4 FULL\n' -> outSocket.puttext;*)
          'FETCH 4 (FLAGS INTERNALDATE RFC822.size ENVELOPE BODY RFC822.TEXT)\n' 
            -> outSocket.puttext;
          (*'FETCH 4 (FLAGS BODY[HEADER])\n' -> outSocket.puttext*)
       #);
     sendLIST: command
       (# done:: (# do listCompleted #);
          mbox,w: ^text;
          msg: @text
       enter(mbox[],w[])
       do 'LIST:'->log.putline;
          'LIST ' -> msg;
          mbox[] -> msg.puttext;
          ' '-> msg.puttext;
          w[] -> msg.puttext;
          '\n' -> msg.puttext;
          msg[] ->putline;
          msg[] -> outSocket.puttext
       #);
     parse:
       (# T: ^text; last: @integer; R: ^response;
          
       enter T[]
       do  T[] -> parseIMAP -> R[];
          (if R[] <> none then R[] -> listResp; if);
       #);     

     sender: @ | system
       (#
       do 
          sendNOOP;        

          sendLOGIN;


          
          ('"/users/olm/IMAP/"','%') -> sendLIST;
         (* ('"/users/olm/IMAP"','%') -> sendLIST;*)
          (*('alexandra','"*"') -> sendLIST;*)
          sendSELECT;
          sendFETCH;
          
       #);
     isOK: booleanValue
       (# R,A: ^text
       enter R[]
       do R.reset;
          R.getAtom -> A[]; ' '->A.put;
          (if A[] -> currentID.equal then
              none -> currentID[];
              true -> value
          if);
       #);
     parseMesg: @boolean;
     receiver: @ | system
       (# R,A: ^text; resp: ^response
       do L: cycle
            (# ch: @char
            do (if outSocket.eos then 
                   'EOS'->log.putline;
                   leave L 
               if);
               (if true then
                   outSocket[] -> parseImap -> resp[];
                else
                   getResponse -> R[] -> putline;
                   (* R[] -> log.putline;*)
                   R[] -> parseImap -> resp[];
               if);
               (if (resp[]<>none) then
                   (if true
                    // resp.isCompleted then
                       (# CR: ^completedResponse
                       do resp[] -> CR[];
                         (* 'Completed?'->puttext;
                          CR.tag[] -> puttext; '?'->put;
                          currentid[] ->puttext; '?'->put; newline;*)
                          (if CR.tag[] -> currentID.equal then
                              'Completed:'->puttext;
                              CR.tag[]->putline;
                              none -> currentID[]
                       if)#)
                    // resp.isMsg then
                       (# msg: @text; MR: ^messageResponse
                       do resp[] -> MR[];
                          (if true then
                              'MSG:'->putline;
                              MR.M.scan
                              (#
                              do current.tag[] -> puttext;
                                 ':' -> put;
                                 (if current.val[] <> none then
                                     current.val.V[] -> putline
                                 if);
                                 (if true
                                  // 'RFC822.TEXT' -> current.tag.equalNCS then
                                     current.val.V[] -> message
                                 if)
                              #) 
                          if)
                       #);
                        // resp.isList then
                           resp[] -> listResp
                       if)
               if);       
              (* R.reset;
               R.getAtom -> A[]; ' '->A.put;
               (if A[] -> currentID.equal then
                   none -> currentID[]
               if);
               none -> currentID[]*)
            #);
          
          outSocket.close;        (* close down the socket *)
       #); 
     fromUser: @ | system
       (# ch: @char
       do L:
            cycle
            (#
            do keyboard.get -> ch;
               pause;
               (if ch = 'q' then         
                   sendLOGOUT;
                   leave L
               if);
            #)
       #)
     
  do 143 -> outSocket.port;
     'daimi.au.dk' -> outSocket.host;
     (#
     do doConnect: outSocket.connect
          (# error::< 
               (#
               do no+1 -> no; '.' -> screen.put;
                  (if no <= 10 then restart doConnect if);
               #);
          #);
        (* connection established *)
        'Connected'->putline;
        'Connected'->LOG.putline;
        'Connected!'->putline;
        sender[] -> fork;
        receiver[] -> fork;
        (*fromUser[] -> fork;*)
     #)
  #)


