ORIGIN '~beta/basiclib/basicsystemenv';
INCLUDE '~beta/basiclib/textUtils';
INCLUDE '~beta/basiclib/file';
INCLUDE '~beta/sysutils/pathhandler';
INCLUDE '~beta/process/streamgenerator';
INCLUDE 'IMAPparser';
(******************************************************************
 * A very simple IMAP client 
 *)
---systemlib:attributes---
IMAP: system
  (# ilog: @ logs;
     logs:< stream
       (# 
       #);
     listResp:<
       (# lst: ^listResponse
       enter lst[]
       do inner
       #);
     message:<
       (# msg: ^messageResponse
       enter msg[]
       do inner
       #);
     exists:< 
       (# R: ^SelectExists
       enter R[]
       do inner
       #);
     listCompleted:< object;
     outSocket: @StreamSocket;
     aText: ^Text;
     no: @Integer;
     getResponse:
       (# T: @text
       do L:
            cycle
            (# ch: @char
            do outSocket.get -> ch;
               (if ch = ascii.newline then leave L if);
               ch -> T.put
            #)
       exit T[]
       #);
     newID: @
       (# n: @integer; ID: ^text
       do 'A'-> ID[];
          n+1->n->ID.putint;
          ' '->ID.put;        
       exit ID[]
       #);
     currentID: ^text;
     wait:
       (#
       do L: (#
             do pause;
                (if currentID[] <> none then restart L if)
             #)
       #);
     command:
       (# done:< object
       do newID -> currentID[] -> outsocket.puttext;
          inner;
          wait;
          done;
       #);
     sendNOOP: command
       (#
       do 'NOOP:'->ilog.putline;
          'NOOP\n' -> outsocket.puttext
       #);
     sendLOGIN: command
       (#
       do 'LOGIN:'->ilog.putline;
          'LOGIN olm mor,Efi.\n' -> outsocket.puttext
       #);        
     sendLOGOUT: command
       (#
       do 'LOGOUT:'->ilog.putline;
          'LOGOUT\n' -> outsocket.puttext
       #);
     sendSELECT: command
       (# folder: ^text
       enter folder[]
       do 'SELECT:'->ilog.putline;
          'SELECT ' -> outSocket.puttext;
          folder[] -> outSocket.puttext;
          outSocket.newline
       #);
     sendFETCH: command
       (# msgNo: @integer; withText: @boolean
       enter(msgNo,withText)
       do 'FETCH:'->ilog.puttext; msgNo -> ilog.putint; ilog.newline;
          'FETCH ' -> outSocket.puttext;
          msgNo -> outSocket.putint;
          ' (FLAGS INTERNALDATE RFC822.size ENVELOPE BODY'
            -> outSocket.puttext;
          (if withText then
              ' RFC822.TEXT'-> outSocket.puttext;
          if);
          ')\n'-> outSocket.puttext;
          'inner'->ilog.putline;
          INNER
       #);
     sendLIST: command
       (# done:: (# do listCompleted #);
          mbox,w: ^text;
          msg: @text
       enter(mbox[],w[])
       do 'LIST:'->ilog.putline;
          'LIST ' -> msg;
          mbox[] -> msg.puttext;
          ' '-> msg.puttext;
          w[] -> msg.puttext;
          '\n' -> msg.puttext;
          msg[] -> ilog.putline;
          msg[] -> outSocket.puttext
       #);
     sender: @ | system
       (#
       do 
          sendNOOP;        

          sendLOGIN;
          
          ('"/users/olm/IMAP/"','%') -> sendLIST;
          (* ('"/users/olm/IMAP"','%') -> sendLIST;*)
          (*('alexandra','"*"') -> sendLIST;*)
          'INBOX' -> sendSELECT;
         (* (3,true) -> sendFETCH;          *)
       #);
     isOK: booleanValue
       (# R,A: ^text
       enter R[]
       do R.reset;
          R.getAtom -> A[]; ' '->A.put;
          (if A[] -> currentID.equal then
              none -> currentID[];
              true -> value
          if);
       #);
     parseMesg: @boolean;
     receiver: @ | system
       (# waitResponse:
            (# 
            enter handler[]
            do wait:
                 (if gotResponse then 
                     false -> gotResponse;
                  else
                     'waitResponse: ' -> ilog.putline;
                     pause;
                     restart wait
                 if)
            exit resp[]
            #);
          handler: ^| system;
          gotResponse: @boolean;
          sendResponse:
            (#
            do 'sendResponse:'->ilog.putline;
               (if handler[] <> none then
                   true -> gotResponse;
                   none -> handler[];
                   wait:
                     (if gotResponse then pause; restart wait if)
               if);
            #);  
          R,A: ^text; resp: ^response;
          IP: @parseIMAP
       do ilog[] -> IP.init;
          L: cycle
            (# ch: @char
            do (if outSocket.eos then 
                   'EOS'->ilog.putline;
                   leave L 
               if);
               'outSocket:get'->ilog.putline;
               outSocket[] -> IP -> resp[];
               (if (resp[]<>none) then
                   (if handler[] <> none then
                       sendResponse
                    else
                       (if true
                        // resp.isCompleted then
                           (# CR: ^completedResponse
                           do resp[] -> CR[];
                              (* 'Completed?'->puttext;
                               CR.tag[] -> puttext; '?'->put;
                               currentid[] ->puttext; '?'->put; newline;*)
                              (if CR.tag[] -> currentID.equal then
                                  'Completed:'->ilog.puttext;
                                  CR.tag[]->ilog.putline;
                                  none -> currentID[]
                           if)#)
                        // resp.isMsg then
                           (# msg: @text; MR: ^messageResponse
                           do resp[] -> MR[];
                              'MSG:'->putline;
                              MR.scan
                              (#
                              do current[] -> puttext;
                                 ':' -> put;
                                 newline;
                              #); 
                              MR[] -> message
                           #);
                        // resp.isList then
                           resp[] -> listResp
                        // resp.isSelectExists then
                           'selectExists:'->ilog.putline;
                           resp[] -> exists;
                       if)
                   if)
               if)
            #);
          
          outSocket.close;        (* close down the socket *)
       #); 
     fromUser: @ | system
       (# ch: @char
       do L:
            cycle
            (#
            do keyboard.get -> ch;
               pause;
               (if ch = 'q' then         
                   sendLOGOUT;
                   leave L
               if);
            #)
       #)
     
  do 143 -> outSocket.port;
     'daimi.au.dk' -> outSocket.host;
     (#
     do doConnect: outSocket.connect
          (# error::< 
               (#
               do no+1 -> no; '.' -> screen.put;
                  (if no <= 10 then restart doConnect if);
               #);
          #);
        (* connection established *)
        'Connected' -> screen.putline;
        'Connected' -> ILOG.putline;
        receiver[] -> fork;
        sender[] -> fork;

        (*fromUser[] -> fork;*)
     #)
  #)


