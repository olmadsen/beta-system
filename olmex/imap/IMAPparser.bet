origin '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/olmex/lisp/lisp'
---lib:attributes---
parseIMAP:
  (# next:
       (# nextCh:
            (#
            do (if not T.eos then
                   T.get -> ch
                else
                   ascii.eot ->ch
               if);
               (*'#'->put; ch->put*)
            #);
          getName:
            (#
            do L: (#
                  do nextCh;
                     (if (('A' <= ch) and (ch <= 'Z')) or
                         (('a' <= ch) and (ch <= 'z')) or
                         (('0' <= ch) and (ch <= '9')) or
                         (ch = '.') or
                         (ch = '/') or
                         (ch = '-') then
                         ch -> tok.put;
                         restart L
                  if)#)
            #);

       do skipBlanks:
            (if ch <= ' ' then 
                nextCh;
                (if ch <> ascii.eot then restart skipBlanks  if)
            if);
          &text[] -> tok[];
          (if ch
           // '*' 
           // ' ' 
           // '(' 
           // ')'
           // '{'
           // '}'
           // '['
           // ']'
           // '='
              then ch -> tok; nextCh;
           // '$'
           // '\\' then
              ch -> Tok;
              getName
           // '"' then
              L: (#
                 do ch -> tok.put;
                    nextCh;
                    (if ch <> '"' then
                        restart L
                    if);
                    ch -> tok.put;
                    nextCh
                 #)
           else (*'&'->put; ch ->putint; newline;*)
                (if (('A' <= ch) and (ch <= 'Z')) or
                    (('a' <= ch) and (ch <= 'z')) or
                    (ch = '/') then 
                    ch -> tok.put;
                    getName
                 else
                    (if not (('0' <= ch) and (ch <= '9')) then
                        '\n*** UNKNOWN CHAR IN: next: "'->puttext;
                        ch -> put;
                        '"'->putline;
                        '?'->tok
                    if);
                    0 -> value;
                    '' -> tValue[];
                    L:
                      (if ('0' <= ch) and (ch <= '9') then
                          ch -> tValue.put;
                          value*10 + ch - '0' -> value;
                          nextCh;
                        restart L
                      if);
                    '0' -> tok;                    
                if);
             (* '%'->put; tok[] -> putline*)
          if);  
          (if true then
              '<'->put; tok[] -> puttext; '>'->put; newline
          if)
       #);
     bodyText:
       (# msg: ^text
       do (*'bodytext:'->puttext; value -> putint; newline;*)
          &text[] -> msg[];
          (for i: value repeat
               T.get -> msg.put;
          for);
          (* msg[] -> putline;*)
       exit msg[]
       #);
     msg_att_data:
       (# size: @integer; 
          LU: ^Unit;
          LC: ^Conss
       do (if true 
           // '(' -> tok.equal then
              next;
              Loop:
                (# LUx: ^Unit
                do (msg_att_data,none) -> &conss -> LUx[];
                   (if LU[] = none then
                       LUx[] -> LU[]
                    else
                       (LU[],LUx[]) -> Append ->  LU[];
                   if);
                   (if not (')'->tok.equal) then
                       restart Loop
                   if)
                #);
              next
           // '{' -> tok.equal then
              next; (* a number *)
              next; 
              (if not ('}' -> tok.equal) then if);
              bodyText -> Atom -> LU[];
              next;
           // '0' -> tok.equal then
              tValue[] -> Atom -> LU[];
              next
           else
              tok[] -> Atom -> LU[];
              next;
          if);
          (*LU.PP*)
       exit LU[]
       #);
     msg_att:
       (# RL: ^Conss; tg: ^text; LL: ^Conss
       do (if true 
           // '(' -> tok.equal then
              next;
              L: (#
                 do tok[] -> tg[];
                    next;
                    (tg[]->Atom,(msg_att_data,none)->Conss) -> Conss -> LL[];
                    (if RL[] = none then
                        (LL[],none)-> Conss -> RL[]
                     else
                        (RL[],(LL[],none)->Conss) 
                          -> Append 
                          -> RL[]
                    if);
                    (if not (')'->tok.equal) then
                        (* a name/attribute *)                       
                        restart L
                    if)
                 #)
           // '[' -> tok.equal then
              next; 
              Loop:
                (#
                do 
                   (LL[],(theToken->atom,none)->conss) -> append -> LL[];
                   next;
                   (if not (']'->tok.equal) then
                       restart Loop
                   if)
                #);
              LL[] -> RL[];
          if);
       exit RL[]
       #);
     ch: @char;
     T: ^stream; 
     theToken: 
       (# S: ^text 
       do (if '0'->tok.equal then tValue[] -> S[] else tok[] -> S[] if)
       exit S[]
       #);
     tok,tValue: ^text; 
     value: @integer;
     R: ^response
  enter T[]
  do 'Parsing:'->putline;
     (*T.reset;*)

     next; '+'->put; tok[] -> putline;
     (if true
      // '*' -> tok.equal then
         next; 
         (if true 
          // 'list' -> tok.equalNCS then
             (# LR: @listResponse
             do next;
                (if '(' -> tok.equal then
                    L: (#
                       do next;
                          (if not (')' -> tok.equal) then
                              (if true 
                               // '\\NoSelect' -> tok.equal then
                                  true -> LR.NoSelect
                              if);
                              restart L
                       if)#);
                    next
                if);
                (if '"/"' -> tok.equal then 
                    next;
                    tok[] -> LR.mbox[];
                if);
                LR[] -> R[]
             #) 
          // '0' -> tok.equal then
             next;
             (if true 
              // 'fetch' -> tok.equalNCS then
                 (# MR: @messageResponse;
                 do next;
                    msg_att -> MR.M[];
                    MR[] -> R[];
                 #);
              // 'exists' -> tok.equalNCS then
                 (# SE: @selectExists
                 do '>>EXISTS:' -> puttext;
                    next;
                    value -> putint;
                    newline;
                    value -> SE.value;
                    SE[] -> R[]
                 #);
              // 'recent' -> tok.equalNCS then
                 '>>RECENT?:'->putline;
                 next;
                 value -> putint;
                 newline
              else
                 ' >>>' -> puttext; tok[] -> putline
             if)
          // 'OK' -> tok.equalNCS then
             '>>OK '-> putline;
             next;

             (# X: ^Unit 
             do msg_att-> X[];
                (if X[] <> none then
                    X.PP;
                    newline;
                 else
                if);
             #);
             T[] -> skipToNl
          // 'FLAGS' -> tok.equalNCS then
             '>>FLAGS:'->putline;
             T[] -> skipToNl
          else
             '>>RESPONSE: ' -> puttext; tok[] -> putline;
             T[] -> skipToNl
         if)
      // '0' -> tok.equalNCS then
         next;
         (if true
          // 'recent' -> tok.equalNCS then
             '>>RECENT:'->putline;
             next;
             value -> putint;
             newline;
          else
             ' >>>' -> puttext; tok[] -> putline;
         if);
         T[] -> skipToNl
      else
         (* tag assumed *)
         (# CR: @ completedResponse
         do tok[] -> CR.tag[];
           (* 'Comp:'->puttext; tok[] -> putline;*)
            ' '->tok.put;
            T[] -> skipToNl;
            CR[] -> R[]
         #)
     if)
  exit R[]
  #);
skipToNL:
  (# T,V: ^stream; ch: @char
  enter T[]
  do &text[] -> V[];
     T.get -> ch;(* ch -> put; '!'->put;*)
     L: (if not T.eos and (ch <> ascii.newline) then
            T.get -> ch -> V.put;
            (* ch->put; '?'->put;*)
            (if ch 
             // ascii.cr //ascii.nl then
             else
                restart L
            if);
        if);
  exit V[]
  #);
response:
  (# isCompleted:< booleanValue;
     isList:< BooleanValue;
     isMsg:< BooleanValue;
     isSelectExists:< BooleanValue
  #);
CompletedResponse: Response
  (# isCompleted:: trueValue;
     tag: ^text
  #);
ListResponse: response
  (# isList::TrueValue;
     NoSelect: @boolean;
     mbox: ^text
  #);
SelectExists: response
  (# isSelectExists:: TrueValue;
     value: @integer
  #);
MessageResponse: response
  (# isMsg::TrueValue;
     M: ^Unit;
     getAtt:
       (# att: ^text;
          V: ^Conss;
          S: ^text;
          A: ^Atom
       do inner
       exit S[]
       #);
     subject: getAtt
       (# 
       do 2 -> findEnvelope -> A[];
          A.a[] -> S[]
       #);
     sender: getAtt
       (# 
       do 3 -> findEnvelope -> V[];
          V.car[] -> V[];
          V.car[] -> A[]; 
          A.a[] -> S[]
       #);
     date: getAtt
       (#
       do 1 -> findEnvelope -> A[];
          A.a[] -> S[];
       #);
     message: getAtt
       (#
       do 'RFC822.TEXT' -> find -> V[];
          V.car[] -> A[];
          A.a[] -> S[]
       #);
     scan:
       (# current: ^text; 
          currentValue: ^Conss;
          Mx: ^Conss;
       do M[] -> Mx[];
          Loop:
          (# V: ^Unit;
             C,next: ^Conss;
             A: ^Atom
          do Mx.car[] -> C[]; C.car[] -> V[];
             C.cdr[] -> currentValue[];
             Mx.cdr[] -> next[];
             (if V.isAtom then
                 V[]->A[];
                 A.a[] -> current[]
             if);
             INNER scan;
             (if next[] <> none then 
                 next[] -> Mx[];
                 restart Loop
             if)
          #)
       #);
     find:
       (# att: ^text; 
          V: ^Conss
       enter att[]
       do loop:
            scan
            (#
            do (if current[] -> att.equalNCS then
                   currentValue[] -> V[];
                   leave loop
            if)#)
       exit V[]
       #);
     findEnvelope:
       (# attNo: @integer;
          V: ^Conss;
          X: ^Unit
       enter attNo
       do 'ENVELOPE' -> find -> V[];
          V.car[] -> V[];
          (for i: attNo-1 repeat
               V.cdr[] -> V[];
          for);
          V.car[] -> X[];
          INNER
       exit X[]
       #);
  #);
