origin '~beta/basiclib/betaenv'
---lib:attributes---
parseIMAP:
  (# next:
       (# nextCh:
            (#
            do (if not T.eos then
                   T.get -> ch
                else
                   ascii.eot ->ch
               if);
            #);
          getName:
            (#
            do L: (#
                  do nextCh;
                     (if (('A' <= ch) and (ch <= 'Z')) or
                         (('a' <= ch) and (ch <= 'z')) then
                         ch -> tok.put;
                         restart L
                  if)#)
            #);

       do skipBlanks:
            (if ch <= ' ' then 
                nextCh;
                (if ch <> ascii.eot then restart skipBlanks  if)
            if);
          &text[] -> tok[];
          (if ch
           // '*' 
           // ' ' 
           // '(' 
           // ')'
              then ch -> tok; nextCh;
           // '\\' then
              ch -> Tok;;
              getName
           // '"' then
              L: (#
                 do ch -> tok.put;
                    nextCh;
                    (if ch <> '"' then
                        restart L
                    if);
                    ch -> tok.put;
                    nextCh
                 #)
           else
              L:
                (if (('A' <= ch) and (ch <= 'Z')) or
                    (('a' <= ch) and (ch <= 'z')) or
                    (ch = '/') then
                    ch -> tok.put;
                    nextCh; 
                    restart L
                 else
                    L:
                      (if ('0' <= ch) and (ch <= '9') then
                          '0' -> tok;
                        nextCh;
                        restart L
                    if)
                if)
          if);  
          (if false then
              '<'->put; tok[] -> puttext; '>'->put;
          if)
       #);
     ch: @char;
     T: ^text; tok: ^text;
     R: ^response
  enter T[]
  do T.reset; next;
     (if true
      // '*' -> tok.equal then
         next; 
         (if true 
          // 'list' -> tok.equalNCS then
             (# LR: @listResponse
             do next;
                (if '(' -> tok.equal then
                    L: (#
                       do next;
                          (if not (')' -> tok.equal) then
                              (if true 
                               // '\\NoSelect' -> tok.equal then
                                  true -> LR.NoSelect
                              if);
                              restart L
                       if)#);
                    next
                if);
                (if '"/"' -> tok.equal then 
                    next;
                    tok[] -> LR.mbox[];
                if);
                LR[] -> R[]
             #) 
          // '0' -> tok.equal then
             next;
             (if 'fetch' -> tok.equalNCS then
                 'Parse msg'->putline;
                 (# MR: @messageResponse;
                 do 
                    T[] -> skipToNL;
                    MR[] -> R[]
                 #)             
             if)
         if)
     if)
  exit R[]
  #);
skipToNL:
  (# T,V: ^text; ch: @char
  enter T[]
  do &text[] -> V[];
     T.get -> ch; (*ch -> put; '!'->put;*)
     L: (if not T.eos and (ch <> ascii.newline) then
            T.get -> ch -> V.put;
            (*ch->put; '?'->put;*)
            (if ch 
             // ascii.cr //ascii.nl then
             else
                restart L
            if);
        if)
  exit V[]
  #);
parseMsg:
  (# getTag:
       (# ch: @char
       do &text[] -> tag[];
          ''->tag[];
          L: (if ch <> ':' then
                 msg.get -> ch;
                 ch ->Tag.put;
                 restart L
             if);
          ''-> val[];
          L: (#
             do msg[] -> skipToNl->val.append;
                (*msg.peek -> put; '"'->put; msg.peek->putint; '"'->put;*)
                (if msg.peek 
                 // ascii.ht // ' ' then restart L if);
             #)          
       #);
     tag,val,V: ^text;
     msg: ^text;     
     MR: @messageResponse
  enter msg[]
  do 'PARSEMSG:'->putline;(* msg[] -> putline;*)
     msg.reset;
     L:
       msg.scanAll
       (#
       do getTag;
          newline; 
          'TAG: ' -> puttext;
          tag[] -> putline;
          'Val: ' -> puttext;
          val[] -> putline;
          (if true
           // 'TO:' -> tag.equalNCS then
              val[] -> MR.sender[]
           // 'subject:' -> tag.equalNCS then
              val[] -> MR.subject[]
          if);
          (if msg.peek = ascii.cr then
              msg.get;
              (if msg.peek = ')' then
                  msg.get;
                  leave L
          if)if)
       #)
  exit MR[]
  #);
response:
  (# isList:< BooleanValue;
     isMsg:< BooleanValue
  #);

ListResponse: response
  (# isList::TrueValue;
     NoSelect: @boolean;
     mbox: ^text
  #);
MessageResponse: response
  (# isMsg::TrueValue;
     sender,subject: ^text
  #)


