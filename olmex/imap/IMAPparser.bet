origin '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/list'
---lib:attributes---
parseIMAP:
  (# next:
       (# nextCh:
            (#
            do (if not T.eos then
                   T.get -> ch
                else
                   ascii.eot ->ch
               if);
               (*'#'->put; ch->put*)
            #);
          getName:
            (#
            do L: (#
                  do nextCh;
                     (if (('A' <= ch) and (ch <= 'Z')) or
                         (('a' <= ch) and (ch <= 'z')) or
                         (('0' <= ch) and (ch <= '9')) or
                         (ch = '.') or
                         (ch = '/') then
                         ch -> tok.put;
                         restart L
                  if)#)
            #);

       do skipBlanks:
            (if ch <= ' ' then 
                nextCh;
                (if ch <> ascii.eot then restart skipBlanks  if)
            if);
          &text[] -> tok[];
          (if ch
           // '*' 
           // ' ' 
           // '(' 
           // ')'
           // '{'
           // '}'
              then ch -> tok; nextCh;
           // '\\' then
              ch -> Tok;
              getName
           // '"' then
              L: (#
                 do ch -> tok.put;
                    nextCh;
                    (if ch <> '"' then
                        restart L
                    if);
                    ch -> tok.put;
                    nextCh
                 #)
           else (*'&'->put; ch ->putint; newline;*)
                (if (('A' <= ch) and (ch <= 'Z')) or
                    (('a' <= ch) and (ch <= 'z')) or
                    (ch = '/') then 
                    ch -> tok.put;
                    getName
                 else
                    0 -> value;
                    L:
                      (if ('0' <= ch) and (ch <= '9') then
                          value*10 + ch - '0' -> value;
                          nextCh;
                        restart L
                      if);
                    '0' -> tok;                    
                if);
             (* '%'->put; tok[] -> putline*)
          if);  
          (if false then
              '<'->put; tok[] -> puttext; '>'->put; newline
          if)
       #);
     bodyText:
       (# msg: ^text
       do (*'bodytext:'->puttext; value -> putint; newline;*)
          &text[] -> msg[];
          (for i: value repeat
               T.get -> msg.put;
          for);
          (* msg[] -> putline;*)
       exit msg[]
       #);
     msg_att_data:
       (# size: @integer; V: @mvalue
       do (if true 
           // '(' -> tok.equal then
              next;
              L:
                (#
                do 
                   msg_att_data;
                   (if not (')'->tok.equal) then
                       restart L
                   if)
                #);
              next
           // '{' -> tok.equal then
              next; (* a number *)
              next; 
              (if not ('}' -> tok.equal) then if);
              bodyText -> V.V[];
              next;
           else
              tok[] -> V.V[];
              next;
          if)
       exit V[]
       #);
     msg_att:
       (# RL: @rList; tg: ^text; V: ^mvalue
       do (if '(' -> tok.equal then
              next;
              L: (#
                 do tok[] -> tg[];
                   (* 'TAG:'->puttext; tok[] -> putline;*)
                    next;
                    msg_att_data -> V[];
                    (tg[],V[]) -> RL.add;
                    (if not (')'->tok.equal) then
                        (* a name/attribute *)                       
                        restart L
                    if)
                 #)
          if);
       exit RL[]
       #);
     ch: @char;
     T: ^stream; 
     tok: ^text; value: @integer;
     R: ^response
  enter T[]
  do (*T.reset;*)
     next;
     (if true
      // '*' -> tok.equal then
         next; 
         (if true 
          // 'list' -> tok.equalNCS then
             (# LR: @listResponse
             do next;
                (if '(' -> tok.equal then
                    L: (#
                       do next;
                          (if not (')' -> tok.equal) then
                              (if true 
                               // '\\NoSelect' -> tok.equal then
                                  true -> LR.NoSelect
                              if);
                              restart L
                       if)#);
                    next
                if);
                (if '"/"' -> tok.equal then 
                    next;
                    tok[] -> LR.mbox[];
                if);
                LR[] -> R[]
             #) 
          // '0' -> tok.equal then
             next;
             (if 'fetch' -> tok.equalNCS then
                 (# MR: @messageResponse;
                 do next;
                    msg_att -> MR.M[];
                    MR[] -> R[];
                 #);
             if)
          else
             T[] -> skipToNl
         if)
      else
         (* tag assumed *)
         (# CR: @ completedResponse
         do tok[] -> CR.tag[];
           (* 'Comp:'->puttext; tok[] -> putline;*)
            ' '->tok.put;
            T[] -> skipToNl;
            CR[] -> R[]
         #)
     if)
  exit R[]
  #);
skipToNL:
  (# T,V: ^stream; ch: @char
  enter T[]
  do &text[] -> V[];
     T.get -> ch;(* ch -> put; '!'->put;*)
     L: (if not T.eos and (ch <> ascii.newline) then
            T.get -> ch -> V.put;
            (* ch->put; '?'->put;*)
            (if ch 
             // ascii.cr //ascii.nl then
             else
                restart L
            if);
        if);
  exit V[]
  #);
response:
  (# isCompleted:< booleanValue;
     isList:< BooleanValue;
     isMsg:< BooleanValue
  #);
CompletedResponse: Response
  (# isCompleted:: trueValue;
     tag: ^text
  #);
ListResponse: response
  (# isList::TrueValue;
     NoSelect: @boolean;
     mbox: ^text
  #);
MessageResponse: response
  (# isMsg::TrueValue;
     sender,subject,msg: ^text;
     M: ^rList
  #);
rList: list
  (# element::
       (# tag: ^text; val: ^mvalue #);
     add:
       (# T: ^text; V: ^mvalue; E: ^element
       enter (T[],V[])
       do &element[] -> E[];
          T[] -> E.tag[];
          V[] -> E.val[];
          E[] -> append
       #)
  #);
mvalue: 
  (# V: ^text; next: ^mvalue
  enter V[]
  exit this(mvalue)[]
  #);



