ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/treeview';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE '~beta/sysutils/objinterface';
INCLUDE 'IMAPlib';
INCLUDE 'mailFolder';
INCLUDE '~beta/basiclib/numberio';
INCLUDE 'mimeDecoders';
INCLUDE 'newMessageWindow';
--- program: descriptor ---
systemenv
(# setWindowEnv::< (# do myWindowEnv[] -> theWindowEnv[] #);   
   myWindowEnv: @guienv 
     (# sizes: @
          (# window_H,window_W
             ,tree_H,tree_W
             ,mails_H,mails_W
             ,mails_X,mails_Y
             ,TE_H,TE_W
             ,TE_X,TE_Y
             : @integer;
             defaults:
               (#
               do 800 -> window_W; 650 -> window_H;
                  200 -> tree_W;   window_H -> tree_H;
                  
                  650 -> mails_W; 300 -> mails_H;
                  150 -> mails_X; 0 -> mails_Y;
                  
                  650 -> TE_W; 350 -> TE_H;
                  150 -> TE_X; 300 -> TE_Y;
               #)
          #);
        theWindow: @window
          (# eventhandler::
               (# onAboutToClose:: (# do terminate #);
                  onMouseDown:: 
                    (# do ff.select(# do scrolltv[]->ff.scrollIntoView #) #)
               #);
             menubarType:: standardMenubar
               (# fileMenu:: standardFileMenu
                    (# newMenuAction: @menuAction
                         (# onSelect:: 
                              (# 
                              do 'New...'->TE.putText;
                              #) 
                         #);
                       saveMenuAction: @menuAction
                         (# onSelect:: (# do 'Saving...'->TE.puttext #) #);
                       saveAsMenuAction: @menuAction
                         (# onSelect:: (# do 'Saving As...'->TE.puttext #) #);
                       iSend: @menuItem
                         (# eventHandler::
                              (# onSelect::
                                   (# W: @newMessageWindow
                                        (# send::
                                             (# M: @sendMail
                                             do (server[],to[],subject[],msg[])
                                                  -> M.send
                                             #)
                                        #);
                                   do 'Send mail'->putline;
                                      W.open;
                                   #)
                              #)
                         #);
                       quitMenuAction: @menuAction
                         (# onSelect:: 
                              (# 
                              do 'Quitting...'->TE.puttext;
                                 IM.sendLOGOUT;
                                 logF.doClose;
                                 terminate 
                              #)
                         #);
                       open::
                         (#
                         do newMenuAction[]->newMenuItem.attach;
                            saveMenuAction[]->saveMenuItem.attach;
                            saveAsMenuAction[]->saveAsMenuItem.attach;
                            iSend.open;
                            iSend[] -> append;
                            quitMenuAction[]->quitMenuItem.attach;
                         #)
                    #);
                  editMenu:: standardEditMenu
               #);
             
             ff: ^treeview.folder;
             scrolltv: @scroller
               (# contentsType:: treeview
                    (# hideRoot:: trueObject;
                       leaf: item
                         (# allowLabelEdit:: trueObject;
                            onLabelChanged:: (# do newlabel[]->label[] #);
                            onSelected::
                              (#
                              do 'Select of:'->log.puttext; 
                                 label[] -> log.putline;
                                 label[] -> IM.selectFolder
                              #);
                         #);
                       addFolder:
                         (# f,f1: ^folder;
                            T: ^text
                         enter(f[],T[])
                         do &folder[] -> f1[]; 
                            T[] -> f1.label[]; 
                            f1[]->f.addItem;
                         exit f1[]
                         #);
                       addLeaf:
                         (# f: ^folder; N: ^text; l: ^leaf
                         enter(f[],N[])
                         do &leaf[]->l[]; N[]->l.label[]; 
                            l[]->f.addItem;
                         #);
                       Open::
                         (# l: ^leaf;
                            r,f,f1: ^folder
                         do &folder[]->r[]; 'root'->r.label[];
                            (*(r[],'INBOX')-> addLeaf;
                             (r[],'ISIS') -> addFolder -> f[];
                             (f[],'projects')->addLeaf;*)
                            r[]->root; f1[]->ff[];
                         #);
                    #);
                  open::
                    (# 
                    do (sizes.tree_W,sizes.tree_H)->size;
                       TRUE -> bindBottom
                    #)
               #);
             TE: @textEditor
               (# open:: 
                    (# aTextStyle: @textStyle;
                    do 'Courier new' -> aTextStyle.name;
                       10 -> aTextStyle.size;
                       (20,500,aTextStyle[]) -> contents.setOneStyle;
                       (* textFaces.bold -> aTextStyle.face;
                        (1,20,aTextStyle[]) -> contents.setOneStyle;*)
                       (sizes.TE_W,sizes.TE_H) -> size;
                       (sizes.TE_X,sizes.TE_Y) -> position;
                       false -> bindBottom -> bindRight
                    #);
                  puttext:
                    (# T: ^text; T1: @StyledText
                    enter T[]
                    do T -> T1;
                       (0, contents.length)-> contents.selection;
                       contents.clear;
                       T1[] -> myWindowEnv.clipboard.textContents;
                       contents.paste;
                    #)                  
               #);
             
             mails: @textScrollList
               (# multipleSelection:: (# do false -> value #);
                  open::
                    (# aTextStyle: ^textStyle;
                    do &textStyle[] -> aTextStyle[];
                       'Times' -> aTextStyle.name;
                       10 -> aTextStyle.size;
                       (* textFaces.bold -> aTextStyle.face;*)
                       aTextStyle[] -> style;
                       
                       (sizes.mails_X,sizes.mails_Y) -> position;
                       (sizes.mails_W, sizes.mails_H) -> size;
                       
                       100 -> append;
                    #);
                  eventHandler::
                    (# onSelect::
                         (# selectedText: ^text;
                         do (if item <> 0 then
                                item -> getText -> selectedText[];
                                (if doubleClick then
                                    '!' -> selectedText.append;
                                if);
                                selectedText[] -> Title;
                                item -> IM.showMessage
                             else
                                '<<NONE>>' -> Title;
                            if);
                         #);
                    #);
               #);
             open::
               (# 
               do sizes.defaults;
                  'myMailer'->title;
                  (sizes.window_W,sizes.window_H) -> size;
                  scrolltv.open;
                  TE.open;
                  mails.open;
               #)
          #);
     do theWindow.open;
     #);
   IM: @ IMAP
     (# logs::
          (# puttext::
               (# 
               do txt[] -> log.puttext
               #);
             put:: (# do ch -> log.put #)
          #);
        listResp::
          (#
          do (17,lst.mbox.length) -> lst.mbox.sub -> lst.mbox[];
             (lst.mbox[],lst.NoSelect) -> MB.addSub;
          #);
        listCompleted::
          (#
          do (if false then
                 MB.scan(# 
                        do (if isF then 'folder: ' -> puttext if);
                           current[] -> putline
                        #);
             if);
             MB.subs.scan
             (#
             do (myWindowEnv.theWindow.scrolltv.contents.root,current.M[]) 
                  -> addFolder
             #);
          #);
        message::
          (# header: ^text; s,e: @integer
          do msg.subject -> header[];
             '   '->header.puttext;
             msg.sender -> header.append;;
             '   '->header.puttext;
             msg.date -> header.append;
             (1,header[])
               -> myWindowEnv.theWindow.mails.setText;
             msg.message -> myWindowEnv.clipboard.textContents;
             (if false then
                 (0, myWindowEnv.theWindow.TE.contents.length)->
                 myWindowEnv.theWindow.TE.contents.selection;
                 '\nLength: ' -> puttext; 
                 myWindowEnv.theWindow.TE.contents.length -> putint; newline;
                 myWindowEnv.theWindow.TE.contents.selection -> (s,e);
                 s -> putint; ' '->put; e -> putint; newline;
                 myWindowEnv.theWindow.TE.contents.contents -> putline;
                 
                 myWindowEnv.theWindow.TE.contents.clear;
                 '\n*********************'->putline;
                 myWindowEnv.theWindow.TE.contents.contents -> putline;
             if);
             myWindowEnv.theWindow.TE.contents.paste;             
             (0,10) -> myWindowEnv.theWindow.TE.scroll;
          #);
        do_coded2iso:
          (# T,S: ^text
          enter T[]
          do 'match: ' -> log.puttext; T[] -> log.putline;
             T[] -> coded2iso -> S[];
             S.reset;
             '\nDONE: ' -> log.puttext; S[] -> log.puttext; log.newline;
          exit S[] 
          #);
        awaitResponse: @ | system
          (# resp: ^response
          do cycle
             (#
             do 'awaitResponse:'->putline;
                this(awaitResponse)[] 
                  -> objectToComponent
                  -> receiver.waitResponse 
                  -> resp[];
                'got response'->putline;
                SUSPEND;
             #)
          exit resp[]
          #);
                
        awaitCompleted:  @ | system
          (* OBS! waitResponse executes pause, which implies
           * a suspend - pause ONLY works when we use scheduling
           * via fork. I.e we should make our own scheduler
           *)
          (#              C: ^response
          do (if true then 
                 'AWAITCOMPLETED:'->log.putline;
                 loop:
                   (#
                   do this(awaitCompleted)[] 
                        -> objectToComponent
                        -> receiver.waitResponse 
                        -> C[];
                      'AwaitCompleted:'->log.putline;
                      (if (C[] = none) or not C.isCompleted then
                          restart loop
                       else
                          SUSPEND;
                          restart loop
                      if)
                   #)
              else
                 Loop:
                   (#
                   do outSocket[] 
                        -> IP 
                        -> C[];
                      (if (C[]=none) or not C.isCompleted then
                          restart Loop
             if)#)if)
          #);
        setMailHeader::
          (#
          do 'Header: '->log.puttext; header[] -> log.putline;
             (msgNo,header[])-> myWindowEnv.theWindow.mails.setText
          #);
        selectHeader:: 
          (# 
          do (msgNo,B) -> myWindowEnv.theWindow.mails.selection.select;
             myWindowEnv.theWindow.mails.selection.scrollIntoView;
          #);
        setMessageBody::
          (#
          do message[] -> myWindowEnv.theWindow.TE.puttext;
          #);
        exists::
          (# mno: @integer;
             C: ^response;
             msg: ^messageResponse;
             header: ^text;
             awaitCompleted:
               (#
               do (if false then
                      loop:
                        (# do
                           getresponse -> putline;
                           restart Loop
                        #)
                   else
                      Loop:
                        (#
                        do outSocket[] 
                             -> IP 
                             -> C[];
                           (if (C[]=none) or not C.isCompleted then
                               restart Loop
                  if)#)if)
               #);
             lastNonDeleted: @integer;
          do 'EXIST: fetching mailbox: '-> log.puttext;
             R.value -> log.putint; log.newline;
             awaitCompleted; (* OK from SELECT *)
             'After awaitCompleted'->log.putline;
             (for i: R.value repeat
                  (*i -> putint; ','->put;*)
                  (i,false) -> sendFetch
                  (#
                  do Loop:
                       (#
                       do (if false then
                              (* do not work since we call
                               * exists from receiver and
                               * awaitResponse will call
                               * receiver recursively and
                               * we will deadlock
                               *)
                              awaitResponse -> msg[];                      
                           else
                              outSocket[] -> IP -> msg[];
                          if);
                          (if (msg[]=none) or not msg.isMsg then
                              restart Loop
                          if)
                       #);
                     log.newline;
                     (if not msg.isDeleted then
                         i -> lastNonDeleted
                     if);
                     msg.M.PP -> log.puttext; log.newline;
                     msg.subject -> do_coded2iso -> header[];
                     '   ' -> header.append;
                     msg.sender  -> do_coded2iso -> header.append;
                     '   ' -> header.append;
                     msg.date -> header.append;
                     (mno+1->mno,header[]) 
                       -> myWindowEnv.theWindow.mails.setText;
                     none -> currentID[];
                     awaitCompleted; (* OK from FETCH *)
                  #)
             for);
             'EXIST: done fetching mailbox'->  log.putline;
             (if lastNonDeleted > 0 then
                 (lastNonDeleted,false) 
                   -> myWindowEnv.theWindow.mails.selection.select;
                 myWindowEnv.theWindow.mails.selection.scrollIntoView;
                 (lastNonDeleted,true) -> sendFetch
                 (# s,e: @integer
                 do Loop:
                      (#
                      do outSocket[] -> IP -> msg[];
                         (if (msg[]=none) or not msg.isMsg then
                             restart Loop
                      if)#);
                    msg.message -> myWindowEnv.theWindow.TE.puttext;
                    awaitCompleted; (* OK FETCH *)
                    none -> currentID[];
                 #)
             if);
             'EXIST: done SHOW lastNonDeleted'->  log.putline;
             'EXIST: done SHOW lastNonDeleted'->  screen.putline;
          #);
        addFolder:
          (# f,f1: ^myWindowEnv.theWindow.scrolltv.contents.folder;
             M: ^mailFolder
          enter(f[],M[])
          do (if not M.isFolder then 
                 (* add leaf *)
                 (F[],M.name[]) 
                   -> myWindowEnv.theWindow.scrolltv.contents.addLeaf
              else
                 (f[],M.name[]) 
                   -> myWindowEnv.theWindow.scrolltv.contents.addFolder
                   -> f1[];
                 M.subs.scan
                 (#
                 do (f1[],current.M[]) -> addFolder
                 #)
             if);
             myWindowEnv.theWindow.scrolltv.contents.changed;
             
          #);
        selectFolder:
          (# name: ^text
          enter name[]
          do name[] -> sendSelect
          #);
        showMessage: @ | system
          (# msgNo: @integer; C: ^response; msg: ^messageResponse
          enter msgNo
          do cycle
               (#
               do 'Showmessage:'->log.putline;
                  (msgNo,true) -> sendFetch
                  (# s,e: @integer
                  do 'getresponse:'->log.putline;
                     (if true then
                         this(showMessage)[] 
                           -> objectToComponent
                           -> receiver.waitResponse 
                           -> C[];                      
                      else
                         outSocket[] -> IP -> C[];
                     if);
                     'got response'->log.putline;
                     (if C.isMsg then
                         C[] -> msg[];
                         msg.M.pp -> log.putline;
                         msg.getFlags;
                         msg.message -> myWindowEnv.theWindow.TE.puttext
                      else
                         '\nFECTH: missing message response'->putline;
                     if);
                     awaitCompleted; (* OK FETCH *)
                     none -> currentID[];
                  #);
                  SUSPEND;
               #)
          #);
        T: @styledtext;
     #);
   MB: @mailFolder;
   IP: @parseImap;
   
   log: ^Stream; 
   logF: @logFile;
   logFile:< file
     (# init:<
          (#
          do (if trace then
                 'myMailer-log.txt' -> name; 
                 openWrite;
                 (if false then
                     screen[] -> log[]
                  else
                     logF[] -> log[];
                 if)
              else 
                 &stream[] -> log[]
             if);
          #);
        doClose:< (# do (if trace then close if)#)
     #);   
   trace: (# exit true #);
do logF.init;
   log[] -> IP.init;
   MB.init;
   'daimi'->MB.name[];
   IM
#)
