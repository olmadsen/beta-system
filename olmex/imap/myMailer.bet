ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/utils/treeview';
INCLUDE '~beta/guienv/scrolllists';
INCLUDE 'IMAPlib';
INCLUDE 'mailFolder';
INCLUDE '~beta/basiclib/numberio'
--- program: descriptor ---
systemenv
(# setWindowEnv::< (# do myWindowEnv[] -> theWindowEnv[] #);   
   myWindowEnv: @guienv 
     (# sizes: @
          (# window_H,window_W
             ,tree_H,tree_W
             ,mails_H,mails_W
             ,mails_X,mails_Y
             ,TE_H,TE_W
             ,TE_X,TE_Y
             : @integer;
             defaults:
               (#
               do 800 -> window_W; 650 -> window_H;
                  200 -> tree_W;   window_H -> tree_H;
                  
                  650 -> mails_W; 300 -> mails_H;
                  150 -> mails_X; 0 -> mails_Y;
                  
                  650 -> TE_W; 350 -> TE_H;
                  150 -> TE_X; 300 -> TE_Y;
               #)
          #);
        theWindow: @window
          (# eventhandler::
               (# onAboutToClose:: (# do terminate #);
                  onMouseDown:: 
                    (# do ff.select(# do scrolltv[]->ff.scrollIntoView #) #)
               #);
             menubarType:: standardMenubar
               (# fileMenu:: standardFileMenu
                    (# newMenuAction: @menuAction
                         (# onSelect:: 
                              (# 
                              do 'New...'->TE.putText;
                              #) 
                         #);
                       saveMenuAction: @menuAction
                         (# onSelect:: (# do 'Saving...'->TE.puttext #) #);
                       saveAsMenuAction: @menuAction
                         (# onSelect:: (# do 'Saving As...'->TE.puttext #) #);
                       quitMenuAction: @menuAction
                         (# onSelect:: 
                              (# 
                              do 'Quitting...'->TE.puttext;
                                 IM.sendLOGOUT;
                                 terminate 
                              #)
                         #);
                       open::
                         (#
                         do newMenuAction[]->newMenuItem.attach;
                            saveMenuAction[]->saveMenuItem.attach;
                            saveAsMenuAction[]->saveAsMenuItem.attach;
                            quitMenuAction[]->quitMenuItem.attach
                         #)
                    #);
                  editMenu:: standardEditMenu
               #);
             
             ff: ^treeview.folder;
             scrolltv: @scroller
               (# contentsType:: treeview
                    (# hideRoot:: trueObject;
                       leaf: item
                         (# allowLabelEdit:: trueObject;
                            onLabelChanged:: (# do newlabel[]->label[] #)
                         #);
                       addFolder:
                         (# f,f1: ^folder;
                            T: ^text
                         enter(f[],T[])
                         do &folder[] -> f1[]; 
                            T[] -> f1.label[]; 
                            f1[]->f.addItem;
                         exit f1[]
                         #);
                       addLeaf:
                         (# f: ^folder; N: ^text; l: ^leaf
                         enter(f[],N[])
                         do &leaf[]->l[]; N[]->l.label[]; 
                            l[]->f.addItem;
                         #);
                       Open::
                         (# l: ^leaf;
                            r,f,f1: ^folder
                         do &folder[]->r[]; 'root'->r.label[];
                            (*(r[],'INBOX')-> addLeaf;
                            (r[],'ISIS') -> addFolder -> f[];
                            (f[],'projects')->addLeaf;*)
                            r[]->root; f1[]->ff[];
                         #)
                    #);
                  open::
                    (# 
                    do (sizes.tree_W,sizes.tree_H)->size;
                       TRUE -> bindBottom
                    #)
               #);
             TE: @textEditor
               (# open:: 
                    (# aTextStyle: @textStyle;
                    do 'Courier new' -> aTextStyle.name;
                       10 -> aTextStyle.size;
                       (20,500,aTextStyle[]) -> contents.setOneStyle;
                      (* textFaces.bold -> aTextStyle.face;
                       (1,20,aTextStyle[]) -> contents.setOneStyle;*)
                       (sizes.TE_W,sizes.TE_H) -> size;
                       (sizes.TE_X,sizes.TE_Y) -> position;
                       false -> bindBottom -> bindRight
                    #);
                  puttext:
                    (# T: @StyledText
                    enter T
                    do T[] ->contents.contents;
                    #)                  
               #);
             
             mails: @textScrollList
               (# multipleSelection:: (# do false -> value #);
                  open::
                    (# aTextStyle: ^textStyle;
                    do &textStyle[] -> aTextStyle[];
                       'Times' -> aTextStyle.name;
                       10 -> aTextStyle.size;
                      (* textFaces.bold -> aTextStyle.face;*)
                       aTextStyle[] -> style;
                       
                       (sizes.mails_X,sizes.mails_Y) -> position;
                       (sizes.mails_W, sizes.mails_H) -> size;
                       
                       100 -> append;
                       (if false then
                           (1, '1 bottle on the wall') -> setText;

                           (2, 100) -> forTo
                           (# t: @text;
                           do t.clear;
                              inx -> t.putInt;
                              ' bottles on the wall' -> t.putText;
                              (inx, t[]) -> setText;
                           #);
                       if)
                    #);
                  eventHandler::
                    (# onSelect::
                         (# selectedText: ^text;
                         do (if item <> 0 then
                                item -> getText -> selectedText[];
                                (if doubleClick then
                                    '!' -> selectedText.append;
                                if);
                                selectedText[] -> Title;
                             else
                                '<<NONE>>' -> Title;
                            if);
                         #);
                    #);
               #);
             open::
               (# 
               do sizes.defaults;
                  'myMailer'->title;
                  (sizes.window_W,sizes.window_H) -> size;
                  scrolltv.open;
                  TE.open;
                  mails.open;
               #)
          #);
        
        
     do theWindow.open;
     #);
   IM: @ IMAP
     (# logs::
          (# puttext::
               (# 
               do (*txt[] -> myWindowEnv.clipboard.textContents;
                  myWindowEnv.theWindow.TE.contents.paste;
                  (0,10) -> myWindowEnv.theWindow.TE.scroll;*)
               #);
          #);
        listResp::
          (#
          do (*mbox[] -> myWindowEnv.clipboard.textContents;
             myWindowEnv.theWindow.TE.contents.paste;
              mbox[] ->  myWindowEnv.theWindow.scrolltv.contents.addFolder;*)
             (17,lst.mbox.length) -> lst.mbox.sub -> lst.mbox[];
             (lst.mbox[],lst.NoSelect) -> MB.addSub;
          #);
        listCompleted::
          (#
          do (if false then
                 MB.scan(# 
                    do (if isF then 'folder: ' -> puttext if);
                       current[] -> putline
                        #);
             if);
             MB.subs.scan
             (#
             do (myWindowEnv.theWindow.scrolltv.contents.root,current.M[]) 
                  -> addFolder
             #);
          #);
        message::
          (# header: ^text
          do msg.subject -> header[];
             '   '->header.puttext;
             msg.sender -> header.append;;
             '   '->header.puttext;
             msg.date -> header.append;
             (1,header[])
               -> myWindowEnv.theWindow.mails.setText;
             msg.message -> myWindowEnv.clipboard.textContents;
             myWindowEnv.theWindow.TE.contents.paste;
             
             (0,10) -> myWindowEnv.theWindow.TE.scroll;
          #);
        coded2iso:
          (# T: ^text; S: @text; i: @integer; ch: @char; 
             isHex: booleanValue
               (# C: @char
               enter C
               do (if ('0' <= C) and (C <= '9') then
                      true -> value
                   else
                      (if ('a' <= C) and (C <= 'f') then
                          true -> value
                       else
                          (if ('A' <= C) and (C <= 'F') then
                              true -> value
                  if)if)if)
               #);
             isIso: booleanvalue
               (# i: @integer
               enter i
               do (if ((i+14) < T.length) and (T.T[i] = '?') then
                      (if T.T[i+1] // 'I' // 'i' then
                          (if T.T[i+2] // 'S' // 's' then
                              (if T.T[i+3] // 'O' // 'o' then
                                  (if T.T[i+10] = '1' then
                                      true -> value
                                  if)
                  if)if)if)if)
               #);
             isUTF8: booleanvalue
               (# i: @integer
               enter i
               do (if ((i+14) < T.length) and (T.T[i] = '?') then
                      (if T.T[i+1] = 'u' then
                          (if T.T[i+2] = 't' then
                              (if T.T[i+3] = 'f' then
                                  (if T.T[i+4] = '-' then
                                      (if T.T[i+5] = '8' then
                                      true -> value
                                  if)if)
                          if)if)
                       else
                          '\nCharSET: ' -> puttext;
                          (for i: 13 repeat T.T[i] -> put for);
                          newline
                      if)
                  if)
               #);
             hexVal:
               (# C: @char; V: @integer
               enter C
               do (if ('0' <= C) and (C <= '9') then
                      C - '0' -> V
                   else
                      (if ('a' <= C) and (C <= 'f') then
                          C - 'a' + 10 -> V
                       else
                          (if ('A' <= C) and (C <= 'F') then
                              C - 'A' + 10 -> V
                           else
                              '\n**** hexVal:Illegal character: "' -> puttext;
                              C -> put;
                              '"'->put; newline
                  if)if)if);
                  (* 'HEX: "'->puttext; C ->put; 
                   * '"'->put; V -> putint; newline*)
               exit V
               #)
          enter T[]
          do 1 ->i;
             loop:
               (if i <= T.length then
                   (if true 
                    // i+1 -> isIso then
                       (*'\nREAD-ISO: ' -> puttext;*)
                       i+15 -> i;
                       readIso:
                         (#
                         do (*ch -> put;*)
                            (if (T.T[i] -> ch) 
                             // '?' then 
                                i+1 -> i;
                                leave readIso
                             // '=' then
                                (if T.T[i+1] -> isHex then
                                    (if (i+2) <= T.length then
                                        (T.T[i+1] -> hexVal)*16 + (T.T[i+2]
                                          -> hexVal)
                                          -> ch;
                                        (if (ch <= ' ' ) or (ch > 255) then 
                                            '*'->ch 
                                        if);
                                        i+2 -> i;
                            if)if)if);
                            ch -> S.put;
                            i+1 -> i;
                            restart readIso
                         #)
                    // i+1 -> isUTF8 then
                       i+10 -> i;
                       '\nUTF-8:'->puttext;
                       T[] -> putline;
                       T.T[i] -> ch;
                       Loop:
                         (if i <= T.length then
                         (# V: @integer; c: @char
                         do (if ch
                             // '?' then 
                                i+1 -> i;
                                leave loop
                             // '=' then
                                i+1 -> i;
                                restart loop
                             else
                                0 -> V;
                                (for j: 4 repeat
                                     (* ch -> put; ' '->put;*)
                                    (if true
                                     // ('A'<= ch) and (ch <= 'Z') then
                                        V*64 + ch - 'A' -> V
                                     // ('a'<= ch) and (ch <= 'z') then
                                        V*64 + ch - 'a' + 26 -> V
                                     // ('0'<= ch) and (ch <= '9') then
                                        V*64 + ch - '0' + 52 -> V
                                     // ch = '=' then
                                        V*64 -> V
                                     else
                                        '\n***Illegal UTF-8 char: "'->puttext;
                                        ch -> put; '"'->put; ch -> puthex;
                                        newline
                                    if);
                                    i+1 -> i;
                                    T.T[i] -> ch;
                                for);
                                2->V.%getByte -> c -> S.put;
                                1->V.%getByte -> c;
                                (if c <> 0 then c -> S.put; if);
                                0->V.%getByte -> c;
                                (if c <> 0 then c -> S.put; if);
                                restart loop
                            if)                                        
                         #)if);

                       (# i: @integer; c: @char; L,R: @integer;
                          W: @text
                       do 
                          Loop:
                            (#
                            do S.T[i+1->i] -> c;
                               (if true 
                                // (c %band 2x11100000)= 2x11000000 then
                                   c %band 2x00011111 -> L;
                                   S.T[i+1->i] -> c; 
                                   c %band 2x00111111 -> R;
                                   L*64 + R -> c; 
                                // (c %band 2x11110000)= 2x11100000 then
                                   'B'->put;
                                   
                                // (c %band 2x11110000)= 2x11110000 then
                                   'C'->put;
                              
                                // (c %band 2x11111000)= 2x11111000 then
                                   'D'->put;
                               if);
                               c -> W.put;
                               (if i < S.length then restart loop if)
                            #);
                          W -> S; 
                       #)                       
                    else 
                       T.T[i] -> ch;                  
                       ch -> S.put;
                       i+1 -> i;
                       restart loop
               if)if);
             (*'\nDONE: ' -> puttext; S[] -> putline;*)
          exit S[] 
          #);
        exists::
          (# mno: @integer;
             C: ^response;
             msg: ^messageResponse;
             header: ^text;
             awaitCompleted:
               (#
               do (if false then
                      loop:
                        (# do
                           getresponse -> putline;
                           restart Loop
                        #)
                   else
                      Loop:
                        (#
                        do outSocket[] -> parseImap -> C[];
                           (if (C[]=none) or not C.isCompleted then
                               restart Loop
                  if)#)if)
               #)
          do 'EXIST: fetching mailbox: '->puttext; R.value -> putint; newline;
             awaitCompleted; (* OK from SELECT *)
             (for i: R.value repeat
                  (*i -> putint; ','->put;*)
                  (i,false) -> sendFetch
                  (#
                  do Loop:
                       (#
                       do outSocket[] -> parseImap -> msg[];
                          (if (msg[]=none) or not msg.isMsg then
                              restart Loop
                       if)#);
                     newline;
                     msg.M.PP; newline;
                     msg.subject -> coded2iso -> header[];
                     '   ' -> header.append;
                     msg.sender  -> coded2iso -> header.append;
                     '   ' -> header.append;
                     msg.date -> header.append;
                     (mno+1->mno,header[]) 
                       -> myWindowEnv.theWindow.mails.setText;
                     none -> currentID[];
                     awaitCompleted; (* OK from FETCH *)
                  #)
             for);
             'EXIST: done fetching mailbox'->putline;
             (R.value,false) -> myWindowEnv.theWindow.mails.selection.select;
             myWindowEnv.theWindow.mails.selection.scrollIntoView;
             (R.value,true) -> sendFetch
             (#
             do outSocket[] -> parseImap -> C[];
                (if C.isMsg then
                    C[] -> msg[];
                    msg.message -> myWindowEnv.clipboard.textContents;
                    myWindowEnv.theWindow.TE.contents.paste;
                 else
                    '\nFECTH: missing message repsonse'->putline;
                if);
                awaitCompleted; (* OK FETCH *)
                none -> currentID[];
             #)
          #);
        addFolder:
          (# f,f1: ^myWindowEnv.theWindow.scrolltv.contents.folder;
             M: ^mailFolder
          enter(f[],M[])
          do (if not M.isFolder then 
                 (* add leaf *)
                 (F[],M.name[]) 
                   -> myWindowEnv.theWindow.scrolltv.contents.addLeaf
              else
                 (f[],M.name[]) 
                   -> myWindowEnv.theWindow.scrolltv.contents.addFolder
                   -> f1[];
                 M.subs.scan
                 (#
                 do (f1[],current.M[]) -> addFolder
                 #)
             if);
             myWindowEnv.theWindow.scrolltv.contents.changed;
             
          #);
        T: @styledtext;
     #);
     MB: @mailFolder;
   
do MB.init;
   'daimi'->MB.name[];
   IM
#)
