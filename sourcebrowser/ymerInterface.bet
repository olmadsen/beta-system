ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/labelled'
        '~beta/editor/codeeditor'
        '~beta/editor/sifinterface'
        '~beta/debugger/debuggerinterface'
        '~beta/interfacebuilder/frigginterface'
        '~beta/debugger/debuggerinterface'
        '~beta/toollibs/utils/mpsinterface'
        '~beta/dependency/dependency'
        '~beta/guienv/utils/toolbar'
        'projects';
-- guienvlib: Attributes --
menuAppendItemAction: (# themenu: ^menu;  enter themenu[] do INNER #);
menubarAppendMenuAction:
  (# themenubar: ^menubar; theBrowser: ^ymerBrowserInterface; 
  enter (theBrowser[],themenubar[])
  do INNER
  #);
codeViewMenuAction:
  (# theWindow: ^window; themenubar: ^menubar; cfe: ^getcfecallback; 
  enter (theWindow[],themenubar[],cfe[])
  do INNER
  #);
getcfecallback:
  (# cfe: ^guienv.window.codeEditor;  do INNER exit cfe[] #);
BrowserCallBack:
  (#
     theBrowser: ^Window;
     browserInt: ^ymerBrowserInterface;
     ymerCallBack: ^ymerCall;
     
  enter (theBrowser[],browserInt[])
  do INNER
  #);
mysimplemenu: menu
(* Simplemenu taken from guienv/utils/simplemenu.bet,
 * but this is in guienvlib:attributes, just as
 * menu is!
 *)
  (#
     item: menuitem
       (#
          enabled: @boolean
          (* Set to true or false to enable or disable THIS(item) *) ;
          onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
          onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
            (#  do enabled->value; INNER #);
          new: (* Open and append THIS(Item) with label itemtext *)
            (# itemtext: ^text; 
            enter itemtext[]
            do
               true->enabled;
               open;
               (if itemtext[] <> none then itemtext[]->name if);
               THIS(item)[]->append;
               INNER ;
               
            #);
          newkey: new (* Also add key quivalent *)
            (# equiv: @char enter equiv do equiv->key #);
          eventhandler::< 
            (#
               onSelect::<  (#  do THIS(item).onSelect; INNER #);
               onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
               
            #);
          
       #);
     noOfRadioGroups:< integervalue
     (* The number of independant groups of radioitems.
      * Default 1.
      *) (#  do 1->value; INNER #);
     radioitem: item
     (* Special item, that is un-checked when another radioitem
      * in the radiogroup indicated by "checkgroup" is selected. 
      *)
       (#
          checkgroup: @integer
          (* The group of items THIS(item) is dependant on. default 1. *) ;
          open::<  (#  do 1->checkgroup; INNER ;  #);
          onSelect::< 
            (#  do THIS(radioitem)[]->changechecked; INNER ;  #);
          
       #);
     toggleitem: item
     (* Special item that is checked evey second time it is selected *)
       (# onSelect::<  (#  do not checked->checked; INNER ;  #) #);
     newseparator: (* Open and append a separator to THIS(simplemenu) *)
       (# 
       do &separator[]->private.s[]; private.s.open; private.s[]->append; 
       #);
     new:
     (* Open THIS(simplemenu) and append it to THIS(MenuBar) 
      * with label menutext.
      *)
       (# menutext: ^text; 
       enter menutext[]
       do
          open;
          (if menutext[] <> none then menutext[]->name if);
          (* THIS(mysimplemenu)[]->THIS(menubar).append *)
          
       #);
     changechecked: (* Explicitly change the checked item to be newitem *)
       (# newitem: ^radioitem
       enter newitem[]
       do
          (if private.oldChecked[newitem.checkgroup][] <> newitem[] then
              (if private.oldChecked[newitem.checkgroup][] <> none then
                  false->private.oldChecked[newitem.checkgroup].checked; 
              if);
              newitem[]->private.oldChecked[newitem.checkgroup][];
              true->newitem.checked;
              
          if)
       #);
     <<SLOT SimpleMenuLib:Attributes>>;
     private: @
       (#
          oldChecked: [noOfRadioGroups]
          ^radioitem;
          s: ^separator;
          
       #);
     
  #);
  

-- menulib: Attributes --
newseparator: (* Open and append a separator to THIS(menu) *)
  (# s: ^separator;  do &separator[]->s[]; s.open; s[]->append;  #);
item: menuitem
  (#
     enabled: @boolean
     (* Set to true or false to enable or disable THIS(item) *) ;
     onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
     onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
       (#  do enabled->value; INNER #);
     new: (* Open and append THIS(Item) with label itemtext *)
       (# itemtext: ^text; 
       enter itemtext[]
       do
          true->enabled;
          open;
          (if itemtext[] <> none then itemtext[]->name if);
          THIS(item)[]->append;
          INNER ;
          
       #);
     newkey: new (* Also add key quivalent *)
       (# equiv: @char enter equiv do equiv->key #);
     eventhandler::< 
       (#
          onSelect::<  (#  do THIS(item).onSelect; INNER #);
          onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
          
       #);
     
  #)  

-- windowlib: Attributes --
sblabelled: labelled
  (#
     changed:< (# status: @boolean enter status do INNER #);
     checked:< (# status: @boolean enter status do INNER #);
     locked:< (# status: @boolean enter status do INNER #);
     
  #);
sbInfoView:
  (#
     silent: @boolean;
     msgList: @list (# element:: text #);
     m: ^text;
     msgPush:< Object;
     msgPop:< Object;
     settext: @
       (# msg: ^text enter msg[] do 'Info: '->m[]; msg[]->m.append #);
     done:< (#  enter m[] do INNER #);
     msg:< (#  enter settext do INNER #);
     msgClear:< Object
  #);
  

-- lib: Attributes --
ymermps: mpsinterface (# dg: @AST.dependencyGraph;  #);
ymerBrowserInterface: (* public interface to a YmerBrowser *)
  (#
     id: @integer;
     (* used to identify browser *)
     gui: ^guienv;
     Ymerbrowser: ^guienv.window;
     mps: ^ymermps;
     theToolBar: ^guienv.window.toolbar;
     currentProject: ^projectInfo.project;
     currentGroup: ^projectInfo.group;
     currentForm: ^astInterface.fragmentForm;
     cge: (* current group editor *) ^guienv.window.editorEnv.groupEditor;
     cfe: (* current form editor *) ^guienv.window.codeEditor;
     edenv: ^guienv.window.editorEnv;
     locationView: ^guienv.window.sblabelled;
     infoView: ^guienv.window.sbinfoView;
     selectFragmentForm:<
       (# fgName: ^text; formName: ^text
       enter (fgName[],formName[])
       do INNER
       #);
     selectFragmentGroup:<
       (# fgName: ^text;  enter (fgName[]) do INNER #);
     projectmenuload:<
       (# theTitle: ^text;  enter theTitle[] do INNER #);
     dumpmenuload:< (# t: ^text;  do INNER exit t[] #);
     addProject:< (# location: ^text enter location[] do INNER #);
     appendProject:< (# location: ^text enter location[] do INNER #);
     appendDone:< Object;
     loadProject:<
       (# project: ^projectInfo.project enter project[] do INNER #);
     findAndSelect:<
       (# node: ^astInterface.ast enter node[] do INNER #);
     findOrCreateGroupEditor:<
       (#
          fg: ^mpsinterface.ast.fragmentGroup;
          ge: ^guienv.window.editorenv.groupEditor;
          
       enter fg[]
       do INNER
       exit ge[]
       #);
     selectNode:<
       (# root,node: ^astInterface.ast; separate: @boolean; 
       enter (root[],node[],separate)
       do INNER
       #);
     propertySelected:< BooleanValue;
     GetWindowsMenu:<
       (# windowsmenu: ^guienv.menu;  do INNER exit windowsmenu[] #);
     WindowsMenuInsertWindow:<
       (# win: ^guienv.window;  enter win[] do INNER #);
     QuitBrowser:< Object;
     updateToolbar:< object;
     updateBrowser:<
       (# fg: ^astInterface.fragmentGroup; ff: ^astInterface.fragmentForm; 
       enter (fg[],ff[])
       do INNER
       #);
     sifExternalInterface: ^SifInterface;
     friggExternalInterface: ^friggInterface;
     debuggerExternalInterface: ^debuggerInterface
  #);
ymerEnvInterface:
  (#
     gui: ^guienv;
     mps: ^ymermps;
     AddMenuAction:<
       (# ma: ^guienv.menubarAppendMenuAction;  enter ma[] do INNER #);
     AddFileMenuAction:<
       (# ma: ^guienv.menuAppendItemAction;  enter ma[] do INNER ;  #);
     isActive:< booleanObject;
     openParseEditor:<
       (# x,y: @integer; fn: ^text;  enter ((x,y),fn[]) do INNER #);
     showLogwindowPushState:< Object;
     LogwindowPopState:< Object;
     
  #);
  

