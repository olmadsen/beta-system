ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/utils/labelled'
        '~beta/editor/codeeditor'
        '~beta/editor/sifinterface'
        '~beta/debugger/debuggerinterface'
        '~beta/interfacebuilder/frigginterface'
        '~beta/debugger/debuggerinterface'
        '~beta/toollibs/utils/mpsinterface'
        '~beta/dependency/dependency'
        'projects';
-- guienvlib: Attributes --
menuAppendItemAction: (# themenu: ^menu;  enter themenu[] do INNER #);
menubarAppendMenuAction:
  (# themenubar: ^menubar; theBrowser: ^ymerBrowserInterface; 
  enter (theBrowser[],themenubar[])
  do INNER
  #);
BrowserCallBack:
  (#
     theBrowser: ^Window;
     browserInt: ^ymerBrowserInterface;
     ymerCallBack: ^ymerCall;
     
  enter (theBrowser[],browserInt[])
  do INNER
  #);
mysimplemenu: menu
(* Simplemenu taken from guienv/utils/simplemenu.bet,
 * but this is in guienvlib:attributes, just as
 * menu is!
 *)
  (#
     item: menuitem
       (#
          enabled: @boolean
          (* Set to true or false to enable or disable THIS(item) *) ;
          onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
          onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
            (#  do enabled->value; INNER #);
          new: (* Open and append THIS(Item) with label itemtext *)
            (# itemtext: ^text; 
            enter itemtext[]
            do
               true->enabled;
               open;
               (if itemtext[] <> none then itemtext[]->name if);
               THIS(item)[]->append;
               INNER ;
               
            #);
          newkey: new (* Also add key quivalent *)
            (# equiv: @char enter equiv do equiv->key #);
          eventhandler::< 
            (#
               onSelect::<  (#  do THIS(item).onSelect; INNER #);
               onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
               
            #);
          
       #);
     noOfRadioGroups:< integervalue
     (* The number of independant groups of radioitems.
      * Default 1.
      *) (#  do 1->value; INNER #);
     radioitem: item
     (* Special item, that is un-checked when another radioitem
      * in the radiogroup indicated by "checkgroup" is selected. 
      *)
       (#
          checkgroup: @integer
          (* The group of items THIS(item) is dependant on. default 1. *) ;
          open::<  (#  do 1->checkgroup; INNER ;  #);
          onSelect::< 
            (#  do THIS(radioitem)[]->changechecked; INNER ;  #);
          
       #);
     toggleitem: item
     (* Special item that is checked evey second time it is selected *)
       (# onSelect::<  (#  do not checked->checked; INNER ;  #) #);
     newseparator: (* Open and append a separator to THIS(simplemenu) *)
       (# 
       do &separator[]->private.s[]; private.s.open; private.s[]->append; 
       #);
     new:
     (* Open THIS(simplemenu) and append it to THIS(MenuBar) 
      * with label menutext.
      *)
       (# menutext: ^text; 
       enter menutext[]
       do
          open;
          (if menutext[] <> none then menutext[]->name if);
          (* THIS(mysimplemenu)[]->THIS(menubar).append *)
          
       #);
     changechecked: (* Explicitly change the checked item to be newitem *)
       (# newitem: ^radioitem
       enter newitem[]
       do
          (if private.oldChecked[newitem.checkgroup][] <> newitem[] then
              (if private.oldChecked[newitem.checkgroup][] <> none then
                  false->private.oldChecked[newitem.checkgroup].checked; 
              if);
              newitem[]->private.oldChecked[newitem.checkgroup][];
              true->newitem.checked;
              
          if)
       #);
     <<SLOT SimpleMenuLib:Attributes>>;
     private: @
       (#
          oldChecked: [noOfRadioGroups]
          ^radioitem;
          s: ^separator;
          
       #);
     
  #);
  

-- menulib: Attributes --
newseparator: (* Open and append a separator to THIS(menu) *)
  (# s: ^separator;  do &separator[]->s[]; s.open; s[]->append;  #);
item: menuitem
  (#
     enabled: @boolean
     (* Set to true or false to enable or disable THIS(item) *) ;
     onSelect:< object (* Shortcut for eventhandler.onSelect *) ;
     onStatus:< booleanValue (* Shortcut for eventhandler.onStatus *)
       (#  do enabled->value; INNER #);
     new: (* Open and append THIS(Item) with label itemtext *)
       (# itemtext: ^text; 
       enter itemtext[]
       do
          true->enabled;
          open;
          (if itemtext[] <> none then itemtext[]->name if);
          THIS(item)[]->append;
          INNER ;
          
       #);
     newkey: new (* Also add key quivalent *)
       (# equiv: @char enter equiv do equiv->key #);
     eventhandler::< 
       (#
          onSelect::<  (#  do THIS(item).onSelect; INNER #);
          onStatus::<  (#  do THIS(item).onStatus->value; INNER #);
          
       #);
     
  #)  

-- windowlib: Attributes --
sblabelled: labelled
  (#
     changed:< (# status: @boolean enter status do INNER #);
     checked:< (# status: @boolean enter status do INNER #);
     locked:< (# status: @boolean enter status do INNER #);
     
  #);
sbInfoView:
  (#
     msgList: @list (# element:: text #);
     m: ^text;
     msgPush:< Object;
     msgPop:< Object;
     settext: @
       (# msg: ^text enter msg[] do 'Info: '->m[]; msg[]->m.append #);
     done:< (#  enter m[] do INNER #);
     msg:< (#  enter settext do INNER #);
     
  #);
  

-- lib: Attributes --
ymermps: mpsinterface (# dg: @AST.dependencyGraph;  #);
ymerBrowserInterface: (* public interface to a YmerBrowser *)
  (#
     gui: ^guienv;
     Ymerbrowser: ^gui.window;
     mps: ^ymermps;
     selectFragmentForm:<
       (# fgName: ^text; formName: ^text
       enter (fgName[],formName[])
       do INNER
       #);
     selectFragmentGroup:<
       (# fgName: ^text;  enter (fgName[]) do INNER #);
     projects: ^projectInfo;
     projectmenuload:<
       (# theTitle: ^text;  enter theTitle[] do INNER #);
     addProject:< (# location: ^text enter location[] do INNER #);
     appendProject:< (# location: ^text enter location[] do INNER #);
     appendDone:< Object;
     findAndSelect:<
       (# node: ^astInterface.ast enter node[] do INNER #);
     findOrCreateGroupEditor:<
       (# fg: ^MPS.ast.fragmentGroup; ge: ^edEnv.groupEditor; 
       enter fg[]
       do INNER
       exit ge[]
       #);
     selectNode:<
       (# root,node: ^astInterface.ast; separate: @boolean; 
       enter (root[],node[],separate)
       do INNER
       #);
     currentProject: ^projects.project;
     currentGroup: ^projects.group;
     currentForm: ^astInterface.fragmentForm;
     cge: (* current group editor *) ^edEnv.groupEditor;
     cfe: (* current form editor *) ^Ymerbrowser.codeEditor;
     edenv: ^Ymerbrowser.editorEnv;
     locationView: ^ymerBrowser.sblabelled;
     infoView: ^ymerBrowser.sbinfoView;
     propertySelected:< BooleanValue;
     CreateSemanticErrorViewer:<
       (#
          SifSBInterface: ^SifsearchBrowserInterface;
          SBInt: ^searchBrowserInterface;
          
       enter SifSBInterface[]
       do INNER ; 
       exit SBInt[]
       #);
     CreateSearchViewer:<
       (#
          SifSBInterface: ^SifsearchBrowserInterface;
          SBInt: ^searchBrowserInterface;
          
       enter SifSBInterface[]
       do INNER ; 
       exit SBInt[]
       #);
     GetWindowsMenu:<
       (# windowsmenu: ^gui.menu;  do INNER exit windowsmenu[] #);
     WindowsMenuInsertWindow:<
       (# win: ^gui.window;  enter win[] do INNER #);
     sifExternalInterface: ^SifInterface;
     friggExternalInterface: ^friggInterface;
     debuggerExternalInterface: ^debuggerInterface;
     
  #);
ymerEnvInterface:
  (#
     gui: ^guienv;
     mps: ^ymermps;
     AddMenuAction:<
       (# ma: ^gui.menubarAppendMenuAction;  enter ma[] do INNER #);
     AddFileMenuAction:<
       (# ma: ^gui.menuAppendItemAction;  enter ma[] do INNER ;  #);
     isActive:< booleanObject;
     
  #);
searchBrowserInterface:
  (#
     opened: @boolean;
     open:< Object;
     show:< Object;
     bringToFront:< Object;
     registerFragmentGroup:<
       (# fg,ff,node: ^object;  enter (fg[],ff[],node[]) do INNER #);
     clearBrowser:< Object;
     showAllHits: @boolean;
     
  #);
SifsearchBrowserInterface:
  (#
     fg: ^astinterface.fragmentgroup;
     fgName: ^text;
     includeWarnings: @boolean;
     Open:< (#  do INNER #);
     setTitle:< (# t: ^text; noHits: @boolean enter noHits do INNER #);
     checkNode:<
       (# node: ^astInterface.ast; value: @boolean; t: ^text
       enter node[]
       do INNER
       exit (value,t[])
       #);
     checkGroupStatus:<
       (# fg: ^astInterface.fragmentGroup; value: @boolean
       enter fg[]
       do true->value; INNER
       exit value
       #)
  #);
  

