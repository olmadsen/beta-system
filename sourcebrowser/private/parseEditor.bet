ORIGIN '../ymer';

INCLUDE '~beta/guienv/fields';
INCLUDE '~beta/guienv/stddialogs';

INCLUDE '~beta/guienv/utils/obguienvadds';
INCLUDE '~beta/guienv/utils/labelled';

INCLUDE '~beta/guienv/utils/prompts';
INCLUDE '~beta/guienv/utils/pane';

INCLUDE 'ymerFileUtils';
INCLUDE 'ymerPrivate';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- ymerEnvLib: attributes ---
parseEditor: gui.window
  (# path: ^text;
     parseOK:< (# fg: ^astInterface.fragmentGroup enter fg[] do INNER #);
     loadFiles:
       (# 
       enter path[]
       do (if path[]<>NONE then
	      (* load source file *)
	      mps.AST.grammarTable.scan
	      (# fn: ^text; found: @boolean
	      do found or
		 (currentExtension[]->(path.copy).append->fn[]->(*GRAM*)gui.fileAvailable)
		   ->found
	      exit fn[]
	      #)
		->contents.sourceEditor.contents.loadFile;

	      (* load LST text file *)
	      '.lst'
		->(path.copy).Append
		->contents.errorsList.contents.loadFile;
	      path[]->gui.(*GRAM*)fragmentDefaultName->((title).copy).Append->title;
	  if)
       #);
     menubarType::
       (# fileMenu: @gui.(*GRAM*)menu
	    (# revertItem: @menuItem
		 (# eventHandler::
		      (# onSelect::
			   (# do path[]->loadFiles #)
		      #);
		    open:: (# do 'Revert'->name #)
		 #);
	       reparseItem: @menuItem
		 (# eventHandler::
		      (# onSelect::
			   (# fg: ^astInterface.fragmentGroup
			   do (if contents.sourceEditor.changed then
				  contents.sourceEditor.contents.saveFile;
				  false->contents.sourceEditor.changed;
				  this(parseEditor).close;
				  path[]->mps.AST.expandToFullPath
				    ->mps.fragmentGroupTable.getFragmentGroup->fg[];
				  (if fg[]<>none then fg[]->parseOK if)
                               
			      if)
			   #)
		      #);
		    open:: (# do 'Reparse'->name #)
		 #);
	       saveItem: @menuItem
		 (# eventHandler::
		      (# onSelect::
			   (#
			   do (if contents.sourceEditor.changed then
				  contents.sourceEditor.contents.saveFile;
				  false->contents.sourceEditor.changed
			      if)
			   #)
		      #);
		    open::
		      (# do 'Save'->name #)
		 #);
	       quitItem: @menuItem
		 (# eventHandler::
		      (# onSelect::
			   (# closeEditor: @boolean;
			      askuser: gui.(*GRAM*)promptForBoolean
				(# ok::
				     (#
				     do this(parseEditor).contents.sourceEditor.contents.saveFile;
					true->closeEditor
				     #);
				   notok:: (# do true->closeEditor #)
				#)
			   do (if contents.sourceEditor.changed then
				  (none,'Quit','Save before close?')
				    ->(&askUser[]).popup;
				  (if closeEditor then this(parseEditor).close if)
			       else
				  this(parseEditor).close
			      if)
			   #)
		      #);
		    open::
		      (# do 'w'->key; 'Close'->name #)
		 #);
	       open::
		 (#
		 do 'File'->name;
		    reparseItem.open; reparseItem[]->append;
		    revertItem.open; revertItem[]->append;
		    saveItem.open; saveItem[]->append;
		    quitItem.open; quitItem[]->append
	    #)#);
	  editMenu: @gui.(*GRAM*)menu
	    (# cutItem: @menuItem
		 (# eventHandler::
		      (# onStatus::
			   (#
			   do (contents.sourceEditor.contents.contents.selection.start<>contents.sourceEditor.contents.contents.selection.end)->value #);
			 onSelect::
			   (#
			   do contents.sourceEditor.contents.contents.cut
			   #)
		      #);
		    open:: (# do 'x'->key; 'Cut'->name #)
		 #);
	       copyItem: @menuItem
		 (# eventHandler::
		      (# onStatus::
			   (# do (contents.sourceEditor.contents.contents.selection.start<>contents.sourceEditor.contents.contents.selection.end)->value #);
			 onSelect::
			   (#
			   do contents.sourceEditor.contents.contents.copy
			   #)
		      #);
		    open::
		      (# do  'c'->key; 'Copy'->name #)
		 #);
	       pasteItem: @menuItem
		 (# eventHandler::
		      (#  onStatus::
			   (# do  gui.(*GRAM*)clipboard.hasText #);
			 onSelect::
			   (# do contents.sourceEditor.contents.contents.paste #)
		      #);
		    open::
		      (# do 'v'->key; 'Paste'->name #)
		 #);
	       open::
		 (#
		 do 'Edit'->name;
		    cutItem.open; cutItem[]->append;
		    copyItem.open; copyItem[]->append;
		    pasteItem.open; pasteItem[]->append
	    #)#);
	  open::
	    (#
	    do fileMenu.open; fileMenu[]->append;
	       editMenu.open; editMenu[]->append
	    #)
       #); (* menubarType *)
     contents: @pane
       (# dobind:
	    (#
	    do TRUE->bindTop->bindLeft->bindRight->bindBottom;
	       sourceEditor.dobind;
	       errorsList.dobind;
	    #);
	  fileEditor: labelled
	    (# loading: @boolean;
	       contentsType::< textEditor
		 (# path: ^text;
		    textFile: @file;
		    lineStarts: [1000]@integer;
		    lineMax: @integer;
		    loadFile:<
		      (#  t: ^text;
			 theText: @StyledText;
			 pos, lineInx: @integer;
		      enter path[]
		      do true->loading;
			 path[]->textFile.name;
			 (if path[]->gui.(*GRAM*)fileAvailable then
			     textFile.openRead;
			     0->pos->lineStarts[1];
			     1->lineInx;
			     textFile.scan
			     (# while:: (# do true->value #);
			     do ch->theText.put;
				pos+1->pos;
				(if ch=ascii.newLine then
				    lineInx+1->lineInx;
				    (if lineInx=lineStarts.range then
					1000->lineStarts.extend if);
				    pos->lineStarts[lineInx];
				if);
			     #);
			     lineInx+1->lineInx;
			     (if lineInx=lineStarts.range then
				 1000->lineStarts.extend if);
			     pos->lineStarts[lineInx];
			     lineInx->lineMax;
			     theText[]->contents.contents;
			     textFile.close;
			  else
			     'No read permissions to the file:\n     '->t[];
			     textFile.name->t.puttext;
			     (this(parseEditor)[], t[],'Read Error')
			       ->gui.(*GRAM*)alertUser;
			     'no .lst file'->theText.puttext;
			     0->pos->lineStarts[1]; 1->lineInx;
			     12->lineStarts[2]; 2->lineMax;
			     theText[]->contents.contents;
			 if);
			 false->loading;
			 INNER
		      #);
		    saveFile:
		      (# t: ^text
		      do true->loading;
			 (if (textFile.name->gui.(*GRAM*)fileExists)
			     and (textfile.name->gui.fileWriteable) then
			     textFile.openWrite;
			     contents.contents->textFile.puttext;
			     textFile.close;
			  else
			     'No write permissions to the file:\n     '->t[];
			     textFile.name->t.puttext;
			     (this(parseEditor)[], t[],'Write Error')
			       ->gui.(*GRAM*)alertUser
			 if);
			 false->loading;
		      #);
		    selectLine:
		      (# lineInx: @integer
		      enter lineInx
		      do (if (0<lineInx) and (lineInx<lineMax) then
                             (lineStarts[lineInx],lineStarts[lineInx+1]-1)
			       ->contents.selection;
			     contents.selection.scrollIntoView;
                         if);
		      #);
		    locateLine:
		      (# pos, lineInx: @integer
		      enter pos
		      do 1->lineInx;
			 loop:
			   (#
			   do lineInx+1->lineInx;
			      (if (lineInx<=lineMax)
			       and (lineStarts[lineInx]<=pos) then
			       restart loop
			      if)
			   #);
		      exit lineInx-1
		      #);
		    dobind:
		      (#
		      do TRUE->bindTop->bindLeft->bindRight->bindBottom;
		      #);
		 #);
	       dobind:
		 (# do contents.dobind #);
	       open::<
		 (#
		 do INNER;

		 #)
	    #);
	  errorsList: @fileEditor
	    (# contentsType::
		 (# contentsType::
		      (# lineInx: @integer;
			 selectLine:
			   (#
			   enter lineInx
			   do (if lineInx>=lineMax then lineMax-3->lineInx if);
                              while:
                                (if (0<lineInx) and (lineInx<=lineMax) then
                                    (if (lineStarts[lineInx]->getChar)='#' then
                                        lineInx+1->lineInx; restart while
                                if) if);
                              lineInx-3->lineInx;
                              l: (# t: @text
                                 do (if (0<lineInx) and (lineInx<lineMax) then
                                        (lineStarts[lineInx]+1,lineStarts[lineInx+1]-1)
                                          ->scanText(# do ch->t.put #);
                                        t.reset;
                                        t.getInt(# syntaxError:: (# do leave l #) #)
                                          ->sourceEditor.contents.selectLine;
                                    if)
                                 #)
                           #);
                         eventhandler::
			   (# onBeforeChange:: (# do loading->allow #);
			      onKeyDown::
				(#
				do (if ch
				    // ascii.cr
				    // ascii.nl then
				       (if lineInx+8>=lineMax then
					   0->lineInx
				       if);
				       lineInx+8->selectLine;
				       (lineStarts[lineInx],lineStarts[lineInx])
					 ->selection;
				       selection.scrollIntoView
				   if)
				#);
			      onMouseDown::
				(#
				do localPosition->ptToPos
				     ->locateLine
				     ->selectLine;
				#)
			   #)
		      #);
		    loadFile:: (# do 1->contents.selectLine #);
		 #);
	       open::
		 (# w,h: @integer;
		 do 'Parse Errors'->label;
		    this(parseEditor).size->(w,h);
		    (w,(h div 3)-1)->size;
		 #)
	    #);
	  sourceEditor: @fileEditor
	    (# changed: @boolean;
	       contentsType::
		 (# contentsType::
		      (# eventhandler::
			   (# onTextChanged:: (# do not loading->changed #) #)
		      #);
		 #);
	       open::
		 (# w,h: @integer
		 do 'BETA Source File'->label;
		    this(parseEditor).size->(w,h);
		    (w,((h*2) div 3)-1)->size;
		 #)
	    #);
	  open::
	    (# setDefaults:: (# do true->verticalStacking #)
	    do errorsList.open; sourceEditor.open;
	       errorsList[]->appendMember; sourceEditor[]->appendMember;
	       appendsDone; dobind
	    #)
       #);
     open::<
       (#
       do 'Parse Errors Editor for: '->title;
	  contents.open;
	  INNER;
       #)
  #)
