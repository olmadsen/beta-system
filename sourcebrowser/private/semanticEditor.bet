ORIGIN  '../ymer';

INCLUDE '~beta/guienv/v1.3.1/fields';
INCLUDE '~beta/guienv/v1.3.1/utils/listview';

INCLUDE '~beta/guienv/v1.3.1/utils/pane';

INCLUDE '~beta/betaast/v4.9.1/semanticerrortext';

INCLUDE '~beta/basiclib/v1.4/file';

INCLUDE '~beta/objectbrowser/v2.0/UI/obguienvadds';
INCLUDE '~beta/objectbrowser/v2.0/UI/labelled';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- browserlib: attributes ---
semanticBrowser: ymerLocalWindow
  (# clear: contents.clear(# #);
     fg: ^mps.AST.fragmentGroup;
     fgName: ^text;
     isWarning: 
       (* findes i mps/v5.0 - blot her for at
        * kunne filtrere warnings fra allerede i
        * v4.9.1 - skal fjernes senere
        *)
       (# no: @integer; boo: @boolean
       enter no
       do
          (if no
           //24//25//86//95//97//99//106//109
           //26 (*not used *) then
              true->boo
          if)
       exit boo
       #);
     includeWarnings: @boolean;
     noErrors: @boolean;
     aspect:< integerValue (#  do 6->value; INNER #);
     contents: @contentsType;
     contentsType:< pane
       (# clear:
            (# do FFlist.clear; errorsList.clear #);
          dobind:<
            (# 
            do
               TRUE->bindTop->bindLeft->bindRight->bindBottom;
               FFlist.dobind;
               errorsList.dobind;
               INNER dobind
            #);
          onNewFragmentGroup:<
            (# ff: ^mps.AST.fragmentForm; name: ^text; 
            enter (ff[],name[])
            do INNER onNewFragmentGroup
            #);
          onNewSemanticError:<
            (# node: ^mps.AST.ast; 
            enter node[]
            do INNER onNewSemanticError
            #);
          FFlist: @labelled
            (# clear: contents.clear(# #);
               dobind: (#  do contents.dobind #);
               contentsType:: listView
                 (# clear:  
                      (# 
                      do listitems.scanReverse(# do current.delete #);
                         listitems.clear;
                      #);
                    current: ^listitems.theCellType;
                    dobind:
                      (# 
                      do TRUE->bindTop->bindLeft->bindRight->bindBottom
                      #);
                    eventhandler:: 
                      (# onKeyDown:: 
                           (# 
                           do
                              (if ch
                               // ascii.cr // ascii.nl then
                                  (if current[] = none then
                                      listitems.head->current[]; 
                                   else
                                      current.succ[]->current[];
                                      (if current[] = none then
                                          listitems.head->current[]
                                      if);
                                      
                                  if);
                                  (if current[] <> none then
                                      current.elm.select;
                                      selection.scrollIntoView
                                  if)
                              if)
                           #)
                      #);
                    fgItem: listItem
                      (#
                         ff: ^mps.AST.fragmentForm;
                         onSelect:: 
                           (# fi: ^listitems.theCellType
                           do THIS(fgItem)[]->listitems.at->fi[];
                              (if fi[]<>current[] then
                                  fi[]->current[];
                                  (ff[],name)->onNewFragmentGroup;
                                  ff[]->errorsList.contents.registerSemanticErrors
                              if)
                           #);
                         
                      #);
                    registerFragmentForms:
                      (#
                         exp: ^mps.AST.expanded;
                         fi: ^fgItem;
                         fg: ^mps.AST.fragmentGroup;
                         ff: ^mps.AST.fragmentForm
                      enter fg[]
                      do clear;
                         true->noErrors;
                         (if fg[]<>none then
                             fg.fragmentList.scan
                             (# 
                             do
                                (if current.type
                                 // mps.AST.formType then
                                    (# 
                                    do
                                       current.open->ff[];
                                       (if ff.root.kind = mps.AST.kinds.interior
                                           then
                                           ff.root[]->exp[];
                                           l: exp.suffixWalk
                                             (# t: ^text
                                             do
                                                (if current.hasSemanticError then
                                                    (if (current.semanticError->isWarning) then
                                                        (if includeWarnings then
                                                            &fgItem[]->fi[];
                                                            fi.init;
                                                            ff[]->fi.ff[];
                                                            fgName.copy->t[];
                                                            '-'->t.append;
                                                            ff.name->t.append;
                                                            t[]->fi.name;
                                                            leave l
                                                        if)
                                                     else
                                                       &fgItem[]->fi[];
                                                       fi.init;
                                                       ff[]->fi.ff[];
                                                       fgName.copy->t[];
                                                       '-'->t.append;
                                                       ff.name->t.append;
                                                       t[]->fi.name;
                                                       leave l
                                                    if)
                                                if)
                                             #)
                                       if)
                                    #)
                                if)
                             #);
                             (if fi[] = none then
                                 ''->errorsList.label;
                                 true->noErrors;
                              else
                                 (if includeWarnings then
                                     'Semantic Errors and Warnings'->errorsList.label
                                  else
                                     'Semantic Errors'->errorsList.label
                                 if);
                                 false->noErrors;
                                 (listitems.head).elm.select
                             if)
                         if)
                      #);
                    open::  (#  do 'Fragment Forms'->label #);
                    
                 #);
               open:: 
                 (# w,h: @integer; 
                 do
                    THIS(semanticBrowser).size->(w,h);
                    (w,(h div aspect)-1)->size;
                    
                 #);
               
            #);
          errorsList: @labelled
            (# clear: contents.clear(# #);
               dobind: (#  do contents.dobind #);
               contentsType:: listView
                 (# clear: 
                      (#
                      do listitems.scanReverse(# do current.delete #);
                         listitems.clear;
                      #);
                    current: ^listitems.theCellType;
                    dobind:
                      (# 
                      do TRUE->bindTop->bindLeft->bindRight->bindBottom
                      #);
                    eventhandler:: 
                      (#
                         onKeyDown:: 
                           (# 
                           do
                              (if ch
                               // ascii.cr // ascii.nl then
                                  (if current[] = none then
                                      listitems.head->current[]; 
                                   else
                                      current.succ[]->current[];
                                      (if current[] = none then
                                          listitems.head->current[]
                                      if);
                                      
                                  if);
                                  (if current[] <> none then
                                      current.elm.select;
                                      selection.scrollIntoView;
                                      
                                  if)
                              if)
                           #)
                      #);
                    errorItem: listItem
                      (#
                         node: ^mps.AST.ast;
                         onSelect:: 
                           (# ei: ^listitems.theCellType;
                           do
                              THIS(errorItem)[]->listitems.at->ei[];
                              (if ei[]<>current[] then
                                  ei[]->current[];
                                  node[]->onNewSemanticError;
                              if)
                           #);
                         
                      #);
                    registerSemanticErrors:
                      (#
                         exp: ^mps.AST.expanded;
                         ei: ^errorItem;
                         ff: ^mps.AST.fragmentForm;
                      enter ff[]
                      do
                         clear;
                         (if ff.root.kind = mps.AST.kinds.interior then
                             ff.root[]->exp[];
                             exp.suffixWalk
                               (# t: ^text
                               do
                                  (if current.hasSemanticError then
                                      (if current.semanticError->isWarning then
                                          (if includeWarnings then
                                             &errorItem[]->ei[];
                                             ei.init;
                                             current[]->ei.node[];
                                             'Warning: '->t[];
                                             ei.node.semanticError->semanticErrorText
                                               ->t.append;
                                             t[]->ei.name;
                                          if)
                                       else
                                          &errorItem[]->ei[];
                                          ei.init;
                                          current[]->ei.node[];
                                          (if includeWarnings then 'Error: '->t[] else &text[]->t[] if);
                                          ei.node.semanticError->semanticErrorText
                                            ->t.append;
                                          t[]->ei.name;
                                     if)
                                  if)
                               #)
                         if);
                         (if ei[] = none then
                             true->noErrors
                          else
                             (listitems.head).elm.select
                         if)
                      #);
                    open::  
                      (#
                      do (if includeWarnings then
                             'Semantic Errors or Warnings'->label
                          else
                             'Semantic Errors'->label
                         if)
                      #);
                    
                 #);
               open:: 
                 (# w,h: @integer; 
                 do
                    THIS(semanticBrowser).size->(w,h);
                    (w,(h div aspect)-1)->size;
                    
                 #)
            #);
          open::< 
            (#
               setDefaults:: 
                 (#  do true->verticalStacking; 50->minsize; 2->panewidth #)
            do
               FFlist.open;
               errorsList.open;
               FFlist[]->appendMember;
               errorsList[]->appendMember;
               INNER open;
               appendsDone;
               dobind;
               
            #)
       #);
     menubarType:: 
       (#
          fileMenu: @menu
            (#
               quitItem: @menuItem
                 (#
                    eventHandler:: 
                      (# onSelect::  (#  do THIS(semanticBrowser).close #)
                      #);
                    open::  (#  do 'w'->key; 'Close'->name #)
                 #);
               open:: 
                 (#  do 'File'->name; quitItem.open; quitItem[]->append #)
            #);
          warningsMenu: @menu
            (# includeItem: @menuItem
                 (# eventhandler::
                      (# onSelect:: 
                           (# 
                           do not checked->checked->includeWarnings;
                              fg[]->registerFragmentGroup
                           #)
                      #);
                    open:: (# do 'i'->key; 'Include'->name #);
                 #);
               open:: 
                 (# 
                 do 'Warnings'->name; 
                    includeItem.open; includeItem[]->append;
                 #);
              #);
          open::  (#  do fileMenu.open; fileMenu[]->append; warningsMenu.open; warningsMenu[]->append #);
          
       #);
     registerFragmentGroup:
       (# enter fg[]
       do clear;
          fg[]->contents.FFlist.contents.registerFragmentForms;
          setTitle;
       #);
     setTitle:
       (# t: ^text
       do (if noErrors then 'No '->t[] else &text[]->t[] if);
          'Semantic Errors'->t.append;
          (if includeWarnings then ' or Warnings'->t.append if);
          ' in: '->t.append;
          fgName[]->t.append;
          t[]->title;
          
       #);
     open::< 
       (# w,h: @integer; 
       do
          hide;
          INNER open;
          contents.open;
          fg[]->registerFragmentGroup;
          show; 
          
       #)
  #);
semanticEditor: semanticBrowser
  (#
     contentsType::< 
       (#
          dobind::<  (#  do ASTeditor.dobind; INNER dobind #);
          onNewFragmentGroup::< 
            (# 
            do ff[]->ASTeditor.newFragment; name[]->ASTeditor.label; INNER
            #);
          onNewSemanticError::< 
            (# do node[]->ASTeditor.fe.setNode #);
          ASTeditor: @labelled
            (#
               dobind: (#  do contents.dobind #);
               ge: ^edenv.groupEditor;
               fe: ^codeEditor;
               newFragment:
                 (# ff: ^mps.AST.fragmentForm; 
                 enter ff[]
                 do
                    (ff[],ff.root[],none ,contents[],ge[])
                      ->edenv.findOrCreateFormEditor->fe[];
                    
                 #);
               contentsType::< codemoveableEditor
                 (# isolated:: trueObject;
                    dobind:
                      (# 
                      do true->bindRight->bindBottom->bindLeft->bindTop
                      #);
                    selectNode:: 
                      (#  do (theEditorRoot[],node[],separate)->browser.selectNode #);
                    charWidthType:: 
                      (#  do ASTeditor.private.theLabel.style->ts[] #);
                    getEncloser::  (#  do ffEncloser[]->theEncloser[] #);
                    ffEncloser: @codemoveableEditorEncloser
                      (#
                         getAST:: 
                           (#  do THIS(ymerApplication).mps.AST[]->AST[] #);
                         getBETACFL:: 
                           (# 
                           do THIS(ymerApplication).mps.BETACFL[]->BETACFL[]
                           #);
                         
                      #);
                    
                 #);
               open:: 
                 (#
                    sz: @point;
                    openContents:: 
                      (# t: ^text
                      do
                         (ASTeditor[],sz)->contents.open;
                         ASTeditor.contents[]->browser.onCodeViewOpen;
                         'No fragments selected'->label;
                         true->doneInInner
                      #);
                    w,h: @integer
                 do
                    THIS(semanticEditor).size->(w,h);
                    (w,(h div aspect)*4-1)->sz->size;
                    (none ,fg[],editMode)->edenv.createGroupEditor->ge[];
                    
                 #);
               
            #);
          open::< 
            (# 
            do ASTeditor.open; ASTeditor[]->appendMember; INNER open; 
            #);
          
       #);
     open::<  (#  do (600,800)->size; INNER open;  #);
     
  #);
semanticViewer: semanticBrowser
  (#
     aspect::  (#  do 2->value #);
     contentsType::< 
       (#
          onNewFragmentGroup::< 
            (# 
            do
               ((ff.father).fullname,ff.name)->browser.selectFragmentForm;
               INNER
            #);
          onNewSemanticError::< 
            (#  do (node.frag.root[],node[],false)->browser.selectNode #);
          
       #);
     open::<  (#  do (400,300)->size; INNER open;  #);
     
  #);
  
