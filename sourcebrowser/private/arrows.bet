ORIGIN '~beta/guienv/v1.6/guienv';
INCLUDE '~beta/guienv/v1.6/figureitems';
INCLUDE '~beta/guienv/v1.6/graphics';
INCLUDE '~beta/basiclib/v1.6/math';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- windowLib: attributes ---

arrow: line
  (# controlPoint: @point;
     arrowATstart, arrowATmid, arrowATend: @boolean;
     filled: @boolean;
     head: graphics
       (# points: [4] ^point;
          recalc:<
            (# pt, pos, p1, p2: @point;
               slope, sin_angle, cos_angle: @real;
               swapH: @boolean;
               quadrant, adjust: @integer;
               rotate: @
                 (# p: @point; ph, pv: @integer
                 enter p
                 do p.h->ph; p.v->pv;
                    (ph*cos_angle+pv*sin_angle,
                    -ph*sin_angle+pv*cos_angle)->p;
                 exit p
                 #);
            enter (pt,pos)
            do (if pt.v>pos.v then
                   (if pt.h>pos.h then
                       1->quadrant
                    else
                       2->quadrant
                   if)
                else
                   (if pt.h>pos.h then
                       3->quadrant
                    else
                       4->quadrant
                   if)
               if);
               (pt.h,-pt.v)->p1; (pos.h,-pos.v)->p2;
               (if (p2.v-p1.v)>0 then
                   (-p1.h,p1.v)->p1;
                   (-p2.h,p2.v)->p2; true->swapH;
               if);
               (if (p2.h-p1.h)=0 then
                   0->cos_angle;
                   (if (p2.v-p1.v)<0 then
                       1->sin_angle
                    else
                       -1->sin_angle
                   if)
                else
                   -(p2.v-p1.v)/((p2.h-p1.h)->abs)->slope;
                   (1/(((slope*slope)+1)->sqrt))->cos_angle;
                   slope*cos_angle->sin_angle;
               if);
               (if quadrant
                // 1 then
                // 2 then -cos_angle->cos_angle;
                // 3 then -cos_angle->cos_angle
                // 4 then
               if);
               0->adjust;
               (adjust,adjust)->points[1];
               (-controlpoint.h+adjust,-controlpoint.v+adjust)->points[2];
               (-controlpoint.h+adjust,+controlpoint.v+adjust)->points[3];
               (adjust,adjust)->points[4];
               
               (for i: 4 repeat points[i]->rotate->points[i] for);
               (for i: 4 repeat (points[i].h,-points[i].v)->points[i] for);
               (if swapH then 
                   (for i: 4 repeat (-points[i].h,points[i].v)->points[i] for)
               if);
               (if quadrant
                // 1 then (pt.h-pos.h,pt.v-pos.v)->pos.add;
                // 2 then (pt.h,pt.v-pos.v)->pos.add;
                // 3 then (pt.h,pos.v+pt.v)->pos
                // 4 then pt->pos.add;
               if);
               (for i: 4 repeat pos->points[i].add for);
            #);
          init:
            (#
            do &point[]->points[1][];
               &point[]->points[2][];
               &point[]->points[3][];
               &point[]->points[4][];
            #)
       do 
               (*(if filled then points->fillPolygon else points->drawPolygon if)*)
          (if not filled then
              this(arrow).pen.backgroundColor->pen.foregroundColor
          if);
          points->fillPolygon; 
          (if not filled then
              this(arrow).pen.foregroundColor->pen.foregroundColor;
              points->drawPolygon
          if);
       #);
     startHead: @head;
     midHead: @head;
     endHead: @head;
     eventhandler::
       (# recalc:
            (# p: @point
            do INNER;
               (if arrowATstart then
                   start->p; end->p.subtract; ((3,3),p)->startHead.recalc
               if);
               (if arrowATmid then
                   start->p; end->p.subtract;
                   (((-p.h div 2)+3,(-p.v div 2)+3),p)->midHead.recalc
               if);
               (if arrowATend then
                   end->p; start->p.subtract; ((3,3),p)->endHead.recalc
               if);
            #);
          redraw:
            (#
            do INNER;
               (if arrowATstart then startHead if);
               (if arrowATmid then midHead if);
               (if arrowATend then endHead if);
            #);
          onFrameChanged::<
            (# do INNER; recalc;redraw #);
          onVisibleChanged::<
            (# do INNER; recalc;redraw #);
          onRefresh::<
            (# do INNER; recalc;redraw #)
       #);
     open::<
       (#
       do startHead.init;
          midHead.init;
          endHead.init;
          INNER;
          
       #)
  #);
