ORIGIN 'hierarchy';
-- HIRfindFGAndSelect: DoPart --
do
   items.scan
     (# pe: ^propertyelement; hf: ^hirfolder; 
     do
        (if current## <= propertyElement## then
            current[]->pe[];
            (if fgname[]->pe.location.equal then
                true->found; (*current.select*) current[]->grp[]
            if)
         else
            (if current## <= hirfolder## then
                current[]->hf[]; fgname[]->hf.findFgandSelect->(found,grp[])
            if)
        if)
     #)  

-- temporaryProjectSavePrjFileAs: DoPart --
do
   l:
     (# prjFile: @file; fileNameFromDialog: @boolean; msg: ^text
     do
        (if fileName[] = none then
            true->fileNameFromDialog;
            fileCreationDialog
              (# 
              do
                 'Save \''->title[];
                 THIS(item).label[]->title.append;
                 '\' as'->title.append
              #)->filename[];
            (if filename[] = none then leave l if);
            '.pjt'->filename.append
        if);
        filename[]->prjfile.name;
        (if prjfile.entry.writeable then
        prjfile.openWrite;
        items.scan
        (# grp: ^group;
           MyDecomposepath:
             (# i,slashinx: @integer;
                path,head,suf,name,main:^text
             enter path[]
             do
                (* decompose path *)
                0->i;
                (* Assume \ is separator *)
                '/' -> path.findAll(# do inx -> i #);
                (* No \ found, check for directorychar instead *)
                (if i=0 then directorychar -> path.findAll(# do inx -> i #); if);
                &text[]->head[];
                (if i=0 then 
                    path.copy -> name[];
                 else
                    i->slashinx;
                    path.t[1:i-1] -> head;
                    &text[] -> name[];
                    path.t[i+1:path.length] -> name;
                if);
                (* decompose name *)
                0->i;
                '.' -> name.find(# from::(# do 0->value #) do inx -> i #);
                &text[] -> suf[];
                (if i=0 then 
                    name.copy -> main[];
                 else
                    &text[] -> main[];
                    name.t[1:i-1] -> main;
                    name.t[i:name.length] -> suf;
                if);
                head[]->path[];
                (if path.length>0 then
                    directorychar->path.put
                if);
                main[]->path.append
             exit path[]
             #)
        do
           current[]->grp[];
           'group#\'%s\' \'%s\'\n'
             ->prjfile.putformat
           (#  do grp.label[]->s; grp.location[]->MyDecomposepath->s #)
          #);
        prjFile.close
       else 
         'No write access to \''->msg[];
         prjFile.name->msg.append; 
         '\''->msg.append;
         (if fileNameFromDialog then
            (none,msg[],'Write error')->alertUser; 
            none->fileName[];
            restart l
          else
            msg[]->putLine
         if)
       if)
     #)  

