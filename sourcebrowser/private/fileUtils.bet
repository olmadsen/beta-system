ORIGIN '../sourcebrowser';
INCLUDE '~beta/basiclib/file'
        '~beta/basiclib/directory';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- guienvLib: Attributes --
fragmentDefaultName:
  (# f: @file enter f.name exit f.entry.path.name.prefix #);
fragmentForeName: (* removes extensions *)
  (# f: @file; t: ^text
  enter f.name
  do
     f.entry.path.head->t[];
     (if t.length > 0 then directoryChar (* ess: was '/' *) ->t.put if);
     f.entry.path.name.prefix->t.append
  exit t[]
  #);
fileAvailable:
  (# f: @file; avail: @boolean; t: ^text; required:< booleanValue; 
  enter f.name
  do
     (if true
      //
      not
      f.entry.exists
        (# error::  (#  do (none ,msg[],'File.exists error')->alertUser #)
        #) then
         (if required then
             'File: '->t[];
             f.name->t.puttext;
             '\ndoes not exist'->t.puttext;
             (none ,t[],'Not available')->alertUser
         if)
      //
      not
      f.entry.readable
        (#
           error::  (#  do (none ,msg[],'File.readable error')->alertUser #)
        #) then
         (if required then
             'No read permissions to the file:\n     '->t[];
             f.name->t.puttext;
             (none ,t[],'Not available')->alertUser
         if)
      else
         true->avail
     if);
     
  exit avail
  #);
fileRequired: fileAvailable (# required:: trueObject #);
fileExists:
  (# f: @file
  enter f.name
  exit f.entry.exists
    (# error::  (#  do (none ,msg[],'File.exists error')->alertUser #)
    #)
  #);
fileReadable:
  (# f: @file
  enter f.name
  exit f.entry.readable
    (# error::  (#  do (none ,msg[],'File.readable error')->alertUser #)
    #)
  #);
fileWriteable:
  (# f: @file
  enter f.name
  exit f.entry.writeable
    (# error::  (#  do (none ,msg[],'File.writeable error')->alertUser #)
    #)
  #);
fileModtime:
  (# f: @file
  enter f.name
  exit f.entry.modtime
    (# error::  (#  do (none ,msg[],'File.modtime error')->alertUser #)
    #)
  #);
isFile:
  (# f: @file
  enter f.name
  exit f.entry.isFile
    (# error::  (#  do (none ,msg[],'File.isFile error')->alertUser #)
    #)
  #);
isDirectory:
  (# f: @file
  enter f.name
  exit f.entry.isDirectory
    (#
       error:: 
         (# 
         do (none ,msg[],'File.isDirectory error')->alertUser; true->continue
         #)
    #)
  #);
  

