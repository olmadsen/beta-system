ORIGIN '~beta/mps/v5.1/astlevel';
INCLUDE '~beta/containers/v1.5/list';
INCLUDE '~beta/sysutils/v1.5/envstring';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- astInterfaceLib: attributes ---

newGrammarTable:
  (# element: (# name, extension, path: ^text #);
     table: [10]@element; inx: @integer;
     init:
       (# grammarExtensions: ^fragmentGroup;
          grammarNameError:< exception
            (#
            do 'Grammar extension or path found in wrong position'->msg.puttext;
               INNER
            #);
          grammarExtensionPathError:< exception
            (#
            do 'Grammar extension or path found in wrong position'->msg.puttext; 
               INNER
            #);
          grammarConstError:< exception
            (#
            do 'Const values does not make sense in grammar specifications'
                 ->msg.puttext; INNER
            #);
          grammarFormatError:< exception
            (#
            do 'Something wrong with the number of values in grammar specification'
                 ->msg.puttext; INNER
            #);
          grammarMPSerror:< exception
            (# t: ^text enter t[] do t[]->msg.puttext; INNER #);
          newGrammarTableInitCatcher: @handler
            (#
            do (if no
                // notificationNumbers.startingParsing
                // notificationNumbers.noParserAvailable then (* ignore *)
                else
                   msg[]->grammarMPSerror
               if)
            #);
       do (if theCatcher[] = none then
              theCatcher[]->newGrammarTableInitCatcher.oldCatcher[];
              newGrammarTableInitCatcher[]->theCatcher[]
             if);
          ('~beta/configuration/MBSgrammarsExt'->expandToFullPath,screen[])
            ->top.open
            ->grammarExtensions[];
          (if grammarExtensions[]<>NONE then
              l:
                grammarExtensions.prop.scanProp
                (# doProp::<
                     (# pos: @integer;
                     do (if 'GRAMMAR'->prop.equalNCS then
                            scanParameters
                            (# doName::<
                                 (#
                                 do (if ((pos+1) mod 3)->pos
                                     // 1 then (* grammar name *)
                                        (if (inx+1->inx)>table.range then
                                            10->table.extend
                                        if);
                                        n.copy->table[inx].name[];
                                     else
                                        grammarNameError  
                                    if)
                                 #);
                               doString::<
                                 (#
                                 do (if ((pos+1) mod 3)->pos
                                     // 2 then (* grammar extension *)
                                        s.copy->table[inx].extension[]
                                     // 0 then (* Grammar path *)
                                        s.copy->table[inx].path[]
                                     else
                                       grammarExtensionPathError 
                                    if);
                                 #);
                               doConst::<
                                 (# do grammarConstError #);
                            #);
                        if);
                        (if pos<>0 then
                            grammarFormatError
                        if)
                     #)
                #)
           else
              'No Grammers Extensions File available'->putline
          if);
          (if theCatcher[] = newGrammarTableInitCatcher[] then
              newGrammarTableInitCatcher.oldCatcher[]->theCatcher[]
          if)
       #);
     checkExtension:
       (# ext: ^text; g: ^object
       enter ext[]
       do l: (for i: inx repeat
                  (if ext[]->table[i].extension.equalNCS then
                      (table[i].name[],screen[])->grammarTable.find->g[];
                      leave l
                  if)
       for)
       exit g[]<>none
       #);
     scanExtensions:
       (# current: ^text
       do (for i: inx repeat
               table[i].extension[]->current[]; inner scanExtensions
          for)
       #);
     scanNames:
       (# current: ^text
       do (for i: inx repeat
               table[i].name[]->current[]; inner scanNames
          for)
       #);
     scanPaths:
       (# current: ^text
       do (for i: inx repeat
               table[i].path[]->current[]; inner scanPaths
          for)
       #);
     scan:
       (# currentName, currentExtension, currentPath: ^text
       do (for i: inx repeat
               table[i].name[]->currentName[]; 
               table[i].extension[]->currentExtension[];
               table[i].path[]->currentPath[];
               inner scan
          for)
       #)
  #)
