ORIGIN '~beta/mps/v5.1/astlevel';
INCLUDE '~beta/containers/v1.5/list';
INCLUDE '~beta/sysutils/v1.5/envstring';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)

--- astInterfaceLib: attributes ---

newGrammarTable:
  (# element: (# name, extension, path: ^text #);
     table: [10]@element; inx: @integer;
     init:
       (# grammarExtensions: ^fragmentGroup;
          grammarNameError:< exception
            (#
            do 'Grammar extension or path found in wrong position'->msg.puttext
            #);
          grammarExtensionPathError:< exception
            (#
            do 'Grammar extension or path found in wrong position'->msg.puttext
            #);
          grammarConstError:< exception
            (#
            do 'Const values does not make sense in grammar specifications'
                 ->msg.puttext
            #);
          grammarFormatError:< exception
            (#
            do 'Something wrong with the number of values in grammar specification'
                 ->msg.puttext
            #);
       do ('~beta/configuration/r4.0/MBSgrammarsExt'->expandToFullPath,screen[])
            ->top.open
            ->grammarExtensions[];
          (if grammarExtensions[]<>NONE then
              l:
                grammarExtensions.prop.scanProp
                (# doProp::<
                     (# pos: @integer;
                     do (if 'GRAMMAR'->prop.equalNCS then
                            scanParameters
                            (# doName::<
                                 (#
                                 do (if ((pos+1) mod 3)->pos
                                     // 1 then (* grammar name *)
                                        (if (inx+1->inx)>table.range then
                                            10->table.extend
                                        if);
                                        n.copy->table[inx].name[];
                                     else
                                        grammarNameError  
                                    if)
                                 #);
                               doString::<
                                 (#
                                 do (if ((pos+1) mod 3)->pos
                                     // 2 then (* grammar extension *)
                                        s.copy->table[inx].extension[]
                                     // 0 then (* Grammar path *)
                                        s.copy->table[inx].path[]
                                     else
                                       grammarExtensionPathError 
                                    if);
                                 #);
                               doConst::<
                                 (# do grammarConstError #);
                            #);
                        if);
                        (if pos<>0 then
                            grammarFormatError
                        if)
                     #)
                #)
           else
              'No Grammers Extensions File available'->putline
          if)
       #);
     checkExtension: @
       (# ext: ^text; found: @boolean;
       enter ext[]
       do false->found;
          l: (for i: inx repeat
                  (if ext[]->table[i].extension.equalNCS then
                      (table[i].name[],screen[])->grammarMissing->found;
                      leave l
                  if)
             for)
       exit found
       #);
     scanExtensions:
       (# current: ^text
       do (for i: inx repeat
               table[i].extension[]->current[]; inner scanExtensions
          for)
       #);
     scanNames:
       (# current: ^text
       do (for i: inx repeat
               table[i].name[]->current[]; inner scanNames
          for)
       #);
     scanPaths:
       (# current: ^text
       do (for i: inx repeat
               table[i].path[]->current[]; inner scanPaths
          for)
       #);
     scan:
       (# currentName, currentExtension, currentPath: ^text
       do (for i: inx repeat
               table[i].name[]->currentName[]; 
               table[i].extension[]->currentExtension[];
               table[i].path[]->currentPath[];
               inner scan
          for)
       #)
  #)
