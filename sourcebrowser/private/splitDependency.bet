ORIGIN '../ymer';
INCLUDE '~beta/mps/astlevel'
        '~beta/betaast/index'
        '~beta/dependency/dependency';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- dependencyPrivate: Descriptor --
(#
   debugSplitDependency:(# exit false #);
   errorMsg: @text;
   Module:
     (#
        Path,Library,Version,Name: ^text;
        NumberOfForms: @integer;
        location:
          (# loc: ^text
          do
             path.copy->loc[];
             mps.ast.thepathhandler.directoryChar->loc.put;
             Library[]->loc.putText;
             mps.ast.thepathhandler.directoryChar->loc.put;
             (if isLibrary then
                 Version[]->loc.putText;
                 mps.ast.thepathhandler.directoryChar->loc.put;
                 
             if)
          exit loc[]
          #);
        isLibrary:
          (#  exit (version[] <> none ) and (Version.Length <> 0) #);
        Dump:
          (#
             newGroup: ^browser.projects.group;
             selectedProj: ^browser.projects.project;
             
          enter selectedProj[]
          do
             &browser.projects.group[]->newGroup[];
             Path->newGroup.location;
             mps.ast.thepathhandler.directoryChar->newGroup.location.put;
             Library[]->newGroup.location.putText;
             mps.ast.thepathhandler.directoryChar->newGroup.location.put;
             (if isLibrary then
                 Version[]->newGroup.location.putText;
                 mps.ast.thepathhandler.directoryChar->newGroup.location.put;
                 
             if);
             Name[]->newGroup.location.puttext;
             Name[]->newGroup.name[];
             'ModuleDumping: loc=%s, name=%s\n'
               ->putformat
                 (#  do newGroup.location[]->s; newGroup.name[]->s #);
             
          exit newGroup[]
          #);
        
     #);
   Library:
     (#
        Name,Version,Path: ^text;
        ModList: [100] ^Module;
        ModEnd: @integer;
        insert:
          (# theModule: ^Module; isPresent: @boolean; 
          enter theModule[]
          do
             false->isPresent;
             loop:
             (for i: ModEnd repeat
               (if (theModule.name[]->ModList[i].name.equal) then
                   true->isPresent; leave loop
               if)
             for);
             (if not isPresent then
                 (if (ModEnd = ModList.range) then
                     ModList.range / 2->ModList.extend
                 if);
                 theModule[]->ModList[ModEnd+1->ModEnd][];
                 
             if)
          exit isPresent
          #);
        Dump:
          (#
             newProj: ^browser.projects.project;
             selectedProj: ^browser.projects.project;
             splitIntoSubprojects:
               (#
                  SplitName:
                    (# name: ^text; index: @integer
                    enter name[]
                    do
                       name.Length->index;
                       l:
                       mps.ast.thepathhandler.directoryChar
                         ->name.FindAll (#  do inx->index; leave l #);
                       
                    exit ((1,index)->name.Sub,(index+1,name.Length)->name.Sub)
                    #);
                  projectList: list
                    (#
                       theCellType:: 
                         (#  #) (* to avoid a beta(5.1) compiler error *) ;
                       element:: 
                         (# name,location: ^text; subs: @projectList #)
                    #);
                  projList: @projectList;
                  name,rest: ^text;
                  pos: ^projectList.theCellType;
                  new: ^projectList.element;
                  currentList: ^projectList;
                  createProjects:
                    (#
                       currentList: ^projectList;
                       newProj,newProj2: ^browser.projects.project;
                       newGroup: ^browser.projects.group;
                       
                    enter (currentList[],newProj[])
                    do
                       currentList.scan
                         (# 
                         do
                            (if current.subs.empty then
                                &browser.projects.group[]->newGroup[];
                                current.name[]->newGroup.name[];
                                current.location->newGroup.location;
                                newGroup[]->newProj.groups.append;
                                
                             else
                                true->newProj.hasSubprojects;
                                &browser.projects.project[]->newProj2[];
                                current.name[]->newProj2.name[];
                                current.location->newProj2.location;
                                newProj2[]->newProj.subprojects.append;
                                (current.subs[],newProj2[])->createProjects;
                                
                            if)
                         #)
                    #);
                  newProj: ^browser.projects.project;
                  loc: ^text;
                  
               enter newProj[]
               do
                  projList.init;
                  (for i: ModEnd repeat
                    projList[]->currentList[];
                    ModList[i].location->loc[];
                    ModList[i].name[]->rest[];
                    l:
                    (if not rest.empty then
                        rest[]->splitname->(name[],rest[]);
                        name[]->loc.puttext;
                        currentList.locate
                          (#
                             predicate:: 
                               (# 
                               do current.elm.name[]->name.equal->value
                               #);
                             notFound:: 
                               (# 
                               do
                                  &projList.element[]->new[];
                                  new[]->currentList.append->pos[];
                                  name[]->new.name[];
                                  loc.copy->new.location[];
                                  
                               #)
                          do position[]->pos[]; 
                          #);
                        pos.elm.subs[]->currentList[];
                        restart l;
                        
                    if)
                  for);
                  (projList[],newProj[])->createProjects
               #)
          enter selectedProj[]
          do
             &browser.projects.project[]->newProj[];
             Path->newProj.location;
             mps.ast.thepathhandler.directoryChar->newProj.location.put;
             Name[]->newProj.location.putText;
             mps.ast.thepathhandler.directoryChar->newProj.location.put;
             (if (version[] <> none ) and (version.length <> 0) then
                 Version[]->newProj.location.putText;
                 mps.ast.thepathhandler.directoryChar->newProj.location.put;
                 
             if);
             Name[]->newProj.name[];
             '/'->newProj.name.put;
             newProj[]->splitIntoSubprojects;
             'Library-Dumping: loc=%s, name=%s\n'
               ->putformat
                 (#  do newProj.location[]->s; newProj.name[]->s #);
             
          exit newProj[]
          #)
     #);
   System:
     (#
        maxLib: (#  exit 100 #);
        LibList: [maxLib] ^Library;
        LibEnd: @integer;
        maxProg: (#  exit 100 #);
        ProgList: [maxProg] ^Library;
        ProgEnd: @integer;
        Insert:
          (#
             conflict:<
               (# lib,v1,v2: ^text;  enter (lib[],v1[],v2[]) do INNER #);
             theModule: ^Module;
             isPresent,libFound: @boolean;
             
          enter theModule[]
          do
             false->isPresent->libFound;
             (if true or theModule.isLibrary then (* Check the LibList *)
                 loop:
                 (for i: LibEnd repeat
                   (if (theModule.Library[]->LibList[i].name.equal) then
                       (if theModule.path[]->libList[i].path.equal then
                           true->libFound;
                           (if not
                           (LibList[i].version[]->theModule.version.equal) or
                           not (LibList[i].path[]->theModule.path.equal) then
                               (theModule.Library[],LibList[i].version[],
                                theModule.version[])->conflict
                           if)
                       if);
                       theModule[]->LibList[i].insert->isPresent;
                       leave loop
                   if)
                 for);
                 (if not libFound then
                     (if (LibEnd = LibList.range) then
                         libList.range / 2->LibList.extend
                     if);
                     &Library[]->LibList[LibEnd+1->LibEnd][];
                     theModule.Library.copy->LibList[LibEnd].name[];
                     theModule.version[]->LibList[LibEnd].version[];
                     theModule.path[]->LibList[LibEnd].path[];
                     theModule[]->LibList[LibEnd].insert
                 if);
                 
              else
             (* Check the ProgList *)
                 loop:
                 (for i: ProgEnd repeat
                   (if (theModule.Library[]->ProgList[i].name.equal) then
                       (if theModule.path[]->ProgList[i].path.equal then
                           true->isPresent;
                           theModule[]->ProgList[i].insert;
                           leave loop
                       if)
                   if)
                 for);
                 (if not isPresent then
                     (if (ProgEnd = ProgList.range) then
                         ProgList.range / 2->ProgList.extend
                     if);
                     &Library[]->ProgList[ProgEnd+1->ProgEnd][];
                     theModule.Library.copy->ProgList[ProgEnd].name[];
                     theModule.version[]->ProgList[ProgEnd].version[];
                     theModule.path[]->ProgList[ProgEnd].path[];
                     theModule[]->ProgList[ProgEnd].insert
                 if);
                 
             if)
          exit isPresent
          #);
        Dump:
          (# selectedProj: ^browser.projects.project; 
          enter selectedProj[]
          do
             true->selectedProj.hasSubprojects;
             (for i: ProgEnd repeat
               selectedProj[]->ProgList[i].Dump->selectedProj.subProjects.append
             for);
             (for i: LibEnd repeat
               selectedProj[]->LibList[i].Dump->selectedProj.subProjects.append
             for)
          #)
     #);
   ParseModuleName:
     (#
        SplitName:
          (# name: ^text; index: @integer
          enter name[]
          do
             mps.ast.thepathhandler.directoryChar
               ->name.FindAll (#  do inx->index #);
             
          exit ((1,index-1)->name.Sub,(index+1,name.Length)->name.Sub)
          #);
        CheckVersion:
          (# String: ^text; result: @boolean
          enter String[]
          do
             (if (string.Length >= 2) then
                 (string.T[1] = 'v') and (string.T[2] >= '0') and
                 (string.T[2] <= '9')->result
              else
                 false->result; 
             if);
             
          exit result
          #);
        theModule: ^Module;
        fileName,tryVersion,rest,path,name,loc: ^text
     enter fileName[]
     do
        (if debugSplitDependency then
            'Parse/ModuleName on :'->puttext;
            filename[]->putline
        if);
        &module[]->theModule[];
        &text[]->theModule.name[];
        &text[]->theModule.version[];
        &text[]->theModule.library[];
        &text[]->theModule.path[];
        filename[]->rest[];
        l:
        (if not rest.empty then
            rest[]->SplitName->(path[],name[]);
            path[]->SplitName->(loc[],tryVersion[]);
            (if (tryVersion[]->CheckVersion) then
                tryVersion[]->theModule.Version[];
                loc[]->SplitName->(theModule.path[],theModule.library[]);
                (if theModule.name.empty then
                    name[]->theModule.name[]
                 else
                    '/'->theModule.name.prepend;
                    name[]->theModule.name.prepend;
                    
                if);
                
             else
                (if theModule.name.empty then
                    name[]->theModule.name[]
                 else
                    '/'->theModule.name.prepend;
                    name[]->theModule.name.prepend;
                    
                if);
                path[]->rest[];
                restart L
            if)
         else
            filename[]->splitName->(theModule.path[],theModule.name[]);
            theModule.path[]->splitName->(theModule.path[],theModule.library[]);
            
        if);
        'Parse/ModuleName got: name:%s, lib:%s, path:%s\n'
          ->putformat
            (# 
            do theModule.name[]->s; theModule.library[]->s; theModule.path[]->s
            #);
        
     exit theModule[]
     #);
   ListGraph:
     (#
        fg: ^mps.ast.fragmentGroup;
        maxList: (#  exit 100 #);
        List: [maxList] ^text;
        End: @integer;
        NodeName: ^text;
        PleaseInsert:
          (# Name,Path: ^text
          enter (Name[],Path[])
          do
             (if (End = List.range) then List.range / 2->List.extend if);
             &text[]->List[End+1->End][];
             (Name[],Path[])->mps.ast.thePathHandler.convertFilePath
               ->List[End][];
             
          #);
        Target: ^text;
        Found: @boolean;
        thisModule: ^Module;
        NumberOfForms: @integer;
        ph: @pathHandler;
        f: @file;
        filename: ^text;
        
     enter NodeName[]
     do
        ph.init;
        0->NumberOfForms;
        nodename[]
          ->THIS(ymerBrowserWindow).mps.dg.scanextent
            (#
               warn: ^text;
               MPSexception:: 
                 (# 
                 do
                    'MPS overflow - '->warn[];
                    T[]->warn.puttext;
                    ' too large)'->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               emptyFragmentException::  (#  do true->continue #);
               DoubleFormException::  (#  do true->continue #);
               transAccessException:: 
                 (# 
                 do
                    'No read access to: '->warn[];
                    FN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               notExistingException:: 
                 (# 
                 do
                    'Not a fragment file: '->warn[];
                    fullFN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               parseException:: 
                 (# 
                 do
                    'Parse errors in: '->warn[];
                    fullFN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               transCreateDirException:: 
                 (# 
                 do
                    'Unable to create directory: '->warn[];
                    FN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               
            do
               current.fullname->ParseModuleName->thisModule[];
               (if not
               (thisModule[]
                  ->MySystem.insert
                    (#
                       conflict:: 
                         (# 
                         do
                            '#### Conflict between: '->errorMsg.puttext;
                            lib[]->errorMsg.putText;
                            ' '->errorMsg.put;
                            v1[]->errorMsg.putText;
                            ' and '->errorMsg.putText;
                            v2[]->errorMsg.putLine;
                            (nodename[],thisModule[])->FindIncludePlace;
                            
                         #)
                    #)) then
                   0->NumberOfForms;
                   current[]->fg[];
                   fg.fragmentList.scan
                     (# 
                     do
                        (if current.type
                         // mps.ast.formType then
                            NumberOfForms+1->NumberOfForms; 
                        if)
                     #);
                   NumberOfForms->thisModule.NumberOfForms;
                   
               if)
            #)
     #);
   FindIncludePlace:
     (#
        scanPropList:
          (# prop: ^propertyList; propfilename: ^text; 
          enter prop[]
          do
             prop.scanProp
               (#
                  doProp:: 
                    (# 
                    do
                       (if ('include'->prop.equal) or ('body'->prop.equal) then
                           scanParameters
                             (#
                                filename: ^text;
                                doString:: 
                                  (# 
                                  do s[]->propfilename[]; INNER scanPropList
                                  #);
                                
                             #);
                           
                       if);
                       
                    #);
                  
               #);
             
          #);
        stripName:
          (# t: ^text; inx: @integer; 
          enter t[]
          do (* Find last / *)
             1->inx;
             L:
             (for i: t.length repeat
               (t.length-i)->inx->t.pos;
               (if t.get = '/' then inx+1->inx; leave L if)
             for);
             
          exit (1,inx)->t.sub
          #);
        fg: ^mps.ast.fragmentGroup;
        NodeName,path,name: ^text;
        thisModule,curModule: ^Module;
        found: @boolean;
        
     enter (NodeName[],thisModule[])
     do
        nodename[]
          ->THIS(ymerBrowserWindow).mps.dg.scanextent
            (#
               warn: ^text;
               MPSexception:: 
                 (# 
                 do
                    'MPS overflow - '->warn[];
                    T[]->warn.puttext;
                    ' too large)'->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               emptyFragmentException::  (#  do true->continue #);
               DoubleFormException::  (#  do true->continue #);
               transAccessException:: 
                 (# 
                 do
                    'No read access to: '->warn[];
                    FN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               notExistingException:: 
                 (# 
                 do
                    'Not a fragment file: '->warn[];
                    fullFN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               parseException:: 
                 (# 
                 do
                    'Parse errors in: '->warn[];
                    fullFN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               transCreateDirException:: 
                 (# 
                 do
                    'Unable to create directory: '->warn[];
                    FN[]->warn.putline;
                    (none ,warn[],'Dependency Graph Error')->alertUser;
                    true->continue
                 #);
               
            do
               current.fullname->stripName->path[];
               current.prop[]
                 ->scanPropList
                   (# 
                   do
                      (if (propfilename.T[1] <> '~') and
                      (propfilename.T[1] <> '/') then
                          path[]->name[]; propfilename[]->name.append; 
                       else
                          propfilename[]->name[]; 
                      if);
                      name[]->parseModuleName->curModule[];
                      false->found;
                      (if curModule.library[]->thisModule.library.equal then
                          (if not found then
                              '   %s depends on:\n'
                                ->errorMsg.putformat
                                  (#  do current.fullname->s #);
                              true->found;
                              
                          if);
                          '      %s\n'
                            ->errorMsg.putFormat (#  do name[]->s;  #);
                          
                      if);
                      
                   #);
               
            #);
        
     #);
   ExpandFileName:
     (# Name: ^text; ExpandedName: ^text
     enter Name[]
     do
        (Name[],mps.ast.thePathHandler.currentDirectory)
          ->mps.ast.thePathHandler.convertFilePath->ExpandedName[];
        
     exit ExpandedName[]
     #);
   MySystem: @System;
   
   
    SplitNameToFirstDir:
     (# name: ^text; index: @integer
     enter name[]
     do
        name.Length->index;
        l:
          mps.ast.thepathhandler.directoryChar
          ->name.FindAll (#  do inx->index; leave l #);
        
     exit ((1,index)->name.Sub,(index+1,name.Length)->name.Sub)
     #);
   
   SplitNameToLast:
     (# name: ^text; index: @integer
     enter name[]
     do
        mps.ast.thepathhandler.directoryChar
          ->name.FindAll (#  do inx->index #);
     exit (index+1,name.Length)->name.Sub
     #);
   
   file:(# name,path:^text #);
   dir:file
     (# directories:@list(# element::dir #); 
        files:@list(# element::file #);
        insertFile:
          (# filename,first,rest:^text;
             targetDir:^dir;
             newFile:^file
          enter filename[]
          do (if debugSplitDependency then 
                 'insertFile on %s\n'->putformat(# do filename[]->s#)
             if);
             filename[]->SplitNameToFirstDir->(first[],rest[]);
             (if debugSplitDependency then 
                 'insertFile got first=%s, rest=%s\n'->putformat(# do first[]->s; rest[]->s #)
             if);
             (if rest.empty then (* in this dir *)
                 (if debugSplitDependency then 
                     'inserted %s into dir:%s\n'->putformat(# do filename[]->s; path[]->s #)
                 if);
                 &file[]->newFile[];
                 path.copy->newFile.path[];
                 filename[]->newFile.path.append;
                 filename[]->splitNameToLast->newFile.name[];
                 newFile[]->files.append
              else
                 directories.find
                 (# predicate::(# do current.name[]->first.equal->value #);
                    notfound::(# adir:^dir;
                              do &dir[]->adir[];
                                 adir[]->directories.append;
                                 first[]->adir.name[];
                                 path.copy->adir.path[];
                                 mps.ast.thepathhandler.directoryChar->adir.path.put;
                                 first[]->adir.path.puttext;
                                 adir[]->targetDir[];
                              #);
                 do current[]->targetdir[];
                 #);
                 rest[]->targetdir.insertfile
             if)
          #);
        dump:
          (# Proj: ^projects.project; 
             newGroup: ^browser.projects.group;
             newProj: ^browser.projects.project;
          enter proj[]
          do files.scan
             (# 
             do &browser.projects.group[]->newGroup[];
                current.path[]->newGroup.location.puttext;                
                (if debugSplitDependency then
                    'inserting file:%s in dir %s\n'->putformat(# do current.path[]->s; proj.location[]->s #)
                if);
                current.name[]->newGroup.name[];
                newGroup[]->proj.groups.append
             #);
             directories.scan
             (# 
             do true->proj.hasSubProjects;
                &browser.projects.project[]->newProj[];
                current.path[]->newProj.location.puttext;
                current.name[]->newProj.name[];
                newProj[]->proj.subProjects.append;
                (if debugSplitDependency then
                    'inserting dir:%s in %s\n'->putformat(# do current.path[]->s; proj.location[]->s #)
                if);
                true->newProj.isDirectory;
                proj[]->newProj.superProject[];
                newProj[]->current.dump;
             #);
          #)
       #);
   MyFiles:@dir
     (# init:
          (# adir:@dir;
          do (*'root'->adir.name[];
             '/'->adir.path[];
              adir[]->directories.append;*)
             ''->name[];
             ''->path[];
          #);
        CreateProjects:
          (# mainProj: ^projects.project; 
             firstDir:^dir;
          enter mainProj[]
          do this(dir)[]->firstDir[];
             l:
               (if ((firstDir.files.size>0) or (firstDir.directories.size>1)) then
                   (if debugSplitDependency then
                       'calling dump'->putline
                   if);
                   mainProj[]->firstDir.dump;
                else
                   (firstDir.directories.head).elm[]->firstDir[];
                   restart l
               if)
          #);
     #);
   
#)  

--dependencyInit:dopart--
do dependencyPrivate.myfiles.init;

-- dependencyRegister: DoPart --
do
   fgName[]->dependencyPrivate.myfiles.insertFile;
   
   (*fgName[]->dependencyPrivate.ParseModuleName
     ->dependencyPrivate.MySystem.insert
       (#
          conflict:: 
            (# 
            do
               '#### Conflict between: '->dependencyPrivate.errorMsg.puttext;
               lib[]->dependencyPrivate.errorMsg.putText;
               ' '->dependencyPrivate.errorMsg.put;
               v1[]->dependencyPrivate.errorMsg.putText;
               ' and '->dependencyPrivate.errorMsg.putText;
               v2[]->dependencyPrivate.errorMsg.putLine;
               (fgName[],theModule[])->dependencyPrivate.FindIncludePlace;
               
            #)
       #);
    *)

-- dependencyCreateSubprojects: Descriptor --
(# 
do
   (* selectedProj[]->dependencyPrivate.mySystem.dump;
   (if not dependencyPrivate.errorMsg.empty then
       (none ,dependencyPrivate.errorMsg[],'Version conflicts')->alertUser
    if)
    *)
   
   selectedProj[]->dependencyPrivate.myfiles.CreateProjects;
#)  

