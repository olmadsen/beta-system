ORIGIN '../ymer';
INCLUDE '~beta/mps/v5.1/astlevel';
INCLUDE '~beta/betaast/v5.1/index';
INCLUDE '~beta/dependency/v1.2/dependency';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
--- dependencyPrivate: descriptor ---
(# errorMsg: @text;
   
   Module: 
     (# Path, Library, Version, Name: ^text;
        NumberOfForms: @integer;
        
        location:
          (# loc: ^text
          do path.copy->loc[];
             mps.ast.thepathhandler.directoryChar->loc.put;
             Library[]->loc.putText;
             mps.ast.thepathhandler.directoryChar->loc.put;
             (if isLibrary then
                 Version[]->loc.putText;
                 mps.ast.thepathhandler.directoryChar->loc.put;
             if)
          exit loc[]
          #);
        
        isLibrary: (# exit (version[]<>NONE) and (Version.Length <> 0) #);
        
        Dump: 
          (# newGroup: ^browser.projects.group;
             selectedProj: ^browser.projects.project;
          enter selectedProj[]
          do &browser.projects.group[]->newGroup[];
             Path->newGroup.location;
             mps.ast.thepathhandler.directoryChar->newGroup.location.put;
             Library[]->newGroup.location.putText;
             mps.ast.thepathhandler.directoryChar->newGroup.location.put;
             (if isLibrary then
                 Version[]->newGroup.location.putText;
                 mps.ast.thepathhandler.directoryChar->newGroup.location.put;
             if);
             Name[]->newGroup.location.puttext;
             Name[]->newGroup.name[];
          exit newGroup[]
          #);
     #);
   
   Library: 
     (# Name, Version, Path: ^text;
        
        ModList: [100]^Module;
        ModEnd: @integer;
        
        insert: 
          (# theModule: ^Module; isPresent: @boolean;
          enter theModule[]
          do false->isPresent;
             loop: 
               (for i: ModEnd repeat
                    (if (theModule.name[]->ModList[i].name.equal) then
                    true->isPresent; leave loop if) for);
             (if not isPresent then
                 (if (ModEnd=ModList.range) then
                     ModList.range/2->ModList.extend
                 if);
                 theModule[]->ModList[ModEnd+1->ModEnd][];
             if)
          exit isPresent
          #);
        
        Dump: 
          (# newProj: ^browser.projects.project;
             selectedProj: ^browser.projects.project;
             splitIntoSubprojects:
               (# SplitName:
                    (# name: ^text; index: @integer
                    enter name[]
                    do name.Length->index;
                       l: mps.ast.thepathhandler.directoryChar
                         ->name.FindAll(# do inx->index; leave l #);
                    exit ((1,index)->name.Sub, (index+1,name.Length)->name.Sub)
                    #);
                  projectList: list
                    (# theCellType::
                         (# #) (* to avoid a beta(5.1) compiler error *);
                       element::
                         (# name, location: ^text;
                            subs: @projectList
                         #)
                    #);
                  projList: @projectList;
                  name, rest: ^text;
                  pos: ^projectList.theCellType;
                  new: ^projectList.element;
                  currentList: ^projectList;
                  createProjects:
                    (# currentList: ^projectList;
                       newProj, newProj2: ^browser.projects.project;
                       newGroup: ^browser.projects.group;
                    enter (currentList[], newProj[])
                    do currentList.scan
                       (#
                       do (if current.subs.empty then
                              &browser.projects.group[]->newGroup[];
                              current.name[]->newGroup.name[];
                              current.location->newGroup.location;
                              newGroup[]->newProj.groups.append;
                           else
                              true->newProj.hasSubprojects;
                              &browser.projects.project[]->newProj2[];
                              current.name[]->newProj2.name[];
                              current.location->newProj2.location;
                              newProj2[]->newProj.subprojects.append;
                              (current.subs[],newProj2[])->createProjects;
                          if)
                       #)
                    #);
                  newProj: ^browser.projects.project;
                  loc: ^text;
               enter newProj[]
               do projList.init;
                  (for i: ModEnd repeat
                       projList[]->currentList[];
                       ModList[i].location->loc[];
                       ModList[i].name[]->rest[];
                       l: (if not rest.empty then
                              rest[]->splitname->(name[], rest[]);
                              name[]->loc.puttext;
                              currentList.locate
                              (# predicate::
                                   (# do current.elm.name[]->name.equal->value #);
                                 notFound::
                                   (#
                                   do 
                                      &projList.element[]->new[];
                                      new[]->currentList.append->pos[];
                                      name[]->new.name[];
                                      loc.copy->new.location[];
                                  #)
                              do position[]->pos[];
                              #);
                              pos.elm.subs[]->currentList[];
                              restart l;
                          if)
                  for);
                  (projList[],newProj[])->createProjects
               #)
          enter selectedProj[]
          do &browser.projects.project[]->newProj[];
             Path->newProj.location;
             mps.ast.thepathhandler.directoryChar->newProj.location.put;
             Name[]->newProj.location.putText;
             mps.ast.thepathhandler.directoryChar->newProj.location.put;
             (if (version[]<>NONE) and (version.length<>0) then
                 Version[]->newProj.location.putText;
                 mps.ast.thepathhandler.directoryChar->newProj.location.put;
             if);
             Name[]->newProj.name[]; '/'->newProj.name.put;
             newProj[]->splitIntoSubprojects
          exit newProj[]
          #)
     #);

   System: 
     (# maxLib: (# exit 100 #);
        LibList: [maxLib]^Library;
        LibEnd: @integer;

        maxProg: (# exit 100 #);
        ProgList: [maxProg]^Library;
        ProgEnd: @integer;
       
        Insert: 
          (#
             conflict:<
               (# lib,v1,v2: ^text;
               enter (lib[],v1[],v2[])
               do 
                  INNER 
               #);
             
             theModule: ^Module; isPresent, libFound: @boolean;
          enter theModule[]
          do false->isPresent->libFound;
             (if theModule.isLibrary then
                 (* Check the LibList *)
                 loop: 
                   (for i: LibEnd repeat
                        (if (theModule.Library[]->LibList[i].name.equal) then
                            true->libFound;
                            (if not (LibList[i].version[]->theModule.version.equal) or not (LibList[i].path[]->theModule.path.equal) then
                                (theModule.Library[],
                                LibList[i].version[],
                                theModule.version[])->conflict;
                            if);
                            theModule[]->LibList[i].insert->isPresent;
                            leave loop
                        if)
                   for);
                 (if not libFound then
                     (if (LibEnd=LibList.range) then 
                         libList.range/2->LibList.extend
                     if);
                     &Library[]->LibList[LibEnd+1->LibEnd][];
                     theModule.Library.copy->LibList[LibEnd].name[];
                     theModule.version[]->LibList[LibEnd].version[];
                     theModule.path[]->LibList[LibEnd].path[];
                     theModule[]->LibList[LibEnd].insert
                 if);
              else
                 (* Check the ProgList *)
                 loop: 
                   (for i: ProgEnd repeat
                        (if (theModule.Library[]->ProgList[i].name.equal) then
                            true->isPresent;
                            theModule[]->ProgList[i].insert;
                            leave loop
                        if)
                   for);
                 (if not isPresent then
                     (if (ProgEnd=ProgList.range) then 
                         ProgList.range/2->ProgList.extend
                     if);
                     &Library[]->ProgList[ProgEnd+1->ProgEnd][];
                     theModule.Library.copy->ProgList[ProgEnd].name[];
                     theModule.version[]->ProgList[ProgEnd].version[];
                     theModule.path[]->ProgList[ProgEnd].path[];
                     theModule[]->ProgList[ProgEnd].insert
                 if);
             if)
          exit isPresent
          #);

        Dump: 
          (# selectedProj: ^browser.projects.project;
          enter selectedProj[]
          do true->selectedProj.hasSubprojects;
             (for i: ProgEnd repeat
                  selectedProj[]->ProgList[i].Dump
                    ->selectedProj.subProjects.append
             for);
             (for i: LibEnd repeat 
                  selectedProj[]->LibList[i].Dump
                    ->selectedProj.subProjects.append
             for)
          #)
     #);

   ParseModuleName: 
     (# SplitName: 
          (# name: ^text; index: @integer
          enter name[]
          do mps.ast.thepathhandler.directoryChar
               ->name.FindAll(# do inx->index #);
          exit ((1,index-1)->name.Sub, (index+1,name.Length)->name.Sub)
          #);
        
        CheckVersion: 
          (# String: ^text; result: @boolean
          enter String[]
          do (if (string.Length >= 2) then
                 (string.T[1] = 'v') AND
                 (string.T[2] >= '0') AND
                 (string.T[2] <= '9')->result
              else
                 false->result;
             if);
          exit result
          #);

        theModule: ^Module;
        fileName, tryVersion, rest, path, name, loc: ^text
          
     enter fileName[]
     do &module[]->themodule[];
        &text[]->theModule.name[];
        &text[]->theModule.version[];
        &text[]->theModule.library[];
        &text[]->theModule.path[];
        filename[]->rest[];
        l: (if not rest.empty then
               rest[]->SplitName->(path[], name[]);
               path[]->SplitName->(loc[], tryVersion[]);
               (if (tryVersion[]->CheckVersion) then
                   tryVersion[]->theModule.Version[];
                   loc[]->SplitName->(theModule.path[], theModule.library[]);
                   (if theModule.name.empty then
                       name[]->theModule.name[]
                    else
                       '/'->theModule.name.prepend;
                       name[]->theModule.name.prepend;
                   if);
                else
                   (if theModule.name.empty then
                       name[]->theModule.name[]
                    else
                       '/'->theModule.name.prepend;
                       name[]->theModule.name.prepend;
                   if);
                   path[]->rest[];
                   restart L
               if)
            else
               filename[]->splitName->(theModule.path[], theModule.name[]);
               theModule.path[]->splitName
                 ->(theModule.path[], theModule.library[]);
           if);
     exit theModule[]
     #);

   ListGraph: 
     (# fg: ^mps.ast.fragmentGroup;
        maxList: (# exit 100 #);
        List: [maxList]^text; End: @integer;
        NodeName: ^text;

        PleaseInsert: 
          (# Name, Path: ^text
          enter (Name[], Path[])
          do (if (End=List.range) then 
                 List.range/2->List.extend
             if);
             &text[]->List[End+1->End][]; 
             (Name[],Path[])->mps.ast.thePathHandler.convertFilePath->List[End][];
          #);

        Target: ^text;
        Found: @boolean;
        thisModule: ^Module;
        NumberOfForms: @integer;
        ph: @pathHandler; f: @file; filename: ^text;
     enter NodeName[]
     do ph.init;
        
        0->NumberOfForms;
        
        nodename[]->mps.dg.scanextent
        (# warn: ^text;
           MPSexception::
             (#
             do 'MPS overflow - '->warn[];
                T[]->warn.puttext; ' too large)'->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           DoubleFormException::
             (# do true->continue #);
           transAccessException::
             (#
             do 'No read access to: '->warn[]; FN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue 
             #);
           notExistingException::
             (#
             do 'Not a fragment file: '->warn[]; fullFN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           parseException::
             (#
             do 'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           transCreateDirException::
             (#
             do 'Unable to create directory: '->warn[]; FN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
        do
           current.fullname->ParseModuleName->thisModule[];
           (if not (thisModule[]->MySystem.insert
               (# conflict::
                    (# do 
                       '#### Conflict between: '->errorMsg.puttext;
                       lib[]->errorMsg.putText;
                       ' '->errorMsg.put; v1[]->errorMsg.putText;
                       ' and '->errorMsg.putText; v2[]->errorMsg.putLine;
                       (nodename[],thisModule[])->FindIncludePlace;
                    #)
               #)
               ) then
               0->NumberOfForms;
               current[]->fg[];
               fg.fragmentList.scan
               (# do (if current.type
                      // mps.ast.formType  then
                         NumberOfForms + 1->NumberOfForms; 
               if) #);
               NumberOfForms->thisModule.NumberOfForms;
           if)
        #)
     #);
   
   
   FindIncludePlace:
     (# 
        scanPropList:
          (# prop: ^propertyList;
             propfilename: ^text;
          enter prop[]
          do
             prop.scanProp
             (# doProp::
                  (# 
                  do 
                     (if ('include'->prop.equal) or
                         ('body'->prop.equal) then
                         scanParameters
                         (# filename:^text;
                            doString::(# do s[]->propfilename[];
                                         INNER scanPropList #);
                            
                          #);
                     if);
                  #);
             #);
          #);
        
        stripName:
          (# t: ^text;
             inx: @integer;
          enter t[]
          do
             (* Find last / *)
             1->inx;
             L: (for i: t.length repeat
                     (t.length-i)->inx->t.pos;
                     (if t.get='/' then inx+1->inx; leave  L if)
                for);
          exit (1,inx)->t.sub
          #);
        
        fg: ^mps.ast.fragmentGroup;
        NodeName,path,name: ^text;
        thisModule,curModule: ^Module;
        found: @boolean;
     enter (NodeName[],thisModule[])
     do nodename[]->mps.dg.scanextent
        (# warn: ^text;
           MPSexception::
             (#
             do 'MPS overflow - '->warn[];
                T[]->warn.puttext; ' too large)'->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           DoubleFormException::
             (# do true->continue #);
           transAccessException::
             (#
             do 'No read access to: '->warn[]; FN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue 
             #);
           notExistingException::
             (#
             do 'Not a fragment file: '->warn[]; fullFN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           parseException::
             (#
             do 'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
           transCreateDirException::
             (#
             do 'Unable to create directory: '->warn[]; FN[]->warn.putline;
                (NONE,warn[],'Dependency Graph Error')->alertUser;
                true->continue
             #);
        do
           current.fullname->stripName->path[];
           current.prop[]->scanPropList
           (# 
           do (if (propfilename.T[1]<>'~') and
                  (propfilename.T[1]<>'/') then
                  path[]->name[];
                  propfilename[]->name.append;
               else
                  propfilename[]->name[];
              if);
              name[]->parseModuleName->curModule[];
              false->found;
              (if curModule.library[]->thisModule.library.equal then
                  (if not found then
                      '   %s depends on:\n'->errorMsg.putformat
                      (# do current.fullname->s#);
                      true->found;
                  if);
                  '      %s\n'->errorMsg.putFormat(# do name[]->s; #);     
              if);
           #);
        #);
     #);
           
             
   ExpandFileName: 
     (# 
        Name: ^text; ExpandedName: ^text
     enter Name[]
     do (Name[], mps.ast.thePathHandler.currentDirectory)
          -> mps.ast.thePathHandler.convertFilePath->ExpandedName[];
    exit ExpandedName[]
     #);
   
   MySystem: @System;
#)

--- dependencyRegister: dopart ---
do fgName[]
     ->dependencyPrivate.ParseModuleName
     ->dependencyPrivate.MySystem.insert
   (# conflict::
        (# do 
           '#### Conflict between: '->dependencyPrivate.errorMsg.puttext;
           lib[]->dependencyPrivate.errorMsg.putText;
           ' '->dependencyPrivate.errorMsg.put;
           v1[]->dependencyPrivate.errorMsg.putText;
           ' and '->dependencyPrivate.errorMsg.putText;
           v2[]->dependencyPrivate.errorMsg.putLine;
           (fgName[],theModule[])->dependencyPrivate.FindIncludePlace;
        #)
   #);
   
--- dependencyCreateSubprojects: descriptor ---
(#
do selectedProj[]->dependencyPrivate.mySystem.dump;
   (if not dependencyPrivate.errorMsg.empty then
       (NONE, dependencyPrivate.errorMsg[], 'Version conflicts')
         ->alertUser
   if)
#)


