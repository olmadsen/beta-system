ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '~beta/sysutils/v1.4/pathhandler';
INCLUDE '~beta/process/v1.4/osinterface';

INCLUDE '~beta/guienv/v1.3.1/utils/dynpane';

INCLUDE '~beta/editor/v5.0/fragmentscanner';

INCLUDE 'settings';
INCLUDE 'fileEditor';
INCLUDE 'parseEditor';
INCLUDE 'sourcebrowserbody';

INCLUDE 'ymerFileUtils';

--- browserFileEdit: dopart ---
do (# fe: @fileEditor
        (# open:: (# do (600,800)->size #) #);
   do fe.open;
      makefile[]->fe.loadFile;
   #)

--- ymerMPSparseerrors: dopart ---
do true->continue;
   (# pe: @ymerBrowser.browser.parseEditor
        (# open::
             (#
             do (600,800)->size;
                groupName[]->loadFiles
             #)
        #);
   do pe.open
   #)   
   
--- ymerMPSbetaparserinit: descriptor ---
(# bobsFile: @file;
   grammarWithPath, help: ^text;
do (if not BETACFL.parser.haveBeenInitialized then
       '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
       (if BETACFL.grammarAst[]
        // none then
           'No grammarAst for '->screen.putText;
           grammarWithPath[]->screen.putLine;
        else
           '-parser'->help[];
           mps.ast.parserFileExtension->help.append;
           help[]->grammarWithPath.copyAppend->mps.ast.expandToFullPath 
             ->bobsFile.name;
           (if bobsFile.entry.exists then
               bobsFile.name->BETACFL.parser.initialize;
               ('objectdescriptor','descriptor')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               ('attributedecl','attributes')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               
            else
               'No parser available: '->screen.putText;
               bobsFile.name->screen.putLine;
               
           if);
       if);
   if)
#)

--- ymerAddProject: dopart ---
do &browser.projects.project[]->newProj[];
   name.copy->newProj.name[];
   location[]->MPS.ast.expandToFullPath->newProj.location.puttext;
   newProj[]->browser.projects.setupProject;
   newProj[]->browser.projects.theProjects.append;
   browser.projectsChanged;
   newProj[]->browser.setProject;
   
--- projectInfoLib: attributes ---
setupProject:
  (# f: @file; ext: ^text; t: ^text;
     proj, root: ^project
  enter proj[]
  do proj.location[]->f.name;
     f.entry.path.name.suffix->ext[];
     (if true
      // mps.AST.astFileExtension->ext.equalNCS then
         (proj.location.length-(mps.AST.astFileExtension).length+1
         ,proj.location.length)
           ->proj.location.delete;
      // '.bet'->ext.equalNCS then
         (proj.location.length-3,proj.location.length)
           ->proj.location.delete;
     if);
     (if (proj.location.length
           ->proj.location.inxGet)='/' then
         (proj.location.length,proj.location.length)
           ->proj.location.delete;
     if);
     (proj.location[],ph.currentDirectory)
       ->ph.convertfilepath->f.name;
     (if proj.name[]=NONE then
         f.entry.path.name->proj.name[]
     if);
     (if true
      // f.entry.exists and
         f.entry.readable and
         f.entry.isDirectory then
         true->proj.isDirectory;
         (if (proj.location.length
               ->proj.location.inxGet)<>'/' then
             '/'->proj.location.append
         if);
         (if (proj.name.length>0) and
             ((proj.name.length->proj.name.inxGet)<>'/') then
             '/'->proj.name.append;
         if);
      else
         f.entry.path.name.suffix->ext[];
         (if true
          // f.entry.exists and
             f.entry.readable and
             (mps.AST.astfileExtension->ext.equal)
          // f.entry.exists and
             f.entry.readable and
             ('.bet'->ext.equal) 
          // (mps.AST.astfileExtension->(f.name).append
               ->fileExists) and
             (mps.AST.astfileExtension->(f.name).append
               ->fileReadable)
          // ('.bet'->(f.name).append->fileExists) and
             ('.bet'->(f.name).append->fileReadable) then
             (if (proj.name.length->proj.name.inxGet) <> '*'
                 then
                 '*'->proj.name.append;
             if);
             
             true->proj.isRoot;
             
             proj[]->root[];
             
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isDomain;
             '[domain]'->proj.name[];
             root[]->proj.superProject[];
             proj[]->root.subprojects.append;
             
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isExtent;
             '[extent]'->proj.name[];
             root[]->proj.superProject[];
             proj[]->root.subprojects.append;
          // f.entry.exists and
             f.entry.readable and
             ('.pjt'->ext.equal) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             (f.name,proj[])
               ->theProjects.parseProjectFile;
          // ('.pjt'->(f.name).append->fileExists) and
             ('.pjt'->(f.name).append->fileReadable) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             ('.pjt'->(f.name).append,proj[])
               ->theProjects.parseProjectFile;
          else
             (* skip for ECOOP: f.name->fileAvailable; *)
         if)
     if)
  #);

--- scanGroupsImpl: dopart ---
do ''->infoView.msg;
   (if true
    // isRoot then
       (if groups.size=0 then
           (* this is the first time we visit this root *)
           &browser.projects.group[]->newGroup[];
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName
             ->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else 
           (* we have visited this root previously *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isExtent then
       (if groups.size=0 then
           (* the extent haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanExtent
           (#
           do &browser.projects.group[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the extent have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDomain then
       (if groups.size=0 then
           (* the domain haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanDomain
           (#
           do &browser.projects.group[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the domain have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDirectory then
       (if groups.size=0 then
           (* the directory haven't previously been scanned *)
           (# d: @directory; count: @integer;
           do this(Project).groups.clear;
              (if location.empty then
                  ph.currentDirectory->location.puttext;
              if);
              (location[],ph.currentDirectory)
                ->ph.convertfilepath->d.name;
              d.scanEntries
              (#
              do select
                 (# whenFile::
                      (# f: ^file; ext: ^Text;
                      do &browser.projects.group[]->newGroup[];
                         thefile->f[];
                         f.entry.path.name.suffix
                           ->ext[];
                         f.entry.path.name
                           ->newGroup.location.puttext;
                         (if true
                          // f.entry.exists and
                             f.entry.readable and
                             (mps.AST.astfileExtension
                               ->ext.equal)
                          // f.entry.exists and
                             f.entry.readable and
                             ('.bet'->ext.equal) then
                             (newGroup.location.length-3,newGroup.location.length)
                               ->newGroup.location.delete;
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name.prefix
                                   ->newGroup.name[];
                                 count+1->count;
                                 newGroup[]->groups.append;
                                 newGroup[]->thescan.foreach
                             if);
                          // f.entry.exists and
                             f.entry.readable then
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name
                                   ->newGroup.name[];
                                 (* activate this code to allow _all_
                                  * files to be shown
                                  *)
                                 (* count+1->count;
                                  * newGroup[]->groups.append;
                                  * newGroup[]->thescan.foreach
                                  *)
                             if);
                          else
                             (* skip for ECOOP: f.name->fileAvailable *)
                         if);
                      #)
                 #)
              #);
              (if count=0 then
                  'no fragments in project'
                    ->infoView.msg;
              if)
           #)
        else
           (* the directory have previously been scanned *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // groups.size<>0 then
       groups.scan
       (#
       do current[]->thescan.foreach
       #)
    else
       (if not unfolded then 
           'open project to find subprojects'
             ->infoView.msg;
        else 
           'open subproject to find fragments'
             ->infoView.msg;
       if)
   if)
   
--- browserLib: attributes ---

setupDotDot:
  (# proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
     d: @directory;
     location: ^text; level: @integer;
     superProject, superSuperProject: ^browser.projects.project;
     createParentProject:
       (# newProj: ^browser.projects.project
       do &browser.projects.project[]->newProj[];
          location->newProj.location;
          newProj[]->browser.projects.setupProject;
          (newProj[],superProject[]->browser.projects.theProjects.at)
            ->browser.projects.theProjects.insertBefore;
          superProject.level->newProj.level;
          (for newProj.level repeat '  '->newProj.name.prepend for);
          superProject.level+1->superProject.level;
          '  '->superProject.name.prepend;
          l: (superProject[]
            ->browser.projects.theProjects.at).succ[]
            ->browser.projects.theProjects.iterateFrom
          (# 
          do (if current.elm.level>=superProject.level then
                 current.elm.level+1->current.elm.level;
                 '  '->current.elm.name.prepend;
              else leave l
             if);
          #);
          superProject.subprojects.clear;
          true->newProj.unfolded;
          newProj[]->foldSubprojects;
          newProj[]->unfoldSubprojects;
          browser.projectsChanged;
          newProj[]->browser.setProject;
       #);
  enter proj[]
  do (* we now have to create a new project to contain the
      * parent directory of currentDirectory
      *)
     ((1,proj.location.length-1)->proj.location.sub,ph.currentDirectory)
       ->ph.convertfilepath->location[]; '/'->location.put;
     proj.superProject[]->superProject[];
     (if superProject[]<>NONE then
         superProject.level->level;
         superProject.superProject[]->superSuperProject[];
         (if superSuperProject[]<>NONE then
             (if superSuperProject.isDirectory then
                 (* this is the .. directory - select it *)
                 superSuperProject[]->setProject;
              else
                 (* try to locate the '..' project in
                  * superSuperProject
                  *)
                 l: (#
                    do superSuperProject.subprojects.iterate
                       (#
                       do 
                          (if current.elm.location[]
                                ->location.equal then
                              current.elm[]->setProject; leave l
                          if);
                       #);
                       (* not found - create it *)
                       createParentProject;
                    #);
             if)
          else (* OK, we are 'on the top'.  Try those *)
             l: (#
                do browser.projects.theProjects.iterate
                   (# where:: (# do (current.elm.level=level)->value #);
                   do 
                      (if current.elm.location[]->location.equal then
                          current.elm[]->setProject; leave l
                      if);
                   #);
                   (* not found - create it *)
                   createParentProject;
                #);
         if);
     if);
  #);

unfoldSubprojects:
  (# proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
  enter proj[]
  do ''->infoView.msg;
     (proj[]->projects.theProjects.at).succ[]->projPos[];
     (if true
      // proj.hasSubprojects 
      // proj.isRoot then
         proj.subprojects.scan
         (#
         do proj.level+1->current.level;
            (for current.level repeat
                 '  '->current.name.prepend
            for);
            (current[],projPos[])
              ->projects.theProjects.insertBefore;
         #);
         proj.subprojects.scan
         (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
      // proj.isDirectory then
         (if proj.subprojects.size=0 then
             (* the directory haven't previously been unfolded *)
             (# d: @directory; f: @file; level: @integer;
             do (proj.location[],ph.currentDirectory)
                  ->ph.convertfilepath->d.name;
                d.scanEntries
                (# 
                do select
                   (# whenDir::
                        (# d: ^directory;
                           name: ^text; location: ^text;
                           newProj: ^browser.projects.project;
                           create, dotdot: @boolean;
                        do thedir->d[];
                           d.entry.path.name->name[];
                           (if true
                            // '.'->name.equalNCS
                            // 'sun4s'->name.equalNCS
                            // 'sun4'->name.equalNCS
                            // 'sun3'->name.equalNCS
                            // 'snake'->name.equalNCS
                            // 'sgi'->name.equalNCS
                            // 'nti'->name.equalNCS
                            // 'linux'->name.equalNCS
                            // 'hpux9mc'->name.equalNCS
                            // 'hpux9pa'->name.equalNCS
                            // 'hpux8'->name.equalNCS
                            // 'b2c'->name.equalNCS then
                               false->create;
                            // '..'->name.equalNCS then
                               true->create; true->dotdot;
                            else
                               true->create; false->dotdot;
                           if);
                           (if create then
                               &browser.projects.project[]
                                 ->newProj[];
                               true->newProj.isDirectory;
                               (d.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->location[];
                               location[]->f.name;
                               &text[]->newProj.name[];
                               proj.level+1->newProj.level;
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               '/'->newProj.name.append;
                               (if dotdot then
                                   true->newProj.isDotDotDirectory;
                                   (f.entry.path.head)->f.name;
                                   (f.entry.path.head)->location[]
                               if);
                               location[]->newProj.location.puttext;
                               (if (newProj.location.length
                                     ->newProj.location.inxGet)<>'/'
                                   then
                                   '/'->newProj.location.append
                               if);
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[], projPos[])
                                     ->projects.theProjects.insertBefore;
                                   proj[]->newProj.superProject[];
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
                               if)
                           if)
                        #);
                      whenFile::
                        (# f: ^file; name: ^text;
                           newProj: ^browser.projects.project;
                        do thefile->f[];
                           f.entry.path.name->name[];
                           (if true
                            // '.pjt'->(f.entry.path.name.suffix).equal then
                               &browser.projects.project[]
                                 ->newProj[];
                               (f.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               (newProj.location.length-3,newProj.location.length)
                                 ->newProj.location.delete;
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               (newProj.name.length-3,newProj.name.length)
                                 ->newProj.name.delete;
                               '+'->newProj.name.append;
                               true->newProj.hasSubprojects;
                               (f.name,newProj[])
                                 ->proj.subprojects.parseProjectFile;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[], projPos[])
                                     ->projects.theProjects.insertBefore;
                                   proj[]->newProj.superProject[];
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
                               if)
                           if)
                        #)
             #)#)#)
          else
             (* the directory have previously been unfolded *)
             proj.subprojects.scan
             (#
             do (for current.level repeat
                     '  '->current.name.prepend
                for);
                (current[],projPos[])
                  ->projects.theProjects.insertBefore;
             #);
             proj.subprojects.scan
             (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
         if)
     if)
  #);
foldSubprojects:
  (# proj: ^browser.projects.project;
     level: @integer
  enter proj[]
  do ''->infoView.msg;
     proj.level->level;
     loop:
       (proj[]
       ->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
     (#
     do (if current.elm.level>level then
            (1,current.elm.level*2)->current.elm.name.delete;
            current[]->projects.theProjects.delete
         else leave loop
        if)
     #);
  #);
projectByIndex:
  (# inx: @integer;
     foundProj: ^browser.projects.project;
  enter inx
  do find: projects.theProjects.scan
       (#
       do inx-1->inx;
          (if inx=0 then
              current[]->foundProj[];
              leave find
       if)#)
  exit foundProj[]
  #);
  
--- onProjectListOpen: dopart --- 
do &theprojectlist.action
   (# eventtype:: theprojectlist.theeventhandler.mousedown;
      i: @integer;
      selectedProj: ^browser.projects.project;
   do (if (theprojectlist.selection.first->i)<>0 then
          (if theEvent.doubleClick then
              i->projectByIndex->selectedProj[];
              (if true
               // selectedProj.isDotDotDirectory then
                  selectedProj[]->setupDotDot;
               // selectedProj.unfolded then
                  false->selectedProj.unfolded;
                  selectedProj[]->foldSubprojects;
                  projectsChanged;
                  selectedProj[]->setProject;
               else
                  true->selectedProj.unfolded;
                  selectedProj[]->unfoldSubprojects;
                  projectsChanged;
                  selectedProj[]->setProject;
              if);
          if)
      if)
   #)[]->theprojectlist.appendAction;

--- onGroupListOpen: dopart --- 
do &thegrouplist.action
   (# eventtype:: thegrouplist.theeventhandler.mousedown;
      selectedGroup: ^projects.group;
      root, newProj: ^browser.projects.project;
   do (if (thegrouplist.selection.first)<>0 then
          (if theEvent.doubleClick then
              (if theEvent.shiftKey then
                  (* do what's needed to make THIS into a root *)
                  thegrouplist.selection.first
                    ->groups.getGroupByIndex->selectedGroup[];
                  &browser.projects.project[]->newProj[];
                  selectedGroup.location->newProj.location;
                  (if newProj.name[]=NONE then
                      selectedGroup.name.copy->newProj.name[]
                  if);
                  (if (newProj.name.length->newProj.name.inxGet) <> '*' then
                      '*'->newProj.name.append;
                  if);
                  true->newProj.isRoot;
                  
                  newProj[]->projects.theProjects.append;
                  newProj[]->root[];
                  
                  &browser.projects.project[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isDomain;
                  '[domain]'->newProj.name[];
                  root[]->newProj.superProject[];
                  newProj[]->root.subprojects.append;
                  
                  &browser.projects.project[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isExtent;
                  '[extent]'->newProj.name[];
                  root[]->newProj.superProject[];
                  newProj[]->root.subprojects.append;
                  
                  projectsChanged;
                  root[]->setProject;
              if)
          if)
      if)
   #)[]->thegrouplist.appendAction;

--- onFragmentgroupViewOpen: dopart --- 
do &thefragmentgroupview.action
   (# eventtype:: thefragmentgroupview.theeventhandler.keydown;
      ch: @char; inx, i: @integer; searching: @boolean;
      g: ^projects.group;
      fg: ^astInterface.fragmentGroup;
      lastff: ^astInterface.fragmentForm;
      fgs: @fragmentGroupScanner;
      prefix, msg: @text
   do theevent.ch->ch; 0->i;
      (if ch
       // ascii.ack (* ^f *) then
          currentGroup[]->g[];
          (if g[]<>none then
              g.getfg->fg[]; prefix.clear; true->searching;
              1->inx;
          if);
       // ascii.bel (* ^g *) then
          inx+1->inx
       // ascii.nl
       // ascii.cr then
          false->searching;
          ''->infoView.msg;
       else (if searching and not (ch->ascii.isWhiteSpace) then
                ch->prefix.put;
            if);
      if);
      (if searching then
          (if inx=0 then
              'Wrapped search for "'->msg;
           else
              'Search for "'->msg; 
          if);
          prefix[]->msg.puttext; '"'->msg.put;
          msg[]->infoView.msg;
          (if g[]<>NONE then
              l:(if fg[]<>NONE then
                    fg.fragmentList.scan
                    (# ff: ^mps.AST.fragmentForm; n: ^text
                    do (if current.type
                        // mps.AST.formType then
                           (if (i+1->i)>=inx then
                               (1,prefix.length)->current.name.sub->n[];
                               (if prefix[]->n.equalNCS then
                                   current.open->ff[]; i->inx;
                                   (if ff[]<>lastff[] then
                                       (browser.currentProject[]
                                       ,browser.currentGroup[]
                                       ,ff[]->lastff[])
                                         ->browser.setFragmentForm;
                                   if);
                                   leave l;
                               if)
                           if)
                       if)
                    #);
                    (* wrap search from the beginning *)
                    -1->inx;
                    'Failing search for "'->msg; prefix[]->msg.puttext; '"'->msg.put;
                    msg[]->infoView.msg;
                if)
          if)
      if);
   #)[]->thefragmentgroupview.appendAction;
      
--- onCurrentProjectChange: dopart ---
do (if newProject[] <> none then
       newProject.location[]->locationView.msg;
   if);
   
--- onCurrentGroupChange: dopart ---
do (if newGroup[] <> none then
       newGroup.location[]->locationView.msg;
   if)
   
--- onCurrentFormChange: dopart ---
do (if newForm[]<>NONE then
       ymerPrivate.history.find
       (# predicate::
            (#
            do (if none
                // browser.currentProject[] then
                // browser.currentGroup[] then
                // current.theProject.location[] then
                // current.theGroup.location[] then
               if);
               ((current.theProject.location[]->browser.currentProject.location.equalNCS)
               and (current.theGroup.location[]->browser.currentGroup.location.equalNCS)
               and (current.theForm[]=newForm[]))->value
            #);
          notFound::
            (# newHist: ^ymerPrivate.history.element
            do &ymerPrivate.history.element[]->newHist[];
               browser.currentProject[]
                 ->newHist.theProject[];
               browser.currentGroup[]
                 ->newHist.theGroup[];
               newForm[]
                 ->newHist.theForm[];
               browser.getFragmentFormEditor
                 ->newHist.theSif[];
               newHist[]->ymerPrivate.history.prepend;
               (this(ymerBrowserWindow).theMenubar).historyMenu.addHistoryElement;
            #)
          do
       #)   
   if);
   
--- selectFragmentGroup: dopart ---
do (if browser.currentProject[]=NONE then
       (# newProj: ^browser.projects.project
       do &browser.projects.project[]->newProj[];
          '+tmp'->newProj.name[];
          '/tmp/'->newproj.location.puttext;
          newProj[]->browser.projects.setupProject;
          newProj[]->browser.projects.theProjects.append;
          browser.projectsChanged;
          newProj[]->browser.setProject;
       #);
   if);
   browser.currentProject.groups.find
   (# predicate:: (# do fgName[]->current.location.equalNCS->value #);
      notFound:: 
        (# cp: ^browser.projects.project;
           newGroup: ^browser.projects.group
        do browser.currentProject[]->cp[];
           &browser.projects.group[]->newGroup[];
           fgName[]->newGroup.location.puttext;
           fgName[]->fragmentDefaultName
             ->newGroup.name[];
           '+'->newGroup.name.prepend;
           true->newGroup.temporary;
           newGroup[]->browser.currentProject.groups.append;
           projectsChanged;
           (cp[],newGroup[])->browser.setGroup;
        #)
   do (browser.currentProject[],current[])->browser.setGroup
   #)
   
--- selectFragmentForm: dopart ---
do fgName[]->selectFragmentGroup;
   (# t: @text;
      ff: ^MPS.ast.fragmentForm;
   do (formName[],screen[])->browser.currentGroup.fg.open->ff[];
      (if ff[]=NONE then
          'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
            ->t.putformat(# do formName[]->s; fgName[]->s #);
          (NONE, t[], 'Warning')->alertUser
       else
          (browser.currentProject[],browser.currentGroup[],ff[])
            ->browser.setFragmentForm
      if);
   #)
   
--- browserOpen: dopart ---
do (# x,y: @integer;
      sz: @point;
   do (sbprivate.initialWindowWidth,45)->sz;
      (sbprivate.outerctrl[],sz)->locationView.open;
      infoView.open;
      locationView[]->sbprivate.outerctrl.appendMember;
      locationView[]->sbprivate.outerctrl.fixedSize;
      sbprivate.outerctrl.appendsDone;
      
   #);

---  ymerInit: descriptor ---
(# OS: @osInterface;
do OS.init;
   OS.hostMachine->machinetype;
   '$(BETALIB)'->expandEnvVar
   (# defaultValue::
        (# do '/usr/local/lib/beta'->envvarvalue[] #)#)
     ->BETAlib[];
   mps.init;
   browsers.init;
   INNER init;
   ymerBrowser.open;
#)

--- ymerPrivate: descriptor ---
(# history: @list
     (# element::
          (# theProject: ^browser.projects.project;
             theGroup: ^browser.projects.group;
             theForm: ^MPS.ast.fragmentForm;
             theSif: ^sifTextEditor;
          #)
     #);
   workspaceCount: @integer;
#)
