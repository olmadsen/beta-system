ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.4/formatio'
        '~beta/sysutils/v1.4.2/pathhandler'
        '~beta/editor/v5.0.1/fragmentscanner'
        '~beta/mps/v5.0.1/findgrammar'
        'hosttype'
        'fileEditor'
        'parseEditor'
        'sourcebrowserbody'
        'ymerFileUtils'
        'ymerPrivate'
        'separateCodeEditor'
        'searchActions'
        'mpsIntAdds';
BODY 'settings';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- historyMenuLib: Attributes --
findAndSelect:
  (# node: ^astInterface.ast
  enter node[]
  do
     (if node[] <> none then
         (if cfe[] <> none then
             (if node.frag[] <> cfe.frag[] then
                 ymerBrowserPrivate.history.find
		   (# predicate:: 
			(# do (current.theForm[] = node.frag[])->value #);
		      notFound:: 
			(#
			do ((node.frag.father).fullName,node.frag.name)
			     ->browser.selectFragmentForm
			#)
		   do (current.theProject[],current.theGroup[],current.theForm[])
			->browser.setFragmentForm
		   #);
                 (if not cfe.theSifTexteditor.textediting then
                     (node[],1,0,0)->cfe.setFocus
                  else
		     (none ,'Cannot reestablish focus - text edit active',
		      'History')->noteUser
                 if)
              else
		 (node[],1,0,0)->cfe.setFocus
             if)
          else
	     ((node.frag.father).fullName,node.frag.name)
               ->browser.selectFragmentForm;
             (if not cfe.theSifTexteditor.textediting then
                 (node[],1,0,0)->cfe.setFocus
              else
		 (none ,'Cannot reestablish focus - text edit active','History')
                   ->noteUser
             if)
         if)
      else
	 (none ,'Should not happen - node[] is none!','History')->alertUser
     if)
  #);
back: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((cfe[] <> none ) and (cfe.cs[] <> none ) and
		  (cfe.cs.node[] <> none ) and
		  (cfe.cs.node[]->edenv.history.BackPossible))->value
            #);
          onSelect:: 
            (#
            do edenv.history.protect
		 (# do cfe.cs.node[]->edenv.history.back->findAndSelect #) #)
       #);
     open::  (#  do 'Back'->name; 'b'->key #)
  #);
forward: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((cfe[] <> none ) and (cfe.cs[] <> none ) and
		  (cfe.cs.node[] <> none ) and
		  (cfe.cs.node[]->edenv.history.forwardPossible))->value
            #);
          onSelect:: 
            (#
            do edenv.history.protect
		 (# do cfe.cs.node[]->edenv.history.forward->findAndSelect #) #)
       #);
     open::  (#  do 'Forward'->name; 'f'->key #)
  #);
historyMenuItem: menuItem
  (#
     theHist: ^ymerBrowserPrivate.history.element;
     eventhandler:: 
       (#
          onSelect:: 
            (# 
            do (theHist.theProject[],theHist.theGroup[],theHist.theForm[])
                 ->browser.setFragmentForm
            #)
       #);
     setName:
       (# t: ^text; 
       do
          (theHist.theGroup.location[],true)
            ->ymerBrowserPrivate.history.names.uniqName
            ->t[];
          (*theHist.theGroup.name.copy->t[];*)
          '-'->t.append;
          theHist.theForm.name->t.append;
          t[]->name
       #)
  #);
addHistoryElement:
  (#
     theHist: ^ymerBrowserPrivate.history.element;
     newHitem: ^historyMenuItem
  enter theHist[]
  do
     (if not protected then
         &historyMenuItem[]->newHitem[];
         newHitem.open;
         theHist[]->newHitem.theHist[];
         newHitem[]->append;
         updateNames;
     if)
  #);
updateNames: scan
  (# theHitem: ^historyMenuItem
  do (if current## <= historyMenuItem## then
	 current[]->theHitem[];
	 theHitem.setname
     if)
  #);
closeHistoryElement:
  (#
     oldElement: ^ymerBrowserPrivate.history.element;
     theHitem: ^historyMenuItem
  enter oldElement[]
  do
     l: scan
       (# 
       do
          (if current## <= historyMenuItem## then
              current[]->theHitem[];
              (if theHitem.theHist[] = oldElement[] then
                  theHitem[]->historyMenu.delete; leave l
              if)
          if)
       #)
  #);
protect:
  (# status: @boolean
  do protected->status; true->protected; INNER protect; status->protected
  #)

-- historyMenuOpen: DoPart --
do
   'History'->name;
   (# item: ^menuItem
   do
      &back[]->item[];
      item.open;
      item[]->append;
      &forward[]->item[];
      item.open;
      item[]->append;
      &separator[]->item[];
      item.open;
      item[]->append
   #)  

-- browserSelectNode: DoPart --
do
   (if true
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and separate then
       (theEditorRoot.frag[],node[])->viewSeparate
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
	(theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->cfe.setNode
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and separate then
       (theEditorRoot[],node[])->cfe.openSubeditor
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
	(theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->cfe.setNode
   if)  

-- browserFileEdit: DoPart --
do (# se: @streamEditor
        (# setTitle::
             (#
             do 'MAKE file editor for '->t[];
                f.name->fragmentDefaultName->t.append;
             #);
           openRead::
             (# t: ^text
             do (if f.entry.exists and f.entry.readable then
                    f.openRead; true->value
                 else
                    'No read permissions to the file:\n     '->t[];
                    f.name->fragmentDefaultName->t.puttext;
                    (se[], t[],'Read Error')
                      ->alertUser;
                    false->value
                if)
             #);
           openWrite::
             (# t: ^text
             do (if f.entry.exists and f.entry.writeable then
                    f.openWrite; true->value
                 else
                    'No write permissions to the file:\n     '->t[];
                    f.name->fragmentDefaultName->t.puttext;
                    (se[], t[],'Write Error')
                      ->alertUser;
                    false->value
                if)
             #);
           closeStream:: (# do f.close #);
           open::  (#  do (600,800)->size #)
        #);
      f: @file; t: ^text
   do se.open;
      currentGroup.location[]->f.name;
      f.entry.path.head->t[];
      mps.ast.thepathhandler.directoryChar->t.put;
      makefile[]->t.append;
      t[]->mps.AST.expandtofullpath->f.name;
      f[]->se.loadStream; 
   #)  
   
-- ymerMPSparseerrors: DoPart --
do
   true->continue;
   (# pe: @parseEditor
	(# open::  (#  do (600,800)->size; groupName[]->loadFiles #) #)
   do pe.open
   #)  

-- ymerMPSbetaparserinit: Descriptor --
(# bobsFile: @file; grammarWithPath,help: ^text; 
do
   (if not BETACFL.parser.haveBeenInitialized then
       '~beta/grammars/beta/v2.4/beta'
         ->mps.ast.expandToFullPath->grammarWithPath[];
       (if BETACFL.grammarAst[]
        // none then
           'No grammarAst for '->screen.putText;
           grammarWithPath[]->screen.putLine
        else
           '-parser'->help[];
           mps.ast.parserFileExtension->help.append;
           help[]->grammarWithPath.copyAppend->mps.ast.expandToFullPath
             ->bobsFile.name;
           (if bobsFile.entry.exists then
               bobsFile.name->BETACFL.parser.initialize;
               ('objectdescriptor','descriptor')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               ('attributedecl','attributes')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias
            else
               'No parser available: '->screen.putText;
               bobsFile.name->screen.putLine
           if)
       if)
   if)
#)  

-- ymerLoadProject: DoPart --
do
   (if true
    // proj.isDirectory // proj.isDotDotDirectory // proj.isRoot
    // proj.isExtent // proj.isDomain then
       (# newProj: ^browser.projects.project; t: ^text; 
       do
	  &browser.projects.project[]->newProj[];
	  proj.location.copy->newProj.location.puttext;
	  (if (newProj[]->browser.projects.setupProject)=NONE then
	      proj.isDirectory->newproj.isDirectory;
	      proj.isRoot->newProj.isRoot;
	      proj.isExtent->newProj.isExtent;
	      proj.isDomain->newProj.isDomain;
	      newProj[]->browser.projects.theProjects.append
	  if);
	  'Browser on: '->t[];
	  newProj.name[]->t.append;
	  (if true
	   // proj.isExtent then
	      ' [extent]'->t.append
	   // proj.isDomain then
	      ' [domain]'->t.append
	  if);
	  t[]->title
       #)
    // proj.isProjectFile // proj.hasSubprojects then
       (# t: ^text
       do
	  proj.subprojects.scan
	    (# 
	    do
	       current.copy->browser.projects.theProjects.append;
	       none ->current.superProject[]
	    #);
	  'Browser on: '->t[];
	  proj.name[]->t.append;
	  t[]->title
       #)
   if);
   browser.projectsChanged

-- ymerAddProject: DoPart --
do location[]->appendProject; appendDone 

-- ymerAppendProject: DoPart --
do
   &browser.projects.project[]->newProj[];
   location[]->fragmentDefaultName->newProj.name[];
   location[]->newProj.location.puttext;
   (if (newProj[]->browser.projects.setupProject)=NONE then
       newProj[]->browser.projects.theProjects.append
   if)

-- ymerAppendDone: DoPart --
do
   browser.projectsChanged;
   (browser.projects.theProjects.last).elm[]->browser.setProject

-- ymerGroupClose: DoPart --
do
   (if theForm[] = none then (* delete all history related to this group *)
       ymerBrowserPrivate.history.iterate
	 (#
	    where:: 
	      (# 
	      do (current.elm.theGroup.location[]->location.equalNCS)->value
	      #)
	 do
	    current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
	    current[]->ymerBrowserPrivate.history.delete;
	    current.elm.theGroup. (*get*) fg[]
	      ->ymerBrowserPrivate.geList.closeGroup;
	    (if currentProject[] <> none then
		none ->currentProject.lastGroupSelected[]
	    if);
	    (if currentGroup[] <> none then
		none ->currentGroup.lastFormSelected[]
	    if);
	    (currentProject[],none )->setGroup;
	    none ->cge[];
	    none ->cfe[]
	 #)
    else
       (* delete only history related to theForm in this group *)
       ymerBrowserPrivate.history.iterate
	 (# where::  (#  do (current.elm.theForm[] = theForm[])->value #); 
	 do
	    current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
	    current[]->ymerBrowserPrivate.history.delete;
	    (if currentForm[] = theForm[] then
		(currentProject[],currentGroup[],none )->setFragmentForm;
		(if currentGroup[] <> none then
		    none ->currentGroup.lastFormSelected[]
		if);
		none ->cfe[]
	    if)
	 #)
   if)  

--- ymerGroupRecheck: dopart ---
do fg.diskfilename->diskfile.name;
   fg.textfilename->textfile.name;
   (if textfile.entry.exists then
       (if (textfile.entry.modTime > fg.modTime) then
           'Source file: '->t.puttext;
           fg.textfilename->t.putline;
           'changed since last access - reload?'->t.puttext;
           (none ,'Notification',t[])
             ->promptForBoolean
		 (# ok:: 
		      (# do true->allowReload #);
		    notok:: 
		      (# do false->allowReload #);
		    cancel:: 
		      (# do false->allowReload #) 
		 #)
        else
           (if diskfile.entry.exists then
               (if (diskfile.entry.modTime>fg.modTime) then
                   'Group file: '->t.puttext;
                   fg.diskfilename->t.putline;
                   'changed since last access - reload?'->t.puttext;
                   (none ,'Notification',t[])
                     ->promptForBoolean
			 (# ok:: (# do true->allowReload #);
			    notok:: (# do false->allowReload #);
			    cancel:: (# do false->allowReload #)
			 #)
               if)
            else
               (none,'no groupfile, should not happen!','Not Available')
                 ->alertUser
           if)                             
       if)                             
   if);
   (if allowReload then
       currentGroup[]->cg[]; (currentProject[],none)->setGroup;
       fg[]->ymerBrowserPrivate.geList.closeGroup;
       fg[]->MPS.reload;
       (currentProject[],cg[])->setGroup;
   if)

-- ymerGroupGetFg: DoPart --
do 'Opening '->infoView.settext; location[]->infoView.append;
   ' ... '->infoView.append; infoView.msgPush;
   (if not location.empty then
       location[]->mps.AST.expandToFullPath
	 ->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (if fg[] <> none then fg[]->doRealOpen if)
   if);
   infoView.msgPop

-- projectInfoLib: Attributes --
setupRootProject:
  (# proj,root,existing: ^project
  enter proj[]
  do projects.theProjects.find
       (# predicate::
	    (# do current.location[]->proj.location.equalNCS->value #)
       #)->existing[];
     (if existing[]=none then
         (if (proj.name.length->proj.name.inxGet) <> '*' then
             '*'->proj.name.append
         if);
         true->proj.isRoot;
         proj[]->root[];
         &browser.projects.project[]->proj[];
         root.location->proj.location;
         true->proj.isDomain;
         '[domain]'->proj.name[];
         root[]->proj.superProject[];
         proj[]->root.subprojects.append;
         &browser.projects.project[]->proj[];
         root.location->proj.location;
         true->proj.isExtent;
         '[extent]'->proj.name[];
         root[]->proj.superProject[];
         proj[]->root.subprojects.append;
     if)
  exit existing[]
  #);
setupProject:
  (# f: @file; ext,name: ^text; t: ^text; proj,existing: ^project;
  enter proj[]
  do proj.location[]->mps.AST.expandToFullPath->f.name;
     f.entry.path.name.suffix->ext[];
     (if (ext[] <> none ) and (ext.length > 0) then
         (if true
          // mps.AST.astFileExtension->ext.equalNCS then
	     (proj.location.length-(mps.AST.astFileExtension).length+1,
	      proj.location.length)->proj.location.delete                 
          // ext[]->ymerPrivate.grammarTable.checkExtension then
	     (proj.location.length-(ext.length-1),proj.location.length)
               ->proj.location.delete                 
         if)
     if);
     (if (proj.location.length>0) and
	   ((proj.location.length->proj.location.inxGet) =
	    mps.ast.thepathhandler.directoryChar) then
	 (proj.location.length,proj.location.length)->proj.location.delete 
     if);
     (if proj.location.length>0 then
         proj.location[]->mps.AST.expandToFullPath->f.name
      else
         &text[]->t[]; mps.ast.thepathhandler.directoryChar->t.put; t[]->f.name
     if);
     (if proj.name[] = none then f.entry.path.name->proj.name[] if);
     projects.theProjects.find
       (# predicate::
	    (# do current.location[]->proj.location.equalNCS->value #)
       #)->existing[];
     (if existing[]=none then
         f.name->t[];         
         (if (t.length>0) and
             ((t.length->t.inxGet) =
             mps.ast.thepathhandler.directoryChar) then
             (1,t.length-1)->t.sub->f.name
         if);
         (if true
          // f.entry.exists and f.entry.readable and f.entry.isDirectory then
             true->proj.isDirectory;
             (if true
              // (proj.location.length>0) and
		   ((proj.location.length->proj.location.inxGet) <>
		    mps.ast.thepathhandler.directoryChar)
              // (proj.location.length=0) then
                 proj.location.length->proj.location.pos;
                 mps.ast.thepathhandler.directoryChar->proj.location.put
             if);
	     (if proj.name.length > 0 then
		 (if (proj.name.length->proj.name.inxGet) <> '/' then
		     '/'->proj.name.append
		 if) 
	      else  '/'->proj.name.append
             if)
          else
             f.entry.path.name.suffix->ext[];
             f.name->name[];
             (if true
              // f.entry.exists and f.entry.readable and
                 (mps.AST.astfileExtension->ext.equal)
              // f.entry.exists and f.entry.readable and
		   (ext[]->ymerPrivate.grammarTable.checkExtension)
              // (mps.AST.astfileExtension->name.copyappend->fileExists)
                 and
		   (mps.AST.astfileExtension->name.copyappend->fileReadable)
              // ymerPrivate.grammarTable.scanExtensions
		   (# fn: ^text; found: @boolean
		   do found or
		      ((current[]->name.copyappend->fn[]->fileExists) and
			 (fn[]->fileReadable))->found
		   exit found
		   #) then
                 proj[]->setupRootProject
              // f.entry.exists and f.entry.readable and ('.pjt'->ext.equal) then
                 true->proj.isProjectFile->proj.hasSubprojects;
                 (if (proj.name.length > 0) and
		       ((proj.name.length->proj.name.inxGet) <> '+') then
                     '+'->proj.name.append; 
                 if);
                 (f.name,proj[])->theProjects.parseProjectFile
              // ('.pjt'->(f.name).append->fileExists)
                 and
		   ('.pjt'->(f.name).append->fileReadable) then
                 true->proj.isProjectFile->proj.hasSubprojects;
                 (if (proj.name.length > 0) and
		       ((proj.name.length->proj.name.inxGet) <> '+') then
                     '+'->proj.name.append; 
                 if);
                 ('.pjt'->(f.name).append,proj[])->theProjects.parseProjectFile;
             if)
         if)
     if)
  exit existing[]
  #)  

-- scanGroupsImpl: DoPart --
do 'Opening '->infoView.settext; location[]->infoView.append;
   ' ... '->infoView.append; infoView.msgPush;
   (if true
    // isRoot then
       (if groups.size = 0 then (* this is the first time we visit this root *)
	   &browser.projects.group[]->newGroup[];
	   location[]->newGroup.location.puttext;
	   newGroup.location[]->fragmentDefaultName->newGroup.name[];
	   newGroup[]->groups.append;
	   newGroup[]->thescan.foreach
	else
	   (* we have visited this root previously *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);  
       infoView.msgPop
    // isExtent then
       (if groups.size = 0 then
	   (* the extent haven't previously been calculated *)
	   machineType->mps.dg.TargetMachine;
	   machineType->mps.dg.TargetDirectory;
	   location[]->mps.AST.expandToFullPath
	     ->mps.dg.scanExtent
		 (# 
		 do
		    &browser.projects.group[]->newGroup[];
		    current.fullname->newGroup.location.puttext;
		    newGroup.location[]->dependencyRegister;
		    current.name->fragmentDefaultName->newGroup.name[];
		    newGroup[]->groups.append;
		    newGroup[]->thescan.foreach
		 #);
	   dependencyCreateSubprojects
	else
	   (* the extent have previously been calculated *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);  
       infoView.msgPop
    // isDomain then
       (if groups.size = 0 then
	   (* the domain haven't previously been calculated *)
	   machineType->mps.dg.TargetMachine;
	   machineType->mps.dg.TargetDirectory;
	   location[]->mps.AST.expandToFullPath
	     ->mps.dg.scanDomain
		 (# 
		 do
		    &browser.projects.group[]->newGroup[];
		    current.fullname->newGroup.location.puttext;
		    newGroup.location[]->dependencyRegister;
		    current.name->fragmentDefaultName->newGroup.name[];
		    newGroup[]->groups.append;
		    newGroup[]->thescan.foreach
		 #);
	   dependencyCreateSubprojects
	else
	   (* the domain have previously been calculated *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);  
       infoView.msgPop
    // isDirectory then
       (if groups.size = 0 then
	   (* the directory haven't previously been scanned *)
	   (# d: @directory; count: @integer; t: @text;
	   do
	      THIS(Project).groups.clear;
	      (if location.empty then
		  mps.ast.thepathhandler.currentDirectory->location.puttext; 
	      if);
              location->t;
              (if (t.length>0) and
                  ((t.length->t.inxGet) =
                  mps.ast.thepathhandler.directoryChar) then
                  (t.length,t.length)->t.delete;
              if);
	      t[]->mps.AST.expandToFullPath->d.name;
	      d.scanEntries
		(# error::  (#  do true->continue #)
		do
		   select
		     (#
			error::  (#  do true->continue #);
			whenFile:: 
			  (# f: ^file; ext: ^Text; 
			  do
			     &browser.projects.group[]->newGroup[];
			     thefile->f[];
			     f.entry.path.name.suffix->ext[];
			     location[]->newGroup.location.puttext;
			     f.entry.path.name.prefix
			       ->newGroup.location.puttext;
			     (*f.entry.path.name->newGroup.location.puttext;*)
			     (if true
			      // f.entry.exists and f.entry.readable and
				 (mps.AST.astfileExtension->ext.equal)
			      // f.entry.exists and f.entry.readable and
				   (ext[] <> none ) and (ext.length > 0) and
				   (ext[]->ymerPrivate.grammarTable.checkExtension)
				 then
				 (*(newGroup.location.length-(ext.length-1),
				  newGroup.location.length)
				  ->newGroup.location.delete;
				  location[]->newGroup.location.prepend;*)
				 (if groups.find
				       (# predicate:: 
					    (# 
					    do current.location[]
						 ->newGroup.location.equalNCS
						 ->value
					    #)
				       #) = none then
				     f.entry.path.name.prefix
				       ->newGroup.name[];
				     count+1->count;
				     newGroup[]->groups.append;
				     newGroup[]->thescan.foreach
				 if)
			      // f.entry.exists and f.entry.readable then
				 (if groups.find
				       (# predicate:: 
					    (# 
					    do current.location[]
						 ->newGroup.location.equalNCS
						 ->value
					    #)
				       #) = none then
				     f.entry.path.name.prefix
				       ->newGroup.name[];
				     (* activate this code to allow _all_
				      * files to be shown
				      * count+1->count;
				      * newGroup[]->groups.append;
				      * newGroup[]->thescan.foreach
				      *)
				 if)
			     if)
			  #)
		     #)
		#);
	      (if count = 0 then
		  'no fragments in project'->infoView.msg
	      if)
	   #)
	else
	   (* the directory have previously been scanned *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);  
       infoView.msgPop
    // groups.size <> 0 then
       groups.scan (#  do current[]->thescan.foreach #);  
       infoView.msgPop
    else
       (if not unfolded then
	   'open project to find subprojects'->infoView.msg
	else
	   'open subproject to find fragments'->infoView.msg
       if)
   if)

-- browserLib: Attributes --
setupDotDot:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
     d: @directory;
     location: ^text;
     level: @integer;
     superProject,superSuperProject: ^browser.projects.project;
     createParentProject:
       (# newProj: ^browser.projects.project
       do
          &browser.projects.project[]->newProj[];
          location->newProj.location;
          newProj[]->browser.projects.setupProject;
          (newProj[],superProject[]->browser.projects.theProjects.at)
            ->browser.projects.theProjects.insertBefore;
          superProject.level->newProj.level;
          (for newProj.level repeat '  '->newProj.name.prepend for);
          superProject.level+1->superProject.level;
          '  '->superProject.name.prepend;
          l:
	    (superProject[]->browser.projects.theProjects.at).succ[]
            ->browser.projects.theProjects.iterateFrom
		(# 
		do
		   (if current.elm.level >= superProject.level then
		       current.elm.level+1->current.elm.level;
		       '  '->current.elm.name.prepend
		    else
		       leave l
		   if)
		#);
          superProject.subprojects.clear;
          true->newProj.unfolded;
          newProj[]->foldSubprojects;
          newProj[]->unfoldSubprojects;
          browser.projectsChanged;
          newProj[]->browser.setProject
       #)
  enter proj[]
  do
     (* we now have to create a new project to contain the parent
      * directory of currentDirectory
      *)
     proj.location.copy->location[];
     (if (location.length>0) and
	   ((location.length->location.inxGet) =
	    mps.ast.thepathhandler.directoryChar) then
	 (location.length,location.length)->location.delete 
     if);
     location.length->location.pos;
     mps.ast.thepathhandler.directoryChar->location.put;
     proj.superProject[]->superProject[];
     (if superProject[] <> none then
         superProject.level->level;
         superProject.superProject[]->superSuperProject[];
         (if superSuperProject[] <> none then
             (if superSuperProject.isDirectory then
                 (* this is the .. directory - select it *)
                 superSuperProject[]->setProject; 
              else
                 (* try to locate the '..' project in
                  * superSuperProject
                  *)
                 l:
                   (# 
                   do
                      superSuperProject.subprojects.iterate
			(# 
			do
			   (if current.elm.location[]->location.equal then
			       current.elm[]->setProject; leave l
			   if)
			#);
                      (* not found - create it *)
                      createParentProject                      
                   #)
             if)
          else
	     (* OK, we are 'on the top'.  Try those *)
             l:
               (# 
               do
                  browser.projects.theProjects.iterate
		    (#
		       where:: 
			 (#  do (current.elm.level = level)->value #)
		    do
		       (if current.elm.location[]->location.equal then
			   current.elm[]->setProject; leave l
		       if)
		    #);
                  (* not found - create it *)
                  createParentProject
               #)
         if)
     if)
  #);
unfoldSubprojects:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType; t: ^text;
  enter proj[]
  do
     'Unfolding '->infoView.settext; proj.location[]->infoView.append; 
     ' ... '->infoView.append; infoView.msgPush;
     (proj[]->projects.theProjects.at).succ[]->projPos[];
     (if true
      // proj.hasSubprojects // proj.isRoot then
         proj.subprojects.scan
	   (# 
	   do
	      proj.level+1->current.level;
	      (for current.level repeat '  '->current.name.prepend for);
	      (current[],projPos[])->projects.theProjects.insertBefore
	   #);
         proj.subprojects.scan
	   (# 
	   do (if current.unfolded then current[]->unfoldSubprojects if)
	   #)
      // proj.isDirectory then
         (if proj.subprojects.size = 0 then
	     (* the directory haven't previously been unfolded *)
	     (# d: @directory; f: @file; level: @integer; t: @text;
	     do
		(if proj.location.length>0 then
                    proj.location->t;
                    (if (t.length>0) and
                        ((t.length->t.inxGet) =
                        mps.ast.thepathhandler.directoryChar) then
                        (t.length,t.length)->t.delete;
                    if);
	            t[]->mps.AST.expandToFullPath->d.name;
		 else
		    mps.ast.thepathhandler.directoryChar->t.put; t[]->d.name
		if);
		d.scanEntries
		  (# error::  (#  do true->continue #)
		  do
		     select
		       (#
			  error::  (#  do true->continue #);
			  whenDir:: 
			    (#
			       d: ^directory;
			       name: ^text;
			       location: ^text;
			       newProj: ^browser.projects.project;
			       create,dotdot: @boolean;
			       dotdir: @file
			    do
			       thedir->d[];
			       d.entry.path.name->name[];
			       (if true
				// '.'->name.equalNCS
				// 'sun4s'->name.equalNCS
				// 'sun4'->name.equalNCS
				// 'sun3'->name.equalNCS
				// 'snake'->name.equalNCS
				// 'sgi'->name.equalNCS
				// 'nti'->name.equalNCS
				// 'linux'->name.equalNCS
				// 'hpux9mc'->name.equalNCS
				// 'hpux9pa'->name.equalNCS
				// 'hpux8'->name.equalNCS
				// 'b2c'->name.equalNCS then
				   false->create; 
				// '..'->name.equalNCS then
				   true->create; true->dotdot
				else
				   true->create; false->dotdot
			       if);
			       (if create then
				   &browser.projects.project[]->newProj[];
				   true->newProj.isDirectory;
				   proj.location.copy->location[];
				   (d.name,proj.location[])
				     ->mps.ast.thepathhandler.convertfilePath
				     ->f.name;
				   &text[]->newProj.name[];
				   proj.level+1->newProj.level;
				   (for newProj.level repeat
					'  '->newProj.name.puttext
				   for);
				   f.entry.path.name
				     ->newProj.name.puttext;
				   '/'->newProj.name.append;
				   (if dotdot then
				       true->newProj.isDotDotDirectory;
				       (f.entry.path.head)->dotdir.name;
				       (dotdir.entry.path.head)->dotdir.name;
				       dotdir.name->newProj.location.puttext
				    else
				       location[]->newProj.location.puttext;
				       f.entry.path.name
					 ->newProj.location.puttext
				   if);
				   (if (newProj.location.length=0) or
					 ((newProj.location.length
					     ->newProj.location.inxGet) <>
					  mps.ast.thepathhandler.directoryChar) then
				       mps.ast.thepathhandler.directoryChar
					 ->newProj.location.put
				   if);
				   (if f.entry.exists and
				       f.entry.readable then
				       (newProj[],projPos[])
					 ->projects.theProjects.insertBefore;
				       proj[]->newProj.superProject[];
				       newProj[]->proj.subprojects.append
				   if)
			       if)
			    #);
			  whenFile:: 
			    (#
			       f: ^file;
			       name: ^text;
			       newProj: ^browser.projects.project
			    do
			       thefile->f[];
			       f.entry.path.name->name[];
			       (if true
				// '.pjt'->(f.entry.path.name.suffix).equal
				   then
				   &browser.projects.project[]->newProj[];
				   (f.name,proj.location[])
				     ->mps.ast.thepathhandler.convertfilePath
				     ->newProj.location.puttext;
				   (newProj.location.length-3,
				    newProj.location.length)
				     ->newProj.location.delete;
				   proj.level+1->newProj.level;
				   &text[]->newProj.name[];
				   (for newProj.level repeat
					'  '->newProj.name.puttext
				   for);
				   f.entry.path.name->newProj.name.puttext;
				   (newProj.name.length-3,newProj.name.length)
				     ->newProj.name.delete;
				   '+'->newProj.name.append;
				   true->newProj.hasSubprojects;
				   (f.name,newProj[])
				     ->proj.subprojects.parseProjectFile;
				   (if (newProj.location[]->fileExists) and
					 (newProj.location[]->fileReadable) then
				       (newProj[],projPos[])
					 ->projects.theProjects.insertBefore;
				       proj[]->newProj.superProject[];
				       newProj[]->proj.subprojects.append
				   if)
			       if)
			    #)
		       #)
		  #)
	     #)
          else
	     (* the directory have previously been unfolded *)
             proj.subprojects.scan
	       (# 
	       do
		  (for current.level repeat '  '->current.name.prepend for);
		  (current[],projPos[])->projects.theProjects.insertBefore
	       #);
             proj.subprojects.scan
	       (# 
	       do (if current.unfolded then current[]->unfoldSubprojects if)
	       #)
         if)
     if);
     infoView.msgPop;
  #);
foldSubprojects:
  (# proj: ^browser.projects.project; level: @integer; t: ^text;
  enter proj[]
  do
     'Folding '->infoView.settext; proj.location[]->infoView.append;
     ' ... '->infoView.append; infoView.msgPush;
     proj.level->level;
     loop:
       (proj[]->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
	   (# 
	   do
	      (if current.elm.level > level then
		  (1,current.elm.level*2)->current.elm.name.delete;
		  current[]->projects.theProjects.delete
	       else
		  leave loop
	      if)
	   #);
     infoView.msgPop;
  #);
projectByIndex:
  (# inx: @integer; foundProj: ^browser.projects.project; 
  enter inx
  do
     find: projects.theProjects.scan
       (# 
       do inx-1->inx; (if inx = 0 then current[]->foundProj[]; leave find if)
       #)
  exit foundProj[]
  #)

-- onProjectListOpen: DoPart --
do
   &theprojectlist.action
      (#
	 eventtype:: theprojectlist.theeventhandler.mousedown;
	 i: @integer;
	 selectedProj: ^browser.projects.project
      do
	 (if theEvent.doubleClick and ((theprojectlist.selection.first->i) <> 0)
	     then
	     (if theEvent.shiftKey then
		 (# fragmentBrowser: ^ymerBrowserWindow 
		 do 'Opening new browser ... '->infoView.settext;
		    infoView.msgPush;
		    &ymerBrowserWindow[]->fragmentBrowser[];
		    fragmentBrowser.open;
		    i->projectByIndex->selectedProj[];
		    selectedProj[]->fragmentBrowser.loadProject;
		    infoView.msgPop
		 #)
	      else
		 i->projectByIndex->selectedProj[];
		 (if true
		  // selectedProj.isDotDotDirectory then
		     'Creating parent directory ... '->infoView.settext;
		     infoView.msgPush;
		     selectedProj[]->setupDotDot; 
		     infoView.msgPop
		  // selectedProj.unfolded then
		     false->selectedProj.unfolded;
		     selectedProj[]->foldSubprojects;
		     projectsChanged;
		     selectedProj[]->setProject
		  else
		     true->selectedProj.unfolded;
		     selectedProj[]->unfoldSubprojects;
		     projectsChanged;
		     selectedProj[]->setProject
		 if)
	     if)
	 if)
      #)[]->theprojectlist.appendAction;
   &theprojectlist.searchAction
      (#
	 getContext::  (#  do none ->context[] #);
	 select:: 
	   (# selectedProject: ^projects.project
	   do
	      inx->sbprivate.projectList.shownprojects.getProjectByIndex
		->selectedProject[];
	      (if selectedProject[] <> currentProject[] then
		  (selectedProject[])->setProject 
	      if)
	   #);
	 info::  (#  do msg[]->infoView.msg #)
      #)[]->theprojectlist.appendAction

-- onGroupListOpen: DoPart --
do
   &thegrouplist.action
      (#
	 eventtype:: thegrouplist.theeventhandler.mousedown;
	 selectedGroup: ^projects.group;
	 root,newProj: ^browser.projects.project
      do
	 (if theEvent.doubleClick and ((thegrouplist.selection.first) <> 0) then
	     (* do what's needed to make THIS into a root *)
	     thegrouplist.selection.first->groups.getGroupByIndex
	       ->selectedGroup[];
	     &browser.projects.project[]->newProj[];
	     selectedGroup.location->newProj.location;
	     (if newProj.name[] = none then
		 selectedGroup.name.copy->newProj.name[]
	     if);
	     (if theEvent.shiftKey then
		 (# fragmentBrowser: ^ymerBrowserWindow; t: ^text; 
		 do 'Opening separate browser on '->infoView.settext;
		    newProj.location[]->infoView.append;
		    ' ... '->infoView.append; infoView.msgPush;
		    &ymerBrowserWindow[]->fragmentBrowser[];
		    fragmentBrowser.open;
		    newProj.location[]->fragmentBrowser.addProject;
		    'Browser on: '->t[];
		    newProj.location[]->t.puttext;
		    t[]->fragmentBrowser.title;
		    infoView.msgPop
		 #)
	      else
		 newProj[]->projects.setupRootProject->root[];
		 (if root[]=NONE then
		     newProj[]->root[]->projects.theProjects.append;
		     projectsChanged
		 if);
		 root[]->setProject
	     if)
	 if)
      #)[]->thegrouplist.appendAction;
   &thegrouplist.searchAction
      (#
	 getContext::  (#  do currentProject[]->context[] #);
	 select:: 
	   (# selectedGroup: ^projects.group; 
	   do
	      inx->groups.getGroupByIndex->selectedGroup[];
	      (if selectedGroup[] <> currentGroup[] then
		  (currentProject[],selectedGroup[])->setGroup
	      if)
	   #);
	 info::  (#  do msg[]->infoView.msg #)
      #)[]->thegrouplist.appendAction

-- onFragmentgroupViewOpen: DoPart --
do
   &theFragmentgroupView.action
      (#
	 eventtype:: theFragmentgroupView.theeventhandler.mousedown;
	 inx: @integer;
	 fgs: @fragmentGroupScanner
      do
	 (if theEvent.doubleClick and
	     ((theFragmentgroupView.selection.first->inx) <> 0) then
	     (if theEvent.shiftKey then
		 (mps.AST[],currentGroup. (*get*) fg[])->fgs;
		 fgs.scanPropsAndFragsForText
		 (* HACK to initialize fgs properly
		  * - error in fragmentGroupScanner implementation
		  * - does not currently initialize noOfProgs
		  *   in scanPropsAndFrags
		  *) ;
		 find:
		   (currentGroup. (*get*) fg[],inx)
		   ->fgs.scanPropsAndFrags
		       (# doProperty:: 
			    (# t: ^Text; fragmentBrowser: ^ymerBrowserWindow; 
			    do (* ORIGIN,BODY, MDBODY or MAKE *)
			       (if true
				// 'ORIGIN'->prop.equalNCS
				// 'BODY'->prop.equalNCS
				// 'MDBODY'->prop.equalNCS then
				   'Opening separate browser on '->infoView.settext;
				   s[]->infoView.append;
				   ' ... '->infoView.append; infoView.msgPush;
				   &ymerBrowserWindow[]->fragmentBrowser[];
				   fragmentBrowser.open;
				   currentGroup.fg.fullName
                                     ->mps.AST.stripPathName->t[];
                                   (if t[] = none then
                                       s.copy
                                         ->mps.AST.expandtofullpath
                                         ->fragmentBrowser.addProject
                                    else
                                       (s.copy,t[])
                                         ->mps.AST.thePathHandler.convertFilePath
                                         ->fragmentBrowser.addProject
                                   if);
				   'Browser on: '->t[];
				   s[]->t.puttext;
				   t[]->fragmentBrowser.title;
				   infoView.msgPop;
				// 'MAKE'->prop.equalNCS then
				   s[]->makeFileEdit; 
			       if);
			       leave find
			    #);
			  doFragmentLink:: 
			    (#
			       fl: ^astInterface.FragmentLink;
			       fragmentBrowser: ^ymerBrowserWindow;
			       t: ^text
			    do (* INCLUDE *)
			       'Opening separate browser on '->infoView.settext;
			       fle.name[]->infoView.append;
			       ' ... '->infoView.append; infoView.msgPush;
			       fle.open->fl[];
			       &ymerBrowserWindow[]->fragmentBrowser[];
			       fragmentBrowser.open;
			       fl.name->fragmentBrowser.addProject;
			       'Browser on: '->t[];
			       fl.name->t.puttext;
			       t[]->fragmentBrowser.title;
			       infoView.msgPop;
			       leave find
			    #);
			  doFragmentForm:: 
			    (# t: ^text
			    do 
			       'Opening separate code viewer on '->infoView.settext;
			       fle.name[]->infoView.append;
			       ' ... '->infoView.append; infoView.msgPush;
			       (fle.open,none )->viewSeparate;
			       infoView.msgPop;
			       leave find
			    #)
		       #)
	     if)
	 if)
      #)[]->theFragmentgroupView.appendAction;
   &theFragmentgroupView.searchAction
      (#
	 getContext:: 
	   (# g: ^projects.group; 
	   do
	      currentGroup[]->g[];
	      (if g[] <> none then g. (*get*) fg[]->context[] if)
	   #);
	 select:: 
	   (#  do inx->sbprivate.fragmentGroupView.contents.doSelect #);
	 info::  (#  do msg[]->infoView.msg #)
      #)[]->theFragmentgroupView.appendAction

-- onCurrentProjectChange: DoPart --
do
   (if newProject[] <> none then
       newProject.location[]->locationView.msg
   if);
   none ->cge[];
   none ->cfe[]

-- onCurrentGroupChange: DoPart --
do
   (if newGroup[] <> none then
       newGroup.location[]->locationView.msg;
       (if newGroup.fg[] <> none then
	   newGroup.fg[]->ymerBrowserPrivate.geList.findOrCreateGroupEditor
	     ->cge[]
       if)
   if)  

-- onCurrentFormChange: DoPart --
do
   (if newForm[] <> none then
       ymerBrowserPrivate.history.find
	 (#
	    predicate:: 
	      (# 
	      do
		 ((current.theProject.location[]
		     ->browser.currentProject.location.equalNCS) and
		    (current.theGroup.location[]
		       ->browser.currentGroup.location.equalNCS) and
		    (current.theForm[] = newForm[]))->value
	      #);
	    notFound:: 
	      (# newHist: ^ymerBrowserPrivate.history.element
	      do
		 &ymerBrowserPrivate.history.element[]->newHist[];
		 browser.currentProject[]->newHist.theProject[];
		 browser.currentGroup[]->newHist.theGroup[];
		 newForm[]->newHist.theForm[];
		 newHist[]->ymerBrowserPrivate.history.add;(*prepend;*)
		 newHist[]->(theMenubar).historyMenu.addHistoryElement
	      #)
	 #);
       'Prettyprinting '->infoView.settext; newForm.name->infoView.append;
       ' ... '->infoView.append; infoView.msgPush;
       (newForm[],newForm.root[],none ,
	browser.sbprivate.down.fragmentView.contents[],cge[])
	 ->edenv.findOrCreateFormEditor->cfe[];
       (* true->cfe.switch[8];  trace history list *)
       infoView.msgPop;
   if)

-- selectFragmentGroup: DoPart --
do
   (if browser.currentProject[] = none then
       (# newProj, proj: ^browser.projects.project
       do
	  &browser.projects.project[]->newProj[];
	  fgName[]->newProj.location.puttext;
	  fgName[]->fragmentDefaultName->newProj.name[];
	  newProj[]->browser.projects.setupProject->proj[];
	  (if proj[]=NONE then
	      newProj[]->proj[]->browser.projects.theProjects.append;
	      browser.projectsChanged
	  if);
	  proj[]->browser.setProject
       #)
   if);
   browser.currentProject.groups.find
     (#
	predicate::  (#  do fgName[]->current.location.equalNCS->value #);
	notFound:: 
	  (# cp: ^browser.projects.project; newGroup: ^browser.projects.group
	  do
	     browser.currentProject[]->cp[];
	     &browser.projects.group[]->newGroup[];
	     fgName[]->newGroup.location.puttext;
	     fgName[]->fragmentDefaultName->newGroup.name[];
	     '+'->newGroup.name.prepend;
	     true->newGroup.temporary;
	     newGroup[]->browser.currentProject.groups.append;
	     projectsChanged;
	     (cp[],newGroup[])->browser.setGroup
	  #)
     do (browser.currentProject[],current[])->browser.setGroup
     #)  

-- selectFragmentForm: DoPart --
do
   fgName[]->selectFragmentGroup;
   (# t: @text; ff: ^MPS.ast.fragmentForm; 
   do
      (formName[],screen[])->browser.currentGroup.fg.open->ff[];
      (if ff[] = none then
	  'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
	    ->t.putformat (#  do formName[]->s; fgName[]->s #);
	  (none ,t[],'Warning')->alertUser
       else
	  (browser.currentProject[],browser.currentGroup[],ff[])
	    ->browser.setFragmentForm
      if)
   #)  

-- ymerOnAboutToClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->browsers.has then
       INNER onAboutToClose;
       (if okToClose then
	   (if ymerBrowserPrivate.geList.closeGroups then
	       THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
	       (if browsers.empty and onTerminateApplication then
		   terminate
		else
		   browsers.scan
		     (# 
		     do
			THIS(ymerBrowserWindow)[]
			  ->(current.theMenubar).windowsMenu.deleteWindow
		     #)
	       if)
	    else
	       false->okToClose
	   if)
       if)
   if)  

-- ymerClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->browsers.has then
       THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
       (if browsers.empty and onTerminateApplication then
	   terminate
	else
	   browsers.scan
	     (# 
	     do
		THIS(ymerBrowserWindow)[]
		  ->(current.theMenubar).windowsMenu.deleteWindow
	     #)
       if)
   if)

-- ymerCloseGroups: DoPart --
do ymerBrowserPrivate.geList.closeGroups->value  

-- ymerQuit: DoPart --
do
   (if (browsers.size = 1) and onTerminateApplication then
       terminate
    else
       THIS(ymerBrowserWindow).close
   if)

-- ymerOpen: Descriptor --
     (# t: ^text; w,h: @integer; 
     do
	browserTitle->t[];
	browserCount+1->browserCount;
	(if browserCount > 1 then (* this is not the first browser *)
	    '<'->t.put; browserCount->t.putint; '>'->t.put
	if);
	t[]->title;
	browser.open;
	ymerPrivate.edenv[]->edenv[]->browser.edenv[];
	browser.size->THIS(ymerBrowserWindow).size;
	INNER open;
	browsers.scan
	  (# 
	  do
	     THIS(ymerBrowserWindow)[]
	       ->(current.theMenubar).windowsMenu.insertWindow;
	     current[]->(theMenubar).windowsMenu.insertWindow
	  #);
	THIS(ymerBrowserWindow)[]->browsers.append
     #)  

-- browserOpen: DoPart --
do (# x,y: @integer; sz: @point; 
   do
      (sbprivate.initialWindowWidth,45)->sz;
      (sbprivate.outerctrl[],sz)->locationView.open;
      infoView.open;
      locationView[]->sbprivate.outerctrl.appendMember;
      locationView[]->sbprivate.outerctrl.fixedSize;
      sbprivate.outerctrl.appendsDone
   #)

-- ymerInit: Descriptor --
(# i: @integer; 
do
   hostType->machinetype;
   mps.init;
   1->i;
   l:
   (if (i+1->i) <= noOfArguments then
       (if true
        // '-mpsTrace'->(i->arguments).equalNCS then
           ll:
           (if (i+1->i) <= noOfArguments then
               (if true
                // 'fragmentOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'onParse'->(i->arguments).equalNCS then
                   (mps.AST.trace.onParse,true)->mps.AST.trace.set;
                   restart ll
                // 'topOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.topOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'compactOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.compactOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'grammars'->(i->arguments).equalNCS then
                   (mps.AST.trace.grammars,true)->mps.AST.trace.set;
                   restart ll
                // 'parsingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.parsingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'getnextComment'->(i->arguments).equalNCS then
                   (mps.AST.trace.getnextComment,true)->mps.AST.trace.set;
                   restart ll
                // 'editingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.editingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'parser'->(i->arguments).equalNCS then
                   (mps.AST.trace.parser,true)->mps.AST.trace.set;
                   restart ll
                // 'getBinding'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBinding,true)->mps.AST.trace.set;
                   restart ll
                // 'getBindingMark'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBindingMark,true)->mps.AST.trace.set;
                   restart ll
               if)
           if)
        // '-ymerhelp'->(i->arguments).equalNCS then
           'Ymer options are "-mpsTrace n1 ...", where ni is one of:'->putline;
           '  fragmentOpen: Trace mps fragmentOpen'->putline;
           '  onParse: Trace mps onParse'->putline;
           '  topOpen: Trace mps topOpen'->putline;
           '  compactOpen: Trace mps compactOpen'->putline;
           '  grammars: Trace mps grammars'->putline;
           '  parsingComments: Trace mps parsingComments'->putline;
           '  getnextComment: Trace mps getnextComment'->putline;
           '  editingComments: Trace mps editingComments'->putline;
           '  parser: Trace mps parser'->putline;
           '  getBinding: Trace mps getBinding'->putline;
           '  getBindingMark: Trace mps getBindingMark'->putline;
       if);
       restart l
   if);
   browsers.init;
   loadEditorEnv;
   ('BETA: Frequently Asked Questions (FAQ)',
    '~beta/doc/r3.1/faq/beta-language-faq.html')
     ->helpDocument;
   ('Ymer: Short Manual',
    '~beta/sourcebrowser/v1.0.1/doc/ymer.html')
     ->helpDocument;
   ('Ymer: Known Bugs and Inconveniences',
    '~beta/sourcebrowser/v1.0.1/doc/ymer.bugs')
     ->helpDocument;
   INNER init;
   userGrammarInit;
   &mps.AST.findGrammar[]->mps.AST.grammarMissing[];
   ymerPrivate.grammarTable.init;
#)  

-- ymerHelpDocument: DoPart --
do
   &ymerPrivate.helpDocuments.element[]->ymerPrivate.helpDocuments.append;
   title[]->(ymerPrivate.helpDocuments.last).elm.title[];
   path[]->(ymerPrivate.helpDocuments.last).elm.path[]

-- loadEditorEnv: DoPart --
do (# editorEnvWindow: @window; initHere: @boolean
   do
      objectPool.get
	(#
	   type:: editorEnvWindow.editorEnv;
	   init:: 
	     (# 
	     do
		true->inithere;
		(mps.ast[],mps.betaCFL[],THIS(ymerApplication)[])->obj.init
	     #)
	#)->ymerPrivate.edenv[];
      (* true->ymerPrivate.edenv.switch[8] trace history-list *)
   #)  

