ORIGIN '../ymer';
INCLUDE '~beta/basiclib/formatio'
        '~beta/sysutils/pathhandler'
        'fileEditor'
        'parseEditor'
        'sourcebrowserbody'
        'ymerFileUtils'
        'ymerPrivate'
        'separateCodeEditor'
        'searchActions'
        'help'
        '~beta/guienv/utils/tooltip'
        'mpsIntAdds'
        '~beta/mjolnertool/prefDialog/editoroptions';
BODY 'settings';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- LIB: Attributes --
trace_OpenURL: (#  exit false #);   

-- findOrCreateGroupEditor: DoPart --
do fg[]->browser.sbprivate.geList.findOrCreateGroupEditor->ge[]  

-- ymerbrowserWindowCreateInterface: DoPart --
do
   &ymerymerBrowserInterface[]->Interface[];
   THIS(guienv)[]->Interface.gui[];
   mps[]->Interface.mps[];
   THIS(ymerBrowserWindow)[]->Interface.ymerBrowser[];
   browser.infoView[]->Interface.infoView[];
   browser.locationView[]->Interface.locationView[];
   edenv[]->Interface.edenv[];
   ymer.browserCount+1->Interface.id  

-- ymerGroupDoRealOpen: DoPart --
do
   (if not g.isRealOpen then (* open g real *)
       none
         ->mps.AST.theCatcher[] (* to remove old exception handler - HACK *) ;
       doOpen: g.realOpen
         (#
            warn:
              (# msg: ^text
              enter msg[]
              do
                 (none ,msg[],'Warning')->alertUser;
                 none
                   ->mps.AST.theCatcher[]
                   (* to remove old exception handler - HACK *) ;
                 leave doOpen
              #);
            astOverflow::  (#  do msg[]->warn #);
            fragmentNotExisting::  (#  do msg[]->warn #);
            badFormat::  (#  do msg[]->warn #);
            grammarNotFound::  (#  do msg[]->warn #);
            doubleFormDeclaration::  (#  do msg[]->warn #);
            readAccessError::  (#  do msg[]->warn #);
            noSuchFileError::  (#  do msg[]->warn #);
            otherFileError::  (#  do msg[]->warn #);
            
         #)
   if)  

-- ymerGroupGetFg: DoPart --
do
   state.busy;
   'Opening '->browser.infoView.settext;
   location[]->browser.infoView.append;
   '... '->browser.infoView.append;
   browser.infoView.msgPush;
   (if not location.empty then
       location[]->mps.AST.expandToFullPath
         ->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (if fg[] <> none then fg[]->doRealOpen if)
   if);
   browser.infoView.msgPop;
   state.normal  

-- ymerGroupClose: DoPart --
do
   '!!ymerGroupClose called'->putline;
   (*   (if theForm[] = none then {* delete all history related to this group *}
    *        l: ymerBrowserPrivate.history.iterate
    *          (#
    *             where:: 
    *               (# 
    *               do (current.elm.theGroup.location[]->location.equal)->value
    *               #)
    *          do
    *             (if current.elm.theGroup.fg[]->ymerBrowserPrivate.geList.closeGroup
    *              then
    *                 current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
    *                 current[]->ymerBrowserPrivate.history.delete;
    *                 (if currentProject[] <> none then
    *                     none ->currentProject.lastGroupSelected[]
    *                 if);
    *                 (if currentGroup[] <> none then
    *                     none ->currentGroup.lastFormSelected[]
    *                 if);
    *                 (currentProject[],none )->setGroup;
    *                 none ->cge;
    *                 none ->browser.cfe;
    *                 none ->browser.cte[];
    *                 
    *              else
    *                 leave l
    *             if)
    *          #)
    *     else
    *    {* delete only history related to theForm in this group *}
    *        ymerBrowserPrivate.history.iterate
    *          (# where::  (#  do (current.elm.theForm[] = theForm[])->value #); 
    *          do
    *             current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
    *             current[]->ymerBrowserPrivate.history.delete;
    *             (if currentForm[] = theForm[] then
    *                 (currentProject[],currentGroup[],none )->setFragmentForm;
    *                 (if currentGroup[] <> none then
    *                     none ->currentGroup.lastFormSelected[]
    *                 if);
    *                 none ->browser.cfe;
    *                 none ->browser.cte[]
    *             if)
    *          #)
    *    if)  
    * 
    *)
     

-- scanGroupsImpl: DoPart --
do
   state.busy;
   'Opening '->browser.infoView.settext;
   location[]->browser.infoView.append;
   '... '->browser.infoView.append;
   browser.infoView.msgPush;
   dependencyInit;
   (if true
    // isProjectFile then
       (if not isLoaded then
       (* this is the first time we visit this projectFile - let's read it *)
           (location[],THIS(project)[])->theProjects.parseProjectFile; 
       if)
   if);
   l:
   (if true
    // isRoot then
       (if groups.size = 0 then (* this is the first time we visit this root *)
           &browser.projects.group[]->newGroup[];
           location[]->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else
       (* we have visited this root previously *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // isExtent then
       (if groups.size = 0 then
       (* the extent hasn't previously been calculated *)
           scanExtentLabel:
           location[]->mps.AST.expandToFullPath
             ->THIS(ymerBrowserWindow).mps.dg.scanExtent
               (#
                  warn: ^text;
                  MPSexception:: 
                    (# 
                    do
                       'MPS overflow - '->warn[];
                       T[]->warn.puttext;
                       ' too large)'->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       true->continue
                    #);
                  DoubleFormException::  (#  do true->continue #);
                  emptyFragmentException::  (#  do true->continue #);
                  transAccessException:: 
                    (# 
                    do
                       'No read access to: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       true->continue
                    #);
                  notExistingException:: 
                    (# 
                    do
                       'Not a fragment file: '->warn[];
                       fullFN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       leave l
                    #);
                  parseException:: 
                    (#
                       pe: @ymer.parseEditor
                         (#
                            parseOK::  (#  do fg.name->addProject #);
                            open:: 
                              (# 
                              do
                                 (600,800)->insetDisplay->size;
                                 fullFN[]->loadFiles
                              #)
                         #)
                    do
                       pe.open;
                       (*'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                        (NONE,warn[],'Dependency Graph Error')->alertUser;*)
                       true->continue;
                       leave scanExtentLabel
                    #);
                  transCreateDirException:: 
                    (# 
                    do
                       'Unable to create directory: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  circularDependencyException:: 
                    (# 
                    do
                       'Circular dependencies in the dependency graph: '
                         ->warn[];
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  unknownPropertyException:: 
                    (# 
                    do
                       'Unknown property: '->warn[];
                       n[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  noSpaceException:: 
                    (# 
                    do
                       'No space left on file system'->warn[];
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  fragmentException:: 
                    (# 
                    do
                       'Fragment Error: '->warn[];
                       errMsg[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  propertyException:: 
                    (# 
                    do
                       'Error in property: '->warn[];
                       p[]->warn.puttext;
                       ' in fragment: '->warn.puttext;
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  
               do
                  &browser.projects.group[]->newGroup[];
                  current.fullname->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects
        else
       (* the extent has previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // isDomain then
       (if groups.size = 0 then
       (* the domain hasn't previously been calculated *)
           scanDomainLabel:
           location[]->mps.AST.expandToFullPath
             ->THIS(YmerBrowserWindow).mps.dg.scanDomain
               (#
                  warn: ^text;
                  MPSexception:: 
                    (# 
                    do
                       'MPS overflow - '->warn[];
                       T[]->warn.puttext;
                       ' too large)'->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  emptyFragmentException::  (#  do true->continue #);
                  DoubleFormException::  (#  do true->continue #);
                  transAccessException:: 
                    (# 
                    do
                       'No read access to: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  notExistingException:: 
                    (# 
                    do
                       'Not a fragment file: '->warn[];
                       fullFN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  parseException:: 
                    (#
                       pe: @ymer.parseEditor
                         (#
                            parseOK::  (#  do fg.name->addProject #);
                            open:: 
                              (# 
                              do
                                 (600,800)->insetDisplay->size;
                                 fullFN[]->loadFiles
                              #)
                         #)
                    do
                       pe.open;
                       (* 'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                        * (NONE,warn[],'Dependency Graph Error')->alertuser;*)
                       true->continue;
                       leave scanDomainLabel
                    #);
                  transCreateDirException:: 
                    (# 
                    do
                       'Unable to create directory: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  circularDependencyException:: 
                    (# 
                    do
                       'Circular dependencies in the dependency graph: '
                         ->warn[];
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  unknownPropertyException:: 
                    (# 
                    do
                       'Unknown property: '->warn[];
                       n[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  noSpaceException:: 
                    (# 
                    do
                       'No space left on file system'->warn[];
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  fragmentException:: 
                    (# 
                    do
                       'Fragment Error: '->warn[];
                       errMsg[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  propertyException:: 
                    (# 
                    do
                       'Error in property: '->warn[];
                       p[]->warn.puttext;
                       ' in fragment: '->warn.puttext;
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  
               do
                  &browser.projects.group[]->newGroup[];
                  current.fullname->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects
        else
       (* the domain has previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       subprojects.size->putint
    // isDirectory then
       (if groups.size = 0 then
       (* the directory hasn't previously been scanned *)
             (# d: @directory; locationfullpath: ^text; 
             do
                THIS(Project).groups.clear;
                (if location.empty then
                    mps.ast.thepathhandler.currentDirectory->location.puttext; 
                if);
                location[]->mps.AST.expandToFullPath->d.name;
                d.scanEntries
                  (# error::  (#  do true->continue #)
                  do
                     select
                       (#
                          error::  (#  do true->continue #);
                          whenFile:: 
                            (# f: ^file; ext: ^Text; 
                            do
                               &browser.projects.group[]->newGroup[];
                               thefile->f[];
                               f.entry.path.name.suffix->ext[];
                               location[]->newGroup.location.puttext;
                               '/'->newGroup.location.put;
                               (if true
                                //
                                (foundfullpath->fileReadable)
                                and
                                (ext[]->mps.AST.grammarTable.legalExtension)
                                then
                                   f.entry.path.name.prefix->newGroup.name[]
                                     ->newGroup.location.puttext;
                                   (if groups.find
                                     (#
                                        predicate:: 
                                          (# 
                                          do
                                             current.location[]
                                               ->newGroup.location.equal->value
                                          #)
                                     #) = none then
                                       newGroup[]->groups.append;
                                       newGroup[]->thescan.foreach
                                   if)
                                //
                                showTxtFiles
                                and
                                (foundfullpath->fileReadable) then
                                   f.entry.path.name->newGroup.name[]
                                     ->newGroup.location.puttext;
                                   (if true
                                    // ((1->newGroup.name.inxGet) = '#')
                                    // ((1->newGroup.name.inxGet) = '.')
                                    //
                                    ((newGroup.name.length
                                        ->newGroup.name.inxGet) = '#')
                                    //
                                    ((newGroup.name.length
                                        ->newGroup.name.inxGet) = '~') then
                                    (* ignore *)
                                       
                                    else
                                       (if groups.find
                                         (#
                                            predicate:: 
                                              (# 
                                              do
                                                 current.location[]
                                                   ->newGroup.location.equal
                                                   ->value
                                              #)
                                         #) = none then
                                           true->newGroup.txtFile;
                                           ' (txt)'->newGroup.name.append;
                                           newGroup[]->groups.append;
                                           newGroup[]->thescan.foreach
                                       if)
                                   if)
                               if)
                            #)
                       #)
                  #);
                (if groups.size = 0 then
                    'no fragments in project'->browser.infoView.msg
                if)
             #)
        else
       (* the directory has previously been scanned *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // groups.size <> 0 then
       groups.scan (#  do current[]->thescan.foreach #); 
    else
       (if not unfolded then
           'open project to find subprojects'->browser.infoView.msg
        else
           'open subproject to find fragments'->browser.infoView.msg
       if)
   if);
   browser.infoView.msgPop;
   state.normal  

-- loadEditorEnv: DoPart --
do
     (# editorEnvWindow: @gui.window; initHere: @boolean
     do
        objectPool.get
          (#
             type:: editorEnvWindow.editorEnv;
             init:: 
               (# 
               do true->inithere; (mps.ast[],mps.betaCFL[],gui[])->obj.init; 
               #)
          #)->ymerPrivate.edenv[]
     #)  

-- ymerGroupRecheck: DoPart --
do
   fg.diskfilename->diskfile.name;
   fg.textfilename->textfile.name;
   false->allowReload;
   (if (textfile.name->fileExists) and
   ((textfile.name->fileModtime) > fg.modTime) then
       t.clear;
       'Source file: '->t.puttext;
       fg.textfilename->t.putline;
       'changed since last access'->t.putline;
       'The file must have been changed by some other application.'->t.putline;
       'Quit immediately (and restart) to avoid further problems'->t.puttext;
       (none ,t[],'Warning')->alertUser;
       false->allowReload (* should be true->allowReload *)
    else
       (if (diskfile.name->fileExists) and
       ((diskfile.name->fileModtime) > fg.modTime) then
           t.clear;
           'Group file: '->t.puttext;
           fg.diskfilename->t.putline;
           'changed since last access'->t.putline;
           'The file must have been changed by some other application.'
             ->t.putline;
           'Quit immediately (and restart) to avoid further problems'
             ->t.puttext;
           (none ,t[],'Warning')->alertUser;
           false->allowReload (* should be true->allowReload *)
       if)
   if);
   (if allowReload then
       'allowReload 544'->putline;
       (*Interface.currentGroup[]->cg[];
        (Interface.currentProject[],none )->setGroup;
        fg[]->ymerBrowserPrivate.geList.closeGroup;
        fg[]->MPS.reload;
        (currentProject[],cg[])->setGroup *)
       
   if)  

-- historyMenuLib: Attributes --
findAndSelect:
  (# node: ^astInterface.ast
  enter node[]
  do
     (if node[] <> none then
         (if browser.cfe[] <> none then
             (if node.frag[] <> (browser.cfe).frag[] then
                 browser.sbprivate.history.find
                   (#
                      predicate:: 
                        (#  do (current.theForm[] = node.frag[])->value #);
                      notFound:: 
                        (# 
                        do
                           ((node.frag.father).fullName,node.frag.name)
                             ->browser.selectFragmentForm
                        #)
                   do
                      (if current.theHirItem[] <> none then
                          current.theHirItem.select;
                          browser.sbprivate.hierarchyView.theScroller[]
                            ->current.theHirItem.scrollIntoView
                       else
                          (current.location[],current.theForm.name)
                            ->browser.selectfragmentform;
                          
                      if);
                      
                   #);
                 (if browser.cfe[] = none then 'cfe none'->putline if);
                 (if not (browser.cfe).theSifTexteditor.textediting then
                     (node[],1,0,0)->(browser.cfe).setFocus
                  else
                     (none ,'Cannot reestablish focus - text edit active',
                      'History')->noteUser
                 if)
              else
                 (node[],1,0,0)->(browser.cfe).setFocus
             if)
          else
             ((node.frag.father).fullName,node.frag.name)
               ->browser.selectFragmentForm;
             (if not (browser.cfe).theSifTexteditor.textediting then
                 (node[],1,0,0)->(browser.cfe).setFocus
              else
                 (none ,'Cannot reestablish focus - text edit active','History')
                   ->noteUser
             if)
         if)
      else
         (none ,'Should not happen - node[] is none!','History')->alertUser
     if);
     Interface.theToolbar.statechanged
  #);
goBack:
  (# 
  do
     edenv.history.protect
       (#  do (browser.cfe).cs.node[]->edenv.history.back->findAndSelect #);
     
  #);
backPossible:
  (# result: @boolean; 
  do
     ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
      ((browser.cfe).cs.node[] <> none ) and
      ((browser.cfe).cs.node[]->edenv.history.BackPossible))->result
  exit result
  #);
goforward:
  (# 
  do
     edenv.history.protect
       (# 
       do (browser.cfe).cs.node[]->edenv.history.forward->findAndSelect
       #)
  #);
forwardpossible:
  (# result: @boolean; 
  do
     ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
      ((browser.cfe).cs.node[] <> none ) and
      ((browser.cfe).cs.node[]->edenv.history.forwardPossible))->result
  exit result
  #);
back: menuItem
  (#
     eventhandler:: 
       (#
          onStatus::  (#  do backPossible->value #);
          onSelect::  (#  do goBack #)
       #);
     open::  (#  do 'Back'->name; 'b'->key #)
  #);
forward: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
                ((browser.cfe).cs.node[] <> none ) and
                ((browser.cfe).cs.node[]->edenv.history.forwardPossible))->value
            #);
          onSelect:: 
            (# 
            do
               edenv.history.protect
                 (# 
                 do
                    (browser.cfe).cs.node[]->edenv.history.forward
                      ->findAndSelect
                 #)
            #)
       #);
     open::  (#  do 'Forward'->name; 'f'->key #)
  #);
historyMenuItem: menuItem
  (#
     theHist: ^browser.sbprivate.history.element;
     eventhandler:: 
       (#
          onSelect:: 
            (# 
            do
            (*(theHist.theProject[],theHist.theGroup[],theHist.theForm[])
             ->browser.setFragmentForm*)
               (if theHist.theHirItem[] <> none then
                   theHist.theHirItem.select;
                   browser.sbprivate.hierarchyView.theScroller[]
                     ->theHist.theHirItem.scrollIntoView
                else
               (* '/home/gram/beta/r5.2/sourcebrowser/private/ymerBody.bet: Line 684'
                ->screen.putline;*)
                   (theHist.location[],theHist.theForm.name)
                     ->browser.selectfragmentform
               if)
            #)
       #);
     setName:
       (# t: ^text; 
       do
          (theHist.location[],true)->browser.sbprivate.history.names.uniqName
            ->t[];
          '-'->t.append;
          theHist.theForm.name->t.append;
          t[]->name
       #)
  #);
addHistoryElement:
  (# theHist: ^browser.sbprivate.history.element; newHitem: ^historyMenuItem
  enter theHist[]
  do
     (if not protected then
         &historyMenuItem[]->newHitem[];
         newHitem.open;
         theHist[]->newHitem.theHist[];
         newHitem[]->append;
         updateNames;
         
     if)
  #);
updateNames: scan
  (# theHitem: ^historyMenuItem
  do
     (if current## <= historyMenuItem## then
         current[]->theHitem[]; theHitem.setname
     if)
  #);
closeHistoryElement:
  (#
     oldElement: ^browser.sbprivate.history.element;
     theHitem: ^historyMenuItem
  enter oldElement[]
  do
     l: scan
       (# 
       do
          (if current## <= historyMenuItem## then
              current[]->theHitem[];
              (if theHitem.theHist[] = oldElement[] then
                  theHitem[]->historyMenu.delete; leave l
              if)
          if)
       #)
  #);
protect:
  (# status: @boolean
  do protected->status; true->protected; INNER protect; status->protected
  #)  

-- historyMenuOpen: DoPart --
do
   'History'->name;
     (# item: ^menuItem
     do
        &back[]->item[];
        item.open;
        item[]->append;
        &forward[]->item[];
        item.open;
        item[]->append;
        &separator[]->item[];
        item.open;
        item[]->append
     #)  

-- browserSelectNode: DoPart --
do
   (if true
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and separate then
       (theEditorRoot.frag[],node[])->viewSeparate
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
        (theEditorRoot.frag.name).copy)->selectFragmentForm;
       (if (browser.cfe) <> none then
           node[]->(browser.cfe).setNode
        else
           (theMenubar).windowsmenu.istatus.theeventhandler.onselect
       if)
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and separate then
       (theEditorRoot[],node[])->(browser.cfe).openSubeditor
    //
    (not (theEditorRoot.frag.root[]->theEditorRoot.equal))
    and
    not
    separate then
       (((theEditorRoot.frag.father).fullName).copy,
        (theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->(browser.cfe).setNode
   if);
   Interface.theToolbar.statechanged  

-- browserFileEdit: DoPart --
do
     (#
        se: @streamEditor
          (#
             setTitle:: 
               (# 
               do
                  'Text file editor for '->t[];
                  f.name->fragmentDefaultName->t.append;
                  
               #);
             openRead:: 
               (# t: ^text
               do
                  (if f.name->fileAvailable then
                      f.openRead; true->value
                   else
                      'No read permissions to the file:\n     '->t[];
                      f.name->fragmentDefaultName->t.puttext;
                      (se[],t[],'Read Error')->alertUser;
                      false->value
                  if)
               #);
             openWrite:: 
               (# t: ^text
               do
                  (if (f.name->fileExists) and (f.name->fileWriteable) then
                      f.openWrite; true->value
                   else
                      'No write permissions to the file:\n     '->t[];
                      f.name->fragmentDefaultName->t.puttext;
                      (se[],t[],'Write Error')->alertUser;
                      false->value
                  if)
               #);
             closeStream::  (#  do f.close #);
             open::  (#  do (600,800)->insetDisplay->size #)
          #);
        f: @file;
        t: ^text
     do
        se.open;
        se.bringToFront;
        filename[]->mps.AST.expandtofullpath->f.name;
        f[]->se.loadStream;
        
     #)  

-- LookForDocDir: Descriptor --
(# entry: @diskentry; 
do
   ('~beta/doc/','')->mps.ast.thepathhandler.convertFilePath->entry.path;
   entry.exists and entry.isdirectory and entry.readable->doc_dir_present
#)  

-- OpenURL: DoPart --
do (* Check for local file *)
   cursors.watch[]->mouse.busyCursor;
   (if trace_openURL then
       'OpenURL: '->screen.puttext; path[]->screen.putline; 
   if);
   (if not is_doc_url then
       path.copy->url[]; 
    else
       (if use_local_files and doc_dir_present then
             (# entry: @diskentry; 
             do
                ('~beta/doc/'->(path.copy).prepend,'')
                  ->mps.ast.thepathhandler.convertFilePath->entry.path;
                (if trace_openURL then
                    'try: '->screen.puttext; entry.path->screen.putline; 
                if);
                (if entry.exists and entry.isfile and entry.readable then
                    entry.path->url[];
                    DirectoryChar
                      ->url.findAll (#  do ('/',inx)->url.inxPut #);
                    (if (1->url.inxget) <> '/' then '/'->url.prepend;  if);
                    'file://'->url.prepend;
                    
                if);
                
             #);
           
       if);
       (if url[] = none then
           'http://www.mjolner.com/mjolner-system/documentation/'
             ->(path.copy).prepend->url[];
           
       if)
   if);
   (if trace_openURL then
       'open: '->screen.puttext; url[]->screen.putline; 
   if);
   (* Possibly need to add this:
    *   DirectoryChar->url.findAll(# do ('/',inx)->url.inxPut #);
    * to make url contain just forward slashes on Windows platforms.
    *)
   'Opening Web Browser for '->browser.infoView.settext;
   url[]->browser.infoView.append;
   ' ... '->browser.infoView.append;
   browser.infoView.msgPush;
   url[]->startBrowser;
   browser.infoView.msgPop;
   none ->mouse.busyCursor  

-- ymerMPSonGroupNotFound: DoPart --
do
   INNER onGroupNotFound;
   (if not doneInInner then
       'Fragment: '->t.puttext;
       groupName[]->t.puttext;
       ' does not exist.'->t.putline;
       'Fragment ignored'->t.puttext;
       (none ,t[],'Notification')->gui.alertUser;
       true->continue
   if)  

-- ymerMPSonOldGroup: DoPart --
do
   INNER onOldGroup;
   true->allowParsing;
   'Parsing '->putText;
   groupName[]->putLine;
   true->continue;
     

-- ymerMPSparseerrors: DoPart --
do
   true->continue;
     (#
        pe: @parseEditor
          (#
             parseOK:: 
               (# 
               do
                  (if (newBrowserCallBack[] <> none ) and
                  (newBrowserCallBack.browserInt[] <> none ) then
                      fg.name->newBrowserCallBack.browserInt.addProject
                  if)
               #);
             open:: 
               (# 
               do (600,800)->insetDisplay->size; groupName[]->loadFiles
               #)
          #)
     do pe.open
     #)  

-- ymerMPSonReadError: DoPart --
do
   true->continue;
   (none ,errorText[],'Error during reading of group')->gui.alertUser  

-- ymerMPSonOtherError: DoPart --
do
   INNER onOtherError;
   true->continue;
   (if not doneInInner then
       (none ,errorText[],'Error during opening of group')->gui.alertUser;
       true->continue
   if)  

-- ymerLoadProject: DoPart --
do
(* (if true
 *     // proj.isDirectory // proj.isDotDotDirectory // proj.isRoot
 *     // proj.isExtent // proj.isDomain then
 * 	 (#  t: ^text;
 * 	 do
 * 	    {*&browser.projects.project[]->newProj[];
 * 	    proj.location.copy->newProj.location.puttext;
 * 	    (if (newProj[]->browser.projects.setupProject) = none then
 * 		proj.isDirectory->newproj.isDirectory;
 * 		proj.isRoot->newProj.isRoot;
 * 		proj.isExtent->newProj.isExtent;
 * 		proj.isDomain->newProj.isDomain;
 * 		newProj[]->browser.projects.theProjects.append
 * 	    if);
 * 	    'Browser on: '->t[];
 * 	    newProj.name[]->t.append;
 * 	    (if true
 * 	     // proj.isExtent then
 * 		' [extent]'->t.append
 * 	     // proj.isDomain then
 * 		' [domain]'->t.append
 * 	    if);
 * 	    t[]->title*}
 * 	 #)
 *     // proj.isProjectFile // proj.hasSubprojects then
 * 	 (# t: ^text
 * 	 do
 * 	    proj.subprojects.scan
 * 	      (#
 * 	      do
 * 		 current.copy->browser.projects.theProjects.append;
 * 		 none ->current.superProject[]
 * 	      #);
 * 	    'Browser on: '->t[];
 * 	    proj.name[]->t.append;
 * 	    t[]->title
 * 	 #)
 *    if);
 *    browser.projectsChanged
 * 
 *)   

-- projectMenuLoaddp: DoPart --
do
   fileSelectionDialog
     (# 
     do
        (if theTitle[] <> none then
            theTitle[]->title[]
         else
            'Load Project File'->title[]
        if)
     #)->t[];
   (if t[] <> none then
   (*(t[],'/fzvsvsvs')->mps.ast.thepathhandler.localpath->fragmentForeName
    ->selectFragmentGroup*)
       t[]->mps.ast.expandtoFullpath->appendProject
   if)  

-- ymerAddProject: DoPart --
do location[]->appendProject; appendDone  

-- ymerAppendProject: DoPart --
do
     (#
        grp: ^browser.sbprivate.hierarchyview.hir.group;
        testFileName:
          (# f: @file; ext,filename,warntext: ^text; result: @boolean
          enter f.name
          do
             f.name->fragmentForeName->filename[];
             mps.ast.grammarTable.scanExtensions
               (# tempfilename: ^text
               do
                  filename.copy->tempfilename[];
                  currentExtension[]->tempfilename.append;
                  tempfilename[]->f.name;
                  (if f.entry.exists then true->result if)
               #);
             (if result then
                 (filename[],true)->browser.addToUsedGroups;
                 browser.onCurrentGroupChange
              else
                 'Neither '->warntext[];
                 filename[]->mps.ast.expandtofullpath->warntext.puttext;
                 '.bet'->warntext.putline;
                 'nor '->warntext.append;
                 filename[]->mps.ast.expandtofullpath->warntext.puttext;
                 mps.ast.astFileExtension->warntext.putline;
                 'could be found'->warntext.putline;
                 (none ,warntext[],'File open error')->alertUser
             if)
          exit result
          #)
     do location.copy->testFileName; 
     #)  

-- ymerAppendDone: DoPart --
do
     (#
        grp: ^browser.sbprivate.hierarchyview.hir.group;
        itm: ^browser.sbprivate.hierarchyview.hir.item;
        
     do
        ((browser.sbprivate.hierarchyview.hir.root).items.last).elm[]->itm[];
        (if itm## = browser.sbprivate.hierarchyview.hir.group## then
            itm[]->grp[];
            grp.onexpand;
            grp.select;
            (*(if grp.items.size>1 then
             (grp.items.head).succ.elm.select
             else
             grp.select
             if)*)
            
        if)
     #)
     (* 
      * -- ymerGroupClose: DoPart --
      * do
      *    (if theForm[] = none then {* delete all history related to this group *}
      *        l: browser.sbprivate.history.iterate
      * 	 (#
      * 	    where::
      * 	      (#
      * 	      do (current.elm.theGroup.location[]->location.equal)->value
      * 	      #)
      * 	 do
      * 	    (if current.elm.theGroup.fg[]->browser.sbprivate.geList.closeGroup
      * 	     then
      * 		current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
      * 		current[]->browser.sbprivate.history.delete;
      * 		(if currentProject[] <> none then
      * 		    none ->currentProject.lastGroupSelected[]
      * 		if);
      * 		(if currentGroup[] <> none then
      * 		    none ->currentGroup.lastFormSelected[]
      * 		if);
      * 		(currentProject[],none )->setGroup;
      * 		none ->cge[];
      * 		none ->browser.cfe;
      * 		none ->browser.cte[];
      * 
      * 	     else
      * 		leave l
      * 	    if)
      * 	 #)
      *     else
      *    {* delete only history related to theForm in this group *}
      *        browser.sbprivate.history.iterate
      * 	 (# where::  (#  do (current.elm.theForm[] = theForm[])->value #);
      * 	 do
      * 	    current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
      * 	    current[]->browser.sbprivate.history.delete;
      * 	    (if currentForm[] = theForm[] then
      * 		(currentProject[],currentGroup[],none )->setFragmentForm;
      * 		(if currentGroup[] <> none then
      * 		    none ->currentGroup.lastFormSelected[]
      * 		if);
      * 		none ->browser.cfe[];
      * 		none ->browser.cte[]
      * 	    if)
      * 	 #)
      *    if)
      * 
      *)  

-- browserLib: Attributes --
(* setupRootProject:
 *   (# proj,root,existing: ^project
 *   enter proj[]
 *   do
 *      {*projects.theProjects.find
 *        (#
 * 	  predicate::
 * 	    (#  do current.location[]->proj.location.equal->value #)
 *        #)->existing[];*}
 *      (if existing[] = none then
 * 	 (if (proj.name.length->proj.name.inxGet) <> '*' then
 * 	     '*'->proj.name.append
 * 	 if);
 * 	 true->proj.isRoot;
 * 	 proj[]->root[];
 * 	 {*&browser.projects.project[]->proj[];*}
 * 	 root.location->proj.location;
 * 	 true->proj.isDomain;
 * 	 '[domain]'->proj.name[];
 * 	 root[]->proj.superProject[];
 * 	 proj[]->root.subprojects.append;
 * 	 {*&browser.projects.project[]->proj[];*}
 * 	 root.location->proj.location;
 * 	 true->proj.isExtent;
 * 	 '[extent]'->proj.name[];
 * 	 root[]->proj.superProject[];
 * 	 proj[]->root.subprojects.append;
 * 
 *      if)
 *   exit existing[]
 *   #);
 * 
 *)
(* 
 * setupDotDot:
 *   (#
 *      proj: ^browser.projects.project;
 *      projPos: ^projects.theProjects.theCellType;
 *      d: @directory;
 *      location: ^text;
 *      level: @integer;
 *      superProject,superSuperProject: ^browser.projects.project;
 *      createParentProject:
 *        (# newProj: ^browser.projects.project
 *        do
 * 	  (if location.length > 0 then
 * 	      &browser.projects.project[]->newProj[];
 * 	      location->newProj.location;
 * 	      true->newProj.isDirectory;
 * 	      newProj[]->browser.projects.setupProject;
 * 	      (newProj[],superProject[]->browser.projects.theProjects.at)
 * 		->browser.projects.theProjects.insertBefore;
 * 	      superProject.level->newProj.level;
 * 	      (for newProj.level repeat '  '->newProj.name.prepend for);
 * 	      superProject.level+1->superProject.level;
 * 	      '  '->superProject.name.prepend;
 * 	      l:
 * 	      (superProject[]->browser.projects.theProjects.at).succ[]
 * 		->browser.projects.theProjects.iterateFrom
 * 		  (#
 * 		  do
 * 		     (if current.elm.level >= superProject.level then
 * 			 current.elm.level+1->current.elm.level;
 * 			 '  '->current.elm.name.prepend;
 * 
 *
 * 		      else
 * 			 leave l
 * 		     if)
 * 		  #);
 * 	      superProject.subprojects.clear;
 * 	      true->newProj.unfolded;
 * 	      newProj[]->foldSubprojects;
 * 	      newProj[]->unfoldSubprojects;
 * 	      browser.projectsChanged;
 * 	      newProj[]->browser.setProject
 * 	  if)
 *        #)
 *   enter proj[]
 *   do
 *   {* we now have to create a new project to contain the parent
 *    * directory of currentDirectory
 *    *}
 *      proj.location.copy->location[];
 *      proj.superProject[]->superProject[];
 *      (if superProject[] <> none then
 * 	 superProject.level->level;
 * 	 superProject.superProject[]->superSuperProject[];
 * 	 (if superSuperProject[] <> none then
 * 	     (if superSuperProject.isDirectory then
 * 	     {* this is the .. directory - select it *}
 * 		 superSuperProject[]->setProject;
 * 	      else
 * 	     {* try to locate the '..' project in
 * 	      * superSuperProject
 * 	      *}
 * 		 l:
 * 		   (#
 * 		   do
 * 		      superSuperProject.subprojects.iterate
 * 			(#
 * 			do
 * 			   (if current.elm.location[]->location.equal then
 * 			       current.elm[]->setProject; leave l
 * 			   if)
 * 			#);
 * 		      {* not found - create it *}
 * 		      createParentProject
 * 		   #)
 * 	     if)
 * 	  else
 * 	 {* OK, we are 'on the top'.  Try those *}
 * 	     l:
 * 	       (#
 * 	       do
 * 		  browser.projects.theProjects.iterate
 * 		    (#
 * 		       where::  (#  do (current.elm.level = level)->value #)
 * 		    do
 * 		       (if current.elm.location[]->location.equal then
 * 			   current.elm[]->setProject; leave l
 * 		       if)
 * 		    #);
 * 		  {* not found - create it *}
 * 		  createParentProject
 * 	       #)
 * 	 if)
 *     if)
 *   #);
 * 
 *)   

-- onProjectListOpen: DoPart --
do INNER  

-- onGroupListOpen: DoPart --
do INNER  

-- onFragmentgroupViewOpen: DoPart --
do INNER  

-- onCurrentProjectChange: DoPart --
do
(* laver setcp paa dp project, giver andet project end tracetest!!! => cfe er none,
 kan lave setcp paa tracetest eller vaelge group + form igen
 *)
   (if newProject[] <> none then
       newProject.location[]->fragmentForename->browser.locationView.msg
   if);
   newProject[]->Interface.CurrentProject[];
   none ->Interface.CurrentGroup[];
   none ->Interface.CurrentForm[];
   none ->cge;
   none ->browser.cfe;
   none ->browser.cte[];
   none ->browser.sbprivate.hierarchyView.hir.selectedFG[];
   Interface.sifExternalInterface.onBrowserSelectionChanged;
   browser.sbprivate.tb.statechanged  

-- onCurrentGroupChange: DoPart --
do
   (if true
    // newGroup[] <> none then
       (if newGroup.fg[] <> none then
           newGroup.fg[]->browser.sbprivate.geList.findOrCreateGroupEditor->cge;
           none ->browser.cte[]
       if);
       newGroup.location[]->fragmentForename->browser.locationView.msg
    // cte[] <> none then
       none ->cge; cte.path->browser.locationView.msg
   if);
   Interface.sifExternalInterface.onBrowserSelectionChanged;
   browser.sbprivate.tb.statechanged  

-- onCurrentFormChange: DoPart --
do
   (if newForm[] = none then
       browser.sbprivate.sourceview.popdown
    else
       state.busy;
       'Opening '->browser.infoView.settext;
       newForm.name->browser.infoView.append;
       '... '->browser.infoView.append;
       browser.infoView.msgPush;
       (if false and debugSourceBrw then
           'history is:'->putline;
           browser.sbprivate.history.scan
             (#  do current.theForm.print #);
           'Looking for:'->puttext;
           newform.print
       if);
       browser.sbprivate.history.find
         (#
            predicate::  (#  do (current.theForm[] = newForm[])->value #);
            notFound:: 
              (# newHist: ^browser.sbprivate.history.element; 
              do
                 &browser.sbprivate.history.element[]->newHist[];
                 (* browser.currentProject[]->newHist.theProject[]; *)
                 (* browser.currentGroup[]->newHist.theGroup[]; *)
                 (newForm.father).Name->newHist.location[];
                 newForm[]->newHist.theForm[];
                 newHist[]->browser.sbprivate.history.add;
                 newHist[]->(theMenubar).historyMenu.addHistoryElement;
                 newForm[]->browser.sbprivate.sourceview.newfragment
                   ->(newHist.theCfe[],newHist.theView[]);
                 (* browser.sbprivate.hierarchyView.hir.selection[]->newHist.theHirItem[]; *)
                 newHist.theCfe[]->browser.cfe;
                 none ->browser.cte[];
                 (* not necessary as newfragment does a popup!! *)
                 (* newHist.theView[]->browser.sbprivate.sourceview.popup; *)
                 
              #)
         do
            current.theCfe[]->browser.cfe;
            none ->browser.cte[];
            newForm.fullname->current.theView.label;
            (* form name might have been changed  *)
            current.theView[]->browser.sbprivate.sourceview.popup;
            (browser.cfe).cs->(browser.cfe).setFocus
         #);
       browser.infoView.msgPop;
       state.normal
   if);
   browser.sbprivate.tb.statechanged;
   Interface.sifExternalInterface.onBrowserSelectionChanged  

-- ymerOnAboutToClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->ymer.browsers.has then
       INNER onAboutToClose;
       (if okToClose then
           (if browser.sbprivate.geList.closeGroups and
           browser.sbprivate.sourceview.aeList.closeAsciiEditors then
               THIS(ymerBrowserWindow)[]->ymer.browsers.at
                 ->ymer.browsers.delete;
               (if ymer.browsers.empty and onTerminateApplication then
                   terminate
                else
                   ymer.browsers.scan
                     (# browser: ^ymerBrowserWindow
                     do
                        current[]->browser[];
                        THIS(ymerBrowserWindow)[]
                          ->(browser.theMenubar).windowsMenu.deleteWindow
                     #)
               if)
            else
               false->okToClose
           if)
       if)
   if)  

-- ymerClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->ymer.browsers.has then
       THIS(ymerBrowserWindow)[]->ymer.browsers.at->ymer.browsers.delete;
       (if ymer.browsers.empty and onTerminateApplication then
           terminate
        else
           ymer.browsers.scan
             (# browser: ^ymerBrowserWindow
             do
                current[]->browser[];
                THIS(ymerBrowserWindow)[]
                  ->(browser.theMenubar).windowsMenu.deleteWindow
             #)
       if)
   if)  

-- ymerCloseGroups: DoPart --
do browser.sbprivate.geList.closeGroups->value  

-- ymerQuit: DoPart --
do
   true->okToClose;
   INNER ;
   l:
   (if okToClose then
       (if browser.sbprivate.hierarchyview.hir.usedGroups.hasChanged and
       (browser.sbprivate.hierarchyview.hir.usedGroups.originalproject[] <> none
        ) then
             (# errtext: ^text; 
             do
                'The "Recent Files" project has changed'->errtext[];
                ', save in file:\n'->errText.append;
                browser.sbprivate.hierarchyview.hir.usedGroups.originalproject[]
                  ->errtext.append;
                '?'->errText.append;
                (none ,'Save Project?',errText[])
                  ->promptForBoolean
                    (#
                       ok:: 
                         (# 
                         do
                            browser.sbprivate.hierarchyview.hir.usedGroups.
                              originalproject[]
                              ->
                                browser.sbprivate.hierarchyview.hir.usedGroups.
                                  SaveProjectFileAs
                         #);
                       cancel::  (#  do leave l #)
                    #)
             #)
       if);
       (if (ymer.browsers.size = 1) and onTerminateApplication then
           terminate
        else
           (if okToClose then THIS(ymerBrowserWindow).close if)
       if)
   if)  

-- ymerOpen: Descriptor --
(# t: ^text; x,y: @integer
do
   browserTitle->t[];
   ymer.browserCount+1->ymer.browserCount;
   (if ymer.browserCount > 1 then (* this is not the first browser *)
       '<'->t.put; ymer.browserCount->t.putint; '>'->t.put
   if);
   t[]->title;
   mps[]->browser.mps[];
   browser.open;
   ymer. (*GRAM*) ymerPrivate.edenv[]->edenv[]->browser.edenv[];
   (800,800)->insetDisplay->THIS(ymerBrowserWindow).size;
   THIS(ymerBrowserWindow).position->(x,y);
   (x+40,y+40)->THIS(ymerBrowserWindow).position;
   INNER open;
   browser.sbprivate.hierarchyView.hir.changed;
   hide
#)  

-- browserOpen: DoPart --
do loadSettings  

-- ymerInit: Descriptor --
(# i: @integer; 
do
   1->i;
   l:
   (if (i+1->i) <= noOfArguments then
       (if true
        // '--mpsTrace'->(i->arguments).equalNCS then
           ll:
           (if (i+1->i) <= noOfArguments then
               (if true
                // 'fragmentOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'fragmentClose'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentClose,true)->mps.AST.trace.set;
                   restart ll
                // 'onParse'->(i->arguments).equalNCS then
                   (mps.AST.trace.onParse,true)->mps.AST.trace.set; restart ll
                // 'topOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.topOpen,true)->mps.AST.trace.set; restart ll
                // 'compactOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.compactOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'grammars'->(i->arguments).equalNCS then
                   (mps.AST.trace.grammars,true)->mps.AST.trace.set; restart ll
                // 'parsingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.parsingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'getnextComment'->(i->arguments).equalNCS then
                   (mps.AST.trace.getnextComment,true)->mps.AST.trace.set;
                   restart ll
                // 'editingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.editingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'parser'->(i->arguments).equalNCS then
                   (mps.AST.trace.parser,true)->mps.AST.trace.set; restart ll
                // 'getBinding'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBinding,true)->mps.AST.trace.set;
                   restart ll
                // 'getBindingMark'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBindingMark,true)->mps.AST.trace.set;
                   restart ll
               if)
           if)
        // '--ymerhelp'->(i->arguments).equalNCS then
           'Ymer options are "--mpsTrace n1 ...", where ni is one of:'->putline;
           '  fragmentOpen: Trace mps fragmentOpen'->putline;
           '  onParse: Trace mps onParse'->putline;
           '  topOpen: Trace mps topOpen'->putline;
           '  compactOpen: Trace mps compactOpen'->putline;
           '  grammars: Trace mps grammars'->putline;
           '  parsingComments: Trace mps parsingComments'->putline;
           '  getnextComment: Trace mps getnextComment'->putline;
           '  editingComments: Trace mps editingComments'->putline;
           '  parser: Trace mps parser'->putline;
           '  getBinding: Trace mps getBinding'->putline;
           '  getBindingMark: Trace mps getBindingMark'->putline;
           
       if);
       restart l
   if);
   mps.init;
   browsers.init;
   loadEditorEnv;
   (*gram loadEnvironments; *)
   (*('BETA: Frequently Asked Questions (FAQ)',
    '~beta/doc/faq/beta-language-faq.html')->helpDocument;
    ('Ymer: Short Manual','~beta/sourcebrowser/doc/ymer.html')
    ->helpDocument;
    ('Ymer: Known Bugs and Inconveniences',
    '~beta/sourcebrowser/doc/ymer.bugs')->helpDocument;*)
   INNER init;
   userGrammarInit;
   &logWindow[]->logwin[];
   logwin.open
#)  

-- ymerMPSinit: DoPart --
do
   dg.init;
   dg.xverboselevel.nothing->dg.xverboselevel;
   machine_type->dg.TargetMachine[];
   machine_type->dg.TargetDirectory[];
   INNER
   (*-- ymerHelpDocument: DoPart --
    do
    &ymenv.private.helpDocuments.element[]->ymenv.private.helpDocuments.append;
    title[]->(ymenv.private.helpDocuments.last).elm.title[];
    path[]->(ymenv.private.helpDocuments.last).elm.path[]
    *)
   (*-- loadEnvironments: DoPart --
    do
    (# editorEnvWindow: @window
    do
    objectPool.get
    (#
    type:: ymerEnv
    #)->ymenv[];
    
    objectPool.get
    (#
    type:: editorEnvWindow.editorEnv;
    init::
    (#
    do
    (mps.ast[],mps.betaCFL[],THIS(ymerApplication)[])->obj.init
    #)
    #)->edenv[];
    edenv[]->ymenv.private.edenv[]
    #)
    *)  

-- ymerNewBrowserDopart: DoPart --
do
   &gui.ymerbrowserWindow[]->browserWindow[];
   (THIS(ymerEnv)[],mps[])->browserWindow.init;
   browserWindow.createInterface->browserInt[];
   browserInt[]->browserWindow.browser.Interface[];
   browserWindow.open;
   (* window is hided, to avoid menu flicker *)
   browserWindow.edenv[]->browserInt.edenv[];
   (browserWindow[],browserInt[])->newBrowserCallBack;
   (if newBrowserCallBack.ymerCallBack[] <> none then
   (* we allways use the ymercall from the first browser, until this is closed *)
       (if browserWindow.edenv.ymerCallBack[] = none then
           newBrowserCallBack.ymerCallBack[]->browserWindow.edenv.ymercallback[]
             ->browserWindow.myYmerCall[]
       if)
    else
       'YmerCallback is none !!!'->screen.putline;
       &ymerCall[]->browserWindow.edenv.ymerCallBack[]
         ->browserWindow.myYmerCall[]
   if);
   (* browserWindow.themenubar->bwm[];  *)
   &browserWindow.MenubarType[]->bwm[];
   bwm.open;
   bwm.fileMenu.open
     (# 
     do fileMenuActionList.scan (#  do bwm.filemenu[]->current #); 
     #);
   bwm.fileMenu[]->bwm.append;
   MenuActionList.scan
     (#  do (BrowserInt[],bwm[])->current #);
   (*bwm.projectMenu.setup;*)
   bwm.historyMenu.setup;
   bwm.windowsMenu.setup;
   bwm.helpMenu.setup;
   browsers.scan
     (# browser: ^gui.ymerBrowserWindow
     do
        current[]->browser[];
        browserWindow[]->(browser.theMenubar).windowsMenu.insertWindow;
        browser[]->bwm.windowsMenu.insertWindow
     #);
   BrowserWindow[]->browsers.append;
   bwm[]->browserWindow.themenubar;
   browserWindow.show;
   INNER ;
   (* show hided window *)
   fileMenuActionList.clear  

-- ymerEndOpenParseEditor: Descriptor --
(#
   pe: @parseEditor
     (#
        parseOK:: 
          (# 
          do
             (if (newBrowserCallBack[] <> none ) and
             (newBrowserCallBack.browserInt[] <> none ) then
                 fg.name->newBrowserCallBack.browserInt.addProject
             if)
          #);
        open::  (#  do (x,y)->size; fn[]->loadFiles #)
     #)
do pe.open
#)  

-- setuptoolb: DoPart --
do
     (#
        back: pixmaptool
          (#
             onEnable:: 
               (#  do (themenubar).historymenu.backPossible->enable #);
             onSelect:: 
               (# 
               do
                  (if (themenubar).historymenu.backPossible then
                      (themenubar).historymenu.goBack
                  if)
               #)
          #);
        frwd: pixmaptool
          (#
             onEnable:: 
               (#  do (themenubar).historymenu.forwardPossible->enable #);
             onSelect:: 
               (# 
               do
                  (if (themenubar).historymenu.forwardpossible then
                      (themenubar).historymenu.goforward
                  if)
               #)
          #);
        up: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do ((cfe) <> none ) and (not (cfe).cs.isSlot)->enable
               #);
             onSelect:: 
               (# 
               do
                  (cfe).doCommand
                    (# ccfe: ^codeeditor; node: ^astInterface.ast
                    do
                       (cfe)->ccfe[];
                       (if ccfe.thisGroupEditor[] <> none then
                           ccfe.frag[]->ccfe.thisGroupEditor.searchSLOT->node[];
                           (if node[] <> none then
                               (node[],node[],false)
                                 ->ccfe.selectNodeInFormEditor
                           if)
                       if)
                    #)
               #)
          #);
        follow: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do ((cfe) <> none ) and (not (cfe).frag.locked)->enable
               #);
             onSelect::  (#  do (cfe).doDetail #)
          #);
        check: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do
                  ((Interface.currentGroup[] <> none ) and
                   (not edenv.textediting))->enable
               #);
             onSelect:: 
               (# 
               do
                  Interface.currentGroup.getfg
                    ->Interface.sifExternalInterface.check;
                  toolb.statechanged
               #)
          #);
        compile: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do
                  ((Interface.currentGroup[] <> none ) and
                   (not edenv.textediting))->enable;
                  enable and (Interface.sifExternalInterface[] <> none ) and
                  (Interface.sifExternalInterface.hasProgramFG)->enable
               #);
             onSelect:: 
               (# 
               do
                  Interface.currentGroup.getfg
                    ->Interface.sifExternalInterface.compile;
                  toolb.statechanged
               #)
          #);
        run: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do
                  (Interface.currentGroup[] <> none ) and
                  (not edenv.textediting)->enable;
                  enable and (Interface.sifExternalInterface[] <> none ) and
                  (Interface.sifExternalInterface.hasProgramFG)->enable
               #);
             onSelect:: 
               (# 
               do
                  Interface.currentGroup.getfg
                    ->Interface.sifExternalInterface.execute;
                  toolb.statechanged
               #)
          #);
        debug: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do
                  ((Interface.sifExternalInterface[] <> none ) and
                   (Interface.currentGroup[] <> none ) and
                   Interface.sifExternalInterface.debugProgramFGPossible)
                    ->enable
               #);
             onSelect:: 
               (# 
               do
                  (if
                  Interface.currentGroup.getFg
                    ->Interface.sifExternalInterface.debug then
                      toolb.statechanged
                  if)
               #)
          #);
        uml: toolb.pixmaptool
          (#
             onEnable:: 
               (# 
               do
                  (if cfe <> none then
                      (not (cfe).frag.locked)->enable
                   else
                      true->enable
                  if)
               #);
             onSelect::  (#  do edenv.frejaExternalInterface.showDiagram #)
          #);
        UI: toolb.pixmaptool
          (#
             onEnable::  (#  do true->enable;  #);
             onSelect:: 
               (# 
               do
                  (if cfe <> none then
                      ((cfe).frag[],(cfe).cs.node[])
                        ->Interface.friggExternalInterface.editUserInterface;
                      
                   else
                      Interface.friggExternalInterface.editUserInterface; 
                  if);
                  
               #)
          #);
        pm: ^toolb.pixmaptool;
        sifprefs: ^editorPreferences;
        small: @boolean;
        
     do
        objectpool.get (# type::< editorpreferences #)->sifprefs[];
        (if sifprefs[] <> none then
            (if sifprefs.SmallFonts then true->small if)
        if);
        (if small then
            &back[]->pm[];
            'Back (Ctrl+B)'->pm.tooltip[];
            ('backbtn-small.png','backbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &frwd[]->pm[];
            'Forward (Ctrl+F)'->pm.tooltip[];
            ('frwbtn-small.png','frwbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &up[]->pm[];
            'Go to Slot (F3)'->pm.tooltip[];
            ('upbtn-small.png','upbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &follow[]->pm[];
            'Go to definition or detail (Ctrl+D)'->pm.tooltip[];
            ('downbtn-small.png','downbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &check[]->pm[];
            'Check from current file (F4)'->pm.tooltip[];
            ('chkbtn-small.png','chkbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &compile[]->pm[];
            'Compile program (Ctrl-F5)'->pm.tooltip[];
            ('compbtn-small.png','compbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &run[]->pm[];
            'Run program (F6)'->pm.tooltip[];
            ('runbtn-small.png','runbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &debug[]->pm[];
            'Debug program (F7)'->pm.tooltip[];
            ('dbgbtn-small.png','dbgbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &uml[]->pm[];
            'Show UML class diagram'->pm.tooltip[];
            ('umlbtn-small.png','umlbtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &UI[]->pm[];
            'Open GUI editor'->pm.tooltip[];
            ('guibtn-small.png','guibtn-small-shadow.png')->pm.init;
            pm[]->toolb.addTool
         else
            &back[]->pm[];
            'Back (Ctrl+B)'->pm.tooltip[];
            ('backbtn.png','backbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &frwd[]->pm[];
            'Forward (Ctrl+F)'->pm.tooltip[];
            ('frwbtn.png','frwbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &up[]->pm[];
            'Go to Slot (F3)'->pm.tooltip[];
            ('upbtn.png','upbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &follow[]->pm[];
            'Go to definition or detail (Ctrl+D)'->pm.tooltip[];
            ('downbtn.png','downbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &check[]->pm[];
            'Check from current file (F4)'->pm.tooltip[];
            ('chkbtn.png','chkbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &compile[]->pm[];
            'Compile program (Ctrl-F5)'->pm.tooltip[];
            ('compbtn.png','compbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &run[]->pm[];
            'Run program (F6)'->pm.tooltip[];
            ('runbtn.png','runbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &debug[]->pm[];
            'Debug program (F7)'->pm.tooltip[];
            ('dbgbtn.png','dbgbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &uml[]->pm[];
            'Show UML class diagram'->pm.tooltip[];
            ('umlbtn.png','umlbtn-shadow.png')->pm.init;
            pm[]->toolb.addTool;
            &UI[]->pm[];
            'Open GUI editor'->pm.tooltip[];
            ('guibtn.png','guibtn-shadow.png')->pm.init;
            pm[]->toolb.addTool
        if)
     #)  

-- windowsmenustatus: DoPart --
do
   Interface.theToolbar.statechanged;
   '==========BROWSER STATUS==========='->putline;
   'Browser-id:%d\n'->putformat (#  do Interface.id->d #);
   'SelectedFG:'->puttext;
   (if browser.sbprivate.hierarchyView.hir.selectedfg[] <> none then
       browser.sbprivate.hierarchyView.hir.selectedfg.fullname->putline
    else
       'is none'->putline
   if);
   'RecentFile: '->puttext;
   (if browser.sbprivate.hierarchyView.hir.usedGroups[] <> none then
       browser.sbprivate.hierarchyView.hir.usedGroups.location[]->putline
   if);
   'CurrentProject: '->puttext;
   (if Interface.currentProject[] <> none then
       (if Interface.currentProject.name[] <> none then
           Interface.currentProject.name[]->putline
        else
           ' name none'->putline
       if)
    else
       ' is none'->putline
   if);
   'CurrentGroup: '->puttext;
   (if Interface.currentGroup[] <> none then
       Interface.currentGroup.location[]->putline
    else
       ' is none'->putline
   if);
   'CurrentForm: '->puttext;
   (if Interface.currentForm[] <> none then
       Interface.currentForm.print
    else
       ' is none'->putline
   if);
   'Codeeditor: '->puttext;
   (if Interface.cfe[] <> none then
       Interface.cfe.id->putint; newline; 
    else
       'cfe none'->putline
   if);
   'GroupEditor: '->puttext;
   (if Interface.cge[] <> none then
       Interface.cge.fg.fullname->putline
    else
       'cge none'->putline
   if);
   'RootProject: '->puttext;
   browser.sbprivate.rootProjectID->putint;
   ' '->put;
   (if browser.sbprivate.theActiveRootProject[] <> none then
       browser.sbprivate.theActiveRootproject.label[]->putline
    else
       ' is none'->putline
   if);
   '==================================='->putline  

-- windowsmenushownode: DoPart --
do getint->Interface.cfe.frag.indexToNode->Interface.findAndSelect  

-- updateToolbar: DoPart --
do interface.theToolbar.stateChanged  

-- updateBrowser: DoPart --
do
   (if fg[] <> none then
       (if fg[] = browser.sbprivate.hierarchyView.hir.selectedFG[] then
             (# fld: ^hierarchy.folder
             do
                browser.sbprivate.hierarchyView.hir.selection[]->fld[];
                (if fld.isExpanded then fld.onCollapse; fld.onExpand if)
             #)
       if);
       none ->browser.sbprivate.formView.selectedFormName[];
       none ->browser.sbprivate.hierarchyView.hir.selectedFG[];
       fg.fullname->selectFragmentGroup
   if)  

-- ymerGroupGetDomain: DoPart --
do
     (# domainproj: @projects.project; 
     do
        location[]->domainproj.location.puttext;
        true->domainproj.isDomain;
        domainproj.scangroups;
        domainproj.groups.copy->glist[]
     #)  

-- ymerGroupGetExtent: DoPart --
do
     (# domainproj: @projects.project; 
     do
        location[]->domainproj.location.puttext;
        true->domainproj.isExtent;
        domainproj.scangroups;
        domainproj.groups.copy->glist[]
     #)  

-- ymerMPSOnOpenGroupDone: DoPart --
do
   (if not fg.isRealOpen then
       fg.realOpen
         (#
            noSuchFileError:: 
              (# 
              do
                 true->continue;
                 (none ,m[],'Error during opening of group')->gui.alertUser
              #)
         #)
   if)  

