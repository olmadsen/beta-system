ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '~beta/sysutils/v1.4/pathhandler';
INCLUDE '~beta/process/v1.4/osinterface';

INCLUDE '../dynpane';

INCLUDE 'settings';
INCLUDE 'fileEditor';
INCLUDE 'parseEditor';
INCLUDE 'sourcebrowserbody';

INCLUDE 'ymerFileUtils';

--- browserFileEdit: dopart ---
do (# fe: @fileEditor
        (# open:: (# do (600,800)->size #) #);
   do fe.open;
      makefile[]->fe.loadFile;
   #)

--- ymerMPSparseerrors: dopart ---
do true->continue;
   (# pe: @ymerBrowser.browser.parseEditor
        (# open::
             (#
             do (600,800)->size;
                ymerBrowser.browser.currentGroup.location[]->loadFiles
             #)
        #);
   do pe.open
   #);
   (ymerBrowser.browser.currentProject[],none)
     ->ymerBrowser.browser.setGroup
   
   
--- ymerMPSbetaparserinit: descriptor ---
(# bobsFile: @file;
   grammarWithPath, help: ^text;
do (if not BETACFL.parser.haveBeenInitialized then
       '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
       (if BETACFL.grammarAst[]
        // none then
           'No grammarAst for '->screen.putText;
           grammarWithPath[]->screen.putLine;
        else
           '-parser'->help[];
           mps.ast.parserFileExtension->help.append;
           help[]->grammarWithPath.copyAppend->mps.ast.expandToFullPath 
             ->bobsFile.name;
           (if bobsFile.entry.exists then
               bobsFile.name->BETACFL.parser.initialize;
               ('objectdescriptor','descriptor')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               ('attributedecl','attributes')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               
            else
               'No parser available: '->screen.putText;
               bobsFile.name->screen.putLine;
               
           if);
       if);
   if)
#)

--- ymerAddProject: dopart ---
do &browser.projects.project[]->newProj[];
   name.copy->newProj.name[];
   location[]->MPS.ast.expandToFullPath->newProj.location.puttext;
   newProj[]->browser.projects.setupProject;
   newProj[]->browser.projects.theProjects.append;
   browser.projectsChanged;
   newProj[]->browser.setProject;
   
--- projectInfoLib: attributes ---
setupProject:
  (# f: @file; ext: ^text;
     proj, root: ^project
  enter proj[]
  do (if (proj.location.length
           ->proj.location.inxGet)='/' then
         (proj.location.length,proj.location.length)
           ->proj.location.delete;
     if);
     (proj.location[],ph.currentDirectory)
       ->ph.convertfilepath->f.name;
     (if proj.name[]=NONE then
         f.entry.path.name->proj.name[]
     if);
     (if true
      // f.entry.exists and
         f.entry.readable and
         f.entry.isDirectory then
         true->proj.isDirectory;
         (if (proj.location.length
               ->proj.location.inxGet)<>'/' then
             '/'->proj.location.append
         if);
         (if (proj.name.length>0) and
             ((proj.name.length->proj.name.inxGet)<>'/') then
             '/'->proj.name.append;
         if);
      else
         f.entry.path.name.suffix->ext[];
         (if true
          // f.entry.exists and
             f.entry.readable and
             (mps.AST.astfileExtension->ext.equal)
          // f.entry.exists and
             f.entry.readable and
             ('.bet'->ext.equal) 
          // (mps.AST.astfileExtension->(f.name).append
               ->fileExists) and
             (mps.AST.astfileExtension->(f.name).append
               ->fileReadable)
          // ('.bet'->(f.name).append->fileExists) and
             ('.bet'->(f.name).append->fileReadable) then
             '*'->proj.name.append;
             true->proj.isRoot;
             
             proj[]->root[];
             
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isDomain;
             '[domain]'->proj.name[];
             proj[]->root.subprojects.append;
             
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isExtent;
             '[extent]'->proj.name[];
             proj[]->root.subprojects.append;
          // f.entry.exists and
             f.entry.readable and
             ('.pjt'->ext.equal) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             (f.name,proj[])
               ->theProjects.parseProjectFile;
          // ('.pjt'->(f.name).append->fileExists) and
             ('.pjt'->(f.name).append->fileReadable) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             ('.pjt'->(f.name).append,proj[])
               ->theProjects.parseProjectFile;
          else
             (* skip for ECOOP: f.name->fileAvailable; *)
         if)
     if)
  #);

--- scanGroupsImpl: dopart ---
do ''->infoView.contents.label;
   (if true
    // isRoot then
       (if groups.size=0 then
           (* this is the first time we visit this root *)
           &browser.projects.group[]->newGroup[];
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName
             ->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else 
           (* we have visited this root previously *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isExtent then
       (if groups.size=0 then
           (* the extent haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanExtent
           (#
           do &browser.projects.group[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the extent have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDomain then
       (if groups.size=0 then
           (* the domain haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanDomain
           (#
           do &browser.projects.group[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the domain have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDirectory then
       (if groups.size=0 then
           (* the directory haven't previously been scanned *)
           (# d: @directory; count: @integer;
           do this(Project).groups.clear;
              (if location.empty then
                  ph.currentDirectory->location.puttext;
              if);
              (location[],ph.currentDirectory)
                ->ph.convertfilepath->d.name;
              d.scanEntries
              (#
              do select
                 (# whenFile::
                      (# f: ^file; ext: ^Text;
                      do &browser.projects.group[]->newGroup[];
                         thefile->f[];
                         f.entry.path.name.suffix
                           ->ext[];
                         f.entry.path.name
                           ->newGroup.location.puttext;
                         (if true
                          // f.entry.exists and
                             f.entry.readable and
                             (mps.AST.astfileExtension
                               ->ext.equal)
                          // f.entry.exists and
                             f.entry.readable and
                             ('.bet'->ext.equal) then
                             (newGroup.location.length-3,newGroup.location.length)
                               ->newGroup.location.delete;
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name.prefix
                                   ->newGroup.name[];
                                 count+1->count;
                                 newGroup[]->groups.append;
                                 newGroup[]->thescan.foreach
                             if)
                          else
                             (* skip for ECOOP: f.name->fileAvailable *)
                         if);
                      #)
                 #)
              #);
              (if count=0 then
                  'no fragments in project'
                    ->infoView.contents.label;
              if)
           #)
        else
           (* the directory have previously been scanned *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // groups.size<>0 then
       groups.scan
       (#
       do current[]->thescan.foreach
       #)
    else
       (if not unfolded then 
           'open project to find subprojects'
             ->infoView.contents.label;
        else 
           'open subproject to find fragments'
             ->infoView.contents.label;
       if)
   if)
   
--- browserLib: attributes ---

unfoldSubprojects:
  (# proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
  enter proj[]
  do ''->infoView.contents.label;
     (if true
      // proj.hasSubprojects 
      // proj.isRoot then
         proj[]->projects.theProjects.at->projPos[];
         proj.subprojects.scan
         (#
         do proj.level+1->current.level;
            (for current.level repeat
                 '  '->current.name.prepend
            for);
            (current[],projPos[])
              ->projects.theProjects.insertAfter->projPos[];
         #);
         proj.subprojects.scan
         (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
      // proj.isDirectory then
         (if proj.subprojects.size=0 then
             (* the directory haven't previously been unfolded *)
             (# d: @directory; f: @file;
             do (proj.location[],ph.currentDirectory)
                  ->ph.convertfilepath->d.name;
                d.scanEntries
                (# 
                do select
                   (# whenDir::
                        (# d: ^directory; name: ^text;
                           newProj: ^browser.projects.project;
                        do thedir->d[];
                           d.entry.path.name->name[];
                           (if true
                            // '.'->name.equalNCS
                            // '..'->name.equalNCS
                            // 'sun4s'->name.equalNCS then
                            // 'sun4'->name.equalNCS then
                            // 'sun3'->name.equalNCS then
                            // 'snake'->name.equalNCS then
                            // 'sgi'->name.equalNCS then
                            // 'nti'->name.equalNCS then
                            // 'linux'->name.equalNCS then
                            // 'hpux9pa'->name.equalNCS then
                            // 'hpux8'->name.equalNCS then
                            // 'b2c'->name.equalNCS then
                            else
                               &browser.projects.project[]
                                 ->newProj[];
                               (d.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               newProj.location[]->f.name;
                               (if (newProj.location.length
                                     ->newProj.location.inxGet)<>'/'
                                   then
                                   '/'->newProj.location.append
                               if);
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               '/'->newProj.name.append;
                               true->newProj.isDirectory;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[],proj[]
                                     ->projects.theProjects.at)
                                     ->projects.theProjects.insertAfter;
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
                               if)
                           if)
                        #);
                      whenFile::
                        (# f: ^file; name: ^text;
                           newProj: ^browser.projects.project;
                        do thefile->f[];
                           f.entry.path.name->name[];
                           (if true
                            // '.pjt'->(f.entry.path.name.suffix).equal then
                               &browser.projects.project[]
                                 ->newProj[];
                               (f.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               (newProj.location.length-3,newProj.location.length)
                                 ->newProj.location.delete;
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               (newProj.name.length-3,newProj.name.length)
                                 ->newProj.name.delete;
                               '+'->newProj.name.append;
                               true->newProj.hasSubprojects;
                               (f.name,newProj[])
                                 ->proj.subprojects.parseProjectFile;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[],proj[]
                                     ->projects.theProjects.at)
                                     ->projects.theProjects.insertAfter;
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
             if)if)#)#)#)#)
          else
             (* the directory have previously been unfolded *)
             proj[]->projects.theProjects.at->projPos[];
             proj.subprojects.scan
             (#
             do (for current.level repeat
                     '  '->current.name.prepend
                for);
                (current[],projPos[])
                  ->projects.theProjects.insertAfter->projPos[];
             #);
             proj.subprojects.scan
             (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
         if)
     if)
  #);
foldSubprojects:
  (# proj: ^browser.projects.project;
     level: @integer
  enter proj[]
  do ''->infoView.contents.label;
     proj.level->level;
     loop:
       (proj[]
       ->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
     (#
     do (if current.elm.level>level then
            (1,current.elm.level*2)->current.elm.name.delete;
            current[]->projects.theProjects.delete
         else leave loop
        if)
     #);
  #);
projectByIndex:
  (# inx: @integer;
     foundProj: ^browser.projects.project;
  enter inx
  do find: projects.theProjects.scan
       (#
       do inx-1->inx;
          (if inx=0 then
              current[]->foundProj[];
              leave find
       if)#)
  exit foundProj[]
  #);

--- onGroupListOpen: dopart --- 
do &thegrouplist.action
   (# eventtype:: thegrouplist.theeventhandler.mousedown;
      selectedGroup: ^projects.group;
      root, newProj: ^browser.projects.project;
   do (if (thegrouplist.selection.first)<>0 then
          (if theEvent.doubleClick then
              (if theEvent.shiftKey then
                  (* do what's needed to make THIS into a root *)
                  thegrouplist.selection.first
                    ->groups.getGroupByIndex->selectedGroup[];
                  &browser.projects.project[]->newProj[];
                  selectedGroup.location->newProj.location;
                  (if newProj.name[]=NONE then
                      selectedGroup.name.copy->newProj.name[]
                  if);
                  '*'->newProj.name.append;
                  true->newProj.isRoot;
                  
                  newProj[]->projects.theProjects.append;
                  newProj[]->root[];
                  
                  &browser.projects.project[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isDomain;
                  '[domain]'->newProj.name[];
                  newProj[]->root.subprojects.append;
                  
                  &browser.projects.project[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isExtent;
                  '[extent]'->newProj.name[];
                  newProj[]->root.subprojects.append;
                  
                  projectsChanged;
                  root[]->setProject;
              if)
          if)
      if)
   #)[]->thegrouplist.appendAction;
   
--- onProjectListOpen: dopart --- 
do &theprojectlist.action
   (# eventtype:: theprojectlist.theeventhandler.mousedown;
      i: @integer;
      selectedProj: ^browser.projects.project;
   do (if (theprojectlist.selection.first->i)<>0 then
          (if theEvent.doubleClick then
              i->projectByIndex->selectedProj[];
              (if selectedProj.unfolded then
                  false->selectedProj.unfolded;
                  selectedProj[]->foldSubprojects;
               else
                  true->selectedProj.unfolded;
                  selectedProj[]->unfoldSubprojects;
              if);
              projectsChanged;
              selectedProj[]->setProject;
          if)
      if)
   #)[]->theprojectlist.appendAction;
   
--- onCurrentFormChange: dopart ---
do (if newForm[]<>NONE then
       ymerPrivate.history.find
       (# predicate::
            (#
            do (if none
                // browser.currentProject[] then
                // browser.currentGroup[] then
                // current.theProject.location[] then
                // current.theGroup.location[] then
               if);
               ((current.theProject.location[]->browser.currentProject.location.equalNCS)
               and (current.theGroup.location[]->browser.currentGroup.location.equalNCS)
               and (current.theForm[]=newForm[]))->value
            #);
          notFound::
            (# newHist: ^ymerPrivate.history.element
            do &ymerPrivate.history.element[]->newHist[];
               browser.currentProject[]
                 ->newHist.theProject[];
               browser.currentGroup[]
                 ->newHist.theGroup[];
               newForm[]
                 ->newHist.theForm[];
               browser.getFragmentFormEditor
                 ->newHist.theSif[];
               newHist[]->ymerPrivate.history.prepend;
               (this(ymerBrowserWindow).theMenubar).historyMenu.addHistoryElement;
            #)
          do
       #)   
   if);
   
--- selectFragmentGroup: dopart ---
do browser.currentProject.groups.find
   (# predicate:: (# do fgName[]->current.location.equalNCS->value #);
      notFound:: 
        (# cp: ^browser.projects.project;
           newGroup: ^browser.projects.group
        do browser.currentProject[]->cp[];
           &browser.projects.group[]->newGroup[];
           fgName[]->newGroup.location.puttext;
           fgName[]->fragmentDefaultName
             ->newGroup.name[];
           '+'->newGroup.name.prepend;
           true->newGroup.temporary;
           newGroup[]->browser.currentProject.groups.append;
           projectsChanged;
           (cp[],newGroup[])->browser.setGroup;
        #)
   do (browser.currentProject[],current[])->browser.setGroup
   #)
   
--- selectFragmentForm: dopart ---
do fgName[]->selectFragmentGroup;
   (# t: @text;
      ff: ^MPS.ast.fragmentForm;
   do (formName[],screen[])->browser.currentGroup.fg.open->ff[];
      (if ff[]=NONE then
          'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
            ->t.putformat(# do formName[]->s; fgName[]->s #);
          (NONE, t[], 'Warning')->alertUser
       else
          (browser.currentProject[],browser.currentGroup[],ff[])
            ->browser.setFragmentForm
      if);
   #)
   
--- browserOpen: dopart ---
do (# infoPane: @dynpane
        (# open:: 
             (# sz: @point;
                setDefaults::
                  (#
                  do false->verticalStacking;
                     50->minsize;
                     2->panewidth;
                  #)
             do sbprivate.initialSize->sz;
                (((sz.h*3+4) div 2)-1,45)->sz;
               
                (infoPane[],sz)->locationView.open;
                (infoPane[],sz)->infoView.open;
                locationView[]->appendMember;
                infoView[]->appendMember;
                appendsDone;
          #);
        #);
      x,y: @integer;
   do (sbprivate.outerctrl[],false,50,2)->infoPane.open;
      infoPane[]->sbprivate.outerctrl.appendMember;
      sbprivate.outerctrl.appendsDone;
      
   #);

---  ymerInit: descriptor ---
(# OS: @osInterface;
do OS.init;
   OS.hostMachine->machinetype;
   '$(BETALIB)'->expandEnvVar
   (# defaultValue::
        (# do '/usr/local/lib/beta'->envvarvalue[] #)#)
     ->BETAlib[];
   mps.init;
   browsers.init;
   INNER init;
   ymerBrowser.open;
#)

--- ymerPrivate: descriptor ---
(# history: @list
     (# element::
          (# theProject: ^browser.projects.project;
             theGroup: ^browser.projects.group;
             theForm: ^MPS.ast.fragmentForm;
             theSif: ^sifTextEditor;
          #)
     #);
   workspaceCount: @integer;
#)
