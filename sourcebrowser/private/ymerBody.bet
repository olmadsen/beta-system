ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.6/formatio'
	'~beta/sysutils/v1.6/pathhandler'
	'~beta/editor/v5.2/fragmentscanner'
	'fileEditor'
	'parseEditor'
	'sourcebrowserbody'
	'ymerFileUtils'
	'ymerPrivate'
	'separateCodeEditor'
	'searchActions'
	'help'
	'mpsIntAdds';
BODY 'settings';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- historyMenuLib: Attributes --
findAndSelect:
  (# node: ^astInterface.ast
  enter node[]
  do
     (if node[] <> none then
	 (if browser.cfe[] <> none then
	     (if node.frag[] <> browser.cfe.frag[] then
		 ymerBrowserPrivate.history.find
		   (# predicate::
			(# do (current.theForm[] = node.frag[])->value #);
		      notFound::
			(#
			do ((node.frag.father).fullName,node.frag.name)
			     ->browser.selectFragmentForm
			#)
		   do (current.theProject[],current.theGroup[],current.theForm[])
			->browser.setFragmentForm
		   #);
		 (if not browser.cfe.theSifTexteditor.textediting then
		     (node[],1,0,0)->browser.cfe.setFocus
		  else
		     (none ,'Cannot reestablish focus - text edit active',
		      'History')->noteUser
		 if)
	      else
		 (node[],1,0,0)->browser.cfe.setFocus
	     if)
	  else
	     ((node.frag.father).fullName,node.frag.name)
	       ->browser.selectFragmentForm;
	     (if not browser.cfe.theSifTexteditor.textediting then
		 (node[],1,0,0)->browser.cfe.setFocus
	      else
		 (none ,'Cannot reestablish focus - text edit active','History')
		   ->noteUser
	     if)
	 if)
      else
	 (none ,'Should not happen - node[] is none!','History')->alertUser
     if)
  #);
back: menuItem
  (#
     eventhandler::
       (#
	  onStatus::
	    (#
	    do
	       ((browser.cfe[] <> none ) and (browser.cfe.cs[] <> none ) and
		  (browser.cfe.cs.node[] <> none ) and
		  (browser.cfe.cs.node[]->edenv.history.BackPossible))->value
	    #);
	  onSelect::
	    (#
	    do edenv.history.protect
		 (# do browser.cfe.cs.node[]->edenv.history.back->findAndSelect #) #)
       #);
     open::  (#  do 'Back'->name; 'b'->key #)
  #);
forward: menuItem
  (#
     eventhandler::
       (#
	  onStatus::
	    (#
	    do
	       ((browser.cfe[] <> none ) and (browser.cfe.cs[] <> none ) and
		  (browser.cfe.cs.node[] <> none ) and
		  (browser.cfe.cs.node[]->edenv.history.forwardPossible))->value
	    #);
	  onSelect::
	    (#
	    do edenv.history.protect
		 (# do browser.cfe.cs.node[]->edenv.history.forward->findAndSelect #) #)
       #);
     open::  (#  do 'Forward'->name; 'f'->key #)
  #);
historyMenuItem: menuItem
  (#
     theHist: ^ymerBrowserPrivate.history.element;
     eventhandler::
       (#
	  onSelect::
	    (#
	    do (theHist.theProject[],theHist.theGroup[],theHist.theForm[])
		 ->browser.setFragmentForm
	    #)
       #);
     setName:
       (# t: ^text;
       do
	  (theHist.theGroup.location[],true)
	    ->ymerBrowserPrivate.history.names.uniqName
	    ->t[];
	  '-'->t.append;
	  theHist.theForm.name->t.append;
	  t[]->name
       #)
  #);
addHistoryElement:
  (#
     theHist: ^ymerBrowserPrivate.history.element;
     newHitem: ^historyMenuItem
  enter theHist[]
  do
     (if not protected then
	 &historyMenuItem[]->newHitem[];
	 newHitem.open;
	 theHist[]->newHitem.theHist[];
	 newHitem[]->append;
	 updateNames;
     if)
  #);
updateNames: scan
  (# theHitem: ^historyMenuItem
  do (if current## <= historyMenuItem## then
	 current[]->theHitem[];
	 theHitem.setname
     if)
  #);
closeHistoryElement:
  (#
     oldElement: ^ymerBrowserPrivate.history.element;
     theHitem: ^historyMenuItem
  enter oldElement[]
  do
     l: scan
       (#
       do
	  (if current## <= historyMenuItem## then
	      current[]->theHitem[];
	      (if theHitem.theHist[] = oldElement[] then
		  theHitem[]->historyMenu.delete; leave l
	      if)
	  if)
       #)
  #);
protect:
  (# status: @boolean
  do protected->status; true->protected; INNER protect; status->protected
  #)

-- historyMenuOpen: DoPart --
do
   'History'->name;
   (# item: ^menuItem
   do
      &back[]->item[];
      item.open;
      item[]->append;
      &forward[]->item[];
      item.open;
      item[]->append;
      &separator[]->item[];
      item.open;
      item[]->append
   #)

-- browserSelectNode: DoPart --
do
   (if true
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and separate then
       (theEditorRoot.frag[],node[])->viewSeparate
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
	(theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->browser.cfe.setNode
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and separate then
       (theEditorRoot[],node[])->browser.cfe.openSubeditor
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
	(theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->browser.cfe.setNode
   if)

-- browserFileEdit: DoPart --
do (# se: @streamEditor
	(# setTitle::
	     (#
	     do 'Text file editor for '->t[];
		f.name->fragmentDefaultName->t.append;
	     #);
	   openRead::
	     (# t: ^text
	     do (if f.name->fileAvailable then
		    f.openRead; true->value
		 else
		    'No read permissions to the file:\n     '->t[];
		    f.name->fragmentDefaultName->t.puttext;
		    (se[], t[],'Read Error')
		      ->alertUser;
		    false->value
		if)
	     #);
	   openWrite::
	     (# t: ^text
	     do (if (f.name->fileExists) and (f.name->fileWriteable) then
		    f.openWrite; true->value
		 else
		    'No write permissions to the file:\n     '->t[];
		    f.name->fragmentDefaultName->t.puttext;
		    (se[], t[],'Write Error')
		      ->alertUser;
		    false->value
		if)
	     #);
	   closeStream:: (# do f.close #);
	   open::  (#  do (600,800)->size #)
	#);
      f: @file; t: ^text
   do se.open;
      filename[]->mps.AST.expandtofullpath->f.name;
      f[]->se.loadStream;
   #)

-- browserViewHTML: DoPart --
do (# help: @helpViewer
	(# open::
	     (# t,n: ^text; d: @directory; f: @file
	     do ymerPrivate.helpDocuments.scan
		(#
		do (current.title[],current.path[])->registerTheme
		#);
		(if currentProject[]<>NONE then
		    (if true
		     // currentProject.isDirectory
		     // currentProject.isDotDotDirectory then
			currentProject.location.copy->t[];
			t[]->mps.AST.expandToFullPath->t[];
			mps.ast.thepathhandler.directoryChar->t.put;
			t[]->d.name;
			d.scanEntries
			(# sep: @boolean;
			   error::  (#  do true->continue #)
			do select
			   (# error::  (#  do true->continue #);
			      whenFile::
				(# f: ^file; ext: ^Text;
				do thefile->f[];
				   f.entry.path.name.suffix->ext[];
				   (if '.html'->ext.equalNCS then
				       currentProject.name.copy->n[];
				       f.entry.path.name->n.append;
				       (if not sep then
					   (none,none)->registerTheme;
					   true->sep;
				       if);
				       (n[],f.name)
					 ->registerTheme
				   if)
				#)
			   #)
			#)
		     // currentProject.isProjectFile
		     // currentProject.isRoot
		     // currentProject.isExtent
		     // currentProject.isDomain then
			currentProject.location.copy->t[];
			'.html'->t.append;
			t[]->mps.ast.expandtofullpath->f.name;
			(if f.name->fileAvailable then
			    currentProject.location[]->fragmentDefaultName
			      ->n[];
			    '.html'->n.append;
			    (none,none)->registerTheme;
			    (n[],t[])->registerTheme
			if)
		    if)
		if);
		(if currentGroup[]<>NONE then
		    currentGroup.location.copy->t[];
		    '.html'->t.append;
		    t[]->mps.ast.expandtofullpath->f.name;
		    (if f.name->fileavailable then
			currentGroup.location[]->fragmentDefaultName->n[];
			'.html'->n.append;
			(none,none)->registerTheme;
			(n[],t[])->registerTheme
		    if)
		if);
		(if (theme[]<>NONE) and (location[]<>NONE) then
		    (theme[],location[])->registerTheme;
		    (location[],theme[])->contents.help.contents.loadFile;
		    'Help: '->t[]; theme[]->t.append; t[]->help.title
		if)
	     #)
	#)
   do help.open
   #)

-- ymerMPSparseerrors: DoPart --
do
   true->continue;
   (# pe: @parseEditor
	(# open::  (#  do (600,800)->size; groupName[]->loadFiles #) #)
   do pe.open
   #)

-- ymerLoadProject: DoPart --
do
   (if true
    // proj.isDirectory // proj.isDotDotDirectory // proj.isRoot
    // proj.isExtent // proj.isDomain then
       (# newProj: ^browser.projects.project; t: ^text;
       do
	  &browser.projects.project[]->newProj[];
	  proj.location.copy->newProj.location.puttext;
	  (if (newProj[]->browser.projects.setupProject)=NONE then
	      proj.isDirectory->newproj.isDirectory;
	      proj.isRoot->newProj.isRoot;
	      proj.isExtent->newProj.isExtent;
	      proj.isDomain->newProj.isDomain;
	      newProj[]->browser.projects.theProjects.append
	  if);
	  'Browser on: '->t[];
	  newProj.name[]->t.append;
	  (if true
	   // proj.isExtent then
	      ' [extent]'->t.append
	   // proj.isDomain then
	      ' [domain]'->t.append
	  if);
	  t[]->title
       #)
    // proj.isProjectFile // proj.hasSubprojects then
       (# t: ^text
       do
	  proj.subprojects.scan
	    (#
	    do
	       current.copy->browser.projects.theProjects.append;
	       none ->current.superProject[]
	    #);
	  'Browser on: '->t[];
	  proj.name[]->t.append;
	  t[]->title
       #)
   if);
   browser.projectsChanged

-- ymerAddProject: DoPart --
do location[]->appendProject; appendDone

-- ymerAppendProject: DoPart --
do
   &browser.projects.project[]->newProj[];
   location[]->fragmentDefaultName->newProj.name[];
   location[]->newProj.location.puttext;
   (if (newProj[]->browser.projects.setupProject)=NONE then
       newProj[]->browser.projects.theProjects.append
   if)

-- ymerAppendDone: DoPart --
do
   browser.projectsChanged;
   (browser.projects.theProjects.last).elm[]->browser.setProject

-- ymerGroupClose: DoPart --
do
   (if theForm[] = none then (* delete all history related to this group *)
       l: ymerBrowserPrivate.history.iterate
	 (#
	    where::
	      (#
	      do (current.elm.theGroup.location[]->location.equal)->value
	      #)
	 do
	    (if current.elm.theGroup.fg[]
		  ->ymerBrowserPrivate.geList.closeGroup then
		current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
		current[]->ymerBrowserPrivate.history.delete;
		(if currentProject[] <> none then
		    none ->currentProject.lastGroupSelected[]
		if);
		(if currentGroup[] <> none then
		    none ->currentGroup.lastFormSelected[]
		if);
		(currentProject[],none )->setGroup;
		none ->cge[];
		none ->browser.cfe[]; none->browser.cte[];
	     else leave l
	    if)
	 #)
    else
       (* delete only history related to theForm in this group *)
       ymerBrowserPrivate.history.iterate
	 (# where::  (#  do (current.elm.theForm[] = theForm[])->value #);
	 do
	    current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
	    current[]->ymerBrowserPrivate.history.delete;
	    (if currentForm[] = theForm[] then
		(currentProject[],currentGroup[],none )->setFragmentForm;
		(if currentGroup[] <> none then
		    none ->currentGroup.lastFormSelected[]
		if);
		none ->browser.cfe[]; none->browser.cte[]
	    if)
	 #)
   if)

--- ymerGroupRecheck: dopart ---
do fg.diskfilename->diskfile.name;
   fg.textfilename->textfile.name;
   false->allowReload;
   (if (textfile.name->fileExists) and
       ((textfile.name->fileModtime) > fg.modTime) then
       t.clear;
       'Source file: '->t.puttext;
       fg.textfilename->t.putline;
       'changed since last access'->t.putline;
       'The file must have been changed by some other application.'->t.putline;
       'Quit immediately (and restart) to avoid further problems'->t.puttext;
       (none ,t[],'Warning')->alertUser;
       false->allowReload (* should be true->allowReload *)
   else
       (if (diskfile.name->fileExists) and
	   ((diskfile.name->fileModtime) > fg.modTime) then
	   t.clear;
	   'Group file: '->t.puttext;
	   fg.diskfilename->t.putline;
	   'changed since last access'->t.putline;
	   'The file must have been changed by some other application.'->t.putline;
	   'Quit immediately (and restart) to avoid further problems'->t.puttext;
	   (none ,t[],'Warning')->alertUser;
	   false->allowReload (* should be true->allowReload *)
       if)
   if);
   (if allowReload then
       currentGroup[]->cg[]; (currentProject[],none)->setGroup;
       fg[]->ymerBrowserPrivate.geList.closeGroup;
       fg[]->MPS.reload;
       (currentProject[],cg[])->setGroup;
   if)

-- ymerGroupDoRealOpen: DoPart --
do
   (if not g.isRealOpen then (* open g real *)
       g.realOpen
   if);

-- ymerGroupGetFg: DoPart --
do state.busy;
   'Opening '->browser.infoView.settext; location[]->browser.infoView.append;
   '... '->browser.infoView.append; browser.infoView.msgPush;
   (if not location.empty then
       location[]->mps.AST.expandToFullPath
	 ->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (if fg[] <> none then fg[]->doRealOpen if)
   if);
   browser.infoView.msgPop; state.normal

-- projectInfoLib: Attributes --
setupRootProject:
  (# proj,root,existing: ^project
  enter proj[]
  do projects.theProjects.find
       (# predicate::
	    (# do current.location[]->proj.location.equal->value #)
       #)->existing[];
     (if existing[]=none then
	 (if (proj.name.length->proj.name.inxGet) <> '*' then
	     '*'->proj.name.append
	 if);
	 true->proj.isRoot;
	 proj[]->root[];
	 &browser.projects.project[]->proj[];
	 root.location->proj.location;
	 true->proj.isDomain;
	 '[domain]'->proj.name[];
	 root[]->proj.superProject[];
	 proj[]->root.subprojects.append;
	 &browser.projects.project[]->proj[];
	 root.location->proj.location;
	 true->proj.isExtent;
	 '[extent]'->proj.name[];
	 root[]->proj.superProject[];
	 proj[]->root.subprojects.append;
     if)
  exit existing[]
  #);
setupProject:
  (# f: @file; ext,name: ^text; t: ^text; proj,existing: ^project;
     newGroup: ^projects.group
  enter proj[]
  do proj.location[]->mps.AST.expandToFullPath->f.name;
     f.entry.path.name.suffix->ext[];
     (if (ext[] <> none ) and (ext.length > 0) then
	 (if true
	  // mps.AST.astFileExtension->ext.equalNCS then
	     (proj.location.length-(mps.AST.astFileExtension).length+1,
	      proj.location.length)->proj.location.delete
	  // ext[]->mps.AST.grammarTable.legalExtension then
	     (proj.location.length-(ext.length-1),proj.location.length)
	       ->proj.location.delete
	 if)
     if);
     (if proj.location.length>0 then
	 proj.location[]->mps.AST.expandToFullPath->f.name
      else
	 &text[]->t[]; mps.ast.thepathhandler.directoryChar->t.put;
	 t[]->f.name; t[]->proj.location.puttext;
     if);
     (if (proj.name[]=none) or (proj.name.length=0) then f.entry.path.name->proj.name[] if);
	 (* try to find the project among the existing ones *)
	 projects.theProjects.find
	 (# predicate::
	      (# do current.location[]->proj.location.equal->value; #)
	 #)->existing[];
     (if existing[]=none then
	 f.name->t[];
	 t[]->f.name;
	 (if true
	  // (f.name->fileAvailable) and (f.name->isDirectory) then
	     true->proj.isDirectory;
	     (if proj.name.length > 0 then
		 (if (proj.name.length->proj.name.inxGet) <> '/' then
		     '/'->proj.name.append
		 if)
	      else  '/'->proj.name.append
	     if)
	  else
	     f.entry.path.name.suffix->ext[];
	     f.entry.path->name[];
	     (if true
	      // (f.name->fileAvailable) and
		 (mps.AST.astfileExtension->ext.equal)
	      // (f.name->fileAvailable) and
		   (ext[]->mps.AST.grammarTable.legalExtension)
	      // (mps.AST.astfileExtension->(name.copy).append->fileAvailable)
	      // mps.AST.grammarTable.scan
		   (# found: @boolean
		   do found or
		      ((currentExtension[]->(name.copy).append->fileAvailable))
			->found;
		   exit found
		   #) then
		 proj[]->setupRootProject
	      // (f.name->fileAvailable) and ('.pjt'->ext.equal) then
		 true->proj.isProjectFile->proj.hasSubprojects;
		 (if (proj.name.length > 0) and
		       ((proj.name.length->proj.name.inxGet) <> '/') then
		     '/'->proj.name.append;
		 if);
		 (f.name,proj[])->theProjects.parseProjectFile
	      // ('.pjt'->(f.name).append->fileAvailable) then
		 true->proj.isProjectFile->proj.hasSubprojects;
		 (if (proj.name.length > 0) and
		       ((proj.name.length->proj.name.inxGet) <> '/') then
		     '/'->proj.name.append;
		 if);
		 ('.pjt'->(f.name).append,proj[])->theProjects.parseProjectFile
	      // (f.name->fileAvailable) then
		 (if proj.showTxtFiles then
		     true->proj.isProjectFile->proj.hasSubprojects;
		     (if (proj.name.length > 0) and
			 ((proj.name.length->proj.name.inxGet) <> ')') then
			 ' (txt)'->proj.name.append;
		     if);
		     &browser.projects.group[]->newGroup[];
		     proj.location[]->newGroup.location.puttext;
		     f.entry.path.name->newGroup.name[];
		     ' (txt)'->newGroup.name.append;
		     true->newGroup.txtFile;
		     newGroup[]->proj.groups.append
		 if);
	     if)
	 if)
     if)
  exit existing[]
  #)

-- scanGroupsImpl: DoPart --
do state.busy;
   'Opening '->browser.infoView.settext; location[]->browser.infoView.append;
   '... '->browser.infoView.append; browser.infoView.msgPush;
   (if true
    // isRoot then
       (if groups.size = 0 then (* this is the first time we visit this root *)
	   &browser.projects.group[]->newGroup[];
	   location[]->newGroup.location.puttext;
	   newGroup.location[]->fragmentDefaultName->newGroup.name[];
	   newGroup[]->groups.append;
	   newGroup[]->thescan.foreach
	else
	   (* we have visited this root previously *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);
    // isExtent then
       (if groups.size = 0 then
	   (* the extent hasn't previously been calculated *)
	   scanExtentLabel:
	     location[]->mps.AST.expandToFullPath
	     ->mps.dg.scanExtent
		 (# warn: ^text;
		    MPSexception::
		      (#
		      do 'MPS overflow - '->warn[];
			 T[]->warn.puttext; ' too large)'->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    DoubleFormException::
		      (# do true->continue #);
		    emptyFragmentException::
		      (# do true->continue #);
		    transAccessException::
		      (#
		      do 'No read access to: '->warn[]; FN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    notExistingException::
		      (#
		      do 'Not a fragment file: '->warn[]; fullFN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    parseException::
		      (# pe: @parseEditor
			   (# open::  (#  do (600,800)->size; fullFN[]->loadFiles #) #)
		      do pe.open;
			 (*'Parse errors in: '->warn[]; fullFN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;*)
			 true->continue; leave scanExtentLabel
		      #);
		    transCreateDirException::
		      (#
		      do 'Unable to create directory: '->warn[]; FN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    circularDependencyException::
		      (#
		      do 'Circular dependencies in the dependency graph: '->warn[]; fg.fullname->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    unknownPropertyException::
		      (#
		      do 'Unknown property: '->warn[]; n[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    noSpaceException::
		      (#
		      do 'No space left on file system'->warn[];
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    fragmentException::
		      (#
		      do 'Fragment Error: '->warn[]; errMsg[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    propertyException::
		      (#
		      do 'Error in property: '->warn[];
			 p[]->warn.puttext; ' in fragment: '->warn.puttext;
			 fg.fullname->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		 do
		    &browser.projects.group[]->newGroup[];
		    current.fullname->newGroup.location.puttext;
		    newGroup.location[]->dependencyRegister;
		    current.name->fragmentDefaultName->newGroup.name[];
		    newGroup[]->groups.append;
		    newGroup[]->thescan.foreach
		 #);
	   dependencyCreateSubprojects
	else
	   (* the extent has previously been calculated *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);
    // isDomain then
       (if groups.size = 0 then
	   (* the domain hasn't previously been calculated *)
	   scanDomainLabel:
	     location[]->mps.AST.expandToFullPath
	     ->mps.dg.scanDomain
		 (# warn: ^text;
		    MPSexception::
		      (#
		      do 'MPS overflow - '->warn[];
			 T[]->warn.puttext; ' too large)'->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    emptyFragmentException::
		      (# do true->continue #);
		    DoubleFormException::
		      (# do true->continue #);
		    transAccessException::
		      (#
		      do 'No read access to: '->warn[]; FN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    notExistingException::
		      (#
		      do 'Not a fragment file: '->warn[]; fullFN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    parseException::
		      (# pe: @parseEditor
			   (# open::  (#  do (600,800)->size; fullFN[]->loadFiles #) #)
		      do pe.open;
			 (*'Parse errors in: '->warn[]; fullFN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;*)
			 true->continue; leave scanDomainLabel
		      #);
		    transCreateDirException::
		      (#
		      do 'Unable to create directory: '->warn[]; FN[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    circularDependencyException::
		      (#
		      do 'Circular dependencies in the dependency graph: '->warn[]; fg.fullname->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    unknownPropertyException::
		      (#
		      do 'Unknown property: '->warn[]; n[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    noSpaceException::
		      (#
		      do 'No space left on file system'->warn[];
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    fragmentException::
		      (#
		      do 'Fragment Error: '->warn[]; errMsg[]->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		    propertyException::
		      (#
		      do 'Error in property: '->warn[];
			 p[]->warn.puttext; ' in fragment: '->warn.puttext;
			 fg.fullname->warn.putline;
			 (NONE,warn[],'Dependency Graph Error')->alertUser;
			 true->continue
		      #);
		 do
		    &browser.projects.group[]->newGroup[];
		    current.fullname->newGroup.location.puttext;
		    newGroup.location[]->dependencyRegister;
		    current.name->fragmentDefaultName->newGroup.name[];
		    newGroup[]->groups.append;
		    newGroup[]->thescan.foreach
		 #);
	   dependencyCreateSubprojects
	else
	   (* the domain has previously been calculated *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);
    // isDirectory then
       (if groups.size = 0 then
	   (* the directory hasn't previously been scanned *)
	   (# d: @directory; locationfullpath: ^text;
	   do
	      THIS(Project).groups.clear;
	      (if location.empty then
		  mps.ast.thepathhandler.currentDirectory->location.puttext;
	      if);
	      location[]->mps.AST.expandToFullPath->d.name;
	      d.scanEntries
		(# error::  (#  do true->continue #)
		do
		   select
		     (#
			error::  (#  do true->continue #);
			whenFile::
			  (# f: ^file; ext: ^Text;
			  do &browser.projects.group[]->newGroup[];
			     thefile->f[];
			     f.entry.path.name.suffix->ext[];
			     location[]->newGroup.location.puttext;
			     '/'->newGroup.location.put;
			     (if true
			      // (foundfullpath->fileReadable) and
				   (ext[]->mps.AST.grammarTable.legalExtension)
				   then
				 f.entry.path.name.prefix
				   ->newGroup.name[]
				   ->newGroup.location.puttext;
				 (if groups.find
				       (# predicate::
					    (#
					    do current.location[]
						 ->newGroup.location.equal
						 ->value
					    #)
				       #) = none then
				     newGroup[]->groups.append;
				     newGroup[]->thescan.foreach
				 if)
			      // showTxtFiles and
                                 (foundfullpath->fileReadable) then
				 f.entry.path.name
				   ->newGroup.name[]
				   ->newGroup.location.puttext;
				 (if true
				  // ((1->newGroup.name.inxGet)='#')
				  // ((1->newGroup.name.inxGet)='.')
				  // ((newGroup.name.length
					 ->newGroup.name.inxGet)='#')
				  // ((newGroup.name.length
					 ->newGroup.name.inxGet)='~') then
				     (* ignore *)
				  else
				     (if groups.find
					   (# predicate::
						(#
						do current.location[]
						     ->newGroup.location.equal
						     ->value
						#)
					   #) = none then
					 true->newGroup.txtFile;
					 ' (txt)'->newGroup.name.append;
					 newGroup[]->groups.append;
					 newGroup[]->thescan.foreach
				     if)
				 if)
			     if)
			  #)
		     #)
		#);
	      (if groups.size = 0 then
		  'no fragments in project'->browser.infoView.msg
	      if)
	   #)
	else
	   (* the directory has previously been scanned *)
	   groups.scan (#  do current[]->thescan.foreach #)
       if);
    // groups.size <> 0 then
       groups.scan (#  do current[]->thescan.foreach #);
    else
       (if not unfolded then
	   'open project to find subprojects'->browser.infoView.msg
	else
	   'open subproject to find fragments'->browser.infoView.msg
       if)
   if);
   browser.infoView.msgPop; state.normal

-- browserLib: Attributes --
setupDotDot:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
     d: @directory;
     location: ^text;
     level: @integer;
     superProject,superSuperProject: ^browser.projects.project;
     createParentProject:
       (# newProj: ^browser.projects.project
       do (if location.length>0 then
	      &browser.projects.project[]->newProj[];
	      location->newProj.location;
	      true->newProj.isDirectory;
	      newProj[]->browser.projects.setupProject;
	      (newProj[],superProject[]->browser.projects.theProjects.at)
		->browser.projects.theProjects.insertBefore;
	      superProject.level->newProj.level;
	      (for newProj.level repeat '  '->newProj.name.prepend for);
	      superProject.level+1->superProject.level;
	      '  '->superProject.name.prepend;
	      l:
		(superProject[]->browser.projects.theProjects.at).succ[]
		->browser.projects.theProjects.iterateFrom
	      (#
	      do (if current.elm.level >= superProject.level then
		     current.elm.level+1->current.elm.level;
		     '  '->current.elm.name.prepend;
		  else
		     leave l
		 if)
	      #);
	      superProject.subprojects.clear;
	      true->newProj.unfolded;
	      newProj[]->foldSubprojects;
	      newProj[]->unfoldSubprojects;
	      browser.projectsChanged;
	      newProj[]->browser.setProject
	  if)
       #)
  enter proj[]
  do
     (* we now have to create a new project to contain the parent
      * directory of currentDirectory
      *)
     proj.location.copy->location[];
     proj.superProject[]->superProject[];
     (if superProject[] <> none then
	 superProject.level->level;
	 superProject.superProject[]->superSuperProject[];
	 (if superSuperProject[] <> none then
	     (if superSuperProject.isDirectory then
		 (* this is the .. directory - select it *)
		 superSuperProject[]->setProject;
	      else
		 (* try to locate the '..' project in
		  * superSuperProject
		  *)
		 l:
		   (#
		   do
		      superSuperProject.subprojects.iterate
			(#
			do
			   (if current.elm.location[]->location.equal then
			       current.elm[]->setProject; leave l
			   if)
			#);
		      (* not found - create it *)
		      createParentProject
		   #)
	     if)
	  else
	     (* OK, we are 'on the top'.  Try those *)
	     l:
	       (#
	       do
		  browser.projects.theProjects.iterate
		    (#
		       where::
			 (#  do (current.elm.level = level)->value #)
		    do
		       (if current.elm.location[]->location.equal then
			   current.elm[]->setProject; leave l
		       if)
		    #);
		  (* not found - create it *)
		  createParentProject
	       #)
	 if)
     if)
  #);
unfoldSubprojects:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType; t: ^text;
  enter proj[]
  do state.busy;
     'Unfolding '->browser.infoView.settext; proj.location[]->browser.infoView.append;
     '... '->browser.infoView.append; browser.infoView.msgPush;
     (proj[]->projects.theProjects.at).succ[]->projPos[];
     (if true
      // proj.hasSubprojects // proj.isRoot then
	 proj.subprojects.scan
	   (#
	   do
	      proj.level+1->current.level;
	      (for current.level repeat '  '->current.name.prepend for);
	      (current[],projPos[])->projects.theProjects.insertBefore
	   #);
	 proj.subprojects.scan
	   (#
	   do (if current.unfolded then current[]->unfoldSubprojects if)
	   #)
      // proj.isDirectory then
	 (if proj.subprojects.size = 0 then
	     (* the directory hasn't previously been unfolded *)
	     (# d: @directory; level: @integer; t: ^text;
	        newProj: ^browser.projects.project;
             do
		(if proj.location.length>0 then
		    proj.location.copy->t[];
		    t[]->mps.AST.expandToFullPath->d.name;
		 else
		    &text[]->t[];
		    mps.ast.thepathhandler.directoryChar->t.put; t[]->d.name;
		if);
		(* create dotdot(parent) directory *)
                &browser.projects.project[]->newProj[];
                true->newProj.isDirectory;
                &text[]->newProj.name[];
                proj.level+1->newProj.level;
                (for newProj.level repeat
                     '  '->newProj.name.puttext
                for);
                '../'->newProj.name.puttext;
                true->newProj.isDotDotDirectory;
                (d.entry.path.head)->newProj.location.puttext;
                (if (newProj.location.length>0) and
                    (newProj.location[]->fileAvailable) and
                    (newProj.location[]->isDirectory) then
                    (newProj[],projPos[])
                      ->projects.theProjects.insertBefore;
                    proj[]->newProj.superProject[];
                    newProj[]->proj.subprojects.append
                if);
		d.scanEntries
		(# error::  (#  do true->continue #)
		do
		     select
		       (#
			  error::  (#  do true->continue #);
			  whenDir::
			    (# f: @file;
			       d: ^directory;
			       name, lcname: ^text;
			       location: ^text;
			       create: @boolean;
			    do thedir->d[];
			       d.entry.path.name->name[];
			       name.copy->lcname[]; lcname.makeLC;
			       (if true
				// (1->lcname.inxGet)='.'
				// 'sun4s'->lcname.equal
				// 'sgi'->lcname.equal
				// 'nti'->lcname.equal
				// 'linux'->lcname.equal
				// 'mac'->lcname.equal
				// 'ppcmac'->lcname.equal
				// 'ppc'->lcname.equal
				// 'sun4'->lcname.equal
				// 'sun3'->lcname.equal
				// 'snake'->lcname.equal
				// 'hpux9mc'->lcname.equal
				// 'hpux9pa'->lcname.equal
				// 'hpux8'->lcname.equal
				// 'b2c'->lcname.equal then
				   false->create;
				else
				   true->create;
			       if);
			       (if create then
				   &browser.projects.project[]->newProj[];
				   true->newProj.isDirectory;
				   proj.location.copy->location[];
				   (d.name,proj.location[])
				     ->mps.ast.thepathhandler.convertfilePath
				     ->f.name;
				   &text[]->newProj.name[];
				   proj.level+1->newProj.level;
				   (for newProj.level repeat
					'  '->newProj.name.puttext
				   for);
				   f.entry.path.name
				     ->newProj.name.puttext;
				   '/'->newProj.name.append;
				   location[]->newProj.location.puttext;
				   '/'->newProj.location.append;
				   f.entry.path.name
				     ->newProj.location.puttext;
				   (if (newProj.location[]
					 ->mps.AST.expandtofullpath
					 ->fileReadable) then
				       (newProj[],projPos[])
					 ->projects.theProjects.insertBefore;
				       proj[]->newProj.superProject[];
				       newProj[]->proj.subprojects.append
				   if)
			       if)
			    #);
			  whenFile::
			    (#
			       f: ^file;
			       name: ^text;
			    do thefile->f[];
			       f.entry.path.name->name[];
			       (if true
				// '.pjt'->(f.entry.path.name.suffix).equal
				   then
				   &browser.projects.project[]->newProj[];
				   (f.name,proj.location[])
				     ->mps.ast.thepathhandler.convertfilePath
				     ->newProj.location.puttext;
				   (newProj.location.length-3,
				    newProj.location.length)
				     ->newProj.location.delete;
				   proj.level+1->newProj.level;
				   &text[]->newProj.name[];
				   (for newProj.level repeat
					'  '->newProj.name.puttext
				   for);
				   f.entry.path.name->newProj.name.puttext;
				   (newProj.name.length-3,newProj.name.length)
				     ->newProj.name.delete;
				   '/'->newProj.name.append;
				   true->newProj.hasSubprojects;
				   (f.name,newProj[])
				     ->proj.subprojects.parseProjectFile;
				   (if (newProj.location[]
					 ->fileReadable) then
				       (newProj[],projPos[])
					 ->projects.theProjects.insertBefore;
				       proj[]->newProj.superProject[];
				       newProj[]->proj.subprojects.append
				   if)
			       if)
			    #);
		       #)
		  #)
	     #)
	  else
	     (* the directory has previously been unfolded *)
	     proj.subprojects.scan
	       (#
	       do (for current.level repeat '  '->current.name.prepend for);
		  (current[],projPos[])->projects.theProjects.insertBefore
	       #);
	     proj.subprojects.scan
	       (#
	       do (if current.unfolded then current[]->unfoldSubprojects if)
	       #)
	 if)
     if);
     browser.infoView.msgPop; state.normal
  #);
foldSubprojects:
  (# proj: ^browser.projects.project; level: @integer; t: ^text;
  enter proj[]
  do state.busy;
     'Folding '->browser.infoView.settext; proj.location[]->browser.infoView.append;
     '... '->browser.infoView.append; browser.infoView.msgPush;
     proj.level->level;
     loop:
       (proj[]->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
	   (#
	   do
	      (if current.elm.level > level then
		  (1,current.elm.level*2)->current.elm.name.delete;
		  current[]->projects.theProjects.delete
	       else
		  leave loop
	      if)
	   #);
     browser.infoView.msgPop; state.normal;
  #);
projectByIndex:
  (# inx: @integer; foundProj: ^browser.projects.project;
  enter inx
  do
     find: projects.theProjects.scan
       (#
       do inx-1->inx; (if inx = 0 then current[]->foundProj[]; leave find if)
       #)
  exit foundProj[]
  #)

-- onProjectListOpen: DoPart --
do
   &theprojectlist.action
      (#
	 eventtype:: theprojectlist.theeventhandler.mousedown;
	 i: @integer;
	 selectedProj: ^browser.projects.project
      do
	 (if theEvent.doubleClick and
	     ((theprojectlist.selection.first->i) <> 0) then
	     state.busy;
	     (if theEvent.shiftKey then
		 (# fragmentBrowser: ^ymerBrowserWindow
		 do 'Opening new browser... '->browser.infoView.settext;
		    browser.infoView.msgPush;
		    &ymerBrowserWindow[]->fragmentBrowser[];
		    fragmentBrowser.open;
		    i->projectByIndex->selectedProj[];
		    selectedProj[]->fragmentBrowser.loadProject;
		    browser.infoView.msgPop
		 #)
	      else
		 i->projectByIndex->selectedProj[];
		 (if true
		  // selectedProj.isDotDotDirectory then
		     'Selecting parent directory... '->browser.infoView.settext;
		     browser.infoView.msgPush;
		     selectedProj[]->setupDotDot;
		     browser.infoView.msgPop
		  // selectedProj.unfolded then
		     false->selectedProj.unfolded;
		     selectedProj[]->foldSubprojects;
		     projectsChanged;
		     selectedProj[]->setProject
		  else
		     true->selectedProj.unfolded;
		     selectedProj[]->unfoldSubprojects;
		     projectsChanged;
		     selectedProj[]->setProject
		 if)
	     if);
	     state.normal
	 if);
      #)[]->theprojectlist.appendAction;
   &theprojectlist.searchAction
      (#
	 getContext::  (#  do none ->context[] #);
	 select::
	   (# selectedProject: ^projects.project
	   do state.busy;
	      inx->sbprivate.projectList.shownprojects.getProjectByIndex
		->selectedProject[];
	      (if selectedProject[] <> currentProject[] then
		  (selectedProject[])->setProject
	      if);
	      state.normal
	   #);
	 info::  (#  do msg[]->browser.infoView.msg #)
      #)[]->theprojectlist.appendAction

-- onGroupListOpen: DoPart --
do
   &thegrouplist.action
      (#
	 eventtype:: thegrouplist.theeventhandler.mousedown;
	 selectedGroup: ^projects.group;
	 root,newProj: ^browser.projects.project
      do
	 (if theEvent.doubleClick and
	     ((thegrouplist.selection.first) <> 0) then
	     state.busy;
	     thegrouplist.selection.first->groups.getGroupByIndex
	       ->selectedGroup[];
	     (* do what's needed to make THIS into a project *)
	     &browser.projects.project[]->newProj[];
	     selectedGroup.location->newProj.location;
	     (if newProj.name[] = none then
		 selectedGroup.name.copy->newProj.name[]
	     if);
	     (if theEvent.shiftKey then
		(if selectedGroup.txtFile then
		    selectedGroup.location[]
		      ->fileEdit
		 else
		    (# fragmentBrowser: ^ymerBrowserWindow; t: ^text;
		    do 'Opening separate browser on '->browser.infoView.settext;
		       newProj.location[]->browser.infoView.append;
		       '... '->browser.infoView.append; browser.infoView.msgPush;
		       &ymerBrowserWindow[]->fragmentBrowser[];
		       fragmentBrowser.open;
		       newProj.location[]->fragmentBrowser.addProject;
		       'Browser on: '->t[];
		       newProj.location[]->t.puttext;
		       t[]->fragmentBrowser.title;
		       browser.infoView.msgPop
		    #)
		if)
	      else
		 (if selectedGroup.txtFile then
		     newProj[]->projects.setupProject->root[];
		     (if root[]=NONE then
			 newProj[]->root[]->browser.projects.theProjects.append;
			 browser.projectsChanged
		     if);
		  else
		     newProj[]->projects.setupRootProject->root[];
		     (if root[]=NONE then
			 newProj[]->root[]->projects.theProjects.append;
			 projectsChanged
		     if)
		 if);
		 root[]->setProject
	     if);
	     state.normal;
	 if)
      #)[]->thegrouplist.appendAction;
   &thegrouplist.searchAction
      (#
	 getContext::  (#  do currentProject[]->context[] #);
	 select::
	   (# selectedGroup: ^projects.group;
	   do
	      inx->groups.getGroupByIndex->selectedGroup[];
	      (if selectedGroup[] <> currentGroup[] then
		  (currentProject[],selectedGroup[])->setGroup
	      if)
	   #);
	 info::  (#  do msg[]->browser.infoView.msg #)
      #)[]->thegrouplist.appendAction

-- onFragmentgroupViewOpen: DoPart --
do
   &theFragmentgroupView.action
      (#
	 eventtype:: theFragmentgroupView.theeventhandler.mousedown;
	 inx: @integer;
	 fgs: @fragmentGroupScanner
      do
	 (if theEvent.doubleClick and
	     ((theFragmentgroupView.selection.first->inx) <> 0) then
	     (if theEvent.shiftKey then
		 state.busy;
		 (mps.AST[],currentGroup.fg[])->fgs;
		 fgs.scanPropsAndFragsForText
		 (* HACK to initialize fgs properly
		  * - error in fragmentGroupScanner implementation
		  * - does not currently initialize noOfProgs
		  *   in scanPropsAndFrags
		  *) ;
		 find:
		   (currentGroup.fg[],inx)
		   ->fgs.scanPropsAndFrags
		       (# doProperty::
			    (# t: ^Text; f: @file;
			       fragmentBrowser: ^ymerBrowserWindow;
			    do (* ORIGIN,BODY, MDBODY or MAKE *)
			       (if true
				// 'ORIGIN'->prop.equalNCS
				// 'BODY'->prop.equalNCS
				// 'MDBODY'->prop.equalNCS then
				   'Opening separate browser on '->browser.infoView.settext;
				   s[]->browser.infoView.append;
				   '... '->browser.infoView.append; browser.infoView.msgPush;
				   &ymerBrowserWindow[]->fragmentBrowser[];
				   fragmentBrowser.open;
				   currentGroup.fg.fullName
				     ->mps.AST.stripPathName->t[];
				   (if t[] = none then
				       s.copy
					 ->mps.AST.expandtofullpath
					 ->fragmentBrowser.addProject
				    else
				       (s.copy,t[])
					 ->mps.AST.thePathHandler.convertFilePath
					 ->fragmentBrowser.addProject
				   if);
				   'Browser on: '->t[];
				   s[]->t.puttext;
				   t[]->fragmentBrowser.title;
				   browser.infoView.msgPop;
				// 'MAKE'->prop.equalNCS then
				   currentGroup.location[]->f.name;
				   f.entry.path.head->t[];
				   mps.ast.thepathhandler.directoryChar
				     ->t.put;
				   s[]->t.append;
				   t[]->fileEdit;
			       if);
			       leave find
			    #);
			  doFragmentLink::
			    (#
			       fg: ^astInterface.Fragmentgroup;
			       fragmentBrowser: ^ymerBrowserWindow;
			       t: ^text
			    do (* INCLUDE *)
			       'Opening separate browser on '->browser.infoView.settext;
			       fle.name[]->browser.infoView.append;
			       '... '->browser.infoView.append; browser.infoView.msgPush;
			       &ymerBrowserWindow[]->fragmentBrowser[];
			       fragmentBrowser.open;
			       currentGroup.fg.fullName
				 ->mps.AST.stripPathName->t[];
			       (if t[] = none then
				   fle.name.copy
				     ->mps.AST.expandtofullpath
				     ->fragmentBrowser.addProject
				else
				   (fle.name.copy,t[])
				     ->mps.AST.thePathHandler.convertFilePath
				     ->fragmentBrowser.addProject
			       if);
			       'Browser on: '->t[];
			       fle.name[]->t.puttext;
			       t[]->fragmentBrowser.title;
			       browser.infoView.msgPop;
			       leave find
			    #);
			  doFragmentForm::
			    (# t: ^text
			    do
			       'Opening separate code viewer on '->browser.infoView.settext;
			       fle.name[]->browser.infoView.append;
			       '... '->browser.infoView.append; browser.infoView.msgPush;
			       (fle.open,none )->viewSeparate;
			       browser.infoView.msgPop;
			       leave find
			    #)
		       #);
		 state.normal
	     if)
	 if)
      #)[]->theFragmentgroupView.appendAction;
   &theFragmentgroupView.searchAction
      (#
	 getContext::
	   (# g: ^projects.group;
	   do
	      currentGroup[]->g[];
	      (if g[] <> none then g.fg[]->context[] if)
	   #);
	 select::
	   (# do state.busy; inx->sbprivate.fragmentGroupView.contents.doSelect; state.normal #);
	 info::  (#  do msg[]->browser.infoView.msg #)
      #)[]->theFragmentgroupView.appendAction

-- onCurrentProjectChange: DoPart --
do
   (if newProject[] <> none then
       newProject.location[]->browser.locationView.msg
   if);
   none ->cge[];
   none ->browser.cfe[]; none->browser.cte[]

-- onCurrentGroupChange: DoPart --
do
   (if true
    // newGroup[] <> none then
       (if newGroup.fg[] <> none then
	   newGroup.fg[]->ymerBrowserPrivate.geList.findOrCreateGroupEditor
	     ->cge[]; none->browser.cte[]
       if);
       newGroup.location[]->browser.locationView.msg;
    // cte[] <> none then
       none->cge[]; cte.path->browser.locationView.msg;
   if)

-- onCurrentFormChange: DoPart --
do
   (if newForm[] = none then
       browser.sbprivate.down.popdown
    else
       state.busy;
       'Opening '->browser.infoView.settext; newForm.name->browser.infoView.append;
       '... '->browser.infoView.append; browser.infoView.msgPush;
       ymerBrowserPrivate.history.find
	 (# predicate::
	      (#
	      do
		 (current.theForm[] = newForm[])->value
	      #);
	    notFound::
	      (# newHist: ^ymerBrowserPrivate.history.element;
	      do
		 &ymerBrowserPrivate.history.element[]->newHist[];
		 browser.currentProject[]->newHist.theProject[];
		 browser.currentGroup[]->newHist.theGroup[];
		 newForm[]->newHist.theForm[];
		 newHist[]->ymerBrowserPrivate.history.add;
		 newHist[]->(theMenubar).historyMenu.addHistoryElement;

		 newForm[]->browser.sbprivate.down.newfragment
		 ->(newHist.theCfe[], newHist.theView[]);
		 newHist.theCfe[]->browser.cfe[]; none->browser.cte[];
		 newHist.theView[]->browser.sbprivate.down.popup;
	      #)
	 do current.theCfe[]->browser.cfe[]; none->browser.cte[];
	    current.theView[]->browser.sbprivate.down.popup;
	    browser.cfe.cs->browser.cfe.setFocus;
	 #);
       browser.infoView.msgPop; state.normal
   if)

-- selectFragmentGroup: DoPart --
do
   (if (fgName[]->mps.AST.expandToFullPath
	 ->mps.fragmentGroupTable.getFragmentGroup)<>NONE then
       (if browser.currentProject[] = none then
	   (# newProj, proj: ^browser.projects.project
	   do
	      &browser.projects.project[]->newProj[];
	      fgName[]->newProj.location.puttext;
	      fgName[]->fragmentDefaultName->newProj.name[];
	      newProj[]->browser.projects.setupProject->proj[];
	      (if proj[]=NONE then
		  newProj[]->proj[]->browser.projects.theProjects.append;
		  browser.projectsChanged
	      if);
	      proj[]->browser.setProject
	   #)
       if);
       browser.currentProject.groups.find
       (#
	  predicate::  (#  do fgName[]->current.location.equal->value #);
	  notFound::
	    (# cp: ^browser.projects.project; newGroup: ^browser.projects.group
	    do
	       browser.currentProject[]->cp[];
	       &browser.projects.group[]->newGroup[];
	       fgName[]->newGroup.location.puttext;
	       fgName[]->fragmentDefaultName->newGroup.name[];
	       '+'->newGroup.name.prepend;
	       true->newGroup.temporary;
	       newGroup[]->browser.currentProject.groups.append;
	       projectsChanged;
	       (cp[],newGroup[])->browser.setGroup
	    #)
       do (browser.currentProject[],current[])->browser.setGroup
       #)
   if)

-- selectFragmentForm: DoPart --
do
   fgName[]->selectFragmentGroup;
   (# t: @text; ff: ^MPS.ast.fragmentForm;
   do
      (formName[],screen[])->browser.currentGroup.fg.open->ff[];
      (if ff[] = none then
	  'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
	    ->t.putformat (#  do formName[]->s; fgName[]->s #);
	  (none ,t[],'Warning')->alertUser
       else
	  (browser.currentProject[],browser.currentGroup[],ff[])
	    ->browser.setFragmentForm
      if)
   #)

-- ymerOnAboutToClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->browsers.has then
       INNER onAboutToClose;
       (if okToClose then
	   (if ymerBrowserPrivate.geList.closeGroups and
	       browser.sbprivate.down.aeList.closeAsciiEditors then
	       THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
	       (if browsers.empty and onTerminateApplication then
		   terminate
		else
		   browsers.scan
		     (# browser: ^ymerBrowserWindow
		     do current[]->browser[];
			THIS(ymerBrowserWindow)[]
			  ->(browser.theMenubar).windowsMenu.deleteWindow
		     #)
	       if)
	    else
	       false->okToClose
	   if)
       if)
   if)

-- ymerClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->browsers.has then
       THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
       (if browsers.empty and onTerminateApplication then
	   terminate
	else
	   browsers.scan
	     (# browser: ^ymerBrowserWindow
	     do current[]->browser[];
		THIS(ymerBrowserWindow)[]
		  ->(browser.theMenubar).windowsMenu.deleteWindow
	     #)
       if)
   if)

-- ymerCloseGroups: DoPart --
do ymerBrowserPrivate.geList.closeGroups->value

-- ymerQuit: DoPart --
do true->okToClose;
   INNER;
   (if (browsers.size = 1) and onTerminateApplication then
       terminate
    else
       (if okToClose then THIS(ymerBrowserWindow).close if)
   if)

-- ymerOpen: Descriptor --
     (# t: ^text; w,h: @integer;
     do
	browserTitle->t[];
	browserCount+1->browserCount;
	(if browserCount > 1 then (* this is not the first browser *)
	    '<'->t.put; browserCount->t.putint; '>'->t.put
	if);
	t[]->title;
	browser.open;
	ymerPrivate.edenv[]->edenv[]->browser.edenv[];
	(600,800)->THIS(ymerBrowserWindow).size;
	INNER open;
	browsers.scan
	  (# browser: ^ymerBrowserWindow
	  do current[]->browser[];
	     THIS(ymerBrowserWindow)[]
	       ->(browser.theMenubar).windowsMenu.insertWindow;
	     browser[]->(theMenubar).windowsMenu.insertWindow
	  #);
	THIS(ymerBrowserWindow)[]->browsers.append
     #)

-- browserOpen: DoPart --
do loadSettings

-- ymerInit: Descriptor --
(# i: @integer;
do
   1->i;
   l:
   (if (i+1->i) <= noOfArguments then
       (if true
	// '--mpsTrace'->(i->arguments).equalNCS then
	   ll:
	   (if (i+1->i) <= noOfArguments then
	       (if true
		// 'fragmentOpen'->(i->arguments).equalNCS then
		   (mps.AST.trace.fragmentOpen,true)->mps.AST.trace.set;
		   restart ll
		 // 'fragmentClose'->(i->arguments).equalNCS then
		    (mps.AST.trace.fragmentClose,true)->mps.AST.trace.set;
		    restart ll
		// 'onParse'->(i->arguments).equalNCS then
		   (mps.AST.trace.onParse,true)->mps.AST.trace.set;
		   restart ll
		// 'topOpen'->(i->arguments).equalNCS then
		   (mps.AST.trace.topOpen,true)->mps.AST.trace.set;
		   restart ll
		// 'compactOpen'->(i->arguments).equalNCS then
		   (mps.AST.trace.compactOpen,true)->mps.AST.trace.set;
		   restart ll
		// 'grammars'->(i->arguments).equalNCS then
		   (mps.AST.trace.grammars,true)->mps.AST.trace.set;
		   restart ll
		// 'parsingComments'->(i->arguments).equalNCS then
		   (mps.AST.trace.parsingComments,true)->mps.AST.trace.set;
		   restart ll
		// 'getnextComment'->(i->arguments).equalNCS then
		   (mps.AST.trace.getnextComment,true)->mps.AST.trace.set;
		   restart ll
		// 'editingComments'->(i->arguments).equalNCS then
		   (mps.AST.trace.editingComments,true)->mps.AST.trace.set;
		   restart ll
		// 'parser'->(i->arguments).equalNCS then
		   (mps.AST.trace.parser,true)->mps.AST.trace.set;
		   restart ll
		// 'getBinding'->(i->arguments).equalNCS then
		   (mps.AST.trace.getBinding,true)->mps.AST.trace.set;
		   restart ll
		// 'getBindingMark'->(i->arguments).equalNCS then
		   (mps.AST.trace.getBindingMark,true)->mps.AST.trace.set;
		   restart ll
	       if)
	   if)
	// '--ymerhelp'->(i->arguments).equalNCS then
	   'Ymer options are "--mpsTrace n1 ...", where ni is one of:'->putline;
	   '  fragmentOpen: Trace mps fragmentOpen'->putline;
	   '  onParse: Trace mps onParse'->putline;
	   '  topOpen: Trace mps topOpen'->putline;
	   '  compactOpen: Trace mps compactOpen'->putline;
	   '  grammars: Trace mps grammars'->putline;
	   '  parsingComments: Trace mps parsingComments'->putline;
	   '  getnextComment: Trace mps getnextComment'->putline;
	   '  editingComments: Trace mps editingComments'->putline;
	   '  parser: Trace mps parser'->putline;
	   '  getBinding: Trace mps getBinding'->putline;
	   '  getBindingMark: Trace mps getBindingMark'->putline;
       if);
       restart l
   if);
   mps.init;
   browsers.init;
   loadEditorEnv;
   ('BETA: Frequently Asked Questions (FAQ)',
    '~beta/doc/faq/beta-language-faq.html')
     ->helpDocument;
   ('Ymer: Short Manual',
    '~beta/sourcebrowser/v1.2/doc/ymer.html')
     ->helpDocument;
   ('Ymer: Known Bugs and Inconveniences',
    '~beta/sourcebrowser/v1.2/doc/ymer.bugs')
     ->helpDocument;
   INNER init;
   userGrammarInit;
#)

-- ymerMPSinit: DoPart --
do dg.init; dg.xverboselevel.nothing->dg.xverboselevel;
   machine_type->dg.TargetMachine[];
   machine_type->dg.TargetDirectory[];
   INNER

-- ymerHelpDocument: DoPart --
do
   &ymerPrivate.helpDocuments.element[]->ymerPrivate.helpDocuments.append;
   title[]->(ymerPrivate.helpDocuments.last).elm.title[];
   path[]->(ymerPrivate.helpDocuments.last).elm.path[]

-- loadEditorEnv: DoPart --
do (# editorEnvWindow: @window; initHere: @boolean
   do
      objectPool.get
	(#
	   type:: editorEnvWindow.editorEnv;
	   init::
	     (#
	     do
		true->inithere;
		(mps.ast[],mps.betaCFL[],THIS(ymerApplication)[])->obj.init
	     #)
	#)->ymerPrivate.edenv[];
   #)
