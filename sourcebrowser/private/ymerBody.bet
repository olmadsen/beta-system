ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.4/formatio'
        '~beta/sysutils/v1.4/pathhandler'
        '~beta/pro/v1.4/osinterface'
        '~beta/editor/v5.0/fragmentscanner'
        '~beta/mps/v4.9.1/findgrammar'
        'fileEditor'
        'parseEditor'
        'sourcebrowserbody'
        'ymerFileUtils'
        'ymerPrivate'
        'separateCodeEditor';
BODY 'settings';
-- historyMenuLib: Attributes --
findAndSelect:
  (# node: ^astInterface.ast
  enter node[]
  do
     (if node[] <> none then
         (if ymerBrowserPrivate.cfe[] <> none then
             (if node.frag[] <> ymerBrowserPrivate.cfe.frag[] then
                 ((node.frag.father).fullName,node.frag.name)
                   ->browser.selectFragmentForm;
                 (if not ymerBrowserPrivate.cfe.theSifTexteditor.textediting
                  then
                     (node[],1,0,0)->ymerBrowserPrivate.cfe.setFocus
                  else
                     (none ,'Cannot reestablish focus - text edit active',
                      'History')->noteUser
                 if)
              else
                 (node[],1,0,0)->ymerBrowserPrivate.cfe.setFocus
             if)
          else
             ((node.frag.father).fullName,node.frag.name)
               ->browser.selectFragmentForm;
             (if not ymerBrowserPrivate.cfe.theSifTexteditor.textediting then
                 (node[],1,0,0)->ymerBrowserPrivate.cfe.setFocus
              else
                 (none ,'Cannot reestablish focus - text edit active','History')
                   ->noteUser
             if)
         if)
      else
         (none ,'Should not happen - node[] is none!','History')->alertUser
     if)
  #);
back: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((ymerBrowserPrivate.cfe[] <> none ) and
                (ymerBrowserPrivate.cfe.cs[] <> none ) and
                (ymerBrowserPrivate.cfe.cs.node[] <> none ) and
                (ymerBrowserPrivate.cfe.cs.node[]->edenv.history.BackPossible))
                 ->value;
               
            #);
          onSelect:: 
            (# 
            do
               ymerBrowserPrivate.cfe.cs.node[]->edenv.history.back
                 ->findAndSelect
            #)
       #);
     open::  (#  do 'Back'->name; 'b'->key #)
  #);
forward: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((ymerBrowserPrivate.cfe[] <> none ) and
                (ymerBrowserPrivate.cfe.cs[] <> none ) and
                (ymerBrowserPrivate.cfe.cs.node[] <> none ) and
                (ymerBrowserPrivate.cfe.cs.node[]
                   ->edenv.history.forwardPossible))->value;
               
            #);
          onSelect:: 
            (# 
            do
               ymerBrowserPrivate.cfe.cs.node[]->edenv.history.forward
                 ->findAndSelect
            #)
       #);
     open::  (#  do 'Forward'->name; 'f'->key #)
  #);
historyMenuItem: menuItem
  (#
     theHist: ^ymerBrowser.ymerBrowserPrivate.history.element;
     eventhandler:: 
       (#
          onSelect:: 
            (# 
            do
               theHist.theProject[]->browser.setProject;
               (theHist.theProject[],theHist.theGroup[])->browser.setGroup;
               (theHist.theProject[],theHist.theGroup[],theHist.theForm[])
                 ->browser.setFragmentForm;
               
            #);
          
       #);
     setName:
       (# t: ^text; 
       do
          theHist.theGroup.name.copy->t[];
          '-'->t.append;
          theHist.theForm.name->t.append;
          t[]->name;
          
       #)
  #);
addHistoryElement:
  (#
     theHist: ^ymerBrowser.ymerBrowserPrivate.history.element;
     newHitem: ^historyMenuItem;
     
  enter theHist[]
  do
     (if not protected then
         &historyMenuItem[]->newHitem[];
         newHitem.open;
         theHist[]->newHitem.theHist[];
         newHitem[]->append;
         newHitem.setName;
         
     if)
  #);
closeHistoryElement:
  (#
     oldElement: ^ymerBrowser.ymerBrowserPrivate.history.element;
     theHitem: ^historyMenuItem
  enter oldElement[]
  do
     l: scan
       (# 
       do
          (if current## <= historyMenuItem## then
              current[]->theHitem[];
              (if theHitem.theHist[] = oldElement[] then
                  theHitem[]->historyMenu.delete; leave l
              if)
          if)
       #)
  #);
protect:
  (# status: @boolean
  do protected->status; true->protected; INNER protect; status->protected
  #);
  

-- historyMenuOpen: DoPart --
do
   'History'->name;
     (# item: ^menuItem
     do
        &back[]->item[];
        item.open;
        item[]->append;
        &forward[]->item[];
        item.open;
        item[]->append;
        &separator[]->item[];
        item.open;
        item[]->append;
        
     #)  

-- browserSelectNode: DoPart --
do
   (if separate then
       ymerBrowserPrivate.cfe.openSubeditor
    else
       (((node.frag.father).fullName).copy,(node.frag.name).copy)
         ->selectFragmentForm;
       node[]->(getFragmentFormEditor).SifViewer.setNode
   if)  

-- browserFileEdit: DoPart --
do
     (# fe: @fileEditor (# open::  (#  do (600,800)->size #) #); 
     do fe.open; makefile[]->fe.loadFile; 
     #)  

-- ymerMPSparseerrors: DoPart --
do
   true->continue;
     (#
        pe: @ymerBrowser.browser.parseEditor
          (# open::  (#  do (600,800)->size; groupName[]->loadFiles #)
          #);
        
     do pe.open
     #)  

-- ymerMPSbetaparserinit: Descriptor --
(# bobsFile: @file; grammarWithPath,help: ^text; 
do
   (if not BETACFL.parser.haveBeenInitialized then
       '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
       (if BETACFL.grammarAst[]
        // none then
           'No grammarAst for '->screen.putText;
           grammarWithPath[]->screen.putLine;
           
        else
           '-parser'->help[];
           mps.ast.parserFileExtension->help.append;
           help[]->grammarWithPath.copyAppend->mps.ast.expandToFullPath
             ->bobsFile.name;
           (if bobsFile.entry.exists then
               bobsFile.name->BETACFL.parser.initialize;
               ('objectdescriptor','descriptor')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               ('attributedecl','attributes')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               
            else
               'No parser available: '->screen.putText;
               bobsFile.name->screen.putLine;
               
           if);
           
       if);
       
   if)
#)  

-- ymerLoadProject: DoPart --
do
   (if true
    // proj.isDirectory // proj.isDotDotDirectory // proj.isRoot
    // proj.isExtent // proj.isDomain then
         (# newProj: ^browser.projects.project; t: ^text; 
         do
            &browser.projects.project[]->newProj[];
            proj.location.copy->newProj.location.puttext;
            newProj[]->browser.projects.setupProject;
            proj.isDirectory->newproj.isDirectory;
            proj.isRoot->newProj.isRoot;
            proj.isExtent->newProj.isExtent;
            proj.isDomain->newProj.isDomain;
            newProj[]->browser.projects.theProjects.append;
            'Browser on: '->t[];
            newProj.name[]->t.append;
            (if true
             // proj.isExtent then
                ' [extent]'->t.append; 
             // proj.isDomain then
                ' [domain]'->t.append; 
            if);
            t[]->title;
            
         #)
    // proj.isProjectFile // proj.hasSubprojects then
         (# t: ^text
         do
            proj.subprojects.scan
              (# 
              do
                 current.copy->browser.projects.theProjects.append;
                 none ->current.superProject[]
              #);
            'Browser on: '->t[];
            proj.name[]->t.append;
            t[]->title;
            
         #);
       
   if);
   browser.projectsChanged;
     

-- ymerAddProject: DoPart --
do location[]->appendProject; appendDone;   

-- ymerAppendProject: DoPart --
do
   &browser.projects.project[]->newProj[];
   location[]->fragmentDefaultName->newProj.name[];
   location[]->MPS.ast.expandToFullPath->newProj.location.puttext;
   newProj[]->browser.projects.setupProject;
   newProj[]->browser.projects.theProjects.append;
     

-- ymerAppendDone: DoPart --
do
   browser.projectsChanged;
   (browser.projects.theProjects.last).elm[]->browser.setProject;
     

-- ymerGroupClose: DoPart --
do
   ymerBrowserPrivate.history.iterate
     (#
        where:: 
          (# 
          do (current.elm.theGroup.location[]->location.equalNCS)->value
          #);
        
     do
        current.elm[]
          ->
            (THIS(ymerBrowserWindow).theMenubar).historyMenu.
              closeHistoryElement;
        current[]->ymerBrowserPrivate.history.delete;
        current.elm.theGroup. (*get*) fg[]
          ->ymerBrowserPrivate.geList.closeGroup;
        (if currentProject[] <> none then
            none ->currentProject.lastGroupSelected[]
        if);
        (if currentGroup[] <> none then
            none ->currentGroup.lastFormSelected[]
        if);
        (currentProject[],none )->setGroup;
        none ->cge[];
        none ->ymerBrowserPrivate.cfe[];
        
     #)  

-- ymerGroupGetFg: DoPart --
do
   (if not THIS(group).location.empty then
       THIS(group).location[]->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (if fg[] <> none then fg[]->doRealOpen;  if)
   if);
     

-- projectInfoLib: Attributes --
setupProject:
  (# f: @file; ext,name: ^text; t: ^text; proj,root: ^project
  enter proj[]
  do
     proj.location[]->f.name;
     f.entry.path.name.suffix->ext[];
     (if (ext[] <> none ) and (ext.length > 0) then
         (if true
          // mps.AST.astFileExtension->ext.equalNCS then
             (proj.location.length-(mps.AST.astFileExtension).length+1,
              proj.location.length)->proj.location.delete;
             
          // ext[]->ymerPrivate.grammarTable.checkExtension then
             (proj.location.length-(ext.length-1),proj.location.length)
               ->proj.location.delete;
             
         if)
     if);
     (if (proj.location.length->proj.location.inxGet) = ph.directoryChar then
         (proj.location.length,proj.location.length)->proj.location.delete; 
     if);
     (proj.location[],ph.currentDirectory)->ph.convertfilepath->f.name;
     (if proj.name[] = none then f.entry.path.name->proj.name[] if);
     (proj.location[],ph.currentDirectory)->ph.convertfilepath->f.name;
     (if proj.name[] = none then f.entry.path.name->proj.name[] if);
     (if true
      // f.entry.exists and f.entry.readable and f.entry.isDirectory then
         true->proj.isDirectory;
         (if (proj.location.length->proj.location.inxGet) <> ph.directoryChar
          then
             proj.location.length->proj.location.pos;
             ph.directoryChar->proj.location.put
         if);
         (if (proj.name.length > 0) and
         ((proj.name.length->proj.name.inxGet) <> '/') then
             '/'->proj.name.append; 
         if);
         
      else
         f.entry.path.name.suffix->ext[];
         f.name->name[];
         (if true
          //
          f.entry.exists
          and
          f.entry.readable
          and
          (mps.AST.astfileExtension->ext.equal)
          //
          f.entry.exists
          and
          f.entry.readable
          and
          (ext[]->ymerPrivate.grammarTable.checkExtension)
          //
          (mps.AST.astfileExtension->name.copyappend->fileExists)
          and
          (mps.AST.astfileExtension->name.copyappend->fileReadable)
          //
          ymerPrivate.grammarTable.scanExtensions
            (# fn: ^text; found: @boolean
            do
               found or
               ((current[]->name.copyappend->fn[]->fileExists) and
                (fn[]->fileReadable))->found
            exit found
            #) then
             (if (proj.name.length->proj.name.inxGet) <> '*' then
                 '*'->proj.name.append; 
             if);
             true->proj.isRoot;
             proj[]->root[];
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isDomain;
             '[domain]'->proj.name[];
             root[]->proj.superProject[];
             proj[]->root.subprojects.append;
             &browser.projects.project[]->proj[];
             root.location->proj.location;
             true->proj.isExtent;
             '[extent]'->proj.name[];
             root[]->proj.superProject[];
             proj[]->root.subprojects.append;
             
          // f.entry.exists and f.entry.readable and ('.pjt'->ext.equal) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length > 0) and
             ((proj.name.length->proj.name.inxGet) <> '+') then
                 '+'->proj.name.append; 
             if);
             (f.name,proj[])->theProjects.parseProjectFile;
             
          //
          ('.pjt'->(f.name).append->fileExists)
          and
          ('.pjt'->(f.name).append->fileReadable) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length > 0) and
             ((proj.name.length->proj.name.inxGet) <> '+') then
                 '+'->proj.name.append; 
             if);
             ('.pjt'->(f.name).append,proj[])->theProjects.parseProjectFile;
             
         if)
     if)
  #);
  

-- scanGroupsImpl: DoPart --
do
   ''->infoView.msg;
   (if true
    // isRoot then
       (if groups.size = 0 then (* this is the first time we visit this root *)
           &browser.projects.group[]->newGroup[];
           (location[],ph.currentDirectory)->ph.convertfilepath
             ->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else
       (* we have visited this root previously *)
           groups.scan (#  do current[]->thescan.foreach #)
       if)
    // isExtent then
       (if groups.size = 0 then
       (* the extent haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)->ph.convertfilepath
             ->mps.dg.scanExtent
               (# 
               do
                  &browser.projects.group[]->newGroup[];
                  (current.fullname,ph.currentDirectory)->ph.convertfilepath
                    ->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects;
           
        else
       (* the extent have previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if)
    // isDomain then
       (if groups.size = 0 then
       (* the domain haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)->ph.convertfilepath
             ->mps.dg.scanDomain
               (# 
               do
                  &browser.projects.group[]->newGroup[];
                  (current.fullname,ph.currentDirectory)->ph.convertfilepath
                    ->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects;
           
        else
       (* the domain have previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if)
    // isDirectory then
       (if groups.size=0 then
           (* the directory haven't previously been scanned *)
           (# d: @directory; count: @integer;
           do this(Project).groups.clear;
              (if location.empty then
                  ph.currentDirectory->location.puttext;
              if);
              (location[],ph.currentDirectory)
                ->ph.convertfilepath->d.name;
              d.scanEntries
              (# error:: (# do true->continue #)
              do select
                 (# error:: (# do true->continue #);
                    whenFile::
                      (# f: ^file; ext: ^Text;
                      do &browser.projects.group[]->newGroup[];
                         thefile->f[];
                         f.entry.path.name.suffix
                           ->ext[];
                         f.entry.path.name
                           ->newGroup.location.puttext;
                         (if true
                          // f.entry.exists and
                             f.entry.readable and
                             (mps.AST.astfileExtension
                               ->ext.equal)
                          // f.entry.exists and
                             f.entry.readable and
                             (ext[]<>NONE) and (ext.length>0) and
                             (ext[]->ymerPrivate.grammarTable.checkExtension) then
                             (newGroup.location.length-(ext.length-1),newGroup.location.length)
                               ->newGroup.location.delete;
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name.prefix
                                   ->newGroup.name[];
                                 count+1->count;
                                 newGroup[]->groups.append;
                                 newGroup[]->thescan.foreach
                             if);
                          // f.entry.exists and
                             f.entry.readable then
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name
                                   ->newGroup.name[];
                                 (* activate this code to allow _all_
                                  * files to be shown
                                  *)
                                 (* count+1->count;
                                  * newGroup[]->groups.append;
                                  * newGroup[]->thescan.foreach
                                  *)
                             if);
                         if);
                      #)
                 #)
              #);
              (if count=0 then
                  'no fragments in project'
                    ->infoView.msg;
              if)
           #)
        else
       (* the directory have previously been scanned *)
           groups.scan (#  do current[]->thescan.foreach #)
       if)
    // groups.size <> 0 then
       groups.scan (#  do current[]->thescan.foreach #)
    else
       (if not unfolded then
           'open project to find subprojects'->infoView.msg; 
        else
           'open subproject to find fragments'->infoView.msg; 
       if)
   if)  

-- browserLib: Attributes --
setupDotDot:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
     d: @directory;
     location: ^text;
     level: @integer;
     superProject,superSuperProject: ^browser.projects.project;
     createParentProject:
       (# newProj: ^browser.projects.project
       do
          &browser.projects.project[]->newProj[];
          location->newProj.location;
          newProj[]->browser.projects.setupProject;
          (newProj[],superProject[]->browser.projects.theProjects.at)
            ->browser.projects.theProjects.insertBefore;
          superProject.level->newProj.level;
          (for newProj.level repeat '  '->newProj.name.prepend for);
          superProject.level+1->superProject.level;
          '  '->superProject.name.prepend;
          l:
          (superProject[]->browser.projects.theProjects.at).succ[]
            ->browser.projects.theProjects.iterateFrom
              (# 
              do
                 (if current.elm.level >= superProject.level then
                     current.elm.level+1->current.elm.level;
                     '  '->current.elm.name.prepend;
                     
                  else
                     leave l
                 if);
                 
              #);
          superProject.subprojects.clear;
          true->newProj.unfolded;
          newProj[]->foldSubprojects;
          newProj[]->unfoldSubprojects;
          browser.projectsChanged;
          newProj[]->browser.setProject;
          
       #);
     
  enter proj[]
  do
  (* we now have to create a new project to contain the
   * parent directory of currentDirectory
   *)
     ((1,proj.location.length-1)->proj.location.sub,ph.currentDirectory)
       ->ph.convertfilepath->location[];
     ph.directoryChar->location.put;
     proj.superProject[]->superProject[];
     (if superProject[] <> none then
         superProject.level->level;
         superProject.superProject[]->superSuperProject[];
         (if superSuperProject[] <> none then
             (if superSuperProject.isDirectory then
             (* this is the .. directory - select it *)
                 superSuperProject[]->setProject; 
              else
             (* try to locate the '..' project in
              * superSuperProject
              *)
                 l:
                   (# 
                   do
                      superSuperProject.subprojects.iterate
                        (# 
                        do
                           (if current.elm.location[]->location.equal then
                               current.elm[]->setProject; leave l
                           if);
                           
                        #);
                      (* not found - create it *)
                      createParentProject;
                      
                   #);
                 
             if)
          else
         (* OK, we are 'on the top'.  Try those *)
             l:
               (# 
               do
                  browser.projects.theProjects.iterate
                    (#
                       where:: 
                         (#  do (current.elm.level = level)->value #);
                       
                    do
                       (if current.elm.location[]->location.equal then
                           current.elm[]->setProject; leave l
                       if);
                       
                    #);
                  (* not found - create it *)
                  createParentProject;
                  
               #);
             
         if);
         
     if);
     
  #);
unfoldSubprojects:
  (#
     proj: ^browser.projects.project;
     projPos: ^projects.theProjects.theCellType;
     
  enter proj[]
  do
     ''->infoView.msg;
     (proj[]->projects.theProjects.at).succ[]->projPos[];
     (if true
      // proj.hasSubprojects // proj.isRoot then
         proj.subprojects.scan
           (# 
           do
              proj.level+1->current.level;
              (for current.level repeat '  '->current.name.prepend for);
              (current[],projPos[])->projects.theProjects.insertBefore;
              
           #);
         proj.subprojects.scan
           (# 
           do (if current.unfolded then current[]->unfoldSubprojects if)
           #);
         
      // proj.isDirectory then
         (if proj.subprojects.size=0 then
             (* the directory haven't previously been unfolded *)
             (# d: @directory; f: @file; level: @integer;
             do (proj.location[],ph.currentDirectory)
                  ->ph.convertfilepath->d.name;
                d.scanEntries
                (# error:: (# do true->continue #)
                do select
                   (# error:: (# do true->continue #);
                      whenDir::
                        (# d: ^directory;
                           name: ^text; location: ^text;
                           newProj: ^browser.projects.project;
                           create, dotdot: @boolean;
                        do thedir->d[];
                           d.entry.path.name->name[];
                           (if true
                            // '.'->name.equalNCS
                            // 'sun4s'->name.equalNCS
                            // 'sun4'->name.equalNCS
                            // 'sun3'->name.equalNCS
                            // 'snake'->name.equalNCS
                            // 'sgi'->name.equalNCS
                            // 'nti'->name.equalNCS
                            // 'linux'->name.equalNCS
                            // 'hpux9mc'->name.equalNCS
                            // 'hpux9pa'->name.equalNCS
                            // 'hpux8'->name.equalNCS
                            // 'b2c'->name.equalNCS then
                               false->create;
                            // '..'->name.equalNCS then
                               true->create; true->dotdot;
                            else
                               true->create; false->dotdot;
                           if);
                           (if create then
                               &browser.projects.project[]
                                 ->newProj[];
                               true->newProj.isDirectory;
                               (d.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->location[];
                               location[]->f.name;
                               &text[]->newProj.name[];
                               proj.level+1->newProj.level;
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               '/'->newProj.name.append;
                               (if dotdot then
                                   true->newProj.isDotDotDirectory;
                                   (f.entry.path.head)->f.name;
                                   (f.entry.path.head)->location[]
                               if);
                               location[]->newProj.location.puttext;
                               (if (newProj.location.length
                                     ->newProj.location.inxGet)<>ph.directoryChar
                                   then
                                   ph.directoryChar->newProj.location.put
                               if);
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[], projPos[])
                                     ->projects.theProjects.insertBefore;
                                   proj[]->newProj.superProject[];
                                   newProj[]->proj.subprojects.append;
                               if)
                           if)
                        #);
                      whenFile::
                        (# f: ^file; name: ^text;
                           newProj: ^browser.projects.project;
                        do thefile->f[];
                           f.entry.path.name->name[];
                           (if true
                            // '.pjt'->(f.entry.path.name.suffix).equal then
                               &browser.projects.project[]
                                 ->newProj[];
                               (f.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               (newProj.location.length-3,newProj.location.length)
                                 ->newProj.location.delete;
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               (newProj.name.length-3,newProj.name.length)
                                 ->newProj.name.delete;
                               '+'->newProj.name.append;
                               true->newProj.hasSubprojects;
                               (f.name,newProj[])
                                 ->proj.subprojects.parseProjectFile;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[], projPos[])
                                     ->projects.theProjects.insertBefore;
                                   proj[]->newProj.superProject[];
                                   newProj[]->proj.subprojects.append;
                               if)
                           if)
                        #)
             #)#)#)
          else
         (* the directory have previously been unfolded *)
             proj.subprojects.scan
               (# 
               do
                  (for current.level repeat '  '->current.name.prepend for);
                  (current[],projPos[])->projects.theProjects.insertBefore;
                  
               #);
             proj.subprojects.scan
               (# 
               do (if current.unfolded then current[]->unfoldSubprojects if)
               #);
             
         if)
     if)
  #);
foldSubprojects:
  (# proj: ^browser.projects.project; level: @integer
  enter proj[]
  do
     ''->infoView.msg;
     proj.level->level;
     loop:
     (proj[]->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
         (# 
         do
            (if current.elm.level > level then
                (1,current.elm.level*2)->current.elm.name.delete;
                current[]->projects.theProjects.delete
             else
                leave loop
            if)
         #);
     
  #);
projectByIndex:
  (# inx: @integer; foundProj: ^browser.projects.project; 
  enter inx
  do
     find: projects.theProjects.scan
       (# 
       do inx-1->inx; (if inx = 0 then current[]->foundProj[]; leave find if)
       #)
  exit foundProj[]
  #);
  

-- onProjectListOpen: DoPart --
do
   &theprojectlist.action
     (#
        eventtype:: theprojectlist.theeventhandler.mousedown;
        i: @integer;
        selectedProj: ^browser.projects.project;
        
     do
        (if (theprojectlist.selection.first->i) <> 0 then
            (if theEvent.doubleClick then
                (if theEvent.shiftKey then
                      (# fragmentBrowser: ^ymerBrowserWindow; t: ^text; 
                      do
                         &ymerBrowserWindow[]->fragmentBrowser[];
                         fragmentBrowser.open;
                         i->projectByIndex->selectedProj[];
                         selectedProj[]->fragmentBrowser.loadProject;
                         
                      #)
                 else
                    i->projectByIndex->selectedProj[];
                    (if true
                     // selectedProj.isDotDotDirectory then
                        selectedProj[]->setupDotDot; 
                     // selectedProj.unfolded then
                        false->selectedProj.unfolded;
                        selectedProj[]->foldSubprojects;
                        projectsChanged;
                        selectedProj[]->setProject;
                        
                     else
                        true->selectedProj.unfolded;
                        selectedProj[]->unfoldSubprojects;
                        projectsChanged;
                        selectedProj[]->setProject;
                        
                    if)
                if)
            if)
        if)
     #)[]->theprojectlist.appendAction;
     

-- onGroupListOpen: DoPart --
do
   &thegrouplist.action
     (#
        eventtype:: thegrouplist.theeventhandler.mousedown;
        selectedGroup: ^projects.group;
        root,newProj: ^browser.projects.project;
        
     do
        (if (thegrouplist.selection.first) <> 0 then
            (if theEvent.doubleClick then
            (* do what's needed to make THIS into a root *)
                thegrouplist.selection.first->groups.getGroupByIndex
                  ->selectedGroup[];
                &browser.projects.project[]->newProj[];
                selectedGroup.location->newProj.location;
                (if newProj.name[] = none then
                    selectedGroup.name.copy->newProj.name[]
                if);
                (if (newProj.name.length->newProj.name.inxGet) <> '*' then
                    '*'->newProj.name.append; 
                if);
                true->newProj.isRoot;
                newProj[]->root[];
                &browser.projects.project[]->newProj[];
                root.location->newProj.location;
                true->newProj.isDomain;
                '[domain]'->newProj.name[];
                root[]->newProj.superProject[];
                newProj[]->root.subprojects.append;
                &browser.projects.project[]->newProj[];
                root.location->newProj.location;
                true->newProj.isExtent;
                '[extent]'->newProj.name[];
                root[]->newProj.superProject[];
                newProj[]->root.subprojects.append;
                (if theEvent.shiftKey then
                      (# fragmentBrowser: ^ymerBrowserWindow; t: ^text; 
                      do
                         &ymerBrowserWindow[]->fragmentBrowser[];
                         fragmentBrowser.open;
                         root[]->fragmentBrowser.loadProject;
                         (*'Browser on: '->t[];
                          root.name[]->t.puttext;
                          t[]->fragmentBrowser.title*)
                         
                      #)
                 else
                    root[]->projects.theProjects.append;
                    projectsChanged;
                    root[]->setProject;
                    
                if)
            if)
        if)
     #)[]->thegrouplist.appendAction;
     

-- onFragmentgroupViewOpen: DoPart --
do
   &theFragmentgroupView.action
     (#
        eventtype:: theFragmentgroupView.theeventhandler.mouseup;
        inx: @integer;
        fgs: @fragmentGroupScanner;
        
     do
        (if (theFragmentgroupView.selection.first->inx) <> 0 then
            (if theEvent.doubleClick then
                (if theEvent.shiftKey then
                    (mps.AST[],currentGroup. (*get*) fg[])->fgs;
                    fgs.scanPropsAndFragsForText
                    (* HACK to initialize fgs properly
                     * - error in fragmentGroupScanner implementation
                     * - does not currently initialize noOfProgs
                     *   in scanPropsAndFrags
                     *) ;
                    find:
                    (currentGroup. (*get*) fg[],inx)
                      ->fgs.scanPropsAndFrags
                        (#
                           doProperty:: 
                             (#
                                t: ^Text;
                                fragmentBrowser: ^ymerBrowserWindow;
                                
                             do (* ORIGIN,BODY, MDBODY or MAKE *)
                                (if true
                                 // 'ORIGIN'->prop.equalNCS
                                 // 'BODY'->prop.equalNCS
                                 // 'MDBODY'->prop.equalNCS then
                                    &ymerBrowserWindow[]->fragmentBrowser[];
                                    fragmentBrowser.open;
                                    s[]->fragmentBrowser.addProject;
                                    'Browser on: '->t[];
                                    s[]->t.puttext;
                                    t[]->fragmentBrowser.title
                                 // 'MAKE'->prop.equalNCS then
                                    s[]->makeFileEdit; 
                                if);
                                leave find;
                                
                             #);
                           doFragmentLink:: 
                             (#
                                fl: ^astInterface.FragmentLink;
                                fragmentBrowser: ^ymerBrowserWindow;
                                t: ^text;
                                
                             do (* INCLUDE *)
                                fle.open->fl[];
                                &ymerBrowserWindow[]->fragmentBrowser[];
                                fragmentBrowser.open;
                                fl.name->fragmentBrowser.addProject;
                                'Browser on: '->t[];
                                fl.name->t.puttext;
                                t[]->fragmentBrowser.title;
                                leave find;
                                
                             #);
                           doFragmentForm:: 
                             (#  do fle.open->viewSeparate; leave find;  #);
                           
                        #);
                    
                if)
            if)
        if)
     #)[]->theFragmentgroupView.appendAction;
   &thefragmentgroupview.action
     (#
        eventtype:: thefragmentgroupview.theeventhandler.keydown;
        ch: @char;
        inx,i: @integer;
        searching: @boolean;
        g: ^projects.group;
        fg,lastFg: ^astInterface.fragmentGroup;
        prefix,msg: @text
     do
        theevent.ch->ch;
        (if ch
         // ascii.ht (* <ctrl>i / ^i *) then
            currentGroup[]->g[];
            (if g[] <> none then
                g. (*get*) fg[]->fg[];
                (if fg[] <> lastFg[] then fg[]->lastFg[]; 0->inx;  if)
            if);
            true->searching;
            inx+1->inx;
            
         // ascii.nl // ascii.cr then
            false->searching; prefix.clear; ''->infoView.msg; 
         else
            (if searching and not (ch->ascii.isWhiteSpace) then
                ch->prefix.put; 
            if);
            
        if);
        (if searching then
            (if inx = 0 then
                'Wrapped search for "'->msg; 
             else
                'Search for "'->msg; 
            if);
            prefix[]->msg.puttext;
            '"'->msg.put;
            msg[]->infoView.msg;
            0->i;
            l:
              (# 
              do
                 fg.fragmentList.scan
                   (# ff: ^mps.AST.fragmentForm; n: ^text
                   do
                      (if current.type
                       // mps.AST.formType then
                          (if (i+1->i) >= inx then
                              (1,prefix.length)->current.name.sub->n[];
                              (if prefix[]->n.equalNCS then
                                  current.open->ff[];
                                  i->inx;
                                  (if ff[] <> currentForm[] then
                                      (currentProject[],currentGroup[],ff[])
                                        ->setFragmentForm;
                                      
                                  if);
                                  leave l;
                                  
                              if)
                          if)
                      if)
                   #);
                 (* wrap search from the beginning *)
                 - 1->inx;
                 'Failing search for "'->msg;
                 prefix[]->msg.puttext;
                 '"'->msg.put;
                 msg[]->infoView.msg;
                 
              #)
        if);
        
     #)[]->thefragmentgroupview.appendAction;
     

-- onCurrentProjectChange: DoPart --
do
   (if newProject[] <> none then
       newProject.location[]->locationView.msg; 
   if);
     

-- onCurrentGroupChange: DoPart --
do
   (if newGroup[] <> none then
       newGroup.location[]->locationView.msg;
       (if newGroup.fg[] <> none then
           newGroup.fg[]->ymerBrowserPrivate.geList.findOrCreateGroupEditor
             ->cge[];
           
       if);
       
   if)  

-- onCurrentFormChange: DoPart --
do
   (if newForm[] <> none then
       ymerBrowserPrivate.history.find
         (#
            predicate:: 
              (# 
              do
                 ((current.theProject.location[]
                     ->browser.currentProject.location.equalNCS) and
                  (current.theGroup.location[]
                     ->browser.currentGroup.location.equalNCS) and
                  (current.theForm[] = newForm[]))->value
              #);
            notFound:: 
              (# newHist: ^ymerBrowserPrivate.history.element
              do
                 &ymerBrowserPrivate.history.element[]->newHist[];
                 browser.currentProject[]->newHist.theProject[];
                 browser.currentGroup[]->newHist.theGroup[];
                 newForm[]->newHist.theForm[];
                 newHist[]->ymerBrowserPrivate.history.prepend;
                 newHist[]
                   ->
                     (theMenubar).historyMenu.
                       addHistoryElement;
                 
              #)
         #);
       (newForm.root[],none ,browser.sbprivate.down.fragmentView.contents[],
        cge[])->edenv.findOrCreateFormEditor->ymerBrowserPrivate.cfe[];
       
   if);
     

-- selectFragmentGroup: DoPart --
do
   (if browser.currentProject[] = none then
         (# newProj: ^browser.projects.project
         do
            &browser.projects.project[]->newProj[];
            '+tmp'->newProj.name[];
            '/tmp/'->newproj.location.puttext;
            newProj[]->browser.projects.setupProject;
            newProj[]->browser.projects.theProjects.append;
            browser.projectsChanged;
            newProj[]->browser.setProject;
            
         #);
       
   if);
   browser.currentProject.groups.find
     (#
        predicate::  (#  do fgName[]->current.location.equalNCS->value #);
        notFound:: 
          (# cp: ^browser.projects.project; newGroup: ^browser.projects.group
          do
             browser.currentProject[]->cp[];
             &browser.projects.group[]->newGroup[];
             fgName[]->newGroup.location.puttext;
             fgName[]->fragmentDefaultName->newGroup.name[];
             '+'->newGroup.name.prepend;
             true->newGroup.temporary;
             newGroup[]->browser.currentProject.groups.append;
             projectsChanged;
             (cp[],newGroup[])->browser.setGroup;
             
          #)
     do (browser.currentProject[],current[])->browser.setGroup
     #)  

-- selectFragmentForm: DoPart --
do
   fgName[]->selectFragmentGroup;
     (# t: @text; ff: ^MPS.ast.fragmentForm; 
     do
        (formName[],screen[])->browser.currentGroup.fg.open->ff[];
        (if ff[] = none then
            'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
              ->t.putformat (#  do formName[]->s; fgName[]->s #);
            (none ,t[],'Warning')->alertUser
         else
            (browser.currentProject[],browser.currentGroup[],ff[])
              ->browser.setFragmentForm
        if);
        
     #)  

-- ymerOnAboutToClose: DoPart --
do
   INNER onAboutToClose;
   (if okToClose then
       (if ymerBrowserPrivate.geList.closeGroups then
           THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
           (if browsers.empty then
               terminate
            else
               browsers.scan
                 (# 
                 do
                    THIS(ymerBrowserWindow)[]
                      ->(current.theMenubar).windowsMenu.deleteWindow
                 #)
           if)
        else
           false->okToClose
       if)
   if)  

-- ymerClose: DoPart --
do
   THIS(ymerBrowserWindow)[]->browsers.at->browsers.delete;
   (if browsers.empty then
       terminate
    else
       browsers.scan
         (# 
         do
            THIS(ymerBrowserWindow)[]
              ->(current.theMenubar).windowsMenu.deleteWindow
         #)
   if)  

-- ymerCloseGroups: DoPart --
do ymerBrowserPrivate.geList.closeGroups->value  

-- ymerQuit: DoPart --
do
   (if browsers.size = 1 then
       terminate
    else
       THIS(ymerBrowserWindow).close
   if);
     

-- ymerOpen: Descriptor --
(# t: ^text; w,h: @integer; 
do
   'Mjølner Fragment Browser and Editor'->t[];
   browserCount+1->browserCount;
   (if browserCount > 1 then (* this is not the first browser *)
       '<'->t.put;
       browserCount->t.putint;
       '>'->t.put;
       ymerBrowser.edenv[]->edenv[]
   if);
   t[]->title;
   browser.open;
   edenv[]->browser.edenv[];
   browser.size->THIS(ymerBrowserWindow).size;
   INNER open;
   browsers.scan
     (# 
     do
        THIS(ymerBrowserWindow)[]
          ->(current.theMenubar).windowsMenu.insertWindow;
        current[]
          ->(theMenubar).windowsMenu.insertWindow;
        
     #);
   THIS(ymerBrowserWindow)[]->browsers.append;
   
#)  

-- browserOpen: DoPart --
do
     (# x,y: @integer; sz: @point; 
     do
        (sbprivate.initialWindowWidth,45)->sz;
        (sbprivate.outerctrl[],sz)->locationView.open;
        infoView.open;
        locationView[]->sbprivate.outerctrl.appendMember;
        locationView[]->sbprivate.outerctrl.fixedSize;
        sbprivate.outerctrl.appendsDone;
        
     #);
     

-- ymerHelpDocument: DoPart --
do
   &ymerPrivate.helpDocuments.element[]->ymerPrivate.helpDocuments.append;
   title[]->(ymerPrivate.helpDocuments.last).elm.title[];
   path[]->(ymerPrivate.helpDocuments.last).elm.path[];
     

-- ymerInit: Descriptor --
(# OS: @osInterface; i: @integer; 
do
   OS.init;
   OS.hostMachine->machinetype;
   '$(BETALIB)'
     ->expandEnvVar
       (# defaultValue::  (#  do '/usr/local/lib/beta'->envvarvalue[] #)
       #)->BETAlib[];
   mps.init;
   1->i;
   l:
   (if (i+1->i) <= noOfArguments then
       (if true
        // '-ymertrace'->(i->arguments).equalNCS then
           ll:
           (if (i+1->i) <= noOfArguments then
               (if true
                // '1'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentOpen,true)->mps.AST.trace.set;
                   restart ll
                // '2'->(i->arguments).equalNCS then
                   (mps.AST.trace.onParse,true)->mps.AST.trace.set; restart ll
                // '3'->(i->arguments).equalNCS then
                   (mps.AST.trace.grammars,true)->mps.AST.trace.set; restart ll
               if)
           if)
        // '-ymerhelp'->(i->arguments).equalNCS then
           'Ymer options are "-ymerTrace n1 ...", where ni is one of:'->putline;
           '  1: Trace fragment open'->putline;
           '  2: Trace onParse'->putline;
           '  3: Trace grammar open'->putline;
           
       if);
       restart l;
       
   if);
   &mps.AST.findGrammar[]->mps.AST.grammarMissing[];
   browsers.init;
   ymerBrowser.loadEditorEnv;
   ('Ymer: Short Manual','~beta/sourcebrowser/v0.1/doc/ymer.html')
     ->ymerBrowser.helpDocument;
   ('Ymer: Known Bugs and Inconveniences',
    '~beta/sourcebrowser/v0.1/doc/ymer.bugs')->ymerBrowser.helpDocument;
   ymerPrivate.grammarTable.init;
   INNER init;
   ymerBrowser.open;
   <<SLOT ymerInitLoadSettings:Descriptor>>
#)  

-- loadEditorEnv: DoPart --
do
     (# initHere: @boolean
     do
        objectPool.get
          (#
             type:: editorEnv;
             init:: 
               (# 
               do
                  true->inithere;
                  (mps.ast[],mps.betaCFL[],THIS(ymerApplication)[])->obj.init
               #)
          #)->edenv[];
        (if inithere then 'ymer'->edenv.initiator[] if)
     #)  

