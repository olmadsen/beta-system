ORIGIN '../ymer';
INCLUDE '~beta/basiclib/formatio'
        '~beta/sysutils/pathhandler'
        'fileEditor'
        'parseEditor'
        'sourcebrowserbody'
        'ymerFileUtils'
        'ymerPrivate'
        'separateCodeEditor'
        'searchActions'
        'help'
        'mpsIntAdds';
BODY 'settings';
(*
 * COPYRIGHT
 *   Copyright Mjolner Informatics, 1995-96
 *   All rights reserved.
 *)
-- LIB: Attributes --
trace_OpenURL: (#  exit false #);   

-- findOrCreateGroupEditor: DoPart --
do fg[]->browser.sbprivate.geList.findOrCreateGroupEditor->ge[]  

-- ymerbrowserWindowCreateInterface: DoPart --
do
   &ymerymerBrowserInterface[]->Interface[];
   THIS(guienv)[]->Interface.gui[];
   mps[]->Interface.mps[];
   THIS(ymerBrowserWindow)[]->Interface.ymerBrowser[];
   browser.infoView[]->Interface.infoView[];
   browser.locationView[]->Interface.locationView[];
   edenv[]->Interface.edenv[];
     
-- ymerGroupDoRealOpen: DoPart --
do
   (if not g.isRealOpen then (* open g real *)
       none
         ->mps.AST.theCatcher[] (* to remove old exception handler - HACK *) ;
       doOpen: g.realOpen
         (#
            warn:
              (# msg: ^text
              enter msg[]
              do
                 (none ,msg[],'Warning')->alertUser;
                 none
                   ->mps.AST.theCatcher[]
                   (* to remove old exception handler - HACK *) ;
                 leave doOpen
              #);
            astOverflow::  (#  do msg[]->warn #);
            fragmentNotExisting::  (#  do msg[]->warn #);
            badFormat::  (#  do msg[]->warn #);
            grammarNotFound::  (#  do msg[]->warn #);
            doubleFormDeclaration::  (#  do msg[]->warn #);
            readAccessError::  (#  do msg[]->warn #);
            noSuchFileError::  (#  do msg[]->warn #);
            otherFileError::  (#  do msg[]->warn #);
            
         #)
   if)   
   
-- ymerGroupGetFg: DoPart --
do
   state.busy;
   'Opening '->browser.infoView.settext;
   location[]->browser.infoView.append;
   '... '->browser.infoView.append;
   browser.infoView.msgPush;
   (if not location.empty then
       location[]->mps.AST.expandToFullPath
         ->mps.fragmentGroupTable.getFragmentGroup->fg[];
       (if fg[] <> none then fg[]->doRealOpen if)
   if);
   browser.infoView.msgPop;
   state.normal  

-- ymerGroupClose: DoPart --
do '!!ymerGroupClose called'->putline;
   (*   (if theForm[] = none then {* delete all history related to this group *}
    *        l: ymerBrowserPrivate.history.iterate
    *          (#
    *             where:: 
    *               (# 
    *               do (current.elm.theGroup.location[]->location.equal)->value
    *               #)
    *          do
    *             (if current.elm.theGroup.fg[]->ymerBrowserPrivate.geList.closeGroup
    *              then
    *                 current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
    *                 current[]->ymerBrowserPrivate.history.delete;
    *                 (if currentProject[] <> none then
    *                     none ->currentProject.lastGroupSelected[]
    *                 if);
    *                 (if currentGroup[] <> none then
    *                     none ->currentGroup.lastFormSelected[]
    *                 if);
    *                 (currentProject[],none )->setGroup;
    *                 none ->cge;
    *                 none ->browser.cfe;
    *                 none ->browser.cte[];
    *                 
    *              else
    *                 leave l
    *             if)
    *          #)
    *     else
    *    {* delete only history related to theForm in this group *}
    *        ymerBrowserPrivate.history.iterate
    *          (# where::  (#  do (current.elm.theForm[] = theForm[])->value #); 
    *          do
    *             current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
    *             current[]->ymerBrowserPrivate.history.delete;
    *             (if currentForm[] = theForm[] then
    *                 (currentProject[],currentGroup[],none )->setFragmentForm;
    *                 (if currentGroup[] <> none then
    *                     none ->currentGroup.lastFormSelected[]
    *                 if);
    *                 none ->browser.cfe;
    *                 none ->browser.cte[]
    *             if)
    *          #)
    *    if)  
    * 
    *)
   
-- scanGroupsImpl: DoPart --
do '!! scanGroupsImpl called'->putline;
    state.busy;
   'Opening '->browser.infoView.settext;
   location[]->browser.infoView.append;
   '... '->browser.infoView.append;
   browser.infoView.msgPush;
   (if true
    // isProjectFile then
       'scangroupsimp.isProjectFile'->putline;
       (if not isLoaded then
       (* this is the first time we visit this projectFile - let's read it *)
           (location[],THIS(project)[])->theProjects.parseProjectFile
       if)
   if);
   (if true
    // isRoot then      
       'scangroupsimp.isRoot'->putline;
       (if groups.size = 0 then (* this is the first time we visit this root *)
           &browser.projects.group[]->newGroup[];
           location[]->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else
       (* we have visited this root previously *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // isExtent then
       'scangroupsimp.isExtent'->putline;
       (if groups.size = 0 then
       (* the extent hasn't previously been calculated *)
           scanExtentLabel:
           location[]->mps.AST.expandToFullPath
             ->This(ymerBrowserWindow).mps.dg.scanExtent
               (#
                  warn: ^text;
                  MPSexception:: 
                    (# 
                    do
                       'MPS overflow - '->warn[];
                       T[]->warn.puttext;
                       ' too large)'->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       true->continue
                    #);
                  DoubleFormException::  (#  do true->continue #);
                  emptyFragmentException::  (#  do true->continue #);
                  transAccessException:: 
                    (# 
                    do
                       'No read access to: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       true->continue
                    #);
                  notExistingException:: 
                    (# 
                    do
                       'Not a fragment file: '->warn[];
                       fullFN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertUser;
                       true->continue
                    #);
                  parseException:: 
                    (#
                       pe: @ymer.parseEditor
                         (#
                            open:: 
                              (# 
                              do
                                 (600,800)->insetDisplay->size;
                                 fullFN[]->loadFiles
                              #)
                         #)
                    do
                       pe.open;
                       (*'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                        (NONE,warn[],'Dependency Graph Error')->alertUser;*)
                       true->continue;
                       leave scanExtentLabel
                    #);
                  transCreateDirException:: 
                    (# 
                    do
                       'Unable to create directory: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  circularDependencyException:: 
                    (# 
                    do
                       'Circular dependencies in the dependency graph: '
                         ->warn[];
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  unknownPropertyException:: 
                    (# 
                    do
                       'Unknown property: '->warn[];
                       n[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  noSpaceException:: 
                    (# 
                    do
                       'No space left on file system'->warn[];
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  fragmentException:: 
                    (# 
                    do
                       'Fragment Error: '->warn[];
                       errMsg[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  propertyException:: 
                    (# 
                    do
                       'Error in property: '->warn[];
                       p[]->warn.puttext;
                       ' in fragment: '->warn.puttext;
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  
               do
                  &browser.projects.group[]->newGroup[];
                  current.fullname->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects
        else
       (* the extent has previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // isDomain then
       'scangroupsimp.isDomain'->putline;
       (if groups.size = 0 then
       (* the domain hasn't previously been calculated *)
           scanDomainLabel:
           location[]->mps.AST.expandToFullPath
             ->this(YmerBrowserWindow).mps.dg.scanDomain
               (#
                  warn: ^text;
                  MPSexception:: 
                    (# 
                    do
                       'MPS overflow - '->warn[];
                       T[]->warn.puttext;
                       ' too large)'->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  emptyFragmentException::  (#  do true->continue #);
                  DoubleFormException::  (#  do true->continue #);
                  transAccessException:: 
                    (# 
                    do
                       'No read access to: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  notExistingException:: 
                    (# 
                    do
                       'Not a fragment file: '->warn[];
                       fullFN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  parseException:: 
                    (#
                       pe: @ymer.parseEditor
                         (#
                            open:: 
                              (# 
                              do
                                 (600,800)->insetDisplay->size;
                                 fullFN[]->loadFiles
                              #)
                         #)
                    do
                       pe.open;
                       (* 'Parse errors in: '->warn[]; fullFN[]->warn.putline;
                        * (NONE,warn[],'Dependency Graph Error')->alertuser;*)
                       true->continue;
                       leave scanDomainLabel
                    #);
                  transCreateDirException:: 
                    (# 
                    do
                       'Unable to create directory: '->warn[];
                       FN[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  circularDependencyException:: 
                    (# 
                    do
                       'Circular dependencies in the dependency graph: '
                         ->warn[];
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  unknownPropertyException:: 
                    (# 
                    do
                       'Unknown property: '->warn[];
                       n[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  noSpaceException:: 
                    (# 
                    do
                       'No space left on file system'->warn[];
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  fragmentException:: 
                    (# 
                    do
                       'Fragment Error: '->warn[];
                       errMsg[]->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  propertyException:: 
                    (# 
                    do
                       'Error in property: '->warn[];
                       p[]->warn.puttext;
                       ' in fragment: '->warn.puttext;
                       fg.fullname->warn.putline;
                       (none ,warn[],'Dependency Graph Error')->alertuser;
                       true->continue
                    #);
                  
               do
                  &browser.projects.group[]->newGroup[];
                  current.fullname->newGroup.location.puttext;
                  newGroup.location[]->dependencyRegister;
                  current.name->fragmentDefaultName->newGroup.name[];
                  newGroup[]->groups.append;
                  newGroup[]->thescan.foreach
               #);
           dependencyCreateSubprojects
        else
       (* the domain has previously been calculated *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // isDirectory then
       'scangroupsimp.isDirectory'->putline;
       (if groups.size = 0 then
       (* the directory hasn't previously been scanned *)
             (# d: @directory; locationfullpath: ^text; 
             do
                THIS(Project).groups.clear;
                (if location.empty then
                    mps.ast.thepathhandler.currentDirectory->location.puttext; 
                if);
                location[]->mps.AST.expandToFullPath->d.name;
                d.scanEntries
                  (# error::  (#  do true->continue #)
                  do
                     select
                       (#
                          error::  (#  do true->continue #);
                          whenFile:: 
                            (# f: ^file; ext: ^Text; 
                            do
                               &browser.projects.group[]->newGroup[];
                               thefile->f[];
                               f.entry.path.name.suffix->ext[];
                               location[]->newGroup.location.puttext;
                               '/'->newGroup.location.put;
                               (if true
                                //
                                (foundfullpath->fileReadable)
                                and
                                (ext[]->mps.AST.grammarTable.legalExtension)
                                then
                                   f.entry.path.name.prefix->newGroup.name[]
                                     ->newGroup.location.puttext;
                                   (if groups.find
                                     (#
                                        predicate:: 
                                          (# 
                                          do
                                             current.location[]
                                               ->newGroup.location.equal->value
                                          #)
                                     #) = none then
                                       newGroup[]->groups.append;
                                       newGroup[]->thescan.foreach
                                   if)
                                //
                                showTxtFiles
                                and
                                (foundfullpath->fileReadable) then
                                   f.entry.path.name->newGroup.name[]
                                     ->newGroup.location.puttext;
                                   (if true
                                    // ((1->newGroup.name.inxGet) = '#')
                                    // ((1->newGroup.name.inxGet) = '.')
                                    //
                                    ((newGroup.name.length
                                        ->newGroup.name.inxGet) = '#')
                                    //
                                    ((newGroup.name.length
                                        ->newGroup.name.inxGet) = '~') then
                                    (* ignore *)
                                       
                                    else
                                       (if groups.find
                                         (#
                                            predicate:: 
                                              (# 
                                              do
                                                 current.location[]
                                                   ->newGroup.location.equal
                                                   ->value
                                              #)
                                         #) = none then
                                           true->newGroup.txtFile;
                                           ' (txt)'->newGroup.name.append;
                                           newGroup[]->groups.append;
                                           newGroup[]->thescan.foreach
                                       if)
                                   if)
                               if)
                            #)
                       #)
                  #);
                (if groups.size = 0 then
                    'no fragments in project'->browser.infoView.msg
                if)
             #)
        else
       (* the directory has previously been scanned *)
           groups.scan (#  do current[]->thescan.foreach #)
       if);
       
    // groups.size <> 0 then
       groups.scan (#  do current[]->thescan.foreach #); 
    else
       (if not unfolded then
           'open project to find subprojects'->browser.infoView.msg
        else
           'open subproject to find fragments'->browser.infoView.msg
       if)
   if);
   browser.infoView.msgPop;
   state.normal  

-- loadEditorEnv: DoPart --
do 
   (# editorEnvWindow: @gui.window; initHere: @boolean
   do
      objectPool.get
      (#
         type:: editorEnvWindow.editorEnv;
         init:: 
           (# 
           do true->inithere; (mps.ast[],mps.betaCFL[],gui[])->obj.init; 
           #)
      #)->ymerPrivate.edenv[]
   #)
   
-- ymerGroupRecheck: DoPart --
do
   fg.diskfilename->diskfile.name;
   fg.textfilename->textfile.name;
   false->allowReload;
   (if (textfile.name->fileExists) and
   ((textfile.name->fileModtime) > fg.modTime) then
       t.clear;
       'Source file: '->t.puttext;
       fg.textfilename->t.putline;
       'changed since last access'->t.putline;
       'The file must have been changed by some other application.'->t.putline;
       'Quit immediately (and restart) to avoid further problems'->t.puttext;
       (none ,t[],'Warning')->alertUser;
       false->allowReload (* should be true->allowReload *)
    else
       (if (diskfile.name->fileExists) and
       ((diskfile.name->fileModtime) > fg.modTime) then
           t.clear;
           'Group file: '->t.puttext;
           fg.diskfilename->t.putline;
           'changed since last access'->t.putline;
           'The file must have been changed by some other application.'
             ->t.putline;
           'Quit immediately (and restart) to avoid further problems'
             ->t.puttext;
           (none ,t[],'Warning')->alertUser;
           false->allowReload (* should be true->allowReload *)
       if)
   if);
   (if allowReload then
       'allowReload 544'->putline;
       (*Interface.currentGroup[]->cg[];
       (Interface.currentProject[],none )->setGroup;
       fg[]->ymerBrowserPrivate.geList.closeGroup;
       fg[]->MPS.reload;
        (currentProject[],cg[])->setGroup *)
   if)  

   
-- historyMenuLib: Attributes --
findAndSelect:
  (# node: ^astInterface.ast
  enter node[]
  do (*'/users/gram/beta/r5.2/sourcebrowser/private/ymerBody.bet: Line 152'->screen.putline;
      node.frag.print;*)
     (if node[] <> none then
     	 (if browser.cfe[] <> none then
     	     (if node.frag[] <> (browser.cfe).frag[] then
     		 browser.sbprivate.history.find
                 (#
                    predicate::
                      (#  do (current.theForm[] = node.frag[])->value #);
                    notFound::
                      (#
                      do 
                         ((node.frag.father).fullName,node.frag.name)
                           ->browser.selectFragmentForm
                      #)
                 do 
                    (if current.theHirItem[]<>none then
                        current.theHirItem.select;
                        browser.sbprivate.hierarchyView.theScroller[]->current.theHirItem.scrollIntoView
                     else
                        (current.location[],current.theForm.name)->browser.selectfragmentform;
                    if);
                 #);
     		 (if not (browser.cfe).theSifTexteditor.textediting then
     		     (node[],1,0,0)->(browser.cfe).setFocus
     		  else
     		     (none ,'Cannot reestablish focus - text edit active',
                     'History')->noteUser
     		 if)
     	      else
     		 (node[],1,0,0)->(browser.cfe).setFocus
     	     if)
     	  else
     	     ((node.frag.father).fullName,node.frag.name)
     	       ->browser.selectFragmentForm;
     	     (if not (browser.cfe).theSifTexteditor.textediting then
     		 (node[],1,0,0)->(browser.cfe).setFocus
     	      else
     		 (none ,'Cannot reestablish focus - text edit active','History')
     		   ->noteUser
     	     if)
     	 if)
      else
     	 (none ,'Should not happen - node[] is none!','History')->alertUser
     if)
  #);

goBack:
  (# 
  do edenv.history.protect
     (# 
     do (browser.cfe).cs.node[]->edenv.history.back->findAndSelect
     #)
  #);
backPossible:
  (# result:@boolean;
  do ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
     ((browser.cfe).cs.node[] <> none ) and
     ((browser.cfe).cs.node[]->edenv.history.BackPossible))->result
  exit result
  #);
goforward:
  (# 
  do  edenv.history.protect
     (# 
     do (browser.cfe).cs.node[]->edenv.history.forward->findAndSelect
     #)
  #);
forwardpossible:
  (# result:@boolean;
  do  ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
     ((browser.cfe).cs.node[] <> none ) and
     ((browser.cfe).cs.node[]->edenv.history.forwardPossible))->result
  exit result
  #);     

back: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do backPossible->value 
            #);
          onSelect:: 
            (# 
            do goBack              
            #)
       #);
     open::  (#  do 'Back'->name; 'b'->key #)
  #);
forward: menuItem
  (#
     eventhandler:: 
       (#
          onStatus:: 
            (# 
            do
               ((browser.cfe <> none ) and ((browser.cfe).cs[] <> none ) and
                ((browser.cfe).cs.node[] <> none ) and
                ((browser.cfe).cs.node[]->edenv.history.forwardPossible))->value
            #);
          onSelect:: 
            (# 
            do
               edenv.history.protect
                 (# 
                 do (browser.cfe).cs.node[]->edenv.history.forward->findAndSelect
                 #)
            #)
       #);
     open::  (#  do 'Forward'->name; 'f'->key #)
  #);
historyMenuItem: menuItem
  (#
     theHist: ^browser.sbprivate.history.element;
     eventhandler:: 
       (#
          onSelect:: 
            (# 
            do
            (*(theHist.theProject[],theHist.theGroup[],theHist.theForm[])
             ->browser.setFragmentForm*) 
               (if theHist.theHirItem[]<>none then
                   theHist.theHirItem.select;
                   browser.sbprivate.hierarchyView.theScroller[]->theHist.theHirItem.scrollIntoView
                else
                   '/home/gram/beta/r5.2/sourcebrowser/private/ymerBody.bet: Line 684'->screen.putline;
                   (theHist.location[],theHist.theForm.name)->browser.selectfragmentform
               if)
            #)
       #);
     setName:
       (# t: ^text; 
       do
          (theHist.location[],true)->browser.sbprivate.history.names.uniqName
            ->t[];
          '-'->t.append;
          theHist.theForm.name->t.append;
          t[]->name
       #)
  #);
addHistoryElement:
  (# theHist: ^browser.sbprivate.history.element; newHitem: ^historyMenuItem
  enter theHist[]
  do
     (if not protected then
         &historyMenuItem[]->newHitem[];
         newHitem.open;
         theHist[]->newHitem.theHist[];
         newHitem[]->append;
         updateNames;
         
     if)
  #);
updateNames: scan
  (# theHitem: ^historyMenuItem
  do
     (if current## <= historyMenuItem## then
         current[]->theHitem[]; theHitem.setname
     if)
  #);
closeHistoryElement:
  (#
     oldElement: ^browser.sbprivate.history.element;
     theHitem: ^historyMenuItem
  enter oldElement[]
  do
     l: scan
       (# 
       do
          (if current## <= historyMenuItem## then
              current[]->theHitem[];
              (if theHitem.theHist[] = oldElement[] then
                  theHitem[]->historyMenu.delete; leave l
              if)
          if)
       #)
  #);
protect:
  (# status: @boolean
  do protected->status; true->protected; INNER protect; status->protected
  #)  

-- historyMenuOpen: DoPart --
do
   'History'->name;
     (# item: ^menuItem
     do
        &back[]->item[];
        item.open;
        item[]->append;
        &forward[]->item[];
        item.open;
        item[]->append;
        &separator[]->item[];
        item.open;
        item[]->append
     #)  

-- browserSelectNode: DoPart --
do
   (if true
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and separate then
       (theEditorRoot.frag[],node[])->viewSeparate
    // (theEditorRoot.frag.root[]->theEditorRoot.equal) and not separate then
       (((theEditorRoot.frag.father).fullName).copy,
        (theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->(browser.cfe).setNode
    // (not (theEditorRoot.frag.root[]->theEditorRoot.equal)) and separate then
       (theEditorRoot[],node[])->(browser.cfe).openSubeditor
    //
    (not (theEditorRoot.frag.root[]->theEditorRoot.equal))
    and
    not
    separate then
       (((theEditorRoot.frag.father).fullName).copy,
        (theEditorRoot.frag.name).copy)->selectFragmentForm;
       node[]->(browser.cfe).setNode
   if)  

-- browserFileEdit: DoPart --
do
     (#
        se: @streamEditor
          (#
             setTitle:: 
               (# 
               do
                  'Text file editor for '->t[];
                  f.name->fragmentDefaultName->t.append;
                  
               #);
             openRead:: 
               (# t: ^text
               do
                  (if f.name->fileAvailable then
                      f.openRead; true->value
                   else
                      'No read permissions to the file:\n     '->t[];
                      f.name->fragmentDefaultName->t.puttext;
                      (se[],t[],'Read Error')->alertUser;
                      false->value
                  if)
               #);
             openWrite:: 
               (# t: ^text
               do
                  (if (f.name->fileExists) and (f.name->fileWriteable) then
                      f.openWrite; true->value
                   else
                      'No write permissions to the file:\n     '->t[];
                      f.name->fragmentDefaultName->t.puttext;
                      (se[],t[],'Write Error')->alertUser;
                      false->value
                  if)
               #);
             closeStream::  (#  do f.close #);
             open::  (#  do (600,800)->insetDisplay->size #)
          #);
        f: @file;
        t: ^text
     do
        se.open;
        se.bringToFront;
        filename[]->mps.AST.expandtofullpath->f.name;
        f[]->se.loadStream;
        
     #)  
   
-- LookForDocDir: Descriptor --
(# entry: @diskentry; 
do
   ('~beta/doc/','')->mps.ast.thepathhandler.convertFilePath->entry.path;
   entry.exists and entry.isdirectory and entry.readable->doc_dir_present   
#)  

-- OpenURL: DoPart --
do (* Check for local file *)
   cursors.watch[]->mouse.busyCursor;
   (if trace_openURL then
       'OpenURL: '->screen.puttext; path[]->screen.putline; 
   if);
   (if not is_doc_url then
       path.copy->url[]; 
    else
       (if use_local_files and doc_dir_present then
             (# entry: @diskentry; 
             do
                ('~beta/doc/'->(path.copy).prepend,'')
                  ->mps.ast.thepathhandler.convertFilePath->entry.path;
                (if trace_openURL then
                    'try: '->screen.puttext; entry.path->screen.putline; 
                if);
                (if entry.exists and entry.isfile and entry.readable then
                    'file://'->(entry.path).prepend->url[]; 
                if);
                
             #);
           
       if);
       (if url[] = none then
           'http://www.mjolner.com/mjolner-system/documentation/'
             ->(path.copy).prepend->url[];
           
       if)
   if);
   (if trace_openURL then
       'open: '->screen.puttext; url[]->screen.putline; 
   if);
   (* Possibly need to add this:
    *   DirectoryChar->url.findAll(# do ('/',inx)->url.inxPut #);
    * to make url contain just forward slashes on Windows platforms.
    *)
   'Opening Web Browser for '->browser.infoView.settext;
   url[]->browser.infoView.append;
   ' ... '->browser.infoView.append;
   browser.infoView.msgPush;
   url[]->startBrowser;
   browser.infoView.msgPop;
   none ->mouse.busyCursor
   
-- ymerMPSonGroupNotFound: DoPart --
do
   INNER onGroupNotFound;
   (if not doneInInner then
       'Fragment: '->t.puttext;
       groupName[]->t.puttext;
       ' does not exist.'->t.putline;
       'Fragment ignored'->t.puttext;
       (none ,t[],'Notification')->gui.alertUser;
       true->continue
   if)  

-- ymerMPSonOldGroup: DoPart --
do
   INNER onOldGroup;
   true->allowParsing;
   'Parsing '->putText;
   groupName[]->putLine;
   true->continue;
     

-- ymerMPSparseerrors: DoPart --
do
   true->continue;
     (#
        pe: @parseEditor
          (#
             open:: 
               (# 
               do (600,800)->insetDisplay->size; groupName[]->loadFiles
               #)
          #)
     do pe.open
     #)
     (*-- ymerMPSonReadError: DoPart --
      do INNER onReadError;
      true->continue;
      (if not doneInInner then
      (none ,errorText[],
      'Error during reading of group')->gui.alertUser;
      true->continue
      if)
      *)
     (*   
      -- ymerMPSonWriteError: DoPart --
      do INNER onWriteError;
      true->continue;
      *)
     (*-- ymerMPSonWriteLstError: DoPart --
      do INNER onWriteLstError;
      true->continue;
      *)  

-- ymerMPSonOtherError: DoPart --
do
   INNER onOtherError;
   true->continue;
   (if not doneInInner then
       (none ,errorText[],'Error during opening of group')->gui.alertUser;
       true->continue
   if)  

-- ymerLoadProject: DoPart --
do
(* (if true
 *     // proj.isDirectory // proj.isDotDotDirectory // proj.isRoot
 *     // proj.isExtent // proj.isDomain then
 * 	 (#  t: ^text;
 * 	 do
 * 	    {*&browser.projects.project[]->newProj[];
 * 	    proj.location.copy->newProj.location.puttext;
 * 	    (if (newProj[]->browser.projects.setupProject) = none then
 * 		proj.isDirectory->newproj.isDirectory;
 * 		proj.isRoot->newProj.isRoot;
 * 		proj.isExtent->newProj.isExtent;
 * 		proj.isDomain->newProj.isDomain;
 * 		newProj[]->browser.projects.theProjects.append
 * 	    if);
 * 	    'Browser on: '->t[];
 * 	    newProj.name[]->t.append;
 * 	    (if true
 * 	     // proj.isExtent then
 * 		' [extent]'->t.append
 * 	     // proj.isDomain then
 * 		' [domain]'->t.append
 * 	    if);
 * 	    t[]->title*}
 * 	 #)
 *     // proj.isProjectFile // proj.hasSubprojects then
 * 	 (# t: ^text
 * 	 do
 * 	    proj.subprojects.scan
 * 	      (#
 * 	      do
 * 		 current.copy->browser.projects.theProjects.append;
 * 		 none ->current.superProject[]
 * 	      #);
 * 	    'Browser on: '->t[];
 * 	    proj.name[]->t.append;
 * 	    t[]->title
 * 	 #)
 *    if);
 *    browser.projectsChanged
 * 
 *)   
   
--projectMenuLoaddp:dopart--
do
  fileSelectionDialog 
        (#  
        do 
           (if theTitle[]<>none then
               theTitle[]->title[] 
             else 
               'Load Project File'->title[]
           if)
        #)->t[];
   (if t[] <> none then
       (t[],'/fzvsvsvs')
         ->mps.ast.thepathhandler.localpath->fragmentForeName->selectFragmentGroup
   if)
   
-- ymerAddProject: DoPart --
do location[]->appendProject; appendDone  

-- ymerAppendProject: DoPart --
do
   (# grp:^browser.sbprivate.hierarchyview.hir.group
   do
      'AppendProject on %s '->putformat(# do location[]->s#);
          &browser.sbprivate.hierarchyView.hir.group[]
            ->grp[];
      (location[],'/fzvsvsvs')
        ->mps.ast.thepathhandler.localpath->fragmentForeName->grp.location[];
      grp.location[]->putline;
      (*
      grp.lfmenu.open;
      grp.lfmenu[]->grp.popupMenu;
      mps.ast.astFileExtension->grp.location.append;
      location[]->fragmentDefaultName->grp.label[];
      '+'->grp.label.prepend;
      grp.init;
       grp[]->(browser.sbprivate.hierarchyView.hir.root).addItem
       *)
      (grp.location[],true)->browser.addToUsedGroups;
      (*(browser.sbprivate.hierarchyView.hir.getUsedGroup).onExpand*)
   #)

-- ymerAppendDone: DoPart --
do
   (# grp:^browser.sbprivate.hierarchyview.hir.group;
      itm:^browser.sbprivate.hierarchyview.hir.item;
   do ((browser.sbprivate.hierarchyview.hir.root).items.last).elm[]->itm[];
      (if itm##=browser.sbprivate.hierarchyview.hir.group## then
          itm[]->grp[];
          grp.onexpand;
          grp.select;
          (*(if grp.items.size>1 then
           (grp.items.head).succ.elm.select
           else
           grp.select
           if)*)
      if)
   #)
   
   (* 
 * -- ymerGroupClose: DoPart --
 * do
 *    (if theForm[] = none then {* delete all history related to this group *}
 *        l: browser.sbprivate.history.iterate
 * 	 (#
 * 	    where::
 * 	      (#
 * 	      do (current.elm.theGroup.location[]->location.equal)->value
 * 	      #)
 * 	 do
 * 	    (if current.elm.theGroup.fg[]->browser.sbprivate.geList.closeGroup
 * 	     then
 * 		current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
 * 		current[]->browser.sbprivate.history.delete;
 * 		(if currentProject[] <> none then
 * 		    none ->currentProject.lastGroupSelected[]
 * 		if);
 * 		(if currentGroup[] <> none then
 * 		    none ->currentGroup.lastFormSelected[]
 * 		if);
 * 		(currentProject[],none )->setGroup;
 * 		none ->cge[];
 * 		none ->browser.cfe;
 * 		none ->browser.cte[];
 * 
 * 	     else
 * 		leave l
 * 	    if)
 * 	 #)
 *     else
 *    {* delete only history related to theForm in this group *}
 *        browser.sbprivate.history.iterate
 * 	 (# where::  (#  do (current.elm.theForm[] = theForm[])->value #);
 * 	 do
 * 	    current.elm[]->(theMenubar).historyMenu.closeHistoryElement;
 * 	    current[]->browser.sbprivate.history.delete;
 * 	    (if currentForm[] = theForm[] then
 * 		(currentProject[],currentGroup[],none )->setFragmentForm;
 * 		(if currentGroup[] <> none then
 * 		    none ->currentGroup.lastFormSelected[]
 * 		if);
 * 		none ->browser.cfe[];
 * 		none ->browser.cte[]
 * 	    if)
 * 	 #)
 *    if)
 * 
 *)   

-- browserLib: Attributes --
(* setupRootProject:
 *   (# proj,root,existing: ^project
 *   enter proj[]
 *   do
 *      {*projects.theProjects.find
 *        (#
 * 	  predicate::
 * 	    (#  do current.location[]->proj.location.equal->value #)
 *        #)->existing[];*}
 *      (if existing[] = none then
 * 	 (if (proj.name.length->proj.name.inxGet) <> '*' then
 * 	     '*'->proj.name.append
 * 	 if);
 * 	 true->proj.isRoot;
 * 	 proj[]->root[];
 * 	 {*&browser.projects.project[]->proj[];*}
 * 	 root.location->proj.location;
 * 	 true->proj.isDomain;
 * 	 '[domain]'->proj.name[];
 * 	 root[]->proj.superProject[];
 * 	 proj[]->root.subprojects.append;
 * 	 {*&browser.projects.project[]->proj[];*}
 * 	 root.location->proj.location;
 * 	 true->proj.isExtent;
 * 	 '[extent]'->proj.name[];
 * 	 root[]->proj.superProject[];
 * 	 proj[]->root.subprojects.append;
 * 
 *      if)
 *   exit existing[]
 *   #);
 * 
 *)
(* 
 * setupDotDot:
 *   (#
 *      proj: ^browser.projects.project;
 *      projPos: ^projects.theProjects.theCellType;
 *      d: @directory;
 *      location: ^text;
 *      level: @integer;
 *      superProject,superSuperProject: ^browser.projects.project;
 *      createParentProject:
 *        (# newProj: ^browser.projects.project
 *        do
 * 	  (if location.length > 0 then
 * 	      &browser.projects.project[]->newProj[];
 * 	      location->newProj.location;
 * 	      true->newProj.isDirectory;
 * 	      newProj[]->browser.projects.setupProject;
 * 	      (newProj[],superProject[]->browser.projects.theProjects.at)
 * 		->browser.projects.theProjects.insertBefore;
 * 	      superProject.level->newProj.level;
 * 	      (for newProj.level repeat '  '->newProj.name.prepend for);
 * 	      superProject.level+1->superProject.level;
 * 	      '  '->superProject.name.prepend;
 * 	      l:
 * 	      (superProject[]->browser.projects.theProjects.at).succ[]
 * 		->browser.projects.theProjects.iterateFrom
 * 		  (#
 * 		  do
 * 		     (if current.elm.level >= superProject.level then
 * 			 current.elm.level+1->current.elm.level;
 * 			 '  '->current.elm.name.prepend;
 * 
 *
 * 		      else
 * 			 leave l
 * 		     if)
 * 		  #);
 * 	      superProject.subprojects.clear;
 * 	      true->newProj.unfolded;
 * 	      newProj[]->foldSubprojects;
 * 	      newProj[]->unfoldSubprojects;
 * 	      browser.projectsChanged;
 * 	      newProj[]->browser.setProject
 * 	  if)
 *        #)
 *   enter proj[]
 *   do
 *   {* we now have to create a new project to contain the parent
 *    * directory of currentDirectory
 *    *}
 *      proj.location.copy->location[];
 *      proj.superProject[]->superProject[];
 *      (if superProject[] <> none then
 * 	 superProject.level->level;
 * 	 superProject.superProject[]->superSuperProject[];
 * 	 (if superSuperProject[] <> none then
 * 	     (if superSuperProject.isDirectory then
 * 	     {* this is the .. directory - select it *}
 * 		 superSuperProject[]->setProject;
 * 	      else
 * 	     {* try to locate the '..' project in
 * 	      * superSuperProject
 * 	      *}
 * 		 l:
 * 		   (#
 * 		   do
 * 		      superSuperProject.subprojects.iterate
 * 			(#
 * 			do
 * 			   (if current.elm.location[]->location.equal then
 * 			       current.elm[]->setProject; leave l
 * 			   if)
 * 			#);
 * 		      {* not found - create it *}
 * 		      createParentProject
 * 		   #)
 * 	     if)
 * 	  else
 * 	 {* OK, we are 'on the top'.  Try those *}
 * 	     l:
 * 	       (#
 * 	       do
 * 		  browser.projects.theProjects.iterate
 * 		    (#
 * 		       where::  (#  do (current.elm.level = level)->value #)
 * 		    do
 * 		       (if current.elm.location[]->location.equal then
 * 			   current.elm[]->setProject; leave l
 * 		       if)
 * 		    #);
 * 		  {* not found - create it *}
 * 		  createParentProject
 * 	       #)
 * 	 if)
 *     if)
 *   #);
 * 
 *)   

-- onProjectListOpen: DoPart --
do INNER  

-- onGroupListOpen: DoPart --
do INNER  

-- onFragmentgroupViewOpen: DoPart --
do INNER  

-- onCurrentProjectChange: DoPart --
do
   (if newProject[] <> none then
       newProject.location[]->browser.locationView.msg
   if);
   newProject[]->Interface.CurrentProject[];
   none->Interface.CurrentGroup[];
   none->Interface.CurrentForm[];
   none ->cge;
   none ->browser.cfe;
   none ->browser.cte[]

-- onCurrentGroupChange: DoPart --
do
(*  (if true
 *     // newGroup[] <> none then
 *        (if newGroup.fg[] <> none then
 * 	   newGroup.fg[]->browser.sbprivate.geList.findOrCreateGroupEditor
 * 	     ->cge[];
 * 	   none ->browser.cte[]
 *        if);
 *        newGroup.location[]->browser.locationView.msg;
 * 
 *     // cte[] <> none then
 *        none ->cge[]; cte.path->browser.locationView.msg;
 *    if)
 *)   

-- onCurrentFormChange: DoPart --
do 
   (if newForm[] = none then
       browser.sbprivate.sourceview.popdown
    else
       state.busy;
       'Opening '->browser.infoView.settext;
       newForm.name->browser.infoView.append;
       '... '->browser.infoView.append;
       browser.infoView.msgPush;
       (if debugSourceBrw then 
           'history is:'->putline;
           browser.sbprivate.history.scan
           (# 
           do current.theForm.print
           #);
           'Looking for:'->puttext;newform.print
       if);
       browser.sbprivate.history.find
       (# predicate::  (#  do (current.theForm[] = newForm[])->value #);
          notFound::
            (# newHist: ^browser.sbprivate.history.element;
            do
               &browser.sbprivate.history.element[]->newHist[];
               (* browser.currentProject[]->newHist.theProject[]; *)
               (* browser.currentGroup[]->newHist.theGroup[]; *)
               (newForm.father).Name->newHist.location[];
               newForm[]->newHist.theForm[];
               newHist[]->browser.sbprivate.history.add;
               newHist[]->(theMenubar).historyMenu.addHistoryElement;
               newForm[]->browser.sbprivate.sourceview.newfragment
                 ->(newHist.theCfe[],newHist.theView[]);
               (* browser.sbprivate.hierarchyView.hir.selection[]->newHist.theHirItem[]; *)
               newHist.theCfe[]->browser.cfe;
               none ->browser.cte[];
               newHist.theView[]->browser.sbprivate.sourceview.popup;
            #)
       do current.theCfe[]->browser.cfe;
          none ->browser.cte[];
          newForm.fullname->current.theView.label; (* form name might have been changed  *)
          current.theView[]->browser.sbprivate.sourceview.popup;
          (browser.cfe).cs->(browser.cfe).setFocus
       #);
       browser.infoView.msgPop;
       state.normal
   if)

-- ymerOnAboutToClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->ymer.browsers.has then
       INNER onAboutToClose;
       (if okToClose then
           (if browser.sbprivate.geList.closeGroups and
           browser.sbprivate.sourceview.aeList.closeAsciiEditors then
               THIS(ymerBrowserWindow)[]->ymer.browsers.at
                 ->ymer.browsers.delete;
               (if ymer.browsers.empty and onTerminateApplication then
                   terminate
                else
                   ymer.browsers.scan
                     (# browser: ^ymerBrowserWindow
                     do
                        current[]->browser[];
                        THIS(ymerBrowserWindow)[]
                          ->(browser.theMenubar).windowsMenu.deleteWindow
                     #)
               if)
            else
               false->okToClose
           if)
       if)
   if)  

-- ymerClose: DoPart --
do
   (if THIS(ymerBrowserWindow)[]->ymer.browsers.has then
       THIS(ymerBrowserWindow)[]->ymer.browsers.at->ymer.browsers.delete;
       (if ymer.browsers.empty and onTerminateApplication then
           terminate
        else
           ymer.browsers.scan
             (# browser: ^ymerBrowserWindow
             do
                current[]->browser[];
                THIS(ymerBrowserWindow)[]
                  ->(browser.theMenubar).windowsMenu.deleteWindow
             #)
       if)
   if)  

-- ymerCloseGroups: DoPart --
do browser.sbprivate.geList.closeGroups->value  

-- ymerQuit: DoPart --
do
   true->okToClose;
   INNER ;
   (if (ymer.browsers.size = 1) and onTerminateApplication then
       terminate
    else
       (if okToClose then THIS(ymerBrowserWindow).close if)
   if)  

-- ymerOpen: Descriptor --
(# t: ^text; x,y: @integer
do
   browserTitle->t[];
   ymer.browserCount+1->ymer.browserCount;
   (if ymer.browserCount > 1 then (* this is not the first browser *)
       '<'->t.put; ymer.browserCount->t.putint; '>'->t.put
   if);
   t[]->title;
   browser.open;
   mps[]->browser.mps[];
   
   ymer. (*GRAM*) ymerPrivate.edenv[]->edenv[]->browser.edenv[]; 
   (900,800)->insetDisplay->THIS(ymerBrowserWindow).size;
   THIS(ymerBrowserWindow).position->(x,y);
   (x+40,y+40)->THIS(ymerBrowserWindow).position;
   INNER open;
   hide   
#)  

-- browserOpen: DoPart --
do loadSettings  

-- ymerInit: Descriptor --
(# i: @integer; 
do
   1->i;
   l:
   (if (i+1->i) <= noOfArguments then
       (if true
        // '--mpsTrace'->(i->arguments).equalNCS then
           ll:
           (if (i+1->i) <= noOfArguments then
               (if true
                // 'fragmentOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'fragmentClose'->(i->arguments).equalNCS then
                   (mps.AST.trace.fragmentClose,true)->mps.AST.trace.set;
                   restart ll
                // 'onParse'->(i->arguments).equalNCS then
                   (mps.AST.trace.onParse,true)->mps.AST.trace.set; restart ll
                // 'topOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.topOpen,true)->mps.AST.trace.set; restart ll
                // 'compactOpen'->(i->arguments).equalNCS then
                   (mps.AST.trace.compactOpen,true)->mps.AST.trace.set;
                   restart ll
                // 'grammars'->(i->arguments).equalNCS then
                   (mps.AST.trace.grammars,true)->mps.AST.trace.set; restart ll
                // 'parsingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.parsingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'getnextComment'->(i->arguments).equalNCS then
                   (mps.AST.trace.getnextComment,true)->mps.AST.trace.set;
                   restart ll
                // 'editingComments'->(i->arguments).equalNCS then
                   (mps.AST.trace.editingComments,true)->mps.AST.trace.set;
                   restart ll
                // 'parser'->(i->arguments).equalNCS then
                   (mps.AST.trace.parser,true)->mps.AST.trace.set; restart ll
                // 'getBinding'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBinding,true)->mps.AST.trace.set;
                   restart ll
                // 'getBindingMark'->(i->arguments).equalNCS then
                   (mps.AST.trace.getBindingMark,true)->mps.AST.trace.set;
                   restart ll
               if)
           if)
        // '--ymerhelp'->(i->arguments).equalNCS then
           'Ymer options are "--mpsTrace n1 ...", where ni is one of:'->putline;
           '  fragmentOpen: Trace mps fragmentOpen'->putline;
           '  onParse: Trace mps onParse'->putline;
           '  topOpen: Trace mps topOpen'->putline;
           '  compactOpen: Trace mps compactOpen'->putline;
           '  grammars: Trace mps grammars'->putline;
           '  parsingComments: Trace mps parsingComments'->putline;
           '  getnextComment: Trace mps getnextComment'->putline;
           '  editingComments: Trace mps editingComments'->putline;
           '  parser: Trace mps parser'->putline;
           '  getBinding: Trace mps getBinding'->putline;
           '  getBindingMark: Trace mps getBindingMark'->putline;
           
       if);
       restart l
   if);
   mps.init;
   browsers.init;
   loadEditorEnv;
   (*gram loadEnvironments; *)
   (*('BETA: Frequently Asked Questions (FAQ)',
    '~beta/doc/faq/beta-language-faq.html')->helpDocument;
    ('Ymer: Short Manual','~beta/sourcebrowser/doc/ymer.html')
    ->helpDocument;
    ('Ymer: Known Bugs and Inconveniences',
    '~beta/sourcebrowser/doc/ymer.bugs')->helpDocument;*)
   INNER init;
   userGrammarInit;
   &logWindow[]->logwin[]; 
   logwin.open
#)  

-- ymerMPSinit: DoPart --
do
   dg.init;
   dg.xverboselevel.nothing->dg.xverboselevel;
   machine_type->dg.TargetMachine[];
   machine_type->dg.TargetDirectory[];
   INNER
   (*-- ymerHelpDocument: DoPart --
    do
    &ymenv.private.helpDocuments.element[]->ymenv.private.helpDocuments.append;
    title[]->(ymenv.private.helpDocuments.last).elm.title[];
    path[]->(ymenv.private.helpDocuments.last).elm.path[]
    *)
   (*-- loadEnvironments: DoPart --
    do
    (# editorEnvWindow: @window
    do
    objectPool.get
    (#
    type:: ymerEnv
    #)->ymenv[];
    
    objectPool.get
    (#
    type:: editorEnvWindow.editorEnv;
    init::
    (#
    do
    (mps.ast[],mps.betaCFL[],THIS(ymerApplication)[])->obj.init
    #)
    #)->edenv[];
    edenv[]->ymenv.private.edenv[]
    #)
    *)  

   
-- ymerNewBrowserDopart: DoPart --
do
   &gui.ymerbrowserWindow[]->browserWindow[];
   (THIS(ymerEnv)[],mps[])->browserWindow.init;
   browserWindow.createInterface->browserInt[];
   browserInt[]->browserWindow.browser.Interface[];
   browserWindow.open;
   (* window is hided, to avoid menu flicker *)
   browserWindow.edenv[]->browserInt.edenv[];
   (browserWindow[],browserInt[])->newBrowserCallBack;
   (if newBrowserCallBack.ymerCallBack[] <> none then
   (* we allways use the ymercall from the first browser, until this is closed *)
       (if browserWindow.edenv.ymerCallBack[] = none then
           newBrowserCallBack.ymerCallBack[]->browserWindow.edenv.ymercallback[]
             ->browserWindow.myYmerCall[]
       if)
    else
       'YmerCallback is none !!!'->screen.putline;
       &ymerCall[]->browserWindow.edenv.ymerCallBack[]
         ->browserWindow.myYmerCall[]
   if);
   (* browserWindow.themenubar->bwm[];  *)
   &browserWindow.MenubarType[]->bwm[];
   bwm.open;
   bwm.fileMenu.open
     (# 
     do fileMenuActionList.scan (#  do bwm.filemenu[]->current #); 
     #);
   bwm.fileMenu[]->bwm.append;
   MenuActionList.scan
     (#  do (BrowserInt[],bwm[])->current #);
   bwm.projectMenu.setup;
   bwm.historyMenu.setup;
   bwm.windowsMenu.setup;
   bwm.helpMenu.setup;
   browsers.scan
     (# browser: ^gui.ymerBrowserWindow
     do
        current[]->browser[];
        browserWindow[]->(browser.theMenubar).windowsMenu.insertWindow;
        browser[]->bwm.windowsMenu.insertWindow
     #);
   BrowserWindow[]->browsers.append;
   bwm[]->browserWindow.themenubar;
   browserWindow.show;
   INNER ;
   (* show hided window *)
   fileMenuActionList.clear
   
   
--ymerEndOpenParseEditor:descriptor--
(# pe:@parseEditor
     (# open::(# do (x,y)->size; fn[]->loadFiles #)
     #)
do pe.open
#)

--setuptoolb:dopart--
do
   (# 
      back:pixmaptool
        (# onSelect::
             (# do 'back'->putline;
                (if (themenubar).historymenu.backPossible then
                    (themenubar).historymenu.goBack
                if)
             #)
        #);
       frwd:pixmaptool
        (# onSelect::
             (# do 'forward'->putline;
                (if (themenubar).historymenu.forwardpossible then
                    (themenubar).historymenu.goforward 
                if)
             #)
        #);
       up:toolb.pixmaptool
        (# onSelect::
             (# do 'up'->putline;
                (cfe).doCommand
                (# ccfe:^codeeditor;
                   node: ^astInterface.ast
                do (cfe)->ccfe[];
                   (if ccfe.thisGroupEditor[] <> none then
                       ccfe.frag[]->ccfe.thisGroupEditor.searchSLOT->node[];
                       (if node[] <> none then
                           (node[],node[],false)->ccfe.selectNodeInFormEditor
                       if)
                   if)
                #)
             #)
        #);
       follow:toolb.pixmaptool
        (# onSelect::
             (# do 'follow'->putline;
                (cfe).doDetail
             #)
        #);
       check:toolb.pixmaptool
        (# onSelect::
             (# do 'Check'->putline;
                (cfe).doDetail
             #)
        #);
       compile:toolb.pixmaptool
        (# onSelect::
             (# do 'compile'->putline;
                (cfe).doDetail
             #)
        #);
      pm:^toolb.pixmaptool;
   do &back[]->pm[];
      'backbtn'->pm.init;
      pm[]->toolb.addTool; 
      &frwd[]->pm[];
      'frwbtn'->pm.init;
      pm[]->toolb.addTool; 
      &up[]->pm[];
      'upbtn'->pm.init;
      pm[]->toolb.addTool; 
      &follow[]->pm[];
      'downbtn'->pm.init;
      pm[]->toolb.addTool;
      &check[]->pm[];
      'chkbtn'->pm.init;
      pm[]->toolb.addTool;
      &compile[]->pm[];
      'compbtn'->pm.init;
      pm[]->toolb.addTool
   #)
   
--windowsmenustatus:dopart--
do
   'SelectedFG:'->puttext;
   (if browser.sbprivate.hierarchyView.hir.selectedfg[]<>none then
       browser.sbprivate.hierarchyView.hir.selectedfg.fullname->putline
    else
       'is none'->putline
   if);
   'CurrentProject: '->puttext;
   (if Interface.currentProject[]<>none then
       (if Interface.currentProject.name[]<>none then
           Interface.currentProject.name[]->putline
        else
           ' name none'->putline
       if)
    else
       ' is none'->putline
   if);
   'CurrentGroup: '->puttext;
   (if Interface.currentGroup[]<>none then
       Interface.currentGroup.location[]->putline
    else
       ' is none'->putline
   if);
       
   'CurrentForm: '->puttext;
    (if Interface.currentForm[]<>none then
        Interface.currentForm.print
     else
        ' is none'->putline
    if)
