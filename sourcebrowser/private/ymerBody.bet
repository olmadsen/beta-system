ORIGIN '../ymer';
INCLUDE '~beta/basiclib/v1.4/formatio';
INCLUDE '~beta/sysutils/v1.4/pathhandler';
INCLUDE '~beta/process/v1.4/osinterface';

INCLUDE '~beta/debugger/v2.0/utils/buffered_io';

INCLUDE '../dynpane';

INCLUDE 'settings';
INCLUDE 'fileEditor';
INCLUDE 'parseEditor';
INCLUDE 'semanticEditor';
INCLUDE 'sourcebrowserbody';

INCLUDE 'ymerFileUtils';

--- browserFileEdit: dopart ---
do (# fe: @fileEditor
        (# open:: (# do (600,800)->size #) #);
   do fe.open;
      makefile[]->fe.loadFile;
   #)

--- ymerMPSparseerrors: dopart ---
do true->continue;
   (# pe: @ymerBrowser.browser.parseEditor
        (# open:: (# do (600,800)->size #) #);
   do pe.open;
      ymerBrowser.browser.currentGroup.location[]->pe.loadFiles;
   #)
   
--- ymerMPSbetaparserinit: descriptor ---
(# bobsFile: @file;
   grammarWithPath, help: ^text;
do (if not BETACFL.parser.haveBeenInitialized then
       '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
       (if BETACFL.grammarAst[]
        // none then
           'No grammarAst for '->screen.putText;
           grammarWithPath[]->screen.putLine;
        else
           '-parser'->help[];
           mps.ast.parserFileExtension->help.append;
           help[]->grammarWithPath.copyAppend->mps.ast.expandToFullPath 
             ->bobsFile.name;
           (if bobsFile.entry.exists then
               bobsFile.name->BETACFL.parser.initialize;
               ('objectdescriptor','descriptor')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               ('attributedecl','attributes')
                 ->BETACFL.parser.privatePart.b.defineNonTAlias;
               
            else
               'No parser available: '->screen.putText;
               bobsFile.name->screen.putLine;
               
           if);
       if);
   if)
#)

--- ymerAddProject: dopart ---
do &browser.projects.theProjects.element[]->newProj[];
   name.copy->newProj.name[];
   location[]->MPS.ast.expandToFullPath->newProj.location.puttext;
   newProj[]->browser.projects.setupProject;
   newProj[]->browser.projects.theProjects.append;
   browser.projectsChanged;
   newProj[]->browser.setProject;
   
--- projectInfoLib: attributes ---
setupProject:
  (# f: @file; ext: ^text;
     proj, root: ^theProjects.element
  enter proj[]
  do (if (proj.location.length
           ->proj.location.inxGet)='/' then
         (proj.location.length,proj.location.length)
           ->proj.location.delete;
     if);
     (proj.location[],ph.currentDirectory)
       ->ph.convertfilepath->f.name;
     (if proj.name[]=NONE then
         f.entry.path.name->proj.name[]
     if);
     (if true
      // f.entry.exists and
         f.entry.readable and
         f.entry.isDirectory then
         true->proj.isDirectory;
         (if (proj.location.length
               ->proj.location.inxGet)<>'/' then
             '/'->proj.location.append
         if);
         (if (proj.name.length>0) and
             ((proj.name.length->proj.name.inxGet)<>'/') then
             '/'->proj.name.append;
         if);
      else
         f.entry.path.name.suffix->ext[];
         (if true
          // f.entry.exists and
             f.entry.readable and
             (mps.AST.astfileExtension->ext.equal)
          // f.entry.exists and
             f.entry.readable and
             ('.bet'->ext.equal) 
          // (mps.AST.astfileExtension->(f.name).append
               ->fileExists) and
             (mps.AST.astfileExtension->(f.name).append
               ->fileReadable)
          // ('.bet'->(f.name).append->fileExists) and
             ('.bet'->(f.name).append->fileReadable) then
             '*'->proj.name.append;
             true->proj.isRoot;
             
             proj[]->root[];
             
             &root.subprojects.element[]->proj[];
             root.location->proj.location;
             true->proj.isDomain;
             '[domain]'->proj.name[];
             proj[]->root.subprojects.append;
             
             &root.subprojects.element[]->proj[];
             root.location->proj.location;
             true->proj.isExtent;
             '[extent]'->proj.name[];
             proj[]->root.subprojects.append;
          // f.entry.exists and
             f.entry.readable and
             ('.pjt'->ext.equal) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             (f.name,proj[])
               ->theProjects.parseProjectFile;
          // ('.pjt'->(f.name).append->fileExists) and
             ('.pjt'->(f.name).append->fileReadable) then
             true->proj.isProjectFile->proj.hasSubprojects;
             (if (proj.name.length>0) and
                 ((proj.name.length->proj.name.inxGet)<>'+') then
                 '+'->proj.name.append;
             if);
             ('.pjt'->(f.name).append,proj[])
               ->theProjects.parseProjectFile;
          else
             (* skip for ECOOP: f.name->fileAvailable; *)
         if)
     if)
  #);

--- scanGroupsImpl: dopart ---
do ''->infoView.contents.label;
   (if true
    // isRoot then
       (if groups.size=0 then
           (* this is the first time we visit this root *)
           &groups.element[]->newGroup[];
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->newGroup.location.puttext;
           newGroup.location[]->fragmentDefaultName
             ->newGroup.name[];
           newGroup[]->groups.append;
           newGroup[]->thescan.foreach
        else 
           (* we have visited this root previously *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isExtent then
       (if groups.size=0 then
           (* the extent haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanExtent
           (#
           do &groups.element[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the extent have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDomain then
       (if groups.size=0 then
           (* the domain haven't previously been calculated *)
           machineType->mps.dg.TargetMachine;
           machineType->mps.dg.TargetDirectory;
           (location[],ph.currentDirectory)
             ->ph.convertfilepath
             ->mps.dg.scanDomain
           (#
           do &groups.element[]->newGroup[];
              (current.fullname,ph.currentDirectory)
                ->ph.convertfilepath
                ->newGroup.location.puttext;
              newGroup.location[]
                ->dependencyRegister;
              current.name->fragmentDefaultName
                ->newGroup.name[];
              newGroup[]->groups.append;
              newGroup[]->thescan.foreach
           #);
           dependencyCreateSubprojects;
        else 
           (* the domain have previously been calculated *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // isDirectory then
       (if groups.size=0 then
           (* the directory haven't previously been scanned *)
           (# d: @directory; count: @integer;
           do this(Project).groups.clear;
              (if location.empty then
                  ph.currentDirectory->location.puttext;
              if);
              (location[],ph.currentDirectory)
                ->ph.convertfilepath->d.name;
              d.scanEntries
              (#
              do select
                 (# whenFile::
                      (# f: ^file; ext: ^Text;
                      do &groups.element[]->newGroup[];
                         thefile->f[];
                         f.entry.path.name.suffix
                           ->ext[];
                         f.entry.path.name
                           ->newGroup.location.puttext;
                         (if true
                          // f.entry.exists and
                             f.entry.readable and
                             (mps.AST.astfileExtension
                               ->ext.equal)
                          // f.entry.exists and
                             f.entry.readable and
                             ('.bet'->ext.equal) then
                             (newGroup.location.length-3,newGroup.location.length)
                               ->newGroup.location.delete;
                             location[]->newGroup.location.prepend;
                             (if groups.find
                                 (# predicate::
                                      (#
                                      do current.location[]
                                           ->newGroup.location.equalNCS
                                           ->value
                                      #)
                                 #)=NONE then
                                 f.entry.path.name.prefix
                                   ->newGroup.name[];
                                 count+1->count;
                                 newGroup[]->groups.append;
                                 newGroup[]->thescan.foreach
                             if)
                          else
                             (* skip for ECOOP: f.name->fileAvailable *)
                         if);
                      #)
                 #)
              #);
              (if count=0 then
                  'no fragments in project'
                    ->infoView.contents.label;
              if)
           #)
        else
           (* the directory have previously been scanned *)
           groups.scan
           (#
           do current[]->thescan.foreach
           #)
       if)
    // groups.size<>0 then
       groups.scan
       (#
       do current[]->thescan.foreach
       #)
    else
       (if not unfolded then 
           'open project to find subprojects'
             ->infoView.contents.label;
        else 
           'open subproject to find fragments'
             ->infoView.contents.label;
       if)
   if)
   
--- browserLib: attributes ---

unfoldSubprojects:
  (# proj: ^projects.theProjects.element;
     projPos: ^projects.theProjects.theCellType;
  enter proj[]
  do ''->infoView.contents.label;
     (if true
      // proj.hasSubprojects 
      // proj.isRoot then
         proj[]->projects.theProjects.at->projPos[];
         proj.subprojects.scan
         (#
         do proj.level+1->current.level;
            (for current.level repeat
                 '  '->current.name.prepend
            for);
            (current[],projPos[])
              ->projects.theProjects.insertAfter->projPos[];
         #);
         proj.subprojects.scan
         (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
      // proj.isDirectory then
         (if proj.subprojects.size=0 then
             (* the directory haven't previously been unfolded *)
             (# d: @directory; f: @file;
             do (proj.location[],ph.currentDirectory)
                  ->ph.convertfilepath->d.name;
                d.scanEntries
                (# 
                do select
                   (# whenDir::
                        (# d: ^directory; name: ^text;
                           newProj: ^projects.theProjects.element;
                        do thedir->d[];
                           d.entry.path.name->name[];
                           (if true
                            // '.'->name.equalNCS
                            // '..'->name.equalNCS
                            // 'sun4s'->name.equalNCS then
                            // 'sun4'->name.equalNCS then
                            // 'sun3'->name.equalNCS then
                            // 'snake'->name.equalNCS then
                            // 'sgi'->name.equalNCS then
                            // 'nti'->name.equalNCS then
                            // 'linux'->name.equalNCS then
                            // 'hpux9pa'->name.equalNCS then
                            // 'hpux8'->name.equalNCS then
                            // 'b2c'->name.equalNCS then
                            else
                               &projects.theProjects.element[]
                                 ->newProj[];
                               (d.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               newProj.location[]->f.name;
                               (if (newProj.location.length
                                     ->newProj.location.inxGet)<>'/'
                                   then
                                   '/'->newProj.location.append
                               if);
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               '/'->newProj.name.append;
                               true->newProj.isDirectory;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[],proj[]
                                     ->projects.theProjects.at)
                                     ->projects.theProjects.insertAfter;
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
                               if)
                           if)
                        #);
                      whenFile::
                        (# f: ^file; name: ^text;
                           newProj: ^projects.theProjects.element;
                        do thefile->f[];
                           f.entry.path.name->name[];
                           (if true
                            // '.pjt'->(f.entry.path.name.suffix).equal then
                               &projects.theProjects.element[]
                                 ->newProj[];
                               (f.name,proj.location[])
                                 ->ph.convertfilePath
                                 ->newProj.location.puttext;
                               (newProj.location.length-3,newProj.location.length)
                                 ->newProj.location.delete;
                               proj.level+1->newProj.level;
                               &text[]->newProj.name[];
                               (for newProj.level repeat
                                    '  '->newProj.name.puttext
                               for);
                               f.entry.path.name
                                 ->newProj.name.puttext;
                               (newProj.name.length-3,newProj.name.length)
                                 ->newProj.name.delete;
                               '+'->newProj.name.append;
                               true->newProj.hasSubprojects;
                               (f.name,newProj[])
                                 ->proj.subprojects.parseProjectFile;
                               (if (newProj.location[]->fileExists) and
                                   (newProj.location[]->fileReadable) then
                                   (newProj[],proj[]
                                     ->projects.theProjects.at)
                                     ->projects.theProjects.insertAfter;
                                   newProj[]->proj.subprojects.append;
                                else
                                   (* skip for ECOOP: newProj.location[]->fileAvailable *)
             if)if)#)#)#)#)
          else
             (* the directory have previously been unfolded *)
             proj[]->projects.theProjects.at->projPos[];
             proj.subprojects.scan
             (#
             do (for current.level repeat
                     '  '->current.name.prepend
                for);
                (current[],projPos[])
                  ->projects.theProjects.insertAfter->projPos[];
             #);
             proj.subprojects.scan
             (# do (if current.unfolded then current[]->unfoldSubprojects if) #);
         if)
     if)
  #);
foldSubprojects:
  (# proj: ^projects.theProjects.element;
     level: @integer
  enter proj[]
  do ''->infoView.contents.label;
     proj.level->level;
     loop:
       (proj[]
       ->projects.theProjects.at).succ[]
       ->projects.theProjects.iterateFrom
     (#
     do (if current.elm.level>level then
            (1,current.elm.level*2)->current.elm.name.delete;
            current[]->projects.theProjects.delete
         else leave loop
        if)
     #);
  #);
projectByIndex:
  (# inx: @integer;
     foundProj: ^projects.theProjects.element;
  enter inx
  do find: projects.theProjects.scan
       (#
       do inx-1->inx;
          (if inx=0 then
              current[]->foundProj[];
              leave find
       if)#)
  exit foundProj[]
  #);

--- onGroupListOpen: dopart --- 
do &thegrouplist.action
   (# eventtype:: thegrouplist.theeventhandler.mousedown;
      selectedGroup: ^projects.group;
      root, newProj: ^projects.theProjects.element;
   do (if (thegrouplist.selection.first)<>0 then
          (if theEvent.doubleClick then
              (if theEvent.shiftKey then
                  (* do what's needed to make THIS into a root *)
                  thegrouplist.selection.first
                    ->groups.getGroupByIndex->selectedGroup[];
                  &projects.theProjects.element[]->newProj[];
                  selectedGroup.location->newProj.location;
                  (if newProj.name[]=NONE then
                      selectedGroup.name.copy->newProj.name[]
                  if);
                  '*'->newProj.name.append;
                  true->newProj.isRoot;
                  
                  newProj[]->projects.theProjects.append;
                  newProj[]->root[];
                  
                  &root.subprojects.element[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isDomain;
                  '[domain]'->newProj.name[];
                  newProj[]->root.subprojects.append;
                  
                  &root.subprojects.element[]->newProj[];
                  root.location->newProj.location;
                  true->newProj.isExtent;
                  '[extent]'->newProj.name[];
                  newProj[]->root.subprojects.append;
                  
                  projectsChanged;
                  root[]->setProject;
              if)
          if)
      if)
   #)[]->thegrouplist.appendAction;
   
--- onProjectListOpen: dopart --- 
do &theprojectlist.action
   (# eventtype:: theprojectlist.theeventhandler.mousedown;
      i: @integer;
      selectedProj: ^projects.theProjects.element;
   do (if (theprojectlist.selection.first->i)<>0 then
          (if theEvent.doubleClick then
              i->projectByIndex->selectedProj[];
              (if selectedProj.unfolded then
                  false->selectedProj.unfolded;
                  selectedProj[]->foldSubprojects;
               else
                  true->selectedProj.unfolded;
                  selectedProj[]->unfoldSubprojects;
              if);
              projectsChanged;
              selectedProj[]->setProject;
          if)
      if)
   #)[]->theprojectlist.appendAction;
   
--- menuFileSaveSettingsOnselect: dopart ---
do browser.saveSettings
   
--- menuFileReloadSettingsOnselect: dopart ---
do browser.reloadSettings
   
--- menuFileQuitOnselect: dopart ---
do ymerBrowserWindowCount-1
     ->ymerBrowserWindowCount;
   l: ymerPrivate.history.scan
     (#
     do (if not current.theSif.closeGroup then true->cancelQuit; leave l if)
     #);
   (if not cancelQuit then
       (if ymerBrowserWindowCount=0 then
           terminate
        else 
           this(ymerBrowserWindow).close
       if)   
   if)
   
--- menuProjectsLoadOnselect: dopart ---
do &fileSelectionDialog(# do 'Load Project File'->label[] #)->t[]; 

   (if true
    // t[]=NONE then (* ignore: cancel pressed *)
    // t[]->fileAvailable then
       &browser.projects.theProjects.element[]->newProj[];
       t->newProj.location;
       newProj[]->browser.projects.setupProject;
       newProj[]->browser.projects.theProjects.append;
       browser.projectsChanged;
       newProj[]->browser.setProject;
   if)
   
--- menuProjectsLoadStdOnselect: dopart ---
do (if not ('.'->(('~beta/configuration/r3.0',ph.currentDirectory)->ph.localpath).equal) then
       &browser.projects.theProjects.element[]->newProj[];
       ('~beta/configuration/r3.0/ymer.pjt',ph.currentDirectory)
         ->ph.convertFilePath
         ->projectFile[];
       (if projectFile[]->fileReadable then
           true->newProj.isProjectFile;
           'Std. Libraries/+'->newProj.name[];
           projectFile->newProj.location;
           (projectFile[],newProj[])
             ->browser.projects.theProjects.parseProjectFile;
           newProj[]->browser.projects.theProjects.append;
           browser.projectsChanged;
           newProj[]->browser.setProject
       if)
   if);   
   
--- menuProjectsRelocateOnselect: dopart ---
do browser.currentProject[]->cp[];
   fileSelectionDialog(# do 'Specify new location'->label[] #)->t[];
   (if true
    // (t[]=NONE) then (* ignore: cancel pressed *)
    // t[]->fileAvailable then
       t->cp.location;
       cp[]->browser.projects.setupProject;
       (if cp.unfolded then
           cp[]->browser.foldSubprojects;
           cp[]->browser.unfoldSubprojects;
       if);
       browser.projectsChanged;
       cp[]->browser.setProject
   if)
   
--- menuProjectsDeleteOnselect: dopart ---
do browser.currentProject[]->cp[];
   (if cp.unfolded then
       cp[]->browser.foldSubprojects;
   if);
   cp[]
     ->browser.projects.theProjects.at
     ->browser.projects.theProjects.delete;
   browser.projectsChanged
   
--- menuGroupsNewOnselect: dopart ---
do (*fileSelectionDialog(# do 'New group'->label[] #)->t[];
   &browser.projects.group[]->newGroup[];
   newGroup[]->browser.currentProject.subprojects.append;
   t->newGroup.location;
   t[]->newGroup.name[];
   browser.projectsChanged*)
   
--- menuGroupsAddOnselect: dopart ---
do

--- menuGroupsDeleteOnselect: dopart ---
do 
   
--- menuGroupsSemanticOnstatus: dopart ---
do false->value;
   l: (if browser.currentGroup[]<>NONE then
          (# exp: ^mps.AST.expanded;
             ff: ^mps.AST.fragmentForm;
             fg: ^mps.AST.fragmentGroup;
          do browser.currentGroup.getfg->fg[];
             (if fg[]<>NONE then
                 fg.fragmentList.scan
                 (#
                 do (if current.type
                     // mps.AST.formType then
                        (#
                        do current.open->ff[];
                           (if ff.root.kind=mps.AST.kinds.interior then
                               ff.root[]->exp[];
                               exp.suffixWalk
                               (# t: ^text
                               do (if current.hasSemanticError then
                                      true->value;
                                      leave l
                                  if)
                               #)
                           if)
                        #)
                    if)
                 #)
             if)
          #)
      if)
   
--- menuGroupsSemanticOnselect: dopart ---
do (# se: @browser.semanticEditor
   do browser.currentGroup.getfg->se.fg[];
      browser.currentGroup.name[]->se.fgName[];
      se.open
   #)
   
--- onCurrentFormChange: dopart ---
do (if newForm[]<>NONE then
       ymerPrivate.history.find
       (# predicate::
            (#
            do (if none
                // browser.currentProject[] then
                // browser.currentGroup[] then
                // current.theProject.location[] then
                // current.theGroup.location[] then
               if);
               ((current.theProject.location[]->browser.currentProject.location.equalNCS)
               and (current.theGroup.location[]->browser.currentGroup.location.equalNCS)
               and (current.theForm[]=newForm[]))->value
            #);
          notFound::
            (# newHist: ^ymerPrivate.history.element
            do &ymerPrivate.history.element[]->newHist[];
               browser.currentProject[]
                 ->newHist.theProject[];
               browser.currentGroup[]
                 ->newHist.theGroup[];
               newForm[]
                 ->newHist.theForm[];
               browser.getFragmentFormEditor
                 ->newHist.theSif[];
               newHist[]->ymerPrivate.history.prepend;
               (this(ymerBrowserWindow).theMenubar).historyMenu.addHistoryElement;
            #)
          do
       #)   
   if);
   
--- selectFragmentGroup: dopart ---
do browser.currentProject.groups.find
   (# predicate:: (# do fgName[]->current.location.equalNCS->value #);
      notFound:: 
        (# cp: ^browser.projects.theProjects.element;
           newGroup: ^browser.currentProject.groups.element
        do browser.currentProject[]->cp[];
           &cp.groups.element[]->newGroup[];
           fgName[]->newGroup.location.puttext;
           fgName[]->fragmentDefaultName
             ->newGroup.name[];
           '+'->newGroup.name.prepend;
           true->newGroup.temporary;
           newGroup[]->browser.currentProject.groups.append;
           projectsChanged;
           (cp[],newGroup[])->browser.setGroup;
        #)
   do (browser.currentProject[],current[])->browser.setGroup
   #)
   
--- selectFragmentForm: dopart ---
do fgName[]->selectFragmentGroup;
   (# t: @text;
      ff: ^MPS.ast.fragmentForm;
   do (formName[],screen[])->browser.currentGroup.fg.open->ff[];
      (if ff[]=NONE then
          'Selected fragment form:\n  "%s"\nnot in selected group:\n   "%s"'
            ->t.putformat(# do formName[]->s; fgName[]->s #);
          (NONE, t[], 'Warning')->alertUser
       else
          (browser.currentProject[],browser.currentGroup[],ff[])
            ->browser.setFragmentForm
      if);
   #)
   
---  ymerInit: descriptor ---
(# OS: @osInterface;
do OS.init;
   OS.hostMachine->machinetype;
   '$(BETALIB)'->expandEnvVar
   (# defaultValue::
        (# do '/usr/local/lib/beta'->envvarvalue[] #)#)
     ->BETAlib[];
   mps.init;
   browsers.init;
   getSystemEnv->theSystemEnv[];
   INNER init;
   ymerBrowser.open;
#)

--- ymerPrivate: descriptor ---
(# history: @list
     (# element::
          (# theProject: ^browser.projects.theProjects.element;
             theGroup: ^browser.projects.group;
             theForm: ^MPS.ast.fragmentForm;
             theSif: ^sifTextEditor;
          #)
     #);
   newWorkspace:
     (# do &workspaceType[]->workspace[] #);
   workspaceCount: @integer;
   workspace: ^workspaceType;
   workspaceType: ymerLocalWindow
     (# menubarType::
          (# addMenu: @menu
               (# iAddCurrentForm: @menuItem
                    (# eventhandler::
                         (# onStatus::
                              (# t: ^text
                              do (browser.currentForm[]<>NONE)->value;
                                 (if value then
                                     browser.currentGroup.name.copy->t[];
                                     '-'->t.put;
                                     browser.currentForm.name->t.append;
                                     t[]->name
                                  else 'no fragment form selected'->name
                                 if)
                              #);
                            onSelect::
                              (#
                              do browser.currentForm[]
                                   ->panes.contents.addFragmentForm;
                              #);
                         #)
                    #);
                  iAddCurrentGroup: @menuItem
                    (# eventhandler::
                         (# onStatus::
                              (# t: ^text
                              do (browser.currentGroup[]<>NONE)->value;
                                 (if value then
                                     browser.currentGroup.name.copy->t[];
                                     '-**all**'->t.puttext;
                                     t[]->name
                                  else 'no group selected'->name
                                 if)
                              #);
                            onSelect::
                              (#            
                              do (browser.currentGroup.getfg).fragmentList.scan
                                 (#
                                 do (if current.type
                                     // mps.AST.formType then
                                        (#
                                        do current.open
                                             ->panes.contents.addFragmentForm;
                                        #);
                                    if);
                                 #)
                              #)
                         #)
                    #);
                  open::
                    (#
                    do 'Add'->name;
                       iAddCurrentForm.open; iAddCurrentForm[]->append;
                       iAddCurrentGroup.open; iAddCurrentGroup[]->append;
                    #)
               #);
             removeMenu: @menu
               (# addItem:
                    (# newIform: ^iForm;
                       member: ^labelled;
                    enter member[]
                    do &iForm[]->newIform[];
                       member[]->newIform.member[];
                       newIform.open; newIform[]->append; newIform.setName;
                    #);
                  iForm: menuItem
                    (# member: ^labelled;
                       eventhandler::
                         (# onSelect::
                              (#
                              do member[]->panes.contents.deleteMember;
                                 this(iForm)[]->delete
                              #);
                         #);
                       setName: (# do member.label->name #)
                    #);
                  open::
                    (# do 'Remove'->name #)
               #);
             open::
               (#
               do addMenu.open; addMenu[]->append;
                  removeMenu.open; removeMenu[]->append;
               #)
          #);
        panes: @scroller
          (# contentsType:: dynpane
               (# changing: @boolean;
                  FFVlist: @list(# element:: fragmentFormView #);
                  fragmentFormView: labelled
                    (# ff: ^mps.AST.fragmentForm;
                       onFatherFrameResizeRelative: @action
                         (# w,w1,h,h1: @integer;
                            eventType:: theEventHandler.fatherFrameChanged;
                         do (if not changing then
                                size->(w,h);
                                panes.size->(w1,h1);
                                (w1-35,h)->size
                            if);
                         #);
                       installResizeRelativeAction:
                         (# do onFatherFrameResizeRelative[]->appendAction #);
                       dobind:
                         (#
                         do installResizeRelativeAction;
                            contents.dobind
                         #);
                       contentsType:: codemoveableEditor
                         (# dobind:
                              (# do true->bindRight->bindBottom->bindLeft->bindTop #);
                            selectNode:: 
                              (# ffV: ^fragmentFormView
                              do node.frag[]->addFragmentForm->ffV[];
                                 (node[],1,0,0)
                                   ->FFV.contents.SifViewer.setFocus;
                              #);
                            open::
                              (# t: ^text;
                              do this(fragmentFormView).contents[]
                                   ->browser.onCodeViewOpen;
                                 (ffEncloser.getAST,ffEncloser.getBETACFL,
                                 ff[],NONE)
                                   ->newFragment;
                                 (ff.father).fullName->fragmentDefaultName->t[];
                                 '-'->t.put;ff.name->t.append;
                                 t[]->label
                              #); 
                            charWidthType::
                              (#
                              do this(fragmentFormView).private.theLabel.style
                                   ->ts[]
                              #);
                            getEncloser:: (# do ffEncloser[]->theEncloser[] #);
                         #); 
                       ffEncloser: @codemoveableEditorEncloser
                         (# getAST:: (# do mps.AST[]->AST[] #);
                            getBETACFL:: (# do mps.BETACFL[]->BETACFL[] #);
                         #);
                       open::
                         (# sz: @point;
                            openContents::
                              (#
                              do (none,sz)->contents.open; true->doneInInner
                              #)
                         enter sz
                         do sz->size
                         #)
                    #);
                  addFragmentForm:
                    (# ffV: ^fragmentFormView;
                       w,h,pw,ph: @integer;
                       ff: ^mps.AST.fragmentForm
                    enter ff[]
                    do l: FFVlist.scan
                         (#
                         do (if ff[]=current.ff[] then
                                current[]->ffV[]; leave l;
                            if)
                         #);
                       (if ffV[]=NONE then (* not already in workspace *)
                           panes.size->(w,h);
                           &fragmentFormView[]->ffV[];
                           ff[]->ffV.ff[];
                           (this(contentsType)[], (w-35,150))->ffV.open;
                           
                           true->changing;
                           ffV[]-> this(contentsType).appendMember;
                           this(contentsType).appendsDone; ffV.dobind;
                           ffV[]->FFVlist.append;
                           false->changing;
                           
                           ffV[]->(theMenubar).removeMenu.addItem;
                       if);
                       ffV.position->(w,h);
                       panes.contents.position->(pw,ph);
                       (pw,-h)->panes.contents.position (* panes.scrollIntoView *);
                    exit ffV[]
                    #);
                  dobind:
                    (# do TRUE->bindTop->bindLeft->bindRight->bindBottom #);
                  open:: 
                    (# setDefaults:: 
                         (#
                         do true->verticalStacking;
                            50->minsize;
                            2->panewidth
                         #);
                    do doBind
                    #);
               #);
             open::
               (# do TRUE->bindTop->bindLeft->bindRight->bindBottom #);
          #);
        open::
          (# t: ^text
          do 'Workspace'->t[];
             workspaceCount+1->workspaceCount; 
             (if workspaceCount>1 then
                 '<'->t.put; workspaceCount->t.putint; '>'->t.put;
             if);
             t[]->title; panes.open;
          #);
     #)
#)
