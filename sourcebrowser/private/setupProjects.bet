ORIGIN 'sourcebrowserbody';
(*
 * COPYRIGHT
 *   Copyright (C) Aarhus University
 *   All rights reserved.
 *)
-- sourcebrowserLib: Attributes --
RealLocation:
  (# (* converts linknames relative to the group *)
     groupName: ^Text; s,t: ^Text; fg: ^mps.ast.fragmentGroup
  enter (s[],fg[])
  do
     (if fg[] <> none then
         fg.fullName->mps.AST.stripPathName->t[];
         (if t[] <> none then
             (s.copy,t[])->mps.AST.thePathHandler.convertFilePath->s[]
         if)
     if)
  exit s[]
  #);


-- parseProjectFile: Descriptor --
(#
   (* project file grammar:
    *     START         ::  <projects> | <groups>
    *     <projects>    ::= <project>*
    *     <project>     ::= project <projectname> <projectDefn>
    *     <projectname> ::= <name> | STRING | <empty>
    *     <projectDefn> ::= <directory> | <root> | <groups> | <subprojects>
    *     <directory>   ::= STRING
    *     <root>        ::= STRING
    *     <groups>      ::= <group>+
    *     <group>       ::= group <groupname> <groupDefn>
    *     <groupname>   ::= <name> | <empty>
    *     <groupDefn>   ::= <.ast-file> | <.bet-file> | <forms>
    *     <.ast-file>   ::= STRING
    *     <.bet-file>   ::= STRING
    *     <forms>       ::= <form>+
    *     <form>        ::= form <formname> <formDefn>
    *     <formname>    ::= <name> | <empty>
    *     <formDefn>    ::= <.ast-file> | <.bet-file>
    * 
    *     <subprojects> ::= <projects> DASH
    *  
    *     <name>        ::= stringname | NAME
    *     <stringname>  ::= HASH NAME | HASH
    * 
    * Lexical tokens:
    *     NAME          {[a-zA-Z]+[a-zA-Z]*}
    *     STRING        {'[^']*'}           {* embedded '' allowed as ' *}
    *     DASH          {--+}
    *     HASH          {#}
    *)
   filename,projectname: ^text;
   input: @file;
   dash: (#  exit - 1 #);
   name: (#  exit - 2 #);
   stringname: (#  exit - 4 #);
   string: (#  exit - 5 #);
   const: (#  exit - 6 #);
   EOF: (#  exit - 7 #);
   projectT: (#  exit - 8 #);
   groupT: (#  exit - 9 #);
   formT: (#  exit - 10 #);
   semiColon: (#  exit ';' #);
   colon: (#  exit ':' #);
   inputPos,lastOKPos: @integer;
   firstComment: @boolean;
   fgComment: @Text;
   markError:
     (# msg: @text
     enter msg
     do
        msg[]->screen.puttext;
        ' at position: '->screen.puttext;
        lastOKpos->screen.putint;
        ' in file: '->screen.puttext;
        input.name->screen.putline
     #);
   get: @
     (# eos: @input.eos
     do
        (if eos then
            EOF->nextCh
         else
            inputPos+1->inputPos; input.get->nextCh
        if)
     exit nextCh
     #);
   currentToken: @ (# val: @integer;  enter val exit val #);
   advance: @|
     (# 
     do
        get;
        cycle
        (# 
        do
           inputPos->lastOKPos;
           (if nextCh
            // '-' then
               (if get = '-' then
                   loop1: (if get = '-' then restart loop1 if);
                   dash->currentToken;
                   SUSPEND;
                   
                else
                   dash->currentToken; SUSPEND; 
               if);
               
            // '\'' then
               theText.clear;
               loop:
                 (if get
                  // '\'' // EOF then ; 
                  else
                     nextCh->theText.put; restart loop
                 if);
               string->currentToken;
               SUSPEND;
               get
            // '(' then
               (if get
                // '*' then
                   (if firstComment then false->firstComment if);
                   loop:
                     (if get
                      // '*' then
                         loop1:
                           (if get
                            // '*' then
                               nextCh->fgComment.put; restart loop1
                            // ')' then
                               get; leave loop
                            // EOF then
                               'advance: EOF reached while skipping this comment'
                                 ->markerror
                            else
                               '*'->fgComment.put;
                               nextCh->fgComment.put;
                               restart loop
                           if)
                      // EOF then
                         'advance: EOF reached while skipping this comment'
                           ->markerror
                      else
                         nextCh->fgComment.put; restart loop
                     if)
                else
                   '('->currentToken; SUSPEND
               if)
            // EOF // ascii.fs then
               EOF->currentToken; SUSPEND; 
            // '#' then
               theText.clear;
               (if get
                // '\'' then
                   loop:
                     (if get
                      // '\'' // EOF then ; 
                      else
                         nextCh->theText.put; restart loop
                     if)
               if);
               stringname->currentToken;
               SUSPEND;
               get
            else
               (if true
                // ('0' <= nextCh) and ('9' >= nextCh) then
                   nextCh-'0'->theConst;
                   get;
                   loop:
                     (if ('0' <= nextCh) and ('9' >= nextCh) then
                         10*theConst+nextCh-'0'->theConst; get; restart loop
                     if);
                   const->currentToken;
                   SUSPEND;
                   
                //
                   ('A' <= (nextCh->ascii.upcase))
                   and
                   ('Z' >= (nextCh->ascii.upcase)) then
                   theText.clear;
                   nextCh->theText.put;
                   get;
                   loop:
                     (if true
                      //
                         ('A' <= (nextCh->ascii.upcase))
                         and
                         ('Z' >= (nextCh->ascii.upcase)) // '_' = nextCh
                      // ('0' <= nextCh) and ('9' >= nextCh) then
                         nextCh->theText.put; get; restart loop
                     if);
                   (if true
                    // 'PROJECT'->nameEqual then
                       projectT->currentToken; SUSPEND
                    // 'GROUP'->nameEqual then
                       groupT->currentToken; SUSPEND
                    // 'FORM'->nameEqual then
                       formT->currentToken; SUSPEND
                    else
                       name->currentToken; SUSPEND
                   if)
                // (0 <= nextCh) and (nextCh <= 32) then
                   get
                else
                   nextCh->currentToken; SUSPEND; get
               if)
           if)
        #)
     #);
   nextCh: @integer;
   theText: @text;
   theConst: @integer;
   accept: @
     (# token: @integer; errorText: @text
     enter token
     do
        (if currentToken <> token then
            (if token
             // name then
                'accept: NAME expected'->markError; 
             // string then
                'accept: STRING expected'->markError; 
             // const then
                'accept: CONST expected'->markError; 
             // projectT then
                'accept: "project" expected'->markError; 
             // groupT then
                'accept: "group" expected'->markError; 
             // formT then
                'accept: "form" expected'->markError; 
             // dash then
                'accept: "--" expected'->markError; 
             // EOF then
                'accept: EOF expected'->markError; 
             else
                'accept: "'->errorText;
                token->errorText.put;
                '" expected'->errorText.puttext;
                errorText->markError
            if)
        if)
     #);
   nameEqual: @
     (# name: ^text enter name[] exit (theText[]->name.equalNCS) #);
   parseProjectFileContents:
     (# newProj: ^hierarchy.project; 
     enter newProj[]
     do
        (if newProj[] = none then &tv.projectFile[]->newProj[];  if);
        (if newProj.label[] = none then
            input.entry.path.name.prefix->newProj.label[]
        if);
        (if newProj.location.empty then
            input.name->newProj.location.puttext
        if);
        newProj[]->parseProjectList;
        EOF->accept
     #);
   parseProjectList:
     (#
        currProj: ^hierarchy.project;
        parseGroupList:
          (#
             currGroupList: ^hierarchy.project;
             parseGroup:
               (#
                  newGroup: ^hierarchy.group;
                  f: @file;
                  ext: ^text;
                  parseFormList:
                    (#
                       currFormList: ^hierarchy.group;
                       parseForm:
                         (# newForm: ^hierarchy.form
                         do (* parseForm *)
                            advance;
                            string->accept;
                            &tv.form[]->newForm[];
                            theText.copy->newForm.location[];
                            newForm[]->currFormList.addItem;
                            advance;
                            
                         #)
                    enter currFormList[]
                    do (* parseFormList *)
                       loop:
                         (if currentToken
                          // formT then
                             parseForm; restart loop; 
                          // projectT // groupT // dash // EOF then
                             leave loop
                          else
                             'parseFormList: EOF, "project", "group", "form" or "--" expected'
                               ->markError
                         if)
                    #);
                  
               do (* parseGroup *)
                  groupT->accept;
                  advance;
                  &tv.group[]->newGroup[];
                  (if currentToken
                   // name // stringname then
                      theText.copy->newGroup.label[]; advance
                  if);
                  (if currentToken
                   // string then
                      theText.copy->newGroup.location[];
                      advance;
                      (if none
                       // newGroup.label[] then
                          newGroup.location.copy->newGroup.label[]
                       // newGroup.location[] then
                          newGroup.label[]->newGroup.location.puttext
                      if);
                      newGroup.location[]->f.name;
                      f.entry.path.name.suffix->ext[];
                      (if ext[]->mps.AST.grammarTable.legalExtension
                          then
                          (newGroup.location.length-(ext.length-1),
                          newGroup.location.length)->newGroup.location.delete
                      if)                      
                   else
                      'parseGroup: NAME or STRING expected'->markError
                  if);
                  currGroupList[]->newGroup.init;
                  (if
                      ((newGroup.location[]->mps.ast.expandtofullpath
                        ->fileAvailable) or
                      (mps.ast.astFileExtension->(newGroup.location.copy).append
                        ->mps.ast.expandtofullpath->fileAvailable)) then
                      newGroup[]->currGroupList.addItem; 
                   else
                      (# t: ^text
                      do
                         'Group: '->t[];
                         newGroup.location[]->t.puttext;
                         (* (none ,t[],'Not Available')->alertUser *)
                         ' is not available!'->t.append;
                         t[]->putline
                      #)
                  if);
                  newGroup[]->parseFormList                  
               #)
          enter currGroupList[]
          do (* parseGroupList *)
             loop:
               (if currentToken
                // groupT then
                   parseGroup; restart loop; 
                // projectT // formT // dash // EOF then
                   leave loop
                else
                   'parseGroupList: EOF, "project", "group", "form" or "--" expected'
                     ->markError
               if)
          #);
        parseProject:
          (# newProj: ^hierarchy.project; n: ^text
          do (* parseProject *)
             projectT->accept;
             advance;
             (if currentToken
              // name // stringname then theText.copy->n[]; advance; 
             if);
             (if currentToken
              // string then
                 &tv.directoryProject[]->newProj[];
                 n[]->newProj.label[];
                 theText.copy->newProj.location[];
                 (if true
                     (*((newProj.location[]
                      ->mps.ast.expandtofullpath->fileAvailable) or
                      (mps.ast.astFileExtension->(newProj.location.copy).append
                      ->mps.ast.expandtofullpath->fileAvailable))*) then
                     currProj[]->newProj.superProject[];
                     (if true (*(newProj[]->setupProject)=NONE*) then
                         newProj[]->currProj.addItem; 
                     if);
                     
                 if);
                 newProj.init;
                 advance
              // groupT then
                 &tv.project[]->newProj[];
                 n[]->newProj.label[];
                 (if currentToken // name // stringname then advance;  if);
                 currProj[]->newProj.superProject[];
                 newProj[]->currProj.addItem;
                 newProj[]->parseGroupList;
                 newProj.init
              // projectT then
                 &tv.project[]->newProj[];
                 n[]->newProj.label[];
                 true->newProj.hasSubprojects;
                 (if (newProj.label.length > 0) and
                     ((newProj.label.length->newProj.label.inxGet) <> '/') then
                     '/'->newProj.label.append; 
                 if);
                 currProj[]->newProj.superProject[];
                 newProj[]->currProj.addItem;
                 newProj[]->parseProjectList;
                 newProj.init
              else
                 'parseProject: STRING or NAME expected'->markError
             if);
             
          #);
        
     enter currProj[]
     do (* parseProjectList *)
        loop:
          (if currentToken
           // projectT then
              true->currProj.hasSubprojects; parseProject; restart loop
           // groupT then
              currProj[]->parseGroupList; restart loop
           // EOF then
              leave loop
           // dash then
              advance; leave loop
           else
              'parseProjectList: EOF, "--" or "project" expected'->markError
          if)
     #);
   tv: ^hierarchy;
   newProj: ^hierarchy.projectFile;
   
enter (filename[],tv[],newProj[])
do
   filename[]->input.name;
   (if filename[]->fileAvailable then
       (if filename[]->isFile then
           input.openRead
        else
           (# t: @text
           do
              'Filename '->t;
              input.name->t.append;
              '\nrefers to a directory, not a file'->t.putline;
              (none ,t[],'Not available')->alertUser
           #)
       if);
       0->inputPos;
       true->firstComment;
       fgComment.clear;
       advance;
       newProj[]->parseProjectFileContents;
       true->newProj.isLoaded;
       input.close
    else
       (# t: @text
       do
          'File: '->t;
          input.name->t.append;
          '\nnot available (do not exist or not readable)'->t.putline;
          (none ,t[],'Not available')->alertUser
       #)
   if)
#)  

-- setupProjectFile: Descriptor --
(# filename: ^text; tv: ^hierarchy; prj: ^hierarchy.projectFile
enter (tv[],prj[])
do
   prj.location[]->mps.ast.expandtofullpath->filename[];
   (if filename[]->fileAvailable then
       (filename[],tv[],prj[])->parseProjectFile
   if)
#)  

-- setupDirectory: Descriptor --
(#
   directoryname: ^text;
   d: @directory;
   newDir: ^hierarchy.directoryProject;
   tv: ^hierarchy;
   proj,tmpproj: ^hierarchy.directoryProject;
   itemlist:list(# element::tv.item #);
   dirlist,projfilelist,filelist:@itemlist;
enter (tv[],proj[],directoryname[])
do (if debugsourcebrw then
       'SetupDir on proj.label=%s, dirname=%s\n'
         ->putformat (#  do proj.label[]->s; directoryname[]->s #)
   if);
   dirlist.init;projfilelist.init;filelist.init;
   directoryname[]->mps.ast.expandtofullpath->directoryname[];
   (if directoryname[]->fileAvailable then
       'scanning directory "'->puttext;
       proj.label[]->puttext;
       '" ... '->puttext;
       directoryname[]->d.entry.path;
       (* create dotdot(parent) directory *)
     
       d.scanEntries 
       (# error::  (#  do true->continue #); pjtExt: ^text
       do
          '.pjt'->pjtExt[];
          select
          (#
             error::  (#  do true->continue #);      
             whenDir:: 
               (#
                  name,lcname: ^text;
                  d: ^directory;
                  theItem: ^hierarchy.directoryProject
               do
                  thedir->d[];
                  d.entry.path.name->name[];
                  name.copy->lcname[];
                  lcname.makeLC;
                  (if true
                   // (1->lcname.inxGet) = '.' // 'sun4s'->lcname.equal
                   // 'sgi'->lcname.equal // 'nti'->lcname.equal
                   // 'linux'->lcname.equal // 'mac'->lcname.equal
                   // 'ppcmac'->lcname.equal // 'ppc'->lcname.equal
                   // 'sun4'->lcname.equal // 'sun3'->lcname.equal
                   // 'snake'->lcname.equal // 'hpux9mc'->lcname.equal
                   // 'hpux9pa'->lcname.equal // 'hpux8'->lcname.equal
                   // 'nti_ms'->lcname.equal // 'nti_gnu'->lcname.equal
                   // 'nti_bor'->lcname.equal // 'nti'->lcname.equal
                   // 'b2c'->lcname.equal then (* ignore *)
                      
                   else
                      &tv.directoryProject[]->tmpProj[]->theItem[];
                      found.path.name->theItem.label[];
                      foundFullPath->theItem.location[];
                      tmpProj.init;
                      (* theItem[]->proj.prependItem; *)
                      proj[]->theItem.father[];
                      theItem[]->dirlist.append
                  if)
               #);
             whenFile:: 
               (#
                  newGroup: ^hierarchy.group;
                  newTxtFile: ^hierarchy.txtfile;
                  newTmpProj: ^hierarchy.temporaryProject;
                  f: ^file;
                  ext: ^text;
                  ll: @integer
               do
                  thefile->f[];
                  f.entry.path.name.suffix->ext[];
                  (if foundfullpath->fileReadable then
                      (if true
                       // ext[]->mps.AST.grammarTable.legalExtension then
                          &tv.group[]->newGroup[];
                          found.path.name.prefix->newGroup.label[];
                          (* foundFullPath->newGroup.location[]; *)
                          d.name->newGroup.location[];
                          '/'->newGroup.location.put;
                          found.path.name.prefix->newGroup.location.puttext;
                          
                          proj[]->newGroup.init;
                          proj.items.find
                          (#
                             predicate:: 
                               (# 
                               do
                                  current.label[]->newGroup.label.equal
                                    ->value
                               #);
                             notFound:: 
                               (#  do newGroup[]->proj.addItem #)
                          #)
                       // ext[]->PjtExt.equal then
                          (if not ('.recentProject'->(f.entry.path.name.prefix).equal) then
                              &tv.ProjectFile[]->newTmpProj[];
                              f.entry.path.name.prefix->newTmpProj.label[];
                              (prjicon[],prjopenicon[])->newTmpProj.icon;
                              foundFullPath->newTmpProj.location[];
                              newTmpProj.init;
                              (* newTmpProj[]->proj.prependItem *)
                              proj[]->newTmpProj.father[];
                              newTmpProj[]->projfilelist.append
                          if)
                       // proj.showTxtFiles then
                          &tv.TxtFile[]->newTxtFile[];
                          found.path.name->newTxtFile.label[];
                          foundFullPath->newTxtFile.location[];
                          newTxtFile.label.length->ll;
                          (if true
                           // ((1->newTxtFile.label.inxGet) = '#')
                           // ((1->newTxtFile.label.inxGet) = '.')
                           // ((ll->newTxtFile.label.inxGet) = '#')
                           // ((ll->newTxtFile.label.inxGet) = '~') then
                              (* ignore *)
                              
                           else
                              proj.items.find
                              (#
                                 predicate:: 
                                   (# 
                                   do
                                      current.label[]
                                        ->newTxtFile.label.equal->value
                                   #);
                                 notFound:: 
                                   (# 
                                   do ' (txt)'->newTxtFile.label.append;
                                      newTxtFile[]->proj.addItem
                                   #)
                              #)
                          if)
                      if)
                  if)
               #)                 
          #)            
       #);
       
      
       projfilelist.scanReverse
       (# do current[]->proj.prependItem
       #);
       
       &tv.directoryProject[]->newDir[];
       '../'->newDir.label[];
       (d.entry.path.head)->newDir.location[];
       (if (newDir.location.length > 0) and (newDir.location[]->fileAvailable)
           and (newDir.location[]->isDirectory) then
           newDir[]->proj.prependItem
       if);
       newDir.init;
       
       dirlist.scanReverse
       (# do current[]->proj.prependItem
       #);
       proj.init;
       newline
   if)
#)  

-- setupGroup: Descriptor --
(#
   tv: ^hierarchy;
   grp: ^hierarchy.group;
   prt: ^hierarchy.properties;
   includeForms: @boolean
enter (tv[],grp[],includeForms)
do
   grp[]->getfg;
   (if grp.fg[] <> none then
       (* &tv.properties[]->prt[];
        'Properties'->prt.label[];
        prt[]->grp.addItem; *)
       grp.fg.scanPropsAndFrags
       (# hasBuild:@boolean;
          doFragmentLink:: 
            (# i: ^hierarchy.include; t: ^text;
               lfmenuitem:^guienv.menu.menuitem                   
            do
               &tv.include[]->i[];
               (* 'INCLUDE \''->t[];*)
               ' \''->t[];
               include.linkname[]->t.putText;
               '\''->t.put;
               t[]->i.label[];
               (include.linkname.copy,grp.fg[])->RealLocation->i.location[];
               (*'include found, grp.loc:%s linkname:%s i.log:%s\n'->putformat(# do grp.location[]->s; include.linkname[]->s;origin.i.location[]->s#);*)
               (includeicon[],none)->i.icon;
               &i.lfmenu.menuitem
               (#
                  eventhandler:: 
                    (#
                       onSelect:: 
                         (# tg:^hierarchy.group;
                            it:^hierarchy.item
                         do i[]->it[];
                            l:(if true then
                                  it.father[]->it[];
                                  (if it##=tv.group## then it[]->tg[]; leave l if);
                                  restart l
                              if);
                            tg[]->tv.onPropertyShowEditor
                         #)
                    #);
                  open::  (#  do 'Edit Properties'->name #)
               #)[]->lfmenuitem[];
               i.lfmenu.open;
               lfmenuitem.open;
               lfmenuitem[]->i.lfmenu.append;
               i.lfmenu[]->i.popupmenu;
               i[]->grp.addItem
            #);
          doFragmentGroup:: 
            (# i: ^hierarchy.group; 
            do &tv.group[]->i[]; 'UNKNOWN'->i.label[]; i[]->grp.addItem
            #);
          doFragmentForm:: 
            (# i: ^hierarchy.form; t,catName: ^text
            do
               (if includeForms and (fle.type = mps.AST.formType) then
                   &tv.form[]->i[];
                   fficon[]->i.icon;
                   fle.open->i.ff[];
                   (i.ff.name).copy->t[];
                   ': '->t.puttext;
                   i.ff.category->i.ff.Grammar.symbolToName->catName[];
                   (if true
                    // ('DescriptorForm'->catName.equal)
                    // ('ObjectDescriptor'->catName.equal) then
                       'Descriptor'->t.putText; 
                    // ('AttributesForm'->catName.equal)
                    // ('AttributeDecl'->catName.equal) then
                       'Attributes'->t.putText; 
                    else
                       (if catName.empty then
                           'Unexpanded'->t.putText; 
                        else
                           catName[]->t.putText; 
                       if)
                   if);
                   t[]->i.label[];
                   i.ff.fullname->i.location[];
                   i[]->grp.addItem
               if)
            #);
          doProperty:: 
            (#
               i: ^hierarchy.element;
               t,propUC: ^text;
               pe: ^hierarchy.propertyelement;
               lfmenuitem:^guienv.menu.menuitem
            do
               prop.copy->propUC[];
               propUC.makeUC;
               (* Do not write 'Include' etc. anymore
                * propUC.copy->t[];
                * ' '->t.put;
                *)
               &text[]->t[];
               none ->i[];
               none ->pe[];
               (if true
                // ('ORIGIN'->propUC.equal) then
                   &tv.origin[]->pe[]; (originicon[],none)->pe.icon
                // ('BODY'->propUC.equal) // ('MDBODY'->propUC.equal) then
                   &tv.body[]->pe[]; (bodyicon[],none)->pe.icon
                // ('OBJFILE'->propUC.equal) // ('BETARUN'->propUC.equal)
                // ('MAKE'->propUC.equal) // ('LIBFILE'->propUC.equal) then
                   &tv.property[]->i[]; selector[]->t.putText; ' '->t.put
                // ('BUILD'->propUC.equal) then
                   (if not hasbuild then
                       &tv.build[]->i[];
                       'BUILD ...'->s;
                       true->hasBuild
                   if)
               if);
               '\''->t.put;
               s[]->t.putText; 
               '\' '->t.putText;
               (if i[] <> none then
                   t[]->i.label[]; s.copy->i.location[]; i[]->grp.addItem
                else
                   (if pe[]<>none then
                       t[]->pe.label[];
                       &pe.lfmenu.menuitem
                       (#
                          eventhandler:: 
                            (#
                               onSelect:: 
                                 (# tg:^hierarchy.group;
                                    it:^hierarchy.item
                                 do pe[]->it[];
                                    l:(if true then
                                          it.father[]->it[];
                                          (if it##=tv.group## then it[]->tg[]; leave l if);
                                          restart l
                                      if);
                                    tg[]->tv.onPropertyShowEditor
                                 #)
                            #);
                          open::  (#  do 'Edit Properties'->name #)
                       #)[]->lfmenuitem[];
                       lfmenuitem.open;  
                       pe.lfMenu.open;
                       lfmenuitem[]->pe.lfmenu.append;
                       pe.lfMenu[]->pe.popupMenu; 
                       (s.copy,grp.fg[])->RealLocation->pe.location[];
                       pe[]->grp.addItem
                   if)
               if)
            #);
          doConstProperty:: 
            (# i: ^hierarchy.property; t: ^text
            do
               &tv.property[]->i[];
               (if toggle then 'ON '->t[] else 'OFF '->t[] if);
               const->t.putInt;
               t[]->i.label[];
               i[]->grp.addItem
            #);
          fileno: (*private*) @integer;
          
       #)
   if)
#)  

-- groupGetfg: DoPart --
do 
   (if grp.hasNoDiskFile then leave getFg if);
   (if grp.fg[] = none then
       state.busy;
       'Opening '->infoView.settext;
       grp.location[]->infoView.append;
       '... '->infoView.append;
       infoView.msgPush;
       (if not grp.location.empty then
           grp.location[]->mps.AST.expandToFullPath
             ->mps.fragmentGroupTable.getFragmentGroup->grp.fg[];
           (if grp.fg[] <> none then grp.fg[]->doRealOpen 
            else
               true->grp.hasNoDiskFile
           if)
       if);
       infoView.msgPop;
       state.normal
    else
       recheck
   if)  

-- groupDoRealOpen: DoPart --
do
   (if not g.isRealOpen then (* open g real *)
       none
         ->mps.AST.theCatcher[] (* to remove old exception handler - HACK *) ;
       doOpen: g.realOpen
         (#
            warn:
              (# msg: ^text
              enter msg[]
              do
                 (none ,msg[],'Warning')->alertUser;
                 none
                   ->mps.AST.theCatcher[]
                 (* to remove old exception handler - HACK *) ;
                 leave doOpen
              #);
            astOverflow::  (#  do msg[]->warn #);
            fragmentNotExisting::  (#  do msg[]->warn #);
            badFormat::  (#  do msg[]->warn #);
            grammarNotFound::  (#  do msg[]->warn #);
            doubleFormDeclaration::  (#  do msg[]->warn #);
            readAccessError::  (#  do msg[]->warn #);
            noSuchFileError::  (#  do msg[]->warn #);
            otherFileError::  (#  do msg[]->warn #);
            
         #)
   if)  

-- groupRecheck: Descriptor --
(#
   diskfile,textfile: @file;
   allowReload: @boolean;
   t: @text;
   cg: ^hierarchy.group
do grp.fg.diskfilename->diskfile.name;
   grp.fg.textfilename->textfile.name;
   false->allowReload;
   (if (textfile.name->fileExists) and
       ((textfile.name->fileModtime) > grp.fg.modTime) then
       t.clear;
       'Source file: '->t.puttext;
       grp.fg.textfilename->t.putline;
       'changed since last access'->t.putline;
       'The file must have been changed by some other application.'->t.putline;
       'Quit immediately (and restart) to avoid further problems'->t.puttext;
       (none ,t[],'Warning')->alertUser;
       false->allowReload (* should be true->allowReload *)
    else
       (if (diskfile.name->fileExists) and
           ((diskfile.name->fileModtime) > grp.fg.modTime) then
           t.clear;
           'Group file: '->t.puttext;
           grp.fg.diskfilename->t.putline;
           'changed since last access'->t.putline;
           'The file must have been changed by some other application.'
             ->t.putline;
           'Quit immediately (and restart) to avoid further problems'
             ->t.puttext;
           (none ,t[],'Warning')->alertUser;
           false->allowReload (* should be true->allowReload *)
       if)
   if);
   (if allowReload then
       (*currentGroup[]->cg[];
        (currentProject[],none )->setGroup;
        grp.fg[]->ymerBrowserPrivate.geList.closeGroup;
        grp.fg[]->MPS.reload;
        (currentProject[],cg[])->setGroup;*)
       
   if)
#)  

