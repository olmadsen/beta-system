contractioncategories compound typedeflist vardeflist constdeflist;
--- pascal : agrammar : metagrammar ---
Grammar pascal:
option
  suffix = '.p'
  version = 2
rule

<Program> 	::= 'PROGRAM' <ProgramName> '(' <IdList> ')' ';' <Block> '.'; 
<ProgramName> 	::= <NameDcl>;

<Block> 	::= <LabelDeclOp> <ConstOp> <TypeOp> <VarOp> <SubProgramOp> 
	            <Compound>; 
<LabelDeclOp>   ::? <LabelDecl>;
<ConstOp>       ::? <ConstDecl>;
<TypeOp>        ::? <TypeDecl>;
<VarOp>       	::? <VarDecl>;
<SubProgramOp> 	::? <SubProgramDecl>;
<LabelDecl>     ::= 'Label' <LabelList> ';';
<ConstDecl>	::= 'Const' <ConstDefList> ';';
<TypeDecl>	::= 'Type' <TypeDefList> ';';
<VarDecl>	::= 'Var' <VarDefList> ';';
<subProgramDecl>::= <subProgramDefList> ';';
<IdList> 	::+ <NameDcl>  ','  ;
<LabelList> 	::+ <Label>  ','  ;
<ConstDefList> 	::+ <ConstDef>   ;
<TypeDefList> 	::+ <TypeDef>  ';' ;
<VarDefList> 	::+ <VarDef>   ';' ;
<SubProgramDefList> ::+ <SubProgram>  ';' ;

<ConstDef> 	::= <NameDcl> '=' <Constant>;
<TypeDef> 	::= <NameDcl> '=' <Type>;
<VarDef> 	::= <IdList> ':' <Type>;
<SubProgram> 	::| <ProcedureDef> | <FunctionDef>;
<ProcedureDef> 	::= 'procedure' <NameDcl> <ParamOp> ';' <BodySpec:Block> ;
<FunctionDef> 	::= 'function' <NameDcl> <ParamOp> 
		    ':' <ResultType:NameApl> ';' <BodySpec:Block>;
<ParamOp> 	::? <ParamDecl> ;
<ParamDecl> 	::= '(' <ParameterList> ')' ;
<ParameterList> ::+ <ParSec>  ';' ; 
<ParSec> ::| <ProcedureParSec> |
		       <FunctionalParSec> |
		       <VariableParSec> |
		       <StandardParSec>;
<ProcedureParSec> ::= 'procedure' <IdList>;
<FunctionalParSec> ::= 'function' <IdList> ':' <NameApl>;
<VariableParSec> ::= 'var' <IdList> ':' <NameApl>;
<StandardParSec> ::= <IdList> ':' <NameApl>;

<StatList> 	::+ <StatementOp>  ';';
<StatementOp>	::? <Statement>;
<Statement>	::| <LabelledStatement> |
	            <assignment> |
		    <procedureCall> |
		    <compound> |
		    <ifThenElse> |
		    <repeatLoop> |
		    <whileLoop>  |
		    <forLoop>    |
		    <caseStatement> |
		    <withStatement> |
		    <gotoStatement> |
		    <outputStatement>; 
<labelledStatement> ::= <label> ':' <Statement>; 
<Assignment>	::= <variable> ':=' <expression>;
<procedureCall> ::= <procedureName:NameApl> <ActualOp>;
<ActualOp>      ::? <ActualArguments>; 
<ActualArguments> ::= '(' <exprList> ')';
<ExprList>	::+ <Expression>  ',';
<compound>	::= 'begin' <statlist> 'end';
<ifThenElse>	::= 'if' <expression> 
		    'then' <consequent:statement>
		    <elsePartOpt>;
<elsePartOpt>   ::? <elsePart>;
<elsePart>      ::= 'else' <elternate:statement>;
<repeatLoop>	::= 'repeat' <statList> 'until' <expression>;
<whileLoop>	::= 'while' <expression> 'do' <statement>;
<forLoop>	::| <forToLoop> | <forDowntoLoop>;
<forToLoop>     ::= 'for' <Index:NameApl> ':='
		    <InitialValue:Expression> 'to' <FinalValue:Expression> 
		    'do' <statement>;
<forDownToLoop> ::= 'for' <Index:NameApl> ':='
		    <InitialValue:Expression> 'downto' <FinalValue:Expression> 
		    'do' <statement>;
<caseStatement> ::= 'case' <expression> 'of'
		    <caseClaseList> 'end';
<caseClaseList> ::+ <caseClase>  ';' ;
<caseClase>	::= <constantList> <statement>;
<withStatement>	::= 'with' <varList> 'do' <statement>;
<gotoStatement> ::= 'goto' <label>;
<outputStatement> ::| <writeStatement> | <writelnStatement>;
<writeStatement> ::= 'write' <writeParList>;
<writelnStatement> ::= 'writeln' <writeParListOp>;
<writeParListOp> ::? <WriteParList>;
<writeParList> ::= '(' <writeParameterList> ')'; 
<writeParameterList> ::+ <writeParameter>  ',' ;
<writeParameter> ::= <expression> <fielddescriptorOp>;
<fielddescriptorOp> ::? <fieldDescriptor> ;
<fielddescriptor> ::| <simpleFieldDesc> | <complexFieldDesc>;
<simpleFieldDesc> ::= ':' <expression>;
<complexFieldDesc> ::= ':' <expression> ':' <decimalplaces:expression>;

<Type> 		::| <simpleType> | <pointerType> | <structuredType>;
<simpleType>	::| <enumeratedType> | <rangeType> | <typeIdentifier>;
<enumeratedType> ::= '(' <IdList> ')';
<rangeType>	::= <lowerbound:constant> '..' <upperBound:constant>;
<pointerType>	::= '^' <NameApl>;
<structuredType> ::| <packedType> | <unpackedType>;
<packedType>	::= 'packed' <unpackedtype>;
<unpackedType>	::| <setType> | <stringType> | <arrayType> | <recordType> | <fileType>;
<setType>	::= 'set' 'of' <simpleType>;
<stringType> ::= 'string' '[' <constantNumber> ']';
<arrayType>	::= 'array' '[' <indexTypeList> ']' 'of' <baseType:type>;
<indexTypeList>	::+ <simpleType>  ',' ;
<recordType>	::= 'record' <fieldList> 'end';
<fieldList>	::| <fixedField> | <mixedFieldList> | <variantFieldList>;
<fixedField>    ::= <fixedFieldList> ;
<fixedFieldList> ::+ <recordSectionOpt>  ';' ;
<recordSectionOpt> ::? <recordSection>;
<recordSection>	::= <IdList> ':' <type>;
<mixedFieldList> ::= <fixedFieldList> <variantFieldList> ;
<variantFieldList> ::= 'case' <selectionfieldOp> ':' <NameApl> 'of' 
			 <variantClaseList>;
<selectionfieldOp> ::? <identifier>;
<variantClaseList> ::+ <variantClase>  ';';
<variantClase>	::= <ConstantList> ':' '(' <fieldList> ')';
<fileType>	::= 'file' 'of' <type>;

<expressionList> ::+ <expression>  ',';
<expression>	::| <simpleExpression> | <relExpression>;
<simpleExpression> ::| <Term> | <signedTerm> | <addExpression>;
<term>		::| <factor> | <multExpression>;
<factor>	::| <variable> | <Astring> | <number> | <functionAppl> |
		    <bracketExpression> |  <notExpression> | <ARealNumber> | <setFactor> ;


<varList>       ::+ <variable> ';';
<variable>	::| <Identifier> | <indexedVariable>  | 
		    <componentVariable> | <referenceVariable>;
<IndexedVariable> ::= <array:variable> '[' <indices:expressionList> ']' ; 
<ComponentVariable> ::= <record:variable> '.' <identifier>;
<referencevariable> ::= <pointer:variable> '^';
<functionAppl>	::= <function:NameApl> '(' <arguments:expressionList> ')';
<bracketExpression> ::= '(' <expression> ')';
<notExpression>	::= 'not' <operand:factor>;
<setFactor>	::= '[' <setElementList> ']';
<setElementList> ::+ <setElement>  ',';
<setElement>	::| <Expression> | <RangeElement>;
<RangeElement>	::= <LowerLimit:Expression> '..' <UpperLimit:Expression>;
<MultExpression> ::= <Operand1:Term> <MultOperator> <Operand2:Factor>;
<AddExpression> ::= <Operand1:SimpleExpression> <AddOperator> <Operand2:Term>;
<RelExpression> ::= <Operand1:SimpleExpression> <RelOperator> <Operand2:Term>;
<signedTerm>	::= <sign> <Term>;
<MultOperator>	::| <TimesOp> | <DivideOp> | <DivOp> | <ModOp> | <AndOp>;	
<AddOperator>	::| <PlusOp> | <MinusOp> | <OrOp>;
<RelOperator>	::| <EqualOp> | <lessOp> | <LessOrEqualOp> | <GreaterOrEqualOp> | <GreaterOp> | <NotEqualOp> | <InOp>;
<ConstantList>	::+ <Constant>  ',';
<Sign>		::| <plusSign> | <MinusSign>;	
<Constant>	::| <NameAplication> | <ConstantNumber> | <ConstantString> | <realnumber>; 

<Identifier>    ::= <NameApl>;
<typeIdentifier> ::= <NameApl>;
<NameAplication> ::= <NameApl>;
<Label>		::= <Const>;
<Number>	::= <Const>;
<constantNumber> ::= <Const>;
<ARealNumber>   ::= <realNumber>;
<realnumber>    ::= <firstPart:const> '.' <secondPart:const>;
<AString>	::= <String>;
<constantString> ::= <String>;

<TimesOp>	::= '*';
<DivideOp>	::= '/';
<DivOp>		::= 'div';
<ModOp>		::= 'mod';
<andOp>		::= 'and';
<plusOp>	::= '+';
<minusOp>	::= '-';
<OrOp>		::= 'or';
<equalOp>	::= '=';
<LessOp>	::= '<';
<LessOrEqualOp>	::= '<=';
<greaterOrEqualOp>	::= '>=';
<greaterOp>	::= '>';
<notEqualOp>	::= '<>';
<inOp>		::= 'in';
<plusSign>	::= '+';
<minussign>	::= '-';

<NameDcl>	::= <NameDecl>;
<NameApl>	::= <NameAppl>

attribute

<NameDcl>: 2
<NameApl>: 2
