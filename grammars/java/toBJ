I just managed to convert your grammar to the format of our generator
tools just before we went to ECOOP.  It went very smoothly and we were
able to demonstrate a parser and structure editor for Java at ECOOP.

I have 2 remaining problems; but one of them looks like an error in
our LALR(1) parser generator.

Since I just managed to do it before we went to ECOOP and since I have
been on some vacation trip this week (Lars Bak and his family are
currently in DK and we have just visited them) I have not had time to
do more about the problems. Also, the is still some polishing to do
before the converted grammar is in a resonable stage. The grammar
format we use require that all productions are divided into
constructor- alternation- and list-productions. This means that we
have to introduce extra nonterminals. Currently these names are not
meaningful, since I am not always sure about the meaning of some of
the rules. I will have to consider this more carefully.

I enclose descriptions of the 2 problems we have, and the current
version of the Structured CFG. But dont use much time on it, since
it need more poslishing and checking.

---olm

1.	The first problem is that the example 
---------------------------------------------

		SortItem.java

	does NOT parse because of the expression

	algorithm = (SortAlgorithm)Class.forName(algName).newInstance();

As far as I can see, class is a reserved word. But perhaps the reserved word
is "class" and "Class" is not reserved?. 

%%%% Sort:Goal:java %%%%
/*
 * @(#)SortItem.java	1.17f 95/04/10 James Gosling
			1.18  96/4/24  Jim Hagen : use setBackground
 *
 * Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
 * without fee is hereby granted. 
 * Please refer to the file http://java.sun.com/copy_trademarks.html
 * for further important copyright and trademark information and to
 * http://java.sun.com/licensing.html for further important licensing
 * information for the Java (tm) Technology.
 * 
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
 * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
 * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
 * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
 * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
 * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
 * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  SUN
 * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
 * HIGH RISK ACTIVITIES.
 */

import java.awt.*;
import java.io.InputStream;
import java.util.Hashtable;
import java.net.*;

/**
 * A simple applet class to demonstrate a sort algorithm.
 * You can specify a sorting algorithm using the "alg"
 * attribyte. When you click on the applet, a thread is
 * forked which animates the sorting algorithm.
 *
 * @author James Gosling
 * @version 	1.17f, 10 Apr 1995
 */
public class SortItem extends java.applet.Applet implements Runnable {
    /**
     * The thread that is sorting (or null).
     */
    private Thread kicker;

    /**
     * The array that is being sorted.
     */
    int arr[];

    /**
     * The high water mark.
     */
    int h1 = -1;

    /**
     * The low water mark.
     */
    int h2 = -1;

    /**
     * The name of the algorithm.
     */
    String algName;

    /**
     * The sorting algorithm (or null).
     */
    SortAlgorithm algorithm;

    /**
     * Fill the array with random numbers from 0..n-1.
     */
    void scramble() {
	int a[] = new int[size().height / 2];
	double f = size().width / (double) a.length;
	for (int i = a.length; --i >= 0;) {
	    a[i] = (int)(i * f);
	}
	for (int i = a.length; --i >= 0;) {
	    int j = (int)(i * Math.random());
	    int t = a[i];
	    a[i] = a[j];
	    a[j] = t;
	}
	arr = a;
    }

    /**
     * Pause a while.
     * @see SortAlgorithm
     */
    void pause() {
	pause(-1, -1);
    }

    /**
     * Pause a while, and draw the high water mark.
     * @see SortAlgorithm
     */
    void pause(int H1) {
	pause(H1, -1);
    }

    /**
     * Pause a while, and draw the low&high water marks.
     * @see SortAlgorithm
     */
    void pause(int H1, int H2) {
	h1 = H1;
	h2 = H2;
	if (kicker != null) {
	    repaint();
	}
	try {Thread.sleep(20);} catch (InterruptedException e){}
    }

    /**
     * Initialize the applet.
     */
    public void init() {
	String at = getParameter("alg");
	if (at == null) {
	    at = "BubbleSort";
	}

	algName = at + "Algorithm";
	scramble();

	resize(100, 100);
    }

    /**
     * Paint the array of numbers as a list
     * of horizontal lines of varying lenghts.
     */
    public void paint(Graphics g) {
	int a[] = arr;
	int y = size().height - 1;

	/* Erase old lines */
	g.setColor(getBackground());
	for (int i = a.length; --i >= 0; y -= 2) {
	    g.drawLine(arr[i], y, size().width, y);
	}

	/* Draw new lines */
	g.setColor(Color.black);
	y = size().height - 1;
	for (int i = a.length; --i >= 0; y -= 2) {
	    g.drawLine(0, y, arr[i], y);
	}

	if (h1 >= 0) {
	    g.setColor(Color.red);
	    y = h1 * 2 + 1;
	    g.drawLine(0, y, size().width, y);
	}
	if (h2 >= 0) {
	    g.setColor(Color.blue);
	    y = h2 * 2 + 1;
	    g.drawLine(0, y, size().width, y);
	}
    }

    /**
     * Update without erasing the background.
     */
    public void update(Graphics g) {
	paint(g);
    }

    /**
     * Run the sorting algorithm. This method is
     * called by class Thread once the sorting algorithm
     * is started.
     * @see java.lang.Thread#run
     * @see SortItem#mouseUp
     */
    public void run() {
	try {
	    if (algorithm == null) {
		algorithm = (SortAlgorithm)Class.forName(algName).newInstance();
//******************************************^^^^
		algorithm.setParent(this);
	    }
	    algorithm.init();
	    algorithm.sort(arr);
	} catch(Exception e) {
	}
    }

    /**
     * Stop the applet. Kill any sorting algorithm that
     * is still sorting.
     */
    public synchronized void stop() {
	if (kicker != null) {
            try {
		kicker.stop();
            } catch (IllegalThreadStateException e) {
                /* ignore this exception */
            }
	    kicker = null;
	}
	if (algorithm != null){
            try {
		algorithm.stop();
            } catch (IllegalThreadStateException e) {
                /* ignore this exception */
            }
	}
    }


    /**
     * For a Thread to actually do the sorting. This routine makes
     * sure we do not simultaneously start several sorts if the user
     * repeatedly clicks on the sort item.  It needs to be
     * synchronoized with the stop() method because they both
     * manipulate the common kicker variable.
     */
    private synchronized void startSort() {
	if (kicker == null || !kicker.isAlive()) {
	    scramble();
	    repaint();
	    kicker = new Thread(this);
	    kicker.start();
	}
    }


    /**
     * The user clicked in the applet. Start the clock!
     */
    public boolean mouseUp(java.awt.Event evt, int x, int y) {
	startSort();
	return true;
    }
}

2.	I have an LR conflict in the converted grammar.
---------------------------------------------------------
	Since our generator tools generate BETA patterns for 
	representing the abstract syntax trees, we can not have
	the same nonterminal on the right side of more than one
	alternation rule. This is why we have to add productions
	like <ArrayAccessX>.
	Now this conflict looks like an error in our generator tool
	since -EOF- (end of file) should never appear after 
	<arrayAccessX>.

  -------------------------------------------------------------
  LALR(1) conflict of type: REDUCE/REDUCE
    first conflicting production:
      414: <arrayaccessx> ::= <arrayaccess>  .
      Lookahead set:
     -EOF- |= ^= >>>= >>= %= *= <<= -= = /* &= += 
    second conflicting production:
     282: <primarynonewarray> ::= <arrayaccess>  .
      lookahead set:
     -EOF- >= >>> : ; < <= > % ? & || != >>. ) [ * && + ] ^ , instanceof - -- == <<. . / ++ | } 
    Conflict on symbol(s)
     -EOF-
    
  -------------------------------------------------------------
  LALR(1) conflict of type: REDUCE/REDUCE
    first conflicting production:
      413: <fieldaccessx> ::= <fieldaccess>  .
      Lookahead set:
     -EOF- |= ^= >>>= >>= %= *= <<= -= = /* &= += 
    second conflicting production:
     280: <primarynonewarray> ::= <fieldaccess>  .
      lookahead set:
     -EOF- >= >>> : ; < <= > % ? & || != >>. ) [ * && + ] ^ , instanceof - -- == <<. . / ++ | } 
    Conflict on symbol(s)
     -EOF-
    

3.	Structured CFG
----------------------
(* java.y 1.89 96/07/02 *)

(*
 * LALR(1) Java Grammar
 *
 * Bill Joy, Guy Steele
 * Sun Microsystems
 * July, 1996
 *
 * This grammar is the minimum modification to the grammar in
 * the Java Language Specification book, as follows:
 *
 * 1) The single nonterminal Modifiers replaces the more specific
 *    (Class/Field/Method/Constructor)Modifiers of the book.
 *    *Modifiers are better expositionally, but can't be discriminated
 *    left-to-right.
 *
 * 2) We handle the [Opt] Symbols with lambda productions, since
 *    this read more like the original grammar, and do it the way
 *    the grammars chapter says (making lots of productions) only
 *    when we get into LALR trouble.  Lambda productions are uniformly
 *    harder, so this is safe...
 *
 * 3) Other changes to make LALR are marked DELTA below.
 *
 *)

contractioncategories 
	ClassBody
	MethodBody

--- java : aGrammar : metagrammar ---
Grammar java :

Option
  version  = 1
  comBegin = '/*'
  comEnd   = '*/'
  stringChar = '"' 
  suffix = '.java'
  EOSchar = '%'
Rule

(* 3.8 keywords 
%token	ABSTRACT		FLOAT			SHORT
%token	BOOLEAN			FOR			STATIC
%token	BREAK			GOTO			SUPER
%token	BYTE			IF			SWITCH
%token	CASE			IMPLEMENTS		SYNCHRONIZED
%token	CAST			IMPORT			THIS
%token	CATCH			INSTANCEOF		THROW
%token	CHAR			INT			THROWS
%token	CLASS			INTERFACE		TRANSIENT
%token	CONST			LONG			TRY
%token	CONTINUE		NATIVE			VOID
%token	DEFAULT			NEW			VOLATILE
%token	DO			NULL_			WHILE
%token	DOUBLE			PACKAGE
%token	ELSE			PRIVATE
%token	EXTENDS			PROTECTED
%token	FINAL			PUBLIC
%token	FINALLY			RETURN
*)

(* 3.9 identifiers 
%token	Identifier
*)

(* 3.10 literals 
%token	IntegerLiteral
%token	FloatingPointLiteral
%token	BooleanLiteral
%token	StringLiteral
%token	CharacterLiteral
*(

(* 3.12 operators 
%token	ANDAND			GTGTGTEQ		OROR
%token	ANDEQ			LTEQ			PCTEQ
%token	DIVEQ			LTLT			PLUSEQ
%token	EQEQ			LTLTEQ			PLUSPLUS
%token	GTEQ			MINUSEQ			TIMESEQ
%token	GTGT			MINUSMINUS		XOREQ
%token	GTGTEQ			NOTEQ
%token	GTGTGT			OREQ

*)

(* 2.3 *)
<Goal>::=			<CompilationUnit> ;

(* 3 *)
<Literal> ::|		<IntegerOrFloatLiteral>
	|		<BooleanLiteral>
	|		<StringOrCharLiteral>
	|		<NullLiteral>
        ;

<NullLiteral>::=		'NULL_' ;

(* 4 *)
<Type> ::|		<PrimitiveType>
	|		<ReferenceType>
        ;
<PrimitiveType> ::|		<NumericType>
	|		<BOOLEAN>
        ;
<BOOLEAN> ::= 'BOOLEAN' ;
<NumericType>::|	<IntegralType>
	|		<FloatingPointType>
        ;
<IntegralType>::|	<BYTE> | <SHORT> | <INT> | <LONG> | <CHAR> ;
<BYTE> ::=  'BYTE' ;
<SHORT>  ::= 'SHORT' ;
<INT>  ::= 'INT' ;
<LONG>  ::= 'LONG' ;
<CHAR> ::= 'CHAR' ;
<FloatingPointType> ::|	<FLOAT> | <DOUBLE>;
<FLOAT> ::= 'FLOAT' ;
<DOUBLE> ::= 'DOUBLE' ;

<ReferenceType> ::|	<ClassOrInterfaceType>
	|		<ArrayType>
        ;
<ClassOrInterfaceType> ::=	<Name> ;

<ClassType> ::=		<ClassOrInterfaceType>;

<InterfaceType>::=	<ClassOrInterfaceType>;

<ArrayType>::|		<ArrayType1> | <ArrayType2> | <ArrayType3> ;

<ArrayType1> ::= <PrimitiveType> '[' ']' ;
<ArrayType2> ::= <Name> '[' ']' ;
<ArrayType3> ::= <ArrayType> '[' ']' ;

(* 6 *)
<Name>::|		<SimpleName>
	|		<QualifiedName>
        ;
<SimpleName>::=		<Identifier> ;

<QualifiedName>::=	<Name> '.' <Identifier> ;


(* 7 *)
<CompilationUnit> ::=	<PackageDeclarationOpt> <ImportDeclarationsOpt> 
			<TypeDeclarationsOpt>
		   ;
<ImportDeclarationsOpt>::?	<ImportDeclarations> ;

<ImportDeclarations>::+	<ImportDeclaration> ;

<TypeDeclarationsOpt> ::? 	<TypeDeclarations> ;

<TypeDeclarations> ::+	<TypeDeclaration> ;

<PackageDeclarationOpt>::? <PackageDeclaration> ;

<PackageDeclaration> ::= 'PACKAGE' <Name> ';' ;

<ImportDeclaration> ::|	<TypeImportDeclaration>
		      | <TypeImportOnDemandDeclaration>
		      ;
<TypeImportDeclaration>::=	'IMPORT' <Name> ';' ;

<TypeImportOnDemandDeclaration> ::= 'IMPORT' <Name> '.' '*' ';' ;

<TypeDeclaration> ::| <ClassDeclaration>
	            | <InterfaceDeclaration>
	            | <TypeSep> 
	;
<TypeSep> ::= ';' ;

(* 8 *)

(* 8.1 *)
<ClassDeclaration>::=	<ModifiersOpt> 'CLASS' <NameDecl> <SuperOpt>
			<InterfacesOpt> <ClassBody>
		   ;
<SuperOpt> ::?	<Super> ;
<Super> ::=	'EXTENDS' <ClassType> ;
<InterfacesOpt> ::?	<Interfaces> ;
<Interfaces>::=		'IMPLEMENTS' <InterfaceTypeList> ;

<InterfaceTypeList> ::+	<InterfaceType> ',' ;

<ClassBody> ::=		'{' <ClassBodyDeclarationsOpt> '}' ;

<ClassBodyDeclarationsOpt>::?		<ClassBodyDeclarations> ;

<ClassBodyDeclarations> ::+	<ClassBodyDeclaration> ;

<ClassBodyDeclaration>::|	<ClassMemberDeclaration>
	|		<StaticInitializer>
	|		<ConstructorDeclaration>
        ;
<ClassMemberDeclaration>::|  <FieldDeclaration>
	|		<MethodDeclaration>
        ;

(* 8.3 *)
<FieldDeclaration>::=	<ModifiersOpt> <Type> <VariableDeclarators> ';' ;

<VariableDeclarators>::+	<VariableDeclarator> ',' ; 

<VariableDeclarator> ::| <VariableDeclarator1> | <VariableDeclarator2>  ;

<VariableDeclarator1> ::= <VariableDeclaratorId> ;
<VariableDeclarator2>::=  <VariableDeclaratorId> '=' <VariableInitializer> ;

<VariableDeclaratorId>::| <VariableDeclaratorId1> | <VariableDeclaratorId2> ;

<VariableDeclaratorId1> ::= <Identifier> ; 
<VariableDeclaratorId2> ::= <VariableDeclaratorId> '[' ']' ;

<VariableInitializer>::|	<Expression>
	|		<ArrayInitializer>
        ;
(* DELTA: ResultType expanded in line.
 *
 * ResultType has to be expanded in MethodDeclaration to multiple
 * method declarations, as otherwise an ambiguity is introduced
 * because of
 *    int foo;
 * versus
 *    int foo();
 * where the first parses as
 *    Type foo
 * and the second as
 *    ResultType foo
 * but we can't see far enough ahead to decide whether to reduce.
 *)

(* 8.4 *)
<MethodDeclaration>::=	<MethodHeader>  <MethodBody> ;
<MethodHeader>::| <MethodHeader1> | <MethodHeader2> ;
<MethodHeader1> ::= <ModifiersOpt> <Type> <MethodDeclarator> <ThrowsOpt> ;
<MethodHeader2>	::= <ModifiersOpt> 'VOID' <MethodDeclarator> <ThrowsOpt> ;

(* ResultType: Type | VOID *)
<MethodDeclarator> ::|	<MethodDeclarator1> | <MethodDeclarator2> ;
<MethodDeclarator1> ::= <Identifier> '(' <FormalParameterListOpt> ')' ;
<MethodDeclarator2> ::= <MethodDeclarator> '[' ']' ;

<FormalParameterListOpt> ::? <FormalParameterList> ;

<FormalParameterList> ::+ <FormalParameter> ',' ;

<FormalParameter> ::= <Type> <VariableDeclaratorId> ;
<ThrowsOpt> ::? <Throws> ;

<Throws>::= 'THROWS' <ClassTypeList> ;
<ClassTypeList>::+  <ClassType> ',' ;

<MethodBody> ::| <MethodBodySep1> | <MethodBodySep2> ;
<MethodBodySep1> ::= <Block> ;
<MethodBodySep2> ::= <MethodBodySep> ;
        
<MethodBodySep> ::= ';' ;

(* 8.5 *)
<StaticInitializer>::=	'STATIC' <Block> ;

(* 8.6 *)
<ConstructorDeclaration>::=	<ModifiersOpt> <ConstructorDeclarator> 
				<ThrowsOpt> <ConstructorBody>
			 ;
<ConstructorDeclarator>::=	<SimpleName> '(' <FormalParameterListOpt> ')'
			;
<ConstructorBody>::| <ConstructorBody1> | <ConstructorBody2> ;
<ConstructorBody1> ::= '{' <BlockStatementsOpt> '}' ;
<ConstructorBody2> ::= '{' <ExplicitConstructorInvocation> 
			<BlockStatementsOpt> '}'
		    ;	
<ExplicitConstructorInvocation> ::| <ExplicitConstructorInvocation1>
				  | <ExplicitConstructorInvocation2>
				  ;
<ExplicitConstructorInvocation1> ::= 'THIS' '(' <ArgumentListOpt> ')' ';' ;
<ExplicitConstructorInvocation2> ::= 'SUPER' '(' <ArgumentListOpt> ')' ';' ;

(* 9 *)

(* 9.1 *)
<InterfaceDeclaration>::=	<ModifiersOpt> 'INTERFACE' <Identifier> 
				<ExtendsInterfacesOpt> <InterfaceBody>
			;
<ExtendsInterfacesOpt>::? <ExtendsInterfaces> ;
<ExtendsInterfaces> ::|	<ExtendsInterfaces1> | <ExtendsInterfaces2> ;
<ExtendsInterfaces1> ::= 'EXTENDS' <InterfaceType> ;
<ExtendsInterfaces2> ::= <ExtendsInterfaces> ',' <InterfaceType> ;

<InterfaceBody>::=		'{' <InterfaceMemberDeclarationsOpt> '}' ;

<InterfaceMemberDeclarationsOpt> ::? <InterfaceMemberDeclarations> ;
<InterfaceMemberDeclarations>::+ <InterfaceMemberDeclaration> ;

<InterfaceMemberDeclaration>::| <ConstantDeclaration>
	|		<AbstractMethodDeclaration>
	;

(* 9.3 *)
<ConstantDeclaration> ::=	<FieldDeclaration> ;

(* 9.4 *)
<AbstractMethodDeclaration>::= <MethodHeader> ';' ;

(* 10 *)
<ArrayInitializer>::| <ArrayInitializer1> | <ArrayInitializer2> ;
<ArrayInitializer1> ::=	'{' <VariableInitializers> <CommaOpt> '}' ;
<ArrayInitializer2> ::= '{' <CommaOpt> '}' ;
<CommaOpt> ::?	<comma> ;
<comma> ::= ',' ;

<VariableInitializers>::+	<VariableInitializer> ',' ;

(* 13 *)
<Block> ::=			'{' <BlockStatementsOpt> '}' ;
<BlockStatementsOpt>::?		<BlockStatements> ;
<BlockStatements>::+	<BlockStatement> ;

<BlockStatement>::|		<LocalVariableDeclarationStatement>
	|		<Statement>
	;
<LocalVariableDeclarationStatement>::= <LocalVariableDeclaration> ';' ;

<LocalVariableDeclaration>::= <Type> <VariableDeclarators> ;

<Statement> ::| <StmtWithoutTrailingSubStmt>
	      | <LabeledStatement>
	      | <IfThenStatement>
	      | <IfThenElseStatement>
	      | <WhileStatement>
	      | <ForStatement>
	      ;
<StatementNoShortIf>::|	<StmtWithoutTrailingSubStmt1>
	|		<LabeledStatementNoShortIf>
	|		<IfThenElseStatementNoShortIf>
	|		<WhileStatementNoShortIf>
	|		<ForStatementNoShortIf>
	;
<StmtWithoutTrailingSubStmt1> ::= <StmtWithoutTrailingSubStmt> ;
<StmtWithoutTrailingSubStmt>::|	<Block>
	|		<EmptyStatement>
	|		<ExpressionStatement>
	|		<SwitchStatement>
	|		<DoStatement>
	|		<BreakStatement>
	|		<ContinueStatement>
	|		<ReturnStatement>
	|		<SynchronizedStatement>
	|		<ThrowStatement>
	|		<TryStatement>
	;
<EmptyStatement>::=		';' ;

<LabeledStatement>::=	<Identifier> ':' <Statement> ;

<LabeledStatementNoShortIf>::= <Identifier> ':' <StatementNoShortIf> ;
<ExpressionStatement>::=	<StatementExpression> ';' ;
<StatementExpression>::|	<AssignmentStatement>
	|		<PreIncrementExpression>
	|		<PreDecrementExpression>
	|		<PostIncrementExpression>
	|		<PostDecrementExpression>
	|		<MethodInvocation>
	|		<ClassInstanceCreationExp>
        ;
<AssignmentStatement> ::= <Assignment> ;

<IfThenStatement>::=	'IF' '(' <Expression> ')' <Statement> ;
<IfThenElseStatement> ::= 'IF' '(' <Expression> ')' <StatementNoShortIf> 
			  'ELSE' <Statement>
			;
<IfThenElseStatementNoShortIf>::= 
		'IF' '(' <Expression> ')' <StatementNoShortIf>
		'ELSE' <StatementNoShortIf>
			       ;
<SwitchStatement>::=	'SWITCH' '(' <Expression> ')' <SwitchBlock> ;
<SwitchBlock>::=		'{' <SwitchBlockStatementGroupsOpt> '}' ;
<SwitchBlockStatementGroupsOpt>::?	<SwitchBlockStatementGroups> ;
<SwitchBlockStatementGroups>::+	<SwitchBlockStatementGroup> ;

<SwitchBlockStatementGroup>::=	<SwitchLabels> <BlockStatements> ;
<SwitchLabels>::+ <SwitchLabel>; 

<SwitchLabel>::|	<SwitchLabel1> | <SwitchLabel2>;
<SwitchLabel1>	::= 'CASE' <ConstantExpression> ':' ;
<SwitchLabel2>  ::= 'DEFAULT' ':' ;

<WhileStatement>::=		'WHILE' '(' <Expression> ')' <Statement> ;
<WhileStatementNoShortIf>::= 'WHILE' '(' <Expression> ')' <StatementNoShortIf> ;

<DoStatement>::= 'DO' <Statement> 'WHILE' '(' <Expression> ')' ';' ;

<ForStatement>::=	'FOR' '(' <ForInitOpt> ';' <ExpressionOpt> ';' 
			<ForUpdateOpt> ')' <Statement> 
		;
<ForStatementNoShortIf>::= 'FOR' '(' <ForInitOpt> ';' <ExpressionOpt> ';'
			    <ForUpdateOpt> ')' <StatementNoShortIf>
			;
<ForInitOpt>::?	<ForInit> ;
<ForInit>::|		<forInit1> 
	|		<LocalVariableDeclaration>
	;
<forInit1> ::= <StatementExpressionList> ;
<ForUpdateOpt>::?	<ForUpdate>;
<ForUpdate>::=	<StatementExpressionList> ;
<StatementExpressionList> ::+ <StatementExpression> ',' ;

<BreakStatement>::=		'BREAK' <IdentifierOpt> ';' ;
<IdentifierOpt>::? <Identifier> ;

<ContinueStatement>::=	'CONTINUE' <IdentifierOpt> ';' ;
<ReturnStatement>::=	'RETURN' <ExpressionOpt> ';' ;
<ThrowStatement>::=	'THROW' <Expression> ';' ;
<SynchronizedStatement>::=	'SYNCHRONIZED' '(' <Expression> ')' <Block> ;
<TryStatement>::| <TryStatement1> |  <TryStatement2> | <TryStatement3> ;
<TryStatement1>	::=	'TRY' <Block> <Finally> ;
<TryStatement2> ::=	'TRY' <Block> <Catches> ;
<TryStatement3>	::=	'TRY' <Block> <Catches> <Finally> ;
<Catches>::+		<CatchClause> ;

<CatchClause>::=	'CATCH' '(' <FormalParameter> ')' <Block> ;
<Finally>::=		'FINALLY' <Block> ;

<Primary>::|		<PrimaryNoNewArray>
	|		<ArrayCreationExpression>
	;
<PrimaryNoNewArray>::|	<Literal>
	|		<THIS>
	|		<BracketedExp>
	|		<ClassInstanceCreationExpX>
	|		<FieldAccess>
	|		<MethodInvocationX>
	|		<ArrayAccess>
	;
<ClassInstanceCreationExpX> ::= <ClassInstanceCreationExp> ;
<MethodInvocationX> ::= <MethodInvocation> ;
<THIS> ::= 'THIS'; 
<BracketedExp> ::= '(' <Expression> ')' ;

<ClassInstanceCreationExp>::= 'NEW' <ClassType> '(' <ArgumentListOpt> ')' ;
<ArgumentListOpt>::?	<ArgumentList> ;
<ArgumentList>::+	<Expression> ',' ;

<ArrayCreationExpression>::| <ArrayCreationExpression1> 
			   | <ArrayCreationExpression2>
			   ;
<ArrayCreationExpression1>::= 'NEW' <ClassOrInterfaceType> <DimExprs> <DimsOpt> ;
<ArrayCreationExpression2>::= 'NEW' <PrimitiveType> <DimExprs> <DimsOpt> ;

<DimExprs>::+		<DimExpr> ;

<DimExpr>::=		'[' <Expression> ']' ;
<DimsOpt>::?	<Dims> ;
<Dims>::|	<Dims1> | <Dims2> ;		
<Dims1> ::= '[' ']' ;
<Dims2> ::= <Dims> '[' ']' ;

<FieldAccess>::| <FieldAccess1> | <FieldAccess2> ;
<FieldAccess1>	::= <Primary> '.' <Identifier> ;
<FieldAccess2>	::= 'SUPER' '.' <Identifier> ;
<MethodInvocation>::| <MethodInvocation1> | <MethodInvocation2> 
		    | <MethodInvocation3>;
<MethodInvocation1> ::= <Name> '(' <ArgumentListOpt> ')' ;
<MethodInvocation2> ::= <Primary> '.' <Identifier> '(' <ArgumentListOpt>  ')' ;
<MethodInvocation3> ::= 'SUPER' '.' <Identifier> '(' <ArgumentListOpt> ')' ;
<ArrayAccess>::| <ArrayAccess1> | <ArrayAccess2> ;
<ArrayAccess1> ::=	<Name> '[' <Expression> ']' ;
<ArrayAccess2> ::= <PrimaryNoNewArray> '[' <Expression> ']' ;
<PostfixExpression>::|	<Primary>
	|		<Name>
	|		<PostIncrementExpressionX>
	|		<PostDecrementExpressionX>
	;
<PostDecrementExpressionX> ::= <PostDecrementExpression> ;
<PostIncrementExpressionX> ::= <PostIncrementExpression>;
<PostIncrementExpression> ::= <PostfixExpression>  '++' ;
<PostDecrementExpression> ::= <PostfixExpression> '--' ;
<UnaryExpression> ::| <PreIncrementExpression1>
		    | <PreDecrementExpression2>
		    | <unaryPlus> 
		    | <unaryMinus> 
		    | <UnaryExpressionNotPlusMinus>
		    ;
<PreIncrementExpression1> ::= <PreIncrementExpression> ;
<PreDecrementExpression2> ::= <PreDecrementExpression> ;
<UnaryPlus> ::= '+' <UnaryExpression> ;
<unaryMinus> ::= '-' <UnaryExpression> ;

<PreIncrementExpression> ::= '++' <UnaryExpression> ;
<PreDecrementExpression> ::= '--' <UnaryExpression> ;
<UnaryExpressionNotPlusMinus>::| <PostfixExpression>
	|		<unaryNegation> 
	|		<unaryExcl> 
	|		<CastExpression>
	;
<unaryNegation> ::= '~' <UnaryExpression> ;
<unaryExcl> ::= '!' <UnaryExpression> ;

(* DELTA: The form of the cast expression is changed
 *
 * ...to prevent an ambiguity with parenthesized expressions.
 * When we see
 *	(a.b)...
 * and have (Name with an incoming ) we don't know
 * whether to leave the symbol as a name or reduce to (Expression).
 *
 * We will have to constrain the (Expression) form
 * below when this production reduces.
 * For example:
 *	((T)[])null
 * should be an error, but this grammar doesn't handle
 * this syntactically.
 *)
<CastExpression>::| <CastExpression1> | <CastExpression2> 
		  | <CastExpression3> | <CastExpression4>
		  ;
<CastExpression1>::=	'(' <PrimitiveType> ')' <UnaryExpression> ;
<CastExpression2>::=	'(' <PrimitiveType> <Dims> ')' <UnaryExpression> ;
<CastExpression3>::=	'(' <Expression> ')' <UnaryExpressionNotPlusMinus> ;
<CastExpression4>::=	'(' <Name> <Dims> ')' <UnaryExpressionNotPlusMinus> ;

<MultiplicativeExpression>::| <UnaryExpression> 
			    | <MultOpExpression>
		            | <DivOpExpression>
		            | <ModOpExpression>
		            ;
<MultOpExpression> ::= <MultiplicativeExpression> '*' <UnaryExpression>;
<DivOpExpression> ::= <MultiplicativeExpression> '/' <UnaryExpression> ;
<ModOpExpression> ::= <MultiplicativeExpression> '%' <UnaryExpression> ;

<AdditiveExpression> ::| <MultiplicativeExpression>
		       | <AddOpExpression>
		       | <MinusOpExpression>
		       ; 
<AddOpExpression> ::= <AdditiveExpression> '+' <MultiplicativeExpression> ;
<MinusOpExpression> ::= <AdditiveExpression> '-' <MultiplicativeExpression> ;

<ShiftExpression>::| <AdditiveExpression> 
 		   | <ShiftLeftExpression>
		   | <ShiftRightExpression>
		   | <ShiftExpression4>
	    	   ;

(* OBS! The Mjolner Structured BNF has a lexical problem with 
 * '<<' and '>>' which are  used for enclosing nonterminals. 
 * This should be fixed!
 *)
<ShiftLeftExpression>  ::= <ShiftExpression> '<<.' <AdditiveExpression> ;
<ShiftRightExpression> ::= <ShiftExpression> '>>.' <AdditiveExpression> ;
<ShiftExpression4> ::=	<ShiftExpression> '>>>' <AdditiveExpression> ;

<RelationalExpression>::| <ShiftExpression> 
			| <LessThanExpression>
			| <GreaterThanExpression>
			| <LessEqualExpression>
			| <GreaterEqualExpression>
			| <InstanceOfExpression>
			;
<LessThanExpression> 	 ::= <RelationalExpression> '<' <ShiftExpression> ;
<GreaterThanExpression>  ::= <RelationalExpression> '>' <ShiftExpression> ;
<LessEqualExpression>	 ::= <RelationalExpression> '<=' <ShiftExpression> ;
<GreaterEqualExpression> ::= <RelationalExpression> '>=' <ShiftExpression> ;
<InstanceOfExpression>   ::= <RelationalExpression> 'INSTANCEOF' <ReferenceType> ;

<EqualityExpression>::|	<RelationalExpression> 
		      |	<isEqualExpression>
		      |	<isNotEqualExpression> 
		      ;
<isEqualExpression> ::= <EqualityExpression> '==' <RelationalExpression> ;
<isNotEqualExpression> ::= <EqualityExpression> '!=' <RelationalExpression> ;

<AndExpression>::| <EqualityExpression> 
		 | <AndOpExpression>
		 ;
<AndOpExpression> ::= <AndExpression> '&' <EqualityExpression> ;

<ExclusiveOrExpression>::| <AndExpression>
			 | <ExclusiveOrOpExpression> 
			 ;
<ExclusiveOrOpExpression> ::= <ExclusiveOrExpression> '^' <AndExpression> ;

<InclusiveOrExpression>::| <ExclusiveOrExpression> 
			 | <InclusiveOrOpExpression>
			 ;
<InclusiveOrOpExpression> ::=
			<InclusiveOrExpression> '|' <ExclusiveOrExpression> ;
<ConditionalAndExpression> ::| <InclusiveOrExpression>
			     | <ConditionalAndOpExpression> 
			     ;
<ConditionalAndOpExpression> ::=
		<ConditionalAndExpression> '&&' <InclusiveOrExpression> ;
<ConditionalOrExpression> ::| <ConditionalAndExpression> 
			    | <ConditionalOrExpression2> 
			    ;
<ConditionalOrExpression2> ::=	
		<ConditionalOrExpression> '||' <ConditionalAndExpression> ;

<ConditionalExpression> ::| <ConditionalOrExpression>
			  | <ConditionalExpression2> 
			  ;
<ConditionalExpression2> ::=
	<ConditionalOrExpression> '?' <Expression> ':' <ConditionalExpression>;
<AssignmentExpression>::| <ConditionalExpression>
			| <Assignment>
			;
<Assignment> ::= <LeftHandSide> <AssignmentOperator> <AssignmentExpression> ;
<LeftHandSide>::| <LeftName>
		| <FieldAccessX>
		| <ArrayAccessX>
		;
<LeftName> ::= <Name> ;
<FieldAccessX> ::= <FieldAccess> ;
<ArrayAccessX> ::= <ArrayAccess> ;
<AssignmentOperator> ::| <EqAsg>
		| <TIMESEQ>
		| <DIVEQ>
		| <PCTEQ>
		| <PLUSEQ>
		| <MINUSEQ>
		| <LTLTEQ>
		| <GTGTEQ>
		| <GTGTGTEQ>
		| <ANDEQ>
		| <XOREQ>
		| <OREQ>
		;
<eqAsg> ::=  '=' ;
<TIMESEQ>	::= '*=' ;
<DIVEQ>		::= '/*' ;
<PCTEQ>		::= '%=' ;
<PLUSEQ>	::= '+=' ;
<MINUSEQ>	::= '-=' ;
<LTLTEQ>	::= '<<=' ;
<GTGTEQ>	::= '>>=' ;
<GTGTGTEQ>	::= '>>>=' ;
<ANDEQ>		::= '&=' ;
<XOREQ>		::= '^=' ;
<OREQ>		::= '|=' ;

<ExpressionOpt>::? <Expression>;
<Expression>::=		<AssignmentExpression> ;
<ConstantExpression>::=	<Expression> ;

(* *.* *)
<ModifiersOpt>::?	<Modifiers> ;
<Modifiers>::+		<Modifier> ;

<Modifier>::|		<PUBLIC>
	|		<PRIVATE>
	|		<PROTECTED>
	|		<STATIC>
	|		<ABSTRACT>
	|		<FINAL>
	|		<NATIVE> 
	|		<SYNCHRONIZED>
	|		<TRANSIENT>
	|		<VOLATILE>
	;
<PUBLIC> ::= 'PUBLIC' ;
<PRIVATE>	::= 'PRIVATE' ;
<PROTECTED>	::= 'PROTECTED' ;
<STATIC>	::= 'STATIC' ;
<ABSTRACT>	::= 'ABSTRACT' ;
<FINAL>	::= 'FINAL' ;
<NATIVE> 	::= 'NATIVE' ;
<SYNCHRONIZED>	::= 'SYNCHRONIZED' ;
<TRANSIENT>	::= 'TRANSIENT' ;
<VOLATILE>	::= 'VOLATILE' ;

<BooleanLiteral> ::| <TRUE> | <FALSE> ;
<TRUE> ::= 'TRUE' ;
<FALSE> ::= 'FALSE' ;
<StringOrCharLiteral> ::= <STRING> ;
<IntegerOrFloatLiteral> ::= <CONST> ;
<Identifier> ::= <nameAppl> 
