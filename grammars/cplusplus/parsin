  
    (*                         *)
    (*  B O B S - SYSTEM       *)
    (*                         *)
    (*  SKELETON COMPILER      *)
    (*                         *)
    (*  VERSION JANUARY 1985   *)
    (*                         *)
    (* This version corresponds to the modified parser generator *)
    (* of January 1985. This version has been heavily modified.*)
    (* The January 85 version is incompatible with all previous*)
    (* versions.     *)
 
  
    (*                          *)
    (* The constants minCh      *)
    (* and maxCh and the types  *)
    (* ascii and                *)
    (* LDBset arenimplementation*)
    (* dependent                *)
  
program exPars(input,output,TABLES);
  
label 10; (*EXIT label*)
const
    stackMax=100; (*SIZE of ATTSTACK and PARSESTACK *)
    stringMax=100; (* SIZE of ATTRIBUTE bSTRING *)
    chBufMax=200; (* SIZE of array CHBUF *)
    minCh=' '; maxCh='~'; (*FIRST/LAST charACTER in type char*)
    TEST=false; (* if TRUE then SNAPSHOTS ARE GENERATED*)
 type
    ascii=char;       (* necessary if not DEC10/aarhus pascal *)
    LDBset=set of ' '..'9'; (*MUST CONTAIN THE charS '0'..'9' and ' '*)
    chBufInx=0..chBufMax;
    stackInx=0..stackMax;
    ATTRIBUTES=record
                  chBufP:  chBufInx;
               end;
    bSTRING=packed array[1..stringMax] of ascii;
 var
    attStack: array[stackInx] of ATTRIBUTES;
  
    chBuf: array[chBufInx] of ascii;
    chBufI: chBufInx;
  
    OK: boolean;
  
    TABLES: text;
    SNAPSHOTS: text;
  
    (*chBuf, chBufI, FIELD chBufP of ATTRIBUTES, TABLES and OK *)
    (*SHOULD not BE CHANGED BY THE USER *)
  
 function clock:integer; begin clock:=0 end;
  
 procedure STOP(N: integer); forward;
 (*   *)
 procedure CODE(OLDTOP,NEWTOP: stackInx; PROD: integer);
  
  
   procedure getString(SY: integer; var STR:bSTRING; var LENGTH: integer);
   var I,J,T:integer;
   begin
      if SY>=0 then T:=NEWTOP+(SY-1)
               else T:=OLDTOP+(SY+1);
      LENGTH:=attStack[T].chBufP-attStack[T-1].chBufP;
      if LENGTH>stringMax then  STOP(5);
      J:=1;
      for I:=attStack[T-1].chBufP to attStack[T].chBufP-1 do
       begin
          STR[J]:=chBuf[I]; J:=J+1;
       end;
   end; (*getString*)
  
  
   procedure OUTTEST;
   (*OUTTEST PRODUCES A SEQUENCE of SNAPHOTS of THE PARSE *)
   (*OUTTEST MAY BE REMOVED BY THE USER *)
   (*DURING THE PARSE, SNAPSHOTS ARE WRITTEN ON FILE SNAPSHOTS *)
   (*WHEN CODE(0) IS CALLED, THESE SNAPSHOTS ARE COPIED to FILE output.*)
   (*PROGRAM LINES WHICH writeS SNAPSHOTS CONTAINS THE COMMENT:*)
   (***SNAPSHOT***)
   (*SNAPSHOTS ARE ONLY GENERATED if const TEST IS TRUE*)
   var S: bSTRING;
      I,J,L:integer; CH:ascii;
   begin
      if PROD <> 0 then
       begin (* CODE(0) IS CALLED in MAIN *)
          writeln(SNAPSHOTS);
          write(SNAPSHOTS,' PRODUCTION:',PROD:3);
          for I:=1 to OLDTOP-NEWTOP+1 do
            begin getString(I,S,L);
               if L>0 then
                begin writeln(SNAPSHOTS);
                   write(SNAPSHOTS,'   SYMB',I:1,' ');
                   for J:=1 to L do write(SNAPSHOTS,S[J]);
                end;
            end;
       end
      else
       begin writeln(SNAPSHOTS); reset(SNAPSHOTS,'snap'); 
	  writeln(output,' SNAPSHOT:');
          while not eof(SNAPSHOTS) do
           begin read(SNAPSHOTS,CH); write(output,CH);
              if eoln(SNAPSHOTS) then writeln(output,' ')
           end;
       end;
   end; (*OUTTEST*)
 begin (*CODE*)
    if TEST then OUTTEST;
 end; (*CODE*)
  
 (*  *)
 procedure STOP;
 begin
    writeln(output);writeln(output);
    case N of
     1: writeln(output,' *** PARSE STACK OVERFLOW. const ''stackMax'' TOO SMALL')
 ;
     2: writeln(output,' *** end of FILE ENCOUNTERED(input) ');
     3: writeln(output,' *** RECOVERY ABANdoNED ');
     4: writeln(output,' *** REDUCTION BUFFER OVERFLOW. const ''REDUMAX'' TOO SMALL');
     5: writeln(output,' *** const ''stringMax'' TOO SMALL ');
     6: writeln(output,' *** const ''chBufMax'' to SMALL ');
     7: writeln(output,' *** FILE input IS EMPTY ');
     8: writeln(output,' *** FILE TABLES IS EMPTY ');
    end;
    goto 10; (*EXIT*);
 end;(*STOP*)
 (*     *)
 procedure PARSER;
  
 const
    (*BOBS, constANTS GENERATED BY THE GENERATOR *)
 goalSymbol=10;
 nontStart=9;
 SYMBMAX=12;
 PRODMAX=13;
 prodFMax=14; (* max of prodmax and errnoMax *)
 LRMAX=41;
 LXMAX=12;
 ERRORVAL=-1;
 NAMEVAL=2;
 CONSTVAL=3;
 STRINGVAL=4;
 STRINGCH=' ';
 COMBEGIN=0;
 COMLENGTH=1;
 nontL=-1;
 nontR=-1;
 (*BOBS*) 
    (*-end-OF-GENERATED-constANTS-*)
    LINEMAX=120; (*MAX. LENGTH of LINES*)
  
    (*-end-OF-PARSER-constANTS-*)
  
 type
    symbol=0..SYMBMAX;
    ERRNO=0..prodFMax;
    PRODNO=0..prodFMax;
    RSLENGTH=-1..SYMBMAX;
    MODE=0..6;
    LRINX=0..LRMAX;
    LRELM=packed record
             CHAIN: LRINX; (*NEXT ITEM IN THIS STATE*)
             NEXT: LRINX; (*NEXT STATE*)
             case KIND: MODE of
              1,2,4,6: (SYMB: symbol; ERR: ERRNO);
              0,3    : (RS: RSLENGTH; PROD: PRODNO);
              5:     (LB: LRINX)
          end;
  
    LXINX=0..LXMAX;
    LXELM=packed record
             NP,HP: LXINX;
             TV: symbol; CH:ascii
          end;
  
    STACKELM=packed record
                LINK: stackInx;
                TABLE: LRINX
             end;
  
    (*-end-OF-PARSER-typeS-*)
  
 var
    LR: array[LRINX] of LRELM; (* LR-PARSE TABLES *)
  
    PARSESTACK: array[stackInx] of STACKELM; (*PARSE STACK*)
  
    ENTRY: array[ascii] of LXELM;
    LX: array[LXINX] of LXELM; (*LEXICAL TABLES*)
    NAMECH: array[ascii] of boolean;   (* characters used in NAME*)
    DIGITCH,                           (* characters used in KONST*)
    SKIPCH: LDBset;   (*charS BEING SKIPPED*)
    newSymb: symbol;           (*CURRENT TERMINAL symbol*)
    CH: ascii;                  (*CURRENT char*)
    STRINGESCAPE: integer;     (*INTERNAL VALUE of THE STRINGESCAPE TERMINAL*)
    OLDBUFI: chBufInx;         (*FIRST char in chBuf of CURRENT LEXICAL TOKEN *)
    MOREinput,                 (*BECOMES FALSE WHEN input IS EXHAUSTED*)
    ERROR: boolean;            (*BECOMES TRUE WHEN SYNTAX ERRORS in input*)
    LINE: array[1..LINEMAX] of ascii; (*CONTAINS CURRENT LINE*)
    LINELENGTH,                      (*LENGTH of CURRENT LINE*)
    ERRORINX,                        (*POSITION in LINE of LAST ERROR MARK*)
    LINEINX: integer;                (*POSITION in LINE of CURRENT CH*)
    PRINTED: boolean;                (*TRUE if CURRENT LINE HAS BEEN PRINTED*)
    CL: integer;               (*VALUE of STANDARD function clock AT START*)
    COMend:  packed array[1..COMLENGTH] of ascii ; (*bSTRING WHICH endS A COMMENT*)
    lowercase: array [ascii] of ascii;
     (* note: the handling of upper/lower case asumes that all terminal symbols
        are in lowercase*)
    goal: integer;
   (*-end-OF-PARSER-varIABLES-*)
  
  
 procedure DUMPLR;
 var I:integer;
 begin writeln('  I ',' CHAIN NEXT KIND SYMB PROD');
    for I:=1 to LRMAX do
    with LR[I] do
    begin write(' ',I:3,CHAIN:6,NEXT:5,KIND:5);
       case KIND of
        1,2,4,6: writeln(SYMB:5,ERR:5);
        0,3    : writeln(RS:5,PROD:5);
        5:     writeln(LB:5)
       end;
    end;
 end;
  
 (* procedureS for input/output of charACTERS*)
 procedure readLINE;
 begin   LINEINX:=1; LINELENGTH:=1; PRINTED:=FALSE; ERRORINX:=0;
    if eof(input) then MOREinput:=FALSE
    else
     begin (*  if eoln(input) then readln; *)
       while not eoln(input) and (LINELENGTH<LINEMAX) do
        begin
          read(LINE[LINELENGTH]); LINELENGTH:=LINELENGTH+1;
        end;
       if eoln(input) then
       begin get(input); LINE[LINELENGTH]:=' ' end
       else read(LINE[LINELENGTH]);
     end;
 end; (*readLINE*)
  
 procedure PRINTLINE;
 var I :integer;
 begin write(' ');
    for I:=1 to LINELENGTH do write(LINE[I]);
    writeln; PRINTED:=TRUE;
 end; (*PRINTLINE*)
  
 procedure INchar;
 begin
    if LINEINX=LINELENGTH then
     begin
        if not PRINTED then PRINTLINE;
        if ERRORINX>0 then writeln;
        readLINE;
        if MOREinput then CH:=LINE[1]
        else SKIPCH:=[];
     end
    else
     begin LINEINX:=LINEINX+1;
        CH:=LINE[LINEINX];
     end;
 end; (*INchar*)
  
 procedure MARKERROR(C: ascii; N: integer);
 var I : integer;
 begin  ERROR:=TRUE;
    if not PRINTED then PRINTLINE;
    for I:=ERRORINX to LINEINX-2 do write(' ');
    if LINEINX=1 then write(' ');
    write(C,N:(N div 100 +2)); (*N <=999 *)
    ERRORINX:=LINEINX+ (N div 100 +2);
 end; (*MARKERROR*)
  
 (*end of input/output procedures*)
  
 procedure INITIALIZE;
 var ch1:ascii;
    A,B,C,D,E,I:integer;
 begin OK:=TRUE; ERROR:=FALSE;
    MOREinput:=TRUE; LINEINX:=1; chBufI:=0;
    LINELENGTH:=1; PRINTED:=TRUE; ERRORINX:=0;
    PARSESTACK[0].TABLE:=0; attStack[0].chBufP:=chBufI;
    PARSESTACK[0].LINK:=0; CH:=' ';
    DIGITCH:=['0'..'9']; SKIPCH:=[' '];
    for ch1:=chr(1) to maxCh do 
       begin NAMECH[ch1]:= false; lowercase[ch1]:=ch1; end;
    for ch1:='A' to 'Z' do
       begin NAMECH[ch1]:=true;
          lowercase[ch1]:=chr(ord(ch1)+32); (* assume ASCII *)
          NAMECH[lowercase[ch1]]:=true;
       end;
    for ch1:=chr(1) to ' ' do lowercase[ch1]:=' ';
    for ch1:='0' to '9' do NAMECH[ch1]:=true;
    reset(TABLES,'tables');
    if eof(TABLES) then STOP(8);
    if eof(input) then STOP(7);
  
    if TEST then rewrite(SNAPSHOTS,'snap'); (***SNAPSHOT***)
  
    for I:=1 to 16 do readln(TABLES);
      (*THE VALUES of THE constANTS GENERATED BY THE GENERATOR *)
      (*ARE ALSO WRITTEN ON FILE TABLES. THEY ARE WRITTEN in THE *)
      (*SAME ORDER AS THEY APPEAR in THE const PART of procedure *)
      (*PARSER. A VALIDITY CHECK BETWEEN FILE TABLES and THIS *)
      (*const PART COULD BE doNE, in ORDER to ASSURE THAT THE VALUES *)
      (*ARE in FACT IDENTICAL. *)
  
    for I:=1 to COMLENGTH do begin read(TABLES,A); COMend[I]:=chr(A) end ;
    readln(TABLES) ;
  
    for ch1:=minCh to maxCh do
    begin readln(TABLES,A,B,C,D);
       with ENTRY[chr(A)] do
        begin
           CH:=chr(A); NP:=B; HP:=C; TV:=D;
        end;
     end;
    for I:=0 to LXMAX do
    with LX[I] do
    begin readln(TABLES,A,B,C,D);
       CH:=chr(A); NP:=B; HP:=C; TV:=D;
    end;
    if STRINGCH=' ' then (*bSTRING FACILITY IS not USED *) STRINGESCAPE:=-2
    else STRINGESCAPE:= ENTRY[STRINGCH].TV;
  
    for I:=0 to LRMAX do
    with LR[I] do
    begin read(TABLES,A,B,C,D);
       if C <> 5 then readln(TABLES,E) else readln(TABLES) ;
       CHAIN:=A; NEXT:=B; KIND:=C;
       case C of
        1,2,4,6: begin SYMB:=D; ERR:=E end;
        0,3    : begin RS:=D; PROD:=E  end;
        5      : LB:=D
       end;
    end;
 end;(*INITIALIZE*)
  
 procedure lexical;
 (* RETURNS NEXT TERMINAL in newSymb*)
 var
    NEWI,N: integer;
    OLDCH: ascii;
    LXNODE: LXELM;
  
 procedure SKIPCOMMENT;
   (* read NEXT char  ON input until COMend IS RECOGNIZED *)
 var
   I,L : integer ; equal: boolean;
   B : packed array[1..COMLENGTH] of ascii ;
  
 procedure NEXTCH ;
 begin
   if (L > COMLENGTH) then INchar
   else
   begin
     CH:=B[L] ;
     L:=L+1 ;
   end ;
 end ;
  
 begin
   L:=COMLENGTH+1 ;
   repeat
     while CH<>COMend[1] do NEXTCH ;
     B[1]:=CH ;
     for I:=2 to COMLENGTH do
     begin
       NEXTCH ;
       B[I]:=CH ;
     end ;
     L:=2 ; CH:=' ';
     equal:=true;
     for I:=1 to COMLENGTH do
	equal:=equal and (B[I]=COMend[I]);
   until equal;
   INchar ;
 end (* SKIPCOMMENT *) ;
  
  
  
 procedure PUSHCH;
 begin
    chBuf[chBufI]:=CH;
    if chBufI<chBufMax then chBufI:=chBufI+1
                       else STOP(6);
    if TEST then write(SNAPSHOTS,CH); (***SNAPSHOT***)
 end; (*PUSHCH*)
  
 procedure readbSTRING;
 label 10;
 begin
    goto 10; (*IN case of THE EMPTY bSTRING*)
    repeat
       repeat
           PUSHCH; INchar;
   10: until CH=STRINGCH;
       INchar;
    until CH<>STRINGCH;
    newSymb:=STRINGVAL;
 end; (*readbSTRING*)
  
 begin (*lexical*)
  
    if TEST then writeln(SNAPSHOTS); (***SNAPSHOT***)
    if TEST then write(SNAPSHOTS,' lexical: '); (***SNAPSHOT***)
  
    while lowercase[CH] in SKIPCH do INchar;
    OLDBUFI:=chBufI;
  
   if not MOREinput then
     begin
        if newSymb=0 then (*THIRD*) STOP(2)
        else
         if newSymb=1 then (*SECOND*) newSymb:=0
         else (*FIRST*) newSymb:=1;
     end
   else
   if CH in DIGITCH then
    begin (*KONST*)
       repeat
          PUSHCH; INchar;
       until not NAMECH[CH];
       newSymb:=CONSTVAL;
    end
   else (* not KONST *)
    begin (* SEARCH in TERMTREE *)
       PUSHCH;
       LXNODE:=ENTRY[lowercase[CH]]; NEWI:=LXNODE.HP;
       INchar;
       if NEWI <> 0 then
        repeat
           if lowercase[LX[NEWI].CH]=lowercase[CH] then
            begin PUSHCH;
               LXNODE:=LX[NEWI];
               NEWI:=LXNODE.HP;
               INchar;
            end
           else NEWI:=LX[NEWI].NP;
        until NEWI=0;
  
       OLDCH:=chBuf[chBufI-1];
  
       if NAMECH[OLDCH] and NAMECH[CH] then
        begin
           repeat PUSHCH;
              INchar;
           until not NAMECH[CH];
           newSymb:=NAMEVAL;
        end
       else
        if LXNODE.TV > 0 then (*VALID TERMINAL*)
         begin newSymb:=LXNODE.TV;
           chBufI:=OLDBUFI;
           if newSymb=STRINGESCAPE then readbSTRING
           else
            if newSymb=COMBEGIN then begin SKIPCOMMENT ;  lexical ; end
            else if newSymb=nontL then
            begin lexical; N:=12; (* NB is only temporary *)
                lexical; newSymb:=N
            end;
         end
        else
         if  NAMECH[OLDCH] then newSymb:=NAMEVAL
         else begin MARKERROR('^',0); newSymb:=0 end;
     end;
  
 end; (*lexical*)
  
 procedure PARSE(goal:symbol);
  
 const
    REDUMAX= 100; (* REDUCTION BUFFER SIZE *)
  
 type
    REDUINX= 0..REDUMAX;
    REDUELEM= packed record
                  OLDTOP,NEWTOP: stackInx;
                  PROD: PRODNO
               end;
  
 var
    REDUBUF: array[REDUINX] of REDUELEM; (* REDUCTION BUFFER *)
    REDUTOP: REDUINX;
    STACKTOP,PSEUdoTOP,VALIDTOP,TOP : stackInx;
    STARTINX,LRI,START: LRINX;
  
 procedure ADVANCE;
 var I: integer;
 begin
    (*PERforM REDUCTIONS*)
    for I:=1 to REDUTOP do
     with REDUBUF[I] do
      begin CODE(OLDTOP,NEWTOP,PROD);
         attStack[NEWTOP].chBufP:=attStack[NEWTOP-1].chBufP;
      end;
  
    (*UPDATE STACK*)
    for I:=1 to STACKTOP-VALIDTOP do
       PARSESTACK[VALIDTOP+I]:=PARSESTACK[TOP+I];
  
    if REDUTOP>0 then (* POSSIBLE POP of chBuf *)
       if OLDBUFI=chBufI then (* newSymb notIN [NAME,KONST,bSTRING]*)
          chBufI:=attStack[STACKTOP-1].chBufP
       else (*newSymb in [NAME,KONST,bSTRING]*)
          attStack[STACKTOP].chBufP:=OLDBUFI;
  
    (*SHifT*)
    if STACKTOP=stackMax then STOP(1);
    STACKTOP:=STACKTOP+1;
    PARSESTACK[STACKTOP].TABLE:=STARTINX;
    attStack[STACKTOP].chBufP:=chBufI;
  
    (* FREEZE NEW STACK SITUATION, readY for NEW LOOKAHEAD *)
    TOP:=STACKTOP; PSEUdoTOP:=STACKTOP; VALIDTOP:=STACKTOP;
    START:=LRI; REDUTOP:=0;
 end; (*ADVANCE*)
  
    procedure BACKTRACK( BTOP: stackInx; BSTART: LRINX);
    begin
       STACKTOP:= BTOP; VALIDTOP:= BTOP; PSEUdoTOP:= BTOP;
       STARTINX:= BSTART; LRI:= BSTART;
       REDUTOP:= 0;
    end; (* BACKTRACK *)
  
    procedure PSEUdoSHifT;
    begin
       if PSEUdoTOP=stackMax then STOP(1);
       STACKTOP:= STACKTOP+1;
       PSEUdoTOP:= TOP+(STACKTOP-VALIDTOP);
       PARSESTACK[PSEUdoTOP].TABLE:= STARTINX;
       attStack[PSEUdoTOP].chBufP:=chBufI;
    end; (* PSEUdoSHifT *)
  
    function LOOKAHEAD( LSYMBOL: symbol): boolean;
    label 11,12,15;
    var DECIDED: boolean;
       LI,SI: LRINX;
    procedure QUEUE( RS: RSLENGTH; P: PRODNO);
    begin
       if REDUTOP=REDUMAX then STOP(4);
       REDUTOP:= REDUTOP+1;
       with REDUBUF[REDUTOP] do
       begin
          OLDTOP:= STACKTOP; STACKTOP:= STACKTOP-RS; NEWTOP:= STACKTOP;
          if STACKTOP <= VALIDTOP then
          begin
             PSEUdoTOP:= STACKTOP; VALIDTOP:= STACKTOP;
          end else PSEUdoTOP:= PSEUdoTOP-RS;
          PROD:=P;
       end;
    end; (* QUEUE *)
  
    begin
       DECIDED:= FALSE;
       repeat
          STARTINX:= LRI;
          case LR[LRI].KIND of
          0: begin
                DECIDED:= TRUE; LOOKAHEAD:= TRUE; OK:= FALSE;
             end;
          1: begin
                while LR[LRI].SYMB<>LSYMBOL do
                begin LI:= LR[LRI].CHAIN;
                   if LI=0 then goto 11; (* EXIT LOOP *)
                   LRI:= LI;
                end;
                11: DECIDED:= TRUE; LOOKAHEAD:= LR[LRI].SYMB=LSYMBOL;
             end;
          2,4,6:
             begin
                while LR[LRI].SYMB<>LSYMBOL do
                begin LI:= LR[LRI].CHAIN;
                   if LI=0 then goto 12; (* EXIT LOOP *)
                   LRI:= LI;
                end;
                12: if LR[LRI].KIND= 2 then
                begin
                   DECIDED:= TRUE; LOOKAHEAD:= TRUE;
                end
                else if LR[LRI].KIND= 6 then
                begin
                   PSEUdoSHifT;
                   STACKTOP:=STACKTOP-1; PSEUdoTOP:=PSEUdoTOP-1;
                   QUEUE(-1,LR[LRI].ERR);
                end;
             end;
          3: begin
                QUEUE(LR[LRI].RS,LR[LRI].PROD);
             end;
          5: begin
                SI:= PARSESTACK[PSEUdoTOP].TABLE;
                while LR[LRI].LB<> SI do
                begin LI:= LR[LRI].CHAIN;
                   if LI=0 then goto 15; (* EXIT LOOP *)
                   LRI:= LI;
                end;
                15:
             end;
          end; (* case *)
          LRI:= LR[LRI].NEXT;
       until DECIDED;
    end; (* LOOKAHEAD *)
  
    procedure syntaxError;
    var SUCCESS: boolean;
       S,S1: stackInx;
  
    begin
       if TEST then write(SNAPSHOTS,' <---syntaxError'); (***SNAPSHOT***)
       MARKERROR('^',LR[STARTINX].ERR);
       BACKTRACK(TOP,START);
       PSEUdoSHifT;
       S:= 0;
       for S1:= 0 to TOP do
       begin
          BACKTRACK(S1,PARSESTACK[S1+1].TABLE);
          if LOOKAHEAD(ERRORVAL) then
          begin
             PARSESTACK[S1].LINK:= S; S:= S1;
          end;
       end;
       SUCCESS:= FALSE;
       repeat
           BACKTRACK(TOP,START);
           PSEUdoSHifT;
          S1:= S;
          repeat
             BACKTRACK(S1,PARSESTACK[S1+1].TABLE);
             if LOOKAHEAD(ERRORVAL) then
             begin
                PSEUdoSHifT;
                SUCCESS:= LOOKAHEAD(newSymb);
             end;
             S1:= PARSESTACK[S1].LINK;
          until (S1=0) or SUCCESS;
          if not SUCCESS then
          begin
             (* MARK PREVIOUS symbol SKIPPED *)
             if TEST then write(SNAPSHOTS,' <---SKIPPED'); (***SNAPSHOT***)
             lexical;
          end;
       until SUCCESS or (not OK);
    if not OK then STOP(3);
    end; (* syntaxError *)
  
  
 begin (* PARSE *)
    TOP:=0; START:=LR[goal-nontStart].NEXT;
    BACKTRACK(TOP,START);
    while OK do
    begin
       lexical;
       if not LOOKAHEAD(newSymb) then syntaxError;
       ADVANCE;
    end;
 end; (*PARSE*)
  
 begin (* PARSER *)
    CL:=clock;
    writeln(output,'=BOBS-SYSTEM VERS. JAN. 1985'); 
    INITIALIZE;
(*
    repeat
       write(output,' type goalsymbol (',nontStart:1,',',symbMax:1,')');
       read(output,goal);
    until (nontStart <= goal) and (goal <= symbMax);
*)
    goal:=nontStart;
    PARSE(goal);
    CODE(2,0,0); (* COPY,SNAPSHOTS,output *)
    if ERROR then writeln(output,' ERROR(S) in BOBS-PROGRAM SORRY');
    CL:=clock-CL;
    writeln(output,' Parse time:',CL,' MILLISECONDS');
    writeln(output,'=end BOBS'); 
 end; (*PARSER*)
  
 begin
    PARSER;
  10:
 end. (*BOBS*)
