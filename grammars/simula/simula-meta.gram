-- simula : aGrammar : metagrammar --
grammar simula :
Option
  stringchar = '" '
rule
  (* the goal symbol: *)
  <startSymbol> ::= <simulaSourceModule>;
  
  (* rule from chapter 1: lexical tokens *)
  <Identifier> ::= <nameAppl>;
  <unsignedNumber> ::= <const>;
 (* <characterConstant> ::= <string>; *)
  
  (* rules from chapter 2 : types and values *)
  
  <optType> ::? <type>;
  <type> ::| <valueType> | <referenceType>;
  <valueType> ::| <arithmeticType> | <boolean> | <character>;
  <arithmeticType> ::| <integerType> | <realType>;
  <integerType> ::= <optShort> 'integer';
  <realType> ::= <optLong> 'real';
  <referenceType> ::| <objectReference> | <text>;
  <objectReference> ::= 'ref' '(' <qualification> ')';
  <qualification> ::= <Classidentifier>;
  
  <boolean> ::= 'boolean';
  <character> ::= 'character';
  <text> ::= 'text';
  <optShort> ::? <short>;
  <optLong> ::? <long>;
  <short> ::= 'short';
  <long> ::= 'long';
  
  (* rules from chapter 3 : expressions *)
  
  <expression> ::| <valueExpression> | 
		   <conditionalExpression> | 
                   <functionOrArrayDesignator>;
  <conditionalExpression> ::= <ifClause> <Expression> 'else' <Expression>;
  <valueExpression> ::| <simpleExpression> | <booleanExpression> ;
  <bracketedExpression> ::= '(' <expression> ')';
  <variable> ::= <identifierOne>;
  <functionOrArrayDesignator> ::= <Identifier:IdentifierOne> <ActualParameterPart>;
  <OptActualParameterPart> ::? <actualParameterPart>;
  <actualParameterPart> ::= '(' <actualParameterList> ')';
  <actualParameterList> ::+ <expression> ',';
  <identifierOne> ::| <identifier> | <remoteIdentifier>;
  <remoteIdentifier> ::= <ObjectExpression> '.' 
                         <attributeIdentifier:Identifier>;
  <BooleanExpression> ::| <simpleBooleanExpression>; 
  <simpleBooleanExpression> ::= <BooleanTertiaryList>;
  <booleanTertiaryList> ::+ <BooleanTertiary> 'orelse';
  <booleanTertiary> ::+ <equivalence> 'andthen';
  <equivalence> ::+ <implication> 'eqv';
  <implication> ::+ <booleanTerm> 'imp';
  <booleanTerm> ::+ <booleanFactor> 'or';
  <booleanFactor> ::+ <booleanSecondary> 'and';
  <booleanSecondary> ::| <NotBooleanPrimary> | <BooleanPrimary>;
  <NotBooleanPrimary> ::= 'not' <BooleanPrimary>;
  <booleanPrimary> ::| <logicalValue> | <relation> ;
  <logicalValue> ::| <true> | <false>;
  <true> ::= 'true';
  <false> ::= 'false';
  <relation> ::| <valueRelation> | <referenceRelation> | <objectRelation>;
  <ValueRelation> ::=  <SimpleExpression> 
		  <ValuerelationalOperator> 
		  <simpleExpression>;
  <ReferenceRelation> ::=  <SimpleExpression> 
		  <ReferenceComperator> 
		  <simpleExpression>;
  <valueRelationalOperator> ::| <lt> | <le> | <eq> | <ne> | <ge> | <gt>;
   <lt> ::= '<';
   <le> ::= '<=';
   <eq> ::= '=';
   <ne> ::= '<>';
   <ge> ::= '>=';
   <gt> ::= '>';
   <referenceComperator> ::| <eqRef> | <neRef>;
   <eqRef> ::= '==';
   <neRef> ::= '=/=';
   <objectRelation> ::| <InRelation> | <IsRelation>;
   <inRelation> ::= <simpleObjectExpression> 'in' <classIdentifier>;
   <isRelation> ::= <simpleObjectExpression> 'is' <classIdentifier>;
  <simpleExpression> ::| <term> | <addition> | <subtraction> 
		       | <simpleTextExpression> | <simpleObjectExpression> ;

  <simpleTextExpression> ::| <notext> | <simulaString> ; 
  <ObjectExpression> ::| <simpleObject> | <objectIf>;
  <objectIf> ::= <ConditionalExpression>;
  <simpleObject> ::= <simpleObjectExpression>;
  <simpleObjectExpression> ::| <none> | <objectGeneration> | <localObject> 
			     | <qualifiedObject> | <switchDesignator>;
  <switchDesignator> ::= <switchIdentifier:Identifier> '(' <subscriptExpression:Expression> ')' ;
  <addition> ::= <SimpleExpression> '+' <Term>;
  <subtraction> ::= <SimpleExpression> '-' <Term>;
  <term> ::| <factor> | <mult> | <intDiv> | <realDiv>;
  <mult> ::= <term> '*' <factor>;
  <intDiv> ::= <term> '//' <factor>;
  <realDiv> ::= <term> '/' <factor>;
  <factor> ::| <primary> | <exponent>;
  <exponent> ::= <factor> '**' <primary>;
  <primary> ::| <unsignedNumber> | <variable> | <BracketedExpression>; 
  <simulaString> ::= <string>;
  <notext> ::= 'notext';
  <objectgeneration> ::= <objectGenerator>;
  <none> ::= 'none';
  <objectGenerator> ::= 'new' <classIdentifier> <OptActualParameterPart>;
  <localObject> ::= 'this' <classIdentifier>;
  <qualifiedObject> ::= <simpleObjectExpression> 'qua' <classIdentifier>;
  <label> ::= <identifier>;
  
  (* rules from chapter 4 : statements *)
  <optStatement> ::? <statement>;
  <statement> ::| <unconditionalStatement> | <labelledStatement> 
                | <conditionalStatement> | <forStatement> | <inner> ;
  <labelling> ::= <label> ':';
  <OptLabelling> ::? <labelling>;
  <LabelledStatement> ::= <labelling> <statement>;
  <unConditionalStatement> ::| <assignmentStatement>
  			     | <whileStatement>
			     | <gotoStatement>
		 	     | <procedureStatement>
			     | <objectGenerator>
			     | <connectionStatement>
			     | <compoundStatement>
			     | <block>
			     | <activationStatement>;
   <assignmentStatement> ::| <valueAssignment> | <referenceAssignment>;
   <valueAssignment> ::= <valueLeftPart> ':=' <valueRightPart>;
   <valueLeftPart> ::| <destination> | <aSimpleTextExpression>;
   <aSimpleTextExpression> ::= <simpleExpression>;
   <valueRightPart> ::| <anExpression> | <aValueAssignment>;
   <anExpression> ::= <Expression>;
   <aValueAssignment> ::= <ValueAssignment>;
   <destination> ::= <Variable>; 
   <referenceRightPart> ::| <aReferenceExpression> | <aReferenceAssignment>;
   <aReferenceExpression> ::= <Expression>;
   <aReferenceAssignment> ::= <ReferenceAssignment>;
   <referenceAssignment> ::= <referenceLeftPart:destination> ':-' <referenceRightPart>;
   <conditionalStatement> ::| <ifUnconditionalStatement> |  <ifForStatement>;
   <ifUnconditionalStatement> ::= <ifClause> <OptLabelling> 
                                  <unconditionalStatement> <OptElse>;
   <optElse> ::? <ElsePart>;
   <elsePart> ::= 'else' <Optstatement>;
   <ifForStatement> ::= <IfClause> <OptLabelling> <forStatement>;
   <ifClause> ::= 'if' <booleanExpression> 'then';
   <whileStatement> ::= 'while' <booleanExpression> 'do' <Optstatement>;
   <forStatement> ::= 'for' <simpleVariable:Identifier> <forRightPart>
                      'do' <optStatement>;
   <forRightPart> ::| <referenceFor> | <valueFor>;
   <referenceFor> ::= ':=' <referenceForList>;
   <referenceForList> ::+ <referenceForListElement> ',';
   <valueFor> ::= ':=' <valueForList>;
   <valueForList> ::+ <valueForListElement> ',';
   <valueForListElement> ::| <valueExpressionWithOptWhile> 
                           | <forTextExpression> 
			   | <stepUntil>;
   <forTextExpression> ::= <Expression>;
   <valueExpressionWithOptWhile> ::= <valueExpression> <OptWhilePart>;
   <OptWhilePart> ::? <whilePart>;
   <whilePart> ::= 'while' <booleanExpression>;
   <stepUntil> ::= <Expression> 'step' <Expression> 'until' <Expression>;
   <referenceForListElement> ::= <Expression> <OptWhilePart>;
   <gotoStatement> ::= <gotoKeyWord> <Expression>;
   <gotoKeyWord> ::| <goto> | <gospto>;
   <goto> ::= 'goto';
   <gospto> ::= 'go' 'to';
   <procedureStatement> ::= <procedureIdentifier:IdentifierOne> <OptActualParameterPart>;
   <connectionStatement> ::| <connectionWithWhen> | <connectionWithoutWhen>;
   <connectionWithWhen> ::= 'inspect' <Expression> <whenClauseList> <OptOtherwiseClause>;
   <connectionWithoutWhen> ::= 'inspect' <Expression> 'do' <optStatement> <OptOtherwiseClause>;
   <OptOtherwiseClause> ::? <otherwiseClause>;
   <whenClauseList> ::+ <whenClause>;
   <whenClause> ::= 'when' <classIdentifier> 'do' <Optstatement>;
   <otherwiseClause> ::= 'otherwise' <Optstatement>;
   <compoundStatement> ::= 'begin' <statementList> 'end';
   <statementList> ::+ <optStatement> ';';
   <block> ::| <subBlock> | <prefixedBlock>;
   <subBlock> ::= 'begin' <declarationList> ';'  <statementList> 'end';
   <prefixedBlock> ::= <classIdentifier> <OptActualParameterPart> <mainBlock>;
   <mainBlock> ::| <aBlock> | <aCompoundStatement>;
   <aBlock> ::= <block>;
   <aCompoundStatement> ::= <compoundStatement>;
   
   
   (*rules from chapter 5 : declarations *)
   <declarationList> ::+ <declaration> ';';
   <declaration> ::| <simpleVariableDeclaration>
                   | <arrayDeclaration>
		   | <switchDeclaration> 
		   | <procedureDeclaration>
		   | <classDeclaration>
		   | <externalDeclaration>;
   <simpleVariableDeclaration> ::= <type> <typeList>;
   <typeList> ::+ <typeListElem> ',';
   <typeListElem> ::| <typeIdentifier> | <constantElement>;
   <typeIdentifier> ::= <identifier>;
   <arrayDeclaration> ::= <OptType> 'array' <arraySegmentList>;
   <arraySegmentList> ::+ <arraySegment> ',';
   <arraySegment> ::= <arrayIdentifierList> '(' <boundPairList> ')';
   <arrayIdentifierList> ::+ <Identifier> ',';
   <boundPairList> ::+ <boundPair> ',';
   <boundPair> ::= <Expression> ':' <Expression>;
   <switchDeclaration> ::= 'switch' <switchIdentifier:Identifier>
                           ':=' <switchList>;
   <switchList> ::+ <Expression> ',';
   <procedureDeclaration> ::= <OptType> 'procedure' <procedureHeading>
                              <procedureBody:Statement>;
   <procedureHeading> ::= <ProcedureName:NameDecl> <OptParameterSpec>;
   <OptParameterSpec> ::? <parameterSpec>;
   <parameterSpec> ::= '(' <formalParameterList:IdentifierList> ')' ';' 
                       <OptModePart> <specificationPart> ';';
   <specificationPart> ::+ <Specification> ';';
   <specification> ::= <specifier> <identifierList>;
   <specifier> ::| <arraySpecifier> | <procedureSpecifier> | <labelSpecifier> | <switchSpecifier> | <typeSpecifier>;
   <arraySpecifier> ::= <type> 'array';
   <procedureSpecifier> ::= <type> 'procedure';
   <labelSpecifier> ::= 'label';
   <switchSpecifier> ::= 'switch';
   <typeSpecifier> ::= <type>;
   <optModePart> ::? <modePart>;
   <modePart> ::| <nameValue> | <valueName>;
   <nameValue> ::= <NamePart> <OptValuePart>;
   <valueName> ::= <ValuePart> <OptNamePart>;
   <OptValuePart> ::? <ValuePart>;
   <OptNamePart> ::? <namePart>;
   <namePart> ::= 'name' <identifierList> ';';
   <valuePart> ::= 'value' <identifierList> ';';
   <identifierList> ::+ <identifier> ',';
   <ClassDeclaration> ::= <OptPrefix> 'class' <classIdentifier> 
                          <OptClassParameterPart> <ProtectionSpecificationList> 
			  <OptVirtualPart> <classBody:Statement>;
   <OptPrefix> ::? <Prefix>;
   <prefix> ::= <classIdentifier>;
   <OptClassParameterPart> ::? <ClassParameterPart>;
   <classParameterPart> ::= '(' <formalParameterList:IdentifierList> ')'
                            ';' <OptValuePart> <specificationPart>;
   <classIdentifier> :: <Identifier>;
   <OptVirtualPart> ::? <virtualPart>;
   <virtualPart> ::= 'virtual' ':' <specificationPart>;
   <protectionSpecificationList> ::* <protectionSpecification>;
   <protectionSpecification> ::| <hidden> | <protected> | <hiddenProtected>
                               | <protectedHidden>;
   <hidden> ::= 'hidden' <identifierList> ';';
   <protected> ::= 'protected' <identifierList> ';';
   <hiddenProtected> ::= 'hidden' 'protected' <identifierList> ';';
   <protectedHidden> ::= 'protected' 'hidden' <identifierList> ';';
   <constantElement> ::= <identifier> '=' <valueExpression>;
   <inner> ::= 'inner';
   
  (* rules from chapter 6 : program modules *)
  <simulaSourceModule> ::= <ExternalHead> <sourceDeclaration>;
  <sourceDeclaration> ::| <program> | <procedureSource> 
                        | <classSource> ;
  <procedureSource> ::= <procedureDeclaration> ;
  <classSource> ::= <classDeclaration>;
  <program> ::= <statement>;
  
  <externalHead> ::* <externalDeclaration>;
  <externalDeclaration> ::| <externalProcedureDeclaration> 
                          | <externalClassDeclaration> ;
  <externalProcedureDeclaration> ::=
              'external' <optKind> <optType> 'procedure' <externalList>;
  <externalClassDeclaration> ::= 'external' 'class' <externalList>;
  <externalList> ::+ <externaIItem> ',';
  <externaIItem> ::= <identifier> <OptExternalIdentification>;
  <OptExternalIdentification> ::? <ExternalIdentification>;
  <ExternalIdentification> ::= '=' <string>;
  <optKind> ::? <identifier>;
  
  (* rules from chapter 12: class simulation: *)
  <activationStatement> ::= <activationClause> <optSchedulingClause>;
  <activationClause> ::= <activator> <Expression>;
  <activator> ::| <activate> | <reactivate>;
  <activate> ::= 'activate';
  <reactivate> ::= 'reactivate';
  <optSchedulingClause> ::? <schedulingClause>;
  <schedulingClause> ::| <at> | <delay> | <before> | <after>;
  <at> ::= 'at' <Expression> <optPrior>;
  <delay> ::= 'delay'  <Expression> <optPrior>;
  <before> ::= 'before' <Expression>;
  <after> ::= 'after' <Expression>;
  <optPrior> ::? <prior>;
  <prior> ::= 'prior'
