EOLasComEnd; 
--- idl: aGrammar: metagrammar ---
Grammar idl:

Option
  version = 7
  comBegin = '//'
  comEnd = '*/'
  stringChar = '"'
  suffix = '.idl'
  EOSchar = '%'

  nameDecl = unused


Rule
 
<specification> ::=     <definitions> ;
                       
<definitions> ::+ <definition> (* ; separator originally *)
	      ;
<definition>  ::|     <def_type_dcl> 
                |     <const_dcl> 
              (*|     <static_dcl>*) 
                |     <except_dcl> 
                |     <interface> 
                |     <dispinterface> 
                |     <library> 
                |     <coclass> 
                |     <module> 
		|     <import>
		|     <importlib>
		|     <def_cpp_quote>
		|     <definition_error>
                ;
<def_type_dcl> 	::=	<type_dcl>  ';'
		;
<def_cpp_quote> ::=     <cpp_quote>
		;
<module>        ::=     'module' <identifier> '{' <definitions> '}' (*<semicolon_opt>*)
		;
<comma_opt>  ::? 	<comma>
		;
<comma>	::=	','
		;
<semicolon_opt>  ::? 	<semicolon>
		;
<semicolon>	::=	';'
		;
<import>   	::=     'import' <string> (* <idl_string> *) ';'
		;
<importlib>   	::=     'importlib' '(' <string> (* <idl_string> *) ')' ';'
		;
<library>	::=     <library_header> '{' <library_body> '}' <semicolon_opt>
			;
<library_header>::=     <attributes_spec>
			'library' <identifier>
			;
<library_body>  ::=     <definitions>
		;
<coclass>	::=     <coclass_header> '{' <coclass_body>  '}' <semicolon_opt>
		;
<coclass_header>::=     <attributes_spec>
			'coclass' <identifier>
			;
<coclass_body>  ::+	<coclass_interface_dcl>
		;
<coclass_interface_dcl> ::| <coclass_interface>
			|   <coclass_dispinterface>
			;
<coclass_interface> 	::= <attributes_specs> 'interface' <identifier> ';'
			;	
<coclass_dispinterface> ::= <attributes_specs> 'dispinterface' <identifier> ';'
			;

(* MIDL attributes *)

<attributes_specs> 	::* <attributes_spec>
			;
<attributes_spec> 	::= '[' <attributes> ']'
			;
<attributes>	 	::+ <attribute_spec_opt> ','
			;
<attribute_spec_opt>	::? <attribute_spec>
		        ;
<attribute_spec>	::| <readonly> 
			|   <default>
			|   <uuid>
			|   <attribute_general>
			;
<attribute_general>	::= <NameAppl> <attribute_value_opt> 
				       <attribute_minor_value_opt>
			;
<attribute_value_opt>	::? <attribute_value>
			;
<attribute_value>	::= '(' <att_val_spec> ')'
			;
<att_val_spec>		::| <att_val_const_exp>
			  | <att_val_string> 
			;
<att_val_const_exp>	::= <comma_opt> <const_exps>
			;
<att_val_string>	::= <string> (* <idl_string> *)
			;
<istring>		::= <NameAppl> (* MUST be 'string' *)
			;
<default>		::= 'default'
			;
<uuid>			::= 'uuid' '(' <uuid_rep> ')'
			;
<uuid_rep>		::* <keys> '-' 
			;
<keys>			::+ <key>
			;
<key>			::| <constKey> | <nameKey>
			;
<constKey>		::= <const>
			;
<nameKey>		::= <nameAppl>
			;
<attribute_minor_value_opt> ::? <attribute_minor_value>
			;
<attribute_minor_value> ::= '.' <const>
			;	

(* End of attributes *)

<interface>	      ::|    <interface_dcl>
		      |      <forward_dcl>
		      ;
<dispinterface>	      ::|    <dispinterface_dcl>
		      |      <dispforward_dcl>
		      ;
<interface_dcl> ::=     <interface_header> '{' <interface_body> '}'
			<semicolon_opt> (* datpete: added semicolon_opt *)
		;
<dispinterface_dcl> ::= <dispinterface_header> '{' <interface_body> '}'
			<semicolon_opt> (* datpete: added semicolon_opt *)
			;
<forward_dcl>		::=     'interface' <identifier> ';' (* ';' added *)
			;
<dispforward_dcl>	::=     'dispinterface' <identifier> ';' (* ';' added *)
			;
<interface_header>      ::=     <attributes_spec>
				'interface' <identifier>
                                <inheritance_spec_opt>
			;
<dispinterface_header>  ::=     <attributes_spec>
				'dispinterface' <identifier>
			;
<inheritance_spec_opt> ::? <inheritance_spec> 
			;
<interface_body>        ::=     <exports_opt>
			;
<exports_opt>		::?	<exports>
			;
<exports> ::+ <export> 
	  ;
<export>        ::|     <export_type_dcl> 
                |       <export_const_dcl> 
                |       <export_except_dcl> 
                |       <export_attr_dcl> 
                |       <export_op_dcl> 
		|	<cpp_quote>
		|	<properties> (* Only for dispinterfaces *)
		|	<methods>    (* Only for dispinterfaces *)
		|	<export_import>
		|	<export_error>
		;
(* cpp_quote is a COM hack - probably not correct *)
<cpp_quote>	::= 'cpp_quote' '(' <string> (* <idl_string> *) ')'
		;
<properties>	::= 'properties' ':'(* Not yet complete *)
		;
<methods>	::= 'methods' ':' (* Not yet complete *)
		;
<export_import>	::= <import>
		;
<export_type_dcl>	::= <type_dcl> ';'
			;
<export_const_dcl> 	::= <const_dcl>
			;	
<export_except_dcl> 	::= <except_dcl> ';'
		;
<export_attr_dcl> 	::= <attr_dcl> ';'
			;
<export_op_dcl> 	::= <op_dcl> ';'
			;
<inheritance_spec>      ::=     ':' <scoped_names> 
			;
<scoped_names>	::* <scoped_name> ',' 
		;
<scoped_name>   ::| <scoped_name1> | <scoped_name2> | <scoped_name3> 
		;
<scoped_name1> ::=     	<identifier>
		;
<scoped_name2> ::=      '::' <identifier>
		;
<scoped_name3>  ::= 	<scoped_name> '::' <identifier>
		;
(*
<static_dcl>    ::=	'static' <type_declarator> '=' <const_exp>
		;
*)
<const_dcl>     ::=     'const' 
			<const_type> 
			<declarator> (*<identifier>*)
			'='
		        <const_exp> 
			';'
		;
<const_type>    ::|     <const_integer_type>
                |       <const_char_type>
                |       <const_boolean_type>
                |       <const_floating_pt_type>
                |       <const_string_type>
                |       <const_void_type>
                |       <const_scoped_name>
		;
<const_integer_type>	::= <integer_type>
			;
<const_char_type>	::= <char_type>
			;
<const_boolean_type>	::= <boolean_type>
			;
<const_floating_pt_type>	::= <floating_pt_type>
			;
<const_void_type>	::= <void_type_spec>
			;
<const_string_type>	::= <string_type>
			;
<const_scoped_name>	::= <scoped_name>
			;
<const_exps>		::+ <const_exp> ','
			;
<const_exp>        ::| <paren_const_exp>
		     | <const_expression>
		   ;
<paren_const_exp>  ::= (*<type_cast_opt>*)  '(' <const_exp> ')'
		   ;
<const_expression> ::=  (*<type_cast_opt>*) <or_expr>
		   ;
<or_expr>       ::| <xor_expr> | <_or> 
                ;
<_or>	  	::= <or_expr> '|' <xor_expr>
                ; (* <or> gives parse errors in idlcfl *)
<xor_expr>	::| <and_expr> | <_xor>
                ;
<_xor> 		::= <xor_expr> '^' <and_expr>
  		; (* <xor> gives parse errors in idlcfl *)
<and_expr>	::| <shift_expr> | <_and>
		;
<_and>		::= <and_expr> '&' <shift_expr>
		; (* <and> gives parse errors in idlcfl *)
<shift_expr>	::|  <add_expr> | <shiftRight> | <shiftLeft> 
		;
<shiftRight>	::= <shift_expr> '>>' <add_expr>;
<shiftLeft> 	::= <shift_expr> '<<' <add_expr>;

<add_expr>      ::| <mult_expr> | <add> | <sub> ;

<add>		::= <add_expr> '+' <mult_expr> ;

<sub>		::= <add_expr> '-' <mult_expr> ;

<mult_expr>     ::| <unary_expr> | <mult> | <idiv> | <imod> ;

<mult>		::= <mult_expr> '*' <unary_expr> 
		;
<idiv>		::= <mult_expr> '/' <unary_expr> 
		;
<imod> 		::= <mult_expr> '%' <unary_expr> 
		;
<unary_expr>    ::|    <unary> 
                |       <primary_expr>
		;
<unary>		::= <unary_operator> <primary_expr>
		;
<unary_operator>::| <unaryMinus> 
                  | <unaryPlus> 
                  | <negation>
		  | <pointer_dereference> (* datpete *)
		  | <logical_not> (* datpete *)
		  | <address_of> (* datpete *)
			;
<unaryMinus>	::= '-'
		;
<unaryPlus>	::= '+'
		;
<negation>	::= '~'
		;
<pointer_dereference>	::= '*'
			;
<logical_not>	::= '!'
		;
<address_of>	::= '&'
		;
<primary_expr>  ::|     <scoped_nameA>
                |       <literal>
                |       <bracketed_expr>
		|	<simple_function>
		;
<scoped_nameA>	::= <scoped_name>
		;
<bracketed_expr>	::= '(' <const_exp> ')'
			;
<literal>       ::|     <number_literal>
                |       <string_literal>
                |       <boolean_literal>
		;
<boolean_literal>       ::| <true> | <false>
			;
<true> 	::=   'TRUE'
	;
<false>	::=  'FALSE'
	;
<positive_int_const>    ::| <const_exp>
			;
<type_dcl>		::| <typedef> 
			|   <extern>	
			|   <struct_type>
			|   <union_type>
			|   <enum_type>
			|   <type_dcl_error>
			;
<typedef>		::= 'typedef' <type_declarator>
			;
<extern>		::= 'extern' <type_declarator>
			;
<type_declarator_opt>	::? <type_declarator>
			;
<type_declarator>	::| <simple_type_declarator> 
			|   <fnc_ptr_type_declarator>
			;
<simple_type_declarator>  ::= <attributes_specs> 
			      <const_opt> 
			      <type_spec> 
			      <declarators>
			  ;
<fnc_ptr_type_declarator> ::= <attributes_specs> 
			      <const_opt> 
			      <return:type_spec> 
			       '(' <std_call_opt> '*' <fname:identifier> ')'
			       '(' <param_dcls> ')'
			  ;

(*
<type_cast_opt>	::?	<type_cast>
		;
<type_cast>	::=	'(' <type_spec> ')'
		;
*)

<type_spec>     ::|     <simple_type_spec>
                |       <constr_type_spec>
		|	<void_type_spec>
		;
<simple_type_spec>      ::|     <base_type_spec>
                	|       <template_type_spec>
                	|       <scoped_name>
			;
<base_type_spec>        ::|     <floating_pt_type>
                |       <integer_type>
                |       <char_type>
                |       <boolean_type>
                |       <octet_type>
                |       <any_type>
		;
<template_type_spec>    ::|     <sequence_type>
                	|       <string_type>
			;
<constr_type_spec>      ::|     <constr_struct_type>
                	|       <constr_union_type>
                	|       <constr_enum_type>
			;
<constr_struct_type>	::= <struct_type>
			;
<constr_union_type>	::= <union_type>
			;
<constr_enum_type>	::= <enum_type>
			;	
<declarators>   ::*     <declarator> ','  (* originally a + *)
		;
<declarator>    ::|     <simple_declarator>
                |       <complex_declarator>
		| 	<pointer_declarator>
		|	<pointer_to_pointer_declarator>
		|	<pointer_to_array_declarator>
		;
<simple_declarator>     ::=     <identifier>
			;
<complex_declarator>    ::|     <array_declarator>
		;
<floating_pt_type>      ::| <float> | <double>
			;
<float>	::=     'float'
	;
<double>	::=   'double'
		;
<integer_type>   ::|    <int>
		 |	<long>
		 |	<long_int>
		 |	<signed>
		 |	<unsigned>
		 |	<signed_int>
		 |	<unsigned_int>
		 |	<signed_long>
		 |	<unsigned_long>
		 |	<signed_long_int>
		 |	<unsigned_long_int>
		 |	<short>
		 |	<short_int>
		 |	<signed_short>
		 |	<unsigned_short>
		 |	<signed_short_int>
		 |	<unsigned_short_int>
		 |	<small>
		 |	<small_int>
		 |	<signed_small>
		 |	<unsigned_small>
		 |	<signed_small_int>
		 |	<unsigned_small_int>
		 |	<int64>
		 |	<signed_int64>
		 |	<unsigned_int64>
		 |	<hyper>
		 ;
<int>			::=     'int'
			;
<long>			::=     'long'
			;
<long_int>		::=     'long' 'int'
			;
<short>			::=     'short'
			;
<short_int>		::=     'short' 'int'
			;
<small>			::=     'small'
			;
<small_int>		::=     'small' 'int'
			;
<hyper>			::=     'hyper'
			;
<signed>		::=     'signed' 
			;
<unsigned>		::=     'unsigned' 
			;
<signed_int>		::=     'signed' 'int'
			;
<unsigned_int>		::=     'unsigned' 'int'
			;
<signed_long_int>       ::=     'signed' 'long' 'int'
			;
<unsigned_long_int>     ::=     'unsigned' 'long' 'int'
			;
<signed_long>    	::=     'signed' 'long'
			;
<unsigned_long>    	::=     'unsigned' 'long'
			;
<signed_short_int>      ::=     'signed' 'short' 'int'
			;
<unsigned_short_int>    ::=     'unsigned' 'short' 'int'
			;
<signed_short>		::=     'signed' 'short'
			;
<unsigned_short>	::=     'unsigned' 'short'
			;
<signed_small_int>      ::=     'signed' 'small' 'int'
			;
<unsigned_small_int>    ::=     'unsigned' 'small' 'int'
			;
<signed_small>		::=     'signed' 'small'
			;
<unsigned_small>	::=     'unsigned' 'small'
			;
<int64>			::=     '__int64'
			;
<signed_int64>		::=     'signed' '__int64'
			;
<unsigned_int64>	::=     'unsigned' '__int64'
			;
<char_type>     ::|     <unsigned_char> | <signed_char> | <char>
		;
<unsigned_char> ::=     'unsigned' 'char'
		;
<signed_char>   ::=     'signed' 'char'
		;
<char>          ::=     'char'
		;
<boolean_type>  ::=     'boolean'
		;
<octet_type>    ::=     'octet'
		;
<any_type>      ::=     'any'
		;
<struct_type>     ::=   'struct' <tag:identifier_opt> <struct_body_opt>
		  ;
<struct_body_opt> ::?   <struct_body>
		  ;
<struct_body>     ::=   '{' <members> <semicolon_opt> '}'
		  ;
<identifier_opt>  ::?	<identifier>
		  ;
<members> 	  ::*   <member>
		  ;
<member>          ::=   <type_declarator> ';'
		  ;
<union_type>            ::= 'union' <tag:identifier_opt> 
				    <union_switch_opt>
				    <union_body_opt> 
		        ;
<union_switch_opt>	::? <union_switch>
			;
<union_switch>		::= 'switch' '(' <switch_type_spec>
			    <identifier> ')' <name:identifier_opt>
			;
<union_body_opt>	::? <union_body>
			;
<union_body>		::= '{' <union_cases> '}'
			;
<switch_type_spec>      ::|     <switch_integer_type>
                	|       <switch_char_type>
                	|       <switch_boolean_type>
                	|       <switch_enum_type>
                	|       <switch_scoped_name>
			;
<switch_integer_type>	::= <integer_type>
			;
<switch_char_type>	::= <char_type>
		        ;
<switch_boolean_type>	::= <boolean_type>
			;
<switch_enum_type>	::= <enum_type>
		        ;
<switch_scoped_name>	::= <scoped_name>
		        ;
<union_cases>      ::+     <case>
		   ;
<case>             ::=     <case_labels> ';'
	           ;
<case_labels>	   ::+ <case_label> (* '$' (* olm *)
		   ;
<case_label>       ::| <bracketed_case_const_label> 
		   |   <bracketed_case_default> 
		   |   <case_const_label> 
		   |   <case_default> 
		   |   <type_declarator>
		   ;
<case_default>     ::= 'default' ':' <type_declarator_opt>
		   ;
<case_const_label> ::= 'case' <const_exp> ':' <type_declarator_opt>
		   ;
<bracketed_case_default>     ::= '[' 'default' ']' <type_declarator_opt>
			     ;
<bracketed_case_const_label> ::= '[' 'case' '(' <const_exps> ')' ']' <type_declarator_opt>
			     ;
<enum_type>     ::=     'enum' <tag:identifier_opt> <enum_body_opt>
		;
<enum_body_opt> ::?     <enum_body>
		;
<enum_body>	::=     '{' <enumerators> <comma_opt> '}' 
		;
<enumerators> 	::+ <enumerator> ','
		;
<enumerator>    ::=     <attributes_specs> <identifier> <value_opt>
		;
<sequence_type> ::|     <sequence1> | <sequence2> 
		;
<sequence1>	::= 'sequence' '<' <simple_type_spec>
                                ',' <positive_int_const> '>'
		;
<sequence2>	::= 'sequence' '<' <simple_type_spec> '>'
		;
<string_type>   ::|     <string1> | <string2>
		;
<string1>	::= <istring> '<' <positive_int_const> '>'
		;
<string2>	::= <istring>
		;
<array_declarator>      ::=     <identifier> <array_sizes>
			;
<array_sizes>		::+ <array_size> 
			;
<array_size>		::| <fixed_array_size> | <variable_array_size>
			;
<fixed_array_size>	::=  '[' <positive_int_const_opt> ']'
			;
<variable_array_size>	::=  '[' '*' ']'
			;
<attr_dcl>      ::=     <readonly_opt> 'attribute'
			<param_type_spec>
			<simple_declarators>
		;
<simple_declarators>	::+ <simple_declarator> ','
			;
<readOnly_opt>	::? <readOnly>
		;
<readOnly>	::= 'readonly'
		;
<except_dcl>   	::= 'exception' <identifier> '{' <members> '}' 
		;
<op_dcl>        ::= <attributes_specs> <op_type_spec> <std_call_opt>
                                <identifier>
                                <parameter_dcls>
                                <raises_expr_opt> <context_expr_opt>
		;
<raises_expr_opt>	::? <raises_expr>  
			;
<context_expr_opt> 	::? <context_expr> 
			;
<op_type_spec>  ::|     <param_type_spec>
                |       <void>
		|	<param_type_spec_ref>
		|	<void_ref>
		;
<void> 	::= 'void'
	;
<parameter_dcls>        ::=     '(' <param_dcls> ')'
			;
<param_dcls> 	::* <param_dcl> ',' 
		;
<param_dcl>     ::|	<simple_param_dcl>
		|	<fnc_ptr_param_dcl>
		; 	
<simple_param_dcl> ::= 	<attributes_specs> 
			<const1: const_opt> 
			<type: param_type_spec> 
			<const2: const_opt> 
			<declarator: declarator_opt>
		   ;
<fnc_ptr_param_dcl>::=  <fnc_ptr_type_declarator>
		   ;
<declarator_opt>	::?	<declarator>
			;
<raises_expr>   ::=     'raises' '(' <scoped_names> ')'
		;

<context_expr>  	::=     'context' '(' <string_literals> ')' 
			;
<string_literals>	::+ <string_literal> ',' ;

<param_type_spec>	::|     <param_base_type_spec> 
			|	<param_string_type>
                        |	<param_scoped_name>
			|	<param_void>
			;
<param_base_type_spec> 	::=	<base_type_spec> 
			;
<param_string_type>	::=	<string_type>
			;
<param_scoped_name>	::=	<scoped_name>
			;
<identifier>	::= <nameAppl>
		;
<number_literal> 	::= <const>
			;
<string_literal>	::= <string> (* <idl_string> *)
			;

(****************************additional COM stuff ****************************)

(*
<idl_string>	::| <unicode_string> | <ascii_string>
		;
<unicode_string>::= 'L' <string>
		;
<ascii_string>::= <string>
		;
*)

<param_void>	::= <void>
			;
<pointer_declarator>	::= '*' <identifier_opt>
			;
<pointer_to_pointer_declarator>	::= '*' '*' <identifier_opt>
			;
<std_call_opt>	::?	<std_call>
		;
<std_call>	::|	<_stdcall> | <__stdcall>
		;
<__stdcall>	::=	'__stdcall'
		;
<_stdcall>	::=	'_stdcall'
		;
<void_ref>	::=	'void' '*'
		;
<value_opt>	::?	<value>
		;
<value>	::=	'=' <const_exp>
	;
<const_opt> 	::? <const_key>
		;
<const_key>	::= 'const'
		;
<positive_int_const_opt> ::? <positive_int_const>
			 ;
<simple_function>	::= <identifier> '(' <const_exp> ')'
			;
<void_type_spec>	::= 'void'
			;
<param_type_spec_ref>	::= <param_type_spec> '*'	
			;
<pointer_to_array_declarator>	::=	'*' <array_declarator>
				;
<definition_error>	::= error
			;
<export_error>	::=	error
		;
<type_dcl_error>	::= error

