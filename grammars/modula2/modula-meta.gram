-- modula : aGrammar : metagrammar --
grammar modula:
rule

<CompilationUnit> ::| <ForeignDefinitionModule> | <ImplementationModule>
		    | <DefinitionModule> | <ProgramModule>;
<ForeignDefinitionModule> ::= '%' 'FOREIGN' 'DEFINITION' 'MODULE' <nameAppl> ';'
			      <imports> <ExportOpt> <ForeignDefinitions>
			      'END' <nameDecl> '.';
<ForeignDefinitions> ::* <ForeignDefinition>;
<ForeignDefinition> ::| <ForeignConstantDecl> | <ForeignTypeDecl> 
		      | <ForeignVariableDecl> | <ForeignProcedureHeading>; 
<ForeignConstantDecl> ::= <ConstantDecl>;
<ForeignTypeDecl> ::= <TypeDecl>;
<ForeignVariableDecl> ::= <VariableDecl>;

<ForeignProcedureHeading> ::= 'PROCEDURE' <nameDecl> 
			      <ForeignFormalParametersOpt>;
<ForeignFormalParametersOpt> ::? <ForeignFormalParameters>;
<ForeignFormalParameters> ::= '(' <ForeignFPSections> ')' <QualOpt>;
<ForeignFPSections> ::+ <ForeignFPSectionOpt> ';';
<ForeignFPSectionOpt> ::? <ForeignFPSection>;
<ForeignFPSection> ::= <VarOpt> <PercentOpt> <IdentList> ':' <FormalType>;
<PercentOpt> ::? <Percent>;
<Percent> ::| <PercentREF> | <PercentIMMED> | <PercentSTDESCR>;
<PercentREF> ::= '%' 'REF';
<PercentIMMED> ::= '%' 'IMMED';
<PercentSTDESCR> ::= '%' 'STDESCR';
<QualOpt> ::? <qual>;
<qual> ::= ':' <QualIdent>; 

<ImplementationModule> ::= 'IMPLEMENTATION' 'MODULE' 
			    <nameDecl> <PriorityOpt> ';'
		            <imports> <block> 'END' <nameAppl> '.';

<ProgramModule> ::= 'MODULE' <nameDecl> <PriorityOpt> ';'
		    <imports> <block> 'END' <nameAppl> '.';

<DefinitionModule> ::= 'DEFINITION' 'MODULE' <nameDecl> ';'
		       <imports> <ExportOpt> <definitions> 
		       'END' <nameAppl> '.';

<definitions>::* <definition>;
<definition> ::| <DefinitionConstantDecl> | <DefinitionTypeDecl> 
	       | <DefinitionVariableDecl> | <ProcedureHeading>; 

<DefinitionConstantDecl> ::= <ConstantDecl>;
<DefinitionTypeDecl> ::= 'TYPE' <TypeList> ';';
<TypeList> ::+ <TypeDefOpt> ';';
<TypeDefOpt> ::? <TypeDef>;
<TypeDef> ::= <nameDecl> <TypeOpt>;
<TypeOpt> ::? <IsType>;
<IsType> ::= '=' <type>;
<DefinitionVariableDecl> ::= <VariableDecl>;

<number> ::= <const>;
(*<real> ::= <const> '.' <scaling>;
<scaling> ::| <NoScaling> | <ScalingPlus> | <ScalingMinus>; 
<NoScaling> ::= <const>;
<ScalingPlus> ::= <const> '+' <const>;
<ScalingMinus> ::= <const> '-' <const>;*)
<str> ::= <string>;
<nameApl> ::= <nameAppl>;

<ConstantDeclaration> ::= <nameDecl> '=' (* const *)<expression>;

(*
<ConstExpression> ::| <SimpleConstExpr> | <RelationalConstExpr>;

<RelationalConstExpr> ::| <EqConstExpr> | <NeConstExpr> 
			| <LtConstExpr> | <LeConstExpr> | <GtConstExpr> 
			| <GeConstExpr> | <InConstExpr>;

<SimpleConstExpr> ::| <AddConstExpr> | <SignedConstTerm> | <ConstTerm>;

<AddConstExpr> ::| <PlusConstExpr> | <MinusConstExpr> | <OrConstExpr>;

<SignedConstTerm> ::| <UnaryPlusConstExpr> | <UnaryMinusConstExpr>;

<ConstTerm> ::| <MulConstExpr> | <ConstFactor>;

<MulConstExpr> ::| <TimesConstExpr> | <DivConstExpr> | <ModConstExpr> 
		 | <AndConstExpr>;

<EqConstExpr> ::= <Operand1:SimpleConstExpr> '=' <Operand2:SimpleConstExpr>;
<NeConstExpr> ::= <Operand1:SimpleConstExpr> <NeSign> 
		  <Operand2:SimpleConstExpr>;
<LtConstExpr> ::= <Operand1:SimpleConstExpr> '<' <Operand2:SimpleConstExpr>;
<LeConstExpr> ::= <Operand1:SimpleConstExpr> '<=' <Operand2:SimpleConstExpr>;
<GtConstExpr> ::= <Operand1:SimpleConstExpr> '>' <Operand2:SimpleConstExpr>;
<GeConstExpr> ::= <Operand1:SimpleConstExpr> '>=' <Operand2:SimpleConstExpr>;
<InConstExpr> ::= <Operand1:SimpleConstExpr> 'IN' <Operand2:SimpleConstExpr>;

<PlusConstExpr>  ::= <SimpleConstExpr> '+' <ConstTerm>;
<MinusConstExpr> ::= <SimpleConstExpr> '-' <ConstTerm>;
<OrConstExpr>    ::= <SimpleConstExpr> 'OR' <ConstTerm>;

<UnaryPlusConstExpr> ::= '+' <ConstTerm>;
<UnaryMinusConstExpr> ::= '-' <ConstTerm>;

<DivConstExpr> ::| <IntegerDivConstExpr> | <RealDivConstExpr>;
<TimesConstExpr>      ::= <ConstTerm> '*' <ConstFactor>;
<IntegerDivConstExpr> ::= <ConstTerm> 'DIV' <ConstFactor>;
<RealDivConstExpr>    ::= <ConstTerm> '/' <ConstFactor>;
<ModConstExpr>        ::= <ConstTerm> 'MOD' <ConstFactor>;
<AndConstExpr>        ::= <ConstTerm> <AndSign> <ConstFactor>;

<ConstFactor> ::| <ConstQualIdent> | <ConstNumber> | <ConstStr> | <ConstSet> 
		| <BracketedConstExpression> | <NotConstFactor>;
<ConstQualIdent> ::= <QualIdent>;
<ConstNumber> ::= <const>;
<ConstStr> ::= <string>;
<ConstSet> ::= <set>;
<BracketedConstExpression> ::= '(' <ConstExpression> ')';
<NotConstFactor> ::= 'NOT' <ConstFactor>;
*)

<set> ::= <QualIdentOpt> '{' <elements> '}';
<QualIdentOpt> ::? <QualIdent>;
<elements> ::+ <element> ',';
<element> ::| (* const *)<Expression> | <SubrangeConstExpr>;
<SubrangeConstExpr> ::= (* const *)<lower:Expression> '..' <upper:Expression>; 

<TypeDeclaration> ::= <nameDecl> '=' <type>;
<type> ::| <SimpleType> | <ArrayType> | <RecordType> 
	 | <SetType> | <PointerType> | <ProcedureType>;

<SimpleType> ::| <QualIdent> | <Enumeration> | <SubrangeType>;

<Enumeration> ::= '(' <IdentList> ')';
<IdentList> ::+ <nameDecl> ',';

<SubrangeType> ::= '[' (* const *)<Expression> '..' <Expression> ']';

<ArrayType> ::= 'ARRAY' <SimpleTypes> 'OF' <type>;
<SimpleTypes> ::+ <SimpleType> ',';

<RecordType> ::= 'RECORD' <FieldListSequence> 'END';
<FieldListSequence> ::+ <FieldList> ';';
<FieldList> ::| <NormalFields> | <VariantFields>;
<NormalFields> ::= <IdentList> ':' <type>;
<VariantFields> ::= 'CASE' <TagField> 'OF' 
		     <variants> <ElseOpt> 'END';
<TagField> ::| <AnonymousTagField> | <NamedTagField>;
<AnonymousTagField> ::= <QualIdent>; 
<NamedTagField> ::= <nameDecl> ':' <QualIdent>;
<variants> ::+ <variant> '|';
<variant> ::= <CaseLabelList> ':' <FieldListSequence>;
<CaseLabelList> ::+ <CaseLabel> ',';
<CaseLabel> ::| <CaseConstExpression> | <CaseSubrangeConstExpr>;
<CaseConstExpression> ::= (* const *)<Expression>;
<CaseSubrangeConstExpr> ::= <SubrangeConstExpr>;

<ElseOpt> ::? <Else>;
<Else> ::= 'ELSE' <FieldListSequence>;

<SetType> ::= 'SET' 'OF' <SimpleType>;

<PointerType> ::= 'POINTER' 'TO' <type>;

<ProcedureType> ::= 'PROCEDURE' <FormalTypeListOpt>;
<FormalTypeListOpt> ::? <FormalTypeList>;
<FormalTypeList> ::= '(' <FormalTypes> ')' <ReturnValueOpt>;
<FormalTypes> ::+ <FormalTypeOne> ',';
<FormalTypeOne> ::= <VarOpt> <FormalType>;
<ReturnValueOpt> ::? <ReturnValue>;
<ReturnValue> ::= ':' <QualIdent>;

<VariableDeclaration> ::= <IdentList> ':' <type>;

<designator> ::| <remote> | <indexed> | <pointer>;
<remote> ::= <QualIdent>;
<QualIdent> ::| <nameApl> | <RemoteIdent>;
<RemoteIdent> ::= <QualIdent> '.' <nameAppl>;
<indexed> ::= <designator> '[' <ExpList> ']';
<pointer> ::= <designator> '^';

<ExpList> ::+ <expression> ',';

<expression> ::| <SimpleExpr> | <RelationalExpr>;

<RelationalExpr> ::| <EqExpr> | <NeExpr> | <AltNeExpr> 
		   | <LtExpr> | <LeExpr> | <GtExpr> | <GeExpr> 
		   | <InExpr>;

<SimpleExpr> ::| <AddExpr> | <SignedTerm> | <Term>;

<AddExpr> ::| <PlusExpr> | <MinusExpr> | <OrExpr>;

<SignedTerm> ::| <UnaryPlusExpr> | <UnaryMinusExpr>;

<term> ::| <MulExpr> | <Factor>;

<MulExpr> ::| <TimesExpr> | <DivExpr> | <ModExpr> | <AndExpr>;

<EqExpr> ::= <Operand1:SimpleExpr> '=' <Operand2:SimpleExpr>;
<NeExpr> ::= <Operand1:SimpleExpr> '<>' <Operand2:SimpleExpr>;
<AltNeExpr> ::= <Operand1:SimpleExpr> '#' <Operand2:SimpleExpr>;
<LtExpr> ::= <Operand1:SimpleExpr> '<' <Operand2:SimpleExpr>;
<LeExpr> ::= <Operand1:SimpleExpr> '<=' <Operand2:SimpleExpr>;
<GtExpr> ::= <Operand1:SimpleExpr> '>' <Operand2:SimpleExpr>;
<GeExpr> ::= <Operand1:SimpleExpr> '>=' <Operand2:SimpleExpr>;
<InExpr> ::= <Operand1:SimpleExpr> 'IN' <Operand2:SimpleExpr>;

<PlusExpr>  ::= <SimpleExpr> '+' <Term>;
<MinusExpr> ::= <SimpleExpr> '-' <Term>;
<OrExpr>    ::= <SimpleExpr> 'OR' <Term>;

<UnaryPlusExpr> ::= '+' <Term>;
<UnaryMinusExpr> ::= '-' <Term>;

<DivExpr> ::| <IntegerDivExpr> | <RealDivExpr>;
<TimesExpr>      ::= <Term> '*' <Factor>;
<IntegerDivExpr> ::= <Term> 'DIV' <Factor>;
<RealDivExpr>    ::= <Term> '/' <Factor>;
<ModExpr>        ::= <Term> 'MOD' <Factor>;
<AndExpr>        ::= <Term> <AndSign> <Factor>;

<AndSign> ::| <NormalAndSign> | <AltAndSign>;
<NormalAndSign> ::= 'AND';
<AltAndSign> ::= '&';

<Factor> ::| <number> | <Str> | <Set> | <DesignatorOpt>
	   | <BracketedExpression> | <NotFactor>;

<DesignatorOpt> ::= <designator> <ActualParametersOpt>;
<ActualParametersOpt> ::? <ActualParameters>;
<ActualParameters> ::= '(' <ExpListOpt> ')';
<ExplistOpt> ::? <ExpList>;

<BracketedExpression> ::= '(' <Expression> ')';

<NotFactor> ::= 'NOT' <factor>;

<statement> ::| <Assignment> | <ProcedureCall> | <IfStatement>
	      | <CaseStatement> | <WhileStateMent> | <RepeatStatement>
	      | <LoopStatement> | <ForStatement> | <WithStatement>
	      | <ExitStatement> | <ReturnStatement>;

<assignment> ::= <designator> ':=' <expression>;

<ProcedureCall> ::= <DesignatorOpt>;

<StatementSequence> ::+ <StatementOpt> ';';
<StatementOpt> ::? <statement>;

<IfStatement> ::= 'IF' <expression> 'THEN' 
		  <StatementSequence>
		  <ElsifPartOpt> <ElsePartOpt> 'END';
<ElsifPartOpt> ::? <ElsifPart>;
<ElsifPart> ::= 'ELSIF' <expression> 'THEN' <StatementSequence>;
<ElsePartOpt> ::? <ElsePart>;
<ElsePart> ::= 'ELSE' <StatementSequence>;

<CaseStatement> ::= 'CASE' <expression> 'OF' 
		    <CaseList> 
		    <ElsePartOpt> 'END';
<CaseList> ::+ <case> '|';
<case> ::= <CaseLabelList> ':' <StatementSequence>;

<WhileStatement> ::= 'WHILE' <expression> 'DO' <StatementSequence> 'END';

<RepeatStatement> ::= 'REPEAT' <StatementSequence> 'UNTIL' <expression>;

<ForStatement> ::= 'FOR' <nameAppl> ':=' <expression> 'TO' <expression>
		   <ByExpressionOpt> 'DO' <StatementSequence> 'END';
<ByExpressionOpt> ::? <ByExpression>;
<ByExpression> ::= 'BY'(* const *) <Expression>;

<LoopStatement> ::= 'LOOP' <StatementSequence> 'END';

<WithStatement> ::= 'WITH' <designator> 'DO' <StatementSequence> 'END';

<ExitStatement> ::= 'EXIT';

<ReturnStatement> ::= 'RETURN' <ExpressionOpt>;
<ExpressionOpt> ::? <expression>;

<ProcedureDeclaration> ::= <ProcedureHeading> <ProcedureBody> ';';
<ProcedureBody> ::= <block> 'END' <nameAppl>;
<ProcedureHeading> ::= 'PROCEDURE' <nameDecl> <FormalParametersOpt> ';'; 
<block> ::= <declarations> <statementsOpt>;
<statementsOpt> ::? <statements>;
<statements> ::= 'BEGIN' <StatementSequence>;

<declarations>::* <declaration>;
<declaration> ::| <ConstantDecl> | <TypeDecl> | <VariableDecl> 
		| <ProcedureDeclaration> | <ModuleDeclaration>; 

<ConstantDecl> ::= 'CONST' <ConstantDeclarations> ';';
<ConstantDeclarations>::+ <ConstantDeclarationOpt> ';';
<ConstantDeclarationOpt>::? <ConstantDeclaration>;

<TypeDecl> ::= 'TYPE' <TypeDeclarations> ';';
<TypeDeclarations>::+ <TypeDeclarationOpt> ';';
<TypeDeclarationOpt>::? <TypeDeclaration>;

<VariableDecl> ::= 'VAR' <VariableDeclarations> ';';
<VariableDeclarations>::+ <VariableDeclarationOpt> ';';
<VariableDeclarationOpt>::? <VariableDeclaration>;

<FormalParametersOpt> ::? <FormalParameters>;
<FormalParameters> ::= '(' <FPSections> ')' <QualOpt>;
<FPSections> ::+ <FPSectionOpt> ',';
<FPSectionOpt> ::? <FPSection>;
<FPSection> ::= <VarOpt> <IdentList> ':' <FormalType>;
<VarOpt> ::? <Var>;
<Var> ::= 'VAR';
<FormalType> ::= <ArrayOpt> <QualIdent>;
<ArrayOpt> ::? <Array>;
<Array> ::= 'ARRAY' 'OF';

<ModuleDeclaration> ::= 'MODULE' <nameDecl> <PriorityOpt> ';' <ModuleBody> ';';
<ModuleBody> ::= <imports> <ExportOpt> <block> 'END' <nameAppl>;
<PriorityOpt> ::? <priority>;
<priority> ::= '['(* const *) <Expression> ']';
<imports> ::* <import>;
<import> ::= <FromOpt> 'IMPORT' <IdentList> ';';
<FromOpt> ::? <From>;
<From> ::= 'FROM' <nameAppl>;
<ExportOpt> ::? <export>;
<export> ::= 'EXPORT' <QualifiedOpt> <IdentList> ';';
<QualifiedOpt> ::? <qualified>;
<qualified> ::= 'QUALIFIED'
