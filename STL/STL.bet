ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
Container: 
  (# Elm:< Object;
     iterator:<
       (# next:< (# inx: @iterator do inner exit inx[] #);
          val:< (# V: ^elm do inner exit V[] #);
          eq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
          neq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
       #);
     begin:< (# ix: ^iterator do inner exit ix[] #);
     end:< (# ix: ^iterator do inner exit ix[] #);
     insert:< (# V: ^elm enter V[] do inner #);
     scan:
       (# first,last: ^iterator;
          current: ^elm
       enter(first[],last[])
       do (if first[] = none then begin -> first[] if);
          (if last[] = none then end -> last[] if);
          L: (if (first[] -> last.neq) then
                 first.val -> current[];
                 INNER;
                 first.next -> first[];
                 restart L
             if)
       #);
     find:
       (# V,F: ^elm;
       enter V[]
       do L:            
            scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #);
     findInRange:
       (# V,F: ^elm;
          first,last: ^iterator;
       enter(first[],last[],V[])
       do L:            
            (first[],last[]) -> scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #)
  #);

list: container 
  (# 
     iterator:: 
       (# ix: @integer;
          next:: (# do ix + 1 -> inx.ix #);
          val:: (# do L[ix][] -> V[] #);
          eq:: (# do inx.val = L[ix][] -> value #);
          neq:: (# do inx.val <> L[ix][] -> value #);
       #);
     begin:: (# do &iterator[] -> ix[]; 1 ->ix.ix #);
     end:: (# do &iterator[] -> ix[]; top + 1 ->ix.ix #);

     insert::
       (# 
       do (if (top+1 -> top) > L.range then L.range -> L.extend if);
          V[] -> L[top][]
       #);
     L: [10] ^elm; top: @integer
  #);

---program:descriptor---
(# L: @ List(# elm:: text #);
   Marianne,Kirsten,Johanna,Lis: ^text;
   T: ^text;
do 'Mini STL '->putline;
   'Marianne' -> Marianne[] -> L.insert;
   'Kirsten' -> Kirsten[] -> L.insert;
   'Johanna' -> Johanna[] -> L.insert;
   'Lis' -> Lis[]; 
   L.scan(#do current[] -> putline #);
   (if (Kirsten[] -> L.find -> T[]) <> none then
       'Found: ' -> puttext; 
       T[] -> putline;
    else
       'Did not find: ' -> puttext;
       Kirsten[] -> putline;
   if);

   (if (Lis[] -> L.find -> T[]) <> none then
       'Found: ' -> puttext;  T[] -> putline;
    else
       'Did not find: ' -> puttext; Lis[] -> putline;
   if);
   (if ((L.begin,L.end,Marianne[]) -> L.findInRange -> T[]) <> none then
       'Found: ' -> puttext;  T[] -> putline;
   if);
#)

