ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
Container: 
  (# Elm:< Object;
     iterator:<
       (# next:< (# inx: @iterator do inner exit inx[] #);
          val:< (# V: ^elm do inner exit V[] #);
          eq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
          neq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
       #);
     begin:< (# ix: ^iterator do inner exit ix[] #);
     end:< (# ix: ^iterator do inner exit ix[] #);
     insert:< (# V: ^elm enter V[] do inner #);
     scan:
       (# first,last: ^iterator;
          current: ^elm
       enter(first[],last[])
       do (if first[] = none then begin -> first[] if);
          (if last[] = none then end -> last[] if);
          L: (if (first[] -> last.neq) then
                 first.val -> current[];
                 INNER;
                 first.next -> first[];
                 restart L
             if)
       #);
     find:
       (# V,F: ^elm;
       enter V[]
       do L:            
            scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #);
     findF:
       (# V,F: ^elm;
          first,last: ^iterator;
       enter(first[],last[],V[])
       do L:            
            (first[],last[]) -> scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #)
  #);

list: container 
  (# 
     iterator:: 
       (# ix: @integer;
          next:: (# do ix + 1 -> inx.ix #);
          val:: (# do L[ix][] -> V[] #);
          eq:: (# do inx.val = L[ix][] -> value #);
          neq:: (# do inx.val <> L[ix][] -> value #);
       #);
     begin:: (# do &iterator[] -> ix[]; 1 ->ix.ix #);
     end:: (# do &iterator[] -> ix[]; top + 1 ->ix.ix #);

     insert::
       (# do (if (top+1 -> top) > L.range then L.range -> L.extend if);
          V[] -> L[top][]
       #);
     L: [10] ^elm; top: @integer
  #);

---program:descriptor---
(# L: @ List(# elm:: text #);
   T1,T2,T3,T4: @text;
   T: ^text;
   I: @ IntegerObject
do 'STL'->putline;
   'Marianne' -> T1; T1[] -> L.insert;
   'Marlene' -> T2; T2[] -> L.insert;
   'Surayaa' -> T3; T3[] -> L.insert;
   'Anne' -> T4; 
   L.scan(#do current[] -> putline #);
   (if (T2[] -> L.find -> T[]) <> none then
       'Found: ' -> puttext; 
       T[] -> putline;
    else
       'Did not find: ' -> puttext;
       T2[] -> putline;
   if);

   (if (T4[] -> L.find -> T[]) <> none then
       'Found: ' -> puttext;  T[] -> putline;
    else
       'Did not find: ' -> puttext; T4[] -> putline;
   if);
   (if ((L.begin,L.end,T1[]) -> L.findF -> T[]) <> none then
       'Found: ' -> puttext;  T[] -> putline;
   if);
   7 -> I;
   I -> putint
#)

