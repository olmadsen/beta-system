ORIGIN '~beta/basiclib/betaenv';
---lib:attributes---
Container: 
  (# Elm:< Object;
     iterator:<
       (# next:< (# inx: @iterator do inner exit inx[] #);
          pred:< (# inx: @iterator do inner exit inx[] #);
          val:< (# V: ^elm do inner exit V[] #);
          eq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
          neq:< booleanValue(# inx: ^iterator enter inx[] do inner #);
       #);
     begin:< (# inx: ^iterator do inner exit inx[] #);
     end:< (# inx: ^iterator do inner exit inx[] #);
     insert:< (# V: ^elm enter V[] do inner #);
     greater:< BooleanValue
       (# left,right: ^elm
       enter(left[],right[])
       do inner
       #);
     swap:<
       (# A,B: ^Iterator
       enter(A[],B[])
       do inner
       #);
     scan:
       (# first,last,currentIt: ^iterator;
          current: ^elm
       enter(first[],last[])
       do (if first[] = none then begin -> first[] if);
          (if last[] = none then end -> last[] if);
          L: (if (first[] -> last.neq) then
                 first.val -> current[];
                 first[] -> currentIt[];
                 INNER;
                 first.next -> first[];
                 restart L
             if)
       #);
     find:
       (# V,F: ^elm;
       enter V[]
       do L:            
            scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #);
     findInRange:
       (# V,F: ^elm;
          first,last: ^iterator;
       enter(first[],last[],V[])
       do L:            
            (first[],last[]) -> scan
            (# 
            do (if V[] = current[] then 
                   current[] -> F[];
                   leave L
               if)
            #)
       exit F[]
       #)
  #);

list: container 
  (#  iterator:: 
       (# ix: @integer;
          next:: (# do ix + 1 -> inx.ix #);
          pred:: (# do ix - 1 -> inx.ix #);
          val:: (# do L[ix][] -> V[] #);
          eq:: (# do inx.val = L[ix][] -> value #);
          neq:: (# do inx.val <> L[ix][] -> value #);
       #);
     begin:: (# do &iterator[] -> inx[]; 1 ->inx.ix #);
     end:: (# do &iterator[] -> inx[]; top + 1 ->inx.ix #);
     swap::
       (# E: ^elm
       do A.val -> E[]; B.val -> L[A.ix][]; E[] -> L[B.ix][]
       #);
     insert::
       (# 
       do (if (top+1 -> top) > L.range then L.range -> L.extend if);
          V[] -> L[top][]
       #);
     L: [10] ^elm; top: @integer
  #);


