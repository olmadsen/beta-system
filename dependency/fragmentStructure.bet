ORIGIN  '~beta/dependency/v1.1/dependency';
---program:descriptor---
(# AST: @ astinterface;
   D: @AST.dependencyGraph;
   FileName: ^text;
   visible:
     (* checks if a property value is one of the reserved properties, like
      * ORIGIN, BODY, etc.
      * If this is true, a warning is generated.
      * n is assumed to be in lower case.
      *)
     (#  n: ^text; b: @boolean
     enter n[]
     do (* n is assumed to be lowercase *)
        (if true
         // 'origin'->n.equal // 'body'->n.equal // 'mdbody'->n.equal
         // 'include'->n.equal
         // 'objfile'->n.equal // 'libfile'->n.equal // 'linkopt'->n.equal 
         // 'betarun'->n.equal // 'make'->n.equal // 'fswitch'->n.equal 
         // 'on'->n.equal // 'off'->n.equal // 'nolink' ->n.equal
            then
            true -> b
         // 'donecheck'->n.equal // 'slots' -> n.equal 
         // 'unique_group_id' -> n.equal then
            special or all -> b
         else all->b
        if)
     exit b
     #);
   oneValPrLine:
     (# n: ^text; b: @boolean
     enter n[]
     do (if true
         // 'body'->n.equal // 'include'->n.equal then 
            true -> b
        if)
     exit b
     #);
   printUsage:
     (#
     do  'Usage: fragmentStructure [options] file\n'->puttext;
        '\tfile:\t\tname of fragment for which to show structure\n'->puttext;
        '\nLegal options are:\n'->puttext;
        '\t--all:\t\tall properties inclucing internal ones are shown\n'
          ->puttext;
        '\t\t\tthis option may show properties with binary values\n'->puttext;
        '\t--special\tspecial compiler properties:\n'->puttext;
        '\t\t\tdonecheck, slots and unique_group_id are shown\n'->putline;
        stop
     #);
   t: ^text;
   all,special: @boolean
do AST.astLevelInit;
   (*(ast.trace.onParse,true)->ast.trace.set;
   (ast.trace.fragmentOpen,true)->ast.trace.set;
    (ast.trace.topOpen,true)->ast.trace.set;*)
   D.Init;
   'sun4s'->D.targetDirectory;
   'sun4s'->D.targetMachine;
   D.xverboselevel.nothing -> D.xverboselevel;
   
   (if noOfArguments > 1 then
       (for i: noOfArguments-2 repeat
            i+1 -> arguments -> t[];
            (if true
             // '--all'->t.equal then true->all
             // '--special'->t.equal then true->special
             else 
                printUsage
            if)
       for);
       noOfArguments -> arguments -> Filename[]
    else printUsage
   if);
   
   'Fragment structure for : ' -> puttext; FileName[] -> putline;
   FileName[] -> D.scanExtent
   (# 
   do newline; newline;
      (for i: (current.fullname).length repeat '-'->put for);
      newline;
      current.fullname->puttext; 
      newline;
      (for i: (current.fullname).length repeat '-'->put for);
      
      current.prop.scanprop
      (# doNl,first: @boolean; 
         doProp::
           (# Nl:
                (#
                do (if doNL and not first then 
                       newline; 
                       (for i: prop.length repeat ' '->put for);
                   if);
                   ' '->put;
                   false -> first;
                #)
           do prop.makeLC;
              (if prop[] -> visible then 
                  true->first; prop[] -> oneValPrLine ->doNl;
                  newline;
                  prop.makeUC;
                  prop[] -> puttext; 
                  scanParameters
                  (# doString::
                       (#do NL; ''''->put; s[]->puttext; ''''->put #);
                     doName::
                       (#
                       do true -> doNl;
                          NL;
                          false->doNl;
                          n[] -> puttext 
                       #);
                     doConst::(#do ' ' ->put; c->putint #)
                  #)
   if)#)#)#); 
   newline;
#)
