ORIGIN '../dependency';
INCLUDE 'misk';
BODY 'controlbody';
MDBODY mac     'control_macbody'
       nti     'control_ntbody'
       ppc     'control_ppcbody'
       default 'control_unixbody';
(* The controller controls calling of AST-interface, checker, codegenerator,
 *  assembly and linking.
 *
 * switch[381-400]
 * 381: trace groupList
 * 382: use groupList when re-doing same translation.
 * 383: trace bodylist complete
 * 384: trace grouplist scan when re-translating
 * 385: trace doneExamine
 * 387: trace read properties
 * 388: dump groupList
 * 389: make modtime test
 * 390: Use new MakeFile handling
 * 392: trace local switches
 * 393: make slow file modtime check
 * 394: trace LIBRARY handling
 * 395: DO not translate, just build graph
 * 396: trace real/compact open
 * 397: Trace Buildgraph
 * 398: Trace translate
 * 399: Force Make (used with new makefile handling)
 *)
--xDependencyGraphPrivate: descriptor--
(# theController: ^controller;
   groupList: @Hashtable
     (# element::
          (# name: ^Text; (* to calc. the hash value *)
             g: ^FragmentGroup;
          #);
        dummy: @Element;
        hashFunction::
          (# inx: @Integer;
          do L: (for i: 7 repeat
	             e.name.lgth-i+1 -> inx;
                     (if inx < 1  then leave L if);
                     e.name.T[inx]+value->value;
          for)#);
        equal::< (# do left.name[] -> right.name.equal -> value #);
        rangeInitial::< (# do 117 -> value #);
        deleteGroup:
          (# fullname: ^Text;
             e: ^Element;
          enter fullname[]
          do fullName[] -> dummy.name[];
             dummy[] -> hashfunction -> findIndexed
             (# predicate::< (# do fullname[] -> current.name.equal -> value #);
             do current[] ->e[];
             #);
             (if e[]<>NONE then e[] -> delete if);
          #);
        insertGroup:
          (# g: ^FragmentGroup;
             name,path,ext: ^Text;
             e: ^Element;
             fullname: ^Text;
          enter(name[],path[])
          do (name.length-3,name.length)->name.sub->ext[];
             (if '.bet'->ext.equal then
                 (name.length-3,name.length)->name.delete
             if);

             (name[],path[]->theController.filenamestripper)->thePathHandler.convertFilePath
              ->fullname[];
             (if theController.switch[381] then
                 'insertGroup: '->screen.puttext; fullname[]->screen.putline
             if);
             fullname[]->dummy.name[];
             dummy[]->hashfunction->findIndexed
             (# predicate:: (# do fullname[]->current.name.equal->value #);
             do current[] ->e[];
             #);
             (if e[]//NONE then (* group not in list *)
                 (if theController.switch[381] then
                     'Not in list'->screen.putline;
                 if);
                 (fullname[],name[])->theController.ASTOpen->g[];
		 NONE->g.origin; (* clear; users of this lib may have set it *)
                 &element[]->e[];
                 g.NameT[]->e.name[];
                 name[]->g.controller.printName[];
                 g[]->e.g[];
                 theController.isOpen->g.controller.status;
                 e[]->insert;
              else
                 e.g[]->g[];
                 (if g.controller.status<=theController.justOpen then
                     (* we have a fragmentgroup in the list which is re-initialized.
                      * It could have changed on disk:
                      *)
                     (# t: @ text;
                        m: @integer;
                     do (if theController.switch[381] then
                            'Group is re-initialized check diskfiles: '->screen.puttext
                        if);
                        g.nameT->t;
			'.bet'->t.append;
			t[]->theController.getmodtime->m;
                        (if theController.switch[381] then
                            t[]->screen.puttext;
                            m->screen.putint; ' '->screen.put;
                            g.modtime->screen.putint; screen.newline;
                        if);
                        (if m>g.modtime then
                            g.close;
                            NONE->g[];
                            (fullname[],name[])->theController.ASTOpen->g[];

e.g.controller.printname[]->g.controller.printname[];
                            g[]->e.g[];
                         else
                            g.nameT->t;
	                    astFileExtension->t.append;
                            (* checking the group file *)
			    t[]->theController.getmodTime->m;
                            (if m>g.modTime  then
                                g.checkDiskRepresentation
                     if)if)#);
                     theController.isOpen->g.controller.status;
                  else
                     (if theController.switch[381] then
                         'Status is: '->screen.puttext;
                         g.controller.status->screen.putint; screen.newline;
                     if);
                 if);
             if);
             NONE->dummy.name[];
          exit g[]
          #);
        findGroup:
          (# fullname: ^Text;
             g: ^FragmentGroup;
          enter fullname[]
          do fullname[]->dummy.name[];
             dummy[]->hashfunction->findIndexed
             (# predicate::< (# do fullname[]->current.name.equal->value #);
             do current.g[]->g[];
             #);
             NONE->dummy.name[];
          exit g[]
          #);
        TryToGC:
          (#  e: ^Element;
          enter e[]
          <<SLOT xTryToGC: dopart>>
          #);
     #);

#)

--xDependencyGraphLib: attributes--
controller:
(#
   (* The different kinds of files that can be put into the job file *)
   BetaRun,  (* file-name for BETA run-time system *)
   ObjName:  (* file-name for object program *) ^Text;
   NoLink: @boolean; (* true ==> do not generate link directive *)
   b2c: @boolean;
   BetaEnvKind: (# exit 1 #);
   BetaKind: (# exit 2 #);
   ObjKind:  (# exit 3 #);
   LibKind:  (# exit 4 #);
   MakeKind: (# exit 5 #);
   LinkOptKind:  (# exit 6 #); (* KJM *)
   ResourceKind: (# exit 7 #); (* KJM *)

   filenamestripper: @stripPathName;
   switch: [500]@boolean;
   fragmentError:
     (* to be called when errors in fragment structure.
      * - close the fragmentgroup and remove it from the groupList
      *)
     (# theGroup: ^FragmentGroup
     enter theGroup[] <<SLOT xfragmentError:dopart>>
     #);
   getmodtime: @
     (# t: ^Text;
        m: @integer;
        doit: @<<SLOT xgetmodtimebody: descriptor>>;
     enter t[]
     do doit;
     exit m
     #);
   ScanProperties:
     (# theGroup, next: ^FragmentGroup
     enter theGroup[]
     do <<SLOT xScanProperties:descriptor>>
     #);
   AstOpen:
     (# fullname,localname: ^Text; g: ^FragmentGroup
     enter (fullname[],localname[])
     do <<SLOT xAstOpen:descriptor>>
     exit g[]
     #);
   CreateAsmFileName:
     (# g: ^FragmentGroup; T: ^text
     enter g[]
     do (g.NameT.copy,true)->InsertSubDir(#do AsmExt->path.append #)
          ->T[]
     exit T[]
     #);
   CreateObjFileName:
     (# g: ^FragmentGroup; T: ^text
     enter g[]
     do (g.NameT.copy,false)->InsertSubDir(# do BinExt->path.append #)
          ->T[]
     exit T[]
     #);
   CreateLibFileName:
     (# g: ^FragmentGroup; T: ^text
     enter g[]
     do (g.NameT.copy,false)->InsertSubDir(#do LibExt->path.append #)
          ->T[]
     exit T[]
     #);
   CreateLstFileName:
     (# g: ^FragmentGroup; t: ^Text;
     enter g[]
     do LstExt -> g.NameT.copyappend -> t[];
     exit t[]
     #);
   checkCodeSubDir:
     (* Checks whether or not the code sub directory denoted by
      targetDirectory has already been created. If not then
      it is created now !
      *)
     (# g: ^FragmentGroup; asmDir: @boolean
     enter(g[],asmDir)
     do <<SLOT xCheckCodeSubDir: descriptor>>
     #);
   cleanUpAfterException:
     (* Called by all exception handlers in this fragment (./control)
      in order to allow some notion of cleaning up when control is
      transferred upwards to the compiler interface.
      *)
     (#
     do ASTVal -> doRealOpen;
        true -> lastTransWasReal;
        (* Should be part of the AST cleanup instead ! *)
        NONE->theCatcher[];
     #);
   buildGraph:
     (# theGroup,next: ^FragmentGroup;
     enter theGroup[]
     do
        (if switch[397] then
            'Build: '->screen.puttext; thegroup.name -> screen.puttext;
            ' '->screen.put;
            theGroup.controller.status->screen.putint; screen.newline;
        if);
        (if true
         // (theGroup.controller.status=beingExamined) then
            screen.newline; 'Fragment: ' -> screen.puttext;
            theGroup[] -> printFN;
            ' reached twice in dependency analysis' -> screen.putline;
            (*12 -> Msg; (* circularity in fragment structure *)
         // (theGroup.controller.status>beingExamined) then
            (* skip fragmentgroup; it is done *)
         else
            theGroup[] -> examineGroup;
            theGroup[] -> scanProperties;
            (* origin, body, mdbody, and externals *)
            theGroup.fragmentList.scan (* scan links *)
            (#
            do (if current.type
                // linkType then
                   (if current.name.length=0 then
                       '\n*** Error in property list of:\n\t'->screen.puttext;
                       theGroup.name->screen.puttext; '\n\n\t'->screen.puttext;
                       'Empty filename in property "INCLUDE"\n'->screen.puttext;
                       theGroup[]->fragmentError;
                    else
                       (current.Name[],theGroup.name)
                         -> DependencyGraphPrivate.groupList.insertGroup -> next[];
                       (if next.controller.status<doneTranslate then
                           next[] -> &buildGraph;
                       if);
                       (theGroup[],next[]) -> setGroupTime;
                   if);
                // formType then true->nonEmpty; (* 'form'->putline *)
                   (if 'program'->current.name.equalNCS then
                       (* 'PROGRAM SLOT found in file: '->screen.puttext;
                       theGroup.fullname->screen.putline;*)
                       true->hasProgramSlot
                   if);
               if)
            #);
            theGroup[] -> doneExamineGroup;
     if)#);
   printFN:
     (# g: ^FragmentGroup;
     enter g[]
     do ''''->screen.put;
        (if switch[35] then
            g.nameT[] -> screen.puttext;
         else
            g.controller.printname[] -> screen.puttext;
        if);
        ''''->screen.put;
     #);

   (* FragmentGroup controller.status *)
   doParse: (# exit 8 #);
   doCheck: (# exit 7 #);
   doCodeGen: (# exit 6 #);
   doAsm: (# exit 5 #);
   doNothing: (# exit 4 #);
   doneTranslate: (# exit 3 #);
   beingExamined: (# exit 2 #);
   isOpen: (# exit 1 #);    (* marked as open and in the list of fragments *)
   justOpen: (# exit 0 #);  (* initial value; open for the first time *)
   (* negative values means that the FragmentGroup is not used in last graphs
    * and could be GCed
    *)
   examineGroup:
     (# g: ^FragmentGroup;
     enter g[]
     do  beingExamined->g.controller.status;
        (* initialize ancestorGroupTime *)
        g.modtime->g.controller.ancestorTime;

(*(THIS(astlevel)[],g[])->getDoneCheckProperty->g.controller.ancestorsChecked;*)
     #);
   doneExamineGroup:
     (# g: ^FragmentGroup;
        groupT,asmT,objT: @Integer;
        doAsm,inLib: @Boolean;
     enter g[]
     do doNothing->g.controller.status;
        g[]->TransList.insert;
        (if g.origin//none then (* betaenv *)
            g.NameT[]->currentProperty
         else
            g.NameT[]->currentProperty
        if);
     #);
   SetGroupTime:
     (# g,ancestor: ^FragmentGroup;
     enter (g[],ancestor[])
     do (ancestor.controller.ancestorTime,g.controller.ancestorTime)
	 ->&Max->g.controller.ancestorTime;
        (if ancestor.controller.ancestorsChecked // false then
	    false->g.controller.ancestorsChecked;
        if);
     #);
   SimpleList:
     (# S: [100] ^FragmentGroup; top: @integer;
        ScanAndClear:
          (# inx: @integer; isEmpty: @boolean; current: ^FragmentGroup
          do true->isEmpty;
             (for i: top repeat
                  i->inx;
                  (if S[inx][] // NONE then (*skip *)
                   else
                      S[inx][]->current[];
                      INNER;
                      NONE->S[inx][];
                      false->isEmpty;
                  if)
             for)
          exit isEmpty
          #);
        init: (# do 0->top #);
     #);
   BodyList: @SimpleList
     (#
        insert:
          (# g: ^FragmentGroup
          enter g[]
          do (if g.controller.status<=isOpen  then
                 (* the fragment is open but not handled, yet *)
                 (if ((top+1->top)>S.range)  then
                     s.range->S.extend;
                 if);
                 g[]->S[top][];
             if);
          #);
        Complete: ScanAndClear
          (#
          do (if switch[383] then 'Completing BodyList'->screen.putline if);
             current[]->&buildGraph;
          #);
     #);
   TransList: @SimpleList
     (# insert:
          (# g: ^FragmentGroup
          enter g[]
          do (if ((top+1->top)>S.range)  then
                 s.range->S.extend;
             if);
             g[]->S[top][];
	     true->lastTransWasReal;
          #);
     #);
   Translate:<
     (# g: ^FragmentGroup;
     enter g[]
     do (if switch[398] then
            'Translate: '->screen.puttext; g[]->printFN;
            screen.newline;
        if);
        (if g.controller.status>doneTranslate then
            (if g.origin<>NONE // true then
                g.origin->&Translate;
            if);
            g[]->ScanLinks
            (#
            do (current.name,g.nameT[]->filenamestripper)
                ->thePathHandler.convertFilePath
                ->DependencyGraphPrivate.grouplist.findgroup->current.f[]
                ->&Translate;
            #);
	    INNER;
            doneTranslate->g.controller.status;
        if);
     #); (* translate *)
  currentProperty:<
    (# name: ^Text;
    enter name[]
    do INNER
    #);
  doDomain:< BooleanValue;

   lastTransWasReal, (* used by fragment GC *)
   ASTval: @boolean;
   lastRootFragment: ^Text;
   nonEmpty,      (* used to catch empty fragments *)
   binaryCodeGen: @Boolean;
   hasProgramSlot: @boolean;
   rootFragment: ^Text;

<<SLOT xcontrolBody:doPart>>
#)

--xscanExtentDoPart: descriptor--
(# thiscontroller: controller
     (# translate:: (# do g[]->current[]; INNER scanExtent #);
        currentProperty:: (# do name[]->propertyFile #);
     do root[]-> rootFragment[];
        THIS(thiscontroller)[]->DependencyGraphPrivate.theController[];
     #);
do thiscontroller;
#)
--xscanDomainDoPart: descriptor--
(# thiscontroller: controller
     (# translate:: (# do g[]->current[]; INNER scanDomain #);
	doDomain:: (# do true->value #);
     do root[]-> rootFragment[];
        THIS(thiscontroller)[]->DependencyGraphPrivate.theController[];
     #);
do thiscontroller;
#)
