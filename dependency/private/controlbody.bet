ORIGIN 'dependencyBody';
INCLUDE '~beta/basiclib/v1.6/betaenvold';
INCLUDE '~beta/betaast/v5.2/donecheck';
INCLUDE '~beta/containers/v1.6/list';
INCLUDE 'findString';
(*BODY 'heapanalyzis'*)
--scanProperties:descriptor--
(# PropError:
     (# p,t: ^text; n: @integer; warning: @boolean;
     enter(p[],t[], n)
     do (theGroup[],p[],t[],n,CloseGroup(#do theGroup[] -> g[]#)) 
          -> PropertyException
     #);
   CheckPropValue:
     (* checks if a property value is one of the reserved properties, like
      * ORIGIN, BODY, etc.
      * If this is true, a warning is generated.
      * n is assumed to be in lower case.
      *)
     (#  p,n: ^text 
     enter(p[],n[])
     do (* n is assumed to be lowercase *)
        (if true
         // 'origin'->n.equal // 'body'->n.equal // 'mdbody'->n.equal
         // 'build' -> n.equal 
         // 'objfile'->n.equal // 'libfile'->n.equal // 'linkopt'->n.equal 
         // 'betarun'->n.equal // 'make'->n.equal // 'fswitch'->n.equal 
         // 'on'->n.equal // 'off'->n.equal // 'nolink' ->n.equal
         // 'donecheck'->n.equal 
         // 'slots' -> n.equal 
         // 'frejamark' -> n.equal then 
            (p[],n[],2)->PropError
        if)
     #);
   originSetHere: @boolean (* code using this var. is made by ESS;
                            * is needed to handle situations where other tools
                            * like the debugger may already have setup origin
                            *)
do false -> originSetHere; 
   theGroup.prop.ScanProp
   (# doProp::<
        (# betaRunProp,libFileProp,makeProp,resProp,linkOptProp,
           objFileProp,MDBodyProp: @boolean 
        do prop.makelc; 
           (*'scanprop:'->puttext; prop[]->putline;*)
           (if true 
            // 'origin' -> prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::<
                    (# 
                    do 15->xtrace
                       (#do ' group:'->xT; theGroup.nameT[]->xT;
                          '\n\torigin:'->xT; S[]->xT; xN
                       #);
                       (if originSetHere (*theGroup.origin<>NONE*) then 
                           (none,s[],1)->PropError 
                       if);
                       (if s.length=0 then
                           (* empty file name: '' *)
                           ('origin',theGroup.fullname,4)->propError;
                        else
                           (s[],theGroup.nameT[]) 
                             -> OpenGroup
                             -> next[] 
                             -> theGroup.origin;
                           true -> originSetHere;
                           (if next.controller.status < doneTranslate then
                               next[] -> &buildGraph
                           if);
                           (theGroup[],next[]) -> setGroupTime;
                       if);
                    #);
                  doName:: (#do ('origin',n[],3)->propError #);
               #);
            // 'body'->prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::
                    (#
                    do (if s.length=0 then
                           (* empty file name: '' *)
                           ('body',theGroup.fullname,4)->propError;
                        else
                           (s[],theGroup.nameT[])
                             -> OpenGroup
                             -> next[];
                           (if next.controller.status < doneTranslate then
                               next[] -> private.bodyList.insert
                           if);
                       if)
                    #);
                  doName:: (#do ('body',n[],3)->propError #)
               #);
            // 'build' -> prop.equal  then
               (# buildArgs: @ containerList (* mps has a list pattern *)
                    (# element ::
                         (# machineId: ^text;
                            mArgs: [3] ^text; top: @integer
                         #);
                       add: @
                         (# machineId: ^text;
                            e: ^element
                         enter machineId[]
                         do &element[] -> e[];
                            machineId[] -> e.machineId[];
                            e[] -> append;
                            e[] -> current[]
                         #);
                       current: ^element;
                       addMarg: @
                         (# ma: ^text
                         enter ma[]
                         do (if (current.top + 1 -> current.top) 
                                > current.mArgs.range
                                then
                                current.mArgs.range -> current.mArgs.extend
                            if);
                            ma.copy -> current.mArgs[current.top][]
                         #);
                       findThisTarget: 
                         (# default,pre,thiss: [3] ^element;
                            dTop,pTop,tTop: @integer;
                            preMatch: 
                              (# t: ^text; b: @boolean
                              enter t[]
                              do
                              exit b
                              #);
                            current: ^ element;
                         do scan
                            (#
                            do (if true 
                                // targetMachine[] -> current.machineId.equal 
                                   then 
                                   (if (tTop+1->tTop) > thiss.range then
                                       thiss.range -> thiss.extend
                                   if);
                                   current[] -> thiss[tTop][] (* exact match *)
                                // defaultId[] -> current.machineId.equal then
                                   (if (dTop+1->dTop) > default.range then
                                       default.range -> default.extend
                                   if);
                                   current[] -> default[dTop][]
                                // current.machineId[] -> preMatch then
                                   (if (pTop+1->pTop) > pre.range then
                                       pre.range ->pre.extend
                                   if);
                                   current[] -> pre[pTop][]
                            if)#);
                            (if tTop > 0 then 
                                (for i: tTop repeat
                                     thiss[i][]-> current[];
                                     INNER
                                for)
                             else (* no exact match *)
                                (if pTop > 0  then
                                    (for i: pTop repeat 
                                         pre[i][] -> current[];
                                         INNER
                                    for);
                                 else
                                    (if dTop > 0 then
                                        (for i: dTop repeat
                                             default[i][] -> current[];
                                             INNER
                                        for);
                                     else
                                        (prop[],targetMachine[],6)->PropError
                            if)if)if)
                         #);                            
                       display:
                         (#
                         do 20->xtrace
                            (#
                            do 'Building' -> xT;
                               scan(#do current.machineId[] -> xT; 
                                      (for i: current.top repeat
                                        ' ' -> xC;
                                           current.mArgs[i][] -> xT;
                                      for);
                                      xN
                         #)#)#);
                       check:
                         (# e: ^element; arg: @text; T: ^text;
                            m,m2: @integer; exeCommand: @boolean
                         enter e[]
                         do (if (e.top = 0) or (e.top = 2) then
                                (prop[],targetMachine[],7) -> PropError
                             else
                                (* we MUST save objfile before replacing '/' by ':' 
                                 * on MAc's below, since the pathhandler otherwise will
                                 * NOT expand objfile to a full path! Yak:-(
                                 *)
                                e.mArgs[1].copy                                 

                                  -> expandMacro2
                                  -> objFile[]
                                  -> EgetModTime -> (m,T[]);
                                
                                (for ix: e.top - 1 repeat 
                                     (* replace '/' on mac-platforms by ':'; 
                                      * the following has no effect for platforms with
                                      * directoryChar = '/'
                                      *)
                                     e.mArgs[ix][] -> t[]; 
                                     '/' -> t.findall(#do (thePathHandler.directoryChar,inx) -> t.inxPut #);
                                     t[] -> e.mArgs[ix][]
                                for);

                                (if m = -1 then
                                    true -> exeCommand
                                 else
                                    (for i: e.top - 2 repeat
                                         e.mArgs[1 + i][] 
                                           -> T[] 
                                           -> EgetModTime 
                                           -> (m2,T[]);
                                         T[] -> isFile;
                                         (if (m < m2) or (m2 = -1) then
                                             (* if m2 = -1 then T is NOT
                                              * existing, i.e. the command
                                              * cannot be executed; the command
                                              * is, however, marked for execution
                                              * anyway, since it may be created
                                              * later, and a possible job-file
                                              * may then be ok
                                              *)
                                             true -> exeCommand
                                         if)
                                    for)
                                if)
                            if);
                         exit exeCommand
                         #);
                       EgetModTime:
                         (# t: ^text; m: @integer
                         enter t[]
                         do (t[],theGroup.nameT[] -> stripPathName) 
                              -> thePathHandler.convertFilePath
                              -> t[];
                            t[] -> getModTime -> m;
                            20->xTrace
                            (#do 'EgetModTime: '->xT; T[] -> xT;
                               '\nmodtime: '->xT; m->xI; xN
                            #);
                         exit(m,t[])
                         #);
                       expandCommand:
                         (# e: ^element; arg: @text; T: ^text; 
                            lastSlash,argNo: @integer
                         enter e[]
                         do e.mArgs[e.top][] -> t[]; (* the command *)
                            
                            (* First we expand args $0,$1, $2, ...;
                             * args must be expanded before $$, since args
                             * may contain $$.
                             * Expansion is made backwards
                             *    ..., $2, $1, $0
                             * since the algoritm belwo may othwervise
                             * replace e.g. $1 in $11
                             *)
                            (for ix: e.top - 1 repeat
                                 arg.clear;
                                 '$'->arg.put;
                                 e.top - ix - 1 -> argNo -> arg.putint;
                                 20->xTrace
                                 (#do 'Find:'->xT; arg[]->xT; '  '->xT #);
                                 findArg:
                                   arg[] -> T.findString
                                 (#
                                 do (inx,inx+(argNo div 10 + 1)) -> T.delete;
                                    (e.mArgs[argNo + 1][],inx) -> T.insert;
                                    20->xTrace
                                    (#do 'Replace:'->xT; 
                                       e.mArgs[argNo + 1][] -> xT; '  '->xT;
                                       T[] -> xT; xN
                                    #); 
                                    restart findArg (* same arguent may appear
                                                     * several times
                                                     *)
                                 #);
                            for);
                            
                            (* replace double $$ by targetDirectory *)
                            T[] -> ExpandMacro2 -> T[];
                            20->xTrace
                            (#do 'Expanded command: '->xT; T[] -> xT; xN #);
                            (theGroup.nameT[],thePathHandler.currentDirectory)
                              -> thePathHandler. convertFilePath
                              -> directory[];
                            20->xTrace(#do 'dir1:'->xT; directory[]->xT; xN #);
                            thePathHandler.directoryChar
                              ->directory.findCh(#do inx -> lastSlash #);
                            (if lastSlash > 0 then
                                (1,lastSlash) -> directory.sub -> directory[]
                            if);
                            20->xTrace(#do 'dir1:'->xT; 
                                         (if directory[] <> NONE then 
                                             directory[] -> xT 
                                         if); xN
                                      #);
                            T[] -> command[];
                         #);
                    #);
                  textList: containerList(# element:: text #);
                  defaultId: @ text;
                  target: ^buildArgs.element;
                  objFile,directory,command: ^text;
               do 'default'->defaultId;
                  buildArgs.clear;
                  scanParameters
                  (# doName:: (# do n[] -> buildArgs.add #);
                     dostring:: (#do s[] -> buildArgs.addMarg #)
                  #);
                  (if switch[20] then buildArgs.display if);
                  buildArgs.findThisTarget 
                  (#
                  do (if current[] -> buildArgs.check then
                         current[] -> buildArgs.expandCommand
                     if);
                     ((objFile[],theGroup.nameT[]->stripPathName) -> thePathHandler.convertFilePath
                     ,directory[]
                     ,command[]) 
                       -> BuildProperty;
                     NONE -> command[]; (* there may be several entries
                                         * pr platform so old value of
                                         * command should be deleted
                                         *)                              
                  #)
               #)
            // ('mdbody'->prop.equal->MDBodyProp)
            // ('objfile'->prop.equal->objFileProp)
            // ('libfile'->prop.equal->libFileProp) 
            // ('linkopt'->prop.equal->linkOptProp) 
            // ('betarun'->prop.equal->betarunProp)
            // ('make'->prop.equal->makeProp)
            // ('resource'->prop.equal->resProp)
               then
               true->nonEmpty; 
               (* Machine dependent properties :
                * Example: objfile sun     './vaffel.o'
                *                  hp      './filur.o'
                *                  default './andre.o'
                * (here theProp='objfile' is assummed).
                * When the property value ('./vaffel.o' etc. 
                * depending on TargetMachine)
                * is determined, PropertyAction.doString is called.
                *)
               (# thisMachine,foundSomething,machineMatch: @boolean;
               do tandem:
                    (* On first iteration look for exact matching machine 
                     * name. If not found try a second round, looking for 
                     * 'default'.
                     *)
                    (for iteration: 2 repeat
                         false -> thisMachine;
                         ScanParameters
                         (# doName::
                              (#
                              do (if iteration = 1 then
                                     targetMachine[]->n.equal->thisMachine;
                                  else
                                     n.makeLC;
                                     'default'->n.equal->thisMachine;
                                 if);
                                 machineMatch or thisMachine -> machineMatch;
                                 (prop[],n[])->CheckPropValue
                              #);
                            doString::
                              (# t: ^Text;
                                 f: @file;
                              do (if s.length=0 then
                                     (* empty file name: '' *)
                                     (if MDBodyProp then
                                         (prop[],theGroup.fullname,4)->propError
                                      else
                                         (* accept '' for others *)
                                         true->foundSomething;
                                     if)
                                  else
                                     (if thisMachine then
                                         true -> foundSomething;
                                         &Text[] ->t[];
                                         s -> t;
                                         t[] -> ExpandMacro;
                                         (if true
                                          // makeProp then
                                             (t[],theGroup.nameT[]
                                               -> stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[];
                                             (if switch[10] then
                                                 t[] -> f.name;
                                                 (if f.entry.exists  then
                                                     (* make file exists *)
                                                     (*AST.*)astFileExtension
                                                       -> theGroup.nameT.CopyAppend
                                                       -> f.name;
                                                     (if switch[19] or f.entry.writeable  then
                                                         (* groupfile is writeable and/or switch is true *)
                                                         t[] -> isFile;
                                                         (makeProperty,t[]) 
                                                           -> CurrentProperty
                                                     if);
                                                  else
                                                     (* if group file is not writeable then issue warning *)
                                                     (*AST.*)astFileExtension
                                                       -> theGroup.nameT.CopyAppend
                                                       -> f.name;
                                                     (if switch[19] or f.entry.writeable  then
                                                         (* groupfile is writable and/or switch is true *)
                                                         t[] -> isFile;
                                                     if);
                                                 if)
                                              else (* old way *)
                                                 t[] -> isFile;
                                                 (makeProperty,t[]) 
                                                   -> CurrentProperty
                                             if);
                                          // resProp then
                                             (t[],theGroup.nameT[]
                                               ->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[]
                                               -> isFile;
                                             (resourceProperty,t[])
                                               -> currentProperty
                                          // libFileProp then
                                             (t[],theGroup.nameT[]->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[]
                                               -> isFile;
                                             (libfileProperty,t[]) 
                                             -> CurrentProperty
                                          // linkOptProp then
                                             (linkoptProperty,t[]) 
                                               -> CurrentProperty
                                          // objFileProp then
                                             (t[],theGroup.nameT[]->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath 
                                               -> t[]
                                               -> isFile;
                                             (objfileProperty,t[]) 
                                               -> CurrentProperty
                                          // MDBodyProp then
                                             (t[],theGroup.nameT[]) 
                                               -> OpenGroup
                                               -> next[];
                                             (if next.controller.status<doneTranslate
                                             then
                                                 next[] -> private.bodyList.insert;
                                             if);
                                          // betarunProp then
                                             (betarunProperty,t[]) -> CurrentProperty;
                                 if)if)if)
                              #);
                         #); (* scan parameters *)
                         (if ((not foundSomething) and
                             ((iteration=2) or machineMatch)) then
                             (prop[],targetMachine[],6)->PropError
                         if);
                         (if machineMatch then leave tandem if);
                    for);
               #); (* End of machine-dependent property handling *)
               
            // 'fswitch'->prop.equal then
                         (* !!!ScanParameters(# doString::<(# do S->AsmLink.fSwitch #) #)*)
               
            // 'on'->prop.equal then (* skip at this point, read in translate *)
            // 'off'->prop.equal then (* skip at this point, read in translate *)
                // 'nolink'->prop.equal then (*True -> AsmLink.NoLink;*)
            // 'donecheck'->prop.equal // 'depfrag'->prop.equal 
            // 'unique_group_id'->prop.equal // 'comment'->prop.equal 
            // 'library'->prop.equal // 'include'->prop.equal 
            // 'slots' -> prop.equal // 'frejamark' -> prop.equal then 
               (* skip *)
            else 
               (if (1->prop.inxGet) <> '_' then
                   (* properties starting with '_' are ignored *)
                   (prop[],'',5)->PropError
           if)if)
        #);
#)#)
--AstOpen:descriptor--
(# doParse: @Boolean;
   
do (*(if switch[10] then
       (* force parsing
        (10,true)->AST.Trace.set
        if);*)
   (*!!!!!!!!!!!
    * fullname[]->common.theGroupName[]; 
    * may be accessed if exception is raised
    * by AST.top.open
    *)

   1->xtrace(#do 'AstOpen: '->xT; fullname[]->xT; xN #);
   (fullname[],messagestream[]) -> (*AST.*)top.open
   (# astOverflow::<
        (# 
        do cleanUpAfterException; 
           '\nAst overflow. The file:\n\t'->msg;
           fullName[]->msg.append;
           '\nis too big!\n'->msg.append;
           'You will have to split this file into smaller fragments.\n'
             ->msg.append;
           (*fullName[]->(*AST.* )top.Close;*)
           msg[]->MPSException
        #);
      StartingParsing::< 
        (# 
        do (if xverboseLevel<=xverboseLevel.actions then 
               'Parsing: '-> infostream.puttext; 
               ''''->infostream.put;
               (if useFullName then
                   fullname[]->infostream.puttext;
                else
                   localname[]->infostream.puttext;
               if);
               ''''->infostream.put;
           if);
           fullname[]->startingParsingNotification;
           true -> doParse;
        #);
      FragmentNotExisting::< 
        (# do cleanUpAfterException; fullName[]->notExistingException #);
      grammarNotFound::< 
        (# do cleanUpAfterException; msg[]->MPSException #); 
      BadFormat::< 
        (# 
        do cleanUpAfterException;
           '**** Error in fragment group: \n\t'->msg;
           fullName[]->msg.putLine;
           'The BETA grammar used for parsing the group is'->msg.putLine;
           'different from the BETA grammar used by the compiler.'
             ->msg.putLine;
           'All fragment groups must be translated by the '->msg.puttext;
           'same version of the BETA compiler.'->msg.putLine;
           msg[]->messagestream.putline;
           msg[]->MPSException; 
        #);
      ParseErrors::< 
        (# G: ^(*AST.*)fragmentGroup
        do cleanUpAfterException; (*fullName[]->(*AST.* )top.namedClose;*)
           fullname[]->DGP.groupList.deleteGroup; 
           fullName[]->parseException;
           false->doParse;
        #);
      FatalParseError::< 
        (# G: ^(*AST.*)fragmentGroup; 
        do (* 5/2/96: according to JLK, this is no longer necessary; KJM has 
            * apparently fixed mps!
            * (fullName[],messagestream[])->(*AST.* )top.open->G[];
            * G.close;
            *)
           fullName[]-> DGP.groupList.deleteGroup;
           cleanUpAfterException;
               (*(if reOpen then fullName[]->closedNotification if);*)
           (* msg from bobs *)
           '\n\n***** '->msg.prepend;
           msg[]->messagestream.putText;
           fullName[]->parseException;
           false ->doParse;
        #);
      doubleFormDeclaration::<
        (#
        do cleanUpAfterException; (*fullName[]->top.namedClose;*)
           this(AstInterface).offendingFormName[]->DoubleFormException
        #);
      ReadAccessError::< 
        (# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessError::< 
        (# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessOnLstFileError::<
        (# do cleanUpAfterException; 
           '.lst'->fullName.copyAppend->transAccessException 
        #);
      EOSerror::(#do 'EOS'->putline #);
      NoSuchFileError::
        (#do cleanUpAfterException; fullName[] -> notExistingException #);
      FileExistsError::
        (# T: @text 
        do cleanUpAfterException; 
           'MPS:top.open exception "FileExistsError" for: '->T;
           FullName[] ->T.append;
           T[] -> MPSException
        #);
      NoSpaceLeftError::(#do cleanUpAfterException;  NoSpaceException #); 
      OtherFileError::
        (#do cleanUpAfterException; fullName[]->notExistingException #);
   #) 
     -> g[];
   (if g[] = NONE then
       (# S: ^text;
       do 'Cannot open fragment-file : '->S[];
          Fullname[]->S.putLine;
          S[]->MPSException; 
       #);
   if);
   1->xtrace(#do ' Group: '->xT; g.nameT[]->xT; xN #);
   (if doParse then
       (false,this(AstInterface)[],g[]) -> setDoneCheckProperty;
       (if useCompact then 
           ' Re-organizing fragment...'->infostream.puttext;
           g[]->addVirtualSuper; '...'->infostream.puttext;
            (* !!!!!! g[]->this(AstInterface).compact *)
        if);
       (if xverboseLevel<= xverboseLevel.actions then infostream.newline if);
   if)
#)
  
---- TryToGC: dopart ----
do (if e.g.controller.status=-1 then
       (*!!!!!!!!!!!!!!!!
       (if e.g.nameT[]->closedNotification then
           e.g.close;
           NONE -> e.g[];
           e[] -> delete;
        if);*)
    else
       (if e.g.controller.status>justOpen then
           (* fragmentgroup has been opened or used in last
            * translate.
            * Reinitialize it
            *)
           justOpen -> e.g.controller.status;
           NONE -> e.g.origin;
        else
           (* fragment not used in last trans
            * decrement status
            *)
           (if lastTransWasReal then
               e.g.controller.status-1 -> e.g.controller.status;
   if)if)if)

---controlBody:dopart---
do false -> DGP.hasProgramSlot;

   translist.init;
   bodylist.init;
   DGP.groupList.scan (# do current[]->DGP.groupList.TryToGC #);
   false -> DGP.lastTransWasReal -> handledUsingList;
   
   (*AST.*)doRealOpen->ASTval;
   false->(*AST.*)doRealOpen;

   (if rootFragment[] = none then stop if);
   (if xverboseLevel < xverboseLevel.nothing then
       'Building dependency graph for: '''->infostream.putText;
       rootFragment[]->infostream.puttext;
       ''' ...'->infostream.putline;
   if);
   (if switch[2] then
       (if lastRootFragment[]<>NONE then
           (if lastRootFragment[]->rootFragment.equal then
               true->handledUsingList;
               'Repeating translation...'->infostream.putline;
               DGP.groupList.scan
               (# t: @text; m: @integer;
                  g: ^(*AST.*)fragmentGroup;
                  name,fullname: ^Text;
               do (if current.g.controller.status=justOpen then
                      current.g.nameT->t;
                      '.bet'->t.append;
                      t[]->getmodtime->m;
                      current.g[]->g[];
                      (if m>g.modtime then
                          (if switch[4] then
                              t[]->tracestream.puttext;
                              m->tracestream.putint; ' '->tracestream.put;
                              g.modtime->tracestream.putint;
                              '.bet has changed'->infostream.putline;
                          if);
                          current.g.controller.printname[]->name[];
                          current.g.fullname->fullname[];
                          (if reloadingNotification then
                              g.close;
                              NONE->g[];
                          if);
                          (fullname[],name[])->ASTOpen->g[];
                          current.g.controller.printname[]->g.controller.printname[];
                          g[]->current.g[];
                          isOpen->g.controller.status;
                          g[]->buildgraph;
                       else
                          current.g.nameT->t;
                          (*AST.*)astFileExtension->t.append;
                          (* checking the group file *)
                          t[]->getmodTime->m;
                          (if m>current.g.modTime then 
                              (if switch[4] then
                                  t[]->tracestream.puttext;
                                  m->tracestream.putint; ' '->tracestream.put;
                                  current.g.modtime->tracestream.putint;
                                  '.ast has changed'->tracestream.putline;
                              if);
                              (if reloadingNotification then
                                  current.g.checkDiskRepresentation;
                              if);
                              isOpen->current.g.controller.status;
                              current.g[]->buildgraph;
                           else
                              (if switch[4] then
                                  'Nothing for: '->tracestream.puttext;
                                  t[]->tracestream.putline;
                              if);
                          if);
                      if)
                  if)
               #);
           if)
   if)if);
   (if not handledUsingList then
       (rootFragment[],'')
         -> OpenGroup
         -> &buildGraph;
   if);
   (if not giveDomain then
       L: (if not BodyList.Complete then restart L if)
   if);

   (if not switch[15]  then
       (if xverboseLevel<xverboseLevel.nothing then
           'Translating fragments ...'->infostream.putline;
       if);
       transList.scanAndClear(# do current[]->&translate #);
       (if switch[8]  then 
           'GroupList  '->tracestream.puttext;
           DGP.groupList.statistics(# do screen[]->print #);
       if);
   if);
   ASTval->(*AST.*)DoRealOpen;
   rootFragment.copy->lastRootFragment[];

--DependencyGraphInit: dopart--
do (if not DGP.notFirst then
       true->DGP.notFirst;
       DGP.groupList.init;
       <<SLOT ControlMDInit: descriptor>>; (* to compiler ? *)
   if);
   INNER Init;
   (if errorStream[] = NONE then screen[] -> errorStream[] if);
   (if traceStream[] = NONE then screen[] -> traceStream[] if);
   (if messageStream[] = NONE then screen[] -> messageStream[] if);
   (if infoStream[] = NONE then screen[] -> infoStream[] if);
