ORIGIN 'dependencyBody';
LIB_ITEM 'dependency';
INCLUDE '~beta/basiclib/betaenvold';
INCLUDE '~beta/betaast/donecheck';
INCLUDE '~beta/containers/list';
INCLUDE 'findString';
(*BODY 'heapanalyzis'*)
--scanProperties:descriptor--
(# PropError:
     (# p,t: ^text; n: @integer; warning: @boolean;
     enter(p[],t[], n)
     do (theGroup[],p[],t[],n,CloseGroup(#do theGroup[] -> g[]#))
	  -> PropertyException
     #);
   CheckPropValue:
     (* checks if a property value is one of the reserved properties, like
      * ORIGIN, BODY, etc.
      * If this is true, a warning is generated.
      * n is assumed to be in lower case.
      *)
     (#  p,n: ^text
     enter(p[],n[])
     do (* n is assumed to be lowercase *)
	(if true
	 // 'origin'->n.equal // 'body'->n.equal // 'mdbody'->n.equal
	 // 'build' -> n.equal
         // 'lib_def' -> n.equal // 'lib_item' -> n.equal
	 // 'objfile'->n.equal // 'libfile'->n.equal // 'linkopt'->n.equal
	 // 'betarun'->n.equal // 'make'->n.equal // 'fswitch'->n.equal
	 // 'on'->n.equal // 'off'->n.equal // 'nolink' ->n.equal
	 // 'donecheck'->n.equal
	 // 'slots' -> n.equal
	 // 'frejamark' -> n.equal
         // 'basic' -> n.equal then
         // 'package' -> n.equal then
	    (p[],n[],2)->PropError
	if)
     #);
   PreMatch: booleanvalue
     (* Attempt to match 
      * build selector:     e.g. 'nti'
      * with targetMachine: e.g. 'nti_ms'
      * 
      * Note! This version has been written
      * to match 'nti' with 
      * either 'nti_ms' or 'nti_gnu'
      *)
     (# selector: ^text; 
     enter selector[]
     do (if switch[20] then
            '\nMatch targetMachine: "'->puttext;
            targetMachine[] -> puttext;
            '" with build selector: "' -> puttext;
            selector[] -> puttext;
        if);
        L:
          (# pos: @integer;
             T: ^text
          do targetmachine.scanAll
             (#
             do pos+1 -> pos;
                (if ch = '_' then 
                    (1,pos-1) 
                      -> targetmachine.sub 
                      -> T[];
                    T[] 
                      -> selector.equalNCS 
                      -> value;
                    leave L
             if)#)
          #);
        (if switch[20] then
            (if value then '" MATCH FOUND!'->putline
             else '" no match!' -> putline
        if)if)
     #);
   
   originSetHere: @boolean (* code using this var. is made by ESS;
			    * is needed to handle situations where other tools
			    * like the debugger may already have setup origin
			    *)
do false -> originSetHere;
   (if theGroup[]=NONE then
       'scanProperties: theGroup is NONE.' -> screen.putline;
    else
       (if theGroup.prop[]=NONE then
           'scanProperties: theGroup.prop is NONE.' -> screen.putline;
        else
           theGroup.prop.ScanProp
           (# doProp::<
	        (# betaRunProp,libFileProp,makeProp,resProp,linkOptProp,
	           objFileProp,MDBodyProp: @boolean
	        do prop.makelc;
	           (*'scanprop:'->puttext; prop[]->putline;*)
	           (if true
	            // 'origin' -> prop.equal then
	               true->nonEmpty;
	               ScanParameters
	               (# doString::<
		            (#
		            do 15->xtrace
		               (#do ' group:'->xT; theGroup.nameT[]->xT;
			          '\n\torigin:'->xT; S[]->xT; xN
		               #);
		               (if originSetHere (*theGroup.origin<>NONE*) then
			           (none,s[],1)->PropError
		               if);
		               (if s.length=0 then
			           (* empty file name: '' *)
			           ('origin',theGroup.fullname,4)->propError;
			        else
			           (s[],theGroup.nameT[])
			             -> OpenGroup
			             -> next[]
			             -> theGroup.origin;
			           true -> originSetHere;
			           (if next.controller.status < doneTranslate then
			               next[] -> &buildGraph
			           if);
			           (theGroup[],next[]) -> setGroupTime;
		               if);
		            #);
		          doName:: (#do ('origin',n[],3)->propError #);
	               #);
	            // 'body'->prop.equal then
	               true->nonEmpty;
	               ScanParameters
	               (# doString::
		            (#
		            do (if s.length=0 then
			           (* empty file name: '' *)
			           ('body',theGroup.fullname,4)->propError;
			        else
			           (s[],theGroup.nameT[])
			             -> OpenGroup
			             -> next[];
			           (if next.controller.status < doneTranslate then
			               next[] -> private.bodyList.insert
			           if);
		               if)
		            #);
		          doName:: (#do ('body',n[],3)->propError #)
	               #);
	            // 'build' -> prop.equal  then
	               (# buildArgs: @ containerList (* mps has a list pattern *)
		            (# element ::
			         (# machineId: ^text;
			            mArgs: [3] ^text; top: @integer
			         #);
		               add: @
			         (# machineId: ^text;
			            e: ^element
			         enter machineId[]
			         do &element[] -> e[];
			            machineId[] -> e.machineId[];
			            e[] -> append;
			            e[] -> current[]
			         #);
		               current: ^element;
		               addMarg: @
			         (# ma: ^text
			         enter ma[]
			         do (if (current.top + 1 -> current.top)
				        > current.mArgs.range
				        then
				        current.mArgs.range -> current.mArgs.extend
			            if);
			            ma.copy -> current.mArgs[current.top][]
			         #);
		               findThisTarget:
			         (# default,pre,thiss: [3] ^element;
			            dTop,pTop,tTop: @integer;
			            current: ^ element;
			         do scan
			            (#
			            do (if true
				        // targetMachine[] -> current.machineId.equal
				           then
				           (if (tTop+1->tTop) > thiss.range then
				               thiss.range -> thiss.extend
				           if);
				           current[] -> thiss[tTop][] (* exact match *)
				        // defaultId[] -> current.machineId.equal then
				           (if (dTop+1->dTop) > default.range then
				               default.range -> default.extend
				           if);
				           current[] -> default[dTop][]
				        // current.machineId[] -> preMatch then
				           (if (pTop+1->pTop) > pre.range then
				               pre.range ->pre.extend
				           if);
				           current[] -> pre[pTop][]
			            if)#);
			            (if tTop > 0 then
				        (for i: tTop repeat
				             thiss[i][]-> current[];
				             INNER
				        for)
			             else (* no exact match *)
				        (if pTop > 0  then
				            (for i: pTop repeat
					         pre[i][] -> current[];
					         INNER
				            for);
				         else
				            (if dTop > 0 then
					        (for i: dTop repeat
					             default[i][] -> current[];
					             INNER
					        for);
				             else
					        (prop[],targetMachine[],6)->PropError
			            if)if)if)
			         #);
		               display:
			         (#
			         do 20->xtrace
			            (#
			            do 'Building' -> xT;
			               scan(#do current.machineId[] -> xT;
				              (for i: current.top repeat
					           ' ' -> xC;
					           current.mArgs[i][] -> xT;
				              for);
				              xN
			         #)#)#);
		               check:
			         (# e: ^element; arg: @text; T: ^text;
			            m,m2: @integer; exeCommand: @boolean
			         enter e[]
			         do (if (e.top = 0) or (e.top = 2) then
				        (prop[],targetMachine[],7) -> PropError
			             else
				        (* we MUST save objfile before replacing '/' by ':'
				         * on Mac's below, since the pathhandler otherwise will
				         * NOT expand objfile to a full path! Yak:-(
				         *)
				        e.mArgs[1].copy

				          -> expandMacro2
                                          -> expandenvvar (* datpete 2003-08021 *)
				          -> objFile[]
				          -> EgetModTime -> (m,T[]);

				        (if m = -1 then
				            true -> exeCommand
				         else
				            (for i: e.top - 2 repeat
					         e.mArgs[1 + i][]
					           -> expandmacro2
					           -> EgetModTime
					           -> (m2,T[]);
					         T[] -> isFile;
					         (if (m < m2) or (m2 = -1) then
					             (* if m2 = -1 then T is NOT
					              * existing, i.e. the command
					              * cannot be executed; the command
					              * is, however, marked for execution
					              * anyway, since it may be created
					              * later, and a possible job-file
					              * may then be ok
					              *)
					             true -> exeCommand
					         if)
				            for)
				        if)
			            if);
			         exit exeCommand
			         #);
		               EgetModTime:
			         (# t: ^text; m: @integer
			         enter t[]
			         do (t[],theGroup.nameT[] -> stripPathName)
			              -> thePathHandler.convertFilePath
			              -> t[];
			            t[] -> getModTime -> m;
			            20->xTrace
			            (#do 'EgetModTime: '->xT; T[] -> xT;
			               '\nmodtime: '->xT; m->xI; xN
			            #);
			         exit(m,t[])
			         #);
		               expandCommand:
			         (# e: ^element; arg: @text; T: ^text;
			            lastSlash,argNo: @integer
			         enter e[]
			         do e.mArgs[e.top][] -> t[]; (* the command *)

			            (* First we expand args $0,$1, $2, ...;
			             * args must be expanded before $$, since args
			             * may contain $$.
			             * Expansion is made backwards
			             *    ..., $2, $1, $0
			             * since the algoritm belwo may othwervise
			             * replace e.g. $1 in $11
			             *)
			            (for ix: e.top - 1 repeat
				         arg.clear;
				         '$'->arg.put;
				         e.top - ix - 1 -> argNo -> arg.putint;
				         20->xTrace
				         (#do 'Find:'->xT; arg[]->xT; '  '->xT #);
				         findArg:
				           arg[] -> T.findString
				         (#
				         do (inx,inx+(argNo div 10 + 1)) -> T.delete;
				            (e.mArgs[argNo + 1][]
                                              -> expandMacro2 (* datpete 2003-08-21 *)
                                              -> expandenvvar (* datpete 2003-08-21 *)
                                            ,inx) -> T.insert;
				            20->xTrace
				            (#do 'Replace:'->xT;
				               e.mArgs[argNo + 1][] -> xT; '  '->xT;
				               T[] -> xT; xN
				            #);
				            restart findArg (* same arguent may appear
						             * several times
						             *)
				         #);
			            for);

			            (* replace double $$ by targetDirectory *)
			            T[] -> ExpandMacro2 -> T[];
                                    (* Expand environment variables (datpete 2003-08-21) *)
                                    T[] -> expandEnvVar -> T[];
                                    (* Replace '/' by native directory char.  Has
                                     * no effect on unix, where native directory
                                     * char is '/'.
                                     * MUST wait until all expandmacro2 calls have been done,
                                     * since '.../$$/...' will become '...\$$\...' on nti, which will
                                     * result in NO expansion of $$.
                                     *)
                                    '/' -> t.findall(#do (thePathHandler.directoryChar,inx) -> t.inxPut #);
			            20->xTrace
			            (#do 'Expanded command: '->xT; T[] -> xT; xN #);
			            (theGroup.nameT[],thePathHandler.currentDirectory)
			              -> thePathHandler.convertFilePath
			              -> directory[];
			            20->xTrace(#do 'dir1:'->xT; directory[]->xT; xN #);
			            thePathHandler.directoryChar
			              ->directory.findAll(#do inx -> lastSlash #);
			            (if lastSlash > 0 then
				        (1,lastSlash) -> directory.sub -> directory[]
			            if);
			            20->xTrace(#do 'dir2:'->xT;
					         (if directory[] <> NONE then
					             directory[] -> xT
					         if); xN
				              #);
			            T[] -> command[];
			         #);
		            #);
		          textList: containerList(# element:: text #);
		          defaultId: @ text;
		          target: ^buildArgs.element;
		          objFile,directory,command: ^text;
	               do 'default'->defaultId;
		          buildArgs.clear;
		          scanParameters
		          (# doName:: (# do n[] -> buildArgs.add #);
		                         (*dostring:: (#do s[] -> buildArgs.addMarg #);*)
		             dostring::
		               (#
		               do (if buildArgs.current[] = NONE then
			              (prop[],targetMachine[],8) -> PropError;
			              defaultId[] -> buildArgs.add
			          if);
			          s[] -> buildArgs.addMarg
		               #)
		          #);
		          (if switch[20] then buildArgs.display if);
		          buildArgs.findThisTarget
		          (#
		          do (if current[] -> buildArgs.check then
			         current[] -> buildArgs.expandCommand
		              else
			         current[] -> buildArgs.expandCommand;
			         (* expandCommand is executed to make the
			          * dependent files and 'directory' available
			          * for tools like betatar, even when no
			          * build is necessary
			          *)
			         NONE->command[]
			         (* NONE indicates to the compiler
			          * that no build is necessary *)
		             if);
                             (if switch[20] then
                                 (if objfile[] = none then 
                                     'objfile none'->putline
                                  else
                                     objFile[] -> putline
                                 if);
                                 (if theGroup[] = none then
                                     'TheGroup NONE' -> putline
                                  else
                                     theGroup.nameT[] -> putline
                                 if)
                             if);
		             ((objFile[],theGroup.nameT[]->stripPathName)
		               -> thePathHandler.convertFilePath
			     ,directory[]
			     ,current.mArgs[2:current.top-1]
			     ,command[])
		               -> BuildProperty;
		             NONE -> command[]; (* there may be several entries
					         * pr platform so old value of
					         * command should be deleted
					         *)
		          #)
	               #)
	            // ('mdbody'->prop.equal->MDBodyProp)
	            // ('objfile'->prop.equal->objFileProp)
	            // ('libfile'->prop.equal->libFileProp)
	            // ('linkopt'->prop.equal->linkOptProp)
	            // ('betarun'->prop.equal->betarunProp)
	            // ('make'->prop.equal->makeProp)
	            // ('resource'->prop.equal->resProp)
	               then
	               true->nonEmpty;
	               (* Machine dependent properties :
		        * Example: objfile sun     './vaffel.o'
		        *                  hp      './filur.o'
		        *                  default './andre.o'
		        * (here theProp='objfile' is assummed).
		        * When the property value ('./vaffel.o' etc.
		        * depending on TargetMachine)
		        * is determined, PropertyAction.doString is called.
		        *)
	               (# thisMachine,foundSomething,machineMatch: @boolean;
	               do tandem:
		            (* 3 iterations are made:
                             * 1: look for exact matching machine name
                             * 2: test is selector is a prefix of machine name
                             *    ( 'nti' will match 'nti_gnu', 'nti_ms')
                             * 3: look for a 'default' selector.
		             *)
		            (for iteration: 3 repeat
			         false -> thisMachine;
			         ScanParameters
			         (# doName::
			              (#
			              do (if iteration 
                                          // 1 then
				             targetMachine[] 
                                               -> n.equal 
                                               -> thisMachine
				          // 2 then
                                             n[] -> PreMatch -> thisMachine
                                          // 3 then
				             n.makeLC;
				             'default' -> n.equal -> thisMachine
				         if);
				         machineMatch or thisMachine -> machineMatch;
				         (prop[],n[]) -> CheckPropValue
			              #);
			            doString::
			              (# t: ^Text;
				         f: @file;
			              do (if s.length = 0 then
				             (* empty file name: '' *)
				             (if MDBodyProp then
					         (prop[],theGroup.fullname,4)
                                                   -> propError
				              else
					         (* accept '' for others *)
					         true->foundSomething;
				             if)
				          else
				             (if thisMachine then
					         true -> foundSomething;
					         &Text[] ->t[];
					         s -> t;
					         t[] -> ExpandMacro;
					         (if true
					          // makeProp then
					             (t[],theGroup.nameT[]
					               -> stripPathName)
					               -> thePathHandler.convertFilePath
					               -> t[];
					             (if switch[10] then
						         t[] -> f.name;
						         (if f.entry.exists  then
						             (* make file exists *)
						             astFileExtension
						               -> theGroup.nameT.CopyAppend
						               -> f.name;
						             (if switch[19] or f.entry.writeable  then
							         (* groupfile is writeable and/or switch is true *)
							         t[] -> isFile;
							         (makeProperty,t[])
							           -> CurrentProperty
						             if);
						          else
						             (* if group file is not writeable then issue warning *)
						             astFileExtension
						               -> theGroup.nameT.CopyAppend
						               -> f.name;
						             (if switch[19] or f.entry.writeable  then
							         (* groupfile is writable and/or switch is true *)
							         t[] -> isFile;
						             if);
						         if)
					              else (* old way *)
						         t[] -> isFile;
						         (makeProperty,t[])
						           -> CurrentProperty
					             if);
					          // resProp then
					             (t[],theGroup.nameT[]
					               ->stripPathName)
					               -> thePathHandler.convertFilePath
					               -> t[]
					               -> isFile;
					             (resourceProperty,t[])
					               -> currentProperty
					          // libFileProp then
					             (t[],theGroup.nameT[]->stripPathName)
					               -> thePathHandler.convertFilePath
					               -> t[]
					               -> isFile;
					             (libfileProperty,t[])
					               -> CurrentProperty
					          // linkOptProp then
					             (linkoptProperty,t[])
					               -> CurrentProperty
					          // objFileProp then
					             (t[],theGroup.nameT[]->stripPathName)
					               -> thePathHandler.convertFilePath
					               -> t[]
					               -> isFile;
					             (objfileProperty,t[])
					               -> CurrentProperty
					          // MDBodyProp then
					             (t[],theGroup.nameT[])
					               -> OpenGroup
					               -> next[];
					             (if next.controller.status<doneTranslate
					                 then
						         next[] -> private.bodyList.insert;
					             if);
					          // betarunProp then
					             (betarunProperty,t[]) -> CurrentProperty;
				         if)if)if)
			              #);
			         #); (* scan parameters *)
			         (if ((not foundSomething) and
			             ((iteration=3) or machineMatch)) then
			             (prop[],targetMachine[],6)->PropError
			         if);
			         (if machineMatch then leave tandem if);
		            for);
	               #); (* End of machine-dependent property handling *)

	            // 'fswitch'->prop.equal then
			  (* !!!ScanParameters(# doString::<(# do S->AsmLink.fSwitch #) #)*)

	            // 'on'->prop.equal then (* skip at this point, read in translate *)
	            // 'off'->prop.equal then (* skip at this point, read in translate *)
                    // 'nolink'->prop.equal then (*True -> AsmLink.NoLink;*)
	            // 'donecheck'->prop.equal // 'depfrag'->prop.equal
	            // 'unique_group_id'->prop.equal // 'comment'->prop.equal
	            // 'library'->prop.equal (* library is being replaced by
                                              * lib_def and lib_item *)
                    // 'lib_def'->prop.equal 
                    // 'lib_item'->prop.equal 
                    // 'include'->prop.equal
	            // 'slots' -> prop.equal // 'frejamark' -> prop.equal
                    // 'basic' -> prop.equal 
                    // 'package' -> prop.equal then
	               (* skip *)
	            else
	               (if (1->prop.inxGet) <> '_' then
		           (* properties starting with '_' are ignored *)
		           (prop[],'',5)->PropError
	               if)
                   if)
	        #);
           #)
       if)
   if)
#)
--AstOpen:descriptor--
(# doParse: @Boolean;

do (*(if switch[10] then
   (* force parsing
    (10,true)->AST.Trace.set
    if);*)
   (*!!!!!!!!!!!
    * fullname[]->common.theGroupName[];
    * may be accessed if exception is raised
    * by AST.top.open
    *)

   1->xtrace(#do 'AstOpen: '->xT; fullname[]->xT; xN #);
   (fullname[],messagestream[]) -> top.open
   (# astOverflow::<
	(#
	do cleanUpAfterException;
	   '\nAst overflow. The file:\n\t'->msg;
	   fullName[]->msg.append;
	   '\nis too big!\n'->msg.append;
	   'You will have to split this file into smaller fragments.\n'
	     ->msg.append;
	   (*fullName[]->(*AST.* )top.Close;*)
	   msg[]->MPSException
	#);
      StartingParsing::<
	(#
	do (if xverboseLevel<=xverboseLevel.actions then
	       'Parsing: '-> infostream.puttext;
	       '\''->infostream.put;
	       (if useFullName then
		   fullname[]->infostream.puttext;
		else
		   localname[]->infostream.puttext;
	       if);
	       '\''->infostream.put;
	   if);
	   fullname[]->startingParsingNotification;
	   true -> doParse;
	#);
      FragmentNotExisting::<
	(# do cleanUpAfterException; fullName[]->notExistingException #);
      grammarNotFound::<
	(# do cleanUpAfterException; msg[]->MPSException #);
      BadFormat::<
	(#
	do cleanUpAfterException;
	   '**** Error in fragment group: \n\t'->msg;
	   fullName[]->msg.putLine;
	   'The BETA grammar used for parsing the group is'->msg.putLine;
	   'different from the BETA grammar used by the compiler.'
	     ->msg.putLine;
	   'All fragment groups must be translated by the '->msg.puttext;
	   'same version of the BETA compiler.'->msg.putLine;
	   msg[]->messagestream.putline;
	   msg[]->MPSException;
	#);
      ParseErrors::<
	(# G: ^fragmentGroup
	do cleanUpAfterException; (*fullName[]->(*AST.* )top.namedClose;*)
	   fullname[]->DGP.groupList.deleteGroup;
	   fullName[]->parseException;
	   false->doParse;
	#);
      FatalParseError::<
	(# G: ^fragmentGroup;
	do (* 5/2/96: according to JLK, this is no longer necessary; KJM has
	    * apparently fixed mps!
	    * (fullName[],messagestream[])->(*AST.* )top.open->G[];
	                                     * G.close;
	                                     *)
	   fullName[]-> DGP.groupList.deleteGroup;
	   cleanUpAfterException;
           (*(if reOpen then fullName[]->closedNotification if);*)
	   (* msg from bobs *)
	   '\n\n***** '->msg.prepend;
	   msg[]->messagestream.putText;
	   fullName[]->parseException;
	   false ->doParse;
	#);
      doubleFormDeclaration::<
	(#
	do cleanUpAfterException; (*fullName[]->top.namedClose;*)
	   this(AstInterface).offendingFormName[]->DoubleFormException;
           true->continue
	#);
      ReadAccessError::<
	(# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessError::<
	(# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessOnLstFileError::<
	(# do cleanUpAfterException;
	   '.lst'->fullName.copyAppend->transAccessException
	#);
      EOSerror::(#do 'EOS'->putline #);
      NoSuchFileError::
	(#do cleanUpAfterException; fullName[] -> notExistingException #);
      FileExistsError::
	(# T: @text
	do cleanUpAfterException;
	   'MPS:top.open exception "FileExistsError" for: '->T;
	   FullName[] ->T.append;
	   T[] -> MPSException
	#);
      NoSpaceLeftError::(#do cleanUpAfterException;  NoSpaceException #);
      OtherFileError::
	(#do cleanUpAfterException; fullName[]->notExistingException #);
   #)
     -> g[];
   (if g[] = NONE then
       (# S: ^text;
       do 'Cannot open fragment-file : '->S[];
	  Fullname[]->S.putLine;
	  S[]->MPSException;
       #);
   if);
   1->xtrace(#do ' Group: '->xT; g.nameT[]->xT; xN #);
   (if doParse then
       (false,this(AstInterface)[],g[]) -> setDoneCheckProperty;
       (if useCompact then
	   ' Re-organizing fragment...'->infostream.puttext;
	   g[]->addVirtualSuper; '...'->infostream.puttext;
           (* !!!!!! g[]->this(AstInterface).compact *)
       if);
       (if xverboseLevel<= xverboseLevel.actions then infostream.newline if);
   if)
#)

---- TryToGC: dopart ----
do (if e.g.controller.status=-1 then
       (*!!!!!!!!!!!!!!!!
        (if e.g.nameT[]->closedNotification then
        e.g.close;
        NONE -> e.g[];
        e[] -> delete;
	if);*)
    else
       (if e.g.controller.status>justOpen then
	   (* fragmentgroup has been opened or used in last
	    * translate.
	    * Reinitialize it
	    *)
	   justOpen -> e.g.controller.status;
	   NONE -> e.g.origin;
	else
	   (* fragment not used in last trans
	    * decrement status
	    *)
	   (if lastTransWasReal then
	       e.g.controller.status-1 -> e.g.controller.status;
   if)if)if)

---controlBody:dopart---
do false -> DGP.hasProgramSlot;

   translist.init;
   bodylist.init;
   DGP.groupList.scan (# do current[]->DGP.groupList.TryToGC #);
   false -> DGP.lastTransWasReal -> handledUsingList;

   doRealOpen->ASTval;
   false->doRealOpen;

   (if rootFragment[] = none then stop if);
   (if xverboseLevel < xverboseLevel.nothing then
       'Building dependency graph for: \''->infostream.putText;
       rootFragment[]->infostream.puttext;
       '\' ...'->infostream.putline;
   if);
   (if switch[2] then
       (if lastRootFragment[]<>NONE then
	   (if lastRootFragment[]->rootFragment.equal then
	       true->handledUsingList;
	       'Repeating translation...'->infostream.putline;
	       DGP.groupList.scan
	       (# t: @text; m: @integer;
		  g: ^fragmentGroup;
		  name,fullname: ^Text;
	       do (if current.g.controller.status=justOpen then
		      current.g.nameT->t;
		      '.bet'->t.append;
		      t[]->getmodtime->m;
		      current.g[]->g[];
		      (if m>g.modtime then
			  (if switch[4] then
			      t[]->tracestream.puttext;
			      m->tracestream.putint; ' '->tracestream.put;
			      g.modtime->tracestream.putint;
			      '.bet has changed'->infostream.putline;
			  if);
			  current.g.controller.printname[]->name[];
			  current.g.fullname->fullname[];
			  (if reloadingNotification then
			      g.close;
			      NONE->g[];
			  if);
			  (fullname[],name[])->ASTOpen->g[];
			  current.g.controller.printname[]->g.controller.printname[];
			  g[]->current.g[];
			  isOpen->g.controller.status;
			  g[]->buildgraph;
		       else
			  current.g.nameT->t;
			  astFileExtension->t.append;
			  (* checking the group file *)
			  t[]->getmodTime->m;
			  (if m>current.g.modTime then
			      (if switch[4] then
				  t[]->tracestream.puttext;
				  m->tracestream.putint; ' '->tracestream.put;
				  current.g.modtime->tracestream.putint;
				  '.ast has changed'->tracestream.putline;
			      if);
			      (if reloadingNotification then
				  current.g.checkDiskRepresentation;
			      if);
			      isOpen->current.g.controller.status;
			      current.g[]->buildgraph;
			   else
			      (if switch[4] then
				  'Nothing for: '->tracestream.puttext;
				  t[]->tracestream.putline;
			      if);
			  if);
		      if)
		  if)
	       #);
	   if)
   if)if);
   (if not handledUsingList then
       (rootFragment[],'')
	 -> OpenGroup
	 -> &buildGraph;
   if);
   (if not giveDomain then
       L: (if not BodyList.Complete then restart L if)
   if);

   (if not switch[15]  then
       (if xverboseLevel<xverboseLevel.nothing then
	   'Translating fragments ...'->infostream.putline;
       if);
       transList.scanAndClear(# do current[]->&translate #);
       (if switch[8]  then
	   'GroupList  '->tracestream.puttext;
	   DGP.groupList.statistics(# do screen[]->print #);
       if);
   if);
   ASTval->DoRealOpen;
   rootFragment.copy->lastRootFragment[];

--DependencyGraphInit: dopart--
do (if not DGP.notFirst then
       true->DGP.notFirst;
       DGP.groupList.init;
       <<SLOT ControlMDInit: descriptor>>; (* to compiler ? *)
   if);
   &text[]->TargetMachine[];
   &text[]->TargetDirectory[];
   INNER Init;
   (if errorStream[] = NONE then screen[] -> errorStream[] if);
   (if traceStream[] = NONE then screen[] -> traceStream[] if);
   (if messageStream[] = NONE then screen[] -> messageStream[] if);
   (if infoStream[] = NONE then screen[] -> infoStream[] if);
