ORIGIN 'control';
INCLUDE '~beta/basiclib/v1.4/directory';
---xfragmentError:dopart--
do theGroup.close; 
   theGroup.fullName->DependencyGraphPrivate.groupList.deleteGroup; 
   none->theGroup[];
   (*11->msg*)
--xscanProperties:descriptor--
(# PropError:
     (# p,t: ^text; n: @integer
     enter(p[],t[], n)
     do '\n*** Error in property list of:\n\t'->screen.puttext; 
        theGroup.name->screen.puttext; '\n\n\t'->screen.puttext;
        (if n
         // 1 then            
            'Two or more origins are specified:\n\t'->screen.puttext;
            (# g: ^fragment;
            do theGroup.origin -> g[]; g.name -> screen.puttext;
            #);
            '\n\t'->screen.puttext; t[]->screen.putline
         // 2 then
            'The reserved property name "'->screen.puttext; 
            t.makeUC; t[]->screen.puttext;
            '"\n\tappears in the property list for '->screen.puttext;
            p.makeUC; p[]->screen.puttext; 
         // 3 then
            'Illegal "'->screen.puttext; p.makeUC; p[]->screen.puttext; 
            '" property: "'->screen.puttext; t.makeUC; t[]->screen.puttext;
            '"\n'->screen.puttext
         // 4 then
            'Empty filename in property "'->screen.puttext;
            p.makeUC; p[]->screen.puttext; '"'->screen.put; screen.newline;
            theGroup[]->fragmentError;
        if);
        '\n\n\tA ";" may be missing before '->screen.puttext;
        t[]->screen.putline;
        theGroup[]->fragmentError
     #);
   CheckPropValue:
     (* checks if a property value is one of the reserved properties, like
      * ORIGIN, BODY, etc.
      * If this is true, a warning is generated.
      * n is assumed to be in lower case.
      *)
     (#  p,n: ^text 
     enter(p[],n[])
     do (* n is assumed to be lowercase *)
        (if true
         // 'origin'->n.equal // 'body'->n.equal // 'mdbody'->n.equal
         // 'objfile'->n.equal // 'libfile'->n.equal // 'linkopt'->n.equal 
         // 'betarun'->n.equal // 'make'->n.equal // 'fswitch'->n.equal 
         // 'on'->n.equal // 'off'->n.equal // 'nolink' ->n.equal
         // 'donecheck'->n.equal then
            (p[],n[],2)->PropError
        if)
     #)
do 
   theGroup.prop.ScanProp
   (# doProp::<
        (# betaRunProp,libFileProp,makeProp,resProp,linkOptProp,
           objFileProp,MDBodyProp: @boolean 
        do prop.makelc; 
           (*'scanprop:'->puttext; prop[]->putline;*)
           (if true 
            // 'origin' -> prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::<
                    (# 
                    do 
                       (if theGroup.origin<>NONE then 
                           (none,s[],1)->PropError 
                       if);
                       (if s.length=0 then
                           (* empty file name: '' *)
                           ('origin',theGroup.fullname,4)->propError;
                        else
                       (s[],theGroup.nameT[]) -> DependencyGraphPrivate.groupList.insertGroup
                         -> next[] -> theGroup.origin;
                       (if next.controller.status<doneTranslate then
                           next[] -> &buildGraph;
                       if);
                       (theGroup[],next[]) -> setGroupTime;
                       if);
                    #);
                  doName::<(#do ('origin',n[],3)->propError #);
               #);
            // 'body'->prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::<
                    (#
                    do (if s.length=0 then
                           (* empty file name: '' *)
                           ('body',theGroup.fullname,4)->propError;
                        else
                           (s[],theGroup.nameT[])
                         -> DependencyGraphPrivate.groupList.insertGroup -> next[];
                       (if next.controller.status<doneTranslate then
                           next[] -> bodyList.insert;
                       if);
                       if)
                    #);
                  doName::<(#do ('body',n[],3)->propError #)
               #);
            // ('mdbody'->prop.equal->MDBodyProp)
            // ('objfile'->prop.equal->objFileProp)
            // ('libfile'->prop.equal->libFileProp) 
            // ('linkopt'->prop.equal->linkOptProp) 
            // ('betarun'->prop.equal->betarunProp)
            // ('make'->prop.equal->makeProp)
            // ('resource'->prop.equal->resProp)
               then
               true->nonEmpty; 
               (* Machine dependent properties :
                Example:     objfile sun     './vaffel.o'
                hp      './filur.o'
                default './andre.o'
                (here theProp='objfile' is assummed).
                When the property value ('./vaffel.o' etc. 
                depending on TargetMachine)
                is determined, PropertyAction.doString is called.
                *)
               (# thisMachine,foundSomething,machineMatch: @boolean;
               do tandem:
                    (* On first iteration look for exact matching machine 
                     name. If not found try a second round, looking for 
                     'default'.
                     *)
                    (for iteration:2 repeat
                         false -> thisMachine;
                         ScanParameters
                         (# doName::<
                              (#
                              do (if iteration//1 then
                                     targetMachine[]->n.equal->thisMachine;
                                  else
                                     n.makeLC;
                                     'default'->n.equal->thisMachine;
                                 if);
                                 machineMatch or thisMachine -> machineMatch;
                                 (prop[],n[])->CheckPropValue
                              #);
                            doString::<
                              (# t: ^Text;
                                 f: @file;
                              do (if s.length=0 then
                                     (* empty file name: '' *)
                                     (if MDBodyProp then
                                         (prop[],theGroup.fullname,4)->propError;
                                      else
                                         (* accept '' for others *)
                                         true->foundSomething;
                                     if)
                                  else
                                     (if thisMachine then
                                     true -> foundSomething;
                                     &Text[] ->t[];
                                     s -> t;
                                     t[] -> ExpandMacro;
                                     (if true
                                      // makeProp then
                                         (t[],theGroup.nameT[]
                                           ->filenamestripper) 
                                           -> thePathHandler.convertFilePath
                                           -> t[];
                                         (if switch[390] then
                                             t[] -> f.name;
                                             (if f.entry.exists  then
                                                 (* make file exists *)
                                                 astFileExtension
                                                   -> theGroup.nameT.CopyAppend
                                                   -> f.name;
                                                 (if switch[399] or f.entry.writeable  then
                                                     (* groupfile is writeable and/or switch is true *)
                                                     t[] -> isFile;
                                                     t[]->currentProperty
                                                 if);
                                              else
                                                 (* if group file is not writeable then issue warning *)
                                                 astFileExtension
                                                   -> theGroup.nameT.CopyAppend
                                                   -> f.name;
                                                 (if switch[399] or f.entry.writeable  then
                                                     (* groupfile is writable and/or switch is true *)
                                                     t[] -> isFile;
                                                 if);
                                             if)
                                          else (* old way *)
                                             t[] -> isFile;
                                             t[]->currentProperty
                                         if);
                                      // resProp then
                                         (t[],theGroup.nameT[]
                                           ->filenamestripper) 
                                           -> thePathHandler.convertFilePath
                                           -> t[];
                                         t[] -> isFile;
                                         t[]->currentProperty
                                      // libFileProp then
                                         (t[],theGroup.nameT[]->filenamestripper) 
                                           -> thePathHandler.convertFilePath
                                           -> t[];
                                         t[] -> isFile;
                                         t[]->currentProperty
                                      // linkOptProp then
                                         t[]->currentProperty
                                      // objFileProp then
                                         (t[],theGroup.nameT[]->filenamestripper) 
                                           -> thePathHandler.convertFilePath 
                                           -> t[];
                                         t[] -> isFile;
                                         t[]->currentProperty
                                      // MDBodyProp then
                                         (t[],theGroup.nameT[]) 
                                           -> DependencyGraphPrivate.groupList.insertgroup -> next[];
                                         (if next.controller.status<doneTranslate
                                             then
                                             next[] -> bodyList.insert;
                                         if);
                                      // betarunProp then
                                         (if betarun.length=0 then
                                             (if b2c then
                                                 s->t;
                                                 t[]-> expandEnvVar -> t[];
                                                 rundkoersel: '$' -> t.findCh
                                             (# bt: @Text;
                                             do 
                                                (inx,inx) -> t.Delete;   (* Delete the '$'. *)
                                                'b2c'->bt;
                                                thePathHandler.directoryChar->bt.put;
                                                (bt[],inx) -> t.Insert; inx+4->inx;
                                                    (TargetDirectory[],inx) -> t.Insert;
                                                    restart rundkoersel      (* Necessary? *)
                                                 #);
                                             if);
                                             (t[],theGroup.nameT[]
                                               ->filenamestripper) 
                                               -> thePathHandler.convertFilePath
                                               -> t[];
                                             t[] -> isFile;
                                             t[]->currentProperty
                                     if)if);
                                 if)if);
                              #);
                         #); (* scan parameters *)
                         (if true//((not foundSomething) and
                             ((iteration=2) or machineMatch)) then
                             '**** Warning: '   -> screen.puttext;
                             TargetMachine[] -> screen.puttext;
                             ' '           -> screen.put;
                             Prop[]-> screen.puttext;
                             ' has no value in file' -> screen.putline;
                             theGroup.nameT[]   -> screen.putline;
                         if);
                         (if true//machineMatch then leave tandem if);
                    for);
               #); (* End of machine-dependent property handling *)
               
            // 'fswitch'->prop.equal then
               
            // 'on'->prop.equal then (* skip at this point, read in translate *)
            // 'off'->prop.equal then (* skip at this point, read in translate *)
            // 'nolink'->prop.equal then True -> NoLink;
            // 'donecheck'->prop.equal // 'depfrag'->prop.equal 
            // 'unique_group_id'->prop.equal // 'comment'->prop.equal 
            // 'library'->prop.equal // 'include'->prop.equal then 
               (* skip *)
            else 
               '**** Warning: unrecognised property: ' -> screen.Puttext;
               prop[]-> screen.Putline;
           if);
        #);
#)#)
--xAstOpen:descriptor--
(# doParse: @Boolean;
   
do (if switch[10] then
   if);
   (fullname[],screen[]) -> top.open
   (# astOverflow::<
        (# 
        do cleanUpAfterException; 
           '\nAst overflow. The file:\n\t'->msg;
           fullName[]->msg.append;
           '\nis too big!\n'->msg.append;
           'You will have to split this file into smaller fragments.\n'
             ->msg.append;
           (*fullName[]->top.Close;*)
           (*msg[]->MPSerror*)
        #);
      doubleFormDeclaration::<
        (#
        do cleanUpAfterException; (*fullName[]->top.namedClose;*)
           (*offendingFormName[]->DoubleFormError*)
        #);
      ReadAccessError::< 
        (# do cleanUpAfterException; (*transAccessError*) #);
      WriteAccessOnLstFileError::<
        (# do cleanUpAfterException; 
           (*'.lst'->fullName.copyAppend->transAccessError *)
        #);
      grammarNotFound::< 
        (# do cleanUpAfterException; (*msg[]->MPSError*) #); 
      FragmentNotExisting::< 
        (# do cleanUpAfterException; (*fullName[]->notExistingError*) #);
      BadFormat::< 
        (# 
        do cleanUpAfterException;
           '**** Error in fragment group: '->msg;
           fullName[]->msg.putLine;
           'The BETA grammar used for parsing the group is'->msg.putLine;
           'different from the BETA grammar used by the compiler.'
             ->msg.putLine;
           'All fragment groups must be translated by the '->msg.puttext;
           'same version of the BETA compiler.'->msg.putLine;
           msg[]->screen.putline;
           (*msg[]->MPSError; *)
        #);
      ParseErrors::< 
        (# G: ^fragmentGroup
        do cleanUpAfterException; (*fullName[]->top.namedClose;*)
           fullname[]->DependencyGraphPrivate.groupList.deleteGroup; 
           (*fullName[]->parseError;*)
           false->doParse;
        #);
      FatalParseError::< 
        (# G: ^fragmentGroup; 
        do '\nFatal parse error in fragment!'->msg.putline;
           (if errNo
            // 10 // 9 then
               'End-of-stream met while parsing a string or comment'->msg.putLine
           if);
           (fullName[],screen[])->top.open->G[];
           G.close;
           fullName[]-> DependencyGraphPrivate.groupList.deleteGroup;
           cleanUpAfterException;
               (*(if reOpen then fullName[]->closedNotification if);*)
           msg[]->screen.putline;
           (*fullName[]->parseError;*)
           false ->doParse;
        #);
      WriteAccessError::< 
        (# do cleanUpAfterException; (*transAccessError*) #);
      StartingParsing::< 
        (# 
        do 
               'Parsing: '-> screen.puttext; 
               ''''->screen.put;
               (if switch[35] then
                   fullname[]->screen.puttext;
                else
                   localname[]->screen.puttext;
               if);
               ''''->screen.put;
           true -> doParse;
   #)#) -> g[];
   (if g[]//NONE then
       (# S: ^text;
       do 'Cannot open fragment-file : '->S[];
          Fullname[]->S.putLine;
          (*S[]->MPSError; *)
       #);
   if);
   (if doParse then
       (*(false,AST[],g[]) -> setDoneCheckProperty;*)
       screen.newline;
   if)
#)
--xCheckCodeSubDir: descriptor--
(# codeDir: @directory
     (# doCreateDir: createDir
          (# error::< 
               (* createDir can fail (UNIX only?) if path is empty 
                * or for one of the following reasons (from "man 2 mkdir"):
                * [EACCES] A component of the path prefix denies search
                *          permission.                
                * [EACCES] The parent directory of the new directory 
                *          denies write permission.                
                * [EEXIST] The named file already exists.                
                * [EFAULT] path points outside the process's allocated address
                *          space.  The reliable detection of this error is
                *          implementation dependent.                
                * [EIO] An I/O error occurred while writing to the file system.
                * [ELOOP] Too many symbolic links are encountered in 
                *         translating the path name.                
                * [EMLINK] The maximum number of links to the parent directory,
                *          {LINK_MAX}, would be exceeded.                
                * [ENAMETOOLONG] The length of the specified path name 
                *                exceeds PATH_MAX bytes, or the length of a 
                *                component of the path name exceeds NAME_MAX 
                *                bytes while _POSIX_NO_TRUNC is in effect.
                * [ENOENT] A component of the path prefix does not exist.
                * [ENOSPC] Not enough space on the file system.
                * [ENOTDIR] A component of the path prefix is not a directory.
                * [EROFS] The named file resides on a read-only file system.
                *)               
               (# 
               do cleanUpAfterException; (*codeDirPath[]->transCreateDirError*)
               #)
          #)
     #);
   codeDirEntry: @diskEntry
     (# doExists: exists
          (# error::< 
               (* exists can fail for the following reasons (UNIX only?):
                *   1. path is empty
                *   or (from "man lstat")
                *   2. A component of the path prefix is not a directory.
                *   3. Search permission is denied for a component of 
                *      the path prefix.
                *   4. Too many symbolic links were encountered in 
                *       translating the path name.
                *   5. The length of the specified path name exceeds PATH_MAX 
                *      (255 or 1023 machine dependent) bytes
                *)
               (# T: @text
               do cleanUpAfterException; 
                  (* the *** in order to distingusihthis exception from
                   * the above one
                   *)
                  (*'      ***'->codeDirPath.copyAppend->transCreateDirError*)
     #)#)#);

   asmFileName,FullFN,codeDirPath,codeSubDir: ^text; 
   dirCh: @char; lastslash: @integer;
   
   (* NOTE: a change has been made to also handle b2c compiler variants.
    * checkCodeSubDir has been extended with an additional parameter
    *    subDir
    * which for non b2c compilers is asmLink.asmExt.
    * For b2c compilers the procedure is called twice:
    *    1.  subDir = 'b2c'
    *    2.  subDir = asmLink.asmExt
    *)
do (*g[]-> createAsmFileName -> asmFileName[];*)
   (g.nameT.copy,asmDir)->insertSubDir(#do asmExt->path.append #)
     ->asmFileName[];
   thePathHandler.DirectoryChar->asmFilename.findCh(#do inx->lastSlash #);
   (0,lastSlash-1)->asmFilename.sub->codeDirPath[]->codeDirEntry.path;
   (* codeDirPath = (users/borge/mycode/foo/sun4s (e.g.) *)   
   thePathHandler.DirectoryChar
     ->codeDirPath.findCh(# do inx -> lastSlash #);
   
   (0,lastSlash-1)->codeDirPath.sub->codeDir.name;
   (lastSlash+1,codeDirPath.length)->codeDirPath.sub->codeSubDir[];

   
   (* codeDir = /users/borge/mycode/foo *)

   (if switch[397] then 
       '\nChekCodeSubDir:\n'->screen.puttext; 
       codeDir.name->screen.putline;
       codeDirEntry.path->screen.putline;
       codeSubDir[]->screen.putline
   if);
   (if not codeDirEntry.doexists then
       (if switch[397] then
           'Does NOT exists: '->screen.puttext;
           codeDirEntry.path->screen.putline
       if);
       codeSubDir[]->codeDir.docreateDir
   if);

#)
--xTryToGC: dopart--
do theController.justOpen -> e.g.controller.status;
   NONE -> e.g.origin;
--xcontrolBody:dopart--
do INNER;
   false->nonEmpty;
   <<SLOT xControlMDInit: descriptor>>;
   translist.init;
   bodylist.init;
   DependencyGraphPrivate.groupList.scan (# do current[]->DependencyGraphPrivate.groupList.TryToGC #);
   
   doRealOpen->ASTval;
   false->doRealOpen;
   
   (if rootFragment[] // none then stop if);
   (*(trace.topOpen,true)->trace.set;*)
   (rootFragment[],'')->DependencyGraphPrivate.groupList.insertGroup->&buildGraph;

   (if nonEmpty=false then
       '\n\n*** The file is empty!'->screen.putLine;
       (*11->msg*)
   if);
   (if not doDomain then L: (if BodyList.Complete // false then restart L if)if);

   L: transList.scanAndClear(# do current[]->&translate #);
   ASTval->DoRealOpen;
   
--xDependencyGraphInit: dopart--
do   DependencyGraphPrivate.groupList.init;

