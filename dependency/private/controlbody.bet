ORIGIN 'dependencyBody';
(*BODY 'heapanalyzis'*)
--scanProperties:descriptor--
(# PropError:
     (# p,t: ^text; n: @integer; warning: @boolean;
     enter(p[],t[], n)
     do (theGroup[],p[],t[],n,CloseGroup(#do theGroup[] -> g[]#)) 
          -> PropertyException
     #);
   CheckPropValue:
     (* checks if a property value is one of the reserved properties, like
      * ORIGIN, BODY, etc.
      * If this is true, a warning is generated.
      * n is assumed to be in lower case.
      *)
     (#  p,n: ^text 
     enter(p[],n[])
     do (* n is assumed to be lowercase *)
        (if true
         // 'origin'->n.equal // 'body'->n.equal // 'mdbody'->n.equal
         // 'objfile'->n.equal // 'libfile'->n.equal // 'linkopt'->n.equal 
         // 'betarun'->n.equal // 'make'->n.equal // 'fswitch'->n.equal 
         // 'on'->n.equal // 'off'->n.equal // 'nolink' ->n.equal
         // 'donecheck'->n.equal 
         // 'slots' -> n.equal then 
            (p[],n[],2)->PropError
        if)
     #);
   originSetHere: @boolean (* code using this var. is made by ESS;
                            * is needed to handle situations where other tools
                            * like the debugger may already have setup origin
                            *)
do false -> originSetHere; 
   theGroup.prop.ScanProp
   (# doProp::<
        (# betaRunProp,libFileProp,makeProp,resProp,linkOptProp,
           objFileProp,MDBodyProp: @boolean 
        do prop.makelc; 
           (*'scanprop:'->puttext; prop[]->putline;*)
           (if true 
            // 'origin' -> prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::<
                    (# 
                    do 395->xtrace
                       (#do ' group:'->xT; theGroup.nameT[]->xT;
                          '\n\torigin:'->xT; S[]->xT; xN
                       #);
                       (if originSetHere (*theGroup.origin<>NONE*) then 
                           (none,s[],1)->PropError 
                       if);
                       (if s.length=0 then
                           (* empty file name: '' *)
                           ('origin',theGroup.fullname,4)->propError;
                        else
                           (s[],theGroup.nameT[]) 
                             -> OpenGroup
                             -> next[] 
                             -> theGroup.origin;
                           true -> originSetHere;
                           (if next.controller.status < doneTranslate then
                               next[] -> &buildGraph
                           if);
                           (theGroup[],next[]) -> setGroupTime;
                       if);
                    #);
                  doName:: (#do ('origin',n[],3)->propError #);
               #);
            // 'body'->prop.equal then
               true->nonEmpty; 
               ScanParameters
               (# doString::
                    (#
                    do (if s.length=0 then
                           (* empty file name: '' *)
                           ('body',theGroup.fullname,4)->propError;
                        else
                           (s[],theGroup.nameT[])
                             -> OpenGroup
                             -> next[];
                           (if next.controller.status < doneTranslate then
                               next[] -> private.bodyList.insert
                           if);
                       if)
                    #);
                  doName:: (#do ('body',n[],3)->propError #)
               #);
            // ('mdbody'->prop.equal->MDBodyProp)
            // ('objfile'->prop.equal->objFileProp)
            // ('libfile'->prop.equal->libFileProp) 
            // ('linkopt'->prop.equal->linkOptProp) 
            // ('betarun'->prop.equal->betarunProp)
            // ('make'->prop.equal->makeProp)
            // ('resource'->prop.equal->resProp)
               then
               true->nonEmpty; 
               (* Machine dependent properties :
                * Example: objfile sun     './vaffel.o'
                *                  hp      './filur.o'
                *                  default './andre.o'
                * (here theProp='objfile' is assummed).
                * When the property value ('./vaffel.o' etc. 
                * depending on TargetMachine)
                * is determined, PropertyAction.doString is called.
                *)
               (# thisMachine,foundSomething,machineMatch: @boolean;
               do tandem:
                    (* On first iteration look for exact matching machine 
                     * name. If not found try a second round, looking for 
                     * 'default'.
                     *)
                    (for iteration: 2 repeat
                         false -> thisMachine;
                         ScanParameters
                         (# doName::
                              (#
                              do (if iteration = 1 then
                                     targetMachine[]->n.equal->thisMachine;
                                  else
                                     n.makeLC;
                                     'default'->n.equal->thisMachine;
                                 if);
                                 machineMatch or thisMachine -> machineMatch;
                                 (prop[],n[])->CheckPropValue
                              #);
                            doString::
                              (# t: ^Text;
                                 f: @file;
                              do (if s.length=0 then
                                     (* empty file name: '' *)
                                     (if MDBodyProp then
                                         (prop[],theGroup.fullname,4)->propError
                                      else
                                         (* accept '' for others *)
                                         true->foundSomething;
                                     if)
                                  else
                                     (if thisMachine then
                                         true -> foundSomething;
                                         &Text[] ->t[];
                                         s -> t;
                                         t[] -> ExpandMacro;
                                         (if true
                                          // makeProp then
                                             (t[],theGroup.nameT[]
                                               -> stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[];
                                             (if switch[390] then
                                                 t[] -> f.name;
                                                 (if f.entry.exists  then
                                                     (* make file exists *)
                                                     (*AST.*)astFileExtension
                                                       -> theGroup.nameT.CopyAppend
                                                       -> f.name;
                                                     (if switch[399] or f.entry.writeable  then
                                                         (* groupfile is writeable and/or switch is true *)
                                                         t[] -> isFile;
                                                         (makeProperty,t[]) 
                                                           -> CurrentProperty
                                                     if);
                                                  else
                                                     (* if group file is not writeable then issue warning *)
                                                     (*AST.*)astFileExtension
                                                       -> theGroup.nameT.CopyAppend
                                                       -> f.name;
                                                     (if switch[399] or f.entry.writeable  then
                                                         (* groupfile is writable and/or switch is true *)
                                                         t[] -> isFile;
                                                     if);
                                                 if)
                                              else (* old way *)
                                                 t[] -> isFile;
                                                 (makeProperty,t[]) 
                                                   -> CurrentProperty
                                             if);
                                          // resProp then
                                             (t[],theGroup.nameT[]
                                               ->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[]
                                               -> isFile;
                                             (resourceProperty,t[])
                                               -> currentProperty
                                          // libFileProp then
                                             (t[],theGroup.nameT[]->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath
                                               -> t[]
                                               -> isFile;
                                             (libfileProperty,t[]) 
                                             -> CurrentProperty
                                          // linkOptProp then
                                             (linkoptProperty,t[]) 
                                               -> CurrentProperty
                                          // objFileProp then
                                             (t[],theGroup.nameT[]->stripPathName) 
                                               -> (*AST.*)thePathHandler.convertFilePath 
                                               -> t[]
                                               -> isFile;
                                             (objfileProperty,t[]) 
                                               -> CurrentProperty
                                          // MDBodyProp then
                                             (t[],theGroup.nameT[]) 
                                               -> OpenGroup
                                               -> next[];
                                             (if next.controller.status<doneTranslate
                                             then
                                                 next[] -> private.bodyList.insert;
                                             if);
                                          // betarunProp then
                                             (betarunProperty,t[]) -> CurrentProperty;
                                 if)if)if)
                              #);
                         #); (* scan parameters *)
                         (if ((not foundSomething) and
                             ((iteration=2) or machineMatch)) then
                             (prop[],targetMachine[],6)->PropError
                         if);
                         (if machineMatch then leave tandem if);
                    for);
               #); (* End of machine-dependent property handling *)
               
            // 'fswitch'->prop.equal then
                         (* !!!ScanParameters(# doString::<(# do S->AsmLink.fSwitch #) #)*)
               
            // 'on'->prop.equal then (* skip at this point, read in translate *)
            // 'off'->prop.equal then (* skip at this point, read in translate *)
                // 'nolink'->prop.equal then (*True -> AsmLink.NoLink;*)
            // 'donecheck'->prop.equal // 'depfrag'->prop.equal 
            // 'unique_group_id'->prop.equal // 'comment'->prop.equal 
            // 'library'->prop.equal // 'include'->prop.equal 
            // 'slots' -> prop.equal then 
               (* skip *)
            else (prop[],'',5)->PropError
           if);
        #);
#)#)
--AstOpen:descriptor--
(# doParse: @Boolean;
   
do (*(if switch[10] then
       (* force parsing
        (10,true)->AST.Trace.set
        if);*)
   (*!!!!!!!!!!!
    * fullname[]->common.theGroupName[]; 
    * may be accessed if exception is raised
    * by AST.top.open
    *)
   381->xtrace(#do 'AstOpen: '->xT; fullname[]->xT; xN #);
   (fullname[],messagestream[]) -> (*AST.*)top.open
   (# astOverflow::<
        (# 
        do cleanUpAfterException; 
           '\nAst overflow. The file:\n\t'->msg;
           fullName[]->msg.append;
           '\nis too big!\n'->msg.append;
           'You will have to split this file into smaller fragments.\n'
             ->msg.append;
           (*fullName[]->(*AST.* )top.Close;*)
           msg[]->MPSException
        #);
      StartingParsing::< 
        (# 
        do (if xverboseLevel<=xverboseLevel.actions then 
               'Parsing: '-> infostream.puttext; 
               ''''->infostream.put;
               (if switch[35] then
                   fullname[]->infostream.puttext;
                else
                   localname[]->infostream.puttext;
               if);
               ''''->infostream.put;
           if);
           true -> doParse;
        #);
      FragmentNotExisting::< 
        (# do cleanUpAfterException; fullName[]->notExistingException #);
      grammarNotFound::< 
        (# do cleanUpAfterException; msg[]->MPSException #); 
      BadFormat::< 
        (# 
        do cleanUpAfterException;
           '**** Error in fragment group: \n\t'->msg;
           fullName[]->msg.putLine;
           'The BETA grammar used for parsing the group is'->msg.putLine;
           'different from the BETA grammar used by the compiler.'
             ->msg.putLine;
           'All fragment groups must be translated by the '->msg.puttext;
           'same version of the BETA compiler.'->msg.putLine;
           msg[]->messagestream.putline;
           msg[]->MPSException; 
        #);
      ParseErrors::< 
        (# G: ^(*AST.*)fragmentGroup
        do cleanUpAfterException; (*fullName[]->(*AST.* )top.namedClose;*)
           fullname[]->DGP.groupList.deleteGroup; 
           fullName[]->parseException;
           false->doParse;
        #);
      FatalParseError::< 
        (# G: ^(*AST.*)fragmentGroup; 
        do (* 5/2/96: according to JLK, this is no longer necessary; KJM has 
            * apparently fixed mps!
            * (fullName[],messagestream[])->(*AST.* )top.open->G[];
            * G.close;
            *)
           fullName[]-> DGP.groupList.deleteGroup;
           cleanUpAfterException;
               (*(if reOpen then fullName[]->closedNotification if);*)
           (* msg from bobs *)
           '\n\n***** '->msg.prepend;
           msg[]->messagestream.putText;
           fullName[]->parseException;
           false ->doParse;
        #);
      doubleFormDeclaration::<
        (#
        do cleanUpAfterException; (*fullName[]->top.namedClose;*)
           this(AstInterface).offendingFormName[]->DoubleFormException
        #);
      ReadAccessError::< 
        (# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessError::< 
        (# do cleanUpAfterException; fullname[] -> transAccessException #);
      WriteAccessOnLstFileError::<
        (# do cleanUpAfterException; 
           '.lst'->fullName.copyAppend->transAccessException 
        #);
      EOSerror::(#do 'EOS'->putline #);
      NoSuchFileError::
        (#do cleanUpAfterException; fullName[] -> notExistingException #);
      FileExistsError::
        (# T: @text 
        do cleanUpAfterException; 
           'MPS:top.open exception "FileExistsError" for: '->T;
           FullName[] ->T.append;
           T[] -> MPSException
        #);
      NoSpaceLeftError::(#do cleanUpAfterException;  NoSpaceException #); 
      OtherFileError::
        (#do cleanUpAfterException; fullName[]->notExistingException #);
   #) 
     -> g[];
   (if g[] = NONE then
       (# S: ^text;
       do 'Cannot open fragment-file : '->S[];
          Fullname[]->S.putLine;
          S[]->MPSException; 
       #);
   if);
   381->xtrace(#do ' Group: '->xT; g.nameT[]->xT; xN #);
   (if doParse then
       (* !!!!!!!!!!
        * (false,this(AstInterface)[],g[]) -> setDoneCheckProperty;
        *)
        (if switch[4] then 
           ' Re-organizing fragment...'->infostream.puttext;
           g[]->addVirtualSuper; '...'->infostream.puttext;
            (* !!!!!! g[]->this(AstInterface).compact *)
        if);
       (if xverboseLevel<= xverboseLevel.actions then infostream.newline if);
   if)
#)
  
---- TryToGC: dopart ----
do (if e.g.controller.status=-1 then
       (*!!!!!!!!!!!!!!!!
       (if e.g.nameT[]->closedNotification then
           e.g.close;
           NONE -> e.g[];
           e[] -> delete;
        if);*)
    else
       (if e.g.controller.status>justOpen then
           (* fragmentgroup has been opened or used in last
            * translate.
            * Reinitialize it
            *)
           justOpen -> e.g.controller.status;
           NONE -> e.g.origin;
        else
           (* fragment not used in last trans
            * decrement status
            *)
           (if lastTransWasReal then
               e.g.controller.status-1 -> e.g.controller.status;
   if)if)if)

---controlBody:dopart---
do false -> DGP.hasProgramSlot;

   translist.init;
   bodylist.init;
   DGP.groupList.scan (# do current[]->DGP.groupList.TryToGC #);

   (*AST.*)doRealOpen->ASTval;
   false->(*AST.*)doRealOpen;

   (if rootFragment[] = none then stop if);
   (if xverboseLevel < xverboseLevel.nothing then
       'Building dependency graph for: '''->infostream.putText;
       rootFragment[]->infostream.puttext;
       ''' ...'->infostream.putline;
   if);
   (if switch[382] then
       (if lastRootFragment[]<>NONE then
           (if lastRootFragment[]->rootFragment.equal then
               true->handledUsingList;
               'Repeating translation...'->infostream.putline;
               DGP.groupList.scan
               (# t: @text; m: @integer;
                  g: ^(*AST.*)fragmentGroup;
                  name,fullname: ^Text;
               do (if current.g.controller.status=justOpen then
                      current.g.nameT->t;
                      '.bet'->t.append;
                      t[]->getmodtime->m;
                      current.g[]->g[];
                      (if m>g.modtime then
                          (if switch[384] then
                              t[]->tracestream.puttext;
                              m->tracestream.putint; ' '->tracestream.put;
                              g.modtime->tracestream.putint;
                              '.bet has changed'->infostream.putline;
                          if);
                          current.g.controller.printname[]->name[];
                          current.g.fullname->fullname[];
                          g.close;
                          NONE->g[];
                          (fullname[],name[])->ASTOpen->g[];
                          current.g.controller.printname[]->g.controller.printname[];
                          g[]->current.g[];
                          isOpen->g.controller.status;
                          g[]->buildgraph;
                       else
                          current.g.nameT->t;
                          (*AST.*)astFileExtension->t.append;
                          (* checking the group file *)
                          t[]->getmodTime->m;
                          (if m>current.g.modTime then 
                              (if switch[384] then
                                  t[]->tracestream.puttext;
                                  m->tracestream.putint; ' '->tracestream.put;
                                  current.g.modtime->tracestream.putint;
                                  '.ast has changed'->tracestream.putline;
                              if);
                              current.g.checkDiskRepresentation;
                              isOpen->current.g.controller.status;
                              current.g[]->buildgraph;
                           else
                              (if switch[384] then
                                  'Nothing for: '->tracestream.puttext;
                                  t[]->tracestream.putline;
                              if);
                          if);
                      if)
                  if)
               #);
           if)
   if)if);
   (if not handledUsingList then
       (rootFragment[],'')
         -> OpenGroup
         -> &buildGraph;
   if);
   (if not giveDomain then
       L: (if not BodyList.Complete then restart L if)
   if);

   (if not switch[395]  then
       (if xverboseLevel<xverboseLevel.nothing then
           'Translating fragments ...'->infostream.putline;
       if);
       transList.scanAndClear(# do current[]->&translate #);
       (if switch[388]  then 
           'GroupList  '->tracestream.puttext;
           DGP.groupList.statistics(# do screen[]->print #);
       if);
   if);
   ASTval->(*AST.*)DoRealOpen;
   rootFragment.copy->lastRootFragment[];

--DependencyGraphInit: dopart--
do DGP.groupList.init;
   <<SLOT ControlMDInit: descriptor>>; (* to compiler ? *)
   INNER Init;
   (if errorStream[] = NONE then screen[] -> errorStream[] if);
   (if traceStream[] = NONE then screen[] -> traceStream[] if);
   (if messageStream[] = NONE then screen[] -> messageStream[] if);
   (if infoStream[] = NONE then screen[] -> infoStream[] if);
