ORIGIN '../dependency';
INCLUDE '~beta/sysutils/v1.4.2/envstring'
--xDependencyGraphLib: attributes--

   singleLinkedList:
   (#
      Insert:<
      (# E: ^elm;
      do &elm[] -> E[]; 
         INNER;
         head[] -> E.succ[]; 
         E[] -> head[];
      #);

      Scan:
      (# thisElm: ^Elm
      do head[] ->ThisElm[];
         L: 
         (if (thisElm[]<>NONE)  then
             INNER;
             thisElm.succ[] -> thisElm[];
             restart L
         if);
      #); 

      clear: (# do NONE -> head[] #);

      Elm:< (# succ: ^elm #);

       
      (*---------- private --------------*)
      head: ^Elm;
   #);

   HeapSize: (# #);

   makeTextRef: (# T: @text; enter T exit T[] #);

   SrcExt: (# exit '.bet' #);
   TrmExt: (# exit '.group' #); 
   LstExt: (# exit '.lst' #);
   CmdExt: (# exit '.cmd' #);

   InsertSubDir:
   (* Inserts the directory name TargetDirectory immedidately before the
      base name of the entered path name. E.g. if TargetDirectory='sun3'
      and path='/home/frede/beta/system/v3.9/control' then the result will
      be:      '/home/frede/beta/system/v3.9/sun3/control'.
      Another example:  path='fusk' will result in: 'sun3/fusk'.
   *)
   (# path: ^text; dirCh: @text;
      lastSlash,L: @integer;
      asmDir: @boolean
   enter(path[],asmDir)
   do thePathHandler.DirectoryChar -> path.findCh(# do inx -> lastSlash #);
      (if false(*b2c*) then
          (# T: @text
          do 'b2c'->T; 3->L;
             (T[],lastSlash+1) -> path.insert;
             (if not asmDir then
			     T.clear;
			     thePathHandler.DirectoryChar->T.put;
                 (T[],lastSlash+4)->path.insert;
                 (TargetDirectory[],lastSlash+5) -> path.insert;
                 4+TargetDirectory.length->L;
          if)#)
       else
          TargetDirectory.length->L;
          (TargetDirectory[],lastSlash+1) -> path.insert;
      if);
      thePathHandler.DirectoryChar->dirCh.put;
      (dirCh[],lastSlash+1+L)-> path.insert;
      inner;
   exit path[]
   #);

   ExpandMacro:
   (* Enters a text string and replaces every occurence of the char '$' 
      in it with the string TargetDirectory (assumed not to contain any '$').
      WARNING : This operation destroys the entered text.
   *)
   (# macroChar: (# exit '$' #);
      T: ^text;
   enter T[]
   do
      t[] -> expandEnvVar -> t[];
      rundkoersel: macroChar -> T.findCh
      (#
      do 
         (inx,inx) -> T.Delete;   (* Delete the '$'. *)
         (TargetDirectory[],inx) -> T.Insert;
         restart rundkoersel      (* Necessary? *)
      #);
   exit T[]
   #);

   isFile:
   (# F: @File
   enter F.name
   do (if F.entry.exists//false then 
          screen.newline; '**** Warning! File does not exist: ' -> screen.puttext;
          F.name->screen.Putline;
      if)
   exit F.name
   #);

   ScanForms:
   (* scan all fragment forms in a group *)
   (# FG: ^FragmentGroup; 
     current: ^FragmentForm;
   enter FG[]
   do FG.FragmentList.scan
      (#
      do (if current.type // formType then
             current.f[] -> this(ScanForms).current[];
			 inner ScanForms;
      if)#)
   #);

   ScanLinks:
   (* scan all fragment Links in a group *)
   (# FG: ^FragmentGroup; 
      current: ^FragmentLink;
   enter FG[]
   do
      FG.FragmentList.scan
      (# FL: ^fragmentLink; T: ^text
      do (if current.type // linkType then
             newfragmentLink -> fl[] -> current.F[];
             current.fullNameOfLink[] -> fl.fullNameOfLink[];
             current.localName[]-> fl.localName[];
             current.name[]-> fl.name;
             FG[] -> fl.father;
             fl[] ->this(ScanLinks).current[];
             INNER ScanLinks
         if)
      #)
   #);


