ORIGIN '../dependency';
INCLUDE '~beta/sysutils/v1.5/envstring'
---dependencyGraphLib: attributes ----
ExpandMacro:
   (* Enters a text string and replaces every occurence of the char '$' 
    * in it with the string TargetDirectory (assumed not to contain any '$').
    * WARNING : This operation destroys the entered text.
    *)
   (# macroChar: (# exit '$' #);
      T: ^text;
   enter T[]
   do t[] -> expandEnvVar -> t[];
      Loop: macroChar -> T.findAll
      (#
      do (inx,inx) -> T.Delete;   (* Delete the '$'. *)
         (TargetDirectory[],inx) -> T.Insert;
         restart loop      (* Necessary? *)
      #);
   exit T[]
   #);

ExpandMacro2:
   (* Enters a text string and replaces every occurence of the '$$' 
    * in it with the string TargetDirectory (assumed not to contain any '$$').
    * A $ prefixed by a \ is ignored as in 'hello\$me'.
    * WARNING : This operation destroys the entered text.
    *)
   (# macroChar: (# exit '$' #);
      T,S: ^text; lastWasSlash: @ boolean
   enter T[]
   do Loop: macroChar -> T.findAll
      (#
      do replace:
           (#do
              (if 1 < inx then
                  (if (inx-1 -> T.inxGet) = '\\' then leave replace 
              if)if);
              (if inx < t.lgth then
                  (if (inx+1 -> T.inxGet) <> '$' then leave replace 
                  if)
               else leave replace
              if);
              (inx,inx+1) -> T.Delete;   (* Delete the '$$'. *)
              (TargetDirectory[],inx) -> T.Insert;
              restart loop      (* Necessary? *)
           #)
      #);
      &text[] -> S[];

      (* replace '\$' by '$' *)
      T.scanAll
      (#
      do (if lastWasSlash then
             (if ch <> '$' then '\\' -> S.put; if);
         if);
         (if ch = '\\' then true -> lastWasSlash 
          else  ch -> S.put;
             false -> lastWasSlash;
      if)#);
      (if lastWasSlash then '\\' -> S.put if);
      20->xtrace(#do T[] -> xT; xN; S[] -> xT; xN #);
   exit S[]
   #);

ScanForms:
  (* scan all fragment forms in a group *)
  (# FG: ^FragmentGroup; 
     current: ^FragmentForm;
  enter FG[]
  do FG.FragmentList.scan
     (#
     do (if current.type // formType then
            current.f[] -> this(ScanForms).current[];
            inner ScanForms;
     if)#)
  #);

ScanLinks:
  (* scan all fragment Links in a group *)
  (# FG: ^FragmentGroup; 
     current: ^FragmentLink;
  enter FG[]
  do
     FG.FragmentList.scan
     (# FL: ^fragmentLink; T: ^text
     do (if current.type // linkType then
            newfragmentLink -> fl[] -> current.F[];
            current.fullNameOfLink[] -> fl.fullNameOfLink[];
            current.localName[]-> fl.localName[];
            current.name[]-> fl.name;
            FG[] -> fl.father;
            fl[] ->this(ScanLinks).current[];
            (*397->trace
            (#do 'include:'->xT;
               current.fullNameOfLink[]->xT; xN;
               current.localName[]->xT; xN;
               current.name[]->xT; xN;
             #);*)
            INNER ScanLinks
        if)
     #)
  #);

