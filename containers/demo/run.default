
############# Running arrayConDemo
arrayCon1.put: 18,17,16,15,14,13,
arrayCon1.capacityExtend
arrayCon1.put: 12,11,10,9,
arrayCon1.elements: 18,17,16,15,14,13,12,11,10,9,
arrayCon1.capacity: 12
arrayCon1.size: 10
arrayCon2.elements: 1,2,3,4,5,6,7,8,9,10,
arrayCon1->arrayCon2: 18,17,16,15,14,13,12,11,10,9,
7->arrayCon2.get: 12
arrayCon1.bubbleSort: 9,10,11,12,13,14,15,16,17,18,
arrayCon1.shellSort: 9,10,11,12,13,14,15,16,17,18,
arrayCon1.quickSort: 9,10,11,12,13,14,15,16,17,18,

############# Running classificationDemo
intClass1.size: 6
intClass1.elements: 14,13,12,11,10,9,
intClass2.size: 6
intClass2.elements: 6,5,4,3,2,1,
intClass3.size: 6
intClass3.elements: 10,9,8,7,6,5,
4->intClass2.delete: 6,5,3,2,1,
intClass2[]->intClass3.insertSubset: 10,9,8,7,{6,5,3,2,1,}
10->intClass3.has: yes: 10,9,8,7,{6,5,3,2,1,}
intClass1[]->intClass2.insertSubset: 6,5,3,2,1,{14,13,12,11,10,9,}
intClass1.scanUnclassified: 14,13,12,11,10,9,
intClass2.scanUnclassified: 6,5,3,2,1,
intClass3.scanUnclassified: 8,7,
3->intClass1.has: no: 14,13,12,11,10,9,
3->intClass3.has: yes: 8,7,{6,5,3,2,1,{14,13,12,11,10,9,}}
intClass1.size: 6
intClass3.size: 13
3->intClass1.insert: 3,14,13,12,11,10,9,
intClass1.size: 7
intClass3.size: 13
3->intClass1.has: yes: 3,14,13,12,11,10,9,
3->intClass3.has: yes: 8,7,{6,5,2,1,{3,14,13,12,11,10,9,}}
3->intClass3.delete: 8,7,{6,5,2,1,{14,13,12,11,10,9,}}

############# Running hashTableDemo
hashtable1.capacity: -1
hashtable1.range: 2
hashtable1.elements: 3,1,4,2,
hashtable1.size: 4

hashtable2.capacity: -1
hashtable2.range: 4
hashtable2.elements: 5,6,7,4,
hashtable2.size: 4

hashtable3.elements: 7,8,9,10,

3->hashtable3.delete: 7,8,9,10,

hashtable2->hashtable3; hashtable1[]->hashtable3.diff: 5,6,7,
hashtable2->hashtable3; hashtable1[]->hashtable3.sect: 4,
hashtable4.capacity: -1
hashtable4.range: 2
hashtable4.elements: 7,5,6,4,
hashtable4.size: 4
hashtable4.statistics(# do screen[]->print #): 
Histogram: (2,2)
Maximum Collisions: 2
Minimum Collisions: 2
Average Collisions: 2
1->hashtable4.scanIndexed(# ... #): 7 5 found
2->hashtable4.scanIndexed(# ... #): 6 4 found
3->hashTable4.extend(# do hashTable4.rehash #)
1->hashtable4.has: no
2->hashtable4.has: no
3->hashtable4.has: no
4->hashtable4.has: yes
5->hashtable4.has: yes
6->hashtable4.has: yes
7->hashtable4.has: yes
8->hashtable4.has: no
9->hashtable4.has: no
10->hashtable4.has: no
1->hashtable4.scanIndexed(# ... #): 6 found
2->hashtable4.scanIndexed(# ... #): 7 found
3->hashtable4.scanIndexed(# ... #): found
4->hashtable4.scanIndexed(# ... #): 4 found
5->hashtable4.scanIndexed(# ... #): 5 found
hashtable4.range: 5
hashtable4.elements: 6,7,4,5,
hashtable4.size: 4
hashtable4.statistics(# do screen[]->print #): 
Histogram: (1,1,0,1,1)
Maximum Collisions: 1
Minimum Collisions: 0
Average Collisions: 1

############# Running listDemo
intList1.prepend: 4,3,2,1,
intList2.append: 4,5,6,7,
intList2.scanReverse: 7,6,5,4,
intList1[]->intList2.concatenate->intList3[]: 4,5,6,7,4,3,2,1,
"10"->("2"->intList3.at).elm[]: 4,5,6,7,4,3,10,1,
6->intList2.at->intList2.delete: 4,5,7,
(8,7)->intList3.insertBefore: 4,5,6,8,7,4,3,10,1,
7->intList3.deleteAfter: 4,5,6,8,7,3,10,1,

############# Running multiSetDemo
intMultiSet1.elements: 4,3,2,1,
intMultiSet2.elements: 7,6,5,4,
intMultiSet2->intMultiSet3: 7,6,5,4,
"7"->intMultiSet3.delete: 6,5,4,
"4"->intMultiSet3.delete: 6,5,
intMultiSet1[]->intMultiSet2.union: 1,2,3,4,7,6,5,4,
intMultiSet1[]->intMultiSet2.diff: 7,6,5,
intMultiSet1[]->intMultiSet2.sect: 4,
intMultiSet1[]->intMultiSet2.symDiff: 1,2,3,7,6,5,4,
intMultiSet3.find(# predicate ::< (# "elm=4" #) #): 4
4->intMultiSet3.has: yes
10->intMultiSet3.has: no

############# Running recListDemo
intList1.elements: 4,3,2,1,
intList2.elements: 4,5,6,7,
intList3.elements: 10,9,8,7,
(intList1[],NONE)->intList3.insertSublistBefore: 10,9,8,7,(4,3,2,1,)
(intList1[],7)->intList3.insertSublistAfter: 10,9,8,7,(4,3,2,1,)(4,3,2,1,)
1->intList3.append: 10,9,8,7,(4,3,2,1,)(4,3,2,1,)1,
6->intList2.at->intList2.delete: 4,5,7,
intList2.scan: 4,5,7,
intList2.scanReverse: 7,5,4,
"5"->intList2.scanReverseFrom: 5,4,
intList2.last: 7
intList2.preample: 4,5,

############# Running seqConDemo
intStack.push: 1,2,3,4,
intStack.elements: 4,3,2,1,
intStack.top: 4
4*intStack.pop: 4,3,2,1,
intStack.elements: 

intQueue.insert: 4,5,6,7,
intQueue.elements: 7,6,5,4,
intQueue.front: 4
4*intQueue.remove: 4,5,6,7,
intQueue.elements: 

intPrioQ.insert: (1:p:2),(2:p:1),(3:p:3),(4:p:2),(5:p:1),(6:p:3),(7:p:2),(8:p:1),(9:p:3),(10:p:2),
intPrioQ.elements: 9,8,10,6,3,5,2,7,4,1,
1->intPrioQ.scanPriority: 8,5,2,
2->intPrioQ.scanPriority: 10,7,4,1,
3->intPrioQ.scanPriority: 9,6,3,
1->intPrioQ.front: 8
2->intPrioQ.front: 10
3->intPrioQ.front: 9
1,2,3->intPrioQ.remove: (1:p:8),(2:p:10),(3:p:9),
intPrioQ.elements: 3,2,1,6,5,7,4,
intPrioQ.size: 7
1->intPrioQ.scanPriority: 2,5,
2->intPrioQ.scanPriority: 1,7,4,
3->intPrioQ.scanPriority: 3,6,
2->intPrioQ.scanPriority(# "current<5" #): 1,4,

intPrioQ.copy->intPrioQref[]:3,2,1,6,5,7,4,
1->intPrioQref.scanPriority: 2,5,
2->intPrioQref.scanPriority: 1,7,4,
3->intPrioQref.scanPriority: 3,6,
intDeque.insertFront: 1,2,3,4,
intDeque.insertBack: 7,8,9,10,
intDeque.elements: 4,3,2,1,7,8,9,10,
intDeque.size: 8
intDeque.front: 4
intDeque.back: 10
4*intDeque.removeFront: 4,3,2,1,
4*intDeque.removeBack: 10,9,8,7,
intDeque.elements: 

############# Running setsDemo
intSet1.capacity: -1
****+intSet1.size: 4
intSet1.elements: 4,3,2,1,
intSet2.elements: 7,6,5,4,
intSet2->intSet3; intSet1->intSet3.union: 1,2,3,7,6,5,4,
intSet2->intSet3; intSet1->intSet3.symDiff: 1,2,3,7,6,5,
intSet3.find(# predicate::< (# "elm=7" #) #): 7
7->intSet3.has: yes
10->intSet3.has: no
