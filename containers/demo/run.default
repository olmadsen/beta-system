
############# Running dictionaryDemo
dictionary1.associate: 1,2,3,4,
dictionary1.elements: 4,3,2,1,
dictionary1.size: 4

dictionary2.associate: 
	(x4,4)
	(x5,5)
	(x6,6)
	(x7,7)

dictionary2.elements: 7,6,5,4,
dictionary2.size: 4

dictionary2.copy->dictionary3[]: 4,5,6,7,
x3->dictionary1.disassociate: 4,2,1,

x2->dictionary1.lookup: 2

dictionary3.find(# predicate ::< (# "elm=4" #) #): 4
4->dictionary3.lookup: yes
10->dictionary3.lookup: no
dictionary1.scanAssociations: 
	(x4,4)
	(x2,2)
	(x1,1)
dictionary2.scanAssociations: 
	(x7,7)
	(x6,6)
	(x5,5)
	(x4,4)
dictionary3.scanAssociations: 
	(x4,4)
	(x6,6)

############# Running arrayConDemo
arrayCon1.put: 18,17,16,15,14,13,
arrayCon1.capacityExtend
arrayCon1.put: 12,11,10,9,
arrayCon1.elements: 18,17,16,15,14,13,12,11,10,9,
arrayCon1.capacity: 12
arrayCon1.size: 10
arrayCon2.elements: 1,2,3,4,5,6,7,8,9,10,
arrayCon1->arrayCon2: 18,17,16,15,14,13,12,11,10,9,
7->arrayCon2.get: 12
arrayCon1.bubbleSort: 9,10,11,12,13,14,15,16,17,18,
arrayCon1.shellSort: 9,10,11,12,13,14,15,16,17,18,
arrayCon1.quickSort: 9,10,11,12,13,14,15,16,17,18,

############# Running classificationDemo
intClass1.size: 6
intClass1.elements: 9,10,11,12,13,14,
intClass2.size: 6
intClass2.elements: 1,2,3,4,5,6,
intClass3.size: 6
intClass3.elements: 5,6,7,8,9,10,
4->intClass2.delete: 1,2,3,6,5,
intClass2[]->intClass3.insertSubset: 9,10,7,8,{1,2,3,6,5,}
10->intClass3.has: yes: 9,10,7,8,{1,2,3,6,5,}
intClass1[]->intClass2.insertSubset: 1,2,3,6,5,{9,10,11,12,13,14,}
intClass1.scanUnclassified: 9,10,11,12,13,14,
intClass2.scanUnclassified: 1,2,3,6,5,
intClass3.scanUnclassified: 8,7,
3->intClass1.has: no: 9,10,11,12,13,14,
3->intClass3.has: yes: 8,7,{1,2,3,6,5,{9,10,11,12,13,14,}}
intClass1.size: 6
intClass3.size: 13
3->intClass1.insert: 9,10,11,12,13,14,3,
intClass1.size: 7
intClass3.size: 13
3->intClass1.has: yes: 9,10,11,12,13,14,3,
3->intClass3.has: yes: 8,7,{1,2,5,6,{9,10,11,12,13,14,3,}}
3->intClass3.delete: 8,7,{1,2,5,6,{9,10,11,12,13,14,}}

############# Running hashTableDemo
hashtable1.capacity: -1
hashtable1.range: 2
hashtable1.elements: 3,1,4,2,
hashtable1.size: 4

hashtable2.capacity: -1
hashtable2.range: 4
hashtable2.elements: 5,6,7,4,
hashtable2.size: 4

hashtable3.elements: 7,8,9,10,

3->hashtable3.delete: 7,8,9,10,

hashtable2->hashtable3; hashtable1[]->hashtable3.diff: 5,6,7,
hashtable2->hashtable3; hashtable1[]->hashtable3.sect: 4,
hashtable4.capacity: -1
hashtable4.range: 2
hashtable4.elements: 7,5,6,4,
hashtable4.size: 4
hashtable4.statistics(# do screen[]->print #): 
Histogram: (2,2)
Maximum Collisions: 2
Minimum Collisions: 2
Average Collisions: 2
1->hashtable4.scanIndexed(# ... #): 7 5 found
2->hashtable4.scanIndexed(# ... #): 6 4 found
3->hashTable4.extend(# do hashTable4.rehash #)
1->hashtable4.has: no
2->hashtable4.has: no
3->hashtable4.has: no
4->hashtable4.has: yes
5->hashtable4.has: yes
6->hashtable4.has: yes
7->hashtable4.has: yes
8->hashtable4.has: no
9->hashtable4.has: no
10->hashtable4.has: no
1->hashtable4.scanIndexed(# ... #): 6 found
2->hashtable4.scanIndexed(# ... #): 7 found
3->hashtable4.scanIndexed(# ... #): found
4->hashtable4.scanIndexed(# ... #): 4 found
5->hashtable4.scanIndexed(# ... #): 5 found
hashtable4.range: 5
hashtable4.elements: 6,7,4,5,
hashtable4.size: 4
hashtable4.statistics(# do screen[]->print #): 
Histogram: (1,1,0,1,1)
Maximum Collisions: 1
Minimum Collisions: 0
Average Collisions: 1

############# Running listDemo
intList1.prepend: 4,3,2,1,
intList2.append: 4,5,6,7,
intList2.scanReverse: 7,6,5,4,
intList1[]->intList2.concatenate->intList3[]: 4,5,6,7,4,3,2,1,
"10"->("2"->intList3.at).elm[]: 4,5,6,7,4,3,10,1,
6->intList2.at->intList2.delete: 4,5,7,
(8,7)->intList3.insertBefore: 4,5,6,8,7,4,3,10,1,
7->intList3.deleteAfter: 4,5,6,8,7,3,10,1,

############# Running multiSetDemo
intMultiSet1.elements: 1,2,3,4,
intMultiSet2.elements: 4,5,6,7,
intMultiSet2->intMultiSet3: 4,5,6,7,
"7"->intMultiSet3.delete: 4,5,6,
"4"->intMultiSet3.delete: 6,5,
intMultiSet1[]->intMultiSet2.union: 4,5,6,7,1,2,3,4,
intMultiSet1[]->intMultiSet2.diff: 7,5,6,
intMultiSet1[]->intMultiSet2.sect: 4,
intMultiSet1[]->intMultiSet2.symDiff: 4,5,6,7,1,2,3,
intMultiSet3.find(# predicate ::< (# "elm=4" #) #): 4
4->intMultiSet3.has: yes
10->intMultiSet3.has: no

############# Running recListDemo
intList1.elements: 4,3,2,1,
intList2.elements: 4,5,6,7,
intList3.elements: 10,9,8,7,
(intList1[],NONE)->intList3.insertSublistBefore: 10,9,8,7,(4,3,2,1,)
(intList1[],7)->intList3.insertSublistAfter: 10,9,8,7,(4,3,2,1,)(4,3,2,1,)
1->intList3.append: 10,9,8,7,(4,3,2,1,)(4,3,2,1,)1,
6->intList2.at->intList2.delete: 4,5,7,
intList2.scan: 4,5,7,
intList2.scanReverse: 7,5,4,
"5"->intList2.scanReverseFrom: 5,4,
intList2.last: 7
intList2.preample: 4,5,

############# Running seqConDemo
intStack.push: 1,2,3,4,
intStack.elements: 4,3,2,1,
intStack.top: 4
4*intStack.pop: 4,3,2,1,
intStack.elements: 

intQueue.insert: 4,5,6,7,
intQueue.elements: 4,5,6,7,
intQueue.front: 4
4*intQueue.remove: 4,5,6,7,
intQueue.elements: 

intPrioQ.insert: (1:p:2),(2:p:1),(3:p:3),(4:p:2),(5:p:1),(6:p:3),(7:p:2),(8:p:1),(9:p:3),(10:p:2),
intPrioQ.elements: 3,6,9,2,5,8,1,4,7,10,
1->intPrioQ.scanPriority: 2,5,8,
2->intPrioQ.scanPriority: 1,4,7,10,
3->intPrioQ.scanPriority: 3,6,9,
1->intPrioQ.front: 2
2->intPrioQ.front: 1
3->intPrioQ.front: 3
1,2,3->intPrioQ.remove: (1:p:2),(2:p:1),(3:p:3),
intPrioQ.elements: 6,9,5,8,4,7,10,
intPrioQ.size: 7
1->intPrioQ.scanPriority: 5,8,
2->intPrioQ.scanPriority: 4,7,10,
3->intPrioQ.scanPriority: 6,9,
2->intPrioQ.scanPriority(# "current<5" #): 4,7,10,

intPrioQ.copy->intPrioQref[]:4,7,10,5,8,6,9,
1->intPrioQref.scanPriority: 5,8,
2->intPrioQref.scanPriority: 4,7,10,
3->intPrioQref.scanPriority: 6,9,
intDeque.insertFront: 1,2,3,4,
intDeque.insertBack: 7,8,9,10,
intDeque.elements: 4,3,2,1,7,8,9,10,
intDeque.size: 8
intDeque.front: 4
intDeque.back: 10
4*intDeque.removeFront: 4,3,2,1,
4*intDeque.removeBack: 10,9,8,7,
intDeque.elements: 

############# Running setsDemo
intSet1.capacity: 2
****+intSet1.size: 4
intSet1.elements: 1,2,3,4,
intSet2.elements: 4,5,6,7,
intSet2->intSet3; intSet1->intSet3.union: 4,5,6,7,1,2,3,
intSet2->intSet3; intSet1->intSet3.symDiff: 3,5,6,7,1,2,
intSet3.find(# predicate::< (# "elm=7" #) #): 7
7->intSet3.has: yes
10->intSet3.has: no

############# Running listSelect
S1:
Peter Jensen 31 450000
Peter Hansen 21 250000
Lise Larsen 41 500000
Kirsten Olesen 36 300000
Lars Bak 41 350000

S2:
Peter Jensen 31 450000
Peter Hansen 21 250000

############# Running mySelect
S1:
Lars Bak 41 350000
Kirsten Olesen 36 300000
Lise Larsen 41 500000

S2:
Peter Jensen 31 450000
Peter Hansen 21 250000
