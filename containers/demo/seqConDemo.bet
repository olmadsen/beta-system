ORIGIN '~beta/containers/v1.6/seqContainers';
--- program:descriptor ---
(* This demo program illustrates the usage of the stack, queue, prioQueue and
 * deque patterns.  The demo is in four sections, illustrating each pattern.
 * 
 * At the end of this file, a copy of the output of this program is given
 *)
(# 
   intStack: @stack(# element ::< integerObject #);
   intQueue: @queue(# element ::< integerObject #);
   intPrioQueue: PrioQueue(# element ::< integerObject #);
   intPrioQ: @intPrioQueue;
   intPrioQref: ^intPrioQueue;
   intDeque: @deque(# element ::< integerObject #);
   
   int: @integer; i: [10]^integerObject; io: ^integerObject;
   
do (* initializing the integerObjects *)
   (for int:10 repeat &integerObject[]->i[int][]; int->i[int] for);
   
   (* initializing intStack and putting some integerObjects into it *)
   intStack.init;
   'intStack.push: '->puttext;
   (for int:4 repeat 
      int->putint; ','->put;
      i[int][]->intStack.push
   for); newline;
   (* printing intStack *)
   'intStack.elements: '->puttext;
   intStack.scan(# do current->putint; ','->put #); newline;
   
   (* illustrating accessing the top of the stack *)
   'intStack.top: '->puttext; 
   intStack.top->io[]; io->putint; newline;
   
   (* popping elements of the stack *)
   '4*intStack.pop: '->putText;
   (for int:4 repeat intStack.pop->io[]; io->putint; ','->put for);
   newline;
   
   (* printing intStack, which is empty by now *)
   'intStack.elements: '->puttext;
   intStack.scan(# do current->putint; ','->put #); newline;
   newline;
   
   (************ QUEUE **********************)
   
   (* initializing intQueue and putting some integerObjects into it *)
   intQueue.init;
   'intQueue.insert: '->puttext;
   (for int:4 repeat 
      int+3->putint; ','->put;
      i[int+3][]->intQueue.insert
   for); newline;
   (* printing intStack *)   
   'intQueue.elements: '->puttext;
   intQueue.scan(# do current->putint; ','->put #); newline;
   
   (* accession the front-most element in the queue *)
   'intQueue.front: '->puttext;
   intQueue.front->io[]; io->putint; newline;
   
   (* removing elements from the queue *)
   '4*intQueue.remove: '->puttext;
   (for int:4 repeat intQueue.remove->io[]; io->putint; ','->put for);
   newline;
   
   (* printing intQueue, which is empty by now *)
   'intQueue.elements: '->puttext;
   intQueue.scan(# do current->putint; ','->put #); newline;
   newline;
   
   (************ PRIOQUEUE **********************)
   
   (* initializing intPrioQ and putting some integerObjects into it *)
   intPrioQ.init;
   'intPrioQ.insert: '->puttext;
   (for int:10 repeat 
      '('->put;int->putint;':p:'->puttext;(3-(int mod 3))->putint;')'->put; ','->put;
      (i[int][],(3-(int mod 3)))->intPrioQ.insert
   for); newline;
   (* printing intPrioQ *)
   'intPrioQ.elements: '->puttext;
   intPrioQ.scan(# do current->putint; ','->put #); newline;
   
   (* printing the elements in the queue with a given priority *)
   '1->intPrioQ.scanPriority: '->putText;
   1->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   '2->intPrioQ.scanPriority: '->puttext;
   2->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   '3->intPrioQ.scanPriority: '->puttext;
   3->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   
   (* accessing the front-most element with a given priority *)
   '1->intPrioQ.front: '->puttext;
   1->intPrioQ.front->io[]; io->putint; newline;
   '2->intPrioQ.front: '->puttext;
   2->intPrioQ.front->io[]; io->putint; newline;
   '3->intPrioQ.front: '->puttext;
   3->intPrioQ.front->io[]; io->putint; newline;
   
   (* remove the front-most element in a given priority *)
   '1,2,3->intPrioQ.remove: '->puttext;
   (for int:3 repeat 
        '('->put; int->putint;
        int->intPrioQ.remove->io[];
        ':p:'->puttext; io->putint;
        ')'->put; ','->put
   for); newline;
   
   (* printing the prioQueue *)
   'intPrioQ.elements: '->puttext;
   intPrioQ.scan(# do current->putint; ','->put #); newline;
   'intPrioQ.size: '->puttext; intPrioQ.size->putint; newline;
   
   (* scanning all elements of a given priority *)
   '1->intPrioQ.scanPriority: '->puttext;
   1->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   '2->intPrioQ.scanPriority: '->puttext;
   2->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   '3->intPrioQ.scanPriority: '->puttext;
   3->intPrioQ.scanPriority(# do current->putint; ','->put #); newline;
   
   (* scanning, using the "where" predicate, resulting in restricting the scan
    * to those elements satisfying the predicate
    *)
   '2->intPrioQ.scanPriority(# "current<5" #): '->puttext;
   2->intPrioQ.scanPriority(# where::<(# do (current<5)->value #)
			   do current->putint; ','->put #); newline;
   newline;
   
   (* make a copy of intPrioQ and scanning all elements of a given priority *)
   'intPrioQ.copy->intPrioQref[]:'->puttext; intPrioQ.copy->intPrioQref[];
   intPrioQref.scan(# do current->putint; ','->put #); newline;
   '1->intPrioQref.scanPriority: '->puttext;
   1->intPrioQref.scanPriority(# do current->putint; ','->put #); newline;
   '2->intPrioQref.scanPriority: '->puttext;
   2->intPrioQref.scanPriority(# do current->putint; ','->put #); newline;
   '3->intPrioQref.scanPriority: '->puttext;
   3->intPrioQref.scanPriority(# do current->putint; ','->put #); newline;
   
   (************ DEQUE **********************)
   
   (* initializing intDeque and putting some integerObjects into it *)
   intDeque.init;
   'intDeque.insertFront: '->puttext;
   (for int:4 repeat 
      int->putint; ','->put;
      i[int][]->intDeque.insertFront
   for); newline;
   'intDeque.insertBack: '->puttext;
   (for int:4 repeat 
      int+6->putint; ','->put;
      i[int+6][]->intDeque.insertBack
   for); newline;   
   (* printing intDequeue *)
   'intDeque.elements: '->puttext;
   intDeque.scan(# do current->putint; ','->put #); newline;
   
   (* printing its size *)
   'intDeque.size: '->puttext; intDeque.size->putint; newline;
   
   (* accessing the elements in the front and back of the deque *)
   'intDeque.front: '->puttext;
   intDeque.front->io[]; io->putint; newline;
   'intDeque.back: '->puttext;
   intDeque.back->io[]; io->putint; newline;
   
   (* removing elements from the front and back of the deque *)
   '4*intDeque.removeFront: '->puttext;
   (for int:4 repeat intDeque.removeFront->io[]; io->putint; ','->put for); newline;
   '4*intDeque.removeBack: '->puttext;
   (for int:4 repeat intDeque.removeBack->io[]; io->putint; ','->put for); newline;
   
   (* printing the elements in the deque, which is empty by now *)
   'intDeque.elements: '->puttext;
   intDeque.scan(# do current->putint; ','->put #); newline;
   
   (*********** OUTPUT ***************
    * intStack.push: 1,2,3,4,
    * intStack.elements: 4,3,2,1,
    * intStack.top: 4
    * 4*intStack.pop: 4,3,2,1,
    * intStack.elements:
    * 
    * intQueue.insert: 4,5,6,7,
    * intQueue.elements: 7,6,5,4,
    * intQueue.front: 7
    * 4*intQueue.remove: 4,5,6,7,
    * intQueue.elements:
    * 
    * intPrioQ.insert: (1:p:2),(2:p:1),(3:p:3),(4:p:2),(5:p:1),(6:p:3),(7:p:2),(8:p:1)
    * ,(9:p:3),(10:p:2),
    * intPrioQ.elements: 9,8,10,6,3,5,2,7,4,1,
    * 1->intPrioQ.scanPriority: 8,5,2,
    * 2->intPrioQ.scanPriority: 10,7,4,1,
    * 3->intPrioQ.scanPriority: 9,6,3,
    * 1->intPrioQ.front: 8
    * 2->intPrioQ.front: 10
    * 3->intPrioQ.front: 9
    * 1,2,3->intPrioQ.remove: (1:p:8),(2:p:10),(3:p:9),
    * intPrioQ.elements: 3,2,1,6,5,7,4,
    * intPrioQ.size: 7
    * 1->intPrioQ.scanPriority: 2,5,
    * 2->intPrioQ.scanPriority: 1,7,4,
    * 3->intPrioQ.scanPriority: 3,6,
    * 2->intPrioQ.scanPriority(# "current<5" #): 1,4,
    * 
    * intDeque.insertFront: 1,2,3,4,
    * intDeque.insertBack: 7,8,9,10,
    * intDeque.elements: 4,3,2,1,7,8,9,10,
    * intDeque.size: 8
    * intDeque.front: 4
    * intDeque.back: 10
    * 4*intDeque.removeFront: 4,3,2,1,
    * 4*intDeque.removeBack: 10,9,8,7,
    * intDeque.elements:
    **********************************)
#)
