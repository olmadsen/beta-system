ORIGIN 'list';
BODY 'private/recListBody';
(*
 * COPYRIGHT
 * 
 *       Copyright (C) Mjolner Informatics, 1992-94
 * 
 *       All rights reserved.
 *)
--- lib: attributes ---
recList: list
  (* This recList pattern extends the list pattern to allow for
   * sublists.  Most operations either enters or exits a list
   * position.  List positions in a recList may contain either an
   * element or a sublist.  Defines the following new operations: 
   * 
   *     insertSublistBefore, insertSublistAfter,
   *)
  (# <<SLOT recListLib: attributes>>;
     theCellType::< 
       (* theCellType is the pattern from which the individual
        * recList positions are created.  It also defines the when
        * attribute which is used for accessing either the element or
        * the sublist at this position.  By further binding element,
        * respectively sublist, in when, the actions to be executed in
        * either case, may be specified.
        *)
       (# sublist: ^list; 
          when: 
            (* to differenciate between this(theCellType) holding an
             * element or a sublist
             *)
            (# elm:< (# elm: ^element
                       <<SLOT recListCellElementDopart: dopart>>
                     exit elm[]
                     #);
               sublist:< (# lst: ^list
                           <<SLOT recListCellSublistDopart: dopart>>
                         exit lst[] 
                         #);
               recListCellWhenPrivate: @<<SLOT recListCellWhenPrivate: descriptor>> 
            do INNER; recListCellWhenPrivate
            #);
          copy::< (# 
                  do (if sublist[] = NONE then
                      else sublist.copy->theCellCopy.sublist[]
                     if)
                  #)
       do INNER
       #);
     insertSublistBefore: 
       (* if position=NONE, insert lst as last element *)
       (# lst: ^list; position, newPosition: ^theCellType;
          illegalSublist:< illegalSublistException
       enter (lst[], position[])
       <<SLOT recListInsertSublistBeforeDopart: dopart>>
       exit newPosition[]
       #);
     insertSublistAfter: 
       (* if position=NONE, insert lst as first element *)
       (# lst: ^list; position, newPosition: ^theCellType;
          illegalSublist:< illegalSublistException
       enter (lst[], position[])
       <<SLOT recListInsertSublistAfterDopart: dopart>>
       exit newPosition[]
       #);
     illegalSublistException: Exception
       (# 
       do 'The element of this sublist does not share '->msg.putText;
          'qualifications with the element type of the list'->msg.putLine;
          INNER
       #);
     implementationScanner::< (* Private *)
       (# sublistScanner: (* Private *) ^containerImplementationScanner;
          sublistPosition: (* Private *) ^theCellType;
          sublistNextPosition: (* Private *) ^theCellType;
          startOP::< (* Private *)
            (# theCell: ^theCellType;
            <<SLOT recListImplementationScannerStartOPDopart: dopart>>
            #);
          nextOP::< (* Private *)
            (# theCell: ^theCellType;
            <<SLOT recListImplementationScannerNextOPDopart: dopart>>
            #)
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< recList do INNER #)
  do INNER
  #) (* recList *);
