ORIGIN 'container';
BODY 'private/seqContainersBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
--- lib: attributes ---
sequentialContainer: container
  (* sequentialContainer is an abstract superpattern and the
   * currently available subpatterns are (indentation specifies
   * specialization): 
   *     sequentialContainer
   *       stack
   *       queue
   *       prioqueue
   *       deque
   *)
  (# <<SLOT sequentialContainerLib: attributes>>;
     clear::< (# <<SLOT sequentialContainerClearDopart: dopart>> #);
     size::< (# <<SLOT sequentialContainerSizeDopart: dopart>> #);
     theCellType::< (* Private *)
       (# succ, pred: (* Private *) ^theCellType; 
          elm: ^element;
          copy::< (# do elm[]->theCellCopy.elm[]; INNER #)
       do INNER #);
     implementationScanner::< (* Private *)
       (# sequentialContainerImplementationScannerPrivate: @<<SLOT sequentialContainerImplementationScannerPrivateBody: descriptor>>;
          startOP::< (# theCell: ^theCellType <<SLOT sequentialContainerImplementationScannerStartOPDopart: dopart>> #);
          nextOP::< (# theCell: ^theCellType <<SLOT sequentialContainerImplementationScannerNextOPDopart: dopart>> #);
          moreOP::< (* Private *) (# <<SLOT sequentialContainerImplementationScannerMoreOPDopart: dopart>> #)
       #);
     implementationCopier::< (* Private *) (# theCategory::< sequentialContainer do INNER #);
     storage: (* Private *) @<<SLOT sequentialContainerStorageBody: descriptor>>
  do INNER
  #) (* sequentialContainer *);

(*------------------------------------------------------------*)
(*--- stack---------------------------------------------------*)
(*------------------------------------------------------------*)

stack: sequentialContainer
  (* Stack is an ordinary stack data structure.  Defines the
   * operations: top, push, pop
   *)
  (# <<SLOT stackLib: attributes>>;
     top: (* Returns the topmost element on THIS(stack) *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerStackTopDopart: dopart>>
       exit elm[]
       #);
     push: 
       (* Takes an element and places it on the top of THIS(stack) *)
       (# elm: ^element
       enter elm[]
       <<SLOT sequentialContainerStackPushDopart: dopart>>
       #);
     pop: 
       (* Returns the topmost element, and removes it from the stack
        *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerStackPopDopart: dopart>>
       exit elm[]
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< stack <<SLOT sequentialContainerStackImplementationCopierDopart: dopart>> #)
  do INNER
  #) (* stack *);

(*------------------------------------------------------------*)   
(*--- queue --------------------------------------------------*)   
(*------------------------------------------------------------*)   

queue: sequentialContainer
  (* Queue is an ordinary queue data structure.  Defines the
   * operations: front, insert, remove
   *)
  (# <<SLOT queueLib: attributes>>;
     front: (* Returns the element in the front of THIS(queue) *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerQueueFrontDopart: dopart>>
       exit elm[]
       #);
     insert: 
       (* Takes an element and inserts it at the end of THIS(queue) *)
       (# elm: ^element
       enter elm[]
       <<SLOT sequentialContainerQueueInsertDopart: dopart>>
       #);
     remove: 
       (* Returns the element in front, and removes it from the queue
        *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerQueueRemoveDopart: dopart>>
       exit elm[]
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< queue <<SLOT sequentialContainerQueueImplementationCopierDopart: dopart>> #)
  do INNER
  #) (* queue *);

(*----------------------------------------------------------------*)   
(*--- prioQueue --------------------------------------------------*)   
(*----------------------------------------------------------------*)   

prioQueue: sequentialContainer
  (* PrioQueue is a priority queue, in which the elements are kept in
   * separate queues for each priority.  Defines the operations: 
   * front, insert, remove
   *)
  (# <<SLOT prioQueueLib: attributes>>;
     size::< (# <<SLOT sequentialContainerPrioQueuesizeDopart: dopart>> #);     
     front: (* Returns the element in front with the given priority *)
       (# prio: @integer; elm: ^element; empty:< emptyContainer
       enter prio
       <<SLOT sequentialContainerPrioQueueFrontDopart: dopart>>
       exit elm[]
       #);
     insert: 
       (* Insert an element in the queue with the given priority *)
       (# prio: @integer; elm: ^element
       enter (elm[],prio)
       <<SLOT sequentialContainerPrioQueueInsertDopart: dopart>>
       #);
     remove: 
       (* Remove and returns the front element with the given
        * priority
        *)
       (# prio: @integer; elm: ^element; empty:< emptyContainer
       enter prio
       <<SLOT sequentialContainerPrioQueueRemoveDopart: dopart>>
       exit elm[]
       #);
     scanPriority: 
       (* scans through all elements of the given priority *)
       (# prio: @integer;
          where:< elementPredicate;
          current: ^element;
          start:< object;
          end:< object;
          sequentialContainerPrioQueueScanPriorityPrivate: @<<SLOT sequentialContainerPrioQueueScanPriorityPrivate: descriptor>>
       enter prio
       <<SLOT sequentialContainerPrioQueueScanPriorityDopart: dopart>>
       #);
     theCellType::< (* Private *)
       (# prio: @integer;
          theQueue: ^queue;
          copy::< (# 
                  do prio->theCellCopy.prio;
                     (if theQueue[] = NONE then
                      else theQueue.copy->theCellCopy.theQueue[]
                     if)
                  #)
       do INNER #);
     implementationScanner::< (* Private *)
       (# currentQueue: ^theCellType;
          theQueueScanner: (* Private *) ^containerImplementationScanner;
          startOP::< (* Private *)
            (# <<SLOT sequentialContainerPrioQueueImplementationScannerStartOPDopart: dopart>> #);
          nextOP::< (* Private *)
            (# <<SLOT sequentialContainerPrioQueueImplementationScannerNextOpDopart: dopart>> #)
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< prioQueue;
          theQueueCopy: ^queue;
       <<SLOT sequentialContainerPrioQueueImplementationCopierDopart: dopart>>
       #)
  do INNER
  #) (* prioQueue *);

(*---------------------------------------------------------------*)   
(*--- deque -----------------------------------------------------*)   
(*---------------------------------------------------------------*)   

deque: sequentialContainer
  (* Deque is a double-ended queue in which elements may be inserted
   * and removed from both ends of the queue.  Defines the operations: 
   * front, insertFront, removeFront, back, insertBack, removeBack
   *)
  (# <<SLOT dequeLib: attributes>>;
     front: (* Returns the element in the front *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerDequeFrontDopart: dopart>>
       exit elm[]
       #);
     insertFront: (* Takes an element and inserts it at the front *)
       (# elm: ^element
       enter elm[]
       <<SLOT sequentialContainerDequeInsertFrontDopart: dopart>>
       #);
     removeFront: 
       (* Remove and return the element in front of THIS(deque) *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerDequeRemoveFrontDopart: dopart>>
       exit elm[]
       #);
     back: (* Returns the element in the back *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerDequeBackDopart: dopart>>
       exit elm[]
       #);
     insertBack: (* Takes an element and inserts it at the back *)
       (# elm: ^element
       enter elm[]
       <<SLOT sequentialContainerDequeInsertBackDopart: dopart>>
       #);
     removeBack: (* Returns the element in the back, removing it *)
       (# elm: ^element; empty:< emptyContainer
         <<SLOT sequentialContainerDequeRemoveBackDopart: dopart>>
       exit elm[]
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< deque;
       <<SLOT sequentialContainerDequeImplementationCopierDopart: dopart>>
       #)
  do INNER
  #) (* deque *);
