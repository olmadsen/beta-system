ORIGIN '../classification';
INCLUDE 'setsBody';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)

--- classificationSetClearDopart: dopart ---
do subsets.scan(# do current.clear #); INNER clear
--- classificationSetSizeDopart: dopart ---
do subsets.scan(# do current.size+value->value #); INNER size

--- classificationSetInsertSubsetDopart: dopart ---
do (# topSet: ^classificationSet
   do (if superSet[]<>NONE then superSet[]->topSet[];
          l: (if topSet.superSet[]<>NONE then
                 topSet.superSet[]->topSet[]; restart l
             if)
       else this(classificationSet)[]->topSet[]
      if);
      (if ss.element##<=element## then 
          ss.scan(# where:: (# do current[]->topset.has->value #)
                 do current[]->topset.delete #);
          ss[]->subsets.insert;
          this(classificationSet)[]->ss.superset[]
       else IllegalSubset 
      if)
   #);
   INNER insertSubset

--- classificationSetInsertDopart: dopart ---
do (if elm[]->has then
       false->allowedToInsert
    else
       (# topSet: ^classificationSet
       do (if superSet[]<>NONE then superSet[]->topSet[];
              l: (if topSet.superSet[]<>NONE then
                     topSet.superSet[]->topSet[]; restart l
                 if)
           else this(classificationSet)[]->topSet[]
          if);
          (if (elm[]->topSet.has) then elm[]->topSet.delete if);
          true->allowedToInsert
       #)
   if);
   INNER insert

--- classificationSetDeleteDopart: dopart ---
do subsets.find
   (# cElm: ^subsets.element;
      predicate::
        (# do current[]->cElm[];
           elm[]->cElm.has->value
        #)
   do current[]->cElm[]; elm[]->cElm.delete
   #);
   INNER delete
   
---  classificationScanUnclassifiedBody: descriptor ---
(# currentCell: ^theCellType;
   thePredicate: @where;
do storage.first[]->currentCell[];
   loop: (if currentCell[] = NONE then
             leave loop
          else
             currentCell.elm[]->current[];
             currentCell.succ[]->currentCell[];
             (if current[]->thePredicate then
                 INNER scanUnclassified
             if);
             restart loop
         if)
#)

--- classificationSetStartOPDopart: dopart ---
do subsets.storage.first[]->currentSubset[];
   l: (if currentSubset[] <> NONE then
          &currentSubset.elm.implementationScanner[]->theSubsetScanner[];
          theSubsetScanner.start->currentElm[];
          theSubsetScanner.currentCell[]->currentCell[];
          currentSubset.succ[]->currentSubset[];
          (if not theSubsetScanner.more then restart l if)
      if);
   INNER startOP

--- classificationSetNextOPDopart: dopart ---
do (if theSubsetScanner[] = NONE then
       subsets.storage.first[]->currentSubset[];
    else
       theSubsetScanner.next->currentElm[];
       theSubsetScanner.currentCell[]->currentCell[]
   if);
   l: (if currentCell[] = NONE then
          (if currentSubset[] <> NONE then
              &currentSubset.elm.implementationScanner[]->theSubsetScanner[];
              theSubsetScanner.start->currentElm[];
              theSubsetScanner.currentCell[]->currentCell[];
              currentSubset.succ[]->currentSubset[];
              (if currentCell[] = NONE then restart l if)
          if)
      if);
   INNER nextOP

--- classificationImplementationCopierDopart: dopart ---
do scanUnclassified
   (# do (if current[]->thePredicate then
             current[]->theCopy.storage.insertLast
         if)
   #);
   subsets.scan
   (# do (NONE,thePredicate[])->current.implementationCopier->theCopy.subsets.storage.insertLast;
   #);
   true->doneInInner;
   INNER implementationCopier
