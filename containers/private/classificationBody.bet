ORIGIN '../classification';
INCLUDE 'setsBody';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)

--- classificationSetClearDopart: dopart ---
do subsets.scan(# do current.clear #); INNER clear
   
--- classificationSetSizeDopart: dopart ---
do subsets.scan(# do current.size+value->value #); INNER size
   
--- classificationSetHasDopart:dopart ---
do
   l:subsets.scan
     (# do (if (elm[]->current.has) then 
               true->value;
               leave l;
           if)
     #);
   
--- classificationSetCopyDoPart :dopart ---
do
   true->doneInInner;
    tp:
     (# p:@predicate;
        cnt:@integer;
        theclass:^classificationSet;
        aCell:^theCellType;
     do
        this(Container)._new->theClass[];
        private.size->theClass.private.data.new;
        0->cnt;
        (for i:private.size repeat
             private.data[i].copy->aCell[];
             (if aCell.elm[]->p then
                 cnt+1->cnt;
                 aCell[]->theClass.private.data[cnt][];
             if);
        for);
        cnt->theClass.private.size;
        theClass[]->theCopy[];
        subsets.scan
        (# do current.copy->theClass.insertsubset; #);
     #);
   
--- classificatonSetDeleteDopart:dopart---
do
   subsets.scan
   (# do elm[]->current.delete; #);
   
--- classificationSetInsertSubsetDopart: dopart ---
do (# topSet: ^classificationSet
   do (if superSet[]<>NONE then 
          superSet[]->topSet[];
          L: (if topSet.superSet[]<>NONE then
                 topSet.superSet[]->topSet[]; 
                 restart L
             if)
       else 
          this(classificationSet)[]->topSet[]
      if);
      (if ss.element## <= element## then 
          ss.scan(# where:: (# do current[]->topset.has->value #)
                 do current[]->topset.delete 
                 #);
          ss[]->subsets.insert;
          this(classificationSet)[]->ss.superset[]
       else IllegalSubset
      if)
   #);
   INNER insertSubset

--- classificationSetInsertDopart: dopart ---
do (if elm[]->has then
       false->allowedToInsert
    else
       (# topSet: ^classificationSet
       do (if superSet[]<>NONE then 
              superSet[]->topSet[];
              l: (if topSet.superSet[]<>NONE then
                     topSet.superSet[]->topSet[]; 
                     restart l
                 if)
           else 
              this(classificationSet)[]->topSet[]
          if);
          (if (elm[]->topSet.has) then elm[]->topSet.delete if);
          true->allowedToInsert
       #)
   if);
   INNER insert

---  classificationScanUnclassifiedBody: descriptor ---
(# currentCell: ^theCellType;
   thePredicate: @where;
do 
   (for i:private.size repeat
        private.data[i].elm[]->current[];
        (if current[]->thePredicate then
            INNER scanUnclassified
        if);
   for);
#)


--- classificationSetTheScannerDoPart:doPart ---
do
   subsets.scan
   (# do (s[],w[])->current.theScanner;
   #);
   
-- classificationSetDoEnter:dopart --
do
   theOther.subsets.scan
   (# 
   do  current.copy->insertSubset;
   #);

