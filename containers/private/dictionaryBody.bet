ORIGIN '../dictionary';
INCLUDE '../hashTable';

--- dictionaryInit:dopart ---
do 
   storage.table.init; 
   INNER init
   
--- dictionaryClear:doPart ---
do
   storage.table.clear;
   
--- dictionaryEmpty:doPart ---
do
   storage.table.size=0 -> value;  
   
--- dictionarySize:doPart ---
do
   storage.table.size->value;
   
   
--- dictionaryHas:doPart ---
do
   elm[]->storage.table.has->value;
   
   
   
--- dictionaryFind:doPart ---
do
   storage.table.scan
   (# pre:@predicate;
      found:@boolean;
      end::<(# do (if not found then notfound; if) #);
   do
      (if current.e[]->pre then
          true->found;
          current.e[]->this(find).current[];
          Inner Find;
      if);
   #);
   
   
--- dictionaryCopy:doPart ---
do
   (# pre:@predicate;
      theother:^dictionary;
   do
      this(dictionary)._new->theother[];
      theother.init;
      
      storage.table.scan
      (# 
      do (if current.e[]->pre then
             (current.k[],current.e[])->theother.storage.insert;
         if);
      #);
      theother[]->theCopy[];
   #);
   
--- dictionaryTheScanner:doPart ---
do
   storage.table.scan
   (# 
   do
      current.e[]->s.current[];
      s;
   #);
   
--- dictionaryAssociate:dopart ---
do 
   (k[],e[])->storage.insert
   
--- dictionaryLookup:dopart ---
do 
   k[]->storage.lookup->e[]; 

--- dictionaryDisassociate:dopart ---
do 
   k[]->storage.delete->e[]; 

--- dictionaryScanAssociations:dopart ---
do
   start;
   storage.table.scan
   (#
   do (current.k[],current.e[])->(k[],e[]);
      (if (e[],k[])->this(scanAssociations).where then
          INNER ScanAssociations
      if);
   #);
   end
   
--- dictionaryStorage:descriptor ---
(# dictionaryElement: (# k: ^key; e: ^element #);
   table: @hashTable
     (# element:: dictionaryElement;
        hashFunction:: (# do e.k[]->THIS(dictionary).hashFunction->value #);
     #);
   insert: 
     (# k: ^key; e: ^dictionary.element; de: ^dictionaryElement
     enter (k[],e[])
     do table.find
        (# predicate:: (# do (current.k[],THIS(insert).k[])->keyEqual->value #);
           notfound::
             (#
             do &dictionaryElement[]->de[];
                k[]->de.k[]; e[]->de.e[];
                de[]->table.insert; NONE->k[]; NONE->e[]; NONE->de[]
             #)
        do e[]->current.e[]
        #);
     #);
   delete: 
     (# k: ^key; e: ^dictionary.element;
     enter k[]
     do table.find
        (# predicate:: (# do (current.k[],THIS(delete).k[])->keyEqual->value #)
        do current.e[]->e[]; current[]->table.delete
        #);
        NONE->k[]
     exit e[]
     #);
   lookup: 
     (# k: ^key; e: ^dictionary.element;
     enter k[]
     do table.find
        (# predicate:: (# do (current.k[],k[])->keyEqual->value #)
        do current.e[]->e[];
        #);
        NONE->k[]
     exit e[]
     #)
#)
