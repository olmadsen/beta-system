ORIGIN '../dictionary';
INCLUDE '../hashTable';
-- dictionaryInit: DoPart --
do storage.table.init; INNER init  

-- dictionaryClear: DoPart --
do storage.table.clear;   

-- dictionaryEmpty: DoPart --
do storage.table.size = 0->value;   

-- dictionarySize: DoPart --
do storage.table.size->value;   

-- dictionaryHas: DoPart --
do elm[]->storage.table.has->value;   

-- dictionaryFind: DoPart --
do
   storage.table.scan
     (#
        pre: @predicate;
        found: @boolean;
        end::<  (#  do (if not found then notfound;  if) #);
        
     do
        (if current.e[]->pre then
            true->found; current.e[]->THIS(find).current[]; INNER Find; 
        if);
        
     #);
     

-- dictionaryCopy: DoPart --
do
     (# pre: @predicate; theother: ^dictionary; 
     do
        THIS(dictionary)._new->theother[];
        theother.init;
        storage.table.scan
          (# 
          do
             (if current.e[]->pre then
                 (current.k[],current.e[])->theother.storage.insert
             if)
          #);
        theother[]->theCopy[]
     #)

-- dictionaryTheScanner: DoPart --
do storage.table.scan 
   (#  
   do current.e[]->s.current[]; 
      (if s.current[]->w then s; if);
   #)

-- dictionaryAssociate: DoPart --
do (k[],e[])->storage.insert  

-- dictionaryLookup: DoPart --
do k[]->storage.lookup->e[];   

-- dictionaryDisassociate: DoPart --
do k[]->storage.delete->e[];   

-- dictionaryScanAssociations: DoPart --
do
   start;
   storage.table.scan
     (# 
     do
        (current.k[],current.e[])->(k[],e[]);
        (if (e[],k[])->THIS(scanAssociations).where then
            INNER ScanAssociations
        if);
        
     #);
   end  

-- dictionaryStorage: Descriptor --
(#
   dictionaryElement: (# k: ^key; e: ^element #);
   table: @hashTable
     (# rangeInitial:: (# do THIS(Dictionary).rangeInitial -> value #);
        element:: dictionaryElement;
        hashFunction:: 
          (#  do e.k[]->THIS(dictionary).hashFunction->value #);
        
     #);
   insert:
     (# k: ^key; e: ^dictionary.element; de: ^dictionaryElement
     enter (k[],e[])
     do
        k[]->hashFunction->
        table.findIndexed
          (#
             predicate:: 
               (# 
               do (current.k[],THIS(insert).k[])->keyEqual->value
               #);
             notfound:: 
               (# 
               do &dictionaryElement[]->de[];
                  k[]->de.k[];
                  e[]->de.e[];
                  de[]->table.insert
               #)
          do e[]->current.e[]; 
          #)
     #);
   delete:
     (# k: ^key; e: ^dictionary.element; 
     enter k[]
     do
        table.find
          (#
             predicate:: 
               (#  do (current.k[],THIS(delete).k[])->keyEqual->value #)
          do current.e[]->e[]; current[]->table.delete
          #);
        none ->k[]
     exit e[]
     #);
   lookup:
     (# k: ^key; e: ^dictionary.element; 
     enter k[]
     do k[]->hashFunction->
        table.findIndexed
          (#
             predicate:: 
               (# 
               do
                  (current.k[],THIS(lookup).k[])->keyEqual->value
               #);
          do current.e[] -> e[]
          #);
     exit e[]
     #)
#)  

