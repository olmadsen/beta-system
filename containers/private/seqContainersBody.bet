ORIGIN '../seqContainers';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)
--- sequentialContainerStorageBody: descriptor ---
(# first, last: (* Private *) ^theCellType;
   length: @integer;
   
   insertFirst: @
     (# elm: ^element;
        cElm: ^theCellType
     enter elm[]
     do &theCellType[]->cElm[];
        elm[]->cElm.elm[];
        first[]->cElm.succ[];
        (if length = 0 then 
            cElm[]->last[];
         else cElm[]->first.pred[]
        if);
        cElm[]->first[];
        length+1->length;
        NONE->elm[]; NONE->cElm[]
     #);
   insertLast: @
     (# elm: ^element;
        cElm: ^theCellType
     enter elm[]
     do &theCellType[]->cElm[];
        elm[]->cElm.elm[];
        last[]->cElm.pred[];
        (if length = 0 then 
            cElm[]->first[];
         else cElm[]->last.succ[]
        if);
        cElm[]->last[];
        length+1->length;
        NONE->elm[]; NONE->cElm[]
     #);
   remove: @
     (# elm: ^element; cElm: ^theCellType
     enter cElm[]
     do (* assumes that the seqContainer is NON-empty !! *)
        (if cElm[]
         //first[] then removeFirst->elm[]; NONE->removeFirst.elm[]
         //last[]  then removeLast->elm[]; NONE->removeLast.elm[]
         else cElm.elm[]->elm[];
            cElm.succ[]->cElm.pred.succ[];
            cElm.pred[]->cElm.succ.pred[];
            length-1->length
        if);
        NONE->cElm[]
     exit elm[]
     #);
   removeFirst: @
     (# elm: ^element
     do (* assumes that the seqContainer is NON-empty !! *)
        first.elm[]->elm[];
        (if first[] = last[] then NONE->first[]->last[]
         else NONE->first.succ.pred[];
            first.succ[]->first[]
        if);
        length-1->length
     exit elm[]
     #);
   removeLast: @
     (# elm: ^element
     do (* assumes that the seqContainer is NON-empty !! *)
        last.elm[]->elm[];
        (if first[] = last[] then NONE->first[]->last[]
         else NONE->last.pred.succ[];
            last.pred[]->last[]
        if);
        length-1->length
     exit elm[]
     #);
   scan: 
     (# current: ^theCellType
     do first[]->current[];
        loop: (if current[] = NONE then leave loop
               else INNER; current.succ[]->current[]; restart loop
              if)
     #) 
#)

--- sequentialContainerImplementationScannerPrivateBody: descriptor ---
(# scanner: 
     (# start:< (# do INNER #);
        next:< (# do INNER #)
     #);
   doScanner: scanner
     (# start::< (# do storage.first[]->currentCell[];
                    (if currentCell[] = NONE then &voidScanner[]->theScanner[] if)
                 #);
        next::< (# theCell: ^theCellType
                do currentCell[]->theCell[]; theCell.succ[]->currentCell[];
                   (if currentCell[] = NONE then &voidScanner[]->theScanner[] if)
                #)
     #);
   voidScanner: scanner
     (# start::< (# do NONE->currentCell[] #);
        next::< (# do NONE->currentCell[] #)
     #);
   theScanner: ^scanner
#)
--- sequentialContainerImplementationScannerStartOPDopart: dopart ---
do &sequentialContainerImplementationScannerPrivate.doScanner[]->sequentialContainerImplementationScannerPrivate.theScanner[];
   sequentialContainerImplementationScannerPrivate.theScanner.start;
   (if currentCell[] = NONE then
       NONE->currentElm[];
       INNER startOP
    else currentCell[]->theCell[]; theCell.elm[]->currentElm[]
   if)
--- sequentialContainerImplementationScannerNextOPDopart: dopart ---
do sequentialContainerImplementationScannerPrivate.theScanner.next;
   (if currentCell[] = NONE then
       NONE->currentElm[];
       INNER nextOP
    else currentCell[]->theCell[]; theCell.elm[]->currentElm[]
   if)
--- sequentialContainerImplementationScannerMoreOPDopart: dopart ---
do (currentCell[]<>NONE)->value

--- sequentialContainerClearDopart: dopart ---
do NONE->storage.first[]->storage.last[]; 0->storage.length; INNER
--- sequentialContainerSizeDopart: dopart ---
do storage.length->value; INNER
   
   
--- sequentialContainerStackTopDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else storage.first.elm[]->elm[]
   if);
   INNER
--- sequentialContainerStackPushDopart: dopart ---
do elm[]->storage.insertFirst; INNER
--- sequentialContainerStackPopDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       storage.removeFirst->elm[]; NONE->storage.removeFirst.elm[]
   if);
   INNER
--- sequentialContainerStackImplementationCopierDopart: dopart ---
do storage.scan(# do (if current.elm[]->thePredicate then
                         current.elm[]->theCopy.storage.insertLast
 	  	     if)
               #);
   INNER

--- sequentialContainerQueueFrontDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else storage.last.elm[]->elm[]
   if);
   INNER
--- sequentialContainerQueueInsertDopart: dopart ---
do elm[]->storage.insertFirst; INNER
--- sequentialContainerQueueRemoveDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       storage.removeLast->elm[]; NONE->storage.removeLast.elm[]
   if);
   INNER
--- sequentialContainerQueueImplementationCopierDopart: dopart ---
do storage.scan(# do (if current.elm[]->thePredicate then
                         current.elm[]->theCopy.storage.insertLast
 	  	     if)
               #)

--- sequentialContainerPrioQueueImplementationScannerStartOPDopart: dopart ---
do storage.first[]->currentCell[];
   l: (if currentCell[] <> NONE then
          currentCell[]->currentQueue[];
          &currentQueue.theQueue.implementationScanner[]->theQueueScanner[];
          theQueueScanner.start->currentElm[];
          theQueueScanner.currentCell[]->currentCell[];
          currentQueue.succ[]->currentQueue[];
          (if not theQueueScanner.more then restart l if) 
      if);
   INNER
--- sequentialContainerPrioQueueImplementationScannerNextOPDopart: dopart ---
do (if theQueueScanner[] = NONE then
       storage.first[]->currentQueue[]
    else
       theQueueScanner.next->currentElm[];
       theQueueScanner.currentCell[]->currentCell[];
   if);
   l: (if currentCell[] = NONE then
          (if currentQueue[] <> NONE then
              &currentQueue.theQueue.implementationScanner[]->theQueueScanner[];
              theQueueScanner.start->currentElm[];
              theQueueScanner.currentCell[]->currentCell[];
              currentQueue.succ[]->currentQueue[];
              (if currentCell[] = NONE then restart l if)
          if)
      if);
   INNER;
--- sequentialContainerPrioQueueImplementationCopierDopart: dopart ---
do storage.scan
   (# do (NONE,thePredicate[])->current.theQueue.implementationCopier->theQueueCopy[];
      (if current.elm[]->thePredicate then
          current.elm[]->theCopy.storage.insertLast;
          current.prio->theCopy.storage.last.prio;
          theQueueCopy[]->theCopy.storage.last.theQueue[]
       else
          (if theQueueCopy.size<>0 then
              theQueueCopy.remove->theCopy.storage.insertLast;
              current.prio->theCopy.storage.last.prio;
              theQueueCopy[]->theCopy.storage.last.theQueue[]
          if)
      if)
   #)

--- sequentialContainerPrioQueueSizeDopart: dopart ---
do storage.scan(# do current.theQueue.size+value->value #); INNER
--- sequentialContainerPrioQueueFrontDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else seek: (# 
 	       do storage.scan(# do (if current.prio = prio then 
				        current.elm[]->elm[];
				        leave seek
				    if)
                              #);
		  (* not found...return NONE *)
		  NONE->elm[]
               #)
   if);
   INNER
--- sequentialContainerPrioQueueInsertDopart: dopart ---
do seek: (# 
	 do storage.scan(# do (if current.prio = prio then 
			          current.elm[]->current.theQueue.insert;
			          elm[]->current.elm[];
			          leave seek
			      if)
                        #);
	    (* first time this priority have appeared...create it *)
   	    elm[]->storage.insertFirst;
   	    prio->storage.first.prio;
   	    &queue[]->storage.first.theQueue[]
         #);
   INNER
--- sequentialContainerPrioQueueRemoveDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else seek: (# 
	       do storage.scan(# do (if current.prio = prio then
			  	        current.elm[]->elm[];
 			  	        current.theQueue.remove->current.elm[];
			  	        leave seek
		      	      	    if)
                              #);
	       	  (* not found...return NONE *)
	       	  NONE->elm[]
               #)
   if);
   INNER
--- sequentialContainerPrioQueueScanPriorityPrivate: descriptor ---
(# thePredicate: @where;
   theStart: @start; theEnd: @end
#)
--- sequentialContainerPrioQueueScanPriorityDopart: dopart ---
do sequentialContainerPrioQueueScanPriorityPrivate.theStart;
   seek: storage.scan(# do (if current.prio = prio then
			       current.elm[]->this(scanPriority).current[];
			       INNER scanPriority;
		      	       current.theQueue.scan(# where::< (# do current[]->this(scanPriority).sequentialContainerPrioQueueScanPriorityPrivate.thePredicate->value #)
						       
					      	    do current[]->this(scanPriority).current[];
 						       INNER scanPriority
                                                    #);
		      	       leave seek
		           if)
                     #);
   sequentialContainerPrioQueueScanPriorityPrivate.theEnd

--- sequentialContainerDequeFrontDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else storage.first.elm[]->elm[]
   if);
   INNER
--- sequentialContainerDequeInsertFrontDopart: dopart ---
do elm[]->storage.insertFirst; INNER
--- sequentialContainerDequeRemoveFrontDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       storage.removeFirst->elm[]; NONE->storage.removeFirst.elm[]
   if);
   INNER
--- sequentialContainerDequeBackDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else storage.last.elm[]->elm[]
   if);
   INNER
--- sequentialContainerDequeInsertBackDopart: dopart ---
do elm[]->storage.insertLast; INNER
--- sequentialContainerDequeRemoveBackDopart: dopart ---
do (if storage.length = 0 then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       storage.removeLast->elm[]; NONE->storage.removeLast.elm[]
   if);
   INNER
--- sequentialContainerDequeImplementationCopierDopart: dopart ---
do storage.scan(# do (if current.elm[]->thePredicate then
                         current.elm[]->theCopy.storage.insertLast
 	  	     if)
               #)

