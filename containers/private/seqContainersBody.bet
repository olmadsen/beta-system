ORIGIN '../seqContainers';
LIB_ITEM 'contseq';

--- sequentialContainerTheScannerDopart : doPart ---
do private.topelement[]->aCell[];
   l:(if aCell[]<>NONE then
         aCell.elm[]->s.current[];
         (if s.current[]->s.where then
             s;
             INNER theScanner;
         if);
         aCell.pred[]->aCell[];
         restart l;
     if);
   
--- sequentialContainerPrivate : descriptor ---
(#
   topElement:^theCelltype;
   bottomElement:^theCelltype;
   size:@integer;
   queues:@integer;
   tempelm:^theCelltype;
#)

--- sequentialContainerSize:doPart ---
do private.size->value
   
--sequentialContainerDequeFind:dopart--
do
   l:
     (# theCell: ^theCelltype; 
        thePred:@predicate;
     do
        private.topElement[]->theCell[];
        ll:(if theCell[]<>none then
               theCell.elm[]->current[];
               (if current[]->thePred then 
                   INNER find; 
                   leave l;  
               if);
               theCell.pred[]->theCell[];
               restart ll
           if);
        notFound
     #);
 
   
--- sequentialContainerClear:doPart---
do NONE->private.topElement[];
   NONE->private.bottomElement[];
   0->private.size;
   
--- sequentialContainerEmpty:doPart ---
do 0=private.size->value;
      
--- sequentialContainerHas:doPart ---
do
   fgc:
     (# aCell:^theCelltype;
        myEqual:@equal;
     do
        private.topelement[]->aCell[];
        fgc2:(if aCell[]<>NONE then
                 (if (aCell.elm[],elm[])->myEqual then
                     true->value;
                 if);
                 aCell.pred[]->aCell[];
                 restart fgc2;
             if);
     #);
   
   (*-----------stack------------*)   
   
--- sequentialContainerStackPrivFind:descriptor ---
(# mytop:^theCellType;
   pre:@predicate;
enter mytop[]
do (if mytop[]<>NONE then
       mytop.elm[]->current[];
       (if current[]->pre then
           INNER find;
           leave privateFinder;
       if);
       mytop.pred[]->mytop[];
       restart privateFinder;
   if);
   notfound;
#)

--- sequentialContainerStackFind:doPart ---
do private.topelement[]->privateFinder;
   
   
--- sequentialContainerStackCopy:doPart ---
do
   (if not doneinInner then 
       fgc:(# thestackCopy:^stack;
              cnt:@integer;
              pre:@predicate;
              runCell:^theCelltype;
           do
              this(stack)._new->thestackCopy[];
              private.topelement[]->runCell[];
              l:(if runCell[]<>NONE then
                    (if runCell.elm[]->pre then
                        theStackCopy.private.topelement[]->runCell.pred[];
                        runCell[]->theStackCopy.private.topelement[];
                        1+cnt->cnt;
                        runCell.pred[]->runCell[];
                        restart l;
                    if);
                if);
              cnt->theStackCopy.private.size;
              theStackCopy[]->theCopy[];
           #);
   if);
   
--- sequentialContainerStackTopDopart: dopart ---
do (if private.size=0 then
       empty
    else
       private.topelement.elm[]->elm[];
   if);
   
--- sequentialContainerStackPushDopart: dopart ---
do &theCelltype[]->private.tempelm[];
   elm[]->private.tempelm.elm[];
   private.topelement[]->private.tempelm.pred[];
   private.tempelm[]->private.topelement[];
   private.size+1->private.size;
   
--- sequentialContainerStackPopDopart: dopart ---
do
   (if private.size=0 then
       emptyContainerError
    else
       private.topelement.elm[]->elm[];
       private.topelement.pred[]->private.topelement[];
       private.size-1->private.size;
   if);
   
-- stackDoEnter:DoPart --
do       
   fgc:(# 
          cnt:@integer;
          runCell,newCell,last:^theCelltype;
          (* runCell scan down the other stack *)
       do
          theOther.private.topelement[]->runCell[];
          l:(if runCell[]<>NONE then
                (if runCell.elm[]->thePred then
                    runCell.copy->newCell[];
                    (if last[]<>none then 
                        newCell[]->last.pred[];
                     else (* remember first element *)
                        newCell[]->private.topelement[]
                    if);
                    1+cnt->cnt;
                    newCell[]->last[];
                if);
                runCell.pred[]->runCell[];
                restart l;
            if);
          cnt->private.size;
       #);
   
   
(*------------queue----------*)

   
--- sequentialContainerQueueHas:doPart ---
do
   queuehas:(# 
               aCell:^theCelltype;
               myEqual:@equal;
            do
               private.topElement[]->aCell[];
               fgc2:(if aCell[]<>NONE then
                        (if (aCell.elm[],elm[])->myEqual then
                            true->value;
                            leave fgc2;
                        if);
                        aCell.pred[]->aCell[];
                        restart fgc2;
                    if);   
            #);
   
   
--- sequentialContainerQueuePrivFind:descriptor ---
(# mytop:^theCellType;
   pre:@predicate;
enter mytop[]
do (if mytop[]<>NONE then
       mytop.elm[]->current[];
       (if current[]->pre then
           INNER find;
           leave privateFinder;
       if);
       mytop.pred[]->mytop[];
       restart privateFinder;
   if);
   notfound;
#)

--- sequentialContainerQueueFind:doPart ---
do private.topElement[]->privateFinder;
   
--- sequentialContainerQueueCopy:doPart ---
do
   (if not doneinInner then 
       fgc:(# thequeueCopy:^queue;
              cnt:@integer;
              pre:@predicate;
              runCell,aCell:^theCelltype;
              ii:^insert;
           do
              this(queue)._new->thequeueCopy[];
              &thequeueCopy.insert[]->ii[];
              private.topElement[]->runCell[];
              l:(if runCell[]<>NONE then
                    (if runCell.elm[]->pre then
                        runCell.copy->aCell[];
                        aCell.elm[]->ii;
                        runCell.pred[]->runCell[];
                        restart l;
                    if);
                if);
              theQueueCopy[]->theCopy[];
           #);
   if);

--- sequentialContainerQueueFrontDopart: dopart ---
do
   (if private.size=0 then
       empty;
    else
       private.topElement.elm[]->elm[];
   if);
   
   
--- sequentialContainerQueueInsertDopart: dopart ---
do
   &theCelltype[]->private.tempelm[];
   elm[]->private.tempelm.elm[];
   (if private.size
    // 0 then
       private.tempelm[]->private.topElement[];
    // 1 then
       private.tempelm[]->private.bottomElement[];
       private.topElement[]->private.bottomElement.succ[];
       private.bottomElement[]->private.topElement.pred[];
    else
       private.bottomElement[]->private.tempelm.succ[];
       private.tempelm[]->private.bottomElement.pred[];
       private.tempelm[]->private.bottomElement[];
   if);
   NONE->private.tempelm[];
   1+private.size->private.size;
   INNER;
   
--- sequentialContainerQueueRemoveDopart: dopart ---
do
   (if private.size=0 then empty if);
   private.topElement.elm[]->elm[];
   private.size-1->private.size;
   (if private.size>0 then
       NONE->private.topElement.pred.succ[];
       private.topElement.pred[]->private.topElement[];
    else
       NONE->private.bottomElement[];
       NONE->private.topElement[];
   if);
   
   
--queueDoEnter:dopart--
do (# 
      cnt:@integer;
      runCell,newCell,last:^theCelltype;
      (* runCell scans the other queue *)
   do
      theOther.private.bottomelement[]->runCell[];
      l:(if runCell[]<>NONE then
            (if runCell.elm[]->thePred then
                runCell.copy->newCell[];
                (if last[]<>none then 
                    newCell[]->last.succ[];
                    last[]->newCell.pred[];
                 else (* remember first element *)
                    newCell[]->private.bottomelement[]
                if);
                1+cnt->cnt;
                newCell[]->last[];
                runCell.succ[]->runCell[];
                restart l;
            if);
        if);
      newCell[]->private.topelement[];
      cnt->private.size;
   #);
   
  
   
(*--------------Deque------------*)
   
--- sequentialContainerDequeFrontDopart: dopart ----
do   
   (if private.size=0 then
       empty;
    else
       private.topElement.elm[]->elm[];
   if);

   
--- sequentialContainerDequeInsertFrontDopart: dopart ---
do
   &theCelltype[]->private.tempelm[];
   elm[]->private.tempelm.elm[];
   (if true 
    // private.size=0 then
       private.tempelm[]->private.topelement[]->private.bottomelement[];
    // private.size>0 then
       private.topelement[]->private.tempelm.pred[];
       private.tempelm[]->private.tempelm.pred.succ[];
   if);
   private.tempelm[]->private.topelement[];
   private.size+1->private.size;
      
   
--- sequentialContainerDequeRemoveFrontDopart: dopart ---
do
   (if private.size=0 then
       empty;
   if);
   private.topelement.elm[]->elm[];
   (if true
    // private.size>1 then
       private.topelement.pred[]->private.topelement[];
       NONE->private.topelement.succ[];
    // private.size=1 then
       NONE->private.bottomelement[];
       NONE->private.topelement[];
   if);
   private.size-1->private.size;
   
--- sequentialContainerDequeBackDopart: dopart ---
do
   private.bottomelement.elm[]->elm[];
   
--- sequentialContainerDequeInsertBackDopart: dopart ---
do 
   &theCelltype[]->private.tempelm[];
   elm[]->private.tempelm.elm[];
   (if true 
    // private.size=0 then
       private.tempelm[]->private.bottomelement[]->private.topelement[];
    // private.size>0 then
       private.bottomelement[]->private.tempelm.succ[];
       private.tempelm[]->private.tempelm.succ.pred[];
   if);
   private.tempelm[]->private.bottomelement[];
   private.size+1->private.size;
      
   
--- sequentialContainerDequeRemoveBackDopart: dopart ---
do
   (if private.size=0 then
       empty;
   if);
   private.bottomelement.elm[]->elm[];
   (if true
    // private.size>1 then
       private.bottomelement.succ[]->private.bottomelement[];
       NONE->private.bottomelement.pred[];
    // private.size=1 then
       NONE->private.bottomelement[];
       NONE->private.topelement[];
   if);
   private.size-1->private.size;
   
-- dequeDoEnter:DoPart --
do  (# 
      cnt:@integer;
      runCell,newCell,last:^theCelltype;
      (* runCell scans the other queue *)
   do
      theOther.private.bottomelement[]->runCell[];
      l:(if runCell[]<>NONE then
            (if runCell.elm[]->thePred then
                runCell.copy->newCell[];
                (if last[]<>none then 
                    newCell[]->last.succ[];
                    last[]->newCell.pred[];
                 else (* remember first element *)
                    newCell[]->private.bottomelement[]
                if);
                1+cnt->cnt;
                newCell[]->last[];
                runCell.succ[]->runCell[];
                restart l;
            if);
        if);
      newCell[]->private.topelement[];
      cnt->private.size;
   #);  
   
(*-----------PrioQueue-------*)
---  prioQueueLib: attributes ---
scanQueues:
  (# theQ:^queue;
     priori:@integer;
     stopscan:@boolean;
     firstelm:^element;
  do
     private.topelement[]->private.tempelm[];
     _loop:(for i:private.queues repeat
                private.tempelm.thequeue[]->theQ[];
                private.tempelm.prio->priori;
                private.tempelm.elm[]->firstelm[];
                INNER;
                (if stopscan then
                    leave _loop;
                 else
                    private.tempelm.pred[]->private.tempelm[];
                if);
           for);
  exit stopscan
  #);

_insertFront:
  (# elm:^element;
  enter elm[]
  do
     &theCelltype[]->private.tempelm[];
     elm[]->private.tempelm.elm[];
     private.topelement[]->private.tempelm.pred[];
     private.tempelm[]->private.topelement[];
     private.queues+1->private.queues;
     private.size+1->private.size;
  #);

_insertQueue:
  (# 
     elm:^element;
     que:^queue;
     prio:@integer;
  enter (elm[],que[],prio)
  do
     &theCelltype[]->private.tempelm[];
     elm[]->private.tempelm.elm[];
     que[]->private.tempelm.theQueue[];
     prio->private.tempelm.prio;
     private.topelement[]->private.tempelm.pred[];
     private.tempelm[]->private.topelement[];
     private.size+1->private.size;
     private.queues+1->private.queues;
     (if que[]<>NONE then
         que.size+private.size->private.size;
     if);
  #);

_insertQueueBottom:
  (# 
     elm:^element;
     que:^queue;
     prio:@integer;
  enter (elm[],que[],prio)
  do
     &theCelltype[]->private.tempelm[];
     elm[]->private.tempelm.elm[];
     que[]->private.tempelm.theQueue[];
     prio->private.tempelm.prio;
     (if private.bottomelement[]<>none then
         private.tempelm[]->private.bottomelement.pred[];
      else
         private.tempelm[]->private.topelement[];
     if);
     private.tempelm[]->private.bottomelement[];
     private.size+1->private.size;
     private.queues+1->private.queues;
     (if que[]<>NONE then
         que.size+private.size->private.size;
     if);
  #);

--- sequentialContainerPrioQueueTheScannerDopart : doPart ---
do
   (if aCell.theQueue[]<>NONE then
       (# myelm:^aCell.theQueue.theCelltype;
       do
          aCell.theQueue.private.topelement[]->myelm[];
          l:(if myelm[]<>none then
             myelm.elm[]->s.current[];
                (if s.current[]->w then s; if);
             myelm.pred[]->myelm[];
             restart l;
            if);
       #);
   if);
   
--- sequentialContainerPrioQueueFrontDopart: dopart ---
do
   scanQueues(# 
             do (if priori=prio then
                    firstelm[]->elm[];
                    true->stopscan;
                if);
             #);
   
--- sequentialContainerPrioQueueInsertDopart: dopart ---
do
   (if
   scanQueues(# 
             do (if priori=prio then
                    elm[]->theQ.insert;
                    1+private.size->private.size;
                    true->stopscan;
                if);
             #) then
    else
       elm[]->_insertFront;
       &queue[]->private.topelement.theQueue[];
       prio->private.topelement.prio;
   if);
   
--- sequentialContainerPrioQueueRemoveDopart: dopart ---
do
   scanQueues(# 
             do
                (if priori=prio then
                    firstelm[]->elm[];
                    (if theQ.size>0 then
                        theQ.remove->private.tempelm.elm[];
                    if);
                    private.size-1->private.size;
                    true->stopscan;
                if);
             #);
   (if elm[]=NONE then 'not found any: '->puttext; prio->putint; newline; if); 
   
--- sequentialContainerPrioQueueScanPriorityDopart: dopart ---
do
   start;
   scanQueues(# 
             do (if priori=prio then
                    firstelm[]->current[];
                    Inner scanPriority;
                    theQ.scan(#
                             do current[]->this(scanPriority).current[];
                                Inner scanPriority
                             #);
                    true->stopscan;
                if);
             #);
   end;
   
--- sequentialContainerPrioQueueCopy:doPart ---
do
   (if not doneinInner then 
       fgc:(# theprioQueueCopy:^prioQueue;
              cnt:@integer;
              pre:@predicate;
              runCell,aCell:^theCelltype;
              theQ:^queue;
              ii:^_insertqueue;
           do
              this(prioQueue)._new->theprioQueueCopy[];
              &theprioQueueCopy._insertqueue[]->ii[];
              private.topElement[]->runCell[];
              l:(if runCell[]<>NONE then
                    (if runCell.elm[]->pre then
                        runCell.copy->aCell[];
                        (aCell.elm[],aCell.theQueue[],runCell.prio)->ii;
                        runCell.pred[]->runCell[];
                        restart l;
                    if);
                if);
              theprioQueueCopy[]->theCopy[];
           #);
   if);
   
   
-- prioQueueDoEnter:DoPart --
do theOther.scanQueues
   (# 
   do (if firstelm[]->thePred then (* insert elm and queue *)
          (firstelm[],theQ.copy,priori)->_insertqueuebottom;
       else
          (if theQ.size<>0 then
              (none,theQ.copy,priori)->_insertqueuebottom;
          if);
      if);
   #);
   
   
   (*--------------PriorityQueue--------*)
   
-- priorityQueueInsert: descriptor --
(# ins: @storage.insert;
   
do (if storage.size = storage.data.range then
       storage.data.range -> storage.data.extend;
   if);
   storage.size + 1 -> storage.size;
   elm[] -> ins;
#)

-- priorityQueueMin: doPart --
do (if storage.size = 0 then
       emptyContainer;
    else
       storage.data[1][] -> elm[];
   if);
   
-- priorityQueueDeleteMin: descriptor --
(# del: @storage.deleteMin;
do (if storage.size > 0 then
       storage.data[1][] -> elm[];
       del;
   if);
#)

-- priorityQueueInit: doPart --
do 1 -> storage.data.new;
   0 -> storage.size;
   inner;

-- priorityQueueClear: doPart --
do 1 -> storage.data.new;
   0 -> storage.size;
   inner;

-- priorityQueueEmpty: doPart --
do storage.size = 0 -> value;

-- priorityQueueSize: doPart --
do storage.size -> value;

-- priorityQueueScan: doPart --
do (for inx: storage.size repeat
        storage.data[inx][] -> current[];
        inner;
   for);

-- priorityQueueHas: doPart --
do false -> value;
   l:
     (for inx: storage.size repeat
          (if elm[] = storage.data[inx][] then
              true -> value;
              leave l;
          if);
     for);

-- priorityQueueStorage: descriptor --
(# data: [1] ^element;
   size: @integer;
   
   insert:
     (# n, fatherInx: @integer;
        elm, father: ^element;
        doLess: @less;
     enter elm[]
     do (if size = 1 then
            elm[] -> data[1][];
         else
            size -> n;
            l:
              (if n > 1 then
                  data[(n div 2) -> fatherInx][] -> father[];
                  (if (elm[], father[]) -> doLess then
                      father[] -> data[n][];
                      fatherInx -> n;
                      restart l;
                   else
                      elm[] -> data[n][];
                  if);
               else
                  elm[] -> data[n][];
              if);
        if);
     #);
   deleteMin:
     (# sonInx: @integer;
        n: @integer;
        elm, son1, son2: ^element;
        doLess: @less;
     do none -> data[1][];
        data[size][] -> elm[];
        size - 1 -> size;
        (if size <> 0 then
            1 -> n;
            l: (#
               do 2 * n -> sonInx;
                  (if sonInx <= size then
                      (if (sonInx < size) and ((data[sonInx +1][], data[sonInx][]) -> doLess) then
                          sonInx + 1 -> sonInx;
                      if);
                      (if (data[sonInx][], elm[]) -> doLess then
                          data[sonInx][] -> data[n][];
                          sonInx -> n;
                          restart l;
                       else
                          elm[] -> data[n][];
                      if);
                   else
                      elm[] -> data[n][];
                  if);
               #);
        if);
     #);
#)
