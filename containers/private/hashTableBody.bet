ORIGIN '../hashTable';
LIB_ITEM 'hashtable';

--- hashTableInit:doPart ---
do
   rangeInitial->private.data.new;
   Inner;
   
--- hashTableRangeDopart:dopart ---
do  
   private.data.range->value;
   Inner;
   
--- hashTableClearDoPart:doPart ---
do rangeInitial->private.data.new;
   0->private.size;
   Inner;
   
--- hashTableEmptydoPart:doPart ---
do private.size=0->value;
   Inner;
   
--- hashTableSizeDoPart:doPart ---
do private.size->value;
   Inner;

--- hashTableHasDopart:dopart ---
do
   pp: (# index:@integer; 
          myCell:^theCelltype;
          myEqual:@this(hashtable).equal;
       do elm[]->hashFunction->index;
          private.data[index][]->myCell[];
          l:(if myCell[]<>NONE then
                (if (myCell.elm[],elm[])->myEqual then
                    true->value;
                 else
                    myCell.next[]->myCell[];
                    restart l;
                if);
            if);
       #);
   Inner;
   
--- hashTableInsertDopart:dopart ---
do
   p:(# index:@integer;
        myCell:^theCelltype;
     do elm[]->hashFunction->index;
        &theCelltype[]->myCell[];
        elm[]->myCell.elm[];
        private.data[index][]->myCell.next[];
        myCell[]->private.data[index][];
        1+private.size->private.size;
     #);
   inner;
   
--- hashTableTheScannerDopart:doPart ---
do 
   p:(# myCell:^theCelltype;
     do (for i:private.data.range repeat
             private.data[i][]->myCell[];
             l:(if myCell[]<>NONE then
                   myCell.elm[]->s.current[];
                   (if myCell.elm[]->w then
                       s
                   if);
                   myCell.next[]->myCell[];
                   restart l;
               if);
        for);
     #);
   
--- hashTableDeleteDopart:dopart ---
do
   p:(# index:@integer;
        former,row:^theCelltype;
        myEqual:@equal;
     do
        elm[]->hashfunction->index;
        private.data[index][]->row[];
        fgc:(if row[]=NONE then
                notFound; (* raise exception *)
             else
                (if (elm[],row.elm[])->myEqual then
                    private.size-1->private.size;
                    (if former[]<>NONE then (* ikke foerste *)
                        row.next[]->former.next[];
                     else                   (* den foerste *)
                        row.next[]->private.data[index][];
                    if);
                 else
                    row[]->former[];
                    row.next[]->row[];
                    restart fgc;
                if);
            if);
     #);
   Inner;
   
--- hashtableScanIndexedDopart:dopart ---
do         
   start;
   p:(# myCell:^theCelltype;
     do private.data[inx][]->myCell[];
        l:(if myCell[]<>NONE then
              myCell.elm[]->current[];
              Inner scanIndexed;
              myCell.next[]->myCell[];
              restart l;
          if);
     #);
   end;
   
--- hashtableFindDopart:doPart ---
do false->private.found;
   p:(# myCell:^theCelltype;
        pre:@predicate
     do          
        (for i:private.data.range repeat
             private.data[i][]->myCell[];
             l:(if myCell[]<>NONE then
                   (if myCell.elm[]->pre then
                       myCell.elm[]->current[];
                       true->private.found;
                       Inner FIND;
                       leave p;
                   if);
                   myCell.next[]->myCell[];
                   restart l;
               if);
        for);
     #);  
   (if not private.found then
       notfound;
   if);
   
--- hashTableFindIndexedDoPart: dopart ---
do
   start;
   p:(# aCell:^theCelltype;
        pre:@predicate;
     do private.data[inx][]->aCell[];
        l:(if aCell[]<>NONE then 
              (if aCell.elm[]->pre then
                  aCell.elm[]->current[];
                  Inner FINDindexed;
                  leave p; (* found, do not search anymore *)
              if);
              aCell.next[]->aCell[];
              restart l;
          if);
        notfound; (* was not found, do raise exception *)
     #);
   end;
  
--- hashTableCopyDopart:doPart ---
do  INNER;
   (if not doneInInner then
       tp:
         (# pre:@predicate;
            cnt:@integer;
            thehashTable:^hashTable;
            aCell,rest,row:^theCelltype;
         do
            this(hashTable)._new->thehashTable[];
            private.data.range->thehashTable.private.data.new;
            0->cnt;
            (for i:private.data.range repeat
                 private.data[i][]->row[];
                 NONE->aCell[];
                 fgc:(if row[]<>NONE then
                         (if row.elm[]->pre then
                             aCell[]->rest[];
                             row.copy->aCell[];
                             rest[]->aCell.next[];
                             cnt+1->cnt;
                         if);
                         row.next[]->row[];
                         restart fgc;
                     if);
                 aCell[]->thehashTable.private.data[i][];
            for);
            thehashTable[]->theCopy[];
            cnt->thehashTable.private.size;
         #);
   if);
   
   
   
--- hashTablePrivate:descriptor ---
(# data:[rangeInitial]^theCelltype;
   size:@integer;
   found:@boolean;
#)

-- hashtableDoenter:DoPart --
do
   (# runCell,newCell,myCell:^theCelltype;
      newindex,newsize:@integer;
      hf:@hashfunction;
   do
      (for i:theOther.private.data.range repeat
           theOther.private.data[i][]->runCell[];
           l:(if runCell[]<>none then
                 runCell.copy->newCell[]; 
                 (*inlined insert *)
                 newCell.elm[]->hf->newindex;
                 &theCelltype[]->myCell[];
                 newCell.elm[]->myCell.elm[];
                 private.data[newindex][]->myCell.next[];
                 myCell[]->private.data[newindex][];
                 1+newsize->newsize;
                 (* next elm *)
                 runCell.next[]->runCell[];
                 restart l;
             if)
      for);
      newsize->private.size;
   #);
                     
   
(*-----------------------------------------------------------------*)   
(*--- extensibleHashTable------------------------------------------*)   
(*-----------------------------------------------------------------*)   

--- extensibleHashTableExtendDopart: dopart ---
do
   increment->private.data.extend;
   INNER;
   
--- extensibleHashTableRehashDopart: dopart ---
do extendhash:
     (# node: (# c: ^theCellType; n: ^node #);
        l, tmp: ^node; c: ^theCellType
     do (for i: private.data.range repeat
             (if NONE
              // private.data[i][]      then (* ignore *)
              else 
                 &node[]->tmp[];
                 private.data[i][]->tmp.c[];
                 NONE->private.data[i][];
                 l[]->tmp.n[]; tmp[]->l[]
             if)
        for);
        0->private.size;
        loop: (if l[] = NONE then leave loop
               else l.c[]->c[];
                  innerLoop: (if c[] = NONE then leave innerLoop
                              else c.elm[]->insert; 
                                 c.next[]->c[];
                                 restart innerLoop
                             if);
                  l.n[]->l[]; restart loop
              if);
        NONE->tmp[]; NONE->c[]
     #);
   
   
