ORIGIN '../sets';
LIB_ITEM 'contsets';
-- multiSetTheScannerDopart: DoPart --
do
   (for i: private.size repeat private.data[i].elm[]->s.current[]; 
        (if s.current[]->w then s; if);
   for);
   INNER theScanner;
     

-- multiSetFindDopart: DoPart --
do
   tp:
     (# p: @predicate; thiselm: ^element; 
     do
        (for i: private.size repeat 
             private.data[i].elm[]->thiselm[];
             (if thiselm[]->p then
                 thiselm[]->current[]; 
                 INNER find; 
                 leave tp; 
             if)          
        for);
        notfound;        
     #)     

-- multiSetCopyDopart: DoPart --
do
   INNER ;
   (if not doneInInner then
       tp:
         (#
            p: @predicate;
            cnt: @integer;
            theSet: ^multiSet;
            aCell: ^theCellType;
            
         do
            THIS(Container)._new->theSet[];
            private.size->theSet.private.data.new;
            0->cnt;
            (for i: private.size repeat
              private.data[i].copy->aCell[];
              (if aCell.elm[]->p then
                  cnt+1->cnt; aCell[]->theSet.private.data[cnt][]; 
              if);
              
            for);
            cnt->theSet.private.size;
            theSet[]->theCopy[];
            
         #);
       
   if);
     

-- multiSetEmptyDopart: DoPart --
do private.size = 0->value;   

-- multiSetCapacityDopart: DoPart --
do private.data.range->value;   

-- multiSetHasDopart: DoPart --
do
   l:
     (# 
     do
        (for i: private.size repeat
          (if (elm[],private.data[i].elm[])->myEqual then
              true->value; leave l; 
          if);
          
        for);
        
     #);
   INNER ;
     

-- multiSetClearDopart: DoPart --
do 2->private.data.new; 0->private.size;   

-- multiSetSizeDopart: DoPart --
do private.size->value; INNER ;   

-- multiSetInsertPrivate: Descriptor --
(# aCell: ^theCellType; 
do
   (if private.size = private.data.range then
       private.data.range->private.data.extend; 
   if);
   1+private.size->private.size;
   &theCelltype[]->aCell[];
   elm[]->aCell.elm[];
   aCell[]->private.data[private.size][];
   
#)  

-- multiSetDeletePrivate: Descriptor --
(# myEqual: @equal; pos: @integer; 
do
   - 1->pos;
   l:
     (# 
     do
        (for i: private.size repeat
          (if (elm[],private.data[i].elm[])->myEqual then
              i->pos; leave l; 
          if);
          
        for);
        
     #);
   (* pos is position of element in repetition *)
   (if true
    // pos < 1 then (* do nothing, not in set *)
       
    // pos < private.size then
       private.data[private.size][]->private.data[pos][];
       (* move last item down *)
       private.size-1->private.size;
       
    // pos = private.size then
       none ->private.data[private.size][]; private.size-1->private.size; 
   if);
   
#)  

-- multiSetPrivate: Descriptor --
(# data: [2] ^theCellType; size: @integer;  #)  

-- multiSetDoEnter: DoPart --
do 
   theOther.private.data.range->private.data.new;
   (for i: theOther.private.size repeat
        (if theOther.private.data[i].elm[]->thePred then
            1+private.size->private.size;
            theOther.private.data[i].copy->private.data[private.size][]
        if)
   for);
   INNER
   
   
   (*------------------------------------------------------------*)
   (*--- set: multiSet ------------------------------------------*)
   (*------------------------------------------------------------*)  

-- setInsertDopart: DoPart --
do not (elm[]->has)->AllowedToInsert; INNER ;   

