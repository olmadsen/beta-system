ORIGIN '../sets'

--- multiSetTheScannerDopart: doPart ---
do
   (for i:private.size repeat
        private.data[i].elm[]->s.current[];
        s;
   for);
   inner theScanner;
   
--- multiSetFindDopart: doPart ---
do tp:(# 
        p:@predicate;
        thiselm:^element;
     do
        (for i:private.size repeat
             private.data[i].elm[]->thiselm[];
             (if thiselm[]->p then
                 thiselm[]->current[];
                 INNER find;
                 leave tp;
             if);
        for);
      #);
   
--- multiSetCopyDopart:doPart ---
do
   INNER;
   (if not doneInInner then
       tp:
         (# p:@predicate;
            cnt:@integer;
            theSet:^multiSet;
            aCell:^theCellType;
         do
            this(Container)._new->theSet[];
            private.size->theSet.private.data.new;
            0->cnt;
            (for i:private.size repeat
                 private.data[i].copy->aCell[];
                 (if aCell.elm[]->p then
                     cnt+1->cnt;
                     aCell[]->theSet.private.data[cnt][];
                 if);
            for);
            cnt->theSet.private.size;
            theSet[]->theCopy[];
         #);
   if);
   
   
--- multiSetEmptyDopart:doPart ---
do private.size=0->value;
   
   
--- multiSetCapacityDopart:doPart ---
do private.data.range->value;


--- multiSetHasDopart:doPart ---
do l:(# 
     do (for i:private.size repeat
             (if (elm[],private.data[i].elm[])->myEqual then
                 true->value;
                 leave l;
             if);
        for);
     #);
   Inner;
   
--- multiSetClearDopart: dopart ---
do
   2->private.data.new;
   0->private.size;
   
--- multiSetSizeDopart: dopart ---
do private.size->value;
   Inner;
   
--- multiSetInsertPrivate: descriptor ---
(# aCell:^theCellType;
do
   (if private.size=private.data.range then
       private.data.range->private.data.extend;
   if);
   1+private.size->private.size;
   &theCelltype[]->aCell[];
   elm[]->aCell.elm[];
   aCell[]->private.data[private.size][];
#)

--- multiSetDeletePrivate: descriptor ---
(# myEqual:@equal;
   pos:@integer;
do -1->pos;
   l:
     (#
     do (for i:private.size repeat
             (if (elm[],private.data[i].elm[])->myEqual then
                 i->pos;
                 leave l;
             if);
        for);
     #);
   (* pos is position of element in repetition *)
   (if true
    // pos<1 then (* do nothing, not in set *)
    // pos<private.size then
       private.data[private.size][]->private.data[pos][]; (* move last item down *)
       private.size-1->private.size;
    // pos=private.size then
       NONE->private.data[private.size][]; 
       private.size-1->private.size;
   if);
#)

--- multiSetPrivate:descriptor ---
(# data:[2]^theCellType;
   size:@integer;
#)

(*------------------------------------------------------------*)
(*--- set: multiSet ------------------------------------------*)
(*------------------------------------------------------------*)

--- setInsertDopart: dopart ---
do
   not (elm[]->has)->AllowedToInsert;
   inner;
