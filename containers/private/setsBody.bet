ORIGIN '../sets';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)
--- multiSetTheCellTypeRemoveDopart: dopart ---
do this(theCellType)[]->storage.removeCell;
   NONE->storage.removeCell.elm[]
   
--- multiSetStorageBody: descriptor ---
(# first, last: ^theCellType;
   length: @integer;
   
   insertFirst: @
     (# elm: ^element;
        cElm: ^theCellType
     enter elm[]
     do &theCellType[]->cElm[];
        elm[]->cElm.elm[];
        first[]->cElm.succ[];
        (if length = 0 then 
            cElm[]->last[];
         else cElm[]->first.pred[]
        if);
        cElm[]->first[];
        length+1->length;
        NONE->elm[]; NONE->cElm[]
     #);
   insertLast: @
     (# elm: ^element;
        cElm: ^theCellType
     enter elm[]
     do &theCellType[]->cElm[];
        elm[]->cElm.elm[];
        last[]->cElm.pred[];
        (if length = 0 then
            cElm[]->first[]
         else cElm[]->last.succ[]
        if);
        cElm[]->last[];
        length+1->length;
        NONE->elm[]; NONE->cElm[]
     #);
   removeCell: @
     (# elm: ^element; cElm: ^theCellType
     enter cElm[]
     do (* assumes that the set is NON-empty !! *)
        (if cElm[]
         //first[] then removeFirst->elm[]; NONE->removeFirst.elm[]
         //last[]  then removeLast->elm[]; NONE->removeLast.elm[]
         else
            cElm.elm[]->elm[];
            cElm.succ[]->cElm.pred.succ[];
            cElm.pred[]->cElm.succ.pred[];
            length-1->length
        if);
        NONE->cElm[]
     exit elm[]
     #);
   removeFirst: @
     (# elm: ^element
     do (* assumes that the set is NON-empty !! *)
        first.elm[]->elm[];
        (if first[] = last[] then NONE->first[]->last[]
         else NONE->first.succ.pred[];
            first.succ[]->first[]
        if);
        length-1->length
     exit elm[]
     #);
   removeLast: @
     (# elm: ^element
     do (* assumes that the set is NON-empty !! *)
        last.elm[]->elm[];
        (if first[] = last[] then NONE->first[]->last[]
         else NONE->last.pred.succ[];
            last.pred[]->last[]
        if);
        length-1->length
     exit elm[]
     #)
#)
--- multiSetImplementationScannerPrivateBody: descriptor ---
(# scanner: 
     (# start:< (# do INNER #);
        next:< (# do INNER #)
     #);
   doScanner: scanner
     (# start::< (# do storage.first[]->currentCell[];
                    (if currentCell[] = NONE then &voidScanner[]->theScanner[] if)
                 #);
        next::< (# theCell: ^theCellType
                do currentCell[]->theCell[]; theCell.succ[]->currentCell[];
                   (if currentCell[] = NONE then &voidScanner[]->theScanner[] if)
                #)
     #);
   voidScanner: scanner
     (# start::< (# do NONE->currentCell[] #);
        next::< (# do NONE->currentCell[] #)
     #);
   theScanner: ^scanner
#)
--- multiSetImplementationScannerStartOPDopart: dopart ---
do &multiSetImplementationScannerPrivate.doScanner[]->multiSetImplementationScannerPrivate.theScanner[];
   multiSetImplementationScannerPrivate.theScanner.start;
   (if currentCell[] = NONE then
       NONE->currentElm[];
       INNER startOP
    else currentCell[]->theCell[]; theCell.elm[]->currentElm[]
   if)
--- multiSetImplementationScannerNextOPDopart: dopart ---
do multiSetImplementationScannerPrivate.theScanner.next;
   (if currentCell[] = NONE then
       NONE->currentElm[];
       INNER nextOP
    else currentCell[]->theCell[]; theCell.elm[]->currentElm[]
   if)
--- multiSetImplementationScannerMoreOPDopart: dopart ---
do (currentCell[]<>NONE)->value 

--- multiSetImplementationCopierPrivate: descriptor ---
(# 
do scan(# do (if current[]->thePredicate then
 	         current[]->theCopy.storage.insertLast
 	     if)
       #)
#)

--- multiSetClearDopart: dopart ---
do NONE->storage.first[]->storage.last[]; 0->storage.length; INNER
   
--- multiSetSizeDopart: dopart ---
do storage.length->value; INNER

--- multiSetInsertPrivate: descriptor ---
(# do elm[]->storage.insertFirst #)

--- multiSetDeletePrivate: descriptor ---
(# scanner: @implementationScanner; current: ^element; theCell: ^theCellType
do scanner.start->current[];
   loop: (if not scanner.more then NONE->current[]; notFound; leave loop
          else (if (current[],elm[])->this(multiSet).equal then
                   scanner.currentCell[]->theCell[]; theCell.remove; leave loop
               if);
             scanner.next->current[];
             restart loop
         if)
#)

--- setInsertDopart: dopart ---
do   (*'OLM:setInsert'->putline;*)
   not(elm[]->has)->allowedToInsert; 
   INNER;
