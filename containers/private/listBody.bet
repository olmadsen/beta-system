ORIGIN '../list';
LIB_ITEM 'list';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)
-- listClearDopart: DoPart --
do none ->private.head[]->private.end[]; 0->private.size;   

-- listSizeDopart: DoPart --
do private.size->value;   

-- listEmptyDopart: DoPart --
do private.size = 0->value;   

-- listhasDopart: DoPart --
do
   p:
     (# thisCell: ^theCelltype; myEqual: @equal; 
     do
        private.head[]->thisCell[];
        (for i: private.size repeat
          (if (thisCell.elm[],elm[])->myEqual then true->value; leave p;  if);
          thisCell.succ[]->thisCell[];
          
        for);
        
     #);
     

-- listCopyDopart: DoPart --
do
   fgc:
     (#
        pre: @predicate;
        thelist: ^list;
        cnt: @integer;
        aCell: ^theCelltype;
        newCell: ^theCelltype;
        
     do
        THIS(list)._new->thelist[];
        private.head[]->aCell[];
        (for i: private.size repeat
          (aCell.copy)->newCell[];
          aCell.elm[]->current[];
          (if current[]->pre then (* insert newCell in thelist *)
              (if true
               // cnt = 0 then
                  newCell[]->thelist.private.head[];
                  newCell[]->thelist.private.end[];
                  
               // cnt > 0 then
                  thelist.private.end[]->newCell.pred[];
                  newCell[]->thelist.private.end.succ[];
                  newCell[]->thelist.private.end[];
                  
              if);
              cnt+1->cnt;
              aCell.succ[]->aCell[];
              
          if);
          
        for);
        cnt->thelist.private.size;
        thelist[]->theCopy[];
        
     #);
     

-- listConcatenateDopart: DoPart --
do
   THIS(list).copy->newlist[];
   otherlist.scan
     (#  do current[]->newlist.append;  #);
     

-- listPrependDopart: DoPart --
do
   &theCelltype[]->position[];
   elm[]->position.elm[];
   (if true
    // private.size = 0 then
       position[]->private.head[]; position[]->private.end[]; 
    // private.size > 0 then
       private.head[]->position.succ[];
       position[]->private.head.pred[];
       position[]->private.head[];
       
   if);
   1+private.size->private.size;
     

-- listAppendDopart: DoPart --
do
   &theCelltype[]->position[];
   elm[]->position.elm[];
   (if true
    // private.size = 0 then
       position[]->private.head[]; position[]->private.end[]; 
    // private.size > 0 then
       private.end[]->position.pred[];
       position[]->private.end.succ[];
       position[]->private.end[];
       
   if);
   1+private.size->private.size;
     

-- listHeadDopart: DoPart --
do private.head[]->position[];   

-- listTailDopart: DoPart --
do
   copy->lst[];
   (if lst.private.size > 0 then
       lst.private.head.succ[]->lst.private.head[];
       none ->lst.private.head.pred[];
       lst.private.size-1->lst.private.size;
       
   if);
     

-- listLastDopart: DoPart --
do private.end[]->position[];   

-- listPreampleDopart: DoPart --
do
   copy->lst[];
   (if lst.private.size > 0 then
       lst.private.end.pred[]->lst.private.end[];
       none ->lst.private.end.succ[];
       lst.private.size-1->lst.private.size;
       
   if);
     

-- listInsertBeforeDopart: DoPart --
do
   &theCelltype[]->newPosition[];
   elm[]->newPosition.elm[];
   private.size+1->private.size;
   (if position[] <> none then
       position[]->newposition.succ[];
       position.pred[]->newPosition.pred[];
       (if position.pred[]<>none then
           newPosition[]->position.pred.succ[];
       if);
       newPosition[]->position.pred[];
       (if position[]=private.head[] then newPosition[]->private.head[]; if);
    else
       (if private.end[]=none then
           newPosition[]->private.head[]->private.end[];
        else
           private.end[]->newPosition.pred[];
           newPosition[]->private.end.succ[]->private.end[];
       if);
   if);
     

-- listInsertAfterDopart: DoPart --
do
   &theCelltype[]->newPosition[];
   elm[]->newPosition.elm[];
   private.size+1->private.size;
   (if position[] <> none then
       position[]->newposition.pred[];
       position.succ[]->newPosition.succ[];
       (if position.succ[]<>none then
           newPosition[]->position.succ.pred[];
       if);
       newPosition[]->position.succ[];
       (if position[]=private.end[] then newPosition[]->private.end[]; if);
    else
       (if private.head[]=none then
           newPosition[]->private.head[]->private.end[];
        else
           private.head[]->newPosition.succ[];
           newPosition[]->private.head.pred[]->private.head[];
       if);
   if);
   
     

-- listDeleteDopart: DoPart --
do
   (if position[] = none then leave delete if);
   (if private.head[]=none then leave delete if);
   private.size-1->private.size;
   position[]->deletedPosition[];
   (if private.head[] = position[] then
       position.succ[]->private.head[];
    else
       position.succ[]->position.pred.succ[];
   if);
   (if private.end[] = position[] then
       position.pred[]->private.end[];
    else
       position.pred[]->position.succ.pred[];
   if);
   none ->position[];
     

-- listDeleteBeforeDopart: DoPart --
do
   (if position[]
    // private.head[] then
       illegalCellReference; 
    // none then
       private.end[]->deletedPosition[];
       private.end.pred[]->private.end[];
       (if private.end[] = none then
           none ->private.head[]
        else
           none ->private.end.succ.pred[]; none ->private.end.succ[]
       if)
    // private.head.succ[] then
       private.head[]->deletedPosition[];
       position[]->private.head[];
       none ->private.head.pred.succ[];
       none ->private.head.pred[]
    else
       position[]->deletedPosition[];
       position.pred.pred[]->position.pred[];
       none ->position.pred.succ.pred[];
       none ->position.pred.succ.succ[];
       position[]->position.pred.succ[];
       
   if);
   private.size-1->private.size;
   INNER DeleteBefore;
     

-- listDeleteAfterDopart: DoPart --
do
   (if position[]
    // private.end[] then
       IllegalCellReference
    // none then
       private.head[]->deletedPosition[];
       private.head.succ[]->private.head[];
       (if private.head[] = none then
           none ->private.end[]
        else
           none ->private.head.pred.succ[]; none ->private.head.pred[]
       if)
    // private.end.pred[] then
       private.end[]->deletedPosition[];
       position[]->private.end[];
       none ->private.end.succ.pred[];
       none ->private.end.succ[]
    else
       position[]->deletedPosition[];
       position.succ.succ[]->position.succ[];
       position[]->position.succ.pred[];
       
   if);
   private.size-1->private.size;
   INNER DeleteAfter;
     

-- listSplitBeforePrivate: Descriptor --
(# copyType: ##list; copyTo: ^list; 
do
   THIS(list)##->copyType##;
   &copyType[]->preList[];
   &copyType[]->postList[];
   preList.init;
   postList.init;
   (if position[] = none then
       copy->preList[]
    else
       preList[]->copyTo[];
       iterate
         (# 
         do
            (if current[] = THIS(splitBefore).position[] then
                postList[]->copyTo[]; 
            if);
            (current.copy)->copyTo.private.appendCell;
            
         #)
   if)
#)  

-- listSplitAfterPrivate: Descriptor --
(# copyType: ##list; copyTo: ^list; 
do
   THIS(list)##->copyType##;
   &copyType[]->preList[];
   &copyType[]->postList[];
   preList.init;
   postList.init;
   (if position[] = none then
       copy->preList[]
    else
       preList[]->copyTo[];
       iterate
         (# 
         do
            (current.copy)->copyTo.private.appendCell;
            (if current[] = THIS(splitAfter).position[] then
                postList[]->copyTo[]; 
            if);
            
         #)
   if)
#)  

-- listAtDopart: DoPart --
do
   private.head[]->position[];
   (if (elm[] <> none ) and (position[] <> none ) then
       loop:
         (# myeq: @equal; 
         do
            (if (position.elm[],elm[])->myeq then
                leave loop; 
             else
                (if position.succ[] <> none then
                    position.succ[]->position[]; restart loop; 
                 else
                    none ->position[]; 
                if);
                
            if);
            
         #);
       
    else
       none ->position[]; 
   if);
     

-- listLocateDopart: DoPart --
do
   start;
   private.head[]->position[];
   l:
     (# current: ^element; 
     do
        (for i: private.size repeat
          position.elm[]->current[];
          (if position[]->predicate then INNER locate; leave l;  if);
          position.succ[]->position[];
          
        for);
        notFound;
        
     #);
   end;

-- listFindDopart: DoPart --
do
   l:
     (# theCell: ^theCelltype; 
     do
        private.head[]->theCell[];
        (for i: private.size repeat
          theCell.elm[]->current[];
          (if current[]->predicate then INNER find; leave l;  if);
          theCell.succ[]->theCell[];
          
        for);
        notFound;
        
     #);
     

-- listTheScannerDopart: DoPart --
do
   private.head[]->theCell[];
   l:
   (if theCell[] <> none then
       true->notdone;
       INNER ;
       (if notdone then
           theCell.elm[]->s.current[]; (if s.current[]->w then s;  if); 
       if);
       theCell.succ[]->theCell[];
       restart l;
       
   if);
     

-- listReverseScanner: DoPart --
do
   true->s.first;
   s.start;
   private.end[]->aCell[];
   l:
   (if aCell[] <> none then
       true->notdone;
       INNER ;
       (if notdone then
           (if aCell.elm[]->w then aCell.elm[]->s.current[]; s;  if); 
       if);
       aCell.pred[]->aCell[];
       restart l;
       
   if);
   s.end;
   false->s.first;
   (* enable static rescanning *)
     

-- listScanReverseDopart: DoPart --
do
   (if not first then
       (THIS(scanReverse)[],&where[])->TheReverseScanner
    else
       INNER ScanReverse; 
   if);
     

-- listFromScanner: DoPart --
do
   true->s.first;
   s.start;
   (if aCell[] = none then private.head[]->aCell[];  if);
   l:
   (if aCell[] <> none then
       true->notdone;
       INNER ;
       (if notdone then
           (if aCell.elm[]->w then aCell.elm[]->s.current[]; s;  if); 
       if);
       aCell.succ[]->aCell[];
       restart l;
       
   if);
   s.end;
   false->s.first;
   (* enable static rescanning *)
     

-- listScanFromDopart: DoPart --
do
   (if not first then
       (THIS(scanFrom)[],&where[],position[])->TheFromScanner
    else
       INNER ScanFrom; 
   if);
     

-- listScanReverseFromDopart: DoPart --
do
   position[]->theCell[];
   loop:
     (# 
     do
        theCell.elm[]->current[];
        INNER scanReverseFrom;
        (if theCell.pred[] <> none then
            theCell.pred[]->theCell[]; restart loop; 
        if);
        
     #);
     

-- listIteratePrivate: Descriptor --
(# theCell: ^theCellType; cp: @where; 
do
   private.head[]->theCell[];
   (for i: private.size repeat
     theCell[]->current[];
     (if theCell[]->cp then INNER Iterate if);
     theCell.succ[]->theCell[];
     
   for);
   
#)  

-- listIterateDopart: DoPart --
do start; listIteratePrivate; end;   

-- listIterateFromPrivate: Descriptor --
(# theCell: ^theCellType; cp: @where; 
enter theCell[]
do
   l:
   (if theCell[] <> none then
       (if theCell[]->cp then theCell[]->current[]; INNER IterateFrom;  if);
       theCell.succ[]->theCell[];
       restart l;
       
   if);
   
#)  

-- listIterateFromDopart: DoPart --
do start; position[]->listiterateFromPrivate; end;   

-- listIterateReversePrivate: Descriptor --
(# theCell: ^theCellType; cp: @cellPredicate; 
do
   private.end[]->theCell[];
   (for i: private.size repeat
     theCell[]->current[];
     (if theCell[]->cp then INNER IterateReverse;  if);
     theCell.pred[]->theCell[];
     
   for);
   
#)  

-- listIterateReverseDopart: DoPart --
do start; listIterateReversePrivate; end;   

-- listIterateReverseFromPrivate: Descriptor --
(# theCell: ^theCellType; cp: @where; 
enter theCell[]
do
   l:
   (if theCell[] <> none then
       (if theCell[]->cp then
           theCell[]->current[]; INNER IterateReverseFrom; 
       if);
       theCell.pred[]->theCell[];
       restart l;
       
   if);
   
#)  

-- listIterateReverseFromDopart: DoPart --
do start; position[]->listiterateReverseFromPrivate; end;   

-- listPrivate: Descriptor --
(#
   head: ^theCelltype;
   end: ^theCelltype;
   size: @integer;
   AppendCell:
     (# newCell: ^theCelltype; 
     enter newCell[]
     do
        (if true
         // size = 0 then
            newCell[]->head[]; newCell[]->end[]; 
         // size > 0 then
            end[]->newCell.pred[]; newCell[]->end.succ[]; newCell[]->end[]; 
        if);
        size+1->size;
        
     #);
   
#)  

-- listDoEnter:dopart --
do INNER;
   (if not doneInInner then
       theOther.iterate
       (# 
       do (if current.elm[]<>none then
              (if current.elm[]->thePred then
                  current.copy->private.appendCell
              if)
          if)
       #)
   if)
   
             
          
