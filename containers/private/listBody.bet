ORIGIN '../list';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)
--- listStorageBody: descriptor ---
(# first, last: ^theCellType;
   length: @integer;
   
   insertBefore: @
     (# newCell, position: ^theCellType
     enter (newCell[],position[])
     do (if last[] = NONE then
            NONE->newCell.pred[]->newCell.succ[];
            newCell[]->first[]; newCell[]->last[];
         else (if position[]
               //NONE then
                  last[]->newCell.pred[];
                  NONE->newCell.succ[];
                  newCell[]->last.succ[];
                  newCell[]->last[]
               //first[] then
                  position[]->newCell.succ[];
                  newCell[]->position.pred[];
                  NONE->newCell.pred[];
                  newCell[]->first[]
               else
                  position[]->newCell.succ[];
                  position.pred[]->newCell.pred[];
                  newCell[]->position.pred.succ[];
                  newCell[]->position.pred[];
              if)
        if);
        length+1->length;
        NONE->newCell[]->position[]
     #);
   insertAfter: @
     (# newCell, position: ^theCellType
     enter (newCell[],position[])
     do (if first[] = NONE then
            NONE->newCell.pred[]->newCell.succ[];
            newCell[]->first[]->last[]
         else (if position[]
               //NONE then
                  first[]->newCell.succ[];
                  NONE->newCell.pred[];
                  newCell[]->first.pred[];
                  newCell[]->first[]
               //last[] then
                  position[]->newCell.pred[];
                  newCell[]->position.succ[];
                  NONE->newCell.succ[];
                  newCell[]->last[]
               else
                  position[]->newCell.pred[];
                  position.succ[]->newCell.succ[];
                  newCell[]->position.succ.pred[];
                  newCell[]->position.succ[];
              if)
        if);
        length+1->length;
        NONE->newCell[]->position[]
     #);
   delete: @
     (# position, deleted: ^theCellType
     enter position[]
     do (* assumes that the list in NON-empty !! *)
        (if position[] = NONE then
            NONE->deleted[];
         else
            (if position[]
             //first[] then
                first[]->deleted[];
                (if first[] = last[]
                    then NONE->first[]->last[]
                 else
                    first.succ[]->first[];
                    NONE->first.pred[]
                if)
             //last[] then
                last[]->deleted[];
                (if first[] = last[]
                    then NONE->first[]->last[]
                 else
                    last.pred[]->last[];
                    NONE->last.succ[]
                if)
             else
                position[]->deleted[];
                position.pred[]->position.succ.pred[];
                position.succ[]->position.pred.succ[]
            if);
            NONE->deleted.succ[];
            NONE->deleted.pred[];
            length-1->length
        if);
        NONE->position[]
     exit deleted[]
     #);
   deleteBefore: @
     (# position, deleted: ^theCellType
     enter position[]
     do (* assumes that the list in NON-empty !! *)
        (if position[]
         //first[] then
            IllegalCellReference
         //NONE then
            last[]->deleted[];
            last.pred[]->last[];
            (if last[] = NONE then NONE->first[]
             else
                NONE->last.succ.pred[];
                NONE->last.succ[]
            if)
         //first.succ[] then
            first[]->deleted[];
            position[]->first[];
            NONE->first.pred.succ[];
            NONE->first.pred[]
         else
            position.pred[]->deleted[];
            position.pred.pred[]->position.pred[];
            NONE->position.pred.succ.pred[];
            NONE->position.pred.succ.succ[];
            position[]->position.pred.succ[];
        if);
        NONE->deleted.succ[];
        NONE->deleted.pred[];
        length-1->length;
        NONE->position[]
     exit deleted[]
     #);
   deleteAfter: @
     (# position, deleted: ^theCellType
     enter position[]
     do (* assumes that the list in NON-empty !! *)
        (if position[]
         //last[] then
            IllegalCellReference
         //NONE then
            first[]->deleted[];
            first.succ[]->first[];
            (if first[] = NONE then NONE->last[]
             else
                NONE->first.pred.succ[];
                NONE->first.pred[]
            if)
         //last.pred[] then
            last[]->deleted[];
            position[]->last[];
            NONE->last.succ.pred[];
            NONE->last.succ[]
         else
            position.succ[]->deleted[];
            position.succ.succ[]->position.succ[];
            NONE->position.succ.succ.pred[];
            NONE->position.succ.pred.succ[];
            position[]->position.succ.pred[];
        if);
        NONE->deleted.succ[];
        NONE->deleted.pred[];
        length-1->length;
        NONE->position[]
     exit deleted[]
     #);
   iterate: 
     (# start, position, current: ^theCellType
     enter start[]
     do start[]->position[]->current[];
        loop: (if position[]<>NONE then
                  position.succ[]->position[];
                  INNER iterate;
                  position[]->current[];
                  restart loop
              if);
     exit current[]
     #);
   iterateReverse: 
     (# start, position, current: ^theCellType
     enter start[]
     do start[]->position[]->current[];
        loop: (if position[]<>NONE then
                  position.pred[]->position[];
                  INNER iterateReverse;
                  position[]->current[];
                  restart loop
              if);
     exit current[]
     #)
#)

--- listClearDopart: dopart ---
do NONE->storage.first[]->storage.last[]; 0->storage.length; INNER clear

--- listSizeDopart: dopart ---
do storage.length->value; INNER size

--- listPrependDopart: dopart ---
do &theCellType[]->position[]; elm[]->position.elm[];
   (position[],NONE)->storage.insertAfter;
   INNER prepend

--- listAppendDopart: dopart ---
do &theCellType[]->position[]; elm[]->position.elm[];
   (position[],NONE)->storage.insertBefore;
   INNER append

--- listHeadDopart: dopart ---
do storage.first[]->position[]; INNER head

--- listTailDopart: dopart ---
do (if storage.first[] = NONE then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       copy->lst[];
       NONE->lst.storage.deleteAfter;
       NONE->lst.storage.deleteAfter.deleted[]
   if);
   INNER tail

--- listLastDopart: dopart ---
do storage.last[]->position[]; INNER last

--- listPreampleDopart: dopart ---
do (if storage.last[] = NONE then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       copy->lst[];
       NONE->lst.storage.deleteBefore;
       NONE->lst.storage.deleteBefore.deleted[]
   if);
   INNER preample

--- listConcatenatePrivate: descriptor ---
(# tmp: ^list
do copy->lst[];
   theOther.copy->tmp[];
   (if none
    // lst.storage.last[] then (* lst.empty - concat = theOther *)
       tmp[]->lst[]
    // lst.storage.last[] then (* tmp.empty - do nothing *)
    else (* both are non-empty - do prpper concat *)
       lst.storage.last[]->tmp.storage.first.pred[];
       tmp.storage.first[]->lst.storage.last.succ[];
       tmp.storage.last[]->lst.storage.last[];
       lst.storage.length+tmp.storage.length->lst.storage.length;
   if)
#)

--- listInsertBeforeDopart: dopart ---
do &theCellType[]->newPosition[]; elm[]->newPosition.elm[];
   (newPosition[],position[])->storage.insertBefore;
   INNER insertBefore

--- listInsertAfterDopart: dopart ---
do &theCellType[]->newPosition[]; elm[]->newPosition.elm[];
   (newPosition[],position[])->storage.insertAfter;
   INNER insertAfter

--- listDeleteDopart: dopart ---
do (if storage.last[] = NONE then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       position[]->storage.delete->deletedPosition[];
       NONE->storage.delete.deleted[]
   if);
   INNER delete

--- listDeleteBeforeDopart: dopart ---
do (if storage.last[] = NONE then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       position[]->storage.deleteBefore->deletedPosition[];
       NONE->storage.deleteBefore.deleted[]
   if);
   INNER deleteBefore
   
--- listDeleteAfterDopart: dopart ---
do (if storage.first[] = NONE then
       (if empty## = emptyContainer## then emptyContainerError else empty if)
    else
       position[]->storage.deleteAfter->deletedPosition[];
       NONE->storage.deleteAfter.deleted[]
   if);
   INNER deleteAfter

--- listSplitBeforePrivate: descriptor ---
(# copyType: ##list; copyTo: ^list
do this(list)##->copyType##;
   &copyType[]->preList[]; &copyType[]->postList[];
   preList.init; postList.init;
   (if position[] = NONE then
       copy->preList[]
    else
       preList[]->copyTo[];
       storage.first[]->storage.iterate
       (# 
       do (if current[] = this(splitBefore).position[] then
              postList[]->copyTo[] if);
          (current.copy,NONE)->copyTo.storage.insertBefore
       #)
   if)
#)

--- listSplitAfterPrivate: descriptor ---
(# copyType: ##list; copyTo: ^list
do this(list)##->copyType##;
   &copyType[]->preList[]; &copyType[]->postList[];
   preList.init; postList.init;
   (if position[] = NONE then
       copy->postList[]
    else
       preList[]->copyTo[];
       storage.first[]->storage.iterate
       (# 
       do (current.copy,NONE)->copyTo.storage.insertBefore;
          (if current[] = this(splitAfter).position[] then
              postList[]->copyTo[] if)
       #)
   if)
#)

--- listAtDopart: dopart --
do locate(# predicate::< (# do (elm[],current.elm[])->equal->value #)
         do position[]->this(at).position[]
         #);
   INNER at

--- listLocatePrivate: descriptor ---
(# thePredicate: @predicate;
   theStart: @start; theEnd: @end
#)     
--- listLocateDopart: dopart ---
do listLocatePrivate.theStart;
   seek: (# 
         do storage.first[]->storage.iterate
            (# do (if current[]->listLocatePrivate.thePredicate then
                      current[]->this(locate).position[];
                      INNER locate;
                      leave seek 
                  if)
            #);
	    NONE->position[]; notFound
         #);
   listLocatePrivate.theEnd

--- listScanReversePrivate: descriptor ---
(# scanner: @implementationScanner;
   thePredicate: @where;
   theStart: @start; theEnd: @end
#)
--- listScanReverseDopart: dopart ---
do listScanReversePrivate.theStart;
   &listScanReversePrivate.scanner.listImplementationScannerPrivate.reverseScanner[]->listScanReversePrivate.scanner.listImplementationScannerPrivate.directionScanner[]->listScanReversePrivate.scanner.listImplementationScannerPrivate.theScanner[];
   storage.last[]->listScanReversePrivate.scanner.listImplementationScannerPrivate.firstCell[];
   listScanReversePrivate.scanner.start->current[];
   loop: (if listScanReversePrivate.scanner.more then
             (if current[]->listScanReversePrivate.thePredicate then
                 INNER scanReverse
             if);
             listScanReversePrivate.scanner.next->current[];
             restart loop
          else leave loop
         if);
   listScanReversePrivate.theEnd

--- listScanReverseFromPrivate: descriptor ---
(# scanner: @implementationScanner;
   thePredicate: @where;
   theStart: @start; theEnd: @end
#)
--- listScanReverseFromDopart: dopart ---
do listScanReverseFromPrivate.theStart;
   &listScanReverseFromPrivate.scanner.listImplementationScannerPrivate.reverseScanner[]->listScanReverseFromPrivate.scanner.listImplementationScannerPrivate.directionScanner[]->listScanReverseFromPrivate.scanner.listImplementationScannerPrivate.theScanner[];
   position[]->listScanReverseFromPrivate.scanner.listImplementationScannerPrivate.firstCell[];
   listScanReverseFromPrivate.scanner.start->current[];
   loop: (if listScanReverseFromPrivate.scanner.more then
             (if current[]->listScanReverseFromPrivate.thePredicate then
                 INNER scanReverseFrom
             if);
             listScanReverseFromPrivate.scanner.next->current[];
             restart loop
          else leave loop
         if);
   listScanReverseFromPrivate.theEnd
   
--- listScanFromPrivate: descriptor ---
(# scanner: @implementationScanner;
   thePredicate: @where;
   theStart: @start;  theEnd: @end
#)
--- listScanFromDopart: dopart ---
do listScanFromPrivate.theStart;
   &listScanFromPrivate.scanner.listImplementationScannerPrivate.forwardScanner[]->listScanFromPrivate.scanner.listImplementationScannerPrivate.directionScanner[]->listScanFromPrivate.scanner.listImplementationScannerPrivate.theScanner[];
   position[]->listScanFromPrivate.scanner.listImplementationScannerPrivate.firstCell[];
   listScanFromPrivate.scanner.start->current[];
   loop: (if listScanFromPrivate.scanner.more then
             (if current[]->listScanFromPrivate.thePredicate then
                 INNER scanFrom
             if);
             listScanFromPrivate.scanner.next->current[];
             restart loop
          else leave loop
         if);
   listScanFromPrivate.theEnd

--- listIteratePrivate: descriptor ---
(# thePredicate: @where;
   theStart: @start;  theEnd: @end
#)
--- listIterateDopart: dopart ---
do listIteratePrivate.theStart;
   storage.first[]->storage.iterate
   (# do (if current[]->listIteratePrivate.thePredicate then
             current[]->this(iterate).current[];
             INNER iterate
         if)
   #);
   listIteratePrivate.theEnd

--- listIterateFromPrivate: descriptor ---
(# thePredicate: @where;
   theStart: @start;  theEnd: @end
#)
--- listIterateFromDopart: dopart ---
do listIterateFromPrivate.theStart;
   position[]->storage.iterate
   (# do (if current[]->listIterateFromPrivate.thePredicate then
             current[]->this(iterateFrom).current[];
             INNER iterateFrom
         if)
   #);
   listIterateFromPrivate.theEnd

--- listIterateReversePrivate: descriptor ---
(# thePredicate: @where;
   theStart: @start;  theEnd: @end
#)
--- listIterateReverseDopart: dopart ---
do listIterateReversePrivate.theStart;
   storage.last[]->storage.iterateReverse
   (# do (if current[]->listIterateReversePrivate.thePredicate then
             current[]->this(iterateReverse).current[];
             INNER iterateReverse
         if)
   #);
   listIterateReversePrivate.theEnd

--- listIterateReverseFromPrivate: descriptor ---
(# thePredicate: @where;
   theStart: @start;  theEnd: @end
#)
--- listIterateReverseFromDopart: dopart ---
do listIterateReverseFromPrivate.theStart;
   position[]->storage.iterateReverse
   (# do (if current[]->listIterateReverseFromPrivate.thePredicate then
             current[]->this(iterateReverseFrom).current[];
             INNER iterateReverseFrom
         if)
   #);
   listIterateReverseFromPrivate.theEnd

--- listImplementationCopierDopart: dopart ---
do storage.first[]->storage.iterate
   (# 
   do (if current.elm[] = NONE then  
       else (if current.elm[]->thePredicate then
                (current.copy,NONE)->theCopy.storage.insertBefore;
                INNER implementationCopier
            if)
      if)
   #);
   INNER implementationCopier

--- listImplementationScannerPrivateBody: descriptor ---
(# scanner: 
     (# start:< (# do INNER start #);
        next:< (# do INNER next #)
     #);
   forwardScanner: scanner
     (# start::< 
          (# do firstCell[]->currentCell[];
             (if currentCell[] = NONE then else firstCell.succ[]->nextCell[] if)
          #);
        next::< 
          (# do nextCell[]->currentCell[];
             (if currentCell[] = NONE then else nextCell.succ[]->nextCell[] if)
          #)
     #);
   reverseScanner: scanner
     (# start::< 
          (# do firstCell[]->currentCell[];
             (if currentCell[] = NONE then else firstCell.pred[]->nextCell[] if)
          #);
        next::< 
          (# do nextCell[]->currentCell[];
             (if currentCell[] = NONE then else nextCell.pred[]->nextCell[] if)
          #)
     #);
   voidScanner: scanner
     (# start::< (# do NONE->currentCell[] #);
        next::< (# do NONE->currentCell[] #)
     #);
   directionScanner, theScanner: ^scanner;
   firstCell, nextCell: ^theCellType
#)

--- listImplementationScannerStartOPDopart: dopart ---
do (if NONE
    //listImplementationScannerPrivate.theScanner[] then
       &listImplementationScannerPrivate.forwardScanner[]->listImplementationScannerPrivate.directionScanner[]->listImplementationScannerPrivate.theScanner[];
       storage.first[]->listImplementationScannerPrivate.firstCell[];
    //listImplementationScannerPrivate.firstCell[] then
       (if listImplementationScannerPrivate.theScanner##=listImplementationScannerPrivate.forwardScanner## then
           storage.first[]->listImplementationScannerPrivate.firstCell[];
        else storage.last[]->listImplementationScannerPrivate.firstCell[];
       if)
   if);
   listImplementationScannerPrivate.theScanner.start; currentCell[]->theCell[];
   (if NONE
    //theCell[] then NONE->currentElm[]
    //theCell.elm[] then NONE->currentElm[]; INNER startOP
    else theCell.elm[]->currentElm[]
   if)
--- listImplementationScannerNextOPDopart: dopart ---
do listImplementationScannerPrivate.theScanner.next; currentCell[]->theCell[];
   (if NONE
    //theCell[] then
       NONE->currentElm[];
       NONE->listImplementationScannerPrivate.theScanner[]
    //theCell.elm[] then NONE->currentElm[]; INNER nextOP
    else theCell.elm[]->currentElm[]
   if)
--- listImplementationScannerMoreOPDopart: dopart ---
do (currentCell[]<>NONE)->value
