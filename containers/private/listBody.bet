ORIGIN '../list';
LIB_ITEM 'list';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)

--- listClearDopart: dopart ---
do
   NONE->private.head[]->private.end[];
   0->private.size;
   
--- listSizeDopart: dopart ---
do
   private.size->value;
   
--- listEmptyDopart: dopart ---
do
   private.size=0->value;
   
--- listhasDopart:doPart ---
do
   p:
     (# thisCell:^theCelltype;
        myEqual:@equal;
     do
        private.head[]->thisCell[];
        (for i:private.size repeat 
             (if (thisCell.elm[],elm[])->myEqual then 
                 true->value;
                 leave p;
             if);
             thisCell.succ[]->thisCell[];
        for);
     #);
   
   
--- listCopyDopart:doPart ---
do
   fgc:(# pre:@predicate;
          thelist:^list;
          cnt:@integer;
          aCell:^theCelltype;
          newCell:^theCelltype;
       do
          this(list)._new->thelist[];
          private.head[]->aCell[];
          (for i:private.size repeat
               (aCell.copy)->newCell[];
               aCell.elm[]->current[];
               (if current[]->pre then (* insert newCell in thelist *)
                   (if true
                    // cnt=0 then
                       newCell[]->thelist.private.head[];
                       newCell[]->thelist.private.end[];
                    // cnt>0 then
                       thelist.private.end[]->newCell.pred[];
                       newCell[]->thelist.private.end.succ[];
                       newCell[]->thelist.private.end[];
                   if);
                   cnt+1->cnt;
                   aCell.succ[]->aCell[];
               if);
          for);
          cnt->thelist.private.size;
          thelist[]->theCopy[];
       #);
   
--- listConcatenateDopart:doPart ---
do
   this(list).copy->newlist[];
   otherlist.scan(# do current[]->newlist.append; #);
   
   
--- listPrependDopart: dopart ---
do &theCelltype[]->position[];
   elm[]->position.elm[];
   (if true
    // private.size=0 then
       position[]->private.head[];
       position[]->private.end[];
    //private.size>0 then
       private.head[]->position.succ[];
       position[]->private.head.pred[];
       position[]->private.head[];
   if);
   1+private.size->private.size;
   
--- listAppendDopart: dopart ---
do &theCelltype[]->position[];
   elm[]->position.elm[];
   (if true
    // private.size=0 then
       position[]->private.head[];
       position[]->private.end[];
    // private.size>0 then
       private.end[]->position.pred[];
       position[]->private.end.succ[];
       position[]->private.end[];
   if);
   1+private.size->private.size;
   
--- listHeadDopart: dopart ---
do private.head[]->position[];
   
--- listTailDopart: dopart ---
do 
   copy->lst[];
   (if lst.private.size>0 then
       lst.private.head.succ[]->lst.private.head[];
       NONE->lst.private.head.pred[];
       lst.private.size-1->lst.private.size;
   if);
   
--- listLastDopart: dopart ---
do private.end[]->position[];
   
--- listPreampleDopart: dopart ---
do
   copy->lst[];
   (if lst.private.size>0 then
       lst.private.end.pred[]->lst.private.end[];
       NONE->lst.private.end.succ[];
       lst.private.size-1->lst.private.size;
   if);
   

-- listInsertBeforeDopart: dopart ---
do
   &theCelltype[]->newPosition[];
   elm[]->newPosition.elm[];
   (if position[]<>NONE then
       position.pred[]->newPosition.pred[];
       position[]->newPosition.succ[];
       (if position.pred[]<>NONE then
           newPosition[]->position.pred.succ[];
       if);
       newPosition[]->position.pred[];
    else
       newPosition[]->private.end.succ[];
       private.end[]->newPosition.pred[];
       newPosition[]->private.end[];
   if);
   private.size+1->private.size;
   
--- listInsertAfterDopart: dopart ---
do
   &theCelltype[]->newPosition[];
   elm[]->newPosition.elm[];
   (if position[]<>NONE then
       position.succ[]->newPosition.succ[];
       newPosition[]->position.succ[];
       position[]->newPosition.pred[];
       (if newPosition.succ[]<>NONE then
           newPosition[]->newPosition.succ.pred[];
       if);
    else
       newPosition[]->private.head.pred[];
       private.head[]->newPosition.succ[];
       newPosition[]->private.head[];
   if);
   private.size+1->private.size;
   
--- listDeleteDopart: dopart ---
do 
   (if position[]=NONE then leave delete if);
   private.size-1->private.size;
   (if private.head[] // position[] then
       position.succ[]->private.head[];
       position[]->deletedPosition[];
       NONE->position[];
       leave delete;
   if);
   (if private.end[] // position[] then
       position.pred[]->private.end[];
       none->private.end.succ[];
       position[]->deletedPosition[];
       NONE->position[];
       leave delete;
   if);
   position[]->deletedPosition[];
   position.succ[]->position.pred.succ[];
   position.pred[]->position.succ.pred[];
   NONE->position[];
   
--- listDeleteBeforeDopart: dopart ---
do
   (if position[]
    // private.head[] then
       illegalCellReference;
    // NONE then
       private.end[]->deletedPosition[];
       private.end.pred[]->private.end[];
       (if private.end[] = NONE then NONE->private.head[]
        else
           NONE->private.end.succ.pred[];
           NONE->private.end.succ[]
       if)
    //private.head.succ[] then
       private.head[]->deletedPosition[];
       position[]->private.head[];
       NONE->private.head.pred.succ[];
       NONE->private.head.pred[]   
    else
       position[]->deletedPosition[];
       position.pred.pred[]->position.pred[];
       NONE->position.pred.succ.pred[];
       NONE->position.pred.succ.succ[];       
       position[]->position.pred.succ[];       
   if);
   private.size-1->private.size;
   Inner DeleteBefore;
   
--- listDeleteAfterDopart: dopart ---
do  
   (if position[]
    //private.end[] then
       IllegalCellReference
    //NONE then
       private.head[]->deletedPosition[];
       private.head.succ[]->private.head[];
       (if private.head[] = NONE then NONE->private.end[]
        else
           NONE->private.head.pred.succ[];
           NONE->private.head.pred[]
       if)
    //private.end.pred[] then
       private.end[]->deletedPosition[];
       position[]->private.end[];
       NONE->private.end.succ.pred[];
       NONE->private.end.succ[]
    else
       position[]->deletedPosition[];
       position.succ.succ[]->position.succ[];
       position[]->position.succ.pred[];
   if);
   private.size-1->private.size;
   Inner DeleteAfter;
   
--- listSplitBeforePrivate: descriptor ---
(#
   copyType: ##list; copyTo: ^list;
do this(list)##->copyType##;
   &copyType[]->preList[]; &copyType[]->postList[];
   preList.init; postList.init;
   (if position[] = NONE then
       copy->preList[]
    else
       preList[]->copyTo[];
       iterate
       (# 
       do (if current[] = this(splitBefore).position[] then
              postList[]->copyTo[];
          if);
          (current.copy)->copyTo.private.appendCell;
       #)
   if)
#)

--- listSplitAfterPrivate: descriptor ---
(#  
   copyType: ##list; copyTo: ^list;
do this(list)##->copyType##;
   &copyType[]->preList[]; &copyType[]->postList[];
   preList.init; postList.init;
   (if position[] = NONE then
       copy->preList[]
    else
       preList[]->copyTo[];
       iterate
       (# 
       do 
          (current.copy)->copyTo.private.appendCell;
          (if current[] = this(splitAfter).position[] then
              postList[]->copyTo[];
          if);
       #)
   if)
#)


--- listAtDopart: dopart ---
do private.head[]->position[];
   (if (elm[]<>none) and (position[]<>none) then 
       loop:
         (# myeq:@equal;
         do 
            (if (position.elm[],elm[])->myeq then
                leave loop;
             else
                (if position.succ[]<>NONE then
                    position.succ[]->position[];
                    restart loop;
                 else
                    NONE->position[];
                if);
            if);
         #);
    else
       none->position[];
   if);
   
--- listLocateDopart: dopart ---
do
   private.head[]->position[];
   l:(# current:^element; 
     do 
        (for i:private.size repeat
             position.elm[]->current[];
             (if current[]->predicate then
                 INNER locate;
                 leave l;
             if);
             position.succ[]->position[];
        for);
        notFound;
     #);
   
--- listFindDopart:doPart ---
do
   l:(# theCell:^theCelltype; 
     do    
        private.head[]->theCell[];
        (for i:private.size repeat
             theCell.elm[]->current[];
             (if current[]->predicate then
                 INNER find;
                 leave l;
             if);
             theCell.succ[]->theCell[];
        for);
        notFound;
     #);   
   
--- listTheScannerDopart: doPart ---
do
   private.head[]->theCell[]; 
   l:(if theCell[]<>NONE then
         true->notdone;
         Inner;
         (if notdone then
             theCell.elm[]->s.current[];
             (if s.current[]->w then
                 s;
             if);
         if);
         theCell.succ[]->theCell[];
         restart l;
     if);
   
--- listReverseScanner: doPart ---
do 
   true->s.first;
   s.start;
   private.end[]->aCell[];
   l:(if aCell[]<>NONE then
         true->notdone;
         Inner;
         (if notdone then
             (if aCell.elm[]->w then
                 aCell.elm[]->s.current[];
                 s;
             if);
         if);
         aCell.pred[]->aCell[];
         restart l;
     if);
   s.end;
   false->s.first; (* enable static rescanning *)

   
--- listScanReverseDopart: dopart ---
do 
   (if not first then 
       (this(scanReverse)[],&where[])->TheReverseScanner
    else
       INNER ScanReverse;
   if);
   
--- listFromScanner: doPart ---
do 
   true->s.first;
   s.start;
   (if aCell[]=none then private.head[]->aCell[]; if);
   l:(if aCell[]<>NONE then
         true->notdone;
         Inner;
         (if notdone then
             (if aCell.elm[]->w then
                 aCell.elm[]->s.current[];
                 s;
             if);
         if);
         aCell.succ[]->aCell[];
         restart l;
     if);
   s.end;
   false->s.first; (* enable static rescanning *)


--- listScanFromDopart: dopart ---
do
   (if not first then 
       (this(scanFrom)[],&where[],position[])->TheFromScanner
    else
       INNER ScanFrom;
   if);
   
--- listScanReverseFromDopart: dopart ---
do
   position[]->theCell[];
   loop:
     (# 
     do theCell.elm[]->current[];
        Inner scanReverseFrom;
        (if theCell.pred[] <> NONE then
            theCell.pred[]->theCell[];
            restart loop;
        if);
     #);
   
--- listIteratePrivate: descriptor ---
(# theCell:^theCellType;
   cp:@where;
do private.head[]->theCell[];
   (for i:private.size repeat
        theCell[]->current[];
        (if theCell[]->cp then
            Inner Iterate
        if);
        theCell.succ[]->theCell[];
   for);
#)

--- listIterateDopart: dopart ---
do
   start;
   listIteratePrivate;
   end;
   
--- listIterateFromPrivate: descriptor ---
(# theCell:^theCellType;
   cp:@where;
enter theCell[]
do
   l:(if theCell[]<>NONE then
         (if theCell[]->cp then
             theCell[]->current[];
             Inner IterateFrom;
         if);
         theCell.succ[]->theCell[];
         restart l;
     if);
#)


--- listIterateFromDopart: dopart ---
do
   start;
   position[]->listiterateFromPrivate;
   end;
   
   
--- listIterateReversePrivate: descriptor ---
(# theCell:^theCellType;
   cp:@cellPredicate;
do private.end[]->theCell[];
   (for i:private.size repeat
        theCell[]->current[];
        (if theCell[]->cp then
            Inner IterateReverse;
        if);
        theCell.pred[]->theCell[];
   for);
#)

--- listIterateReverseDopart: dopart ---
do  
   start;
   listIterateReversePrivate;
   end;
   
   
--- listIterateReverseFromPrivate: descriptor ---
(# theCell:^theCellType;
   cp:@where;
enter theCell[]
do
   l:(if theCell[]<>NONE then
         (if theCell[]->cp then
             theCell[]->current[];
             Inner IterateReverseFrom;
         if);
         theCell.pred[]->theCell[];
         restart l;
     if);
#)

--- listIterateReverseFromDopart: dopart ---
do
   start;
   position[]->listiterateReverseFromPrivate;
   end;
   
   
--- listPrivate:descriptor ---
(#
   head:^theCelltype;
   end:^theCelltype;
   size:@integer;
   
   AppendCell:
     (# newCell:^theCelltype;
     enter newCell[]
     do
        (if true
         // size=0 then
            newCell[]->head[];
            newCell[]->end[];
         // size>0 then
            end[]->newCell.pred[];
            newCell[]->end.succ[];
            newCell[]->end[];
        if);
        size+1->size;
     #);   
#)





