ORIGIN '../arrayContainer';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-94
 *	 All rights reserved.
 *)
INCLUDE 'containerBody';
--- arrayContainerStorageBody: descriptor ---
(# table: [capacityInitial] ^theCellType;
   
   extend: @
     (# oldRange, inc: @integer 
     do table.range->oldRange;
        capacityIncrement->inc->table.extend;
        (for i: inc repeat
 	     &theCellType[]->table[oldRange+i][]
        for)
     #);
   swap: @
     (# i,j: @integer; tmp: ^theCellType
     enter (i,j)
     do table[i][]->tmp[];
        table[j][]->table[i][];
        tmp[]->table[j][];
        NONE->tmp[]
     #);
   copy: @
     (# theCopy: ^arrayContainer;
        current: ^theCellType
     enter theCopy[]
     do table.range->theCopy.storage.table.new;
        theCopy.init;
        (for i: table.range repeat
             table[i][]->current[];
             (if current.occupied then
	         current.elm[]->theCopy.storage.table[i].elm[];
                 true->theCopy.storage.table[i].occupied; 
             if)
        for)
     #)
#)

--- arrayContainerImplementationScannerStartOPDopart: dopart ---
do i+1->i;
   loop: (if (i<=storage.table.range) then
             (if not storage.table[i].occupied then i+1->i; restart loop if);
             storage.table[i][]->theCell[]->currentCell[];
             theCell.elm[]->currentElm[]
         if);
   INNER startOP
--- arrayContainerImplementationScannerNextOPDopart: dopart ---
do i+1->i;
   loop: (if (i<=storage.table.range) then
             (if not storage.table[i].occupied then i+1->i; restart loop if);
             storage.table[i][]->theCell[]->currentCell[];
             theCell.elm[]->currentElm[]
         if);
   INNER nextOP
--- arrayContainerImplementationScannerMoreOPDopart: dopart ---
do (i<=storage.table.range)->value; INNER moreOP
--- arrayContainerImplementationCopierDopart: dopart ---
do storage.table.range->theCopy.storage.table.new;
   theCopy.init;
   (for i: storage.table.range repeat
        storage.table[i][]->current[];
        (if current.occupied then
	    (if (current.elm[]->thePredicate) then
                current.elm[]->theCopy.storage.table[i].elm[];
                true->theCopy.storage.table[i].occupied; 
            if)
        if)
   for)

--- arrayContainerClearDopart: dopart ---
do (for i: storage.table.range repeat
        &theCellType[]->storage.table[i][];
        false->storage.table[i].occupied
   for);
   INNER clear
--- arrayContainerSizeDopart: dopart ---
do 0->value;
   (for i: storage.table.range repeat
        (if storage.table[i].occupied then value+1->value if)
   for);
   INNER size

--- arrayContainerPutDopart: dopart ---
do elm[]->storage.table[inx].elm[]; true->storage.table[inx].occupied;
   INNER put

--- arrayContainerGetDopart: dopart ---
do storage.table[inx].elm[]->elm[]; INNER get

--- arrayContainerDeleteDopart: dopart ---
do storage.table[inx].elm[]->elm[]; false->storage.table[inx].occupied;
   INNER delete

--- arrayContainerCapacityDopart: dopart ---
do storage.table.range->value; INNER capacity

--- arrayContainerCapacityExtendDopart: dopart ---
do storage.extend; INNER capacityExtend

--- arrayContainerBubblesortBody: descriptor ---
(# k: @integer; LessThan: @less
do (for i: n-1 repeat
        (for j: n-i repeat
	     n-j+1->k;
	     (if ((storage.table[k].elm[],storage.table[k-1].elm[])->LessThan) then  
	         (k,k-1)->storage.swap
	     if)
   for)for)
#)

--- arrayContainerShellsortBody: descriptor ---
(# incr,i,j: @integer; LessThan: @less 
do n div 2->incr;
   l: (if (incr>0) then
	  (for i: n-incr repeat
	       i->j;
	       l1: (if (j>0) then
		       (if ((storage.table[j+incr].elm[],storage.table[j].elm[])->LessThan) then
                           (j+incr,j)->storage.swap; j - incr->j; restart l1
                   if)if)
	  for); 
	  incr div 2->incr;
	  restart l
      if)
#)

--- arrayContainerQuicksortBody: descriptor ---
(# incr,i,j: @integer; LessThan: @less;
   partition: @
     (# i,j: @integer;
        pivot: ^element
     enter (i,j,pivot[])
     do l: (# 
           do (i,j)->storage.swap;
              l1: (if ((storage.table[i].elm[],pivot[])->LessThan) then i+1->i; restart l1 if);
              l1: (if not ((storage.table[j].elm[],pivot[])->LessThan) then j-1->j; restart l1 if);
              (if (i<=j) then restart l if)
           #)
     exit i
     #);
   
   findPivot: @
     (# i,j,res: @integer;
        first: ^element;
     enter (i,j)
     do 0->res;
        storage.table[i].elm[]->first[];
        l: (for k: j-i repeat
	        (if true
                 //(first[],storage.table[k+i].elm[])->LessThan then k+i->res; leave l
                 //(storage.table[k+i].elm[],first[])->LessThan then i->res; leave l
	        if)
           for)
     exit res
     #);
   
   sort: 
     (# i,j: @integer;
        e: ^element;
        k,inx: @integer;
     enter (i,j)
     do (if ((i,j)->findPivot->inx) <> 0 then
            storage.table[inx].elm[]->e[];
            (i,j,e[])->partition->k;
            (i,k-1)->sort;
            (k,j)->sort;
        if)
     #);
   
do (1,n)->sort
#)
