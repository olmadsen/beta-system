ORIGIN '../arrayContainer';
LIB_ITEM 'arraycont';
(*
 * COPYRIGHT
 *	 Copyright (C) Mjolner Informatics, 1992-98
 *	 All rights reserved.
 *)
INCLUDE 'containerBody';
--- arrayContainerPrivateBody: descriptor ---
(# table: [capacityInitial] ^theCellType;
   
   extend: @
     (# oldRange, inc: @integer 
     do table.range->oldRange;
	capacityIncrement->inc->table.extend;
	(for i: inc repeat
	     &theCellType[]->table[oldRange+i][]
	for)
     #);
   swap: @
     (# i,j: @integer; tmp: ^theCellType
     enter (i,j)
     do table[i][]->tmp[];
	table[j][]->table[i][];
	tmp[]->table[j][];
	NONE->tmp[]
     #);
   copy: @
     (# theCopy: ^arrayContainer;
	current: ^theCellType
     enter theCopy[]
     do table.range->theCopy.private.table.new;
	theCopy.init;
	(for i: table.range repeat
	     table[i][]->current[];
	     (if current.occupied then
		 current.elm[]->theCopy.private.table[i].elm[];
		 true->theCopy.private.table[i].occupied; 
	     if)
	for)
     #)
#)

--- arrayContainerInitDopart: doPart ---
do
   (for i: private.table.range repeat
	&theCellType[]->private.table[i][];
	false->private.table[i].occupied
   for);
   INNER Init
   
--- arrayContainerClearDopart: dopart ---
do (for i: private.table.range repeat
	&theCellType[]->private.table[i][];
	false->private.table[i].occupied
   for);
   INNER clear
   
--- arrayContainerSizeDopart: dopart ---
do 0->value;
   (for i: private.table.range repeat
	(if private.table[i].occupied then value+1->value if)
   for);
   INNER size
   
-- arrayContainerEmptyDopart:dopart --
do (size=0)->value; Inner
   
--- arrayContainerHasDoPart:doPart ---
do 
   thishas:
     (# myEqual:@equal;
     do (for i:private.table.range repeat
             (if private.table[i].occupied then
                 (if (private.table[i].elm[],elm[])->myEqual then
                     true->value;
                     leave thishas;
                 if);
             if);
        for);
     #);
   
--- arrayContainerPutDopart: dopart ---
do elm[]->private.table[inx].elm[]; true->private.table[inx].occupied;
   INNER put

--- arrayContainerGetDopart: dopart ---
do (if private.table[inx].occupied then private.table[inx].elm[]->elm[] if);
   INNER get

--- arrayContainerDeleteDopart: dopart ---
do (if private.table[inx].occupied then
       private.table[inx].elm[]->elm[];
       none->private.table[inx].elm[]
   if);
   false->private.table[inx].occupied;
   INNER delete

--- arrayContainerCapacityDopart: dopart ---
do private.table.range->value; INNER capacity

--- arrayContainerCapacityExtendDopart: dopart ---
do private.extend; INNER capacityExtend

   
   
   
--- arrayContainerBubblesortBody: descriptor ---
(# k: @integer; LessThan: @less
do (n,private.table.range)->min->n;
   (for i: n-1 repeat
	(for j: n-i repeat
	     n-j+1->k;
	     (if ((private.table[k].elm[],private.table[k-1].elm[])->LessThan) then
		 (k,k-1)->private.swap
	     if)
   for)for)
#)

--- arrayContainerShellsortBody: descriptor ---
(# incr,i,j: @integer; LessThan: @less
do (n,private.table.range)->min->n;
   n div 2->incr;
   l: (if (incr>0) then
	  (for i: n-incr repeat
	       i->j;
	       l1: (if (j>0) then
		       (if ((private.table[j+incr].elm[],private.table[j].elm[])->LessThan) then
			   (j+incr,j)->private.swap; j - incr->j; restart l1
		   if)if)
	  for);
	  incr div 2->incr;
	  restart l
      if)
#)

--- arrayContainerQuicksortBody: descriptor ---
(# incr,i,j: @integer; LessThan: @less;
   partition: @
     (# i,j: @integer;
	pivot: ^element
     enter (i,j,pivot[])
     do l: (#
	   do (i,j)->private.swap;
	      l1: (if ((private.table[i].elm[],pivot[])->LessThan) then i+1->i; restart l1 if);
	      l1: (if not ((private.table[j].elm[],pivot[])->LessThan) then j-1->j; restart l1 if);
	      (if (i<=j) then restart l if)
	   #)
     exit i
     #);

   findPivot: @
     (# i,j,res: @integer;
	first: ^element;
     enter (i,j)
     do 0->res;
	private.table[i].elm[]->first[];
	l: (for k: j-i repeat
		(if true
		 //(first[],private.table[k+i].elm[])->LessThan then k+i->res; leave l
		 //(private.table[k+i].elm[],first[])->LessThan then i->res; leave l
		if)
	   for)
     exit res
     #);

   sort:
     (# i,j: @integer;
	e: ^element;
	k,inx: @integer;
     enter (i,j)
     do (if ((i,j)->findPivot->inx) <> 0 then
	    private.table[inx].elm[]->e[];
	    (i,j,e[])->partition->k;
	    (i,k-1)->sort;
	    (k,j)->sort;
	if)
     #);

do (1,(n,private.table.range)->min)->sort
#)

--- arrayContainerdoEnterdoPart: doPart ---
do 
   theOther.private.table.range->private.table.new;
   (for i:private.table.range repeat
        (if theOther.private.table[i].elm[]->thePred then
            theOther.private.table[i].copy->private.table[i][];
        if);
   for);
            
   (* this is a general copier, from all to arraycont. * )
   clear;
   theOther.size->private.table.new;
   (for i:theOther.size repeat
        &theCellType[]->private.table[i][];
   for);
   1->count;
   theOther.scan
   (# 
   do (if current
      (current[],count)->put;
      count+1->count 
    #);
    *)
   
   
--- arrayTableTheScannerDopart:doPart ---
do
   (for i:private.table.range repeat
        (if private.table[i].occupied then
            private.table[i].elm[]->s.current[];
            (if s.current[]->w then s; if);
        if);
   for);
   
--- arrayContainerFindDoPart: doPart ---
do
   (for i:private.table.range repeat
        (if private.table[i].occupied then
            (if private.table[i].elm[]->predicate then
                private.table[i].elm[]->current[];
                Inner Find;
            if);
        if);
   for);
   
--- arrayContainerCopyDoPart: doPart ---
do (if not doneInInner then
       this(Container)._new->theCopy[];
       theCopy[]->private.copy;
   if);
