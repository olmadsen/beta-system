ORIGIN 'container';
LIB_DEF 'collection' '../lib';
BODY 'private/collectionBody';
(*
 * COPYRIGHT
 * 
 *       Copyright (C) Aarhus University
 * 
 *       All rights reserved.
 *)
--- lib: attributes ---
collection: container
  (* Collection is the superpattern for all collection data
   * structures.  Defines the operations: 
   *     insert, delete, union, diff, sect, xclOr
   * Container is an abstract superpattern and the currently available
   * subpatterns are (indentation specifies specialization): 
   * 
   *     collection
   *       multiSet
   *         set
   *           classificationSet --- allows for sets of sets, etc.
   *       hashTable
   *         extensibleHashTable --- allows for extending the index
   *                                 range
   *)
  (# <<SLOT collectionLib: attributes>>;
     insert:< 
       (* Takes an element and inserts it in THIS(collection) *)
       (# elm: ^element
       enter elm[]
       do INNER
       #);
     delete:< 
       (* Takes an element and removes the object from
        * THIS(collection).  Invokes the notification notFound, if the
        * element cannot be found.
        *)
       (# elm: ^element;
          notFound:< Notification
            (# 
            do 'Element not found in container'->msg.putLine;
               INNER
            #);
       enter elm[]
       do INNER
       #);
     union:< 
       (* Takes a collection, and unifies its elements into
        *         THIS(collection)
        *)
       (# theOther: ^collection
       enter theOther[]
       <<SLOT collectionUnionDopart: dopart>>
       exit this(collection)[]
       #);
     diff:< 
       (* Takes a collection, and removes its elements from
        *         THIS(collection)
        *)
       (# theOther: ^collection
       enter theOther[]
       <<SLOT collectionDiffDopart: dopart>>
       exit this(collection)[]
       #);
     sect:< 
       (* Takes a collection, and keeps in THIS(collection) those
        * elements that are in both collections
        *)
       (# theOther: ^collection
       enter theOther[]
       <<SLOT collectionSectDopart: dopart>>
       exit this(collection)[]
       #);
     symDiff:< 
       (* Takes a collection, and inserts into THIS(collection) those
        * elements not being in both collections
        *)
       (# theOther: ^collection; tmp1, tmp2: ^collection
       enter theOther[]
       <<SLOT collectionSymDiffDopart: dopart>>
       exit this(collection)[]
       #);
  do INNER
  #) (* collection *);
