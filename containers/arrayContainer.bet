ORIGIN 'container';
BODY 'private/arrayContainerBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
--- lib: attributes ---
arrayContainer: container
  (* ArrayContainer is an abstraction of a repetition, offering
   * container capabilities as well as repetition capabilities.
   * Furthermore, arrayContainer implements three popular sorting
   * algorithms on the elements in the arrayContainer.  Defines the
   * operations: 
   *      capacityInitial, capacityIncrement, capacityExtend,
   *      get, put, delete, bubbleSort, shellSort, quickSort
   *)  
  (# <<SLOT arrayContainerLib: attributes>>;
     less:< booleanValue
       (* should be further bound to contain an ordering operation to
        * be used by the sorting algorithms.  Less is only used during
        * sorting, and can therefore be ignored if sorting is not
        * applied.
        *)
       (# left, right: ^element
       enter (left[],right[])
       do INNER
       #);
     clear::< (# <<SLOT arrayContainerClearDopart: dopart>> #);
     size::< (# <<SLOT arrayContainerSizeDopart: dopart>> #);
     capacity::< (# <<SLOT arrayContainercapacityDopart: dopart>> #);
     capacityInitial:< integerObject(# do 25->value; INNER #);
     capacityIncrement:< integerObject(# do 10->value; INNER #);
     capacityExtend:< (# <<SLOT arrayContainerCapacityExtendDopart: dopart>> #);
     put:< 
       (* Takes an element and an index position and inserts the
        * element at that position
        *)
       (# elm: ^element; inx: @integer 
       enter (elm[],inx)
       <<SLOT arrayContainerPutDopart: dopart>>
       #);
     get:< 
       (* Takes an index position and returns the element at that
        * position
        *)
       (# elm: ^element; inx: @integer
       enter inx
       <<SLOT arrayContainerGetDopart: dopart>>
       exit elm[]
       #);
     delete:< 
       (* Takes an index position and deletes the element at that
        * position (the deleted element is returned)
        *)
       (# inx: @integer; elm: ^element;
       enter inx
       <<SLOT arrayContainerDeleteDopart: dopart>>
       exit elm[]
       #);
     bubbleSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the bubblesort algorithm
        *)
       (# n: @integer
       enter n
       do <<SLOT arrayContainerBubblesortBody: descriptor>>; INNER
       exit this(arrayContainer)[]   
       #);    
     shellSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the shellsort algorithm
        *)
       (# n: @integer
       enter n
       do <<SLOT arrayContainerShellsortBody: descriptor>>; INNER
       exit this(arrayContainer)[]   
       #);     
     quickSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the quicksort algorithm
        *)
       (# n: @integer;
       enter n
       do <<SLOT arrayContainerQuicksortBody: descriptor>>; INNER        
       exit this(arrayContainer)[]   
       #);
     theCellType::< (* Private *)
       (# elm: ^element; occupied: @boolean;
          copy::< (# 
                  do elm[]->theCellCopy.elm[];
                     occupied->theCellCopy.occupied; INNER
                  #)
       enter elm[]
       do INNER 
       exit elm[]
       #);
     implementationScanner::< (* Private *)
       (# i: (* Private *) @integer;
          startOP::< (* Private *)
            (# theCell: ^theCellType
              <<SLOT arrayContainerImplementationScannerStartOPDopart: dopart>>
            #);
          nextOP::< (* Private *)
            (# theCell: ^theCellType
              <<SLOT arrayContainerImplementationScannerNextOPDopart: dopart>>
            #);
          moreOP::< (* Private *)
            (# <<SLOT arrayContainerImplementationScannerMoreOPDopart: dopart>>
            #)
       #);
     implementationCopier::< (* Private *)
       (# theCategory::< arrayContainer; current: ^theCellType 
         <<SLOT arrayContainerImplementationCopierDopart: dopart>> #);
     storage: (* Private *) @<<SLOT arrayContainerStorageBody: descriptor>>
  do INNER
  #) (* arrayContainer *);

