ORIGIN 'container';
LIB_DEF 'arraycont' '../lib';
BODY 'private/arrayContainerBody';
(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)
--- lib: attributes ---
arrayContainer: container
  (* ArrayContainer is an abstraction of a repetition, offering
   * container capabilities as well as repetition capabilities.
   * Furthermore, arrayContainer implements three popular sorting
   * algorithms on the elements in the arrayContainer.  Defines the
   * operations: 
   *      capacityInitial, capacityIncrement, capacityExtend,
   *      get, put, delete, bubbleSort, shellSort, quickSort
   *)  
  (# <<SLOT arrayContainerLib: attributes>>;
     less:< booleanValue
       (* should be further bound to contain an ordering operation to
        * be used by the sorting algorithms.  Less is only used during
        * sorting, and can therefore be ignored if sorting is not
        * applied.
        *)
       (# left, right: ^element
       enter (left[],right[])
       do INNER
       #);
     init::< (# <<SLOT arrayContainerInitDopart: doPart>> #);
     clear::< (# <<SLOT arrayContainerClearDopart: dopart>> #);
     empty::< (# <<SLOT arrayContainerEmptyDopart: dopart>> #);
     size::< (# <<SLOT arrayContainerSizeDopart: dopart>> #);
     capacity::< (# <<SLOT arrayContainercapacityDopart: dopart>> #);
     capacityInitial:< integerObject(# do 25->value; INNER #);
     capacityIncrement:< integerObject(# do 10->value; INNER #); (* -1 means double *)
     capacityExtend:< (# <<SLOT arrayContainerCapacityExtendDopart: dopart>> #);
     find::(# <<SLOT arrayContainerFindDoPart: doPart>> #);
     copy::(# <<SLOT arrayContainerCopyDoPart: doPart>> #);
     has::(# <<SLOT arrayContainerHasDoPart:doPart>> #);
     put:< 
       (* Takes an element and an index position and inserts the
        * element at that position
        *)
       (# elm: ^element; inx: @integer 
       enter (elm[],inx)
       <<SLOT arrayContainerPutDopart: dopart>>
       #);
     get:< 
       (* Takes an index position and returns the element at that
        * position
        *)
       (# elm: ^element; inx: @integer
       enter inx
       <<SLOT arrayContainerGetDopart: dopart>>
       exit elm[]
       #);
     delete:< 
       (* Takes an index position and deletes the element at that
        * position (the deleted element is returned)
        *)
       (# inx: @integer; elm: ^element;
       enter inx
       <<SLOT arrayContainerDeleteDopart: dopart>>
       exit elm[]
       #);
     bubbleSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the bubblesort algorithm
        *)
       (# n: @integer
       enter n
       do <<SLOT arrayContainerBubblesortBody: descriptor>>; INNER
       exit this(arrayContainer)[]   
       #);    
     shellSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the shellsort algorithm
        *)
       (# n: @integer
       enter n
       do <<SLOT arrayContainerShellsortBody: descriptor>>; INNER
       exit this(arrayContainer)[]   
       #);     
     quickSort: 
       (* Takes an index position and sorts the elements in positions
        * [1: n], using the quicksort algorithm
        *)
       (# n: @integer;
       enter n
       do <<SLOT arrayContainerQuicksortBody: descriptor>>; INNER        
       exit this(arrayContainer)[]   
       #);
     doEnter::<
       (# containerType::<arrayContainer
       <<SLOT arrayContainerdoEnterdoPart: doPart>> 
       #);
     theCellType::< (* Private *)
       (# occupied: @boolean;
          copy::< (# 
                  do elm[]->theCellCopy.elm[];
                     occupied->theCellCopy.occupied; INNER
                  #)
       enter elm[]
       do INNER 
       exit elm[]
       #);
     theScanner::<
       (# <<SLOT arrayTableTheScannerDopart:doPart>> #);
     private: (* Private *) @<<SLOT arrayContainerPrivateBody: descriptor>>
  do INNER
  #) (* arrayContainer *);

