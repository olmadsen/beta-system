ORIGIN '../classes';
INCLUDE '~beta/betaast/v5.2/gram';
INCLUDE '~beta/betaast/v5.2/betasematt';
INCLUDE '../../code/followsemanticlink';
INCLUDE '../../code/generate';

-- getClassesDoPart: doPart --
do (# 
      inheritsFrom:
        (# prefix: ^text;
           node: ^astInterface.beta.patternDecl;
           result: @boolean;
        enter (node[], prefix[])
        do (# theObjectDescriptor: ^astInterface.beta.objectDescriptor;
              thePrefixOpt: ^astInterface.AST;
              thePrefix: ^astInterface.beta.prefix;
              theAttributeDenotation: ^astInterface.AST;
              theNameApl: ^astInterface.beta.nameApl;
              thisPrefix: ^text;
              dest: ^astInterface.AST;
              theNameDcl: ^astInterface.beta.nameDcl;
              theNames: ^astInterface.beta.names;
              superNode: ^astInterface.AST;
           do node.getObjectDescriptor -> theObjectDescriptor[];
              theObjectDescriptor.getPrefixOpt -> thePrefixOpt[];
              (if thePrefixOpt.symbol = gram.prefix then
                  thePrefixOpt[] -> thePrefix[];
                  thePrefix.getAttributeDenotation -> theAttributeDenotation[];
                  (if theAttributeDenotation.symbol = gram.nameApl then
                      theAttributeDenotation[] -> theNameApl[];
                      theNameApl.getText -> thisPrefix[];
                      (if prefix[] -> thisPrefix.equalNCS then
                          true -> result
                       else
                          (mps[], theNameApl[]) -> followSemanticLink -> dest[];
                          (if (dest[] <> none) and (dest.symbol = gram.nameDcl) then
                              dest[] -> theNameDcl[];
                              theNameDcl.father -> theNames[];
                              theNames.father -> superNode[];
                              (if superNode.symbol = gram.patternDecl then
                                  (superNode[], prefix[]) -> inheritsFrom -> result;
                              if);
                          if);
                      if);
                  if);
              if);
           #);
        exit result
        #);
      
      collectClasses:
        (# theAttributes: ^astInterface.beta.attributes;
        enter theAttributes[]
        do theAttributes.newScan
           (# thePattern: ^pattern;
           do (if current.symbol = gram.patternDecl then
                  (if (current[], prefix[]) -> inheritsFrom then
                      &pattern[] -> thePattern[];
                      current[] -> thePattern;
                      thePattern[] -> classes.append;
                  if);
              if);
           #);
        #);
      theAttributesForm: ^astInterface.beta.attributesForm;
      gram: @grammar;
      fragName: ^text;
   do &patternList[] -> classes[];
      classes.init;
      (if true
       //'window' -> prefix.equalNCS then
          'GUIenvLib' -> fragName[];
       //'canvas' -> prefix.equalNCS then
          'windowLib' -> fragName[];
       else
          'GUIenvLib' -> fragName[];
      if);
      (mps[], group[], fragName[]) -> scanDomain
      (# thePattern: ^pattern;
      do (if current.symbol = gram.patternDecl then
             (if (current[], prefix[]) -> inheritsFrom then
                 &pattern[] -> thePattern[];
                 current[] -> thePattern;
                 thePattern[] -> classes.append;
             if);
         if);
      #);
   #);
-- patternListFindByName: doPart --
do search: scan
     (# theNames: ^astInterface.beta.names;
        theNameDcl: ^astInterface.beta.nameDcl;
     do current.node.getNames -> theNames[];
        1 -> theNames.get -> theNameDcl[];
        (if theNameDcl.getText -> name.equalNCS then
            current.node[] -> node[];
            leave search;
        if);
     #);
   
-- scanDomainDoPart: doPart --
do (# scanFragmentGroup:
        (# group: ^astInterface.fragmentGroup;
           gram: @grammar;
        enter group[]
        do group.fragmentList.scan
           (# frag: ^astInterface.fragmentForm;
           do   (if current.type = mps.formType then
                    (if current.name[] -> fragName.equalNCS then
                        current.open -> frag[];
                        (if frag.root[] <> none then
                            (if frag.root.symbol = gram.attributesForm then
                                frag[] -> scanFragment;
                            if);
                        if);
                    if)
                if)
           #);
        #);
      check:
        (# anAst: ^astInterface.ast;
        enter anAst[]
        do (if anAst[] <> NONE then
               (if anAst.kind <> mps.kinds.interior then
                   NONE -> anAst[];
               if);
           if)
        exit anAst[]
        #);
      scanFragment:
        (# frag: ^astInterface.fragmentForm;
           theAttributesForm: ^astInterface.beta.attributesForm;
           theAttributes: ^astInterface.beta.attributes;
        enter frag[]
        do frag.root[] -> check -> theAttributesForm[];
           (if theAttributesForm[] <> none then
               theAttributesForm.getAttributes -> check -> theAttributes[];
               (if theAttributes[] <> none then
                   theAttributes.newScan
                   (# 
                   do current[] -> this(scanDomain).current[];
                      inner scanDomain;
                   #);
               if);
           if);
        #);
      openGroup:
        (#
           g: ^astInterface.FragmentGroup;
           name,path,ext: ^Text;
           fullname: ^Text;
           
           
        enter (name[],path[])
        do (name.length-3,name.length)->name.sub->ext[];
           (if '.bet'->ext.equal then
               (name.length-3,name.length)->name.delete
           if);
           (name[],path[]->MPS.stripPathName)->MPS.thePathHandler.convertFilePath
             ->fullname[];
           fullName[] -> MPS.safeOpen -> g[];
            
        exit g[]
        #);
   do group[] -> scanFragmentGroup;
      group.fragmentList.scan (* scan links *)
         (# next: ^astInterface.fragmentGroup;
         do (if current.type
             // mps.linkType then 
                (if current.name.length = 0 then
                    (# T: @text
                    do '\n*** Error in property list of:\n\t'->T; 
                       group.name->T.puttext; '\n\n\t'->T.puttext;
                       'Empty filename in property "INCLUDE"\n'->T.puttext;
                       
                    #)
                 else
                    (current.Name[],group.name)
                      -> OpenGroup 
                      -> next[];
                    (if next[] <> none then
                        next[] -> scanFragmentGroup;
                    if);
                if);
             
            if) 
         #);
   #)
 
