ORIGIN 'abstractcontainer';

BODY 'private/sequencebody';

-- lib: attributes --

sequence: container
  (# <<SLOT sequenceLib: attributes>>;
     
     (* 
      * Stack and queue interface.
      * 
      * Time complexity: amortized O(1)
      *)
     
     append:<
       (# elm: ^element;
       enter elm[]
       <<SLOT sequenceAppend: doPart>> 
       #);
     prepend:<
       (# elm: ^element;
          doPrepend: (* private *) @<<SLOT sequencePrepend: descriptor>> 
       enter elm[]
       do doPrepend; inner 
       #);
     deleteLast:<
       (#  elm: ^element;
       <<SLOT sequenceDeleteLast: doPart>>
       exit elm[]
       #);
     deleteFirst:<
       (# elm: ^element;
       <<SLOT sequenceDeleteFirst: doPart>>
       exit elm[]
       #);
     last:<
       (# elm: ^element;
       <<SLOT sequenceLast: doPart>> 
       exit elm[]
       #);
     first:<
       (# elm: ^element;
       <<SLOT sequenceFirst: doPart>> 
       exit elm[]
       #);
     
     (*
      * Array interface
      *)
     
     get:
       (# inx: @integer;
          elm: ^element;
       enter inx
       <<SLOT sequenceGet: doPart>> 
       exit elm[]
       #);
     put:
       (# inx: @integer;
          elm: ^element;
       enter (inx, elm[])
       <<SLOT sequencePut: doPart>> 
       #);
     insert:
       (# inx: @integer;
          elm: ^element;
       enter (inx, elm[])
       <<SLOT sequenceInsert: doPart>>
       #);
     delete:
       (# inx: @integer;
          elm: ^element;
       enter inx
       <<SLOT sequenceDelete: doPart>>
       exit elm[]
       #);
     insertRange:
       (# inx: @integer;
          range: @integer;
          fill: ^element;
       enter (inx, range, fill[])
       <<SLOT sequenceInsertRange: doPart>>
       #);
     deleteRange:
       (# inx: @integer;
          range: @integer;
       enter (inx, range)
       <<SLOT sequenceDeleteRange: doPart>>
       #);
     
     (*
      * Scanning
      *)
     
     scan:
       (# current: ^element;
          inx: @integer;
       <<SLOT sequenceScan: doPart>> 
       #);
     
     (* 
      * Sort and search
      *)
     
     lessFunction: booleanValue
       (# left, right: ^element;
       enter (left[], right[])
       do inner;
       #);
     sort:
       (# less:< lessFunction;
          doSort: @<<SLOT sequenceSort: descriptor>>;
       do doSort;
       #);
     
     binarySearch:
       (# 
          less:<
            (# elm: ^element;
               value: @boolean;
            enter elm[]
            do inner;
            exit value
            #);
          equal:<
            (# elm: ^element;
               value: @boolean;
            enter elm[]
            do inner;
            exit value
            #);
          
          left: ^element;
          right: ^element;
          found: ^element;
          doBinarySearch: (* private *) @<<SLOT sequenceDoBinarySearch: descriptor>>;
       do doBinarySearch;
          inner;
       exit found[]
       #);
     
     (*
      * Configuration
      *)
     
     extendCapacityRight:
       (# n: @integer;
       enter n 
       <<SLOT sequenceExtendCapacityRight: doPart>> 
       #);
     extendCapacityLeft:
       (# n: @integer;
       enter n 
       <<SLOT sequenceExtendCapacityLeft: doPart>> 
       #);
     
     (* 
      * Further bindings
      *)
     
     init:<
       (# <<SLOT sequenceInit: doPart>> #);
     clear:<
       (# <<SLOT sequenceClear: doPart>> #);
     
     
     (*
      * Final bindings
      *)
     
     size::
       (# <<SLOT sequenceSize: doPart>> #);
     
     empty::
       (# <<SLOT sequenceEmpty: doPart>> #);
     has::
       (# dohas: @<<SLOT sequenceHas: descriptor>> 
       do doHas
       #);
     
     indexError:< exception
       (# do 'index error in sequence' -> msg.append; inner; #);
     storage: (* Private *) @<<SLOT sequenceStorage: descriptor>>;
  #);
