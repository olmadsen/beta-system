ORIGIN '~beta/basiclib/v1.5/betaenv';

BODY 'private/sequencebody';

-- lib: attributes --

sequence:
  (# <<SLOT sequenceLib: attributes>>;
     
     element:< object;
     
     append:<
       (# elm: ^element;
       enter elm[]
       <<SLOT sequenceAppend: doPart>> 
       #);
     prepend:<
       (# elm: ^element;
          doPrepend: (* private *) @<<SLOT sequencePrepend: descriptor>> 
       enter elm[]
       do doPrepend; inner 
       #);
     deleteLast:<
       (#  elm: ^element;
       <<SLOT sequenceDeleteLast: doPart>>
       exit elm[]
       #);
     deleteFirst:<
       (# elm: ^element;
       <<SLOT sequenceDeleteFirst: doPart>>
       exit elm[]
       #);
     last:<
       (# elm: ^element;
       <<SLOT sequenceLast: doPart>> 
       exit elm[]
       #);
     first:<
       (# elm: ^element;
       <<SLOT sequenceFirst: doPart>> 
       exit elm[]
       #);
     
     get:
       (# inx: @integer;
          elm: ^element;
       enter inx
       <<SLOT sequenceGet: doPart>> 
       exit elm[]
       #);
     put:
       (# inx: @integer;
          elm: ^element;
       enter (inx, elm[])
       <<SLOT sequencePut: doPart>> 
       #);
     insert:
       (# inx: @integer;
          elm: ^element;
       enter (inx, elm[])
       <<SLOT sequenceInsert: doPart>>
       #);
     delete:
       (# inx: @integer;
          elm: ^element;
       enter inx
       <<SLOT sequenceDelete: doPart>>
       exit elm[]
       #);
     insertRange:
       (# inx: @integer;
          range: @integer;
          fill: ^element;
       enter (inx, range, fill[])
       <<SLOT sequenceInsertRange: doPart>>
       #);
     deleteRange:
       (# inx: @integer;
          range: @integer;
       enter (inx, range)
       <<SLOT sequenceDeleteRange: doPart>>
       #);
     
     scan:
       (# current: ^element;
          inx: @integer;
       <<SLOT sequenceScan: doPart>> 
       #);
     scanReverse:
       (# current: ^element;
          inx: @integer;
       <<SLOT sequenceScanReverse: doPart>> 
       #);
     lessFunction: booleanValue
       (# left, right: ^element;
       enter (left[], right[])
       do inner;
       #);
     sort:
       (# less:< lessFunction;
          doSort: @<<SLOT sequenceSort: descriptor>>;
       do doSort;
       #);
     
     binarySearch:
       (# 
          less:<
            (# elm: ^element;
               value: @boolean;
            enter elm[]
            do inner;
            exit value
            #);
          equal:<
            (# elm: ^element;
               value: @boolean;
            enter elm[]
            do inner;
            exit value
            #);
          
          left: ^element;
          right: ^element;
          found: ^element;
          doBinarySearch: (* private *) @<<SLOT sequenceDoBinarySearch: descriptor>>;
       do doBinarySearch;
          inner;
       exit found[]
       #);
     
     extendCapacityRight:
       (# n: @integer;
       enter n 
       <<SLOT sequenceExtendCapacityRight: doPart>> 
       #);
     extendCapacityLeft:
       (# n: @integer;
       enter n 
       <<SLOT sequenceExtendCapacityLeft: doPart>> 
       #);
     
     init:<
       (# <<SLOT sequenceInit: doPart>> #);
     clear:<
       (# <<SLOT sequenceClear: doPart>> #);
     
     size: integerValue
       (# <<SLOT sequenceSize: doPart>> #);
     empty: booleanValue
       (# <<SLOT sequenceEmpty: doPart>> #);
     has: booleanValue
       (# elm: ^element;
          dohas: @<<SLOT sequenceHas: descriptor>> 
       enter elm[]
       do doHas
       #);
     
     emptyContainer:< exception
       (# 
       do 'Empty container' -> msg.append; INNER;
       #);
     indexError:< exception
       (# do 'index error in sequence' -> msg.append; inner; #);
     storage: (* Private *) @<<SLOT sequenceStorage: descriptor>>;
  #);
