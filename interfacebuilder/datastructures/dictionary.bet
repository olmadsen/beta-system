ORIGIN '~beta/basiclib/v1.5/betaenv';

BODY 'private/dictionarybody';

-- lib: attributes --

dictionary:
  (# <<SLOT dictionaryLib: attributes>>;
     
     key:< object;
     element:< object;
     
     equal:< booleanValue
       (# left, right: ^key;
       enter (left[], right[])
       do INNER;
       #);
     hash:< integerValue
       (# theKey: ^key;
       enter theKey[]
       do inner
       #);
     
     insert:<
       (# theKey: ^key;
          elm: ^element;
          doInsert: @<<SLOT dictionaryInsert: descriptor>>;
       enter (theKey[], elm[])
       do doInsert;
       #);
     delete:<
       (# theKey: ^key;
          doDelete: @<<SLOT dictionaryDelete: descriptor>>;
       enter theKey[]
       do doDelete;
       #);
     lookup:<
       (# theKey: ^key;
          elm: ^element;
          doLookup: @<<SLOT dictionaryLookup: descriptor>>;
       enter theKey[]
       do doLookup;
       exit elm[]
       #);
     
     (*
      * Scanning
      *)
     
     scan:
       (# doScan: @<<SLOT dictionaryScan: descriptor>>;
          currentKey: ^key;
          current: ^element;
       do doScan;
       #);
     
     
     (*
      * Configuration
      *)
     
     range:
       (# value: @integer;
       <<SLOT dictionaryRange: doPart>>
       exit value
       #);
     rangeInitial:< integerValue
       (# do 117 -> value; inner #);
     extend:
       (# increment: @integer;
          doExtend: @<<SLOT dictionaryExtend: descriptor>>;
       enter increment
       do doExtend;
       #);
     automaticExtend:< booleanValue
       (# 
       do true -> value;
          inner;
       #);
     allowDuplicates:< booleanValue
       (# 
       do false -> value;
          inner;
       #);
   
     
     init:<
       (# <<SLOT dictionaryInit: doPart>> #);
     clear:<
       (# <<SLOT dictionaryClear: doPart>> #);
     
     
     empty: booleanValue
       (# <<SLOT dictionaryEmpty: doPart>> #);
     size: integerValue
       (# <<SLOT dictionarySize: doPart>> #);
     
     storage: @<<SLOT dictionaryStorage: descriptor>>;
  #);

textDictionary: dictionary
  (# key:: text;
     equal::
       (# 
       do left[] -> right.equal -> value;
       #);
     hash::
       (# doHash: @textHash;
       do theKey[] -> doHash -> value;
       #);
  #);

textHash: integerValue
  (# str: ^text;
  enter str[]
  do 0 -> value;
   
     (for inx: str.lgth repeat 
          ((str.T[inx])- 'a') + value * 52 -> value;
     for);
     (if value < 0 then
         - value -> value;
     if);
  #);
