ORIGIN 'abstractcontainer';

BODY 'private/mapbody';
INCLUDE 'textfunctions';

-- lib: attributes --

map: container
  (# <<SLOT mapLib: attributes>>;
     
     key:< object;
     
     equal:< booleanValue
       (# left, right: ^key;
       enter (left[], right[])
       do inner;
       #);
     
     hash:< integerValue
       (# theKey: ^key;
       enter theKey[]
       do inner;
       #);
     
     insert:<
       (# theKey: ^key;
          elm: ^element;
          doInsert: @<<SLOT mapInsert: descriptor>>;
       enter (theKey[], elm[])
       do doInsert;
       #);
     delete:<
       (# theKey: ^key;
          doDelete: @<<SLOT mapDelete: descriptor>>;
       enter theKey[]
       do doDelete;
       #);
     lookup:<
       (# theKey: ^key;
          elm: ^element;
          doLookup: @<<SLOT mapLookup: descriptor>>;
       enter theKey[]
       do doLookup;
       exit elm[]
       #);
     
     (*
      * Scanning
      *)
     
     scan:
       (# doScan: @<<SLOT mapScan: descriptor>>;
          currentKey: ^key;
          current: ^element;
       do doScan;
       #);
     
     
     (*
      * Configuration
      *)
     
     range:
       (# value: @integer;
       <<SLOT mapRange: doPart>>
       exit value
       #);
     rangeInitial:< integerValue
       (# do 117 -> value; inner #);
     extend:
       (# increment: @integer;
          doExtend: @<<SLOT mapExtend: descriptor>>;
       enter increment
       do doExtend;
       #);
     automaticExtend:< booleanValue
       (# 
       do true -> value;
          inner;
       #);
     allowDuplicates:< booleanValue
       (# 
       do false -> value;
          inner;
       #);
     
     (*
      * Further bindins
      *)
     
     init::<
       (# <<SLOT mapInit: doPart>> #);
     clear::<
       (# <<SLOT mapClear: doPart>> #);
     
     (*
      * Final bindings
      *)
     
     empty::
       (# <<SLOT mapEmpty: doPart>> #);
     size::
       (# <<SLOT mapSize: doPart>> #);
     
     storage: @<<SLOT mapStorage: descriptor>>;
  #);

textMap: map
  (# key:: text;
     equal::
       (# doEqual: @textEqual;
       do (left[], right[]) -> doEqual -> value;
       #);
     hash::
       (# doHash: @textHash;
       do theKey[] -> doHash -> value;
       #);
  #);
