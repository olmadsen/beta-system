ORIGIN '../intmap';

-- intMapLib: attributes --
bucket:
  (# elements: [2] ^element;
     inxs: [2] @integer;
     top: @integer;
  #);

-- intMapPut: descriptor --
(# b: ^bucket;
   bucketInx: @integer;
do putting:
     (#
     do inx mod storage.buckets.range + 1 -> bucketInx;
        storage.buckets[bucketInx][] -> b[];
        (if b[] = none then
            (if elm[] <> none then
                &bucket[] -> b[] -> storage.buckets[bucketInx][];
                1 -> b.top;
                elm[] -> b.elements[1][];
                inx -> b.inxs[1];
                storage.size + 1 -> storage.size;
            if);
         else
            (if elm[] = none then
                (for i: b.top repeat
                     (if b.inxs[i] = inx then
                         b.inxs[b.top] -> b.inxs[i];
                         b.elements[b.top][] -> b.elements[i][];
                         b.top - 1 -> b.top;
                         storage.size - 1 -> storage.size;
                         leave putting;
                     if);
                for);
             else
                (for i: b.top repeat
                     (if b.inxs[i] = inx then
                         elm[] -> b.elements[i][];
                         leave putting;
                     if);
                for);
                
                (*
                 * If we reach this point, the inx was not used
                 *)
                
                (if b.top = b.elements.range then
                    b.top -> b.elements.extend;
                    b.top -> b.inxs.extend;
                if);
                b.top + 1 -> b.top;
                elm[] -> b.elements[b.top][];
                inx -> b.inxs[b.top];
                storage.size + 1 -> storage.size;
            if);
        if);
     #);
#)

-- intMapGet: descriptor --
(# b: ^bucket;
   bucketInx: @integer;
do inx mod storage.buckets.range + 1 -> bucketInx;
   storage.buckets[bucketInx][] -> b[];
   none -> elm[];
   (if b[] <> none then
       l: (for i: b.top repeat
               (if b.inxs[i] = inx then
                   b.elements[i][] -> elm[];
                   leave l;
               if);
          for);
   if);
#)

-- intMapInit: doPart --
do rangeInitial -> storage.buckets.new;
   0 -> storage.size;
   inner;
   
-- intMapClear: doPart --
do storage.buckets.range -> storage.buckets.new;
   0 -> storage.size;
   inner;

-- intMapEmpty: doPart --
do storage.size = 0 -> value;

-- intMapSize: doPart --
do storage.size -> value;
   
-- intMapStorage: descriptor --
(# buckets: [0] ^bucket;
   size: @integer;
#)

