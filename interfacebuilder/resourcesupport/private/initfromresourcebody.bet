ORIGIN '../initfromresource';
MDBODY mac 'macintosh/initfromresource_macbody'
       ppc 'macintosh/initfromresource_macbody'
       nti 'winnt/initfromresource_ntibody'
       default 'X11/initfromresource_X11body';
INCLUDE '../../atom/atom';
INCLUDE '~beta/datastructures/v1.0/map';
INCLUDE '~beta/datastructures/v1.0/intmap';
INCLUDE '~beta/guienv/v1.4/controls';
-- guienvLib: attributes --

resourceStore: intMap
  (# element:: tableAtom;
     init::
       (# resources: ^listAtom;
       enter resources[]
       do resources.storage.scan
          (# ID: ^intAtom;
          do 'id' -> (current.asTableAtom).lookup -> ID[];
             (ID, current[]) -> put;
          #);
       #);
  #);

resourceDB:
  (#
     init:
       (# theStream: ^stream;
          parser: @atomParser;
          theResourceStoreList: ^listAtom;
       enter theStream[]
       do theStream[] -> parser.init;
          parser.readAtom -> theResourceStoreList[];
          (if theResourceStoreList[] <> none then
              theResourceStoreList[] -> initDatabase;
          if);
       #);
     initDatabase:
       (# theResourceStoreList: ^listAtom;
       enter theResourceStoreList[]
       do storage.init;
          theResourceStoreList.storage.scan
          (# name: ^textAtom;
             resources: ^listAtom;
             theResourceStore: ^resourceStore;
             currentTable: ^tableAtom;
          do current.asTableAtom -> currentTable[];
             'name' -> currentTable.lookup -> name[];
             'value' -> currentTable.lookup -> resources[];
             &resourceStore[] -> theResourceStore[];
             resources[] -> theResourceStore.init;
             name.value.makeLC;
             (name, theResourceStore[]) -> storage.insert;
          #);
       #);
     get:
       (# name: ^text;
          theResourceStore: ^resourceStore;
       enter name[]
       do name[] -> storage.lookup -> theResourceStore[];
       exit theResourceStore[]
       #);
     storage: @textMap
       (# element:: resourceStore;
       #);
  #);

getResourceDB: objectPool.get
  (# type:: resourceDB;
     init::
       (# 
       <<SLOT getResourceDBInit: doPart>>
       #);
  #);

getResources:
  (# storeName: ^text;
     ID: @integer;
     resources: ^tableAtom;
  enter (storeName[], ID)
  do (# theResourceDB: ^resourceDB;
        theResourceStore: ^resourceStore;
     do getResourceDB -> theResourceDB[];
        (if theResourceDB[] <> none then
            storeName[] -> theResourceDB.get -> theResourceStore[];
            (if theResourceStore[] <> none then
                ID -> theResourceStore.get -> resources[];
            if);
        if);
     #)
  exit resources[]
  #);


-- windowLib: attributes --

initWindowItem:
  (# type:< windowItem;
     obj: ^type;
     resources: ^tableAtom;
     width, height: ^intAtom;
     x, y: ^intAtom;
     bindLeft, bindRight, bindTop, bindBottom: ^boolAtom;
     visible, hilite, enabled: ^boolAtom;
     borderStyle: ^intAtom;
     borderVisible: ^boolAtom;
  enter (resources[], obj[])
  do 'x' -> resources.lookup -> x[];
     'y' -> resources.lookup -> y[];
     'width' -> resources.lookup -> width[];
     'height' -> resources.lookup -> height[];
     
     'bindRight' -> resources.lookup -> bindRight[];
     'bindLeft' -> resources.lookup -> bindLeft[];
     'bindTop' -> resources.lookup -> bindTop[];
     'bindBottom' -> resources.lookup -> bindBottom[];
     
     'visible' -> resources.lookup -> visible[];
     'hilite' -> resources.lookup -> hilite[];
     'enabled' -> resources.lookup -> enabled[];
     'borderStyle' -> resources.lookup -> borderStyle[];
     'borderVisible' -> resources.lookup -> borderVisible[];
     
     ((x, y), (x + width, y + height)) -> obj.frame;
     bindRight -> obj.bindRight;
     bindLeft -> obj.bindLeft;
     bindTop -> obj.bindTop;
     bindBottom -> obj.bindBottom;
     visible -> obj.visible;
     hilite -> obj.hilite;
     enabled -> obj.enabled;
     borderStyle -> obj.border.style;
     borderVisible -> obj.border.visible;
     inner;
  #);
initButton: initWindowItem
  (# type::< button;
     theLabel: ^textAtom;
  do 'label' -> resources.lookup -> thelabel[];
     theLabel -> obj.label;
     inner;
  #);
initSeparator: initWindowItem
  (# type::< separator;
     style: ^intAtom;
  do 'style' -> resources.lookup -> style[];
     style -> obj.style;
     inner;
  #);
initToggleButton: initButton
  (# type::< toggleButton;
     state: ^boolAtom;
  do 'state' -> resources.lookup -> state[];
     state -> obj.state;
     inner;
  #);
initScrollbar: initWindowItem
  (# type::< scrollBar;
     scrollAmount, pageScrollAmount, maxValue, value: ^intAtom;
  do 'scrollAmount' -> resources.lookup -> scrollAmount[];
     'pageScrollAmount' -> resources.lookup -> pageScrollAmount[];
     'maxValue' -> resources.lookup -> maxValue[];
     'value' -> resources.lookup -> value[];
     
     scrollAmount -> obj.scrollAmount;
     pageScrollAmount -> obj.pageScrollAmount;
     maxValue -> obj.maxValue;
     value -> obj.value;
     inner;
  #);

-- windowInitFromResource: doPart --
do (# resources: ^tableAtom;
      width, height: ^intAtom;
   do storeName.makeLC;
      (storeName[], ID) -> getResources -> resources[];
      'width' -> resources.lookup -> width[];
      'height' -> resources.lookup -> height[];
      (width, height) -> size;
   #);
   
-- windowItemInitFromResource: doPart --
do (# resources: ^tableAtom;
   do storeName.makeLC;
      (storeName[], ID) -> getResources -> resources[];
      (if true 
       //this(windowItem)## <= button## then
          (resources[], this(windowItem)[]) -> initButton;
       //this(windowItem)## <= scrollBar## then
          (resources[], this(windowItem)[]) -> initScrollBar;
       //this(windowItem)## <= toggleButton## then
          (resources[], this(windowItem)[]) -> initToggleButton;
       //this(windowItem)## <= separator## then
          (resources[], this(windowItem)[]) -> initSeparator;
       else
          (resources[], this(windowItem)[]) -> initWindowItem;
      if);
   #)
