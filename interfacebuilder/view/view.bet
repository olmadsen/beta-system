ORIGIN '~beta/guienv/guienv';
INCLUDE '~beta/guienv/graphics'
        '~beta/guienv/fields'
        '~beta/guienv/utils/graphicsadds'
        '~beta/guienv/utils/guienvadds'
        '~beta/guienv/private/datastructures/sequence'
        '~beta/sysutils/objinterface'
        'colorsupport';
-- lib: Attributes --
inspector:
  (# inspect:< (# obj: ^object;  enter obj[] do INNER ;  #);  #);
  

-- windowLib: Attributes --
world: canvas
  (#
     <<SLOT worldLib:Attributes>>;
     doInspect: @boolean;
     background: ^color;
     theInspector: ^inspector;
     inspect:
       (# obj: ^object; 
       enter obj[]
       do
       (*
        * (if theInspector[] <> NONE then
        * obj[] -> theInspector.inspect;
        * if);
        *) (* obj[]->getPatternName->putLine;  *) 
       #);
     updateArea:
       (#
          area: ^box;
          g: @graphics
            (# r: @rectangle; 
            do
               area.asRectangle->r;
               r->clipRectangle;
               background->pen.foreGroundColor;
               r->fillRect;
               (g[])->bulletinBoard.draw;
               
            #);
          
       enter area[]
       do g; 
       #);
     floatingText: @textField
       (#
          mkStyledText:
            (# theText: ^text; theStyledText: ^styledText; 
            enter theText[]
            do &styledText[]->theStyledText[]; theText->theStyledText; 
            exit theStyledText[]
            #);
          mkText:
            (# theText: ^text; theStyledText: ^styledText; 
            enter theStyledText[]
            do &text[]->theText[]; theStyledText->theText; 
            exit theText[]
            #);
          attach:
            (# bounds: ^box; theStringView: ^stringView; 
            enter (theStringView[],bounds[])
            do
                 (#
                    t: @timer
                      (#
                         action:: 
                           (# actualBounds: ^box; theStyle: ^textStyle; 
                           do
                              'Attaching'->putLine;
                              stop;
                              theStringView.string->mkStyledText->contents;
                              (- 3,- 3)->bounds.inset->actualBounds[];
                              theStringView.style->theStyle[];
                              actualBounds.y-2->actualBounds.y;
                              actualBounds.height+2->actualBounds.height;
                              actualBounds.asRectangle->frame;
                              theStyle[]->defaultStyle;
                              show;
                              
                           #);
                         
                      #);
                    
                 do 1->t.start; 
                 #);
               
            #);
          open::  (#  do (1,1)->margin; hide;  #);
          
       #);
     bulletinBoard: @view
       (#
          children: @sequence (# element:: wrapper;  #);
          updateChild:: 
            (# w: ^wrapper do child[]->w[]; true->w.changedFlag;  #);
          onMouseDown:: 
            (# 
            do
               l: children.scanReverse
                 (# 
                 do
                    (if (x,y)->current.containsPoint then
                        (g[],x,y,background[])->current.onMouseDown; leave l; 
                    if);
                    
                 #);
               
            #);
          draw:: 
            (# 
            do
               children.scan
                 (# 
                 do
                    (if current.asRectangle->g.isInClip then
                        (g[])->current.draw; 
                    if);
                    
                 #);
               
            #);
          append:
            (# theWrapper: ^wrapper; child: ^view; 
            enter child[]
            do
               &wrapper[]->theWrapper[];
               child[]->theWrapper.init;
               theWrapper[]->children.append;
               bulletinBoard[]->theWrapper.super[];
               theWrapper[]->updateChild;
               
            #);
          wrapper: adorner
            (#
               init:: 
                 (# 
                 enter theInterior[]
                 do
                    10->x;
                    10->y;
                    theInterior.naturalWidth->width;
                    theInterior.naturalHeight->height;
                    width->putInt;
                    newLine;
                    height->putInt;
                    newLine;
                    THIS(wrapper)[]->theInterior.super[];
                    
                 #);
               draw::  (#  do true->override; (g[])->theInterior.draw;  #);
               onMouseDown:: 
                 (# r: @rectangle; newBounds,area: ^box; 
                 do
                    asRectangle->r;
                    (r,true,true,true,true)->defineRect->r;
                    (r.left,r.top,r.right-r.left,r.bottom-r.top)->makeBox
                      ->newBounds[];
                    THIS(box)[]->newBounds.union->area[];
                    newBounds[]->compute;
                    area[]->updateArea;
                    
                 #);
               changedFlag: @boolean;
               processChanged:
                 (# area: ^box; width,height: @integer; 
                 do
                    false->changedFlag;
                    THIS(wrapper)->makeBox->area[];
                    naturalWidth->width;
                    naturalHeight->height;
                    4
                      ->trace
                        (# 
                        do
                           'update'->xT;
                           ' width = '->xT;
                           width->xI;
                           'height = '->xT;
                           height->xI
                        #);
                    (x,y,width,height)->makeBox->compute;
                    4
                      ->trace
                        (# 
                        do
                           'after'->xT;
                           ' width = '->xT;
                           width->xI;
                           'height = '->xT;
                           height->xI
                        #);
                    THIS(wrapper)[]->area.union->area[];
                    area[]->THIS(world).updateArea;
                    
                 #);
               
            #);
          
       #);
     box:
       (#
          x,y: @integer;
          width,height: @integer;
          containsPoint: booleanValue
            (# x_,y_: @integer; 
            enter (x_,y_)
            do
               (x_ >= x) and (x_ < x+width) and (y_ >= y) and (y_ < y+height)
                 ->value;
               
            #);
          inset:
            (# dx,dy: @integer; new: ^box; 
            enter (dx,dy)
            do
               &box[]->new[];
               x+dx->new.x;
               y+dy->new.y;
               width-2*dx->new.width;
               height-2*dy->new.height;
               (*
                * Fixme: The width or height might be empty
                *)
               
            exit new[]
            #);
          union:
            (# other: ^box; new: ^box; 
            enter other[]
            do
               &box[]->new[];
               (x,other.x)->Min->new.x;
               (y,other.y)->Min->new.y;
               ((x+width,other.x+other.width)->Max)-new.x->new.width;
               ((y+height,other.y+other.height)->Max)-new.y->new.height;
               
            exit new[]
            #);
          copy:
            (# new: ^box; 
            do
               &box[]->new[];
               x->new.x;
               y->new.y;
               width->new.width;
               height->new.height;
               
            exit new[]
            #);
          asRectangle: (#  exit ((x,y),(x+width,y+height)) #);
          
       enter (x,y,width,height)
       exit (x,y,width,height)
       #);
     makeBox:
       (# b: ^box; x,y,width,height: @integer; 
       enter (x,y,width,height)
       do &box[]->b[]; (x,y,width,height)->b; 
       exit b[]
       #);
     layout: sequence (# element:: box; bounds: ^box;  #);
     view: box
       (#
          <<SLOT viewLib:Attributes>>;
          super: ^view;
          init:< (#  do INNER ;  #);
          naturalWidth:< integerValue;
          naturalHeight:< integerValue;
          widthStretch:< integerValue;
          heightStretch:< integerValue;
          ascent:< integerValue;
          draw:<
            (# g: ^graphics; 
            enter g[]
            do
               5
                 ->trace
                   (# 
                   do
                      xN;
                      THIS(view)[]->getPatternName
                        ->xT;
                      up
                   #);
               INNER ;
               5->trace (#  do down #);
               
            #);
          onMouseDown:<
            (#
               x,y: @integer;
               g: ^graphics;
               background: ^color;
               track:
                 (#
                    press:< (#  do INNER #);
                    release:<
                      (#
                         inside:<
                           (#  do INNER #);
                         outside:<
                           (#  do INNER #);
                         
                      do
                         (if state then
                             inside; 
                          else
                             outside; 
                         if);
                         INNER ;
                         
                      #);
                    enterView:<
                      (#  do INNER #);
                    exitView:<
                      (#  do INNER #);
                    state: @boolean;
                    
                 do
                    trackMouse
                      (#
                         mousePress:: 
                           (# 
                           do true->state; press; 
                           #);
                         mouseMove:: 
                           (# inside: @boolean; 
                           do
                              (curPt.h,curPt.v)
                                ->containsPoint
                                ->inside;
                              (if inside <> state
                               then
                                  inside->state;
                                  (if state then
                                      enterView; 
                                   else
                                      exitView; 
                                  if);
                                  
                              if);
                              
                           #);
                         mouseRelease::  (#  do release;  #);
                         
                      #);
                    
                 #);
               handled: @boolean;
               
            enter (g[],x,y,background[])
            do (if doInspect then THIS(view)[]->inspect;  if); INNER ; 
            exit handled
            #);
          updateChild:<
            (# child: ^view; 
            enter child[]
            do
               1
                 ->trace
                   (# 
                   do
                      THIS(view)[]->getPatternName->xT;
                      '.updateChild: '->xT;
                      child[]->getPatternName->xT;
                      xN
                   #);
               INNER ;
               
            #);
          changed:<
            (# 
            do
               2
                 ->trace
                   (# 
                   do THIS(view)[]->getPatternName->xT; '.changed'->xt; xN
                   #);
               (if super[] <> none then
                   THIS(view)[]->super.updateChild; 
               if);
               INNER ;
               
            #);
          compute:<
            (# bounds: ^box; 
            enter bounds[]
            do
               3->trace (#  do xN; THIS(view)[]->getPatternName->xT; up #);
               bounds->THIS(view);
               INNER ;
               3->trace (#  do down #);
               
            #);
          copy:<
            (# type:< view; new: ^type; s: ##view; 
            do THIS(view)##->s##; &s[]->new[]; INNER ; 
            exit new[]
            #);
          
       #);
     composite: view
       (#
          children: @sequence (# element:: view;  #);
          init::<  (#  do children.init; INNER ;  #);
          append:<
            (# child: ^view; 
            enter child[]
            do
               (if child.super[] <> THIS(composite)[] then
                   child[]->children.append;
                   THIS(composite)[]->child.super[];
                   changed;
                   INNER ;
                   
               if);
               
            #);
          delete:<
            (# child: ^view; 
            enter child[]
            do
               (if child.super[] = THIS(composite)[] then
                   child[]->children.delete;
                   none ->child.super[];
                   changed;
                   INNER ;
                   
               if);
               
            #);
          compute::< 
            (# theLayout: ^layout; 
            do
               INNER ;
               children.scan
                 (# inx: @integer
                 do inx+1->inx; inx->theLayout.get->current.compute
                 #);
               
            #);
          draw:: 
            (#  do children.scan (#  do (g[])->current.draw;  #);  #);
          onMouseDown::< 
            (# theLayout: ^layout; 
            do
               l: children.scan
                 (# b: ^box; 
                 do
                    (if (x,y)->current.containsPoint then
                        (g[],x,y,background[])->current.onMouseDown->handled;
                        leave l;
                        
                    if);
                    
                 #);
               (if not handled then INNER ;  if);
               
            #);
          updateChild:: 
            (# 
            do
               (if super[] <> none then
                   THIS(composite)[]->super.updateChild; 
               if);
               
            #);
          copy:: 
            (# type:: composite; 
            do
               new.children.init;
               children.scan
                 (#  do current.copy->new.children.append;  #);
               
            #);
          
       #);
     row: composite
       (#
          init::<  (#  do INNER ;  #);
          compute:: 
            (# 
            do
               &layout[]->theLayout[];
               theLayout.init;
               bounds[]->theLayout.bounds[];
                 (#
                    stretch,spread: @integer;
                    descent,ascent: @integer;
                    x_i,y_i,width_i,height_i: @integer;
                    
                 do
                    bounds.width-naturalWidth->spread;
                    (if spread <> 0 then
                        children.scan
                          (#  do stretch+current.widthStretch->stretch;  #);
                        
                    if);
                    (maxAscent,maxDescent)->(ascent,descent);
                    bounds.x->x_i;
                    children.scan
                      (#
                         spread_i: @integer;
                         stretch_i: @integer;
                         ascent_i: @integer;
                         
                      do
                         (if stretch <> 0 then
                             current.widthStretch->stretch_i;
                             (if stretch_i <> 0 then
                                 (stretch_i*spread) div stretch->spread_i; 
                              else
                                 0->spread_i; 
                             if);
                             
                          else
                             0->spread_i; 
                         if);
                         current.naturalWidth+spread_i->width_i;
                         current.ascent->ascent_i;
                         bounds.y+(ascent-ascent_i)->y_i;
                         current.naturalHeight->height_i;
                         (x_i,y_i,width_i,height_i)->makeBox->theLayout.append;
                         x_i+width_i->x_i;
                         
                      #);
                    
                 #)
            #);
          naturalWidth:: 
            (# 
            do
               children.scan (#  do value+current.naturalWidth->value;  #); 
            #);
          calculateAscentDescent:
            (# 
            do
               children.scan
                 (#
                    height_i: @integer;
                    ascent_i: @integer;
                    descent_i: @integer;
                    
                 do
                    current.naturalHeight->height_i;
                    current.ascent->ascent_i;
                    height_i-ascent_i->descent_i;
                    (maxAscent,ascent_i)->max->maxAscent;
                    (maxDescent,descent_i)->max->maxDescent;
                    
                 #);
               maxAscent
               +
               maxDescent;
               
            #);
          naturalHeight:: 
            (#  do calculateAscentDescent; maxAscent+maxDescent->value;  #);
          ascent:: 
            (# 
            do
               children.scan
                 (#  do (value,current.ascent)->Max->value;  #);
               
            #);
          widthStretch:: 
            (# 
            do
               children.scan (#  do value+current.widthStretch->value;  #); 
            #);
          maxAscent,maxDescent: @integer;
          
       #);
     column: composite
       (#
          compute:: 
            (# 
            do
               &layout[]->theLayout[];
               theLayout.init;
               bounds[]->theLayout.bounds[];
                 (# x_i,y_i,width_i,height_i: @integer; 
                 do
                    bounds.y->y_i;
                    bounds.x->x_i;
                    children.scan
                      (# stretch_i: @integer; spread_i: @integer; 
                      do
                         current.naturalWidth->width_i;
                         current.widthStretch->stretch_i;
                         (bounds.width-width_i,stretch_i)->min->spread_i;
                         width_i+spread_i->width_i;
                         current.naturalHeight->height_i;
                         (x_i,y_i,width_i,height_i)->makeBox->theLayout.append;
                         y_i+height_i->y_i;
                         
                      #);
                    
                 #);
               
            #);
          naturalWidth:: 
            (# 
            do
               children.scan
                 (#  do (value,current.naturalWidth)->Max->value;  #);
               
            #);
          naturalHeight:: 
            (# 
            do
               children.scan
                 (#  do value+current.naturalHeight->value;  #);
               
            #);
          
       #);
     stringView: view
       (#
          string:
            (# 
            enter (#  enter theString[] do - 1->cachedWidth; changed;  #)
            exit theString[]
            #);
          style:
            (# 
            enter (#  enter theStyle[] do - 1->cachedWidth; changed;  #)
            exit theStyle[]
            #);
          paint:
            (# 
            enter (#  enter thePaint[] do changed;  #)
            exit thePaint[]
            #);
          init::<  (#  do blackish->thePaint[]; INNER ;  #);
          naturalWidth:: 
            (# 
            do
               (if cachedWidth = - 1 then
                   theString[]->theStyle.widthOfText->cachedWidth; 
               if);
               cachedWidth->value;
               
            #);
          onMouseDown::<  (#  do INNER ;  #);
          naturalHeight:: 
            (#  do theStyle.ascent+theStyle.descent->value #);
          ascent::  (#  do theStyle.ascent->value;  #);
          draw:: 
            (# 
            do
               thePaint->g.pen.foregroundColor;
               theStyle[]->g.style;
               (x,y+theStyle.ascent)->g.moveTo;
               theString[]->g.drawText;
               
            #);
          copy::< 
            (# type::< stringView; 
            do
               theString.copy->new.theString[];
               theStyle[]->new.theStyle[];
               thePaint[]->new.thePaint[];
               INNER ;
               
            #);
          theString: ^text;
          theStyle: ^textStyle;
          thePaint: ^color;
          cachedWidth: @integer;
          
       #);
     stringViewEditor: adorner
       (#
          interiorType:: stringView;
          init::<  (#  do INNER #);
          onMouseDown:: 
            (# override::  (#  do true->value #); 
            do (interior,THIS(view)[])->floatingText.attach; 
            #);
          
       #);
     imageView: view
       (#
          image:
            (# 
            enter (#  enter theImage[] do changed;  #)
            exit theImage[]
            #);
          naturalWidth:: 
            (# 
            do (if theImage[] <> none then theImage.width->value;  if); 
            #);
          naturalHeight:: 
            (# 
            do (if theImage[] <> none then theImage.height->value;  if); 
            #);
          ascent:: 
            (# 
            do (if theImage[] <> none then theImage.height->value;  if); 
            #);
          draw:: 
            (# 
            do
               (if theImage[] <> none then
                   (theImage[],(0,0),(x,y),width,height)->g.drawRaster; 
               if);
               
            #);
          copy::< 
            (# type:: imageView; 
            do theImage[]->new.theImage[]; INNER ; 
            #);
          theImage: ^pixmap;
          
       #);
     adorner: view
       (#
          interiorType:< view;
          static:< booleanObject;
          interior:
            (# 
            enter
              (# newInterior: ^interiorType; 
              enter newInterior[]
              do
                 (if theInterior[] <> none then
                     none ->theInterior.super[]; 
                 if);
                 newInterior[]->theInterior[];
                 (if theInterior[] <> none then
                     THIS(adorner)[]->theInterior.super[]; 
                 if);
                 
              #)
            exit theInterior[]
            #);
          init::< 
            (# 
            do
               (if static then
                   &interiorType[]->theInterior[];
                   theInterior.init;
                   THIS(adorner)[]->theInterior.super[];
                   
               if);
               INNER ;
               
            #);
          naturalWidth::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then theInterior.naturalWidth->value;  if);
               
            #);
          naturalHeight::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then theInterior.naturalHeight->value;  if);
               
            #);
          widthStretch::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then theInterior.widthStretch->value;  if);
               
            #);
          heightStretch::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then theInterior.heightStretch->value;  if);
               
            #);
          ascent::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then theInterior.ascent->value;  if);
               
            #);
          compute::< 
            (# override: @boolean
            do
               INNER ;
               (if not override then THIS(box)[]->theInterior.compute if)
            #);
          draw::< 
            (# override: @boolean; 
            do
               INNER ; (if not override then (g[])->theInterior.draw;  if); 
            #);
          onMouseDown::< 
            (#
               override:< booleanValue;
               redraw: (#  do (g[])->theInterior.draw;  #);
               
            do
               (if not override then
                   (g[],x,y,background[])->theInterior.onMouseDown->handled;
                   (if not handled then INNER ;  if);
                   
                else
                   INNER ; 
               if);
               
            #);
          updateChild::< 
            (# override: @boolean; 
            do
               INNER ;
               (if not override then
                   (if super[] <> none then
                       THIS(adorner)[]->super.updateChild; 
                   if);
                   
               if);
               
            #);
          copy::< 
            (# type::< adorner; 
            do
               (if theInterior[] <> none then
                   theInterior.copy->new.theInterior[]; 
               if);
               INNER ;
               
            #);
          theInterior: ^interiorType;
          
       #);
     solidBackground: adorner
       (#
          paint:
            (# 
            enter (#  enter thePaint[] do changed;  #)
            exit thePaint[]
            #);
          init::<  (#  do lightGrey->thePaint[]; INNER ;  #);
          draw:: 
            (# 
            do
               true->override;
               thePaint->g.pen.foregroundColor;
               asRectangle->g.fillRect;
               (g[])->theInterior.draw;
               
            #);
          onMouseDown::< 
            (# override::  (#  do true->value #); 
            do
               (g[],x,y,thePaint[])->theInterior.onMouseDown->handled;
               (if not handled then INNER ;  if);
               
            #);
          copy::< 
            (# type::< solidBackground; 
            do thePaint[]->new.thePaint[]; INNER ; 
            #);
          thePaint: ^color;
          
       #);
     shadowIn: (#  exit 1 #);
     shadowOut: (#  exit 2 #);
     motifBorder: adorner
       (#
          borderWidth:
            (# 
            enter (#  enter theBorderWidth do changed #)
            exit theBorderWidth
            #);
          borderStyle:
            (# 
            enter (#  enter theBorderStyle do changed #)
            exit theBorderStyle
            #);
          paint:
            (# 
            enter (#  enter thePaint[] do changed;  #)
            exit thePaint[]
            #);
          init::< 
            (# 
            do
               shadowIn->theBorderStyle;
               2->theBorderWidth;
               lightGrey->thePaint[];
               INNER ;
               
            #);
          naturalWidth:: 
            (# 
            do
               true->override;
               theInterior.naturalWidth+2*theBorderWidth->value;
               
            #);
          naturalHeight:: 
            (# 
            do
               true->override;
               theInterior.naturalHeight+2*theBorderWidth->value;
               
            #);
          draw:: 
            (#
               drawBorder:
                 (#
                    left,right,top,bottom: @integer;
                    topColor,bottomColor: ^color;
                    
                 enter (left,top,right,bottom)
                 do
                    (if theBorderStyle
                     // shadowIn then
                        thePaint[]->lighter->bottomColor[];
                        thePaint[]->darker->topColor[];
                        
                     // shadowOut then
                        thePaint[]->lighter->topColor[];
                        thePaint[]->darker->bottomColor[];
                        
                    if);
                    topColor->g.pen.foregroundColor;
                    (for i: borderWidth repeat
                      ((left+i-1,top+i-1),(right-i,top+i-1))->g.drawLine;
                      ((left+i-1,top+i-1),(left+i-1,bottom-i))->g.drawLine;
                      
                    for);
                    bottomColor->g.pen.foregroundColor;
                    (for i: borderWidth repeat
                      ((right-i,top+i-1),(right-i,bottom-i))->g.drawLine;
                      ((left+i-1,bottom-i),(right-i,bottom-i))->g.drawLine;
                      
                    for);
                    
                 #);
               
            do
               true->override;
               (x,y,x+width,y+height)->drawBorder;
               (g[])->theInterior.draw;
               
            #);
          onMouseDown::< 
            (# override::  (#  do true->value #); 
            do
               (if (x,y)->theInterior.containsPoint then
                   (g[],x,y,background[])->theInterior.onMouseDown->handled;
                   (if not handled then INNER ;  if);
                   
               if);
               
            #);
          compute:: 
            (# 
            do
               (borderWidth,borderWidth)->bounds.inset->theInterior.compute;
               true->override
            #);
          copy::< 
            (# type::< motifBorder; 
            do
               theBorderStyle->new.theBorderStyle;
               theBorderWidth->new.theBorderWidth;
               thePaint[]->new.thePaint[];
               INNER ;
               
            #);
          theBorderStyle,theBorderWidth: @integer;
          thePaint: ^color;
          
       #);
     margin: adorner
       (#
          size:
            (# 
            enter (#  enter theSize do changed;  #)
            exit theSize
            #);
          init::<  (#  do 4->theSize; INNER ;  #);
          naturalWidth:: 
            (# 
            do true->override; theInterior.naturalWidth+2*theSize->value; 
            #);
          naturalHeight:: 
            (# 
            do true->override; theInterior.naturalHeight+2*theSize->value; 
            #);
          compute:: 
            (# 
            do (size,size)->bounds.inset->theInterior.compute; true->override
            #);
          draw::  (#  do true->override; (g[])->theInterior.draw;  #);
          theSize: @integer;
          
       #);
     center: adorner
       (#
          ascent::  (#  do true->override; naturalHeight div 2->value;  #); 
       #);
     open::< 
       (# 
       do
          screen[]->traceStream[];
          grey2->background[];
          bulletinBoard.init;
          true->doInspect;
          THIS(world)[]->floatingText.open;
          100->updateTimer.start;
          INNER ;
          
       #);
     close::<  (#  do INNER ; updateTimer.stop #);
     eventHandler::< 
       (#
          onRefresh:: 
            (# r: ^rectangle; 
            do
               updateRect->r[];
               (r.left,r.top,r.right-r.left,r.bottom-r.top)->makeBox
                 ->updateArea;
               
            #);
          onMouseDown:: 
            (# 
            do
               graphics
                 (# x,y: @integer; 
                 do
                    localPosition->(x,y);
                    (THIS(graphics)[],x,y,none )->bulletinBoard.onMouseDown;
                    
                 #);
               
            #);
          
       #);
     updateTimer: @timer
       (#
          action:: 
            (# 
            do
               bulletinboard.children.scan
                 (# 
                 do (if current.changedFlag then current.processChanged if)
                 #)
            #)
       #);
     switch: [255] @boolean;
     indent: [255] @integer;
     trace:
       (#
          xT: (# xT: ^text enter xT[] do xT[]->tracestream.putText #);
          xC: (# c: @char;  enter c do c->tracestream.put;  #);
          xI:
            (# n: @integer
            enter n
            do
               ' '->tracestream.put; n->tracestream.putint; ' '->tracestream.put
            #);
          xB:
            (# b: @boolean
            enter b
            do
               (if b then
                   ' true '->traceStream.puttext
                else
                   ' false '->traceStream.puttext
               if)
            #);
          xN:
            (# 
            do
               tracestream.newline;
               '$'->xC;
               no->xI;
               ': '->xT;
               (for indent[no] repeat '  '->xT;  for)
            #);
          up: (#  do indent[no]+1->indent[no] #);
          down: (#  do indent[no]-1->indent[no] #);
          no: @integer;
          
       enter no
       do (if switch[no] then INNER ;  if); 
       #);
     traceStream: ^stream;
     
  #);
  

