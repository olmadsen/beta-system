ORIGIN '../forms';
INCLUDE '~beta/sysutils/v1.6/objinterface';

-- windowItemLib: attributes --

flexible: booleanValue
  (# 
  do (if true 
      //this(windowItem)## <= editText## then
         true -> value;
      //this(windowItem)## <= row## then
         true -> value;
      //this(windowItem)## <= col## then
         true -> value;
      else
         false -> value;
     if);
  #);
  
-- canvasLib: attributes --



maxSize:
  (# maxWidth, maxHeight: @integer;
     widthSum, heightSum: @integer;
     noOfChildren: @integer;
  do scan
     (# width, height: @integer;
     do noOfChildren + 1 -> noOfChildren;
        current.size -> (width, height);
        widthSum + width -> widthSum;
        heightSum + height -> heightSum;
        (width, maxWidth) -> max -> maxWidth;
        (height, maxHeight) -> max -> maxHeight;
     #);
  exit ((maxWidth, maxHeight), (widthSum, heightSum), noOfChildren)
  #);
countFlexible: integerValue
  (# 
  do scan
     (# 
     do (if current.flexible then
            value + 1 -> value;
        if);
     #);
  #);

stackingInfo:
  (# sum: @integer;
     max: @integer;
     noOfFlexible: @integer;
  #);

computeStackingInfo:
  (# horInfo, verInfo: ^stackingInfo;
     noOfChildren: @integer;
  do &stackingInfo[] -> horInfo[];
     &stackingInfo[] -> verInfo[];
     scan
     (# w, h: @integer;
     do noOfChildren + 1 -> noOfChildren;
        current.size -> (w, h);
        (w, horInfo.max) -> max -> horInfo.max;
        (h, verInfo.max) -> max -> verInfo.max;
        horInfo.sum + w -> horInfo.sum;
        verInfo.sum + h -> verInfo.sum;
        (if current.flexible then
            horInfo.noOfFlexible + 1 -> horInfo.noOfFlexible;
            verInfo.noOfFlexible + 1 -> verInfo.noOfFlexible;
        if);
     #);
  exit (horInfo[], verInfo[], noOfChildren)
  #);

stackChildrenVertical:
  (# margin, distance: @integer;
     hor, ver: ^resizingAttributes;
     swap:<
       (# left,right: @integer;
       enter (left, right)
       do inner;
       exit (left, right)
       #);
     adjustSize: @boolean;
  enter (margin, distance, hor[], ver[], adjustSize)
  do (# horInfo, verInfo: ^stackingInfo;
        x, y: @integer;
        noOfChildren: @integer;
        deltaY: @integer;
        verJust, horJust: @integer;
        currentWidth, currentHeight: @integer;
        childrenWidth, childrenHeight: @integer;
        extraSpace: @integer;
     do computeStackingInfo -> (horInfo[], verInfo[], noOfChildren);
        (if noOfChildren > 0 then
            (horInfo.max, verInfo.max) -> swap -> (horInfo.max, verInfo.max);
            (horInfo.sum, verInfo.sum) -> swap -> (horInfo.sum, verInfo.sum);
            (horInfo.noOfFlexible, verInfo.noOfFlexible) -> swap -> (horInfo.noOfFlexible, verInfo.noOfFlexible);
            (hor.Justification, ver.Justification) -> swap -> (horJust, verJust);
            
            size -> swap -> (currentWidth, currentHeight);
            margin * 2 + horInfo.max -> childrenWidth;
            margin * 2 + verInfo.sum + (noOfChildren - 1) * distance -> childrenHeight;
            
            (if adjustSize then
                (childrenWidth, childrenHeight) -> swap -> size;
                (childrenWidth, childrenHeight) -> (currentWidth, currentHeight);
             else
                currentHeight - childrenHeight -> extraSpace;
                (if verJust 
                 //topJustify then
                    0 -> extraSpace;
                 //bottomJustify then
                    (* Nothing *)
                 //centerJustify then
                    extraSpace div 2 -> extraSpace;
                 //equalJustify then
                    (# forEach: @integer;
                    do 
                       (if verInfo.noOfFlexible = 0 then
                           (if extraSpace > 0 then
                               (if noOfChildren > 1 then
                                   extraSpace div (noOfChildren - 1) + distance -> distance;
                                   0 -> extraSpace;
                                else
                                   extraSpace div 2 -> extraSpace;
                               if);
                            else
                               0 -> extraSpace;
                           if);
                        else
                           extraSpace div verInfo.noOfFlexible -> forEach;
                           scan
                           (# w, h: @integer;
                           do (if current.flexible then
                                  current.size -> swap -> (w, h);
                                  h + forEach -> h;
                                  (w, h) -> swap -> current.size;
                              if);
                           #);
                           0 -> extraSpace;
                       if);
                    #);
                if);
            if);
            
            margin -> x -> y;
            currentWidth - (2 * margin) -> currentWidth;
            scan
            (# w, h: @integer;
               theX, theY: @integer;
               theWidth: @integer;
               theHeight: @integer;
            do current.size -> swap -> (w, h);
               h -> theHeight;
               y + extraSpace -> theY;
               (if horJust
                //leftJustify then
                   x -> theX;
                   w -> theWidth;
                //rightJustify then
                   x + (currentWidth - w) -> theX;
                   w -> theWidth;
                //centerJustify then
                   x + (currentWidth - w) / 2 -> theX;
                   w -> theWidth;
                //equalJustify then
                   x -> theX;
                   currentWidth -> theWidth;
               if);
               ((theX, theY) -> swap, (theX + theWidth, theY + theHeight) -> swap) -> current.frame;
               y + theHeight + distance -> y;
            #);
         else
            (2 * margin, 2 * margin) -> size;
        if);
     #);
  #);

stackChildrenHorizontal: stackChildrenVertical
  (# swap::
       (# tmp: @integer;
       do left -> tmp;
          right -> left;
          tmp -> right;
       #);
  #);

-- colComputeLayout: doPart --
do (if not sema then
       true -> sema;
       (margin, distance, &horizontal[], &vertical[], true) -> stackChildrenVertical;
       false -> sema;
   if);

-- colOpen: doPart --
do inner;
   computeLayout;

-- colClose: doPart --
do inner;
   
-- colOnFrameChanged: doPart --
do (if not sema then
       true -> sema;
       (margin, distance, &horizontal[], &vertical[], false) -> stackChildrenVertical;
       false -> sema;
   if);
   
-- rowComputeLayout: doPart --
do (if not sema then
       true -> sema;
       (margin, distance, &horizontal[], &vertical[], true) -> stackChildrenHorizontal;
       false -> sema;
   if);
   
-- rowOpen: doPart --
do inner;
   computeLayout;
   
-- rowClose: doPart --
do inner;
   
-- rowOnFrameChanged: doPart --
do (if not sema then
       true -> sema;
       (margin, distance, &horizontal[], &vertical[], false) -> stackChildrenHorizontal;
       false -> sema;
   if);

