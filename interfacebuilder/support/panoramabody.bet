ORIGIN 'panorama';

-- panoramaLib: attributes --

firstChild:
  (# child: ^windowItem;
  do l: scan (# do current[] -> child[]; leave l #);
  exit child[]
  #);
adjustScrollvalues:
  (#
  do scrollbars.scan
     (#
     do current.adjustScrollvalues;
     #);
  #);

-- panoramePrivate: descriptor --
(# 
   duringScroll: @boolean;
#)


-- panoramaSetTheScroll: doPart --
do (# child: ^windowItem;
   do true -> private.duringScroll;
      firstChild -> child[];
      (if child[] <> NONE then
          (-horizontal,-vertical) -> child.position;
          this(window).update;
      if);
      false -> private.duringScroll;
   #)

-- panoramaGetTheScroll: doPart --
do (# child: ^windowItem;
   do firstChild -> child[];
      (if child[] <> NONE then
          child.position -> (horizontal, vertical);
          -vertical -> vertical;
          -horizontal -> horizontal;
      if);
   #)
   
-- panoramaMaxScroll: doPart --
do (# child: ^windowItem;
      width, height: @integer;
      childWidth, childHeight: @integer;
   do l: scan (# do current[] -> child[]; leave l #);
      (if child[] <> NONE then
          size -> (width, height);
          child.size -> (childWidth, childHeight);
          (childWidth - width, 0) -> max -> horizontal;
          (childHeight - height, 0) -> max -> vertical;
      if);
   #)
   
-- panoramOnFrameChanged: doPart --
do adjustScrollvalues;
   INNER;
   
-- panoramOnChildFrameChanged: doPart --
do (if not private.duringScroll then
       adjustScrollvalues;
   if);
   INNER;

-- panoramOpen: doPart --
do scrollbars.init;
   INNER;

-- panoramaScrollbarLib: attributes --
adjustScrollvalues:
  (# oldValue: @integer;
     maxScroll: @integer;
     minPage: @integer;
  do (if NOT flag then
         true -> flag;
         (if not panoramas.empty then
             value -> oldValue;
             0 -> maxScroll;
             maxInt -> minPage;
             panoramas.scan
             (# horizontal, vertical: @integer;
                pageWidth, pageHeight: @integer;
             do current.maxScroll -> (horizontal, vertical);
                current.size -> (pageWidth, pageHeight);
                (if this(scrollbar).vertical then
                    (vertical, maxScroll) -> max -> maxScroll;
                    (pageHeight, minPage) -> min -> minPage;
                 else
                    (horizontal, maxScroll) -> max -> maxScroll;
                    (pageWidth, minPage) -> min -> minPage;
                if);
                
             #);
         if);
         maxScroll -> maxValue;
         minPage -> pageScrollAmount;
         (if oldValue > maxScroll then
             adjustPanorama;
         if);
         false -> flag;
     if);
  #);
adjustPanorama:
  (# vertical, horizontal: @integer;
  do panoramas.scan
     (#
     do current.theScroll -> (horizontal, vertical);
        (if this(scrollbar).vertical then
            value -> vertical;
         else
            value -> horizontal;
        if);
        (horizontal, vertical) -> current.theScroll;
     #);
  #);

-- panoramaScrollbarAttach: doPart --
do this(panoramaScrollbar)[] -> thePanorama.scrollbars.append;
   thePanorama[] -> panoramas.append;
   adjustScrollvalues;
   
-- panoramaScrollbarOnValueChanged: doPart --
do adjustPanorama;
   INNER;
