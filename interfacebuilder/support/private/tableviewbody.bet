ORIGIN '../tableview';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/guienv/utils/drawing';
INCLUDE '~beta/guienv/controls';
INCLUDE '~beta/guienv/private/datastructures/sequence';

-- columnSetTitle: doPart --
do value.copy -> private.theTitle[];

-- columnGetTitle: doPart --
do private.theTitle.copy -> value[];

-- columnSetWidth: doPart --
do value -> private.theWidth;

-- columnGetWidth: doPart --
do private.theWidth -> value;

-- columnLess: doPart --
do left.private.data[private.index][] -> leftData[];
   right.private.data[private.index][] -> rightData[];
   INNER;
   (if not doneInInner then
       less:
         (if leftData[] <> NONE then
             (if rightData[] <> NONE then
                 (if true
                  //(leftData.lgth<rightData.lgth) then
                     (for i: leftData.lgth repeat
                          (if leftData.T[i]<>rightData.T[i] then 
                              (leftData.T[i]<rightData.T[i])->value; 
                              leave less;
                          if)
                     for);
                     true->value;
                  //(leftData.lgth>=rightData.lgth) then
                     (for i: rightData.lgth repeat
                          (if leftData.T[i]<>rightData.T[i] then 
                              (leftData.T[i]<rightData.T[i])->value; 
                              leave less;
                          if)
                     for);
                     false->value;
                 if);
              else
                 false -> value;
             if);
          else
             true -> value;
         if);
   if);

-- columnOpen: doPart --
do 'Column' -> private.theTitle[];
   150 -> private.theWidth;
   0 -> private.index;
   INNER;

-- columnClose: doPart --
do INNER;
   0 -> private.theWidth;
   NONE -> private.theTitle[];


   
-- columnPrivate: descriptor --
(# theTitle: ^text;
   theWidth: @integer;
   pos: ^columnList.theCellType;
   index: @integer;
#)

-- tableViewAppendColumn: doPart --
do theColumn[] -> private.columns.append 
     -> theColumn.private.pos[];
   private.columns.size -> theColumn.private.index;

-- tableViewInsertColumn: doPart --
do	after.private.index -> theColumn.private.index;
   (theColumn[], after.private.pos[]) 
     -> private.columns.insertAfter
     -> theColumn.private.pos[];
   theColumn.private.pos[] -> private.columns.scanFrom
   (#
   do current.private.index + 1 -> current.private.index;
   #);

-- tableViewDeleteColumn: doPart --
do theColumn.private.pos[] -> private.columns.scanFrom
   (#
   do current.private.index - 1 -> current.private.index;
   #);
   theColumn.private.pos[] -> private.columns.delete;
   NONE -> theColumn.private.pos[];
   0 -> theColumn.private.index;



-- mainColumnTypeOnDrawTitle: doPart --
do (# box: @rectangle;
      mainColumnIndent: (# exit 25 #);
      kind: @integer;
   do bounds -> box;
      (if this(column)[] = sortByColumn then
          g.bevelSmallPressed -> kind;
       else
          g.bevelSmallNormal -> kind;
      if);
      (box, kind) -> g.drawBevel;
      g.black -> g.pen.foreGroundColor;
      box.left + mainColumnIndent -> box.left;
      (this(tableView).private.titleStyle[],
      private.theTitle[], box, g.alignmentLeft) -> g.drawCenteredText;
   #);

-- mainColumnTypeOnDrawItem: doPart --
do (# box, iconBox: @rectangle;
      icon: ^pixmap;
      expLeft, expTop: @integer;
   do bounds -> box;
      (if theTableItem.expander then
          box.left + 5 -> expLeft;
          box.top + (rowHeight - 12) div 2 -> expTop;
          (if theTableItem.private.expanded then
              (expLeft, expTop, g.expanderEnabledDown) -> g.drawExpander;
           else
              (expLeft, expTop, g.expanderEnabledRight) -> g.drawExpander;
          if);
      if);
      theTableItem.icon -> icon[];
      (if icon[] <> NONE then
          box -> iconBox;
          iconBox.left + theTableItem.iconIndent -> iconBox.left;
          (icon[], iconBox, g. alignmentLeft) -> g.drawCenteredIcon;
      if);
      (if data[] <> NONE then
          g.black -> g.pen.foreGroundColor;
          box.left + theTableItem.textIndent -> box.left;
          (this(tableView).private.bodyStyle[],
          data[], box, g.alignmentLeft) -> g.drawCenteredText;
      if);
   #);
   


-- simpleColumnSetAlignment: doPart --
do value -> private.theAlignment;

-- simpleColumnGetAlignment: doPart --
do private.theAlignment -> value;

-- simpleColumnOpen: doPart --
do alignLeft -> alignment;
   INNER;
   
-- simpleColumnClose: doPart --
do INNER;


-- simpleColumnOnDrawTitle: doPart --
do (# box: @rectangle;
      inset: (# exit 5 #);
      align: @integer;
      kind: @integer;
   do bounds -> box;
      (if this(column)[] = sortByColumn then
          g.bevelSmallPressed -> kind;
       else
          g.bevelSmallNormal -> kind;
      if);
      (box, kind) -> g.drawBevel;
      g.black -> g.pen.foreGroundColor;
      box.left + inset -> box.left;
      box.right - inset -> box.right;
      (if alignment = alignLeft then
          g.alignmentLeft -> align;
       else
          g.alignmentRight -> align;
      if);
      (this(tableView).private.titleStyle[],
      this(column).private.theTitle[], box, align) -> g.drawCenteredText;
   #);

-- simpleColumnOnDrawItem: doPart --
do (# box: @rectangle;
      inset: (# exit 5 #);
      align: @integer;
   do (if data[] <> NONE then
          'bounds.left = ' -> puttext;
          bounds.left -> putint;
          newline;
          bounds -> box;
          g.black -> g.pen.foreGroundColor;
          box.left + inset -> box.left;
          box.right - inset -> box.right;
          (if alignment = alignLeft then
              g.alignmentLeft -> align;
           else
              g.alignmentRight -> align;
          if);
          
          (this(tableView).private.bodyStyle[],
          data[], box, align) -> g.drawCenteredText;
      if);
   #); 

-- simpleColumnPrivate: descriptor --
(#
   theAlignment: @integer;
#)

-- tableItemSetMainText: doPart --
do value.copy -> private.data[1][];

-- tableItemGetMainText: doPart --
do private.data[1].copy -> value[];

-- tableItemSetIcon: doPart --
do theIcon[] -> private.theIcon[];

-- tableItemGetIcon: doPart --
do private.theIcon[] -> theIcon[];

-- tableItemSetColumnText: doPart --
do value.copy -> private.data[theColumn.private.index][];

-- tableItemGetColumnText: doPart --
do private.data[theColumn.private.index].copy -> value[];

-- tableItemSetTextIndent: doPart --
do value -> private.theTextIndent;

-- tableItemGetTextIndent: doPart --
do private.theTextIndent -> value;

-- tableItemSetIconIndent: doPart --
do value -> private.theIconIndent;

-- tableItemGetIconIndent: doPart --
do private.theIconIndent -> value;

-- tableItemSetExpander: doPart --
do value -> private.isExpander;

-- tableItemGetExpander: doPart --
do private.isExpander -> value;


-- tableItemSelected: doPart --
do private.selected -> value;

-- tableItemOpen: doPart --
do this(tableView).private.columns.size -> private.data.new;
   defaultIconIndent -> private.theIconIndent;
   defaultTextIndent -> private.theTextIndent;
   INNER;

-- tableItemClose: doPart --
do INNER;

-- tableItemLib: attributes --

toggle:
  (#
  do not private.expanded -> private.expanded;
     (if private.expanded then
         theEventHandler.onExpand;
      else
         theEventHandler.onColapse;
     if);
     updateMainView;
  #);
-- tableItemPrivate: descriptor --
(# data: [1]^text;	
   theIcon: ^pixmap;
   selected, isExpander, expanded: @boolean;
   theIconIndent: @integer;
   theTextIndent: @integer;
   pos: ^tableItemList.theCellType;
#)

-- tableViewAppend: doPart --
do theTableItem[] 
     -> private.tableItems.append
     -> theTableItem.private.pos[];
   (if private.tableItems.size = 1 then
       theTableItem[] -> private.topItem[];
   if);
   updateMainView;

-- tableViewPrepend: doPart --
do theTableItem[] 
     -> private.tableItems.prepend
     -> theTableItem.private.pos[];
   theTableItem[] -> private.topItem[];
   updateMainView;

-- tableViewInsert: doPart --
do (theTableItem[], after.private.pos[]) 
     -> private.tableItems.insertAfter
     -> theTableItem.private.pos[];
   updateMainView;

-- tableViewScan: doPart --
do private.tableitems.scan
   (#
   do current[] -> this(scan).current[];
   #);
   
-- tableViewSelectionSet: doPart --
do (if theTableItem.selected then
       (if private.theSelection.size <> 1 then
           clear;
           theTableItem[] -> add;
       if);
    else
       clear;
       theTableItem[] -> add;
   if);

-- tableViewSelectionAdd: doPart --
do (if not theTableItem.selected then
       theTableItem[] -> private.theSelection.append;
       theTableItem.theEventHandler.onSelect;
       true -> theTableItem.private.selected;
       updateMainView;
   if);
   

-- tableViewSelectionRemove: doPart --
do (if theTableItem.selected then
       theTableItem[] -> private.theSelection.at
         -> private.theSelection.delete;
       theTableItem.theEventHandler.onDeSelect;
       false -> theTableItem.private.selected;
       updateMainView;
   if);

-- tableViewSelectionClear: doPart --
do (if NOT private.theSelection.empty then
       private.theSelection.scan
       (#
       do current.theEventHandler.onDeSelect;
          false -> current.private.selected;
       #);
       private.theSelection.clear;
       updateMainView;
   if);

-- tableViewSelectionScan: doPart --
do  private.theSelection.scan
   (#
   do current[] -> this(scan).current[];
      INNER scan;
   #);
   

-- tableViewSetTheScroll: doPart --
do (if (x <> private.xScroll) OR (y <> private.yScroll) then
       (x, y) -> (private.xScroll, private.yScroll);
       updateScrollCache;
       updateMainView;
       this(window).update;
   if);

-- tableViewGetTheScroll: doPart --
do (private.xScroll, private.yScroll) -> (x, y);

-- tableViewScroll: doPart --
do

-- tableViewMaxScroll: doPart --
do (# width, height: @integer;
   do private.mainView.size -> (width, height);
      private.columns.scan
      (#
      do maxX + current.width -> maxX;
      #);
      maxX + 50 -> maxX;
      maxX - width -> maxX;
      (if maxX < 0 then
          0 -> maxX;
      if);
      
      private.tableItems.size * (rowHeight +  rowDist) -> maxY;
      maxY - height -> maxY;
      (if maxY < 0 then
          0 -> maxY;
      if);
   #);


-- tableViewSetSortByColumn: doPart --
do theColumn[] -> private.sortColumn[];
   updateTitleView;
   sortTableView;

-- tableViewGetSortByColumn: doPart --
do private.sortColumn[] -> theColumn[];


-- tableViewOpen: doPart --
do 'Helvetica' -> private.titleStyle.name;
   10 -> private.titleStyle.size;
   'Helvetica' -> private.bodyStyle.name;
   10 -> private.bodyStyle.size;
   
   this(tableView)[] -> private.titleView.open;
   this(tableView)[] -> private.cornerView.open;
   this(tableView)[] -> private.mainView.open;
   this(tableView)[] -> private.verticalScrollbar.open;
   private.tableItems.init;
   private.columns.init;
   private.theSelection.init;
   mainColumn.open;
   mainColumn[] -> appendColumn;
   true -> border.visible;
   borderStyles.shadowIn -> border.style;
   layout;
   50 -> private.xOffset;
   INNER;
   

-- tableViewClose: doPart --
do INNER;
   private.tableItems.clear;
   private.columns.clear;
   private.titleView.close;
   private.mainView.close;

-- tableViewOnFrameChanged: doPart --
do layout;
   updateScrollBars;
   INNER;

-- tableViewLib: attributes --
titleHeight: (# exit 20 #);
scrollbarWidth: (# exit 16 #);
defaultTextIndent: (# exit 45 #);
defaultIconIndent: (# exit 25 #);

sortTableView:
  (# sorter: @sequence
       (# element:: tableItemType;
       #);
     index: @integer;
     theLess: ^column.less;
     
  do sorter.init;
     private.sortColumn.private.index -> index;
     &private.sortColumn.less[] -> theLess[];
     private.tableItems.scan
     (#
     do current[] -> sorter.append;
     #);
     sorter.sort
     (# 
        less::
          (#
          do (left[], right[]) -> theLess -> value;
          #);
     #);
     private.tableItems.clear;
     sorter.scan
     (#
     do current[] -> private.tableItems.append
          -> current.private.pos[];
     #);
     updateScrollCache;
     updateMainView;
  #);
updateScrollCache:
  (# itemNumber: @integer;
     lineHeight: @integer;
     inx: @integer;
  do rowHeight + rowDist -> lineHeight;
     (private.yScroll + lineHeight) div lineHeight -> itemNumber;
     private.yScroll - (itemNumber - 1) * lineHeight -> private.yOffset;
     search: private.tableItems.scan
       (#
       do inx + 1 -> inx;
          (if inx = itemNumber then
              current[] -> private.topItem[];
              leave search;
          if);
       #);
  #);
updateMainView:
  (#
  do (if not private.pendingUpdate then
         private.mainView.update;
         true -> private.pendingUpdate;
     if);
  #);
updateTitleView:
  (#
  do private.titleView.update;
  #);

updateScrollBars:
  (# maxX, maxY: @integer;
     x, y: @integer;
     width, height: @integer;
  do true -> private.updatingScrollbars;
     maxScroll -> (maxX, maxY);
     theScroll -> (x, y);
     maxY -> private.verticalScrollBar.maxValue;
     y -> private.verticalScrollBar.value;
     rowHeight + rowDist -> private.verticalScrollBar.scrollAmount;
     private.mainView.size -> (width, height);
     height - (rowHeight + rowDist) -> private.verticalScrollBar.pageScrollAmount;
     false -> private.updatingScrollbars;
  #);

hiliteColor:
  (# exit (0xFFFF, 52428, 26214) #);


columnList: list
  (# theCellType:: (# #);
     element:: column;
  #);
tableItemList: list
  (# theCellType:: (# #);
     element:: tableItemType;
  #);

layout:
  (# width, height: @integer;
  do size -> (width, height);
     ((2, 2), (width - scrollbarWidth, 2+titleHeight)) 
       -> private.titleView.frame;
     ((width - scrollbarWidth, 2), (width - 2, 2 + titleHeight))
       -> private.cornerView.frame;
     ((2, 2 + titleHeight), (width - scrollbarWidth - 1, height-2)) 
       -> private.mainView.frame;
     ((width - scrollbarWidth - 1, titleHeight+1), (width-1, height-1)) 
       -> private.verticalScrollbar.frame;
  #);

tableItemClick:
  (# theEvent: ^windowItem.eventHandler.mouseDown;
     theTableItem: ^tableItemType;
     bounds: ^rectangle;
     getExpanderBox:
       (# bounds: ^rectangle;
          box: @rectangle;
       enter	bounds[]
       do bounds.left + 5 -> box.left;
          bounds.top + (rowHeight - 12) div 2 -> box.top;
          (12, 12) -> box.size;
       exit box
       #);
     box: @rectangle;
  enter (theEvent[], theTableItem[], bounds[])
  do bounds[] -> getExpanderBox -> box;
     (if theEvent.localPosition -> box.containsPoint then
         theTableItem.toggle;
      else
         (if theTableItem.selected then
             (if theEvent.shiftKey then
                 theTableItem[] -> selection.remove;
             if);
          else
             (if theEvent.shiftKey then
                 theTableItem[] -> selection.add;
              else
                 theTableItem[] -> selection.set;
             if);
         if);
     if);

  #);
tableViewClick:
  (# theEvent: ^windowItem.eventHandler.mouseDown
  enter theEvent[]
  do (if not theEvent.shiftKey then
         selection.clear;
     if);
  #);
columnClick:
  (# theEvent: ^windowItem.eventHandler.mouseDown;
     theColumn: ^column;
  enter (theEvent[], theColumn[])
  do theColumn[] -> sortByColumn;
  #);

rowheight: (# exit 18 #);
rowdist: (# exit 1 #);


-- tableViewPrivate: descriptor --
(# topItem: ^tableItemType;
   xScroll, yScroll: @integer;
   xOffset, yOffset: @integer;
   
   pendingUpdate: @boolean;
   updatingScrollbars: @boolean;
   columns: @columnList;
   tableItems: @tableItemList;
   titleStyle, bodyStyle: @textStyle;
   
   sortColumn: ^column;
   theSelection: @tableItemList;
   
   titleView: @windowItem
     (# eventHandler::
          (# onRefresh::
               (#
               do graphics
                  (# r: @rectangle;
                     width, height: @integer;
                  do -xOffset -> r.left;
                     0 -> r.top;
                     titleHeight -> r.bottom;
                     
                     columns.scan
                     (#
                     do r.left + current.width -> r.right; 
                        (this(graphics)[], r[]) 
                          -> current.theEventHandler.onDrawTitle;
                        r.right -> r.left;
                     #);
                     size -> (width, height);
                     (if r.left < width then
                         width -> r.right;
                         (r, bevelSmallNormal) -> drawBevel;
                     if);
                  #);
               #);
             onMouseDown::
               (# x, y: @integer;
                  left: @integer;
                  right: @integer;
                  theColumn: ^column;
               do localPosition -> (x, y);
                  -xOffset -> left;
                  search: columns.scan
                    (#
                    do left + current.width -> right;
                       (if (x >= left) and (x < right) then
                           current[] -> theColumn[];
                           leave search;
                       if);
                       right -> left;
                    #);
                  (if theColumn[] <> NONE then
                      (this(onMouseDown)[], theColumn[]) -> columnClick;
                  if);
               #);
          #);
     #);
   mainView: @windowItem
     (# eventHandler::
          (# onRefresh::
               (#
               do graphics
                  (# box: @rectangle;
                     width, height: @integer;
                     str: ^text;
                     sortBox: @integer;
                  do size -> (width, height);
                     
                     (if sortColumn[] <> NONE then
                         -xOffset -> box.left;
                         search: columns.scan
                           (#
                           do (if current[] = sortColumn[] then
                                  box.left + sortColumn.width -> box.Right;
                                  leave search;
                               else
                                  box.left + current.width -> box.left;
                              if);
                           #);
                         0 -> box.top;
                         height -> box.bottom;
                         gray3 -> pen.foregroundColor;
                         box -> fillRect;
                     if);
                     
                     -yOffset -> box.top;
                     (if topItem[] <> NONE then
                         updating: topItem.private.pos[] -> tableitems.scanFrom
                         (# item: ^tableItemType;
                            hiliteBox: @rectangle;
                         do (if box.top < height then
                                -xOffset -> box.left;
                                box.top + rowHeight -> box.bottom;
                                current[] -> item[];
                                box -> hiliteBox;
                                -xOffset -> hiliteBox.left;
                                width -> hiliteBox.right;
                                (if current.selected then
                                    hiliteColor -> pen.foreGroundColor;
                                    hiliteBox -> fillRect;
                                if);
                                columns.scan
                                (#
                                do box.left + current.width -> box.right;
                                   item.private.data[current.private.index][] -> str[];
                                   (this(graphics)[], box[], item[], str[]) 
                                     -> current.theEventHandler.onDrawItem;
                                   box.right -> box.left;
                                #);
                                gray1 -> pen.foreGroundColor;
                                (0, box.bottom) -> moveTo;
                                (width, box.bottom) -> drawTo;
                                box.bottom + 1 -> box.top;
                             else
                                leave updating;
                            if);
                         #);
                     if);
                  #);
                  false -> pendingUpdate;
               #);
             onMouseDown::
               (# r: @rectangle;
                  x, y: @integer;
                  item: ^tableItemType;
                  width, height: @integer;
               do - yOffset -> r.top;
                  localPosition -> (x, y);
                  search: topItem.private.pos[] -> tableitems.scanFrom
                  (# 
                  do 0 -> r.left;
                     r.top + rowHeight -> r.bottom;
                     (if (y >= r.top) and (y < r.bottom) then
                         current[] -> item[];
                         leave search;
                     if);
                     r.bottom + 1 -> r.top;
                  #);
                  (if item[] <> NONE then
                      size -> (width, height);
                      -xOffset ->	r.left;
                      r.left + width -> r.right;
                      (this(onMouseDown)[], item[], r[]) -> tableItemClick;
                   else
                      this(onMouseDown)[] -> tableViewClick;
                  if);
               #);
          #);
     #);
   verticalScrollBar: @scrollbar
     (# vertical:: (# do true -> value #);
        eventHandler::
          (# onValueChanged::
               (# x, y: @integer;
               do (if NOT updatingScrollbars then
                      theScroll -> (x, y);
                      (x, value) -> theScroll;
                  if);
               #);
          #);
     #);
   cornerView: @windowItem
     (# eventHandler::
          (# onRefresh::
               (#
               do graphics
                  (#
                  do (((0, 0), size), bevelSmallNormal) -> drawBevel;
                  #);
               #);
          #);
     #);
#)

