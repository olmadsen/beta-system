ORIGIN '../draganddrop';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds'
        '~beta/guienv/v1.6/graphics'
        '~beta/sysutils/v1.6/objinterface';
-- windowItemLib: Attributes --
inside: booleanValue
  (# x,y: @integer; r: @rectangle; 
  enter (x,y)
  do frame->r; (x,y)->r.containsPoint->value; 
  #);
findReciever:
  (# x,y: @integer; theReciever: ^reciever; dragee: ^object; 
  enter (x,y,dragee[])
  do (contents,x,y,dragee[])->findRecieverIn->theReciever[]
  exit theReciever[]
  #);
findRecieverIn:
  (#
     x,y: @integer;
     aCanvas: ^canvas;
     theReciever: ^reciever;
     asReciever: ^reciever;
     dragee: ^object;
     correct: @boolean;
     
  enter (aCanvas[],x,y,dragee[])
  do
     search: aCanvas.scan
       (# left,top: @integer; 
       do
          (if current## <= canvas## then
              (if (x,y)->current.inside then
                  current.position->(left,top);
                  (current[],x-left,y-top,dragee[])->findRecieverIn
                    ->theReciever[];
                  (if theReciever[] <> none then leave search;  if);
                  
              if);
              
          if);
          
       #);
     (if theReciever[] = none then
         (if aCanvas## <= reciever## then
             aCanvas[]->asReciever[];
             (if dragee## <= asReciever.drageeType## then
                 (if dragee[]->asReciever.accept then
                     asReciever[]->theReciever[]; 
                 if);
                 
             if);
             
         if);
         
     if);
     
  exit theReciever[]
  #);
  

-- dragAndDropBody: DoPart --
do
     (#
        globalBounds: @rectangle;
        currentReciever: ^reciever;
        dragee: ^object;
        adjustToGrid:
          (# x,y: @integer; 
          enter (x,y)
          do
             x-oriX->x;
             y-oriY->y;
             (if gridSize <> 0 then
                 ((x+(gridSize div 2)) div gridSize)*gridSize->x;
                 ((y+(gridSize div 2)) div gridSize)*gridSize->y
             if);
             x+oriX->x;
             y+oriY->y
          exit (x,y)
          #);
        oriX,oriY: @integer;
        
     do
        gridStart->(oriX,oriY);
        (if bounds[] = none then
            &rectangle[]->bounds[]; size->bounds.bottomRight; 
        if);
        (if proxy[] = none then
            THIS(windowItem)[]->dragee[]; 
         else
            proxy[]->dragee[]; 
        if);
        (bounds.topLeft,THIS(windowItem)[],contents)->translate
          ->globalBounds.topLeft;
        (bounds.bottomRight,THIS(windowItem)[],contents)->translate
          ->globalBounds.bottomRight;
        (contents).graphics
          (# overrideChildren::  (#  do true->value #); 
          do
             (contents).trackMouse
               (#
                  actualBounds: @rectangle;
                  mousePress:: 
                    (# 
                    do
                       transferModes.xorBlend->pen.mode;
                       globalBounds->drawRect;
                       globalBounds->actualBounds;
                       
                    #);
                  mouseMove:: 
                    (# newReciever: ^reciever; width,height: @integer; 
                    do
                       (curPt.h,curPt.v,dragee[])->findReciever->newReciever[];
                       (if newReciever[] <> currentReciever[] then
                           (if currentReciever[] <> none then
                               currentReciever.lowlite; 
                           if);
                           (if newReciever[] <> none then
                               newReciever.hilite; 
                           if);
                           newReciever[]->currentReciever[];
                           
                       if);
                       actualBounds->drawRect;
                       (h,v)->globalBounds.offset;
                       globalBounds.topLeft->adjustToGrid->actualBounds.topLeft;
                       globalBounds.size->actualBounds.size;
                       actualBounds->drawRect;
                       
                    #);
                  mouseRelease:: 
                    (# 
                    do
                       actualBounds->drawRect;
                       actualBounds->globalBounds;
                       (if currentReciever[] <> none then
                           currentReciever.lowlite;
                           (globalBounds.topLeft,contents,currentReciever[])
                             ->translate->globalBounds.topLeft;
                           (globalBounds.bottomRight,contents,currentReciever[])
                             ->translate->globalBounds.bottomRight;
                           (globalBounds[],dragee[])->currentReciever.recieve;
                           
                       if);
                       
                    #);
                  
               #);
             
          #);
        
     #);
     

