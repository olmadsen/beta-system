ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/guienv/private/datastructures/sequence'
        '~beta/containers/sets';
BODY 'private/atombody';

LIB_DEF 'frigg_atom' '../../lib'

-- lib: Attributes --
textType: (#  exit 1 #);
boolType: (#  exit 2 #);
intType: (#  exit 3 #);
listType: (#  exit 4 #);
tableType: (#  exit 5 #);
atom:
  (#
     <<SLOT atomLib:Attributes>>;
     type:< integerValue;
     equal:<
       (# other: ^atom; isEqual: @boolean; 
       enter other[]
       <<SLOT atomEqual:DoPart>>
       exit isEqual
       #);
     asTextAtom:<
       (#
          value: ^textAtom;
          
       do INNER ; 
       exit value[]
       #);
     asBoolAtom:<
       (#
          value: ^boolAtom;
          
       do INNER ; 
       exit value[]
       #);
     asIntAtom:<
       (#
          value: ^intAtom; 
       do INNER ; 
       exit value[]
       #);
     asListAtom:<
       (#
          value: ^listAtom;
          
       do INNER ; 
       exit value[]
       #);
     asTableAtom:<
       (#
          value:
            ^tableAtom;
          
       do INNER ; 
       exit value[]
       #);
     
  #);
textAtom: atom
  (#
     value: ^text;
     asTextAtom:: 
       (# 
       do
          THIS(textAtom)[]
            ->value[];
          
       #);
     type:: 
       (# 
       do textType->value
       #);
     equal:: 
       (# 
       <<SLOT textAtomEqual:DoPart>>
       #);
     
  enter value[]
  exit value[]
  #);
boolAtom: atom
  (#
     value: @boolean;
     asBoolAtom::  (#  do THIS(boolAtom)[]->value[];  #);
     type::  (#  do boolType->value #);
     equal::  (#  <<SLOT boolAtomEqual:DoPart>> #);
     
  enter value
  exit value
  #);
intAtom: atom
  (#
     value: @integer;
     asIntAtom:: 
       (#  do THIS(intAtom)[]->value[];  #);
     type::  (#  do intType->value #);
     equal:: 
       (#  <<SLOT intAtomEqual:DoPart>> #);
     
  enter value
  exit value
  #);
listAtom: atom
  (#
     storage:
       @sequence (# element:: atom;  #);
     asListAtom::  (#  do THIS(listAtom)[]->value[];  #);
     type::  (#  do listType->value #);
     equal::  (#  <<SLOT listAtomEqual:DoPart>> #);
     
  #);
tableAtom: atom
  (#
     storage: @sequence
       (#
          element::
            (# key: ^text; value: ^atom;  #);
          
       #);
     define:
       (# key: ^text; value: ^atom; 
       enter (key[],value[])
       <<SLOT tableAtomDefine:DoPart>>
       #);
     lookup:
       (# key: ^text; value: ^atom; 
       enter key[]
       <<SLOT tableAtomLookup:DoPart>>
       exit value[]
       #);
     delete:
       (# key: ^text; 
       enter key[]
       <<SLOT tableAtomDelete:DoPart>>
       #);
     asTableAtom::  (#  do THIS(tableAtom)[]->value[];  #);
     type::  (#  do tableType->value #);
     equal::  (#  <<SLOT tableAtomEqual:DoPart>> #);
     
  #);
atomParser:
  (#
     <<SLOT atomParserLib:Attributes>>;
     theStream:
       ^stream;
     init: (#  enter theStream[] <<SLOT atomParserInit:DoPart>> #);
     readAtom:
       (# theAtom: ^atom; 
       <<SLOT atomParserReadAtom:DoPart>>
       exit
       theAtom[]
       #);
     private: @<<SLOT atomParserPrivate:Descriptor>>;
     
  #);
atomPrinter:
  (#
     <<SLOT atomPrinterLib:Attributes>>;
     theStream: ^stream;
     init: (#  enter theStream[] <<SLOT atomPrinterInit:DoPart>> #);
     printAtom:
       (# theAtom: ^atom; 
       enter theAtom[]
       <<SLOT atomPrinterPrintAtom:DoPart>>
       #);
     private: @<<SLOT atomPrinterPrivate:Descriptor>>;
     
  #);
  

