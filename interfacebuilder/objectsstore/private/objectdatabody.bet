ORIGIN '../objectdata';
INCLUDE '~beta/containers/v1.5/hashTable';
INCLUDE '~beta/basiclib/v1.5/file';

-- lib: attributes --
quote: (# exit 39 #);
backslash: (# exit 92 #);

catchAllFile: file
  (# 
     failure:<
       (# msg: ^text;
       enter msg[]
       do inner;
       #);
     AccessError::<
       (# 
       do msg[] -> failure;
       #);
     WriteError::<
       (# 
       do msg[] -> failure;
       #);
     ReadError::<
       (# 
       do msg[] -> failure;
       #);
     EOSerror::<
       (# 
       do msg[] -> failure;
       #);
     NoSuchFileError::<
       (# 
       do msg[] -> failure;
       #);
     FileExistsError::<
       (# 
       do msg[] -> failure;
       #);
     NoSpaceError::<
       (# 
       do msg[] -> failure;
       #);
     OtherError::<
       (# 
       do msg[] -> failure;
       #);
     safeGetInt: getInt
       (# syntaxError::
            (# 
            do msg[] -> failure;
            #);
       #);
  #);



-- IBobjectDataStoreRead: doPart --
do l: (# version: @integer;
         numberOfObjects: @integer;
         type: @integer;
         theData: ^objectData;
         ignore: ^text;
         getInt: theStream.getInt  
           (# syntaxError::<
                (#
                do failure;
                   leave l;
                #);
           #);
      do theStream.getAtom -> ignore[];
         getInt -> version;
         (if version//1 then
             theStream.getAtom -> ignore[];
             getInt -> numberOfObjects;
             (for numberOfObjects repeat
                  theStream.getAtom -> ignore[];
                  theStream.getInt -> type;
                  type -> newObjectData -> theData[];
                  theStream.getAtom -> ignore[];
                  getInt  -> theData.ID;
                  (private.maxIDinUse, theData.ID) -> Max -> private.maxIDinUse;
                  theStream[] -> theData.read;
                  (if theData.ID <> -1 then
                      theData[] -> private.dataTable.insert;
                   else
                      failure;
                      leave l;
                  if);
             for);
         if);
      #);

-- IBobjectDataStoreWrite: doPart --
do L: (#
         version: (# exit 1 #);
         numberOfObjects: @integer;
         type: @integer;
      do 
         'version: ' -> theStream.putText;
         version -> theStream.putInt;
         theStream.newLine;
         theStream.newLine;
         'numberOfObjects: ' -> theStream.putText;
         private.dataTable.size -> theStream.putInt;
         theStream.newLine;
         theStream.newLine;
         
         private.dataTable.scan
         (# 
         do 
            current.type -> type;
            'type: ' -> theStream.putText;
            type -> theStream.putInt;
            theStream.newLine;
            'ID: ' -> theStream.putText;
            current.ID -> theStream.putInt;
            theStream.newLine;
            theStream[] -> current.write;
            theStream.newLine;
            
         #);
      #)

-- IBobjectDataStoreGet: doPart --
do ID -> private.dataTable.getByID -> theObjectData[];
   (if theObjectData[]//none then
       failure;
   if);

-- IBobjectDataStoreNew: doPart --
do type -> newObjectData -> theObjectData[];
   uniqueID -> theObjectData.ID;
   theObjectData[] -> private.dataTable.insert;
   
-- objectDataStoreLib: attributes --


generateObjectData:
  (# theData: ^objectData;
  do inner;
  exit theData[]
  #);
uniqueID:
  (# ID: @integer;
  do private.maxIDinUse + 1 -> ID;
     ID -> private.maxIDinUse;
  exit ID
  #);
newObjectData:
  (# type: @integer;
     theData: ^objectData;
  enter type
  do private.objectDataGenerator[type] -> theData[];
     type -> theData.type;
  exit theData[]
  #);

-- IBobjectDataStorePrivate: descriptor --
(# fileName: ^text;
   dataTable: @hashTable
     (# element::< objectData;
        hashFunction::<
          (# 
          do e.ID -> value;
          #);
        getByID:
          (# ID: @integer;
             foundElement: ^element;
          enter ID
          do l: ID -> scanIndexed
             (# 
             do (if ID//current.ID then
                    current[] -> foundElement[];
                    leave l;
                if);
             #);
          exit foundElement[]
          #);
     #);
   maxIDinUse: @integer;
   objectDataGenerator: [26] ^generateObjectData;
   initObjectDataGenerator:
     (# 
     do &generateObjectData (# do &interfaceObjectData[] -> theData[] #)[] -> objectdataGenerator[1][];
        &generateObjectData (# do &windowitemData[] -> theData[] #)[] -> objectdataGenerator[2][];
        &generateObjectData (# do &separatorData[] -> theData[] #)[] -> objectdataGenerator[3][];
        &generateObjectData (# do &canvasData[] -> theData[] #)[] -> objectdataGenerator[4][];
        &generateObjectData (# do &abstractScrollerData[] -> theData[] #)[] -> objectdataGenerator[5][];
        &generateObjectData (# do &scrollerData[] -> theData[] #)[] -> objectdataGenerator[6][];
        &generateObjectData (# do &textEditorData[] -> theData[] #)[] -> objectdataGenerator[7][];
        &generateObjectData (# do &controlData[] -> theData[] #)[] -> objectdataGenerator[8][];
        &generateObjectData (# do &buttonData[] -> theData[] #)[] -> objectdataGenerator[9][];
        &generateObjectData (# do &pushButtonData[] -> theData[] #)[] -> objectdataGenerator[10][];
        &generateObjectData (# do &iconButtonData[] -> theData[] #)[] -> objectdataGenerator[11][];
        &generateObjectData (# do &optionButtonData[] -> theData[] #)[] -> objectdataGenerator[12][];
        &generateObjectData (# do &staticTextData[] -> theData[] #)[] -> objectdataGenerator[13][];
        &generateObjectData (# do &toggleButtonData[] -> theData[] #)[] -> objectdataGenerator[14][];
        &generateObjectData (# do &radioButtonData[] -> theData[] #)[] -> objectdataGenerator[15][];
        &generateObjectData (# do &checkBoxData[] -> theData[] #)[] -> objectdataGenerator[16][];
        &generateObjectData (# do &scrollbarData[] -> theData[] #)[] -> objectdataGenerator[17][];
        &generateObjectData (# do &editTextData[] -> theData[] #)[] -> objectdataGenerator[18][];
        &generateObjectData (# do &textFieldData[] -> theData[] #)[] -> objectdataGenerator[19][];
        &generateObjectData (# do &scrollListData[] -> theData[] #)[] -> objectdataGenerator[20][];
        &generateObjectData (# do &textScrollListData[] -> theData[] #)[] -> objectdataGenerator[21][];
        &generateObjectData (# do &windowData[] -> theData[] #)[] -> objectdataGenerator[22][];
        &generateObjectData (# do &menuData[] -> theData[] #)[] -> objectdataGenerator[23][];
        &generateObjectData (# do &menubarData[] -> theData[] #)[] -> objectdataGenerator[24][];
        &generateObjectData (# do &menuitemData[] -> theData[] #)[] -> objectdataGenerator[25][];
        &generateObjectData (# do &dynamicMenuitemData[] -> theData[] #)[] -> objectdataGenerator[26][];
     #);
#)

-- IBobjectDataStoreInit: doPart --
do private.dataTable.init;
   private.initObjectDataGenerator;
   
-- windowitemDataRead: doPart --
do ignoreAtom; getPoint -> position;
   ignoreAtom; getPoint  -> size;
   ignoreAtom; getInt -> bindLeft;
   ignoreAtom; getInt -> bindRight;
   ignoreAtom; getInt -> bindTop;
   ignoreAtom; getInt -> bindBottom;
   ignoreAtom; getInt -> visible;
   ignoreAtom; getInt -> hilite;
   ignoreAtom; getInt -> enabled;
   ignoreAtom; getInt -> borderStyle;
   ignoreAtom; getInt -> borderVisible;
   inner;
   
-- windowitemDataWrite: doPart --
do 
   
   'position: ' -> putText; position -> putPoint; newLine;
   'size: ' -> putText; size -> putPoint; newLine;
   'bindLeft: ' -> putText; bindLeft -> putInt; newLine;
   'bindRight: ' -> putText; bindRight -> putInt; newLine;
   'bindTop: ' -> putText; bindTop -> putInt; newLine;
   'bindBottom: ' -> putText; bindBottom -> putInt; newLine;
   'visible: ' -> putText; visible -> putInt; newLine;
   'hilite: ' -> putText; hilite -> putInt; newLine;
   'enabled: ' -> putText; enabled -> putInt; newLine;
   'borderStyle: ' -> putText; borderStyle -> putInt; newLine;
   'borderVisible: ' -> putText; borderVisible -> putInt; newLine;
   inner;

-- separatorDataRead: doPart --
do ignoreAtom; getInt -> style;
   ignoreAtom; getInt -> vertical;
   inner;

-- separatorDataWrite: doPart --
do 'style: ' -> putText; style -> putInt; newline;
   'vertical: ' -> putText; vertical -> putInt; newline;
   inner;
   
-- buttonDataRead: doPart --
do ignoreAtom; getString -> label[];
   ignoreAtom; getTextStyle -> style[];
   inner;

-- buttonDataWrite: doPart --
do 'label: ' -> putText; label[] -> putString; newLine;
   'style: ' -> putText; style[] -> putTextStyle; newLine;
   inner;
   

-- iconButtonDataRead: doPart --
do ignoreAtom; getAtom -> theRaster[];
   ignoreAtom; getInt -> showLabel;
   inner;

-- iconButtonDataWrite: doPart --
do 'raster: ' -> putText; theRaster[] -> putText; newLine;;
   'showlabel: ' -> putText; showlabel -> putInt; newLine;
   inner;

-- toggleButtonDataRead: doPart --
do ignoreAtom; getInt -> state;
   inner;

-- toggleButtonDataWrite: doPart --
do 'state: ' -> putText; state -> putInt; newLine;
   inner;

-- scrollbarDataRead: doPart --
do ignoreAtom; getInt -> vertical;
   ignoreAtom; getInt -> scrollAmount;
   ignoreAtom; getInt -> pageScrollAmount;
   ignoreAtom; getInt -> maxValue;
   ignoreAtom; getInt -> value;
   inner;

-- scrollbarDataWrite: doPart --
do 'vertical: ' -> putText; vertical -> putInt; newLine;
   'scrollAmount: ' -> putText; scrollAmount -> putInt; newLine;
   'pageScrollAmount: ' -> putText; pageScrollAmount -> putInt; newLine;
   'maxValue: ' -> putText; maxValue -> putInt; newLine;
   'value: ' -> putText; value -> putInt; newLine;
   inner;

-- editTextDataRead: doPart --
do ignoreAtom; getTextStyle -> style[];
   inner;

-- editTextDataWrite: doPart --
do 'style: ' -> putText; style[] -> putTextStyle; newLine;
   inner;

-- textFieldDataRead: doPart --
do ignoreAtom; getTextStyle -> defaultStyle[];
   ignoreAtom; getInt -> leftMargin;
   ignoreAtom; getInt -> rightMargin;
   inner;

-- textFieldDataWrite: doPart --
do 'defaultStyle: ' -> putText; defaultStyle[] -> putTextStyle; newLine;
   'leftMargin: ' -> putText; leftMargin -> putInt; newLine;
   'rightMargin: ' -> putText; rightMargin -> putInt; newLine;
   inner;
   
-- scrollListDataRead: doPart --
do ignoreAtom; getInt -> numberOfItems;
   inner;

-- scrollListDataWrite: doPart --
do 'numberOfItems: ' -> putText; numberOfItems -> putInt; newLine;
   inner;

-- textScrollListDataRead: doPart --
do ignoreAtom; getTextStyle -> style[];
   inner;
   
-- textScrollListDataWrite: doPart --
do 'style: ' -> putText; style[] -> putTextStyle; newLine;
   inner;

-- windowDataRead: doPart --
do ignoreAtom; getPoint -> position;
   ignoreAtom; getPoint -> size;
   ignoreAtom; getInt -> floating;
   ignoreAtom; getAtom -> title[];
   ignoreAtom; getInt -> visible;
   ignoreAtom; getPoint -> maxSize;
   ignoreAtom; getPoint -> minSize;
   inner;
   
-- windowDataWrite: doPart --
do 'position: ' -> putText; position -> putPoint; newLine;
   'size: ' -> putText; size -> putPoint; newLine;
   'floating: ' -> putText; floating -> putInt; newLine;
   'title: ' -> putText; title[] -> putText; newLine;
   'visible: ' -> putText; visible -> putInt; newLine;
   'maxSize: ' -> putText; maxSize -> putPoint; newLine;
   'minSize: ' -> putText; minSize -> putPoint; newLine;

-- menuDataRead: doPart --
do inner;

-- menuDataWrite: doPart --
do inner;

-- menuitemDataRead: doPart --
do inner;

-- menuitemDataWrite: doPart --
do inner;
   
   
-- interfaceObjectDataGetString: doPart --
do getting:
     (# ch: @integer;
        next: @
          (# 
          do theStream.get -> ch;
          #);
     do &text[] -> string[];
        theStream.getNonBlank -> ch;
        (if ch = quote then
            next;
            l: (if ch
                //quote then
                   leave l;
                //backslash then
                   next;
                   (if ch
                    //quote then
                       quote -> string.put;
                       next;
                    else
                       backslash -> string.put;
                       (* No next here *)
                   if);
                   restart l;
                else 
                   ch -> string.put;
                   next;
                   restart l;
               if);
         else
            failure;
            leave getting;
        if);
     #);
   

-- interfaceObjectDataPutString: doPart --
do quote -> theStream.put;
   string.scanAll
   (# 
   do (if ch = quote then
          backslash -> theStream.put;
      if);
      ch -> theStream.put;
   #);
   quote -> theStream.put;


-- objectDataStoreReadFile: doPart --
do l: (# theFile: @catchAllFile
           (# 
              failure::
                (# 
                do leave l;
                #);
           #);
      do fileName[] -> theFile.name;
         (if theFile.entry.exists then
             theFile.openRead;
             theFile[] -> read;
             theFile.close;
         if);
         fileName.copy -> private.fileName[];
      #);
   
-- objectDataStoreSave: doPart --
do (if private.fileName[] <> none then
       l: (# theFile: @catchAllFile
               (# 
                  failure::
                    (# 
                    do leave l;
                    #);
               #);
          do private.fileName[] -> theFile.name;
             theFile.openWrite;
             theFile[] -> write;
             theFile.close;
          #);
   if);
             
