ORIGIN 'fragedit'
[[
-- INCLUDE '~beta/guienv/v1.3/stddialogs'
-- INCLUDE '~beta/guienv/v1.3/controls'
-- INCLUDE '~beta/guienv/v1.3/fields'
-- Include '~beta/guienv/v1.3/scrolllists'
-- Include '~beta/guienv/v1.3/styledtext'
-- Include 'propertyparser'
-- INCLUDE '~beta/basiclib/v1.4/regexp'

--FragmentEditorOpen: Descriptor --
(#
do
   (550,500)->Size;
   Properties.open;
   Fragments.open;
   Openbutton.open;
   Revertbutton.open;
   Parsebutton.open;
   INNER open;
#)

--FragmentEditorOpenButtonCommand: Descriptor --
(#
do 
#)


--FragmentEditorOpenButtonOpen: Descriptor --
(#
do 'Open Properties'->label;
   (100,20)->size;
   (5,10)->position;
#)

--FragmentEditorRevertButtonCommand: Descriptor --
(#
do    
   (if not TargetFlag then
       Properties.prettyprint;
    else 
       Fragments.prettyprint;
   if);
#)


--FragmentEditorRevertButtonOpen: Descriptor --
(#
do 'Revert Properties'->label;
   (115,20)->size;
   (120,10)->position;
   disable;
#)

--FragmentEditorParseButtonCommand: Descriptor --
(#
do (if not TargetFlag then
       Properties.parse;
    else 
       (*Fragments.parse;*)
   if);
#)


--FragmentEditorParseButtonOpen: Descriptor --
(#
do 'Parse Properties'->label;
   (105,20)->size;
   (250,10)->position;
   disable;
#)

--FragmentEditorPropertiesOpen: Descriptor --
(# 
do 
   (3,50)->position;
   (540,170)->Size;
   INNER open;
#)

--FragmentEditorPropertiesInit: Descriptor --
(# 
do contents[]->theTextField[];
   prettyPrint;
#)

--FragmentEditorPropertiesPrettyPrint: Descriptor --
(# st: ^styledtext;
do    
   &styledtext[]->st[];
   (theFragmentGroup.prop[],st[]) -> pretty.printProperties;
   st[]->textContents;
#)

--FragmentEditorPropertiesParse: Descriptor --
(# TextToParse: ^text;
   parseOK: @boolean;
   errorText: @text;
   fg: ^MPS.fragmentGroup;
   prop: ^propertyList;
do
(*   fg.fragmentList.scan
   (# 
   do (if current.type//MPS.linkType then
          Delete current 
      if);
   #);*)
   theFragmentGroup[] -> fg[];
   TextContents -> TextToParse[];
   TextToParse.reset;
   &propertyList[] -> prop[];
   prop.init;
   parsing: (TextToParse[], screen[],prop[]) -> MPS.parseProperty
   (#
      parseErrors::<
        (# 
        do leave parsing;
        #);
   #) -> parseOK;
   (if parseOK then
       prop[] -> theFragmentGroup.prop[];
       false->Changed;
       Properties.prettyprint;
       ' parse ok \n'->putline;
    else
       ' parse not ok \n'->putline;
   if);
   
#)

--FragmentEditorPropertiescTeHonMouseDown: Descriptor --
(# do 
   'Open Properties'->OpenButton.label;
   'Revert Properties'->RevertButton.label;
   'Parse Properties'->ParseButton.label;
   Changed->State;
   0->TargetFlag;
#) 

--FragmentEditorPropertiescTeHonTextChanged: Descriptor --
(# do 
   count + 1 ->count;
   'text changed ' -> putText;
   count -> putInt;
   newLine;
   (if (count > 1) then 
       true->Changed->State;
   if);
#) 

--FragmentEditorFragmentsOpen: Descriptor --
(# st: ^styledtext;
do 
   (3,250)->position;
   (540,270)->size;
   Private.FragmentField.open;
   Private.NameField.open;
   Private.TypeOptionButton.open;
   Private.FragmentField.init;
   (*&styledtext[]->st[];*)
   (*st[]->contents.contents;*)
   INNER open;
#)

--FragmentEditorFragmentsPrivate: Descriptor --
(#
   FragmentField: @TextScrolllist
     (# 
        count: @integer;
        changed: @boolean;
        eventHandler::<
          (# onMouseDown::<
               (#
               do
                  'on mouse down '->putline;
               #);
             onKeyDown::<
               (#
               do
                  'on Key  down '->putline;
               #);
          #);             
        Open::<
          (# do
             (0,0)->position;
             (540,170)->Size;
             SaveList.init;
             true->singleSelection;
          #);
        Init:
          (# numberofLines: @integer;
             st: ^styledtext;
          do    
             &styledtext[]->st[];
             0->numberofLines;
             theFragmentGroup.fragmentlist.scan(#
                                                  theFragmentForm: ^MPS.fragmentForm;
                                               do
                                                  (if current.type//MPS.formType then
                                                      screen[] -> current.open -> theFragmentForm[];
                                                      (if theFragmentForm.category 
                                                       // betaGram.DescriptorForm then
                                                          numberofLines+1->numberofLines;
                                                       // betagram.AttributesForm then
                                                          numberofLines+1->numberofLines;
                                                       // betagram.doPart then
                                                          numberofLines+1->numberofLines;
                                                      if);
                                                  if);
                                               #);
             numberofLines->append;
             numberofLines->putint;
             0->numberofLines;
             theFragmentGroup.fragmentlist.scan(# theFragmentForm: ^MPS.fragmentForm;
                                               do current.type->putint;
                                                  current.name[]->putline;
                                                  (if current.type//MPS.formType then
                                                      screen[] -> current.open -> theFragmentForm[];
                                                      (if theFragmentForm.category 
                                                       // betaGram.DescriptorForm then
                                                          'Descriptor'->putline;
                                                          current.name[]->st.append;
                                                          ': Descriptor'->st.append;
                                                          (*'\n'->st.append;*)
                                                          numberofLines+1->numberofLines;
                                                          (numberofLines,st[])->settext;
                                                          st[]->SaveList.append;
                                                       // betagram.AttributesForm then
                                                          'Attributes'->putline;
                                                          current.name[]->st.append;
                                                          ': Attributes'->st.append;
                                                          numberofLines+1->numberofLines;
                                                          (numberofLines,st[])->settext;
                                                          (*'\n'->st.append;*)
                                                          st[]->SaveList.append;
                                                       // betagram.doPart then
                                                          'DoPart'->putline;
                                                          current.name[]->st.append;
                                                          ': DoPart'->st.append;
                                                          numberofLines+1->numberofLines;
                                                          (numberofLines,st[])->settext;
                                                          (*'\n'->st.append;*)
                                                          st[]->SaveList.append;
                                                      if);
                                                  if);
                                               #);
          (*   st[]->contents.contents;
             contents[]->theTextField[];
             &styledtext[]->SaveContents[];
           st[]->SaveContents[];*)
          #);
        
     #);
   SaveList: @list
     (# element::< styledtext #);
   NameField: @TextField
     (#
        Open::<
          (# do
             (0,200)->position;
             (200,20)->Size;
          #);
     #);
   TypeMenu: @menu
     (# attributeType, doPartType, descriptorType: @MenuItem;
        open::<
          (#
          do (200,20)->size;
             attributeType.open;
             'Attributes'->attributeType.name;
             doPartType.open;
             'DoPart'->doPartType.name;
             descriptorType.open;
             'Descriptor'->descriptorType.name;
             descriptorType[]->append;
             attributeType[]->append;
             doPartType[]->append;
          #);
     #);
   TypeoptionButton: @OptionButton
     (#
        open::<
          (#
          do TypeMenu.open;
             (300,200)->position;
             (280,30)->Size;
             TypeMenu[]->popupMenu;
             ':'->label;
          #);
     #);
   
   
#)





--FragmentEditorFragmentsPrettyPrint: Descriptor --
(# st: ^styledtext;
do    
   Private.SaveList.scan 
(*   &styledtext[]->st[];
   SaveContents[]->st[];
   st[]->textContents;*)
#)
(*
--FragmentEditorFragmentsParse: Descriptor --
(# TextToParse: ^text;
   parseOK: @boolean;
   line: ^text;
   regexpr:^text;
do    
   TextContents -> TextToParse[];
   TextToParse.reset;
   true->parseOK;
   '[a-zA-z][a-zA-Z0-9_]*[ \t]*:[ \t]*\\(Descriptor\\|Attributes\\|DoPart\\)'->regexpr[];
   *)
   (*   MPS: ^astInterface;
    fg: ^MPS.fragmentGroup;
    ff: ^MPS.fragmentForm;
    betaGram: ^MPS.beta;
    do createMPS -> MPS[];
    MPS.grammarTable.beta[] -> betaGram[];
    
       //'create' -> command.equalNCS then
          getAtom -> what[];
          getAtom -> name[];
         
              betaGram[] -> MPS.newFragmentForm -> ff[];
              (if ff[]<>none then
                  name[] -> ff.name;
                  ff[] -> fg.fragmentList.addFragment;
                  ff.name -> putLine;
                  (ff[],'GUIenv') -> betaGram.newDescriptorForm -> ff.root[];
              if);
          if);
   *)
   (*
   L:
     (# 
     do (if (TextToParse.eos) then
            leave L;
         else
            TextToParse.getline->line[];
            line[]->putline;
            (if line.length // 0 then restart L; if);
            0->line.pos;
            regexpr[] ->line.regexp_match
            (# noMatch::< (#do '\t no match'->putline; 
                             false->parseOK #)
            #);
            restart L;
        if)
     #);
   
   TextToParse.getline->line[];
   line[]->putline;
   (if parseOK then
       ' parse ok \n'->putline;
    else
       ' parse not ok \n'->putline;
   if);
#)



--FragmentEditorFragmentscTeHonMouseDown : Descriptor --
(# do 
   'Open Fragments'->OpenButton.label;
   'Revert Fragments'->RevertButton.label;
   'Parse Fragments'->ParseButton.label;
   Changed->State;
   1->TargetFlag;
   selection.start->putint;
   selection.end->putint;
   
#) 


--FragmentEditorFragmentscTeHonTextChanged: Descriptor --
(# do 
   count + 1 ->count;
   'text changed ' -> putText;
   count -> putInt;
   newLine;
   (if (count > 1) then 
       true->Changed->State;
   if);
#) 
*)
--]]












