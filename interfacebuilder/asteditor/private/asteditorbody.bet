ORIGIN '../asteditor';
INCLUDE '~beta/guienv/v1.3.1/fields';
INCLUDE 'parsing';
INCLUDE '~beta/interfacebuilder/v1.0/mpsstuff/mpsutils';

-- astEditorLib: attributes --

textContents:
  (# t: ^styledText;
  enter (#
        enter t[]
        do false -> dirty;
           true -> private.settingContents;
           t[] -> private.theTextField.contents;
           false -> private.settingContents;
        #)
  exit (#
       do private.theTextField.contents -> t[];
       exit t[]
       #)
  #);

prettyPrint:
  (# t: @styledText;
  do (astControl.node[],t[]) -> pretty.printNode;
     t[] -> textContents;
  #);
closeEditor:
  (# 
  do(if theEventHandler.onAboutToClose then
        this(asteditor).close;
    if);
     
  #);

-- IBastEditorInit: doPart --
do open;
   node[] -> astControl.init;
   prettyPrint;
  
-- IBastEditorOpen: doPart --
do private.open;
   

-- IBastEditorPrivate: descriptor --
(# dirtyFlag: @boolean;
   obsoleteFlag: @boolean;
   settingContents: @boolean;
   open:
     (# server: ^astEditorServer;
     do getAstEditorServer -> server[];
        this(astEditor)[] -> server.insert;
        closeButton.open;
        (5,5) -> closeButton.position;
        revertButton.open;
        (70,5) -> revertButton.position;
        parseButton.open;
        (135,5) -> parseButton.position;
        theTextEditor.open;
        theTextEditor.contents[] -> theTextField[];
     #);
   theTextField: ^textField;
   theTextEditor: @textEditor
     (# count: @integer;
        contentsType::<
          (# 
             eventHandler::<
               (# onBeforeChange::<
                    (# 
                    do not readOnly or settingContents  -> allow;
                    #);
                  onTextChanged::<
                    (# 
                    do (if not settingContents then
                           true -> dirty;
                       if);
                    #);
               #);
          #);
        open::<
          (# width, height: @integer;
          do this(astEditor).size -> (width,height);
             ((5, 30), (width - 5, height - 5)) -> frame;
             true -> bindBottom -> bindRight;
          #);
     #);
   button: pushButton
     (# 
        command:< Object;
        eventHandler::<
          (#  onMouseUp::<
               (# 
               do command;
               #);
          #);
        open::<
          (# 
          do (60,20) -> size;
             inner;
          #);
     #);
   parseButton: @button
     (# command::<
          (# 
          do (if not obsoleteFlag then 
                 parse;
             if);
          #);
        open::<
          (# 
          do 'Parse' -> label;
             disable;
          #);
     #);
   closeButton: @button
     (# command::<
          (# 
          do closeEditor;
          #);
        open::<
          (# 
          do 'Close' -> label;
          #);
     #);
   revertButton: @button
     (# command::<
          (#
          do prettyPrint;
          #);
        open::<
          (# 
          do 'Revert' -> label;
             disable;
          #);
     #);
#)

-- AstEditorAstControlChanged: doPart --
do (if not dirty then
       prettyPrint
   if);
-- AstEditorAstControlReplaced: doPart --
do (if not dirty then
       prettyPrint;
       
   if);

-- EditorEnvAstEditorClose: doPart --
do inner;
   (if not private.obsoleteFlag then 
       astControl.release;
   if);
   (# server: ^astEditorServer;
   do
      getAstEditorServer -> server[];
      this(astEditor)[] -> server.delete;
   #);
   
-- EditorEnvAstEditorEnterDirty: doPart --
do (if value<>private.dirtyFlag then
       value -> private.dirtyFlag;
       (if private.dirtyFlag then
           private.parseButton.enable;
           private.revertButton.enable;
        else
           private.parseButton.disable;
           private.revertButton.disable;
       if);
   if);
   
-- EditorEnvAstEditorExitDirty: doPart --
do private.dirtyFlag -> value;
   
-- EditorEnvAstEditorParse: doPart --
   
do (# textToParse: ^text;
      synCatNo: @integer;
      astToReplace: ^MPS.AST;
      father: ^MPS.expanded;
      sonNo: @integer;
      
      frag: ^MPS.fragmentForm;
      root: ^MPS.AST;
      
      newAST: ^MPS.AST;
      
      parseOK, fatal: @boolean;
      errorText: @text;
      oldErrorReporter: ^MPS.errorReporter;
   do MPS.theErrorReporter[] -> oldErrorReporter[];
      &MPS.interactiveErrorReporter[] -> MPS.theErrorReporter[];
      astControl.prepareUpdate;
      
      astControl.node[] -> astToReplace[];
      astToReplace[] -> parsingSynCatNo -> synCatNo;
      astToReplace.father -> father[];
      (if father[] <> none then
          astToReplace.sonNo -> sonNo;
      if);
      astToReplace.frag[] -> frag[];
      frag.root[] -> root[];
      textContents -> textToParse[];
      textToParse.reset;
      
      (synCatNo,textToParse[],Screen[],frag[]) -> betagram.parser.doParse
      (#
         fatalParseError::<
           (#
           do
              'Parse errors: ' -> errorText.putText;
              msg[] -> errorText.putLine;
              true -> fatal;
              true -> continue;
           #);
      #) -> parseOK;
      
      (if parseOK then
          (* Now the parser has placed the new AST in the root of frag *)
          frag.root[] -> newAST[];
          (if father[]<>None then
              (sonNo,newAST[]) -> father.put;
              root[] -> frag.root[]; (* Reestablish old root *)
           else
              (* Do nothing since newAST is already root *)
          if);
          newAST[] -> astControl.replace;
          prettyPrint;
       else
          astControl.nothing;
          (if not fatal then
              textToParse.Reset;
              (textToParse[],errorText[]) -> betagram.parser.errorReport;
              
          if);
          root[] -> frag.root[];
          errorText[] -> showParseErrors;
      if);
      parseOK -> OK;
      oldErrorReporter[] -> MPS.theErrorReporter[];
   #)
   
-- AstEditorAstControlDeleted: doPart --
do obsolete;
   
--  AstEditorAstControlAncestorReplaced: doPart --
do obsolete;
   
-- AstEditorObsolete: doPart --
do true -> private.obsoleteFlag;
   private.parseButton.disable;
   private.revertButton.disable;
   true -> readOnly;
   'Deleted' -> title;
   
-- AstEditorEventHandlerOnBoutToClose: doPart --
do (if private.obsoleteFlag then
       true -> okToClose;
    else
       inner;
   if);

-- astEditorServerInit: doPart --
do private.editors.init;
   
-- astEditorServerInsert: doPart --
do editor[] -> private.editors.append;

-- astEditorServerDelete: doPart --
do editor[] -> private.editors.at -> private.editors.delete;

-- astEditorServerFind: doPart --
do search:
     private.editors.iterate
     (# 
     do (if node[] -> current.elm.astControl.node.equal then
            current.elm[] -> editor[];
            leave search;
        if);
     #);
   
-- astEditorServerPrivate: descriptor --
(# editors: @list
     (# element:: astEditor;
     #);
#)

