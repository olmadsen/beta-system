ORIGIN '../asteditor';
INCLUDE '~beta/guienv/v1.4/fields';
INCLUDE 'parsing';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '~beta/guienv/v1.4/utils/timer';

-- astEditorLib: attributes --

textContents:
  (# t: ^styledText;
  enter (#
        enter t[]
        do false -> dirty;
           true -> private.settingContents;
           t[] -> private.theTextField.contents;
           false -> private.settingContents;
        #)
  exit (#
       do private.theTextField.contents -> t[];
       exit t[]
       #)
  #);
postPrettyPrint:
  (# theTimer: @timer
       (# action::
            (# 
            do (if this(asteditor).private.doprettyPrint then
                   prettyPrint;
                   false -> this(asteditor).private.doPrettyPrint;
                   pause;
               if);
            #);
       #);
  do (if not private.doPrettyPrint then
         1 -> theTimer.activate;
         true -> private.doPrettyPrint;
     if);
  #);
  
prettyPrint:
  (# t: @styledText;
  do (node[],t[]) -> pretty.printNode;
     t[] -> textContents;
  #);
closeEditor:
  (# 
  do(if theEventHandler.onAboutToClose then
        this(asteditor).close;
    if);
     
  #);

-- IBastEditorInit: doPart --
do open;
   prettyPrint;
   node.frag[] -> private.fragHandler.frag[];
   private.fragHandler[] -> theFragServer.subscribe;
  
-- IBastEditorOpen: doPart --
do (500, 200) -> size;
   private.open;
   

-- IBastEditorPrivate: descriptor --
(# doPrettyPrint: @boolean;
   
   dirtyFlag: @boolean;
   obsoleteFlag: @boolean;
   settingContents: @boolean;
   fragHandler: @fragmentHandler
     (# isAncestorOrEqual: booleanValue
          (# ancestor, self: ^astInterface.AST;
          enter (ancestor[], self[])
          do (if (ancestor[], self[]) -> astEqual then
                 true -> value;
              else
                 (if (ancestor[], self[]) -> isAncestor then
                     true -> value;
                  else
                     false -> value;
                 if);
             if);
          #);
        
        astReplaced::
          (#
          do (if (oldAst[], node[]) -> astEqual then
                 newAst[] -> node[];
                 postPrettyPrint;
              else
                 (if (node[], newAst[]) -> isAncestor then
                     postPrettyPrint;
                  else
                     (if (oldAst[], node[]) -> isAncestor then
                         obsolete;
                     if)
                 if)
             if);
          #);
        listElementInserted::
          (# 
          do (if ((node[], listNode[]) -> isAncestorOrEqual) then
                 postPrettyPrint;
             if);
          #);
        handleListElementsDeleted:
          (# oldElements: ^astInterface.astList;
             listNode: ^astInterface.expanded;
          enter (listNode[], oldElements[])
          do (if (node[], listNode[]) ->  isAncestorOrEqual then
                 postPrettyPrint;
              else
                 l: oldElements.scan
                   (# 
                   do (if ((current[], node[]) -> isAncestorOrEqual) then
                          obsolete;
                          leave l;
                      if);
                   #);
             if);
          #);
        listElementsDeleted::
          (# 
          do (listNode[], oldElements[]) -> handleListElementsDeleted;
          #);
        listElementsReplaced::
          (# 
          do (listNode[], oldElements[]) -> handleListElementsDeleted;
          #);
        astReplacedSequence::
          (# doPretty: @boolean;
          do false -> doPretty;
             (if (rootOfSequence[], node[]) -> isAncestorOrEqual then
                 true -> doPretty;
              else
                 (if (node[], rootOfSequence[]) -> isAncestor then 
                     true -> doPretty;
                 if);
             if);
             (if doPretty then
                 postPrettyPrint;
             if);
          #);
     #);
   open:
     (# 
     do 
        this(astEditor)[] -> insert;
        closeButton.open;
        (5,5) -> closeButton.position;
        revertButton.open;
        (70,5) -> revertButton.position;
        parseButton.open;
        (135,5) -> parseButton.position;
        theTextEditor.open;
        theTextEditor.contents[] -> theTextField[];
        
     #);
   theTextField: ^textField;
   theTextEditor: @textEditor
     (# count: @integer;
        contentsType::<
          (# 
             eventHandler::<
               (# onBeforeChange::<
                    (# 
                    do not readOnly or settingContents  -> allow;
                    #);
                  onTextChanged::<
                    (# 
                    do (if not settingContents then
                           true -> dirty;
                       if);
                    #);
               #);
          #);
        open::<
          (# width, height: @integer;
          do this(astEditor).size -> (width,height);
             ((5, 30), (width - 5, height - 5)) -> frame;
             true -> bindBottom -> bindRight;
          #);
     #);
   button: pushButton
     (# 
        command:< Object;
        eventHandler::<
          (#  onMouseUp::<
               (# 
               do command;
               #);
          #);
        open::<
          (# 
          do (60,20) -> size;
             inner;
          #);
     #);
   parseButton: @button
     (# command::<
          (# 
          do (if not obsoleteFlag then 
                 parse;
             if);
          #);
        open::<
          (# 
          do 'Parse' -> label;
             disable;
          #);
     #);
   closeButton: @button
     (# command::<
          (# 
          do closeEditor;
          #);
        open::<
          (# 
          do 'Close' -> label;
          #);
     #);
   revertButton: @button
     (# command::<
          (#
          do prettyPrint;
          #);
        open::<
          (# 
          do 'Revert' -> label;
             disable;
          #);
     #);
#)

(* -- AstEditorAstControlChanged: doPart --
 * do (if not dirty then
 *        prettyPrint
 *    if);
 * -- AstEditorAstControlReplaced: doPart --
 * do (if not dirty then
 *        prettyPrint;
 *        
 *    if);
 * 
 *)
-- EditorEnvAstEditorClose: doPart --
do inner;
   private.fragHandler[] -> theFragServer.unsubscribe;
   this(astEditor)[] -> delete;
   
-- EditorEnvAstEditorEnterDirty: doPart --
do (if value<>private.dirtyFlag then
       value -> private.dirtyFlag;
       (if private.dirtyFlag then
           private.parseButton.enable;
           private.revertButton.enable;
        else
           private.parseButton.disable;
           private.revertButton.disable;
       if);
   if);
   
-- EditorEnvAstEditorExitDirty: doPart --
do private.dirtyFlag -> value;
   
-- EditorEnvAstEditorParse: doPart --
   
do (# textToParse: ^text;
      synCatNo: @integer;
      astToReplace: ^astInterface.AST;
      father: ^astInterface.expanded;
      sonNo: @integer;
      
      frag: ^astInterface.fragmentForm;
      root: ^astInterface.AST;
      
      newAST: ^astInterface.AST;
      
      parseOK, fatal: @boolean;
      errorText: @text;
      oldErrorReporter: ^astInterface.errorReporter;
   do MPS.theErrorReporter[] -> oldErrorReporter[];
      &MPS.interactiveErrorReporter[] -> MPS.theErrorReporter[];
      
      node[] -> astToReplace[];
      astToReplace[] -> parsingSynCatNo -> synCatNo;
      astToReplace.father -> father[];
      (if father[] <> none then
          astToReplace.sonNo -> sonNo;
      if);
      astToReplace.frag[] -> frag[];
      frag.root[] -> root[];
      textContents -> textToParse[];
      textToParse.reset;
      (synCatNo,textToParse[],Screen[],frag[]) -> frag.grammar.parser.doParse
      (#
         fatalParseError::<
           (#
           do
              'Parse errors: ' -> errorText.putText;
              msg[] -> errorText.putLine;
              true -> fatal;
              true -> continue;
           #);
      #) -> parseOK;
      
      (if parseOK then
          (* Now the parser has placed the new AST in the root of frag *)
          frag.root[] -> newAST[];
          (if father[]<>None then
              (sonNo,newAST[]) -> father.put;
              root[] -> frag.root[]; (* Reestablish old root *)
           else
              (* Do nothing *)
          if);
          (true, frag[], node[], newAst[]) -> theFragServer.notifyAstReplaced;
       else
          (if not fatal then
              textToParse.Reset;
              (textToParse[],errorText[]) -> frag.grammar.parser.errorReport;
              
          if);
          root[] -> frag.root[];
          errorText[] -> showParseErrors;
      if);
      parseOK -> OK;
      oldErrorReporter[] -> MPS.theErrorReporter[];
   #)
   
   (* -- AstEditorAstControlDeleted: doPart --
    * do obsolete;
    *    
    * --  AstEditorAstControlAncestorReplaced: doPart --
    * do obsolete;
    *)
   
-- AstEditorObsolete: doPart --
do true -> private.obsoleteFlag;
   false -> private.doPrettyPrint;
   private.parseButton.disable;
   private.revertButton.disable;
   true -> readOnly;
   'Deleted' -> title;
   
-- AstEditorEventHandlerOnBoutToClose: doPart --
do (if private.obsoleteFlag then
       true -> okToClose;
    else
       inner;
   if);

-- astEditorEnvFind: doPart --
do search:
     private.editors.iterate
     (# 
     do (if node[] -> current.elm.node.equal then
            current.elm[] -> editor[];
            leave search;
        if);
     #);
   


-- astEditorEnvInit: doPart --
do private.editors.init;
   inner;
   
-- astEditorEnvLib: attributes --

insert:
  (# editor: ^astEditor;
  enter editor[]
  do editor[] -> private.editors.append;
  #);

delete:
  (# editor: ^astEditor;
  enter editor[]
  do editor[] -> private.editors.at -> private.editors.delete;
  #);

-- astEditorEnvPrivate: descriptor --
(# 
   editors: @list
     (# element:: astEditor;
     #);
#)
