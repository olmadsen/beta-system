ORIGIN '../fragmenthandler';
INCLUDE '~beta/datastructures/v0.1/map';



-- fragmentServerSubscribe: doPart --
do (if fragHandler[] = none then
       'fragHandler' -> refNone;
    else
       (if fragHandler.frag[] = none then
           'fragHandler.frag' -> refNone;
        else
           fragHandler[] -> private.insert;
           inner;
       if);
   if);
   
-- fragmentServerUnsubscribe: doPart --
do (if fragHandler[] = none then
       'fragHandler' -> refNone;
    else
       (if fragHandler.frag[] = none then
           'fragHandler.frag' -> refNone;
        else
           fragHandler[] -> private.delete;
           inner;
       if);
   if);

-- fragmentServerNotify: doPart --
do (# theSet: ^private.fragHandlers.element;
      dummy: @fragmentHandler;
   do true -> (frag.father).changed;
      frag[] -> dummy.frag[];
      dummy[] -> private.fragHandlers.lookup -> theSet[];
      (if theSet[] <> none then
          theSet.scan
          (# 
          do current[] -> foreach;
          #);
      if);
   #);
   inner;
   
-- fragmentServerNotifyAstReplaced: doPart --
do inner;

-- fragmentServerNotifyAstReplacedSequence: doPart --
do inner;

-- fragmentServerNotifyListElementInserted: doPart --
do inner;

-- fragmentServerNotifyListElementsDeleted: doPart --
do inner;

-- fragmentServerNotifyListElementsReplaced: doPart --
do inner;

-- fragmentServerInit: doPart --
do private.fragHandlers.init;

-- fragmentServerPrivate: descriptor --
(# fragHandlers: @map
     (# key:: fragmentHandler;
        hash::
          (# doHash: @textHash;
          do theKey.frag.name -> doHash -> value;
          #);
        equal::
          (# 
          do (left.frag[] = right.frag[]) -> value;
          #);
        element:: set
          (# element:: fragmentHandler;
          #);
     #);
   insert:
     (# theSet: ^fragHandlers.element;
        fragHandler: ^fragmentHandler;
     enter fragHandler[]
     do fragHandler[] -> fragHandlers.lookup -> theSet[];
        (if theSet[] = none then
            &fragHandlers.element[] -> theSet[];
            theSet.init;
            (fragHandler[], theSet[]) -> fragHandlers.insert;
        if);
        fragHandler[] -> theSet.insert;
     #);
   delete:
     (# theSet: ^fragHandlers.element;
        fragHandler: ^fragmentHandler;
     enter fragHandler[]
     do fragHandler[] -> fragHandlers.lookup -> theSet[];
        (if theSet[] <> none then
            fragHandler[] -> theSet.delete;
        if);
     #);
#)

-- astCompare: doPart --
do (# 
   do (if (left[], right[]) -> astEqual then
          equal;
       else
          (if (right[], left[]) -> isAncestor then
              rightAncestor;
           else
              (if (left[], right[]) -> isAncestor then
                  leftAncestor;
               else
                  unRelated;
              if);
          if);
      if);
   #);
-- astEqual: doPart --
do (left.index = right.index) and (left.frag[] = right.frag[]) -> value;
   
-- isAncestor: doPart --
do false -> value;
   l: (# 
      do child.father -> child[];
         (if child[] <> none then
             (if (anc[], child[]) -> astEqual then
                 true -> value;
              else
                 restart l;
             if);
         if);
      #);
