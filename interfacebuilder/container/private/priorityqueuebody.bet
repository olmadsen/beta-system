ORIGIN '../priorityqueue';

-- priorityQueueInsert: descriptor --
(# ins: @storage.insert;
   
do (if storage.size = storage.data.range then
       storage.data.range -> storage.data.extend;
   if);
   storage.size + 1 -> storage.size;
   elm[] -> ins;
#)

-- priorityQueueMin: doPart --
do (if storage.size = 0 then
       emptyContainer;
    else
       storage.data[1][] -> elm[];
   if);
   
-- priorityQueueDeleteMin: descriptor --
(# del: @storage.deleteMin;
do (if storage.size > 0 then
       storage.data[1][] -> elm[];
       del;
   if);
#)

-- priorityQueueInit: doPart --
do 1 -> storage.data.new;
   0 -> storage.size;
   inner;

-- priorityQueueClear: doPart --
do 1 -> storage.data.new;
   0 -> storage.size;
   inner;

-- priorityQueueEmpty: doPart --
do storage.size = 0 -> value;

-- priorityQueueSize: doPart --
do storage.size -> value;

-- priorityQueueScan: doPart --
do (for inx: storage.size repeat
        storage.data[inx][] -> current[];
        inner;
   for);

-- priorityQueueHas: doPart --
do false -> value;
   l:
     (for inx: storage.size repeat
          (if elm[] = storage.data[inx][] then
              true -> value;
              leave l;
          if);
     for);

-- priorityQueueStorage: descriptor --
(# data: [1] ^element;
   size: @integer;
   
   insert:
     (# n, fatherInx: @integer;
        elm, father: ^element;
        doLess: @less;
     enter elm[]
     do (if size = 1 then
            elm[] -> data[1][];
         else
            size -> n;
            l:
              (if n > 1 then
                  data[(n div 2) -> fatherInx][] -> father[];
                  (if (elm[], father[]) -> doLess then
                      father[] -> data[n][];
                      fatherInx -> n;
                      restart l;
                   else
                      elm[] -> data[n][];
                  if);
               else
                  elm[] -> data[n][];
              if);
        if);
     #);
   deleteMin:
     (# sonInx: @integer;
        n: @integer;
        elm, son1, son2: ^element;
        doLess: @less;
     do none -> data[1][];
        data[size][] -> elm[];
        size - 1 -> size;
        (if size <> 0 then
            1 -> n;
            l: (#
               do 2 * n -> sonInx;
                  (if sonInx <= size then
                      (if (sonInx < size) and ((data[sonInx +1][], data[sonInx][]) -> doLess) then
                          sonInx + 1 -> sonInx;
                      if);
                      (if (data[sonInx][], elm[]) -> doLess then
                          data[sonInx][] -> data[n][];
                          sonInx -> n;
                          restart l;
                       else
                          elm[] -> data[n][];
                      if);
                   else
                      elm[] -> data[n][];
                  if);
               #);
        if);
     #);
#)

