ORIGIN '../doublelinkedlist';

-- listDeletePosition: doPart --
do (if pos.prev[] <> none then
       pos.next[] -> pos.prev.next[];
    else
       pos.next[] -> firstPos[];
   if);
   (if pos.next[] <> none then
       pos.prev[] -> pos.next.prev[];
    else
       pos.prev[] -> lastPos[];
   if);
   sz - 1 -> sz;
   inner;

-- listAt: doPart --
do firstPos[] -> pos[];
   l: (if pos[] <> none then
          (if pos.elm[] = elm[] then
              leave l;
           else
              pos.next[] -> pos[];
              restart l;
          if);
      if);

-- listDelete: doPart --
do elm[] -> at -> deletePosition;
   inner delete;

-- listInsert: doPart --
do inner; 

-- listScan: doPart --
do (if currentPos[] = none then
       firstPos[] -> currentPos[];
   if);
   l: (if currentPos[] <> none then
          currentPos.elm[] -> current[];
          inner;
          currentPos.next[] -> currentPos[];
          restart l;
      if);

-- listScanReverse: doPart --
do (if currentPos[] = none then
       lastPos[] -> currentPos[];
   if);
   l: (if currentPos[] <> none then
          currentPos.elm[] -> current[];
          inner;
          currentPos.prev[] -> currentPos[];
          restart l;
      if);

-- listAppend: doPart --
do &position[] -> pos[];
   elm[] -> pos.elm[];
   (if lastPos[] = none then
       pos[] -> firstPos[];
       pos[] -> lastPos[];
    else
       lastPos[] -> pos.prev[];
       pos[] -> lastPos.next[];
       pos[] -> lastPos[];
   if);
   sz + 1 -> sz;
   inner;

-- listPrepend: doPart --
do &position[] -> pos[];
   elm[] -> pos.elm[];
   (if firstPos[] = none then
       pos[] -> firstPos[];
       pos[] -> lastPos[];
    else
       firstPos[] -> pos.next[];
       pos[] -> firstPos.prev[];
       pos[] -> firstPos[];
   if);
   sz + 1 -> sz;
   inner;

-- listClear: doPart --
do inner;
   none -> lastPos[];
   none -> firstPos[];
   0 -> sz;
   

-- listInit: doPart --
do none -> lastPos[];
   none -> firstPos[];
   0 -> sz;
   inner;
   
-- listDeleteFirst: doPart --
do (if firstPos[] = none then
       emptyContainer;
    else
       (if firstPos.next[] <> none then
           firstPos[] -> firstPos.next.prev[];
           firstPos.next[] -> firstPos[];
       if);
       sz + 1 -> sz;
   if);
   
-- listDeleteLast: doPart --
do (if lastPos[] = none then
       emptyContainer;
    else
       (if lastPos.prev[] <> none then
           lastPos[] -> lastPos.prev.next[];
           lastPos.prev[] -> lastPos[];
       if);
       sz + 1 -> sz;
   if);

-- listLast: doPart --
do (if lastPos[] <> none then
       lastPos.elm[] -> elm[];
    else
       emptyContainer
   if);

-- listFirst: doPart --
do (if firstPos[] <> none then
       firstPos.elm[] -> elm[];
    else
       emptyContainer
   if);

-- listEmpty: doPart --
do sz = 0 -> value;

-- listSize: doPart --
do sz -> value;
   
-- listHas: doPart --
do l: scan
   (#
   do (if current[] = elm[] then
          true -> value;
          leave l;
      if);
   #);
   
-- listFirstPosition: doPart --
do firstPos[] -> pos[];
   
-- listLastPosition: doPart --
do lastPos[] -> pos[];

