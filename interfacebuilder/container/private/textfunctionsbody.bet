ORIGIN '../textfunctions';

-- lib: attributes --

less: (# exit -1 #);
equal: (# exit 0 #);
greater: (# exit 1 #);

textCompare:
  (# left, right: ^text;
     lgth: @integer;
     value: @integer;
     c1, c2: @integer;
     charInx: @integer;
  enter (left[], right[])
  do (if left.lgth < right.lgth then
         left.lgth -> lgth;
         less -> value;
      else
         right.lgth -> lgth;
         greater -> value;
     if);
     0 -> charInx;
     (for lgth -> TOS'%shiftRight[2]' repeat
          (left.T, charInx) -> TOS'%inxGetLong' -> c1;
          (right.T, charInx) -> TOS'%inxGetLong' -> c2;
          charInx + 4 -> charInx;
          (if c1 <> c2 then
              (if c1 < c2 then
                  less -> value;
               else
                  greater -> value;
              if);
              leave textCompare;
          if)
     for);
     (for (lgth - charInx) repeat
          charInx + 1 -> charInx;
          left.T[charInx] -> c1;
          right.T[charInx] -> c2;
          (if c1 <> c2 then
              (if c1 < c2 then
                  less -> value;
               else
                  greater -> value;
              if);
              leave textCompare;
          if)
     for);
     (if left.lgth = right.lgth then
         equal -> value;
     if);
  exit value
  #);
-- textEqualDopart: descriptor --
(# cmp: @textCompare;
do ((left[], right[]) -> cmp) = 0 -> value;
#)

-- textEqualNCSDopart: descriptor --
(# cmp: @textCompare;
do ((left[], right[]) -> cmp) = 0 -> value;
#)

-- textLessDopart: descriptor --
(# cmp: @textCompare;
do ((left[], right[]) -> cmp) = -1 -> value;
#)

-- textLessNCSDopart: descriptor --
(# cmp: @textCompare;
do ((left[], right[]) -> cmp) = -1 -> value;
#)

-- textHashDoPart: descriptor --
(# lowCase: @ascii.lowCase;
do 0 -> value;
   (for inx: t.lgth repeat 
        ((t.T[inx] -> lowCase) - 'a') + value * 26 -> value;
   for);
   (if value < 0 then
       - value -> value;
   if);
#)
