ORIGIN '../astcommunication';
INCLUDE '../../container/doublelinkedlist';

-- lib: attributes --


astServer:
  (# insert:
       (# theAstController: ^astController;
       enter theAstController[]
       do theAstController[] -> controllers.append;
       #);
     delete:
       (# theAstController: ^astController;
       enter theAstController[]
       do theAstController[] -> controllers.delete;
       #);
     init:
       (# 
       do controllers.init;
       #);
     findFamily:
       (# node: ^astInterface.AST;
          failure:< exception
            (# 
            do 'Family in use' -> msg.append;
               inner;
            #);
          theFamily: ^family;
       enter node[]
       do &family[] -> theFamily[];
          theFamily.init;
          node[] -> scanRelated
          (# member: ^familyMember;
             doSame::
               (# 
               do &same[] -> member[];
                  current[] -> member.init;
                  member[] -> theFamily.append;
               #);
             doAncestor::
               (# 
               do &ancestor[] -> member[];
                  current[] -> member.init;
                  member[] -> theFamily.append;
               #);
             doChild::
               (# 
               do &child[] -> member[];
                  current[] -> member.init;
                  member[] -> theFamily.append;
               #);
          #);
       exit theFamily[]
       #);
     
     
     scanRelated:
       (# doChild:<
            (# 
            enter current[]
            do inner;
            #);
          doAncestor:<
            (# 
            enter current[]
            do inner;
            #);
          doSame:<
            (# 
            enter current[]
            do inner;
            #);
          current: ^astController;
          node: ^astInterface.AST;
       enter node[]
       do controllers.scan
          (# ancestor: ^astInterface.AST;
             ignore: @integer;
          do 
             (if node[] -> current.node.equal then
                 current[] -> doSame;
              else
                 (if current.node.frag[] = node.frag[] then
                     current.node[] -> node.nearestCommonAncestor 
                       -> (ancestor[],ignore,ignore);
                  else
                     none -> ancestor[];
                 if);
                 (if ancestor[]<>None then
                     (if true
                      //ancestor[] -> node.equal then
                         current[] -> doChild;
                      //ancestor[] -> current.node.equal then
                         current[] -> doAncestor;
                     if);
                 if);
             if);
          #);
       #);
     controllers: @doubleLinkedList
       (# element:: astController;
          
       #);
     

     familyMember:
       (# controller: ^astController;
          init:<
            (#
            enter controller[]
            do inner;
            #);
          notifyChange:< object;
          notifyDelete:< object;
          notifyReplace:<
            (# node: ^astInterface.AST;
            enter node[]
            do inner;
            #);
       #);
     same: familyMember
       (# notifyChange::<
            (# 
            do controller.onChanged;
            #);
          notifyDelete::<
            (# 
            do none -> controller.node[];
               controller[] -> delete;
               controller.onDeleted;
            #);
          notifyReplace::<
            (# 
            do node[] -> controller.onReplaced;
            #);
       #);
     ancestor: familyMember
       (# notifyChange::<
            (# 
            do controller.onChanged;
            #);
          notifyDelete::<
            (# 
            do controller.onChanged;
            #);
          notifyReplace::<
            (# 
            do controller.onChanged;
            #);
       #);
     child: familyMember
       (# notifyChange::<
            (# 
            do (* nothing *)
            #);
          notifyDelete::<
            (# 
            do
               none -> controller.node[];
               controller[] -> delete;
               controller.onDeleted;
            #);
          notifyReplace::<
            (# 
            do none -> controller.node[];
               controller[] -> delete;
               controller.onAncestorReplaced;
            #);
       #);
     family: doubleLinkedList
       (# element:: familyMember;
          notify:
            (# exclude: ^astController;
            enter exclude[]
            do inner;
            #);
          scanExcept: scan
            (# exclude: ^astController;
            enter exclude[]
            do (if current.controller[] <> exclude[] then
                   inner;
               if);
            #);
          notifyNothing: notify 
            (#  #);
          notifyChange: notify
            (# 
            do (none, exclude[]) -> scanExcept
               (# 
               do current.notifyChange;
               #);
            #);
          notifyDelete: notify
            (# 
            do (none, exclude[]) -> scanExcept
               (# 
               do current.notifyDelete;
               #);
            #);
          notifyReplace: notify
            (# node: ^astInterface.AST;
            enter node[]
            do (none, exclude[]) -> scanExcept
               (# 
               do node[] -> current.notifyReplace;
               #);
            #);
       #);
  #);

getServer: objectPool.get
  (# type:: astServer;
     exact:: (# do true -> value #);
     init::
       (# 
       do obj.init;
       #);
  #);

-- astControllerInit: doPart --
do getServer -> private.server[];
   this(astController)[] -> private.server.insert;
   inner;

-- astControllerRelease: doPart --
do inner;
   this(astController)[] -> private.server.delete;
   none -> private.server[];
   none -> node[];
   
-- notifyPrivate: descriptor --
(# 
   theFamily: ^astServer.family;
#)

-- astControllerNotify: doPart --
do node[] -> this(astController).private.server.findFamily -> private.theFamily[];
   inner notify;


-- astControllerChange: doPart --
do inner;
   true -> node.frag.fatherR.changed;
   this(astController)[] -> private.theFamily.notifyChange;

-- astControllerDelete: doPart --
do inner;
   true -> node.frag.fatherR.changed;
   none -> node[];
   this(astController)[] -> private.theFamily.notifyDelete;
   this(astController)[] -> this(astController).private.server.delete;

-- astControllerReplace: doPart --
do inner;
   newNode[] -> node[];
   true -> node.frag.fatherR.changed;
   (this(astController)[], node[]) -> private.theFamily.notifyReplace;
   
-- astControllerEnterDirty: doPart --
do

-- astControllerExitDirty: doPart --
do

-- astControllerBeeingEdited: doPart --
do

-- astControllerPrivate: descriptor --
(# 
   server: ^astServer;
#)


-- libNotifyPrivate: descriptor --
(# theFamily: ^astServer.family;
   server: ^astServer;
#)

-- libNotify: doPart --
do getServer -> private.server[];
   node[] -> private.server.findFamily -> private.theFamily[];
   inner notify;
   
   
-- libNotifyChange: doPart --
do inner;
   true -> node.frag.fatherR.changed;
   private.theFamily.notifyChange;
   
-- libNotifyDelete: doPart --
do inner;
   true -> node.frag.fatherR.changed;
   private.theFamily.notifyDelete

   
-- libNotifyReplace: doPart --
do inner;
   newNode[] -> node[];
   true -> node.frag.fatherR.changed;
   (none, node[]) -> private.theFamily.notifyReplace;
   
   
