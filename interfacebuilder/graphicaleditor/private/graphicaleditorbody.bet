ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds'
        '~beta/sysutils/v1.6/time'
        '~beta/sysutils/v1.6/objinterface'
        '~beta/betaast/v5.2/gram'
        '~beta/betaast/v5.2/betasematt'
        '~beta/guienv/v1.6/private/datastructures/sequence'
        '~beta/containers/v1.6/list'
        '../../dialogs/editinfo'
        '../../dialogs/namedialog'
        '../../dialogs/integerfield'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '../../asteditor/asteditor'
        '~beta/guienv/v1.6/utils/guienvstuff'
        '../../guienvstuff/killtranslations'
        '../../mpsstuff/mpsutils'
        '../../dialogs/spacingdialog'
        '../../buildermenu'
        '~beta/guienv/v1.6/utils/prompts'
        '../../resourcesupport/easyinterface'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        'classinfobody'
        'editorwindowbody';
MDBODY mac 'macintosh/graphicaleditor_mac'
       ppcmac 'macintosh/graphicaleditor_mac'
       nti 'winnt/graphicaleditor_nti'
       default 'X11/graphicaleditor_X11';
-- entryExistsBody: DoPart --
do
   false->value;
   l:
     (# e: @diskEntry; 
     do
        name[]->e.path;
        e.exists (# error::  (#  do leave l;  #);  #)->value;
        
     #);
     

-- entryReadableBody: DoPart --
do
   false->value;
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.readable (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
   if);
     

-- entryWriteAbleBody: DoPart --
do
   false->value;
   l:
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.writeAble (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
    else
       true->value; 
   if);
     

-- astFileExistsBody: DoPart --
do
     (# path: ^text; 
     do
        MPS.astFileExtension->(name.copy).Append->path[];
        (if path[]->entryExists then
            true->value; 
         else
            '.bet'->(name.copy).Append->path[]; path[]->entryExists->value; 
        if);
        
     #);
     

-- astFileReadAbleBody: DoPart --
do
     (# path: ^text; 
     do
        MPS.astFileExtension->(name.copy).Append->path[];
        (if path[]->entryReadAble then
            true->value; 
         else
            '.bet'->(name.copy).Append->path[]; path[]->entryReadAble->value; 
        if);
        
     #)  

-- astFileWriteAbleBody: DoPart --
do
     (# path: ^text; 
     do
        MPS.astFileExtension->(name.copy).Append->path[];
        (if path[]->entryWriteAble then
            '.bet'->(name.copy).Append->path[]; path[]->entryWriteAble->value; 
         else
            false->value; 
        if);
        
     #);
     

-- InterfaceBuilderGraphicalEditorWindowMenubarOpen: DoPart --
do
   THIS(graphicalEditor).private.theFileMenu.open;
   THIS(graphicalEditor).private.theFileMenu[]->append;
   THIS(graphicalEditor).private.theEditMenu.open;
   THIS(graphicalEditor).private.theEditMenu[]->append;
   THIS(graphicalEditor).private.theAlignMenu.open;
   THIS(graphicalEditor).private.theAlignMenu[]->append;
     

-- windowitemEditornew: DoPart --
do
     (# inst: ^instantiator; theDoPart: ^astInterface.beta.doPart
     do
        className[]->lookup->inst[];
        false->inherited;
        10->trace (#  do 'new windowitem'->xT #);
        (if vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        newNode;
        node[]->getClassData->theClassData[];
        realCreateOpen->theDoPart[];
        node[]->owner.appendAttribute;
        (if inst[] <> none then
            (if inst.path[] <> none then
                (node.frag.father,inst.path[])->addInclude
            if)
        if);
        true->createTheWindowItem;
        applyObjectData;
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.appendChild; 
        if);
        (data[],true)->changeData;
        theDoPart[]->initDopart;
        
     #);
   INNER ;
     

-- canvasEditornew: DoPart --
do INNER ;   

-- graphicalEditorNewEditor: DoPart --
do
     (#
        node: ^astInterface.beta.attributeDecl;
        super: ^astInterface.beta.patternDecl;
        theAttributes: ^astInterface.beta.attributes;
        name: ^text;
        vertical: @boolean;
        split:
          (# name,realName: ^text; vertical: @boolean
          enter name[]
          do
             (if name.length > 9 then
                 (if '-vertical'->((name.length-8,name.length)->name.sub).equal
                  then
                     (1,name.length-9)->name.sub->realName[]; true->vertical
                  else
                     name[]->realName[]; false->vertical
                 if)
              else
                 name[]->realName[]; false->vertical
             if)
          exit (realName[],vertical)
          #);
        
     do
        (if theClassData[] = none then
            className[]->split->(className[],vertical);
            (className.copy,vertical)->makeEditor->theEditor[];
            vertical->theEditor.vertical;
            (THIS(canvasEditor)[],className.copy,none )->theEditor.new;
            selection.clear;
            theEditor.select;
            
         else
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theClassData.node[]->super[];
            super[]->betaGram.getName->className[];
            getMainAttributes->theAttributes[];
            (theAttributes[],className[])->newUniqueName->name[];
            (theAttributes.frag[],name[],className[])->betaGram.newSingularItem
              ->node[];
            (node[],super[])->setSemanticLink;
            node[]->appendAttribute;
            node[]->getClassData->theClassData[];
            (if theClassData[] <> none then
                (THIS(canvasEditor)[],node[],none ,false,theClassData[],none )
                  ->theEditor.init;
                theEditor.realCreateOpen;
                
            if);
            
        if);
        
     #);
     

-- graphicalEditorOpen: DoPart --
do
     (# 
     do
        THIS(graphicalEditorEnv).private.theFactory.scan
          (# 
          do
             (if current.grouping[] <> none then
                 (current.grouping[],current.icon[],current.name[])
                   ->THIS(editorWindow).private.paletteTabber.addPaletteItem
             if);
             
          #);
        THIS(graphicalEditor)[]->insert;
        hide;
        'Graphical Objects'->title;
        (600,500)->size;
        private.theClipBoard.init;
        selectMode->private.mode;
        private.initNames;
        
     #);
     

-- graphicalEditorClose: DoPart --
do
     (# 
     do
        INNER close;
        selection.clear;
        forgetSelectionChanged;
        private.contentsEditor.close;
        THIS(graphicalEditor)[]->delete;
        
     #);
     

-- graphicalEditorOnMouseDown: DoPart --
do selection.clear;   

-- windowitemEditorMousedown: DoPart --
do
   INNER ;
   (if skip then
       false->private.skip
    else
       (if not (readOnly or inherited) then
           INNER mouseDown;
           (if theEvent.doubleClick then
               showInfoDialog; 
            else
               (if not done then
                     (# actualMode: @integer; 
                     do
                        mode->actualMode;
                        (if theEvent.shiftKey then
                            (if private.selected then
                                deSelect; 
                             else
                                select; 
                            if);
                            
                         else
                            (if not private.selected then
                                selection.clear; select; 
                            if);
                            
                        if);
                        (if private.selected then
                            pt
                              ->theWindowItem.delay
                                (#  do theEvent[]->selection.drag;  #);
                            
                        if);
                        
                     #);
                   
               if);
               
           if);
           
       if);
       
   if);
     

-- canvasEditorMousedown: DoPart --
do
   INNER mouseDown;
   (if not skip then
       (if not theEvent.doubleClick then
           (if (owner[] = none ) or (theEvent.controlKey) then
                 (#
                    r: @rectangle;
                    width,height: @integer;
                    intersectedObjects: @windowItemEditorList;
                    
                 do
                    intersectedObjects.init;
                    (theEvent.localPosition,theEvent.localPosition)->r;
                    (r,false,false,true,true)->theWindowItem.defineRect->r;
                    children.scan
                      (# itsFrame: ^rectangle; 
                      do
                         current.frame->itsFrame[];
                         (if (r,itsFrame)->itsFrame.intersection then
                             current[]->intersectedObjects.append; 
                         if);
                         
                      #);
                    (if intersectedObjects.empty then
                        (if theEvent.shiftKey then
                            (if selected then deSelect;  else select;  if); 
                         else
                            selection.clear; select; 
                        if);
                        
                     else
                        (if theEvent.shiftKey then
                            intersectedObjects.scan
                              (# 
                              do
                                 (if current.selected then
                                     current.deSelect; 
                                  else
                                     current.select; 
                                 if);
                                 
                              #);
                            
                         else
                            selection.clear;
                            intersectedObjects.scan
                              (#  do current.select;  #);
                            
                        if);
                        
                    if);
                    true->skip;
                    
                 #);
               
           if)
       if);
       
   if);
     

-- windowItemEditorSelect: DoPart --
do
   (if not private.selected then
       (if THIS(windowItemEditor)[]->selection.selectable then
           THIS(windowItemEditor)[]->selection.append; 
        else
           system.beep; 
       if);
       
   if);
     

-- windowItemEditorDeSelect: DoPart --
do
   (if private.selected then THIS(windowItemEditor)[]->selection.delete;  if);
     

-- GraphicalEditorInit: DoPart --
do
     (#
        theClassData: ^classData;
        theEditor: ^windowItemEditor;
        theTimer: @timer
          (#
             action:: 
               (# 
               do
                  stop;
                  THIS(graphicalEditor).private.contentsEditor.fixOptionButtons
               #);
             
          #);
        privateFrag: ^astInterface.fragmentForm;
        
     do
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            INNER init;
            adjustSize;
            private.controlPoints.init;
            show;
            (if platform = X11 then 300->theTimer.start;  if);
            
         else
            close; 
        if);
        
     #);
     

-- IBwindowitemEditorapplyObjectData: DoPart --
do
     (# r: @rectangle; x,y,width,height: @integer; 
     do
        data.position->(x,y);
        data.size->(width,height);
        (x,y)->r.topLeft;
        11
          ->trace
            (# 
            do
               node[]->betaGram.getName->xT;
               '.applyObjectData'->xT;
               xN;
               'width: '->xT;
               width->xI;
               'height: '->xT;
               height->xI
            #);
        (width,height)->r.size;
        r[]->frame;
        
     #);
   data.bindLeft->item.bindLeft;
   data.bindRight->item.bindRight;
   data.bindTop->item.bindTop;
   data.bindBottom->item.bindBottom;
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   data.borderStyle->theWindowItem.border.style;
   data.borderVisible->theWindowItem.border.visible;
   data.backgroundColor->theWindowItem.backgroundColor;
   INNER ;
     

-- IBcanvasEditorapplyObjectData: DoPart --
do INNER ;   

-- GraphicalEditorWindowItemEditorEditAttributes: DoPart --
do
     (#
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : attributes'->theTitle.append;
             
          exit theTitle[]
          #);
        
     do (node[],makeTitle)->openAstEditor; 
     #);
     

-- GraphicalEditorWindowItemEditorShowInfoDialog: DoPart --
do
     (#
        makeTitle:
          (# title: ^text; 
          do node[]->betaGram.getName->title[]; ' : info'->title.append; 
          exit title[]
          #);
        
     do
        (data.copy,makeTitle,platform,node[]->betaGram.getPrefix)
          ->newEditInfo
            (#
               onOk:: 
                 (# 
                 do (THIS(windowItemEditor)[],data[])->makeDialogOperation; 
                 #);
               
            #);
        
     #);
     

-- GraphicalEditorWindowItemEditorEditVirtual: DoPart --
do
     (#
        theAttribute,theVirtual,theEventHandler:
          ^astInterface.beta.attributeDecl;
        theEditor: ^astEditorEnv.astEditor;
        astToEdit: ^astInterface.AST;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        slotName: ^text;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        theAst: ^astInterface.AST;
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : '->theTitle.append;
             name[]->theTitle.append;
             
          exit theTitle[]
          #);
        frag: ^astInterface.fragmentForm;
        
     do
        node[]->theAttribute[];
        name[]->findVirtual->theVirtual[];
        (if theVirtual[] = none then
            name[]->createVirtual->theVirtual[];
            (if theVirtual[] <> none then
                (if isPrivateToWindow or (defaultBodyGroup = none ) then
                    theVirtual[]->astToEdit[]; 
                 else
                    theVirtual[]->betaGram.getObjectDescriptor
                      ->theObjectDescriptor[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getActionPart->theActionPart[];
                    theAttribute[]->betaGram.getName->slotName[];
                    name[]->slotName.append;
                    (theAttribute.frag[],slotName[])->betaGram.newSlotDoPart
                      ->theActionPart.putDoPartOpt;
                    slotName[]->betaGram.newDoPartFrag->doPartFrag[];
                    defaultBodyGroup->group[];
                    slotName[]->group.findFragment->frag[];
                    (if frag[] <> none then
                        frag.root[]->astToEdit[]; 
                     else
                        doPartFrag[]->group.fragmentList.addFragment;
                        doPartFrag.root[]->astToEdit[];
                        
                    if);
                    
                if);
                
             else
                
            if);
            
         else
            theVirtual[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getActionPart->theActionPart[];
            theActionPart.getDoPartOpt->theAst[];
            (if theAst.kind = MPS.kinds.unExpanded then
                theAst[]->theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot->theSlot[];
                    defaultBodyGroup->group[];
                    theSlot.name->group.findFragment->doPartFrag[];
                    doPartFrag.root[]->astToEdit[];
                    
                if);
                
             else
                theVirtual[]->astToEdit[]; 
            if);
            
        if);
        (astToEdit[],makeTitle)->openAstEditor;
        
     #);
   (* theDocument.autoSave; *)
     

-- GraphicalEditorWindowItemEditorInit: DoPart --
do
     (#
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        
     do
        theClassData.className[]->className[];
        true->private.initializing;
        inherited->THIS(windowItemEditor).inherited;
        10->trace (#  do 'init windowitem'->xT #);
        (if theClassData.vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        4->trace (#  do 'type -> makeData -> defaultData[]'->xT;  #);
        initialize;
        (*  defaultData.data.storage.scan
         *       (# 
         *       do (current.key[], current.value[]) -> data.data.define;
         *       #);
         *)
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.children.append; 
        if);
        INNER init;
        false->private.initializing;
        6
          ->trace
            (# 
            do
               node[]->betaGram.getName->xT;
               ' defaultdata: '->xT;
               xN;
               defaultData[]->xData
            #);
        6
          ->trace
            (# 
            do node[]->betaGram.getName->xT; ' data '->xT; xN; data[]->xData
            #);
        
     #);
     

-- canvasEditorInit: DoPart --
do INNER ;   

-- GraphicalEditorNew: DoPart --
do
     (#
        theTimer: @timer
          (#
             action:: 
               (# 
               do
                  stop;
                  THIS(graphicalEditor).private.contentsEditor.fixOptionButtons
               #);
             
          #);
        theClassData: ^classData;
        theEditor: ^windowItemEditor;
        privateFrag: ^astInterface.fragmentForm;
        theDoPart: ^astInterface.beta.doPart;
        
     do
        9->trace (#  do node[]->betaGram.getName->xT; '.new'->xT;  #);
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            privateFrag.father->onGroupChanged;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            9->trace (#  do 'adding open declaration'->xT #);
            theEditor.realCreateOpen->theDoPart[];
            adjustSize;
            private.controlPoints.init;
            show;
            (if platform = X11 then 300->theTimer.start;  if);
            
         else
            close; 
        if);
        
     #);
     

-- graphicalEditorWindowItemEditorFindEditor: DoPart --
do INNER ;   

-- graphicalEditorCanvasEditorFindEditor: DoPart --
do
   (if not locked then
       search: children.scan
         (# theFrame: ^rectangle; 
         do
            (if current[] <> ignoreEditor[] then
                current.frame->theFrame[];
                (if pt->theFrame.containsPoint then
                    theFrame.topLeft->pt.subTract;
                    (pt,ignoreEditor[])->current.findEditor->theEditor[];
                    leave search;
                    
                if);
                
            if);
            
         #);
       (if theEditor[] = none then THIS(canvasEditor)[]->theEditor[];  if);
       
   if);
     

-- GraphicalEditorEnterPrivateAttributes: DoPart --
do   

-- GraphicalEditorExitPrivateAttributes: DoPart --
do   

-- GraphicalEditorEnterPrivateDoParts: DoPart --
do   

-- GraphicalEditorExitPrivateDoPart: DoPart --
do   

-- GraphicalEditorWindowItemEditorClose: DoPart --
do INNER close;   

-- GraphicalEditorCanvasEditorClose: DoPart --
do INNER ; children.scan (#  do current.close;  #);   

-- GraphicalEditorSelectionDelete: DoPart --
do makeDeleteOperation;   

-- GraphicalEditorSelectionShowInfo: DoPart --
do (if not empty then (first).showInfoDialog;  if);   

-- GraphicalEditorSelectionFitToContents: DoPart --
do makeFitToContentsOperation;   

-- GraphicalEditorSelectionAlignLeft: DoPart --
do
   makeAlignOperation
     (#  do (modelFrame.left-currentFrame.left,0)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignRight: DoPart --
do
   makeAlignOperation
     (# 
     do (modelFrame.right-currentFrame.right,0)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignTop: DoPart --
do
   makeAlignOperation
     (#  do (0,modelFrame.top-currentFrame.top)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignBottom: DoPart --
do
   makeAlignOperation
     (# 
     do (0,modelFrame.bottom-currentFrame.bottom)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignHorCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.right-currentFrame.left) div 2)+currentFrame.left
          ->itsCent;
        ((modelFrame.right-modelFrame.left) div 2)+modelFrame.left->cent;
        (cent-itsCent,0)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionAlignVerCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.bottom-currentFrame.top) div 2)+currentFrame.top
          ->itsCent;
        ((modelFrame.bottom-modelFrame.top) div 2)+modelFrame.top->cent;
        (0,cent-itsCent)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionShowSpacingDialog: DoPart --
do
     (#
        theWindow: @window
          (#
             theSpacingDialog: @spacingDialog
               (#
                  accept:: 
                    (# abort: @boolean; 
                    do
                       (if values.doWidth then
                           (if values.width = 0 then
                               'The width must be greater than zero'
                                 ->displayMessage;
                               true->abort;
                               
                           if);
                           
                       if);
                       (if not abort then
                           (if values.doHeight then
                               (if values.height = 0 then
                                   'The height must be greater than zero'
                                     ->displayMessage;
                                   true->abort;
                                   
                               if);
                               
                           if);
                           
                       if);
                       (if not abort then
                           values[]->alignspacing; theWindow.close; 
                       if);
                       
                    #);
                  cancel::  (#  do theWindow.close;  #);
                  
               #);
             open:: 
               (# 
               do
                  'Spacing'->title;
                  hide;
                  (contents,values[])->theSpacingDialog.open;
                  theSpacingDialog.size->THIS(window).size;
                  centerOnScreen;
                  
               #);
             
          #);
        values: ^spacingValues;
        
     do getSpacingValues->values[]; theWindow.open; theWindow.showModal; 
     #)  

-- graphicalEditorSelectionDoCopy: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            
        if);
        
     #);
     

-- graphicalEditorSelectionDoCut: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            makeCutOperation;
            
        if);
        
     #);
     

-- graphicalEditorEnvFind: DoPart --
do
   search: private.editors.scan
     (# 
     do
        (if node[]->current.node.equal then
            current[]->editor[]; leave search; 
        if);
        
     #);
     

-- graphicalEditorEnvInit: DoPart --
do
   screen[]->tracestream[];
   private.editors.init;
   private.theFactory.init;
   private.infoDialogs.init;
   ('pushbutton',buttonDialog##)->registerDialog;
   ('separator',separatorDialog##)->registerDialog;
   ('scrollbar',scrollbarDialog##)->registerDialog;
   ('staticText',buttonDialog##)->registerDialog;
   ('iconButton',iconButtonDialog##)->registerDialog;
   ('optionButton',buttonDialog##)->registerDialog;
   ('toggleButton',buttonDialog##)->registerDialog;
   ('radioButton',buttonDialog##)->registerDialog;
   ('checkBox',buttonDialog##)->registerDialog;
   ('window',windowDialog##)->registerDialog;
   (theFragServer[],MPS[],pretty[])->theAstEditorEnv.init;
   private.theScrap.init;
   INNER ;
     

-- GraphicalEdioterWindowItemEditorCreateWindowItem: DoPart --
do
   &wrapper[]->item[];
   (if owner[] <> none then
       owner.getMainCanvas->item.open; 
    else
       THIS(editorWindow).private.adorner.inside->item.open;
       item[]->THIS(editorWindow).private.adorner.interior;
       
   if);
   &windowItemType[]->theWindowItem[];
   item[]->theWindowItem.open;
   (if not initial then applyObjectData;  if);
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[]->theWindowItem.prependAction;
   &handleRefresh[]->theWindowItem.appendAction;
   &handleFrameChanged[]->item.appendAction;
   (if inherited then
       (theWindowItem[],none )->makeDelegateMousedownAction; 
   if);
   INNER ;
     

-- GraphicalEditorCanvasEditorCreateTheWindowItem: DoPart --
do
   (if not initial then
       children.scan (#  do current.createTheWindowItem;  #); 
   if);
   INNER ;
     

-- textEditorPictOpen: DoPart --
do private.open;   

-- graphicalEditorUndo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.undoStack.empty then
            private.undoStack.pop->theOperation[];
            theOperation.undoIt;
            theOperation[]->private.redoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorUndoText: DoPart --
do (if canUndo then (private.undoStack.top).name->value[];  if);   

-- graphicalEditorCanUndo: DoPart --
do not private.undoStack.empty->value;   

-- graphicalEditorRedo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.redoStack.empty then
            private.redoStack.pop->theOperation[];
            theOperation.doIt;
            theOperation[]->private.undoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorCanRedo: DoPart --
do not private.redoStack.empty->value  

-- graphicalEditorRedoText: DoPart --
do (if canRedo then (private.redoStack.top).name->value[];  if);   

-- graphicalEditorCanPaste: DoPart --
do not private.theClipBoard.theScrap.empty->value;   

-- graphicalEditorPaste: DoPart --
do private.theClipBoard.makePasteOperation;   

-- graphicalEditorEnvOpenSeparateAstEditorMethod: DoPart --
do
     (# theEditor: ^scriptEditor; 
     do
        node[]->theAstEditorEnv.find->theEditor[];
        (if theEditor[] = none then
            &scriptEditor[]->theEditor[];
            node[]->theEditor.init;
            title[]->theEditor.title;
            
         else
            theEditor.bringToFront; 
        if);
        
     #);
     

-- graphicalEditorExitMode: DoPart --
do private.mode->value;   

-- windowItemEditorListCopy: DoPart --
do
   &windowItemEditorList[]->theCopy[];
   theCopy.init;
   scan
     (#  do current[]->theCopy.append;  #);
     

-- windowItemEditorListSet: DoPart --
do clear; theOther.scan (#  do current[]->append;  #);   

-- selectionAppend: DoPart --
do true->elm.private.selected; selectionChanged;   

-- selectionPrepend: DoPart --
do true->elm.private.selected; selectionChanged;   

-- selectionDelete: DoPart --
do false->elm.private.selected; selectionChanged;   

-- selectionClear: DoPart --
do selectionChanged; scan (#  do false->current.private.selected;  #);   

-- windowItemEditorGetPublicAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       node[]->betaGram.getAttributes->theAttributes[]; 
   if);
     

-- windowItemEditorGetPrivateAttributes: DoPart --
do
     (#
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        
     do
        (if privateFrag[] <> none then
            privateFrag.root[]->theDescriptorForm[];
            theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            
        if);
        
     #);
   INNER ;
     

-- windowItemEditorGetMainAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       getPrivateAttributes->theAttributes[];
       (if theAttributes[] = none then
           getPublicAttributes->theAttributes[]; 
       if);
       
   if);
     

-- windowItemEditorNewNode: DoPart --
do
     (# theAttributes: ^astInterface.beta.attributes; instanceName: ^text; 
     do
        owner.getMainAttributes->theAttributes[];
        (theAttributes[],className[])->newUniqueName->instanceName[];
        (theAttributes.frag[],instanceName[],className[])
          ->betaGram.newSingularItem->node[];
        
     #);
   INNER ;
     

-- graphicalEditorOnAboutToClose: DoPart --
do INNER ;   

-- windowItemEditorCreateOpen: DoPart --
do
     (#
        theDoPart: ^astInterface.beta.doPart;
        oldImps: ^astInterface.beta.imperatives;
        openDecl: ^astInterface.beta.attributeDecl;
        gram: @grammar;
        
     do
        forInitStatements->findOpenDopart->theDoPart[];
        (if theDoPart[] = none then
            (node.frag[],'open::< (# do #)',gram.attributeDecl)->parseText
              ->openDecl[];
            (node[],openDecl[])->appendAttributeToNode;
            
        if);
        INNER createOpen;
        
     #)  

-- CanvasEditorCreateOpen: DoPart --
do
(* children.scan
 *    (#
 *    do (if not current.inherited then
 *           newImps.frag[] -> current.generateOpenImp -> newImps.append;
 *       if);
 *    #);
 *) INNER createOpen;   

-- classDataInit: DoPart --
do   

-- windowEditorNewData: DoPart --
do 'untitled'->data.title; INNER ;   

-- GraphicalEditorWindowItemEditorCreateInitImps: DoPart --
do
   (if override then
       INNER ; 
    else
         (# x,y,width,height: @integer; 
         do
            'here we go'->putLine;
            data.position->(x,y);
            data.size->(width,height);
            (betaGram.imperatives,frag[])->betaGram.newAst->initImps[];
            (frag[],'position',(frag[],x,y)->betaGram.newPointEvaluation)
              ->betaGram.newAssignment->initImps.append;
            (frag[],'size',(frag[],width,height)->betaGram.newPointEvaluation)
              ->betaGram.newAssignment->initImps.append;
            (frag[],'bindLeft',
             (frag[],data.bindLeft)->betaGram.newBoolEvaluation)
              ->betaGram.newAssignment->initImps.append;
            (frag[],'bindRight',
             (frag[],data.bindRight)->betaGram.newBoolEvaluation)
              ->betaGram.newAssignment->initImps.append;
            (frag[],'bindTop',(frag[],data.bindTop)->betaGram.newBoolEvaluation)
              ->betaGram.newAssignment->initImps.append;
            (frag[],'bindBottom',
             (frag[],data.bindBottom)->betaGram.newBoolEvaluation)
              ->betaGram.newAssignment->initImps.append;
            
         #);
       INNER ;
       
   if);
     

-- windowItemEditorInitialize: DoPart --
do
   INNER ;
   (if not done then
         (#
            initializeData:
              (#
                 aClassData: ^classData;
                 theData: ^parameters;
                 super: @boolean;
                 
              enter (theData[],aClassData[],super)
              do
                 (if aClassData[] <> none then
                     (theData[],aClassData.superClassData[],true)
                       ->initializeData;
                     (if not super then
                         4
                           ->trace
                             (#  do 'data[] -> defaultData.set;'->xT;  #);
                         data[]->defaultData.set;
                         
                     if);
                     (theData[],aClassData.theImperatives[])->initData;
                     applyObjectData;
                     
                 if);
                 
              #);
            
         do
            true->createTheWindowItem;
            (contents).backgroundColor->data.backgroundColor;
            (data[],theClassData[],false)->initializeData;
            12->trace (#  do 'initializeData:'->xT; xN; data[]->xData #);
            
         #);
       
   if);
     

-- canvasEditorInitialize: DoPart --
do
     (#
        initAttributes:
          (# aClassData: ^classData; super: @boolean; 
          enter (aClassData[],super)
          do
             5
               ->trace
                 (# 
                 do 'Init attributes'->xT; aClassData.classname[]->xT
                 #);
             (if aClassData.superClassData[] <> none then
                 (aClassData.superClassData[],true)->initAttributes; 
             if);
             4->trace (#  do 'canvas init data'->xT #);
             7
               ->trace
                 (# 
                 do
                    node[]->betaGram.getName->xT;
                    ' initdata BEFORE'->xT;
                    xN;
                    data[]->xData
                 #);
             (contents).backgroundColor->data.backgroundColor;
             (data[],aClassData.theImperatives[])->initData;
             7
               ->trace
                 (# 
                 do
                    node[]->betaGram.getName->xT;
                    ' initdata AFTER'->xT;
                    xN;
                    data[]->xData
                 #);
             applyObjectData;
             aClassData.theAttributes.scan
               (# theEditor: ^windowItemEditor; theClassData: ^classData; 
               do
                  (if current[]->isStaticItem then
                      current[]->getClassData->theClassData[];
                      (if theClassData[] <> none then
                          (theClassData.className.copy,theClassData.vertical)
                            ->makeEditor->theEditor[];
                          (if theEditor[] <> none then
                              (THIS(canvasEditor)[],current[],none ,super,
                               theClassData[],none )->theEditor.init
                          if);
                          
                      if);
                      
                  if);
                  
               #);
             
          #);
        initAttributes2:
          (# anInst: ^instantiator; super: @boolean; 
          enter (anInst[],super)
          do
             anInst.scanAttributes
               (#
                  whenPartObject:: 
                    (# theEditor: ^windowItemEditor; theClassData: ^classData
                    do
                       current[]->getClassData->theClassData[];
                       (if theClassData[] <> none then
                           (theClassData.className.copy,theClassData.vertical)
                             ->makeEditor->theEditor[];
                           (THIS(canvasEditor)[],current[],none ,super,
                            theClassData[],none )->theEditor.init;
                           
                       if)
                    #);
                  
               #);
             
          #);
        proto: ^astInterface.AST;
        isStaticItem: booleanValue
          (# node: ^astInterface.beta.attributeDecl; 
          enter node[]
          do (mps[],node[],proto[])->match->value; 
          #);
        frag: ^astInterface.fragmentForm;
        inst: ^instantiator;
        
     do
        className[]->lookup->inst[];
        true->createTheWindowItem;
        betaGram[]->mps.newFragmentForm->frag[];
        (frag[],'<<nameDcl>>: @<<nameApl>> <<mainpart>>',betaGram.simpleDecl)
          ->parseText->proto[];
        (theClassData[],inherited)->initAttributes;
        true->done;
        
     #);
     

-- getClassDataDoPart: DoPart --
do
     (#
        superNode: ^astInterface.beta.attributeDecl;
        prefixName: ^text;
        inst: ^instantiator;
        superClassData: ^classData;
        verticalDecl: ^astInterface.beta.attributeDecl;
        
     do
        node[]->betaGram.getPrefix->prefixName[];
        &classData[]->theClassData[];
        node[]->theClassData.node[];
        (node[],'vertical')->betaGram.findAttribute->verticalDecl[];
        (verticalDecl[] <> none )->theClassData.vertical;
        (if prefixName[] <> none then
            prefixName[]->lookup->inst[];
            (if inst[] = none then
                node[]->getSuperPattern->superNode[];
                (if superNode[] <> none then
                    superNode[]->getClassData->superClassData[];
                    (if superClassData[] <> none then
                        superClassData.className[]->theClassData.className[];
                        superClassData[]->theClassData.superClassData[];
                        
                     else
                        none ->theClassData[]; 
                    if);
                    
                 else
                    none ->theClassData[]; 
                if);
                
             else
                (if inst[] <> none then
                    inst.name[]->theClassData.className[]; 
                 else
                    none ->theClassData[]; 
                if);
                
            if);
            
         else
            none ->theClassData[]; 
        if);
        (if theClassData[] <> none then
            node[]->getAttributes
              ->(theClassData.theAttributes[],theClassData.theImperatives[]);
            
        if);
        
     #)  

-- checkIdentifierDoPart: DoPart --
do
   (if name.empty then
       false->value; 
    else
       makeFragmentForm->frag[];
       (frag[],name[],betaGram.nameDcl)->parseText->nameDecl[];
       (nameDecl[] <> none )->value;
       
   if);
     

-- textEditorPictContentsOnMousedown: DoPart --
do   

-- makeDelegateMousedownAction: DoPart --
do
   (if enclosing[] = none then findEnclosing->enclosing[];  if);
   &aWindowItem.mousedownAction
     (# p: @point; 
     do
        theEvent.localPosition->p;
        (p,aWindowItem[],enclosing.theWindowItem[])->translate->p;
        (theEvent[],p)->enclosing.mouseDown;
        
     #)[]->aWindowitem.appendAction;
     

-- GraphicalEditorCanvasEditorNewData: DoPart --
do borderStyles.shadowIn->data.borderStyle; false->data.borderVisible; INNER  

-- graphicalEditorEnvInsertCustom: DoPart --
do
     (# 
     do
        ('canvas'->loadBitmap,name[],theInstantiator[],path[],grouping[],100,
         200)->private.theFactory.insert;
        
     #);
     

-- graphicalEditorMousedownInItem: DoPart --
do
     (#
        value: ^rectangle;
        prox: @proxy
          (#
             moveTo:: 
               (# theCreateOperation: ^createOperation; 
               do
                  &createOperation[]->theCreateOperation[];
                  (theCanvasEditor[],newFrame[],none ,name[])
                    ->theCreateOperation.init;
                  
               #);
             
          #);
        
     do
        &rectangle[]->value[];
        p->value.topLeft;
        name[]->getDefaultSize->value.size;
        true->prox.palette;
        (value[],prox[])->THIS(editorWindow).private.paletteTabber.dragAndDrop;
        
     #);
     

-- recievingCanvasEditorAccept: DoPart --
do
   (if dragee.palette then
       TRUE->value; 
    else
       (if (THIS(graphicalEditor).selection.first).owner[] = THIS(canvasEditor
       )[] then
           TRUE->value; 
        else
           THIS(canvasEditor)[]->THIS(graphicalEditor).selection.moveAllowed
             ->value;
           
       if);
       
   if);
     

-- recievingCanvasEditorRecieve: DoPart --
do (THIS(canvasEditor)[],bounds[])->dragee.moveTo;   

-- addInclude: DoPart --
do
   (if not ((group[],path[])->hasInclude) then
       'INCLUDE'
         ->group.prop.addProp
           (# ifPropExist::  (#  do false->delete #); 
           do path[]->addString
           #);
       group.loadIncludes
   if)  

-- hasInclude: DoPart --
do
   l:
   'INCLUDE'
     ->group.prop.getProp
       (#
          doProp:: 
            (# 
            do
               scanParameters
                 (#
                    doString:: 
                      (# 
                      do (if path[]->s.equal then TRUE->value; leave l if)
                      #)
                 #)
            #)
       #)  

-- createNewWindow: DoPart --
do
     (# frag: ^astInterface.fragmentForm
     do
        (name[],'guienvlib')->createSourceFile->frag[];
        (frag[],name[],'window')->createWindow
     #)  

-- createSourceFile: DoPart --
do
     (#
        stripExtension:
          (# path: ^text; lastDotInx,lastSlashInx: @integer; 
          enter path[]
          do
             '.'->path.findAll (#  do inx->lastDotInx #);
             MPS.thePathHandler.directoryChar
               ->path.findAll (#  do inx->lastSlashInx #);
             (if (lastDotInx > 0) and (lastDotInx > lastSlashInx) then
                 (lastDotInx,path.length)->path.delete; 
             if);
             
          #);
        createFragmentGroup:
          (# name: ^text; group: ^astInterface.fragmentGroup; 
          enter name[]
          do name[]->MPS.top.newGroup->group[]; 
          exit group[]
          #);
        createFragmentForm:
          (# name: ^text; frag: ^astInterface.fragmentForm; 
          enter name[]
          do betagram[]->MPS.newFragmentForm->frag[]; name[]->frag.name; 
          exit frag[]
          #);
        bodyGroup: ^astInterface.fragmentGroup;
        astFileName: ^text;
        betFileName: ^text;
        bodyFileName: ^text;
        bodyAstFileName: ^text;
        bodyBetFileName: ^text;
        gram: @grammar;
        guienvLocation: (#  exit '~beta/guienv/v1.6/guienv' #);
        iconNameLocation: (#  exit '~beta/guienv/v1.6/utils/iconname' #);
        getShortName:
          (# name: ^text; shortName: ^text; lastDirCharPos: @integer; 
          enter name[]
          do
             name.reset;
             MPS.thePathHandler.directoryChar
               ->name.find (#  do inx->lastDirCharPos;  #);
             (if (lastDirCharPos > 0) and (lastDirCharPos < name.length) then
                 (lastDirCharPos+1,name.length)->name.sub->shortName[]; 
              else
                 name.copy->shortName[]; 
             if);
             
          exit shortName[]
          #);
        
     do
        (if fileName[] <> none then
            fileName[]->stripExtension;
            (fileName[],currentDirectory)->MPS.thePathHandler.convertFilePath
              ->fileName[];
            '.ast'->(fileName.copy).append->astFileName[];
            '.bet'->(fileName.copy).append->betFileName[];
            (if (astFileName[]->entryExists) or (betFileName[]->entryExists)
             then
                'does already exist'->displayMessage; 
             else
                fileName[]->createFragmentGroup->group[];
                (if group[] <> none then
                    'ORIGIN'
                      ->group.prop.addProp
                        (#  do guienvLocation->addString;  #);
                    fragName[]->betagram.newAttributesFrag->frag[];
                    frag[]->group.fragmentList.addFragment;
                    fileName[]->putLine;
                    group.markAsChanged;
                    (group[],betFileName[])->prettyprintFragment;
                    INNER createSourceFile;
                    
                if);
                
            if);
            
        if);
        
     #)  

-- friggApplicationCreateWindow: DoPart --
do
   l:
     (#
        theAttributesForm: ^astInterface.beta.attributesForm;
        theAttributes: ^astInterface.beta.attributes;
        theAttribute: ^astInterface.beta.attributeDecl;
        theGraphicalEditor: ^graphicalEditorEnv.graphicalEditor;
        fg: ^astInterface.fragmentGroup;
        classes: ^patternList;
        classNames: @textList;
        gram: @grammar;
        
     do
        frag.father->fg[];
        frag.root[]->theAttributesForm[];
        theAttributesForm.getAttributes->theAttributes[];
        (theAttributes[],name[])->betagram.find->theAttribute[];
        (if theAttribute[] <> none then
            'The window could not be created because it already exists'
              ->putLine;
            
         else
              (#
                 son1: ^astInterface.ast;
                 doReplace: @boolean;
                 super: ^astInterface.beta.patternDecl;
                 
              do
                 (if 'canvas'->className.equalNCS then
                     name[]->recentCanvas
                 if);
                 (frag[],name[],className[])->betaGram.newPatternAttribute
                   ->theAttribute[];
                   (#
                      group,bodyGroup: ^astInterface.fragmentGroup;
                      bodyName: ^text;
                      t: @text;
                      decl: ^astInterface.beta.simpleDecl;
                      privateFrag,theFragment: ^astinterface.fragmentForm;
                      privateName: ^text;
                      
                   do
                      frag.father->group[];
                      (if group[] <> none then
                          l: group.scanBodyGroups
                            (# 
                            do currentFullPath[]->bodyName[]; leave l; 
                            #);
                          (if bodyName[] <> none then
                              bodyName[]->MPS.safeOpen->bodyGroup[];
                              (if bodyGroup[] <> none then
                                  'private'->(name.copy).append->privateName[];
                                  'private: @<<SLOT '->t.append;
                                  privateName[]->t.append;
                                  ': descriptor>>'->t.append;
                                  (frag[],t[],gram.simpleDecl)->parseText
                                    ->decl[];
                                  (theAttribute[],decl[])
                                    ->betaGram.appendAttribute;
                                  betaGram[]->MPS.newFragmentForm
                                    ->privateFrag[];
                                  privateName[]->privateFrag.name;
                                  privateName[]->bodyGroup.findFragment
                                    ->theFragment[];
                                  (if theFragment[] <> none then
                                      theFragment[]->bodyGroup.deleteFragment; 
                                  if);
                                  privateFrag[]
                                    ->bodyGroup.fragmentList.addFragment;
                                  (privateFrag[],none )
                                    ->betaGram.newDescriptorForm
                                    ->privateFrag.root[];
                                  bodyGroup[]->onGroupChanged;
                                  
                              if);
                              
                          if);
                          
                      if);
                      
                   #);
                 (if theAttributes.noOfsons = 1 then
                     1->theAttributes.get->son1[];
                     (if son1.kind = mps.kinds.optional then
                         true->doReplace; 
                     if);
                     
                 if);
                 (if doReplace then
                     (1,theAttribute[])->theAttributes.put; 
                  else
                     theAttribute[]->theAttributes.append; 
                 if);
                 frag.father->onGroupChanged;
                 &graphicalEditor[]->theGraphicalEditor[];
                 theGraphicalEditor.open;
                 theAttribute[]->theGraphicalEditor.new;
                 (if doReplace then
                     (true,frag[],son1[],theAttribute[])
                       ->theFragServer.notifyAstReplaced;
                     
                  else
                     (true,frag[],theAttributes[],theAttributes.noOfSons-1)
                       ->theFragServer.notifyListElementInserted;
                     
                 if);
                 
              #);
            
        if);
        
     #);
     

-- windowEditorApplyObjectData: DoPart --
do false->theWindowItem.border.visible; ; INNER  

-- windowItemEditorOutline: DoPart --
do not theWindowItem.border.visible->value; INNER  

-- GraphicalEditorWindowItemEditorNewData: DoPart --
do
     (# width,height: @integer; vertical: @boolean
     do
        &parameters[]->data[];
        data.init;
        (0,0)->data.position;
        (if vertical then
            '-vertical'->(name.copy).append->getDefaultSize->(width,height)
         else
            name[]->getDefaultSize->(width,height)
        if);
        10
          ->trace
            (# 
            do
               name[]->xT;
               '.newData'->xT;
               xN;
               'width = '->xT;
               width->xI;
               'height = '->xT;
               height->xI
            #);
        (if width = 0 then 300->width if);
        (if height = 0 then 200->height if);
        (width,height)->data.size;
        true->data.bindLeft;
        false->data.bindRight;
        true->data.bindTop;
        false->data.bindBottom;
        true->data.visible;
        true->data.enabled;
        false->data.hilite;
        borderStyles.shadowOut->data.borderStyle;
        false->data.borderVisible;
        (contents).backgroundColor->data.backgroundColor
     #);
   INNER  

-- graphicalEditorEnterMode: DoPart --
do
   value->private.mode;
   (if value
    // selectMode then
       cursors.arrow[]->(contents).theCursor; 
    // hierarkiMode then
       cursors.cross[]->(contents).theCursor; 
    // resizeMode then
       cursors.plus[]->(contents).theCursor; 
   if);
     

-- graphicalEditorClearSelection: DoPart --
do selection.clear  

-- windowItemEditorInitDopart: DoPart --
do 8->trace (#  do 'init dopart, node = '->xT; xN; node[]->xA #); INNER  

-- wrapperHilite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- wrapperLowlite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

