ORIGIN '../graphicaleditor';
INCLUDE '~beta/guienv/v1.2/utils/guienvadds';
INCLUDE '~beta/guienv/v1.2/utils/track';
INCLUDE '~beta/sysutils/v1.4/time';
INCLUDE '~beta/sysutils/v1.4/objinterface';
INCLUDE '~beta/betaast/v4.9.1/gram';
INCLUDE '~beta/interfacebuilder/v1.0/code/generate';
INCLUDE '~beta/interfacebuilder/v1.0/asteditor/asteditor';
INCLUDE '~beta/interfacebuilder/v1.0/palettes/palette';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/guienvstuff';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/walkingants';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/killtranslations';
INCLUDE '~beta/interfacebuilder/v1.0/mpsstuff/mpsutils';
INCLUDE '../classinfo';

MDBODY default 'X11/graphicaleditor_X11body';


-- lib: attributes --
getMPS: objectPool.get
  (# type:: astInterface;
     init::
       (# 
       do exception
          (# 
          do 'No instance of astInterface in objectPool' -> msg.append;
          #);
       #);
  #);
-- GUIenvLib: attributes --

getWalkingAnts: objectPool.get
  (# type:: walkingAnts;
     init::
       (# 
       do obj.init;
          50 -> obj.interval;
       #);
  #);
putPoint:
  (# x, y: @integer;
  enter (x, y)
  do '[' -> put;
     x -> putInt;
     ' ' -> put;
     y -> putInt;
     ']' -> put;
  #);

-- windowitemEditornew: doPart --
do (# theAttributeDecl: ^astInterface.beta.attributeDecl;
      className, instanceName: ^text;
      theAttributes: ^astInterface.beta.attributes;
   do  (if data[]//none then
           newData;
       if);
      (if astControl.node[]//None then
          (if owner.private.privateAttributes[] <> none then
              owner.private.privateAttributes[] -> theAttributes[]
           else
              owner.astControl.node[] -> betaGram.getAttributes -> theAttributes[];
          if);
          this(graphicalEditor).private.names[type][] -> className[];
          className.copy -> instanceName[];
          instanceName.length -> instanceName.setPos;
          data.id -> instanceName.putInt;
          (theAttributes.frag[], instanceName[],className[])
            -> betaGram.newSingularItem -> theAttributeDecl[];
          data.id -> theAttributeDecl.guiInfo;
          theAttributeDecl[] -> theAttributes.smartAppend;
          (if owner.private.privateAttributes[] <> none then
              owner.private.privateControl.prepareUpdate;
              owner.private.privateControl.change;
          if);
          theAttributeDecl[] -> astControl.init;
      if);
     
      generateSimpleOpen;
      createTheWindowItem;
      (if owner[]<>None then
          this(windowitemEditor)[] -> owner.children.append;
          owner.generateOpen;
      if);
      
      owner.astControl.prepareUpdate;
      owner.astControl.change;
   #);
   inner;
   
   
-- windowItemEditorLib: attributes --

isPrivateToWindow: booleanValue
  (# 
  do not (astControl.node.frag[] = this(graphicalEditor).astControl.node.frag[]) -> value;
  #);

isPrivateToOwner: booleanValue
  (# 
  do (if owner[] = none then
         false -> value;
      else
         not (astControl.node.frag[] = owner.astControl.node.frag[]) -> value;
     if);
  #);

appendAttribute:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  enter theAttribute[]
  do astControl.node[] -> betaGram.getAttributes
     (# 
        failure:: exception
          (# 
          do 'No attributes in appendAttribute' -> msg.append;
          #);
     #) -> theAttributes[];
     theAttribute[] -> theAttributes.smartAppend;
     astControl.prepareUpdate;
     astControl.change;
  #);

findVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        astControl.node[] -> currentNode[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
        if);
        (if currentNode[] <> none then
             (currentNode[], name[]) -> betaGram.findAttribute-> theVirtual[];
        if);
     #);
  exit theVirtual[]
  #);

createVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
        theAttribute: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        astControl.node[] -> currentNode[] -> theAttribute[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
            (if currentNode[] = none then
                (theAttribute.frag[], 'eventHandler', none) -> betaGram.newVirtualBinding -> currentNode[];
                (theAttribute[], currentNode[]) -> betaGram.appendAttribute;
            if);
        if);
        (currentNode.frag[], name[], none) -> betaGram.newVirtualBinding -> theVirtual[];
        (currentNode[], theVirtual[]) -> betaGram.appendAttribute;
     #);
  exit theVirtual[]
  #);



reEstablishNode:
  (# gram: @grammar;
     theExpanded: ^astInterface.expanded;
  do this(graphicalEditor).astControl.node[] -> theExpanded[];
     l: gram.simpleDecl -> theExpanded.suffixWalkForProd
     (# 
     do (if current.hasGUIcomment then
            (if data.ID = current.guiInfo then
                current[] -> astControl.init;
                leave l;
            if);
        if);
     #);
  #);

createTheWindowItem:
  (# thisCanvasEditor: ^canvasEditor;
  do (if theWindowItem[] = None then
         &windowItemType[] -> theWindowItem[];
         owner.theWindowItem[] -> theWindowItem.open;
         theWindowItem.killTranslations;
     if);
     &handleMouseDown[] -> theWindowItem.prependAction;
     &handleRefresh[] -> theWindowItem.appendAction;
     &handleFrameChanged[] -> theWindowItem.appendAction;
     applyObjectData;
     (if this(windowItemEditor)## <= canvasEditor## then
         this(windowItemEditor)[] -> thisCanvasEditor[];
         thisCanvasEditor.children.scan
         (# 
         do current.createTheWindowItem; 
         #)
     if);
  #);
setIDcomment:
  (#
  do 
  #);

createOpenDopart:
  (# theDoPart: ^astInterface.beta.doPart;
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        slotName: ^text;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theUnExpanded: ^astInterface.unExpanded;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        isPrivate: @boolean;
     do astControl.node[] -> node[];
        (node.frag[], 'open', none) -> betaGram.newVirtualBinding -> openDecl[];
        (node[], openDecl[]) -> betaGram.appendAttribute;
        openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
        (if isPrivateToWindow then
            node.frag[] -> betaGram.newDoPart ->  theDoPart[];
            (theObjectDescriptor[], theDoPart[]) -> betaGram.setDoPart;
         else
            node[] -> betaGram.getName -> slotName[];
            'Open' -> slotName.append;
            (node.frag[], slotName[]) -> betaGram.newSlotDoPart -> theUnExpanded[];
            (theObjectDescriptor[], theUnExpanded[]) -> betaGram.setDoPart;
            slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
            body -> group[];
            doPartFrag[] -> group.fragmentList.addFragment;
            doPartFrag.root[] -> theDoPart[];
        if);
     #);
  exit theDoPart[]
  #);

findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theAst: ^astInterface.AST;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
     do astControl.node[] -> node[];
        (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] <> none then
            openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
            theObjectDescriptor.getMainPart -> theMainPart[];
            theMainPart.getActionPart -> theActionPart[];
            theActionPart.getDoPartOpt -> theAst[];
            (if theAst.symbol = MPS.unExpanded then
                theAst[] -> theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot -> theSlot[];
                    body -> group[];
                    theSlot.name -> group.findFragment -> doPartFrag[];
                    (if doPartFrag[] <> None then
                        doPartFrag.root[] -> theDoPart[];
                    if);
                if);
             else
                theAst[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);

generateSimpleOpen:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
     node: ^astInterface.beta.attributeDecl;
  do astControl.node[] -> node[];
     findOpenDoPart -> theDoPart[];
     (if theDoPart[] = none then
         createOpenDopart -> theDoPart[];
     if);
     theDoPart.getImperatives -> oldImperatives[];
     (betaGram.imperatives, theDoPart.frag[]) -> betaGram.newAst -> theImperatives[] -> theDoPart.putImperatives;
     (theDoPart.frag[], data.id) -> betaGram.newInitFromResourceStatement -> theImperatives.smartAppend;
     (if oldImperatives[]<>none then
         oldImperatives.iterate
         (# 
         do theDoPart.frag[] -> current.copy -> theImperatives.smartAppend;
         #);
     if);
  #);

changeOwner:
  (# newOwner: ^canvasEditor;
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     theFather: ^astInterface.beta.attributes;
     currentOwner: ^canvasEditor;
  enter newOwner[]
  do 
     astControl.node[] -> theAttribute[];
     theAttribute.father -> theFather[];
     theAttribute.sonNo -> theFather.delete;
     (if newOwner.private.privateAttributes[] <> none then
         newOwner.private.privateAttributes[] -> theAttributes[];
      else
         newOwner.astControl.node[] -> betaGram.getAttributes -> theAttributes[];
     if);
     theAttribute[] -> theAttributes.smartAppend;
     owner[] -> currentOwner[];
     newOwner[] -> owner[];
     
     theWindowItem.close;
     None -> theWindowItem[];
     this(windowItemEditor)[] -> currentOwner.children.at -> currentOwner.children.delete;
     this(windowItemEditor)[] -> newOwner.children.append;
     createTheWindowItem;
     newOwner.generateOpen;
     currentOwner.generateOpen;
     newOwner.astControl.prepareUpdate;
     newOwner.astControl.change;
     currentOwner.astControl.prepareUpdate;
     currentOwner.astControl.change;
  #);


handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do theEvent[] -> this(windowItemEditor).mousedown;
  #);
handleFrameChanged: theWindowItem.frameChangedAction
  (# 
  do (if theWindowItem[]<>none then
         (if data[]<>none then
             theWindowItem.position -> data.position;
             theWindowItem.size -> data.size;
             (if private.selected then
                 restartWalkingAnts;
             if);
         if);
     if);
  #);
restartWalkingAnts:
  (#
  do stopWalkingAnts;
     startWalkingAnts;
  #);
stopWalkingAnts:
  (# 
  do this(graphicalEditor).private.theWalkingAnts.stop;
  #);
startWalkingAnts:
  (# r: ^rectangle
  do &rectangle[] -> r[];
     theWindowItem.frame -> r;
     (-1, -1) -> r.inset;
     owner.theWindowItem[] -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
     r[] -> this(graphicalEditor).private.theWalkingAnts.start;
  #);
handleRefresh: theWindowItem.refreshAction
  (#
  #);
reConfigure:
  (# doLeft,doTop,doRight,doBottom: @boolean;
     r: @rectangle;
     newOwner: ^canvasEditor;
  enter (doLeft,doTop,doRight,doBottom)
  do (if private.selected then
         this(graphicalEditor).private.theWalkingAnts.stop;
     if);
     theWindowItem.frame -> r;
     (r[],  theWindowItem.father[], (contentsEditor).theWindowItem[]) 
       -> translateRect;
     (r,doLeft,doTop,doRight,doBottom) -> (contentsEditor).theWindowItem.defineRect -> r;
     (r.topLeft, this(windowItemEditor)[]) -> (contentsEditor).findEditor 
       -> newOwner[];
     (if newOwner[]<>owner[] then
         (r[], (contentsEditor).theWindowItem[], newOwner.theWindowItem[])
           -> translateRect;
         r.topLeft -> data.position;
         r.size -> data.size;
         newOwner[] -> changeOwner;
      else
         (r.topLeft, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.topLeft;
         (r.bottomRight, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.bottomRight;
         r -> theWindowItem.frame;
     if);
     (if private.selected then
         owner.theWindowItem[] -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
         (-1, -1) -> r.inset;
         r[] -> this(graphicalEditor).private.theWalkingAnts.start;
     if);
  #);
resize:
  (# r: @rectangle;
  do theWindowItem.frame -> r;
     (r,false,false,true,true) -> theWindowItem.father.defineRect -> theWindowItem.frame;
  #);
drag:
  (# r: @rectangle;
  do theWindowItem.frame -> r;
     (r,true,true,true,true) -> theWindowItem.father.defineRect -> theWindowItem.frame;
  #);


-- windowitemEditorPrivate: descriptor --
(# selected: @boolean;
#)

-- canvasEditornew: doPart --
do (if theWindowItem[]<>contents then
       borderStyles.shadowIn -> theWindowItem.border.style;
       true -> theWindowItem.border.visible;
   if);
   inner;

-- abstractScrollerEditornew: doPart --
do false -> theWindowItem.border.visible;
   inner;

-- scrollerEditornew: doPart --
do inner;

-- textEditorEditornew: doPart --
do inner;

-- controlEditornew: doPart --
do inner;

-- buttonEditornew: doPart --
do 
   inner;

-- pushButtonEditornew: doPart --
do inner;

-- iconButtonEditornew: doPart --
do 
   inner;

-- optionButtonEditornew: doPart --
do inner;

-- staticTextEditornew: doPart --
do inner;

-- toggleButtonEditornew: doPart --
do 
   inner;

-- radioButtonEditornew: doPart --
do inner;

-- checkBoxEditornew: doPart --
do inner;

-- scrollbarEditornew: doPart --
do 
   inner;

-- editTextEditornew: doPart --
do 
   inner;

-- textFieldEditornew: doPart --
do inner;

-- scrollListEditornew: doPart --
do inner;

-- textScrollListEditornew: doPart --
do inner;

-- graphicalEditorSetcurrentMode: doPart --
do mode[] -> private.currentmode[];
   mode[] -> private.objectSpecificationList.findObjectType -> private.currentType##;

-- graphicalEditorGetcurrentMode: doPart --
do private.currentmode[] -> mode[];

-- graphicalEditorNewEditor: doPart --
do this(graphicalEditor).private.editorGenerator[type] -> theEditor[];
   (this(canvasEditor)[],type) -> theEditor.new;
   theEditor[] -> select;




-- graphicalEditormenubarTypeOpen: doPart --
do fileMenu.open;
   fileMenu[] -> append;
   this(graphicalEditor).private.theObjectMenu.open;
   this(graphicalEditor).private.theObjectMenu[] -> append;

-- graphicalEditorOpen: doPart --
do (#
   do 'Graphical Objects' -> title;
      getMPS -> MPS[];
      getClassInfo -> private.theClassInfo[];
      MPS.grammarTable.beta[] -> betaGram[];
      getWalkingAnts -> private.theWalkingAnts[];
      (600, 500) -> size;
      private.theControlPalette.open;
      private.theViewsPalette.open;
      
      (* 
       * (contents, width, height) -> private.windowView.open;
       *)
      ('PushButton',pushButtonEditor##) -> addObjectSpecification;
      ('StaticText',staticTextEditor##) -> addObjectSpecification;
      ('TextScrollList',textScrollListEditor##) -> addObjectSpecification;
      ('Scroller',scrollerEditor##) -> addObjectSpecification;
      ('Canvas',canvasEditor##) -> addObjectSpecification;
      ('IconButton',iconButtonEditor##) -> addObjectSpecification;
      ('OptionButton',optionButtonEditor##) -> addObjectSpecification;
      ('RadioButton',radioButtonEditor##) -> addObjectSpecification;
      ('CheckBox',checkBoxEditor##) -> addObjectSpecification;
      ('ScrollBar',scrollbarEditor##) -> addObjectSpecification;
      ('EditText',editTextEditor##) -> addObjectSpecification;
      ('TextField',textFieldEditor##) -> addObjectSpecification;
      ('TextEditor',textEditorEditor##) -> addObjectSpecification;
      private.initEditorGenerator;
      private.initNames;
      (*
       * private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
       *)
   #);

-- graphicalEditorClose: doPart --
do inner;
   private.selection.makeEmpty;
   private.contentsEditor.close;

-- graphicalEditorOnMouseDown: doPart --
do 
   
-- graphicalEditorLib: attributes --
itemSelected:
  (# name: ^text;
     type: @integer;
  enter (name[], type)
  do type -> this(graphicalEditor).private.currentCanvasEditor.newEditor;
  #);
paletteMenu: menu
  (# thePalette: ^palette;
     paletteMenuItem: menuItem
       (# type: @integer;
          eventHandler::<
            (#  onSelect::<
                 (# do (name, type) -> itemSelected #);
            #);
          init:<
            (# theName: ^text;
            enter (type, theName[])
            do open;
               theName[] -> name;
               this(paletteMenuItem)[] -> append;
               inner;
            #);
       #);
     installItem: @menuItem
       (# eventHandler::<
            (# onSelect::<
                 (# do thePalette.show; #);
            #);
          open::<
            (# 
            do 'Show Palette' -> name;
               installItem[] -> this(paletteMenu).append;
            #);
       #);
     addPaletteMenuItem:
       (# name: ^text;
          type: @integer;
          thePaletteMenuItem: ^paletteMenuItem;
       enter (type, name[])
       do &paletteMenuItem[] -> thePaletteMenuItem[];
          (type, name[]) -> thePaletteMenuItem.init;
       #);
     open::<
       (# 
       enter thePalette[]
       do installItem.open;
          inner;
       #);
  #);

scriptEditor: astEditor
  (# eventHandler::
       (# onAboutToClose::
            (# parseOK: @boolean;
            do (if dirty then
                   parse -> parseOK;
                   parseOK -> okToClose;
               if);
            #);
       #);
  #);

initialize:
  (# width, height: @integer;
  enter (width, height)
  do (*
      * (width, height) -> open;
      *)
     (contents, width, height) -> private.windowView.open;
     private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
  #);

generateEditor:
  (# we: ^windowItemEditor;
  do inner;
  exit we[]
  #);

contentsEditor:
  (# 
  exit private.contentsEditor[]
  #);

objectSpecification:
  (# ID: ^text;
     type: ##windowItemEditor;
  #);
addObjectSpecification:
  (# type: ##windowItemEditor;
     ID: ^text;
     spec: ^objectSpecification;
  enter (ID[],type##)
  do &objectSpecification[] -> spec[];
     ID[] -> spec.ID[];
     type## -> spec.type##;
     spec[] -> private.objectSpecificationList.append;
  #);
uniqueID:
  (# 
  do private.currentId + 1 -> private.currentId;
  exit private.currentId
  #);
currentType:
  (# 
  enter private.currentType##
  exit private.currentType##
  #);
currentCanvasEditor:
  (# 
  enter private.currentCanvasEditor[]
  exit private.currentCanvasEditor[]
  #);

translateRect:
  (# r: ^rectangle;
     from, to: ^windowItem;
  enter (r[], from[], to[])
  do (r.topLeft,from[], to[]) -> translate -> r.topLeft;
     (r.bottomRight, from[], to[]) -> translate -> r.bottomRight;
  #);
privateAttributes:
  (# theAttributes: ^astInterface.beta.attributes;
  enter (#
        enter theAttributes[]
        do theAttributes[] -> private.contentsEditor.private.privateAttributes[];
           theAttributes[] -> private.contentsEditor.private.privateControl.init;
        #)
  exit private.contentsEditor.private.privateAttributes[]
  #);
findPrivateAttributes:
  (# theAttributes: ^astInterface.beta.attributes;
     failure:< object;
  do (# theAst: ^astInterface.AST;
        group: ^astInterface.fragmentGroup;
        theSimpleDecl: ^astInterface.beta.simpleDecl;
        theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
        theStaticItem: ^astInterface.beta.staticItem;
        theUnExpanded: ^astInterface.unExpanded;
        theSlotDesc: ^astInterface.slotDesc;
        frag: ^astInterface.fragmentForm;
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
     do findBody;
        body -> group[];
        (if group[]<>None then
            (astControl, 'private') -> betaGram.findAttribute -> theAst[];
            (if theAst[]<>None then
                (if theAst.symbol = betaGram.simpleDecl then
                    theAst[] -> theSimpleDecl[];
                    theSimpleDecl.getReferenceSpecification -> theReferenceSpecification[];
                    (if theReferenceSpecification.symbol = betagram.staticItem then
                        theReferenceSpecification[] -> theStaticItem[];
                        theStaticItem.getObjectSpecification -> theAst[];
                        (if theAst.kind = MPS.kinds.unExpanded then
                            theAst[] -> theUnExpanded[];
                            (if theUnExpanded.isSlot then
                                theUnExpanded.theSlot -> theSlotDesc[];
                                theSlotDesc.name -> group.findFragment -> frag[];
                                (if frag[]<>None then
                                    (if frag.category = betaGram.descriptorForm then
                                        frag.root[] -> theDescriptorForm[];
                                        theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                                        theObjectDescriptor.getMainPart -> theMainPart[];
                                        theMainPart.getAttributes -> theAttributes[];
                                     else
                                        failure;
                                    if);
                                 else
                                    failure;
                                if);
                             else
                                failure;
                            if);
                         else
                            failure;
                        if);
                     else
                        failure;
                    if);
                 else
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
     theAttributes[] -> privateAttributes;
  #);

createPrivateAttributes:
  (# failure:< object;
     group: ^astInterface.fragmentGroup;
     node: ^astInterface.beta.attributeDecl;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
     theStaticItem: ^astInterface.beta.staticItem;
     theUnExpanded: ^astInterface.unExpanded;
     theSlotDesc: ^astInterface.slotDesc;
     frag: ^astInterface.fragmentForm;
     theDescriptorForm: ^astInterface.beta.descriptorForm;
     theObjectDescriptor: ^astInterface.beta.objectDescriptor;
     theMainPart: ^astInterface.beta.mainPart;
     name: ^text;
     privateFrag: ^astInterface.fragmentForm;
  do body -> group[];
     (if group[]<>None then
         astControl.node[] -> node[];
         node.frag[] -> frag[];
         (betaGram.simpleDecl, frag[]) -> betaGram.newAst -> theSimpleDecl[];
         (frag[], 'private') -> betaGram.newNames -> theSimpleDecl.putNames;
         (betaGram.staticItem, frag[]) 
           -> betaGram.newAst -> theStaticItem[] 
           -> theSimpleDecl.putReferenceSpecification;
         (betaGram.objectDescriptor, frag[]) 
           -> betaGram.newUnExpanded  -> theUnExpanded[]
           -> theStaticItem.putObjectSpecification;
         frag[] -> betaGram.newSlot -> theSlotDesc[] -> theUnExpanded.theSlot;
         node[] -> betaGram.getName -> name[];
         'Private' -> name.append;
         name[] -> theSlotDesc.name;
         (node[], theSimpleDecl[]) -> betaGram.appendAttribute;
         betaGram[] -> MPS.newFragmentForm -> privateFrag[];
         name[] -> privateFrag.name;
         privateFrag[] -> group.fragmentList.addFragment;
         (privateFrag[], none) 
           -> betaGram.newDescriptorForm -> theDescriptorForm[]
           -> privateFrag.root[];
         theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
         theObjectDescriptor.getMainPart -> theMainPart[];
         theMainPart.getAttributes -> privateAttributes;
      else
         failure;
     if);
  #);

findBody:
  (# group: ^astInterface.fragmentGroup;
     theBody: ^astInterface.fragmentGroup;
     name, fullPath: ^text;
  do (astControl).frag.father -> group[];
     search: group.prop.scanProp
     (# 
        doProp::<
          (# 
          do (if true 
              //'BODY' -> prop.equalNCS
              //'MDBODY' -> prop.equalNCS then
                 scanParameters
                 (# doString::<
                      (# 
                      do s[] -> name[];
                         leave search;
                      #);
                 #);
             if);
          #);
     #);
     (if name[] = none then
         group.shortName -> name[];
         'Body' -> name.append;
         'BODY' -> group.prop.addProp
         (# 
         do name[] -> addString;
         #);
     if);
     name[] -> MPS.expandToFullPath -> fullPath[];
     fullPath[] -> MPS.safeOpen -> theBody[];
     (if theBody[] = None then
         fullPath[] -> MPS.top.newGroup -> theBody[];
         group.shortName -> theBody.originProperty;
     if);
     theBody[] -> body;
  #);

-- graphicalEditorPrivate: descriptor --
(# editorGenerator: [26] ^generateEditor;
   initEditorGenerator:
     (# 
     do (* &generateEditor (# do &interfaceObjectEditor[] -> we[] #)[] -> editorGenerator[1][]; *)
        &generateEditor (# do &windowitemEditor[] -> we[] #)[] -> editorGenerator[2][];
        (* &generateEditor (# do &separatorEditor[] -> we[] #)[] -> editorGenerator[3][]; *)
        &generateEditor (# do &canvasEditor[] -> we[] #)[] -> editorGenerator[4][];
        &generateEditor (# do &abstractScrollerEditor[] -> we[] #)[] -> editorGenerator[5][];
        &generateEditor (# do &scrollerEditor[] -> we[] #)[] -> editorGenerator[6][];
        &generateEditor (# do &textEditorEditor[] -> we[] #)[] -> editorGenerator[7][];
        &generateEditor (# do &controlEditor[] -> we[] #)[] -> editorGenerator[8][];
        &generateEditor (# do &buttonEditor[] -> we[] #)[] -> editorGenerator[9][];
        &generateEditor (# do &pushButtonEditor[] -> we[] #)[] -> editorGenerator[10][];
        &generateEditor (# do &iconButtonEditor[] -> we[] #)[] -> editorGenerator[11][];
        &generateEditor (# do &OptionButtonEditor[] -> we[] #)[] -> editorGenerator[12][];
        &generateEditor (# do &staticTextEditor[] -> we[] #)[] -> editorGenerator[13][];
        &generateEditor (# do &toggleButtonEditor[] -> we[] #)[] -> editorGenerator[14][];
        &generateEditor (# do &radioButtonEditor[] -> we[] #)[] -> editorGenerator[15][];
        &generateEditor (# do &checkBoxEditor[] -> we[] #)[] -> editorGenerator[16][];
        &generateEditor (# do &scrollbarEditor[] -> we[] #)[] -> editorGenerator[17][];
        &generateEditor (# do &editTextEditor[] -> we[] #)[] -> editorGenerator[18][];
        &generateEditor (# do &textFieldEditor[] -> we[] #)[] -> editorGenerator[19][];
        &generateEditor (# do &scrollListEditor[] -> we[] #)[] -> editorGenerator[20][];
        &generateEditor (# do &textScrollListEditor[] -> we[] #)[] -> editorGenerator[21][];
        (* &generateEditor (# do &windowEditor[] -> we[] #)[] -> editorGenerator[22][]; *)
        (* &generateEditor (# do &menuEditor[] -> we[] #)[] -> editorGenerator[23][]; *)
        (* &generateEditor (# do &menubarEditor[] -> we[] #)[] -> editorGenerator[24][]; *)
        (* &generateEditor (# do &menuitemEditor[] -> we[] #)[] -> editorGenerator[25][]; *)
       (* &generateEditor (# do &dynamicMenuitemEditor[] -> we[] #)[] -> editorGenerator[26][];*)
     #);
   
   names: [26] ^text;
   initNames:
     (# 
     do 'interfaceObject' -> names[1][];
        'windowitem' -> names[2][];
        'separator' -> names[3][];
        'canvas' -> names[4][];
        'abstractScroller' -> names[5][];
        'scroller' -> names[6][];
        'textEditor' -> names[7][];
        'control' -> names[8][];
        'button' -> names[9][];
        'pushButton' -> names[10][];
        'iconButton' -> names[11][];
        'menuButton' -> names[12][];
        'staticText' -> names[13][];
        'toggleButton' -> names[14][];
        'radioButton' -> names[15][];
        'checkBox' -> names[16][];
        'scrollbar' -> names[17][];
        'editText' -> names[18][];
        'textField' -> names[19][];
        'scrollList' -> names[20][];
        'textScrollList' -> names[21][];
        'window' -> names[22][];
        'menu' -> names[23][];
        'menubar' -> names[24][];
        'menuitem' -> names[25][];
        'dynamicMenuitem' -> names[26][];
     #);
   currentmode: ^text;
   currentId: @integer;
   currentType: ##windowItemEditor;
   lastTime: @integer;
   startUptime: @integer;
   currentCanvasEditor: ^canvasEditor;
   objectSpecificationList: @list
     (# element::< objectSpecification;
        findObjectType:
          (# ID: ^text;
             type: ##windowItemEditor;
          enter ID[]
          do l: scan
               (# 
               do (if current.ID[] -> ID.equalNCS//true then
                      current.type## -> type##;
                      leave l;
                  if);
               #);
          exit type##
          #);
     #);
   (* thePaletteEnv: @paletteEnv
    *      (# itemSelected::<
    *           (# 
    *           do type -> this(graphicalEditor).private.currentCanvasEditor.newEditor;
    *           #);
    *      #);
    *)
   contentsEditorObject: @canvas
     (# 
        open::<
          (#
          do true -> bindRight -> bindBottom;
             false -> border.visible;
          #);
     #);
   windowView: @canvas
     (# 
        titleBar: @staticText
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do true -> bindRight;
                  'Untitled' -> label;
                  center -> alignment;
                  ((2, 2), (width - 2, 20)) -> frame;
               #);
             eventHandler::
               (# 
                  onMouseDown::
                    (# 
                    do windowView.drag;
                    #);
               #);
          #);
        interior: @canvas
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do borderStyles.shadowIn -> border.style;
                  true -> border.visible;
                  ((6, 20), (width - 6, height - 6)) -> frame;
                  interior[] -> contentsEditorObject.open;
                  ((2, 2), (width - 14, height - 30)) -> contentsEditorObject.frame;
                  true -> bindRight;
                  true -> bindBottom;
               #);
          #);
        open::
          (# width, height: @integer;
          enter (width, height)
          do 
             (width + 16 -> width, height + 32 -> height) -> size;
             true -> border.visible;
             borderstyles.shadowOut -> border.style;
             (windowView[], width, height) -> titleBar.open;
             (windowView[], width, height) -> interior.open;
          #);
        eventHandler::
          (# 
             onMouseDown::
               (# 
               do (frame, false, false, true, true) -> father.defineRect -> frame;
               #);
          #);
     #);
   contentsEditor: @canvasEditor
     (# 
        mouseDown::<
          (# 
          do (* this(graphicalEditor).currentType -> newEditor; *)
             (if theEvent.doubleClick//true then
                 (* createAstEditor; *)
              else
                 this(graphicalEditor).private.selection.makeEmpty;
                 this(contentsEditor)[] -> currentCanvasEditor[];
             if);
             true -> done;
          #);
     #);
   
   selection: @list
     (# element::< windowItemEditor;
        makeEmpty:
          (# 
          do scan
             (# 
             do false -> current.selected;
             #);
             clear;
          #);
     #);
   initializing: @boolean;
   body: ^astInterface.fragmentGroup;
   theWalkingAnts: ^walkingAnts;
   
   theClassInfo: ^classInfo;
   
   theObjectMenu: @menu
     (# controlsItem: @menuItem
          (# 
             open::
               (#
               do 'Controls' -> name;
                  theControlPalette[] -> theControlsMenu.open;
                  theControlsMenu[] -> subMenu;
               #);
          #);
        viewsItem: @menuItem
          (# 
             open::
               (#
               do 'Views' -> name;
                  theViewsPalette[] -> theViewMenu.open;
                  theViewMenu[] -> subMenu;
               #);
          #);
        open::
          (# 
          do 'Objects' -> name;
             controlsItem.open;
             controlsItem[] -> append;
             viewsItem.open;
             viewsItem[] -> append;
          #);
     #);
   
   theControlsMenu: @paletteMenu
     (# 
        open::
          (# 
          do 'Controls' -> name;
             (pushButtonType, 'PushButton') -> addPaletteMenuItem;
             (menuButtonType, 'OptionButton') -> addPaletteMenuItem;
             (staticTextType, 'StaticText') -> addPaletteMenuItem;
             (iconButtonType, 'IconButton') -> addPaletteMenuItem;
             (radioButtonType, 'RadioButton') -> addPaletteMenuItem;
             (checkBoxType, 'CheckBox') -> addPaletteMenuItem;
             (scrollBarType, 'ScrollBar') -> addPaletteMenuItem;
             (editTextType, 'EditText') -> addPaletteMenuItem;
             theControlsMenu[] -> theObjectMenu.controlsItem.subMenu;
          #);
     #);
   theViewMenu: @paletteMenu
     (# 
        open::
          (# 
          do 'Views' -> name;
             (canvasType, 'Canvas') -> addPaletteMenuItem;
             (scrollerType, 'Scroller') -> addPaletteMenuItem;
             (textEditorType, 'TextEditor') -> addPaletteMenuItem;
             (textScrollListType, 'ScrollList') -> addPaletteMenuItem;
             (textFieldType, 'TextField') -> addPaletteMenuItem;
             (separatorType, 'Separator') -> addPaletteMenuItem;
             theViewMenu[] -> theObjectMenu.viewsItem.subMenu;
          #);
     #);
   theControlPalette: @controlPalette
     (# 
        mouseDownInItem::
          (# 
          do (name[], type) -> itemSelected;
          #);
     #);
   theViewsPalette: @viewPalette
     (# 
         
        mouseDownInItem::
          (# 
          do (name[], type) -> itemSelected;
          #);
     #);
#)

-- canvasEditorPrivate: descriptor --
(# privateAttributes: ^astInterface.beta.attributes;
   privateControl: @astController
     (# 
     #);
#)

-- windowitemEditorMousedown: doPart --
do (# r: @rectangle;
      width,height: @integer;
      dh,dv: @integer;
      h,v: @integer;
      doTop,doLeft,doBottom,doRight: @boolean;
   do inner mousedown;
      (if theEvent.doubleClick then
          showInfoDialog;
       else
          (if not done then
              theWindowItem.size -> (width,height);
              ((width div 5,1) -> max,10) -> min  -> dh;
              ((height div 5,1) -> max,10) -> min -> dv;
              
              theEvent.localPosition -> (h,v);
              (if (h <= dh) then 
                  true -> doLeft 
              if);
              (if (h >= (width - dh)) then
                  true -> doRight
              if);
              (if (v <= dv) then
                  true -> doTop
              if);
              (if (v >= (height - dv)) then 
                  true -> doBottom
              if);
              (if (doLeft or doBottom or doTop or doRight) then
                  (doLeft,doTop,doRight,doBottom) -> reConfigure;
               else
                  (true,true,true,true) -> reConfigure;
              if);
              this(windowItemEditor)[] -> owner.select;
          if);
      if);
   #);

-- canvasEditorMousedown: doPart --
do inner mouseDown;
   (*  (if not done then
    *        (if theEvent.shiftKey then
    *            false -> done;
    *         else
    *            currentType -> newEditor;
    *            true -> done;
    *        if);
    *    if);
    *)

-- graphicalEditorQuitItemOnSelect: doPart --
do Terminate;

-- graphicalEditorQuitItemOpen: doPart --
do 'Quit' -> name;

-- graphicalEditorFileMenuOpen: doPart --
do 'File' -> name;
   saveItem.open;
   saveItem[] -> append;
   quitItem.open;
   quitItem[] -> append;
   
   
-- canvasEditorLib: attributes --
select:
  (# theWindowItemEditor: ^windowItemEditor;
  enter theWindowItemEditor[]
  do (if not (theWindowItemEditor[] -> this(graphicalEditor).private.selection.has) then
         this(graphicalEditor).private.selection.makeEmpty;
         theWindowItemEditor[] -> this(graphicalEditor).private.selection.append;
         true -> theWindowItemEditor.selected;
     if);
  #);
generateOpen:
  (# node: ^astInterface.beta.attributeDecl;
     theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
  do astControl.node[] -> node[];
     findOpenDoPart -> theDoPart[];
     (if theDoPart[] = none then
         createOpenDopart -> theDoPart[];
     if);
     theDoPart.getImperatives -> oldImperatives[];
     (betaGram.imperatives, theDoPart.frag[]) -> betaGram.newAst -> theImperatives[];
     children.scan
     (# name: ^text;
        theImp: ^astInterface.beta.imp;
     do current.astControl.node[] -> betaGram.getName -> name[];
        (theDoPart.frag[], name[], current.isPrivateToOwner) 
          -> betaGram.newOpenStatement -> theImp[] -> theImperatives.smartAppend;
        current.astControl.node.guiInfo -> theImp.guiInfo;
     #);
     (if oldImperatives[]<>none then
         oldImperatives.iterate
         (# 
         do (if not current.hasGUIcomment then
                theDoPart.frag[] -> current.copy -> theImperatives.smartAppend;
            if);
         #);
     if);
     theImperatives[] -> theDoPart.putImperatives;
  #);
scanAttributes:
  (# current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  do astControl.node[] -> betaGram.getAttributes -> theAttributes[];
     theAttributes.iterate
     (# 
     do current[] -> this(scanAttributes).current[];
        inner scanAttributes;
     #);
     (if private.privateAttributes[] <> none then
         private.privateAttributes.iterate
         (# 
         do current[] -> this(scanAttributes).current[];
            inner scanAttributes;
         #);
     if);
  #);

-- windowitemEditorSelected: doPart --
do isSelected -> private.selected;
   (if isSelected then
       (# r: ^rectangle;
       do owner.theWindowItem[] 
            -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
          &rectangle[] -> r[];
          theWindowItem.frame -> r;
          (-1, -1) -> r.inset;
          r[] -> this(graphicalEditor).private.theWalkingAnts.start;
       #);
    else
       this(graphicalEditor).private.theWalkingAnts.stop;
   if);
   inner selected;

-- canvasEditorSelected: doPart --
do (if isSelected then
       this(canvasEditor)[] -> currentCanvasEditor;
    else
       (* none -> currentCanvasEditor; *)
   if);


-- GraphicalEditorInit: doPart --
do (# data: ^windowItemData;
      prop: ^propertyList;
      ID: @integer;
      width, height: @integer;
   do node[] -> astControl.init;
      node.guiInfo -> ID;
      ID -> theObjectStore.get -> data[];
      data.size ->  initialize;
      findPrivateAttributes;
      (none, node[], data[]) -> private.contentsEditor.init;
      private.contentsEditor[] -> currentCanvasEditor;
     
      inner;
   #);

-- IBwindowitemEditorapplyObjectData: doPart --
do (# r: @rectangle;
   do data.position -> r.topLeft;
      data.size -> r.size;
      r -> theWindowItem.frame;
   #);
   data.bindLeft -> theWindowItem.bindLeft;
   data.bindRight -> theWindowItem.bindRight;
   data.bindTop -> theWindowItem.bindTop;
   data.bindBottom -> theWindowItem.bindBottom;
  (* data.visible -> theWindowItem.visible;
   data.hilite -> theWindowItem.hilite;
   data.enabled -> theWindowItem.enabled; *)
   data.borderStyle -> theWindowItem.border.style;
   data.borderVisible -> theWindowItem.border.visible;
   inner;

-- IBcanvasEditorapplyObjectData: doPart --
do inner;

-- IBbuttonApplyObjectData: doPart --
do data.label[] -> theWindowItem.label;
   (* Not implemented !!! *)
   inner;

-- IBiconButtonapplyObjectData: doPart --
do inner; 
   (* Not implemented !!! *)

-- IBoptionButtonapplyObjectData: doPart --
do inner;
   (* Not implemented !!! *)
   
-- IBtoggleButtonapplyObjectData: doPart --
do data.state -> theWindowItem.state;
   inner;

-- IBscrollBarapplyObjectData: doPart --
do data.scrollAmount -> theWindowItem.scrollAmount;
   data.pageScrollAmount -> theWindowItem.pageScrollAmount;
   data.maxValue  -> theWindowItem.maxValue;
   data.value -> theWindowItem.value;
   inner;
-- IBeditTextapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;


-- IBscrollListapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;

-- IBtextScrollListapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;

-- WindowitemEditorAstControlReplaced: doPart --
do (* Nothing *)

-- GraphicalEditorAstControlReplaced: doPart --
do (* Nothing *)
   
-- graphicalEditorSaveItemOnSelect: doPart --
do (# group: ^astInterface.fragmentGroup;
   do astControl.node.frag.father -> group[];
      group.save;
      (if body<>none then
         (body).save;
      if);
      save: (# theFile: @file;
            do 
               'guifile.gui' -> theFile.name;
               theFile.openWrite;
               theFile[] -> theObjectStore.write;
               theFile.close;
            #);
   #);

-- graphicalEditorSaveItemOpen: doPart --
do 'Save' -> name;
-- GraphicalEditorWindowItemEditorEditAttributes: doPart --
do (# theEditor: ^astEditor;
   do &scriptEditor[] -> theEditor[];
      astControl.node[] -> theEditor.init;
      (* true -> theEditor.readOnly; *)
   #);

-- GraphicalEditorWindowItemEditorShowInfoDialog: doPart --
do (if infoDialog[]<>none then
       infoDialog.updateFields;
       infoDialog.bringToFront;
       infoDialog.show;
    else
       &infoDialogType[] -> infoDialog[];
       infoDialog.open;
       this(windowItemEditor)[] -> infoDialog.editor[];
       infoDialog.updateFields;
       infoDialog.show;
   if);
   

-- GraphicalEditorWindowItemEditorShowCodeDialog: doPart --
do (if codeDialog[]//none then
       &codeDialogType[] -> codeDialog[];
       codeDialog.open;
       this(windowItemEditor)[] -> codeDialog.editor[];
    else
       codeDialog.bringToFront;
       codeDialog.show;
   if);
   codeDialog.updateFields;

-- GraphicalEditorWindowItemEditorEditVirutal: doPart --
do (# theAttribute, theVirtual, theEventHandler: ^astInterface.beta.attributeDecl;
      theEditor: ^astEditor;
      astToEdit: ^astInterface.AST;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
      theActionPart: ^astInterface.beta.actionPart;
      theUnExpanded: ^astInterface.unExpanded;
      theSlot: ^astInterface.slotDesc;
      slotName: ^text;
      doPartFrag: ^astInterface.fragmentForm;
      group: ^astInterface.fragmentGroup;
      theAst: ^astInterface.AST;
      
   do astControl.node[] -> theAttribute[];
      name[] -> findVirtual -> theVirtual[];
      (if theVirtual[] = none then
          name[] -> createVirtual -> theVirtual[];
          (if isPrivateToWindow then
              theVirtual[] -> astToEdit[];
           else
              theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
              theObjectDescriptor.getMainPart -> theMainPart[];
              theMainPart.getActionPart -> theActionPart[];
              theAttribute[] -> betaGram.getName -> slotName[];
              name[] -> slotName.append;
              (theAttribute.frag[], slotName[]) 
                -> betaGram.newSlotDoPart -> theActionPart.putDoPartOpt;
              
              slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
              body -> group[];
              doPartFrag[] -> group.fragmentList.addFragment;
              doPartFrag.root[] -> astToEdit[];
          if);
          astControl.prepareUpdate;
          astControl.change;
       else
          theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getActionPart -> theActionPart[];
          theActionPart.getDoPartOpt -> theAst[];
          (if theAst.kind = MPS.kinds.unExpanded then
              theAst[] -> theUnExpanded[];
              (if theUnExpanded.isSlot then
                  theUnExpanded.theSlot -> theSlot[];
                  body -> group[];
                  theSlot.name -> putLine;
                  theSlot.name -> group.findFragment -> doPartFrag[];
                  doPartFrag.root[] -> astToEdit[];
              if);
           else
              theVirtual[] -> astToEdit[];
          if);
      if);
      &scriptEditor[] -> theEditor[];
      astToEdit[] -> theEditor.init;
   #)
   
   
-- GraphicalEditorWindowItemEditorInit: doPart --
do (# 
   do 
      (if theAttribute[]<>none then
          theAttribute[] -> astControl.init;
      if);
      (if theWindowItem[] = None then
          createTheWindowItem;
       else
          &handleMouseDown[] -> theWindowItem.prependAction;
          &handleRefresh[] -> theWindowItem.appendAction;
          &handleFrameChanged[] -> theWindowItem.appendAction;
      if);
      (if owner[]<>none then
          this(windowitemEditor)[] -> owner.children.append;
      if);
      inner init;
   #);

-- canvasEditorInit: doPart --
do scanAttributes
   (# theEditor: ^windowItemEditor;
      ID: @integer;
      prop: ^propertyList;
      theData: ^windowItemData;
   do (if current.hasGUIcomment then
          current.guiInfo -> ID;
          ID -> theObjectStore.get -> theData[];
          (if theData[]//none then
           else
              this(graphicalEditor).private.editorGenerator[theData.type] -> theEditor[];
              (this(canvasEditor)[],current[], theData[]) -> theEditor.init;
          if);
      if);
   #);
   inner;


-- GraphicalEditorNew: doPart --
do (# frag: ^astInterface.fragmentForm;
      thePatternDecl: ^astInterface.beta.patternDecl;
      data: ^windowItemData;
      prop: ^propertyList;
   do (300, 200) -> initialize;
      theAttribute[] -> thePatternDecl[];
      canvasType -> theObjectStore.new -> data[];
      true -> data.bindLeft -> data.bindTop;
      (contents).size -> data.size;
      data.id -> thePatternDecl.guiInfo;
      thePatternDecl[] -> astControl.init;
      true -> privateAttributes;
      (none, thePatternDecl[], data[]) -> private.contentsEditor.init;
      private.contentsEditor[] -> currentCanvasEditor;
      private.contentsEditor.generateSimpleOpen;
   #);

-- graphicalEditorWindowItemEditorFindEditor: doPart --
do inner;
   
-- graphicalEditorCanvasEditorFindEditor: doPart --
do search: children.iterate
     (# theFrame: @rectangle;
     do (if current.elm[] <> ignoreEditor[] then
            current.elm.theWindowItem.frame -> theFrame;
            (if pt -> theFrame.containsPoint then
                theFrame.topLeft -> pt.subTract;
                (pt, ignoreEditor[]) -> current.elm.findEditor -> theEditor[];
                leave search;
            if);
        if);
     #);
   
   (if theEditor[] = None then
       this(canvasEditor)[] -> theEditor[];
   if);
   
   
-- GraphicalEditorWindowItemEditorNewData: doPart --
do type -> theObjectStore.new -> data[];
   (100, 100) -> data.size;
   true -> data.bindLeft;
   false -> data.bindRight;
   true -> data.bindTop;
   false -> data.bindBottom;
   true -> data.visible;
   true -> data.enabled;
   inner

-- GraphicalEditorCanvasEditorNewData: doPart --
do borderStyles.shadowIn -> data.borderStyle;
   true -> data.borderVisible;
   inner


-- GraphicalEditorAbstractScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorTextEditorEditorNewData: doPart --
do inner

-- GraphicalEditorControlEditorNewData: doPart --
do inner

-- GraphicalEditorButtonEditorNewData: doPart --
do 'Button' -> data.label[];
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];
   inner

-- GraphicalEditorPushButtonEditorNewData: doPart --
do 
   (60, 20) -> data.size;
   inner

-- GraphicalEditorIconButtonEditorNewData: doPart --
do 
   (40, 40) -> data.size;
   inner

-- GraphicalEditorOptionButtonEditorNewData: doPart --
do inner

-- GraphicalEditorStaticTextEditorNewData: doPart --
do inner

-- GraphicalEditorToggleButtonEditorNewData: doPart --
do (70,20) -> data.size;
   inner

-- GraphicalEditorCheckBoxEditorNewData: doPart --
do inner

-- GraphicalEditorScrollBarEditorNewData: doPart --
do (100,16) -> data.size;
   inner

-- GraphicalEditorEditTextEditorNewData: doPart --
do (100,22) -> data.size;
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];inner

-- GraphicalEditorTextFieldEditorNewData: doPart --
do inner

-- GraphicalEditorScrollListEditorNewData: doPart --
do inner

-- GraphicalEditorTextScrollListEditorNewData: doPart --
do inner
   
-- GraphicalEditorRadioButtonEditorNewData: doPart --
do inner;
   
   
-- GraphicalEditorEnterBody: doPart --
do group[] -> private.body[];

-- GraphicalEditorExitBody: doPart --
do private.body[] -> group[]

-- GraphicalEditorEnterPrivateAttributes: doPart --
do findBody;
   createPrivateAttributes;
   
-- GraphicalEditorExitPrivateAttributes: doPart --
do 

-- GraphicalEditorEnterPrivateDoParts: doPart --
do 

-- GraphicalEditorExitPrivateDoPart: doPart --
do 


-- GraphicalEditorWindowItemEditorDeleted: doPart --
do reEstablishNode;
   
-- GraphicalEditorWindowItemdEditorAncestorReplaced: doPart --
do reEstablishNode;
   
-- GraphicalEditorWindowItemEditorClose: doPart --
do inner close;
   astControl.release
-- GraphicalEditorCanvasEditorClose: doPart --
do inner;
   (if private.privateAttributes[] <> none then
       private.privateControl.release;
   if);
   children.scan
   (# 
   do current.close;
   #);
   
