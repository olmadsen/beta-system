ORIGIN '../graphicaleditor';
INCLUDE '~beta/guienv/v1.3/utils/guienvadds';
INCLUDE '~beta/guienv/v1.3/utils/track';
INCLUDE '~beta/sysutils/v1.4/time';
INCLUDE '~beta/sysutils/v1.4/objinterface';
INCLUDE '~beta/betaast/v4.9.1/gram';
INCLUDE '~beta/containers/v1.4/arrayContainer';
INCLUDE '~beta/interfacebuilder/v1.0/code/generate';
INCLUDE '~beta/interfacebuilder/v1.0/asteditor/asteditor';
INCLUDE '~beta/interfacebuilder/v1.0/palettes/palette';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/guienvstuff';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/walkingants';
INCLUDE '~beta/interfacebuilder/v1.0/guienvstuff/killtranslations';
INCLUDE '~beta/interfacebuilder/v1.0/mpsstuff/mpsutils';
INCLUDE '~beta/interfacebuilder/v1.0/dialogs/spacingdialog';
INCLUDE '../classinfo';

MDBODY default 'X11/graphicaleditor_X11body';


-- lib: attributes --
getMPS: objectPool.get
  (# type:: astInterface;
     init::
       (# 
       do exception
          (# 
          do 'No instance of astInterface in objectPool' -> msg.append;
          #);
       #);
  #);

getSpacingValues: objectPool.get
  (# type:: spacingValues;
  #);
-- editorEnvLib: attributes --

editorWalkingAnts: walkingAnts
  (# editor: ^graphicalEditor;
  #);

getWalkingAnts: objectPool.get
  (# type:: editorWalkingAnts;
     init::
       (# 
       do obj.init;
          50 -> obj.interval;
       #);
  #);
putPoint:
  (# x, y: @integer;
  enter (x, y)
  do '[' -> put;
     x -> putInt;
     ' ' -> put;
     y -> putInt;
     ']' -> put;
  #);

-- windowitemEditornew: doPart --
do (# theAttributeDecl: ^astInterface.beta.attributeDecl;
      className, instanceName: ^text;
      theAttributes: ^astInterface.beta.attributes;
   do  (if data[]//none then
           newData;
       if);
      (if astControl.node[]//None then
          (if owner.private.privateAttributes[] <> none then
              owner.private.privateAttributes[] -> theAttributes[]
           else
              owner.getMainNode -> betaGram.getAttributes -> theAttributes[];
          if);
          this(graphicalEditor).private.names[type][] -> className[];
          className.copy -> instanceName[];
          instanceName.length -> instanceName.setPos;
          data.id -> instanceName.putInt;
          (theAttributes.frag[], instanceName[],className[])
            -> betaGram.newSingularItem -> theAttributeDecl[];
          data.id -> theAttributeDecl.guiInfo;
          theAttributeDecl[] -> theAttributes.smartAppend;
          (if owner.private.privateAttributes[] <> none then
              owner.private.privateControl.prepareUpdate;
              owner.private.privateControl.change;
          if);
          theAttributeDecl[] -> astControl.init;
      if);
     
      
      createTheWindowItem;
      (if owner[]<>None then
          this(windowitemEditor)[] -> owner.children.append;
          owner.generateOpen;
      if);
   #);
   inner;
   generateSimpleOpen;
   owner.astControl.prepareUpdate;
   owner.astControl.change;
   
-- windowItemEditorLib: attributes --
delete:
  (# theAttributeDecl: ^astInterface.beta.attributeDecl;
     father: ^astInterface.beta.attributes;
     tmpAstControl: @astController;
  do selection.makeEmpty;
     astControl.node[] -> theAttributeDecl[];
     close;
     theAttributeDecl.father -> father[] -> tmpAstControl.init;
     theAttributeDecl.sonNo -> father.delete;
     tmpAstControl.prepareUpdate;
     tmpAstControl.change;
     tmpAstControl.release;
     this(windowitemEditor)[] -> owner.children.at -> owner.children.delete;
     theWindowItem.close;
     owner.generateOpen;
     
  #);


isPrivateToWindow: booleanValue
  (# 
  do not (astControl.node.frag[] = this(graphicalEditor).astControl.node.frag[]) -> value;
  #);

isPrivateToOwner: booleanValue
  (# 
  do (if owner[] = none then
         false -> value;
      else
         not (astControl.node.frag[] = owner.astControl.node.frag[]) -> value;
     if);
  #);

appendAttribute:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  enter theAttribute[]
  do getMainNode -> betaGram.getAttributes
     (# 
        failure:: exception
          (# 
          do 'No attributes in appendAttribute' -> msg.append;
          #);
     #) -> theAttributes[];
     theAttribute[] -> theAttributes.smartAppend;
     astControl.prepareUpdate;
     astControl.change;
  #);

findVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        astControl.node[] -> currentNode[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
        if);
        (if currentNode[] <> none then
             (currentNode[], name[]) -> betaGram.findAttribute-> theVirtual[];
        if);
     #);
  exit theVirtual[]
  #);

createVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
        theAttribute: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        astControl.node[] -> currentNode[] -> theAttribute[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
            (if currentNode[] = none then
                (theAttribute.frag[], 'eventHandler', none) -> betaGram.newVirtualBinding -> currentNode[];
                (theAttribute[], currentNode[]) -> betaGram.appendAttribute;
            if);
        if);
        (currentNode.frag[], name[], none) -> betaGram.newVirtualBinding -> theVirtual[];
        (currentNode[], theVirtual[]) -> betaGram.appendAttribute;
     #);
  exit theVirtual[]
  #);



reEstablishNode:
  (# gram: @grammar;
     theExpanded: ^astInterface.expanded;
  do this(graphicalEditor).private.contentsEditor.private.privateAttributes[] -> theExpanded[];
     l: gram.simpleDecl -> theExpanded.suffixWalkForProd
     (# 
     do (if current.hasGUIcomment then
            (if data.ID = current.guiInfo then
                current[] -> astControl.init;
                leave l;
            if);
        if);
     #);
  #);

createTheWindowItem:
  (# thisCanvasEditor: ^canvasEditor;
  do &windowItemType[] -> theWindowItem[];
     owner.getMainCanvas -> theWindowItem.open;
     theWindowItem.killTranslations;
     &handleMouseDown[] -> theWindowItem.prependAction;
     &handleRefresh[] -> theWindowItem.appendAction;
     &handleFrameChanged[] -> theWindowItem.appendAction;
     applyObjectData;
     (if this(windowItemEditor)## <= canvasEditor## then
         this(windowItemEditor)[] -> thisCanvasEditor[];
         thisCanvasEditor.children.scan
         (# 
         do current.createTheWindowItem; 
         #)
     if);
  #);
setIDcomment:
  (#
  do 
  #);

createOpenDopart:
  (# theDoPart: ^astInterface.beta.doPart;
     main: @boolean;
  enter main
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        slotName: ^text;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theUnExpanded: ^astInterface.unExpanded;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        isPrivate: @boolean;
     do (if main then
            getMainNode -> node[];
         else
            astControl.node[] -> node[];
        if);
        (node.frag[], 'open', none) -> betaGram.newVirtualBinding -> openDecl[];
        (node[], openDecl[]) -> betaGram.appendAttribute;
        openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
        (if isPrivateToWindow then
            node.frag[] -> betaGram.newDoPart ->  theDoPart[];
            (theObjectDescriptor[], theDoPart[]) -> betaGram.setDoPart;
         else
            node[] -> betaGram.getName -> slotName[];
            'Open' -> slotName.append;
            (node.frag[], slotName[]) -> betaGram.newSlotDoPart -> theUnExpanded[];
            (theObjectDescriptor[], theUnExpanded[]) -> betaGram.setDoPart;
            slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
            body -> group[];
            doPartFrag[] -> group.fragmentList.addFragment;
            doPartFrag.root[] -> theDoPart[];
        if);
     #);
  exit theDoPart[]
  #);

findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     main: @boolean;
  enter main
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theAst: ^astInterface.AST;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
     do (if main then
            getMainNode -> node[];
         else
            astControl.node[] -> node[];
        if);
        (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] <> none then
            openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
            theObjectDescriptor.getMainPart -> theMainPart[];
            theMainPart.getActionPart -> theActionPart[];
            theActionPart.getDoPartOpt -> theAst[];
            (if theAst.symbol = MPS.unExpanded then
                theAst[] -> theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot -> theSlot[];
                    body -> group[];
                    theSlot.name -> group.findFragment -> doPartFrag[];
                    (if doPartFrag[] <> None then
                        doPartFrag.root[] -> theDoPart[];
                    if);
                if);
             else
                theAst[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);

generateSimpleOpen:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
     node: ^astInterface.beta.attributeDecl;
     theImp: ^astInterface.beta.imp;
     theInnerImp: ^astInterface.beta.innerImp;
  do astControl.node[] -> node[];
     false -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] = none then
         false -> createOpenDopart -> theDoPart[];
     if);
     theDoPart.getImperatives -> oldImperatives[];
     (betaGram.imperatives, theDoPart.frag[]) 
       -> betaGram.newAst 
       -> theImperatives[] 
       -> theDoPart.putImperatives;
     (theDoPart.frag[], data.id) 
       -> betaGram.newInitFromResourceStatement 
       -> theImp[]
       -> theImperatives.smartAppend;
     0 -> theImp.guiInfo;
     (if node.symbol = betaGram.patternDecl then
         (betaGram.innerImp, theDoPart.frag[]) 
           -> betaGram.newAst 
           -> theInnerImp[]
           -> theImperatives.smartAppend;
         (betaGram.nameApl, theDoPart.frag[]) 
           -> betaGram.newOptional 
           -> theInnerImp.putNameAplOpt;
     if);
     (if oldImperatives[]<>none then
         oldImperatives.iterate
         (# 
         do theDoPart.frag[] -> current.copy -> theImperatives.smartAppend;
         #);
     if);
  #);

changeOwner:
  (# newOwner: ^canvasEditor;
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     theFather: ^astInterface.beta.attributes;
     currentOwner: ^canvasEditor;
  enter newOwner[]
  do 
     astControl.node[] -> theAttribute[];
     theAttribute.father -> theFather[];
     theAttribute.sonNo -> theFather.delete;
     (if newOwner.private.privateAttributes[] <> none then
         newOwner.private.privateAttributes[] -> theAttributes[];
      else
         newOwner.getMainNode -> betaGram.getAttributes -> theAttributes[];
     if);
     theAttribute[] -> theAttributes.smartAppend;
     owner[] -> currentOwner[];
     newOwner[] -> owner[];
     
     theWindowItem.close;
     None -> theWindowItem[];
     this(windowItemEditor)[] -> currentOwner.children.at -> currentOwner.children.delete;
     this(windowItemEditor)[] -> newOwner.children.append;
     createTheWindowItem;
     newOwner.generateOpen;
     currentOwner.generateOpen;
     newOwner.astControl.prepareUpdate;
     newOwner.astControl.change;
     currentOwner.astControl.prepareUpdate;
     currentOwner.astControl.change;
  #);


handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do theEvent[] -> this(windowItemEditor).mousedown;
  #);
handleFrameChanged: theWindowItem.frameChangedAction
  (# 
  do (if theWindowItem[]<>none then
         (if data[]<>none then
             theWindowItem.position -> data.position;
             theWindowItem.size -> data.size;
             (if private.selected then
                 restartWalkingAnts;
             if);
         if);
     if);
  #);
restartWalkingAnts:
  (#
  do stopWalkingAnts;
     startWalkingAnts;
  #);
stopWalkingAnts:
  (# 
  do this(graphicalEditor).private.theWalkingAnts.stop;
  #);
startWalkingAnts:
  (# r: ^rectangle
  do &rectangle[] -> r[];
     theWindowItem.frame -> r;
     (-1, -1) -> r.inset;
     owner.getMainCanvas -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
     r[] -> this(graphicalEditor).private.theWalkingAnts.start;
  #);
handleRefresh: theWindowItem.refreshAction
  (#
  #);
reConfigure:
  (# doLeft,doTop,doRight,doBottom: @boolean;
     r: @rectangle;
     newOwner: ^canvasEditor;
  enter (doLeft,doTop,doRight,doBottom)
  do (if private.selected then
         this(graphicalEditor).private.theWalkingAnts.stop;
     if);
     theWindowItem.frame -> r;
     (r[],  theWindowItem.father[], (contentsEditor).theWindowItem[]) 
       -> translateRect;
     (r,doLeft,doTop,doRight,doBottom) -> (contentsEditor).theWindowItem.defineRect -> r;
     (if doLeft and doTop and doRight and doBottom then
         (r.topLeft, this(windowItemEditor)[]) -> (contentsEditor).findEditor 
           -> newOwner[];
         (if newOwner[]<>owner[] then
             (r[], (contentsEditor).theWindowItem[], newowner.getMainCanvas)
               -> translateRect;
             r.topLeft -> data.position;
             r.size -> data.size;
             newOwner[] -> changeOwner;
          else
             (r.topLeft, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.topLeft;
             (r.bottomRight, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.bottomRight;
             r -> theWindowItem.frame;
         if);
      else
         (r.topLeft, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.topLeft;
         (r.bottomRight, (contentsEditor).theWindowItem[], theWindowItem.father[]) -> translate -> r.bottomRight;
         r -> theWindowItem.frame;
     if);
     (if private.selected then
         owner.getMainCanvas -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
         (-1, -1) -> r.inset;
         r[] -> this(graphicalEditor).private.theWalkingAnts.start;
     if);
  #);
resize:
  (# r: @rectangle;
  do theWindowItem.frame -> r;
     (r,false,false,true,true) -> theWindowItem.father.defineRect -> theWindowItem.frame;
  #);
drag:
  (# r: @rectangle;
  do theWindowItem.frame -> r;
     (r,true,true,true,true) -> theWindowItem.father.defineRect -> theWindowItem.frame;
  #);


-- windowitemEditorPrivate: descriptor --
(# selected: @boolean;
#)

-- canvasEditornew: doPart --
do (if theWindowItem[]<>contents then
       borderStyles.shadowIn -> theWindowItem.border.style;
       true -> theWindowItem.border.visible;
   if);
   inner;

-- abstractScrollerEditornew: doPart --
do false -> theWindowItem.border.visible;
   (# node: ^astInterface.beta.attributeDecl;
      theAttributes: ^astInterface.beta.attributes;
   do astControl.node[] -> node[];
      node[] -> betaGram.getAttributes -> theAttributes[];
      (node.frag[], 'contentsType', none) 
        -> betaGram.newVirtualBinding 
        -> theAttributes.smartAppend;
   #);
   inner;

-- scrollerEditornew: doPart --
do inner;

-- textEditorEditornew: doPart --
do inner;

-- controlEditornew: doPart --
do inner;

-- buttonEditornew: doPart --
do 
   inner;

-- pushButtonEditornew: doPart --
do inner;

-- iconButtonEditornew: doPart --
do 'nothing' -> data.theRaster[];
   inner;

-- optionButtonEditornew: doPart --
do inner;

-- staticTextEditornew: doPart --
do inner;

-- toggleButtonEditornew: doPart --
do 
   inner;

-- radioButtonEditornew: doPart --
do inner;

-- checkBoxEditornew: doPart --
do inner;

-- scrollbarEditornew: doPart --
do 
   inner;

-- editTextEditornew: doPart --
do 
   inner;

-- textFieldEditornew: doPart --
do inner;

-- scrollListEditornew: doPart --
do inner;

-- textScrollListEditornew: doPart --
do inner;

-- graphicalEditorSetcurrentMode: doPart --
do mode[] -> private.currentmode[];
   mode[] -> private.objectSpecificationList.findObjectType -> private.currentType##;

-- graphicalEditorGetcurrentMode: doPart --
do private.currentmode[] -> mode[];

-- graphicalEditorNewEditor: doPart --
do this(graphicalEditor).private.editorGenerator[type] -> theEditor[];
   (this(canvasEditor)[],type) -> theEditor.new;
   theEditor[] -> selection.set;


-- graphicalEditorOpen: doPart --
do (#
   do hide;
      'Graphical Objects' -> title;
      getMPS -> MPS[];
      getClassInfo -> private.theClassInfo[];
      MPS.grammarTable.beta[] -> betaGram[];
      getWalkingAnts -> private.theWalkingAnts[];
      (600, 500) -> size;
      private.theControlPalette.open;
      private.theViewsPalette.open;
      
      (* 
       * (contents, width, height) -> private.windowView.open;
       *)
      ('PushButton',pushButtonEditor##) -> addObjectSpecification;
      ('StaticText',staticTextEditor##) -> addObjectSpecification;
      ('TextScrollList',textScrollListEditor##) -> addObjectSpecification;
      ('Scroller',scrollerEditor##) -> addObjectSpecification;
      ('Canvas',canvasEditor##) -> addObjectSpecification;
      ('IconButton',iconButtonEditor##) -> addObjectSpecification;
      ('OptionButton',optionButtonEditor##) -> addObjectSpecification;
      ('RadioButton',radioButtonEditor##) -> addObjectSpecification;
      ('CheckBox',checkBoxEditor##) -> addObjectSpecification;
      ('ScrollBar',scrollbarEditor##) -> addObjectSpecification;
      ('EditText',editTextEditor##) -> addObjectSpecification;
      ('TextField',textFieldEditor##) -> addObjectSpecification;
      ('TextEditor',textEditorEditor##) -> addObjectSpecification;
      private.initEditorGenerator;
      private.initNames;
      (*
       * private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
       *)
   #);

-- graphicalEditorClose: doPart --
do inner;
   selection.makeEmpty;
   private.contentsEditor.close;

-- graphicalEditorOnMouseDown: doPart --
do 
   
-- graphicalEditorLib: attributes --
itemSelected:
  (# name: ^text;
     type: @integer;
     firstItem: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (name[], type)
  do l: selection.scan
     (# 
     do current[] -> firstItem[];
        leave l;
     #);
     (if firstItem[] = none then
         type -> this(graphicalEditor).private.contentsEditor.newEditor;
      else
         (if firstItem## <= canvasEditor## then
             firstItem[] -> theCanvasEditor[];
             type -> theCanvasEditor.newEditor;
          else
             type -> firstItem.owner.newEditor;
         if);
     if);
  #);

scriptEditor: astEditor
  (# eventHandler::
       (# onAboutToClose::
            (# parseOK: @boolean;
            do (if dirty then
                   parse -> parseOK;
                   parseOK -> okToClose;
               if);
            #);
       #);
  #);

initialize:
  (# width, height: @integer;
  enter (width, height)
  do (*
      * (width, height) -> open;
      *)
     (contents, width, height) -> private.windowView.open;
     private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
  #);

generateEditor:
  (# we: ^windowItemEditor;
  do inner;
  exit we[]
  #);

contentsEditor:
  (# 
  exit private.contentsEditor[]
  #);

objectSpecification:
  (# ID: ^text;
     type: ##windowItemEditor;
  #);
addObjectSpecification:
  (# type: ##windowItemEditor;
     ID: ^text;
     spec: ^objectSpecification;
  enter (ID[],type##)
  do &objectSpecification[] -> spec[];
     ID[] -> spec.ID[];
     type## -> spec.type##;
     spec[] -> private.objectSpecificationList.append;
  #);
uniqueID:
  (# 
  do private.currentId + 1 -> private.currentId;
  exit private.currentId
  #);
currentType:
  (# 
  enter private.currentType##
  exit private.currentType##
  #);


translateRect:
  (# r: ^rectangle;
     from, to: ^windowItem;
  enter (r[], from[], to[])
  do (r.topLeft,from[], to[]) -> translate -> r.topLeft;
     (r.bottomRight, from[], to[]) -> translate -> r.bottomRight;
  #);
privateAttributes:
  (# theAttributes: ^astInterface.beta.attributes;
  enter (#
        enter theAttributes[]
        do theAttributes[] -> private.contentsEditor.private.privateAttributes[];
           theAttributes[] -> private.contentsEditor.private.privateControl.init;
        #)
  exit private.contentsEditor.private.privateAttributes[]
  #);
findPrivateAttributes:
  (# theAttributes: ^astInterface.beta.attributes;
     failure:< object;
  do (# theAst: ^astInterface.AST;
        group: ^astInterface.fragmentGroup;
        theSimpleDecl: ^astInterface.beta.simpleDecl;
        theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
        theStaticItem: ^astInterface.beta.staticItem;
        theUnExpanded: ^astInterface.unExpanded;
        theSlotDesc: ^astInterface.slotDesc;
        frag: ^astInterface.fragmentForm;
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
     do findBody;
        body -> group[];
        (if group[]<>None then
            (astControl, 'private') -> betaGram.findAttribute -> theAst[];
            (if theAst[]<>None then
                (if theAst.symbol = betaGram.simpleDecl then
                    theAst[] -> theSimpleDecl[];
                    theSimpleDecl.getReferenceSpecification -> theReferenceSpecification[];
                    (if theReferenceSpecification.symbol = betagram.staticItem then
                        theReferenceSpecification[] -> theStaticItem[];
                        theStaticItem.getObjectSpecification -> theAst[];
                        (if theAst.kind = MPS.kinds.unExpanded then
                            theAst[] -> theUnExpanded[];
                            (if theUnExpanded.isSlot then
                                theUnExpanded.theSlot -> theSlotDesc[];
                                theSlotDesc.name -> group.findFragment -> frag[];
                                (if frag[]<>None then
                                    (if frag.category = betaGram.descriptorForm then
                                        frag.root[] -> theDescriptorForm[];
                                        theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                                        theObjectDescriptor.getMainPart -> theMainPart[];
                                        theMainPart.getAttributes -> theAttributes[];
                                     else
                                        failure;
                                    if);
                                 else
                                    failure;
                                if);
                             else
                                failure;
                            if);
                         else
                            failure;
                        if);
                     else
                        failure;
                    if);
                 else
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
     theAttributes[] -> privateAttributes;
  #);

createPrivateAttributes:
  (# failure:< object;
     group: ^astInterface.fragmentGroup;
     node: ^astInterface.beta.attributeDecl;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
     theStaticItem: ^astInterface.beta.staticItem;
     theUnExpanded: ^astInterface.unExpanded;
     theSlotDesc: ^astInterface.slotDesc;
     frag: ^astInterface.fragmentForm;
     theDescriptorForm: ^astInterface.beta.descriptorForm;
     theObjectDescriptor: ^astInterface.beta.objectDescriptor;
     theMainPart: ^astInterface.beta.mainPart;
     name: ^text;
     privateFrag: ^astInterface.fragmentForm;
  do body -> group[];
     (if group[]<>None then
         astControl.node[] -> node[];
         node.frag[] -> frag[];
         (betaGram.simpleDecl, frag[]) -> betaGram.newAst -> theSimpleDecl[];
         (frag[], 'private') -> betaGram.newNames -> theSimpleDecl.putNames;
         (betaGram.staticItem, frag[]) 
           -> betaGram.newAst -> theStaticItem[] 
           -> theSimpleDecl.putReferenceSpecification;
         (betaGram.objectDescriptor, frag[]) 
           -> betaGram.newUnExpanded  -> theUnExpanded[]
           -> theStaticItem.putObjectSpecification;
         frag[] -> betaGram.newSlot -> theSlotDesc[] -> theUnExpanded.theSlot;
         node[] -> betaGram.getName -> name[];
         'Private' -> name.append;
         name[] -> theSlotDesc.name;
         (node[], theSimpleDecl[]) -> betaGram.appendAttribute;
         betaGram[] -> MPS.newFragmentForm -> privateFrag[];
         name[] -> privateFrag.name;
         privateFrag[] -> group.fragmentList.addFragment;
         (privateFrag[], none) 
           -> betaGram.newDescriptorForm -> theDescriptorForm[]
           -> privateFrag.root[];
         theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
         theObjectDescriptor.getMainPart -> theMainPart[];
         theMainPart.getAttributes -> privateAttributes;
      else
         failure;
     if);
  #);

findBody:
  (# group: ^astInterface.fragmentGroup;
     theBody: ^astInterface.fragmentGroup;
     name, fullPath: ^text;
  do (astControl).frag.father -> group[];
     search: group.prop.scanProp
     (# 
        doProp::<
          (# 
          do (if true 
              //'BODY' -> prop.equalNCS
              //'MDBODY' -> prop.equalNCS then
                 scanParameters
                 (# doString::<
                      (# 
                      do s[] -> name[];
                         leave search;
                      #);
                 #);
             if);
          #);
     #);
     (if name[] = none then
         group.shortName -> name[];
         'body' -> name.append;
         'BODY' -> group.prop.addProp
         (# 
         do name[] -> addString;
         #);
     if);
     name[] -> MPS.expandToFullPath -> fullPath[];
     fullPath[] -> MPS.safeOpen -> theBody[];
     (if theBody[] = None then
         fullPath[] -> MPS.top.newGroup -> theBody[];
         group.shortName -> theBody.originProperty;
     if);
     theBody[] -> body;
     true -> theBody.changed;
  #);

-- graphicalEditorPrivate: descriptor --
(# editorGenerator: [26] ^generateEditor;
   initEditorGenerator:
     (# 
     do (* &generateEditor (# do &interfaceObjectEditor[] -> we[] #)[] -> editorGenerator[1][]; *)
        &generateEditor (# do &windowitemEditor[] -> we[] #)[] -> editorGenerator[2][];
        &generateEditor (# do &separatorEditor[] -> we[] #)[] -> editorGenerator[3][];
        &generateEditor (# do &canvasEditor[] -> we[] #)[] -> editorGenerator[4][];
        &generateEditor (# do &abstractScrollerEditor[] -> we[] #)[] -> editorGenerator[5][];
        &generateEditor (# do &scrollerEditor[] -> we[] #)[] -> editorGenerator[6][];
        &generateEditor (# do &textEditorEditor[] -> we[] #)[] -> editorGenerator[7][];
        &generateEditor (# do &controlEditor[] -> we[] #)[] -> editorGenerator[8][];
        &generateEditor (# do &buttonEditor[] -> we[] #)[] -> editorGenerator[9][];
        &generateEditor (# do &pushButtonEditor[] -> we[] #)[] -> editorGenerator[10][];
        &generateEditor (# do &iconButtonEditor[] -> we[] #)[] -> editorGenerator[11][];
        &generateEditor (# do &OptionButtonEditor[] -> we[] #)[] -> editorGenerator[12][];
        &generateEditor (# do &staticTextEditor[] -> we[] #)[] -> editorGenerator[13][];
        &generateEditor (# do &toggleButtonEditor[] -> we[] #)[] -> editorGenerator[14][];
        &generateEditor (# do &radioButtonEditor[] -> we[] #)[] -> editorGenerator[15][];
        &generateEditor (# do &checkBoxEditor[] -> we[] #)[] -> editorGenerator[16][];
        &generateEditor (# do &scrollbarEditor[] -> we[] #)[] -> editorGenerator[17][];
        &generateEditor (# do &editTextEditor[] -> we[] #)[] -> editorGenerator[18][];
        &generateEditor (# do &textFieldEditor[] -> we[] #)[] -> editorGenerator[19][];
        &generateEditor (# do &scrollListEditor[] -> we[] #)[] -> editorGenerator[20][];
        &generateEditor (# do &textScrollListEditor[] -> we[] #)[] -> editorGenerator[21][];
        (* &generateEditor (# do &windowEditor[] -> we[] #)[] -> editorGenerator[22][]; *)
        (* &generateEditor (# do &menuEditor[] -> we[] #)[] -> editorGenerator[23][]; *)
        (* &generateEditor (# do &menubarEditor[] -> we[] #)[] -> editorGenerator[24][]; *)
        (* &generateEditor (# do &menuitemEditor[] -> we[] #)[] -> editorGenerator[25][]; *)
       (* &generateEditor (# do &dynamicMenuitemEditor[] -> we[] #)[] -> editorGenerator[26][];*)
     #);
   
   names: [26] ^text;
   initNames:
     (# 
     do 'interfaceObject' -> names[1][];
        'windowitem' -> names[2][];
        'separator' -> names[3][];
        'canvas' -> names[4][];
        'abstractScroller' -> names[5][];
        'scroller' -> names[6][];
        'textEditor' -> names[7][];
        'control' -> names[8][];
        'button' -> names[9][];
        'pushButton' -> names[10][];
        'iconButton' -> names[11][];
        'menuButton' -> names[12][];
        'staticText' -> names[13][];
        'toggleButton' -> names[14][];
        'radioButton' -> names[15][];
        'checkBox' -> names[16][];
        'scrollbar' -> names[17][];
        'editText' -> names[18][];
        'textField' -> names[19][];
        'scrollList' -> names[20][];
        'textScrollList' -> names[21][];
        'window' -> names[22][];
        'menu' -> names[23][];
        'menubar' -> names[24][];
        'menuitem' -> names[25][];
        'dynamicMenuitem' -> names[26][];
     #);
   currentmode: ^text;
   currentId: @integer;
   currentType: ##windowItemEditor;
   lastTime: @integer;
   startUptime: @integer;
   objectSpecificationList: @list
     (# element::< objectSpecification;
        findObjectType:
          (# ID: ^text;
             type: ##windowItemEditor;
          enter ID[]
          do l: scan
               (# 
               do (if current.ID[] -> ID.equalNCS//true then
                      current.type## -> type##;
                      leave l;
                  if);
               #);
          exit type##
          #);
     #);
   
   contentsEditorObject: @canvas
     (# 
        open::<
          (#
          do true -> bindRight -> bindBottom;
             false -> border.visible;
          #);
     #);
   windowView: @canvas
     (# 
        titleBar: @staticText
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do true -> bindRight;
                  'Untitled' -> label;
                  center -> alignment;
                  ((2, 2), (width - 2, 20)) -> frame;
               #);
             eventHandler::
               (# 
                  onMouseDown::
                    (# 
                    do windowView.drag;
                    #);
               #);
          #);
        interior: @canvas
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do borderStyles.shadowIn -> border.style;
                  true -> border.visible;
                  ((6, 20), (width - 6, height - 6)) -> frame;
                  interior[] -> contentsEditorObject.open;
                  ((2, 2), (width - 14, height - 30)) -> contentsEditorObject.frame;
                  true -> bindRight;
                  true -> bindBottom;
               #);
          #);
        open::
          (# width, height: @integer;
          enter (width, height)
          do hide;
             (100, 10) -> position;
             (width + 16 -> width, height + 32 -> height) -> size;
             true -> border.visible;
             borderstyles.shadowOut -> border.style;
             (windowView[], width, height) -> titleBar.open;
             (windowView[], width, height) -> interior.open;
             show;
          #);
        eventHandler::
          (# 
             onMouseDown::
               (# 
               do (frame, false, false, true, true) -> father.defineRect -> frame;
               #);
          #);
     #);
   contentsEditor: @canvasEditor
     (# 
        mouseDown::<
          (# 
          do (* this(graphicalEditor).currentType -> newEditor; *)
             (if theEvent.doubleClick//true then
                 (* createAstEditor; *)
              else
                 selection.makeEmpty;
             if);
             true -> done;
          #);
     #);
   
   selection: @list
     (# element::< windowItemEditor;
        makeEmpty:
          (# 
          do scan
             (# 
             do false -> current.selected;
             #);
             clear;
          #);
     #);
   initializing: @boolean;
   body: ^astInterface.fragmentGroup;
   theWalkingAnts: ^editorWalkingAnts;
   
   theClassInfo: ^classInfo;
   
   
   theControlPalette: @controlPalette
     (# 
        mouseDownInItem::
          (# 
          do (name[], type) -> itemSelected;
          #);
        open::
          (# 
          do (10, 10) -> position
          #);
     #);
   theViewsPalette: @viewPalette
     (# 
         
        mouseDownInItem::
          (# 
          do (name[], type) -> itemSelected;
          #);
        open::
          (# 
          do (10, 270) -> position;
          #);
     #);
#)

-- canvasEditorPrivate: descriptor --
(# privateAttributes: ^astInterface.beta.attributes;
   privateControl: @astController
     (# 
     #);
#)

-- windowitemEditorMousedown: doPart --
do (# r: @rectangle;
      width,height: @integer;
      dh,dv: @integer;
      h,v: @integer;
      doTop,doLeft,doBottom,doRight: @boolean;
   do inner mousedown;
      (if theEvent.doubleClick then
          (if theEvent.metaKey then
              showCodeDialog;
           else
              showInfoDialog;
          if);
       else
          (if not done then
              (if theEvent.shiftKey then
                  this(windowItemEditor)[] -> selection.add;
               else
                  15 -> theEvent.delay
                  (# 
                  do (if theEvent.buttonState = 2  then
                         theEvent.localPosition -> (h,v);
                         theWindowItem.size -> (width,height);
                         width div 3 -> dh;
                         height div 3 -> dv;
                         
                         (if (h <= dh) then 
                             true -> doLeft 
                         if);
                         (if (h >= (width - dh)) then
                             true -> doRight
                         if);
                         (if (v <= dv) then
                             true -> doTop
                         if);
                         (if (v >= (height - dv)) then 
                             true -> doBottom
                         if);
                         (if (doLeft or doBottom or doTop or doRight) then
                             (doLeft,doTop,doRight,doBottom) -> reConfigure;
                          else
                             width div 2 -> dh;
                             height div 2 -> dv;
                             
                             (if (h <= dh) then 
                                 true -> doLeft
                              else
                                 true -> doRight;
                             if);
                             (if (v <= dv) then
                                 true -> doTop
                              else
                                 true -> doBottom;
                             if);
                             (doLeft,doTop,doRight,doBottom) -> reConfigure;
                         if);
                      else
                         (true,true,true,true) -> reConfigure;
                     if);
                  #);
                  this(windowItemEditor)[] -> selection.set;
              if);
             
              (* theWindowItem.size -> (width,height);
               *                  ((width div 5,1) -> max,10) -> min  -> dh;
               *                  ((height div 5,1) -> max,10) -> min -> dv;
               *                  
               *                  theEvent.localPosition -> (h,v);
               *                  (if (h <= dh) then 
               *                      true -> doLeft 
               *                  if);
               *                  (if (h >= (width - dh)) then
               *                      true -> doRight
               *                  if);
               *                  (if (v <= dv) then
               *                      true -> doTop
               *                  if);
               *                  (if (v >= (height - dv)) then 
               *                      true -> doBottom
               *                  if);
               *                  (if (doLeft or doBottom or doTop or doRight) then
               *                      (doLeft,doTop,doRight,doBottom) -> reConfigure;
               *                   else
               *                      (true,true,true,true) -> reConfigure;
               *                  if);
               *                  this(windowItemEditor)[] -> owner.select;
               *)
          if);
      if);
   #);

-- canvasEditorMousedown: doPart --
do inner mouseDown;
   (*  (if not done then
    *        (if theEvent.shiftKey then
    *            false -> done;
    *         else
    *            currentType -> newEditor;
    *            true -> done;
    *        if);
    *    if);
    *)

   
-- canvasEditorLib: attributes --

generateOpen:
  (# node: ^astInterface.beta.attributeDecl;
     theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
     theImp: ^astInterface.beta.imp;
  do getMainNode -> node[];
     true -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] = none then
         true -> createOpenDopart -> theDoPart[];
     if);
     theDoPart.getImperatives -> oldImperatives[];
     (betaGram.imperatives, theDoPart.frag[]) -> betaGram.newAst -> theImperatives[];
     (theDoPart.frag[], data.id) 
       -> betaGram.newInitFromResourceStatement 
       -> theImp[]
       -> theImperatives.smartAppend;
     0 -> theImp.guiInfo;
     children.scan
     (# name: ^text;
        theImp: ^astInterface.beta.imp;
     do current.astControl.node[] -> betaGram.getName -> name[];
        (theDoPart.frag[], name[], current.isPrivateToOwner) 
          -> betaGram.newOpenStatement -> theImp[] -> theImperatives.smartAppend;
        current.astControl.node.guiInfo -> theImp.guiInfo;
     #);
     (if oldImperatives[]<>none then
         oldImperatives.iterate
         (# 
         do (if not current.hasGUIcomment then
                theDoPart.frag[] -> current.copy -> theImperatives.smartAppend;
            if);
         #);
     if);
     theImperatives[] -> theDoPart.putImperatives;
  #);
scanAttributes:
  (# current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  do getMainNode -> betaGram.getAttributes -> theAttributes[];
     theAttributes.iterate
     (# 
     do current[] -> this(scanAttributes).current[];
        inner scanAttributes;
     #);
     (if private.privateAttributes[] <> none then
         private.privateAttributes.iterate
         (# 
         do current[] -> this(scanAttributes).current[];
            inner scanAttributes;
         #);
     if);
  #);

-- windowitemEditorSelected: doPart --
do isSelected -> private.selected;
   (if isSelected then
       (# r: ^rectangle;
       do owner.getMainCanvas 
            -> this(graphicalEditor).private.theWalkingAnts.theCanvas[];
          &rectangle[] -> r[];
          theWindowItem.frame -> r;
          (-1, -1) -> r.inset;
          r[] -> this(graphicalEditor).private.theWalkingAnts.start;
       #);
    else
       this(graphicalEditor).private.theWalkingAnts.stop;
   if);
   inner selected;

-- canvasEditorSelected: doPart --
do 


-- GraphicalEditorInit: doPart --
do (# data: ^windowItemData;
      prop: ^propertyList;
      ID: @integer;
      width, height: @integer;
   do node[] -> astControl.init;
      true -> (node.frag.father).changed;
      node.guiInfo -> ID;
      ID -> theObjectStore.get -> data[];
      data.size ->  initialize;
      findPrivateAttributes;
      (none, node[], data[]) -> private.contentsEditor.init;
      show;
      inner init;
   #);

-- IBwindowitemEditorapplyObjectData: doPart --
do (# r: @rectangle;
   do data.position -> r.topLeft;
      data.size -> r.size;
      r -> theWindowItem.frame;
   #);
   data.bindLeft -> theWindowItem.bindLeft;
   data.bindRight -> theWindowItem.bindRight;
   data.bindTop -> theWindowItem.bindTop;
   data.bindBottom -> theWindowItem.bindBottom;
  (* data.visible -> theWindowItem.visible;
   data.hilite -> theWindowItem.hilite;
   data.enabled -> theWindowItem.enabled; *)
   data.borderStyle -> theWindowItem.border.style;
   data.borderVisible -> theWindowItem.border.visible;
   inner;

-- IBcanvasEditorapplyObjectData: doPart --
do inner;

-- IBbuttonApplyObjectData: doPart --
do data.label[] -> theWindowItem.label;
   (* Not implemented !!! *)
   inner;

-- IBiconButtonapplyObjectData: doPart --
do inner; 
   (* Not implemented !!! *)

-- IBoptionButtonapplyObjectData: doPart --
do inner;
   (* Not implemented !!! *)
   
-- IBtoggleButtonapplyObjectData: doPart --
do data.state -> theWindowItem.state;
   inner;

-- IBscrollBarapplyObjectData: doPart --
do data.scrollAmount -> theWindowItem.scrollAmount;
   data.pageScrollAmount -> theWindowItem.pageScrollAmount;
   data.maxValue  -> theWindowItem.maxValue;
   data.value -> theWindowItem.value;
   inner;
-- IBeditTextapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;


-- IBscrollListapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;

-- IBtextScrollListapplyObjectData: doPart --
do (* Not implemented !!! *)
   inner;

-- WindowitemEditorAstControlReplaced: doPart --
do (* nothing *)

-- GraphicalEditorAstControlReplaced: doPart --
do (* Nothing *)
   

-- GraphicalEditorWindowItemEditorEditAttributes: doPart --
do (# theEditor: ^astEditor;
   do &scriptEditor[] -> theEditor[];
      astControl.node[] -> theEditor.init;
      (* true -> theEditor.readOnly; *)
   #);

-- GraphicalEditorWindowItemEditorShowInfoDialog: doPart --
do (if infoDialog[]<>none then
       infoDialog.updateFields;
       infoDialog.bringToFront;
       infoDialog.show;
    else
       &infoDialogType[] -> infoDialog[];
       infoDialog.open;
       this(windowItemEditor)[] -> infoDialog.editor[];
       infoDialog.updateFields;
       infoDialog.show;
   if);
   

-- GraphicalEditorWindowItemEditorShowCodeDialog: doPart --
do (if codeDialog[]//none then
       &codeDialogType[] -> codeDialog[];
       codeDialog.open;
       this(windowItemEditor)[] -> codeDialog.editor[];
    else
       codeDialog.bringToFront;
       codeDialog.show;
   if);
   codeDialog.updateFields;

-- GraphicalEditorWindowItemEditorEditVirutal: doPart --
do (# theAttribute, theVirtual, theEventHandler: ^astInterface.beta.attributeDecl;
      theEditor: ^astEditor;
      astToEdit: ^astInterface.AST;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
      theActionPart: ^astInterface.beta.actionPart;
      theUnExpanded: ^astInterface.unExpanded;
      theSlot: ^astInterface.slotDesc;
      slotName: ^text;
      doPartFrag: ^astInterface.fragmentForm;
      group: ^astInterface.fragmentGroup;
      theAst: ^astInterface.AST;
      
   do astControl.node[] -> theAttribute[];
      name[] -> findVirtual -> theVirtual[];
      (if theVirtual[] = none then
          name[] -> createVirtual -> theVirtual[];
          (if isPrivateToWindow then
              theVirtual[] -> astToEdit[];
           else
              theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
              theObjectDescriptor.getMainPart -> theMainPart[];
              theMainPart.getActionPart -> theActionPart[];
              theAttribute[] -> betaGram.getName -> slotName[];
              name[] -> slotName.append;
              (theAttribute.frag[], slotName[]) 
                -> betaGram.newSlotDoPart -> theActionPart.putDoPartOpt;
              
              slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
              body -> group[];
              doPartFrag[] -> group.fragmentList.addFragment;
              doPartFrag.root[] -> astToEdit[];
          if);
          astControl.prepareUpdate;
          astControl.change;
       else
          theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getActionPart -> theActionPart[];
          theActionPart.getDoPartOpt -> theAst[];
          (if theAst.kind = MPS.kinds.unExpanded then
              theAst[] -> theUnExpanded[];
              (if theUnExpanded.isSlot then
                  theUnExpanded.theSlot -> theSlot[];
                  body -> group[];
                  theSlot.name -> group.findFragment -> doPartFrag[];
                  doPartFrag.root[] -> astToEdit[];
              if);
           else
              theVirtual[] -> astToEdit[];
          if);
      if);
      &scriptEditor[] -> theEditor[];
      astToEdit[] -> theEditor.init;
   #)
   
   
-- GraphicalEditorWindowItemEditorInit: doPart --
do (# 
   do 
      (if theAttribute[]<>none then
          theAttribute[] -> astControl.init;
      if);
      (if theWindowItem[] = None then
          createTheWindowItem;
       else
          &handleMouseDown[] -> theWindowItem.prependAction;
          &handleRefresh[] -> theWindowItem.appendAction;
          &handleFrameChanged[] -> theWindowItem.appendAction;
      if);
      (if owner[]<>none then
          this(windowitemEditor)[] -> owner.children.append;
      if);
      inner init;
   #);

-- canvasEditorInit: doPart --
do scanAttributes
   (# theEditor: ^windowItemEditor;
      ID: @integer;
      prop: ^propertyList;
      theData: ^windowItemData;
   do (if current.hasGUIcomment then
          current.guiInfo -> ID;
          ID -> theObjectStore.get -> theData[];
          (if theData[]//none then
           else
              this(graphicalEditor).private.editorGenerator[theData.type] -> theEditor[];
              (this(canvasEditor)[],current[], theData[]) -> theEditor.init;
          if);
      if);
   #);
   inner;


-- GraphicalEditorNew: doPart --
do (# frag: ^astInterface.fragmentForm;
      thePatternDecl: ^astInterface.beta.patternDecl;
      data: ^windowItemData;
      prop: ^propertyList;
   do (300, 200) -> initialize;
      true -> (theAttribute.frag.father).changed;
      theAttribute[] -> thePatternDecl[];
      canvasType -> theObjectStore.new -> data[];
      true -> data.bindLeft -> data.bindTop;
      (300, 200) -> data.size;
      data.id -> thePatternDecl.guiInfo;
      thePatternDecl[] -> astControl.init;
      true -> privateAttributes;
      (none, thePatternDecl[], data[]) -> private.contentsEditor.init;
      private.contentsEditor.generateSimpleOpen;
      show;
   #);

-- graphicalEditorWindowItemEditorFindEditor: doPart --
do inner;
   
-- graphicalEditorCanvasEditorFindEditor: doPart --
do search: children.iterate
     (# theFrame: @rectangle;
     do (if current.elm[] <> ignoreEditor[] then
            current.elm.theWindowItem.frame -> theFrame;
            (if pt -> theFrame.containsPoint then
                theFrame.topLeft -> pt.subTract;
                (pt, ignoreEditor[]) -> current.elm.findEditor -> theEditor[];
                leave search;
            if);
        if);
     #);
   
   (if theEditor[] = None then
       this(canvasEditor)[] -> theEditor[];
   if);
   
   
-- GraphicalEditorWindowItemEditorNewData: doPart --
do type -> theObjectStore.new -> data[];
   (100, 100) -> data.size;
   true -> data.bindLeft;
   false -> data.bindRight;
   true -> data.bindTop;
   false -> data.bindBottom;
   true -> data.visible;
   true -> data.enabled;
   inner

-- GraphicalEditorCanvasEditorNewData: doPart --
do borderStyles.shadowIn -> data.borderStyle;
   true -> data.borderVisible;
   inner


-- GraphicalEditorAbstractScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorTextEditorEditorNewData: doPart --
do inner

-- GraphicalEditorControlEditorNewData: doPart --
do inner

-- GraphicalEditorButtonEditorNewData: doPart --
do 'Button' -> data.label[];
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];
   inner

-- GraphicalEditorPushButtonEditorNewData: doPart --
do 
   (60, 20) -> data.size;
   inner

-- GraphicalEditorIconButtonEditorNewData: doPart --
do 
   (40, 40) -> data.size;
   inner

-- GraphicalEditorOptionButtonEditorNewData: doPart --
do inner

-- GraphicalEditorStaticTextEditorNewData: doPart --
do inner

-- GraphicalEditorToggleButtonEditorNewData: doPart --
do (70,20) -> data.size;
   inner

-- GraphicalEditorCheckBoxEditorNewData: doPart --
do inner

-- GraphicalEditorScrollBarEditorNewData: doPart --
do (100,16) -> data.size;
   inner

-- GraphicalEditorEditTextEditorNewData: doPart --
do (100,22) -> data.size;
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];inner

-- GraphicalEditorTextFieldEditorNewData: doPart --
do inner

-- GraphicalEditorScrollListEditorNewData: doPart --
do inner

-- GraphicalEditorTextScrollListEditorNewData: doPart --
do inner
   
-- GraphicalEditorRadioButtonEditorNewData: doPart --
do inner;
   
   
-- GraphicalEditorEnterBody: doPart --
do group[] -> private.body[];

-- GraphicalEditorExitBody: doPart --
do private.body[] -> group[]

-- GraphicalEditorEnterPrivateAttributes: doPart --
do findBody;
   createPrivateAttributes;
   
-- GraphicalEditorExitPrivateAttributes: doPart --
do 

-- GraphicalEditorEnterPrivateDoParts: doPart --
do 

-- GraphicalEditorExitPrivateDoPart: doPart --
do 


-- GraphicalEditorWindowItemEditorDeleted: doPart --
do 
   reEstablishNode;
   
-- GraphicalEditorWindowItemdEditorAncestorReplaced: doPart --
do
   reEstablishNode;
   
-- GraphicalEditorWindowItemEditorClose: doPart --
do inner close;
   astControl.release
-- GraphicalEditorCanvasEditorClose: doPart --
do inner;
   (if private.privateAttributes[] <> none then
       private.privateControl.release;
   if);
   children.scan
   (# 
   do current.close;
   #);
   
-- GraphicalEditorSelectionEmpty: doPart --
do private.selection.empty -> value;

-- GraphicalEditorSelectionDelete: doPart --
do private.selection.iterate
   (# 
   do current.elm.delete;
   #);

-- GraphicalEditorSelectionShowInfo: doPart --
do private.selection.iterate
   (# 
   do current.elm.showInfoDialog;
   #);

-- GraphicalEditorSelectionShowCode: doPart --
do private.selection.iterate
   (# 
   do current.elm.showCodeDialog;
   #);

-- GraphicalEditorSeparatorEditorNewData: doPart --
do separatorStyles.etchedIn -> data.style;
   inner;


-- SeparatorEditornew: doPart --
do inner;

-- IBSeparatorApplyObjectData: doPart --
do data.style -> theWindowItem.style;
   inner;

-- ScrollerEditorGetMainNode: doPart --
do (theNode[], 'contentsType') -> betaGram.findAttribute -> theNode[];
   inner;

-- ScrollerEditorGetMainCanvas: doPart --
do theWindowItem.contents[] -> theCanvas[];

-- GraphicalEditorSelectionAdd: doPart --
do (# okToAdd: @boolean;
   do (if private.theWalkingAnts.editor[] <> none then
          (if private.theWalkingAnts.editor[] <> this(GraphicalEditor)[] then
           private.theWalkingAnts.editor.selection.makeEmpty;
          if);
      if);
      (if not (editor[] -> member) then
          (if empty then
              true -> okToAdd
           else
              l: scan
                (# 
                do (current.owner[] = editor.owner[]) -> okToAdd;
                   leave l;
                #);
          if);
          (if okToAdd then
              editor[] -> private.selection.append;
              true -> editor.selected;
              this(graphicaleditor)[] -> private.theWalkingAnts.editor[];
           else
              system.beep;
          if);
      if);
      
   #);

-- GraphicalEditorSelectionSet: doPart --
do (if private.theWalkingAnts.editor[] <> none then
       (if private.theWalkingAnts.editor[] <> this(GraphicalEditor)[] then
           private.theWalkingAnts.editor.selection.makeEmpty;
       if);
   if);
   makeEmpty;
   editor[] -> private.selection.append;
   true -> editor.selected;
   this(graphicaleditor)[] -> private.theWalkingAnts.editor[];

-- GraphicalEditorSelectionRemove: doPart --
do (if editor[] -> member then
       editor[] -> private.selection.at -> private.selection.delete;
       false -> editor.selected;
       
   if);

-- GraphicalEditorSelectionMakeEmpty: doPart --
do 
   (if not empty then
       private.theWalkingAnts.stop;
       none -> private.theWalkingAnts.editor[];
       scan
       (# 
       do false -> current.selected;
       #);
       private.selection.clear;
   if);

-- GraphicalEditorSelectionMember: doPart --
do editor[] -> private.selection.has -> value;


-- GraphicalEditorSelectionScan: doPart --
do private.selection.iterate
   (# 
   do current.elm[] -> this(scan).current[];
      inner scan;
   #);
-- GraphicalEditorSelectionFitToContents: doPart --
do scan
   (# 
   do current.theWindowItem.preferredSize -> current.theWindowItem.size;   
   #);
   
-- GraphicalEditorSelectionAlignLeft: doPart --
do alignSetup
   (# 
   do (modelFrame.left - currentFrame.left, 0) -> current.theWindowItem.move;
   #);

-- GraphicalEditorSelectionAlignRight: doPart --
do alignSetup
   (# 
   do (modelFrame.right - currentFrame.right, 0) -> current.theWindowItem.move;
   #);

-- GraphicalEditorSelectionAlignTop: doPart --
do alignSetup
   (# 
   do (0, modelFrame.top - currentFrame.top) -> current.theWindowItem.move;
   #);

-- GraphicalEditorSelectionAlignBottom: doPart --
do alignSetup
   (# 
   do (0, modelFrame.bottom - currentFrame.bottom) -> current.theWindowItem.move;
   #);

-- GraphicalEditorSelectionAlignHorCenter: doPart --
do alignSetup
   (# cent, itsCent: @integer;
   do ((currentFrame.right - currentFrame.left) div 2) + currentFrame.left -> itsCent;
      ((modelFrame.right - modelFrame.left) div 2) + modelFrame.left -> cent;
      (cent - itsCent, 0) -> current.theWindowItem.move;
   #)
   
-- GraphicalEditorSelectionAlignVerCenter: doPart --
do alignSetup
   (# cent, itsCent: @integer;
   do ((currentFrame.bottom - currentFrame.top) div 2) + currentFrame.top -> itsCent;
      ((modelFrame.bottom - modelFrame.top) div 2) + modelFrame.top -> cent;
      (0, cent - itsCent) -> current.theWindowItem.move;
   #);

-- GraphicalEditorSelectionShowSpacingDialog: doPart --
do (# theWindow: @window
        (# theSpacingDialog: @spacingDialog
             (# accept::
                  (# 
                  do values[] -> alignspacing;
                     theWindow.close;
                     
                  #);
                cancel::
                  (# 
                  do theWindow.close;
                  #);
             #);
           open::
             (# 
             do 'Spacing' -> title;
                hide;
                (contents, values[]) -> theSpacingDialog.open;
             #);
        #);
      values: ^spacingValues;
   do getSpacingValues -> values[];
      theWindow.open;
      theWindow.showModal;
   #)

-- selectionLib: attributes --

stopAnts: 
  (# 
  do private.theWalkingAnts.stop;
  #);
startAnts: scan
  (# 
  do current.startWalkingAnts;
  #);

array: arrayContainer
  (# element::< windowItem;
     append:
       (# elm: ^Element;
       enter elm[]
       do (if Top//Capacity then capacityExtend if);
          Top + 1 -> Top;
          (elm[],Top) -> Put;
       #);
     iterate:
       (# Current: ^Element;
       do (for inx: Top repeat
               Inx -> Get -> Current[];
               Inner;
          for);
       #);
     sort:
       (#
       do top -> shellSort;
       #);
     top: @Integer;
  #);


sort:
  (# sortedarray: ^arraytype;
     arraytype:< array;
  do &arraytype[] -> sortedarray[];
     sortedarray.init;
     scan
     (#
     do current.theWindowitem[] -> sortedarray.append;
     #);
     sortedarray.sort;
  exit sortedarray[]
  #);
sorthorizontal: sort
  (# arraytype::<
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.h < rightpos.h -> value;
            #);
       #);
  #);
sortvertical: sort
  (# arraytype::<
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.v < rightpos.v -> value;
            #);
       #);
  #);

alignspacing:
  (# values: ^spacingValues;
     sorted: ^Array;
  enter values[]
  do stopAnts;
     (if (values.doWidth OR values.doHeight)//true then
         scan
         (# width, height: @integer;
         do current.theWindowItem.Size -> (width, height);
            (if values.doWidth//true then values.width -> width; if);
            (if values.doHeight//true then values.height -> height; if);
            (width, height) -> current.theWindowItem.Size;
         #);
     if);
     (if values.doVerticalDist then
         SortVertical -> sorted[];
         sorted.Scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Bottom + values.verticalDist -> curPos.v;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     (if values.doHorizontalDist then
         SortHorizontal -> sorted[];
         sorted.Iterate
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Right + values.horizontalDist -> curPos.h;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     startAnts;
  #);


alignSetup:
  (# first: @boolean;
     current: ^windowItemEditor;
     modelFrame: @rectangle;
     currentFrame: @rectangle;
  do stopAnts;
     true -> first;
     scan
     (# 
     do (if first then
            current.theWindowItem.frame -> modelFrame;
            false -> first;
         else
            current.theWindowItem.frame -> currentFrame;
            current[] -> this(alignSetup).current[];
            inner alignSetup;
        if);
     #);
     startAnts;
  #);
