ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/v1.4/utils/guienvadds';
INCLUDE '~beta/guienv/v1.4/utils/track';
INCLUDE '~beta/sysutils/v1.5/time';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/betaast/v5.1/gram';
INCLUDE '~beta/betaast/v5.1/betasematt';
INCLUDE '../../datastructures/sequence';
INCLUDE '../../datastructures/doublelinkedlist';
INCLUDE '../../dialogs/editinfo';
INCLUDE '../../code/generate';
INCLUDE '../../code/pattern';
INCLUDE '../../code/followsemanticlink';
INCLUDE '../../code/match';
INCLUDE '../../asteditor/asteditor';
INCLUDE '../../palettes/palette';
INCLUDE '~beta/guienv/v1.4/utils/guienvstuff';
INCLUDE '../../guienvstuff/killtranslations';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '../../dialogs/spacingdialog';
INCLUDE '../classinfo';
INCLUDE '../../dragmanager/dragmanager';
INCLUDE '../../buildermenu';

INCLUDE '~beta/guienv/v1.4/utils/prompts';
INCLUDE '../../resourcesupport/easyinterface';

MDBODY mac    'macintosh/graphicaleditor_macbody'
       ppcmac 'macintosh/graphicaleditor_macbody'
       nti 'winnt/graphicaleditor_ntibody'
       default 'X11/graphicaleditor_X11body';


-- InterfaceBuilderGraphicalEditorWindowMenubarOpen: doPart --
do this(graphicalEditor).private.theFileMenu.open;
   this(graphicalEditor).private.theFileMenu[] -> append;
   this(graphicalEditor).private.theEditMenu.open;
   this(graphicalEditor).private.theEditMenu[] -> append;
   this(graphicalEditor).private.theAlignMenu.open;
   this(graphicalEditor).private.theAlignMenu[] -> append;;
   
-- lib: attributes --

getSpacingValues: objectPool.get
  (# type:: spacingValues;
  #);

-- guienvLib: attributes --

putPoint:
  (# h, v: @integer;
  enter (h, v)
  do '[' -> put;
     h -> putInt;
     ' ' -> put;
     v -> putInt;
     ']' -> put;
  #);
putRect:
  (# r: ^rectangle;
  enter r[]
  do r.topLeft -> putPoint;
     ' ' -> put;
     r.bottomRight -> putPoint;
  #);

-- windowItemLib: attributes --

delay:
  (# startPt: @point;
  enter startPt
  do l: track
     (# 
        mouseMove::
          (# dh, dv: @integer;
          do curPt.h - startPt.h -> dh;
             curPt.v - startPt.v -> dv;
             (if (dh*2 > 4) or (dv*dv > 4) then
                 inner delay;
                 leave l;
             if);
          #);
     #);
  #);

-- windowitemEditornew: doPart --
do (# 
   do false -> inherited;
      (if data[] = none then
          type -> newData -> data[];
          type -> makeData -> defaultData[];
      if);
      (if node[] = None then
          newNode;
          node[] -> owner.appendAttribute;
      if);
      (if this(windowItemEditor)## <= textEditorEditor## then
          this(windowItemEditor)[] -> qua
          (# as:: canvasEditor;
          do true -> thisObj.private.locked;
          #);
      if);
      
      false -> createTheWindowItem;
      (if owner[]<>None then
          this(windowitemEditor)[] -> owner.appendChild;
          
          (* (# theDoPart: ^astInterface.beta.doPart;
           *        do owner.findOpenDoPart -> theDoPart[];
           *           (if theDoPart[] <> none then
           *               theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
           *           if);
           *        #);
           *)
      if);
      (* fixOpen; *)
      createOpen;
      (data[], true) -> changeData;
   #);
   inner;
   
   
-- windowItemEditorLib: attributes --

codeGuard:
  (# 
  do (if inherited then
         'Trying to change inherited code!' -> putLine;
      else
         INNER;
     if);
  #);

deleteImperative: codeGuard
  (# name: ^text;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.AST;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.imp;
     theImperatives: ^astInterface.beta.imperatives;
     oldElements: ^astInterface.astList;
     deleteInx: @integer;
  enter name[]
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> ' -> txt.append;
         name[] -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
         (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             &mps.astList[] -> oldElements[];
             oldElements.init;
             imp.sonNo -> deleteInx;
             imp[] -> oldElements.insert;
             deleteInx -> theImperatives.delete;
             (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
               -> theFragserver.notifyListElementsDeleted;
         if);
     if);
  #);

generateEvaluation:
  (# value: ^atom;
     frag: ^astInterface.fragmentForm;
     eval: ^astInterface.beta.evaluation;
  enter (frag[], value[])
  do (if value.type
      //textType then
         (frag[],(value.asTextAtom).value[])
           -> betaGram.newTextEvaluation -> eval[];
      //boolType then
         (frag[],(value.asBoolAtom).value)
           -> betaGram.newBoolEvaluation -> eval[];
      //intType then
         (frag[],(value.asIntAtom).value)
           -> betaGram.newIntEvaluation -> eval[];
     if);
  exit eval[]
  #);

changeImperative: codeGuard
  (# name: ^text;
     value: ^atom;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldEval, newEval: ^astInterface.beta.evaluation;
  enter (name[], value[])
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> ' -> txt.append;
         name[] -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
         (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (theDoPart.frag[], value[]) -> generateEvaluation  -> newEval[];
         (if imp[] <> none then
             imp.getEvaluation -> oldEval[];
             newEval[] -> imp.putEvaluation;
             (true, imp.frag[], oldEval[], newEval[])
               -> theFragServer.notifyAstReplaced;
          else
             (theDoPart.frag[], value[]) -> generateEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
             (true, theImperatives.frag[], theImperatives[], 1) 
               -> theFragServer.notifyListElementInserted;
             
         if);
     if);
  #);
generateImperative:
  (# theImperatives: ^astInterface.beta.imperatives;
     name: ^text;
     value: ^atom;
     eval: ^astInterface.beta.evaluation;
     imp: ^astInterface.beta.imp;
  enter (theImperatives[], name[], value[])
  do (theImperatives.frag[], value[]) -> generateEvaluation -> eval[];
     (theImperatives.frag[], name[], eval[]) -> betaGram.newAssignment -> imp[];
     (1, imp[]) -> theImperatives.insert;
  #);

changeData:
  (# newData: ^parameters;
     force: @boolean;
     oldValue: ^atom;
     defaultValue: ^atom;
     doChangePosition, doChangeSize: @boolean;
  enter (newData[], force)
  do newData.data.storage.scan
     (# name: ^text;
     do (if true
         //'x' -> current.key.equalNCS
         //'y' -> current.key.equalNCS then
            true -> doChangePosition;
         //'width' -> current.key.equalNCS
         //'height' -> current.key.equalNCS then
            true -> doChangeSize;
         //'ID' -> current.key.equalNCS then
         //'type' -> current.key.equalNCS then
         else
            current.key[] -> data.data.lookup -> oldValue[];
            (if (not force) AND (current.value[] -> oldValue.equal) then
             else
                current.key[] -> defaultData.data.lookup -> defaultValue[];
                (if true 
                 //'borderStyle' -> current.key.equalNCS then
                    'border.style' -> name[];
                 //'borderVisible' -> current.key.equalNCS then
                    'border.visible' -> name[];
                 else
                    current.key[] -> name[];
                if);
                
                (if (not (defaultValue[] = NONE)) AND (current.value[] -> defaultValue.equal) then
                    name[] -> deleteImperative;
                 else
                    (name[], current.value[]) -> changeImperative;
                if);
            if);
        if);
     #);
     (if doChangePosition then
         newData.position -> changePosition;
     if);
     (if doChangeSize then
         newData.size -> changeSize;
     if);
  #);

changePosition: codeGuard
  (# x, y: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
  enter (x, y)
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> position' -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
        (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             (theDoPart.frag[], x, y) -> betaGram.newPointEvaluation 
               -> imp.putEvaluation;
          else
             (theDoPart.frag[], x, y) -> betaGram.newPointEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
         if);
     if);
  #);
changeSize: codeGuard
  (# width, height: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation, oldEval, newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
  enter (width, height)
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> size' -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
        (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             imp.getEvaluation -> oldEval[];
             (theDoPart.frag[], width, height) -> betaGram.newPointEvaluation -> newEval[];
             newEval[] -> imp.putEvaluation;
             (true, imp.frag[], oldEval[], newEval[]) -> theFragServer.notifyAstreplaced;
          else
             (theDoPart.frag[], width, height) -> betaGram.newPointEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
             (true, theDoPart.frag[], theImperatives[], 1) -> theFragServer.notifyListElementInserted;
         if);
     if);
  #);

inherited:
  (#
  enter private.inherited
  exit private.inherited
  #);



dragOrResize:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
     width, height: @integer;
     minBorder: (# exit 1 #);
     maxBorder: (# exit 5 #);
     borderRatio: (# exit 5 #);
     borderWidth: @integer;
     borderHeight: @integer;
     h, v: @integer;
     doLeft, doTop, doRight, doBottom: @boolean;
  enter theEvent[]
  do theWindowItem.size -> (width, height);
     (((width div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderWidth;
     (((height div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderHeight;
     theEvent.localPosition -> (h, v);
     (if (h <= borderWidth) then 
         true -> doLeft 
     if);
     (if (h >= (width - borderWidth)) then
         true -> doRight
     if);
     (if (v <= borderHeight) then
         true -> doTop
     if);
     (if (v >= (height - borderHeight)) then 
         true -> doBottom
     if);
     (if doLeft or doTop or doRight or doBottom then
         (doLeft, doTop, doRight, doBottom) -> reConfigure;
      else
         theEvent[] -> selection.drag;
     if);
  #);

closeWindowItem:
  (# 
  do traverse
     (# forEach::<
          (# 
          do current[] -> qua
             (# as:: canvasEditor;
                quaError:: (# do true -> continue #);
             do (if thisObj.private.theReciever[] <> none then
                    thisObj.private.theReciever.delete;
                    none -> thisObj.private.theReciever[];
                if);
             #);
          #);
     #);
     theWindowItem.close;
     none -> theWindowItem[];
  #);

frame:
  (# r: ^rectangle;
  enter (# enter r[]
        do true -> dontHandleFrameChanged;
           (if theWindowItem[] = contentsEditorObject then
               r[] -> (contentsEditorObject).setRealFrame;
            else
               r -> theWindowItem.frame;
           if);
           false -> dontHandleFrameChanged;
        #)
  exit (# 
       do (if theWindowItem[] = contentsEditorObject then
              (contentsEditorObject).getRealFrame -> r[];
           else
              &rectangle[] -> r[];
              theWindowItem.frame -> r;
          if);
       exit r[]
       #)
  #);

createShadowTree:
  (# tree: ^shadowTree;
     thisCanvasEditor: ^canvasEditor;
  do &shadowTree[] -> tree[];
     node[] -> betaGram.getName -> tree.name[];
     data.copy -> tree.data[];
     defaultData[] -> tree.defaultData[];
     theClassData[] -> tree.theClassData[]; 
     tree.children.init;
     (if this(windowItemEditor)## <= canvasEditor## then
         this(windowItemEditor)[] -> thisCanvasEditor[];
         thisCanvasEditor.children.scan
         (# 
         do current.createShadowTree -> tree.children.append;
         #);
     if);
  exit tree[]
  #);

delete:
  (# father: ^astInterface.list;
     oldElements: ^astInterface.astList;
     deleteInx: @integer;
  do closeCodeDialog;
     closeWindowItem;
     node.father -> father[];
     node.sonNo -> deleteInx;
     deleteInx -> father.delete;
     &MPS.astList[] -> oldElements[];
     oldElements.init;
     node[] -> oldElements.insert;
     (true, father.frag[], father[], deleteInx, 1, oldElements[])
       -> theFragServer.notifyListElementsDeleted;
     this(windowitemEditor)[] -> owner.children.delete;
     node[] -> betaGram.getName -> owner.deleteOpenImp;
     false -> private.selected;
  #);
reInsert:
  (# theDoPart: ^astInterface.beta.doPart;
  do this(windowitemEditor)[] -> owner.children.append;
     createTheWindowItem;
     node[] -> owner.appendAttribute;
     forOpenStatements -> owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);


isPrivateToWindow: booleanValue
  (# 
  do not (node.frag[] = this(graphicalEditor).node.frag[]) -> value;
  #);

isPrivateToOwner: booleanValue
  (# 
  do (if owner[] = none then
         false -> value;
      else
         not (node.frag[] = owner.node.frag[]) -> value;
     if);
  #);

traverseCallback:
  (# current: ^windowItemEditor;
     continue: @boolean;
  enter current[]
  do true -> continue;
     inner;
  exit continue
  #);

recTraverse:
  (# callback: ^traverseCallback;
     editor: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (editor[], callback[])
  do (if editor[] -> callback then
         (if editor## <= canvasEditor## then
             editor[] -> theCanvasEditor[];
             theCanvasEditor.children.scan
             (# 
             do (current[], callback[]) -> &recTraverse;
             #);
         if);
     if);
  #);

traverse:
  (# forEach:< traverseCallback;
  do (this(windowItemEditor)[], &forEach[]) -> recTraverse;
  #);
     
closeCodeDialog:
  (# 
  do (if codeDialog[] <> none then
         codeDialog.close;
         none -> codeDialog[];
     if);
  #);
       

(* 
 * Code
 *)


(* fixOpen:
 *   (# theDoPart: ^astInterface.beta.doPart;
 *      newImps, oldImps: ^astInterface.beta.imperatives;
 *   do findOpenDopart -> theDoPart[];
 *      (if theDoPart[] <> none then
 *          theDoPart.frag[] -> createInitImps -> newImps[];
 *          theDoPart.getImperatives -> oldImps[];
 *          oldImps.iterate
 *          (# 
 *          do current[] -> newImps.append;
 *          #);
 *          newImps[] -> theDoPart.putImperatives;
 *          (true, theDoPart.frag[], oldImps[], newImps[])
 *               -> theFragServer.notifyAstReplaced;
 *      if);
 *   #);
 * 
 *)
appendToAttributes: codeGuard
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter (theAttributes[], theAttribute[])
  do (if theAttributes.empty then
         (# father: ^astInterface.expanded;
            sonNo: @integer;
            newAttributes: ^astInterface.beta.attributes;
         do theAttributes.father -> father[];
            theAttributes.sonNo -> sonNo;
            (father.frag[], theAttribute[])-> betaGram.newAttributes -> newAttributes[];
            (sonNo, newAttributes[]) -> father.put;
            (true, father.frag[], theAttributes[], newAttributes[])
              -> theFragServer.notifyAstReplaced;
         #);
      else
         theAttributes.noOfSons -> insertInx;
         theAttribute[] -> theAttributes.append;
         (true, theAttributes.frag[], theAttributes[], insertInx) 
           -> theFragServer.notifyListElementInserted;
     if)
  #);

updateOpen1:
  (# theDoPart: ^astInterface.beta.doPart;
  do forOpenStatements -> owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         node[] -> betaGram.getName -> owner.deleteOpenImp;
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);


prependOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
     do forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            (1, imp[]) -> theImperatives.insert;
            (true, theImperatives.frag[], theImperatives[], 1) 
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);

appendOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
        insertInx: @integer;
     do forOpenStatements  -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# 
              do current.sonNo -> insertInx;
              #);
            (if insertInx  = theImperatives.noOfsons then
                imp[] -> theImperatives.append;
             else
                (insertInx + 1, imp[]) -> theImperatives.insert;
            if);
            (true, theImperatives.frag[], theImperatives[], insertInx)
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);


deleteOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     name: ^text;
     failure:
       (# 
       do
       #);
  enter name[]
  do (# theImperatives: ^astInterface.beta.imperatives;
        deleteInx: @integer;
        oldElements: ^astInterface.astList;
     do forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            &MPS.astList[] -> oldElements[];
            oldElements.init;
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# theObjectDenotation: ^astInterface.beta.objectDenotation;
                 theNameApl: ^astInterface.beta.nameApl;
                 theText: ^text;
                 theAttributeDenotation: ^astInterface.ast;
                 theRemote: ^astInterface.beta.remote;
              do (if current.symbol = betaGram.objectDenotation then
                     current[] -> theObjectDenotation[];
                     theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
                     (if theAttributeDenotation.symbol = betaGram.remote then
                         theAttributeDenotation[] -> theRemote[];
                         theRemote.getNameApl -> theNameApl[];
                         theNameApl.getText -> theText[];
                         (if 'open' -> theText.equalNCS then
                             theRemote.getAttributeDenotation -> theAttributeDenotation[];
                             (if theAttributeDenotation.symbol
                              //betaGram.remote then
                                 theAttributeDenotation[] -> theRemote[];
                                 theRemote.getNameApl -> theNameApl[];
                              //betaGram.nameApl then
                                 theAttributeDenotation[] -> theNameApl[];
                              else
                                 none -> theNameApl[];
                             if);
                             (if theNameApl[] <> none then
                                 theNameApl.getText -> theText[];
                                 (if name[] -> theText.equalNCS then
                                     current.sonNo -> deleteInx;
                                     current[] -> oldElements.insert;
                                     leave l;
                                 if);
                             if);
                         if);
                     if);
                 if);
              #);
            (if deleteInx <> 0 then
                
                deleteInx -> theImperatives.delete;
                (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
                  -> theFragServer.notifyListElementsDeleted;
                
            if);
        if);
     #);
  #);

(* deleteOpenImp1:
 *   (# theDoPart: ^astInterface.beta.doPart;
 *      id: @integer;
 *      failure:
 *        (# 
 *        do
 *        #);
 *   enter id
 *   do (# theImperatives: ^astInterface.beta.imperatives;
 *         deleteInx: @integer;
 *         oldElements: ^astInterface.astList;
 *      do findOpenDoPart -> theDoPart[];
 *         (if theDoPart[] = none then
 *             failure;
 *          else
 *             &MPS.astList[] -> oldElements[];
 *             oldElements.init;
 *             theDoPart.getImperatives -> theImperatives[];
 *             l: theImperatives.iterate
 *               (# 
 *               do (if current.guiInfo = id then
 *                      current.sonNo -> deleteInx;
 *                      current[] -> oldElements.insert;
 *                      leave l;
 *                  if);
 *               #);
 *             (if deleteInx <> 0 then
 *                 
 *                 deleteInx -> theImperatives.delete;
 *                 (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
 *                   -> theFragServer.notifyListElementsDeleted;
 *                 
 *             if);
 *         if);
 *      #);
 *   #);
 *)




generateOpenImp:
  (# name: ^text;
     theImp: ^astInterface.beta.imp;
     frag: ^astInterface.fragmentForm;
  enter frag[]
  do node[] -> betaGram.getName -> name[];
     (frag[], name[], isPrivateToOwner) 
       -> betaGram.newOpenStatement -> theImp[];
  exit theImp[]
  #);
(* generateInitImp:
 *   (# frag: ^astInterface.fragmentForm;
 *      theImp: ^astInterface.beta.imp;
 *   enter frag[]
 *   do (frag[], theDocument.theParameterStore.shortName, data.id) 
 *        -> betaGram.newInitFromResourceStatement 
 *        -> theImp[];
 *      0 -> theImp.guiInfo;
 *   exit theImp[]
 *   #);
 *)
(* updateInitImp:
 *   (# theDoPart: ^astInterface.beta.doPart;
 *   do findOpenDoPart -> theDoPart[];
 *      (if theDoPart[] <> none then
 *          0 -> deleteOpenImp;
 *          theDoPart.frag[] -> generateInitImp -> prependOpenImp;
 *      if);
 *   #);
 *)
findVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
        if);
        (if currentNode[] <> none then
             (currentNode[], name[]) -> betaGram.findAttribute-> theVirtual[];
        if);
     #);
  exit theVirtual[]
  #);

appendAttributeToNode:
  (# node, theAttribute: ^astInterface.beta.attributeDecl;
  enter (node[], theAttribute[])
  do 
     (# theAttributes: ^astInterface.beta.attributes;
        insertInx: @integer;
     do node[] -> betaGram.getAttributes -> theAttributes[];
        (theAttributes[], theAttribute[]) -> appendToAttributes;
     #);
  #);

createVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
        theAttribute: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[] -> theAttribute[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
            (if currentNode[] = none then
                (theAttribute.frag[], 'eventHandler', none) -> betaGram.newVirtualBinding -> currentNode[];
                (theAttribute[], currentNode[]) -> appendAttributeToNode;
            if);
        if);
        (currentNode.frag[], name[], none) -> betaGram.newVirtualBinding -> theVirtual[];
        (currentNode[], theVirtual[]) -> appendAttributeToNode;
     #);
  exit theVirtual[]
  #);


handleAstReplaced:
  (# oldAst, newAst: ^astInterface.AST;
     succes: @boolean;
  enter (oldAst[], newAst[])
  do false -> succes;
     (if oldAst[] -> node.equal then
         newAst[] -> node[]; (* !!! Check for validitet *)
         true -> succes;
      else
         (if (node[], newAst[]) -> isAncestor then
             true -> succes;
          else
             (if (oldAst[], node[]) -> isAncestor then
                 (# theAttributes: ^astInterface.beta.attributes;
                    name: ^text;
                 do node[] -> betaGram.getName -> name[];
                    owner.getMainAttributes -> theAttributes[];
                    (if theAttributes[] <> none then
                        l: theAttributes.iterate
                        (# 
                        do (if current[] -> betaGram.getName -> name.equalNCS then
                               current[] -> node[];
                               true -> succes;
                               leave l;
                           if);
                        #);
                    if);
                 #);
              else
                 true -> succes;
             if);
         if);
     if);
  exit succes
  #);



createOpenDopart: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     main: @boolean;
  enter main
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        slotName: ^text;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theUnExpanded: ^astInterface.unExpanded;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        isPrivate: @boolean;
        frag: ^astInterface.fragmentForm;
     do (if main then
            getMainNode -> node[];
         else
            this(windowItemEditor).node[] -> node[];
        if);
        
        (node.frag[], 'open', none) -> betaGram.newVirtualBinding -> openDecl[];
        (node[], openDecl[]) -> appendAttributeToNode;
        openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
        (if isPrivateToWindow then
            node.frag[] -> betaGram.newDoPart ->  theDoPart[];
            (theObjectDescriptor[], theDoPart[]) -> betaGram.setDoPart; (* !!! NOTIFY !!! *)
         else
            node[] -> betaGram.getName -> slotName[];
            'Open' -> slotName.append;
            (node.frag[], slotName[]) -> betaGram.newSlotDoPart -> theUnExpanded[];
            (theObjectDescriptor[], theUnExpanded[]) -> betaGram.setDoPart;
            slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
            defaultBodyGroup -> group[];
            slotName[] -> group.findFragment -> frag[];
            (if frag[] <> none then
                frag.root[] -> theDoPart[];
             else
                doPartFrag[] -> group.fragmentList.addFragment;
                doPartFrag.root[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);


findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     purpose: @integer;
  enter purpose
  do (# node: ^astInterface.beta.attributeDecl;
     do (if purpose
         //forInitStatements then
            this(windowItemEditor).node[] -> node[];
         //forOpenStatements then
            getMainNode -> node[];
        if);
        (node[], defaultBodyGroup) -> realFindOpenDoPart -> theDoPart[];
     #);
  exit theDoPart[]
  #);

generateSimpleOpen: (* !!! NOTIFY !!! *)
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
     theImp: ^astInterface.beta.imp;
     theInnerImp: ^astInterface.beta.innerImp;
     gram: @grammar;
  do false -> createOpenDopart -> theDoPart[];
     (betaGram.imperatives, theDoPart.frag[]) 
       -> betaGram.newAst 
       -> theImperatives[] 
       -> theDoPart.putImperatives;
     (* (theDoPart.frag[], theDocument.theParameterStore.shortName, data.id) 
      *        -> betaGram.newInitFromResourceStatement 
      *        -> theImp[]
      *        -> theImperatives.smartAppend;
      *      0 -> theImp.guiInfo;
      *)
     (if node.symbol = betaGram.patternDecl then
         (betaGram.innerImp, theDoPart.frag[]) 
           -> betaGram.newAst 
           -> theInnerImp[]
           -> theImperatives.smartAppend;
         (gram.nameAplOpt, theDoPart.frag[]) 
           -> betaGram.makeOptional 
           -> theInnerImp.putNameAplOpt;
     if);
  #);

changeOwnerOld:
  (# newOwner: ^canvasEditor;
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     theFather: ^astInterface.beta.attributes;
     currentOwner: ^canvasEditor;
     oldDoPart: ^astInterface.beta.doPart;
     newDoPart: ^astInterface.beta.doPart;
     
  enter newOwner[]
  do 
     node[] -> theAttribute[];
     theAttribute.father -> theFather[];
     theAttribute.sonNo -> theFather.delete;
     theAttribute[] -> newOwner.appendAttribute;
     owner[] -> currentOwner[];
     newOwner[] -> owner[];
     
     closeWindowItem;
     None -> theWindowItem[];
     this(windowItemEditor)[] -> currentOwner.children.delete;
     this(windowItemEditor)[] -> newOwner.children.append;
     createTheWindowItem;
     
     forOpenStatements -> newOwner.findOpenDoPart -> newDoPart[];
     node[] -> betaGram.getName -> currentOwner.deleteOpenImp; 
     (if newDoPart[] <> none then
         newDoPart.frag[] -> generateOpenImp -> newOwner.appendOpenImp;
     if);
     
  #);

changeOwner:
  (# newOwner: ^canvasEditor;  
  enter newOwner[]
  do delete;
     newOwner[] -> owner[];
     reInsert;
  #);

handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do theEvent[] -> this(windowItemEditor).mousedown;
  #);
putRect:
  (# r: ^rectangle;
  enter r[]
  do '[' -> put;
     r.left -> putInt;
     ' ' -> put;
     r.top -> putInt;
     ' ' -> put;
     r.right -> putInt;
     ' ' -> put;
     r.bottom -> putInt;
     ']' -> put;
  #);
handleFrameChanged: theWindowItem.frameChangedAction
  (# r: ^rectangle;
     x, y: @integer;
  do (if not dontHandleFrameChanged then
         (x, y) -> changePosition;
         r.size -> changeSize;
     if);
     (if theWindowItem[]<>none then
         (if data[]<>none then
             frame -> r[];
             r.topLeft -> (x, y);
             (x, y) -> data.position;
             r.size  -> data.size;
             
             (if private.selected then
                 (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
                 startWalkingAnts;
             if);
         if);
     if);
  #);

startWalkingAnts:
  (# 
  do theWindowItem[] -> this(graphicalEditorEnv).private.theWalkingAnts.attach;
  #);
stopWalkingAnts:
  (# 
  do (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
  #);
handleRefresh: theWindowItem.refreshAction
  (#
  #);

reConfigure:
  (# doLeft,doTop,doRight,doBottom: @boolean;
     bounds: ^rectangle;
     newOwner: ^canvasEditor;
  enter (doLeft,doTop,doRight,doBottom)
  do 
     frame -> bounds[];
     (bounds[],  theWindowItem.father[], (contentsEditor).theWindowItem[]) 
       -> translateRect;
     (bounds,doLeft,doTop,doRight,doBottom) -> (contentsEditor).theWindowItem.defineRect -> bounds;
     (bounds.topLeft, (contentsEditor).theWindowItem[], theWindowItem.father[]) 
       -> translate -> bounds.topLeft;
     (bounds.bottomRight, (contentsEditor).theWindowItem[], theWindowItem.father[]) 
       -> translate -> bounds.bottomRight;
     (this(windowItemEditor)[], bounds[]) -> makeResizeOperation;
  #);

-- windowitemEditorPrivate: descriptor --
(# selected: @boolean;
   inherited: @boolean;
   pos: ^windowItemEditorList.position;
   node: ^astInterface.AST;
#)

-- canvasEditornew: doPart --
do (if theWindowItem[]<>contents then
       borderStyles.shadowIn -> theWindowItem.border.style;
       true -> theWindowItem.border.visible;
   if);
   inner;

-- abstractScrollerEditornew: doPart --
do inner;

-- scrollerEditornew: doPart --
do (# theAttributes: ^astInterface.beta.attributes;
   do 
      node[] -> betaGram.getAttributes -> theAttributes[];
      (node.frag[], 'contentsType', none) 
        -> betaGram.newVirtualBinding 
        -> theAttributes.smartAppend;
      true -> createOpenDoPart;
   #);
   inner;

-- textEditorEditornew: doPart --
do true -> locked;
   inner;

-- controlEditornew: doPart --
do inner;

-- buttonEditornew: doPart --
do 
   inner;

-- pushButtonEditornew: doPart --
do inner;

-- iconButtonEditornew: doPart --
do 
   inner;

-- optionButtonEditornew: doPart --
do 
   inner;

-- staticTextEditornew: doPart --
do inner;

-- toggleButtonEditornew: doPart --
do 
   inner;

-- radioButtonEditornew: doPart --
do inner;

-- checkBoxEditornew: doPart --
do inner;

-- scrollbarEditornew: doPart --
do 
   inner;

-- editTextEditornew: doPart --
do 
   inner;

-- textFieldEditornew: doPart --
do inner;

-- scrollListEditornew: doPart --
do inner;

-- textScrollListEditornew: doPart --
do inner;

-- graphicalEditorNewEditor: doPart --
do this(graphicalEditor).private.editorGenerator[type] -> theEditor[];
   (this(canvasEditor)[],type, makeClassData) -> theEditor.new;
   selection.clear;
   theEditor.select;


-- graphicalEditorOpen: doPart --
do (# 
   do contents -> private.theDragManager.init;
      this(graphicalEditor)[] -> insert;
      hide;
      'Graphical Objects' -> title;
      
      (600, 500) -> size;
      private.theClipBoard.init;
      private.theControlPalette.open;
      private.theViewsPalette.open;
      private.theToolPalette.open;
      selectMode -> private.mode;
      private.initEditorGenerator;
      private.initNames;
      private.initSizes;
      
   #);

-- graphicalEditorClose: doPart --
do (# 
   do inner close;
      selection.clear;
      private.contentsEditor.close;
      this(graphicalEditor)[] -> delete;
   #);
-- graphicalEditorOnMouseDown: doPart --
do 
   
-- graphicalEditorLib: attributes --
dontHandleFrameChanged:
  (# 
  enter private.dontHandleFrameChanged
  exit private.dontHandleFrameChanged
  #);


forInitStatements: (# exit 1 #);
forOpenStatements: (# exit 2 #);

makeData:
  (# data: ^parameters;
     type: @integer;
  enter type
  do type -> theDocument.theParameterStore.new -> data[];
     true -> data.bindLeft;
     false -> data.bindRight;
     true -> data.bindTop;
     false -> data.bindBottom;
     true -> data.visible;
     true -> data.enabled;
     false -> data.hilite;
  exit data[]
  #);



makeImperativeList:
  (# theImperativeList: ^imperativeList;
  do &imperativeList[] -> theImperativeList[];
     theImperativeList.init;
  exit theImperativeList[]
  #);
makeAttributeList:
  (# theAttributeList: ^attributeList;
  do &attributeList[] -> theAttributeList[];
     theAttributeList.init;
  exit theAttributeList[]
  #);
makeClassData:
  (# theClassData: ^classData;
  do &classData[] -> theClassData[];
     makeImperativeList -> theClassData.initImps[];
     makeAttributeList -> theClassData.inheritedAttributes[];
  exit theClassData[]
  #);

getClassData:
  (# node: ^astInterface.beta.attributeDecl;
     theClass: ^classInfo.class;
     theClassData: ^classData;
  enter node[]
  do node[] -> getClass -> theClass[];
     (if theClass[] <> none then
         &classData[] -> theClassData[];
         (theClass[], node[], defaultBodyGroup) -> theClassData.init;
     if);
  exit theClassData[]
  #);

makeFragmentForm:
  (# frag: ^astInterface.fragmentForm;
  do betaGram[] -> mps.newFragmentForm -> frag[];
  exit frag[]
  #);
initData:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperativeList: ^imperativeList;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1, proto2: ^astInterface.AST;
  enter (theData[], theImperativeList[])
  do makeFragmentForm -> frag[];
     (frag[], 'border.style', betaGram.remote) -> parseText -> proto1[];
     (frag[], 'border.visible', betaGram.remote) -> parseText -> proto2[];
     theImperativeList.scan
     (# theAssignment: ^astInterface.beta.assignmentEvaluation;
        theTransaction: ^astInterface.ast;
        theObjectDenotation: ^astInterface.beta.objectDenotation;
        theAttributeDenotation: ^astInterface.ast;
        theNameApl: ^astInterface.beta.nameApl;
        
     do current[] -> theAssignment[];
        theAssignment.getTransaction -> theTransaction[];
        (if theTransaction.symbol = betaGram.objectDenotation then
            theTransaction[] -> theObjectDenotation[];
            theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
            (if theAttributeDenotation.symbol = betaGram.nameApl then
                theAttributeDenotation[] -> theNameApl[];
                (theData[], theNameApl.getText, theAssignment[]) -> adjustValue;
             else
                (if true 
                 //(mps[], theAttributeDenotation[], proto1[]) -> match then
                    (theData[], 'borderStyle', theAssignment[]) -> adjustValue;
                 //(mps[], theAttributeDenotation[], proto2[]) -> match then
                    (theData[], 'borderVisible', theAssignment[]) -> adjustValue;
                if);
            if);
        if);
     #);
  #);

initData1:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives: ^astInterface.beta.imperatives;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1, proto2: ^astInterface.AST;
  enter (theData[], theImperatives[])
  do makeFragmentForm -> frag[];
     (frag[], 'border.style', betaGram.remote) -> parseText -> proto1[];
     (frag[], 'border.visible', betaGram.remote) -> parseText -> proto2[];
     theImperatives.iterate
     (# theAssignment: ^astInterface.beta.assignmentEvaluation;
        theTransaction: ^astInterface.ast;
        theObjectDenotation: ^astInterface.beta.objectDenotation;
        theAttributeDenotation: ^astInterface.ast;
        theNameApl: ^astInterface.beta.nameApl;
     do (if current.symbol = betaGram.assignmentEvaluation then
            current[] -> theAssignment[];
            theAssignment.getTransaction -> theTransaction[];
            (if theTransaction.symbol = betaGram.objectDenotation then
                theTransaction[] -> theObjectDenotation[];
                theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
                (if theAttributeDenotation.symbol = betaGram.nameApl then
                    theAttributeDenotation[] -> theNameApl[];
                    (theData[], theNameApl.getText, theAssignment[]) -> adjustValue;
                 else
                    (if true 
                     //(mps[], theAttributeDenotation[], proto1[]) -> match then
                        (theData[], 'borderStyle', theAssignment[]) -> adjustValue;
                     //(mps[], theAttributeDenotation[], proto2[]) -> match then
                        (theData[], 'borderVisible', theAssignment[]) -> adjustValue;
                    if);
                if);
            if);
        if);
     #);
  #);

adjustValue:
  (# theAssignment: ^astInterface.beta.assignmentEvaluation;
     theEvaluation: ^astInterface.beta.evaluation;
     name: ^text;
     value: ^atom;
     x, y, width, height: @integer;
     theData: ^parameters;
  enter (theData[], name[], theAssignment[])
  do theAssignment.getEvaluation -> theEvaluation[];
     (if true 
      //'position' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluatePoint -> (x, y);
         ('x', x) -> theData.setInt;
         ('y', y) -> theData.setInt;
      //'size' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluatePoint -> (width, height);
         ('width', width) -> theData.setInt;
         ('height', height) -> theData.setInt;
      //'frame' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluateRect -> (x, y, width, height);
         ('x', x) -> theData.setInt;
         ('y', y) -> theData.setInt;
         ('width', width) -> theData.setInt;
         ('height', height) -> theData.setInt;
      else
         name[] -> theData.data.lookup -> value[];
         (if value[] <> none then
             (if value.type
              //textType then
                 (name[], theEvaluation[] -> betaGram.evaluateText) -> theData.setText;
              //boolType then
                 (name[], theEvaluation[] -> betaGram.evaluateBool) -> theData.setBool;
              //intType then
                 (name[], theEvaluation[] -> betaGram.evaluateInt) -> theData.setInt;
             if);
         if);
     if);
  #);


defaultBodyGroup:
  (# group: ^mps.fragmentGroup;
  do (if private.privateFrag[] <> none then
         private.privateFrag.father -> group[];
      else
         theDocument.defaultBodyGroup -> group[];
     if);
  exit group[]
  #);

(*
 * Class support
 *)

(* getClass1:
 *   (# node: ^astInterface.beta.attributeDecl;
 *      prefixName: ^text;
 *      theClass: ^classInfo.class;
 *   enter node[]
 *   do node[] -> betaGram.getPrefix -> prefixName[];
 *      
 *      (if prefixName[] <> none then
 *          prefixName[] -> private.theClassInfo.lookup -> theClass[];
 *      if);
 *   exit theClass[]
 *   #);
 * 
 * 
 *)



undoTop:
  (# top: ^operation;
  do (if private.undoStack.empty then
         none -> top[];
      else
         private.undoStack.top -> top[];
     if);
  exit top[]
  #);

saveGraphicalEditor:
  (# 
  do undoTop -> private.lastSaveOperation[];
     theDocument.save;
  #);
graphicalEditorDirty: booleanValue
  (# 
  do (if undoTop <> private.lastSaveOperation[] then
         true -> value;
      else
         false -> value;
     if);
  #);

graphicalEditorMenu: menu
  (# graphicalEditorItem: menuItem
       (# eventHandler::<
            (# onStatus::<
                 (# 
                 do (if readOnly then
                        false -> value;
                     else
                        inner;
                    if);
                 #);
            #);
          open::<
            (# 
            do inner;
               this(graphicalEditorItem)[] -> append;
            #);
       #);
     
     addSeparator:
       (# aSeparator: ^separator;
       do &separator[] -> aSeparator[];
          aSeparator.open;
          aSeparator[] -> append;
       #);
  #);
(*
 * container types
 *)

rectangleList: sequence
  (# element:: rectangle;
  #);

stack: sequence
  (# 
     push:
       (# doAppend: @append;
       enter doAppend
       #);
     pop:
       (# doDeleteLast: @deleteLast;
       exit doDeleteLast
       #);
     top:
       (# doLast: @last;
       exit doLast
       #);
  #);


(*
 * Clipboard
 *)

clipBoard:
  (# init:
       (# 
       do getScrap -> this(clipBoard).theScrap[];
       #);
     
     theScrap: ^scrap;
     
     copyToScrap:
       (# theSelection: ^windowItemEditorList;
       enter theSelection[]
       do theScrap.clear;
          theSelection.scan
          (# scrapElm: ^scrap.element;
             frag: ^astInterface.fragmentForm;
          do &theScrap.element[] -> scrapElm[];
             current.createShadowTree  -> scrapElm.tree[];
             current.node.frag[] -> frag[];
             frag[] -> current.node.copy -> scrapElm.node[];
             scrapElm[] -> theScrap.append;
          #);
       #);
     
     createEditor:
       (# node: ^astInterface.beta.attributeDecl;
          owner: ^canvasEditor;
          tree: ^shadowTree;
          editor: ^windowItemEditor;
          data: ^parameters;
          type: @integer;
          top: @boolean;
       enter (node[], owner[], tree[], top)
       do tree.data.type -> type;
          this(graphicalEditor).private.editorGenerator[type] -> editor[];
          owner[] -> editor.owner[];
          
          type -> theDocument.theParameterStore.new -> data[];
          tree.data[] -> data.set;
          
          none -> node.addComment;
          (* data.id -> node.guiInfo; *)
          node[] -> editor.node[];
          data[] -> editor.data[];
          tree.defaultData[] -> editor.defaultData[];
          tree.theClassData[] -> editor.theClassData[];
          (* editor.updateInitImp; *)
          (if top then
              (node[], (type, data.id) -> freshName) -> betaGram.setName;
           else
              editor[] -> owner.children.append;
          if);
          tree.children.scan
          (# subNode: ^astInterface.beta.attributeDecl;
          do (node[], current.name[]) -> betaGram.findAttribute -> subNode[];
             (subNode[], editor[], current[], false) -> &createEditor;
          #);
       exit editor[]
       #);
     
     makePasteOperation: makeOperation
       (# operationType:: pasteOperation;
          theSelection: ^windowitemEditorList;
           theAttributes: ^astInterface.beta.attributes;
       do &windowitemEditorList[] -> theSelection[];
          (contentsEditor).getMainAttributes -> theAttributes[];
          theScrap.scan
          (# node: ^astInterface.beta.attributeDecl;
          do theAttributes.frag[] -> current.node.copy -> node[];
             (node[], contentsEditor, current.tree[], true) -> createEditor -> theSelection.append;
          #);
          theSelection[] -> theOperation.init;
       #);
  #);


(*
 * Generating names
 *)

getClassName:
  (# type: @integer;
     name: ^text;
  enter type
  do private.names[type][] -> name[];
  exit name[]
  #);
freshName:
  (# type: @integer;
     id: @integer;
     name: ^text;
  enter (type, id)
  do (type -> getClassName).copy -> name[];
     id -> name.putInt;
  exit name[]
  #);

(*
 * Default sizes
 *)

getDefaultSize:
  (# width, height: @integer;
     type: @integer;
  enter type
  do private.sizes[type] -> (width, height);
  exit (width, height)
  #);

(*
 * Classes for supporting undo 
 *)

clearRedoStack:
  (# 
  do private.redoStack.clear;
  #);
pushUndoStack:
  (# theOperation: ^operation;
  enter theOperation[]
  do theOperation[] -> private.undoStack.push;
  #);

operation:
  (# command:
       (# 
       do inner;
          theDocument.autoSave;
       #);
     
     doIt:<
       command;
     unDoIt:<
       command;
     init:<
       (# 
       do 
          inner;
          clearRedoStack;
          this(operation)[] -> pushUndoStack;
          theDocument.autoSave;
       #);
     name:<
       (# value: ^text;
       do inner;
       exit value[]
       #);
  #);

makeOperation:
  (# operationType:< operation;
     theOperation: ^operationType;
  do &operationType[] -> theOperation[];
     inner;
  #);

singleOperation: operation
  (# 
     theEditor: ^windowItemEditor;
     init::<
       (# 
       enter theEditor[]
       do inner;
       #);
  #);

resizeOperation: singleOperation
  (# oldFrame, newFrame: ^rectangle;
     
     init::
       (# 
       enter newFrame[]
       do theEditor.frame -> oldFrame[];
          newFrame[] -> theEditor.frame;
          (* theEditor.fixOpen; *)
          newFrame.size -> theEditor.changeSize;
       #);
     doIt::
       (# 
       do newFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          newFrame.size -> theEditor.changeSize;
       #);
     unDoIt::
       (# 
       do oldFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          oldFrame.size -> theEditor.changeSize;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);

makeSingleOperation: makeOperation
  (# operationType::< singleOperation;
     theEditor: ^windowItemEditor;
  enter theEditor[]
  do inner;
  #);
makeResizeOperation: makeSingleOperation
  (# operationType:: resizeOperation;
     newFrame: ^rectangle;
  enter newFrame[]
  do (theEditor[], newFrame[]) -> theOperation.init;
  #);

selectionOperation: operation
  (# theSelection: ^windowItemEditorList;
     setSelection: command
       (# 
       do selection.clear;
          inner;
          theSelection[] -> selection.set;
       #);
     init::<
       (# 
       enter theSelection[]
       do inner;
       #);
  #);
moveOperation: selectionOperation
  (# dh, dv: @integer;
     init::<
       (# 
       enter (dh, dv)
       do doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do true -> dontHandleFrameChanged;
             (dh, dv) -> current.theWindowItem.move;
             false -> dontHandleFrameChanged;
             current.theWindowItem.position -> current.changePosition;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do true -> dontHandleFrameChanged;
             (-dh, -dv) -> current.theWindowItem.move;
             false -> dontHandleFrameChanged;
             current.theWindowItem.position -> current.changePosition;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeOwnerOperation: selectionOperation
  (# dh, dv: @integer;
     newOwner, oldOwner: ^canvasEditor;
     init::
       (# 
       enter (newOwner[], dh, dv)
       do (theSelection.first).owner[] -> oldOwner[];
          doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h + dh, v + dv) -> current.data.position;
             (h + dh, v + dv) -> current.changePosition;
             newOwner[] -> current.changeOwner;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h - dh, v - dv) -> current.data.position;
             (h - dh, v - dv) -> current.changePosition;
             oldOwner[] -> current.changeOwner;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeBoundsOperation: selectionOperation
  (# newBounds, oldBounds: ^rectangleList;
     init::
       (# 
       enter newBounds[]
       do &rectangleList[] -> oldBounds[];
          oldBounds.init;
          theSelection.scan
          (#
          do current.frame -> oldBounds.append;
          #);
          doIt;
       #);
     doIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# b: ^rectangle;
          do inx -> newBounds.get -> b[] -> current.frame;
             inx + 1 -> inx;
             b.topLeft -> current.changePosition;
             b.size -> current.changeSize;
          #);
       #);
     unDoIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# b: ^rectangle;
          do inx -> oldBounds.get -> b[] -> current.frame;
             inx + 1 -> inx;
             b.topLeft -> current.changePosition;
             b.size -> current.changeSize;
          #);
       #);
  #);

alignOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Alignment' -> value[];
          inner;
       #);
  #);
fitToContentsOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Fit to contents' -> value[];
          inner;
       #);
  #);
spacingOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Spacing' -> value[];
          inner;
       #);
  #);

createOperation: operation
  (# bounds: ^rectangle;
     owner: ^canvasEditor;
     type: @integer;
     theEditor: ^windowItemEditor;
     init::
       (# 
       enter (owner[], type, bounds[])
       do selection.clear;
          type -> owner.newEditor -> theEditor[];
          bounds[] -> theEditor.frame;
          bounds.topLeft -> theEditor.changePosition;
          bounds.size -> theEditor.changeSize;
       #);
     doIt::
       (# 
       do selection.clear;
          theEditor.reInsert;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          theEditor.delete;
       #);
     name::<
       (# 
       do 'New' -> value[];
       #);
  #);

deleteOperation: selectionOperation
  (# 
     init::
       (# 
       do doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     name::<
       (# 
       do inner;
          (if value[] = none then
              'Delete' -> value[];
          if);
       #);
  #);
cutOperation: deleteOperation
  (# name::<
       (# 
       do 'Cut' -> value[];
       #);
  #);
pasteOperation: selectionOperation
  (# name::<
       (# 
       do 'Paste' -> value[];
       #);
     init::
       (# 
       do doIt;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     unDoIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
  #);
dialogOperation: singleOperation
  (# oldData, newData: ^parameters;
     init::
       (# 
       enter newData[]
       do theEditor.data.copy -> oldData[];
          doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          (newData[], false) -> theEditor.changeData;
          newData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          (oldData[], false)  -> theEditor.changeData;
          oldData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     name::<
       (# 
       do 
          'Dialog' -> value[];
       #);
  #);
makeDialogOperation: makeSingleOperation
  (# operationType:: dialogOperation;
     data: ^parameters;
  enter data[]
  do (theEditor[], data[]) -> theOperation.init;
  #);
changeWindowSizeOperation: operation
  (# width, height: @integer;
     oldWidth, oldHeight: @integer;
     init::
       (# 
       enter (width, height)
       do (contentsEditor).getSize -> (oldWidth, oldHeight);
          doIt;
       #);
     doIt::
       (# 
       do (width, height) -> (contentsEditor).setSize;
       #);
     unDoIt::
       (# 
       do (oldWidth, oldHeight) -> (contentsEditor).setSize;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);
makeChangeWindowSizeOperation: makeOperation
  (# operationType::< changeWindowSizeOperation;
     width, height: @integer;
  enter (width, height)
  do (width, height) -> theOperation.init;
  #);
(* End of undo *)


(* 
 * drag and drop  
 *)

changeHierarkiDragger: private.theDragManager.changeHierarkiDragger
  (# 
  #);

createDragger: private.theDragManager.createDragger
  (# 
  #);
  

reciever: private.theDragManager.reciever
  (# 
  #);

(* end *)

itemSelected:
  (# name: ^text;
     type: @integer;
     firstItem: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (name[], type)
  do  type -> this(graphicalEditor).private.contentsEditor.newEditor;
  #);



initialize:
  (# width, height: @integer;
  enter (width, height)
  do 
     (contents, width, height) -> private.windowView.open;
     private.windowView.bringBack;
     private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
     (private.viewPaletteRight + 5, 
      (private.viewPaletteBottom + 5, private.windowViewBottom + 5) -> max) -> size;
  #);

generateEditor:
  (# we: ^windowItemEditor;
  do inner;
  exit we[]
  #);

contentsEditor:
  (# 
  exit private.contentsEditor[]
  #);
contentsEditorObject:
  (# 
  exit private.contentsEditorObject[]
  #);



translateRect:
  (# r: ^rectangle;
     from, to: ^windowItem;
  enter (r[], from[], to[])
  do (r.topLeft,from[], to[]) -> translate -> r.topLeft;
     (r.bottomRight, from[], to[]) -> translate -> r.bottomRight;
  #);



(*
 * Handling of private attributes
 *)

(* findPrivateSlotName:
 *   (# slotName: ^text;
 *   do (# theAst: ^astInterface.AST;
 *         theSimpleDecl: ^astInterface.beta.simpleDecl;
 *         theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
 *         theStaticItem: ^astInterface.beta.staticItem;
 *         theUnExpanded: ^astInterface.unExpanded;
 *         theSlotDesc: ^astInterface.slotDesc;
 *      do (node[], 'private') -> betaGram.findAttribute -> theAst[];
 *         (if theAst[] <> none then
 *             (if theAst.symbol = betaGram.simpleDecl then
 *                 theAst[] -> theSimpleDecl[];
 *                 theSimpleDecl.getReferenceSpecification -> theReferenceSpecification[];
 *                 (if theReferenceSpecification.symbol = betagram.staticItem then
 *                     theReferenceSpecification[] -> theStaticItem[];
 *                     theStaticItem.getObjectSpecification -> theAst[];
 *                     (if theAst.kind = MPS.kinds.unExpanded then
 *                         theAst[] -> theUnExpanded[];
 *                         (if theUnExpanded.isSlot then
 *                             theUnExpanded.theSlot -> theSlotDesc[];
 *                             theSlotDesc.name -> slotName[];
 *                          else
 *                             failure;
 *                         if);
 *                      else
 *                         failure;
 *                     if);
 *                  else
 *                     failure;
 *                 if);
 *              else
 *                 failure;
 *             if);
 *          else
 *             failure;
 *         if);
 *      #);
 *   exit slotName[]
 *   #);
 * 
 * findPrivate:
 *   (# failure:< object;
 *   do 
 *      (if theDocument.defaultBodyGroup <> none then
 *          true -> (theDocument.defaultBodyGroup).changed;
 *          (# slotName: ^text;
 *             frag: ^astInterface.fragmentForm;
 *          do findPrivateSlotName -> slotName[];
 *             (if slotName[] <> none then
 *                 slotName[] -> (theDocument.defaultBodyGroup).findFragment -> frag[];
 *                 (if frag[] <> none then 
 *                     (if frag.category = betaGram.descriptorForm then
 *                         frag[] -> private.privateFrag[];
 *                         private.privateFrag[] -> private.privateFragHandler.frag[];
 *                         private.privateFragHandler[] -> theFragServer.subscribe;
 *                      else
 *                         failure;
 *                     if);
 *                  else
 *                     failure;
 *                 if);
 *              else
 *                 failure;
 *             if);
 *          #);
 *       else
 *          failure;
 *      if);
 *   #);
 *)
findBody:
  (# failure:< object;
     body: ^astInterface.fragmentGroup;
  do (# group: ^astInterface.fragmentGroup;
        fullPath: ^text;
     do node.frag.father -> group[];
        (if group[] <> none then
            search: group.scanBodyGroups
              (# 
              do 
                 currentFullPath[] -> fullPath[];
                 leave search;
              #);
            (if fullPath[] <> none then
                fullPath[] -> MPS.safeOpen -> body[];
                (if body[] = none then
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
  exit body[]
  #);

createPrivateAttributes:
  (# failure:< object;
     group: ^astInterface.fragmentGroup;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
     theStaticItem: ^astInterface.beta.staticItem;
     theUnExpanded: ^astInterface.unExpanded;
     theSlotDesc: ^astInterface.slotDesc;
     frag: ^astInterface.fragmentForm;
     theDescriptorForm: ^astInterface.beta.descriptorForm;
     theObjectDescriptor: ^astInterface.beta.objectDescriptor;
     theMainPart: ^astInterface.beta.mainPart;
     name: ^text;
     privateFrag, theFragment: ^astInterface.fragmentForm;
  do defaultBodyGroup -> group[];
     (if group[]<>None then
         node.frag[] -> frag[];
         (betaGram.simpleDecl, frag[]) -> betaGram.newAst -> theSimpleDecl[];
         (frag[], 'private') -> betaGram.newNames -> theSimpleDecl.putNames;
         (betaGram.staticItem, frag[]) 
           -> betaGram.newAst -> theStaticItem[] 
           -> theSimpleDecl.putReferenceSpecification;
         (betaGram.objectDescriptor, frag[]) 
           -> betaGram.newUnExpanded  -> theUnExpanded[]
           -> theStaticItem.putObjectSpecification;
         frag[] -> betaGram.newSlot -> theSlotDesc[] -> theUnExpanded.theSlot;
         node[] -> betaGram.getName -> name[];
         'Private' -> name.append;
         name[] -> theSlotDesc.name;
         (node[], theSimpleDecl[]) -> betaGram.appendAttribute;
         betaGram[] -> MPS.newFragmentForm -> privateFrag[];
         name[] -> privateFrag.name;
         name[] -> group.findFragment -> theFragment[];
         (if theFragment[] <> none then
             theFragment[] -> group.deleteFragment;
         if);
         privateFrag[] -> group.fragmentList.addFragment;
         (privateFrag[], none) 
           -> betaGram.newDescriptorForm -> theDescriptorForm[]
           -> privateFrag.root[];
         privateFrag[] -> private.privateFrag[];
         private.privateFrag[] -> private.privateFragHandler.frag[];
         private.privateFragHandler[] -> theFragServer.subscribe;
     else
         failure;
     if);
  #);

-- graphicalEditorPrivateAttributes: descriptor --
(# newlyCreated: @boolean;
   forbidCodeChanges, dontHandleFrameChanged: @boolean;
   lastSaveOperation: ^operation;
   theFileMenu: @graphicalEditorMenu
     (# 
        closeItem: @menuItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do (if this(graphicalEditor).theEventHandler.onAboutToClose then
                           this(graphicalEditor).close;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Close' -> name;
                  'W' -> key;
                  closeItem[] -> append;
               #);
          #);
        saveItem: @graphicalEditorItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do theDocument.interfaceGroup[] -> saveFragmentGroup;
                    #);
               #);
             open::
               (# 
               do 'Save' -> name;
                  'S' -> key;
               #);
          #);
        open::
          (# 
          do 'File' -> name;
             closeItem.open;
             saveItem.open;
          #);
     #);
   theEditMenu: @graphicalEditorMenu
     (# undoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do undo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canUndo then 
                           'Undo ' -> t[];
                           undoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Undo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Undo' -> name;
                  'Z' -> key;
               #);
          #);
        redoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do redo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canRedo then 
                           'Redo ' -> t[];
                           redoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Redo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Redo' -> name;
                  'R' -> key;
               #);
          #);
        cutItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCut;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Cut' -> name;
                  'X' -> key;
               #);
          #);
        copyItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCopy;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Copy' -> name;
                  'C' -> key;
               #);
          #);
        pasteItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do paste;
                    #);
                  onStatus::
                    (# 
                    do canPaste -> value;
                    #);
               #);
             open::
               (# 
               do 'Paste' -> name;
                  'V' -> key;
               #);
          #);
        deleteItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.deleteAll;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Delete' -> name;
               #);
          #);
        findItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find...' -> name;
               #);
          #);
        findAgainItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find again' -> name;
               #);
          #);
        objectInfoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showInfo;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Object info...' -> name;
                  'I' -> key;
               #);
          #);
        objectCodeItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do (if selection.empty then
                           showCode;
                        else
                           selection.showCode;
                       if);
                    #);
                  onStatus::
                    (# 
                    do true  -> value;
                    #);
               #);
             open::
               (# 
               do 'Object code...' -> name;
                  'K' -> key;
               #);
          #);
        objectFitToContents: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.fitToContents;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Fit to contents' -> name;
               #);
          #);
        open::
          (# 
          do 'Edit' -> name;
             undoItem.open;
             redoItem.open;
             addSeparator;
             cutItem.open;
             copyItem.open;
             pasteItem.open;
             deleteItem.open;
             addSeparator;
             findItem.open;
             findAgainItem.open;
             addSeparator;
             objectInfoItem.open;
             objectCodeItem.open;
             objectFitToContents.open;
          #);
     #);
   theAlignMenu: @graphicalEditorMenu
     (#
        alignLeftItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignLeft;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Left side' -> name;
               #);
          #);
        alignRightItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignRight;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Right side' -> name;
               #);
          #);
        alignTopItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignTop;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Top edge' -> name;
               #);
          #);
        alignBottomItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignBottom;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Bottom edge' -> name;
               #);
          #);
        alignHorCenterItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignHorCenter;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Horizontal center' -> name;
               #);
          #);
        alignVerCenterItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignVerCenter;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Vertical center' -> name;
               #);
          #);
        showSpacingDialogItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showSpacingDialog;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Spacing...' -> name;
               #);
          #);
        open::
          (#
          do 'Align' -> name;
             alignLeftItem.open;
             alignRightItem.open;
             alignTopItem.open;
             alignBottomItem.open;
             alignHorCenterItem.open;
             alignVerCenterItem.open;
             addSeparator;
             showSpacingDialogItem.open;
          #);
     #);
   (*
    * Handling of private attributes
    *)
   
   body: ^astInterface.fragmentGroup;
   privateFrag: ^astInterface.fragmentForm;
   
   (*
    * Fragment handler
    *)
   
   
   fragHandler, privateFragHandler: @fragmentHandler
     (# handleAstReplaced:
          (#  oldAst, newAst: ^astInterface.ast; 
          enter (oldAst[], newAst[])
          do contentsEditor.traverse
             (# forEach::
                  (# 
                  do (oldAst[], newAst[]) -> current.handleAstReplaced -> continue;
                  #);
             #);
          #);
        astReplaced::
          (#
          do (oldAst[], newAst[]) -> handleAstReplaced;
          #);
        (* astReplacedSequence:<
         *           (# rootOfSequence: ^astInterface.ast
         *           enter rootOfSequence[]
         *           do inner;
         *           #);
         *         listElementInserted:<
         *           (# position: @integer; listNode: ^astInterface.expanded; 
         *           enter (listNode[], position)
         *           do inner;
         *           #);
         *         listElementsDeleted:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length: @integer
         *           enter (listNode[], position, length, oldElements[])
         *           do inner;
         *           #);
         *         listElementsReplaced:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length, newLength: @integer
         *           enter (listNode[], position, length, oldElements[], newLength)
         *           do inner;
         *           #);
         *)
     #);
   
   
   (*
    * Undo and redo
    *)
   undoStack: @stack
     (# element:: operation;
     #);
   redoStack: @stack
     (# element:: operation;
     #);
      
   (*
    * Drag and drop
    *)


   theDragManager: @dragManager
     (# dragger::
          (#  moveTo:<
               (# theCanvasEditor: ^canvasEditor;
                  newFrame: ^rectangle;
               enter (theCanvasEditor[], newFrame[])
               do inner;
               #);
          #);
        changeHierarkiDragger: dragger
          (# bounds: ^rectangle;
             moveTo::
               (# dh, dv: @integer;
               do newFrame.left - bounds.left -> dh;
                  newFrame.top - bounds.top -> dv;
                  (if theCanvasEditor[] -> selection.moveAllowed then
                      (if (selection.first).owner[] <> theCanvasEditor[] then
                          (theCanvasEditor[], dh, dv) -> selection.makeChangeOwnerOperation;
                      if);
                   else
                      system.beep;
                  if);
               #);
          #);
        createDragger: dragger
          (# type: @integer;
             moveTo::
               (# theEditor: ^windowItemEditor;
                  theCreateOperation: ^createOperation;
               do &createOperation[] -> theCreateOperation[];
                  (theCanvasEditor[], type, newFrame[]) -> theCreateOperation.init;
               #);
          #);
     #);
   
   (* END of drag and drop *)
   
   (*
    * Clipboard
    *)
   
   theClipBoard: @clipboard;
   
   (* 
    * Mode
    *)
   
   mode: @integer;
   
   (* End of mode *)
   
   (*
    * Generators
    *)
   
   editorGenerator: [28] ^generateEditor;
   initEditorGenerator:
     (# 
     do (* &generateEditor (# do &interfaceObjectEditor[] -> we[] #)[] -> editorGenerator[1][]; *)
        &generateEditor (# do &windowitemEditor[] -> we[] #)[] -> editorGenerator[2][];
        &generateEditor (# do &separatorEditor[] -> we[] #)[] -> editorGenerator[3][];
        &generateEditor (# do &canvasEditor[] -> we[] #)[] -> editorGenerator[4][];
        &generateEditor (# do &abstractScrollerEditor[] -> we[] #)[] -> editorGenerator[5][];
        &generateEditor (# do &scrollerEditor[] -> we[] #)[] -> editorGenerator[6][];
        &generateEditor (# do &textEditorEditor[] -> we[] #)[] -> editorGenerator[7][];
        &generateEditor (# do &controlEditor[] -> we[] #)[] -> editorGenerator[8][];
        &generateEditor (# do &buttonEditor[] -> we[] #)[] -> editorGenerator[9][];
        &generateEditor (# do &pushButtonEditor[] -> we[] #)[] -> editorGenerator[10][];
        &generateEditor (# do &iconButtonEditor[] -> we[] #)[] -> editorGenerator[11][];
        &generateEditor (# do &OptionButtonEditor[] -> we[] #)[] -> editorGenerator[12][];
        &generateEditor (# do &staticTextEditor[] -> we[] #)[] -> editorGenerator[13][];
        &generateEditor (# do &toggleButtonEditor[] -> we[] #)[] -> editorGenerator[14][];
        &generateEditor (# do &radioButtonEditor[] -> we[] #)[] -> editorGenerator[15][];
        &generateEditor (# do &checkBoxEditor[] -> we[] #)[] -> editorGenerator[16][];
        &generateEditor (# do &scrollbarEditor[] -> we[] #)[] -> editorGenerator[17][];
        &generateEditor (# do &editTextEditor[] -> we[] #)[] -> editorGenerator[18][];
        &generateEditor (# do &textFieldEditor[] -> we[] #)[] -> editorGenerator[19][];
        &generateEditor (# do &scrollListEditor[] -> we[] #)[] -> editorGenerator[20][];
        &generateEditor (# do &textScrollListEditor[] -> we[] #)[] -> editorGenerator[21][];
        (* &generateEditor (# do &windowEditor[] -> we[] #)[] -> editorGenerator[22][]; *)
        (* &generateEditor (# do &menuEditor[] -> we[] #)[] -> editorGenerator[23][]; *)
        (* &generateEditor (# do &menubarEditor[] -> we[] #)[] -> editorGenerator[24][]; *)
        (* &generateEditor (# do &menuitemEditor[] -> we[] #)[] -> editorGenerator[25][]; *)
        (* &generateEditor (# do &dynamicMenuitemEditor[] -> we[] #)[] -> editorGenerator[26][];*)
        &generateEditor (# do &verScrollbarEditor[] -> we[] #)[] -> editorGenerator[27][];
        &generateEditor (# do &verSeparatorEditor[] -> we[] #)[] -> editorGenerator[28][];
     #);
   
   names: [28] ^text;
   initNames:
     (# 
     do 'interfaceObject' -> names[1][];
        'windowitem' -> names[2][];
        'separator' -> names[3][];
        'canvas' -> names[4][];
        'abstractScroller' -> names[5][];
        'scroller' -> names[6][];
        'textEditor' -> names[7][];
        'control' -> names[8][];
        'button' -> names[9][];
        'pushButton' -> names[10][];
        'iconButton' -> names[11][];
        'optionButton' -> names[12][];
        'staticText' -> names[13][];
        'toggleButton' -> names[14][];
        'radioButton' -> names[15][];
        'checkBox' -> names[16][];
        'scrollbar' -> names[17][];
        'editText' -> names[18][];
        'textField' -> names[19][];
        'scrollList' -> names[20][];
        'textScrollList' -> names[21][];
        'window' -> names[22][];
        'menu' -> names[23][];
        'menubar' -> names[24][];
        'menuitem' -> names[25][];
        'dynamicMenuitem' -> names[26][];
        'scrollbar' -> names[27][];
        'separator' -> names[28][];
     #);
   sizes: [28] ^point;
   initSizes:
     (# 
     do (for inx: sizes.range repeat
             &point[] -> sizes[inx][];
        for);
        (100, 20) -> sizes[2];
        (100, 4) -> sizes[3];
        (200, 100) -> sizes[4];
        (200, 100) -> sizes[5];
        (200, 100) -> sizes[6];
        (200, 100) -> sizes[7];
        (100, 20) -> sizes[8];
        (100, 20) -> sizes[9];
        (60, 20) -> sizes[10];
        (40, 40) -> sizes[11];
        (100, 40) -> sizes[12];
        (60, 16) -> sizes[13];
        (100, 20) -> sizes[14];
        (100, 20) -> sizes[15];
        (100, 20) -> sizes[16];
        (100, 16) -> sizes[17];
        (100, 30) -> sizes[18];
        (200, 100) -> sizes[19];
        (200, 100)  -> sizes[20];
        (200, 100) -> sizes[21];
        (16, 100) -> sizes[27];
        (4, 100) -> sizes[28];
     #);
   
   contentsEditorObject: @canvas
     (# setRealFrame:
          (# r: ^rectangle;
             width, height: @integer;
          enter r[]
          do r.size -> (width, height);
             width + 16 -> width;
             height + 32 -> height;
             (width, height) -> windowView.size;
             r.topLeft -> windowView.position;
          #);
        getRealFrame:
          (# r: ^rectangle;
          do &rectangle[] -> r[];
             windowView.position -> r.topLeft;
             size -> r.size;
          exit r[]
          #);
        open::<
          (#
          do true -> bindRight -> bindBottom;
             false -> border.visible;
          #);
     #);
   windowView: @canvas
     (# 
        titleBar: @staticText
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do true -> bindRight;
                  '' -> label;
                  center -> alignment;
                  ((2, 2), (width - 2, 20)) -> frame;
               #);
             eventHandler::
               (# 
                  onMouseDown::
                    (# 
                    do windowView.drag;
                    #);
               #);
          #);
        interior: @canvas
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do borderStyles.shadowIn -> border.style;
                  true -> border.visible;
                  ((6, 20), (width - 6, height - 6)) -> frame;
                  interior[] -> contentsEditorObject.open;
                  ((2, 2), (width - 14, height - 30)) -> contentsEditorObject.frame;
                  true -> bindRight;
                  true -> bindBottom;
               #);
          #);
        open::
          (# width, height: @integer;
             windowViewRight: @integer;
             ignore: @integer;
          enter (width, height)
          do hide;
             (toolPaletteRight + 10, 5) -> position;
             (width + 16 -> width, height + 32 -> height) -> size;
             true -> border.visible;
             borderstyles.shadowOut -> border.style;
             (windowView[], width, height) -> titleBar.open;
             (windowView[], width, height) -> interior.open;
             5 + height -> windowViewBottom;
             toolPaletteRight + 10 + width -> windowViewRight;
             (windowViewRight + 10, 5) -> theControlPalette.position;
             (windowViewRight + 10, controlPaletteBottom + 5) -> theViewsPalette.position;
             theViewsPalette.frame -> ((ignore, ignore), (viewPaletteRight, viewPaletteBottom));
             show;
          #);
        eventHandler::
          (# 
             onMouseDown::
               (# r: @rectangle;
                  width, height: @integer;
               do (if not readOnly then
                      (frame, false, false, true, true) -> father.defineRect -> r;
                      r.size -> (width, height);
                      (width - 16, height - 32) -> makeChangeWindowSizeOperation;
                  if);
               #);
          #);
     #);
   contentsEditor: @canvasEditor
     (# setSize:
          (# width, height: @integer;
          enter (width, height)
          do (width + 16, height + 32) -> windowView.size;
             (width, height) -> changeSize;
          #);
        getSize:
          (# width, height: @integer;
          do theWindowItem.size -> (width, height);
          exit (width, height)
          #);
        
        getMainAttributes::
          (# 
          do getPrivateAttributes -> theAttributes[];
          #);
        getPrivateAttributes::
          (# theDescriptorForm: ^astInterface.beta.descriptorForm;
             theObjectDescriptor: ^astInterface.beta.objectDescriptor;
             theMainPart: ^astInterface.beta.mainPart;
          do (if privateFrag[] <> none then
                 privateFrag.root[] -> theDescriptorForm[];
                 theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                 theObjectDescriptor.getMainPart -> theMainPart[];
                 theMainPart.getAttributes -> theAttributes[];
             if);
          #);
        createInitImps::
          (# override:: (# do true -> value #);
             width, height: @integer
          do data.size -> (width, height);
             (betaGram.imperatives, frag[]) -> betaGram.newAst -> initImps[];
             (frag[], 'size', (frag[], width, height) -> betaGram.newPointEvaluation)
               -> betaGram.newAssignment -> initImps.append;
          #);
        mouseDown::
          (# 
          do 
             (if theEvent.doubleClick then
              else
                 selection.clear;
             if);
             true -> done;
          #);
        init::
          (# theAttributes: ^astInterface.beta.attributes;
          do createTheReciever;
          #);
     #);
   
   
   theControlPalette: @controlPalette
     (# 
        mouseDownInItem::
          (# theDragger: @createDragger;
          do (if not readOnly then
                 theControlPalette[] -> theDragger.item[];
                 type -> theDragger.type;
                 (event[], theControlPalette[]) -> theDragger.drag
                 (# 
                    frame::
                      (# 
                      do &rectangle[] -> value[];
                         p -> value.topLeft;
                         type -> getDefaultSize -> value.size;
                      #);
                 #);
             if);
          #);
        open::
          (# ignore: @integer;
          do (200, 5) -> position;
             frame -> ((ignore, ignore), (controlPaletteRight, controlPaletteBottom));
          #);
     #);
   theViewsPalette: @viewPalette
     (# 
         
        mouseDownInItem::
          (# theDragger: @createDragger;
          do (if not readOnly then
                 theViewsPalette[] -> theDragger.item[];
                 type -> theDragger.type;
                 (event[], theViewsPalette[])  -> theDragger.drag
                 (# 
                    frame::
                      (# 
                      do &rectangle[] -> value[];
                         p -> value.topLeft;
                         type -> getDefaultSize -> value.size;
                      #);
                 #);
             if);
             
          #);
        open::
          (# ignore: @integer;
          do (200, controlPaletteBottom + 5) -> position;
             frame -> ((ignore, ignore), (viewPaletteRight, viewPaletteBottom));
          #);
     #);
   theToolPalette: @toolPalette
     (# mouseDownInItem::
          (# 
          do (if not readOnly then
                 type -> this(graphicalEditor).mode;
             if);
          #);
        open::
          (# width, height: @integer;
          do (5, 5) -> position;
             size -> (width, height);
             width + 5 -> toolPaletteRight;
             height + 5 -> toolPaletteBottom;
          #);
        
     #);
   
   toolPaletteRight, toolPaletteBottom: @integer;
   controlPaletteBottom, controlPaletteRight: @integer;
   viewPaletteRight, viewPaletteBottom: @integer;
   windowViewBottom: @integer;
#)

-- canvasEditorPrivate: descriptor --
(# locked: @boolean;
   theReciever: ^recieverType;
#)


-- windowitemEditorMousedown: doPart --
do (if not (readOnly OR inherited) then
       inner mouseDown;
       (if theEvent.doubleClick then
           (if theEvent.controlKey then
               showCodeDialog;
            else
               (if this(windowItemEditor)[] <> contentsEditor then 
                   showInfoDialog;
               if);
           if);
        else
           (if not done then
               (# actualMode: @integer;
                  
               do mode -> actualMode;
                  (if theEvent.shiftKey then
                      (if private.selected then
                          deSelect;
                       else
                          select;
                      if);
                   else
                      (if not private.selected then 
                          selection.clear;
                          select;
                      if);
                  if);
                  (if private.selected then
                      (if actualMode
                       //selectMode then
                          theEvent.localPosition -> theWindowItem.delay
                          (# 
                          do theEvent[] -> dragOrResize;
                          #);
                       //resizeMode then
                          (# width,height: @integer;
                             dh,dv: @integer;
                             h,v: @integer;
                             doTop,doLeft,doBottom,doRight: @boolean;
                          do theEvent.localPosition -> (h,v);
                             theWindowItem.size -> (width,height);
                             width div 3 -> dh;
                             height div 3 -> dv;
                             
                             (if (h <= dh) then 
                                 true -> doLeft 
                             if);
                             (if (h >= (width - dh)) then
                                 true -> doRight
                             if);
                             (if (v <= dv) then
                                 true -> doTop
                             if);
                             (if (v >= (height - dv)) then 
                                 true -> doBottom
                             if);
                             (if (doLeft or doBottom or doTop or doRight) then
                                 (doLeft,doTop,doRight,doBottom) -> reConfigure;
                              else
                                 width div 2 -> dh;
                                 height div 2 -> dv;
                                 
                                 (if (h <= dh) then 
                                     true -> doLeft
                                  else
                                     true -> doRight;
                                 if);
                                 (if (v <= dv) then
                                     true -> doTop
                                  else
                                     true -> doBottom;
                                 if);
                                 (doLeft,doTop,doRight,doBottom) -> reConfigure;
                             if);
                          #);
                       //hierarkiMode then
                          theEvent[] -> selection.interactiveChangeHierarki;
                      if);
                  if);
               #);
           if);
       if);
   if);
  
  
-- canvasEditorMousedown: doPart --
do inner mouseDown;
   
-- canvasEditorLib: attributes --

updateOpen: codeGuard
  (# oldName, newName: ^text;
     
  enter (oldName[], newName[])
  do (# oldStmProto: ^astInterface.beta.imp;
        oldStm: ^astInterface.beta.imp;
        newStm: ^astInterface.beta.imp;
        frag: ^astInterface.fragmentForm;
        txt: @text;
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        gram: @grammar;
     do 
        forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] <> none then
            makeFragmentForm -> frag[];
            oldName[] -> txt.append;
            '.open' -> txt.append;
            (frag[], txt[], gram.imp) -> parseText -> oldStmProto[];
            txt.clear;
            newName[] -> txt.append;
            '.open' -> txt.append;
            theDoPart.getImperatives -> theImperatives[];
            (theImperatives.frag[], txt[], gram.imp) -> parseText -> newStm[];
            (mps[], theImperatives[], oldStmProto[]) -> listSearch -> oldStm[];
            (if oldStm[] <> none then
                (oldStm.sonNo, newStm[]) -> theImperatives.put;
                (true, theImperatives.frag[], oldStm[], newStm[])
                  -> theFragServer.notifyAstReplaced;
            if);
        if);
     #);
  #);


appendChild: codeGuard
  (# editor: ^windowItemEditor;
     
  enter editor[]
  do (# theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
     do
        editor[] -> children.append;
        forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] <> none then
            theDoPart.getImperatives -> theImperatives[];
            theImperatives.frag[] -> editor.generateOpenImp -> theImperatives.append;
            (true, theImperatives.frag[], theImperatives[], theImperatives.noOfSons)
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);

(* 
 * Drag and drop support
 *)

recieverType: reciever
  (* Should be a singular object, but a reciever can 
   * not be reused.
   *)
  (# savedStyle: @integer;
     onHilite::
       (# 
       do theWindowItem.border.style -> savedStyle;
          (if savedStyle
           //borderstyles.shadowIn then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.shadowOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedIn then
              borderstyles.etchedOut -> theWindowItem.border.style;
          if);
       #);
     onLowLite::
       (# 
       do savedStyle -> theWindowItem.border.style;
       #);
     
     recieve::
       (# 
       do (this(canvasEditor)[], frame[]) -> theDragger.moveTo;
       #);
  #);

createTheReciever:
  (# 
  do (if private.theReciever[] <> none then
         private.theReciever.delete;
     if);
     &recieverType[] -> private.theReciever[];
     theWindowItem[] -> private.theReciever.init;
  #);
(* End of drag and drop support *)

(*
 * Locking
 *)


locked:
  (# 
  enter private.locked
  exit private.locked
  #);

(* End of locking *)


(*
 * Code
 *)

getMainFrag:
  (# theAttributes: ^astInterface.beta.attributes;
     frag: ^astInterface.fragmentForm;
  do getMainAttributes -> theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.frag[] -> frag[];
     if);
  exit frag[]
  #);



appendAttribute:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter theAttribute[]
  do 
     getMainAttributes -> theAttributes[];
     (if theAttributes[] = none then
         failure;
      else
         (theAttributes[], theAttribute[]) -> appendToAttributes;
     if);
  #);

scanAttributes:
  (# current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  do getMainAttributes -> theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.iterate
         (# 
         do current[] -> this(scanAttributes).current[];
            inner scanAttributes;
         #);
     if);
  #);

-- windowItemEditorSelect: doPart --
do (if not private.selected then
       (if this(windowItemEditor)[] -> selection.selectable then
           this(windowItemEditor)[] -> selection.append;
        else
           system.beep;
       if);
   if);
   
-- windowItemEditorDeSelect: doPart --
do (if private.selected then
       this(windowItemEditor)[] -> selection.delete;
   if);

-- GraphicalEditorInit: doPart --
do true -> private.forbidcodechanges;
   (# data: ^parameters;
      prop: ^propertyList;
      ID: @integer;
      width, height: @integer;
   do privateFrag[] -> private.privateFrag[];
      
      (* node.guiInfo -> ID;
       * ID -> theDocument.theParameterStore.get -> data[];
       *)
      canvasType -> theDocument.theParameterStore.new -> data[];
      true -> data.bindLeft -> data.bindTop;
      (300, 200) -> data.size;
      
      (# theDoPart: ^astInterface.beta.doPart;
      do (node[], defaultBodyGroup) -> realFindOpenDoPart -> theDoPart[];
         (if theDoPart[] <> none then
             (data[], theDoPart.getImperatives) -> initData1;
         if);
      #);
      data.size ->  initialize;
      (if privateFrag[] <> none then
          private.privateFrag[] -> private.privateFragHandler.frag[];
          private.privateFragHandler[] -> theFragServer.subscribe;
      if);
      (none, node[], data[], canvasType, false, node[] -> getClassData) 
        -> private.contentsEditor.init;
      show;
      inner init;
   #);
   (* false -> private.forbidcodechanges; *)

-- IBwindowitemEditorapplyObjectData: doPart --
do (# r: @rectangle;
   do data.position -> r.topLeft;
      data.size -> r.size;
      r[] -> frame;
   #);
   data.bindLeft -> theWindowItem.bindLeft;
   data.bindRight -> theWindowItem.bindRight;
   data.bindTop -> theWindowItem.bindTop;
   data.bindBottom -> theWindowItem.bindBottom;
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   data.borderStyle -> theWindowItem.border.style;
   data.borderVisible -> theWindowItem.border.visible;
   inner;

-- IBcanvasEditorapplyObjectData: doPart --
do inner;

-- IBbuttonApplyObjectData: doPart --
do data.label -> theWindowItem.label;
   inner;

-- IBiconButtonapplyObjectData: doPart --
do inner; 

-- IBoptionButtonapplyObjectData: doPart --
do inner;
   
-- IBtoggleButtonapplyObjectData: doPart --
do data.state -> theWindowItem.state;
   inner;

-- IBscrollBarapplyObjectData: doPart --
do data.scrollAmount -> theWindowItem.scrollAmount;
   data.pageScrollAmount -> theWindowItem.pageScrollAmount;
   data.maxValue  -> theWindowItem.maxValue;
   data.value -> theWindowItem.value;
   inner;
-- IBeditTextapplyObjectData: doPart --
do inner;


-- IBscrollListapplyObjectData: doPart --
do inner;

-- IBtextScrollListapplyObjectData: doPart --
do inner;
   

-- GraphicalEditorWindowItemEditorEditAttributes: doPart --
do 
   (# makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : attributes' -> theTitle.append;
        exit theTitle[]
        #);
   do (node[], makeTitle) -> openAstEditor;
   #);

-- GraphicalEditorWindowItemEditorShowInfoDialog: doPart --
do (# makeTitle:
        (# title: ^text;
        do node[] -> betaGram.getName -> title[];
           ' : info' -> title.append;
        exit title[]
        #);
   do (data.copy, makeTitle) -> editInfo
      (# 
         onOk::
           (# 
           do (this(windowItemEditor)[], data[]) -> makeDialogOperation;
           #);
      #);
   #);
   

-- GraphicalEditorWindowItemEditorShowCodeDialog: doPart --
do (if codeDialog[]//none then
       &codeDialogType[] -> codeDialog[];
       codeDialog.open;
       this(windowItemEditor)[] -> codeDialog.editor[];
    else
       codeDialog.bringToFront;
       codeDialog.show;
   if);
   codeDialog.updateFields;

-- GraphicalEditorWindowItemEditorEditVirutal: doPart --
do (# theAttribute, theVirtual, theEventHandler: ^astInterface.beta.attributeDecl;
      theEditor: ^astEditorEnv.astEditor;
      astToEdit: ^astInterface.AST;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
      theActionPart: ^astInterface.beta.actionPart;
      theUnExpanded: ^astInterface.unExpanded;
      theSlot: ^astInterface.slotDesc;
      slotName: ^text;
      doPartFrag: ^astInterface.fragmentForm;
      group: ^astInterface.fragmentGroup;
      theAst: ^astInterface.AST;
      makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : ' -> theTitle.append;
           name[] -> theTitle.append;
        exit theTitle[]
        #);
      frag: ^astInterface.fragmentForm;
   do node[] -> theAttribute[];
      name[] -> findVirtual -> theVirtual[];
      (if theVirtual[] = none then
          name[] -> createVirtual -> theVirtual[];
          (if theVirtual[] <> none then
              (if isPrivateToWindow then
                  theVirtual[] -> astToEdit[];
               else
                  theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
                  theObjectDescriptor.getMainPart -> theMainPart[];
                  theMainPart.getActionPart -> theActionPart[];
                  theAttribute[] -> betaGram.getName -> slotName[];
                  name[] -> slotName.append;
                  (theAttribute.frag[], slotName[]) 
                    -> betaGram.newSlotDoPart -> theActionPart.putDoPartOpt;
                  
                  slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
                  defaultBodyGroup -> group[];
                  slotName[] -> group.findFragment -> frag[];
                  (if frag[] <> none then
                      frag.root[] -> astToEdit[];
                   else
                      doPartFrag[] -> group.fragmentList.addFragment;
                      doPartFrag.root[] -> astToEdit[];
                  if);
              if);
           else
          if);
          (* astControl.notifyChange; *)
       else
          theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getActionPart -> theActionPart[];
          theActionPart.getDoPartOpt -> theAst[];
          (if theAst.kind = MPS.kinds.unExpanded then
              theAst[] -> theUnExpanded[];
              (if theUnExpanded.isSlot then
                  theUnExpanded.theSlot -> theSlot[];
                  defaultBodyGroup -> group[];
                  theSlot.name -> group.findFragment -> doPartFrag[];
                  doPartFrag.root[] -> astToEdit[];
              if);
           else
              theVirtual[] -> astToEdit[];
          if);
      if);
      (astToEdit[], makeTitle) -> openAstEditor;
   #);
   theDocument.autoSave;
   
   
-- GraphicalEditorWindowItemEditorInit: doPart --
do (# theDoPart: ^astInterface.beta.doPart;
      theImperatives: ^astInterface.beta.imperatives;
   do inherited -> this(windowItemEditor).inherited;
      (if data[] = none then
          type -> newData -> defaultData[];
          (defaultData[], theClassData.initImps[]) -> initData;
          defaultData.copy -> data[];
      if);
      (if theAttribute[]<>none then
          theAttribute[] -> node[];
          forInitStatements -> findOpenDoPart -> theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives -> theImperatives[];
              (data[], theImperatives[]) -> initData1;
          if);
      if);
      (if theWindowItem[] = None then
          (if this(windowItemEditor)## <= textEditorEditor## then
              this(windowItemEditor)[] -> qua
              (# as:: canvasEditor;
              do true -> thisObj.private.locked;
              #);
          if);
          createTheWindowItem;
       else
          &handleMouseDown[] -> theWindowItem.prependAction;
          &handleRefresh[] -> theWindowItem.appendAction;
          &handleFrameChanged[] -> theWindowItem.appendAction;
      if);
      (if owner[]<>none then
          this(windowitemEditor)[] -> owner.children.append;
      if);
      inner init;
   #);

-- canvasEditorInit: doPart --
do inner;
   (# proto: ^astInterface.AST;
      isStaticItem: booleanValue
        (# node: ^astInterface.beta.attributeDecl;
        enter node[]
        do (mps[], node[], proto[]) -> match -> value;
        #);
      frag: ^astInterface.fragmentForm;
      
   do betaGram[] -> mps.newFragmentForm -> frag[];
      (frag[], '<<nameDcl>>: @<<nameApl>> <<mainpart>>', betaGram.simpleDecl) -> parseText -> proto[];
      theClassData.inheritedAttributes.scan
      (# theEditor: ^windowItemEditor;
         theClassData: ^classData;
      do (if current[] -> isStaticItem then
             current[] -> getClassData -> theClassData[];
             (if theClassData[] <> none then
                 this(graphicalEditor).private.editorGenerator[theClassData.theClass.type] -> theEditor[];
                 (this(canvasEditor)[],current[], NONE, theClassData.theClass.type, true, theClassData[]) 
                   -> theEditor.init;
             if);
         if);
      #);
      scanAttributes
      (# theEditor: ^windowItemEditor;
         theClassData: ^classData;
      do (if current[] -> isStaticItem then
             current[] -> getClassData -> theClassData[];
             (if theClassData[] <> none then
                 this(graphicalEditor).private.editorGenerator[theClassData.theClass.type] -> theEditor[];
                 (this(canvasEditor)[],current[], NONE, theClassData.theClass.type, inherited, theClassData[]) 
                   -> theEditor.init;
             if);
         if);
      #);
   #);


-- GraphicalEditorNew: doPart --
do (# frag: ^astInterface.fragmentForm;
      thePatternDecl: ^astInterface.beta.patternDecl;
      data: ^parameters;
      prop: ^propertyList;
   do true -> private.newlyCreated;
      (300, 200) -> initialize;
      true -> (node.frag.father).changed;
      node[] -> thePatternDecl[];
      canvasType -> theDocument.theParameterStore.new -> data[];
      true -> data.bindLeft -> data.bindTop;
      (300, 200) -> data.size;
      (* data.id -> thePatternDecl.guiInfo; *)
      createPrivateAttributes;
      (none, thePatternDecl[], data[], canvasType, false, node[] -> getClassData) -> private.contentsEditor.init;
      private.contentsEditor.generateSimpleOpen;
      show;
      (if not readOnly then
          theDocument.autoSave;
      if);
   #);

-- graphicalEditorWindowItemEditorFindEditor: doPart --
do inner;
   
-- graphicalEditorCanvasEditorFindEditor: doPart --
do (if not locked then
       search: children.scan
         (# theFrame: ^rectangle;
         do (if current[] <> ignoreEditor[] then
                current.frame -> theFrame[];
                (if pt -> theFrame.containsPoint then
                    theFrame.topLeft -> pt.subTract;
                    (pt, ignoreEditor[]) -> current.findEditor -> theEditor[];
                    leave search;
                if);
            if);
         #);
       
       (if theEditor[] = None then
           this(canvasEditor)[] -> theEditor[];
       if);
   if);
   
   

   
-- GraphicalEditorEnterPrivateAttributes: doPart --
do 
   
-- GraphicalEditorExitPrivateAttributes: doPart --
do 

-- GraphicalEditorEnterPrivateDoParts: doPart --
do 

-- GraphicalEditorExitPrivateDoPart: doPart --
do 



   
-- GraphicalEditorWindowItemEditorClose: doPart --
do inner close;
   closeCodeDialog;
   
-- GraphicalEditorCanvasEditorClose: doPart --
do inner;
   children.scan
   (# 
   do current.close;
   #);
   

-- GraphicalEditorSelectionDelete: doPart --
do makeDeleteOperation;

-- GraphicalEditorSelectionShowInfo: doPart --
do (if not empty then
       (first).showInfoDialog;
   if);

-- GraphicalEditorSelectionShowCode: doPart --
do scan
   (# 
   do current.showCodeDialog;
   #);


-- SeparatorEditornew: doPart --
do inner;

-- IBSeparatorApplyObjectData: doPart --
do data.style -> theWindowItem.style;
   inner;

-- ScrollerEditorGetMainNode: doPart --
do 
   
   (theNode[], 'contentsType') -> betaGram.findAttribute -> theNode[];
   inner;

-- ScrollerEditorGetMainCanvas: doPart --
do theWindowItem.contents[] -> theCanvas[];

-- GraphicalEditorSelectionFitToContents: doPart --
do makeFitToContentsOperation;
   
-- GraphicalEditorSelectionAlignLeft: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.left - currentFrame.left, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignRight: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.right - currentFrame.right, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignTop: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.top - currentFrame.top) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignBottom: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.bottom - currentFrame.bottom) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignHorCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.right - currentFrame.left) div 2) + currentFrame.left -> itsCent;
      ((modelFrame.right - modelFrame.left) div 2) + modelFrame.left -> cent;
      (cent - itsCent, 0) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignVerCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.bottom - currentFrame.top) div 2) + currentFrame.top -> itsCent;
      ((modelFrame.bottom - modelFrame.top) div 2) + modelFrame.top -> cent;
      (0, cent - itsCent) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionShowSpacingDialog: doPart --
do (# theWindow: @window
        (# theSpacingDialog: @spacingDialog
             (# accept::
                  (# abort: @boolean;
                  do (if values.doWidth then
                         (if values.width = 0 then
                             'The width must be greater than zero' -> displayMessage;
                             true -> abort;
                         if);
                     if);
                     (if not abort then
                         (if values.doHeight then
                             (if values.height = 0 then
                                 'The height must be greater than zero' -> displayMessage;
                                 true -> abort;
                             if);
                         if);
                     if);
                     (if not abort then
                         values[] -> alignspacing;
                         theWindow.close;
                     if);
                  #);
                cancel::
                  (# 
                  do theWindow.close;
                  #);
             #);
           open::
             (# 
             do 'Spacing' -> title;
                hide;
                (contents, values[]) -> theSpacingDialog.open;
             #);
        #);
      values: ^spacingValues;
   do getSpacingValues -> values[];
      theWindow.open;
      theWindow.showModal;
   #)
   
-- graphicalEditorSelectionDoCopy: doPart --
do this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
   
-- graphicalEditorSelectionDoCut: doPart --
do this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
   makeCutOperation;

-- selectionLib: attributes --
isAncestor: booleanValue
  (# ancestor, child: ^windowItemEditor;
  enter (ancestor[], child[])
  do (if child[] = NONE then
         false -> value;
      else
         (if ancestor[] = child[] then
             true -> value;
          else
             (ancestor[], child.owner[]) -> isAncestor -> value;
         if);
     if);
  #);

moveAllowed: booleanValue
  (# theCanvasEditor: ^canvasEditor;
  enter theCanvasEditor[]
  do true -> value;
     l: 
       (# 
       do scan
          (# 
          do (if current.owner[] = theCanvasEditor[] then
                 false -> value;
                 leave l;
              else
                 (if (current[], theCanvasEditor[]) -> isAncestor then
                     false -> value;
                     leave l;
                 if);
             if);
          #);
       #);
     
  #);

makeSelectionOperation: makeOperation
  (# operationType::< selectionOperation;
     theSelection: ^windowItemEditorList;
  do copy -> theSelection[];
     inner;
  #);
makeMoveOperation: makeSelectionOperation
  (# operationType:: moveOperation;
     dh, dv: @integer;
  enter (dh, dv)
  do (theSelection[], dh, dv) -> theOperation.init;
  #);
makeChangeOwnerOperation: makeSelectionOperation
  (# operationType:: changeOwnerOperation;
     dh, dv: @integer;
     newOwner: ^canvasEditor;
  enter (newOwner[], dh, dv)
  do (theSelection[], newOwner[], dh, dv) -> theOperation.init;
  #);
makeDeleteOperation: makeSelectionOperation
  (# operationType::< deleteOperation;
  do theSelection[] -> theOperation.init;
  #);
makeCutOperation: makeDeleteOperation
  (# operationType:: cutOperation
  #);

makeChangeBoundsOperation: makeSelectionOperation
  (# operationType::< changeBoundsOperation;
     newBounds: ^rectangleList;
  do &rectangleList[] -> newBounds[];
     newBounds.init;
     inner;
     (theSelection[], newBounds[]) -> theOperation.init;
  #);
makeAlignOperation: makeChangeBoundsOperation
  (# operationType:: alignOperation;
     modelFrame: ^rectangle;
     currentFrame: ^rectangle;
     first: @boolean;
  do true -> first;
     scan
     (# 
     do (if first then
            current.frame -> modelFrame[];
            modelFrame[] -> newBounds.append;
            false -> first;
         else
            current.frame -> currentFrame[];
            inner makeAlignOperation;
            currentFrame[] -> newBounds.append;
        if);
     #);
  #);
makeFitToContentsOperation: makeChangeBoundsOperation
  (# operationType:: fitToContentsOperation;
  do scan
     (# r: ^rectangle;
     do 
        current.frame -> r[];
        current.theWindowItem.preferredSize -> r.size;
        r[] -> newBounds.append;
     #);
  #);

  
bounds:
  (# theBounds: ^rectangle;
  do &rectangle[] ->  theBounds[];
     minInt -> theBounds.right -> theBounds.bottom;
     maxInt -> theBounds.left -> theBounds.top;
     scan
     (# r: ^rectangle;
     do current.frame -> r[];
        (r.left, theBounds.left) -> Min -> theBounds.left;
        (r.top, theBounds.top) -> Min -> theBounds.top;
        (r.right, theBounds.right) -> Max -> theBounds.right;
        (r.bottom, theBounds.bottom) -> Max -> theBounds.bottom;
     #);
  exit theBounds[]
  #);

interactiveChangeHierarki:
  (# theDragger: @changeHierarkiDragger;
     event: ^windowItem.eventHandler.mouseDown;
  enter event[]
  do theDragger.init;
     (first).owner.theWindowItem[] -> theDragger.item[];
     bounds -> theDragger.bounds[];
     (event[], (first).theWindowItem[]) -> theDragger.drag
     (# 
        frame::
          (# 
          do &rectangle[] -> value[];
             theDragger.bounds -> value;
          #);
     #);
  #);

drag:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
  enter theEvent[]
  do (# oldBounds, newBounds: ^rectangle;
        dh, dv: @integer;
     do 
        bounds -> oldBounds[];
        (oldBounds[], (first).theWindowItem.father[], (contentsEditor).theWindowItem[])
          -> translateRect;
        &rectangle[] -> newBounds[];
        (oldBounds, true, true, true, true) 
          -> (contentsEditor).theWindowItem.defineRect -> newBounds;
        newBounds.left - oldBounds.left -> dh;
        newBounds.top - oldBounds.top -> dv;
        (dh, dv) -> makeMoveOperation;
     #);
  #);

stopAnts: 
  (# 
  do this(graphicalEditorEnv).private.theWalkingAnts.fullStop;
  #);
startAnts: scan
  (# 
  do current.startWalkingAnts;
  #);

selectable: booleanValue
  (# theEditor: ^windowItemEditor;
  enter theEditor[]
  do (if empty then
         true -> value;
      else
         (theEditor.owner[] = (first).owner[]) -> value;
     if);
  #);

array: sequence
  (# element::< windowItem;
     
     sortHorizontal: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.h < rightpos.h -> value;
            #);
       #);
     sortVertical: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.v < rightpos.v -> value;
            #)
       #);
     
     top: @Integer;
  #);


sort:
  (# sortedarray: ^array;
  do &array[] -> sortedarray[];
     sortedarray.init;
     scan
     (#
     do current.theWindowitem[] -> sortedarray.append;
     #);
     inner;
  exit sortedarray[]
  #);
sorthorizontal: sort
  (# 
  do sortedarray.sortHorizontal;
  #);
sortvertical: sort
  (# 
  do sortedarray.sortVertical;
  #);

alignspacing:
  (# values: ^spacingValues;
     sorted: ^Array;
  enter values[]
  do stopAnts;
     (if (values.doWidth OR values.doHeight)//true then
         scan
         (# width, height: @integer;
         do current.theWindowItem.Size -> (width, height);
            (if values.doWidth//true then values.width -> width; if);
            (if values.doHeight//true then values.height -> height; if);
            (width, height) -> current.theWindowItem.Size;
         #);
     if);
     (if values.doVerticalDist then
         SortVertical -> sorted[];
         sorted.Scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Bottom + values.verticalDist -> curPos.v;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     (if values.doHorizontalDist then
         SortHorizontal -> sorted[];
         sorted.scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Right + values.horizontalDist -> curPos.h;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     theDocument.autoSave;
     startAnts;
  #);


-- graphicalEditorEnvFind: doPart --
do search:
     private.editors.scan
     (# 
     do (if node[] -> current.node.equal then
            current[] -> editor[];
            leave search;
        if);
     #);
   
-- graphicalEditorEnvInit: doPart --
do private.editors.init;
   private.documents.init;
   &editorWalkingAnts[] -> private.theWalkingAnts[];
   private.theWalkingAnts.init;
   (theFragServer[], MPS[], pretty[]) -> theAstEditorEnv.init;
   private.theScrap.init;
   getClassInfo -> private.theClassInfo[];
   inner;
   
-- graphicalEditorEnvLib: attributes --

realFindOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     node: ^astInterface.beta.attributeDecl;
     group: ^astInterface.fragmentGroup;
  enter (node[], group[])
  do (# 
        openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theAst: ^astInterface.AST;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        doPartFrag: ^astInterface.fragmentForm;
     do 
        
        (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] <> none then
            openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
            theObjectDescriptor.getMainPart -> theMainPart[];
            theMainPart.getActionPart -> theActionPart[];
            theActionPart.getDoPartOpt -> theAst[];
            (if theAst.symbol = MPS.unExpanded then
                theAst[] -> theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot -> theSlot[];
                    theSlot.name -> group.findFragment -> doPartFrag[];
                    (if doPartFrag[] <> None then
                        doPartFrag.root[] -> theDoPart[];
                    if);
                if);
             else
                theAst[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);



scriptEditor: theAstEditorEnv.astEditor
  (# eventHandler::
       (# onAboutToClose::
            (# parseOK: @boolean;
            do (if dirty then
                   parse -> parseOK;
                   parseOK -> okToClose;
               if);
            #);
       #);
     
  #);

scanPrefixChain:
  (# node: ^astInterface.beta.attributeDecl;
     current: ^astInterface.beta.attributeDecl;
     prefixName: ^text;
     theClass: ^classInfo.class;
  enter node[]
  do node[] -> current[];
     l:
       (#
       do current[] ->  betaGram.getPrefix -> prefixName[];
          (if prefixName[] <> none then
              prefixName[] -> private.theClassInfo.lookup -> theClass[];
              (if theClass[] = NONE then
                  current[] -> getSuperPattern -> current[];
                  (if current[] <> none then
                      INNER scanPrefixChain;
                      restart l;
                  if);
              if);
          if);
       #);
  #);




getInheritedAttributes:
  (# node: ^astInterface.beta.attributeDecl;
     theAttributeList: ^attributeList;
     getPrivateAttributes:
       (# node: ^astInterface.beta.attributeDecl;
          theAttributes: ^astInterface.beta.attributes;
          frag: ^astInterface.fragmentForm;
          theDescriptorForm: ^astInterface.beta.descriptorForm;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
       enter node[]
       do node[] -> betaGram.getPrivateFragment -> frag[];
          (if frag[] <> none then
              (if frag.category = betaGram.descriptorForm then
                  frag.root[] -> theDescriptorForm[];
                  theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                  theObjectDescriptor.getMainPart -> theMainPart[];
                  theMainPart.getAttributes -> theAttributes[];
              if);
          if);
       exit theAttributes[]
       #);
     
     addAttributes:
       (# theAttributes: ^astInterface.beta.attributes
       enter theAttributes[]
       do (if theAttributes[] <> none then
              theAttributes.iterate
              (# 
              do current[] -> theAttributeList.prepend;
              #);
          if);
       #);
     addImperatives:
       (# node: ^astInterface.beta.attributeDecl;
          theNameApl: ^astInterface.beta.nameApl;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
       enter node[]
       do (node[], group[]) -> realFindOpenDoPart -> theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives -> theImperatives[];
              theImperatives.newScan
              (# doMatch: @boolean;
              do 
                 (mps[], current[], proto1[]) -> match -> doMatch;
                 (if not doMatch then
                     (mps[], current[], proto2[]) -> match -> doMatch;
                 if);
                 (if doMatch then
                     current[] -> theImperativeList.prepend;
                 if);
              #);
          if);
       #);
     theImperativeList: ^imperativeList;
     proto1, proto2: ^astInterface.AST;
     gram: @grammar;
     group: ^astInterface.fragmentGroup;
  enter (node[], group[])
  do (node.frag[], '<<evaluation>> -> <<nameApl>>', gram.imp)
       -> parseText -> proto1[];
     (node.frag[], '<<evaluation>> -> <<remote>>', gram.imp)
       -> parseText -> proto2[];
     
     &attributeList[] -> theAttributeList[];
     theAttributeList.init;
     &imperativeList[] -> theImperativeList[];
     theImperativeList.init;
     
     node[] -> scanPrefixChain
     (# 
     do current[] -> betaGram.getAttributes -> addAttributes;
        current[] -> getPrivateAttributes -> addAttributes;
        current[] -> addImperatives;
     #);
  exit (theAttributeList[], theImperativeList[])
  #);

getClass:
  (# node: ^astInterface.beta.attributeDecl;
     prefixName: ^text;
     theClass: ^classInfo.class;
     superNode: ^astInterface.beta.attributeDecl;
  enter node[]
  do node[] -> betaGram.getPrefix -> prefixName[];
          
     (if prefixName[] <> none then         
         prefixName[] -> private.theClassInfo.lookup -> theClass[];
         (if theClass[] = NONE then
             node[] -> getSuperPattern -> superNode[];
             (if superNode[] <> none then
                 superNode[] -> getClass -> theClass[];
             if);
         if);
     if);
     
  exit theClass[]
  #);

getSuperPattern:
  (# node, superNode: ^astInterface.beta.attributeDecl;
     theNameApl: ^astInterface.beta.nameApl;
     theNameDcl: ^astInterface.beta.nameDcl;
     theNames: ^astInterface.beta.names;
     dest: ^astInterface.ast;
  enter node[]
  do node[] -> betaGram.getPrefixNameApl -> theNameApl[];
     (if theNameApl[] <> none then
         (mps[], theNameApl[]) -> followSemanticLink -> dest[];
         (if (dest[] <> none) and (dest.symbol = betaGram.nameDcl) then
             dest[] -> theNameDcl[];
             theNameDcl.father -> theNames[];
             theNames.father -> superNode[];
         if);
     if);
  exit superNode[]
  #);

(* End of Class support *)


getScrap:
  (# 
  exit private.theScrap[]
  #);
insert:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.append;
  #);

delete:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.delete;
  #);



putPoint:
  (# x, y: @integer;
  enter (x, y)
  do '[' -> put;
     x -> putInt;
     ' ' -> put;
     y -> putInt;
     ']' -> put;
  #);


-- GraphicalEdioterWindowItemEditorCreateWindowItem: doPart --
do &windowItemType[] -> theWindowItem[];
   owner.getMainCanvas -> theWindowItem.open;
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[] -> theWindowItem.prependAction;
   &handleRefresh[] -> theWindowItem.appendAction;
   &handleFrameChanged[] -> theWindowItem.appendAction;
   (if not initial then
       applyObjectData;
   if);
   inner;
   
   
-- GraphicalEditorCanvasEditorCreateTheWindowItem: doPart --
do (if not (private.locked OR inherited) then
       createTheReciever;
   if);
   children.scan
   (# 
   do current.createTheWindowItem; 
   #);
   inner;
   

-- GraphicalEditorTextEditorEditorCreateTheWindowItem: doPart --
do inner; 
   
-- textEditorPictOpen: doPart --
do private.open;
   
-- textEditorPictPrivate: descriptor --
(# open:
     (# width, height: @integer;
     do true -> border.visible;
        size -> (width, height);
        
        this(textEditorPict)[] -> contents.open;
        true -> contents.delegateMouseEvents;
        ((2, 2), (width - 16, height - 16)) -> contents.frame;
        true -> contents.bindRight -> contents.bindBottom;
        
        this(textEditorPict)[] -> vScrollBar.open;
        true -> vScrollBar.delegateMouseEvents;
        vScrollBar.disableDefaultBehaviour;
        ((width - 16, 0), (width, height - 16)) -> vScrollBar.frame;
        true -> vScrollBar.bindRight;
        false -> vScrollBar.bindLeft;
        true -> vScrollBar.bindBottom;
        
        this(textEditorPict)[] -> hScrollBar.open;
        true -> hScrollBar.delegateMouseEvents;
        hScrollBar.disableDefaultBehaviour;
        ((0, height - 16), (width - 16, height)) -> hScrollBar.frame;
        true -> hScrollBar.bindRight;
        false -> hScrollBar.bindTop;
        true -> hScrollBar.bindBottom;
     #);
   contents: @canvas
     (# eventHandler::<
          (# 
             onMouseDown::
               (#
               <<SLOT textEditorPictContentsOnMousedown: doPart>>
               #)
          #)
     #);
   vScrollBar: @scrollBar
     (# vertical:: (# do true -> value #);
        
     #);
   hScrollBar: @scrollBar
     (# 
     #);
#)

-- GraphicalEditorTextEditorEditorInit: doPart --
do true -> locked;
   inner;
   
-- graphicalEditorUndo: doPart --
do (# theOperation: ^operation;
   do (if not private.undoStack.empty then
          private.undoStack.pop -> theOperation[];
          theOperation.undoIt;
          theOperation[] -> private.redoStack.push;
      if);
   #);
   
-- graphicalEditorUndoText: doPart --
do (if canUndo then
       (private.undoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanUndo: doPart --
do not private.undoStack.empty -> value;
   
-- graphicalEditorRedo: doPart --
do (# theOperation: ^operation;
   do (if not private.redoStack.empty then
          private.redoStack.pop -> theOperation[];
          theOperation.doIt;
          theOperation[] -> private.undoStack.push;
      if);
   #);
  
   
-- graphicalEditorCanRedo: doPart --
do not private.redoStack.empty -> value
   
-- graphicalEditorRedoText: doPart --
do (if canRedo then
       (private.redoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanPaste: doPart --
do not private.theClipBoard.theScrap.empty -> value;
   
-- graphicalEditorPaste: doPart --
do private.theClipBoard.makePasteOperation;
   
-- graphicalEditorEnvOpenSeparateAstEditorMethod: doPart --
do (# theEditor: ^scriptEditor;
   do node[] -> theAstEditorEnv.find -> theEditor[];
      (if theEditor[] = none then
          &scriptEditor[] -> theEditor[];
          node[] -> theEditor.init;
          title[] -> theEditor.title;
       else
          theEditor.bringToFront;
      if);
   #);
   

   
-- graphicalEditorExitMode: doPart --
do private.mode -> value;
   
-- windowItemEditorListCopy: doPart --
do &windowItemEditorList[] -> theCopy[];
   theCopy.init;
   scan
   (# 
   do current[] -> theCopy.append;
   #);
   
-- windowItemEditorListSet: doPart --
do clear;
   theOther.scan
   (# 
   do current[] -> append;
   #);
   

-- selectionAppend: doPart --
do true -> elm.private.selected;
   elm.startWalkingAnts;;
   
-- selectionPrepend: doPart --
do true -> elm.private.selected;
   elm.startWalkingAnts;
   
-- selectionDelete: doPart --
do false -> elm.private.selected;
   elm.stopWalkingAnts;
   
-- selectionClear: doPart --
do stopAnts;
   scan
   (# 
   do false -> current.private.selected;
   #);
   
-- windowItemEditorGetPublicAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       node[] -> betaGram.getAttributes -> theAttributes[];
   if);
   
-- windowItemEditorGetPrivateAttributes: doPart --
do inner;
   
-- windowItemEditorGetMainAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       getPublicAttributes -> theAttributes[];
   if);
   
-- scrollerEditorGetMainAttributes: doPart --
do (# theNode: ^astInterface.beta.attributeDecl;
   do (node[], 'contentsType') 
        -> betaGram.findAttribute -> theNode[];
      (if theNode[] = none then
          (* Failure!!! *)
       else
          theNode[] -> betaGram.getAttributes -> theAttributes[];
      if);
   #);
-- graphicalEditorShowCode: doPart --
do (contentsEditor).showCodeDialog;
   
-- windowItemEditorNewNode: doPart --
do (# theAttributes: ^astInterface.beta.attributes;
      className, instanceName: ^text;
   do owner.getMainAttributes -> theAttributes[];
      type -> getClassName -> className[];
      (type, data.id) -> freshName -> instanceName[];
      (theAttributes.frag[], instanceName[],className[])
        -> betaGram.newSingularItem -> node[];
      (* data.id -> node.guiInfo; *)
      generateSimpleOpen;
   #);
   inner;
   
-- graphicalEditorOnAboutToClose: doPart --
do (* (if not readOnly then
    *        (if theDocument.touched  then
    *            (this(graphicalEditor)[], '', 'Save changes to window before closing?') -> promptForBoolean
    *            (# 
    *               ok::
    *                 (# 
    *                 do theDocument.save;
    *                    true -> okToClose;
    *                 #);
    *               notOk::
    *                 (# 
    *                 do true -> okToClose;
    *                 #);
    *               cancel::
    *                 (# 
    *                 do false -> okToClose;
    *                 #);
    *            #);
    *        if);
    *    if);
    *)
   
-- VerSeparatorEditornew: doPart --
do (node[], (node.frag[], 'vertical', true) ->  betaGram.newBooleanBinding) -> appendAttributeToNode;
   inner;
   
-- IBVerSeparatorApplyObjectData: doPart --
do inner;
   
-- verScrollbarEditornew: doPart --
do (node[], (node.frag[], 'vertical', true) ->  betaGram.newBooleanBinding) -> appendAttributeToNode;
   inner;
   
-- IBverScrollBarapplyObjectData: doPart --
do inner;
   

   
-- scrollerEditorLib: attributes --

delegateMouseDown: theWindowItem.contents.mousedownAction
  (# 
  do theWindowItem.theEventHandler.onMouseDown; 
  #)

-- GraphicalEditorWindowItemEditorCreateInitImps: doPart --
do (if override then
       INNER;
    else
       (# x, y, width, height: @integer;
       do data.position -> (x, y);
          data.size -> (width, height);
          (betaGram.imperatives, frag[]) -> betaGram.newAst -> initImps[];
          (frag[], 'position', (frag[], x, y) -> betaGram.newPointEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'size', (frag[], width, height) -> betaGram.newPointEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindLeft', (frag[], data.bindLeft) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindRight', (frag[], data.bindRight) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindTop', (frag[], data.bindTop) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindBottom', (frag[], data.bindBottom) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
       #);
       INNER;
   if);
   
-- separatorEditorCreateInitImps: doPart --
do inner;
   
-- buttonEditorCreateInitImps: doPart --
do (frag[], 'label', (frag[], data.label) -> betaGram.newTextEvaluation)
        -> betaGram.newAssignment -> initImps.append;
   
-- optionButtonCreateInitImps: doPart --
do 
   
-- toggleButtonEditorCreateInitImps: doPart --
do 
   
-- scrollbarEditorCreateInitImps: doPart --
do
   
-- windowItemEditorCreateOpen: doPart --
do (# theDoPart: ^astInterface.beta.doPart;
      oldImps: ^astInterface.beta.imperatives;
      openDecl: ^astInterface.beta.attributeDecl;
      gram: @grammar;
   do forInitStatements -> findOpenDopart -> theDoPart[];
      (if theDoPart[] = none then
          (node.frag[],'open::< (# do #)', gram.attributeDecl) -> parseText -> openDecl[];
          (node[], openDecl[]) -> appendAttributeToNode;
          findOpenDopart -> theDoPart[];
      if);
      (* (if theDoPart[] <> none then
       *           theDoPart.frag[] -> createInitImps -> newImps[];
       *           theDoPart.getImperatives -> oldImps[];
       *       if)
       *)
      ;
      INNER createOpen;
      (* newImps[] -> theDoPart.putImperatives;
       *       (true, theDoPart.frag[], oldImps[], newImps[])
       *         -> theFragServer.notifyAstReplaced;
       *)
   #)
   
-- CanvasEditorCreateOpen: doPart --
do (* children.scan
    *    (# 
    *    do (if not current.inherited then
    *           newImps.frag[] -> current.generateOpenImp -> newImps.append;
    *       if);
    *    #);
    *)
   inner createOpen;
   
-- classDataInit: doPart --
do  (node[], group[]) -> getInheritedAttributes 
     -> (inheritedAttributes[], initImps[]);
