ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/utils/guienvadds'
        '~beta/sysutils/time'
        '~beta/sysutils/objinterface'
        '~beta/betaast/gram'
        '~beta/betaast/betasematt'
        '~beta/guienv/private/datastructures/sequence'
        '~beta/containers/list'
        '../../dialogs/confirmdialog'
        '../../dialogs/coloreditor'
        '../../dialogs/integerfield'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '~beta/guienv/utils/guienvstuff'
        '../../guienvstuff/killtranslations'
        '../../mpsstuff/mpsutils'
        '../../dialogs/distributedialog'
        '../../buildermenu'
        '~beta/guienv/utils/prompts'
        '../../resourcesupport/easyinterface'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        '../../dialogs/center'
        '../icons'
        '~beta/basiclib/binfile'
        '~beta/editor/sifnotifications';
MDBODY mac 'macintosh/graphicaleditor_mac'
       ppcmac 'macintosh/graphicaleditor_mac'
       nti 'winnt/graphicaleditor_nti'
       default 'X11/graphicaleditor_X11';
-- entryExistsBody: DoPart --
do
   false->value;
   l:
     (# e: @diskEntry; 
     do
        name[]->e.path;
        e.exists (# error::  (#  do leave l;  #);  #)->value;
        
     #);
     

-- entryReadableBody: DoPart --
do
   false->value;
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.readable (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
   if);
     

-- entryWriteAbleBody: DoPart --
do
   false->value;
   l:
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.writeAble (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
    else
       true->value; 
   if);
     

-- graphicalEditorNewEditor: DoPart --
do
     (#
        node: ^astInterface.beta.attributeDecl;
        super: ^astInterface.beta.patternDecl;
        theAttributes: ^astInterface.beta.attributes;
        name: ^text;
        vertical: @boolean;
        split:
          (# name,realName: ^text; vertical: @boolean
          enter name[]
          do
             (if name.length > 9 then
                 (if '-vertical'->((name.length-8,name.length)->name.sub).equal
                  then
                     (1,name.length-9)->name.sub->realName[]; true->vertical
                  else
                     name[]->realName[]; false->vertical
                 if)
              else
                 name[]->realName[]; false->vertical
             if)
          exit (realName[],vertical)
          #);
        
     do
        className[]->split->(className[],vertical);
        (className.copy,vertical)->makeEditor->theEditor[];
        vertical->theEditor.vertical;
        (THIS(componentEditor)[],className.copy)->theEditor.new;
        selection.clear;
        theEditor.select;
        
     #);
     

-- graphicalEditorOpen: DoPart --
do
     (# 
     do
        (5,40)->position;
        (540,400)->size;
        registerStandardItems;
        private.paletteTabber.open;
        private.statusbar.open;
        private.adorner.open;
        200->private.aTimer.start;
        5->gridSize;
        THIS(graphicalEditorEnv).factory.scan
          (# 
          do
             (if current.grouping[] <> none then
                 (current.grouping[],current.icon[],current.name[])
                   ->THIS(graphicalEditor).private.paletteTabber.addPaletteItem
             if);
             
          #);
        THIS(graphicalEditor)[]->insert;
        hide;
        'Graphical Objects'->title;
        private.theClipBoard.init;
        selectMode->private.mode;
        private.initNames;
        THIS(graphicalEditorEnv).private.theConstants[]
          ->private.thePropertyInspector.open;
        true->private.isOpen;
        
     #);
     

-- graphicalEditorClose: DoPart --
do
     (# 
     do
        false->private.isOpen;
        INNER close;
        selection.clear;
        forgetSelectionChanged;
        private.contentsEditor.close;
        THIS(graphicalEditor)[]->delete;
        private.thePropertyInspector.close;
        
     #);
     

-- graphicalEditorOnMouseDown: DoPart --
do selection.clear;   

-- windowItemEditorSelect: DoPart --
do
   (if not selected then
       (if THIS(componentEditor)[]->selection.selectable then
           THIS(componentEditor)[]->selection.append; 
        else
           beep; 
       if);
       
   if);
     

-- windowItemEditorDeSelect: DoPart --
do (if selected then THIS(componentEditor)[]->selection.delete;  if);   

-- GraphicalEditorInit: DoPart --
do
     (#
        theEditor: ^componentEditor;
        privateFrag: ^astInterface.fragmentForm;
        className: ^text;
        vertical: @boolean;
        
     do
        node.frag[]->registerFragment;
        node[]->comp.node[];
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then privateFrag[]->registerFragment;  if);
        node[]->getClassName->className[];
        node[]->getVertical->vertical;
        (if className[] <> none then
            (className[],vertical)->makeEditor->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,privateFrag[])->theEditor.init;
            INNER init;
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     

-- GraphicalEditorWindowItemEditorEditAttributes: DoPart --
do
     (#
        makeTitle:
          (# theTitle: ^text; 
          do comp.name->theTitle[]; ' : attributes'->theTitle.append; 
          exit theTitle[]
          #);
        
     do (node[],makeTitle)->com.openAstEditor; 
     #);
     

-- GraphicalEditorWindowItemEditorEditVirtual: DoPart --
do
     (#
        theAttribute,theVirtual,theEventHandler:
          ^astInterface.beta.attributeDecl;
        astToEdit: ^astInterface.AST;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        slotName: ^text;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        theAst: ^astInterface.AST;
        makeTitle:
          (# theTitle: ^text; 
          do
             comp.name->theTitle[];
             ' : '->theTitle.append;
             name[]->theTitle.append;
             
          exit theTitle[]
          #);
        frag: ^astInterface.fragmentForm;
        
     do
        node[]->theAttribute[];
        name[]->findVirtual->theVirtual[];
        (if theVirtual[] = none then
            name[]->createVirtual->theVirtual[];
            (if theVirtual[] <> none then
                (if isPrivateToWindow or (defaultBodyGroup = none ) then
                    theVirtual[]->astToEdit[]; 
                 else
                    theVirtual[]->betaGram.getObjectDescriptor
                      ->theObjectDescriptor[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getActionPart->theActionPart[];
                    theAttribute[]->betaGram.getName->slotName[];
                    name[]->slotName.append;
                    (theAttribute.frag[],slotName[])->betaGram.newSlotDoPart
                      ->theActionPart.putDoPartOpt;
                    slotName[]->betaGram.newDoPartFrag->doPartFrag[];
                    defaultBodyGroup->group[];
                    slotName[]->group.findFragment->frag[];
                    (if frag[] <> none then
                        frag.root[]->astToEdit[]; 
                     else
                        doPartFrag[]->group.fragmentList.addFragment;
                        doPartFrag.root[]->astToEdit[];
                        
                    if);
                    
                if);
                
             else
                
            if);
            
         else
            theVirtual[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getActionPart->theActionPart[];
            theActionPart.getDoPartOpt->theAst[];
            (if theAst.kind = MPS.kinds.unExpanded then
                theAst[]->theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot->theSlot[];
                    defaultBodyGroup->group[];
                    theSlot.name->group.findFragment->doPartFrag[];
                    doPartFrag.root[]->astToEdit[];
                    
                if);
                
             else
                theVirtual[]->astToEdit[]; 
            if);
            
        if);
        (astToEdit[],makeTitle)->com.openAstEditor;
        
     #);
     

-- GraphicalEditorNew: DoPart --
do
     (#
        theEditor: ^componentEditor;
        privateFrag: ^astInterface.fragmentForm;
        theDoPart: ^astInterface.beta.doPart;
        className: ^text;
        vertical: @boolean;
        
     do
        node.frag[]->registerFragment;
        9->trace (#  do comp.name->xT; '.new'->xT;  #);
        node[]->comp.node[];
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->registerFragment;
            privateFrag.father->onGroupChanged;
            
        if);
        node[]->getClassName->className[];
        node[]->getVertical->vertical;
        (if className[] <> none then
            (className[],vertical)->makeEditor->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,privateFrag[])->theEditor.init;
            9->trace (#  do 'adding open declaration'->xT #);
            theEditor.realCreateOpen->theDoPart[];
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     

-- GraphicalEditorEnterPrivateAttributes: DoPart --
do   

-- GraphicalEditorExitPrivateAttributes: DoPart --
do   

-- GraphicalEditorEnterPrivateDoParts: DoPart --
do   

-- GraphicalEditorExitPrivateDoPart: DoPart --
do   

-- GraphicalEditorSelectionDelete: DoPart --
do makeDeleteOperation;   

-- GraphicalEditorSelectionFitToContents: DoPart --
do makeFitToContentsOperation;   

-- GraphicalEditorSelectionAlignLeft: DoPart --
do
   makeAlignOperation
     (#  do (modelFrame.left-currentFrame.left,0)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignRight: DoPart --
do
   makeAlignOperation
     (# 
     do (modelFrame.right-currentFrame.right,0)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignTop: DoPart --
do
   makeAlignOperation
     (#  do (0,modelFrame.top-currentFrame.top)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignBottom: DoPart --
do
   makeAlignOperation
     (# 
     do (0,modelFrame.bottom-currentFrame.bottom)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignHorCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.right-currentFrame.left) div 2)+currentFrame.left
          ->itsCent;
        ((modelFrame.right-modelFrame.left) div 2)+modelFrame.left->cent;
        (cent-itsCent,0)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionAlignVerCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.bottom-currentFrame.top) div 2)+currentFrame.top
          ->itsCent;
        ((modelFrame.bottom-modelFrame.top) div 2)+modelFrame.top->cent;
        (0,cent-itsCent)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionShowSpacingDialog: DoPart --
do
     (#
        theDistributeDialog: @distributeDialog
          (#
             type:: windowTypes.dialog;
             onConfirm:: 
               (# 
               do
                  (if horizontalBox.state then
                      true->values.doHorizontalDist;
                      spaceFld.integerContents->values.horizontalDist;
                      
                   else
                      true->values.doVerticalDist;
                      spaceFld.integerContents->values.verticalDist;
                      
                  if);
                  values[]->alignspacing;
                  close;
                  
               #);
             onCancel::  (#  do close;  #);
             open:: 
               (# 
               do
                  'Distribute Objects'->title;
                  'Distribute Objects'->dialogTitle;
                  
               #);
             
          #);
        values: ^spacingValues;
        
     do &spacingValues[]->values[]; theDistributeDialog.open; 
     #)  

-- graphicalEditorSelectionDoCopy: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            
        if);
        
     #);
     

-- graphicalEditorSelectionDoCut: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            makeCutOperation;
            
        if);
        
     #);
     

-- graphicalEditorEnvFind: DoPart --
do
   search: private.editors.scan
     (# 
     do
        (if node[]->current.node.equal then
            current[]->editor[]; leave search; 
        if);
        
     #);
     

-- graphicalEditorEnvInit: DoPart --
do
   screen[]->tracestream[];
   private.editors.init;
   factory.init;
   private.borderConsts.init;
   private.hAlignmentConsts.init;
   private.vAlignmentConsts.init;
   ('border.style',private.borderConsts[])->registerConstants;
   ('vertical.alignment',private.vAlignmentConsts[])->registerConstants;
   ('horizontal.alignment',private.hAlignmentConsts[])->registerConstants;
   private.compiledWindowItems.init;
   INNER ;
     

-- graphicalEditorUndo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.undoStack.empty then
            private.undoStack.pop->theOperation[];
            theOperation.undoIt;
            theOperation[]->private.redoStack.push;
            
        if);
        touch;
        
     #);
     

-- graphicalEditorUndoText: DoPart --
do (if canUndo then (private.undoStack.top).name->value[];  if);   

-- graphicalEditorCanUndo: DoPart --
do not private.undoStack.empty->value;   

-- graphicalEditorRedo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.redoStack.empty then
            private.redoStack.pop->theOperation[];
            theOperation.doIt;
            theOperation[]->private.undoStack.push;
            
        if);
        touch;
        
     #);
     

-- graphicalEditorCanRedo: DoPart --
do not private.redoStack.empty->value  

-- graphicalEditorRedoText: DoPart --
do (if canRedo then (private.redoStack.top).name->value[];  if);   

-- graphicalEditorCanPaste: DoPart --
do not private.theClipBoard.theScrap.empty->value;   

-- graphicalEditorPaste: DoPart --
do private.theClipBoard.makePasteOperation;   

-- graphicalEditorExitMode: DoPart --
do private.mode->value;   

-- windowItemEditorListCopy: DoPart --
do
   &componentEditorList[]->theCopy[];
   theCopy.init;
   scan
     (#  do current[]->theCopy.append;  #);
     

-- windowItemEditorListSet: DoPart --
do clear; theOther.scan (#  do current[]->append;  #);   

-- selectionAppend: DoPart --
do true->elm.selected; selectionChanged;   

-- selectionPrepend: DoPart --
do true->elm.selected; selectionChanged;   

-- selectionDelete: DoPart --
do false->elm.selected; selectionChanged;   

-- selectionClear: DoPart --
do selectionChanged; scan (#  do false->current.selected;  #);   

-- graphicalEditorOnAboutToClose: DoPart --
do INNER ;   

-- graphicalEditorEnvGetClassName: DoPart --
do
     (#
        prefixName: ^text;
        inst: ^instantiator;
        superNode: ^astInterface.beta.attributeDecl;
        
     do
        node[]->betaGram.getPrefix->prefixName[];
        (if prefixName[] <> none then
            prefixName[]->lookup->inst[];
            (if inst[] <> none then
                prefixName[]->className[]; 
             else
                node[]->getSuperPattern->superNode[];
                (if superNode[] <> none then
                    superNode[]->getClassName->className[]; 
                if);
                
            if);
            
        if);
        
     #);
     

-- graphicalEditorEnvGetVertical: DoPart --
do ((node[],'vertical')->betaGram.findAttribute) <> none ->vertical  

-- checkIdentifierDoPart: DoPart --
do
   (if name.empty then
       false->value; 
    else
       makeFragmentForm->frag[];
       (frag[],name[],betaGram.nameDcl)->parseText->nameDecl[];
       (nameDecl[] <> none )->value;
       
   if);
     

-- graphicalEditorMousedownInItem: DoPart --
do
     (#
        value: ^rectangle;
        prox: @proxy
          (#
             moveTo:: 
               (# theCreateOperation: ^createOperation; 
               do
                  &createOperation[]->theCreateOperation[];
                  (theCanvasEditor[],newFrame[],name[])
                    ->theCreateOperation.init;
                  
               #);
             
          #);
        
     do
        &rectangle[]->value[];
        p->value.topLeft;
        name[]->getDefaultSize->value.size;
        true->prox.palette;
        (value[],prox[])
          ->THIS(graphicalEditor).private.paletteTabber.dragAndDrop
            (#
               gridSize::  (#  do THIS(graphicalEditor).gridSize->value #);
               gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #)
            #);
        
     #);
     

-- addInclude: DoPart --
do
   (if not ((group[],path[])->hasInclude) then
       'INCLUDE'
         ->group.prop.addProp
           (# ifPropExist::  (#  do false->delete #); 
           do path[]->addString
           #);
       group.loadIncludes
   if)  

-- hasInclude: DoPart --
do
   l:
   'INCLUDE'
     ->group.prop.getProp
       (#
          doProp:: 
            (# 
            do
               scanParameters
                 (#
                    doString:: 
                      (# 
                      do (if path[]->s.equal then TRUE->value; leave l if)
                      #)
                 #)
            #)
       #)  

-- createNewWindow: DoPart --
do
     (# frag: ^astInterface.fragmentForm
     do
        (name[],'guienvlib')->com.createSourceFile->frag[];
        (if frag[] <> none then (frag[],name[],'window')->createWindow if)
     #)  

-- createSourceFile: DoPart --
do
     (#
        stripExtension:
          (# path: ^text; lastDotInx,lastSlashInx: @integer; 
          enter path[]
          do
             '.'->path.findAll (#  do inx->lastDotInx #);
             MPS.thePathHandler.directoryChar
               ->path.findAll (#  do inx->lastSlashInx #);
             (if (lastDotInx > 0) and (lastDotInx > lastSlashInx) then
                 (lastDotInx,path.length)->path.delete; 
             if);
             
          #);
        createFragmentGroup:
          (# name: ^text; group: ^astInterface.fragmentGroup; 
          enter name[]
          do name[]->MPS.top.newGroup->group[]; 
          exit group[]
          #);
        createFragmentForm:
          (# name: ^text; frag: ^astInterface.fragmentForm; 
          enter name[]
          do betagram[]->MPS.newFragmentForm->frag[]; name[]->frag.name; 
          exit frag[]
          #);
        bodyGroup: ^astInterface.fragmentGroup;
        astFileName: ^text;
        betFileName: ^text;
        bodyFileName: ^text;
        bodyAstFileName: ^text;
        bodyBetFileName: ^text;
        gram: @grammar;
        guienvLocation: (#  exit '~beta/guienv/guienv' #);
        getShortName:
          (# name: ^text; shortName: ^text; lastDirCharPos: @integer; 
          enter name[]
          do
             name.reset;
             MPS.thePathHandler.directoryChar
               ->name.find (#  do inx->lastDirCharPos;  #);
             (if (lastDirCharPos > 0) and (lastDirCharPos < name.length) then
                 (lastDirCharPos+1,name.length)->name.sub->shortName[]; 
              else
                 name.copy->shortName[]; 
             if);
             
          exit shortName[]
          #);
        isOpen: booleanValue
          (# name: ^text
          enter name[]
          do (name[]->mps.top.groupTable.find) <> none ->value
          #);
        
     do
        creating:
          (#
             ok: @boolean;
             deleteFile:
               (# fName: ^text; ok: @boolean
               enter fName[]
               do
                  deleting:
                    (#
                       f: @file
                         (#
                            reportError:
                              (# reason: ^text; msg: ^text
                              enter reason[]
                              do
                                 &text[]->msg[];
                                 'The file "'->msg.putText;
                                 entry.path.name->msg.putText;
                                 '" cannot be deleted, because '->msg.putText;
                                 reason[]->msg.putText;
                                 msg[]->displayMessage;
                                 false->ok;
                                 leave deleting
                              #);
                            otherError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            AccessError:: 
                              (# 
                              do
                                 'of insufficient access priviligies.'
                                   ->reportError
                              #);
                            NoSpaceError:: 
                              (# 
                              do
                                 'there is no space left on device.'
                                   ->reportError
                              #);
                            FileExistsError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            NoSuchFileError::  (#  do true->continue #);
                            
                         #)
                    do fName[]->f.name; true->ok; f.delete
                    #)
               exit ok
               #);
             f: @file
          do
             (if fileName[] <> none then
                 fileName[]->stripExtension;
                 (fileName[],currentDirectory)
                   ->MPS.thePathHandler.convertFilePath->fileName[];
                 '.ast'->(fileName.copy).append->astFileName[];
                 '.bet'->(fileName.copy).append->betFileName[];
                 (if (astFileName[]->entryExists) or
                 (betFileName[]->entryExists) then
                     (if fileName[]->isOpen then
                         composeMsg:
                           (# str: @text
                           do
                              'The fragment group "'->str.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->str.putText;
                              '" cannot be created, because it is already open.'
                                ->str.putText;
                              str[]->displayMessage
                           #)
                      else
                         askUser:
                           (# msg: @text
                           do
                              'Replace existing "'->msg.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->msg.putText;
                              '" ?'->msg.putText;
                              (msg[],'Replace',true)
                                ->confirm
                                  (#
                                     onConfirm:: 
                                       (# 
                                       do
                                          (if astFileName[]->deleteFile then
                                              betFileName[]->deleteFile->ok
                                          if)
                                       #)
                                  #)
                           #)
                     if)
                  else
                     true->ok
                 if);
                 (if ok then
                     fileName[]->createFragmentGroup->group[];
                     (if group[] <> none then
                         'ORIGIN'
                           ->group.prop.addProp
                             (#  do guienvLocation->addString;  #);
                         fragName[]->betagram.newAttributesFrag->frag[];
                         frag[]->group.fragmentList.addFragment;
                         group.markAsChanged;
                         (group[],betFileName[])->com.prettyPrintGroup;
                         INNER createSourceFile;
                         
                     if)
                 if);
                 
             if)
          #);
        
     #)  

-- friggApplicationCreateWindow: DoPart --
do
   l:
     (#
        theAttributesForm: ^astInterface.beta.attributesForm;
        theAttributes: ^astInterface.beta.attributes;
        theAttribute: ^astInterface.beta.attributeDecl;
        theGraphicalEditor: ^graphicalEditorEnv.graphicalEditor;
        fg: ^astInterface.fragmentGroup;
        classes: ^patternList;
        classNames: @textList;
        gram: @grammar;
        
     do
        frag.father->fg[];
        frag.root[]->theAttributesForm[];
        theAttributesForm.getAttributes->theAttributes[];
        (theAttributes[],name[])->betagram.find->theAttribute[];
        (if theAttribute[] <> none then
            'The window could not be created because it already exists'
              ->displayMessage;
            
         else
              (#
                 son1: ^astInterface.ast;
                 doReplace: @boolean;
                 super: ^astInterface.beta.patternDecl;
                 
              do
              (*** Not mature yet 
               (if 'canvas'->className.equalNCS then
               name[]->recentCanvas
               if);
               
               ***)
                 (frag[],name[],className[])->betaGram.newPatternAttribute
                   ->theAttribute[];
                   (#
                      group,bodyGroup: ^astInterface.fragmentGroup;
                      bodyName: ^text;
                      t: @text;
                      decl: ^astInterface.beta.simpleDecl;
                      privateFrag,theFragment: ^astinterface.fragmentForm;
                      privateName: ^text;
                      
                   do
                      frag.father->group[];
                      (if group[] <> none then
                          l: group.scanBodyGroups
                            (# 
                            do currentFullPath[]->bodyName[]; leave l; 
                            #);
                          (if bodyName[] <> none then
                              bodyName[]->MPS.safeOpen->bodyGroup[];
                              (if bodyGroup[] <> none then
                                  'private'->(name.copy).append->privateName[];
                                  'private: @<<SLOT '->t.append;
                                  privateName[]->t.append;
                                  ': descriptor>>'->t.append;
                                  (frag[],t[],gram.simpleDecl)->parseText
                                    ->decl[];
                                  (theAttribute[],decl[])
                                    ->betaGram.appendAttribute;
                                  betaGram[]->MPS.newFragmentForm
                                    ->privateFrag[];
                                  privateName[]->privateFrag.name;
                                  privateName[]->bodyGroup.findFragment
                                    ->theFragment[];
                                  (if theFragment[] <> none then
                                      theFragment[]->bodyGroup.deleteFragment; 
                                  if);
                                  privateFrag[]
                                    ->bodyGroup.fragmentList.addFragment;
                                  (privateFrag[],none )
                                    ->betaGram.newDescriptorForm
                                    ->privateFrag.root[];
                                  bodyGroup[]->onGroupChanged;
                                  
                              if);
                              
                          if);
                          
                      if);
                      
                   #);
                 (if theAttributes.noOfsons = 1 then
                     1->theAttributes.get->son1[];
                     (if son1.kind = mps.kinds.optional then
                         true->doReplace; 
                     if);
                     
                 if);
                 (if doReplace then
                     (1,theAttribute[])->theAttributes.put; 
                  else
                     theAttribute[]->theAttributes.append; 
                 if);
                 frag.father->onGroupChanged;
                 &graphicalEditor[]->theGraphicalEditor[];
                 theGraphicalEditor.open;
                 theAttribute[]->theGraphicalEditor.new;
                 (if doReplace then
                     (son1[],theAttribute[])->frag.notifyAstReplaced;
                     frag[]->fragmentChanged;
                     
                  else
                     (theAttributes[],theAttributes.noOfSons)
                       ->frag.notifyListElementInserted;
                     frag[]->fragmentChanged;
                     
                 if);
                 
              #);
            
        if);
        
     #);
     

-- graphicalEditorEnterMode: DoPart --
do
   value->private.mode;
   (if value
    // selectMode then
       cursors.arrow[]->(contents).theCursor; 
    // hierarkiMode then
       cursors.cross[]->(contents).theCursor; 
    // resizeMode then
       cursors.plus[]->(contents).theCursor; 
   if);
     

-- graphicalEditorClearSelection: DoPart --
do selection.clear  

-- graphicalEditorOnSelectEntire: DoPart --
do selection.clear; (contentsEditor).select;   

-- wrapperHilite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- wrapperLowlite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- windowItemRubber: DoPart --
do
   graphics
     (#
        overrideChildren::  (#  do true->value #);
        adjustToGrid:
          (# x,y: @integer; 
          enter (x,y)
          do
             x-oriX->x;
             y-oriY->y;
             (if gridSize <> 0 then
                 ((x+(gridSize div 2)) div gridSize)*gridSize->x;
                 ((y+(gridSize div 2)) div gridSize)*gridSize->y
             if);
             x+oriX->x;
             y+oriY->y
          exit (x,y)
          #);
        oriX,oriY: @integer;
        
     do
        gridStart->(oriX,oriY);
        trackMouse
          (#
             topWeight,leftWeight,rightWeight,bottomWeight: @integer;
             ignore: @integer;
             adjusted: @rectangle;
             mousePress:: 
               (# 
               do
                  (if doTop then 1->topWeight;  if);
                  (if doLeft then 1->leftWeight;  if);
                  (if doRight then 1->rightWeight;  if);
                  (if doBottom then 1->bottomWeight;  if);
                  transferModes.xorBlend->pen.mode;
                  r->adjusted;
                  adjusted->drawRect;
                  
               #);
             mouseMove:: 
               (# 
               do
                  (if (h <> 0) or (v <> 0) then
                      adjusted->drawRect;
                      r.top+v*topWeight->r.top;
                      r.left+h*leftWeight->r.left;
                      r.bottom+v*bottomWeight->r.bottom;
                      r.right+h*rightWeight->r.right;
                      (if (r.bottom-r.top < 1) then
                          (if doTop then
                              r.bottom-1->r.top; 
                           else
                              r.top+1->r.bottom
                          if);
                          
                      if);
                      (if (r.right-r.left < 1) then
                          (if doLeft then
                              r.right-1->r.left; 
                           else
                              r.left+1->r.right
                          if);
                          
                      if);
                      r->adjusted;
                      (if doLeft then
                          (r.left,0)->adjustToGrid->(adjusted.left,ignore)
                      if);
                      (if doTop then
                          (0,r.top)->adjustToGrid->(ignore,adjusted.top)
                      if);
                      (if doRight then
                          (r.right,0)->adjustToGrid->(adjusted.right,ignore)
                      if);
                      (if doBottom then
                          (0,r.bottom)->adjustToGrid->(ignore,adjusted.bottom)
                      if);
                      adjusted->drawRect;
                      
                  if);
                  
               #);
             mouseRelease::  (#  do adjusted->drawRect; adjusted->r;  #);
             
          #);
        
     #)  

-- graphicalEditorEnvAddPatternToPalette: DoPart --
do
     (# theInstantiator: ^instantiator; name: ^text; prefixName: ^text; 
     do
        node[]->betaGram.getPrefix->prefixName[];
        (if prefixName[] <> none then
            prefixName[]->lookup->theInstantiator[];
            (if theInstantiator[] <> none then
                node[]->betaGram.getName->name[];
                name[]->theInstantiator.copyName->theInstantiator[];
                (node.frag.father).fullName->theInstantiator.path[];
                'Custom'->theInstantiator.grouping[];
                (name[],theInstantiator[])->factory.insts.define;
                
            if);
            
        if);
        
     #);
     

-- componentEditorCopy: DoPart --
do
     (#
        type: ##componentEditor;
        theAttributes: ^astInterface.beta.attributes;
        
     do
        THIS(componentEditor)##->type##;
        &type[]->theCopy[];
        (if frag[] = none then makeFragmentForm->frag[];  if);
        (if newNode[] = none then frag[]->node.copy->newNode[];  if);
        newNode[]->theCopy.node[];
        newNode[]->theCopy.comp.node[];
        className[]->theCopy.className[];
        vertical->theCopy.vertical;
        data.copy->theCopy.data[];
        defaultData[]->theCopy.defaultData[];
        theCopy.children.init;
        theCopy.comp.getAttributes->theAttributes[];
        children.scan
          (# new: ^astInterface.expanded; currentCopy: ^componentEditor; 
          do
             (if current.inherited then
                 (current.node.frag[],current.node[])->current.copy
                   ->currentCopy[];
                 true->currentCopy.inherited;
                 
              else
                 current.node.sonNo->theAttributes.get->new[];
                 (frag[],new[])->current.copy->currentCopy[];
                 
             if);
             currentCopy[]->theCopy.children.append;
             theCopy[]->currentCopy.owner[];
             
          #);
        
     #);
     

-- preferencesInit: DoPart --
do entries.init;   

-- preferencesRead: DoPart --
do
   l:
     (#
        prefFile: @binFile
          (#
             readError::  (#  do leave l #);
             getString:
               (# count: @integer; string: ^text; 
               do
                  getLong->count;
                  (if (count >= 0) and (count < 1000) then
                      &text[]->string[];
                      (for count repeat getByte->string.put;  for);
                      
                  if);
                  
               exit string[]
               #);
             
          #);
        read1:
          (# count: @integer; entry: ^paletteEntry; 
          do
             prefFile.getLong->count;
             (if (count >= 0) and (count < 1000) then
                 (for count repeat
                   &paletteEntry[]->entry[];
                   prefFile.getString->entry.grouping[];
                   prefFile.getString->entry.name[];
                   prefFile.getString->entry.path[];
                   prefFile.getString->entry.fragment[];
                   entry[]->entries.append;
                   
                 for);
                 
             if);
             
          #);
        tag: @text;
        theVersion: @integer;
        
     do
        preferencesFileName->prefFile.name;
        (if prefFile.entry.exists then
            prefFile.openRead;
            (for 8 repeat prefFile.getByte->tag.put;  for);
            (if 'frigpref'->tag.equal then
                prefFile.getLong->theVersion;
                (if theVersion <= version then read1;  if);
                
            if);
            prefFile.close;
            
        if);
        
     #);
     

-- preferencesWrite: DoPart --
do
   l:
     (#
        prefFile: @binFile
          (#
             writeError::  (#  do leave l;  #);
             putString:
               (# string: ^text; 
               enter string[]
               do
                  (if string[] = none then
                      0->putLong; 
                   else
                      string.length->putLong;
                      string.scanAll
                        (#  do ch->putByte;  #);
                      
                  if);
                  
               #);
             
          #);
        write1:
          (# 
          do
             1->prefFile.putLong;
             entries.size->prefFile.putLong;
             entries.scan
               (# 
               do
                  current.grouping[]->prefFile.putString;
                  current.name[]->prefFile.putString;
                  current.path[]->prefFile.putString;
                  current.fragment[]->prefFile.putString;
                  
               #);
             
          #);
        tag: @text;
        
     do
        preferencesFileName->prefFile.name;
        prefFile.openWrite;
        'frigpref'->tag;
        tag.scanAll
          (#  do ch->prefFile.putByte;  #);
        write1;
        prefFile.close;
        
     #);
     

-- initializeCustomPalette: DoPart --
do
     (# aWindow: @window; 
     do
        private.preferences.entries.scan
          (#
             openReferencedNode:
               (#
                  path: ^text;
                  fragName: ^text;
                  name: ^text;
                  node: ^astInterface.beta.attributeDecl;
                  
               enter (path[],fragName[],name[])
               do
                    (#
                       group: ^astInterface.fragmentGroup;
                       frag: ^astInterface.fragmentForm;
                       theBetaForm: ^astInterface.beta.betaForm;
                       theAttributesForm: ^astInterface.beta.attributesForm;
                       theAttributes: ^astInterface.beta.attributes;
                       
                    do (* open fragment group *)
                       path[]->mps.safeOpen->group[];
                       (if group[] <> none then (* find fragment *)
                           fragName[]->group.findFragment->frag[];
                           (if frag[] <> none then (* find node *)
                               frag.root[]->theBetaForm[];
                               (if theBetaForm.symbol = gram.attributesForm then
                                   theBetaForm[]->theAttributesForm[];
                                   theAttributesForm.getAttributes->check
                                     ->theAttributes[];
                                   (if theAttributes[] <> none then
                                       l: theAttributes.newScan
                                         (# theName: ^text; 
                                         do
                                            current[]->betaGram.getName
                                              ->theName[];
                                            theName[]->putLine;
                                            (if theName[] <> none then
                                                (if theName[]->name.equalNCS
                                                 then
                                                    current[]->node[]; leave l; 
                                                if);
                                                
                                            if);
                                            
                                         #);
                                       
                                    else
                                       'no attributes'->displayMessage; 
                                   if);
                                   
                                else
                                   'wrong type'->displayMessage; 
                               if);
                               
                            else
                               'no frag'->displayMessage; 
                           if);
                           
                        else
                           'no group'->displayMessage; 
                       if);
                       
                    #);
                  
               exit node[]
               #);
             node: ^astInterface.beta.attributeDecl;
             structure,instantiatorType: ##object;
             prefixName: ^text;
             inst,newInst: ^instantiator;
             
          do (* Open the node *)
             (current.path[],current.fragment[],current.name[])
               ->openReferencedNode->node[];
             (if node[] <> none then (* Compile it *)
                 (node[],aWindow[])->com.compilePattern->structure##;
                 (if structure## <> none then
                     (if structure## <= aWindow.windowItem## then
                         (current.name[],structure##)
                           ->private.compiledWindowItems.define;
                         
                     if);
                     
                 if);
                 (* add a factory entry *)
                 node[]->betaGram.getPrefix->prefixName[];
                 (if prefixName[] <> none then
                     prefixName[]->lookup->inst[];
                     (if inst[] <> none then
                         inst##->instantiatorType##;
                         &instantiatorType[]->newInst[];
                         true->newInst.compiled;
                         (inst.icon[],current.name[],newInst[],current.path[],
                          'Custom',inst.width,inst.height,node[],false)
                           ->factory.insert;
                         
                     if);
                     
                 if);
                 
              else
                 'unable to open node'->displayMessage; 
             if);
             
          #);
        
     #);
     

-- editorWindowRegisterItem: DoPart --
do (name[],item##)->private.itemDictionary.define  

-- editorWindowLookupItem: DoPart --
do name[]->private.itemDictionary.lookup->item##;   

-- editorWindowInterior: DoPart --
do theInterior[]->private.adorner.interior  

-- editorWindowStatus: DoPart --
do
   (if not (private.statusbar.statusLabel.label->msg.equalNCS) then
       msg[]->private.statusbar.statusLabel.label
   if)  

-- editorWindowTitleBar: DoPart --
do str[]->private.adorner.outerFrame.titlePanel.label  

-- editorWindowIsOpen: DoPart --
do private.isOpen->value;   

-- editorWindowNeededSize: DoPart --
do
     (# bounds: @rectangle; 
     do
        private.adorner.outerFrame.frame->bounds;
        bounds.right+10->width;
        bounds.bottom+10->height;
        ((width,height),private.adorner[],contents)->translate->(width,height);
        
     #);
     

