ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds'
        '~beta/sysutils/v1.6/time'
        '~beta/sysutils/v1.6/objinterface'
        '~beta/betaast/v5.2/gram'
        '~beta/betaast/v5.2/betasematt'
        '~beta/guienv/v1.6/private/datastructures/sequence'
        '~beta/containers/v1.6/list'
        '../../dialogs/confirmdialog'
        '../../dialogs/coloreditor'
        '../../dialogs/integerfield'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '~beta/guienv/v1.6/utils/guienvstuff'
        '../../guienvstuff/killtranslations'
        '../../mpsstuff/mpsutils'
        '../../dialogs/spacingdialog'
        '../../buildermenu'
        '~beta/guienv/v1.6/utils/prompts'
        '../../resourcesupport/easyinterface'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        '../../dialogs/center'
        '../icons'
        'editorwindowbody';
MDBODY mac 'macintosh/graphicaleditor_mac'
       ppcmac 'macintosh/graphicaleditor_mac'
       nti 'winnt/graphicaleditor_nti'
       default 'X11/graphicaleditor_X11';
-- entryExistsBody: DoPart --
do
   false->value;
   l:
     (# e: @diskEntry; 
     do
        name[]->e.path;
        e.exists (# error::  (#  do leave l;  #);  #)->value;
        
     #);
     

-- entryReadableBody: DoPart --
do
   false->value;
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.readable (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
   if);
     

-- entryWriteAbleBody: DoPart --
do
   false->value;
   l:
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.writeAble (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
    else
       true->value; 
   if);
     

-- InterfaceBuilderGraphicalEditorWindowMenubarOpen: DoPart --
do
   THIS(graphicalEditor).private.theFileMenu.open;
   THIS(graphicalEditor).private.theFileMenu[]->append;
   THIS(graphicalEditor).private.theEditMenu.open;
   THIS(graphicalEditor).private.theEditMenu[]->append;
   THIS(graphicalEditor).private.theAlignMenu.open;
   THIS(graphicalEditor).private.theAlignMenu[]->append;
     

-- windowitemEditornew: DoPart --
do
     (# inst: ^instantiator; theDoPart: ^astInterface.beta.doPart
     do
        className[]->lookup->inst[];
        false->inherited;
        10->trace (#  do 'new windowitem'->xT #);
        (if vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        newNode;
        node[]->getClassData->theClassData[];
        realCreateOpen->theDoPart[];
        node[]->owner.appendAttribute;
        (if inst[] <> none then
            (if inst.path[] <> none then
                (node.frag.father,inst.path[])->addInclude
            if)
        if);
        true->createTheWindowItem;
        applyObjectData;
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.appendChild; 
        if);
        (data[],true)->changeData;
        theDoPart[]->initDopart;
        
     #);
   INNER ;
     

-- canvasEditornew: DoPart --
do INNER ;   

-- graphicalEditorNewEditor: DoPart --
do
     (#
        node: ^astInterface.beta.attributeDecl;
        super: ^astInterface.beta.patternDecl;
        theAttributes: ^astInterface.beta.attributes;
        name: ^text;
        vertical: @boolean;
        split:
          (# name,realName: ^text; vertical: @boolean
          enter name[]
          do
             (if name.length > 9 then
                 (if '-vertical'->((name.length-8,name.length)->name.sub).equal
                  then
                     (1,name.length-9)->name.sub->realName[]; true->vertical
                  else
                     name[]->realName[]; false->vertical
                 if)
              else
                 name[]->realName[]; false->vertical
             if)
          exit (realName[],vertical)
          #);
        
     do
        (if theClassData[] = none then
            className[]->split->(className[],vertical);
            (className.copy,vertical)->makeEditor->theEditor[];
            vertical->theEditor.vertical;
            (THIS(canvasEditor)[],className.copy,none )->theEditor.new;
            selection.clear;
            theEditor.select;
            
         else
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theClassData.node[]->super[];
            super[]->betaGram.getName->className[];
            getMainAttributes->theAttributes[];
            (theAttributes[],className[])->newUniqueName->name[];
            (theAttributes.frag[],name[],className[])->betaGram.newSingularItem
              ->node[];
            (node[],super[])->setSemanticLink;
            node[]->appendAttribute;
            node[]->getClassData->theClassData[];
            (if theClassData[] <> none then
                (THIS(canvasEditor)[],node[],none ,false,theClassData[],none )
                  ->theEditor.init;
                theEditor.realCreateOpen;
                
            if);
            
        if);
        
     #);
     

-- graphicalEditorOpen: DoPart --
do
     (# 
     do
        5->gridSize;
        THIS(graphicalEditorEnv).private.theFactory.scan
          (# 
          do
             (if current.grouping[] <> none then
                 (current.grouping[],current.icon[],current.name[])
                   ->THIS(editorWindow).private.paletteTabber.addPaletteItem
             if);
             
          #);
        THIS(graphicalEditor)[]->insert;
        hide;
        'Graphical Objects'->title;
        private.theClipBoard.init;
        selectMode->private.mode;
        private.initNames;
        THIS(graphicalEditorEnv).private.theConstants[]
          ->private.thePropertyInspector.open;
        
     #);
     

-- graphicalEditorClose: DoPart --
do
     (# 
     do
        INNER close;
        selection.clear;
        forgetSelectionChanged;
        private.contentsEditor.close;
        THIS(graphicalEditor)[]->delete;
        private.thePropertyInspector.close;
        
     #);
     

-- graphicalEditorOnMouseDown: DoPart --
do selection.clear;   

-- windowitemEditorMousedown: DoPart --
do
   INNER ;
   (if skip then
       false->private.skip
    else
       (if not (readOnly or inherited) then
           INNER mouseDown;
           (if theEvent.doubleClick then
               showPropertyInspector; 
            else
               (if not done then
                     (# actualMode: @integer; 
                     do
                        mode->actualMode;
                        (if theEvent.shiftKey then
                            (if private.selected then
                                deSelect; 
                             else
                                select; 
                            if);
                            
                         else
                            (if not private.selected then
                                selection.clear; select; 
                            if);
                            
                        if);
                        (if private.selected then
                            pt
                              ->theWindowItem.delay
                                (#  do theEvent[]->selection.drag;  #);
                            
                        if);
                        
                     #);
                   
               if);
               
           if);
           
       if);
       
   if);
     

-- canvasEditorMousedown: DoPart --
do
   INNER mouseDown;
   (if not skip then
       (if not theEvent.doubleClick then
           (if (owner[] = none ) or (theEvent.controlKey) then
                 (#
                    r: @rectangle;
                    width,height: @integer;
                    intersectedObjects: @windowItemEditorList;
                    
                 do
                    intersectedObjects.init;
                    (theEvent.localPosition,theEvent.localPosition)->r;
                    (r,false,false,true,true)->theWindowItem.defineRect->r;
                    children.scan
                      (# itsFrame: ^rectangle; 
                      do
                         (if not current.inherited then
                             current.frame->itsFrame[];
                             (if (r,itsFrame)->itsFrame.intersection then
                                 current[]->intersectedObjects.append; 
                             if);
                             
                         if);
                         
                      #);
                    (if intersectedObjects.empty then
                        (if theEvent.shiftKey then
                            (if selected then deSelect;  else select;  if); 
                         else
                            selection.clear; select; 
                        if);
                        
                     else
                        (if theEvent.shiftKey then
                            intersectedObjects.scan
                              (# 
                              do
                                 (if current.selected then
                                     current.deSelect; 
                                  else
                                     current.select; 
                                 if);
                                 
                              #);
                            
                         else
                            selection.clear;
                            intersectedObjects.scan
                              (#  do current.select;  #);
                            
                        if);
                        
                    if);
                    true->skip;
                    
                 #);
               
           if)
       if);
       
   if);
     

-- windowItemEditorSelect: DoPart --
do
   (if not private.selected then
       (if THIS(windowItemEditor)[]->selection.selectable then
           THIS(windowItemEditor)[]->selection.append; 
        else
           beep; 
       if);
       
   if);
     

-- windowItemEditorDeSelect: DoPart --
do
   (if private.selected then THIS(windowItemEditor)[]->selection.delete;  if);
     

-- GraphicalEditorInit: DoPart --
do
     (#
        theClassData: ^classData;
        theEditor: ^windowItemEditor;
        privateFrag: ^astInterface.fragmentForm;
        
     do
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            INNER init;
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     

-- IBwindowitemEditorapplyObjectData: DoPart --
do
     (# r: @rectangle; x,y,width,height: @integer; 
     do
        data.position->(x,y);
        data.size->(width,height);
        11
          ->trace
            (# 
            do
               node[]->betaGram.getName->xT;
               '.applyObjectData'->xT;
               xN;
               'width: '->xT;
               width->xI;
               'height: '->xT;
               height->xI
            #);
        (if owner[] <> none then
            (x,y)->r.topLeft; (width,height)->r.size; r[]->frame
         else
            item.position->r.topLeft; (width,height)->r.size; r[]->frame
        if);
        
     #);
   (if hasBindings then
       data.bindLeft->item.bindLeft;
       data.bindRight->item.bindRight;
       data.bindTop->item.bindTop;
       data.bindBottom->item.bindBottom;
       
   if);
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   (if hasBorder then
       data.borderStyle->theWindowItem.border.style;
       data.borderVisible->theWindowItem.border.visible;
       
   if);
   INNER ;
     

-- IBcanvasEditorapplyObjectData: DoPart --
do INNER ;   

-- GraphicalEditorWindowItemEditorEditAttributes: DoPart --
do
     (#
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : attributes'->theTitle.append;
             
          exit theTitle[]
          #);
        
     do (node[],makeTitle)->com.openAstEditor; 
     #);
     


-- GraphicalEditorWindowItemEditorEditVirtual: DoPart --
do
     (#
        theAttribute,theVirtual,theEventHandler:
          ^astInterface.beta.attributeDecl;
        astToEdit: ^astInterface.AST;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        slotName: ^text;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        theAst: ^astInterface.AST;
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : '->theTitle.append;
             name[]->theTitle.append;
             
          exit theTitle[]
          #);
        frag: ^astInterface.fragmentForm;
        
     do
        node[]->theAttribute[];
        name[]->findVirtual->theVirtual[];
        (if theVirtual[] = none then
            name[]->createVirtual->theVirtual[];
            (if theVirtual[] <> none then
                (if isPrivateToWindow or (defaultBodyGroup = none ) then
                    theVirtual[]->astToEdit[]; 
                 else
                    theVirtual[]->betaGram.getObjectDescriptor
                      ->theObjectDescriptor[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getActionPart->theActionPart[];
                    theAttribute[]->betaGram.getName->slotName[];
                    name[]->slotName.append;
                    (theAttribute.frag[],slotName[])->betaGram.newSlotDoPart
                      ->theActionPart.putDoPartOpt;
                    slotName[]->betaGram.newDoPartFrag->doPartFrag[];
                    defaultBodyGroup->group[];
                    slotName[]->group.findFragment->frag[];
                    (if frag[] <> none then
                        frag.root[]->astToEdit[]; 
                     else
                        doPartFrag[]->group.fragmentList.addFragment;
                        doPartFrag.root[]->astToEdit[];
                        
                    if);
                    
                if);
                
             else
                
            if);
            
         else
            theVirtual[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getActionPart->theActionPart[];
            theActionPart.getDoPartOpt->theAst[];
            (if theAst.kind = MPS.kinds.unExpanded then
                theAst[]->theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot->theSlot[];
                    defaultBodyGroup->group[];
                    theSlot.name->group.findFragment->doPartFrag[];
                    doPartFrag.root[]->astToEdit[];
                    
                if);
                
             else
                theVirtual[]->astToEdit[]; 
            if);
            
        if);
        (astToEdit[],makeTitle)->com.openAstEditor;
        
     #);
     

-- GraphicalEditorWindowItemEditorInit: DoPart --
do
     (#
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        asCanvasEditor: ^canvasEditor;
		
     do
        theClassData.className[]->className[];
        true->private.initializing;
        inherited->THIS(windowItemEditor).inherited;
        10->trace (#  do 'init windowitem'->xT #);
        (if theClassData.vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        4->trace (#  do 'type -> makeData -> defaultData[]'->xT;  #);
        initialize;
        (*  defaultData.data.storage.scan
         *       (# 
         *       do (current.key[], current.value[]) -> data.data.define;
         *       #);
         *)
        (if owner[] <> none then
		    owner[] -> asCanvasEditor[];
            THIS(windowitemEditor)[]->asCanvasEditor.children.append; 
        if);
        INNER init;
        false->private.initializing;
        6
          ->trace
            (# 
            do
               node[]->betaGram.getName->xT;
               ' defaultdata: '->xT;
               xN;
               defaultData[]->xData
            #);
        6
          ->trace
            (# 
            do node[]->betaGram.getName->xT; ' data '->xT; xN; data[]->xData
            #);
        
     #);
     

-- canvasEditorInit: DoPart --
do INNER ;   

-- GraphicalEditorNew: DoPart --
do
     (#
        theClassData: ^classData;
        theEditor: ^windowItemEditor;
        privateFrag: ^astInterface.fragmentForm;
        theDoPart: ^astInterface.beta.doPart;
        
     do
        9->trace (#  do node[]->betaGram.getName->xT; '.new'->xT;  #);
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            privateFrag.father->onGroupChanged;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            9->trace (#  do 'adding open declaration'->xT #);
            theEditor.realCreateOpen->theDoPart[];
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     

-- graphicalEditorWindowItemEditorFindEditor: DoPart --
do INNER ;   

-- graphicalEditorCanvasEditorFindEditor: DoPart --
do
   (if not locked then
       search: children.scan
         (# theFrame: ^rectangle; 
         do
            (if current[] <> ignoreEditor[] then
                current.frame->theFrame[];
                (if pt->theFrame.containsPoint then
                    theFrame.topLeft->pt.subTract;
                    (pt,ignoreEditor[])->current.findEditor->theEditor[];
                    leave search;
                    
                if);
                
            if);
            
         #);
       (if theEditor[] = none then THIS(canvasEditor)[]->theEditor[];  if);
       
   if);
     

-- GraphicalEditorEnterPrivateAttributes: DoPart --
do   

-- GraphicalEditorExitPrivateAttributes: DoPart --
do   

-- GraphicalEditorEnterPrivateDoParts: DoPart --
do   

-- GraphicalEditorExitPrivateDoPart: DoPart --
do   

-- GraphicalEditorWindowItemEditorClose: DoPart --
do INNER close;   

-- GraphicalEditorCanvasEditorClose: DoPart --
do INNER ; children.scan (#  do current.close;  #);   

-- GraphicalEditorSelectionDelete: DoPart --
do makeDeleteOperation;   

-- GraphicalEditorSelectionFitToContents: DoPart --
do makeFitToContentsOperation;   

-- GraphicalEditorSelectionAlignLeft: DoPart --
do
   makeAlignOperation
     (#  do (modelFrame.left-currentFrame.left,0)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignRight: DoPart --
do
   makeAlignOperation
     (# 
     do (modelFrame.right-currentFrame.right,0)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignTop: DoPart --
do
   makeAlignOperation
     (#  do (0,modelFrame.top-currentFrame.top)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignBottom: DoPart --
do
   makeAlignOperation
     (# 
     do (0,modelFrame.bottom-currentFrame.bottom)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignHorCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.right-currentFrame.left) div 2)+currentFrame.left
          ->itsCent;
        ((modelFrame.right-modelFrame.left) div 2)+modelFrame.left->cent;
        (cent-itsCent,0)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionAlignVerCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.bottom-currentFrame.top) div 2)+currentFrame.top
          ->itsCent;
        ((modelFrame.bottom-modelFrame.top) div 2)+modelFrame.top->cent;
        (0,cent-itsCent)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionShowSpacingDialog: DoPart --
do
     (#
        theWindow: @window
          (#
             theSpacingDialog: @spacingDialog
               (#
                  accept:: 
                    (# abort: @boolean; 
                    do
                       (if values.doWidth then
                           (if values.width = 0 then
                               'The width must be greater than zero'
                                 ->displayMessage;
                               true->abort;
                               
                           if);
                           
                       if);
                       (if not abort then
                           (if values.doHeight then
                               (if values.height = 0 then
                                   'The height must be greater than zero'
                                     ->displayMessage;
                                   true->abort;
                                   
                               if);
                               
                           if);
                           
                       if);
                       (if not abort then
                           values[]->alignspacing; theWindow.close; 
                       if);
                       
                    #);
                  cancel::  (#  do theWindow.close;  #);
                  
               #);
             open:: 
               (# 
               do
                  'Spacing'->title;
                  hide;
                  (contents,values[])->theSpacingDialog.open;
                  theSpacingDialog.size->THIS(window).size;
                  center;
                  
               #);
             
          #);
        values: ^spacingValues;
        
     do getSpacingValues->values[]; theWindow.open; theWindow.showModal; 
     #)  

-- graphicalEditorSelectionDoCopy: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            
        if);
        
     #);
     

-- graphicalEditorSelectionDoCut: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            makeCutOperation;
            
        if);
        
     #);
     

-- graphicalEditorEnvFind: DoPart --
do
   search: private.editors.scan
     (# 
     do
        (if node[]->current.node.equal then
            current[]->editor[]; leave search; 
        if);
        
     #);
     

-- graphicalEditorEnvInit: DoPart --
do
   screen[]->tracestream[];
   private.editors.init;
   private.theFactory.init;
   private.infoDialogs.init;
   private.theScrap.init;
   private.borderConsts.init;
   private.hAlignmentConsts.init;
   private.vAlignmentConsts.init;
   ('border.style',private.borderConsts[])->registerConstants;
   ('vertical.alignment',private.vAlignmentConsts[])->registerConstants;
   ('horizontal.alignment',private.hAlignmentConsts[])->registerConstants;
   INNER ;
     

-- GraphicalEdioterWindowItemEditorCreateWindowItem: DoPart --
do
   &wrapper[]->item[];
   (if owner[] <> none then
       owner[] -> qua
	     (# as:: canvasEditor;
		 do thisObj.getMainCanvas->item.open;
		 #);
       &windowItemType[]->theWindowItem[];
       item[]->theWindowItem.open;
    else
       THIS(editorWindow).private.adorner.inside->item.open;
       &windowItemType[]->theWindowItem[];
       item[]->theWindowItem.open;
       item[]->THIS(editorWindow).private.adorner.interior;
       
   if);
   (if not initial then applyObjectData;  if);
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[]->theWindowItem.prependAction;
   &handleRefresh[]->theWindowItem.appendAction;
   &handleFrameChanged[]->item.appendAction;
   (if inherited then
       (theWindowItem[],none )->makeDelegateMousedownAction; 
   if);
   none ->theWindowItem.theCursor;
   INNER ;
     

-- GraphicalEditorCanvasEditorCreateTheWindowItem: DoPart --
do
   theWindowItem.scan
     (# 
     do
        (current[],THIS(canvasEditor)[])->makeDelegateMousedownAction;
        current.disableDefaultBehaviour;
        none ->current.theCursor;
        
     #);
   (if not initial then
       children.scan (#  do current.createTheWindowItem;  #); 
   if);
   INNER ;
     

-- graphicalEditorUndo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.undoStack.empty then
            private.undoStack.pop->theOperation[];
            theOperation.undoIt;
            theOperation[]->private.redoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorUndoText: DoPart --
do (if canUndo then (private.undoStack.top).name->value[];  if);   

-- graphicalEditorCanUndo: DoPart --
do not private.undoStack.empty->value;   

-- graphicalEditorRedo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.redoStack.empty then
            private.redoStack.pop->theOperation[];
            theOperation.doIt;
            theOperation[]->private.undoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorCanRedo: DoPart --
do not private.redoStack.empty->value  

-- graphicalEditorRedoText: DoPart --
do (if canRedo then (private.redoStack.top).name->value[];  if);   

-- graphicalEditorCanPaste: DoPart --
do not private.theClipBoard.theScrap.empty->value;   

-- graphicalEditorPaste: DoPart --
do private.theClipBoard.makePasteOperation;   

-- graphicalEditorExitMode: DoPart --
do private.mode->value;   

-- windowItemEditorListCopy: DoPart --
do
   &windowItemEditorList[]->theCopy[];
   theCopy.init;
   scan
     (#  do current[]->theCopy.append;  #);
     

-- windowItemEditorListSet: DoPart --
do clear; theOther.scan (#  do current[]->append;  #);   

-- selectionAppend: DoPart --
do true->elm.private.selected; selectionChanged;   

-- selectionPrepend: DoPart --
do true->elm.private.selected; selectionChanged;   

-- selectionDelete: DoPart --
do false->elm.private.selected; selectionChanged;   

-- selectionClear: DoPart --
do selectionChanged; scan (#  do false->current.private.selected;  #);   

-- windowItemEditorGetPublicAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       node[]->betaGram.getAttributes->theAttributes[]; 
   if);
     

-- windowItemEditorGetPrivateAttributes: DoPart --
do
     (#
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        
     do
        (if privateFrag[] <> none then
            privateFrag.root[]->theDescriptorForm[];
            theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            
        if);
        
     #);
   INNER ;
     

-- windowItemEditorGetMainAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       getPrivateAttributes->theAttributes[];
       (if theAttributes[] = none then
           getPublicAttributes->theAttributes[]; 
       if);
       
   if);
     

-- windowItemEditorNewNode: DoPart --
do
     (# theAttributes: ^astInterface.beta.attributes; instanceName: ^text; 
     do
        owner.getMainAttributes->theAttributes[];
        (theAttributes[],className[])->newUniqueName->instanceName[];
        (theAttributes.frag[],instanceName[],className[])
          ->betaGram.newSingularItem->node[];
        
     #);
   INNER ;
     

-- graphicalEditorOnAboutToClose: DoPart --
do INNER ;   


-- classDataInit: DoPart --
do   

-- windowEditorNewData: DoPart --
do 'untitled'->data.title; INNER ;   


-- windowItemEditorInitialize: DoPart --
do
   INNER ;
   (if not done then
         (#
            initializeData:
              (#
                 aClassData: ^classData;
                 theData: ^parameters;
                 super: @boolean;
                 
              enter (theData[],aClassData[],super)
              do
                 (if aClassData[] <> none then
                     (theData[],aClassData.superClassData[],true)
                       ->initializeData;
                     (if not super then
                         4
                           ->trace
                             (#  do 'data[] -> defaultData.set;'->xT;  #);
                         data[]->defaultData.set;
                         
                     if);
                     (theData[],aClassData.theImperatives[])->initData;
                     applyObjectData;
                     
                 if);
                 
              #);
            
         do
            true->createTheWindowItem;
            (data[],theClassData[],false)->initializeData;
            12->trace (#  do 'initializeData:'->xT; xN; data[]->xData #);
            
         #);
       
   if);
     

-- canvasEditorInitialize: DoPart --
do
     (#
        initAttributes:
          (# aClassData: ^classData; super: @boolean; 
          enter (aClassData[],super)
          do
             5
               ->trace
                 (# 
                 do 'Init attributes'->xT; aClassData.classname[]->xT
                 #);
             (if aClassData.superClassData[] <> none then
                 (aClassData.superClassData[],true)->initAttributes; 
             if);
             4->trace (#  do 'canvas init data'->xT #);
             7
               ->trace
                 (# 
                 do
                    node[]->betaGram.getName->xT;
                    ' initdata BEFORE'->xT;
                    xN;
                    data[]->xData
                 #);
             (data[],aClassData.theImperatives[])->initData;
             7
               ->trace
                 (# 
                 do
                    node[]->betaGram.getName->xT;
                    ' initdata AFTER'->xT;
                    xN;
                    data[]->xData
                 #);
             applyObjectData;
             aClassData.theAttributes.scan
               (# theEditor: ^windowItemEditor; theClassData: ^classData; 
               do
                  (if current[]->isStaticItem then
                      current[]->getClassData->theClassData[];
                      (if theClassData[] <> none then
                          (theClassData.className.copy,theClassData.vertical)
                            ->makeEditor->theEditor[];
                          (if theEditor[] <> none then
                              (THIS(canvasEditor)[],current[],none ,super,
                               theClassData[],none )->theEditor.init
                          if);
                          
                      if);
                      
                  if);
                  
               #);
             
          #);
        initAttributes2:
          (# anInst: ^instantiator; super: @boolean; 
          enter (anInst[],super)
          do
             anInst.scanAttributes
               (#
                  whenPartObject:: 
                    (# theEditor: ^windowItemEditor; theClassData: ^classData
                    do
                       current[]->getClassData->theClassData[];
                       (if theClassData[] <> none then
                           (theClassData.className.copy,theClassData.vertical)
                             ->makeEditor->theEditor[];
                           (THIS(canvasEditor)[],current[],none ,super,
                            theClassData[],none )->theEditor.init;
                           
                       if)
                    #);
                  
               #);
             
          #);
        proto: ^astInterface.AST;
        isStaticItem: booleanValue
          (# node: ^astInterface.beta.attributeDecl; 
          enter node[]
          do (mps[],node[],proto[])->match->value; 
          #);
        frag: ^astInterface.fragmentForm;
        inst: ^instantiator;
        
     do
        className[]->lookup->inst[];
        true->createTheWindowItem;
        betaGram[]->mps.newFragmentForm->frag[];
        (frag[],'<<nameDcl>>: @<<nameApl>> <<mainpart>>',betaGram.simpleDecl)
          ->parseText->proto[];
        (theClassData[],inherited)->initAttributes;
        true->done;
        
     #);
     

-- getClassDataDoPart: DoPart --
do
     (#
        superNode: ^astInterface.beta.attributeDecl;
        prefixName: ^text;
        inst: ^instantiator;
        superClassData: ^classData;
        verticalDecl: ^astInterface.beta.attributeDecl;
        
     do
        node[]->betaGram.getPrefix->prefixName[];
        (if prefixName[] <> none then
            &classData[]->theClassData[];
            node[]->theClassData.node[];
            (node[],'vertical')->betaGram.findAttribute->verticalDecl[];
            (verticalDecl[] <> none )->theClassData.vertical;
            (if prefixName[] <> none then
                prefixName[]->lookup->inst[];
                (if inst[] = none then
                    node[]->getSuperPattern->superNode[];
                    (if superNode[] <> none then
                        superNode[]->getClassData->superClassData[];
                        (if superClassData[] <> none then
                            superClassData.className[]
                              ->theClassData.className[];
                            superClassData[]->theClassData.superClassData[];
                            
                         else
                            none ->theClassData[]; 
                        if);
                        
                     else
                        none ->theClassData[]; 
                    if);
                    
                 else
                    (if inst[] <> none then
                        inst.name[]->theClassData.className[]; 
                     else
                        none ->theClassData[]; 
                    if);
                    
                if);
                
             else
                none ->theClassData[]; 
            if);
            (if theClassData[] <> none then
                node[]->getAttributes
                  ->
                    (theClassData.theAttributes[],
                     theClassData.theImperatives[]);
                
            if);
            
        if);
        
     #)  

-- checkIdentifierDoPart: DoPart --
do
   (if name.empty then
       false->value; 
    else
       makeFragmentForm->frag[];
       (frag[],name[],betaGram.nameDcl)->parseText->nameDecl[];
       (nameDecl[] <> none )->value;
       
   if);
     


-- makeDelegateMousedownAction: DoPart --
do
   (if enclosing[] = none then findEnclosing->enclosing[];  if);
   &aWindowItem.mousedownAction
     (# p: @point; 
     do
        theEvent.localPosition->p;
        (p,aWindowItem[],enclosing.theWindowItem[])->translate->p;
        (theEvent[],p)->enclosing.mouseDown;
        
     #)[]->aWindowitem.appendAction;
     

-- GraphicalEditorCanvasEditorNewData: DoPart --
do
   (if hasBorder then
       borderStyles.shadowIn->data.borderStyle; false->data.borderVisible; 
   if);
   INNER  

-- graphicalEditorEnvInsertCustom: DoPart --
do
     (# 
     do
        ((iconName[],iconID)->loadBitmap,name[],theInstantiator[],path[],
         grouping[],width,height)->private.theFactory.insert;
        
     #);
     

-- graphicalEditorMousedownInItem: DoPart --
do
     (#
        value: ^rectangle;
        prox: @proxy
          (#
             moveTo:: 
               (# theCreateOperation: ^createOperation; 
               do
                  &createOperation[]->theCreateOperation[];
                  (theCanvasEditor[],newFrame[],none ,name[])
                    ->theCreateOperation.init;
                  
               #);
             
          #);
        
     do
        &rectangle[]->value[];
        p->value.topLeft;
        name[]->getDefaultSize->value.size;
        true->prox.palette;
        (value[],prox[])
          ->THIS(editorWindow).private.paletteTabber.dragAndDrop
            (#
               gridSize::  (#  do THIS(graphicalEditor).gridSize->value #);
               gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #)
            #);
        
     #);
     

-- recievingCanvasEditorAccept: DoPart --
do
   (if not locked then
       (if dragee.palette then
           TRUE->value; 
        else
           (if (THIS(graphicalEditor).selection.first).owner[] = THIS(
           canvasEditor)[] then
               TRUE->value; 
            else
               THIS(canvasEditor)[]->THIS(graphicalEditor).selection.moveAllowed
                 ->value;
               
           if);
           
       if);
       
   if);
     

-- recievingCanvasEditorRecieve: DoPart --
do (THIS(canvasEditor)[],bounds[])->dragee.moveTo;   

-- addInclude: DoPart --
do
   (if not ((group[],path[])->hasInclude) then
       'INCLUDE'
         ->group.prop.addProp
           (# ifPropExist::  (#  do false->delete #); 
           do path[]->addString
           #);
       group.loadIncludes
   if)  

-- hasInclude: DoPart --
do
   l:
   'INCLUDE'
     ->group.prop.getProp
       (#
          doProp:: 
            (# 
            do
               scanParameters
                 (#
                    doString:: 
                      (# 
                      do (if path[]->s.equal then TRUE->value; leave l if)
                      #)
                 #)
            #)
       #)  

-- createNewWindow: DoPart --
do
     (# frag: ^astInterface.fragmentForm
     do
        (name[],'guienvlib')->com.createSourceFile->frag[];
        (if frag[] <> none then (frag[],name[],'window')->createWindow if)
     #)  

-- createSourceFile: DoPart --
do
     (#
        stripExtension:
          (# path: ^text; lastDotInx,lastSlashInx: @integer; 
          enter path[]
          do
             '.'->path.findAll (#  do inx->lastDotInx #);
             MPS.thePathHandler.directoryChar
               ->path.findAll (#  do inx->lastSlashInx #);
             (if (lastDotInx > 0) and (lastDotInx > lastSlashInx) then
                 (lastDotInx,path.length)->path.delete; 
             if);
             
          #);
        createFragmentGroup:
          (# name: ^text; group: ^astInterface.fragmentGroup; 
          enter name[]
          do name[]->MPS.top.newGroup->group[]; 
          exit group[]
          #);
        createFragmentForm:
          (# name: ^text; frag: ^astInterface.fragmentForm; 
          enter name[]
          do betagram[]->MPS.newFragmentForm->frag[]; name[]->frag.name; 
          exit frag[]
          #);
        bodyGroup: ^astInterface.fragmentGroup;
        astFileName: ^text;
        betFileName: ^text;
        bodyFileName: ^text;
        bodyAstFileName: ^text;
        bodyBetFileName: ^text;
        gram: @grammar;
        guienvLocation: (#  exit '~beta/guienv/v1.6/guienv' #);
        getShortName:
          (# name: ^text; shortName: ^text; lastDirCharPos: @integer; 
          enter name[]
          do
             name.reset;
             MPS.thePathHandler.directoryChar
               ->name.find (#  do inx->lastDirCharPos;  #);
             (if (lastDirCharPos > 0) and (lastDirCharPos < name.length) then
                 (lastDirCharPos+1,name.length)->name.sub->shortName[]; 
              else
                 name.copy->shortName[]; 
             if);
             
          exit shortName[]
          #);
        isOpen: booleanValue
          (# name: ^text
          enter name[]
          do (name[]->mps.top.groupTable.find) <> none ->value
          #);
        
     do
        creating:
          (#
             ok: @boolean;
             deleteFile:
               (# fName: ^text; ok: @boolean
               enter fName[]
               do
                  deleting:
                    (#
                       f: @file
                         (#
                            reportError:
                              (# reason: ^text; msg: ^text
                              enter reason[]
                              do
                                 &text[]->msg[];
                                 'The file "'->msg.putText;
                                 entry.path.name->msg.putText;
                                 '" cannot be deleted, because '->msg.putText;
                                 reason[]->msg.putText;
                                 msg[]->displayMessage;
                                 false->ok;
                                 leave deleting
                              #);
                            otherError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            AccessError:: 
                              (# 
                              do
                                 'of insufficient access priviligies.'
                                   ->reportError
                              #);
                            NoSpaceError:: 
                              (# 
                              do
                                 'there is no space left on device.'
                                   ->reportError
                              #);
                            FileExistsError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            NoSuchFileError::  (#  do true->continue #);
                            
                         #)
                    do fName[]->f.name; true->ok; f.delete
                    #)
               exit ok
               #);
             f: @file
          do
             (if fileName[] <> none then
                 fileName[]->stripExtension;
                 (fileName[],currentDirectory)
                   ->MPS.thePathHandler.convertFilePath->fileName[];
                 '.ast'->(fileName.copy).append->astFileName[];
                 '.bet'->(fileName.copy).append->betFileName[];
                 (if (astFileName[]->entryExists) or
                 (betFileName[]->entryExists) then
                     (if fileName[]->isOpen then
                         composeMsg:
                           (# str: @text
                           do
                              'The fragment group "'->str.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->str.putText;
                              '" cannot be created, because it is already open.'
                                ->str.putText;
                              str[]->displayMessage
                           #)
                      else
                         askUser:
                           (# msg: @text
                           do
                              'Replace existing "'->msg.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->msg.putText;
                              '" ?'->msg.putText;
                              (msg[],'Replace',true)
                                ->confirm
                                  (#
                                     onConfirm:: 
                                       (# 
                                       do
                                          (if astFileName[]->deleteFile then
                                              betFileName[]->deleteFile->ok
                                          if)
                                       #)
                                  #)
                           #)
                     if)
                  else
                     true->ok
                 if);
                 (if ok then
                     fileName[]->createFragmentGroup->group[];
                     (if group[] <> none then
                         'ORIGIN'
                           ->group.prop.addProp
                             (#  do guienvLocation->addString;  #);
                         fragName[]->betagram.newAttributesFrag->frag[];
                         frag[]->group.fragmentList.addFragment;
                         group.markAsChanged;
                         (group[],betFileName[])->com.prettyPrintGroup;
                         INNER createSourceFile;
                         
                     if)
                 if);
                 
             if)
          #);
        
     #)  

-- friggApplicationCreateWindow: DoPart --
do
   l:
     (#
        theAttributesForm: ^astInterface.beta.attributesForm;
        theAttributes: ^astInterface.beta.attributes;
        theAttribute: ^astInterface.beta.attributeDecl;
        theGraphicalEditor: ^graphicalEditorEnv.graphicalEditor;
        fg: ^astInterface.fragmentGroup;
        classes: ^patternList;
        classNames: @textList;
        gram: @grammar;
        
     do
        frag.father->fg[];
        frag.root[]->theAttributesForm[];
        theAttributesForm.getAttributes->theAttributes[];
        (theAttributes[],name[])->betagram.find->theAttribute[];
        (if theAttribute[] <> none then
            'The window could not be created because it already exists'
              ->displayMessage;
            
         else
              (#
                 son1: ^astInterface.ast;
                 doReplace: @boolean;
                 super: ^astInterface.beta.patternDecl;
                 
              do
              (*** Not mature yet 
               (if 'canvas'->className.equalNCS then
               name[]->recentCanvas
               if);
               
               ***)
                 (frag[],name[],className[])->betaGram.newPatternAttribute
                   ->theAttribute[];
                   (#
                      group,bodyGroup: ^astInterface.fragmentGroup;
                      bodyName: ^text;
                      t: @text;
                      decl: ^astInterface.beta.simpleDecl;
                      privateFrag,theFragment: ^astinterface.fragmentForm;
                      privateName: ^text;
                      
                   do
                      frag.father->group[];
                      (if group[] <> none then
                          l: group.scanBodyGroups
                            (# 
                            do currentFullPath[]->bodyName[]; leave l; 
                            #);
                          (if bodyName[] <> none then
                              bodyName[]->MPS.safeOpen->bodyGroup[];
                              (if bodyGroup[] <> none then
                                  'private'->(name.copy).append->privateName[];
                                  'private: @<<SLOT '->t.append;
                                  privateName[]->t.append;
                                  ': descriptor>>'->t.append;
                                  (frag[],t[],gram.simpleDecl)->parseText
                                    ->decl[];
                                  (theAttribute[],decl[])
                                    ->betaGram.appendAttribute;
                                  betaGram[]->MPS.newFragmentForm
                                    ->privateFrag[];
                                  privateName[]->privateFrag.name;
                                  privateName[]->bodyGroup.findFragment
                                    ->theFragment[];
                                  (if theFragment[] <> none then
                                      theFragment[]->bodyGroup.deleteFragment; 
                                  if);
                                  privateFrag[]
                                    ->bodyGroup.fragmentList.addFragment;
                                  (privateFrag[],none )
                                    ->betaGram.newDescriptorForm
                                    ->privateFrag.root[];
                                  bodyGroup[]->onGroupChanged;
                                  
                              if);
                              
                          if);
                          
                      if);
                      
                   #);
                 (if theAttributes.noOfsons = 1 then
                     1->theAttributes.get->son1[];
                     (if son1.kind = mps.kinds.optional then
                         true->doReplace; 
                     if);
                     
                 if);
                 (if doReplace then
                     (1,theAttribute[])->theAttributes.put; 
                  else
                     theAttribute[]->theAttributes.append; 
                 if);
                 frag.father->onGroupChanged;
                 &graphicalEditor[]->theGraphicalEditor[];
                 theGraphicalEditor.open;
                 theAttribute[]->theGraphicalEditor.new;
                 (if doReplace then
                     (true,frag[],son1[],theAttribute[])
                       ->theFragServer.notifyAstReplaced;
                     
                  else
                     (true,frag[],theAttributes[],theAttributes.noOfSons-1)
                       ->theFragServer.notifyListElementInserted;
                     
                 if);
                 
              #);
            
        if);
        
     #);
     

-- windowEditorApplyObjectData: DoPart --
do false->theWindowItem.border.visible; data.title->titleBar; INNER  

-- windowItemEditorOutline: DoPart --
do not theWindowItem.border.visible->value; INNER  

-- GraphicalEditorWindowItemEditorNewData: DoPart --
do
     (# width,height: @integer; vertical: @boolean
     do
        &parameters[]->data[];
        data.init;
        (0,0)->data.position;
        (if vertical then
            '-vertical'->(name.copy).append->getDefaultSize->(width,height)
         else
            name[]->getDefaultSize->(width,height)
        if);
        10
          ->trace
            (# 
            do
               name[]->xT;
               '.newData'->xT;
               xN;
               'width = '->xT;
               width->xI;
               'height = '->xT;
               height->xI
            #);
        (if width = 0 then 300->width if);
        (if height = 0 then 200->height if);
        (width,height)->data.size;
        (if hasBindings then
            true->data.bindLeft;
            false->data.bindRight;
            true->data.bindTop;
            false->data.bindBottom;
            
        if);
        (if hasBorder then
            borderStyles.shadowOut->data.borderStyle;
            false->data.borderVisible;
            
        if);
        
     #);
   INNER  

-- graphicalEditorEnterMode: DoPart --
do
   value->private.mode;
   (if value
    // selectMode then
       cursors.arrow[]->(contents).theCursor; 
    // hierarkiMode then
       cursors.cross[]->(contents).theCursor; 
    // resizeMode then
       cursors.plus[]->(contents).theCursor; 
   if);
     

-- graphicalEditorClearSelection: DoPart --
do selection.clear  

-- graphicalEditorOnSelectEntire: DoPart --
do selection.clear; (contentsEditor).select;   

-- windowItemEditorInitDopart: DoPart --
do 8->trace (#  do 'init dopart, node = '->xT; xN; node[]->xA #); INNER  

-- wrapperHilite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- wrapperLowlite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- windowItemRubber: DoPart --
do
   graphics
     (#
        overrideChildren::  (#  do true->value #);
        adjustToGrid:
          (# x,y: @integer; 
          enter (x,y)
          do
             x-oriX->x;
             y-oriY->y;
             (if gridSize <> 0 then
                 ((x+(gridSize div 2)) div gridSize)*gridSize->x;
                 ((y+(gridSize div 2)) div gridSize)*gridSize->y
             if);
             x+oriX->x;
             y+oriY->y
          exit (x,y)
          #);
        oriX,oriY: @integer;
        
     do
        gridStart->(oriX,oriY);
        trackMouse
          (#
             topWeight,leftWeight,rightWeight,bottomWeight: @integer;
             ignore: @integer;
             adjusted: @rectangle;
             mousePress:: 
               (# 
               do
                  (if doTop then 1->topWeight;  if);
                  (if doLeft then 1->leftWeight;  if);
                  (if doRight then 1->rightWeight;  if);
                  (if doBottom then 1->bottomWeight;  if);
                  transferModes.xorBlend->pen.mode;
                  r->adjusted;
                  adjusted->drawRect;
                  
               #);
             mouseMove:: 
               (# 
               do
                  (if (h <> 0) or (v <> 0) then
                      adjusted->drawRect;
                      r.top+v*topWeight->r.top;
                      r.left+h*leftWeight->r.left;
                      r.bottom+v*bottomWeight->r.bottom;
                      r.right+h*rightWeight->r.right;
                      (if (r.bottom-r.top < 1) then
                          (if doTop then
                              r.bottom-1->r.top; 
                           else
                              r.top+1->r.bottom
                          if);
                          
                      if);
                      (if (r.right-r.left < 1) then
                          (if doLeft then
                              r.right-1->r.left; 
                           else
                              r.left+1->r.right
                          if);
                          
                      if);
                      r->adjusted;
                      (if doLeft then
                          (r.left,0)->adjustToGrid->(adjusted.left,ignore)
                      if);
                      (if doTop then
                          (0,r.top)->adjustToGrid->(ignore,adjusted.top)
                      if);
                      (if doRight then
                          (r.right,0)->adjustToGrid->(adjusted.right,ignore)
                      if);
                      (if doBottom then
                          (0,r.bottom)->adjustToGrid->(ignore,adjusted.bottom)
                      if);
                      adjusted->drawRect;
                      
                  if);
                  
               #);
             mouseRelease::  (#  do adjusted->drawRect; adjusted->r;  #);
             
          #);
        
     #)  
-- graphicalEditorEnvAddPatternToPalette: doPart --
do (# theInstantiator: ^instantiator;
		name: ^text;		
		prefixName: ^text;
   do node[] -> betaGram.getPrefix -> prefixName[];
      (if prefixName[] <> NONE then
      	prefixName[] -> lookup -> theInstantiator[];
      	(if theInstantiator[] <> NONE then
      		node[] -> betaGram.getName -> name[];
      		name[] -> theInstantiator.copyName -> theInstantiator[];
      		(node.frag.father).fullName -> theInstantiator.path[];
      		'Custom' -> theInstantiator.grouping[];
      		(name[],theInstantiator[]) -> private.theFactory.insts.define;
      	if);
      if);
   #);
-- canvasEditorAppendChild: doPart --
do (# theDoPart: ^astInterface.beta.doPart;
      theImperatives: ^astInterface.beta.imperatives;
	  imp: ^astInterface.beta.imp;
	  insertInx: @integer;
   do child[]->children.append;
	  forOpenStatements->findOpenDoPart->theDoPart[];
	  (if theDoPart[] <> none then
		  theDoPart.getImperatives->theImperatives[];
		  l: theImperatives.iterate
			(# 
			do
			   current.sonNo->insertInx;
			   (if current.symbol = betaGram.innerImp then leave l;  if);
			   
			#);
		  theImperatives.frag[]->child.generateOpenImp->imp[];
		  (insertInx,imp[])->theImperatives.insert;
		  (true,theImperatives.frag[],theImperatives[],insertInx)
			->theFragServer.notifyListElementInserted;
		  
	  if);
	  
   #);

-- canvasEditorDeleteChild: doPart --
do 
     
