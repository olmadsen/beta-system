ORIGIN '../graphicaleditor';
INCLUDE '~beta/guienv/v1.3.1/utils/guienvadds';
INCLUDE '~beta/guienv/v1.3.1/utils/track';
INCLUDE '~beta/sysutils/v1.4/time';
INCLUDE '~beta/sysutils/v1.4/objinterface';
INCLUDE '~beta/betaast/v4.9.1/gram';
INCLUDE '~beta/datastructures/v0.1/sequence';
INCLUDE '~beta/datastructures/v0.1/doublelinkedlist';
INCLUDE '../../dialogs/editinfo';
INCLUDE '../../code/generate';
INCLUDE '../../asteditor/asteditor';
INCLUDE '../../palettes/palette';
INCLUDE '~beta/guienv/v1.3.1/utils/guienvstuff';
INCLUDE '~beta/guienv/v1.3.1/utils/walkingants';
INCLUDE '../../guienvstuff/killtranslations';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '../../dialogs/spacingdialog';
INCLUDE '../classinfo';
INCLUDE '../../dragmanager/dragmanager';
INCLUDE '../../buildermenu';


MDBODY default 'X11/graphicaleditor_X11body';


-- InterfaceBuilderGraphicalEditorWindowMenubarOpen: doPart --
do this(graphicalEditor).private.theFileMenu.open;
   this(graphicalEditor).private.theFileMenu[] -> append;
   this(graphicalEditor).private.theEditMenu.open;
   this(graphicalEditor).private.theEditMenu[] -> append;
   this(graphicalEditor).private.theAlignMenu.open;
   this(graphicalEditor).private.theAlignMenu[] -> append;;
   
-- lib: attributes --
getMPS: objectPool.get
  (# type:: astInterface;
     init::
       (# 
       do exception
          (# 
          do 'No instance of astInterface in objectPool' -> msg.append;
          #);
       #);
  #);

getSpacingValues: objectPool.get
  (# type:: spacingValues;
  #);

-- guienvLib: attributes --

putPoint:
  (# h, v: @integer;
  enter (h, v)
  do '[' -> put;
     h -> putInt;
     ' ' -> put;
     v -> putInt;
     ']' -> put;
  #);
putRect:
  (# r: ^rectangle;
  enter r[]
  do r.topLeft -> putPoint;
     ' ' -> put;
     r.bottomRight -> putPoint;
  #);

-- windowItemLib: attributes --

delay:
  (# startPt: @point;
  enter startPt
  do l: track
     (# 
        mouseMove::
          (# dh, dv: @integer;
          do curPt.h - startPt.h -> dh;
             curPt.v - startPt.v -> dv;
             (if (dh*2 > 4) or (dv*dv > 4) then
                 inner delay;
                 leave l;
             if);
          #);
     #);
  #);

-- windowitemEditornew: doPart --
do (# 
   do  (if data[] = none then
           newData;
       if);
      (if node[] = None then
          newNode;
          node[] -> owner.appendAttribute;
      if);
      (if this(windowItemEditor)## <= textEditorEditor## then
          this(windowItemEditor)[] -> qua
          (# as:: canvasEditor;
          do true -> thisObj.private.locked;
          #);
      if);
      
      false -> createTheWindowItem;
      (if owner[]<>None then
          this(windowitemEditor)[] -> owner.children.append;
          (# theDoPart: ^astInterface.beta.doPart;
          do owner.findOpenDoPart -> theDoPart[];
             (if theDoPart[] <> none then
                 theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
             if);
          #);
      if);
   #);
   inner;
   
   
-- windowItemEditorLib: attributes --

dragOrResize:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
     width, height: @integer;
     minBorder: (# exit 1 #);
     maxBorder: (# exit 5 #);
     borderRatio: (# exit 5 #);
     borderWidth: @integer;
     borderHeight: @integer;
     h, v: @integer;
     doLeft, doTop, doRight, doBottom: @boolean;
  enter theEvent[]
  do theWindowItem.size -> (width, height);
     (((width div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderWidth;
     (((height div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderHeight;
     theEvent.localPosition -> (h, v);
     (if (h <= borderWidth) then 
         true -> doLeft 
     if);
     (if (h >= (width - borderWidth)) then
         true -> doRight
     if);
     (if (v <= borderHeight) then
         true -> doTop
     if);
     (if (v >= (height - borderHeight)) then 
         true -> doBottom
     if);
     (if doLeft or doTop or doRight or doBottom then
         (doLeft, doTop, doRight, doBottom) -> reConfigure;
      else
         theEvent[] -> selection.drag;
     if);
  #);

closeWindowItem:
  (# 
  do traverse
     (# forEach::<
          (# 
          do current[] -> qua
             (# as:: canvasEditor;
                quaError:: (# do true -> continue #);
             do (if thisObj.private.theReciever[] <> none then
                    thisObj.private.theReciever.delete;
                    none -> thisObj.private.theReciever[];
                if);
             #);
          #);
     #);
     theWindowItem.close;
     none -> theWindowItem[];
  #);

frame:
  (# r: ^rectangle;
  enter (# enter r[]
        do (if theWindowItem[] = contentsEditorObject then
               r[] -> (contentsEditorObject).setRealFrame;
            else
               r -> theWindowItem.frame;
           if);
        #)
  exit (# 
       do (if theWindowItem[] = contentsEditorObject then
              (contentsEditorObject).getRealFrame -> r[];
           else
              &rectangle[] -> r[];
              theWindowItem.frame -> r;
          if);
       exit r[]
       #)
  #);

createShadowTree:
  (# tree: ^shadowTree;
     thisCanvasEditor: ^canvasEditor;
  do &shadowTree[] -> tree[];
     node[] -> betaGram.getName -> tree.name[];
     data.copy -> tree.data[];
     tree.children.init;
     (if this(windowItemEditor)## <= canvasEditor## then
         this(windowItemEditor)[] -> thisCanvasEditor[];
         thisCanvasEditor.children.scan
         (# 
         do current.createShadowTree -> tree.children.append;
         #);
     if);
  exit tree[]
  #);

delete:
  (# father: ^astInterface.list;
     oldElements: ^astInterface.astList;
     deleteInx: @integer;
  do closeCodeDialog;
     closeWindowItem;
     node.father -> father[];
     node.sonNo -> deleteInx;
     deleteInx -> father.delete;
     &MPS.astList[] -> oldElements[];
     oldElements.init;
     node[] -> oldElements.insert;
     (true, father.frag[], father[], deleteInx, 1, oldElements[])
       -> theFragServer.notifyListElementsDeleted;
     this(windowitemEditor)[] -> owner.children.delete;
     (#
     do data.id -> owner.deleteOpenImp;
     #);
     false -> private.selected;
  #);
reInsert:
  (# theDoPart: ^astInterface.beta.doPart;
  do this(windowitemEditor)[] -> owner.children.append;
     createTheWindowItem;
     node[] -> owner.appendAttribute;
     owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);


isPrivateToWindow: booleanValue
  (# 
  do not (node.frag[] = this(graphicalEditor).node.frag[]) -> value;
  #);

isPrivateToOwner: booleanValue
  (# 
  do (if owner[] = none then
         false -> value;
      else
         not (node.frag[] = owner.node.frag[]) -> value;
     if);
  #);

traverseCallback:
  (# current: ^windowItemEditor;
     continue: @boolean;
  enter current[]
  do true -> continue;
     inner;
  exit continue
  #);

recTraverse:
  (# callback: ^traverseCallback;
     editor: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (editor[], callback[])
  do (if editor[] -> callback then
         (if editor## <= canvasEditor## then
             editor[] -> theCanvasEditor[];
             theCanvasEditor.children.scan
             (# 
             do (current[], callback[]) -> &recTraverse;
             #);
         if);
     if);
  #);

traverse:
  (# forEach:< traverseCallback;
  do (this(windowItemEditor)[], &forEach[]) -> recTraverse;
  #);
     
closeCodeDialog:
  (# 
  do (if codeDialog[] <> none then
         codeDialog.close;
         none -> codeDialog[];
     if);
  #);
       

(* 
 * Code
 *)

appendToAttributes:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter (theAttributes[], theAttribute[])
  do (if theAttributes.empty then
         (# father: ^astInterface.expanded;
            sonNo: @integer;
            newAttributes: ^astInterface.beta.attributes;
         do theAttributes.father -> father[];
            theAttributes.sonNo -> sonNo;
            (father.frag[], theAttribute[])-> betaGram.newAttributes -> newAttributes[];
            (sonNo, newAttributes[]) -> father.put;
            (true, father.frag[], theAttributes[], newAttributes[])
              -> theFragServer.notifyAstReplaced;
         #);
      else
         theAttributes.noOfSons -> insertInx;
         theAttribute[] -> theAttributes.append;
         (true, theAttributes.frag[], theAttributes[], insertInx) 
           -> theFragServer.notifyListElementInserted;
     if)
  #);

updateOpen:
  (# theDoPart: ^astInterface.beta.doPart;
  do owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         data.ID -> owner.deleteOpenImp;
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);

prependOpenImp:
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
     do findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            (1, imp[]) -> theImperatives.insert;
            (true, theImperatives.frag[], theImperatives[], 1) 
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);

appendOpenImp:
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
        insertInx: @integer;
     do findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# 
              do (if current.hasGUIcomment then
                     current.sonNo -> insertInx;
                 if);
              #);
            (if insertInx  = theImperatives.noOfsons then
                imp[] -> theImperatives.append;
             else
                (insertInx + 1, imp[]) -> theImperatives.insert;
            if);
            (true, theImperatives.frag[], theImperatives[], insertInx)
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);



deleteOpenImp:
  (# theDoPart: ^astInterface.beta.doPart;
     id: @integer;
     failure:
       (# 
       do
       #);
  enter id
  do (# theImperatives: ^astInterface.beta.imperatives;
        deleteInx: @integer;
        oldElements: ^astInterface.astList;
     do findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            &MPS.astList[] -> oldElements[];
            oldElements.init;
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# 
              do (if current.guiInfo = id then
                     current.sonNo -> deleteInx;
                     current[] -> oldElements.insert;
                     leave l;
                 if);
              #);
            (if deleteInx <> 0 then
                
                deleteInx -> theImperatives.delete;
                (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
                  -> theFragServer.notifyListElementsDeleted;
                
            if);
        if);
     #);
  #);

generateOpenImp:
  (# name: ^text;
     theImp: ^astInterface.beta.imp;
     frag: ^astInterface.fragmentForm;
  enter frag[]
  do node[] -> betaGram.getName -> name[];
     (frag[], name[], isPrivateToOwner) 
       -> betaGram.newOpenStatement -> theImp[];
     node.guiInfo -> theImp.guiInfo;
  exit theImp[]
  #);
generateInitImp:
  (# frag: ^astInterface.fragmentForm;
     theImp: ^astInterface.beta.imp;
  enter frag[]
  do (frag[], data.id) 
       -> betaGram.newInitFromResourceStatement 
       -> theImp[];
     0 -> theImp.guiInfo;
  exit theImp[]
  #);
updateInitImp:
  (# theDoPart: ^astInterface.beta.doPart;
  do findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         0 -> deleteOpenImp;
         theDoPart.frag[] -> generateInitImp -> prependOpenImp;
     if);
  #);
findVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
        if);
        (if currentNode[] <> none then
             (currentNode[], name[]) -> betaGram.findAttribute-> theVirtual[];
        if);
     #);
  exit theVirtual[]
  #);

appendAttributeToNode:
  (# node, theAttribute: ^astInterface.beta.attributeDecl;
  enter (node[], theAttribute[])
  do 
     (# theAttributes: ^astInterface.beta.attributes;
        insertInx: @integer;
     do node[] -> betaGram.getAttributes -> theAttributes[];
        (theAttributes[], theAttribute[]) -> appendToAttributes;
     #);
  #);

createVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
        theAttribute: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[] -> theAttribute[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
            (if currentNode[] = none then
                (theAttribute.frag[], 'eventHandler', none) -> betaGram.newVirtualBinding -> currentNode[];
                (theAttribute[], currentNode[]) -> appendAttributeToNode;
            if);
        if);
        (currentNode.frag[], name[], none) -> betaGram.newVirtualBinding -> theVirtual[];
        (currentNode[], theVirtual[]) -> appendAttributeToNode;
     #);
  exit theVirtual[]
  #);


handleAstReplaced:
  (# oldAst, newAst: ^astInterface.AST;
     succes: @boolean;
  enter (oldAst[], newAst[])
  do false -> succes;
     (if oldAst[] -> node.equal then
         newAst[] -> node[]; (* !!! Check for validitet *)
         true -> succes;
      else
         (if (node[], newAst[]) -> isAncestor then
             true -> succes;
          else
             (if (oldAst[], node[]) -> isAncestor then
                 (# theAttributes: ^astInterface.beta.attributes;
                 do owner.getMainAttributes -> theAttributes[];
                    (if theAttributes[] <> none then
                        l: theAttributes.iterate
                        (# 
                        do (if current.hasGUIcomment then
                               (if data.ID = current.guiInfo then
                                   current[] -> node[];
                                   true -> succes;
                                   leave l;
                               if);
                           if);
                        #);
                    if);
                 #);
              else
                 true -> succes;
             if);
         if);
     if);
  exit succes
  #);



createOpenDopart:
  (# theDoPart: ^astInterface.beta.doPart;
     main: @boolean;
  enter main
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        slotName: ^text;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theUnExpanded: ^astInterface.unExpanded;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        isPrivate: @boolean;
     do (if main then
            getMainNode -> node[];
         else
            this(windowItemEditor).node[] -> node[];
        if);
        
        (node.frag[], 'open', none) -> betaGram.newVirtualBinding -> openDecl[];
        (node[], openDecl[]) -> appendAttributeToNode;
        openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
        (if isPrivateToWindow then
            node.frag[] -> betaGram.newDoPart ->  theDoPart[];
            (theObjectDescriptor[], theDoPart[]) -> betaGram.setDoPart; (* !!! NOTIFY !!! *)
         else
            node[] -> betaGram.getName -> slotName[];
            'Open' -> slotName.append;
            (node.frag[], slotName[]) -> betaGram.newSlotDoPart -> theUnExpanded[];
            (theObjectDescriptor[], theUnExpanded[]) -> betaGram.setDoPart;
            slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
            body -> group[];
            doPartFrag[] -> group.fragmentList.addFragment;
            doPartFrag.root[] -> theDoPart[];
        if);
     #);
  exit theDoPart[]
  #);

findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     main: @boolean;
  enter main
  do (# node: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theAst: ^astInterface.AST;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
     do (if main then
            getMainNode -> node[];
         else
            this(windowItemEditor).node[] -> node[];
        if);
        (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] <> none then
            openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
            theObjectDescriptor.getMainPart -> theMainPart[];
            theMainPart.getActionPart -> theActionPart[];
            theActionPart.getDoPartOpt -> theAst[];
            (if theAst.symbol = MPS.unExpanded then
                theAst[] -> theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot -> theSlot[];
                    body -> group[];
                    theSlot.name -> group.findFragment -> doPartFrag[];
                    (if doPartFrag[] <> None then
                        doPartFrag.root[] -> theDoPart[];
                    if);
                if);
             else
                theAst[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);

generateSimpleOpen: (* !!! NOTIFY !!! *)
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives, oldImperatives: ^astInterface.beta.imperatives;
     theImp: ^astInterface.beta.imp;
     theInnerImp: ^astInterface.beta.innerImp;
  do false -> createOpenDopart -> theDoPart[];
     (betaGram.imperatives, theDoPart.frag[]) 
       -> betaGram.newAst 
       -> theImperatives[] 
       -> theDoPart.putImperatives;
     (theDoPart.frag[], data.id) 
       -> betaGram.newInitFromResourceStatement 
       -> theImp[]
       -> theImperatives.smartAppend;
     0 -> theImp.guiInfo;
     (if node.symbol = betaGram.patternDecl then
         (betaGram.innerImp, theDoPart.frag[]) 
           -> betaGram.newAst 
           -> theInnerImp[]
           -> theImperatives.smartAppend;
         (betaGram.nameApl, theDoPart.frag[]) 
           -> betaGram.newOptional 
           -> theInnerImp.putNameAplOpt;
     if);
  #);

changeOwnerOld:
  (# newOwner: ^canvasEditor;
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     theFather: ^astInterface.beta.attributes;
     currentOwner: ^canvasEditor;
     oldDoPart: ^astInterface.beta.doPart;
     newDoPart: ^astInterface.beta.doPart;
     
  enter newOwner[]
  do 
     node[] -> theAttribute[];
     theAttribute.father -> theFather[];
     theAttribute.sonNo -> theFather.delete;
     theAttribute[] -> newOwner.appendAttribute;
     owner[] -> currentOwner[];
     newOwner[] -> owner[];
     
     closeWindowItem;
     None -> theWindowItem[];
     this(windowItemEditor)[] -> currentOwner.children.delete;
     this(windowItemEditor)[] -> newOwner.children.append;
     createTheWindowItem;
     
     true -> newOwner.findOpenDoPart -> newDoPart[];
     data.id -> currentOwner.deleteOpenImp; 
     (if newDoPart[] <> none then
         newDoPart.frag[] -> generateOpenImp -> newOwner.appendOpenImp;
     if);
     
  #);

changeOwner:
  (# newOwner: ^canvasEditor;  
  enter newOwner[]
  do delete;
     newOwner[] -> owner[];
     reInsert;
  #);

handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do theEvent[] -> this(windowItemEditor).mousedown;
  #);
handleFrameChanged: theWindowItem.frameChangedAction
  (# r: ^rectangle
  do (if theWindowItem[]<>none then
         (if data[]<>none then
             frame -> r[];
             r.topLeft -> data.position;
             r.size  -> data.size;
             (if private.selected then
                 (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
                 startWalkingAnts;
             if);
         if);
     if);
  #);

startWalkingAnts:
  (# 
  do theWindowItem[] -> this(graphicalEditorEnv).private.theWalkingAnts.attach;
  #);
stopWalkingAnts:
  (# 
  do (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
  #);
handleRefresh: theWindowItem.refreshAction
  (#
  #);

reConfigure:
  (# doLeft,doTop,doRight,doBottom: @boolean;
     bounds: ^rectangle;
     newOwner: ^canvasEditor;
  enter (doLeft,doTop,doRight,doBottom)
  do 
     frame -> bounds[];
     (bounds[],  theWindowItem.father[], (contentsEditor).theWindowItem[]) 
       -> translateRect;
     (bounds,doLeft,doTop,doRight,doBottom) -> (contentsEditor).theWindowItem.defineRect -> bounds;
     (bounds.topLeft, (contentsEditor).theWindowItem[], theWindowItem.father[]) 
       -> translate -> bounds.topLeft;
     (bounds.bottomRight, (contentsEditor).theWindowItem[], theWindowItem.father[]) 
       -> translate -> bounds.bottomRight;
     (this(windowItemEditor)[], bounds[]) -> makeResizeOperation;
  #);

-- windowitemEditorPrivate: descriptor --
(# selected: @boolean;
   pos: ^windowItemEditorList.position;
   node: ^astInterface.AST;
#)

-- canvasEditornew: doPart --
do (if theWindowItem[]<>contents then
       borderStyles.shadowIn -> theWindowItem.border.style;
       true -> theWindowItem.border.visible;
   if);
   inner;

-- abstractScrollerEditornew: doPart --
do false -> theWindowItem.border.visible;
   (# 
      theAttributes: ^astInterface.beta.attributes;
   do 
      node[] -> betaGram.getAttributes -> theAttributes[];
      (node.frag[], 'contentsType', none) 
        -> betaGram.newVirtualBinding 
        -> theAttributes.smartAppend;
   #);
   inner;

-- scrollerEditornew: doPart --
do 
   inner;

-- textEditorEditornew: doPart --
do true -> locked;
   inner;

-- controlEditornew: doPart --
do inner;

-- buttonEditornew: doPart --
do 
   inner;

-- pushButtonEditornew: doPart --
do inner;

-- iconButtonEditornew: doPart --
do 
   inner;

-- optionButtonEditornew: doPart --
do inner;

-- staticTextEditornew: doPart --
do inner;

-- toggleButtonEditornew: doPart --
do 
   inner;

-- radioButtonEditornew: doPart --
do inner;

-- checkBoxEditornew: doPart --
do inner;

-- scrollbarEditornew: doPart --
do 
   inner;

-- editTextEditornew: doPart --
do 
   inner;

-- textFieldEditornew: doPart --
do inner;

-- scrollListEditornew: doPart --
do inner;

-- textScrollListEditornew: doPart --
do inner;

-- graphicalEditorNewEditor: doPart --
do this(graphicalEditor).private.editorGenerator[type] -> theEditor[];
   (this(canvasEditor)[],type) -> theEditor.new;
   selection.clear;
   theEditor.select;


-- graphicalEditorOpen: doPart --
do (# 
   do contents -> private.theDragManager.init;
      this(graphicalEditor)[] -> insert;
      hide;
      'Graphical Objects' -> title;
      getMPS -> MPS[];
      getClassInfo -> private.theClassInfo[];
      MPS.grammarTable.beta[] -> betaGram[];
      (600, 500) -> size;
      private.theClipBoard.init;
      private.theControlPalette.open;
      private.theViewsPalette.open;
      private.theToolPalette.open;
      selectMode -> private.mode;
      private.initEditorGenerator;
      private.initNames;
      private.initSizes;
      
   #);

-- graphicalEditorClose: doPart --
do (# 
   do inner close;
      selection.clear;
      private.contentsEditor.close;
      this(graphicalEditor)[] -> delete;
   #);
-- graphicalEditorOnMouseDown: doPart --
do 
   
-- graphicalEditorLib: attributes --


(*
 * container types
 *)

rectangleList: sequence
  (# element:: rectangle;
  #);

stack: sequence
  (# 
     push:
       (# doAppend: @append;
       enter doAppend
       #);
     pop:
       (# doDeleteLast: @deleteLast;
       exit doDeleteLast
       #);
     top:
       (# doLast: @last;
       exit doLast
       #);
  #);


(*
 * Clipboard
 *)

clipBoard:
  (# init:
       (# 
       do getScrap -> this(clipBoard).theScrap[];
       #);
     
     theScrap: ^scrap;
     
     copyToScrap:
       (# theSelection: ^windowItemEditorList;
       enter theSelection[]
       do theScrap.clear;
          theSelection.scan
          (# scrapElm: ^scrap.element;
             frag: ^astInterface.fragmentForm;
          do &theScrap.element[] -> scrapElm[];
             current.createShadowTree  -> scrapElm.tree[];
             current.node.frag[] -> frag[];
             frag[] -> current.node.copy -> scrapElm.node[];
             scrapElm[] -> theScrap.append;
          #);
       #);
     
     createEditor:
       (# node: ^astInterface.beta.attributeDecl;
          owner: ^canvasEditor;
          tree: ^shadowTree;
          editor: ^windowItemEditor;
          data: ^objectData;
          type: @integer;
          top: @boolean;
       enter (node[], owner[], tree[], top)
       do tree.data.type -> type;
          this(graphicalEditor).private.editorGenerator[type] -> editor[];
          owner[] -> editor.owner[];
          
          type -> theObjectStore.new -> data[];
          tree.data[] -> data.set;
          none -> node.addComment;
          data.id -> node.guiInfo;
          node[] -> editor.node[];
          data[] -> editor.data[];
          editor.updateInitImp;
          (if top then
              (node[], (type, data.id) -> freshName) -> betaGram.setName;
           else
              editor[] -> owner.children.append;
          if);
          tree.children.scan
          (# subNode: ^astInterface.beta.attributeDecl;
          do (node[], current.name[]) -> betaGram.findAttribute -> subNode[];
             (subNode[], editor[], current[], false) -> &createEditor;
          #);
       exit editor[]
       #);
     
     makePasteOperation: makeOperation
       (# operationType:: pasteOperation;
          theSelection: ^windowitemEditorList;
           theAttributes: ^astInterface.beta.attributes;
       do &windowitemEditorList[] -> theSelection[];
          (contentsEditor).getMainAttributes -> theAttributes[];
          theScrap.scan
          (# node: ^astInterface.beta.attributeDecl;
          do theAttributes.frag[] -> current.node.copy -> node[];
             (node[], contentsEditor, current.tree[], true) -> createEditor -> theSelection.append;
          #);
          theSelection[] -> theOperation.init;
       #);
     
     (* makePasteOperation: makeOperation
      *        (# operationType:: pasteOperation;
      *           theSelection: ^windowitemEditorList;
      *           theAttributes: ^astInterface.beta.attributes;
      *        do &windowitemEditorList[] -> theSelection[];
      *           theSelection.init;
      *           (contentsEditor).getMainAttributes -> theAttributes[];
      *           theScrap.scan
      *           (# theEditor: ^windowItemEditor;
      *              type: @integer;
      *              data: ^objectData;
      *              node: ^astInterface.beta.attributeDecl;
      *              name: ^text;
      *           do current.tree.data.position.h + 2 -> current.tree.data.position.h;
      *              current.tree.data.position.v + 2 -> current.tree.data.position.v;
      *              current.tree.data.type -> type;
      *              this(graphicalEditor).private.editorGenerator[type] -> theEditor[];
      *              contentsEditor -> theEditor.owner[];
      *              type -> theObjectStore.new -> data[];
      *              current.tree.data[] -> data.set;
      *              data[] -> theEditor.data[];
      *              theAttributes.frag[] -> current.node.copy -> node[];
      *              (type, data.id) -> freshName -> name[];
      *              (node[], name[]) -> betaGram.setName;
      *              none -> node.addComment;
      *              data.id -> node.guiInfo;
      *              node[] -> theEditor.node[];
      *              theEditor[] -> theSelection.append;
      *           #);
      *           theSelection[] -> theOperation.init;
      *        #);
      *)
  #);


(*
 * Generating names
 *)

getClassName:
  (# type: @integer;
     name: ^text;
  enter type
  do private.names[type][] -> name[];
  exit name[]
  #);
freshName:
  (# type: @integer;
     id: @integer;
     name: ^text;
  enter (type, id)
  do (type -> getClassName).copy -> name[];
     id -> name.putInt;
  exit name[]
  #);

(*
 * Default sizes
 *)

getDefaultSize:
  (# width, height: @integer;
     type: @integer;
  enter type
  do private.sizes[type] -> (width, height);
  exit (width, height)
  #);

(*
 * Classes for supporting undo 
 *)

clearRedoStack:
  (# 
  do private.redoStack.clear;
  #);
pushUndoStack:
  (# theOperation: ^operation;
  enter theOperation[]
  do theOperation[] -> private.undoStack.push;
  #);

operation:
  (# doIt:<
       object;
     unDoIt:<
       object;
     init:<
       (# 
       do 
          inner;
          clearRedoStack;
          this(operation)[] -> pushUndoStack;
       #);
     name:<
       (# value: ^text;
       do inner;
       exit value[]
       #);
  #);

makeOperation:
  (# operationType:< operation;
     theOperation: ^operationType;
  do &operationType[] -> theOperation[];
     inner;
  #);

singleOperation: operation
  (# 
     theEditor: ^windowItemEditor;
     init::<
       (# 
       enter theEditor[]
       do inner;
       #);
  #);

resizeOperation: singleOperation
  (# oldFrame, newFrame: ^rectangle;
     
     init::
       (# 
       enter newFrame[]
       do theEditor.frame -> oldFrame[];
          newFrame[] -> theEditor.frame;
       #);
     doIt::
       (# 
       do newFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do oldFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);

makeSingleOperation: makeOperation
  (# operationType::< singleOperation;
     theEditor: ^windowItemEditor;
  enter theEditor[]
  do inner;
  #);
makeResizeOperation: makeSingleOperation
  (# operationType:: resizeOperation;
     newFrame: ^rectangle;
  enter newFrame[]
  do (theEditor[], newFrame[]) -> theOperation.init;
  #);

selectionOperation: operation
  (# theSelection: ^windowItemEditorList;
     setSelection:
       (# 
       do selection.clear;
          inner;
          theSelection[] -> selection.set;
       #);
     init::<
       (# 
       enter theSelection[]
       do inner;
       #);
  #);
moveOperation: selectionOperation
  (# dh, dv: @integer;
     init::<
       (# 
       enter (dh, dv)
       do doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do (dh, dv) -> current.theWindowItem.move;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do (-dh, -dv) -> current.theWindowItem.move;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeOwnerOperation: selectionOperation
  (# dh, dv: @integer;
     newOwner, oldOwner: ^canvasEditor;
     init::
       (# 
       enter (newOwner[], dh, dv)
       do (theSelection.first).owner[] -> oldOwner[];
          doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h + dh, v + dv) -> current.data.position;
             newOwner[] -> current.changeOwner;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h - dh, v - dv) -> current.data.position;
             oldOwner[] -> current.changeOwner;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeBoundsOperation: selectionOperation
  (# newBounds, oldBounds: ^rectangleList;
     init::
       (# 
       enter newBounds[]
       do &rectangleList[] -> oldBounds[];
          oldBounds.init;
          theSelection.scan
          (#
          do current.frame -> oldBounds.append;
          #);
          doIt;
       #);
     doIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# 
          do inx -> newBounds.get -> current.frame;
             inx + 1 -> inx;
          #);
       #);
     unDoIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# r: ^rectangle;
          do inx -> oldBounds.get -> current.frame;
             inx + 1 -> inx;
          #);
       #);
  #);
alignOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Alignment' -> value[];
          inner;
       #);
  #);
fitToContentsOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Fit to contents' -> value[];
          inner;
       #);
  #);
spacingOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Spacing' -> value[];
          inner;
       #);
  #);

createOperation: operation
  (# bounds: ^rectangle;
     owner: ^canvasEditor;
     type: @integer;
     theEditor: ^windowItemEditor;
     init::
       (# 
       enter (owner[], type, bounds[])
       do selection.clear;
          type -> owner.newEditor -> theEditor[];
          bounds[] -> theEditor.frame;
       #);
     doIt::
       (# 
       do selection.clear;
          theEditor.reInsert;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          theEditor.delete;
       #);
     name::<
       (# 
       do 'New' -> value[];
       #);
  #);

deleteOperation: selectionOperation
  (# 
     init::
       (# 
       do doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     name::<
       (# 
       do inner;
          (if value[] = none then
              'Delete' -> value[];
          if);
       #);
  #);
cutOperation: deleteOperation
  (# name::<
       (# 
       do 'Cut' -> value[];
       #);
  #);
pasteOperation: selectionOperation
  (# name::<
       (# 
       do 'Paste' -> value[];
       #);
     init::
       (# 
       do doIt;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     unDoIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
  #);
dialogOperation: singleOperation
  (# oldData, newData: ^scrapData;
     init::
       (# 
       enter newData[]
       do theEditor.data.copy -> oldData[];
          doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          newData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          oldData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     name::<
       (# 
       do 
          'Dialog' -> value[];
       #);
  #);
makeDialogOperation: makeSingleOperation
  (# operationType:: dialogOperation;
     data: ^scrapData;
  enter data[]
  do (theEditor[], data[]) -> theOperation.init;
  #);
changeWindowSizeOperation: operation
  (# width, height: @integer;
     oldWidth, oldHeight: @integer;
     init::
       (# 
       enter (width, height)
       do (contentsEditor).getSize -> (oldWidth, oldHeight);
          doIt;
       #);
     doIt::
       (# 
       do (width, height) -> (contentsEditor).setSize;
       #);
     unDoIt::
       (# 
       do (oldWidth, oldHeight) -> (contentsEditor).setSize;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);
makeChangeWindowSizeOperation: makeOperation
  (# operationType::< changeWindowSizeOperation;
     width, height: @integer;
  enter (width, height)
  do (width, height) -> theOperation.init;
  #);
(* End of undo *)


(* 
 * drag and drop  
 *)

changeHierarkiDragger: private.theDragManager.changeHierarkiDragger
  (# 
  #);

createDragger: private.theDragManager.createDragger
  (# 
  #);
  

reciever: private.theDragManager.reciever
  (# 
  #);

(* end *)

itemSelected:
  (# name: ^text;
     type: @integer;
     firstItem: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (name[], type)
  do  type -> this(graphicalEditor).private.contentsEditor.newEditor;
  #);



initialize:
  (# width, height: @integer;
  enter (width, height)
  do 
     (contents, width, height) -> private.windowView.open;
     private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
     (private.viewPaletteRight + 5, 
      (private.viewPaletteBottom + 5, private.windowViewBottom + 5) -> max) -> size;
  #);

generateEditor:
  (# we: ^windowItemEditor;
  do inner;
  exit we[]
  #);

contentsEditor:
  (# 
  exit private.contentsEditor[]
  #);
contentsEditorObject:
  (# 
  exit private.contentsEditorObject[]
  #);



translateRect:
  (# r: ^rectangle;
     from, to: ^windowItem;
  enter (r[], from[], to[])
  do (r.topLeft,from[], to[]) -> translate -> r.topLeft;
     (r.bottomRight, from[], to[]) -> translate -> r.bottomRight;
  #);



(*
 * Handling of private attributes
 *)

findPrivateSlotName:
  (# slotName: ^text;
  do (# theAst: ^astInterface.AST;
        theSimpleDecl: ^astInterface.beta.simpleDecl;
        theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
        theStaticItem: ^astInterface.beta.staticItem;
        theUnExpanded: ^astInterface.unExpanded;
        theSlotDesc: ^astInterface.slotDesc;
     do (node[], 'private') -> betaGram.findAttribute -> theAst[];
        (if theAst[] <> none then
            (if theAst.symbol = betaGram.simpleDecl then
                theAst[] -> theSimpleDecl[];
                theSimpleDecl.getReferenceSpecification -> theReferenceSpecification[];
                (if theReferenceSpecification.symbol = betagram.staticItem then
                    theReferenceSpecification[] -> theStaticItem[];
                    theStaticItem.getObjectSpecification -> theAst[];
                    (if theAst.kind = MPS.kinds.unExpanded then
                        theAst[] -> theUnExpanded[];
                        (if theUnExpanded.isSlot then
                            theUnExpanded.theSlot -> theSlotDesc[];
                            theSlotDesc.name -> slotName[];
                         else
                            failure;
                        if);
                     else
                        failure;
                    if);
                 else
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
  exit slotName[]
  #);

findPrivate:
  (# failure:< object;
  do findBody -> private.body[];
     (if private.body[] <> none then
         true -> private.body.changed;
         (# slotName: ^text;
            frag: ^astInterface.fragmentForm;
         do findPrivateSlotName -> slotName[];
            (if slotName[] <> none then
                slotName[] -> private.body.findFragment -> frag[];
                (if frag[] <> none then 
                    (if frag.category = betaGram.descriptorForm then
                        frag[] -> private.privateFrag[];
                        private.privateFrag[] -> private.privateFragHandler.frag[];
                        private.privateFragHandler[] -> theFragServer.subscribe;
                     else
                        failure;
                    if);
                 else
                    failure;
                if);
             else
                failure;
            if);
         #);
      else
         failure;
     if);
  #);
findBody:
  (# failure:< object;
     body: ^astInterface.fragmentGroup;
  do (# group: ^astInterface.fragmentGroup;
        fullPath: ^text;
     do node.frag.father -> group[];
        (if group[] <> none then
            search: group.scanBodyGroups
              (# 
              do 
                 currentFullPath[] -> fullPath[];
                 leave search;
              #);
            (if fullPath[] <> none then
                fullPath[] -> MPS.safeOpen -> body[];
                (if body[] = none then
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
  exit body[]
  #);

createPrivateAttributes:
  (# failure:< object;
     group: ^astInterface.fragmentGroup;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
     theStaticItem: ^astInterface.beta.staticItem;
     theUnExpanded: ^astInterface.unExpanded;
     theSlotDesc: ^astInterface.slotDesc;
     frag: ^astInterface.fragmentForm;
     theDescriptorForm: ^astInterface.beta.descriptorForm;
     theObjectDescriptor: ^astInterface.beta.objectDescriptor;
     theMainPart: ^astInterface.beta.mainPart;
     name: ^text;
     privateFrag: ^astInterface.fragmentForm;
  do private.body[] -> group[];
     (if group[]<>None then
         node.frag[] -> frag[];
         (betaGram.simpleDecl, frag[]) -> betaGram.newAst -> theSimpleDecl[];
         (frag[], 'private') -> betaGram.newNames -> theSimpleDecl.putNames;
         (betaGram.staticItem, frag[]) 
           -> betaGram.newAst -> theStaticItem[] 
           -> theSimpleDecl.putReferenceSpecification;
         (betaGram.objectDescriptor, frag[]) 
           -> betaGram.newUnExpanded  -> theUnExpanded[]
           -> theStaticItem.putObjectSpecification;
         frag[] -> betaGram.newSlot -> theSlotDesc[] -> theUnExpanded.theSlot;
         node[] -> betaGram.getName -> name[];
         'Private' -> name.append;
         name[] -> theSlotDesc.name;
         (node[], theSimpleDecl[]) -> betaGram.appendAttribute;
         betaGram[] -> MPS.newFragmentForm -> privateFrag[];
         name[] -> privateFrag.name;
         privateFrag[] -> group.fragmentList.addFragment;
         (privateFrag[], none) 
           -> betaGram.newDescriptorForm -> theDescriptorForm[]
           -> privateFrag.root[];
         privateFrag[] -> private.privateFrag[];
         private.privateFrag[] -> private.privateFragHandler.frag[];
         private.privateFragHandler[] -> theFragServer.subscribe;
     else
         failure;
     if);
  #);

createBody:
  (# group: ^astInterface.fragmentGroup;
     theBody: ^astInterface.fragmentGroup;
     name, fullPath: ^text;
  do node.frag.father -> group[];
     group.shortName -> name[];
     'body' -> name.append;
     name[] -> group.fullPath -> fullPath[];
     'BODY' -> group.prop.addProp
     (# 
     do name[] -> addString;
     #);
     fullPath[] -> MPS.top.newGroup -> theBody[];
     group.shortName -> theBody.originProperty;
     theBody[] -> private.body[];
     true -> theBody.changed;
     true -> group.changed;
  #);

-- graphicalEditorPrivate: descriptor --
(# 
   theFileMenu: @builderMenu
     (# 
        closeItem: @builderItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do this(graphicalEditor).close;
                    #);
               #);
             open::
               (# 
               do 'Close' -> name;
                  'W' -> key;
               #);
          #);
        saveItem: @builderItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do save;
                    #);
               #);
             open::
               (# 
               do 'Save all' -> name;
                  'S' -> key;
               #);
          #);
        open::
          (# 
          do 'File' -> name;
             closeItem.open;
             saveItem.open;
          #);
     #);
   theEditMenu: @builderMenu
     (# undoItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do undo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canUndo then 
                           'Undo ' -> t[];
                           undoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Undo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Undo' -> name;
                  'Z' -> key;
               #);
          #);
        redoItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do redo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canRedo then 
                           'Redo ' -> t[];
                           redoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Redo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Redo' -> name;
                  'R' -> key;
               #);
          #);
        cutItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCut;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Cut' -> name;
                  'X' -> key;
               #);
          #);
        copyItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCopy;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Copy' -> name;
                  'C' -> key;
               #);
          #);
        pasteItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do paste;
                    #);
                  onStatus::
                    (# 
                    do canPaste -> value;
                    #);
               #);
             open::
               (# 
               do 'Paste' -> name;
                  'V' -> key;
               #);
          #);
        deleteItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.deleteAll;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Delete' -> name;
               #);
          #);
        findItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find...' -> name;
               #);
          #);
        findAgainItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find again' -> name;
               #);
          #);
        objectInfoItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showInfo;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Object info...' -> name;
                  'I' -> key;
               #);
          #);
        objectCodeItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do (if selection.empty then
                           showCode;
                        else
                           selection.showCode;
                       if);
                    #);
                  onStatus::
                    (# 
                    do true  -> value;
                    #);
               #);
             open::
               (# 
               do 'Object code...' -> name;
                  'K' -> key;
               #);
          #);
        objectFitToContents: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.fitToContents;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Fit to contents' -> name;
               #);
          #);
        open::
          (# 
          do 'Edit' -> name;
             undoItem.open;
             redoItem.open;
             addSeparator;
             cutItem.open;
             copyItem.open;
             pasteItem.open;
             deleteItem.open;
             addSeparator;
             findItem.open;
             findAgainItem.open;
             addSeparator;
             objectInfoItem.open;
             objectCodeItem.open;
             objectFitToContents.open;
          #);
     #);
   theAlignMenu: @builderMenu
     (#
        alignLeftItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignLeft;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Left side' -> name;
               #);
          #);
        alignRightItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignRight;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Right side' -> name;
               #);
          #);
        alignTopItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignTop;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Top edge' -> name;
               #);
          #);
        alignBottomItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignBottom;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Bottom edge' -> name;
               #);
          #);
        alignHorCenterItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignHorCenter;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Horizontal center' -> name;
               #);
          #);
        alignVerCenterItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignVerCenter;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Vertical center' -> name;
               #);
          #);
        showSpacingDialogItem: @builderItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showSpacingDialog;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Spacing...' -> name;
               #);
          #);
        open::
          (#
          do 'Align' -> name;
             alignLeftItem.open;
             alignRightItem.open;
             alignTopItem.open;
             alignBottomItem.open;
             alignHorCenterItem.open;
             alignVerCenterItem.open;
             addSeparator;
             showSpacingDialogItem.open;
          #);
     #);
   (*
    * Handling of private attributes
    *)
   
   body: ^astInterface.fragmentGroup;
   privateFrag: ^astInterface.fragmentForm;
   
   (*
    * Fragment handler
    *)
   
   
   fragHandler, privateFragHandler: @fragmentHandler
     (# handleAstReplaced:
          (#  oldAst, newAst: ^astInterface.ast; 
          enter (oldAst[], newAst[])
          do contentsEditor.traverse
             (# forEach::
                  (# 
                  do (oldAst[], newAst[]) -> current.handleAstReplaced -> continue;
                  #);
             #);
          #);
        astReplaced::
          (#
          do (oldAst[], newAst[]) -> handleAstReplaced;
          #);
        (* astReplacedSequence:<
         *           (# rootOfSequence: ^astInterface.ast
         *           enter rootOfSequence[]
         *           do inner;
         *           #);
         *         listElementInserted:<
         *           (# position: @integer; listNode: ^astInterface.expanded; 
         *           enter (listNode[], position)
         *           do inner;
         *           #);
         *         listElementsDeleted:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length: @integer
         *           enter (listNode[], position, length, oldElements[])
         *           do inner;
         *           #);
         *         listElementsReplaced:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length, newLength: @integer
         *           enter (listNode[], position, length, oldElements[], newLength)
         *           do inner;
         *           #);
         *)
     #);
   
   
   (*
    * Undo and redo
    *)
   undoStack: @stack
     (# element:: operation;
     #);
   redoStack: @stack
     (# element:: operation;
     #);
      
   (*
    * Drag and drop
    *)


   theDragManager: @dragManager
     (# dragger::
          (#  moveTo:<
               (# theCanvasEditor: ^canvasEditor;
                  newFrame: ^rectangle;
               enter (theCanvasEditor[], newFrame[])
               do inner;
               #);
          #);
        changeHierarkiDragger: dragger
          (# bounds: ^rectangle;
             moveTo::
               (# dh, dv: @integer;
               do newFrame.left - bounds.left -> dh;
                  newFrame.top - bounds.top -> dv;
                  (if (selection.first).owner[] <> theCanvasEditor[] then
                      (theCanvasEditor[], dh, dv) -> selection.makeChangeOwnerOperation;
                  if);
               #);
          #);
        createDragger: dragger
          (# type: @integer;
             moveTo::
               (# theEditor: ^windowItemEditor;
                  theCreateOperation: ^createOperation;
               do &createOperation[] -> theCreateOperation[];
                  (theCanvasEditor[], type, newFrame[]) -> theCreateOperation.init;
               #);
          #);
     #);
   
   (* END of drag and drop *)
   
   (*
    * Clipboard
    *)
   
   theClipBoard: @clipboard;
   
   (* 
    * Mode
    *)
   
   mode: @integer;
   
   (* End of mode *)
   
   (*
    * Generators
    *)
   
   editorGenerator: [26] ^generateEditor;
   initEditorGenerator:
     (# 
     do (* &generateEditor (# do &interfaceObjectEditor[] -> we[] #)[] -> editorGenerator[1][]; *)
        &generateEditor (# do &windowitemEditor[] -> we[] #)[] -> editorGenerator[2][];
        &generateEditor (# do &separatorEditor[] -> we[] #)[] -> editorGenerator[3][];
        &generateEditor (# do &canvasEditor[] -> we[] #)[] -> editorGenerator[4][];
        &generateEditor (# do &abstractScrollerEditor[] -> we[] #)[] -> editorGenerator[5][];
        &generateEditor (# do &scrollerEditor[] -> we[] #)[] -> editorGenerator[6][];
        &generateEditor (# do &textEditorEditor[] -> we[] #)[] -> editorGenerator[7][];
        &generateEditor (# do &controlEditor[] -> we[] #)[] -> editorGenerator[8][];
        &generateEditor (# do &buttonEditor[] -> we[] #)[] -> editorGenerator[9][];
        &generateEditor (# do &pushButtonEditor[] -> we[] #)[] -> editorGenerator[10][];
        &generateEditor (# do &iconButtonEditor[] -> we[] #)[] -> editorGenerator[11][];
        &generateEditor (# do &OptionButtonEditor[] -> we[] #)[] -> editorGenerator[12][];
        &generateEditor (# do &staticTextEditor[] -> we[] #)[] -> editorGenerator[13][];
        &generateEditor (# do &toggleButtonEditor[] -> we[] #)[] -> editorGenerator[14][];
        &generateEditor (# do &radioButtonEditor[] -> we[] #)[] -> editorGenerator[15][];
        &generateEditor (# do &checkBoxEditor[] -> we[] #)[] -> editorGenerator[16][];
        &generateEditor (# do &scrollbarEditor[] -> we[] #)[] -> editorGenerator[17][];
        &generateEditor (# do &editTextEditor[] -> we[] #)[] -> editorGenerator[18][];
        &generateEditor (# do &textFieldEditor[] -> we[] #)[] -> editorGenerator[19][];
        &generateEditor (# do &scrollListEditor[] -> we[] #)[] -> editorGenerator[20][];
        &generateEditor (# do &textScrollListEditor[] -> we[] #)[] -> editorGenerator[21][];
        (* &generateEditor (# do &windowEditor[] -> we[] #)[] -> editorGenerator[22][]; *)
        (* &generateEditor (# do &menuEditor[] -> we[] #)[] -> editorGenerator[23][]; *)
        (* &generateEditor (# do &menubarEditor[] -> we[] #)[] -> editorGenerator[24][]; *)
        (* &generateEditor (# do &menuitemEditor[] -> we[] #)[] -> editorGenerator[25][]; *)
       (* &generateEditor (# do &dynamicMenuitemEditor[] -> we[] #)[] -> editorGenerator[26][];*)
     #);
   
   names: [26] ^text;
   initNames:
     (# 
     do 'interfaceObject' -> names[1][];
        'windowitem' -> names[2][];
        'separator' -> names[3][];
        'canvas' -> names[4][];
        'abstractScroller' -> names[5][];
        'scroller' -> names[6][];
        'textEditor' -> names[7][];
        'control' -> names[8][];
        'button' -> names[9][];
        'pushButton' -> names[10][];
        'iconButton' -> names[11][];
        'optionButton' -> names[12][];
        'staticText' -> names[13][];
        'toggleButton' -> names[14][];
        'radioButton' -> names[15][];
        'checkBox' -> names[16][];
        'scrollbar' -> names[17][];
        'editText' -> names[18][];
        'textField' -> names[19][];
        'scrollList' -> names[20][];
        'textScrollList' -> names[21][];
        'window' -> names[22][];
        'menu' -> names[23][];
        'menubar' -> names[24][];
        'menuitem' -> names[25][];
        'dynamicMenuitem' -> names[26][];
     #);
   sizes: [26] ^point;
   initSizes:
     (# 
     do (for inx: sizes.range repeat
             &point[] -> sizes[inx][];
        for);
        (100, 20) -> sizes[2];
        (100, 4) -> sizes[3];
        (200, 100) -> sizes[4];
        (200, 100) -> sizes[5];
        (200, 100) -> sizes[6];
        (200, 100) -> sizes[7];
        (100, 20) -> sizes[8];
        (100, 20) -> sizes[9];
        (60, 20) -> sizes[10];
        (40, 40) -> sizes[11];
        (100, 40) -> sizes[12];
        (60, 16) -> sizes[13];
        (100, 20) -> sizes[14];
        (100, 20) -> sizes[15];
        (100, 20) -> sizes[16];
        (100, 16) -> sizes[17];
        (100, 30) -> sizes[18];
        (200, 100) -> sizes[19];
        (200, 100)  -> sizes[20];
        (200, 100) -> sizes[21];
       
     #);
   
   contentsEditorObject: @canvas
     (# setRealFrame:
          (# r: ^rectangle;
             width, height: @integer;
          enter r[]
          do r.size -> (width, height);
             width + 16 -> width;
             height + 32 -> height;
             (width, height) -> windowView.size;
             r.topLeft -> windowView.position;
          #);
        getRealFrame:
          (# r: ^rectangle;
          do &rectangle[] -> r[];
             windowView.position -> r.topLeft;
             size -> r.size;
          exit r[]
          #);
        open::<
          (#
          do true -> bindRight -> bindBottom;
             false -> border.visible;
          #);
     #);
   windowView: @canvas
     (# 
        titleBar: @staticText
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do true -> bindRight;
                  '' -> label;
                  center -> alignment;
                  ((2, 2), (width - 2, 20)) -> frame;
               #);
             eventHandler::
               (# 
                  onMouseDown::
                    (# 
                    do windowView.drag;
                    #);
               #);
          #);
        interior: @canvas
          (# open::
               (# width, height: @integer;
               enter (width, height)
               do borderStyles.shadowIn -> border.style;
                  true -> border.visible;
                  ((6, 20), (width - 6, height - 6)) -> frame;
                  interior[] -> contentsEditorObject.open;
                  ((2, 2), (width - 14, height - 30)) -> contentsEditorObject.frame;
                  true -> bindRight;
                  true -> bindBottom;
               #);
          #);
        open::
          (# width, height: @integer;
             windowViewRight: @integer;
             ignore: @integer;
          enter (width, height)
          do hide;
             (toolPaletteRight + 10, 5) -> position;
             (width + 16 -> width, height + 32 -> height) -> size;
             true -> border.visible;
             borderstyles.shadowOut -> border.style;
             (windowView[], width, height) -> titleBar.open;
             (windowView[], width, height) -> interior.open;
             5 + height -> windowViewBottom;
             toolPaletteRight + 10 + width -> windowViewRight;
             (windowViewRight + 10, 5) -> theControlPalette.position;
             (windowViewRight + 10, controlPaletteBottom + 5) -> theViewsPalette.position;
             theViewsPalette.frame -> ((ignore, ignore), (viewPaletteRight, viewPaletteBottom));
             show;
          #);
        eventHandler::
          (# 
             onMouseDown::
               (# r: @rectangle;
                  width, height: @integer;
               do (frame, false, false, true, true) -> father.defineRect -> r;
                  r.size -> (width, height);
                  (width - 16, height - 32) -> makeChangeWindowSizeOperation;
               #);
          #);
     #);
   contentsEditor: @canvasEditor
     (# setSize:
          (# width, height: @integer;
          enter (width, height)
          do (width + 16, height + 32) -> windowView.size;
          #);
        getSize:
          (# width, height: @integer;
          do theWindowItem.size -> (width, height);
          exit (width, height)
          #);
        
        getMainAttributes::
          (# 
          do getPrivateAttributes -> theAttributes[];
          #);
        getPrivateAttributes::
          (# theDescriptorForm: ^astInterface.beta.descriptorForm;
             theObjectDescriptor: ^astInterface.beta.objectDescriptor;
             theMainPart: ^astInterface.beta.mainPart;
          do privateFrag.root[] -> theDescriptorForm[];
             theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
             theObjectDescriptor.getMainPart -> theMainPart[];
             theMainPart.getAttributes -> theAttributes[];
          #);
        mouseDown::
          (# 
          do 
             (if theEvent.doubleClick then
              else
                 selection.clear;
             if);
             true -> done;
          #);
        init::
          (# theAttributes: ^astInterface.beta.attributes;
          do createTheReciever;
          #);
     #);
   
   theClassInfo: ^classInfo;
   
   theControlPalette: @controlPalette
     (# 
        mouseDownInItem::
          (# theDragger: @createDragger;
          do theControlPalette[] -> theDragger.item[];
             type -> theDragger.type;
             (event[], theControlPalette[]) -> theDragger.drag
             (# 
                frame::
                  (# 
                  do &rectangle[] -> value[];
                     p -> value.topLeft;
                     type -> getDefaultSize -> value.size;
                  #);
             #)
          #);
        open::
          (# ignore: @integer;
          do (200, 5) -> position;
             frame -> ((ignore, ignore), (controlPaletteRight, controlPaletteBottom));
          #);
     #);
   theViewsPalette: @viewPalette
     (# 
         
        mouseDownInItem::
          (# theDragger: @createDragger;
          do theViewsPalette[] -> theDragger.item[];
             type -> theDragger.type;
             (event[], theViewsPalette[])  -> theDragger.drag
             (# 
                frame::
                  (# 
                  do &rectangle[] -> value[];
                     p -> value.topLeft;
                     type -> getDefaultSize -> value.size;
                  #);
             #)
             
          #);
        open::
          (# ignore: @integer;
          do (200, controlPaletteBottom + 5) -> position;
             frame -> ((ignore, ignore), (viewPaletteRight, viewPaletteBottom));
          #);
     #);
   theToolPalette: @toolPalette
     (# mouseDownInItem::
          (# 
          do type -> this(graphicalEditor).mode;
          #);
        open::
          (# width, height: @integer;
          do (5, 5) -> position;
             size -> (width, height);
             width + 5 -> toolPaletteRight;
             height + 5 -> toolPaletteBottom;
          #);
        
     #);
   
   toolPaletteRight, toolPaletteBottom: @integer;
   controlPaletteBottom, controlPaletteRight: @integer;
   viewPaletteRight, viewPaletteBottom: @integer;
   windowViewBottom: @integer;
#)

-- canvasEditorPrivate: descriptor --
(# locked: @boolean;
   theReciever: ^recieverType;
#)


-- windowitemEditorMousedown: doPart --
do inner mouseDown;
   (if theEvent.doubleClick then
       (if theEvent.metaKey then
           showCodeDialog;
        else
           (if this(windowItemEditor)[] <> contentsEditor then 
               showInfoDialog;
           if);
       if);
    else
       (if not done then
           (# actualMode: @integer;
              
           do mode -> actualMode;
              (if theEvent.shiftKey then
                  (if private.selected then
                      deSelect;
                   else
                      select;
                  if);
               else
                  (if not private.selected then 
                      selection.clear;
                      select;
                  if);
              if);
              (if private.selected then
                  (if actualMode
                   //selectMode then
                      theEvent.localPosition -> theWindowItem.delay
                      (# 
                      do theEvent[] -> dragOrResize;
                      #);
                   //resizeMode then
                      (# width,height: @integer;
                         dh,dv: @integer;
                         h,v: @integer;
                         doTop,doLeft,doBottom,doRight: @boolean;
                      do theEvent.localPosition -> (h,v);
                         theWindowItem.size -> (width,height);
                         width div 3 -> dh;
                         height div 3 -> dv;
                         
                         (if (h <= dh) then 
                             true -> doLeft 
                         if);
                         (if (h >= (width - dh)) then
                             true -> doRight
                         if);
                         (if (v <= dv) then
                             true -> doTop
                         if);
                         (if (v >= (height - dv)) then 
                             true -> doBottom
                         if);
                         (if (doLeft or doBottom or doTop or doRight) then
                             (doLeft,doTop,doRight,doBottom) -> reConfigure;
                          else
                             width div 2 -> dh;
                             height div 2 -> dv;
                             
                             (if (h <= dh) then 
                                 true -> doLeft
                              else
                                 true -> doRight;
                             if);
                             (if (v <= dv) then
                                 true -> doTop
                              else
                                 true -> doBottom;
                             if);
                             (doLeft,doTop,doRight,doBottom) -> reConfigure;
                         if);
                      #);
                   //hierarkiMode then
                      theEvent[] -> selection.interactiveChangeHierarki;
                  if);
              if);
           #);
       if);
   if);
  
  
-- canvasEditorMousedown: doPart --
do inner mouseDown;
   
-- canvasEditorLib: attributes --

(* 
 * Drag and drop support
 *)

recieverType: reciever
  (* Should be a singular object, but a reciever can 
   * not be reused.
   *)
  (# savedStyle: @integer;
     onHilite::
       (# 
       do theWindowItem.border.style -> savedStyle;
          (if savedStyle
           //borderstyles.shadowIn then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.shadowOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedIn then
              borderstyles.etchedOut -> theWindowItem.border.style;
          if);
       #);
     onLowLite::
       (# 
       do savedStyle -> theWindowItem.border.style;
       #);
     
     recieve::
       (# 
       do (this(canvasEditor)[], frame[]) -> theDragger.moveTo;
       #);
  #);

createTheReciever:
  (# 
  do (if private.theReciever[] <> none then
         private.theReciever.delete;
     if);
     &recieverType[] -> private.theReciever[];
     theWindowItem[] -> private.theReciever.init;
  #);
(* End of drag and drop support *)

(*
 * Locking
 *)


locked:
  (# 
  enter private.locked
  exit private.locked
  #);

(* End of locking *)


(*
 * Code
 *)

getMainFrag:
  (# theAttributes: ^astInterface.beta.attributes;
     frag: ^astInterface.fragmentForm;
  do getMainAttributes -> theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.frag[] -> frag[];
     if);
  exit frag[]
  #);



appendAttribute:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter theAttribute[]
  do 
     getMainAttributes -> theAttributes[];
     (if theAttributes[] = none then
         failure;
      else
         (theAttributes[], theAttribute[]) -> appendToAttributes;
     if);
  #);

scanAttributes:
  (# current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  do getMainAttributes -> theAttributes[];
     theAttributes.iterate
     (# 
     do current[] -> this(scanAttributes).current[];
        inner scanAttributes;
     #);
  #);

-- windowItemEditorSelect: doPart --
do (if not private.selected then
       (if this(windowItemEditor)[] -> selection.selectable then
           this(windowItemEditor)[] -> selection.append;
        else
           system.beep;
       if);
   if);
   
-- windowItemEditorDeSelect: doPart --
do (if private.selected then
       this(windowItemEditor)[] -> selection.delete;
   if);

-- GraphicalEditorInit: doPart --
do (# data: ^windowItemData;
      prop: ^propertyList;
      ID: @integer;
      width, height: @integer;
   do 
      true -> (node.frag.father).changed; (* !!! *)
      node.guiInfo -> ID;
      ID -> theObjectStore.get -> data[];
      data.size ->  initialize;
      findPrivate;
      (none, node[], data[]) -> private.contentsEditor.init;
      show;
      inner init;
   #);

-- IBwindowitemEditorapplyObjectData: doPart --
do (# r: @rectangle;
   do data.position -> r.topLeft;
      data.size -> r.size;
      r[] -> frame;
   #);
   data.bindLeft -> theWindowItem.bindLeft;
   data.bindRight -> theWindowItem.bindRight;
   data.bindTop -> theWindowItem.bindTop;
   data.bindBottom -> theWindowItem.bindBottom;
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   data.borderStyle -> theWindowItem.border.style;
   data.borderVisible -> theWindowItem.border.visible;
   inner;

-- IBcanvasEditorapplyObjectData: doPart --
do inner;

-- IBbuttonApplyObjectData: doPart --
do data.label[] -> theWindowItem.label;
   inner;

-- IBiconButtonapplyObjectData: doPart --
do inner; 

-- IBoptionButtonapplyObjectData: doPart --
do inner;
   
-- IBtoggleButtonapplyObjectData: doPart --
do data.state -> theWindowItem.state;
   inner;

-- IBscrollBarapplyObjectData: doPart --
do data.scrollAmount -> theWindowItem.scrollAmount;
   data.pageScrollAmount -> theWindowItem.pageScrollAmount;
   data.maxValue  -> theWindowItem.maxValue;
   data.value -> theWindowItem.value;
   inner;
-- IBeditTextapplyObjectData: doPart --
do inner;


-- IBscrollListapplyObjectData: doPart --
do inner;

-- IBtextScrollListapplyObjectData: doPart --
do inner;
   

-- GraphicalEditorWindowItemEditorEditAttributes: doPart --
do 
   (# makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : attributes' -> theTitle.append;
        exit theTitle[]
        #);
   do (node[], makeTitle) -> openAstEditor;
   #);

-- GraphicalEditorWindowItemEditorShowInfoDialog: doPart --
do (# makeTitle:
        (# title: ^text;
        do node[] -> betaGram.getName -> title[];
           ' : info' -> title.append;
        exit title[]
        #);
   do (data.copy, makeTitle) -> editInfo
      (# 
         onOk::
           (# 
           do (this(windowItemEditor)[], data[]) -> makeDialogOperation;
           #);
      #);
   #);
   

-- GraphicalEditorWindowItemEditorShowCodeDialog: doPart --
do (if codeDialog[]//none then
       &codeDialogType[] -> codeDialog[];
       codeDialog.open;
       this(windowItemEditor)[] -> codeDialog.editor[];
    else
       codeDialog.bringToFront;
       codeDialog.show;
   if);
   codeDialog.updateFields;

-- GraphicalEditorWindowItemEditorEditVirutal: doPart --
do (# theAttribute, theVirtual, theEventHandler: ^astInterface.beta.attributeDecl;
      theEditor: ^astEditorEnv.astEditor;
      astToEdit: ^astInterface.AST;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
      theActionPart: ^astInterface.beta.actionPart;
      theUnExpanded: ^astInterface.unExpanded;
      theSlot: ^astInterface.slotDesc;
      slotName: ^text;
      doPartFrag: ^astInterface.fragmentForm;
      group: ^astInterface.fragmentGroup;
      theAst: ^astInterface.AST;
      makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : ' -> theTitle.append;
           name[] -> theTitle.append;
        exit theTitle[]
        #);
   do node[] -> theAttribute[];
      name[] -> findVirtual -> theVirtual[];
      (if theVirtual[] = none then
          name[] -> createVirtual -> theVirtual[];
          (if isPrivateToWindow then
              theVirtual[] -> astToEdit[];
           else
              theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
              theObjectDescriptor.getMainPart -> theMainPart[];
              theMainPart.getActionPart -> theActionPart[];
              theAttribute[] -> betaGram.getName -> slotName[];
              name[] -> slotName.append;
              (theAttribute.frag[], slotName[]) 
                -> betaGram.newSlotDoPart -> theActionPart.putDoPartOpt;
              
              slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
              body -> group[];
              doPartFrag[] -> group.fragmentList.addFragment;
              doPartFrag.root[] -> astToEdit[];
          if);
          (* astControl.notifyChange; *)
       else
          theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getActionPart -> theActionPart[];
          theActionPart.getDoPartOpt -> theAst[];
          (if theAst.kind = MPS.kinds.unExpanded then
              theAst[] -> theUnExpanded[];
              (if theUnExpanded.isSlot then
                  theUnExpanded.theSlot -> theSlot[];
                  body -> group[];
                  theSlot.name -> group.findFragment -> doPartFrag[];
                  doPartFrag.root[] -> astToEdit[];
              if);
           else
              theVirtual[] -> astToEdit[];
          if);
      if);
      (astToEdit[], makeTitle) -> openAstEditor;
   #)
   
   
-- GraphicalEditorWindowItemEditorInit: doPart --
do (# 
   do 
      (if theAttribute[]<>none then
          theAttribute[] -> node[];
      if);
      (if theWindowItem[] = None then
          (if this(windowItemEditor)## <= textEditorEditor## then
              this(windowItemEditor)[] -> qua
              (# as:: canvasEditor;
              do true -> thisObj.private.locked;
              #);
          if);
          createTheWindowItem;
       else
          &handleMouseDown[] -> theWindowItem.prependAction;
          &handleRefresh[] -> theWindowItem.appendAction;
          &handleFrameChanged[] -> theWindowItem.appendAction;
      if);
      (if owner[]<>none then
          this(windowitemEditor)[] -> owner.children.append;
      if);
      inner init;
   #);

-- canvasEditorInit: doPart --
do inner;
   scanAttributes
   (# theEditor: ^windowItemEditor;
      ID: @integer;
      prop: ^propertyList;
      theData: ^windowItemData;
   do (if current.hasGUIcomment then
          current.guiInfo -> ID;
          ID -> theObjectStore.get -> theData[];
          (if theData[]//none then
           else
              this(graphicalEditor).private.editorGenerator[theData.type] -> theEditor[];
              (this(canvasEditor)[],current[], theData[]) -> theEditor.init;
          if);
      if);
   #);


-- GraphicalEditorNew: doPart --
do (# frag: ^astInterface.fragmentForm;
      thePatternDecl: ^astInterface.beta.patternDecl;
      data: ^windowItemData;
      prop: ^propertyList;
   do (300, 200) -> initialize;
      true -> (node.frag.father).changed;
      node[] -> thePatternDecl[];
      canvasType -> theObjectStore.new -> data[];
      true -> data.bindLeft -> data.bindTop;
      (300, 200) -> data.size;
      data.id -> thePatternDecl.guiInfo;
      findBody -> private.body[];
      (if private.body[] = none then
          createBody;
      if);
      createPrivateAttributes;
      (none, thePatternDecl[], data[]) -> private.contentsEditor.init;
      private.contentsEditor.generateSimpleOpen;
      show;
   #);

-- graphicalEditorWindowItemEditorFindEditor: doPart --
do inner;
   
-- graphicalEditorCanvasEditorFindEditor: doPart --
do (if not locked then
       search: children.scan
         (# theFrame: ^rectangle;
         do (if current[] <> ignoreEditor[] then
                current.frame -> theFrame[];
                (if pt -> theFrame.containsPoint then
                    theFrame.topLeft -> pt.subTract;
                    (pt, ignoreEditor[]) -> current.findEditor -> theEditor[];
                    leave search;
                if);
            if);
         #);
       
       (if theEditor[] = None then
           this(canvasEditor)[] -> theEditor[];
       if);
   if);
   
   
-- GraphicalEditorWindowItemEditorNewData: doPart --
do type -> theObjectStore.new -> data[];
   (100, 100) -> data.size;
   true -> data.bindLeft;
   false -> data.bindRight;
   true -> data.bindTop;
   false -> data.bindBottom;
   true -> data.visible;
   true -> data.enabled;
   borderStyles.shadowOut -> data.borderStyle;
   inner

-- GraphicalEditorCanvasEditorNewData: doPart --
do borderStyles.shadowIn -> data.borderStyle;
   true -> data.borderVisible;
   inner


-- GraphicalEditorAbstractScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorScrollerEditorNewData: doPart --
do inner

-- GraphicalEditorTextEditorEditorNewData: doPart --
do inner

-- GraphicalEditorControlEditorNewData: doPart --
do inner

-- GraphicalEditorButtonEditorNewData: doPart --
do 'Button' -> data.label[];
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];
   inner

-- GraphicalEditorPushButtonEditorNewData: doPart --
do 
   (60, 20) -> data.size;
   inner

-- GraphicalEditorIconButtonEditorNewData: doPart --
do 'nothing' -> data.theRaster[];
   (40, 40) -> data.size;
   inner

-- GraphicalEditorOptionButtonEditorNewData: doPart --
do inner

-- GraphicalEditorStaticTextEditorNewData: doPart --
do inner

-- GraphicalEditorToggleButtonEditorNewData: doPart --
do (70,20) -> data.size;
   inner

-- GraphicalEditorCheckBoxEditorNewData: doPart --
do inner

-- GraphicalEditorScrollBarEditorNewData: doPart --
do (100,16) -> data.size;
   100 -> data.maxValue;
   16 -> data.scrollAmount;
   50 -> data.pageScrollAmount;
   inner

-- GraphicalEditorEditTextEditorNewData: doPart --
do (100,22) -> data.size;
   &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];inner

-- GraphicalEditorTextFieldEditorNewData: doPart --
do &textStyleData[] -> data.defaultStyle[];
   'Courier' -> data.defaultStyle.name[];
   inner

-- GraphicalEditorScrollListEditorNewData: doPart --
do inner

-- GraphicalEditorTextScrollListEditorNewData: doPart --
do &textStyleData[] -> data.style[];
   'Courier' -> data.style.name[];
   inner
   
-- GraphicalEditorRadioButtonEditorNewData: doPart --
do inner;
   
   
-- GraphicalEditorEnterBody: doPart --
do group[] -> private.body[];

-- GraphicalEditorExitBody: doPart --
do private.body[] -> group[]

-- GraphicalEditorEnterPrivateAttributes: doPart --
do 
   
-- GraphicalEditorExitPrivateAttributes: doPart --
do 

-- GraphicalEditorEnterPrivateDoParts: doPart --
do 

-- GraphicalEditorExitPrivateDoPart: doPart --
do 



   
-- GraphicalEditorWindowItemEditorClose: doPart --
do inner close;
   closeCodeDialog;
   
-- GraphicalEditorCanvasEditorClose: doPart --
do inner;
   children.scan
   (# 
   do current.close;
   #);
   

-- GraphicalEditorSelectionDelete: doPart --
do makeDeleteOperation;

-- GraphicalEditorSelectionShowInfo: doPart --
do (if not empty then
       (first).showInfoDialog;
   if);

-- GraphicalEditorSelectionShowCode: doPart --
do scan
   (# 
   do current.showCodeDialog;
   #);

-- GraphicalEditorSeparatorEditorNewData: doPart --
do separatorStyles.etchedIn -> data.style;
   inner;


-- SeparatorEditornew: doPart --
do inner;

-- IBSeparatorApplyObjectData: doPart --
do data.style -> theWindowItem.style;
   inner;

-- ScrollerEditorGetMainNode: doPart --
do (theNode[], 'contentsType') -> betaGram.findAttribute -> theNode[];
   inner;

-- ScrollerEditorGetMainCanvas: doPart --
do theWindowItem.contents[] -> theCanvas[];

-- GraphicalEditorSelectionFitToContents: doPart --
do makeFitToContentsOperation;
   
-- GraphicalEditorSelectionAlignLeft: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.left - currentFrame.left, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignRight: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.right - currentFrame.right, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignTop: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.top - currentFrame.top) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignBottom: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.bottom - currentFrame.bottom) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignHorCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.right - currentFrame.left) div 2) + currentFrame.left -> itsCent;
      ((modelFrame.right - modelFrame.left) div 2) + modelFrame.left -> cent;
      (cent - itsCent, 0) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignVerCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.bottom - currentFrame.top) div 2) + currentFrame.top -> itsCent;
      ((modelFrame.bottom - modelFrame.top) div 2) + modelFrame.top -> cent;
      (0, cent - itsCent) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionShowSpacingDialog: doPart --
do (# theWindow: @window
        (# theSpacingDialog: @spacingDialog
             (# accept::
                  (# 
                  do values[] -> alignspacing;
                     theWindow.close;
                     
                  #);
                cancel::
                  (# 
                  do theWindow.close;
                  #);
             #);
           open::
             (# 
             do 'Spacing' -> title;
                hide;
                (contents, values[]) -> theSpacingDialog.open;
             #);
        #);
      values: ^spacingValues;
   do getSpacingValues -> values[];
      theWindow.open;
      theWindow.showModal;
   #)
   
-- graphicalEditorSelectionDoCopy: doPart --
do this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
   
-- graphicalEditorSelectionDoCut: doPart --
do this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
   makeCutOperation;

-- selectionLib: attributes --

makeSelectionOperation: makeOperation
  (# operationType::< selectionOperation;
     theSelection: ^windowItemEditorList;
  do copy -> theSelection[];
     inner;
  #);
makeMoveOperation: makeSelectionOperation
  (# operationType:: moveOperation;
     dh, dv: @integer;
  enter (dh, dv)
  do (theSelection[], dh, dv) -> theOperation.init;
  #);
makeChangeOwnerOperation: makeSelectionOperation
  (# operationType:: changeOwnerOperation;
     dh, dv: @integer;
     newOwner: ^canvasEditor;
  enter (newOwner[], dh, dv)
  do (theSelection[], newOwner[], dh, dv) -> theOperation.init;
  #);
makeDeleteOperation: makeSelectionOperation
  (# operationType::< deleteOperation;
  do theSelection[] -> theOperation.init;
  #);
makeCutOperation: makeDeleteOperation
  (# operationType:: cutOperation
  #);

makeChangeBoundsOperation: makeSelectionOperation
  (# operationType::< changeBoundsOperation;
     newBounds: ^rectangleList;
  do &rectangleList[] -> newBounds[];
     newBounds.init;
     inner;
     (theSelection[], newBounds[]) -> theOperation.init;
  #);
makeAlignOperation: makeChangeBoundsOperation
  (# operationType:: alignOperation;
     modelFrame: ^rectangle;
     currentFrame: ^rectangle;
     first: @boolean;
  do true -> first;
     scan
     (# 
     do (if first then
            current.frame -> modelFrame[];
            modelFrame[] -> newBounds.append;
            false -> first;
         else
            current.frame -> currentFrame[];
            inner makeAlignOperation;
            currentFrame[] -> newBounds.append;
        if);
     #);
  #);
makeFitToContentsOperation: makeChangeBoundsOperation
  (# operationType:: fitToContentsOperation;
  do scan
     (# r: ^rectangle;
     do 
        current.frame -> r[];
        current.theWindowItem.preferredSize -> r.size;
        r[] -> newBounds.append;
     #);
  #);

  
bounds:
  (# theBounds: ^rectangle;
  do &rectangle[] ->  theBounds[];
     minInt -> theBounds.right -> theBounds.bottom;
     maxInt -> theBounds.left -> theBounds.top;
     scan
     (# r: ^rectangle;
     do current.frame -> r[];
        (r.left, theBounds.left) -> Min -> theBounds.left;
        (r.top, theBounds.top) -> Min -> theBounds.top;
        (r.right, theBounds.right) -> Max -> theBounds.right;
        (r.bottom, theBounds.bottom) -> Max -> theBounds.bottom;
     #);
  exit theBounds[]
  #);

interactiveChangeHierarki:
  (# theDragger: @changeHierarkiDragger;
     event: ^windowItem.eventHandler.mouseDown;
  enter event[]
  do theDragger.init;
     (first).owner.theWindowItem[] -> theDragger.item[];
     bounds -> theDragger.bounds[];
     (event[], (first).theWindowItem[]) -> theDragger.drag
     (# 
        frame::
          (# 
          do &rectangle[] -> value[];
             theDragger.bounds -> value;
          #);
     #);
  #);

drag:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
  enter theEvent[]
  do (# oldBounds, newBounds: ^rectangle;
        dh, dv: @integer;
     do 
        bounds -> oldBounds[];
        (oldBounds[], (first).theWindowItem.father[], (contentsEditor).theWindowItem[])
          -> translateRect;
        &rectangle[] -> newBounds[];
        (oldBounds, true, true, true, true) 
          -> (contentsEditor).theWindowItem.defineRect -> newBounds;
        newBounds.left - oldBounds.left -> dh;
        newBounds.top - oldBounds.top -> dv;
        (dh, dv) -> makeMoveOperation;
     #);
  #);

stopAnts: 
  (# 
  do this(graphicalEditorEnv).private.theWalkingAnts.fullStop;
  #);
startAnts: scan
  (# 
  do current.startWalkingAnts;
  #);

selectable: booleanValue
  (# theEditor: ^windowItemEditor;
  enter theEditor[]
  do (if empty then
         true -> value;
      else
         (theEditor.owner[] = (first).owner[]) -> value;
     if);
  #);

array: sequence
  (# element::< windowItem;
     
     sortHorizontal: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.h < rightpos.h -> value;
            #);
       #);
     sortVertical: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.v < rightpos.v -> value;
            #)
       #);
     
     top: @Integer;
  #);


sort:
  (# sortedarray: ^array;
  do &array[] -> sortedarray[];
     sortedarray.init;
     scan
     (#
     do current.theWindowitem[] -> sortedarray.append;
     #);
     inner;
  exit sortedarray[]
  #);
sorthorizontal: sort
  (# 
  do sortedarray.sortHorizontal;
  #);
sortvertical: sort
  (# 
  do sortedarray.sortVertical;
  #);

alignspacing:
  (# values: ^spacingValues;
     sorted: ^Array;
  enter values[]
  do stopAnts;
     (if (values.doWidth OR values.doHeight)//true then
         scan
         (# width, height: @integer;
         do current.theWindowItem.Size -> (width, height);
            (if values.doWidth//true then values.width -> width; if);
            (if values.doHeight//true then values.height -> height; if);
            (width, height) -> current.theWindowItem.Size;
         #);
     if);
     (if values.doVerticalDist then
         SortVertical -> sorted[];
         sorted.Scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Bottom + values.verticalDist -> curPos.v;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     (if values.doHorizontalDist then
         SortHorizontal -> sorted[];
         sorted.scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Right + values.horizontalDist -> curPos.h;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     startAnts;
  #);


-- graphicalEditorEnvFind: doPart --
do search:
     private.editors.scan
     (# 
     do (if node[] -> current.node.equal then
            current[] -> editor[];
            leave search;
        if);
     #);
   
-- graphicalEditorEnvInit: doPart --
do private.editors.init;
   &editorWalkingAnts[] -> private.theWalkingAnts[];
   private.theWalkingAnts.init;
   theFragServer[] -> theAstEditorEnv.init;
   private.theScrap.init;
   inner;
   
-- graphicalEditorEnvLib: attributes --

scriptEditor: theAstEditorEnv.astEditor
  (# eventHandler::
       (# onAboutToClose::
            (# parseOK: @boolean;
            do (if dirty then
                   parse -> parseOK;
                   parseOK -> okToClose;
               if);
            #);
       #);
     
  #);

shadowTree:
  (# name: ^text;
     data: ^scrapData;
     children: @doubleLinkedList
       (# element:: shadowTree;
       #);
  #);

scrap: doubleLinkedList
  (# element::
       (# tree: ^shadowTree;
          node: ^astInterface.AST;
       #);
  #);
getScrap:
  (# 
  exit private.theScrap[]
  #);
insert:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.append;
  #);

delete:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.delete;
  #);

editorWalkingAnts: walkingAnts
  (# editor: ^graphicalEditor;
     fullStop:
       (# 
       do stop;
          clear;
       #);
     attach:
       (# item: ^window.windowItem;
          area: ^rectangle;
          width, height: @integer;
       enter item[]
       do &rectangle[] -> area[];
          item.size -> (width, height);
          ((0, 0), (width - 1, height - 1)) -> area;
          (item[], area[]) -> add;
          start;
       #);
  #);

putPoint:
  (# x, y: @integer;
  enter (x, y)
  do '[' -> put;
     x -> putInt;
     ' ' -> put;
     y -> putInt;
     ']' -> put;
  #);

-- graphicalEditorEnvPrivate: descriptor --
(# theWalkingAnts: ^editorWalkingAnts;
   theScrap: @scrap;
   editors: @doubleLinkedList
     (# element:: graphicalEditor;
     #);
#)

-- GraphicalEdioterWindowItemEditorCreateWindowItem: doPart --
do &windowItemType[] -> theWindowItem[];
   owner.getMainCanvas -> theWindowItem.open;
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[] -> theWindowItem.prependAction;
   &handleRefresh[] -> theWindowItem.appendAction;
   &handleFrameChanged[] -> theWindowItem.appendAction;
   (if not initial then
       applyObjectData;
   if);
   inner;
   
   
-- GraphicalEditorCanvasEditorCreateTheWindowItem: doPart --
do (if not private.locked then
       createTheReciever;
   if);
   children.scan
   (# 
   do current.createTheWindowItem; 
   #);
   inner;
   
-- GraphicalEditorScrollerEditorCreateTheWindowItem: doPart --
do (1000, 1000) ->  theWindowItem.contents.size;
   inner;
   
-- GraphicalEditorTextEditorEditorCreateTheWindowItem: doPart --
do inner; 
   
-- textEditorPictOpen: doPart --
do private.open;
   
-- textEditorPictPrivate: descriptor --
(# open:
     (# width, height: @integer;
     do true -> border.visible;
        size -> (width, height);
        
        this(textEditorPict)[] -> contents.open;
        true -> contents.delegateMouseEvents;
        ((2, 2), (width - 16, height - 16)) -> contents.frame;
        true -> contents.bindRight -> contents.bindBottom;
        
        this(textEditorPict)[] -> vScrollBar.open;
        true -> vScrollBar.delegateMouseEvents;
        vScrollBar.disableDefaultBehaviour;
        ((width - 16, 0), (width, height - 16)) -> vScrollBar.frame;
        true -> vScrollBar.bindRight;
        false -> vScrollBar.bindLeft;
        true -> vScrollBar.bindBottom;
        
        this(textEditorPict)[] -> hScrollBar.open;
        true -> hScrollBar.delegateMouseEvents;
        hScrollBar.disableDefaultBehaviour;
        ((0, height - 16), (width - 16, height)) -> hScrollBar.frame;
        true -> hScrollBar.bindRight;
        false -> hScrollBar.bindTop;
        true -> hScrollBar.bindBottom;
     #);
   contents: @canvas
     (# 
     #);
   vScrollBar: @scrollBar
     (# vertical:: (# do true -> value #);
        
     #);
   hScrollBar: @scrollBar
     (# 
     #);
#)

-- GraphicalEditorTextEditorEditorInit: doPart --
do true -> locked;
   inner;
   
-- graphicalEditorUndo: doPart --
do (# theOperation: ^operation;
   do (if not private.undoStack.empty then
          private.undoStack.pop -> theOperation[];
          theOperation.undoIt;
          theOperation[] -> private.redoStack.push;
      if);
   #);
   
-- graphicalEditorUndoText: doPart --
do (if canUndo then
       (private.undoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanUndo: doPart --
do not private.undoStack.empty -> value;
   
-- graphicalEditorRedo: doPart --
do (# theOperation: ^operation;
   do (if not private.redoStack.empty then
          private.redoStack.pop -> theOperation[];
          theOperation.doIt;
          theOperation[] -> private.undoStack.push;
      if);
   #);
  
   
-- graphicalEditorCanRedo: doPart --
do not private.redoStack.empty -> value
   
-- graphicalEditorRedoText: doPart --
do (if canRedo then
       (private.redoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanPaste: doPart --
do not private.theClipBoard.theScrap.empty -> value;
   
-- graphicalEditorPaste: doPart --
do private.theClipBoard.makePasteOperation;
   
-- graphicalEditorEnvOpenSeparateAstEditorMethod: doPart --
do (# theEditor: ^scriptEditor;
   do node[] -> theAstEditorEnv.find -> theEditor[];
      (if theEditor[] = none then
          &scriptEditor[] -> theEditor[];
          node[] -> theEditor.init;
          title[] -> theEditor.title;
       else
          theEditor.bringToFront;
      if);
   #);
   
-- graphicalEditorEnterMode: doPart --
do value -> private.mode;
   (if value 
    //selectMode then
       cursors.arrow[] -> (contents).theCursor;
    //hierarkiMode then
       cursors.cross[] -> (contents).theCursor;
    //resizeMode then
       cursors.plus[] -> (contents).theCursor;
   if);
   
-- graphicalEditorExitMode: doPart --
do private.mode -> value;
   
-- windowItemEditorListCopy: doPart --
do &windowItemEditorList[] -> theCopy[];
   theCopy.init;
   scan
   (# 
   do current[] -> theCopy.append;
   #);
   
-- windowItemEditorListSet: doPart --
do clear;
   theOther.scan
   (# 
   do current[] -> append;
   #);
   

-- selectionAppend: doPart --
do true -> elm.private.selected;
   elm.startWalkingAnts;;
   
-- selectionPrepend: doPart --
do true -> elm.private.selected;
   elm.startWalkingAnts;
   
-- selectionDelete: doPart --
do false -> elm.private.selected;
   elm.stopWalkingAnts;
   
-- selectionClear: doPart --
do stopAnts;
   scan
   (# 
   do false -> current.private.selected;
   #);
   
-- windowItemEditorGetPublicAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       node[] -> betaGram.getAttributes -> theAttributes[];
   if);
   
-- windowItemEditorGetPrivateAttributes: doPart --
do inner;
   
-- windowItemEditorGetMainAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       getPublicAttributes -> theAttributes[];
   if);
   
-- scrollerEditorGetMainAttributes: doPart --
do (# theNode: ^astInterface.beta.attributeDecl;
   do (node[], 'contentsType') 
        -> betaGram.findAttribute -> theNode[];
      (if theNode[] = none then
          (* Failure!!! *)
       else
          theNode[] -> betaGram.getAttributes -> theAttributes[];
      if);
   #);
-- graphicalEditorShowCode: doPart --
do (contentsEditor).showCodeDialog;
   
-- windowItemEditorNewNode: doPart --
do (# theAttributes: ^astInterface.beta.attributes;
      className, instanceName: ^text;
   do owner.getMainAttributes -> theAttributes[];
      type -> getClassName -> className[];
      (type, data.id) -> freshName -> instanceName[];
      (theAttributes.frag[], instanceName[],className[])
        -> betaGram.newSingularItem -> node[];
      data.id -> node.guiInfo;
      generateSimpleOpen;
   #);
   inner;
