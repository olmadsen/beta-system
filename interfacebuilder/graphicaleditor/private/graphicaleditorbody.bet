ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds';
INCLUDE '~beta/guienv/v1.6/utils/track';
INCLUDE '~beta/sysutils/v1.6/time';
INCLUDE '~beta/sysutils/v1.6/objinterface';
INCLUDE '~beta/betaast/v5.2/gram';
INCLUDE '~beta/betaast/v5.2/betasematt';
INCLUDE '~beta/guienv/v1.6/private/datastructures/sequence';
INCLUDE '~beta/containers/v1.6/list';
INCLUDE '../../dialogs/editinfo';
INCLUDE '../../dialogs/namedialog';
INCLUDE '../../dialogs/integerfield';
INCLUDE '../../code/generate';
INCLUDE '../../code/pattern';
INCLUDE '../../code/followsemanticlink';
INCLUDE '../../code/match';
INCLUDE '../../asteditor/asteditor';
INCLUDE '../../palettes/palette';
INCLUDE '~beta/guienv/v1.6/utils/guienvstuff';
INCLUDE '../../guienvstuff/killtranslations';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '../../dialogs/spacingdialog';
INCLUDE '../classinfo';
INCLUDE '../../dragmanager/dragmanager';
INCLUDE '../../buildermenu';
INCLUDE '~beta/guienv/v1.6/utils/prompts';
INCLUDE '../../resourcesupport/easyinterface';
INCLUDE '../../guienvstuff/loadbitmap';
INCLUDE '../../code/private/generatebody';


MDBODY mac    'macintosh/graphicaleditor_mac'
       ppcmac 'macintosh/graphicaleditor_mac'
       nti 'winnt/graphicaleditor_nti'
       default 'X11/graphicaleditor_X11';


-- entryExistsBody: doPart --
do false -> value;
   l: (# e: @diskEntry;
      do name[] -> e.path;
         e.exists
         (# 
            error::
              (# 
              do leave l;
              #);
         #) -> value;
      #);

-- entryReadableBody: doPart --
do false -> value;
   (if name[] -> entryExists then
       l: (# e: @diskEntry;
          do name[] -> e.path;
             e.readable
             (# error::
                  (# 
                  do leave l;
                  #);
                
             #) -> value;
          #);
   if);

-- entryWriteAbleBody: doPart --
do false -> value;
   l:
     (if name[] -> entryExists then
         l: (# e: @diskEntry;
            do name[] -> e.path;
               e.writeAble
               (# error::
                    (# 
                    do  leave l;
                    #);
               #) -> value;
            #);
      else
         true -> value;
     if);

-- astFileExistsBody: doPart --
do (# path: ^text;
   do MPS.astFileExtension -> (name.copy).Append -> path[];
      (if path[] -> entryExists then
          true -> value;
       else
          '.bet' -> (name.copy).Append -> path[];
          path[] -> entryExists -> value;
      if);
      
   #);

-- astFileReadAbleBody: doPart --
do (# path: ^text;
   do MPS.astFileExtension -> (name.copy).Append -> path[];
      (if path[] -> entryReadAble then
          true -> value;
       else
          '.bet' -> (name.copy).Append -> path[];
          path[] -> entryReadAble -> value;
      if);
      
   #)

-- astFileWriteAbleBody: doPart --
do (# path: ^text;
   do MPS.astFileExtension -> (name.copy).Append -> path[];
      (if path[] -> entryWriteAble then
         '.bet' -> (name.copy).Append -> path[];
          path[] -> entryWriteAble -> value;
       else
          false -> value;
      if);
   #);
 

-- InterfaceBuilderGraphicalEditorWindowMenubarOpen: doPart --
do this(graphicalEditor).private.theFileMenu.open;
   this(graphicalEditor).private.theFileMenu[] -> append;
   this(graphicalEditor).private.theEditMenu.open;
   this(graphicalEditor).private.theEditMenu[] -> append;
   this(graphicalEditor).private.theAlignMenu.open;
   this(graphicalEditor).private.theAlignMenu[] -> append;;
   



-- windowitemEditornew: doPart --
do (# 
   do false -> inherited;
      type -> newData -> data[];
      type -> makeData -> defaultData[];
      newNode;
      realCreateOpen;
      (node[], defaultBodyGroup) -> getClassData -> theClassData[];
      node[] -> owner.appendAttribute;
      true  -> createTheWindowItem;
      applyObjectData;
      (if owner[]<>None then
          this(windowitemEditor)[] -> owner.appendChild;
      if);
      (data[], true) -> changeData;
   #);
   inner;
   
   



-- canvasEditornew: doPart --
do (if theWindowItem[]<>contents then
       borderStyles.shadowIn -> theWindowItem.border.style;
       true -> theWindowItem.border.visible;
   if);
   inner;


-- graphicalEditorNewEditor: doPart --
do (# node: ^astInterface.beta.attributeDecl;
      super: ^astInterface.beta.patternDecl;
      theAttributes: ^astInterface.beta.attributes;
      name, className: ^text;
   do (if theClassData[] = NONE then
          (type, false) -> makeEditor -> theEditor[];
          (this(canvasEditor)[],type, none) -> theEditor.new;
          selection.clear;
          theEditor.select;
       else
          (type, theClassData.vertical) -> makeEditor -> theEditor[];
          theClassData.node[] -> super[];
          super[] -> betaGram.getName -> className[];
          type -> uniqueName -> name[];
          getMainAttributes -> theAttributes[];
          (theAttributes.frag[], name[], className[]) -> betaGram.newSingularItem -> node[];
          (node[], super[]) -> setSemanticLink;
          node[] -> appendAttribute;
          (node[], defaultBodyGroup) -> getClassData -> theClassData[];
          (if theClassData[] <> none then
              (this(canvasEditor)[],node[], NONE, type, false, theClassData[], none) 
                -> theEditor.init;
              theEditor.realCreateOpen;
          if);
      if);
   #);


-- graphicalEditorOpen: doPart --
do (# 
   do contents -> private.theDragManager.init;
      this(graphicalEditor)[] -> insert;
      hide;
      private.controlPoints.init;
      'Graphical Objects' -> title;
      
      (600, 500) -> size;
      private.theClipBoard.init;
      private.theControlPalette.open;
      private.theToolPalette.open;
      selectMode -> private.mode;
      private.initNames;
      private.initSizes;
      
   #);

-- graphicalEditorClose: doPart --
do (# 
   do inner close;
      selection.clear;
      forgetSelectionChanged;
      private.contentsEditor.close;
      this(graphicalEditor)[] -> delete;
   #);
-- graphicalEditorOnMouseDown: doPart --
do selection.clear;
   


-- windowitemEditorMousedown: doPart --
do INNER;
   (if skip then
       false -> private.skip
    else
       (if not (readOnly OR inherited) then
           inner mouseDown;
           (if theEvent.doubleClick then
               showInfoDialog;
            else
               (if not done then
                   (# actualMode: @integer;
                      
                   do mode -> actualMode;
                      (if theEvent.shiftKey then
                          (if private.selected then
                              deSelect;
                           else
                              select;
                          if);
                       else
                          (if not private.selected then
                              selection.clear;
                              select;
                          if);
                      if);
                      (if private.selected then
                          (if actualMode
                           //selectMode then
                              
                              pt -> theWindowItem.delay
                              (# 
                              do theEvent[] -> selection.drag;
                              #);
                           //resizeMode then
                              (# width,height: @integer;
                                 dh,dv: @integer;
                                 h,v: @integer;
                                 doTop,doLeft,doBottom,doRight: @boolean;
                              do pt -> (h,v);
                                 theWindowItem.size -> (width,height);
                                 width div 3 -> dh;
                                 height div 3 -> dv;
                                 
                                 (if (h <= dh) then 
                                     true -> doLeft 
                                 if);
                                 (if (h >= (width - dh)) then
                                     true -> doRight
                                 if);
                                 (if (v <= dv) then
                                     true -> doTop
                                 if);
                                 (if (v >= (height - dv)) then 
                                     true -> doBottom
                                 if);
                                 (if (doLeft or doBottom or doTop or doRight) then
                                     (doLeft,doTop,doRight,doBottom) -> reConfigure;
                                  else
                                     width div 2 -> dh;
                                     height div 2 -> dv;
                                     
                                     (if (h <= dh) then 
                                         true -> doLeft
                                      else
                                         true -> doRight;
                                     if);
                                     (if (v <= dv) then
                                         true -> doTop
                                      else
                                         true -> doBottom;
                                     if);
                                     (doLeft,doTop,doRight,doBottom) -> reConfigure;
                                 if);
                              #);
                           //hierarkiMode then
                              (if owner[] <> none then
                                  theEvent[] -> selection.interactiveChangeHierarki;
                              if);
                          if);
                      if);
                   #);
               if);
           if);
       if);
   if);
  
  
-- canvasEditorMousedown: doPart --
do inner mouseDown;
   (if not skip then
       (if (owner[] = NONE) OR (theEvent.controlKey) then
           (# r: @rectangle;
              width, height: @integer;
              intersectedObjects: @windowItemEditorList;
           do intersectedObjects.init;
              (theEvent.localPosition, theEvent.localPosition) -> r;
              (r, false, false, true, true) -> theWindowItem.defineRect -> r;
              
              children.scan
              (# itsFrame: ^rectangle;
              do current.frame -> itsFrame[];
                 (if (r, itsFrame) -> itsFrame.intersection then
                     current[] -> intersectedObjects.append;
                 if);
              #);
              (if intersectedObjects.empty then
                  (if theEvent.shiftKey then
                      (if selected then
                          deSelect;
                       else
                          select;
                      if);
                   else
                      selection.clear;
                      select;
                  if);
               else
                  (if theEvent.shiftKey then
                      intersectedObjects.scan
                      (# 
                      do (if current.selected then
                             current.deSelect;
                          else
                             current.select;
                         if);
                      #);
                   else
                      selection.clear;
                      intersectedObjects.scan
                      (# 
                      do current.select;
                      #);
                  if);
              if);
              true -> skip;
           #);
       if);
   if);
       
   

-- windowItemEditorSelect: doPart --
do (if not private.selected then
       
       (if this(windowItemEditor)[] -> selection.selectable then
           this(windowItemEditor)[] -> selection.append;
        else
           system.beep;
       if);
   if);
   
-- windowItemEditorDeSelect: doPart --
do (if private.selected then
       this(windowItemEditor)[] -> selection.delete;
   if);

-- GraphicalEditorInit: doPart --
do (# theClassData: ^classData;
      theEditor: ^windowItemEditor;
      theTimer: @timer
        (# action::
             (# 
             do stop;
                this(graphicalEditor).private.contentsEditor.fixOptionButtons
             #);
        #);
   do 
      (if privateFrag[] <> none then
         
          privateFrag[] -> private.privateFragHandler.frag[];
          private.privateFragHandler[] -> theFragServer.subscribe;
      if);
      private.adorner.open;
      (node[], defaultBodyGroup) -> getClassData -> theClassData[];
      (if theClassData[] <> none then
          (theClassData.theClass.type, theClassData.vertical) -> makeEditor -> theEditor[];
          (none, node[], none, theClassData.theClass.type, false, theClassData[], privateFrag[])
            -> theEditor.init;
          theEditor[] -> private.contentsEditor[];
          inner init;
          private.theCustomPalette.open;
          adjustPalettes;
          show;
          (if platform = X11 then
              300 -> theTimer.start;
          if);
       else
          close;
      if);
      
   #);
   
-- IBwindowitemEditorapplyObjectData: doPart --
do (# r: @rectangle;
   do data.position -> r.topLeft;
      data.size -> r.size;
      r[] -> frame;
   #);
   data.bindLeft -> theWindowItem.bindLeft;
   data.bindRight -> theWindowItem.bindRight;
   data.bindTop -> theWindowItem.bindTop;
   data.bindBottom -> theWindowItem.bindBottom;
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   data.borderStyle -> theWindowItem.border.style;
   data.borderVisible -> theWindowItem.border.visible;
   inner;
   

-- IBcanvasEditorapplyObjectData: doPart --
do inner;


-- GraphicalEditorWindowItemEditorEditAttributes: doPart --
do 
   (# makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : attributes' -> theTitle.append;
        exit theTitle[]
        #);
   do (node[], makeTitle) -> openAstEditor;
   #);

-- GraphicalEditorWindowItemEditorShowInfoDialog: doPart --
do (# makeTitle:
        (# title: ^text;
        do node[] -> betaGram.getName -> title[];
           ' : info' -> title.append;
        exit title[]
        #);
   do (data.copy, makeTitle, platform) -> editInfo
      (# 
         onOk::
           (# 
           do (this(windowItemEditor)[], data[]) -> makeDialogOperation;
           #);
      #);
   #);
   

-- GraphicalEditorWindowItemEditorEditVirutal: doPart --
do (# theAttribute, theVirtual, theEventHandler: ^astInterface.beta.attributeDecl;
      theEditor: ^astEditorEnv.astEditor;
      astToEdit: ^astInterface.AST;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
      theActionPart: ^astInterface.beta.actionPart;
      theUnExpanded: ^astInterface.unExpanded;
      theSlot: ^astInterface.slotDesc;
      slotName: ^text;
      doPartFrag: ^astInterface.fragmentForm;
      group: ^astInterface.fragmentGroup;
      theAst: ^astInterface.AST;
      makeTitle:
        (# theTitle: ^text;
        do node[] -> betaGram.getName -> theTitle[];
           ' : ' -> theTitle.append;
           name[] -> theTitle.append;
        exit theTitle[]
        #);
      frag: ^astInterface.fragmentForm;
   do node[] -> theAttribute[];
      name[] -> findVirtual -> theVirtual[];
      (if theVirtual[] = none then
          name[] -> createVirtual -> theVirtual[];
          (if theVirtual[] <> none then
              (if isPrivateToWindow then
                  theVirtual[] -> astToEdit[];
               else
                  theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
                  theObjectDescriptor.getMainPart -> theMainPart[];
                  theMainPart.getActionPart -> theActionPart[];
                  theAttribute[] -> betaGram.getName -> slotName[];
                  name[] -> slotName.append;
                  (theAttribute.frag[], slotName[]) 
                    -> betaGram.newSlotDoPart -> theActionPart.putDoPartOpt;
                  
                  slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
                  defaultBodyGroup -> group[];
                  slotName[] -> group.findFragment -> frag[];
                  (if frag[] <> none then
                      frag.root[] -> astToEdit[];
                   else
                      doPartFrag[] -> group.fragmentList.addFragment;
                      doPartFrag.root[] -> astToEdit[];
                  if);
              if);
           else
          if);
          (* astControl.notifyChange; *)
       else
          theVirtual[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getActionPart -> theActionPart[];
          theActionPart.getDoPartOpt -> theAst[];
          (if theAst.kind = MPS.kinds.unExpanded then
              theAst[] -> theUnExpanded[];
              (if theUnExpanded.isSlot then
                  theUnExpanded.theSlot -> theSlot[];
                  defaultBodyGroup -> group[];
                  theSlot.name -> group.findFragment -> doPartFrag[];
                  doPartFrag.root[] -> astToEdit[];
              if);
           else
              theVirtual[] -> astToEdit[];
          if);
      if);
      (astToEdit[], makeTitle) -> openAstEditor;
   #);
   (* theDocument.autoSave; *)
   
   
-- GraphicalEditorWindowItemEditorInit: doPart --
do (# theDoPart: ^astInterface.beta.doPart;
      theImperatives: ^astInterface.beta.imperatives;
      
   do true -> private.initializing;
      inherited -> this(windowItemEditor).inherited;
      type -> newData -> data[];
      type -> makeData -> defaultData[];
      initialize;
      
      (*  defaultData.data.storage.scan
       *       (# 
       *       do (current.key[], current.value[]) -> data.data.define;
       *       #);
       *)
      (if owner[]<>none then
          this(windowitemEditor)[] -> owner.children.append;
      if);
      inner init;
      false -> private.initializing;
   #);

-- canvasEditorInit: doPart --
do inner;


-- GraphicalEditorNew: doPart --
do (#
      theTimer: @timer
        (# action::
             (# 
             do stop;
                this(graphicalEditor).private.contentsEditor.fixOptionButtons
             #);
        #);
      theClassData: ^classData;
      theEditor: ^windowItemEditor;
      privateFrag: ^astInterface.fragmentForm;
   do true -> (node.frag.father).changed;
      createPrivateAttributes -> privateFrag[];
      private.adorner.open;
      (node[], defaultBodyGroup) -> getClassData -> theClassData[];
      (if theClassData[] <> none then
          (theClassData.theClass.type, theClassData.vertical) -> makeEditor -> theEditor[];
          (none, node[], none, theClassData.theClass.type, false, theClassData[], privateFrag[])
            -> theEditor.init;
          theEditor.realCreateOpen;
          theEditor[] -> private.contentsEditor[];
          (* theDocument.autoSave; *)
          private.theCustomPalette.open;
          adjustPalettes;
          show;
          (if platform = X11 then
              300 -> theTimer.start;
          if);
              
       else
          close;
      if);
      
      
   #);

-- graphicalEditorWindowItemEditorFindEditor: doPart --
do inner;
   
-- graphicalEditorCanvasEditorFindEditor: doPart --
do (if not locked then
       search: children.scan
         (# theFrame: ^rectangle;
         do (if current[] <> ignoreEditor[] then
                current.frame -> theFrame[];
                (if pt -> theFrame.containsPoint then
                    theFrame.topLeft -> pt.subTract;
                    (pt, ignoreEditor[]) -> current.findEditor -> theEditor[];
                    leave search;
                if);
            if);
         #);
       
       (if theEditor[] = None then
           this(canvasEditor)[] -> theEditor[];
       if);
   if);
   
   

   
-- GraphicalEditorEnterPrivateAttributes: doPart --
do 
   
-- GraphicalEditorExitPrivateAttributes: doPart --
do 

-- GraphicalEditorEnterPrivateDoParts: doPart --
do 

-- GraphicalEditorExitPrivateDoPart: doPart --
do 



   
-- GraphicalEditorWindowItemEditorClose: doPart --
do inner close;
   
-- GraphicalEditorCanvasEditorClose: doPart --
do inner;
   children.scan
   (# 
   do current.close;
   #);
   

-- GraphicalEditorSelectionDelete: doPart --
do makeDeleteOperation;

-- GraphicalEditorSelectionShowInfo: doPart --
do (if not empty then
       (first).showInfoDialog;
   if);
   


-- GraphicalEditorSelectionFitToContents: doPart --
do makeFitToContentsOperation;
   
-- GraphicalEditorSelectionAlignLeft: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.left - currentFrame.left, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignRight: doPart --
do makeAlignOperation
   (# 
   do (modelFrame.right - currentFrame.right, 0) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignTop: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.top - currentFrame.top) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignBottom: doPart --
do makeAlignOperation
   (# 
   do (0, modelFrame.bottom - currentFrame.bottom) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionAlignHorCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.right - currentFrame.left) div 2) + currentFrame.left -> itsCent;
      ((modelFrame.right - modelFrame.left) div 2) + modelFrame.left -> cent;
      (cent - itsCent, 0) -> currentFrame.offset;
   #);
   
-- GraphicalEditorSelectionAlignVerCenter: doPart --
do makeAlignOperation
   (# cent, itsCent: @integer;
   do ((currentFrame.bottom - currentFrame.top) div 2) + currentFrame.top -> itsCent;
      ((modelFrame.bottom - modelFrame.top) div 2) + modelFrame.top -> cent;
      (0, cent - itsCent) -> currentFrame.offset;
   #);

-- GraphicalEditorSelectionShowSpacingDialog: doPart --
do (# theWindow: @window
        (# theSpacingDialog: @spacingDialog
             (# accept::
                  (# abort: @boolean;
                  do (if values.doWidth then
                         (if values.width = 0 then
                             'The width must be greater than zero' -> displayMessage;
                             true -> abort;
                         if);
                     if);
                     (if not abort then
                         (if values.doHeight then
                             (if values.height = 0 then
                                 'The height must be greater than zero' -> displayMessage;
                                 true -> abort;
                             if);
                         if);
                     if);
                     (if not abort then
                         values[] -> alignspacing;
                         theWindow.close;
                     if);
                  #);
                cancel::
                  (# 
                  do theWindow.close;
                  #);
             #);
           open::
             (# 
             do 'Spacing' -> title;
                hide;
                (contents, values[]) -> theSpacingDialog.open;
                theSpacingDialog.size -> this(window).size;
                centerOnScreen;
             #);
        #);
      values: ^spacingValues;
   do getSpacingValues -> values[];
      theWindow.open;
      theWindow.showModal;
   #)
   
-- graphicalEditorSelectionDoCopy: doPart --
do (# 
   do (if isEditMenuPossible then
          this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
      if);
   #);
   
-- graphicalEditorSelectionDoCut: doPart --
do (# 
   do (if isEditMenuPossible then
          this(selection)[] -> this(graphicalEditor).private.theClipBoard.copyToScrap;
          makeCutOperation;
      if);
   #);


-- graphicalEditorEnvFind: doPart --
do search:
     private.editors.scan
     (# 
     do (if node[] -> current.node.equal then
            current[] -> editor[];
            leave search;
        if);
     #);
   
-- graphicalEditorEnvInit: doPart --
do private.editors.init;
   private.theFactory.init;
   &editorWalkingAnts[] -> private.theWalkingAnts[];
   private.theWalkingAnts.init;
   (theFragServer[], MPS[], pretty[]) -> theAstEditorEnv.init;
   private.theScrap.init;
   getClassInfo -> private.theClassInfo[];
   inner;
   


-- GraphicalEdioterWindowItemEditorCreateWindowItem: doPart --
do 
   &windowItemType[] -> theWindowItem[];
   (if owner[] <> none then
       owner.getMainCanvas -> theWindowItem.open;
    else
       this(graphicalEditor).private.adorner[] -> theWindowItem.open;
       theWindowItem[] -> this(graphicalEditor).private.adorner.interior[];
   if);
   (if not initial then
       applyObjectData;
   if);
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[] -> theWindowItem.prependAction;
   &handleRefresh[] -> theWindowItem.appendAction;
   &handleFrameChanged[] -> theWindowItem.appendAction;
   (if inherited then
       theWindowItem[] -> makeDelegateMousedownAction;
   if);
   inner;
   
   
-- GraphicalEditorCanvasEditorCreateTheWindowItem: doPart --
do (if not (locked OR inherited) then
       createTheReciever;
   if);
   (if not initial then
       children.scan
       (# 
       do current.createTheWindowItem; 
       #);
   if);
   inner;
   


   
-- textEditorPictOpen: doPart --
do private.open;
   


-- graphicalEditorUndo: doPart --
do (# theOperation: ^operation;
   do (if not private.undoStack.empty then
          private.undoStack.pop -> theOperation[];
          theOperation.undoIt;
          theOperation[] -> private.redoStack.push;
      if);
   #);
   
-- graphicalEditorUndoText: doPart --
do (if canUndo then
       (private.undoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanUndo: doPart --
do not private.undoStack.empty -> value;
   
-- graphicalEditorRedo: doPart --
do (# theOperation: ^operation;
   do (if not private.redoStack.empty then
          private.redoStack.pop -> theOperation[];
          theOperation.doIt;
          theOperation[] -> private.undoStack.push;
      if);
   #);
  
   
-- graphicalEditorCanRedo: doPart --
do not private.redoStack.empty -> value
   
-- graphicalEditorRedoText: doPart --
do (if canRedo then
       (private.redoStack.top).name -> value[];
   if);
   
-- graphicalEditorCanPaste: doPart --
do not private.theClipBoard.theScrap.empty -> value;
   
-- graphicalEditorPaste: doPart --
do private.theClipBoard.makePasteOperation;
   
-- graphicalEditorEnvOpenSeparateAstEditorMethod: doPart --
do (# theEditor: ^scriptEditor;
   do node[] -> theAstEditorEnv.find -> theEditor[];
      (if theEditor[] = none then
          &scriptEditor[] -> theEditor[];
          node[] -> theEditor.init;
          title[] -> theEditor.title;
       else
          theEditor.bringToFront;
      if);
   #);
   

   
-- graphicalEditorExitMode: doPart --
do private.mode -> value;
   
-- windowItemEditorListCopy: doPart --
do &windowItemEditorList[] -> theCopy[];
   theCopy.init;
   scan
   (# 
   do current[] -> theCopy.append;
   #);
   
-- windowItemEditorListSet: doPart --
do clear;
   theOther.scan
   (# 
   do current[] -> append;
   #);
   

-- selectionAppend: doPart --
do true -> elm.private.selected;
   selectionChanged;
   
-- selectionPrepend: doPart --
do true -> elm.private.selected;
   selectionChanged;
   
-- selectionDelete: doPart --
do 
   false -> elm.private.selected;
   selectionChanged;
   
-- selectionClear: doPart --
do selectionChanged;
   scan
   (# 
   do false -> current.private.selected;
   #);
   
-- windowItemEditorGetPublicAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       node[] -> betaGram.getAttributes -> theAttributes[];
   if);
   
-- windowItemEditorGetPrivateAttributes: doPart --
do (# theDescriptorForm: ^astInterface.beta.descriptorForm;
      theObjectDescriptor: ^astInterface.beta.objectDescriptor;
      theMainPart: ^astInterface.beta.mainPart;
   do (if privateFrag[] <> none then
          privateFrag.root[] -> theDescriptorForm[];
          theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
          theObjectDescriptor.getMainPart -> theMainPart[];
          theMainPart.getAttributes -> theAttributes[];
      if);
   #);
   inner;
   
-- windowItemEditorGetMainAttributes: doPart --
do inner;
   (if theAttributes[] = none then
       getPrivateAttributes -> theAttributes[];
       (if theAttributes[] = None then
           getPublicAttributes -> theAttributes[];
       if);
   if);
   

-- windowItemEditorNewNode: doPart --
do (# theAttributes: ^astInterface.beta.attributes;
      className, instanceName: ^text;
   do owner.getMainAttributes -> theAttributes[];
      type -> getClassName -> className[];
      type -> uniqueName -> instanceName[];
      (theAttributes.frag[], instanceName[],className[])
        -> betaGram.newSingularItem -> node[];
   #);
   inner;
   
-- graphicalEditorOnAboutToClose: doPart --
do INNER;
   

-- windowItemEditorCreateOpen: doPart --
do (# theDoPart: ^astInterface.beta.doPart;
      oldImps: ^astInterface.beta.imperatives;
      openDecl: ^astInterface.beta.attributeDecl;
      gram: @grammar;
   do forInitStatements -> findOpenDopart -> theDoPart[];
      (if theDoPart[] = none then
          (node.frag[],'open::< (# do #)', gram.attributeDecl) -> parseText -> openDecl[];
          (node[], openDecl[]) -> appendAttributeToNode;
      if);
      INNER createOpen;
   #)
   
-- CanvasEditorCreateOpen: doPart --
do (* children.scan
    *    (# 
    *    do (if not current.inherited then
    *           newImps.frag[] -> current.generateOpenImp -> newImps.append;
    *       if);
    *    #);
    *)
   inner createOpen;
   
-- classDataInit: doPart --
do 
   
-- windowEditorNewData: doPart --
do 'untitled' -> data.title;
   inner;
   
-- GraphicalEditorWindowItemEditorCreateInitImps: doPart --
do (if override then
       INNER;
    else
       (# x, y, width, height: @integer;
       do data.position -> (x, y);
          data.size -> (width, height);
          (betaGram.imperatives, frag[]) -> betaGram.newAst -> initImps[];
          (frag[], 'position', (frag[], x, y) -> betaGram.newPointEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'size', (frag[], width, height) -> betaGram.newPointEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindLeft', (frag[], data.bindLeft) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindRight', (frag[], data.bindRight) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindTop', (frag[], data.bindTop) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
          (frag[], 'bindBottom', (frag[], data.bindBottom) -> betaGram.newBoolEvaluation)
            -> betaGram.newAssignment -> initImps.append;
       #);
       INNER;
   if);
   
-- windowItemEditorInitialize: doPart --
do inner;
   (if not done then
       (# initializeData:
            (# aClassData: ^classData;
               theData: ^parameters;
               super: @boolean;
            enter (theData[], aClassData[], super)
            do (if aClassData[] <> none then
                   (theData[], aClassData.superClassData[], true) -> initializeData;
                   (if not super then
                       data[] -> defaultData.set;
                   if);
                   (theData[], aClassData.theImperatives[]) -> initData;
                   applyObjectData;
               if);
            #);
       do true -> createTheWindowItem;
          (data[], theClassData[], false) -> initializeData;
       #);
   if);
   
-- canvasEditorInitialize: doPart --
do (# initAttributes:
        (# aClassData: ^classData;
           super: @boolean;
        enter (aClassData[], super)
        do (if aClassData.superClassData[] <> none then
               (aClassData.superClassData[], true) -> initAttributes;
           if);
           (data[], aClassData.theImperatives[]) -> initData;
           applyObjectData;
           aClassData.theAttributes.scan
           (# theEditor: ^windowItemEditor;
              theClassData: ^classData;
           do (if current[] -> isStaticItem then
                  (current[], defaultBodyGroup) -> getClassData -> theClassData[];
                  (if theClassData[] <> none then
                      (theClassData.theClass.type, theClassData.vertical) -> makeEditor -> theEditor[];
                      (this(canvasEditor)[],current[], NONE, theClassData.theClass.type, super, theClassData[], none) 
                        -> theEditor.init;
                  if);
              if);
           #);
           
        #);
      proto: ^astInterface.AST;
      isStaticItem: booleanValue
        (# node: ^astInterface.beta.attributeDecl;
        enter node[]
        do (mps[], node[], proto[]) -> match -> value;
        #);
      frag: ^astInterface.fragmentForm;
   do true -> createTheWindowItem;
      betaGram[] -> mps.newFragmentForm -> frag[];
      (frag[], '<<nameDcl>>: @<<nameApl>> <<mainpart>>', betaGram.simpleDecl) -> parseText -> proto[];
      (theClassData[], inherited) -> initAttributes;
      true -> done;
   #);
   
-- getClassDataDoPart: doPart --
do (# superNode: ^astInterface.beta.attributeDecl;
      prefixName: ^text;
      theClass: ^classInfo.class;
      superClassData: ^classData;
      verticalDecl: ^astInterface.beta.attributeDecl;
   do node[] -> betaGram.getPrefix -> prefixName[];
      &classData[] -> theClassData[];
      node[] -> theClassData.node[];
      (if prefixName[] <> none then
          prefixName[] -> this(graphicalEditorEnv).private.theClassInfo.lookup -> theClass[];
          (if theClass[] = none then
              node[] -> getSuperPattern -> superNode[];
              (if superNode[] <> none then
                  (superNode[], group[]) -> getClassData -> superClassData[];
                  (if superClassData[] <> none then
                      superClassData.theClass[] -> theClassData.theClass[];
                      superClassData[] -> theClassData.superClassData[];
                   else
                      none -> theClassData[];
                  if);
               else
                  none -> theClassData[];
              if);
           else
              (if theClass.supported  then
                  (if theClass.type
                   //scrollbarType 
                   //separatorType then
                      (node[], 'vertical') -> betaGram.findAttribute -> verticalDecl[];
                      (if verticalDecl[] <> none then
                          true -> theClassData.vertical;
                      if);
                  if);
                  theClass[] -> theClassData.theClass[];
               else
                  NONE -> theClassData[];
              if);
          if);
       else
          NONE -> theClassData[];
      if);
      (if theClassData[] <> none then
          (node[], group[]) -> getAttributes -> (theClassData.theAttributes[], theClassData.theImperatives[]);
      if);
   #)
   
-- checkIdentifierDoPart: doPart --
do (if name.empty then
       false -> value;
    else
       makeFragmentForm -> frag[];
       (frag[], name[], betaGram.nameDcl) -> parseText -> nameDecl[];
       (nameDecl[] <> NONE) -> value;
   if);
-- textEditorPictContentsOnMousedown: doPart --
do 
   
-- makeDelegateMousedownAction: doPart --
do findEnclosing -> enclosing[];
   &aWindowItem.mousedownAction
   (# p: @point;
   do theEvent.localPosition -> p;
      (p, aWindowItem[], enclosing.theWindowItem[]) -> translate -> p;
      (theEvent[], p) -> enclosing.mouseDown;
   #)[] -> aWindowitem.appendAction;
   
