ORIGIN 'graphicaleditorprivate';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds'
        '~beta/sysutils/v1.6/time'
        '~beta/sysutils/v1.6/objinterface'
        '~beta/betaast/v5.2/gram'
        '~beta/betaast/v5.2/betasematt'
        '~beta/guienv/v1.6/private/datastructures/sequence'
        '~beta/containers/v1.6/list'
        '../../dialogs/confirmdialog'
        '../../dialogs/coloreditor'
        '../../dialogs/integerfield'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '~beta/guienv/v1.6/utils/guienvstuff'
        '../../guienvstuff/killtranslations'
        '../../mpsstuff/mpsutils'
        '../../dialogs/spacingdialog'
        '../../buildermenu'
        '~beta/guienv/v1.6/utils/prompts'
        '../../resourcesupport/easyinterface'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        '../../dialogs/center'
        '../icons'
        'editorwindowbody';
MDBODY mac 'macintosh/graphicaleditor_mac'
       ppcmac 'macintosh/graphicaleditor_mac'
       nti 'winnt/graphicaleditor_nti'
       default 'X11/graphicaleditor_X11';
-- entryExistsBody: DoPart --
do
   false->value;
   l:
     (# e: @diskEntry; 
     do
        name[]->e.path;
        e.exists (# error::  (#  do leave l;  #);  #)->value;
        
     #);
     

-- entryReadableBody: DoPart --
do
   false->value;
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.readable (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
   if);
     

-- entryWriteAbleBody: DoPart --
do
   false->value;
   l:
   (if name[]->entryExists then
       l:
         (# e: @diskEntry; 
         do
            name[]->e.path;
            e.writeAble (# error::  (#  do leave l;  #);  #)->value;
            
         #);
       
    else
       true->value; 
   if);
     






-- graphicalEditorNewEditor: DoPart --
do
     (#
        node: ^astInterface.beta.attributeDecl;
        super: ^astInterface.beta.patternDecl;
        theAttributes: ^astInterface.beta.attributes;
        name: ^text;
        vertical: @boolean;
        split:
          (# name,realName: ^text; vertical: @boolean
          enter name[]
          do
             (if name.length > 9 then
                 (if '-vertical'->((name.length-8,name.length)->name.sub).equal
                  then
                     (1,name.length-9)->name.sub->realName[]; true->vertical
                  else
                     name[]->realName[]; false->vertical
                 if)
              else
                 name[]->realName[]; false->vertical
             if)
          exit (realName[],vertical)
          #);
        
     do
        (if theClassData[] = none then
            className[]->split->(className[],vertical);
            (className.copy,vertical)->makeEditor->theEditor[];
            vertical->theEditor.vertical;
            (THIS(componentEditor)[],className.copy,none )->theEditor.new;
            selection.clear;
            theEditor.select;
            
         else
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theClassData.node[]->super[];
            super[]->betaGram.getName->className[];
            getMainAttributes->theAttributes[];
            (theAttributes[],className[])->newUniqueName->name[];
            (theAttributes.frag[],name[],className[])->betaGram.newSingularItem
              ->node[];
            (node[],super[])->setSemanticLink;
            node[]->appendAttribute;
            node[]->getClassData->theClassData[];
            (if theClassData[] <> none then
                (THIS(componentEditor)[],node[],none ,false,theClassData[],none )
                  ->theEditor.init;
                theEditor.realCreateOpen;
                
            if);
            
        if);
        
     #);
     

-- graphicalEditorOpen: DoPart --
do
     (# 
     do
        5->gridSize;
        THIS(graphicalEditorEnv).factory.scan
          (# 
          do
             (if current.grouping[] <> none then
                 (current.grouping[],current.icon[],current.name[])
                   ->THIS(editorWindow).private.paletteTabber.addPaletteItem
             if);
             
          #);
        THIS(graphicalEditor)[]->insert;
        hide;
        'Graphical Objects'->title;
        private.theClipBoard.init;
        selectMode->private.mode;
        private.initNames;
        THIS(graphicalEditorEnv).private.theConstants[]
          ->private.thePropertyInspector.open;
        
     #);
     

-- graphicalEditorClose: DoPart --
do
     (# 
     do
        INNER close;
        selection.clear;
        forgetSelectionChanged;
        private.contentsEditor.close;
        THIS(graphicalEditor)[]->delete;
        private.thePropertyInspector.close;
        
     #);
     

-- graphicalEditorOnMouseDown: DoPart --
do selection.clear;   





-- windowItemEditorSelect: DoPart --
do
   (if not selected then
       (if THIS(componentEditor)[]->selection.selectable then
           THIS(componentEditor)[]->selection.append; 
        else
           beep; 
       if);
       
   if);
     

-- windowItemEditorDeSelect: DoPart --
do
   (if selected then THIS(componentEditor)[]->selection.delete;  if);
     

-- GraphicalEditorInit: DoPart --
do
     (#
        theClassData: ^classData;
        theEditor: ^componentEditor;
        privateFrag: ^astInterface.fragmentForm;
        
     do
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            INNER init;
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     




-- GraphicalEditorWindowItemEditorEditAttributes: DoPart --
do
     (#
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : attributes'->theTitle.append;
             
          exit theTitle[]
          #);
        
     do (node[],makeTitle)->com.openAstEditor; 
     #);
     


-- GraphicalEditorWindowItemEditorEditVirtual: DoPart --
do
     (#
        theAttribute,theVirtual,theEventHandler:
          ^astInterface.beta.attributeDecl;
        astToEdit: ^astInterface.AST;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        slotName: ^text;
        doPartFrag: ^astInterface.fragmentForm;
        group: ^astInterface.fragmentGroup;
        theAst: ^astInterface.AST;
        makeTitle:
          (# theTitle: ^text; 
          do
             node[]->betaGram.getName->theTitle[];
             ' : '->theTitle.append;
             name[]->theTitle.append;
             
          exit theTitle[]
          #);
        frag: ^astInterface.fragmentForm;
        
     do
        node[]->theAttribute[];
        name[]->findVirtual->theVirtual[];
        (if theVirtual[] = none then
            name[]->createVirtual->theVirtual[];
            (if theVirtual[] <> none then
                (if isPrivateToWindow or (defaultBodyGroup = none ) then
                    theVirtual[]->astToEdit[]; 
                 else
                    theVirtual[]->betaGram.getObjectDescriptor
                      ->theObjectDescriptor[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getActionPart->theActionPart[];
                    theAttribute[]->betaGram.getName->slotName[];
                    name[]->slotName.append;
                    (theAttribute.frag[],slotName[])->betaGram.newSlotDoPart
                      ->theActionPart.putDoPartOpt;
                    slotName[]->betaGram.newDoPartFrag->doPartFrag[];
                    defaultBodyGroup->group[];
                    slotName[]->group.findFragment->frag[];
                    (if frag[] <> none then
                        frag.root[]->astToEdit[]; 
                     else
                        doPartFrag[]->group.fragmentList.addFragment;
                        doPartFrag.root[]->astToEdit[];
                        
                    if);
                    
                if);
                
             else
                
            if);
            
         else
            theVirtual[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getActionPart->theActionPart[];
            theActionPart.getDoPartOpt->theAst[];
            (if theAst.kind = MPS.kinds.unExpanded then
                theAst[]->theUnExpanded[];
                (if theUnExpanded.isSlot then
                    theUnExpanded.theSlot->theSlot[];
                    defaultBodyGroup->group[];
                    theSlot.name->group.findFragment->doPartFrag[];
                    doPartFrag.root[]->astToEdit[];
                    
                if);
                
             else
                theVirtual[]->astToEdit[]; 
            if);
            
        if);
        (astToEdit[],makeTitle)->com.openAstEditor;
        
     #);
     


-- GraphicalEditorNew: DoPart --
do
     (#
        theClassData: ^classData;
        theEditor: ^componentEditor;
        privateFrag: ^astInterface.fragmentForm;
        theDoPart: ^astInterface.beta.doPart;
        
     do
        9->trace (#  do node[]->betaGram.getName->xT; '.new'->xT;  #);
        node[]->betaGram.getPrivateFragment->privateFrag[];
        (if privateFrag[] <> none then
            privateFrag[]->private.privateFragHandler.frag[];
            private.privateFragHandler[]->theFragServer.subscribe;
            privateFrag.father->onGroupChanged;
            
        if);
        node[]->getClassData->theClassData[];
        (if theClassData[] <> none then
            (theClassData.className.copy,theClassData.vertical)->makeEditor
              ->theEditor[];
            theEditor[]->private.contentsEditor[];
            (none ,node[],none ,false,theClassData[],privateFrag[])
              ->theEditor.init;
            9->trace (#  do 'adding open declaration'->xT #);
            theEditor.realCreateOpen->theDoPart[];
            adjustSize;
            private.controlPoints.init;
            show;
            
         else
            close; 
        if);
        
     #);
     



-- GraphicalEditorEnterPrivateAttributes: DoPart --
do   

-- GraphicalEditorExitPrivateAttributes: DoPart --
do   

-- GraphicalEditorEnterPrivateDoParts: DoPart --
do   

-- GraphicalEditorExitPrivateDoPart: DoPart --
do   


-- GraphicalEditorSelectionDelete: DoPart --
do makeDeleteOperation;   

-- GraphicalEditorSelectionFitToContents: DoPart --
do makeFitToContentsOperation;   

-- GraphicalEditorSelectionAlignLeft: DoPart --
do
   makeAlignOperation
     (#  do (modelFrame.left-currentFrame.left,0)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignRight: DoPart --
do
   makeAlignOperation
     (# 
     do (modelFrame.right-currentFrame.right,0)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignTop: DoPart --
do
   makeAlignOperation
     (#  do (0,modelFrame.top-currentFrame.top)->currentFrame.offset;  #);
     

-- GraphicalEditorSelectionAlignBottom: DoPart --
do
   makeAlignOperation
     (# 
     do (0,modelFrame.bottom-currentFrame.bottom)->currentFrame.offset; 
     #);
     

-- GraphicalEditorSelectionAlignHorCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.right-currentFrame.left) div 2)+currentFrame.left
          ->itsCent;
        ((modelFrame.right-modelFrame.left) div 2)+modelFrame.left->cent;
        (cent-itsCent,0)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionAlignVerCenter: DoPart --
do
   makeAlignOperation
     (# cent,itsCent: @integer; 
     do
        ((currentFrame.bottom-currentFrame.top) div 2)+currentFrame.top
          ->itsCent;
        ((modelFrame.bottom-modelFrame.top) div 2)+modelFrame.top->cent;
        (0,cent-itsCent)->currentFrame.offset;
        
     #);
     

-- GraphicalEditorSelectionShowSpacingDialog: DoPart --
do
     (#
        theWindow: @window
          (#
             theSpacingDialog: @spacingDialog
               (#
                  accept:: 
                    (# abort: @boolean; 
                    do
                       (if values.doWidth then
                           (if values.width = 0 then
                               'The width must be greater than zero'
                                 ->displayMessage;
                               true->abort;
                               
                           if);
                           
                       if);
                       (if not abort then
                           (if values.doHeight then
                               (if values.height = 0 then
                                   'The height must be greater than zero'
                                     ->displayMessage;
                                   true->abort;
                                   
                               if);
                               
                           if);
                           
                       if);
                       (if not abort then
                           values[]->alignspacing; theWindow.close; 
                       if);
                       
                    #);
                  cancel::  (#  do theWindow.close;  #);
                  
               #);
             open:: 
               (# 
               do
                  'Spacing'->title;
                  hide;
                  (contents,values[])->theSpacingDialog.open;
                  theSpacingDialog.size->THIS(window).size;
                  center;
                  
               #);
             
          #);
        values: ^spacingValues;
        
     do getSpacingValues->values[]; theWindow.open; theWindow.showModal; 
     #)  

-- graphicalEditorSelectionDoCopy: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            
        if);
        
     #);
     

-- graphicalEditorSelectionDoCut: DoPart --
do
     (# 
     do
        (if isEditMenuPossible then
            THIS(selection)[]
              ->THIS(graphicalEditor).private.theClipBoard.copyToScrap;
            makeCutOperation;
            
        if);
        
     #);
     

-- graphicalEditorEnvFind: DoPart --
do
   search: private.editors.scan
     (# 
     do
        (if node[]->current.node.equal then
            current[]->editor[]; leave search; 
        if);
        
     #);
     

-- graphicalEditorEnvInit: DoPart --
do
   screen[]->tracestream[];
   private.editors.init;
   factory.init;
   private.infoDialogs.init;
   private.theScrap.init;
   private.borderConsts.init;
   private.hAlignmentConsts.init;
   private.vAlignmentConsts.init;
   ('border.style',private.borderConsts[])->registerConstants;
   ('vertical.alignment',private.vAlignmentConsts[])->registerConstants;
   ('horizontal.alignment',private.hAlignmentConsts[])->registerConstants;
   INNER ;
     



-- graphicalEditorUndo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.undoStack.empty then
            private.undoStack.pop->theOperation[];
            theOperation.undoIt;
            theOperation[]->private.redoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorUndoText: DoPart --
do (if canUndo then (private.undoStack.top).name->value[];  if);   

-- graphicalEditorCanUndo: DoPart --
do not private.undoStack.empty->value;   

-- graphicalEditorRedo: DoPart --
do
     (# theOperation: ^operation; 
     do
        (if not private.redoStack.empty then
            private.redoStack.pop->theOperation[];
            theOperation.doIt;
            theOperation[]->private.undoStack.push;
            
        if);
        
     #);
     

-- graphicalEditorCanRedo: DoPart --
do not private.redoStack.empty->value  

-- graphicalEditorRedoText: DoPart --
do (if canRedo then (private.redoStack.top).name->value[];  if);   

-- graphicalEditorCanPaste: DoPart --
do not private.theClipBoard.theScrap.empty->value;   

-- graphicalEditorPaste: DoPart --
do private.theClipBoard.makePasteOperation;   

-- graphicalEditorExitMode: DoPart --
do private.mode->value;   

-- windowItemEditorListCopy: DoPart --
do
   &componentEditorList[]->theCopy[];
   theCopy.init;
   scan
     (#  do current[]->theCopy.append;  #);
     

-- windowItemEditorListSet: DoPart --
do clear; theOther.scan (#  do current[]->append;  #);   

-- selectionAppend: DoPart --
do true->elm.selected; selectionChanged;   

-- selectionPrepend: DoPart --
do true->elm.selected; selectionChanged;   

-- selectionDelete: DoPart --
do false->elm.selected; selectionChanged;   

-- selectionClear: DoPart --
do selectionChanged; scan (#  do false->current.selected;  #);   


     

-- graphicalEditorOnAboutToClose: DoPart --
do INNER ;   


-- classDataInit: DoPart --
do   




-- getClassDataDoPart: DoPart --
do
     (#
        superNode: ^astInterface.beta.attributeDecl;
        prefixName: ^text;
        inst: ^instantiator;
        superClassData: ^classData;
        verticalDecl: ^astInterface.beta.attributeDecl;
        
     do
        node[]->betaGram.getPrefix->prefixName[];
        (if prefixName[] <> none then
            &classData[]->theClassData[];
            node[]->theClassData.node[];
            (node[],'vertical')->betaGram.findAttribute->verticalDecl[];
            (verticalDecl[] <> none )->theClassData.vertical;
            (if prefixName[] <> none then
                prefixName[]->lookup->inst[];
                (if inst[] = none then
                    node[]->getSuperPattern->superNode[];
                    (if superNode[] <> none then
                        superNode[]->getClassData->superClassData[];
                        (if superClassData[] <> none then
                            superClassData.className[]
                              ->theClassData.className[];
                            superClassData[]->theClassData.superClassData[];
                            
                         else
                            none ->theClassData[]; 
                        if);
                        
                     else
                        none ->theClassData[]; 
                    if);
                    
                 else
                    (if inst[] <> none then
                        inst.name[]->theClassData.className[]; 
                     else
                        none ->theClassData[]; 
                    if);
                    
                if);
                
             else
                none ->theClassData[]; 
            if);
            (if theClassData[] <> none then
                node[]->getAttributes
                  ->
                    (theClassData.theAttributes[],
                     theClassData.theImperatives[]);
                
            if);
            
        if);
        
     #)  

-- checkIdentifierDoPart: DoPart --
do
   (if name.empty then
       false->value; 
    else
       makeFragmentForm->frag[];
       (frag[],name[],betaGram.nameDcl)->parseText->nameDecl[];
       (nameDecl[] <> none )->value;
       
   if);
     




-- graphicalEditorEnvInsertCustom: DoPart --
do
     (# 
     do
        ((iconName[],iconID)->loadBitmap,name[],theInstantiator[],path[],
         grouping[],width,height)->factory.insert;
        
     #);
     

-- graphicalEditorMousedownInItem: DoPart --
do
     (#
        value: ^rectangle;
        prox: @proxy
          (#
             moveTo:: 
               (# theCreateOperation: ^createOperation; 
               do
                  &createOperation[]->theCreateOperation[];
                  (theCanvasEditor[],newFrame[],none ,name[])
                    ->theCreateOperation.init;
                  
               #);
             
          #);
        
     do
        &rectangle[]->value[];
        p->value.topLeft;
        name[]->getDefaultSize->value.size;
        true->prox.palette;
        (value[],prox[])
          ->THIS(editorWindow).private.paletteTabber.dragAndDrop
            (#
               gridSize::  (#  do THIS(graphicalEditor).gridSize->value #);
               gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #)
            #);
        
     #);
     




-- addInclude: DoPart --
do
   (if not ((group[],path[])->hasInclude) then
       'INCLUDE'
         ->group.prop.addProp
           (# ifPropExist::  (#  do false->delete #); 
           do path[]->addString
           #);
       group.loadIncludes
   if)  

-- hasInclude: DoPart --
do
   l:
   'INCLUDE'
     ->group.prop.getProp
       (#
          doProp:: 
            (# 
            do
               scanParameters
                 (#
                    doString:: 
                      (# 
                      do (if path[]->s.equal then TRUE->value; leave l if)
                      #)
                 #)
            #)
       #)  

-- createNewWindow: DoPart --
do
     (# frag: ^astInterface.fragmentForm
     do
        (name[],'guienvlib')->com.createSourceFile->frag[];
        (if frag[] <> none then (frag[],name[],'window')->createWindow if)
     #)  

-- createSourceFile: DoPart --
do
     (#
        stripExtension:
          (# path: ^text; lastDotInx,lastSlashInx: @integer; 
          enter path[]
          do
             '.'->path.findAll (#  do inx->lastDotInx #);
             MPS.thePathHandler.directoryChar
               ->path.findAll (#  do inx->lastSlashInx #);
             (if (lastDotInx > 0) and (lastDotInx > lastSlashInx) then
                 (lastDotInx,path.length)->path.delete; 
             if);
             
          #);
        createFragmentGroup:
          (# name: ^text; group: ^astInterface.fragmentGroup; 
          enter name[]
          do name[]->MPS.top.newGroup->group[]; 
          exit group[]
          #);
        createFragmentForm:
          (# name: ^text; frag: ^astInterface.fragmentForm; 
          enter name[]
          do betagram[]->MPS.newFragmentForm->frag[]; name[]->frag.name; 
          exit frag[]
          #);
        bodyGroup: ^astInterface.fragmentGroup;
        astFileName: ^text;
        betFileName: ^text;
        bodyFileName: ^text;
        bodyAstFileName: ^text;
        bodyBetFileName: ^text;
        gram: @grammar;
        guienvLocation: (#  exit '~beta/guienv/v1.6/guienv' #);
        getShortName:
          (# name: ^text; shortName: ^text; lastDirCharPos: @integer; 
          enter name[]
          do
             name.reset;
             MPS.thePathHandler.directoryChar
               ->name.find (#  do inx->lastDirCharPos;  #);
             (if (lastDirCharPos > 0) and (lastDirCharPos < name.length) then
                 (lastDirCharPos+1,name.length)->name.sub->shortName[]; 
              else
                 name.copy->shortName[]; 
             if);
             
          exit shortName[]
          #);
        isOpen: booleanValue
          (# name: ^text
          enter name[]
          do (name[]->mps.top.groupTable.find) <> none ->value
          #);
        
     do
        creating:
          (#
             ok: @boolean;
             deleteFile:
               (# fName: ^text; ok: @boolean
               enter fName[]
               do
                  deleting:
                    (#
                       f: @file
                         (#
                            reportError:
                              (# reason: ^text; msg: ^text
                              enter reason[]
                              do
                                 &text[]->msg[];
                                 'The file "'->msg.putText;
                                 entry.path.name->msg.putText;
                                 '" cannot be deleted, because '->msg.putText;
                                 reason[]->msg.putText;
                                 msg[]->displayMessage;
                                 false->ok;
                                 leave deleting
                              #);
                            otherError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            AccessError:: 
                              (# 
                              do
                                 'of insufficient access priviligies.'
                                   ->reportError
                              #);
                            NoSpaceError:: 
                              (# 
                              do
                                 'there is no space left on device.'
                                   ->reportError
                              #);
                            FileExistsError:: 
                              (# 
                              do 'of unspecified error.'->reportError
                              #);
                            NoSuchFileError::  (#  do true->continue #);
                            
                         #)
                    do fName[]->f.name; true->ok; f.delete
                    #)
               exit ok
               #);
             f: @file
          do
             (if fileName[] <> none then
                 fileName[]->stripExtension;
                 (fileName[],currentDirectory)
                   ->MPS.thePathHandler.convertFilePath->fileName[];
                 '.ast'->(fileName.copy).append->astFileName[];
                 '.bet'->(fileName.copy).append->betFileName[];
                 (if (astFileName[]->entryExists) or
                 (betFileName[]->entryExists) then
                     (if fileName[]->isOpen then
                         composeMsg:
                           (# str: @text
                           do
                              'The fragment group "'->str.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->str.putText;
                              '" cannot be created, because it is already open.'
                                ->str.putText;
                              str[]->displayMessage
                           #)
                      else
                         askUser:
                           (# msg: @text
                           do
                              'Replace existing "'->msg.putText;
                              fileName[]->f.entry.path;
                              f.entry.path.name->msg.putText;
                              '" ?'->msg.putText;
                              (msg[],'Replace',true)
                                ->confirm
                                  (#
                                     onConfirm:: 
                                       (# 
                                       do
                                          (if astFileName[]->deleteFile then
                                              betFileName[]->deleteFile->ok
                                          if)
                                       #)
                                  #)
                           #)
                     if)
                  else
                     true->ok
                 if);
                 (if ok then
                     fileName[]->createFragmentGroup->group[];
                     (if group[] <> none then
                         'ORIGIN'
                           ->group.prop.addProp
                             (#  do guienvLocation->addString;  #);
                         fragName[]->betagram.newAttributesFrag->frag[];
                         frag[]->group.fragmentList.addFragment;
                         group.markAsChanged;
                         (group[],betFileName[])->com.prettyPrintGroup;
                         INNER createSourceFile;
                         
                     if)
                 if);
                 
             if)
          #);
        
     #)  

-- friggApplicationCreateWindow: DoPart --
do
   l:
     (#
        theAttributesForm: ^astInterface.beta.attributesForm;
        theAttributes: ^astInterface.beta.attributes;
        theAttribute: ^astInterface.beta.attributeDecl;
        theGraphicalEditor: ^graphicalEditorEnv.graphicalEditor;
        fg: ^astInterface.fragmentGroup;
        classes: ^patternList;
        classNames: @textList;
        gram: @grammar;
        
     do
        frag.father->fg[];
        frag.root[]->theAttributesForm[];
        theAttributesForm.getAttributes->theAttributes[];
        (theAttributes[],name[])->betagram.find->theAttribute[];
        (if theAttribute[] <> none then
            'The window could not be created because it already exists'
              ->displayMessage;
            
         else
              (#
                 son1: ^astInterface.ast;
                 doReplace: @boolean;
                 super: ^astInterface.beta.patternDecl;
                 
              do
              (*** Not mature yet 
               (if 'canvas'->className.equalNCS then
               name[]->recentCanvas
               if);
               
               ***)
                 (frag[],name[],className[])->betaGram.newPatternAttribute
                   ->theAttribute[];
                   (#
                      group,bodyGroup: ^astInterface.fragmentGroup;
                      bodyName: ^text;
                      t: @text;
                      decl: ^astInterface.beta.simpleDecl;
                      privateFrag,theFragment: ^astinterface.fragmentForm;
                      privateName: ^text;
                      
                   do
                      frag.father->group[];
                      (if group[] <> none then
                          l: group.scanBodyGroups
                            (# 
                            do currentFullPath[]->bodyName[]; leave l; 
                            #);
                          (if bodyName[] <> none then
                              bodyName[]->MPS.safeOpen->bodyGroup[];
                              (if bodyGroup[] <> none then
                                  'private'->(name.copy).append->privateName[];
                                  'private: @<<SLOT '->t.append;
                                  privateName[]->t.append;
                                  ': descriptor>>'->t.append;
                                  (frag[],t[],gram.simpleDecl)->parseText
                                    ->decl[];
                                  (theAttribute[],decl[])
                                    ->betaGram.appendAttribute;
                                  betaGram[]->MPS.newFragmentForm
                                    ->privateFrag[];
                                  privateName[]->privateFrag.name;
                                  privateName[]->bodyGroup.findFragment
                                    ->theFragment[];
                                  (if theFragment[] <> none then
                                      theFragment[]->bodyGroup.deleteFragment; 
                                  if);
                                  privateFrag[]
                                    ->bodyGroup.fragmentList.addFragment;
                                  (privateFrag[],none )
                                    ->betaGram.newDescriptorForm
                                    ->privateFrag.root[];
                                  bodyGroup[]->onGroupChanged;
                                  
                              if);
                              
                          if);
                          
                      if);
                      
                   #);
                 (if theAttributes.noOfsons = 1 then
                     1->theAttributes.get->son1[];
                     (if son1.kind = mps.kinds.optional then
                         true->doReplace; 
                     if);
                     
                 if);
                 (if doReplace then
                     (1,theAttribute[])->theAttributes.put; 
                  else
                     theAttribute[]->theAttributes.append; 
                 if);
                 frag.father->onGroupChanged;
                 &graphicalEditor[]->theGraphicalEditor[];
                 theGraphicalEditor.open;
                 theAttribute[]->theGraphicalEditor.new;
                 (if doReplace then
                     (true,frag[],son1[],theAttribute[])
                       ->theFragServer.notifyAstReplaced;
                     
                  else
                     (true,frag[],theAttributes[],theAttributes.noOfSons-1)
                       ->theFragServer.notifyListElementInserted;
                     
                 if);
                 
              #);
            
        if);
        
     #);
     




-- graphicalEditorEnterMode: DoPart --
do
   value->private.mode;
   (if value
    // selectMode then
       cursors.arrow[]->(contents).theCursor; 
    // hierarkiMode then
       cursors.cross[]->(contents).theCursor; 
    // resizeMode then
       cursors.plus[]->(contents).theCursor; 
   if);
     

-- graphicalEditorClearSelection: DoPart --
do selection.clear  

-- graphicalEditorOnSelectEntire: DoPart --
do selection.clear; (contentsEditor).select;   


-- wrapperHilite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- wrapperLowlite: DoPart --
do
   graphics
     (# overrideChildren::  (#  do true->value #); h,v: @integer; 
     do
        size->(h,v);
        transferModes.xorBlend->pen.mode;
        2->pen.size;
        ((0+2,0+2),(h-2,v-2))->drawRect;
        
     #);
     

-- windowItemRubber: DoPart --
do
   graphics
     (#
        overrideChildren::  (#  do true->value #);
        adjustToGrid:
          (# x,y: @integer; 
          enter (x,y)
          do
             x-oriX->x;
             y-oriY->y;
             (if gridSize <> 0 then
                 ((x+(gridSize div 2)) div gridSize)*gridSize->x;
                 ((y+(gridSize div 2)) div gridSize)*gridSize->y
             if);
             x+oriX->x;
             y+oriY->y
          exit (x,y)
          #);
        oriX,oriY: @integer;
        
     do
        gridStart->(oriX,oriY);
        trackMouse
          (#
             topWeight,leftWeight,rightWeight,bottomWeight: @integer;
             ignore: @integer;
             adjusted: @rectangle;
             mousePress:: 
               (# 
               do
                  (if doTop then 1->topWeight;  if);
                  (if doLeft then 1->leftWeight;  if);
                  (if doRight then 1->rightWeight;  if);
                  (if doBottom then 1->bottomWeight;  if);
                  transferModes.xorBlend->pen.mode;
                  r->adjusted;
                  adjusted->drawRect;
                  
               #);
             mouseMove:: 
               (# 
               do
                  (if (h <> 0) or (v <> 0) then
                      adjusted->drawRect;
                      r.top+v*topWeight->r.top;
                      r.left+h*leftWeight->r.left;
                      r.bottom+v*bottomWeight->r.bottom;
                      r.right+h*rightWeight->r.right;
                      (if (r.bottom-r.top < 1) then
                          (if doTop then
                              r.bottom-1->r.top; 
                           else
                              r.top+1->r.bottom
                          if);
                          
                      if);
                      (if (r.right-r.left < 1) then
                          (if doLeft then
                              r.right-1->r.left; 
                           else
                              r.left+1->r.right
                          if);
                          
                      if);
                      r->adjusted;
                      (if doLeft then
                          (r.left,0)->adjustToGrid->(adjusted.left,ignore)
                      if);
                      (if doTop then
                          (0,r.top)->adjustToGrid->(ignore,adjusted.top)
                      if);
                      (if doRight then
                          (r.right,0)->adjustToGrid->(adjusted.right,ignore)
                      if);
                      (if doBottom then
                          (0,r.bottom)->adjustToGrid->(ignore,adjusted.bottom)
                      if);
                      adjusted->drawRect;
                      
                  if);
                  
               #);
             mouseRelease::  (#  do adjusted->drawRect; adjusted->r;  #);
             
          #);
        
     #)  
-- graphicalEditorEnvAddPatternToPalette: doPart --
do (# theInstantiator: ^instantiator;
		name: ^text;		
		prefixName: ^text;
   do node[] -> betaGram.getPrefix -> prefixName[];
      (if prefixName[] <> NONE then
      	prefixName[] -> lookup -> theInstantiator[];
      	(if theInstantiator[] <> NONE then
      		node[] -> betaGram.getName -> name[];
      		name[] -> theInstantiator.copyName -> theInstantiator[];
      		(node.frag.father).fullName -> theInstantiator.path[];
      		'Custom' -> theInstantiator.grouping[];
      		(name[],theInstantiator[]) -> factory.insts.define;
      	if);
      if);
   #);

