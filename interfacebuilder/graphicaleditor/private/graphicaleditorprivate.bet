ORIGIN '../graphicaleditor';
BODY 'graphicaleditorbody';
INCLUDE '../../guienvstuff/mywalkingants';

INCLUDE 'controlpoints';

INCLUDE '~beta/guienv/v1.4/utils/guienvadds';
INCLUDE '~beta/guienv/v1.4/utils/track';
INCLUDE '~beta/guienv/v1.4/utils/iconname';
INCLUDE '~beta/guienv/v1.4/utils/timer';
INCLUDE '~beta/sysutils/v1.5/time';
INCLUDE '~beta/sysutils/v1.5/objinterface';
INCLUDE '~beta/betaast/v5.1/gram';
INCLUDE '~beta/betaast/v5.1/betasematt';
INCLUDE '../../datastructures/sequence';
INCLUDE '../../datastructures/doublelinkedlist';
INCLUDE '../../dialogs/editinfo';
INCLUDE '../../dialogs/namedialog';
INCLUDE '../../code/generate';
INCLUDE '../../code/pattern';
INCLUDE '../../code/followsemanticlink';
INCLUDE '../../code/match';
INCLUDE '../../asteditor/asteditor';
INCLUDE '../../palettes/palette';
INCLUDE '~beta/guienv/v1.4/utils/guienvstuff';
INCLUDE '../../guienvstuff/killtranslations';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '../../dialogs/spacingdialog';
INCLUDE '../classinfo';
INCLUDE '../../dragmanager/dragmanager';
INCLUDE '../../buildermenu';
INCLUDE '~beta/guienv/v1.4/utils/prompts';
INCLUDE '../../resourcesupport/easyinterface';
INCLUDE '../../guienvstuff/loadbitmap';
INCLUDE '../../code/private/generatebody';
INCLUDE '../../classes/classes';

-- lib: attributes --

getSpacingValues: objectPool.get
  (# type:: spacingValues;
  #);

-- windowItemLib: attributes --

delay:
  (# startPt: @point;
  enter startPt
  do l: father.track
     (# 
        mouseMove::
          (# dh, dv: @integer;
          do curPt.h - startPt.h -> dh;
             curPt.v - startPt.v -> dv;
             (if (dh*dh > 4) or (dv*dv > 4) then
                 inner delay;
                 leave l;
             if);
          #);
     #);
  #);

-- graphicalEditorLib: attributes --


makeEditor:
  (# editor: ^windowItemEditor;
     type: @integer;
     vertical: @boolean;
  enter (type, vertical)
  do (if vertical then
         (if type
          //scrollbarType then
             verScrollbarType -> type;
          //separatorType then
             verSeparatorType -> type;
         if);
     if);
     private.editorGenerator[type] -> editor[];
  exit editor[]
  #);

dontHandleFrameChanged:
  (# 
  enter private.dontHandleFrameChanged
  exit private.dontHandleFrameChanged
  #);

adjustPalettes:
  (# r: @rectangle;
  do private.adorner.frame -> r;
     (r.right + 10, 5) -> private.theControlPalette.position;
     private.theControlPalette.frame -> r;
     (r.left, r.bottom + 10) -> private.theViewsPalette.position;
     private.theViewsPalette.frame -> r;
     (if not private.theCustomPalette.patterns.empty then
         (r.left, r.bottom + 1) -> private.theCustomPalette.position;
         private.theCustomPalette.frame -> r;
     if);
     (r.right + 5, r.bottom + 5) -> size;
  #);



makeData:
  (# data: ^parameters;
     type: @integer;
  enter type
  do type -> theDocument.theParameterStore.new -> data[];
     true -> data.bindLeft;
     false -> data.bindRight;
     true -> data.bindTop;
     false -> data.bindBottom;
     true -> data.visible;
     true -> data.enabled;
     false -> data.hilite;
  exit data[]
  #);



makeImperativeList:
  (# theImperativeList: ^imperativeList;
  do &imperativeList[] -> theImperativeList[];
     theImperativeList.init;
  exit theImperativeList[]
  #);
makeAttributeList:
  (# theAttributeList: ^attributeList;
  do &attributeList[] -> theAttributeList[];
     theAttributeList.init;
  exit theAttributeList[]
  #);
makeClassData:
  (# theClassData: ^classData;
  do &classData[] -> theClassData[];
     makeImperativeList -> theClassData.theImperatives[];
     makeAttributeList -> theClassData.theAttributes[];
  exit theClassData[]
  #);

getClassData1:
  (# node: ^astInterface.beta.attributeDecl;
     theClass: ^classInfo.class;
     theClassData: ^classData;
  enter node[]
  do node[] -> getClass -> theClass[];
     (if theClass[] <> none then
         (if theClass.supported then
             &classData[] -> theClassData[];
             (theClass[], node[], defaultBodyGroup) -> theClassData.init;
         if);
     if);
  exit theClassData[]
  #);


initData:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperativeList: ^imperativeList;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1, proto2: ^astInterface.AST;
  enter (theData[], theImperativeList[])
  do makeFragmentForm -> frag[];
     (frag[], 'border.style', betaGram.remote) -> parseText -> proto1[];
     (frag[], 'border.visible', betaGram.remote) -> parseText -> proto2[];
     theImperativeList.scan
     (# theAssignment: ^astInterface.beta.assignmentEvaluation;
        theTransaction: ^astInterface.ast;
        theObjectDenotation: ^astInterface.beta.objectDenotation;
        theAttributeDenotation: ^astInterface.ast;
        theNameApl: ^astInterface.beta.nameApl;
        
     do current[] -> theAssignment[];
        theAssignment.getTransaction -> theTransaction[];
        (if theTransaction.symbol = betaGram.objectDenotation then
            theTransaction[] -> theObjectDenotation[];
            theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
            (if theAttributeDenotation.symbol = betaGram.nameApl then
                theAttributeDenotation[] -> theNameApl[];
                (theData[], theNameApl.getText, theAssignment[]) -> adjustValue;
             else
                (if true 
                 //(mps[], theAttributeDenotation[], proto1[]) -> match then
                    (theData[], 'borderStyle', theAssignment[]) -> adjustValue;
                 //(mps[], theAttributeDenotation[], proto2[]) -> match then
                    (theData[], 'borderVisible', theAssignment[]) -> adjustValue;
                if);
            if);
        if);
     #);
  #);

initData1:
  (# theDoPart: ^astInterface.beta.doPart;
     theImperatives: ^astInterface.beta.imperatives;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1, proto2: ^astInterface.AST;
  enter (theData[], theImperatives[])
  do makeFragmentForm -> frag[];
     (frag[], 'border.style', betaGram.remote) -> parseText -> proto1[];
     (frag[], 'border.visible', betaGram.remote) -> parseText -> proto2[];
     theImperatives.iterate
     (# theAssignment: ^astInterface.beta.assignmentEvaluation;
        theTransaction: ^astInterface.ast;
        theObjectDenotation: ^astInterface.beta.objectDenotation;
        theAttributeDenotation: ^astInterface.ast;
        theNameApl: ^astInterface.beta.nameApl;
     do (if current.symbol = betaGram.assignmentEvaluation then
            current[] -> theAssignment[];
            theAssignment.getTransaction -> theTransaction[];
            (if theTransaction.symbol = betaGram.objectDenotation then
                theTransaction[] -> theObjectDenotation[];
                theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
                (if theAttributeDenotation.symbol = betaGram.nameApl then
                    theAttributeDenotation[] -> theNameApl[];
                    (theData[], theNameApl.getText, theAssignment[]) -> adjustValue;
                 else
                    (if true 
                     //(mps[], theAttributeDenotation[], proto1[]) -> match then
                        (theData[], 'borderStyle', theAssignment[]) -> adjustValue;
                     //(mps[], theAttributeDenotation[], proto2[]) -> match then
                        (theData[], 'borderVisible', theAssignment[]) -> adjustValue;
                    if);
                if);
            if);
        if);
     #);
  #);

adjustValue:
  (# theAssignment: ^astInterface.beta.assignmentEvaluation;
     theEvaluation: ^astInterface.beta.evaluation;
     name: ^text;
     value: ^atom;
     x, y, width, height: @integer;
     theData: ^parameters;
  enter (theData[], name[], theAssignment[])
  do theAssignment.getEvaluation -> theEvaluation[];
     (if true 
      //'position' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluatePoint -> (x, y);
         ('x', x) -> theData.setInt;
         ('y', y) -> theData.setInt;
      //'size' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluatePoint -> (width, height);
         ('width', width) -> theData.setInt;
         ('height', height) -> theData.setInt;
      //'frame' -> name.equalNCS then
         theEvaluation[] -> betaGram.evaluateRect -> (x, y, width, height);
         ('x', x) -> theData.setInt;
         ('y', y) -> theData.setInt;
         ('width', width) -> theData.setInt;
         ('height', height) -> theData.setInt;
      else
         name[] -> theData.data.lookup -> value[];
         (if value[] <> none then
             (if value.type
              //textType then
                 (name[], theEvaluation[] -> betaGram.evaluateText) -> theData.setText;
              //boolType then
                 (name[], theEvaluation[] -> betaGram.evaluateBool) -> theData.setBool;
              //intType then
                 (name[], theEvaluation[] -> betaGram.evaluateInt) -> theData.setInt;
             if);
         if);
     if);
  #);


defaultBodyGroup:
  (# group: ^mps.fragmentGroup;
  do theDocument.defaultBodyGroup -> group[];
  exit group[]
  #);

(*
 * Class support
 *)

(* getClass1:
 *   (# node: ^astInterface.beta.attributeDecl;
 *      prefixName: ^text;
 *      theClass: ^classInfo.class;
 *   enter node[]
 *   do node[] -> betaGram.getPrefix -> prefixName[];
 *      
 *      (if prefixName[] <> none then
 *          prefixName[] -> private.theClassInfo.lookup -> theClass[];
 *      if);
 *   exit theClass[]
 *   #);
 * 
 * 
 *)



undoTop:
  (# top: ^operation;
  do (if private.undoStack.empty then
         none -> top[];
      else
         private.undoStack.top -> top[];
     if);
  exit top[]
  #);

saveGraphicalEditor:
  (# 
  do undoTop -> private.lastSaveOperation[];
     theDocument.save;
  #);
graphicalEditorDirty: booleanValue
  (# 
  do (if undoTop <> private.lastSaveOperation[] then
         true -> value;
      else
         false -> value;
     if);
  #);

graphicalEditorMenu: menu
  (# graphicalEditorItem: menuItem
       (# eventHandler::<
            (# onStatus::<
                 (# 
                 do (if readOnly then
                        false -> value;
                     else
                        inner;
                    if);
                 #);
            #);
          open::<
            (# 
            do inner;
               this(graphicalEditorItem)[] -> append;
            #);
       #);
     
     addSeparator:
       (# aSeparator: ^separator;
       do &separator[] -> aSeparator[];
          aSeparator.open;
          aSeparator[] -> append;
       #);
  #);
(*
 * container types
 *)

rectangleList: sequence
  (# element:: rectangle;
  #);

stack: sequence
  (# 
     push:
       (# doAppend: @append;
       enter doAppend
       #);
     pop:
       (# doDeleteLast: @deleteLast;
       exit doDeleteLast
       #);
     top:
       (# doLast: @last;
       exit doLast
       #);
  #);


(*
 * Clipboard
 *)

clipBoard:
  (# init:
       (# 
       do getScrap -> this(clipBoard).theScrap[];
       #);
     
     theScrap: ^scrap;
     
     copyToScrap:
       (# theSelection: ^windowItemEditorList;
       enter theSelection[]
       do theScrap.clear;
          theSelection.scan
          (# scrapElm: ^scrap.element;
             frag: ^astInterface.fragmentForm;
          do &theScrap.element[] -> scrapElm[];
             current.createShadowTree  -> scrapElm.tree[];
             current.node.frag[] -> frag[];
             frag[] -> current.node.copy -> scrapElm.node[];
             scrapElm[] -> theScrap.append;
          #);
       #);
     
     createEditor:
       (# node: ^astInterface.beta.attributeDecl;
          owner: ^canvasEditor;
          tree: ^shadowTree;
          editor: ^windowItemEditor;
          data: ^parameters;
          type: @integer;
          top: @boolean;
       enter (node[], owner[], tree[], top)
       do tree.data.type -> type;
          (type, false) -> makeEditor -> editor[];
          owner[] -> editor.owner[];
          type -> theDocument.theParameterStore.new -> data[];
          tree.data[] -> data.set;
          node[] -> editor.node[];
          data[] -> editor.data[];
          
          tree.defaultData[] -> editor.defaultData[];
          tree.theClassData[] -> editor.theClassData[];
          tree.inherited -> editor.inherited;
          (if top then
              (node[], (type, data.id) -> freshName) -> betaGram.setName;
           else
              editor[] -> owner.children.append;
          if);
          tree.children.scan
          (# subNode: ^astInterface.beta.attributeDecl;
          do (if current.inherited then
                 current.node[] -> subNode[];
              else
                 (node[], current.name[]) -> betaGram.findAttribute -> subNode[];
             if);
             (subNode[], editor[], current[], false) -> &createEditor;
          #);
       exit editor[]
       #);
     
     makePasteOperation: makeOperation
       (# operationType:: pasteOperation;
          theSelection: ^windowitemEditorList;
           theAttributes: ^astInterface.beta.attributes;
       do &windowitemEditorList[] -> theSelection[];
          (contentsEditor).getMainAttributes -> theAttributes[];
          theScrap.scan
          (# node: ^astInterface.beta.attributeDecl;
          do theAttributes.frag[] -> current.node.copy -> node[];
             (node[], contentsEditor, current.tree[], true) -> createEditor -> theSelection.append;
          #);
          theSelection[] -> theOperation.init;
       #);
  #);


(*
 * Generating names
 *)

getClassName:
  (# type: @integer;
     name: ^text;
  enter type
  do private.names[type][] -> name[];
  exit name[]
  #);
freshName:
  (# type: @integer;
     id: @integer;
     name: ^text;
  enter (type, id)
  do type -> uniqueName -> name[];
  exit name[]
  #);
uniqueName:
  (# type: @integer;
     name: ^text;
  enter type
  do (type -> getClassName).copy -> name[];
     private.uniqueID + 1 -> private.uniqueID;
     private.uniqueID -> name.putInt;
  exit name[]
  #);

(*
 * Default sizes
 *)

getDefaultSize:
  (# width, height: @integer;
     type: @integer;
  enter type
  do private.sizes[type] -> (width, height);
  exit (width, height)
  #);

(*
 * Classes for supporting undo 
 *)

clearRedoStack:
  (# 
  do private.redoStack.clear;
  #);
pushUndoStack:
  (# theOperation: ^operation;
  enter theOperation[]
  do theOperation[] -> private.undoStack.push;
  #);

operation:
  (# command:
       (# 
       do inner;
          theDocument.autoSave;
       #);
     
     doIt:<
       command;
     unDoIt:<
       command;
     init:<
       (# 
       do 
          inner;
          clearRedoStack;
          this(operation)[] -> pushUndoStack;
          theDocument.autoSave;
       #);
     name:<
       (# value: ^text;
       do inner;
       exit value[]
       #);
  #);

makeOperation:
  (# operationType:< operation;
     theOperation: ^operationType;
  do &operationType[] -> theOperation[];
     inner;
  #);

singleOperation: operation
  (# 
     theEditor: ^windowItemEditor;
     init::<
       (# 
       enter theEditor[]
       do inner;
       #);
  #);

resizeOperation: singleOperation
  (# oldFrame, newFrame: ^rectangle;
     
     init::
       (# 
       enter newFrame[]
       do theEditor.frame -> oldFrame[];
          newFrame[] -> theEditor.frame;
          (* theEditor.fixOpen; *)
          newFrame.size -> theEditor.changeSize;
       #);
     doIt::
       (# 
       do newFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          newFrame.size -> theEditor.changeSize;
       #);
     unDoIt::
       (# 
       do oldFrame[] -> theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          oldFrame.size -> theEditor.changeSize;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);

makeSingleOperation: makeOperation
  (# operationType::< singleOperation;
     theEditor: ^windowItemEditor;
  enter theEditor[]
  do inner;
  #);
makeResizeOperation: makeSingleOperation
  (# operationType:: resizeOperation;
     newFrame: ^rectangle;
  enter newFrame[]
  do (theEditor[], newFrame[]) -> theOperation.init;
  #);

selectionOperation: operation
  (# theSelection: ^windowItemEditorList;
     setSelection: command
       (# 
       do selection.clear;
          inner;
          theSelection[] -> selection.set;
       #);
     init::<
       (# 
       enter theSelection[]
       do inner;
       #);
  #);
moveOperation: selectionOperation
  (# dh, dv: @integer;
     init::<
       (# 
       enter (dh, dv)
       do doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do true -> dontHandleFrameChanged;
             (dh, dv) -> current.theWindowItem.move;
             false -> dontHandleFrameChanged;
             current.theWindowItem.position -> current.changePosition;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do true -> dontHandleFrameChanged;
             (-dh, -dv) -> current.theWindowItem.move;
             false -> dontHandleFrameChanged;
             current.theWindowItem.position -> current.changePosition;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeOwnerOperation: selectionOperation
  (# dh, dv: @integer;
     newOwner, oldOwner: ^canvasEditor;
     init::
       (# 
       enter (newOwner[], dh, dv)
       do (theSelection.first).owner[] -> oldOwner[];
          doIt;
          inner;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h + dh, v + dv) -> current.data.position;
             (h + dh, v + dv) -> current.changePosition;
             newOwner[] -> current.changeOwner;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# h, v: @integer;
          do current.data.position -> (h, v);
             (h - dh, v - dv) -> current.data.position;
             (h - dh, v - dv) -> current.changePosition;
             oldOwner[] -> current.changeOwner;
          #);
       #);
     name::<
       (# 
       do 'Move' -> value[];
          inner;
       #);
  #);
changeBoundsOperation: selectionOperation
  (# newBounds, oldBounds: ^rectangleList;
     init::
       (# 
       enter newBounds[]
       do &rectangleList[] -> oldBounds[];
          oldBounds.init;
          theSelection.scan
          (#
          do current.frame -> oldBounds.append;
          #);
          doIt;
       #);
     doIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# b: ^rectangle;
          do inx -> newBounds.get -> b[] -> current.frame;
             inx + 1 -> inx;
             b.topLeft -> current.changePosition;
             b.size -> current.changeSize;
          #);
       #);
     unDoIt:: setSelection
       (# inx: @integer;
       do 1 -> inx;
          theSelection.scan
          (# b: ^rectangle;
          do inx -> oldBounds.get -> b[] -> current.frame;
             inx + 1 -> inx;
             b.topLeft -> current.changePosition;
             b.size -> current.changeSize;
          #);
       #);
  #);

alignOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Alignment' -> value[];
          inner;
       #);
  #);
fitToContentsOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Fit to contents' -> value[];
          inner;
       #);
  #);
spacingOperation: changeBoundsOperation
  (# name::<
       (# 
       do 'Spacing' -> value[];
          inner;
       #);
  #);

createOperation: operation
  (# bounds: ^rectangle;
     owner: ^canvasEditor;
     type: @integer;
     theEditor: ^windowItemEditor;
     theClassData: ^classData;
     init::
       (# 
       enter (owner[], type, bounds[], theClassData[])
       do selection.clear;
          (type, theClassData[]) -> owner.newEditor -> theEditor[];
          bounds.topLeft -> theEditor.theWindowitem.position;
          bounds.topLeft -> theEditor.changePosition;
       #);
     doIt::
       (# 
       do selection.clear;
          theEditor.reInsert;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          theEditor.delete;
       #);
     name::<
       (# 
       do 'New' -> value[];
       #);
  #);

deleteOperation: selectionOperation
  (# 
     init::
       (# 
       do doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
     unDoIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     name::<
       (# 
       do inner;
          (if value[] = none then
              'Delete' -> value[];
          if);
       #);
  #);
cutOperation: deleteOperation
  (# name::<
       (# 
       do 'Cut' -> value[];
       #);
  #);
pasteOperation: selectionOperation
  (# name::<
       (# 
       do 'Paste' -> value[];
       #);
     init::
       (# 
       do doIt;
       #);
     doIt:: setSelection
       (# 
       do theSelection.scan
          (# 
          do current.reInsert;
          #);
       #);
     unDoIt::
       (# 
       do selection.clear;
          theSelection.scan
          (# 
          do current.delete;
          #);
       #);
  #);
dialogOperation: singleOperation
  (# oldData, newData: ^parameters;
     init::
       (# 
       enter newData[]
       do theEditor.data.copy -> oldData[];
          doIt;
       #);
     doIt::
       (# 
       do selection.clear;
          (newData[], false) -> theEditor.changeData;
          newData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     unDoIt::
       (# 
       do selection.clear;
          (oldData[], false)  -> theEditor.changeData;
          oldData[] -> theEditor.data.set;
          theEditor.applyObjectData;
          theEditor.select;
       #);
     name::<
       (# 
       do 
          'Dialog' -> value[];
       #);
  #);
makeDialogOperation: makeSingleOperation
  (# operationType:: dialogOperation;
     data: ^parameters;
  enter data[]
  do (theEditor[], data[]) -> theOperation.init;
  #);
changeWindowSizeOperation: operation
  (# width, height: @integer;
     oldWidth, oldHeight: @integer;
     init::
       (# 
       enter (width, height)
       do (contentsEditor).theWindowItem.size -> (oldWidth, oldHeight);
          doIt;
       #);
     doIt::
       (# 
       do (width, height) -> (contentsEditor).theWindowItem.size;
       #);
     unDoIt::
       (# 
       do (oldWidth, oldHeight) -> (contentsEditor).theWindowItem.size;
       #);
     name::<
       (# 
       do 'Resize' -> value[];
          inner;
       #);
  #);
makeChangeWindowSizeOperation: makeOperation
  (# operationType::< changeWindowSizeOperation;
     width, height: @integer;
  enter (width, height)
  do (width, height) -> theOperation.init;
  #);
(* End of undo *)


(* 
 * drag and drop  
 *)

changeHierarkiDragger: private.theDragManager.changeHierarkiDragger
  (# 
  #);

createDragger: private.theDragManager.createDragger
  (# 
  #);
  

reciever: private.theDragManager.reciever
  (# 
  #);

(* end *)



initialize:
  (# width, height: @integer;
  enter (width, height)
  do 
     (* (contents, width, height) -> private.windowView.open;
      *      private.windowView.bringBack;
      *      private.contentsEditorObject[] -> private.contentsEditor.theWindowItem[];
      *      (private.viewPaletteRight + 5, 
      *       (private.viewPaletteBottom + 5, private.windowViewBottom + 5) -> max) -> size;
      *)
  #);

generateEditor:
  (# we: ^windowItemEditor;
  do inner;
  exit we[]
  #);

contentsEditor:
  (# 
  exit private.contentsEditor[]
  #);



translateRect:
  (# r: ^rectangle;
     from, to: ^windowItem;
  enter (r[], from[], to[])
  do (r.topLeft,from[], to[]) -> translate -> r.topLeft;
     (r.bottomRight, from[], to[]) -> translate -> r.bottomRight;
  #);



(*
 * Handling of private attributes
 *)


findBody:
  (# failure:< object;
     body: ^astInterface.fragmentGroup;
  do (# group: ^astInterface.fragmentGroup;
        fullPath: ^text;
     do node.frag.father -> group[];
        (if group[] <> none then
            search: group.scanBodyGroups
              (# 
              do 
                 currentFullPath[] -> fullPath[];
                 leave search;
              #);
            (if fullPath[] <> none then
                fullPath[] -> MPS.safeOpen -> body[];
                (if body[] = none then
                    failure;
                if);
             else
                failure;
            if);
         else
            failure;
        if);
     #);
  exit body[]
  #);

createPrivateAttributes:
  (# failure:< object;
     group: ^astInterface.fragmentGroup;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theReferenceSpecification: ^astInterface.beta.ReferenceSpecification;
     theStaticItem: ^astInterface.beta.staticItem;
     theUnExpanded: ^astInterface.unExpanded;
     theSlotDesc: ^astInterface.slotDesc;
     frag: ^astInterface.fragmentForm;
     theDescriptorForm: ^astInterface.beta.descriptorForm;
     theObjectDescriptor: ^astInterface.beta.objectDescriptor;
     theMainPart: ^astInterface.beta.mainPart;
     name: ^text;
     privateFrag, theFragment: ^astInterface.fragmentForm;
  do defaultBodyGroup -> group[];
     (if group[]<>None then
         node.frag[] -> frag[];
         (betaGram.simpleDecl, frag[]) -> betaGram.newAst -> theSimpleDecl[];
         (frag[], 'private') -> betaGram.newNames -> theSimpleDecl.putNames;
         (betaGram.staticItem, frag[]) 
           -> betaGram.newAst -> theStaticItem[] 
           -> theSimpleDecl.putReferenceSpecification;
         (betaGram.objectDescriptor, frag[]) 
           -> betaGram.newUnExpanded  -> theUnExpanded[]
           -> theStaticItem.putObjectSpecification;
         frag[] -> betaGram.newSlot -> theSlotDesc[] -> theUnExpanded.theSlot;
         node[] -> betaGram.getName -> name[];
         'Private' -> name.append;
         name[] -> theSlotDesc.name;
         (node[], theSimpleDecl[]) -> betaGram.appendAttribute;
         betaGram[] -> MPS.newFragmentForm -> privateFrag[];
         name[] -> privateFrag.name;
         name[] -> group.findFragment -> theFragment[];
         (if theFragment[] <> none then
             theFragment[] -> group.deleteFragment;
         if);
         privateFrag[] -> group.fragmentList.addFragment;
         (privateFrag[], none) 
           -> betaGram.newDescriptorForm -> theDescriptorForm[]
           -> privateFrag.root[];
         privateFrag[] -> private.privateFragHandler.frag[];
         private.privateFragHandler[] -> theFragServer.subscribe;
     else
         failure;
     if);
  exit privateFrag[]
  #);

-- canvasEditorLib: attributes --

updateOpen: codeGuard
  (# oldName, newName: ^text;
     
  enter (oldName[], newName[])
  do (# oldStmProto: ^astInterface.beta.imp;
        oldStm: ^astInterface.beta.imp;
        newStm: ^astInterface.beta.imp;
        frag: ^astInterface.fragmentForm;
        txt: @text;
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        gram: @grammar;
     do 
        forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] <> none then
            makeFragmentForm -> frag[];
            oldName[] -> txt.append;
            '.open' -> txt.append;
            (frag[], txt[], gram.imp) -> parseText -> oldStmProto[];
            txt.clear;
            newName[] -> txt.append;
            '.open' -> txt.append;
            theDoPart.getImperatives -> theImperatives[];
            (theImperatives.frag[], txt[], gram.imp) -> parseText -> newStm[];
            (mps[], theImperatives[], oldStmProto[]) -> listSearch -> oldStm[];
            (if oldStm[] <> none then
                (oldStm.sonNo, newStm[]) -> theImperatives.put;
                (true, theImperatives.frag[], oldStm[], newStm[])
                  -> theFragServer.notifyAstReplaced;
            if);
        if);
     #);
  #);


appendChild: codeGuard
  (# editor: ^windowItemEditor;
     
  enter editor[]
  do (# theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        imp: ^astInterface.beta.imp;
        insertInx: @integer;
     do
        editor[] -> children.append;
        forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] <> none then
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# 
              do current.sonNo -> insertInx;
                 (if current.symbol = betaGram.innerImp then
                     leave l;
                 if);
              #);
            theImperatives.frag[] -> editor.generateOpenImp -> imp[];
            (insertInx, imp[]) -> theImperatives.insert;
            (true, theImperatives.frag[], theImperatives[], insertInx)
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);

(* 
 * Drag and drop support
 *)

recieverType: reciever
  (* Should be a singular object, but a reciever can 
   * not be reused.
   *)
  (# savedStyle: @integer;
     onHilite::
       (# 
       do theWindowItem.border.style -> savedStyle;
          (if savedStyle
           //borderstyles.shadowIn then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.shadowOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedOut then
              borderstyles.etchedIn -> theWindowItem.border.style;
           //borderstyles.etchedIn then
              borderstyles.etchedOut -> theWindowItem.border.style;
          if);
       #);
     onLowLite::
       (# 
       do savedStyle -> theWindowItem.border.style;
       #);
     
     recieve::
       (# 
       do (this(canvasEditor)[], frame[]) -> theDragger.moveTo;
       #);
  #);

createTheReciever:
  (# 
  do (if private.theReciever[] <> none then
         private.theReciever.delete;
     if);
     &recieverType[] -> private.theReciever[];
     theWindowItem[] -> private.theReciever.init;
  #);
(* End of drag and drop support *)

(*
 * Locking
 *)


locked:
  (# 
  enter private.locked
  exit private.locked
  #);

(* End of locking *)


(*
 * Code
 *)

getMainFrag:
  (# theAttributes: ^astInterface.beta.attributes;
     frag: ^astInterface.fragmentForm;
  do getMainAttributes -> theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.frag[] -> frag[];
     if);
  exit frag[]
  #);



appendAttribute:
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter theAttribute[]
  do 
     getMainAttributes -> theAttributes[];
     (if theAttributes[] = none then
         failure;
      else
         (theAttributes[], theAttribute[]) -> appendToAttributes;
     if);
  #);

scanAttributes:
  (# current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
  do 
     getMainAttributes -> theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.iterate
         (# 
         do current[] -> this(scanAttributes).current[];
            inner scanAttributes;
         #);
         
     if);
  #);
-- selectionLib: attributes --

editName:
  (# 
  do selection.scan
     (# 
     do current.editName;
     #);
  #);

editScripts:
  (# 
  do selection.scan
     (# 
     do current.editScripts;
     #);
  #);

openSubEditor:
  (# 
  do selection.scan
     (# 
     do current.openSubEditor;
     #);
  #);

isEditMenuPossible: booleanValue
  (# 
  do true -> value;
     scan
     (# 
     do (if current[] = contentsEditor then
            false -> value;
        if);
     #);
  #);

isAncestor: booleanValue
  (# ancestor, child: ^windowItemEditor;
  enter (ancestor[], child[])
  do (if child[] = NONE then
         false -> value;
      else
         (if ancestor[] = child[] then
             true -> value;
          else
             (ancestor[], child.owner[]) -> isAncestor -> value;
         if);
     if);
  #);

moveAllowed: booleanValue
  (# theCanvasEditor: ^canvasEditor;
  enter theCanvasEditor[]
  do true -> value;
     l: 
       (# 
       do scan
          (# 
          do (if current.owner[] = theCanvasEditor[] then
                 false -> value;
                 leave l;
              else
                 (if (current[], theCanvasEditor[]) -> isAncestor then
                     false -> value;
                     leave l;
                 if);
             if);
          #);
       #);
     
  #);

makeSelectionOperation: makeOperation
  (# operationType::< selectionOperation;
     theSelection: ^windowItemEditorList;
  do copy -> theSelection[];
     inner;
  #);
makeMoveOperation: makeSelectionOperation
  (# operationType:: moveOperation;
     dh, dv: @integer;
  enter (dh, dv)
  do (theSelection[], dh, dv) -> theOperation.init;
  #);
makeChangeOwnerOperation: makeSelectionOperation
  (# operationType:: changeOwnerOperation;
     dh, dv: @integer;
     newOwner: ^canvasEditor;
  enter (newOwner[], dh, dv)
  do (theSelection[], newOwner[], dh, dv) -> theOperation.init;
  #);
makeDeleteOperation: makeSelectionOperation
  (# operationType::< deleteOperation;
  do theSelection[] -> theOperation.init;
  #);
makeCutOperation: makeDeleteOperation
  (# operationType:: cutOperation
  #);

makeChangeBoundsOperation: makeSelectionOperation
  (# operationType::< changeBoundsOperation;
     newBounds: ^rectangleList;
  do &rectangleList[] -> newBounds[];
     newBounds.init;
     inner;
     (theSelection[], newBounds[]) -> theOperation.init;
  #);
makeAlignOperation: makeChangeBoundsOperation
  (# operationType:: alignOperation;
     modelFrame: ^rectangle;
     currentFrame: ^rectangle;
     first: @boolean;
  do true -> first;
     scan
     (# 
     do (if first then
            current.frame -> modelFrame[];
            modelFrame[] -> newBounds.append;
            false -> first;
         else
            current.frame -> currentFrame[];
            inner makeAlignOperation;
            currentFrame[] -> newBounds.append;
        if);
     #);
  #);
makeFitToContentsOperation: makeChangeBoundsOperation
  (# operationType:: fitToContentsOperation;
  do scan
     (# r: ^rectangle;
     do 
        current.frame -> r[];
        current.theWindowItem.preferredSize -> r.size;
        r[] -> newBounds.append;
     #);
  #);

  
bounds:
  (# theBounds: ^rectangle;
  do &rectangle[] ->  theBounds[];
     minInt -> theBounds.right -> theBounds.bottom;
     maxInt -> theBounds.left -> theBounds.top;
     scan
     (# r: ^rectangle;
     do current.frame -> r[];
        (r.left, theBounds.left) -> Min -> theBounds.left;
        (r.top, theBounds.top) -> Min -> theBounds.top;
        (r.right, theBounds.right) -> Max -> theBounds.right;
        (r.bottom, theBounds.bottom) -> Max -> theBounds.bottom;
     #);
  exit theBounds[]
  #);

interactiveChangeHierarki:
  (# theDragger: @changeHierarkiDragger;
     event: ^windowItem.eventHandler.mouseDown;
  enter event[]
  do theDragger.init;
     (first).owner.theWindowItem[] -> theDragger.item[];
     bounds -> theDragger.bounds[];
     (event[], (first).theWindowItem[]) -> theDragger.drag
     (# 
        frame::
          (# 
          do &rectangle[] -> value[];
             theDragger.bounds -> value;
          #);
     #);
  #);

drag:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
  enter theEvent[]
  do (# oldBounds, newBounds: ^rectangle;
        dh, dv: @integer;
     do 
        bounds -> oldBounds[];
        (oldBounds[], (first).theWindowItem.father[], contents)
          -> translateRect;
        &rectangle[] -> newBounds[];
        (oldBounds, true, true, true, true) 
          -> (contents).defineRect -> newBounds;
        newBounds.left - oldBounds.left -> dh;
        newBounds.top - oldBounds.top -> dv;
        (dh, dv) -> makeMoveOperation;
     #);
  #);

stopAnts: 
  (# 
  do this(graphicalEditorEnv).private.theWalkingAnts.fullStop;
  #);
startAnts: scan
  (# 
  do current.startWalkingAnts;
  #);

removeControlPoints:
  (# 
  do scan (# do current.removeControlPoints #);
  #);
showControlPoints:
  (# t: @timer
       (# action::
            (# 
            do pause;
               scan (# do current.showControlPoints #); 
            #);
       #);
  do 1 -> t.activate;
  #);

selectable: booleanValue
  (# theEditor: ^windowItemEditor;
  enter theEditor[]
  do (if empty then
         true -> value;
      else
         (theEditor.owner[] = (first).owner[]) -> value;
     if);
  #);

array: sequence
  (# element::< windowItem;
     
     sortHorizontal: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.h < rightpos.h -> value;
            #);
       #);
     sortVertical: sort
       (# less::<
            (# leftpos,rightpos: @point;
            do left.position -> leftpos;
               right.position -> rightpos;
               leftpos.v < rightpos.v -> value;
            #)
       #);
     
     top: @Integer;
  #);


sort:
  (# sortedarray: ^array;
  do &array[] -> sortedarray[];
     sortedarray.init;
     scan
     (#
     do current.theWindowitem[] -> sortedarray.append;
     #);
     inner;
  exit sortedarray[]
  #);
sorthorizontal: sort
  (# 
  do sortedarray.sortHorizontal;
  #);
sortvertical: sort
  (# 
  do sortedarray.sortVertical;
  #);

alignspacing:
  (# values: ^spacingValues;
     sorted: ^Array;
  enter values[]
  do (*  stopAnts; *)
     (if (values.doWidth OR values.doHeight)//true then
         scan
         (# width, height: @integer;
         do current.theWindowItem.Size -> (width, height);
            (if values.doWidth//true then values.width -> width; if);
            (if values.doHeight//true then values.height -> height; if);
            (width, height) -> current.theWindowItem.Size;
         #);
     if);
     (if values.doVerticalDist then
         SortVertical -> sorted[];
         sorted.Scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Bottom + values.verticalDist -> curPos.v;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     (if values.doHorizontalDist then
         SortHorizontal -> sorted[];
         sorted.scan
         (# prevFrame: @rectangle;
            curPos: @Point;
            Previous: ^WindowItem;
         do (if Previous[]//None then
             else
                current.Position -> curPos;
                Previous.Frame -> prevFrame;
                prevFrame.Right + values.horizontalDist -> curPos.h;
                curPos -> current.Position;
            if);
            current[] -> Previous[];
         #);
     if);
     theDocument.autoSave;
     (* startAnts; *)
  #);


-- windowItemEditorLib: attributes --

northEast: (# exit 1 #);
northWest: (# exit 2 #);
southEast: (# exit 3 #);
southWest: (# exit 4 #);

controlPoint: windowItem
  (# corner: @integer;
     
     init:
       (# 
       enter corner
       do assertWindowItem
          (# location:: (# do 'controlPoint.init' -> value[] #);
          do this(window).contents -> open;
             show;
          #);
       #);
     
     open::
       (# r: @rectangle;
          p: @point;
       do hide;
          black -> backgroundColor;
          theWindowItem.frame -> r;
          (if corner
           //northEast then
              (r.right, r.top) -> p;
           //northWest then
              (r.left, r.top) -> p;
           //southEast then
              (r.right, r.bottom) -> p;
           //southWest then
              (r.left, r.bottom) -> p;
           else
              exception
              (# 
              do '"corner" is impossible' -> msg.append;
              #);
          if);
          (p, theWindowItem.father[], this(window).contents) -> translate -> p;
          (p, p) -> r;
          (-3, -3) -> r.inset;
          r -> frame;
       #);
     eventHandler::
       (# onMouseDown::
            (# 
            do (if corner
                //northEast then
                   (false, true, true, false) -> reConfigure;
                //northWest then
                   (true, true, false, false) -> reConfigure;
                //southEast then
                   (false, false, true, true) -> reConfigure;
                //southWest then
                   (true, false, false, true) -> reConfigure;
               if);
            #);
       #);
  #);


reConfigure:
  (# doLeft,doTop,doRight,doBottom: @boolean;
     bounds: ^rectangle;
     newOwner: ^canvasEditor;
  enter (doLeft,doTop,doRight,doBottom)
  do 
     frame -> bounds[];
     (bounds[],  theWindowItem.father[], contents) 
       -> translateRect;
     (bounds,doLeft,doTop,doRight,doBottom) -> (contents).defineRect -> bounds;
     (bounds.topLeft, contents, theWindowItem.father[]) 
       -> translate -> bounds.topLeft;
     (bounds.bottomRight, contents, theWindowItem.father[]) 
       -> translate -> bounds.bottomRight;
     (this(windowItemEditor)[], bounds[]) -> makeResizeOperation;
  #);

assertWindowItem:
  (# error:< exception
       (# 
       do '"theWindowItem" is NONE in "' -> msg.putText;
          location -> msg.putText;
          '"' -> msg.putLine;
          INNER;
       #);
     location:<
       (# value: ^text;
       do INNER;
       exit value[]
       #);
  do (if theWindowItem[] <> NONE then
         INNER;
      else
         error;
     if);
  #);


showControlPoints:
  (#
     t: @timer
       (# action::
            (# addControlPoint:
                 (# corner: @integer;
                    cp: ^controlPoint;
                 enter corner
                 do &controlPoint[] -> cp[];
                    corner -> cp.init;
                    cp[] -> this(windowItemEditor).private.controlPoints.append;
                 #);
            do pause;
               northEast -> addControlPoint;
               northWest -> addControlPoint;
               southEast -> addControlPoint;
               southWest -> addControlPoint;
            #);
       #);
     
  do 1 -> t.activate;
  #);
removeControlPoints:
  (# 
  do private.controlpoints.scan
     (# 
     do current.close;
     #);
     private.controlpoints.clear;
  #);

findEnclosing:
  (# current: ^windowItemEditor;
     
  do this(windowItemEditor)[] -> current[];
     l: (if current.inherited then
            current.owner[] -> current[];
            restart l;
        if);
  exit current[]
  #);

makeDelegateMousedownAction:
  (# aWindowItem: ^windowItem;
     enclosing: ^canvasEditor;
  enter aWindowItem[]
  do findEnclosing -> enclosing[];
     &aWindowItem.mousedownAction
     (# p: @point;
     do theEvent.localPosition -> p;
        (p, aWindowItem[], enclosing.theWindowItem[]) -> translate -> p;
        (theEvent[], p) -> enclosing.mouseDown;
     #)[] -> aWindowitem.appendAction;
  #);



editName:
  (# oldName, newName: ^text;
     isIdentifier: @boolean;
     isEqual: @boolean;
     theNameDialog: @nameDialog
       (# open::
            (# 
            do 'Edit Name' -> title;
               oldName[] -> name;
               hide;
            #);
          onOk::
            (# 
            do name -> newName[];
               newName[] -> checkIdentifier -> isIdentifier;
               (if isIdentifier then
                   newName[] -> oldName.equalNCS -> isEqual;
                   (if not isEqual then
                       (# theNames: ^astInterface.beta.names;
                          theNameDcl: ^astInterface.beta.nameDcl;
                          theNameDecl: ^astInterface.nameDecl;
                          oldNameDcl: ^astInterface.beta.nameDcl;
                       do node[] -> betaGram.getNames -> theNames[];
                          (if theNames[] <> none then
                              1 -> theNames.get -> oldNameDcl[];
                              (theNames.frag[], newName[]) -> betaGram.newNameDcl -> theNameDcl[];
                              (1, theNameDcl[]) -> theNames.put;
                              (true, theNames.frag[], oldNameDcl[], theNameDcl[])
                                -> theFragServer.notifyAstReplaced;
                          if);
                       #);
                       (if owner[] <> none then
                           (if isPrivateToOwner then
                               'private.' -> oldName.prepend;
                               'private.' -> newName.prepend;
                           if);
                           (oldName[], newName[]) -> owner.updateOpen;
                       if);
                   if);
                   theDocument.autosave;
                   close;
                else
                   newName[] -> putText;
                   ' is not a legal name' -> putLine;
               if);
            #);
          onCancel::
            (# 
            do close;
            #);
       #);
  do node[] -> betaGram.getName -> oldName[];
     theNameDialog.open;
     theNameDialog.showModal;
  #);
editScripts:
  (# theScriptDialog: @scriptDialog
       (# open::
            (# 
            do 'Edit virtuals' -> title;
               theNames[] -> names;
            #);
          onEdit::
            (# name: ^text;
            do currentName -> name[];
               (if name[] <> NONE then
                   name[] -> editVirtual;
               if);
               close;
            #);
          onCancel::
            (# 
            do close;
            #);
       #);
     theNames: @textList;
      
  do theNames.init;
     (if theClassData[] <> none then
          (if theClassData.theClass[] <> none then
              theClassData.theClass.methods.scan
              (# 
              do current.name[] -> theNames.append;
              #);
          if);
      if);
     theScriptDialog.open;
     theScriptDialog.showModal;
  #);
openSubEditor:
  (# 
  do editAttributes;
  #);

addOpen:
  (# node: ^astInterface.beta.attributeDecl;
  enter node[]
  do (# openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theDoPart: ^astInterface.beta.doPart;
        theAttributes: ^astInterface.beta.attributes;
        gram: @grammar;
        
     do (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] = NONE then
            (if privateFrag[] <> none then
                (node.frag[],'open::< (# <<SLOT name: doPart>> #)', gram.attributeDecl) -> parseText -> openDecl[];
             else
                (node.frag[],'open::< (# do #)', gram.attributeDecl) -> parseText -> openDecl[];
            if);
            node[] -> betaGram.getAttributes -> theAttributes[];
            openDecl[] -> theAttributes.append;
         else
            (if openDecl.symbol
             //betaGram.bindingDecl
             //betaGram.finalDecl then
                node[] -> betaGram.getObjectDescriptor -> check -> theObjectDescriptor[];
                (if theObjectDescriptor[] <> none then
                    theObjectDescriptor.getMainPart -> check -> theMainPart[];
                    (if theMainPart[] <> none then
                        theMainPart.getActionPart -> check -> theActionPart[];
                        (if theActionPart[] <> none then
                            theActionPart.getDoPartOpt -> check -> theDoPart[];
                            (if theDoPart[] <> NONE then
                                
                             else
                                (if privateFrag[] <> NONE then
                                    (node.frag[], '<<SLOT name: doPart>>', gram.doPart) -> parseText -> theActionPart.putDoPartOpt;
                                 else
                                    (node.frag[], 'do', gram.doPart) -> parseText -> theActionPart.putDoPartOpt;
                                if);
                               
                            if);
                         else
                            (if privateFrag[] <> NONE then
                                (node.frag[], '<<SLOT name: doPart>>', gram.actionPart) -> parseText -> theMainPart.putActionPart;
                             else
                                (node.frag[], 'do', gram.actionPart) -> parseText -> theMainPart.putActionPart;
                            if);
                        if);
                     else
                        (if privateFrag[] <> NONE then
                            (node.frag[], '(# <<SLOT name: doPart>>  #)', gram.mainPart) -> parsetext -> theObjectDescriptor.putMainPart;
                         else
                            (node.frag[], '(# do #)', gram.mainPart) -> parsetext -> theObjectDescriptor.putMainPart;
                        if);
                    if);
                if);
             else
                NONE -> openDecl[];
            if);
        if);
        (if theDoPart[] = NONE then
            (if openDecl[] <> none then
                (if privateFrag[] <> NONE then
                    mps.unExpanded -> openDecl.suffixWalkForProd
                    (# theSlotDesc: ^mps.slotDesc;
                       doPartFrag, frag: ^astInterface.fragmentForm;
                       group: ^astInterface.fragmentGroup;
                       slotName: ^text;
                       theUnExp: ^astInterface.unExpanded;
                    do current[] -> theUnExp[];
                       (if theUnExp.isSlot then
                           theUnExp.theSlot -> theSlotDesc[];
                           node[] -> betaGram.getName -> slotName[];
                           'Open' -> slotName.append;
                           slotName[] -> theSlotDesc.name;
                           slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
                           privateFrag.father ->  group[];
                           slotName[] -> group.findFragment -> frag[];
                           (if frag[] <> none then
                               frag.root[] -> theDoPart[];
                            else
                               doPartFrag[] -> group.fragmentList.addFragment;
                               doPartFrag.root[] -> theDoPart[];
                           if);
                       if);
                    #);
                 else
                    gram.doPart -> openDecl.suffixWalkForProd
                    (# 
                    do current[] -> theDoPart[];
                    #);
                if);
                (if theDoPart[] <> none then
                    (if node.symbol = betaGram.patternDecl then
                        (# innerImp: ^astInterface.beta.imp;
                           theImperatives: ^astInterface.beta.imperatives;
                        do (theDoPart.frag[], 'INNER', gram.imp) -> parseText -> innerImp[];
                           theDoPart.getImperatives -> theImperatives[];
                           (1, innerImp[]) -> theImperatives.put;
                        #);
                    if);
                if);
            if);
        if);
     #);
  #);
realCreateOpen:
  (# 
  do node[] -> addOpen;
  #);



skip:
  (# 
  enter private.skip
  exit private.skip
  #);
codeGuard:
  (# 
  do (if inherited OR private.initializing then
      else
         INNER;
     if);
  #);

deleteImperative: codeGuard
  (# name: ^text;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.AST;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.imp;
     theImperatives: ^astInterface.beta.imperatives;
     oldElements: ^astInterface.astList;
     deleteInx: @integer;
  enter name[]
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> ' -> txt.append;
         name[] -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
         (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             &mps.astList[] -> oldElements[];
             oldElements.init;
             imp.sonNo -> deleteInx;
             imp[] -> oldElements.insert;
             deleteInx -> theImperatives.delete;
             (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
               -> theFragserver.notifyListElementsDeleted;
         if);
     if);
  #);

generateEvaluation:
  (# value: ^atom;
     frag: ^astInterface.fragmentForm;
     eval: ^astInterface.beta.evaluation;
     gram: @grammar;
  enter (frag[], value[])
  do (if value[] = NONE then
         (frag[], 'NONE', gram.imp) -> parseText -> eval[];
     if);
     (if value.type
      //textType then
         (if (value.asTextAtom).value[] = none then
             (frag[], 'NONE', gram.imp) -> parseText -> eval[];
          else
             (frag[],(value.asTextAtom).value[])
               -> betaGram.newTextEvaluation -> eval[];
         if);
      //boolType then
         (frag[],(value.asBoolAtom).value)
           -> betaGram.newBoolEvaluation -> eval[];
      //intType then
         (frag[],(value.asIntAtom).value)
           -> betaGram.newIntEvaluation -> eval[];
     if);
  exit eval[]
  #);

changeImperative: codeGuard
  (# name: ^text;
     value: ^atom;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldEval, newEval: ^astInterface.beta.evaluation;
  enter (name[], value[])
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> ' -> txt.append;
         name[] -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
         (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (theDoPart.frag[], value[]) -> generateEvaluation  -> newEval[];
         (if imp[] <> none then
             imp.getEvaluation -> oldEval[];
             newEval[] -> imp.putEvaluation;
             (true, imp.frag[], oldEval[], newEval[])
               -> theFragServer.notifyAstReplaced;
          else
             (theDoPart.frag[], value[]) -> generateEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
             (true, theImperatives.frag[], theImperatives[], 1) 
               -> theFragServer.notifyListElementInserted;
             
         if);
     if);
  #);
generateImperative:
  (# theImperatives: ^astInterface.beta.imperatives;
     name: ^text;
     value: ^atom;
     eval: ^astInterface.beta.evaluation;
     imp: ^astInterface.beta.imp;
  enter (theImperatives[], name[], value[])
  do (theImperatives.frag[], value[]) -> generateEvaluation -> eval[];
     (theImperatives.frag[], name[], eval[]) -> betaGram.newAssignment -> imp[];
     (1, imp[]) -> theImperatives.insert;
  #);

changeData:
  (# newData: ^parameters;
     force: @boolean;
     oldValue: ^atom;
     defaultValue: ^atom;
     doChangePosition, doChangeSize: @boolean;
  enter (newData[], force)
  do newData.data.storage.scan
     (# name: ^text;
     do (if true
         //'x' -> current.key.equalNCS
         //'y' -> current.key.equalNCS then
            true -> doChangePosition;
         //'width' -> current.key.equalNCS
         //'height' -> current.key.equalNCS then
            true -> doChangeSize;
         //'ID' -> current.key.equalNCS then
         //'type' -> current.key.equalNCS then
         else
            current.key[] -> data.data.lookup -> oldValue[];
            (if (not force) AND (current.value[] -> oldValue.equal) then
             else
                current.key[] -> defaultData.data.lookup -> defaultValue[];
                (if true 
                 //'borderStyle' -> current.key.equalNCS then
                    'border.style' -> name[];
                 //'borderVisible' -> current.key.equalNCS then
                    'border.visible' -> name[];
                 else
                    current.key[] -> name[];
                if);
                
                (if (not (defaultValue[] = NONE)) AND (current.value[] -> defaultValue.equal) then
                    name[] -> deleteImperative;
                 else
                    (name[], current.value[]) -> changeImperative;
                if);
            if);
        if);
     #);
     (if doChangePosition then
         newData.position -> changePosition;
     if);
     (if doChangeSize then
         newData.size -> changeSize;
     if);
  #);

changePosition: codeGuard
  (# x, y: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation, oldEval, newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
  enter (x, y)
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> position' -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
        (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             imp.getEvaluation -> oldEval[];
             (theDoPart.frag[], x, y) -> betaGram.newPointEvaluation -> newEval[];
             newEval[]  -> imp.putEvaluation;
             (true, imp.frag[], oldEval[], newEval[]) -> theFragServer.notifyAstreplaced;
          else
             (theDoPart.frag[], x, y) -> betaGram.newPointEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
             (true, theDoPart.frag[], theImperatives[], 1) -> theFragServer.notifyListElementInserted;
         if);
     if);
  #);
changeSize: codeGuard
  (# width, height: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation, oldEval, newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
  enter (width, height)
  do forInitStatements -> findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives -> theImperatives[];
         '<<evaluation>> -> size' -> txt.append;
         (theImperatives.frag[], txt[], gram.imp) -> parseText -> proto[];
        (mps[], theImperatives[], proto[]) -> listSearch -> imp[];
         (if imp[] <> none then
             imp.getEvaluation -> oldEval[];
             (theDoPart.frag[], width, height) -> betaGram.newPointEvaluation -> newEval[];
             newEval[] -> imp.putEvaluation;
             (true, imp.frag[], oldEval[], newEval[]) -> theFragServer.notifyAstreplaced;
          else
             (theDoPart.frag[], width, height) -> betaGram.newPointEvaluation 
               -> proto.putEvaluation;
             (1, proto[]) -> theImperatives.insert;
             (true, theDoPart.frag[], theImperatives[], 1) -> theFragServer.notifyListElementInserted;
         if);
     if);
  #);

inherited:
  (#
  enter private.inherited
  exit private.inherited
  #);



dragOrResize:
  (# theEvent: ^windowItem.eventhandler.mouseDown;
     width, height: @integer;
     minBorder: (# exit 1 #);
     maxBorder: (# exit 5 #);
     borderRatio: (# exit 5 #);
     borderWidth: @integer;
     borderHeight: @integer;
     h, v: @integer;
     x, y: @integer;
     doLeft, doTop, doRight, doBottom: @boolean;
  enter (theEvent[], (h, v))
  do theWindowItem.size -> (width, height);
     
     
     (((width div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderWidth;
     (((height div borderRatio), maxBorder) -> Min, minBorder) -> max -> borderHeight;
     
     (if (h <= borderWidth) then 
         true -> doLeft 
     if);
     (if (h >= (width - borderWidth)) then
         true -> doRight
     if);
     (if (v <= borderHeight) then
         true -> doTop
     if);
     (if (v >= (height - borderHeight)) then 
         true -> doBottom
     if);
     (if doLeft or doTop or doRight or doBottom then
         (doLeft, doTop, doRight, doBottom) -> reConfigure;
      else
         theEvent[] -> selection.drag;
     if);
  #);

closeWindowItem:
  (# 
  do traverse
     (# forEach::<
          (# 
          do current[] -> qua
             (# as:: canvasEditor;
                quaError:: (# do true -> continue #);
             do (if thisObj.private.theReciever[] <> none then
                    thisObj.private.theReciever.delete;
                    none -> thisObj.private.theReciever[];
                if);
             #);
          #);
     #);
     theWindowItem.close;
     none -> theWindowItem[];
  #);
fixOptionButtons:
  (# 
  do traverse
     (# forEach::<
          (# 
          do current[] -> qua
             (# as:: optionButtonEditor;
                quaError:: (# do true -> continue #);
             do thisObj.theWindowItem.preferredSize -> thisObj.theWindowItem.size;;
             #);
          #);
     #);
  #);

frame:
  (# r: ^rectangle;
  enter (# enter r[]
        do true -> dontHandleFrameChanged;
           r -> theWindowItem.frame;
           false -> dontHandleFrameChanged;
        #)
  exit (# 
       do &rectangle[] -> r[];
          theWindowItem.frame -> r;
       exit r[]
       #)
  #);

createShadowTree:
  (# tree: ^shadowTree;
     thisCanvasEditor: ^canvasEditor;
  do &shadowTree[] -> tree[];
     node[] -> betaGram.getName -> tree.name[];
     data.copy -> tree.data[];
     defaultData[] -> tree.defaultData[];
     theClassData[] -> tree.theClassData[];
     inherited -> tree.inherited;
     node[] -> tree.node[];
     tree.children.init;
     (if this(windowItemEditor)## <= canvasEditor## then
         this(windowItemEditor)[] -> thisCanvasEditor[];
         thisCanvasEditor.children.scan
         (# 
         do current.createShadowTree -> tree.children.append;
         #);
     if);
  exit tree[]
  #);

delete:
  (# father: ^astInterface.list;
     oldElements: ^astInterface.astList;
     deleteInx: @integer;
  do 
     closeWindowItem;
     node.father -> father[];
     node.sonNo -> deleteInx;
     deleteInx -> father.delete;
     &MPS.astList[] -> oldElements[];
     oldElements.init;
     node[] -> oldElements.insert;
     (true, father.frag[], father[], deleteInx, 1, oldElements[])
       -> theFragServer.notifyListElementsDeleted;
     this(windowitemEditor)[] -> owner.children.delete;
     node[] -> betaGram.getName -> owner.deleteOpenImp;
     false -> private.selected;
  #);
reInsert:
  (# theDoPart: ^astInterface.beta.doPart;
     theAttributes: ^astInterface.beta.attributes;
  do this(windowitemEditor)[] -> owner.children.append;
     createTheWindowItem;
     owner.getMainAttributes -> theAttributes[];
     (if node.frag[] <> theAttributes.frag[] then
         theAttributes.frag[] -> node.copy -> node[];
     if);
     node[] -> owner.appendAttribute;
     forOpenStatements -> owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);


isPrivateToWindow: booleanValue
  (# 
  do not (node.frag[] = this(graphicalEditor).node.frag[]) -> value;
  #);

isPrivateToOwner: booleanValue
  (# 
  do (if owner[] = none then
         false -> value;
      else
         not (node.frag[] = owner.node.frag[]) -> value;
     if);
  #);

traverseCallback:
  (# current: ^windowItemEditor;
     continue: @boolean;
  enter current[]
  do true -> continue;
     inner;
  exit continue
  #);

recTraverse:
  (# callback: ^traverseCallback;
     editor: ^windowItemEditor;
     theCanvasEditor: ^canvasEditor;
  enter (editor[], callback[])
  do (if editor[] -> callback then
         (if editor## <= canvasEditor## then
             editor[] -> theCanvasEditor[];
             theCanvasEditor.children.scan
             (# 
             do (current[], callback[]) -> &recTraverse;
             #);
         if);
     if);
  #);

traverse:
  (# forEach:< traverseCallback;
  do (this(windowItemEditor)[], &forEach[]) -> recTraverse;
  #);
            

(* 
 * Code
 *)



appendToAttributes: codeGuard
  (# theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
  enter (theAttributes[], theAttribute[])
  do (if theAttributes.empty then
         (# father: ^astInterface.expanded;
            sonNo: @integer;
            newAttributes: ^astInterface.beta.attributes;
         do theAttributes.father -> father[];
            theAttributes.sonNo -> sonNo;
            (father.frag[], theAttribute[])-> betaGram.newAttributes -> newAttributes[];
            (sonNo, newAttributes[]) -> father.put;
            (true, father.frag[], theAttributes[], newAttributes[])
              -> theFragServer.notifyAstReplaced;
         #);
      else
         theAttributes.noOfSons -> insertInx;
         theAttribute[] -> theAttributes.append;
         (true, theAttributes.frag[], theAttributes[], insertInx) 
           -> theFragServer.notifyListElementInserted;
     if)
  #);

updateOpen1:
  (# theDoPart: ^astInterface.beta.doPart;
  do forOpenStatements -> owner.findOpenDoPart -> theDoPart[];
     (if theDoPart[] <> none then
         node[] -> betaGram.getName -> owner.deleteOpenImp;
         theDoPart.frag[] -> generateOpenImp -> owner.appendOpenImp;
     if);
  #);


prependOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
     do forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            (1, imp[]) -> theImperatives.insert;
            (true, theImperatives.frag[], theImperatives[], 1) 
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);

appendOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure:
       (# 
       do 
       #);
  enter imp[]
  do (# theImperatives: ^astInterface.beta.imperatives;
        insertInx: @integer;
     do forOpenStatements  -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# 
              do current.sonNo -> insertInx;
                 (if current.symbol = betaGram.innerImp then
                     leave l;
                 if);
              #);
            (insertInx, imp[]) -> theImperatives.insert;
            (true, theImperatives.frag[], theImperatives[], insertInx)
              -> theFragServer.notifyListElementInserted;
        if);
     #);
  #);


deleteOpenImp: codeGuard
  (# theDoPart: ^astInterface.beta.doPart;
     name: ^text;
     failure:
       (# 
       do
       #);
  enter name[]
  do (# theImperatives: ^astInterface.beta.imperatives;
        deleteInx: @integer;
        oldElements: ^astInterface.astList;
     do forOpenStatements -> findOpenDoPart -> theDoPart[];
        (if theDoPart[] = none then
            failure;
         else
            &MPS.astList[] -> oldElements[];
            oldElements.init;
            theDoPart.getImperatives -> theImperatives[];
            l: theImperatives.iterate
              (# theObjectDenotation: ^astInterface.beta.objectDenotation;
                 theNameApl: ^astInterface.beta.nameApl;
                 theText: ^text;
                 theAttributeDenotation: ^astInterface.ast;
                 theRemote: ^astInterface.beta.remote;
              do (if current.symbol = betaGram.objectDenotation then
                     current[] -> theObjectDenotation[];
                     theObjectDenotation.getAttributeDenotation -> theAttributeDenotation[];
                     (if theAttributeDenotation.symbol = betaGram.remote then
                         theAttributeDenotation[] -> theRemote[];
                         theRemote.getNameApl -> theNameApl[];
                         theNameApl.getText -> theText[];
                         (if 'open' -> theText.equalNCS then
                             theRemote.getAttributeDenotation -> theAttributeDenotation[];
                             (if theAttributeDenotation.symbol
                              //betaGram.remote then
                                 theAttributeDenotation[] -> theRemote[];
                                 theRemote.getNameApl -> theNameApl[];
                              //betaGram.nameApl then
                                 theAttributeDenotation[] -> theNameApl[];
                              else
                                 none -> theNameApl[];
                             if);
                             (if theNameApl[] <> none then
                                 theNameApl.getText -> theText[];
                                 (if name[] -> theText.equalNCS then
                                     current.sonNo -> deleteInx;
                                     current[] -> oldElements.insert;
                                     leave l;
                                 if);
                             if);
                         if);
                     if);
                 if);
              #);
            (if deleteInx <> 0 then
                
                deleteInx -> theImperatives.delete;
                (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
                  -> theFragServer.notifyListElementsDeleted;
                
            if);
        if);
     #);
  #);

(* deleteOpenImp1:
 *   (# theDoPart: ^astInterface.beta.doPart;
 *      id: @integer;
 *      failure:
 *        (# 
 *        do
 *        #);
 *   enter id
 *   do (# theImperatives: ^astInterface.beta.imperatives;
 *         deleteInx: @integer;
 *         oldElements: ^astInterface.astList;
 *      do findOpenDoPart -> theDoPart[];
 *         (if theDoPart[] = none then
 *             failure;
 *          else
 *             &MPS.astList[] -> oldElements[];
 *             oldElements.init;
 *             theDoPart.getImperatives -> theImperatives[];
 *             l: theImperatives.iterate
 *               (# 
 *               do (if current.guiInfo = id then
 *                      current.sonNo -> deleteInx;
 *                      current[] -> oldElements.insert;
 *                      leave l;
 *                  if);
 *               #);
 *             (if deleteInx <> 0 then
 *                 
 *                 deleteInx -> theImperatives.delete;
 *                 (true, theImperatives.frag[], theImperatives[], deleteInx, 1, oldElements[])
 *                   -> theFragServer.notifyListElementsDeleted;
 *                 
 *             if);
 *         if);
 *      #);
 *   #);
 *)




generateOpenImp:
  (# name: ^text;
     theImp: ^astInterface.beta.imp;
     frag: ^astInterface.fragmentForm;
  enter frag[]
  do node[] -> betaGram.getName -> name[];
     (frag[], name[], isPrivateToOwner) 
       -> betaGram.newOpenStatement -> theImp[];
  exit theImp[]
  #);
(* generateInitImp:
 *   (# frag: ^astInterface.fragmentForm;
 *      theImp: ^astInterface.beta.imp;
 *   enter frag[]
 *   do (frag[], theDocument.theParameterStore.shortName, data.id) 
 *        -> betaGram.newInitFromResourceStatement 
 *        -> theImp[];
 *      0 -> theImp.guiInfo;
 *   exit theImp[]
 *   #);
 *)
(* updateInitImp:
 *   (# theDoPart: ^astInterface.beta.doPart;
 *   do findOpenDoPart -> theDoPart[];
 *      (if theDoPart[] <> none then
 *          0 -> deleteOpenImp;
 *          theDoPart.frag[] -> generateInitImp -> prependOpenImp;
 *      if);
 *   #);
 *)
findVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
        if);
        (if currentNode[] <> none then
             (currentNode[], name[]) -> betaGram.findAttribute-> theVirtual[];
        if);
     #);
  exit theVirtual[]
  #);

appendAttributeToNode:
  (# node, theAttribute: ^astInterface.beta.attributeDecl;
  enter (node[], theAttribute[])
  do 
     (# theAttributes: ^astInterface.beta.attributes;
        insertInx: @integer;
     do node[] -> betaGram.getAttributes -> theAttributes[];
        (theAttributes[], theAttribute[]) -> appendToAttributes;
     #);
  #);

createVirtual:
  (# name: ^text;
     theVirtual: ^astInterface.beta.attributeDecl;
  enter name[]
  do (# isEvent: @boolean;
        currentNode: ^astInterface.beta.attributeDecl;
        theAttribute: ^astInterface.beta.attributeDecl;
     do (if name.length >= 2 then
            'on' -> ((1, 2) -> name.sub).equal -> isEvent;
         else
            false -> isEvent;
        if);
        node[] -> currentNode[] -> theAttribute[];
        (if isEvent then
            (currentNode[], 'eventHandler') -> betaGram.findAttribute -> currentNode[];
            (if currentNode[] = none then
                (theAttribute.frag[], 'eventHandler', none) -> betaGram.newVirtualBinding -> currentNode[];
                (theAttribute[], currentNode[]) -> appendAttributeToNode;
            if);
        if);
        (currentNode.frag[], name[], none) -> betaGram.newVirtualBinding -> theVirtual[];
        (currentNode[], theVirtual[]) -> appendAttributeToNode;
     #);
  exit theVirtual[]
  #);


handleAstReplaced:
  (# oldAst, newAst: ^astInterface.AST;
     succes: @boolean;
  enter (oldAst[], newAst[])
  do false -> succes;
     (if oldAst[] -> node.equal then
         newAst[] -> node[]; (* !!! Check for validitet *)
         true -> succes;
      else
         (if (node[], newAst[]) -> isAncestor then
             true -> succes;
          else
             (if (oldAst[], node[]) -> isAncestor then
                 (# theAttributes: ^astInterface.beta.attributes;
                    name: ^text;
                 do node[] -> betaGram.getName -> name[];
                    owner.getMainAttributes -> theAttributes[];
                    (if theAttributes[] <> none then
                        l: theAttributes.iterate
                        (# 
                        do (if current[] -> betaGram.getName -> name.equalNCS then
                               current[] -> node[];
                               true -> succes;
                               leave l;
                           if);
                        #);
                    if);
                 #);
              else
                 true -> succes;
             if);
         if);
     if);
  exit succes
  #);



(* createOpenDopart: codeGuard
 *   (# theDoPart: ^astInterface.beta.doPart;
 *      main: @boolean;
 *   enter main
 *   do (# node: ^astInterface.beta.attributeDecl;
 *         openDecl: ^astInterface.beta.attributeDecl;
 *         slotName: ^text;
 *         theObjectDescriptor: ^astInterface.beta.objectDescriptor;
 *         theUnExpanded: ^astInterface.unExpanded;
 *         doPartFrag: ^astInterface.fragmentForm;
 *         group: ^astInterface.fragmentGroup;
 *         isPrivate: @boolean;
 *         frag: ^astInterface.fragmentForm;
 *      do (if main then
 *             getMainNode -> node[];
 *          else
 *             this(windowItemEditor).node[] -> node[];
 *         if);
 *         
 *         (node.frag[], 'open', none) -> betaGram.newVirtualBinding -> openDecl[];
 *         (node[], openDecl[]) -> appendAttributeToNode;
 *         openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
 *         (if isPrivateToWindow then
 *             node.frag[] -> betaGram.newDoPart ->  theDoPart[];
 *             (theObjectDescriptor[], theDoPart[]) -> betaGram.setDoPart; {* !!! NOTIFY !!! *}
 *          else
 *             node[] -> betaGram.getName -> slotName[];
 *             'Open' -> slotName.append;
 *             (node.frag[], slotName[]) -> betaGram.newSlotDoPart -> theUnExpanded[];
 *             (theObjectDescriptor[], theUnExpanded[]) -> betaGram.setDoPart;
 *             slotName[] -> betaGram.newDoPartFrag -> doPartFrag[];
 *             defaultBodyGroup -> group[];
 *             slotName[] -> group.findFragment -> frag[];
 *             (if frag[] <> none then
 *                 frag.root[] -> theDoPart[];
 *              else
 *                 doPartFrag[] -> group.fragmentList.addFragment;
 *                 doPartFrag.root[] -> theDoPart[];
 *             if);
 *         if);
 *      #);
 *   exit theDoPart[]
 *   #);
 * 
 * 
 *)
findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     purpose: @integer;
  enter purpose
  do (# 
       
     do 
        (node[], defaultBodyGroup, purpose) -> realFindOpenDoPart -> theDoPart[];
     #);
  exit theDoPart[]
  #);

(* generateSimpleOpen: {* !!! NOTIFY !!! *}
 *   (# theDoPart: ^astInterface.beta.doPart;
 *      theImperatives, oldImperatives: ^astInterface.beta.imperatives;
 *      theImp: ^astInterface.beta.imp;
 *      theInnerImp: ^astInterface.beta.innerImp;
 *      gram: @grammar;
 *   do false -> createOpenDopart -> theDoPart[];
 *      (betaGram.imperatives, theDoPart.frag[]) 
 *        -> betaGram.newAst 
 *        -> theImperatives[] 
 *        -> theDoPart.putImperatives;
 *      {* (theDoPart.frag[], theDocument.theParameterStore.shortName, data.id) 
 *       *        -> betaGram.newInitFromResourceStatement 
 *       *        -> theImp[]
 *       *        -> theImperatives.smartAppend;
 *       *      0 -> theImp.guiInfo;
 *       *}
 *      (if node.symbol = betaGram.patternDecl then
 *          (betaGram.innerImp, theDoPart.frag[]) 
 *            -> betaGram.newAst 
 *            -> theInnerImp[]
 *            -> theImperatives.smartAppend;
 *          (gram.nameAplOpt, theDoPart.frag[]) 
 *            -> betaGram.makeOptional 
 *            -> theInnerImp.putNameAplOpt;
 *      if);
 *   #);
 * 
 *)
changeOwnerOld:
  (# newOwner: ^canvasEditor;
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     theFather: ^astInterface.beta.attributes;
     currentOwner: ^canvasEditor;
     oldDoPart: ^astInterface.beta.doPart;
     newDoPart: ^astInterface.beta.doPart;
     
  enter newOwner[]
  do 
     node[] -> theAttribute[];
     theAttribute.father -> theFather[];
     theAttribute.sonNo -> theFather.delete;
     theAttribute[] -> newOwner.appendAttribute;
     owner[] -> currentOwner[];
     newOwner[] -> owner[];
     
     closeWindowItem;
     None -> theWindowItem[];
     this(windowItemEditor)[] -> currentOwner.children.delete;
     this(windowItemEditor)[] -> newOwner.children.append;
     createTheWindowItem;
     
     forOpenStatements -> newOwner.findOpenDoPart -> newDoPart[];
     node[] -> betaGram.getName -> currentOwner.deleteOpenImp; 
     (if newDoPart[] <> none then
         newDoPart.frag[] -> generateOpenImp -> newOwner.appendOpenImp;
     if);
     
  #);

changeOwner:
  (# newOwner: ^canvasEditor;  
  enter newOwner[]
  do delete;
     newOwner[] -> owner[];
     reInsert;
  #);

handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do (theEvent[], theEvent.localPosition) -> this(windowItemEditor).mousedown;
  #);
handleFrameChanged: theWindowItem.frameChangedAction
  (# r: ^rectangle;
     x, y: @integer;
  do 
     (if theWindowItem[]<>none then
         frame -> r[];
         r.topLeft -> (x, y);
         (if not dontHandleFrameChanged then
             (x, y) -> changePosition;
             r.size -> changeSize;
         if);
         (if data[]<>none then
             
             (x, y) -> data.position;
             r.size  -> data.size;
             
             (if private.selected then
                 removeControlPoints;
                 showControlPoints;
             if);
             (*
              * (if private.selected then
              *   (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
              *   startWalkingAnts;
              * if);
              *)
         if);
     if);
  #);

startWalkingAnts:
  (# 
  do theWindowItem[] -> this(graphicalEditorEnv).private.theWalkingAnts.attach;
  #);
stopWalkingAnts:
  (# 
  do (theWindowItem[], none) -> this(graphicalEditorEnv).private.theWalkingAnts.delete;
  #);
handleRefresh: theWindowItem.refreshAction
  (#
  #);


-- windowitemEditorPrivate: descriptor --
(# selected: @boolean;
   skip: @boolean;
   inherited: @boolean;
   initializing: @boolean;
   pos: ^windowItemEditorList.position;
   node: ^astInterface.AST;
   controlPoints: @sequence
     (# element:: controlPoint;
     #);
#)

-- canvasEditorPrivate: descriptor --
(# locked: @boolean;
   theReciever: ^recieverType;
#)


-- graphicalEditorEnvLib: attributes --
makeFragmentForm:
  (# frag: ^astInterface.fragmentForm;
  do betaGram[] -> mps.newFragmentForm -> frag[];
  exit frag[]
  #);

check:
  (# anAst: ^astInterface.ast;
  enter anAst[]
  do (if anAst[] <> none then
         (if anAst.kind <> mps.kinds.interior then
             none -> anAst[];
         if);
     if);
  exit anAst[]
  #);

forInitStatements: (# exit 1 #);
forOpenStatements: (# exit 2 #);

realFindOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart;
     node: ^astInterface.beta.attributeDecl;
     group: ^astInterface.fragmentGroup;
     purpose: @integer;
  enter (node[], group[], purpose)
  do (# contents: ^astInterface.beta.attributeDecl;
        openDecl: ^astInterface.beta.attributeDecl;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        theActionPart: ^astInterface.beta.actionPart;
        theAst: ^astInterface.AST;
        theUnExpanded: ^astInterface.unExpanded;
        theSlot: ^astInterface.slotDesc;
        doPartFrag: ^astInterface.fragmentForm;
        
     do node.frag.father -> group[];
        (if purpose
         //forOpenStatements then
            (node[], 'contentsType') -> betaGram.findAttribute -> contents[];
            (if contents[] <> none then
                (if contents.symbol
                 //betaGram.bindingDecl
                 //betaGram.finalDecl then
                    contents[] -> node[];
                if);
            if);
        if);
        (node[], 'open') -> betaGram.findAttribute -> openDecl[];
        (if openDecl[] <> none then
            openDecl[] -> betaGram.getObjectDescriptor -> theObjectDescriptor[];
            theObjectDescriptor.getMainPart -> theMainPart[];
            theMainPart.getActionPart -> theActionPart[];
            theActionPart.getDoPartOpt -> theAst[];
            (if theAst.symbol = MPS.unExpanded then
                (if group[] <> none then
                    theAst[] -> theUnExpanded[];
                    
                    (if theUnExpanded.isSlot then
                        theUnExpanded.theSlot -> theSlot[];
                        theSlot.name -> group.findBodyFragment -> doPartFrag[];
                        (if doPartFrag[] <> None then
                            doPartFrag.root[] -> theDoPart[];
                        if);
                    if);
                if);
             else
                theAst[] -> theDoPart[];
            if);
        if);
     #);
  exit theDoPart[]
  #);




scriptEditor: theAstEditorEnv.astEditor
  (# eventHandler::
       (# onAboutToClose::
            (# parseOK: @boolean;
            do (if dirty then
                   parse -> parseOK;
                   parseOK -> okToClose;
               if);
            #);
       #);
     
  #);

scanPrefixChain:
  (# node: ^astInterface.beta.attributeDecl;
     current: ^astInterface.beta.attributeDecl;
     prefixName: ^text;
     theClass: ^classInfo.class;
  enter node[]
  do node[] -> current[];
     l:
       (#
       do current[] ->  betaGram.getPrefix -> prefixName[];
          (if prefixName[] <> none then
              prefixName[] -> private.theClassInfo.lookup -> theClass[];
              (if theClass[] = NONE then
                  current[] -> getSuperPattern -> current[];
                  (if current[] <> none then
                      INNER scanPrefixChain;
                      restart l;
                  if);
              if);
          if);
       #);
  #);

getAttributes:
  (# node: ^astInterface.beta.attributeDecl;
     theAttributeList: ^attributeList;
     getPrivateAttributes:
       (# node: ^astInterface.beta.attributeDecl;
          theAttributes: ^astInterface.beta.attributes;
          frag: ^astInterface.fragmentForm;
          theDescriptorForm: ^astInterface.beta.descriptorForm;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
       enter node[]
       do node[] -> betaGram.getPrivateFragment -> frag[];
          (if frag[] <> none then
              (if frag.category = betaGram.descriptorForm then
                  frag.root[] -> theDescriptorForm[];
                  theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                  theObjectDescriptor.getMainPart -> theMainPart[];
                  theMainPart.getAttributes -> theAttributes[];
              if);
          if);
       exit theAttributes[]
       #);
     
     addAttributes:
       (# theAttributes: ^astInterface.beta.attributes
       enter theAttributes[]
       do (if theAttributes[] <> none then
              theAttributes.iterate
              (# 
              do current[] -> theAttributeList.append;
              #);
          if);
       #);
     addImperatives:
       (# node: ^astInterface.beta.attributeDecl;
          theNameApl: ^astInterface.beta.nameApl;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
       enter node[]
       do (node[], group[], forInitStatements) -> realFindOpenDoPart -> theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives -> theImperatives[];
              theImperatives.newScan
              (# doMatch: @boolean;
              do 
                 (mps[], current[], proto1[]) -> match -> doMatch;
                 (if not doMatch then
                     (mps[], current[], proto2[]) -> match -> doMatch;
                 if);
                 (if doMatch then
                     current[] -> theImperativeList.prepend;
                 if);
              #);
          if);
       #);
     theImperativeList: ^imperativeList;
     proto1, proto2: ^astInterface.AST;
     gram: @grammar;
     group: ^astInterface.fragmentGroup;
  enter (node[], group[])
  do (node.frag[], '<<evaluation>> -> <<nameApl>>', gram.imp)
       -> parseText -> proto1[];
     (node.frag[], '<<evaluation>> -> <<remote>>', gram.imp)
       -> parseText -> proto2[];
     
     &attributeList[] -> theAttributeList[];
     theAttributeList.init;
     &imperativeList[] -> theImperativeList[];
     theImperativeList.init;
     
     node[] -> betaGram.getAttributes -> addAttributes;
     node[] -> getPrivateAttributes -> addAttributes;
     node[] -> addImperatives;
   
   
     
  exit (theAttributeList[], theImperativeList[])
  #);


getInheritedAttributes:
  (# node: ^astInterface.beta.attributeDecl;
     theAttributeList: ^attributeList;
     getPrivateAttributes:
       (# node: ^astInterface.beta.attributeDecl;
          theAttributes: ^astInterface.beta.attributes;
          frag: ^astInterface.fragmentForm;
          theDescriptorForm: ^astInterface.beta.descriptorForm;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
       enter node[]
       do node[] -> betaGram.getPrivateFragment -> frag[];
          (if frag[] <> none then
              (if frag.category = betaGram.descriptorForm then
                  frag.root[] -> theDescriptorForm[];
                  theDescriptorForm.getObjectDescriptor -> theObjectDescriptor[];
                  theObjectDescriptor.getMainPart -> theMainPart[];
                  theMainPart.getAttributes -> theAttributes[];
              if);
          if);
       exit theAttributes[]
       #);
     
     addAttributes:
       (# theAttributes: ^astInterface.beta.attributes
       enter theAttributes[]
       do (if theAttributes[] <> none then
              theAttributes.iterate
              (# 
              do current[] -> theAttributeList.prepend;
              #);
          if);
       #);
     addImperatives:
       (# node: ^astInterface.beta.attributeDecl;
          theNameApl: ^astInterface.beta.nameApl;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
       enter node[]
       do (node[], group[], forInitStatements) -> realFindOpenDoPart -> theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives -> theImperatives[];
              theImperatives.newScan
              (# doMatch: @boolean;
              do 
                 (mps[], current[], proto1[]) -> match -> doMatch;
                 (if not doMatch then
                     (mps[], current[], proto2[]) -> match -> doMatch;
                 if);
                 (if doMatch then
                     current[] -> theImperativeList.prepend;
                 if);
              #);
          if);
       #);
     theImperativeList: ^imperativeList;
     proto1, proto2: ^astInterface.AST;
     gram: @grammar;
     group: ^astInterface.fragmentGroup;
  enter (node[], group[])
  do (node.frag[], '<<evaluation>> -> <<nameApl>>', gram.imp)
       -> parseText -> proto1[];
     (node.frag[], '<<evaluation>> -> <<remote>>', gram.imp)
       -> parseText -> proto2[];
     
     &attributeList[] -> theAttributeList[];
     theAttributeList.init;
     &imperativeList[] -> theImperativeList[];
     theImperativeList.init;
     
     node[] -> scanPrefixChain
     (# 
     do current[] -> betaGram.getAttributes -> addAttributes;
        current[] -> getPrivateAttributes -> addAttributes;
        current[] -> addImperatives;
     #);
  exit (theAttributeList[], theImperativeList[])
  #);

getClass:
  (# node: ^astInterface.beta.attributeDecl;
     prefixName: ^text;
     theClass: ^classInfo.class;
     superNode: ^astInterface.beta.attributeDecl;
  enter node[]
  do node[] -> betaGram.getPrefix -> prefixName[];
          
     (if prefixName[] <> none then         
         prefixName[] -> private.theClassInfo.lookup -> theClass[];
         (if theClass[] = NONE then
             node[] -> getSuperPattern -> superNode[];
             (if superNode[] <> none then
                 superNode[] -> getClass -> theClass[];
             if);
         if);
     if);
     
  exit theClass[]
  #);

getSuperPattern:
  (# node, superNode: ^astInterface.beta.attributeDecl;
     theNameApl: ^astInterface.beta.nameApl;
     theNameDcl: ^astInterface.beta.nameDcl;
     theNames: ^astInterface.beta.names;
     dest: ^astInterface.ast;
  enter node[]
  do node[] -> betaGram.getPrefixNameApl -> theNameApl[];
     (if theNameApl[] <> none then
         (mps[], theNameApl[]) -> followSemanticLink -> dest[];
         (if (dest[] <> none) and (dest.symbol = betaGram.nameDcl) then
             dest[] -> theNameDcl[];
             theNameDcl.father -> theNames[];
             theNames.father -> superNode[];
         if);
     if);
  exit superNode[]
  #);

(* End of Class support *)


getScrap:
  (# 
  exit private.theScrap[]
  #);
insert:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.append;
  #);

delete:
  (# editor: ^graphicalEditor;
  enter editor[]
  do editor[] -> private.editors.delete;
  #);

editorWalkingAnts: walkingAnts
  (# editor: ^graphicalEditor;
     fullStop:
       (# 
       do stop;
          clear;
       #);
     attach:
       (# item: ^window.windowItem;
          area: ^rectangle;
          width, height: @integer;
       enter item[]
       do &rectangle[] -> area[];
          item.size -> (width, height);
          ((0, 0), (width - 1, height - 1)) -> area;
          (item[], area[]) -> add;
          start;
       #);
  #);

scrap: doubleLinkedList
  (# element::
       (# tree: ^shadowTree;
          node: ^astInterface.AST;
       #);
  #);
shadowTree:
  (# name: ^text;
     data, defaultData: ^parameters;
     theClassData: ^classData;
     inherited: @boolean;
     node: ^astInterface.beta.attributeDecl;
     children: @doubleLinkedList
       (# element:: shadowTree;
       #);
  #);

-- graphicalEditorEnvPrivate: descriptor --
(# theClassInfo: ^classInfo;
   
   theWalkingAnts: ^editorWalkingAnts;
   theScrap: @scrap;
   editors: @doubleLinkedList
     (# element:: graphicalEditor;
     #);
   documents: @doubleLinkedList
     (# element:: document;
     #);
          
#)

-- textEditorPictPrivate: descriptor --
(# open:
     (# width, height: @integer;
     do true -> border.visible;
        size -> (width, height);
        
        this(textEditorPict)[] -> contents.open;
        true -> contents.delegateMouseEvents;
        ((2, 2), (width - 16, height - 16)) -> contents.frame;
        true -> contents.bindRight -> contents.bindBottom;
        
        this(textEditorPict)[] -> vScrollBar.open;
        true -> vScrollBar.delegateMouseEvents;
        vScrollBar.disableDefaultBehaviour;
        ((width - 16, 0), (width, height - 16)) -> vScrollBar.frame;
        true -> vScrollBar.bindRight;
        false -> vScrollBar.bindLeft;
        true -> vScrollBar.bindBottom;
        
        this(textEditorPict)[] -> hScrollBar.open;
        true -> hScrollBar.delegateMouseEvents;
        hScrollBar.disableDefaultBehaviour;
        ((0, height - 16), (width - 16, height)) -> hScrollBar.frame;
        true -> hScrollBar.bindRight;
        false -> hScrollBar.bindTop;
        true -> hScrollBar.bindBottom;
     #);
   contents: @canvas
     (# eventHandler::<
          (# 
             onMouseDown::
               (#
               <<SLOT textEditorPictContentsOnMousedown: doPart>>
               #)
          #)
     #);
   vScrollBar: @scrollBar
     (# vertical:: (# do true -> value #);
        
     #);
   hScrollBar: @scrollBar
     (# 
     #);
#)

-- graphicalEditorPrivateAttributes: descriptor --
(# forbidCodeChanges, dontHandleFrameChanged: @boolean;
   uniqueID: @integer;
   lastSaveOperation: ^operation;
   theFileMenu: @graphicalEditorMenu
     (# 
        closeItem: @menuItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do (if this(graphicalEditor).theEventHandler.onAboutToClose then
                           this(graphicalEditor).close;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Close' -> name;
                  'W' -> key;
                  closeItem[] -> append;
               #);
          #);
        saveItem: @graphicalEditorItem
          (# eventHandler::
               (# onStatus::
                    (# 
                    do true -> value;
                    #);
                  onSelect::
                    (# 
                    do theDocument.interfaceGroup[] -> saveFragmentGroup;
                    #);
               #);
             open::
               (# 
               do 'Save' -> name;
                  'S' -> key;
               #);
          #);
        open::
          (# 
          do 'File' -> name;
             closeItem.open;
             saveItem.open;
          #);
     #);
   theEditMenu: @graphicalEditorMenu
     (# undoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do undo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canUndo then 
                           'Undo ' -> t[];
                           undoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Undo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Undo' -> name;
                  'Z' -> key;
               #);
          #);
        redoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do redo;
                    #);
                  onStatus::
                    (# t: ^text;
                    do (if canRedo then 
                           'Redo ' -> t[];
                           redoText -> t.append;
                           t[] -> name;
                           true -> value;
                        else
                           'Redo' -> name;
                           false -> value;
                       if);
                    #);
               #);
             open::
               (# 
               do 'Redo' -> name;
                  'R' -> key;
               #);
          #);
        cutItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCut;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Cut' -> name;
                  'X' -> key;
               #);
          #);
        copyItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.doCopy;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty  -> value;
                    #);
               #);
             open::
               (# 
               do 'Copy' -> name;
                  'C' -> key;
               #);
          #);
        pasteItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do paste;
                    #);
                  onStatus::
                    (# 
                    do canPaste -> value;
                    #);
               #);
             open::
               (# 
               do 'Paste' -> name;
                  'V' -> key;
               #);
          #);
        deleteItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.deleteAll;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Delete' -> name;
               #);
          #);
        findItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find...' -> name;
               #);
          #);
        findAgainItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    #);
                  onStatus::
                    (# 
                    do false -> value;
                    #);
               #);
             open::
               (# 
               do 'Find again' -> name;
               #);
          #);
        editNameItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.editName;
                    #);
                  onStatus::
                    (# 
                    do selection.size = 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Edit Name...' -> name;
                  'N' -> key;
               #);
          #);
        editScriptsItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.editScripts;
                    #);
                  onStatus::
                    (# 
                    do selection.size = 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Edit Virtuals...' -> name;
                  'K' -> key;
               #);
          #);
        openSubEditorItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.openSubEditor;
                    #);
                  onStatus::
                    (# 
                    do selection.size >= 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Open Subeditor' -> name;
                  'J' -> key;
               #);
          #);
        objectInfoItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showInfo;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Object info...' -> name;
                  'I' -> key;
               #);
          #);
        objectFitToContents: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.fitToContents;
                    #);
                  onStatus::
                    (# 
                    do not selection.empty -> value;
                    #);
               #);
             open::
               (# 
               do 'Fit to contents' -> name;
               #);
          #);
        open::
          (# 
          do 'Edit' -> name;
             undoItem.open;
             redoItem.open;
             addSeparator;
             cutItem.open;
             copyItem.open;
             pasteItem.open;
             deleteItem.open;
             addSeparator;
             
             (* findItem.open;
              *              findAgainItem.open;
              *               addSeparator;
              *)
             editNameItem.open;
             editScriptsItem.open;
             openSubEditorItem.open;
             addSeparator;
             objectInfoItem.open;
             objectFitToContents.open;
          #);
     #);
   theAlignMenu: @graphicalEditorMenu
     (#
        alignLeftItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignLeft;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Left side' -> name;
               #);
          #);
        alignRightItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignRight;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Right side' -> name;
               #);
          #);
        alignTopItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignTop;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Top edge' -> name;
               #);
          #);
        alignBottomItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignBottom;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Bottom edge' -> name;
               #);
          #);
        alignHorCenterItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignHorCenter;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Vertcial center' -> name;
               #);
          #);
        alignVerCenterItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.alignVerCenter;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Horizontal center' -> name;
               #);
          #);
        showSpacingDialogItem: @graphicalEditorItem
          (# eventHandler::
               (# onSelect::
                    (# 
                    do selection.showSpacingDialog;
                    #);
                  onStatus::
                    (# 
                    do selection.size > 1 -> value;
                    #);
               #);
             open::
               (# 
               do 'Spacing...' -> name;
               #);
          #);
        open::
          (#
          do 'Align' -> name;
             alignLeftItem.open;
             alignRightItem.open;
             alignTopItem.open;
             alignBottomItem.open;
             alignHorCenterItem.open;
             alignVerCenterItem.open;
             addSeparator;
             showSpacingDialogItem.open;
          #);
     #);
   (*
    * Handling of private attributes
    *)
   
   body: ^astInterface.fragmentGroup;
   
   (*
    * Fragment handler
    *)
   
   
   fragHandler, privateFragHandler: @fragmentHandler
     (# handleAstReplaced:
          (#  oldAst, newAst: ^astInterface.ast; 
          enter (oldAst[], newAst[])
          do contentsEditor.traverse
             (# forEach::
                  (# 
                  do (oldAst[], newAst[]) -> current.handleAstReplaced -> continue;
                  #);
             #);
          #);
        astReplaced::
          (#
          do (oldAst[], newAst[]) -> handleAstReplaced;
          #);
        (* astReplacedSequence:<
         *           (# rootOfSequence: ^astInterface.ast
         *           enter rootOfSequence[]
         *           do inner;
         *           #);
         *         listElementInserted:<
         *           (# position: @integer; listNode: ^astInterface.expanded; 
         *           enter (listNode[], position)
         *           do inner;
         *           #);
         *         listElementsDeleted:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length: @integer
         *           enter (listNode[], position, length, oldElements[])
         *           do inner;
         *           #);
         *         listElementsReplaced:<
         *           (# oldElements: ^astInterface.astList;
         *              listNode: ^astInterface.expanded;
         *              position, length, newLength: @integer
         *           enter (listNode[], position, length, oldElements[], newLength)
         *           do inner;
         *           #);
         *)
     #);
   
   
   (*
    * Undo and redo
    *)
   undoStack: @stack
     (# element:: operation;
     #);
   redoStack: @stack
     (# element:: operation;
     #);
      
   (*
    * Drag and drop
    *)


   theDragManager: @dragManager
     (# dragger::
          (#  moveTo:<
               (# theCanvasEditor: ^canvasEditor;
                  newFrame: ^rectangle;
               enter (theCanvasEditor[], newFrame[])
               do inner;
               #);
          #);
        changeHierarkiDragger: dragger
          (# bounds: ^rectangle;
             moveTo::
               (# dh, dv: @integer;
               do newFrame.left - bounds.left -> dh;
                  newFrame.top - bounds.top -> dv;
                  (if theCanvasEditor[] -> selection.moveAllowed then
                      (if (selection.first).owner[] <> theCanvasEditor[] then
                          (theCanvasEditor[], dh, dv) -> selection.makeChangeOwnerOperation;
                      if);
                   else
                      system.beep;
                  if);
               #);
          #);
        createDragger: dragger
          (# type: @integer;
             theClassData: ^classData;
             moveTo::
               (# theEditor: ^windowItemEditor;
                  theCreateOperation: ^createOperation;
               do &createOperation[] -> theCreateOperation[];
                  (theCanvasEditor[], type, newFrame[], theClassData[]) -> theCreateOperation.init;
               #);
          #);
     #);
   
   (* END of drag and drop *)
   
   (*
    * Clipboard
    *)
   
   theClipBoard: @clipboard;
   
   (* 
    * Mode
    *)
   
   mode: @integer;
   
   (* End of mode *)
   
   (*
    * Generators
    *)
   
   editorGenerator: [29] ^generateEditor;
   initEditorGenerator:
     (# 
     do (* &generateEditor (# do &interfaceObjectEditor[] -> we[] #)[] -> editorGenerator[1][]; *)
        &generateEditor (# do &windowitemEditor[] -> we[] #)[] -> editorGenerator[2][];
        &generateEditor (# do &separatorEditor[] -> we[] #)[] -> editorGenerator[3][];
        &generateEditor (# do &canvasEditor[] -> we[] #)[] -> editorGenerator[4][];
        &generateEditor (# do &abstractScrollerEditor[] -> we[] #)[] -> editorGenerator[5][];
        &generateEditor (# do &scrollerEditor[] -> we[] #)[] -> editorGenerator[6][];
        &generateEditor (# do &textEditorEditor[] -> we[] #)[] -> editorGenerator[7][];
        &generateEditor (# do &controlEditor[] -> we[] #)[] -> editorGenerator[8][];
        &generateEditor (# do &buttonEditor[] -> we[] #)[] -> editorGenerator[9][];
        &generateEditor (# do &pushButtonEditor[] -> we[] #)[] -> editorGenerator[10][];
        &generateEditor (# do &iconButtonEditor[] -> we[] #)[] -> editorGenerator[11][];
        &generateEditor (# do &OptionButtonEditor[] -> we[] #)[] -> editorGenerator[12][];
        &generateEditor (# do &staticTextEditor[] -> we[] #)[] -> editorGenerator[13][];
        &generateEditor (# do &toggleButtonEditor[] -> we[] #)[] -> editorGenerator[14][];
        &generateEditor (# do &radioButtonEditor[] -> we[] #)[] -> editorGenerator[15][];
        &generateEditor (# do &checkBoxEditor[] -> we[] #)[] -> editorGenerator[16][];
        &generateEditor (# do &scrollbarEditor[] -> we[] #)[] -> editorGenerator[17][];
        &generateEditor (# do &editTextEditor[] -> we[] #)[] -> editorGenerator[18][];
        &generateEditor (# do &textFieldEditor[] -> we[] #)[] -> editorGenerator[19][];
        &generateEditor (# do &scrollListEditor[] -> we[] #)[] -> editorGenerator[20][];
        &generateEditor (# do &textScrollListEditor[] -> we[] #)[] -> editorGenerator[21][];
        &generateEditor (# do &windowEditor[] -> we[] #)[] -> editorGenerator[22][];
        (* &generateEditor (# do &menuEditor[] -> we[] #)[] -> editorGenerator[23][]; *)
        (* &generateEditor (# do &menubarEditor[] -> we[] #)[] -> editorGenerator[24][]; *)
        (* &generateEditor (# do &menuitemEditor[] -> we[] #)[] -> editorGenerator[25][]; *)
        (* &generateEditor (# do &dynamicMenuitemEditor[] -> we[] #)[] -> editorGenerator[26][];*)
        &generateEditor (# do &verScrollbarEditor[] -> we[] #)[] -> editorGenerator[27][];
        &generateEditor (# do &verSeparatorEditor[] -> we[] #)[] -> editorGenerator[28][];
        &generateEditor (# do &rectangleEditor[] -> we[] #)[] -> editorGenerator[29][];
     #);
   
   names: [29] ^text;
   initNames:
     (# 
     do 'interfaceObject' -> names[1][];
        'windowitem' -> names[2][];
        'separator' -> names[3][];
        'canvas' -> names[4][];
        'abstractScroller' -> names[5][];
        'scroller' -> names[6][];
        'textEditor' -> names[7][];
        'control' -> names[8][];
        'button' -> names[9][];
        'pushButton' -> names[10][];
        'iconButton' -> names[11][];
        'optionButton' -> names[12][];
        'staticText' -> names[13][];
        'toggleButton' -> names[14][];
        'radioButton' -> names[15][];
        'checkBox' -> names[16][];
        'scrollbar' -> names[17][];
        'editText' -> names[18][];
        'textField' -> names[19][];
        'scrollList' -> names[20][];
        'textScrollList' -> names[21][];
        'window' -> names[22][];
        'menu' -> names[23][];
        'menubar' -> names[24][];
        'menuitem' -> names[25][];
        'dynamicMenuitem' -> names[26][];
        'scrollbar' -> names[27][];
        'separator' -> names[28][];
        'rect' -> names[29][];
     #);
   sizes: [29] ^point;
   initSizes:
     (# 
     do (for inx: sizes.range repeat
             &point[] -> sizes[inx][];
        for);
        (100, 20) -> sizes[2];
        (100, 4) -> sizes[3];
        (200, 100) -> sizes[4];
        (200, 100) -> sizes[5];
        (200, 100) -> sizes[6];
        (200, 100) -> sizes[7];
        (100, 20) -> sizes[8];
        (100, 20) -> sizes[9];
        (60, 20) -> sizes[10];
        (40, 40) -> sizes[11];
        (100, 40) -> sizes[12];
        (60, 16) -> sizes[13];
        (100, 20) -> sizes[14];
        (100, 20) -> sizes[15];
        (100, 20) -> sizes[16];
        (100, 16) -> sizes[17];
        (100, 30) -> sizes[18];
        (200, 100) -> sizes[19];
        (200, 100)  -> sizes[20];
        (200, 100) -> sizes[21];
        (300, 200) -> sizes[22];
        (16, 100) -> sizes[27];
        (4, 100) -> sizes[28];
        (30, 40) -> sizes[29];
     #);
   
   (* contentsEditorObject: @canvas
    *      (# setRealFrame:
    *           (# r: ^rectangle;
    *              width, height: @integer;
    *           enter r[]
    *           do r.size -> (width, height);
    *              width + 16 -> width;
    *              height + 32 -> height;
    *              (width, height) -> windowView.size;
    *              r.topLeft -> windowView.position;
    *           #);
    *         getRealFrame:
    *           (# r: ^rectangle;
    *           do &rectangle[] -> r[];
    *              windowView.position -> r.topLeft;
    *              size -> r.size;
    *           exit r[]
    *           #);
    *         open::<
    *           (#
    *           do true -> bindRight -> bindBottom;
    *              false -> border.visible;
    *           #);
    *      #);
    *)
   adorner: @canvas
     (# interior: ^windowItem;
        adjustSize:
          (# width, height: @integer;
          do interior.size -> (width, height);
             (width + 8, height + 8) -> size;
             (4, 4) -> interior.position;
          #);
        open::
          (# 
             windowViewRight: @integer;
             ignore: @integer;
          do bringBack;
             true -> border.visible;
             borderstyles.shadowOut -> border.style;
             (toolPaletteRight + 10, 5) -> position;            
          #);
        eventHandler::
          (# onChildFrameChanged::
               (# 
               do adjustSize;
               #);
             onMouseDown::
               (# r: @rectangle;
                  width, height: @integer;
               do (if not readOnly then
                      (this(onMouseDown)[], localPosition) -> contentsEditor.dragOrResize;
                      (*  (interior.frame, false, false, true, true) -> defineRect -> r;
                       *                       r.size -> (width, height);
                       *                       (width, height) -> makeChangeWindowSizeOperation;
                       *)
                  if);
               #);
          #);
     #);
   
   contentsEditor: ^windowItemEditor;
   
   theCustomPalette: @palette
     (# 
        patterns: @sequence
          (# element:: classData;
          #);
        
        addPattern:
          (# thePattern: ^astInterface.beta.patternDecl;
             theClassData: ^classData;
          enter thePattern[]
          do 
             (thePattern[], defaultBodyGroup) -> getClassData -> theClassData[];
             (if theClassData[] <> none then
                 theClassData[] -> patterns.append;
                 (none,
                 thePattern[] -> betaGram.getName,
                 theClassData.theClass.type,
                 patterns.size) -> addPaletteItem;
             if);
          #);
        
        addPatternsFromAttributes:
          (# theAttributes: ^astInterface.beta.attributes;
          enter theAttributes[]
          do (if theAttributes[] <> none then
                 theAttributes.newScan
                 (# 
                 do (if current.symbol = betaGram.patternDecl then
                        current[] -> addPattern;
                    if);
                 #);
             if);
          #);
        addPatternsFromNode:
          (# node: ^astInterface.beta.attributeDecl;
          enter node[]
          do node[] -> betaGram.getAttributes -> addPatternsFromAttributes;
          #);
        open::
          (# 
          do patterns.init;
             contentsEditor.getPublicAttributes -> addPatternsFromAttributes;
             contentsEditor.getPrivateAttributes -> addPatternsFromAttributes;
             (mps[], contentsEditor.node.frag.father, 'windowLib') -> scanDomain
             (# 
             do (if current.symbol = betaGram.patternDecl then
                    current[] -> addPattern;
                if);
             #);
             fit;
             (if patterns.empty then 
                 hide;
             if);
                 
          #);
        mouseDownInItem::
          (# theDragger: @createDragger;
          do (if not readOnly then
                 theCustomPalette[] -> theDragger.item[];
                 type -> theDragger.type;
                 (if index <> 0 then
                     index -> patterns.get -> theDragger.theClassData[];
                 if);
                 (event[], theControlPalette[]) -> theDragger.drag
                 (# 
                    frame::
                      (# 
                      do &rectangle[] -> value[];
                         p -> value.topLeft;
                         (32, 32) -> value.size;
                      #);
                 #);
             if);
          #);
     #);
   
   theControlPalette: @controlPalette
     (# 
        mouseDownInItem::
          (# theDragger: @createDragger;
          do (if not readOnly then
                 theControlPalette[] -> theDragger.item[];
                 type -> theDragger.type;
                 (event[], theControlPalette[]) -> theDragger.drag
                 (# 
                    frame::
                      (# 
                      do &rectangle[] -> value[];
                         p -> value.topLeft;
                         type -> getDefaultSize -> value.size;
                      #);
                 #);
             if);
          #);
        open::
          (# ignore: @integer;
          do (200, 5) -> position;
             frame -> ((ignore, ignore), (controlPaletteRight, controlPaletteBottom));
          #);
     #);
   theViewsPalette: @viewPalette
     (# 
         
        mouseDownInItem::
          (# theDragger: @createDragger;
          do (if not readOnly then
                 theViewsPalette[] -> theDragger.item[];
                 type -> theDragger.type;
                 (event[], theViewsPalette[])  -> theDragger.drag
                 (# 
                    frame::
                      (# 
                      do &rectangle[] -> value[];
                         p -> value.topLeft;
                         type -> getDefaultSize -> value.size;
                      #);
                 #);
             if);
             
          #);
        open::
          (# ignore: @integer;
          do (200, controlPaletteBottom + 5) -> position;
             frame -> ((ignore, ignore), (viewPaletteRight, viewPaletteBottom));
          #);
     #);
   theToolPalette: @toolPalette
     (# mouseDownInItem::
          (# 
          do (if not readOnly then
                 type -> this(graphicalEditor).mode;
             if);
          #);
        open::
          (# width, height: @integer;
          do (5, 5) -> position;
             size -> (width, height);
             width + 5 -> toolPaletteRight;
             height + 5 -> toolPaletteBottom;
          #);
        
     #);
   
   toolPaletteRight, toolPaletteBottom: @integer;
   controlPaletteBottom, controlPaletteRight: @integer;
   viewPaletteRight, viewPaletteBottom: @integer;
   windowViewBottom: @integer;
#)


