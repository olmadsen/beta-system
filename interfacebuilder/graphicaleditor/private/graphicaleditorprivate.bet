ORIGIN '../graphicaleditor';
INCLUDE '~beta/guienv/utils/guienvadds'
        '~beta/guienv/utils/iconname'
        '~beta/sysutils/time'
        '~beta/sysutils/objinterface'
        '~beta/betaast/gram'
        '~beta/betaast/betasematt'
        '~beta/guienv/private/datastructures/sequence'
        '~beta/containers/list'
        '../../dialogs/griddialog'
        '../../code/semanticlink'
        '../../dialogs/propertyInspector'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '~beta/guienv/utils/guienvstuff'
        '~beta/guienv/utils/tabControl'
        '../../guienvstuff/killtranslations'
        '~beta/toollibs/utils/mpsutils'
        '../../buildermenu'
        '~beta/guienv/utils/prompts'
        '~beta/guienv/utils/row'
        '~beta/guienv/utils/guienvadds'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        '../../classes/classes'
        '../../view/colorsupport'
        '../patterndictionary'
        '../constants'
        '../icons';
BODY 'graphicaleditorbody'
     'graphicaleditormenus'
     'factorybody';

LIB_ITEM 'frigg_graph';

-- windowItemLib: Attributes --
delay:
  (# startPt: @point; 
  enter startPt
  do
     l: father.trackMouse
       (#
          mouseMove:: 
            (# dh,dv: @integer; 
            do
               curPt.h-startPt.h->dh;
               curPt.v-startPt.v->dv;
               (if (dh*dh > 4) or (dv*dv > 4) then
                   INNER delay; leave l; 
               if);
               
            #);
          
       #);
     
  #);
rubber:
(* Let the use drag the rectangle. 
 * doLeft,doTop,doRight,doBottom specifies which 
 * sides of the rectangle should follow the mouse.
 *)
  (#
     r: @rectangle;
     doLeft,doTop,doRight,doBottom: @boolean;
     gridStart:< (# pt: @point do INNER exit pt #);
     gridSize:< integerValue;
     
  enter (r,doLeft,doTop,doRight,doBottom)
  <<SLOT windowItemRubber:DoPart>>
  exit r
  #);
  

-- graphicalEditorLib: Attributes --

astEqual: booleanValue
  (# left,right: ^astInterface.AST; 
  enter (left[],right[])
  do (left.index = right.index) and (left.frag[] = right.frag[])->value; 
  #);
isAncestor: booleanValue
  (# anc,child: ^astInterface.AST; father: ^astInterface.AST; 
  enter (anc[],child[])
  do
     false->value;
     l:
       (# 
       do
          child.father->child[];
          (if child[] <> none then
              (if (anc[],child[])->astEqual then
                  true->value; 
               else
                  restart l; 
              if);
              
          if);
          
       #);
     
  #);

isRelated: BooleanValue
	(# anc,child: ^astInterface.AST; 
  enter (anc[],child[])
  do ((anc[],child[]) -> astEqual) OR ((anc[],child[]) -> isAncestor) -> value;
  #);

closeEditor:
	(#
	do 'Closing Editor' -> displayMessage;
		this(graphicalEditor).close;
	#);
	
friggObserver: fragmentFormObserver
  (#
     onAstReplaced::  
	 	(#  
		do
                   (if (node[], oldAst[]) -> astEqual then
				closeEditor;
			else
				(if (node[], newAst[]) -> isAncestor then
					newAst[]->handleAstChanged;
				else
					(if (oldAst[], node[]) -> isAncestor then
						closeEditor;
					if);
				if);
			if);
			
		#);
		
     onAstReplacedSequence::
    	 (* invoked when a sequence of astReplaced events have occured in node[]  *)
      (#  do  (* Ignored *)#);
	  
	  
	  
     onListElementInserted::
     (* invoked when a new list element have been inserted in node[] *) 
       (# 
	   do   (if (this(graphicalEditor).node[], node[]) -> isAncestor then
	   			node[] -> handleAstChanged;
			if);
	   #);
	   count: @integer;
     onListElementsDeleted::
     (* invoked when a list of elements have been deleted from node[] *) 
       (# 
	   do 
          (if (this(graphicalEditor).node[], node[]) -> isAncestor then
              node[] -> handleAstChanged;
           else
              search: 
                (for inx: length repeat
                     (if (oldElements.elm[inx][], this(graphicalEditor).node[]) -> isRelated then
                         closeEditor;
                         leave search;
                     if);
                for);
          if);
       #);
     onListElementsReplaced::
     (* invoked when a list of elements have been replaced in node[] *) 
       (# 
       do 
          (if (this(graphicalEditor).node[], node[]) -> isAncestor then
              node[] -> handleAstChanged;
           else
              search: 
                (for inx: length repeat
                     (if (oldElements.elm[inx][], this(graphicalEditor).node[]) -> isRelated then
                         closeEditor;
                         leave search;
                     if);
                for);
          if);
       #);
  #);
registerFragment:
  (# theObserver: ^fragmentFormObserver; frag: ^astInterface.fragmentForm; 
  enter frag[]
  do
     &friggObserver[]->theObserver[];
     theObserver[]->frag.attachObserver;
     frag.father->private.groups.append;
     frag[] -> private.fragments.append;
     theObserver[] -> private.observers.append;
  #);
abstractNode:
  (#
     node: ^astInterface.beta.attributeDecl;
     thePatternDecl: ^astInterface.beta.patternDecl;
     theSimpleDecl: ^astInterface.beta.simpleDecl;
     theAttributesForm: ^astInterface.beta.attributesForm;
     theAttributes: ^astInterface.beta.attributes;
     theNames: ^astInterface.beta.names;
     theStaticItem: ^astInterface.beta.staticItem;
     theReferenceSpecification: ^astInterface.beta.referenceSpecification;
     theObjectSpecification: ^astInterface.beta.objectSpecification;
     frag: ^astInterface.fragmentForm;
     group: ^astInterface.fragmentGroup;
     name,groupName: ^text;
     prefixName: ^text;
     guienvLocation: (#  exit '~beta/guienv/guienv' #);
     inst,newInst: ^instantiator;
     compiledWindowItem,instantiatorType: ##object;
     grouping: ^text;
     
  enter (grouping[],node[])
  do
     (if node.symbol = gram.simpleDecl then (* construct the node *)
         node[]->theSimpleDecl[];
         makeFragmentForm->frag[];
         'windowLib'->frag.name;
         (gram.attributesForm,frag[])->betaGram.newAst->theAttributesForm[]
           ->frag.root[];
         (gram.attributes,frag[])->betaGram.newAst->theAttributes[]
           ->theAttributesForm.putAttributes;
         (gram.patternDecl,frag[])->betaGram.newAst->thePatternDecl[];
         (1,thePatternDecl[])->theAttributes.insert;
         theSimpleDecl.getNames->theNames[];
         frag[]->theNames.copy->thePatternDecl.putNames;
         theSimpleDecl.getReferenceSpecification->theReferenceSpecification[];
         (if theReferenceSpecification.symbol = gram.staticItem then
             theReferenceSpecification[]->theStaticItem[];
             theStaticItem.getObjectSpecification->theObjectSpecification[];
             (if theObjectSpecification.symbol = gram.objectDescriptor then
                 frag[]->theObjectSpecification.copy
                   ->thePatternDecl.putObjectDescriptor;
                 
             if);
             
         if);
         (* construct the file *)
         thePatternDecl[]->betaGram.getName->name[];
         thePatternDecl[]->betaGram.getPrefix->prefixName[];
         prefixName[]->lookup->inst[];
         name[]->MPS.expandToFullPath->groupName[];
         groupName[]->MPS.top.newGroup->group[];
         'ORIGIN'->group.prop.addProp (#  do guienvLocation->addString;  #);
         gram.prefix
           ->thePatternDecl.suffixWalkForProd
             (#
                scanCat:: betaGram.prefix;
                theAttributeDenotation: ^astInterface.beta.attributeDenotation;
                theNameApl: ^astInterface.beta.nameApl;
                anInst: ^instantiator;
                
             do
                current.getAttributeDenotation->theAttributeDenotation[];
                (if theAttributeDenotation.symbol = gram.nameApl then
                    theAttributeDenotation[]->theNameApl[];
                    theNameApl.getText->lookup->anInst[];
                    (if anInst[] <> none then
                        (if anInst.path[] <> none then
                            (group[],anInst.path[])->addInclude; 
                        if);
                        
                    if);
                    
                if);
                
             #);
         group.loadIncludes;
         frag[]->group.fragmentList.addFragment;
         group.markAsChanged;
         (group[],'.bet'->(groupName.copy).append)->com.prettyPrintGroup;
         (* put it in the factory *)
         inst##->instantiatorType##;
         &instantiatorType[]->newInst[];
         (inst.icon[],name[],newInst[],groupName[],grouping[],inst.width,
          inst.height,thePatternDecl[],false)->factory.insert;
         (* thePatternDecl[] -> addPatternToPalette; *)
         (* put in into the preferences *)
         THIS(graphicalEditorEnv).private.preferences.addPaletteEntry
           (# 
           do
              name[]->entry.name[];
              groupName[]->entry.path[];
              thePatternDecl.frag.name->entry.fragment[];
              grouping[]->entry.grouping[];
              
           #);
         THIS(graphicalEditorEnv).private.preferences.write;
         (* place it on the palette *)
         (newInst.grouping[],newInst.icon[],newInst.name[])
           ->THIS(graphicalEditor).private.paletteTabber.addPaletteItem;
         (* Compile the windowitem *)
         (* (group.fullName, THIS(window)[]) -> com.evaluateFile -> compiledWindowItem##; *)
         (thePatternDecl[],THIS(window)[])->com.compilePattern
           ->compiledWindowItem##;
         (if compiledWindowItem## <> none then
             (if compiledWindowItem## <= windowItem## then
                 (name[],compiledWindowItem##)
                   ->
                     THIS(graphicalEditorEnv).private.compiledWindowItems.
                       define;
                 
             if);
             
         if);
         
     if);
     
  #);
registerStandardItems:
  (# 
  do
     ('windowItem',windowItem##)->registerItem;
     ('canvas',canvas##)->registerItem;
     ('control',control##)->registerItem;
     ('scrollbar',scrollbar##)->registerItem;
     ('button',button##)->registerItem;
     ('pushButton',pushButton##)->registerItem;
     ('staticText',staticText##)->registerItem;
     ('iconButton',iconButton##)->registerItem;
     ('optionButton',optionButton##)->registerItem;
     ('toggleButton',toggleButton##)->registerItem;
     ('radioButton',radioButton##)->registerItem;
     ('checkBox',checkBox##)->registerItem;
     ('editText',editText##)->registerItem;
     ('textField',textField##)->registerItem;
     ('abstractScroller',abstractScroller##)->registerItem;
     ('textEditor',textEditor##)->registerItem;
     ('scroller',scroller##)->registerItem;
     ('scrollList',scrollList##)->registerItem;
     ('textScrollList',textScrollList##)->registerItem
  #);

handleAstChanged:
  (# newAst: ^astInterface.ast;
     editor: ^componentEditor;
  enter newAst[]
  do (if NOT this(graphicalEditor).private.handlingNotification then
         true -> this(graphicalEditor).private.handlingNotification;
         newAst[] -> findOutermost -> editor[];
         (if editor[] = NONE then
             this(graphicalEditor).close;
          else
             newAst[] -> editor.changedNode;
         if);
         clearUndoStack;
         clearRedoStack;
         clearSelection;
         false -> this(graphicalEditor).private.handlingNotification;
     if);
  #);
findOutermost:
  (# newAst: ^astInterface.ast;
     editor: ^componentEditor;
  enter newAst[]
  do newAst[] -> (contentsEditor).findOutermost -> editor[];
  exit editor[]
  #);
gridSize: (#  enter private.gridSize exit private.gridSize #);
showPropertyInspector: (#  do private.thePropertyInspector.activate #);
gridStart:
  (# pt: @point
  do ((0,0),(contentsEditor).item[],THIS(window).contents)->translate->pt
  exit pt
  #);
changeGrid:
  (#
     theGridDialog: @gridDialog
       (#
          type:: windowTypes.dialog;
          onCancel::  (#  do close #);
          onConfirm:: 
            (#  do gridSizeFld.integerContents->gridSize; close #);
          
       #);
     
  do gridSize->theGridDialog.open; 
  #);
hasPrivateAttributes:
  (# 
  enter private.hasPrivateAttributes
  exit private.hasPrivateAttributes
  #);
instantiate:
  (# name: ^text; theWindowItemEditor: ^componentEditor; 
  enter name[]
  do
     (THIS(graphicalEditor)[],name[])->THIS(graphicalEditorEnv).instantiate
       ->theWindowItemEditor[];
     
  exit theWindowItemEditor[]
  #);
selectionChanged:
  (# 
  do
     (if not private.selectionChanged then
         true->private.selectionChanged; 1->private.selectionTimer.start; 
     if);
     
  #);
forgetSelectionChanged: (#  do private.selectionTimer.stop;  #);
controlPointEnv:
  (#
     hide:
       (# 
       do
          north.hide;
          east.hide;
          west.hide;
          south.hide;
          northEast.hide;
          northWest.hide;
          southEast.hide;
          southWest.hide;
          
       #);
     show:
       (# 
       do
          north.show;
          east.show;
          west.show;
          south.show;
          northEast.show;
          northWest.show;
          southEast.show;
          southWest.show;
          
       #);
     bounds:
       (# b: ^rectangle; mx,my: @integer; 
       enter b[]
       do
          (b.left+b.right) div 2->mx;
          (b.top+b.bottom) div 2->my;
          (mx,b.top)->north.corner;
          (mx,b.bottom)->south.corner;
          (b.left,my)->west.corner;
          (b.right,my)->east.corner;
          (b.right,b.top)->northEast.corner;
          (b.left,b.top)->northWest.corner;
          (b.right,b.bottom)->southEast.corner;
          (b.left,b.bottom)->southWest.corner;
          show;
          
       #);
     theEditor: ^componentEditor;
     north: @controlPoint (# init::  (#  do true->doTop;  #);  #);
     south: @controlPoint (# init::  (#  do true->doBottom;  #);  #);
     west: @controlPoint (# init::  (#  do true->doLeft;  #);  #);
     east: @controlPoint (# init::  (#  do true->doRight;  #);  #);
     northEast: @controlPoint
       (# init::  (#  do true->doTop; true->doRight;  #);  #);
     northWest: @controlPoint
       (# init::  (#  do true->doTop; true->doLeft;  #);  #);
     southEast: @controlPoint
       (# init::  (#  do true->doBottom; true->doRight;  #);  #);
     southWest: @controlPoint
       (# init::  (#  do true->doBottom; true->doLeft;  #);  #);
     init:
       (# 
       do
          northEast.init;
          northWest.init;
          southEast.init;
          southWest.init;
          north.init;
          west.init;
          south.init;
          east.init;
          
       #);
     controlPoint: windowItem
       (#
          doLeft,doTop,doBottom,doRight: @boolean;
          corner: (# p: @point;  enter p do (p.h-3,p.v-3)->position;  #);
          init:< (#  do THIS(window).contents->open; INNER ;  #);
          open:: 
            (# r: @rectangle; p: @point; black: (#  exit (0,0,0) #); 
            do hide; black->backgroundColor; (6,6)->size; 
            #);
          eventHandler:: 
            (#
               onMouseDown:: 
                 (# 
                 do
                    (if theEditor[] <> none then
                        (doLeft,doTop,doRight,doBottom)->theEditor.reConfigure; 
                    if);
                    
                 #);
               
            #);
          
       #);
     
  #);
makeEditor:
  (#
     editor: ^componentEditor;
     name: ^text;
     className: ^text;
     vertical: @boolean;
     
  enter (name[],vertical)
  do
     (if vertical then '-vertical'->name.append;  if);
     name[]->instantiate->editor[];
     
  exit editor[]
  #);
dontHandleFrameChanged:
  (# 
  enter private.dontHandleFrameChanged
  exit private.dontHandleFrameChanged
  #);
adjustSize:
  (# width,height: @integer; 
  do
     neededSize->(width,height);
     (540,width)->Max->width;
     (400,height)->Max->height;
     (width,height)->size;
     
  #);
makeData:
  (# data: ^parameters; 
  do
     &parameters[]->data[];
     data.init;
     true->data.bindLeft;
     false->data.bindRight;
     true->data.bindTop;
     false->data.bindBottom;
     true->data.visible;
     true->data.enabled;
     false->data.hilite;
     false->data.borderVisible;
     12->trace (#  do 'makeData: '->xT; xN; data[]->xData #);
     
  exit data[]
  #);
makeImperativeList:
  (# theImperativeList: ^imperativeList; 
  do &imperativeList[]->theImperativeList[]; theImperativeList.init; 
  exit theImperativeList[]
  #);
makeAttributeList:
  (# theAttributeList: ^attributeList; 
  do &attributeList[]->theAttributeList[]; theAttributeList.init; 
  exit theAttributeList[]
  #);
initData:
  (#
     theDoPart: ^astInterface.beta.doPart;
     theImperativeList: ^imperativeList;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1,proto2,proto3: ^astInterface.AST;
     theRemote: ^astInterface.beta.remote;
     
  enter (theData[],theImperativeList[])
  do
     makeFragmentForm->frag[];
     theImperativeList.scan
       (#
          theAssignment: ^astInterface.beta.assignmentEvaluation;
          theTransaction: ^astInterface.ast;
          theObjectDenotation: ^astInterface.beta.objectDenotation;
          theAttributeDenotation: ^astInterface.ast;
          theNameApl: ^astInterface.beta.nameApl;
          name: ^text;
          
       do
          current[]->theAssignment[];
          theAssignment.getTransaction->theTransaction[];
          (if theTransaction.symbol = betaGram.objectDenotation then
              theTransaction[]->theObjectDenotation[];
              theObjectDenotation.getAttributeDenotation
                ->theAttributeDenotation[];
              (if theAttributeDenotation.symbol = betaGram.nameApl then
                  theAttributeDenotation[]->theNameApl[];
                  (theData[],theNameApl.getText,theAssignment[])->adjustValue;
                  
               else
                  (if theAttributeDenotation.symbol = betagram.remote then
                      theAttributeDenotation[]->theRemote[];
                      theRemote.getAttributeDenotation
                        ->theAttributeDenotation[];
                      (if theAttributeDenotation.symbol = betaGram.nameApl then
                          theAttributeDenotation[]->theNameApl[];
                          theNameApl.getText->name[];
                          '.'->name.put;
                          theRemote.getNameApl->theNameApl[];
                          theNameApl.getText->name.append;
                          (theData[],name[],theAssignment[])->adjustValue
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     
  #);
adjustValue:
  (#
     theAssignment: ^astInterface.beta.assignmentEvaluation;
     theEvaluation: ^astInterface.beta.evaluation;
     name: ^text;
     value: ^atom;
     x,y,width,height: @integer;
     theData: ^parameters;
     borderStyleConsts: @borderStyleConstants;
     
  enter (theData[],name[],theAssignment[])
  do
     borderStyleConsts.init;
     12->trace (#  do 'adjustValue name: '->xT; name[]->xT #);
     theAssignment.getEvaluation->theEvaluation[];
     (if true
      // 'position'->name.equalNCS then
         theEvaluation[]->betaGram.evaluatePoint->(x,y);
         ('x',x)->theData.setInt;
         ('y',y)->theData.setInt;
         
      // 'size'->name.equalNCS then
         theEvaluation[]->betaGram.evaluatePoint->(width,height);
         ('width',width)->theData.setInt;
         ('height',height)->theData.setInt;
         
      // 'frame'->name.equalNCS then
         theEvaluation[]->betaGram.evaluateRect->(x,y,width,height);
         ('x',x)->theData.setInt;
         ('y',y)->theData.setInt;
         ('width',width)->theData.setInt;
         ('height',height)->theData.setInt;
         
      else
         name[]->theData.data.lookup->value[];
         (if value[] <> none then
             (if value.type
              // textType then
                 (name[],theEvaluation[]->betaGram.evaluateText)
                   ->theData.setText;
                 
              // boolType then
                 (name[],theEvaluation[]->betaGram.evaluateBool)
                   ->theData.setBool;
                 
              // intType then
                 (name[],
                  (theEvaluation[],name[]->lookupConstants)
                    ->betaGram.evaluateInt)->theData.setInt;
                 
             if);
             
         if);
         
     if);
     
  #);
defaultBodyGroup:
  (# group: ^astInterface.fragmentGroup; frag: ^astInterface.fragmentForm; 
  do
     private.contentsEditor.privateFrag[]->frag[];
     (if frag[] <> none then frag.name->putLine; frag.father->group[];  if);
     
  exit group[]
  #);
undoTop:
  (# top: ^operation; 
  do
     (if private.undoStack.empty then
         none ->top[]; 
      else
         private.undoStack.top->top[]; 
     if);
     
  exit top[]
  #);
saveGraphicalEditor: (#  do undoTop->private.lastSaveOperation[];  #);
graphicalEditorDirty: booleanValue
  (# 
  do
     (if undoTop <> private.lastSaveOperation[] then
         true->value; 
      else
         false->value; 
     if);
     
  #);
graphicalEditorMenu: menu
  (#
     graphicalEditorItem: menuItem
       (#
          eventHandler::< 
            (#
               onStatus::< 
                 (# 
                 do (if readOnly then false->value;  else INNER ;  if); 
                 #);
               
            #);
          open::<  (#  do INNER ; THIS(graphicalEditorItem)[]->append;  #);
          
       #);
     addSeparator:
       (# aSeparator: ^separator; 
       do &separator[]->aSeparator[]; aSeparator.open; aSeparator[]->append; 
       #);
     
  #);
(*
 * container types
 *)
rectangleList: sequence (# element:: rectangle;  #);
stack: sequence
  (#
     push: (# doAppend: @append;  enter doAppend #);
     pop: (# doDeleteLast: @deleteLast;  exit doDeleteLast #);
     top: (# doLast: @last;  exit doLast #);
     
  #);
(*
 * Clipboard
 *)
clipBoard:
  (#
     init:< (#  do theScrap.init; INNER ;  #);
     theScrap: @componentEditorList;
     count: @integer;
     copyToScrap:
       (# theSelection: ^componentEditorList; 
       enter theSelection[]
       do
          1->count;
          theScrap.clear;
          theSelection.scan
            (#  do current.copy->theScrap.append;  #);
          
       #);
     makePasteOperation: makeOperation
       (#
          operationType:: pasteOperation;
          theSelection: ^componentEditorList;
          theAttributes: ^astInterface.beta.attributes;
          
       do
          &componentEditorList[]->theSelection[];
          (contentsEditor).getMainAttributes->theAttributes[];
          theScrap.scan
            (# 
            do
               (theAttributes.frag[],none )->current.copy->theSelection.append;
               theSelection.scan
                 (#  do contentsEditor->current.owner[];  #);
               
            #);
          (theSelection[],count)->theOperation.init;
          count+1->count;
          
       #);
     
  #);
(*
 * Generating names
 *)
newUniqueName:
  (#
     theAttributes: ^astInterface.beta.attributes;
     name,newName: ^text;
     count: @integer;
     
  enter (theAttributes[],name[])
  do
     1->count;
     name.copy->newName[];
     count->newName.putInt;
     l:
     (if ((theAttributes[],newName[])->betaGram.find) <> none then
         name.copy->newName[];
         count+1->count;
         count->newName.putInt;
         restart l;
         ;
         
     if);
     
  exit newName[]
  #);
(*
 * Default sizes
 *)
getDefaultSize:
  (# width,height: @integer; name: ^text; inst: ^instantiator; 
  enter name[]
  do
     name[]->lookup->inst[];
     (if inst[] <> none then
         inst.width->width; inst.height->height
      else
         (100,50)->(width,height)
     if);
     
  exit (width,height)
  #);
(*
 * Classes for supporting undo
 *)
clearRedoStack: (#  do private.redoStack.clear;  #);
clearUndoStack: (#  do private.undoStack.clear;  #);

pushUndoStack:
  (# theOperation: ^operation; 
  enter theOperation[]
  do theOperation[]->private.undoStack.push; 
  #);
touch:
  (# 
  do
     private.touched+1->private.touched;
     (if private.touched mod 10 = 0 then autoSave;  if);
     
  #);
autoSave:
  (# 
  do private.groups.scan (#  do current[]->com.autoSaveGroup;  #); 
  #);
save:
  (# 
  do
     0->private.touched;
     private.groups.scan
       (#  do current[]->com.saveFragmentGroup;  #);
     
  #);

displayAstTooBigWarning:
  (# group: ^astInterface.fragmentGroup;
  enter group[]
  do (# msg: ^text;
     do 'AST overflow in '->msg[];
        (if group[] <> NONE then
            group.fullName -> msg.putText;
         else
            'temporary' -> msg.putText;
        if);
        '\nMjolner is quitting - answer Yes or No to save changes'
          ->msg.append;
        '\nIf Yes the AST is automatically garbage-collected'
               ->msg.append;
        msg[] -> displayMessage;
        com.quitApplication;
     #)
  #);

astFileTooBig: booleanValue
  (# 
     maxAstIndex: (# exit 125000 #);

  do false -> value;
     search: private.fragments.scan
     (#
     do (if current.curTop >= maxAstIndex then
            true -> value;
            current.father -> displayAstTooBigWarning;
            leave search;
        if);
     #);
  #);
displayFragmentLockedWarning:
  (# msg: @text;
     frag: ^astInterface.fragmentForm;
  enter frag[]
  do 'The operation could not be completed ' -> msg.putLine;
     'because the fragment ' -> msg.putLine;
     (frag.father).name -> msg.putTExt;
     '-' -> msg.put;
     frag.name -> msg.putText;
     msg.newLine;
     'is currently being textedited' -> msg.putText;
     msg[] -> displayMessage;
  #);
displayFragmentReadOnlyWarning:
  (# msg: @text;
     frag: ^astInterface.fragmentForm;
  enter frag[]
  do 'The operation could not be completed ' -> msg.putLine;
     'because the fragment ' -> msg.putLine;
     (frag.father).name -> msg.putTExt;
     '-' -> msg.put;
     frag.name -> msg.putText;
     msg.newLine;
     'is write-protected' -> msg.putText;
     msg[] -> displayMessage;
  #);

checkFragmentLocked: booleanValue
  (#
  do false -> value;
     search: private.fragments.scan
     (#
     do (if current.locked then
            true -> value;
            leave search;
        if);
     #);
  #);
fragmentLocked: booleanValue
  (#
  do false -> value;
     search: private.fragments.scan
     (#
     do (if current.locked then
            current[] -> displayFragmentLockedWarning;
            true -> value;
            leave search;
         else
            (if current.readOnly then
                current[] -> displayFragmentReadOnlyWarning;
                true -> value;
                leave search;
            if);
        if);
     #);
  #);

allowCommand: booleanValue
  (#
  do false -> value;
     (if not astFileTooBig then
         (if not fragmentlocked then
             true -> value;
         if);
     if);
  #);
printSizes:
  (#
  do private.fragments.scan
     (#
     do current.name -> putText;
        ' ' -> putText;
        current.curTop -> putInt;
        newLine;
     #);
  #);
operation:
  (#
     undoable:< booleanValue (#  do true->value; INNER #);
     command: 
       (# 
       do true -> this(GraphicalEditor).private.handlingNotification; 
          INNER;
          false -> this(GraphicalEditor).private.handlingNotification;
       #);
     doIt:< command;
     unDoIt:< command;
     init:< command
       (# 
       do 
          (if allowCommand then
              touch;
              INNER ;
              (if undoable then
                  clearRedoStack; THIS(operation)[]->pushUndoStack; 
              if);
          if);
          
       #);
     name:< (# value: ^text;  do INNER ;  exit value[] #);
     
  #);
makeOperation:
  (# operationType:< operation; theOperation: ^operationType; 
  do &operationType[]->theOperation[]; INNER ; 
  #);
singleOperation: operation
  (#
     theEditor: ^componentEditor;
     init::<  (#  enter theEditor[] do INNER ;  #);
     
  #);
resizeOperation: singleOperation
  (#
     oldFrame,newFrame: ^rectangle;
     init:: 
       (# 
       enter newFrame[]
       do
          theEditor.frame->oldFrame[];
          newFrame[]->theEditor.frame;
          (* theEditor.fixOpen; *)
          newFrame.size->theEditor.changeSize;
          
       #);
     doIt:: 
       (# 
       do
          newFrame[]->theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          newFrame.size->theEditor.changeSize;
          
       #);
     unDoIt:: 
       (# 
       do
          oldFrame[]->theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          oldFrame.size->theEditor.changeSize;
          
       #);
     name::<  (#  do 'Resize'->value[]; INNER ;  #);
     
  #);
makeSingleOperation: makeOperation
  (# operationType::< singleOperation; theEditor: ^componentEditor; 
  enter theEditor[]
  do INNER ; 
  #);
makeResizeOperation: makeSingleOperation
  (# operationType:: resizeOperation; newFrame: ^rectangle; 
  enter newFrame[]
  do (theEditor[],newFrame[])->theOperation.init; 
  #);
selectionOperation: operation
  (#
     theSelection: ^componentEditorList;
     setSelection: command
       (#  do selection.clear; INNER ; theSelection[]->selection.set;  #);
     init::<  (#  enter theSelection[] do INNER ;  #);
     
  #);
moveOperation: selectionOperation
  (#
     dh,dv: @integer;
     init::<  (#  enter (dh,dv) do doIt; INNER ;  #);
     doIt:: setSelection
       (# 
       do
          theSelection.scan
            (# 
            do (* true -> dontHandleFrameChanged; *)
               (dh,dv)->current.item.move;
               (* false -> dontHandleFrameChanged; *)
               current.item.position->current.changePosition;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# 
       do
          theSelection.scan
            (# 
            do (* true -> dontHandleFrameChanged; *)
               (- dh,- dv)->current.item.move;
               (* false -> dontHandleFrameChanged; *)
               current.item.position->current.changePosition;
               
            #);
          
       #);
     name::<  (#  do 'Move'->value[]; INNER ;  #);
     
  #);
changeOwnerOperation: selectionOperation
  (#
     dh,dv: @integer;
     newOwner,oldOwner: ^componentEditor;
     init:: 
       (# 
       enter (newOwner[],dh,dv)
       do
          (theSelection.first).owner[]->oldOwner[];
          doIt;
          INNER ;
          
       #);
     doIt:: setSelection
       (# 
       do
          theSelection.scan
            (# h,v: @integer; 
            do
               current.data.position->(h,v);
               (h+dh,v+dv)->current.data.position;
               (h+dh,v+dv)->current.changePosition;
               newOwner[]->current.changeOwner;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# 
       do
          theSelection.scan
            (# h,v: @integer; 
            do
               current.data.position->(h,v);
               (h-dh,v-dv)->current.data.position;
               (h-dh,v-dv)->current.changePosition;
               oldOwner[]->current.changeOwner;
               
            #);
          
       #);
     name::<  (#  do 'Move'->value[]; INNER ;  #);
     
  #);
changeBoundsOperation: selectionOperation
  (#
     newBounds,oldBounds: ^rectangleList;
     init:: 
       (# 
       enter newBounds[]
       do
          &rectangleList[]->oldBounds[];
          oldBounds.init;
          theSelection.scan
            (#  do current.frame->oldBounds.append;  #);
          doIt;
          
       #);
     doIt:: setSelection
       (# inx: @integer; 
       do
          1->inx;
          theSelection.scan
            (# b: ^rectangle; 
            do
               inx->newBounds.get->b[]->current.frame;
               inx+1->inx;
               b.topLeft->current.changePosition;
               b.size->current.changeSize;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# inx: @integer; 
       do
          1->inx;
          theSelection.scan
            (# b: ^rectangle; 
            do
               inx->oldBounds.get->b[]->current.frame;
               inx+1->inx;
               b.topLeft->current.changePosition;
               b.size->current.changeSize;
               
            #);
          
       #);
     
  #);
alignOperation: changeBoundsOperation
  (# name::<  (#  do 'Alignment'->value[]; INNER ;  #);  #);
fitToContentsOperation: changeBoundsOperation
  (# name::<  (#  do 'Fit to contents'->value[]; INNER ;  #);  #);
spacingOperation: changeBoundsOperation
  (# name::<  (#  do 'Spacing'->value[]; INNER ;  #);  #);
createOperation: operation
  (#
     bounds: ^rectangle;
     owner: ^componentEditor;
     type: @integer;
     theEditor: ^componentEditor;
     className: ^text;
     init:: 
       (# 
       enter (owner[],bounds[],className[])
       do
          selection.clear;
          className[]->owner.newEditor->theEditor[];
          bounds.topLeft->theEditor.item.position;
          bounds.topLeft->theEditor.changePosition;
          
       #);
     doIt:: 
       (#  do selection.clear; theEditor.reInsert; theEditor.select;  #);
     unDoIt::  (#  do selection.clear; theEditor.delete;  #);
     name::<  (#  do 'New'->value[];  #);
     
  #);
deleteOperation: selectionOperation
  (#
     init::  (#  do doIt;  #);
     doIt:: 
       (# 
       do selection.clear; theSelection.scan (#  do current.delete;  #); 
       #);
     unDoIt:: setSelection
       (#  do theSelection.scan (#  do current.reInsert;  #);  #);
     name::< 
       (# 
       do INNER ; (if value[] = none then 'Delete'->value[];  if); 
       #);
     
  #);
cutOperation: deleteOperation
  (# name::<  (#  do 'Cut'->value[];  #);  #);
pasteOperation: selectionOperation
  (#
     name::<  (#  do 'Paste'->value[];  #);
     makeUniqueNames:
       (# count: @integer; 
       enter count
       do
          theSelection.scan
            (# name: ^text; 
            do
               current.comp.name->name[];
               (if name[] = NONE then
                 'NoName' -> name[];
               if);
               (current.owner.comp.getAttributes,name[])->newUniqueName->name[];
               name[]->current.comp.name;
               
            #);
          
       #);
     moveObjects:
       (# dx,dy: @integer; theData: @parameters; 
       enter (dx,dy)
       do
          theData.init;
          theSelection.scan
            (# x,y: @integer; 
            do
               'x'->current.data.getInt->x;
               'y'->current.data.getInt->y;
               ('x',(x+dx))->theData.setint;
               ('y',(y+dy))->theData.setint;
               ('x',(x+dx))->current.data.setint;
               ('y',(y+dy))->current.data.setint;
               (theData[],false)->current.changeData;
               
            #);
          
       #);
     init:: 
       (# count: @integer; 
       enter count
       do makeUniqueNames; (count*4,count*4)->moveObjects; doIt; 
       #);
     doIt:: setSelection
       (#  do theSelection.scan (#  do current.reInsert;  #);  #);
     unDoIt:: 
       (# 
       do selection.clear; theSelection.scan (#  do current.delete;  #); 
       #);
     
  #);
dialogOperation: singleOperation
  (#
     oldData,newData: ^parameters;
     init:: 
       (#  enter newData[] do theEditor.data.copy->oldData[]; doIt;  #);
     doIt:: 
       (# 
       do
          selection.clear;
          TRUE->THIS(graphicalEditor).private.allowPositionChange;
          (newData[],false)->theEditor.changeData;
          newData[]->theEditor.data.set;
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     unDoIt:: 
       (# 
       do
          selection.clear;
          (oldData[],false)->theEditor.changeData;
          oldData[]->theEditor.data.set;
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     name::<  (#  do 'Dialog'->value[];  #);
     
  #);
changeOperation: singleOperation
  (#
     oldData,newData: ^parameters;
     init:: 
       (#  enter newData[] do theEditor.data.copy->oldData[]; doIt;  #);
     doIt:: 
       (# 
       do
          TRUE->THIS(graphicalEditor).private.allowPositionChange;
          (newData[],false)->theEditor.changeData;
          newData.data.storage.scan
            (# 
            do (current.key[],current.value[])->theEditor.data.define; 
            #);
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          
       #);
     unDoIt:: 
       (# 
       do
          selection.clear;
          (oldData[],false)->theEditor.changeData;
          oldData.data.storage.scan
            (# 
            do (current.key[],current.value[])->theEditor.data.data.define; 
            #);
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     name::<  (#  do 'Changed'->value[];  #);
     
  #);
makeDialogOperation: makeSingleOperation
  (# operationType:: dialogOperation; data: ^parameters; 
  enter data[]
  do (theEditor[],data[])->theOperation.init; 
  #);
makeChangeOperation: makeSingleOperation
  (# operationType:: changeOperation; data: ^parameters; 
  enter data[]
  do (theEditor[],data[])->theOperation.init; 
  #);
changeWindowSizeOperation: operation
  (#
     width,height: @integer;
     oldWidth,oldHeight: @integer;
     init:: 
       (# 
       enter (width,height)
       do (contentsEditor).item.size->(oldWidth,oldHeight); doIt; 
       #);
     doIt::  (#  do (width,height)->(contentsEditor).item.size;  #);
     unDoIt::  (#  do (oldWidth,oldHeight)->(contentsEditor).item.size;  #);
     name::<  (#  do 'Resize'->value[]; INNER ;  #);
     
  #);
makeChangeWindowSizeOperation: makeOperation
  (# operationType::< changeWindowSizeOperation; width,height: @integer; 
  enter (width,height)
  do (width,height)->theOperation.init; 
  #);
contentsEditor: (#  exit private.contentsEditor[] #);
translateRect:
  (# r: ^rectangle; from,to: ^windowItem; 
  enter (r[],from[],to[])
  do
     (r.topLeft,from[],to[])->translate->r.topLeft;
     (r.bottomRight,from[],to[])->translate->r.bottomRight;
     
  #);
  

-- selectionLib: Attributes --
extractData:
  (# data: ^parameters; count,firstData: ^parameters
  do
     &parameters[]->data[];
     data.init;
     &parameters[]->count[];
     count.init;
     scan
       (# 
       do
          current.data.data.storage.scan
            (# val: @integer
            do
               current.key[]->count.getInt->val;
               (current.key[],val+1)->count.setInt;
               
            #)
       #);
     (first).data[]->firstData[];
     count.data.storage.scan
       (# val: @integer
       do
          (current.value.asIntAtom).value->val;
          (if val = size then
              (current.key[],(current.key[]->firstData.find))->data.data.define
          if)
       #);
     
  exit data[]
  #);
moveControlPoints:
  (# b: ^rectangle; 
  do
     (if size
      // 0 then
         private.controlPoints.hide; 
      // 1 then
         bounds->b[];
         (b[],(first).item.father[],contents)->translateRect;
         b[]->private.controlPoints.bounds;
         first->private.controlPoints.theEditor[];
         
      else
         bounds->b[];
         (b[],(first).item.father[],contents)->translateRect;
         b[]->private.controlPoints.bounds;
         
     if);
     
  #);
openSubEditor:
  (#  do selection.scan (#  do current.openSubEditor;  #);  #);
isEditMenuPossible: booleanValue
  (# 
  do
     true->value;
     scan
       (#  do (if current[] = contentsEditor then false->value;  if);  #);
     
  #);
isAncestor: booleanValue
  (# ancestor,child: ^componentEditor; 
  enter (ancestor[],child[])
  do
     (if child[] = none then
         false->value; 
      else
         (if ancestor[] = child[] then
             true->value; 
          else
             (ancestor[],child.owner[])->isAncestor->value; 
         if);
         
     if);
     
  #);
moveAllowed: booleanValue
  (# theComponentEditor: ^componentEditor; 
  enter theComponentEditor[]
  do
     true->value;
     l:
       (# 
       do
          scan
            (# 
            do
               (if current.owner[] = theComponentEditor[] then
                   false->value; leave l; 
                else
                   (if (current[],theComponentEditor[])->isAncestor then
                       false->value; leave l; 
                   if);
                   
               if);
               
            #);
          
       #);
     
  #);
makeSelectionOperation: makeOperation
  (#
     operationType::< selectionOperation; theSelection: ^componentEditorList; 
  do copy->theSelection[]; INNER ; 
  #);
makeMoveOperation: makeSelectionOperation
  (# operationType:: moveOperation; dh,dv: @integer; 
  enter (dh,dv)
  do (theSelection[],dh,dv)->theOperation.init; 
  #);
makeChangeOwnerOperation: makeSelectionOperation
  (#
     operationType:: changeOwnerOperation;
     dh,dv: @integer;
     newOwner: ^componentEditor;
     
  enter (newOwner[],dh,dv)
  do (theSelection[],newOwner[],dh,dv)->theOperation.init; 
  #);
makeDeleteOperation: makeSelectionOperation
  (# operationType::< deleteOperation; 
  do theSelection[]->theOperation.init; 
  #);
makeCutOperation: makeDeleteOperation (# operationType:: cutOperation #);
makeChangeBoundsOperation: makeSelectionOperation
  (# operationType::< changeBoundsOperation; newBounds: ^rectangleList; 
  do
     &rectangleList[]->newBounds[];
     newBounds.init;
     INNER ;
     (theSelection[],newBounds[])->theOperation.init;
     
  #);
makeAlignOperation: makeChangeBoundsOperation
  (#
     operationType:: alignOperation;
     modelFrame: ^rectangle;
     currentFrame: ^rectangle;
     first: @boolean;
     
  do
     true->first;
     scan
       (# 
       do
          (if first then
              current.frame->modelFrame[];
              modelFrame[]->newBounds.append;
              false->first;
              
           else
              current.frame->currentFrame[];
              INNER makeAlignOperation;
              currentFrame[]->newBounds.append;
              
          if);
          
       #);
     
  #);
makeFitToContentsOperation: makeChangeBoundsOperation
  (# operationType:: fitToContentsOperation; 
  do
     scan
       (# r: ^rectangle; 
       do
          current.frame->r[];
          current.theWindowItem.preferredSize->r.size;
          r[]->newBounds.append;
          
       #);
     
  #);
makeSpacingOperation: makeOperation
  (#
     operationType:: spacingOperation;
     theSelection: ^componentEditorList;
     newBounds: ^rectanglelist;
     
  enter (theSelection[],newBounds[])
  do (theSelection[],newBounds[])->theOperation.init; 
  #);
bounds:
  (# theBounds: ^rectangle; 
  do
     &rectangle[]->theBounds[];
     minInt->theBounds.right->theBounds.bottom;
     maxInt->theBounds.left->theBounds.top;
     scan
       (# r: ^rectangle; 
       do
          current.frame->r[];
          (r.left,theBounds.left)->Min->theBounds.left;
          (r.top,theBounds.top)->Min->theBounds.top;
          (r.right,theBounds.right)->Max->theBounds.right;
          (r.bottom,theBounds.bottom)->Max->theBounds.bottom;
          
       #);
     
  exit theBounds[]
  #);
drag:
  (#
     theProxy: @proxy
       (#
          moveTo:: 
            (# dh,dv: @integer; 
            do
               newFrame.left-oldBounds.left->dh;
               newFrame.top-oldBounds.top->dv;
               (if theCanvasEditor[] = (first).owner[] then
                   (dh,dv)->makeMoveOperation; 
                else
                   (theCanvasEditor[],dh,dv)
                     ->selection.makeChangeOwnerOperation;
                   
               if);
               
            #);
          abstract:: 
            (# 
            do
               selection.scan
                 (#  do (grouping[],current.node[])->abstractNode #)
            #);
          
       #);
     oldBounds: ^rectangle;
     event: ^windowItem.eventHandler.mouseDown;
     dragItem: ^windowItem;
     theGridStart: @point;
     theFirst: ^ComponentEditor;
  enter event[]
  do (if contentsEditor <> NONE then
         (if (contentsEditor).item[] <> NONE then
             ((0,0),(contentsEditor).item[],THIS(window).contents)->translate
               ->theGridStart;
             bounds->oldBounds[];
             first -> theFirst[];
             (if theFirst[] <> NONE then
                 (if theFirst.owner[] <> NONE then
                     theFirst.owner.theWindowItem[]->dragItem[];
                     (if dragItem[] <> NONE then
                         FALSE->theProxy.palette;
                         (oldBounds[],theProxy[])  ->dragItem.dragAndDrop
                         (#
                            gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #);
                            gridSize::  (#  do THIS(graphicalEditor).gridSize->value #)
                         #);
                     if);
                 if);
             if);
         if);
     if);
  #);

selectable: booleanValue
  (# theEditor: ^componentEditor; 
  enter theEditor[]
  do
     (if empty then
         true->value; 
      else
         (theEditor.owner[] = (first).owner[])->value; 
     if);
     
  #);
array: sequence
  (#
     element:: 
       (#
          editor: ^componentEditor;
          init: (#  enter editor[] do editor.frame->frame[];  #);
          frame: ^rectangle;
          position:
            (# 
            enter
              (# x,y: @integer; 
              enter (x,y)
              do (x-frame.left,y-frame.top)->frame.offset
              #)
            exit frame.topLeft
            #);
          size: (#  enter frame.size exit frame.size #);
          
       #);
     add:
       (# editor: ^componentEditor; elm: ^element; 
       enter editor[]
       do &element[]->elm[]; editor[]->elm.init; elm[]->append; 
       #);
     sortHorizontal: sort
       (#
          less::< 
            (# leftpos,rightpos: @point; 
            do
               left.editor.item.position->leftpos;
               right.editor.item.position->rightpos;
               leftpos.h < rightpos.h->value;
               
            #);
          
       #);
     sortVertical: sort
       (#
          less::< 
            (# leftpos,rightpos: @point; 
            do
               left.editor.item.position->leftpos;
               right.editor.item.position->rightpos;
               leftpos.v < rightpos.v->value;
               
            #)
       #);
     
  #);
makeArray:
  (# theArray: ^array; 
  do
     &array[]->theArray[];
     theArray.init;
     scan
       (#  do current[]->theArray.add;  #);
     
  exit theArray[]
  #);
spacingValues:
  (#
     doWidth,doHeight,doVerticalDist,doHorizontalDist: @boolean;
     width,height,verticalDist,horizontalDist: @integer;
     
  #);
alignspacing:
  (#
     values: ^spacingValues;
     theArray: ^array;
     newBounds: ^rectangleList;
     theSelection: ^componentEditorList;
     
  enter values[]
  do
     makeArray->theArray[];
     (if (values.doWidth or values.doHeight)
      // true then
         theArray.scan
           (# width,height: @integer; 
           do
              current.size->(width,height);
              (if values.doWidth // true then values.width->width;  if);
              (if values.doHeight // true then values.height->height;  if);
              (width,height)->current.size;
              
           #);
         
     if);
     (if values.doVerticalDist then
         theArray.sortVertical;
         theArray.scan
           (#
              prevFrame: @rectangle;
              curPos: @Point;
              previous: ^array.element;
              
           do
              (if previous[] <> none then
                  current.position->curPos;
                  previous.frame->prevFrame;
                  prevFrame.bottom+values.verticalDist->curPos.v;
                  curPos->current.position;
                  
              if);
              current[]->previous[];
              
           #);
         
     if);
     (if values.doHorizontalDist then
         theArray.sortHorizontal;
         theArray.scan
           (#
              prevFrame: @rectangle;
              curPos: @Point;
              previous: ^array.element;
              
           do
              (if previous[] <> none then
                  current.position->curPos;
                  previous.frame->prevFrame;
                  prevFrame.Right+values.horizontalDist->curPos.h;
                  curPos->current.position;
                  
              if);
              current[]->previous[];
              
           #);
         
     if);
     &rectangleList[]->newBounds[];
     newBounds.init;
     &componentEditorList[]->theSelection[];
     theSelection.init;
     theArray.scan
       (# 
       do
          current.editor[]->theSelection.append;
          current.frame[]->newBounds.append;
          
       #);
     (theSelection[],newBounds[])->makeSpacingOperation;
     
  #);
  

-- componentEditorLib: Attributes --


appendAttribute:
  (# attribute: ^astInterface.beta.attributeDecl;
  enter attribute[]
  do (#
        theAttributes: ^astInterface.beta.attributes;
        son1: ^astInterface.ast;
        doReplace: @boolean;
        insertInx: @integer;
        
     do getMainAttributes ->theAttributes[];
        (if theAttributes[] <> none then
            (if theAttributes.noOfsons = 1 then
                1->theAttributes.get->son1[];
                (if son1.kind = 3 (* optional *) then true->doReplace;  if);
                
            if);
            (if doReplace then
                (1,attribute[])->theAttributes.put;
                theAttributes.frag[] -> removeDoneCheck;
                (son1[],attribute[])->theAttributes.frag.notifyAstReplaced;
                (* DANGER!!! *)
                
             else
                theAttributes.noOfSons+1->insertInx;
                attribute[]->theAttributes.append;
                theAttributes.frag[] -> removeDoneCheck;
                (theAttributes[],insertInx)
                  ->theAttributes.frag.notifyListElementInserted;
                (* DANGER!!! *)
                
            if);
            
        if);
        
     #);
  #);

findOutermost:
  (# newAst: ^astInterface.AST;
     editor: ^componentEditor;
  enter newAst[]
  do (if (node[], newAst[]) -> isAncestor then
         search: children.scan
         (#
         do newAst[] -> current.findOutermost -> editor[];
            (if editor[] <> NONE then
                leave search;
            if);
         #);
         (if editor[] = NONE then
             this(componentEditor)[] -> editor[];
         if);
     if);
  exit editor[]
  #);

addOpen:
  (#
     node: ^astInterface.beta.attributeDecl;
     theDoPart: ^astInterface.beta.doPart;
     
  enter node[]
  do
     9
       ->trace
         (# 
         do 'add open'->xT; xN; '------- BEFORE --------'->xT; node[]->xA
         #);
       (#
          openDecl: ^astInterface.beta.attributeDecl;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          theActionPart: ^astInterface.beta.actionPart;
          theAttributes: ^astInterface.beta.attributes;
          gram: @grammar;
          aComp: @betaPattern;
          
       do
          (node[],'open')->betaGram.findAttribute->openDecl[];
          (if openDecl[] = none then
              (if privateFrag[] <> none then
                  (node.frag[],'open::< (# <<SLOT name: doPart>> #)',
                   gram.attributeDecl)->parseText->openDecl[];
                  
               else
                  (node.frag[],'open::< (# do #)',gram.attributeDecl)->parseText
                    ->openDecl[];
                  
              if);
              node[]->aComp.node[];
              openDecl[]->aComp.append;
              openDecl.frag[]->fragmentChanged;
              
           else
              (if openDecl.symbol
               // betaGram.bindingDecl // betaGram.finalDecl then
                  node[]->betaGram.getObjectDescriptor->check
                    ->theObjectDescriptor[];
                  (if theObjectDescriptor[] <> none then
                      theObjectDescriptor.getMainPart->check->theMainPart[];
                      (if theMainPart[] <> none then
                          theMainPart.getActionPart->check->theActionPart[];
                          (if theActionPart[] <> none then
                              theActionPart.getDoPartOpt->check->theDoPart[];
                              (if theDoPart[] <> none then
                                  
                               else
                                  (if privateFrag[] <> none then
                                      (node.frag[],'<<SLOT name: doPart>>',
                                       gram.doPart)->parseText
                                        ->theActionPart.putDoPartOpt;
                                      
                                   else
                                      (node.frag[],'do',gram.doPart)->parseText
                                        ->theActionPart.putDoPartOpt;
                                      
                                  if);
                                  
                              if);
                              
                           else
                              (if privateFrag[] <> none then
                                  (node.frag[],'<<SLOT name: doPart>>',
                                   gram.actionPart)->parseText
                                    ->theMainPart.putActionPart;
                                  
                               else
                                  (node.frag[],'do',gram.actionPart)->parseText
                                    ->theMainPart.putActionPart;
                                  
                              if);
                              
                          if);
                          
                       else
                          (if privateFrag[] <> none then
                              (node.frag[],'(# <<SLOT name: doPart>>  #)',
                               gram.mainPart)->parsetext
                                ->theObjectDescriptor.putMainPart;
                              
                           else
                              (node.frag[],'(# do #)',gram.mainPart)->parsetext
                                ->theObjectDescriptor.putMainPart;
                              
                          if);
                          
                      if);
                      
                  if);
                  
               else
                  none ->openDecl[]; 
              if);
              
          if);
          (if theDoPart[] = none then
              (if openDecl[] <> none then
                  (if privateFrag[] <> none then
                      mps.unExpanded
                        ->openDecl.suffixWalkForProd
                          (#
                             theSlotDesc: ^mps.slotDesc;
                             doPartFrag,frag: ^astInterface.fragmentForm;
                             group: ^astInterface.fragmentGroup;
                             slotName: ^text;
                             theUnExp: ^astInterface.unExpanded;
                             
                          do
                             current[]->theUnExp[];
                             (if theUnExp.isSlot then
                                 theUnExp.theSlot->theSlotDesc[];
                                 comp.name->slotName[];
                                 (if slotname[] = NONE then
                                    'NoName' -> slotName[];
                                 if);
                                 'Open'->slotName.append;
                                 slotName[]->theSlotDesc.name;
                                 slotName[]->betaGram.newDoPartFrag
                                   ->doPartFrag[];
                                 privateFrag.father->group[];
                                 slotName[]->group.findFragment->frag[];
                                 (if frag[] <> none then
                                     frag.root[]->theDoPart[]; 
                                  else
                                     doPartFrag[]
                                       ->group.fragmentList.addFragment;
                                     doPartFrag.root[]->theDoPart[];
                                     
                                 if);
                                 
                             if);
                             
                          #);
                      
                   else
                      gram.doPart
                        ->openDecl.suffixWalkForProd
                          (#  do current[]->theDoPart[];  #);
                      
                  if);
                  (if theDoPart[] <> none then
                      (if node.symbol
                       // gram.patternDecl // gram.simpleDecl then
                            (#
                               innerImp: ^astInterface.beta.imp;
                               theImperatives: ^astInterface.beta.imperatives;
                               
                            do
                               (theDoPart.frag[],'INNER',gram.imp)->parseText
                                 ->innerImp[];
                               theDoPart.getImperatives->theImperatives[];
                               (1,innerImp[])->theImperatives.put;
                               
                            #);
                          
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     9->trace (#  do '------ AFTER --------'->xT; node[]->xA #)
  exit theDoPart[]
  #);
realCreateOpen: (#  exit node[]->addOpen #);

deleteImperative:
  (#
     name: ^text;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.AST;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.imp;
     theImperatives: ^astInterface.beta.imperatives;
     oldies: ^astInterface.astList;
     deleteInx: @integer;
     
  enter name[]
  do
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> '->txt.append;
         name[]->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (if imp[] <> none then
             &mps.astList[]->oldies[];
             imp.sonNo->deleteInx;
             imp[]->oldies.elm[1][];
             deleteInx->theImperatives.delete;
             theImperatives.frag[] -> removeDoneCheck;
             (theImperatives[],deleteInx,1,oldies[])
               ->theImperatives.frag.notifyListElementsDeleted;
             theImperatives.frag[]->fragmentChanged;
             
         if);
         
     if);
     
  #);
generateEvaluation:
  (#
     value: ^atom;
     frag: ^astInterface.fragmentForm;
     eval: ^astInterface.beta.evaluation;
     gram: @grammar;
     consts: ^constants;
     
  enter (frag[],value[],consts[])
  do
     (if value[] = none then
         (frag[],'NONE',gram.imp)->parseText->eval[]; 
     if);
     (if value.type
      // textType then
         (if (value.asTextAtom).value[] = none then
             (frag[],'NONE',gram.imp)->parseText->eval[]; 
          else
             (frag[],(value.asTextAtom).value[])->betaGram.newTextEvaluation
               ->eval[];
             
         if);
         
      // boolType then
         (frag[],(value.asBoolAtom).value)->betaGram.newBoolEvaluation->eval[]; 
      // intType then
         (frag[],(value.asIntAtom).value,consts[])->betaGram.newIntEvaluation
           ->eval[];
         
     if);
     
  exit eval[]
  #);
changeImperative:
  (#
     name: ^text;
     value: ^atom;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldEval,newEval: ^astInterface.beta.evaluation;
     
  enter (name[],value[])
  do
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> '->txt.append;
         name[]->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (theDoPart.frag[],value[],name[]->lookupConstants)->generateEvaluation
           ->newEval[];
         
         (if imp[] <> none then
             imp.getEvaluation->oldEval[];
             newEval[]->imp.putEvaluation;
             imp.frag[] -> removeDoneCheck;
             (oldEval[],newEval[])->imp.frag.notifyAstReplaced;
             imp.frag[]->fragmentChanged;
             
          else
             theDoPart.frag[]->proto.copy->proto[];
             (theDoPart.frag[],value[],name[]->lookupConstants)
               ->generateEvaluation->proto.putEvaluation;
             (1,proto[])->theImperatives.insert;
             theDoPart.frag[] -> removeDoneCheck;
             (theImperatives[],1)->theDoPart.frag.notifyListElementInserted;
             theDoPart.frag[]->fragmentChanged;
             
         if);
         
     if);
     
  #);
changeData:
  (#
     newData: ^parameters;
     force: @boolean;
     oldValue: ^atom;
     defaultValue: ^atom;
     x,y,width,height: @integer;
     doChangePosition,doChangeSize: @boolean;
     
  enter (newData[],force)
  do
     maxint->x->y->width->height;
     newData.data.storage.scan
       (# name: ^text; ignoreDefault: @boolean; 
       do
          (if true
           // 'x'->current.key.equalNCS then
              true->doChangePosition; 'x'->newData.getInt->x; 
           // 'y'->current.key.equalNCS then
              true->doChangePosition; 'y'->newData.getInt->y; 
           // 'height'->current.key.equalNCS then
              true->doChangeSize; 'height'->newData.getInt->height; 
           // 'width'->current.key.equalNCS then
              true->doChangeSize; 'width'->newData.getInt->width; 
           // 'iconName'->current.key.equalNCS then
              ('thePixmap.read',current.value[])->changeImperative
           // 'ID'->current.key.equalNCS then
              
           // 'type'->current.key.equalNCS then
              
           else
              (if 'label'->current.key.equalNCS then true->ignoreDefault if);
              current.key[]->data.data.lookup->oldValue[];
              (if (not force) and (current.value[]->oldValue.equal) then
                  
               else
                  current.key[]->defaultData.data.lookup->defaultValue[];
                  4
                    ->trace
                      (# 
                      do
                         '    defaultValue = '->xT;
                         (if defaultValue[] = none then
                             'NONE'->xT; 
                          else
                             'defined'->xT; 
                         if);
                         
                      #);
                  current.key[]->name[];
                  (if (not ignoreDefault) and
                  ((not (defaultValue[] = none )) and
                   (current.value[]->defaultValue.equal)) then
                      4->trace (#  do '     DELETED'->xT;  #);
                      name[]->deleteImperative;
                      
                   else
                      4->trace (#  do '     WRITTEN'->xT;  #);
                      (name[],current.value[])->changeImperative;
                      
                  if);
                  
              if);
              
          if);
          
       #);
     (if doChangePosition then
         (if x = maxint then 'x'->data.getInt->x if);
         (if y = maxint then 'y'->data.getInt->y if);
         (x,y)->changePosition;
         
     if);
     (if doChangeSize then
         (if width = maxint then 'width'->data.getInt->width if);
         (if height = maxint then 'height'->data.getInt->height if);
         (width,height)->changeSize;
         
     if);
     
  #);
reConfigure:
  (#
     doLeft,doTop,doRight,doBottom: @boolean;
     bounds: ^rectangle;
     newOwner: ^componentEditor;
     
  enter (doLeft,doTop,doRight,doBottom)
  do
     frame->bounds[];
     (bounds[],item.father[],contents)->translateRect;
     (bounds,doLeft,doTop,doRight,doBottom)
       ->(contents).rubber
         (#
            gridSize::  (#  do THIS(graphicalEditor).gridSize->value #);
            gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #)
         #)->bounds;
     (bounds.topLeft,contents,item.father[])->translate->bounds.topLeft;
     (bounds.bottomRight,contents,item.father[])->translate->bounds.bottomRight;
     (THIS(componentEditor)[],bounds[])->makeResizeOperation;
     
  #);
traverse:
  (# forEach:< traverseCallback; 
  do (THIS(componentEditor)[],&forEach[])->recTraverse; 
  #);
traverseCallback:
  (# current: ^componentEditor; continue: @boolean; 
  enter current[]
  do true->continue; INNER ; 
  exit continue
  #);
recTraverse:
  (# callback: ^traverseCallback; editor: ^componentEditor; 
  enter (editor[],callback[])
  do
     (if editor[]->callback then
         editor.children.scan
           (#  do (current[],callback[])->&recTraverse;  #);
         
     if);
     
  #);
closeWindowItem:
  (#  do item.close; none ->theWindowItem[]; none ->item[];  #);
changeOwner:
  (# newOwner: ^componentEditor; 
  enter newOwner[]
  do delete; newOwner[]->owner[]; reInsert; 
  #);
changePosition:
  (#
     x,y: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation,oldEval,newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
     
  enter (x,y)
  do
     (if (THIS(componentEditor)[] <> contentsEditor) or
     THIS(graphicalEditor).private.allowPositionChange then
         3->trace (#  do 'ChangePosition: '->xT;  #);
         forInitStatements->findOpenDoPart->theDoPart[];
         (if theDoPart[] <> none then
             theDoPart.getImperatives->theImperatives[];
             '<<evaluation>> -> position'->txt.append;
             (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
             (mps[],theImperatives[],proto[])->listSearch->imp[];
             (if imp[] <> none then
                 imp.getEvaluation->oldEval[];
                 (theDoPart.frag[],x,y)->betaGram.newPointEvaluation->newEval[];
                 newEval[]->imp.putEvaluation;
                 imp.frag[] -> removeDoneCheck;
                 (oldEval[],newEval[])->imp.frag.notifyAstreplaced;
                 imp.frag[]->fragmentChanged;
                 
              else
                 theDoPart.frag[]->proto.copy->proto[];
                 (theDoPart.frag[],x,y)->betaGram.newPointEvaluation
                   ->proto.putEvaluation;
                 (1,proto[])->theImperatives.insert;
                 theDoPart.frag[] -> removeDoneCheck;
                 (theImperatives[],1)->theDoPart.frag.notifyListElementInserted;
                 theDoPart.frag[]->fragmentChanged;
                 
             if);
             
         if);
         
      else
         
     if);
     
  #);
changeSize:
  (#
     width,height: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation,oldEval,newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldWidth,oldHeight: @integer;
     
  enter (width,height)
  do
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> size'->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (if imp[] <> none then
             imp.getEvaluation->oldEval[];
             (theDoPart.frag[],width,height)->betaGram.newPointEvaluation
               ->newEval[];
             newEval[]->imp.putEvaluation;
             imp.frag[] -> removeDoneCheck;
             (oldEval[],newEval[])->imp.frag.notifyAstreplaced;
             imp.frag[]->fragmentChanged;
             
          else
             theDoPart.frag[]->proto.copy->proto[];
             (theDoPart.frag[],width,height)->betaGram.newPointEvaluation
               ->proto.putEvaluation;
             (1,proto[])->theImperatives.insert;
             theDoPart.frag[] -> removeDoneCheck;
             (theImperatives[],1)->theDoPart.frag.notifyListElementInserted;
             theDoPart.frag[]->fragmentChanged;
             
         if);
         
     if);
     
  #);
changeName:
  (# oldName,newName: ^text; isIdentifier: @boolean; isEqual: @boolean
  enter newName[]
  do true -> this(graphicalEditor).private.handlingNotification;
     comp.name->oldName[];
     newName[]->checkIdentifier->isIdentifier;
     (if isIdentifier then
         (if oldName[] = NONE then
            FALSE -> isEqual;
         else
            newName[]->oldName.equalNCS->isEqual;
         if);
         (if not isEqual then
               (#
                  theNames: ^astInterface.beta.names;
                  theNameDcl: ^astInterface.beta.nameDcl;
                  theNameDecl: ^astInterface.nameDecl;
                  oldNameDcl: ^astInterface.beta.nameDcl;
                  
               do
                  node[]->betaGram.getNames->theNames[];
                  (if theNames[] <> none then
                      1->theNames.get->oldNameDcl[];
                      (theNames.frag[],newName[])->betaGram.newNameDcl
                        ->theNameDcl[];
                      (1,theNameDcl[])->theNames.put;
                      theNames.frag[] -> removeDoneCheck;
                      (oldNameDcl[],theNameDcl[])
                        ->theNames.frag.notifyAstReplaced;
                      theNames.frag[]->fragmentChanged;
                      
                  if);
                  
               #);
             (if owner[] <> none then
                 (if isPrivateToOwner then
                     'private.'->oldName.prepend; 'private.'->newName.prepend; 
                 if);
                 (oldName[],newName[])->owner.updateOpen;
                 
             if);
             
         if);
         
     if);
     
    false -> this(graphicalEditor).private.handlingNotification;
  #);
openSubEditor: (#  do editAttributes;  #);
frame:
  (# r: ^rectangle; 
  enter (#  enter r[] do r->item.frame;  #)
  exit (#  do &rectangle[]->r[]; item.frame->r;  exit r[] #)
  #);
delete:
  (#
     father: ^astInterface.list;
     deleteInx: @integer;
     oldies: ^astInterface.astList;
     
  do
     closeWindowItem;
     node.father->father[];
     node.sonNo->deleteInx;
     deleteInx->father.delete;
     &MPS.astList[]->oldies[];
     node[]->oldies.elm[1][];
     father.frag[] -> removeDoneCheck;
     (father[],deleteInx,1,oldies[])->father.frag.notifyListElementsDeleted;
     father.frag[]->fragmentChanged;
     THIS(componentEditor)[]->owner.children.delete;
     comp.name->owner.deleteOpenImp;
     false->selected;
     
  #);
reInsert:
  (# 
  do THIS(componentEditor)[]->owner.appendChild; createTheWindowItem; 
  #);
newEditor:
  (# theEditor: ^componentEditor; className: ^text; 
  enter className[]
  <<SLOT graphicalEditorNewEditor:DoPart>>
  exit theEditor[]
  #);
generateOpenImp:
  (#
     name: ^text;
     theImp: ^astInterface.beta.imp;
     frag: ^astInterface.fragmentForm;
     
  enter frag[]
  do
     comp.name->name[];
     
     (if name[] <> NONE then
        (frag[],name[],isPrivateToOwner)
          ->betaGram.newOpenStatement
          ->theImp[];
     if);
  exit theImp[]
  #);
isPrivateToOwner: booleanValue
  (# 
  do
     (if owner[] = none then
         false->value; 
      else
         not
         (node.frag[] =
          owner.node.frag[])->value;
         
     if);
     
  #);
findOpenDoPart:
  (#
     theDoPart:
       ^astInterface.beta.doPart;
     purpose: @integer;
     
  enter purpose
  do
       (# 
       do
          (node[],purpose)
            ->realFindOpenDoPart
            ->theDoPart[];
          
       #);
     
  exit theDoPart[]
  #);
appendOpenImp:
  (#
     theDoPart:
       ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure: (#  do  #);
     
  enter imp[]
  do
       (#
          theImperatives:
            ^astInterface.beta.
               imperatives;
          insertInx: @integer;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              theDoPart.getImperatives->theImperatives[];
              l: theImperatives.iterate
                (# 
                do
                   current.sonNo->insertInx;
                   (if current.symbol = betaGram.innerImp then leave l;  if);
                   
                #);
              (insertInx,imp[])->theImperatives.insert;
              theImperatives.frag[] -> removeDoneCheck;
              (theImperatives[],insertInx)
                ->theImperatives.frag.notifyListElementInserted;
              theImperatives.frag[]->fragmentChanged;
              
          if);
          
       #);
     
  #);
deleteOpenImp:
  (#
     theDoPart: ^astInterface.beta.doPart;
     name: ^text;
     failure: (#  do  #);
     
  enter name[]
  do (if name[] <> NONE then
       (#
          theImperatives: ^astInterface.beta.imperatives;
          deleteInx: @integer;
          oldies: ^astInterface.astList;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              &MPS.astList[]->oldies[];
              theDoPart.getImperatives->theImperatives[];
              l: theImperatives.iterate
                (#
                   theObjectDenotation: ^astInterface.beta.objectDenotation;
                   theNameApl: ^astInterface.beta.nameApl;
                   theText: ^text;
                   theAttributeDenotation: ^astInterface.ast;
                   theRemote: ^astInterface.beta.remote;
                   
                do
                   (if current.symbol = betaGram.objectDenotation then
                       current[]->theObjectDenotation[];
                       theObjectDenotation.getAttributeDenotation
                         ->theAttributeDenotation[];
                       (if theAttributeDenotation.symbol = betaGram.remote then
                           theAttributeDenotation[]->theRemote[];
                           theRemote.getNameApl->theNameApl[];
                           theNameApl.getText->theText[];
                           (if 'open'->theText.equalNCS then
                               theRemote.getAttributeDenotation
                                 ->theAttributeDenotation[];
                               (if theAttributeDenotation.symbol
                                // betaGram.remote then
                                   theAttributeDenotation[]->theRemote[];
                                   theRemote.getNameApl->theNameApl[];
                                   
                                // betaGram.nameApl then
                                   theAttributeDenotation[]->theNameApl[]; 
                                else
                                   none ->theNameApl[]; 
                               if);
                               (if theNameApl[] <> none then
                                   theNameApl.getText->theText[];
                                   (if name[]->theText.equalNCS then
                                       current.sonNo->deleteInx;
                                       current[]->oldies.elm[1][];
                                       leave l;
                                       
                                   if);
                                   
                               if);
                               
                           if);
                           
                       if);
                       
                   if);
                   
                #);
              (if deleteInx <> 0 then
                  deleteInx->theImperatives.delete;
                  theImperatives.frag[] -> removeDoneCheck;
                  (theImperatives[],deleteInx,1,oldies[])
                    ->theImperatives.frag.notifyListElementsDeleted;
                  theImperatives.frag[]->fragmentChanged;
                  
              if);
              
          if);
          
       #);
     if);
  #);
updateOpen:
  (# oldName,newName: ^text; 
  enter (oldName[],newName[])
  do (if oldName[] <> NONE then
       (#
          oldStmProto: ^astInterface.beta.imp;
          oldStm: ^astInterface.beta.imp;
          newStm: ^astInterface.beta.imp;
          frag: ^astInterface.fragmentForm;
          txt: @text;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
          gram: @grammar;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] <> none then
              makeFragmentForm->frag[];
              oldName[]->txt.append;
              '.open'->txt.append;
              (makeFragmentForm,txt[],gram.imp)->parseText->oldStmProto[];
              txt.clear;
              newName[]->txt.append;
              '.open'->txt.append;
              theDoPart.getImperatives->theImperatives[];
              (theImperatives.frag[],txt[],gram.imp)->parseText->newStm[];
              (mps[],theImperatives[],oldStmProto[])->listSearch->oldStm[];
              (if oldStm[] <> none then
                  (oldStm.sonNo,newStm[])->theImperatives.put;
                  theImperatives.frag[] -> removeDoneCheck;
                  (oldStm[],newStm[])->theImperatives.frag.notifyAstReplaced;
                  theImperatives.frag[]->fragmentChanged;
                  
              if);
              
          if);
          
       #);
     if);
  #);
findVirtual:
  (# name: ^text; theVirtual: ^astInterface.beta.attributeDecl; 
  enter name[]
  do
       (# isEvent: @boolean; currentNode: ^astInterface.beta.attributeDecl; 
       do
          (if name.length >= 2 then
              'on'->((1,2)->name.sub).equal->isEvent; 
           else
              false->isEvent; 
          if);
          node[]->currentNode[];
          (if isEvent then
              (currentNode[],'eventHandler')->betaGram.findAttribute
                ->currentNode[];
              
          if);
          (if currentNode[] <> none then
              (currentNode[],name[])->betaGram.findAttribute->theVirtual[]; 
          if);
          
       #);
     
  exit theVirtual[]
  #);
createVirtual:
  (# name: ^text; theVirtual: ^astInterface.beta.attributeDecl; 
  enter name[]
  do
       (#
          isEvent: @boolean;
          currentNode: ^astInterface.beta.attributeDecl;
          theAttribute: ^astInterface.beta.attributeDecl;
          aComp: @betaPattern;
          
       do
          (if name.length >= 2 then
              'on'->((1,2)->name.sub).equal->isEvent; 
           else
              false->isEvent; 
          if);
          node[]->currentNode[]->theAttribute[];
          (if isEvent then
              (currentNode[],'eventHandler')->betaGram.findAttribute
                ->currentNode[];
              (if currentNode[] = none then
                  (theAttribute.frag[],'eventHandler',none )
                    ->betaGram.newVirtualBinding->currentNode[];
                  theAttribute[]->aComp.node[];
                  currentNode[]->aComp.append;
                  currentNode.frag[]->fragmentChanged;
                  
              if);
              
          if);
          (currentNode.frag[],name[],none )->betaGram.newVirtualBinding
            ->theVirtual[];
          currentNode[]->aComp.node[];
          theVirtual[]->aComp.append;
          theVirtual.frag[]->fragmentChanged;
          
       #);
     
  exit theVirtual[]
  #);
isPrivateToWindow: booleanValue
  (#  do not (node.frag[] = THIS(graphicalEditor).node.frag[])->value;  #);
  

-- graphicalEditorEnvLib: Attributes --
fragmentChanged:
  (# frag: ^astInterface.fragmentForm; 
  enter frag[]
  do frag.father->onGroupChanged; 
  #);
initializeCustomPalette: (#  <<SLOT initializeCustomPalette:DoPart>> #);
realFindOpenDoPart:
  (#
     theDoPart:
       ^astInterface.beta.doPart;
     node:
       ^astInterface.beta.attributeDecl;
     purpose: @integer;
     
  enter (node[],purpose)
  do
       (#
          contents:
            ^astInterface.beta.
               attributeDecl;
          openDecl: ^astInterface.beta.attributeDecl;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          theActionPart: ^astInterface.beta.actionPart;
          theAst: ^astInterface.AST;
          theUnExpanded: ^astInterface.unExpanded;
          theSlot: ^astInterface.slotDesc;
          doPartFrag: ^astInterface.fragmentForm;
          group: ^astInterface.fragmentGroup;
          
       do
          node.frag.father->group[];
          (if purpose
           // forOpenStatements then
              (node[],'contentsType')->betaGram.findAttribute->contents[];
              (if contents[] <> none then
                  (if contents.symbol
                   // betaGram.bindingDecl // betaGram.finalDecl then
                      contents[]->node[]; 
                  if);
                  
              if);
              
          if);
          (node[],'open')->betaGram.findAttribute->openDecl[];
          (if openDecl[] <> none then
              openDecl[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
              theObjectDescriptor.getMainPart->theMainPart[];
              theMainPart.getActionPart->theActionPart[];
              theActionPart.getDoPartOpt->theAst[];
              (if theAst.symbol = MPS.unExpanded then
                  (if group[] <> none then
                      theAst[]->theUnExpanded[];
                      (if theUnExpanded.isSlot then
                          theUnExpanded.theSlot->theSlot[];
                          theSlot.name->group.findBodyFragment->doPartFrag[];
                          (if doPartFrag[] <> none then
                              doPartFrag.root[]->theDoPart[]; 
                          if);
                          
                      if);
                      
                  if);
                  
               else
                  theAst[]->theDoPart[]; 
              if);
              
          if);
          
       #);
     
  exit theDoPart[]
  #);
registerConstants:
  (# name: ^text; consts: ^constants
  enter (name[],consts[])
  do (name[],consts[])->private.theConstants.define
  #);
lookupConstants:
  (# name: ^text; consts: ^constants
  enter name[]
  do name[]->private.theConstants.lookup->consts[]
  exit consts[]
  #);
makeUniqueName:
  (#
     node: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     name,newName: ^text;
     
  enter node[]
  do
     node[]->betaGram.getName->name[];
     node.father->theAttributes[];
     name.copy->newName[];
     'Copy'->newName.append;
     
  exit newName[]
  #);
defined: booleanValue
  (# name: ^text;  enter name[] do name[]->factory.defined->value;  #);
lookup:
  (# name: ^text; theInstantiator: ^instantiator; 
  enter name[]
  do name[]->factory.lookup->theInstantiator[]; 
  exit theInstantiator[]
  #);
instantiate:
  (#
     theGraphicalEditor: ^graphicalEditor;
     name: ^text;
     theWindowItemEditor: ^graphicalEditor.componentEditor;
     
  enter (theGraphicalEditor[],name[])
  do
     (theGraphicalEditor[],name[])->factory.instantiate->theWindowItemEditor[]; 
  exit theWindowItemEditor[]
  #);
check:
  (# anAst: ^astInterface.ast; 
  enter anAst[]
  do
     (if anAst[] <> none then
         (if anAst.kind <> mps.kinds.interior then none ->anAst[];  if); 
     if);
     
  exit anAst[]
  #);
forInitStatements: (#  exit 1 #);
forOpenStatements: (#  exit 2 #);
getAttributes:
  (#
     node: ^astInterface.beta.attributeDecl;
     theAttributeList: ^attributeList;
     getPrivateAttributes:
       (#
          node: ^astInterface.beta.attributeDecl;
          theAttributes: ^astInterface.beta.attributes;
          frag: ^astInterface.fragmentForm;
          theDescriptorForm: ^astInterface.beta.descriptorForm;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          
       enter node[]
       do
          node[]->betaGram.getPrivateFragment->frag[];
          (if frag[] <> none then
              (if frag.category = betaGram.descriptorForm then
                  frag.root[]->theDescriptorForm[];
                  theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
                  theObjectDescriptor.getMainPart->theMainPart[];
                  theMainPart.getAttributes->theAttributes[];
                  
              if);
              
          if);
          
       exit theAttributes[]
       #);
     addAttributes:
       (# theAttributes: ^astInterface.beta.attributes
       enter theAttributes[]
       do
          (if theAttributes[] <> none then
              theAttributes.iterate
                (#  do current[]->theAttributeList.append;  #);
              
          if);
          
       #);
     addImperatives:
       (#
          node: ^astInterface.beta.attributeDecl;
          theNameApl: ^astInterface.beta.nameApl;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
          
       enter node[]
       do
          (node[],forInitStatements)->realFindOpenDoPart->theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives->theImperatives[];
              theImperatives.newScan
                (# doMatch: @boolean; 
                do
                   (mps[],current[],proto1[])->match->doMatch;
                   (if not doMatch then
                       (mps[],current[],proto2[])->match->doMatch; 
                   if);
                   (if doMatch then
                       current[]->theImperativeList.prepend; 
                   if);
                   
                #);
              
          if);
          
       #);
     theImperativeList: ^imperativeList;
     proto1,proto2: ^astInterface.AST;
     gram: @grammar;
     contentsType,mainNode: ^astInterface.beta.attributeDecl;
     
  enter node[]
  do
     (makeFragmentForm,'<<evaluation>> -> <<nameApl>>',gram.imp)->parseText
       ->proto1[];
     (makeFragmentForm,'<<evaluation>> -> <<remote>>',gram.imp)->parseText
       ->proto2[];
     &attributeList[]->theAttributeList[];
     theAttributeList.init;
     &imperativeList[]->theImperativeList[];
     theImperativeList.init;
     node[]->mainNode[];
     (node[],'contentsType')->betaGram.findAttribute->contentsType[];
     (if contentsType[] <> none then
         (if contentsType.symbol
          // gram.bindingDecl // gram.finalDecl then
             contentsType[]->mainNode[]; 
         if);
         
     if);
     mainNode[]->betaGram.getAttributes->addAttributes;
     mainNode[]->getPrivateAttributes->addAttributes;
     node[]->addImperatives;
     
  exit (theAttributeList[],theImperativeList[])
  #);
getSuperPattern:
  (#
     node,superNode: ^astInterface.beta.attributeDecl;
     theNameApl: ^astInterface.beta.nameApl;
     theNameDcl: ^astInterface.beta.nameDcl;
     theNames: ^astInterface.beta.names;
     dest: ^astInterface.ast;
     
  enter node[]
  do
     node[]->betaGram.getPrefixNameApl->theNameApl[];
     (if theNameApl[] <> none then
         (mps[],theNameApl[])->followSemanticLink->dest[];
         (if (dest[] <> none ) and (dest.symbol = betaGram.nameDcl) then
             dest[]->theNameDcl[];
             theNameDcl.father->theNames[];
             theNames.father->superNode[];
             
         if);
         
     if);
     
  exit superNode[]
  #);
insert:
  (# editor: ^graphicalEditor; 
  enter editor[]
  do editor[]->private.editors.append; 
  #);
delete:
  (# editor: ^graphicalEditor; 
  enter editor[]
  do editor[]->private.editors.remove; 
  #);
addInclude:
  (# group: ^astInterface.fragmentGroup; path: ^text; 
  enter (group[],path[])
  <<SLOT addInclude:DoPart>>
  #);
hasInclude: booleanValue
  (#
     group: ^astInterface.fragmentGroup;
     path: ^text;
     
  enter (group[],path[])
  <<SLOT hasInclude:DoPart>>
  #);
  

-- graphicalEditorEnvPrivate: Descriptor --
(#
   compiledWindowitems: @patternDictionary;
   editors: @list
     (#
        element:: graphicalEditor;
        remove: (# elm: ^element;  enter elm[] do elm[]->at->delete #);
        
     #);
   theConstants: @constantTable;
   borderConsts: @borderStyleConstants;
   hAlignmentConsts: @horAlignmentConstants;
   vAlignmentConsts: @verAlignmentConstants;
   preferences: @
     (#
        version: (#  exit 1 #);
        init: (#  <<SLOT preferencesInit:DoPart>> #);
        read:
          (# 
          <<SLOT preferencesRead:DoPart>>
          #);
        write:
          (# 
          <<SLOT preferencesWrite:DoPart>>
          #);
        display:
          (# 
          do
             '----- preferences -----'->putLine;
             entries.scan
               (# 
               do
                  current.name[]->putLine;
                  current.grouping[]->putLine;
                  current.path[]->putLine;
                  current.fragment[]->putLine;
                  
               #);
             
          #);
        paletteEntry:
          (# grouping: ^text; name: ^text; path: ^text; fragment: ^text; 
          #);
        addPaletteEntry:
          (# entry: ^paletteEntry; 
          do &paletteEntry[]->entry[]; INNER ; entry[]->entries.append; 
          #);
        entries: @sequence (# element:: paletteEntry;  #);
        preferencesFileName:
          (# fileName: ^text; 
          <<SLOT preferencesFileName:DoPart>>
          exit fileName[]
          #);
        
     #);
   
#)  

-- graphicalEditorPrivateAttributes: Descriptor --
(#
   handlingNotification: @boolean;
   groups: @list (# element:: MPS.fragmentGroup;  #);
   fragments: @list (# element:: MPS.fragmentForm #);
   observers: @list (# element:: fragmentFormObserver #);
   touched: @integer;
   gridSize: @integer;
   thePropertyInspector: @propertyInspector
     (#
        data: ^parameters;
        activate:
          (# 
          do
             (if active then
                 bringToFront
              else
                 true->active; update; show; bringToFront
             if)
          #);
        deActivate: (#  do (if active then hide; false->active if) #);
        active: @boolean;
        propertyChanged:: 
          (#
             newData: ^parameters;
             theAtom: ^atom;
             asBool:
               (# str: ^text; b: @boolean
               enter str[]
               do
                  (if str[] <> none then
                      (if true
                       // 'true'->str.equalNCS then
                          true->b
                       // 'false'->str.equalNCS then
                          false->b
                      if)
                  if)
               exit b
               #);
             asInt:
               (# str: ^text; int: @integer
               enter str[]
               do
                  l:
                  (if str[] <> none then
                      str.asInt (# syntaxError::  (#  do leave l #) #)->int
                  if)
               exit int
               #)
          do (if not fragmentLocked then
                 &parameters[]->newData[];
                 newData.init;
                 name[]->data.find->theAtom[];
                 (if theAtom[] <> none then
                     (if theAtom.type
                      // textType then
                         (name[],value[])->newdata.setText
                      // boolType then
                         (name[],value[]->asBool)->newdata.setBool
                      // intType then
                         (name[],value[]->asInt)->newdata.setInt
                     if);
                     selection.scan
                     (#  do (current[],newData[])->makeChangeOperation #)
                 if);
             if);
          #);
        nameChanged:: 
          (# 
          do (if not fragmentLocked then
                 (if selection.size = 1 then
                     name[]->(selection.first).changeName
                 if)
             if);
          #);
        editScript:: 
          (# 
          do (if not fragmentLocked then
                 (if selection.size = 1 then
                     name[]->(selection.first).editVirtual
                 if);
             if);
          #);
        update:
          (# theEditor: ^componentEditor; inst: ^instantiator
          do
             (if active then
                 (if not selection.empty then
                     selection.extractData->data[];
                     (if data[] <> none then
                         inspectorPane.propertyPane.scan
                           (# 
                           do
                              current[]
                                ->qua
                                  (# as:: propertyView
                                  do
                                     (if (thisObj.name->data.find) = none then
                                         thisObj.close
                                     if)
                                  #)
                           #);
                         data.data.storage.scan
                           (# propView: ^propertyView
                           do
                              current.key[]->inspectorPane.propertyPane.find
                                ->propView[];
                              (if current.value.type
                               // intType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asIntAtom).value)
                                        ->makeIntProperty
                                   else
                                      (if true
                                       // propView## <= textPropertyView## then
                                          propView[]
                                            ->qua
                                              (# as:: textPropertyView
                                              do
                                                 (current.value.asIntAtom).value
                                                   ->thisObj.intValue
                                              #)
                                       // propView## <= constantPropertyView##
                                       then
                                          propView[]
                                            ->qua
                                              (# as:: constantPropertyView
                                              do
                                                 (current.value.asIntAtom).value
                                                   ->thisObj.value
                                              #)
                                      if)
                                  if)
                               // boolType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asBoolAtom).value)
                                        ->makeBoolProperty
                                   else
                                      propView[]
                                        ->qua
                                          (# as:: boolPropertyView
                                          do
                                             (current.value.asBoolAtom).value
                                               ->thisObj.value
                                          #)
                                  if)
                               // textType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asTextAtom).value[])
                                        ->makeTextProperty
                                   else
                                      propView[]
                                        ->qua
                                          (# as:: textPropertyView
                                          do
                                             (current.value.asTextAtom).value[]
                                               ->thisObj.value
                                          #)
                                  if)
                              if)
                           #);
                         inspectorPane.propertyPane.changed
                     if);
                     (if selection.size = 1 then
                         (selection.first).comp.name->inspectorPane.name;
                         (selection.first).className[]->lookup->inst[];
                         (if inst[] <> none then
                             inst.scripts[]->inspectorPane.scripts
                         if);
                         
                      else
                         none ->inspectorPane.name; none ->inspectorPane.scripts
                     if)
                  else
                     inspectorPane.propertyPane.scan
                       (#  do current.close #);
                     none ->inspectorPane.name;
                     none ->inspectorPane.scripts
                 if)
             if);
             
          #);
        open:: 
          (# 
          do hide; inspectorpane.propertypane.scan (#  do current.close #)
          #);
        eventHandler:: 
          (#
             onAboutToClose:: 
               (#  do thePropertyInspector.deactivate; false->okToClose #)
          #)
     #);
   hasPrivateAttributes: @boolean;
   allowPositionChange: @boolean;
   selectionChanged: @boolean;
   selectionTimer: @editorTimer
     (#
        action:: 
          (# 
          do
             stop;
             (if selectionChanged then
                 selection.moveControlPoints;
                 thePropertyInspector.update;
                 false->selectionChanged;
                 
             if);
             
          #);
        
     #);
   forbidCodeChanges,dontHandleFrameChanged: @boolean;
   controlPoints: @controlPointEnv;
   uniqueID: @integer;
   lastSaveOperation: ^operation;
   executeWindow:
     (# windowPattern: ##window; theWindow: ^window
     enter windowPattern##
     do &windowPattern[]->theWindow[]; theWindow.open
     #);
   executeCanvas:
     (# canvasPattern: ##canvas; theCanvas: ^canvas
     enter canvasPattern##
     do
        &canvasPattern[]->theCanvas[];
        contents->theCanvas.open;
        &theCanvas.mouseDownAction (#  do theCanvas.drag #)[]
          ->theCanvas.appendAction
     #);
   theFileMenu: @<<SLOT graphicalEditorFileMenu:Descriptor>>;
   theEditMenu:
     @<<SLOT graphicalEditorEditMenu:Descriptor>>;
   theAlignMenu: @<<SLOT graphicalEditorAlignMenu:Descriptor>>;
   (*
    * Fragment handler
    *)
   (*
    * Undo and redo
    *)
   undoStack: @stack
     (# element:: operation; 
     #);
   redoStack: @stack
     (# element:: operation; 
     #);
   (*
    * Clipboard
    *)
   theClipBoard: @clipboard;
   (*
    * Mode
    *)
   mode: @integer;
   (* End of mode *)
   names: [29] ^text;
   initNames:
     (# 
     do
        'interfaceObject'
          ->names[1][];
        'windowitem'->names[2][];
        'separator'->names[3][];
        'canvas'->names[4][];
        'abstractScroller'
          ->names[5][];
        'scroller'->names[6][];
        'textEditor'->names[7][];
        'control'->names[8][];
        'button'->names[9][];
        'pushButton'->names[10][];
        'iconButton'->names[11][];
        'optionButton'->names[12][];
        'staticText'->names[13][];
        'toggleButton'->names[14][];
        'radioButton'->names[15][];
        'checkBox'->names[16][];
        'scrollbar'->names[17][];
        'editText'->names[18][];
        'textField'->names[19][];
        'scrollList'->names[20][];
        'textScrollList'->names[21][];
        'window'->names[22][];
        'menu'->names[23][];
        'menubar'->names[24][];
        'menuitem'->names[25][];
        'dynamicMenuitem'->names[26][];
        'scrollbar'->names[27][];
        'separator'->names[28][];
        'rect'->names[29][];
        
     #);
   contentsEditor: ^componentEditor;
   isOpen: @boolean;
   palette: reciever
     (#
        hilite:: 
          (# 
          do
             graphics
               (#
                  overrideChildren::  (#  do true->value #);
                  h,v: @integer;
                  
               do
                  size->(h,v);
                  transferModes.xorBlend->pen.mode;
                  2->pen.size;
                  ((0+2,0+2),(h-2,v-2))->drawRect;
                  
               #);
             
          #);
        grouping: ^text;
        lowlite:: 
          (# 
          do
             graphics
               (#
                  overrideChildren::  (#  do true->value #);
                  h,v: @integer;
                  
               do
                  size->(h,v);
                  transferModes.xorBlend->pen.mode;
                  2->pen.size;
                  ((0+2,0+2),(h-2,v-2))->drawRect;
                  
               #);
             
          #);
        drageeType:: proxy;
        accept::  (#  do (* not dragee.palette->value *) false->value #);
        recieve::  (#  do grouping[]->dragee.abstract #);
        theRow: @row
          (#
             open:: 
               (# 
               do 2 -> distance;
                  (552,40)->size; true->bindRight; true->bindBottom; 
               #);
             
          #);
        x,y: @integer;
        paletteItem: iconButton
          (#
             name:
               (# 
               enter (#  enter theName[] do theName[]->label;  #)
               exit theName[]
               #);
             theName: ^text;
             open:: 
               (# 
               do disableDefaultBehaviour; (30,30)->size; false->showLabel; 
               #);
             eventHandler:: 
               (#
                  onMouseDown:: 
                    (# p: @point; 
                    do
                       (localPosition,THIS(paletteItem)[],paletteTabber[])
                         ->translate->p;
                       (theName[],p,THIS(mouseDown)[])->mousedownInItem;
                       
                    #);
                  
               #);
             
          #);
        addPaletteItem:
          (# icon: ^pixmap; name: ^text; 
          enter (icon[],name[])
          do
               (# theItem: ^paletteItem; 
               do
                  &paletteItem[]->theItem[];
                  theRow[]->theItem.open;
                  icon[]->theItem.icon;
                  name[]->theItem.name;
                  
               #);
             
          #);
        findPaletteItem:
          (# pt: @point; thePaletteItem: ^paletteItem
          enter pt
          do
             search: theRow.scan
               (# r: @rectangle
               do
                  current.frame->r;
                  (if pt->r.containsPoint then
                      current[]->thePaletteItem[]; leave search
                  if)
               #)
          exit thePaletteItem[]
          #);
        open::<  (#  do true->bindRight; (552,40)->size; theRow.open;  #)
     #);
   makePalette:
     (# aPalette: ^palette
     do &palette[]->aPalette[]; paletteTabber[]->aPalette.open
     exit aPalette[]
     #);
   itemDictionary: @patternDictionary;
   aTimer: @editorTimer
     (# action::  (#  do paletteTabber.checkStatus #) #);
   paletteTabber: @tabControl
     (#
        palettes: @dictionary (# element:: palette #);
        checkStatus:
          (# thePalette: ^palette; theItem: ^palette.paletteItem; pt: @point
          do
             (if selection = none then
                 ''->status
              else
                 (selection).page->thePalette[];
                 mouse.globalPosition->pt;
                 pt->THIS(window).globalToLocal->pt;
                 pt.v->pt.v (* Adjust for menubar - bug in GUIenv *) ;
                 (pt,THIS(window).contents,thePalette[])->translate->pt;
                 pt->thePalette.findPaletteItem->theItem[];
                 (if theItem[] = none then
                     ''->status
                  else
                     theItem.name->status
                 if)
             if)
          #);
        addPaletteItem:
          (# icon: ^pixmap; name,grouping: ^text; 
          enter (grouping[],icon[],name[])
          do
               (# thePalette: ^palette
               do
                  grouping[]->palettes.lookup->thePalette[];
                  (if thePalette[] = none then
                      (grouping[],makePalette->thePalette[])->addPalette
                  if);
                  (icon[],name[])->thePalette.addPaletteItem
               #);
             
          #);
        add:
          (# name: ^text; thePalette: ^palette; theTab: ^tab
          enter (thePalette[],name[])
          do
             &tab[]->theTab[];
             name[]->theTab.label;
             thePalette[]->theTab.page;
             theTab.open;
             
          #);
        addPalette:
          (# name: ^text; thePalette: ^palette; 
          enter (name[],thePalette[])
          do
             name[]->thePalette.grouping[];
             (thePalette[],name[])->add;
             (name[],thePalette[])->palettes.define
          #);
        open::< 
          (# 
          do
             true->bindRight;
             false->border.visible;
             (540,68)->size;
             (0,0)->position;
             palettes.init;
             
          #)
     #);
   statusbar: @canvas
     (#
        open::< 
          (# 
          do
             true->bindRight;
             5->border.style;
             true->border.visible;
             (540,24)->size;
             statusLabel.open;
             (0,68)->position;
             
          #);
        statusLabel: @statictext
          (#
             open::< 
               (# theStyle: ^textStyle
               do
                  true->bindRight;
                  'Status'->label;
                  (521,19)->size;
                  (12,3)->position;
                  &textStyle[]->theStyle[];
                  'Times'->theStyle.name;
                  12->theStyle.size;
                  textFaces.italic->theStyle.face;
                  theStyle[]->style
               #)
          #)
     #);
   adorner: @canvas
     (#
        interior: (#  enter theInterior[] do adjustSize #);
        inside: (#  exit outerframe.innerFrame[] #);
        theInterior: ^windowItem;
        open::< 
          (# 
          do
             true->bindBottom;
             true->bindRight;
             (540,308)->size;
             outerFrame.open;
             (0,92)->position;
             
          #);
        adjustingSize: @boolean;
        adjustSize:
          (# width,height: @integer; 
          do
             (if not adjustingSize then
                 true->adjustingSize;
                 (if theInterior[] <> none then
                     (4,4)->theInterior.position;
                     theInterior.size->(width,height);
                     (width+16,height+25+8+4)->outerFrame.size
                 if);
                 false->adjustingSize
             if)
          #);
        eventHandler::<  (# onMouseUp::<  (#  do clearSelection #) #);
        outerFrame: @canvas
          (#
             open::< 
               (# 
               do
                  5->border.style;
                  true->border.visible;
                  (408,208)->size;
                  innerFrame.open;
                  titlePanel.open;
                  (4,10)->position;
                  
               #);
             innerFrame: @canvas
               (#
                  eventHandler:: 
                    (#
                       onChildFrameChanged::  (#  do adjustSize #);
                       onMouseUp::<  (#  do onSelectEntire #)
                    #);
                  open::< 
                    (# 
                    do
                       true->bindBottom;
                       true->bindRight;
                       4->border.style;
                       true->border.visible;
                       (400,179)->size;
                       (4,25)->position;
                       
                    #)
               #);
             titlePanel: @statictext
               (#
                  open::< 
                    (# 
                    do
                       true->bindRight;
                       'This space for rent...'->label;
                       (376,14)->size;
                       (17,6)->position;
                       
                    #);
                  eventHandler::< 
                    (# onMouseUp::<  (#  do onSelectEntire #) #)
               #);
             eventHandler::< 
               (# onMouseUp::<  (#  do onSelectEntire #) #)
          #)
     #);
   
#)  

