ORIGIN '../graphicaleditor';
INCLUDE '~beta/guienv/v1.6/utils/guienvadds'
        '~beta/guienv/v1.6/utils/iconname'
        '~beta/sysutils/v1.6/time'
        '~beta/sysutils/v1.6/objinterface'
        '~beta/betaast/v5.2/gram'
        '~beta/betaast/v5.2/betasematt'
        '~beta/guienv/v1.6/private/datastructures/sequence'
        '~beta/containers/v1.6/list'
        '../../dialogs/griddialog'
        '../../dialogs/propertyInspector'
        '../../code/generate'
        '../../code/pattern'
        '../../code/followsemanticlink'
        '../../code/match'
        '~beta/guienv/v1.6/utils/guienvstuff'
        '../../guienvstuff/killtranslations'
        '../../mpsstuff/mpsutils'
        '../../dialogs/spacingdialog'
        '../../buildermenu'
        '~beta/guienv/v1.6/utils/prompts'
        '../../resourcesupport/easyinterface'
        '../../guienvstuff/loadbitmap'
        '../../code/private/generatebody'
        '../../classes/classes'
        '../../view/colorsupport'
        '../patterndictionary'
        '../constants'
        '../icons'
        '../../dialogs/infodialogs';
BODY 'graphicaleditorbody'
     'factorybody';
-- lib: Attributes --
getSpacingValues: objectPool.get (# type:: spacingValues;  #);   

-- windowItemLib: Attributes --
delay:
  (# startPt: @point; 
  enter startPt
  do
     l: father.trackMouse
       (#
          mouseMove:: 
            (# dh,dv: @integer; 
            do
               curPt.h-startPt.h->dh;
               curPt.v-startPt.v->dv;
               (if (dh*dh > 4) or (dv*dv > 4) then
                   INNER delay; leave l; 
               if);
               
            #);
          
       #);
     
  #);
rubber:
(* Let the use drag the rectangle. 
 * doLeft,doTop,doRight,doBottom specifies which 
 * sides of the rectangle should follow the mouse.
 *)
  (#
     r: @rectangle;
     doLeft,doTop,doRight,doBottom: @boolean;
     gridStart:< (# pt: @point do INNER exit pt #);
     gridSize:< integerValue;
     
  enter (r,doLeft,doTop,doRight,doBottom)
  <<SLOT windowItemRubber:DoPart>>
  exit r
  #);
  

-- graphicalEditorLib: Attributes --
gridSize: (#  enter private.gridSize exit private.gridSize #);
showPropertyInspector: (#  do private.thePropertyInspector.activate #);
gridStart:
  (# pt: @point
  do ((0,0),(contentsEditor).item[],THIS(window).contents)->translate->pt
  exit pt
  #);
changeGrid:
  (#
     theGridDialog: @gridDialog
       (#
          type:: windowTypes.dialog;
          onCancel::  (#  do close #);
          onConfirm:: 
            (#  do gridSizeFld.integerContents->gridSize; close #);
          
       #);
     
  do gridSize->theGridDialog.open; 
  #);
hasPrivateAttributes:
  (# 
  enter private.hasPrivateAttributes
  exit private.hasPrivateAttributes
  #);
instantiate:
  (# name: ^text; theWindowItemEditor: ^windowItemEditor; 
  enter name[]
  do
     (THIS(graphicalEditor)[],name[])->THIS(graphicalEditorEnv).instantiate
       ->theWindowItemEditor[];
     
  exit theWindowItemEditor[]
  #);
selectionChanged:
  (# 
  do
     (if not private.selectionChanged then
         true->private.selectionChanged; 1->private.selectionTimer.start; 
     if);
     
  #);
forgetSelectionChanged: (#  do private.selectionTimer.stop;  #);
controlPointEnv:
  (#
     hide:
       (# 
       do
          north.hide;
          east.hide;
          west.hide;
          south.hide;
          northEast.hide;
          northWest.hide;
          southEast.hide;
          southWest.hide;
          
       #);
     show:
       (# 
       do
          north.show;
          east.show;
          west.show;
          south.show;
          northEast.show;
          northWest.show;
          southEast.show;
          southWest.show;
          
       #);
     bounds:
       (# b: ^rectangle; mx,my: @integer; 
       enter b[]
       do
          (b.left+b.right) div 2->mx;
          (b.top+b.bottom) div 2->my;
          (mx,b.top)->north.corner;
          (mx,b.bottom)->south.corner;
          (b.left,my)->west.corner;
          (b.right,my)->east.corner;
          (b.right,b.top)->northEast.corner;
          (b.left,b.top)->northWest.corner;
          (b.right,b.bottom)->southEast.corner;
          (b.left,b.bottom)->southWest.corner;
          show;
          
       #);
     theEditor: ^windowItemEditor;
     north: @controlPoint (# init::  (#  do true->doTop;  #);  #);
     south: @controlPoint (# init::  (#  do true->doBottom;  #);  #);
     west: @controlPoint (# init::  (#  do true->doLeft;  #);  #);
     east: @controlPoint (# init::  (#  do true->doRight;  #);  #);
     northEast: @controlPoint
       (# init::  (#  do true->doTop; true->doRight;  #);  #);
     northWest: @controlPoint
       (# init::  (#  do true->doTop; true->doLeft;  #);  #);
     southEast: @controlPoint
       (# init::  (#  do true->doBottom; true->doRight;  #);  #);
     southWest: @controlPoint
       (# init::  (#  do true->doBottom; true->doLeft;  #);  #);
     init:
       (# 
       do
          northEast.init;
          northWest.init;
          southEast.init;
          southWest.init;
          north.init;
          west.init;
          south.init;
          east.init;
          
       #);
     controlPoint: windowItem
       (#
          doLeft,doTop,doBottom,doRight: @boolean;
          corner: (# p: @point;  enter p do (p.h-3,p.v-3)->position;  #);
          init:< (#  do THIS(window).contents->open; INNER ;  #);
          open:: 
            (# r: @rectangle; p: @point; black: (#  exit (0,0,0) #); 
            do hide; black->backgroundColor; (6,6)->size; 
            #);
          eventHandler:: 
            (#
               onMouseDown:: 
                 (# 
                 do
                    (if theEditor[] <> none then
                        (doLeft,doTop,doRight,doBottom)->theEditor.reConfigure; 
                    if);
                    
                 #);
               
            #);
          
       #);
     
  #);
makeEditor:
  (#
     editor: ^windowItemEditor;
     name: ^text;
     className: ^text;
     vertical: @boolean;
     
  enter (name[],vertical)
  do
     2->trace (#  do 'MakeEditor: '->xT; xN; name[]->xT;  #);
     (if vertical then '-vertical'->name.append;  if);
     name[]->instantiate->editor[];
     
  exit editor[]
  #);
dontHandleFrameChanged:
  (# 
  enter private.dontHandleFrameChanged
  exit private.dontHandleFrameChanged
  #);
adjustSize:
  (# width,height: @integer; 
  do
     neededSize->(width,height);
     (540,width)->Max->width;
     (400,height)->Max->height;
     (width,height)->size;
     
  #);
makeData:
  (# data: ^parameters; 
  do
     &parameters[]->data[];
     data.init;
     true->data.bindLeft;
     false->data.bindRight;
     true->data.bindTop;
     false->data.bindBottom;
     true->data.visible;
     true->data.enabled;
     false->data.hilite;
     false->data.borderVisible;
     borderstyles.shadowIn->data.borderStyle;
     12->trace (#  do 'makeData: '->xT; xN; data[]->xData #);
     
  exit data[]
  #);
makeImperativeList:
  (# theImperativeList: ^imperativeList; 
  do &imperativeList[]->theImperativeList[]; theImperativeList.init; 
  exit theImperativeList[]
  #);
makeAttributeList:
  (# theAttributeList: ^attributeList; 
  do &attributeList[]->theAttributeList[]; theAttributeList.init; 
  exit theAttributeList[]
  #);
makeClassData:
  (# theClassData: ^classData; 
  do
     &classData[]->theClassData[];
     makeImperativeList->theClassData.theImperatives[];
     makeAttributeList->theClassData.theAttributes[];
     
  exit theClassData[]
  #);
initData:
  (#
     theDoPart: ^astInterface.beta.doPart;
     theImperativeList: ^imperativeList;
     theData: ^parameters;
     frag: ^astInterface.fragmentForm;
     proto1,proto2,proto3: ^astInterface.AST;
     theRemote: ^astInterface.beta.remote;
     
  enter (theData[],theImperativeList[])
  do
     makeFragmentForm->frag[];
     theImperativeList.scan
       (#
          theAssignment: ^astInterface.beta.assignmentEvaluation;
          theTransaction: ^astInterface.ast;
          theObjectDenotation: ^astInterface.beta.objectDenotation;
          theAttributeDenotation: ^astInterface.ast;
          theNameApl: ^astInterface.beta.nameApl;
          name: ^text;
          
       do
          current[]->theAssignment[];
          theAssignment.getTransaction->theTransaction[];
          (if theTransaction.symbol = betaGram.objectDenotation then
              theTransaction[]->theObjectDenotation[];
              theObjectDenotation.getAttributeDenotation
                ->theAttributeDenotation[];
              (if theAttributeDenotation.symbol = betaGram.nameApl then
                  theAttributeDenotation[]->theNameApl[];
                  (theData[],theNameApl.getText,theAssignment[])->adjustValue;
                  
               else
                  (if theAttributeDenotation.symbol = betagram.remote then
                      theAttributeDenotation[]->theRemote[];
                      theRemote.getAttributeDenotation
                        ->theAttributeDenotation[];
                      (if theAttributeDenotation.symbol = betaGram.nameApl then
                          theAttributeDenotation[]->theNameApl[];
                          theNameApl.getText->name[];
                          '.'->name.put;
                          theRemote.getNameApl->theNameApl[];
                          theNameApl.getText->name.append;
                          (theData[],name[],theAssignment[])->adjustValue
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     
  #);
adjustValue:
  (#
     theAssignment: ^astInterface.beta.assignmentEvaluation;
     theEvaluation: ^astInterface.beta.evaluation;
     name: ^text;
     value: ^atom;
     x,y,width,height: @integer;
     theData: ^parameters;
     borderStyleConsts: @borderStyleConstants;
     
  enter (theData[],name[],theAssignment[])
  do
     borderStyleConsts.init;
     12->trace (#  do 'adjustValue name: '->xT; name[]->xT #);
     theAssignment.getEvaluation->theEvaluation[];
     (if true
      // 'position'->name.equalNCS then
         theEvaluation[]->betaGram.evaluatePoint->(x,y);
         ('x',x)->theData.setInt;
         ('y',y)->theData.setInt;
         
      // 'size'->name.equalNCS then
         theEvaluation[]->betaGram.evaluatePoint->(width,height);
         ('width',width)->theData.setInt;
         ('height',height)->theData.setInt;
         
      // 'frame'->name.equalNCS then
         theEvaluation[]->betaGram.evaluateRect->(x,y,width,height);
         ('x',x)->theData.setInt;
         ('y',y)->theData.setInt;
         ('width',width)->theData.setInt;
         ('height',height)->theData.setInt;
         
      else
         name[]->theData.data.lookup->value[];
         (if value[] <> none then
             (if value.type
              // textType then
                 (name[],theEvaluation[]->betaGram.evaluateText)
                   ->theData.setText;
                 
              // boolType then
                 (name[],theEvaluation[]->betaGram.evaluateBool)
                   ->theData.setBool;
                 
              // intType then
                 (name[],
                  (theEvaluation[],name[]->lookupConstants)
                    ->betaGram.evaluateInt)->theData.setInt;
                 
             if);
             
         if);
         
     if);
     
  #);
defaultBodyGroup:
  (# group: ^astInterface.fragmentGroup; frag: ^astInterface.fragmentForm; 
  do
     private.contentsEditor.privateFrag[]->frag[];
     (if frag[] <> none then frag.name->putLine; frag.father->group[];  if);
     
  exit group[]
  #);
undoTop:
  (# top: ^operation; 
  do
     (if private.undoStack.empty then
         none ->top[]; 
      else
         private.undoStack.top->top[]; 
     if);
     
  exit top[]
  #);
saveGraphicalEditor: (#  do undoTop->private.lastSaveOperation[];  #);
graphicalEditorDirty: booleanValue
  (# 
  do
     (if undoTop <> private.lastSaveOperation[] then
         true->value; 
      else
         false->value; 
     if);
     
  #);
graphicalEditorMenu: menu
  (#
     graphicalEditorItem: menuItem
       (#
          eventHandler::< 
            (#
               onStatus::< 
                 (# 
                 do (if readOnly then false->value;  else INNER ;  if); 
                 #);
               
            #);
          open::<  (#  do INNER ; THIS(graphicalEditorItem)[]->append;  #);
          
       #);
     addSeparator:
       (# aSeparator: ^separator; 
       do &separator[]->aSeparator[]; aSeparator.open; aSeparator[]->append; 
       #);
     
  #);
(*
 * container types
 *)
rectangleList: sequence (# element:: rectangle;  #);
stack: sequence
  (#
     push: (# doAppend: @append;  enter doAppend #);
     pop: (# doDeleteLast: @deleteLast;  exit doDeleteLast #);
     top: (# doLast: @last;  exit doLast #);
     
  #);
(*
 * Clipboard
 *)
clipBoard:
  (#
     init: (#  do getScrap->THIS(clipBoard).theScrap[];  #);
     theScrap: ^scrap;
     copyToScrap:
       (# theSelection: ^windowItemEditorList; 
       enter theSelection[]
       do
          theScrap.clear;
          theSelection.scan
            (# scrapElm: ^scrap.element; frag: ^astInterface.fragmentForm; 
            do
               &theScrap.element[]->scrapElm[];
               current.createShadowTree->scrapElm.tree[];
               current.node.frag[]->frag[];
               frag[]->current.node.copy->scrapElm.node[];
               scrapElm[]->theScrap.append;
               
            #);
          
       #);
     createEditor:
       (#
          node: ^astInterface.beta.attributeDecl;
          owner: ^componentEditor;
          tree: ^shadowTree;
          editor: ^windowItemEditor;
          data: ^parameters;
          top: @boolean;
          
       enter (node[],owner[],tree[],top)
       do
          (tree.className.copy,false)->makeEditor->editor[];
          tree.className.copy->editor.className[];
          owner[]->editor.owner[];
          &parameters[]->data[];
          data.init;
          tree.data[]->data.set;
          node[]->editor.node[];
          data[]->editor.data[];
          tree.defaultData[]->editor.defaultData[];
          tree.theClassData[]->editor.theClassData[];
          tree.inherited->editor.inherited;
          tree.vertical->editor.vertical;
          (if top then
              (node[],node[]->makeUniqueName)->betaGram.setName; 
           else
              editor[]->owner.children.append; 
          if);
          tree.children.scan
            (# subNode: ^astInterface.beta.attributeDecl; 
            do
               (if current.inherited then
                   current.node[]->subNode[]; 
                else
                   (node[],current.name[])->betaGram.findAttribute->subNode[]; 
               if);
               (subNode[],editor[],current[],false)->&createEditor;
               
            #);
          
       exit editor[]
       #);
     makePasteOperation: makeOperation
       (#
          operationType:: pasteOperation;
          theSelection: ^windowitemEditorList;
          theAttributes: ^astInterface.beta.attributes;
          
       do
          &windowitemEditorList[]->theSelection[];
          (contentsEditor).getMainAttributes->theAttributes[];
          theScrap.scan
            (# node: ^astInterface.beta.attributeDecl; 
            do
               theAttributes.frag[]->current.node.copy->node[];
               (node[],contentsEditor,current.tree[],true)->createEditor
                 ->theSelection.append;
               
            #);
          theSelection[]->theOperation.init;
          
       #);
     
  #);
(*
 * Generating names
 *)
newUniqueName:
  (#
     theAttributes: ^astInterface.beta.attributes;
     name,newName: ^text;
     count: @integer;
     
  enter (theAttributes[],name[])
  do
     1->count;
     name.copy->newName[];
     count->newName.putInt;
     l:
     (if ((theAttributes[],newName[])->betaGram.find) <> none then
         name.copy->newName[];
         count+1->count;
         count->newName.putInt;
         restart l;
         ;
         
     if);
     
  exit newName[]
  #);
(*
 * Default sizes
 *)
getDefaultSize:
  (# width,height: @integer; name: ^text; inst: ^instantiator; 
  enter name[]
  do
     name[]->lookup->inst[];
     (if inst[] <> none then
         inst.width->width; inst.height->height
      else
         (100,50)->(width,height)
     if);
     
  exit (width,height)
  #);
(*
 * Classes for supporting undo
 *)
clearRedoStack: (#  do private.redoStack.clear;  #);
pushUndoStack:
  (# theOperation: ^operation; 
  enter theOperation[]
  do theOperation[]->private.undoStack.push; 
  #);
operation:
  (#
     undoable:< booleanValue (#  do true->value; INNER #);
     command: (#  do INNER ;  #);
     doIt:< command;
     unDoIt:< command;
     init:<
       (# 
       do
          INNER ;
          (if undoable then
              clearRedoStack; THIS(operation)[]->pushUndoStack; 
          if);
          
       #);
     name:< (# value: ^text;  do INNER ;  exit value[] #);
     
  #);
makeOperation:
  (# operationType:< operation; theOperation: ^operationType; 
  do &operationType[]->theOperation[]; INNER ; 
  #);
singleOperation: operation
  (#
     theEditor: ^windowItemEditor;
     init::<  (#  enter theEditor[] do INNER ;  #);
     
  #);
resizeOperation: singleOperation
  (#
     oldFrame,newFrame: ^rectangle;
     init:: 
       (# 
       enter newFrame[]
       do
          theEditor.frame->oldFrame[];
          newFrame[]->theEditor.frame;
          (* theEditor.fixOpen; *)
          newFrame.size->theEditor.changeSize;
          
       #);
     doIt:: 
       (# 
       do
          newFrame[]->theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          newFrame.size->theEditor.changeSize;
          
       #);
     unDoIt:: 
       (# 
       do
          oldFrame[]->theEditor.frame;
          selection.clear;
          theEditor.select;
          (* theEditor.fixOpen; *)
          oldFrame.size->theEditor.changeSize;
          
       #);
     name::<  (#  do 'Resize'->value[]; INNER ;  #);
     
  #);
makeSingleOperation: makeOperation
  (# operationType::< singleOperation; theEditor: ^windowItemEditor; 
  enter theEditor[]
  do INNER ; 
  #);
makeResizeOperation: makeSingleOperation
  (# operationType:: resizeOperation; newFrame: ^rectangle; 
  enter newFrame[]
  do (theEditor[],newFrame[])->theOperation.init; 
  #);
selectionOperation: operation
  (#
     theSelection: ^windowItemEditorList;
     setSelection: command
       (#  do selection.clear; INNER ; theSelection[]->selection.set;  #);
     init::<  (#  enter theSelection[] do INNER ;  #);
     
  #);
moveOperation: selectionOperation
  (#
     dh,dv: @integer;
     init::<  (#  enter (dh,dv) do doIt; INNER ;  #);
     doIt:: setSelection
       (# 
       do
          theSelection.scan
            (# 
            do (* true -> dontHandleFrameChanged; *)
               (dh,dv)->current.item.move;
               (* false -> dontHandleFrameChanged; *)
               current.item.position->current.changePosition;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# 
       do
          theSelection.scan
            (# 
            do (* true -> dontHandleFrameChanged; *)
               (- dh,- dv)->current.item.move;
               (* false -> dontHandleFrameChanged; *)
               current.item.position->current.changePosition;
               
            #);
          
       #);
     name::<  (#  do 'Move'->value[]; INNER ;  #);
     
  #);
changeOwnerOperation: selectionOperation
  (#
     dh,dv: @integer;
     newOwner,oldOwner: ^componentEditor;
     init:: 
       (# 
       enter (newOwner[],dh,dv)
       do (theSelection.first).owner[]->oldOwner[]; doIt; INNER ; 
       #);
     doIt:: setSelection
       (# 
       do
          theSelection.scan
            (# h,v: @integer; 
            do
               current.data.position->(h,v);
               (h+dh,v+dv)->current.data.position;
               (h+dh,v+dv)->current.changePosition;
               newOwner[]->current.changeOwner;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# 
       do
          theSelection.scan
            (# h,v: @integer; 
            do
               current.data.position->(h,v);
               (h-dh,v-dv)->current.data.position;
               (h-dh,v-dv)->current.changePosition;
               oldOwner[]->current.changeOwner;
               
            #);
          
       #);
     name::<  (#  do 'Move'->value[]; INNER ;  #);
     
  #);
changeBoundsOperation: selectionOperation
  (#
     newBounds,oldBounds: ^rectangleList;
     init:: 
       (# 
       enter newBounds[]
       do
          &rectangleList[]->oldBounds[];
          oldBounds.init;
          theSelection.scan
            (#  do current.frame->oldBounds.append;  #);
          doIt;
          
       #);
     doIt:: setSelection
       (# inx: @integer; 
       do
          1->inx;
          theSelection.scan
            (# b: ^rectangle; 
            do
               inx->newBounds.get->b[]->current.frame;
               inx+1->inx;
               b.topLeft->current.changePosition;
               b.size->current.changeSize;
               
            #);
          
       #);
     unDoIt:: setSelection
       (# inx: @integer; 
       do
          1->inx;
          theSelection.scan
            (# b: ^rectangle; 
            do
               inx->oldBounds.get->b[]->current.frame;
               inx+1->inx;
               b.topLeft->current.changePosition;
               b.size->current.changeSize;
               
            #);
          
       #);
     
  #);
alignOperation: changeBoundsOperation
  (# name::<  (#  do 'Alignment'->value[]; INNER ;  #);  #);
fitToContentsOperation: changeBoundsOperation
  (# name::<  (#  do 'Fit to contents'->value[]; INNER ;  #);  #);
spacingOperation: changeBoundsOperation
  (# name::<  (#  do 'Spacing'->value[]; INNER ;  #);  #);
createOperation: operation
  (#
     bounds: ^rectangle;
     owner: ^componentEditor;
     type: @integer;
     theEditor: ^windowItemEditor;
     theClassData: ^classData;
     className: ^text;
     init:: 
       (# 
       enter (owner[],bounds[],theClassData[],className[])
       do
          3
            ->trace
              (# 
              do
                 'bounds: '->xT;
                 bounds.left->xI;
                 bounds.top->xI;
                 bounds.right-bounds.left->xI;
                 bounds.bottom-bounds.top->xI;
                 
              #);
          selection.clear;
          (theClassData[],className[])->owner.newEditor->theEditor[];
          bounds.topLeft->theEditor.item.position;
          bounds.topLeft->theEditor.changePosition;
          
       #);
     doIt:: 
       (#  do selection.clear; theEditor.reInsert; theEditor.select;  #);
     unDoIt::  (#  do selection.clear; theEditor.delete;  #);
     name::<  (#  do 'New'->value[];  #);
     
  #);
deleteOperation: selectionOperation
  (#
     init::  (#  do doIt;  #);
     doIt:: 
       (# 
       do selection.clear; theSelection.scan (#  do current.delete;  #); 
       #);
     unDoIt:: setSelection
       (#  do theSelection.scan (#  do current.reInsert;  #);  #);
     name::< 
       (# 
       do INNER ; (if value[] = none then 'Delete'->value[];  if); 
       #);
     
  #);
cutOperation: deleteOperation
  (# name::<  (#  do 'Cut'->value[];  #);  #);
pasteOperation: selectionOperation
  (#
     name::<  (#  do 'Paste'->value[];  #);
     init::  (#  do doIt;  #);
     doIt:: setSelection
       (#  do theSelection.scan (#  do current.reInsert;  #);  #);
     unDoIt:: 
       (# 
       do selection.clear; theSelection.scan (#  do current.delete;  #); 
       #);
     
  #);
dialogOperation: singleOperation
  (#
     oldData,newData: ^parameters;
     init:: 
       (#  enter newData[] do theEditor.data.copy->oldData[]; doIt;  #);
     doIt:: 
       (# 
       do
          selection.clear;
          TRUE->THIS(graphicalEditor).private.allowPositionChange;
          (newData[],false)->theEditor.changeData;
          newData[]->theEditor.data.set;
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     unDoIt:: 
       (# 
       do
          selection.clear;
          (oldData[],false)->theEditor.changeData;
          oldData[]->theEditor.data.set;
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     name::<  (#  do 'Dialog'->value[];  #);
     
  #);
changeOperation: singleOperation
  (#
     oldData,newData: ^parameters;
     init:: 
       (#  enter newData[] do theEditor.data.copy->oldData[]; doIt;  #);
     doIt:: 
       (# 
       do
          TRUE->THIS(graphicalEditor).private.allowPositionChange;
          (newData[],false)->theEditor.changeData;
          newData.data.storage.scan
            (# 
            do (current.key[],current.value[])->theEditor.data.data.define; 
            #);
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          
       #);
     unDoIt:: 
       (# 
       do
          selection.clear;
          (oldData[],false)->theEditor.changeData;
          oldData.data.storage.scan
            (# 
            do (current.key[],current.value[])->theEditor.data.data.define; 
            #);
          theEditor.applyObjectData;
          FALSE->THIS(graphicalEditor).private.allowPositionChange;
          theEditor.select;
          
       #);
     name::<  (#  do 'Changed'->value[];  #);
     
  #);
makeDialogOperation: makeSingleOperation
  (# operationType:: dialogOperation; data: ^parameters; 
  enter data[]
  do (theEditor[],data[])->theOperation.init; 
  #);
makeChangeOperation: makeSingleOperation
  (# operationType:: changeOperation; data: ^parameters; 
  enter data[]
  do (theEditor[],data[])->theOperation.init; 
  #);
changeWindowSizeOperation: operation
  (#
     width,height: @integer;
     oldWidth,oldHeight: @integer;
     init:: 
       (# 
       enter (width,height)
       do (contentsEditor).item.size->(oldWidth,oldHeight); doIt; 
       #);
     doIt::  (#  do (width,height)->(contentsEditor).item.size;  #);
     unDoIt::  (#  do (oldWidth,oldHeight)->(contentsEditor).item.size;  #);
     name::<  (#  do 'Resize'->value[]; INNER ;  #);
     
  #);
makeChangeWindowSizeOperation: makeOperation
  (# operationType::< changeWindowSizeOperation; width,height: @integer; 
  enter (width,height)
  do (width,height)->theOperation.init; 
  #);

contentsEditor: (#  exit private.contentsEditor[] #);
translateRect:
  (# r: ^rectangle; from,to: ^windowItem; 
  enter (r[],from[],to[])
  do
     (r.topLeft,from[],to[])->translate->r.topLeft;
     (r.bottomRight,from[],to[])->translate->r.bottomRight;
     
  #);
(*
 * Handling of private attributes
 *)
  

-- canvasEditorLib: Attributes --


  
getMainFrag:
  (#
     theAttributes: ^astInterface.beta.attributes;
     frag: ^astInterface.fragmentForm;
     
  do
     getMainAttributes->theAttributes[];
     (if theAttributes[] <> none then theAttributes.frag[]->frag[];  if);
     
  exit frag[]
  #);

scanAttributes:
  (#
     current: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     
  do
     getMainAttributes->theAttributes[];
     (if theAttributes[] <> none then
         theAttributes.iterate
           (# 
           do
              current[]->THIS(scanAttributes).current[]; INNER scanAttributes; 
           #);
         
     if);
     
  #);
  

-- selectionLib: Attributes --
extractData:
  (# data: ^parameters; count,firstData: ^parameters
  do
     &parameters[]->data[];
     data.init;
     &parameters[]->count[];
     count.init;
     scan
       (# 
       do
          current.data.data.storage.scan
            (# val: @integer
            do
               current.key[]->count.getInt->val;
               (current.key[],val+1)->count.setInt;
               
            #)
       #);
     (first).data[]->firstData[];
     count.data.storage.scan
       (# val: @integer
       do
          (current.value.asIntAtom).value->val;
          (if val = size then
              (current.key[],(current.key[]->firstData.find))->data.data.define
          if)
       #);
     
  exit data[]
  #);
moveControlPoints:
  (# b: ^rectangle; 
  do
     (if size
      // 0 then
         private.controlPoints.hide; 
      // 1 then
         bounds->b[];
         (b[],(first).item.father[],contents)->translateRect;
         b[]->private.controlPoints.bounds;
         first->private.controlPoints.theEditor[];
         
      else
         bounds->b[];
         (b[],(first).item.father[],contents)->translateRect;
         b[]->private.controlPoints.bounds;
         
     if);
     
  #);
openSubEditor:
  (#  do selection.scan (#  do current.openSubEditor;  #);  #);
isEditMenuPossible: booleanValue
  (# 
  do
     true->value;
     scan
       (#  do (if current[] = contentsEditor then false->value;  if);  #);
     
  #);
isAncestor: booleanValue
  (# ancestor,child: ^windowItemEditor; 
  enter (ancestor[],child[])
  do
     (if child[] = none then
         false->value; 
      else
         (if ancestor[] = child[] then
             true->value; 
          else
             (ancestor[],child.owner[])->isAncestor->value; 
         if);
         
     if);
     
  #);
moveAllowed: booleanValue
  (# theComponentEditor: ^componentEditor; 
  enter theComponentEditor[]
  do
     true->value;
     l:
       (# 
       do
          scan
            (# 
            do
               (if current.owner[] = theComponentEditor[] then
                   false->value; leave l; 
                else
                   (if (current[],theComponentEditor[])->isAncestor then
                       false->value; leave l; 
                   if);
                   
               if);
               
            #);
          
       #);
     
  #);
makeSelectionOperation: makeOperation
  (#
     operationType::< selectionOperation;
     theSelection: ^windowItemEditorList;
     
  do copy->theSelection[]; INNER ; 
  #);
makeMoveOperation: makeSelectionOperation
  (# operationType:: moveOperation; dh,dv: @integer; 
  enter (dh,dv)
  do (theSelection[],dh,dv)->theOperation.init; 
  #);
makeChangeOwnerOperation: makeSelectionOperation
  (#
     operationType:: changeOwnerOperation;
     dh,dv: @integer;
     newOwner: ^componentEditor;
     
  enter (newOwner[],dh,dv)
  do (theSelection[],newOwner[],dh,dv)->theOperation.init; 
  #);
makeDeleteOperation: makeSelectionOperation
  (# operationType::< deleteOperation; 
  do theSelection[]->theOperation.init; 
  #);
makeCutOperation: makeDeleteOperation (# operationType:: cutOperation #);
makeChangeBoundsOperation: makeSelectionOperation
  (# operationType::< changeBoundsOperation; newBounds: ^rectangleList; 
  do
     &rectangleList[]->newBounds[];
     newBounds.init;
     INNER ;
     (theSelection[],newBounds[])->theOperation.init;
     
  #);
makeAlignOperation: makeChangeBoundsOperation
  (#
     operationType:: alignOperation;
     modelFrame: ^rectangle;
     currentFrame: ^rectangle;
     first: @boolean;
     
  do
     true->first;
     scan
       (# 
       do
          (if first then
              current.frame->modelFrame[];
              modelFrame[]->newBounds.append;
              false->first;
              
           else
              current.frame->currentFrame[];
              INNER makeAlignOperation;
              currentFrame[]->newBounds.append;
              
          if);
          
       #);
     
  #);
makeFitToContentsOperation: makeChangeBoundsOperation
  (# operationType:: fitToContentsOperation; 
  do
     scan
       (# r: ^rectangle; 
       do
          current.frame->r[];
          current.theWindowItem.preferredSize->r.size;
          r[]->newBounds.append;
          
       #);
     
  #);
makeSpacingOperation: makeOperation
  (#
     operationType:: spacingOperation;
     theSelection: ^windowItemEditorList;
     newBounds: ^rectanglelist;
     
  enter (theSelection[],newBounds[])
  do (theSelection[],newBounds[])->theOperation.init; 
  #);
bounds:
  (# theBounds: ^rectangle; 
  do
     &rectangle[]->theBounds[];
     minInt->theBounds.right->theBounds.bottom;
     maxInt->theBounds.left->theBounds.top;
     scan
       (# r: ^rectangle; 
       do
          current.frame->r[];
          (r.left,theBounds.left)->Min->theBounds.left;
          (r.top,theBounds.top)->Min->theBounds.top;
          (r.right,theBounds.right)->Max->theBounds.right;
          (r.bottom,theBounds.bottom)->Max->theBounds.bottom;
          
       #);
     
  exit theBounds[]
  #);
drag:
  (#
     theProxy: @proxy
       (#
          moveTo:: 
            (# dh,dv: @integer; 
            do
               newFrame.left-oldBounds.left->dh;
               newFrame.top-oldBounds.top->dv;
               (if theCanvasEditor[] = (first).owner[] then
                   (dh,dv)->makeMoveOperation; 
                else
                   (theCanvasEditor[],dh,dv)
                     ->selection.makeChangeOwnerOperation;
                   
               if);
               
            #);
          
       #);
     oldBounds: ^rectangle;
     event: ^windowItem.eventHandler.mouseDown;
     dragItem: ^windowItem;
     theGridStart: @point;
     
  enter event[]
  do
     ((0,0),(contentsEditor).item[],THIS(window).contents)->translate
       ->theGridStart;
     bounds->oldBounds[];
     (first).owner.theWindowItem[]->dragItem[];
     FALSE->theProxy.palette;
     (oldBounds[],theProxy[])
       ->dragItem.dragAndDrop
         (#
            gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #);
            gridSize::  (#  do THIS(graphicalEditor).gridSize->value #)
         #);
     
  #);
selectable: booleanValue
  (# theEditor: ^windowItemEditor; 
  enter theEditor[]
  do
     (if empty then
         true->value; 
      else
         (theEditor.owner[] = (first).owner[])->value; 
     if);
     
  #);
array: sequence
  (#
     element:: 
       (#
          editor: ^windowItemEditor;
          init: (#  enter editor[] do editor.frame->frame[];  #);
          frame: ^rectangle;
          position:
            (# 
            enter
              (# x,y: @integer; 
              enter (x,y)
              do (x-frame.left,y-frame.top)->frame.offset
              #)
            exit frame.topLeft
            #);
          size: (#  enter frame.size exit frame.size #);
          
       #);
     add:
       (# editor: ^windowItemEditor; elm: ^element; 
       enter editor[]
       do &element[]->elm[]; editor[]->elm.init; elm[]->append; 
       #);
     sortHorizontal: sort
       (#
          less::< 
            (# leftpos,rightpos: @point; 
            do
               left.editor.item.position->leftpos;
               right.editor.item.position->rightpos;
               leftpos.h < rightpos.h->value;
               
            #);
          
       #);
     sortVertical: sort
       (#
          less::< 
            (# leftpos,rightpos: @point; 
            do
               left.editor.item.position->leftpos;
               right.editor.item.position->rightpos;
               leftpos.v < rightpos.v->value;
               
            #)
       #);
     
  #);
makeArray:
  (# theArray: ^array; 
  do
     &array[]->theArray[];
     theArray.init;
     scan
       (#  do current[]->theArray.add;  #);
     
  exit theArray[]
  #);
alignspacing:
  (#
     values: ^spacingValues;
     theArray: ^array;
     newBounds: ^rectangleList;
     theSelection: ^windowItemEditorList;
     
  enter values[]
  do
     makeArray->theArray[];
     (if (values.doWidth or values.doHeight)
      // true then
         theArray.scan
           (# width,height: @integer; 
           do
              current.size->(width,height);
              (if values.doWidth // true then values.width->width;  if);
              (if values.doHeight // true then values.height->height;  if);
              (width,height)->current.size;
              
           #);
         
     if);
     (if values.doVerticalDist then
         theArray.sortVertical;
         theArray.scan
           (#
              prevFrame: @rectangle;
              curPos: @Point;
              previous: ^array.element;
              
           do
              (if previous[] <> none then
                  current.position->curPos;
                  previous.frame->prevFrame;
                  prevFrame.bottom+values.verticalDist->curPos.v;
                  curPos->current.position;
                  
              if);
              current[]->previous[];
              
           #);
         
     if);
     (if values.doHorizontalDist then
         theArray.sortHorizontal;
         theArray.scan
           (#
              prevFrame: @rectangle;
              curPos: @Point;
              previous: ^array.element;
              
           do
              (if previous[] <> none then
                  current.position->curPos;
                  previous.frame->prevFrame;
                  prevFrame.Right+values.horizontalDist->curPos.h;
                  curPos->current.position;
                  
              if);
              current[]->previous[];
              
           #);
         
     if);
     &rectangleList[]->newBounds[];
     newBounds.init;
     &windowItemEditorList[]->theSelection[];
     theSelection.init;
     theArray.scan
       (# 
       do
          current.editor[]->theSelection.append;
          current.frame[]->newBounds.append;
          
       #);
     (theSelection[],newBounds[])->makeSpacingOperation;
     
  #);
  

-- componentEditorLib: attributes --
newEditor:
                 (#
                    theEditor: ^windowitemEditor;
                    theClassData: ^classData;
                    className: ^text;
                    
                 enter (theClassData[],className[])
                 <<SLOT graphicalEditorNewEditor:DoPart>>
                 exit theEditor[]
                 #);
                 
generateOpenImp:
  (#
     name: ^text;
     theImp: ^astInterface.beta.imp;
     frag: ^astInterface.fragmentForm;
     
  enter frag[]
  do
     node[]->betaGram.getName->name[];
     (frag[],name[],isPrivateToOwner)->betaGram.newOpenStatement->theImp[];
     
  exit theImp[]
  #);
isPrivateToOwner: booleanValue
  (# 
  do
     (if owner[] = none then
         false->value; 
      else
         not (node.frag[] = owner.node.frag[])->value; 
     if);
     
  #);
  
findOpenDoPart:
  (# theDoPart: ^astInterface.beta.doPart; purpose: @integer; 
  enter purpose
  do (#  do (node[],purpose)->realFindOpenDoPart->theDoPart[];  #); 
  exit theDoPart[]
  #);

appendAttribute:
  (#
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
     
  enter theAttribute[]
  do
     getMainAttributes->theAttributes[];
     (if theAttributes[] = none then
         failure; 
      else
         (theAttributes[],theAttribute[])->appendToAttributes; 
     if);
     
  #);

appendOpenImp:
  (#
     theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure: (#  do  #);
     
  enter imp[]
  do
       (#
          theImperatives: ^astInterface.beta.imperatives;
          insertInx: @integer;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              theDoPart.getImperatives->theImperatives[];
              l: theImperatives.iterate
                (# 
                do
                   current.sonNo->insertInx;
                   (if current.symbol = betaGram.innerImp then leave l;  if);
                   
                #);
              (insertInx,imp[])->theImperatives.insert;
              (true,theImperatives.frag[],theImperatives[],insertInx)
                ->theFragServer.notifyListElementInserted;
              
          if);
          
       #);
     
  #);
deleteOpenImp:
  (#
     theDoPart: ^astInterface.beta.doPart;
     name: ^text;
     failure: (#  do  #);
     
  enter name[]
  do
       (#
          theImperatives: ^astInterface.beta.imperatives;
          deleteInx: @integer;
          oldElements: ^astInterface.myAstList;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              &MPS.myAstList[]->oldElements[];
              oldElements.init;
              theDoPart.getImperatives->theImperatives[];
              l: theImperatives.iterate
                (#
                   theObjectDenotation: ^astInterface.beta.objectDenotation;
                   theNameApl: ^astInterface.beta.nameApl;
                   theText: ^text;
                   theAttributeDenotation: ^astInterface.ast;
                   theRemote: ^astInterface.beta.remote;
                   
                do
                   (if current.symbol = betaGram.objectDenotation then
                       current[]->theObjectDenotation[];
                       theObjectDenotation.getAttributeDenotation
                         ->theAttributeDenotation[];
                       (if theAttributeDenotation.symbol = betaGram.remote then
                           theAttributeDenotation[]->theRemote[];
                           theRemote.getNameApl->theNameApl[];
                           theNameApl.getText->theText[];
                           (if 'open'->theText.equalNCS then
                               theRemote.getAttributeDenotation
                                 ->theAttributeDenotation[];
                               (if theAttributeDenotation.symbol
                                // betaGram.remote then
                                   theAttributeDenotation[]->theRemote[];
                                   theRemote.getNameApl->theNameApl[];
                                   
                                // betaGram.nameApl then
                                   theAttributeDenotation[]->theNameApl[]; 
                                else
                                   none ->theNameApl[]; 
                               if);
                               (if theNameApl[] <> none then
                                   theNameApl.getText->theText[];
                                   (if name[]->theText.equalNCS then
                                       current.sonNo->deleteInx;
                                       current[]->oldElements.insert;
                                       leave l;
                                       
                                   if);
                                   
                               if);
                               
                           if);
                           
                       if);
                       
                   if);
                   
                #);
              (if deleteInx <> 0 then
                  deleteInx->theImperatives.delete;
                  (true,theImperatives.frag[],theImperatives[],deleteInx,1,
                   oldElements[])->theFragServer.notifyListElementsDeleted;
                  
              if);
              
          if);
          
       #);
     
  #);
  
updateOpen:
  (# oldName,newName: ^text; 
  enter (oldName[],newName[])
  do
       (#
          oldStmProto: ^astInterface.beta.imp;
          oldStm: ^astInterface.beta.imp;
          newStm: ^astInterface.beta.imp;
          frag: ^astInterface.fragmentForm;
          txt: @text;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
          gram: @grammar;
          
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] <> none then
              makeFragmentForm->frag[];
              oldName[]->txt.append;
              '.open'->txt.append;
              (makeFragmentForm,txt[],gram.imp)->parseText->oldStmProto[];
              txt.clear;
              newName[]->txt.append;
              '.open'->txt.append;
              theDoPart.getImperatives->theImperatives[];
              (theImperatives.frag[],txt[],gram.imp)->parseText->newStm[];
              (mps[],theImperatives[],oldStmProto[])->listSearch->oldStm[];
              (if oldStm[] <> none then
                  (oldStm.sonNo,newStm[])->theImperatives.put;
                  (true,theImperatives.frag[],oldStm[],newStm[])
                    ->theFragServer.notifyAstReplaced;
                  
              if);
              
          if);
          
       #);
     
  #);

  

appendAttributeToNode:
  (# node,theAttribute: ^astInterface.beta.attributeDecl; 
  enter (node[],theAttribute[])
  do
       (# theAttributes: ^astInterface.beta.attributes; insertInx: @integer; 
       do
          node[]->betaGram.getAttributes->theAttributes[];
          (theAttributes[],theAttribute[])->appendToAttributes;
          
       #);
     
  #);
appendToAttributes:
  (#
     theAttribute: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     insertInx: @integer;
     son1: ^astInterface.AST;
     doReplace: @boolean;
     
  enter (theAttributes[],theAttribute[])
  do
     (if theAttributes.noOfsons = 1 then
         1->theAttributes.get->son1[];
         (if son1.kind = mps.kinds.optional then true->doReplace;  else  if);
         
     if);
     (if doReplace then
         (1,theAttribute[])->theAttributes.put;
         (true,theAttributes.frag[],son1[],theAttribute[])
           ->theFragServer.notifyAstReplaced;
         
      else
         theAttributes.noOfSons->insertInx;
         theAttribute[]->theAttributes.append;
         (true,theAttributes.frag[],theAttributes[],insertInx)
           ->theFragServer.notifyListElementInserted;
         
     if);
     
  #);
  
findVirtual:
  (# name: ^text; theVirtual: ^astInterface.beta.attributeDecl; 
  enter name[]
  do
       (# isEvent: @boolean; currentNode: ^astInterface.beta.attributeDecl; 
       do
          (if name.length >= 2 then
              'on'->((1,2)->name.sub).equal->isEvent; 
           else
              false->isEvent; 
          if);
          node[]->currentNode[];
          (if isEvent then
              (currentNode[],'eventHandler')->betaGram.findAttribute
                ->currentNode[];
              
          if);
          (if currentNode[] <> none then
              (currentNode[],name[])->betaGram.findAttribute->theVirtual[]; 
          if);
          
       #);
     
  exit theVirtual[]
  #);
  
 createVirtual:
  (# name: ^text; theVirtual: ^astInterface.beta.attributeDecl; 
  enter name[]
  do
       (#
          isEvent: @boolean;
          currentNode: ^astInterface.beta.attributeDecl;
          theAttribute: ^astInterface.beta.attributeDecl;
          
       do
          (if name.length >= 2 then
              'on'->((1,2)->name.sub).equal->isEvent; 
           else
              false->isEvent; 
          if);
          node[]->currentNode[]->theAttribute[];
          (if isEvent then
              (currentNode[],'eventHandler')->betaGram.findAttribute
                ->currentNode[];
              (if currentNode[] = none then
                  (theAttribute.frag[],'eventHandler',none )
                    ->betaGram.newVirtualBinding->currentNode[];
                  (theAttribute[],currentNode[])->appendAttributeToNode;
                  
              if);
              
          if);
          (currentNode.frag[],name[],none )->betaGram.newVirtualBinding
            ->theVirtual[];
          (currentNode[],theVirtual[])->appendAttributeToNode;
          
       #);
     
  exit theVirtual[]
  #);

isPrivateToWindow: booleanValue
  (#  do not (node.frag[] = THIS(graphicalEditor).node.frag[])->value;  #);

  
-- windowItemEditorLib: Attributes --
findEnclosing:
  (# current: ^windowItemEditor; 
  do
     THIS(windowItemEditor)[]->current[];
     l:
     (if current.inherited then current.owner[]->current[]; restart l;  if);
     
  exit current[]
  #);
selected: (#  exit private.selected #);
reConfigure:
  (#
     doLeft,doTop,doRight,doBottom: @boolean;
     bounds: ^rectangle;
     newOwner: ^componentEditor;
     
  enter (doLeft,doTop,doRight,doBottom)
  do
     frame->bounds[];
     (bounds[],item.father[],contents)->translateRect;
     (bounds,doLeft,doTop,doRight,doBottom)
       ->(contents).rubber
         (#
            gridSize::  (#  do THIS(graphicalEditor).gridSize->value #);
            gridStart::  (#  do THIS(graphicalEditor).gridStart->pt #)
         #)->bounds;
     (bounds.topLeft,contents,item.father[])->translate->bounds.topLeft;
     (bounds.bottomRight,contents,item.father[])->translate->bounds.bottomRight;
     (THIS(windowItemEditor)[],bounds[])->makeResizeOperation;
     
  #);
assertWindowItem:
  (#
     error:< exception
       (# 
       do
          '"theWindowItem" is NONE in "'->msg.putText;
          location->msg.putText;
          '"'->msg.putLine;
          INNER ;
          
       #);
     location:< (# value: ^text;  do INNER ;  exit value[] #);
     
  do (if theWindowItem[] <> none then INNER ;  else error;  if); 
  #);
changeName:
  (# oldName,newName: ^text; isIdentifier: @boolean; isEqual: @boolean
  enter newName[]
  do
     node[]->betaGram.getName->oldName[];
     newName[]->checkIdentifier->isIdentifier;
     (if isIdentifier then
         newName[]->oldName.equalNCS->isEqual;
         (if not isEqual then
               (#
                  theNames: ^astInterface.beta.names;
                  theNameDcl: ^astInterface.beta.nameDcl;
                  theNameDecl: ^astInterface.nameDecl;
                  oldNameDcl: ^astInterface.beta.nameDcl;
                  
               do
                  node[]->betaGram.getNames->theNames[];
                  (if theNames[] <> none then
                      1->theNames.get->oldNameDcl[];
                      (theNames.frag[],newName[])->betaGram.newNameDcl
                        ->theNameDcl[];
                      (1,theNameDcl[])->theNames.put;
                      (true,theNames.frag[],oldNameDcl[],theNameDcl[])
                        ->theFragServer.notifyAstReplaced;
                      
                  if);
                  
               #);
             (if owner[] <> none then
                 (if isPrivateToOwner then
                     'private.'->oldName.prepend; 'private.'->newName.prepend; 
                 if);
                 (oldName[],newName[])->owner.updateOpen;
                 
             if);
             
         if);
         
     if)
  #);
openSubEditor: (#  do editAttributes;  #);
addOpen:
  (#
     node: ^astInterface.beta.attributeDecl;
     theDoPart: ^astInterface.beta.doPart;
     
  enter node[]
  do
     9
       ->trace
         (# 
         do 'add open'->xT; xN; '------- BEFORE --------'->xT; node[]->xA
         #);
       (#
          openDecl: ^astInterface.beta.attributeDecl;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          theActionPart: ^astInterface.beta.actionPart;
          theAttributes: ^astInterface.beta.attributes;
          gram: @grammar;
          
       do
          (node[],'open')->betaGram.findAttribute->openDecl[];
          (if openDecl[] = none then
              (if privateFrag[] <> none then
                  (node.frag[],'open::< (# <<SLOT name: doPart>> #)',
                   gram.attributeDecl)->parseText->openDecl[];
                  
               else
                  (node.frag[],'open::< (# do #)',gram.attributeDecl)->parseText
                    ->openDecl[];
                  
              if);
              node[]->betaGram.getAttributes->theAttributes[];
              (theAttributes[],openDecl[])->appendToAttributes;
              
           else
              (if openDecl.symbol
               // betaGram.bindingDecl // betaGram.finalDecl then
                  node[]->betaGram.getObjectDescriptor->check
                    ->theObjectDescriptor[];
                  (if theObjectDescriptor[] <> none then
                      theObjectDescriptor.getMainPart->check->theMainPart[];
                      (if theMainPart[] <> none then
                          theMainPart.getActionPart->check->theActionPart[];
                          (if theActionPart[] <> none then
                              theActionPart.getDoPartOpt->check->theDoPart[];
                              (if theDoPart[] <> none then
                                  
                               else
                                  (if privateFrag[] <> none then
                                      (node.frag[],'<<SLOT name: doPart>>',
                                       gram.doPart)->parseText
                                        ->theActionPart.putDoPartOpt;
                                      
                                   else
                                      (node.frag[],'do',gram.doPart)->parseText
                                        ->theActionPart.putDoPartOpt;
                                      
                                  if);
                                  
                              if);
                              
                           else
                              (if privateFrag[] <> none then
                                  (node.frag[],'<<SLOT name: doPart>>',
                                   gram.actionPart)->parseText
                                    ->theMainPart.putActionPart;
                                  
                               else
                                  (node.frag[],'do',gram.actionPart)->parseText
                                    ->theMainPart.putActionPart;
                                  
                              if);
                              
                          if);
                          
                       else
                          (if privateFrag[] <> none then
                              (node.frag[],'(# <<SLOT name: doPart>>  #)',
                               gram.mainPart)->parsetext
                                ->theObjectDescriptor.putMainPart;
                              
                           else
                              (node.frag[],'(# do #)',gram.mainPart)->parsetext
                                ->theObjectDescriptor.putMainPart;
                              
                          if);
                          
                      if);
                      
                  if);
                  
               else
                  none ->openDecl[]; 
              if);
              
          if);
          (if theDoPart[] = none then
              (if openDecl[] <> none then
                  (if privateFrag[] <> none then
                      mps.unExpanded
                        ->openDecl.suffixWalkForProd
                          (#
                             theSlotDesc: ^mps.slotDesc;
                             doPartFrag,frag: ^astInterface.fragmentForm;
                             group: ^astInterface.fragmentGroup;
                             slotName: ^text;
                             theUnExp: ^astInterface.unExpanded;
                             
                          do
                             current[]->theUnExp[];
                             (if theUnExp.isSlot then
                                 theUnExp.theSlot->theSlotDesc[];
                                 node[]->betaGram.getName->slotName[];
                                 'Open'->slotName.append;
                                 slotName[]->theSlotDesc.name;
                                 slotName[]->betaGram.newDoPartFrag
                                   ->doPartFrag[];
                                 privateFrag.father->group[];
                                 slotName[]->group.findFragment->frag[];
                                 (if frag[] <> none then
                                     frag.root[]->theDoPart[]; 
                                  else
                                     doPartFrag[]
                                       ->group.fragmentList.addFragment;
                                     doPartFrag.root[]->theDoPart[];
                                     
                                 if);
                                 
                             if);
                             
                          #);
                      
                   else
                      gram.doPart
                        ->openDecl.suffixWalkForProd
                          (#  do current[]->theDoPart[];  #);
                      
                  if);
                  (if theDoPart[] <> none then
                      (if node.symbol = betaGram.patternDecl then
                            (#
                               innerImp: ^astInterface.beta.imp;
                               theImperatives: ^astInterface.beta.imperatives;
                               
                            do
                               (theDoPart.frag[],'INNER',gram.imp)->parseText
                                 ->innerImp[];
                               theDoPart.getImperatives->theImperatives[];
                               (1,innerImp[])->theImperatives.put;
                               
                            #);
                          
                      if);
                      
                  if);
                  
              if);
              
          if);
          
       #);
     9->trace (#  do '------ AFTER --------'->xT; node[]->xA #)
  exit theDoPart[]
  #);
realCreateOpen: (#  exit node[]->addOpen #);
skip: (#  enter private.skip exit private.skip #);
codeGuard:
  (# 
  do
     (if inherited or private.initializing then
         3->trace (#  do 'code-change disallowed'->xT #)
      else
         INNER ; 
     if);
     
  #);
deleteImperative: codeGuard
  (#
     name: ^text;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.AST;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.imp;
     theImperatives: ^astInterface.beta.imperatives;
     oldElements: ^astInterface.myAstList;
     deleteInx: @integer;
     
  enter name[]
  do
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> '->txt.append;
         name[]->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (if imp[] <> none then
             &mps.myAstList[]->oldElements[];
             oldElements.init;
             imp.sonNo->deleteInx;
             imp[]->oldElements.insert;
             deleteInx->theImperatives.delete;
             (true,theImperatives.frag[],theImperatives[],deleteInx,1,
              oldElements[])->theFragserver.notifyListElementsDeleted;
             
         if);
         
     if);
     
  #);
generateEvaluation:
  (#
     value: ^atom;
     frag: ^astInterface.fragmentForm;
     eval: ^astInterface.beta.evaluation;
     gram: @grammar;
     consts: ^constants;
     
  enter (frag[],value[],consts[])
  do
     (if value[] = none then
         (frag[],'NONE',gram.imp)->parseText->eval[]; 
     if);
     (if value.type
      // textType then
         (if (value.asTextAtom).value[] = none then
             (frag[],'NONE',gram.imp)->parseText->eval[]; 
          else
             (frag[],(value.asTextAtom).value[])->betaGram.newTextEvaluation
               ->eval[];
             
         if);
         
      // boolType then
         (frag[],(value.asBoolAtom).value)->betaGram.newBoolEvaluation->eval[]; 
      // intType then
         (frag[],(value.asIntAtom).value,consts[])->betaGram.newIntEvaluation
           ->eval[];
         
     if);
     
  exit eval[]
  #);
changeImperative: codeGuard
  (#
     name: ^text;
     value: ^atom;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldEval,newEval: ^astInterface.beta.evaluation;
     
  enter (name[],value[])
  do
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> '->txt.append;
         name[]->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (theDoPart.frag[],value[],name[]->lookupConstants)->generateEvaluation
           ->newEval[];
         (if imp[] <> none then
             imp.getEvaluation->oldEval[];
             newEval[]->imp.putEvaluation;
             (true,imp.frag[],oldEval[],newEval[])
               ->theFragServer.notifyAstReplaced;
             
          else
             theDoPart.frag[]->proto.copy->proto[];
             (theDoPart.frag[],value[],name[]->lookupConstants)
               ->generateEvaluation->proto.putEvaluation;
             (1,proto[])->theImperatives.insert;
             (true,theImperatives.frag[],theImperatives[],1)
               ->theFragServer.notifyListElementInserted;
             
         if);
         
     if);
     
  #);
changeData:
  (#
     newData: ^parameters;
     force: @boolean;
     oldValue: ^atom;
     defaultValue: ^atom;
     x,y,width,height: @integer;
     doChangePosition,doChangeSize: @boolean;
     
  enter (newData[],force)
  do
     14
       ->trace
         (#  do node[]->betaGram.getName->xT; '.changeData'->xT; xN;  #);
     maxint->x->y->width->height;
     4->trace (#  do 'ChangeData FORCE = '->xT; force->xB;  #);
     newData.data.storage.scan
       (# name: ^text; 
       do
          4->trace (#  do 'current.key = '->xT; current.key[]->xT;  #);
          (if true
           // 'x'->current.key.equalNCS then
              true->doChangePosition; 'x'->newData.getInt->x; 
           // 'y'->current.key.equalNCS then
              true->doChangePosition; 'y'->newData.getInt->y; 
           // 'height'->current.key.equalNCS then
              true->doChangeSize; 'height'->newData.getInt->height; 
           // 'width'->current.key.equalNCS then
              true->doChangeSize; 'width'->newData.getInt->width; 
           // 'iconName'->current.key.equalNCS then
              ('thePixmap.read',current.value[])
                ->changeImperative
                (* // 'border.style'->current.key.equalNCS then *)
           // 'ID'->current.key.equalNCS then
              
           // 'type'->current.key.equalNCS then
              
           else
              current.key[]->data.data.lookup->oldValue[];
              (if (not force) and (current.value[]->oldValue.equal) then
                  
               else
                  current.key[]->defaultData.data.lookup->defaultValue[];
                  4
                    ->trace
                      (# 
                      do
                         '    defaultValue = '->xT;
                         (if defaultValue[] = none then
                             'NONE'->xT; 
                          else
                             'defined'->xT; 
                         if);
                         
                      #);
                  current.key[]->name[];
                  (if (not (defaultValue[] = none )) and
                  (current.value[]->defaultValue.equal) then
                      4->trace (#  do '     DELETED'->xT;  #);
                      name[]->deleteImperative;
                      
                   else
                      4->trace (#  do '     WRITTEN'->xT;  #);
                      (name[],current.value[])->changeImperative;
                      
                  if);
                  
              if);
              
          if);
          
       #);
     (if doChangePosition then
         (if x = maxint then 'x'->data.getInt->x if);
         (if y = maxint then 'y'->data.getInt->y if);
         (x,y)->changePosition;
         
     if);
     (if doChangeSize then
         (if width = maxint then 'width'->data.getInt->width if);
         (if height = maxint then 'height'->data.getInt->height if);
         (width,height)->changeSize;
         
     if);
     
  #);
changePosition: codeGuard
  (#
     x,y: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation,oldEval,newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
     
  enter (x,y)
  do
     14
       ->trace
         (# 
         do
            node[]->betaGram.getName->xT;
            '.changePosition'->xT;
            ' x = '->xT;
            x->xI;
            ' y = '->xT;
            y->xI;
            xN;
            
         #);
     (if (THIS(windowItemEditor)[] <> contentsEditor) or
     THIS(graphicalEditor).private.allowPositionChange then
         3->trace (#  do 'ChangePosition: '->xT;  #);
         forInitStatements->findOpenDoPart->theDoPart[];
         (if theDoPart[] <> none then
             theDoPart.getImperatives->theImperatives[];
             '<<evaluation>> -> position'->txt.append;
             (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
             (mps[],theImperatives[],proto[])->listSearch->imp[];
             (if imp[] <> none then
                 imp.getEvaluation->oldEval[];
                 (theDoPart.frag[],x,y)->betaGram.newPointEvaluation->newEval[];
                 newEval[]->imp.putEvaluation;
                 (true,imp.frag[],oldEval[],newEval[])
                   ->theFragServer.notifyAstreplaced;
                 
              else
                 theDoPart.frag[]->proto.copy->proto[];
                 (theDoPart.frag[],x,y)->betaGram.newPointEvaluation
                   ->proto.putEvaluation;
                 (1,proto[])->theImperatives.insert;
                 (true,theDoPart.frag[],theImperatives[],1)
                   ->theFragServer.notifyListElementInserted;
                 
             if);
             
         if);
         
      else
         3->trace (#  do 'position change not allowed'->xT #)
     if);
     
  #);
changeSize: codeGuard
  (#
     width,height: @integer;
     theDoPart: ^astInterface.beta.doPart;
     proto: ^astInterface.beta.assignmentEvaluation;
     gram: @grammar;
     txt: @text;
     imp: ^astInterface.beta.assignmentEvaluation;
     theImperatives: ^astInterface.beta.imperatives;
     theEvaluation,oldEval,newEval: ^astInterface.beta.evaluation;
     assignment: ^astInterface.beta.assignmentEvaluation;
     oldWidth,oldHeight: @integer;
     
  enter (width,height)
  do
     3->trace (#  do 'ChangeSize: '->xT; width->xI; height->xI;  #);
     forInitStatements->findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.getImperatives->theImperatives[];
         '<<evaluation>> -> size'->txt.append;
         (makeFragmentForm,txt[],gram.imp)->parseText->proto[];
         (mps[],theImperatives[],proto[])->listSearch->imp[];
         (if imp[] <> none then
             imp.getEvaluation->oldEval[];
             (theDoPart.frag[],width,height)->betaGram.newPointEvaluation
               ->newEval[];
             newEval[]->imp.putEvaluation;
             (true,imp.frag[],oldEval[],newEval[])
               ->theFragServer.notifyAstreplaced;
             
          else
             theDoPart.frag[]->proto.copy->proto[];
             (theDoPart.frag[],width,height)->betaGram.newPointEvaluation
               ->proto.putEvaluation;
             (1,proto[])->theImperatives.insert;
             (true,theDoPart.frag[],theImperatives[],1)
               ->theFragServer.notifyListElementInserted;
             
         if);
         
     if);
     
  #);
inherited: (#  enter private.inherited exit private.inherited #);
closeWindowItem:
  (#  do item.close; none ->theWindowItem[]; none ->item[];  #);
frame:
  (# r: ^rectangle; 
  enter
    (# 
    enter r[]
    do (*true -> dontHandleFrameChanged;*)
       r->item.frame; (*false -> dontHandleFrameChanged;*) 
    #)
  exit (#  do &rectangle[]->r[]; item.frame->r;  exit r[] #)
  #);
createShadowTree:
  (# tree: ^shadowTree; 
  do
     &shadowTree[]->tree[];
     className[]->tree.className[];
     node[]->betaGram.getName->tree.name[];
     data.copy->tree.data[];
     defaultData[]->tree.defaultData[];
     theClassData[]->tree.theClassData[];
     inherited->tree.inherited;
     vertical->tree.vertical;
     node[]->tree.node[];
     tree.children.init;
         children.scan
           (#  do current.createShadowTree->tree.children.append;  #);
     
  exit tree[]
  #);
delete:
  (#
     father: ^astInterface.list;
     oldElements: ^astInterface.myAstList;
     deleteInx: @integer;
  do closeWindowItem;
     node.father->father[];
     node.sonNo->deleteInx;
     deleteInx->father.delete;
     &MPS.myAstList[]->oldElements[];
     oldElements.init;
     node[]->oldElements.insert;
     (true,father.frag[],father[],deleteInx,1,oldElements[])
       ->theFragServer.notifyListElementsDeleted;
     THIS(windowitemEditor)[]->owner.children.delete;
     node[]->betaGram.getName->owner.deleteOpenImp;
     false->private.selected;
     
  #);
reInsert:
  (#
     theDoPart: ^astInterface.beta.doPart;
     theAttributes: ^astInterface.beta.attributes;
  do 
     THIS(windowitemEditor)[]->owner.children.append;
     createTheWindowItem;
     owner.getMainAttributes->theAttributes[];
     (if node.frag[] <> theAttributes.frag[] then
         theAttributes.frag[]->node.copy->node[]; 
     if);
     node[]->owner.appendAttribute;
     forOpenStatements->owner.findOpenDoPart->theDoPart[];
     (if theDoPart[] <> none then
         theDoPart.frag[]->generateOpenImp->owner.appendOpenImp; 
     if);
     
  #);

traverseCallback:
  (# current: ^windowItemEditor; continue: @boolean; 
  enter current[]
  do true->continue; INNER ; 
  exit continue
  #);
recTraverse:
  (#
     callback: ^traverseCallback;
     editor: ^windowItemEditor;
     
  enter (editor[],callback[])
  do
     (if editor[]->callback then
     		editor.children.scan
               (#  do (current[],callback[])->&recTraverse;  #);
     if);
     
  #);
traverse:
  (# forEach:< traverseCallback; 
  do (THIS(windowItemEditor)[],&forEach[])->recTraverse; 
  #);
(*
 * Code
 *)

prependOpenImp: codeGuard
  (#
     theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure: (#  do  #);
     
  enter imp[]
  do
       (# theImperatives: ^astInterface.beta.imperatives; 
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              theDoPart.getImperatives->theImperatives[];
              (1,imp[])->theImperatives.insert;
              (true,theImperatives.frag[],theImperatives[],1)
                ->theFragServer.notifyListElementInserted;
              
          if);
          
       #);
     
  #);



handleAstReplaced:
  (# oldAst,newAst: ^astInterface.AST; succes: @boolean; 
  enter (oldAst[],newAst[])
  do
     false->succes;
     (if oldAst[]->node.equal then
         newAst[]->node[]; (* !!! Check for validitet *) true->succes; 
      else
         (if (node[],newAst[])->isAncestor then
             true->succes; 
          else
             (if (oldAst[],node[])->isAncestor then
                   (#
                      theAttributes: ^astInterface.beta.attributes;
                      name: ^text;
                      
                   do
                      node[]->betaGram.getName->name[];
                      owner.getMainAttributes->theAttributes[];
                      (if theAttributes[] <> none then
                          l: theAttributes.iterate
                            (# 
                            do
                               (if current[]->betaGram.getName->name.equalNCS
                                then
                                   current[]->node[]; true->succes; leave l; 
                               if);
                               
                            #);
                          
                      if);
                      
                   #);
                 
              else
                 true->succes; 
             if);
             
         if);
         
     if);
     
  exit succes
  #);

changeOwner:
  (# newOwner: ^componentEditor; 
  enter newOwner[]
  do delete; newOwner[]->owner[]; reInsert; 
  #);
handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do (theEvent[],theEvent.localPosition)->THIS(windowItemEditor).mousedown; 
  #);
handleFrameChanged: item.frameChangedAction
  (# r: ^rectangle; x,y,width,height: @integer; 
  do
     3
       ->trace
         (# 
         do
            '-----------------------------------------'->xT;
            xN;
            ' HandleFrameChanged: '->xT;
            
         #);
     (if item[] <> none then
         frame->r[];
         r.topLeft->(x,y);
         r.size->(width,height);
         3
           ->trace
             (# 
             do
                ' x = '->xT;
                x->xI;
                ' y = '->xT;
                y->xI;
                xN;
                ' width = '->xT;
                width->xI;
                ' height = '->xT;
                height->xI;
                
             #);
         (if not dontHandleFrameChanged then
             3->trace (#  do ' Change the Actual Code'->xT;  #);
             (if THIS(windowItemEditor)[] <> ContentsEditor then
                 14
                   ->trace
                     (# 
                     do node[]->betaGram.getName->xT; '.changeFrame'->xT; xN; 
                     #);
                 (x,y)->changePosition;
                 
             if);
             r.size->changeSize;
             
         if);
         (if data[] <> none then
             (if (THIS(windowItemEditor)[] <> contentsEditor) or
             THIS(graphicalEditor).private.allowPositionChange then
                 14->trace (#  do ' setting data.position'->xT; xN #);
                 (x,y)->data.position;
                 
             if);
             3->trace (#  do ' setting data.size'->xT;  #);
             (width,height)->data.size;
             (if private.selected then selectionChanged;  if);
             
         if);
         
     if);
     3->trace (#  do '-----------------------------------------'->xT; xN #);
     
  #);
handleRefresh: theWindowItem.refreshAction
  (# 
  do
     (if outline then
         theWindowItem.graphics
           (# width,height: @integer
           do
              (if platform <> winnt then patterns.gray[]->pen.stipple if);
              item.size->(width,height);
              ((0,0),(width-1,height-1))->drawRect
           #)
     if)
  #);
  

-- windowitemEditorPrivate: Descriptor --
(#
   selected: @boolean;
   skip: @boolean;
   inherited: @boolean;
   initializing: @boolean;
   pos: @integer;
   node: ^astInterface.AST;
   
#)  

-- canvasEditorPrivate: Descriptor --
(#  #)  

-- graphicalEditorEnvLib: Attributes --

realFindOpenDoPart:
  (#
     theDoPart: ^astInterface.beta.doPart;
     node: ^astInterface.beta.attributeDecl;
     purpose: @integer;
     
  enter (node[],purpose)
  do
       (#
          contents: ^astInterface.beta.attributeDecl;
          openDecl: ^astInterface.beta.attributeDecl;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          theActionPart: ^astInterface.beta.actionPart;
          theAst: ^astInterface.AST;
          theUnExpanded: ^astInterface.unExpanded;
          theSlot: ^astInterface.slotDesc;
          doPartFrag: ^astInterface.fragmentForm;
          group: ^astInterface.fragmentGroup;
          
       do
          node.frag.father->group[];
          (if purpose
           // forOpenStatements then
              (node[],'contentsType')->betaGram.findAttribute->contents[];
              (if contents[] <> none then
                  (if contents.symbol
                   // betaGram.bindingDecl // betaGram.finalDecl then
                      contents[]->node[]; 
                  if);
                  
              if);
              
          if);
          (node[],'open')->betaGram.findAttribute->openDecl[];
          (if openDecl[] <> none then
              openDecl[]->betaGram.getObjectDescriptor->theObjectDescriptor[];
              theObjectDescriptor.getMainPart->theMainPart[];
              theMainPart.getActionPart->theActionPart[];
              theActionPart.getDoPartOpt->theAst[];
              (if theAst.symbol = MPS.unExpanded then
                  (if group[] <> none then
                      theAst[]->theUnExpanded[];
                      (if theUnExpanded.isSlot then
                          theUnExpanded.theSlot->theSlot[];
                          theSlot.name->group.findBodyFragment->doPartFrag[];
                          (if doPartFrag[] <> none then
                              doPartFrag.root[]->theDoPart[]; 
                          if);
                          
                      if);
                      
                  if);
                  
               else
                  theAst[]->theDoPart[]; 
              if);
              
          if);
          
       #);
     
  exit theDoPart[]
  #);
  
  
recentCanvas:
  (# name: ^text
  enter name[]
  do
       (# inst: ^instantiator
       do
          'canvas'->lookup->inst[];
          (name[],name[]->inst.copyName,none ,'Recent','canvas',canvasIcon,100,
           20)->insertCustom
       #)
  #);
registerConstants:
  (# name: ^text; consts: ^constants
  enter (name[],consts[])
  do (name[],consts[])->private.theConstants.define
  #);
lookupConstants:
  (# name: ^text; consts: ^constants
  enter name[]
  do name[]->private.theConstants.lookup->consts[]
  exit consts[]
  #);

makeUniqueName:
  (#
     node: ^astInterface.beta.attributeDecl;
     theAttributes: ^astInterface.beta.attributes;
     name,newName: ^text;
     
  enter node[]
  do
     node[]->betaGram.getName->name[];
     node.father->theAttributes[];
     name.copy->newName[];
     'Copy'->newName.append;
     
  exit newName[]
  #);
defined: booleanValue
  (# name: ^text; 
  enter name[]
  do name[]->private.theFactory.defined->value; 
  #);
lookup:
  (# name: ^text; theInstantiator: ^instantiator; 
  enter name[]
  do name[]->private.theFactory.lookup->theInstantiator[]; 
  exit theInstantiator[]
  #);
instantiate:
  (#
     theGraphicalEditor: ^graphicalEditor;
     name: ^text;
     theWindowItemEditor: ^graphicalEditor.windowItemEditor;
     
  enter (theGraphicalEditor[],name[])
  do
     (theGraphicalEditor[],name[])->private.theFactory.instantiate
       ->theWindowItemEditor[];
     
  exit theWindowItemEditor[]
  #);
check:
  (# anAst: ^astInterface.ast; 
  enter anAst[]
  do
     (if anAst[] <> none then
         (if anAst.kind <> mps.kinds.interior then none ->anAst[];  if); 
     if);
     
  exit anAst[]
  #);
forInitStatements: (#  exit 1 #);
forOpenStatements: (#  exit 2 #);

getAttributes:
  (#
     node: ^astInterface.beta.attributeDecl;
     theAttributeList: ^attributeList;
     getPrivateAttributes:
       (#
          node: ^astInterface.beta.attributeDecl;
          theAttributes: ^astInterface.beta.attributes;
          frag: ^astInterface.fragmentForm;
          theDescriptorForm: ^astInterface.beta.descriptorForm;
          theObjectDescriptor: ^astInterface.beta.objectDescriptor;
          theMainPart: ^astInterface.beta.mainPart;
          
       enter node[]
       do
          node[]->betaGram.getPrivateFragment->frag[];
          (if frag[] <> none then
              (if frag.category = betaGram.descriptorForm then
                  frag.root[]->theDescriptorForm[];
                  theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
                  theObjectDescriptor.getMainPart->theMainPart[];
                  theMainPart.getAttributes->theAttributes[];
                  
              if);
              
          if);
          
       exit theAttributes[]
       #);
     addAttributes:
       (# theAttributes: ^astInterface.beta.attributes
       enter theAttributes[]
       do
          (if theAttributes[] <> none then
              theAttributes.iterate
                (#  do current[]->theAttributeList.append;  #);
              
          if);
          
       #);
     addImperatives:
       (#
          node: ^astInterface.beta.attributeDecl;
          theNameApl: ^astInterface.beta.nameApl;
          theDoPart: ^astInterface.beta.doPart;
          theImperatives: ^astInterface.beta.imperatives;
          
       enter node[]
       do
          (node[],forInitStatements)->realFindOpenDoPart->theDoPart[];
          (if theDoPart[] <> none then
              theDoPart.getImperatives->theImperatives[];
              theImperatives.newScan
                (# doMatch: @boolean; 
                do
                   (mps[],current[],proto1[])->match->doMatch;
                   (if not doMatch then
                       (mps[],current[],proto2[])->match->doMatch; 
                   if);
                   (if doMatch then
                       current[]->theImperativeList.prepend; 
                   if);
                   
                #);
              
          if);
          
       #);
     theImperativeList: ^imperativeList;
     proto1,proto2: ^astInterface.AST;
     gram: @grammar;
     contentsType,mainNode: ^astInterface.beta.attributeDecl;
     
  enter node[]
  do
     (makeFragmentForm,'<<evaluation>> -> <<nameApl>>',gram.imp)->parseText
       ->proto1[];
     (makeFragmentForm,'<<evaluation>> -> <<remote>>',gram.imp)->parseText
       ->proto2[];
     &attributeList[]->theAttributeList[];
     theAttributeList.init;
     &imperativeList[]->theImperativeList[];
     theImperativeList.init;
     node[]->mainNode[];
     (node[],'contentsType')->betaGram.findAttribute->contentsType[];
     (if contentsType[] <> none then
         (if contentsType.symbol
          // gram.bindingDecl // gram.finalDecl then
             contentsType[]->mainNode[]; 
         if);
         
     if);
     mainNode[]->betaGram.getAttributes->addAttributes;
     mainNode[]->getPrivateAttributes->addAttributes;
     node[]->addImperatives;
     
  exit (theAttributeList[],theImperativeList[])
  #);
getSuperPattern:
  (#
     node,superNode: ^astInterface.beta.attributeDecl;
     theNameApl: ^astInterface.beta.nameApl;
     theNameDcl: ^astInterface.beta.nameDcl;
     theNames: ^astInterface.beta.names;
     dest: ^astInterface.ast;
     
  enter node[]
  do
     node[]->betaGram.getPrefixNameApl->theNameApl[];
     (if theNameApl[] <> none then
         (mps[],theNameApl[])->followSemanticLink->dest[];
         (if (dest[] <> none ) and (dest.symbol = betaGram.nameDcl) then
             dest[]->theNameDcl[];
             theNameDcl.father->theNames[];
             theNames.father->superNode[];
             
         if);
         
     if);
     
  exit superNode[]
  #);

getScrap: (#  exit private.theScrap[] #);
insert:
  (# editor: ^graphicalEditor; 
  enter editor[]
  do editor[]->private.editors.append; 
  #);
delete:
  (# editor: ^graphicalEditor; 
  enter editor[]
  do editor[]->private.editors.remove; 
  #);
scrap: list
  (# element::  (# tree: ^shadowTree; node: ^astInterface.AST;  #); 
  #);
shadowTree:
  (#
     name: ^text;
     className: ^text;
     data,defaultData: ^parameters;
     theClassData: ^classData;
     inherited: @boolean;
     vertical: @boolean;
     node: ^astInterface.beta.attributeDecl;
     children: @list (# element:: shadowTree;  #);
     
  #);
addInclude:
  (# group: ^astInterface.fragmentGroup; path: ^text; 
  enter (group[],path[])
  <<SLOT addInclude:DoPart>>
  #);
hasInclude: booleanValue
  (#
     group: ^astInterface.fragmentGroup;
     path: ^text;
     
  enter (group[],path[])
  <<SLOT hasInclude:DoPart>>
  #);
  

-- graphicalEditorEnvPrivate: Descriptor --
(#
   theFactory: @factory;
   infoDialogs: @patternDictionary;
   theScrap: @scrap;
   editors: @list
     (#
        element:: graphicalEditor;
        remove: (# elm: ^element;  enter elm[] do elm[]->at->delete #);
        
     #);
   theConstants: @constantTable;
   borderConsts: @borderStyleConstants;
   hAlignmentConsts: @horAlignmentConstants;
   vAlignmentConsts: @verAlignmentConstants;
   
#)  

-- graphicalEditorPrivateAttributes: Descriptor --
(#
   gridSize: @integer;
   thePropertyInspector: @propertyInspector
     (#
        data: ^parameters;
        activate:
          (# 
          do
             (if active then
                 bringToFront
              else
                 true->active; update; show; bringToFront
             if)
          #);
        deActivate: (#  do (if active then hide; false->active if) #);
        active: @boolean;
        propertyChanged:: 
          (#
             newData: ^parameters;
             theAtom: ^atom;
             asBool:
               (# str: ^text; b: @boolean
               enter str[]
               do
                  (if str[] <> none then
                      (if true
                       // 'true'->str.equalNCS then
                          true->b
                       // 'false'->str.equalNCS then
                          false->b
                      if)
                  if)
               exit b
               #);
             asInt:
               (# str: ^text; int: @integer
               enter str[]
               do
                  l:
                  (if str[] <> none then
                      str.asInt (# syntaxError::  (#  do leave l #) #)->int
                  if)
               exit int
               #)
          do
             &parameters[]->newData[];
             newData.init;
             name[]->data.find->theAtom[];
             (if theAtom[] <> none then
                 (if theAtom.type
                  // textType then
                     (name[],value[])->newdata.setText
                  // boolType then
                     (name[],value[]->asBool)->newdata.setBool
                  // intType then
                     (name[],value[]->asInt)->newdata.setInt
                 if);
                 selection.scan
                   (#  do (current[],newData[])->makeChangeOperation #)
             if)
          #);
        nameChanged:: 
          (# 
          do
             (if selection.size = 1 then
                 name[]->(selection.first).changeName
             if)
          #);
        editScript:: 
          (# 
          do
             (if selection.size = 1 then
                 name[]->(selection.first).editVirtual
             if)
          #);
        update:
          (# theEditor: ^windowItemEditor; inst: ^instantiator
          do
             (if active then
                 (if not selection.empty then
                     selection.extractData->data[];
                     (if data[] <> none then
                         inspectorPane.propertyPane.scan
                           (# 
                           do
                              current[]
                                ->qua
                                  (# as:: propertyView
                                  do
                                     (if (thisObj.name->data.find) = none then
                                         thisObj.close
                                     if)
                                  #)
                           #);
                         data.data.storage.scan
                           (# propView: ^propertyView
                           do
                              current.key[]->inspectorPane.propertyPane.find
                                ->propView[];
                              (if current.value.type
                               // intType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asIntAtom).value)
                                        ->makeIntProperty
                                   else
                                      (if true
                                       // propView## <= textPropertyView## then
                                          propView[]
                                            ->qua
                                              (# as:: textPropertyView
                                              do
                                                 (current.value.asIntAtom).value
                                                   ->thisObj.intValue
                                              #)
                                       // propView## <= constantPropertyView##
                                       then
                                          propView[]
                                            ->qua
                                              (# as:: constantPropertyView
                                              do
                                                 (current.value.asIntAtom).value
                                                   ->thisObj.value
                                              #)
                                      if)
                                  if)
                               // boolType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asBoolAtom).value)
                                        ->makeBoolProperty
                                   else
                                      propView[]
                                        ->qua
                                          (# as:: boolPropertyView
                                          do
                                             (current.value.asBoolAtom).value
                                               ->thisObj.value
                                          #)
                                  if)
                               // textType then
                                  (if propView[] = none then
                                      (current.key[],
                                       (current.value.asTextAtom).value[])
                                        ->makeTextProperty
                                   else
                                      propView[]
                                        ->qua
                                          (# as:: textPropertyView
                                          do
                                             (current.value.asTextAtom).value[]
                                               ->thisObj.value
                                          #)
                                  if)
                              if)
                           #);
                         inspectorPane.propertyPane.changed
                     if);
                     (if selection.size = 1 then
                         (selection.first).node[]->betaGram.getName
                           ->inspectorPane.name;
                         (selection.first).className[]->lookup->inst[];
                         (if inst[] <> none then
                             inst.scripts[]->inspectorPane.scripts
                         if);
                         
                      else
                         none ->inspectorPane.name; none ->inspectorPane.scripts
                     if)
                  else
                     inspectorPane.propertyPane.scan
                       (#  do current.close #);
                     none ->inspectorPane.name;
                     none ->inspectorPane.scripts
                 if)
             if);
             
          #);
        open:: 
          (# 
          do hide; inspectorpane.propertypane.scan (#  do current.close #)
          #);
        eventHandler:: 
          (#
             onAboutToClose:: 
               (#  do thePropertyInspector.deactivate; false->okToClose #)
          #)
     #);
   hasPrivateAttributes: @boolean;
   allowPositionChange: @boolean;
   selectionChanged: @boolean;
   selectionTimer: @editorTimer
     (#
        action:: 
          (# 
          do
             stop;
             (if selectionChanged then
                 selection.moveControlPoints;
                 thePropertyInspector.update;
                 false->selectionChanged;
                 
             if);
             
          #);
        
     #);
   forbidCodeChanges,dontHandleFrameChanged: @boolean;
   controlPoints: @controlPointEnv;
   uniqueID: @integer;
   lastSaveOperation: ^operation;
   executeWindow:
     (# windowPattern: ##window; theWindow: ^window
     enter windowPattern##
     do &windowPattern[]->theWindow[]; theWindow.open
     #);
   executeCanvas:
     (# canvasPattern: ##canvas; theCanvas: ^canvas
     enter canvasPattern##
     do
        &canvasPattern[]->theCanvas[];
        contents->theCanvas.open;
        &theCanvas.mouseDownAction (#  do theCanvas.drag #)[]
          ->theCanvas.appendAction
     #);
   theFileMenu: @graphicalEditorMenu
     (#
        closeItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect:: 
                    (# 
                    do
                       (if THIS(graphicalEditor).theEventHandler.onAboutToClose
                        then
                           THIS(graphicalEditor).close; 
                       if);
                       
                    #);
                  
               #);
             open:: 
               (#  do 'Close'->name; 'W'->key; closeItem[]->append;  #);
             
          #);
        runItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect:: 
                    (# P: ##object; 
                    do
                       ((node.frag.father).fullName,THIS(guienv)[])
                         ->com.evaluateFile->P##;
                       (if P## <> none then
                           (if P## <= window## then P##->executeWindow if)
                       if);
                       
                    #);
                  
               #);
             open::  (#  do 'Run'->name; 'R'->key;  #);
             
          #);
        runInsideItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect:: 
                    (# P: ##object; 
                    do
                       ((node.frag.father).fullName,THIS(graphicalEditor)[])
                         ->com.evaluateFile->P##;
                       (if P## <> none then
                           (if P## <= window## then P##->executeWindow if)
                       if);
                       
                    #);
                  
               #);
             open::  (#  do 'Run Inside Frigg'->name;  #);
             
          #);
        runCanvasItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect:: 
                    (# P: ##object; 
                    do
                       ((node.frag.father).fullName,THIS(graphicalEditor)[])
                         ->com.evaluateFile->P##;
                       (if P## <> none then
                           (if P## <= canvas## then P##->executeCanvas if)
                       if);
                       
                    #);
                  
               #);
             open::  (#  do 'Run Canvas'->name;  #);
             
          #);
        saveItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect:: 
                    (#  do node.frag.father->com.saveFragmentGroup #);
                  
               #);
             open::  (#  do 'Save'->name; 'S'->key;  #);
             
          #);
        quitItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect::  (#  do com.quitApplication #);
                  
               #);
             open::  (#  do 'Quit'->name; 'Q'->key;  #);
             
          #);
        open:: 
          (# 
          do
             'File'->name;
             closeItem.open;
             saveItem.open;
             addSeparator;
             (if com.dynamicCompilationAvailable then
                 runItem.open; addSeparator; 
             if);
             quitItem.open;
             
          #);
        
     #);
   theEditMenu: @graphicalEditorMenu
     (#
        undoItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do undo;  #);
                  onStatus:: 
                    (# t: ^text; 
                    do
                       (if canUndo then
                           'Undo '->t[];
                           undoText->t.append;
                           t[]->name;
                           true->value;
                           
                        else
                           'Undo'->name; false->value; 
                       if);
                       
                    #);
                  
               #);
             open::  (#  do 'Undo'->name; 'Z'->key;  #);
             
          #);
        redoItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do redo;  #);
                  onStatus:: 
                    (# t: ^text; 
                    do
                       (if canRedo then
                           'Redo '->t[];
                           redoText->t.append;
                           t[]->name;
                           true->value;
                           
                        else
                           'Redo'->name; false->value; 
                       if);
                       
                    #);
                  
               #);
             open::  (#  do 'Redo'->name; 'R'->key;  #);
             
          #);
        cutItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.doCut;  #);
                  onStatus::  (#  do not selection.empty->value;  #);
                  
               #);
             open::  (#  do 'Cut'->name; 'X'->key;  #);
             
          #);
        copyItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.doCopy;  #);
                  onStatus::  (#  do not selection.empty->value;  #);
                  
               #);
             open::  (#  do 'Copy'->name; 'C'->key;  #);
             
          #);
        pasteItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do paste;  #);
                  onStatus::  (#  do canPaste->value;  #);
                  
               #);
             open::  (#  do 'Paste'->name; 'V'->key;  #);
             
          #);
        deleteItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.deleteAll;  #);
                  onStatus::  (#  do not selection.empty->value;  #);
                  
               #);
             open::  (#  do 'Delete'->name;  #);
             
          #);
        gridItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do changeGrid;  #);
                  onStatus::  (#  do true->value;  #);
                  
               #);
             open::  (#  do 'Grid...'->name;  #);
             
          #);
        findItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  #);
                  onStatus::  (#  do false->value;  #);
                  
               #);
             open::  (#  do 'Find...'->name;  #);
             
          #);
        findAgainItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  #);
                  onStatus::  (#  do false->value;  #);
                  
               #);
             open::  (#  do 'Find again'->name;  #);
             
          #);
        openSubEditorItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.openSubEditor;  #);
                  onStatus::  (#  do selection.size >= 1->value;  #);
                  
               #);
             open::  (#  do 'Show Source Code'->name; 'J'->key;  #);
             
          #);
        inspectItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onStatus::  (#  do true->value;  #);
                  onSelect::  (#  do thePropertyInspector.activate #);
                  
               #);
             open::  (#  do 'Object Inspector'->name; 'I'->key;  #);
             
          #);
        objectFitToContents: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.fitToContents;  #);
                  onStatus::  (#  do not selection.empty->value;  #);
                  
               #);
             open::  (#  do 'Fit to contents'->name;  #);
             
          #);
        open:: 
          (# 
          do
             'Edit'->name;
             undoItem.open;
             redoItem.open;
             addSeparator;
             cutItem.open;
             copyItem.open;
             pasteItem.open;
             deleteItem.open;
             addSeparator;
             gridItem.open;
             addSeparator;
             openSubEditorItem.open;
             addSeparator;
             inspectItem.open;
             objectFitToContents.open;
             
          #);
        
     #);
   theAlignMenu: @graphicalEditorMenu
     (#
        alignLeftItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignLeft;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Left side'->name;  #);
             
          #);
        alignRightItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignRight;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Right side'->name;  #);
             
          #);
        alignTopItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignTop;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Top edge'->name;  #);
             
          #);
        alignBottomItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignBottom;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Bottom edge'->name;  #);
             
          #);
        alignHorCenterItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignHorCenter;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Vertical center'->name;  #);
             
          #);
        alignVerCenterItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.alignVerCenter;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Horizontal center'->name;  #);
             
          #);
        showSpacingDialogItem: @graphicalEditorItem
          (#
             eventHandler:: 
               (#
                  onSelect::  (#  do selection.showSpacingDialog;  #);
                  onStatus::  (#  do selection.size > 1->value;  #);
                  
               #);
             open::  (#  do 'Spacing...'->name;  #);
             
          #);
        open:: 
          (# 
          do
             'Align'->name;
             alignLeftItem.open;
             alignRightItem.open;
             alignTopItem.open;
             alignBottomItem.open;
             alignHorCenterItem.open;
             alignVerCenterItem.open;
             addSeparator;
             showSpacingDialogItem.open;
             
          #);
        
     #);
   (*
    * Fragment handler
    *)
   fragHandler,privateFragHandler: @fragmentHandler
     (#
        handleAstReplaced:
          (# oldAst,newAst: ^astInterface.ast; 
          enter (oldAst[],newAst[])
          do
             contentsEditor.traverse
               (#
                  forEach:: 
                    (# 
                    do
                       (oldAst[],newAst[])->current.handleAstReplaced->continue;
                       
                    #);
                  
               #);
             
          #);
        astReplaced::  (#  do (oldAst[],newAst[])->handleAstReplaced;  #);
        
     #);
   (*
    * Undo and redo
    *)
   undoStack: @stack (# element:: operation;  #);
   redoStack: @stack (# element:: operation;  #);
   (*
    * Clipboard
    *)
   theClipBoard: @clipboard;
   (*
    * Mode
    *)
   mode: @integer;
   (* End of mode *)
   names: [29] ^text;
   initNames:
     (# 
     do
        'interfaceObject'->names[1][];
        'windowitem'->names[2][];
        'separator'->names[3][];
        'canvas'->names[4][];
        'abstractScroller'->names[5][];
        'scroller'->names[6][];
        'textEditor'->names[7][];
        'control'->names[8][];
        'button'->names[9][];
        'pushButton'->names[10][];
        'iconButton'->names[11][];
        'optionButton'->names[12][];
        'staticText'->names[13][];
        'toggleButton'->names[14][];
        'radioButton'->names[15][];
        'checkBox'->names[16][];
        'scrollbar'->names[17][];
        'editText'->names[18][];
        'textField'->names[19][];
        'scrollList'->names[20][];
        'textScrollList'->names[21][];
        'window'->names[22][];
        'menu'->names[23][];
        'menubar'->names[24][];
        'menuitem'->names[25][];
        'dynamicMenuitem'->names[26][];
        'scrollbar'->names[27][];
        'separator'->names[28][];
        'rect'->names[29][];
        
     #);
   contentsEditor: ^windowItemEditor;
   
#)  

