ORIGIN '../windowitemeditor';
INCLUDE 'graphicaleditorprivate'
        '~beta/sysutils/objinterface';

LIB_ITEM 'frigg_windowitem';

-- lib: Attributes --
setOriginOfStructure:
  (# structure: ##object; origin: ^object; 
  enter (structure##,origin[])
  do ((%getLongAt @@ structure)+8,%getLongAt @@ origin)->assignRef; 
  #);
  

-- windowitemEditorPrivate: Descriptor --
(# skip: @boolean; initializing: @boolean; pos: @integer;  #)  

-- windowItemEditorLib: Attributes --
makeWindowItem:
  (# type: ##object; new: ^windowItem; thisWindow: ^window; 
  do
     className[]->THIS(graphicalEditorEnv).private.compiledWindowItems.lookup
       ->type##;
     (if type## <> none then
         'got a type'->putLine;
         (* Change the origin of the Structure: *)
         (type##,THIS(window)[])->setOriginOfStructure;
         (if type## <= windowItemType## then
             'it works'->putLine; &type[]->new[]; 
         if);
         
     if);
     (if new[] = none then &windowItemType[]->new[];  if);
     
  exit new[]
  #);
findEnclosing:
  (# current: ^windowItemEditor; 
  do
     THIS(windowItemEditor)[]->current[];
     l:
     (if current.inherited then current.owner[]->current[]; restart l;  if);
     
  exit current[]
  #);
assertWindowItem:
  (#
     error:< exception
       (# 
       do
          '"theWindowItem" is NONE in "'->msg.putText;
          location->msg.putText;
          '"'->msg.putLine;
          INNER ;
          
       #);
     location:< (# value: ^text;  do INNER ;  exit value[] #);
     
  do (if theWindowItem[] <> none then INNER ;  else error;  if); 
  #);
skip: (#  enter private.skip exit private.skip #);
codeGuard:
  (# 
  do
     (if inherited or private.initializing then
         3->trace (#  do 'code-change disallowed'->xT #)
      else
         INNER ; 
     if);
     
  #);
(*
 * Code
 *)
prependOpenImp: codeGuard
  (#
     theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure: (#  do  #);
     
  enter imp[]
  do
       (# theImperatives: ^astInterface.beta.imperatives; 
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              theDoPart.getImperatives->theImperatives[];
              (1,imp[])->theImperatives.insert;
              theImperatives.frag[] -> removeDoneCheck;
              (theImperatives[],1)
                ->theImperatives.frag.notifyListElementInserted;
              theImperatives.frag[]->fragmentChanged;
              
          if);
          
       #);
     
  #);
handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do (theEvent[],theEvent.localPosition)->THIS(windowItemEditor).mousedown; 
  #);
handleFrameChanged: item.frameChangedAction
  (# r: ^rectangle; x,y,width,height: @integer; 
  do
     (if not inherited then
         (if item[] <> none then
             frame->r[];
             r.topLeft->(x,y);
             r.size->(width,height);
             (if not THIS(windowItemEditor).private.initializing then
                 (if THIS(windowItemEditor)[] <> ContentsEditor then
                     (x,y)->changePosition; 
                 if);
                 r.size->changeSize;
                 
             if);
             (if data[] <> none then
                 (if (THIS(windowItemEditor)[] <> contentsEditor) or
                 THIS(graphicalEditor).private.allowPositionChange then
                     (x,y)->data.position; 
                 if);
                 (width,height)->data.size;
                 (if selected then selectionChanged;  if);
                 
             if);
             
         if);
         
     if);
     
  #);
handleRefresh: theWindowItem.refreshAction
  (# 
  do
     (if outline then
         theWindowItem.graphics
           (# width,height: @integer
           do
              (if platform <> winnt then patterns.gray[]->pen.stipple if);
              item.size->(width,height);
              ((0,0),(width,height))->drawRect
           #)
     if)
  #);
  

-- windowItemEditorInitialize: DoPart --
do
   INNER ;
   (if not done then
         (#
            initializeData:
              (#
                 theData: ^parameters;
                 super: @boolean;
                 aNode: ^astInterface.beta.attributeDecl;
                 prefixName: ^text;
                 aComp: @betaPattern;
                 theAttributes: ^attributeList;
                 theImperatives: ^imperativeList;
                 inst: ^instantiator;
                 
              enter (theData[],aNode[],super)
              do
                 (if aNode[] <> none then
                     aNode[]->aComp.node[];
                     aComp.prefix->prefixName[];
                     (if prefixName[] <> none then
                         prefixName[]->lookup->inst[];
                         (if inst[] = none then
                             (theData[],aNode[]->getSuperPattern,true)
                               ->initializeData;
                             
                          else
                             (if not inst.basic then
                                 (theData[],inst.node[],true)->initializeData; 
                             if);
                             
                         if);
                         
                     if);
                     (if not super then theData[]->defaultData.set;  if);
                     aNode[]->getAttributes->(theAttributes[],theImperatives[]);
                     (theData[],theImperatives[])->initData;
                     
                 if);
                 
              #);
            
         do
            true->createTheWindowItem;
            (data[],node[],false)->initializeData;
            applyObjectData;
            
         #);
       
   if);
     

-- GraphicalEditorWindowItemEditorInit: DoPart --
do
     (#
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
        
     do
        node[]->getClassName->className[];
        node[]->getVertical->vertical;
        true->private.initializing;
        inherited->THIS(windowItemEditor).inherited;
        (if vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        initialize;
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.children.append; 
        if);
        INNER init;
        false->private.initializing;
        
     #);
     

-- GraphicalEditorWindowItemEditorNewData: DoPart --
do
     (# width,height: @integer; vertical: @boolean
     do
        &parameters[]->data[];
        data.init;
        (0,0)->data.position;
        (if vertical then
            '-vertical'->(name.copy).append->getDefaultSize->(width,height)
         else
            name[]->getDefaultSize->(width,height)
        if);
        10
          ->trace
            (# 
            do
               name[]->xT;
               '.newData'->xT;
               xN;
               'width = '->xT;
               width->xI;
               'height = '->xT;
               height->xI
            #);
        (if width = 0 then 300->width if);
        (if height = 0 then 200->height if);
        (width,height)->data.size;
        (if hasBindings then
            true->data.bindLeft;
            false->data.bindRight;
            true->data.bindTop;
            false->data.bindBottom;
            
        if);
        (if hasBorder then
            borderStyles.shadowOut->data.borderStyle;
            false->data.borderVisible;
            
        if);
        
     #);
   INNER  

-- windowItemEditorNewNode: DoPart --
do
     (# theAttributes: ^astInterface.beta.attributes; instanceName: ^text; 
     do
        owner.getMainAttributes->theAttributes[];
        (theAttributes[],className[])->newUniqueName->instanceName[];
        (theAttributes.frag[],instanceName[],className[])
          ->betaGram.newSingularItem->node[];
        
     #);
   INNER ;
     

-- windowitemEditornew: DoPart --
do
     (# inst: ^instantiator; theDoPart: ^astInterface.beta.doPart
     do
        className[]->lookup->inst[];
        false->inherited;
        (if vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        newNode;
        (if inst[] <> none then
            (if inst.path[] <> none then
                (node.frag.father,inst.path[])->addInclude
            if)
        if);
        initialize;
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.appendChild; 
        if);
        realCreateOpen->theDoPart[];
        (* (data[],true)->changeData; *)
        theDoPart[]->initDopart;
        
     #);
   INNER ;
     

-- windowItemEditorInitDopart: DoPart --
do INNER  

-- windowitemEditorMousedown: DoPart --
do
   INNER ;
   (if skip then
       false->private.skip
    else
       (if not (readOnly or inherited) then
           INNER mouseDown;
           (if theEvent.doubleClick then
               showPropertyInspector; 
            else
               (if not done then
                     (# actualMode: @integer; 
                     do
                        mode->actualMode;
                        (if theEvent.shiftKey then
                            (if selected then deSelect;  else select;  if); 
                         else
                            (if not selected then
                                selection.clear; select; 
                            if);
                            
                        if);
                        (if selected then
                            pt
                              ->theWindowItem.delay
                                (#  do theEvent[]->selection.drag;  #);
                            
                        if);
                        
                     #);
                   
               if);
               
           if);
           
       if);
       
   if);
     

-- IBwindowitemEditorapplyObjectData: DoPart --
do
     (# r: @rectangle; x,y,width,height: @integer; 
     do
        data.position->(x,y);
        data.size->(width,height);
        11
          ->trace
            (# 
            do
               comp.name->xT;
               '.applyObjectData'->xT;
               xN;
               'width: '->xT;
               width->xI;
               'height: '->xT;
               height->xI
            #);
        (if owner[] <> none then
            (x,y)->r.topLeft; (width,height)->r.size; r[]->frame
         else
            item.position->r.topLeft; (width,height)->r.size; r[]->frame
        if);
        
     #);
   (if hasBindings then
       data.bindLeft->item.bindLeft;
       data.bindRight->item.bindRight;
       data.bindTop->item.bindTop;
       data.bindBottom->item.bindBottom;
       
   if);
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   (if hasBorder then
       data.borderStyle->theWindowItem.border.style;
       data.borderVisible->theWindowItem.border.visible;
       
   if);
   INNER ;
     

-- windowItemEditorGetPublicAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       node[]->betaGram.getAttributes->theAttributes[]; 
   if);
     

-- windowItemEditorGetPrivateAttributes: DoPart --
do
     (#
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        
     do (if privateFrag[] <> none then
            
            privateFrag.root[]->theDescriptorForm[];
            theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
        if);
        
     #);
   INNER ;
     

-- windowItemEditorGetMainAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       getPrivateAttributes->theAttributes[];
       (if theAttributes[] = none then
           getPublicAttributes->theAttributes[]; 
       if);
       
   if);
     

-- windowItemEditorOutline: DoPart --
do not theWindowItem.border.visible->value; INNER  

-- GraphicalEdioterWindowItemEditorCreateWindowItem: DoPart --
do
   &wrapper[]->item[];
   (if owner[] <> none then
       owner.getMainCanvas->item.open;
       makeWindowItem->theWindowItem[];
       item[]->theWindowItem.open;
       
    else
       THIS(graphicalEditor).private.adorner.inside->item.open;
       makeWindowItem->theWindowItem[];
       item[]->theWindowItem.open;
       item[]->THIS(graphicalEditor).private.adorner.interior;
       
   if);
   (0,0)->theWindowItem.position;
   (if not initial then applyObjectData;  if);
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[]->theWindowItem.prependAction;
   &handleRefresh[]->theWindowItem.appendAction;
   &handleFrameChanged[]->item.appendAction;
   (if inherited then
       (theWindowItem[],none )->makeDelegateMousedownAction; 
   if);
   none ->theWindowItem.theCursor;
   INNER ;
     

-- makeDelegateMousedownAction: DoPart --
do
   (if enclosing[] = none then findEnclosing->enclosing[];  if);
   &aWindowItem.mousedownAction
     (# p: @point; 
     do
        theEvent.localPosition->p;
        (p,aWindowItem[],enclosing.theWindowItem[])->translate->p;
        (theEvent[],p)->enclosing.mouseDown;
        
     #)[]->aWindowitem.appendAction;
     

-- windowItemEditorChangedNode: doPart --
do closeWindowItem;
   children.clear;
   initialize;
   INNER;
