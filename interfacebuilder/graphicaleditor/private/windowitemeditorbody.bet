ORIGIN '../windowitemeditor';
INCLUDE 'graphicaleditorprivate'
	    'editorwindowbody';

INCLUDE '~beta/sysutils/v1.6/objinterface';

-- lib: attributes ---

setOriginOfStructure:
  (# structure: ##object;
     origin: ^object;
  enter (structure##, origin[])
  do ((%getLongAt @@structure) + 8, %getLongAt @@origin) -> assignRef;
  #);

-- windowitemEditorPrivate: Descriptor --
(#
   skip: @boolean;
   initializing: @boolean;
   pos: @integer;
   
#)  

-- windowItemEditorLib: Attributes --
makeWindowItem:
  (# type: ##object;
     new: ^windowItem;
     thisWindow: ^window;
  do className[] -> THIS(graphicalEditorEnv).private.compiledWindowItems.lookup -> type##;
     (if type## <> NONE then
         (* Change the origin of the Structure: *)
         (type##, this(window)[]) -> setOriginOfStructure;
               
         (if type## <= windowItemType## then
             &type[] -> new[];
         if);
     if);
     (if new[] = NONE then
         &windowItemType[] -> new[];
     if);
  exit new[] 
  #);

findEnclosing:
  (# current: ^windowItemEditor; 
  do
     THIS(windowItemEditor)[]->current[];
     l:
     (if current.inherited then current.owner[]->current[]; restart l;  if);
     
  exit current[]
  #);

assertWindowItem:
  (#
     error:< exception
       (# 
       do
          '"theWindowItem" is NONE in "'->msg.putText;
          location->msg.putText;
          '"'->msg.putLine;
          INNER ;
          
       #);
     location:< (# value: ^text;  do INNER ;  exit value[] #);
     
  do (if theWindowItem[] <> none then INNER ;  else error;  if); 
  #);

skip: (#  enter private.skip exit private.skip #);
codeGuard:
  (# 
  do
     (if inherited or private.initializing then
         3->trace (#  do 'code-change disallowed'->xT #)
      else
         INNER ; 
     if);
     
  #);



(*
 * Code
 *)

prependOpenImp: codeGuard
  (#
     theDoPart: ^astInterface.beta.doPart;
     imp: ^astInterface.beta.imp;
     failure: (#  do  #);
     
  enter imp[]
  do
       (# theImperatives: ^astInterface.beta.imperatives; 
       do
          forOpenStatements->findOpenDoPart->theDoPart[];
          (if theDoPart[] = none then
              failure; 
           else
              theDoPart.getImperatives->theImperatives[];
              (1,imp[])->theImperatives.insert;
              (true,theImperatives.frag[],theImperatives[],1)
                ->theFragServer.notifyListElementInserted;
              
          if);
          
       #);
     
  #);





handleMouseDown: theWindowItem.mouseDownAction
  (# 
  do (theEvent[],theEvent.localPosition)->THIS(windowItemEditor).mousedown; 
  #);
handleFrameChanged: item.frameChangedAction
  (# r: ^rectangle; x,y,width,height: @integer; 
  do
     3
       ->trace
         (# 
         do
            '-----------------------------------------'->xT;
            xN;
            ' HandleFrameChanged: '->xT;
            
         #);
     (if item[] <> none then
         frame->r[];
         r.topLeft->(x,y);
         r.size->(width,height);
         3
           ->trace
             (# 
             do
                ' x = '->xT;
                x->xI;
                ' y = '->xT;
                y->xI;
                xN;
                ' width = '->xT;
                width->xI;
                ' height = '->xT;
                height->xI;
                
             #);
         (if not dontHandleFrameChanged then
             3->trace (#  do ' Change the Actual Code'->xT;  #);
             (if THIS(windowItemEditor)[] <> ContentsEditor then
                 14
                   ->trace
                     (# 
                     do comp.name->xT; '.changeFrame'->xT; xN; 
                     #);
                 (x,y)->changePosition;
                 
             if);
             r.size->changeSize;
             
         if);
         (if data[] <> none then
             (if (THIS(windowItemEditor)[] <> contentsEditor) or
             THIS(graphicalEditor).private.allowPositionChange then
                 14->trace (#  do ' setting data.position'->xT; xN #);
                 (x,y)->data.position;
                 
             if);
             3->trace (#  do ' setting data.size'->xT;  #);
             (width,height)->data.size;
             (if selected then selectionChanged;  if);
             
         if);
         
     if);
     3->trace (#  do '-----------------------------------------'->xT; xN #);
     
  #);
handleRefresh: theWindowItem.refreshAction
  (# 
  do
     (if outline then
         theWindowItem.graphics
           (# width,height: @integer
           do
              (if platform <> winnt then patterns.gray[]->pen.stipple if);
              item.size->(width,height);
              ((0,0),(width-1,height-1))->drawRect
           #)
     if)
  #);
  


-- windowItemEditorInitialize: DoPart --
do
   INNER ;
   (if not done then
         (#
            initializeData:
              (#
                 aClassData: ^classData;
                 theData: ^parameters;
                 super: @boolean;
                 
              enter (theData[],aClassData[],super)
              do
                 (if aClassData[] <> none then
                     (theData[],aClassData.superClassData[],true)
                       ->initializeData;
                     (if not super then
                         4
                           ->trace
                             (#  do 'data[] -> defaultData.set;'->xT;  #);
                         data[]->defaultData.set;
                         
                     if);
                     (theData[],aClassData.theImperatives[])->initData;
                     applyObjectData;
                     
                 if);
                 
              #);
            
         do
            true->createTheWindowItem;
            (data[],theClassData[],false)->initializeData;
            12->trace (#  do 'initializeData:'->xT; xN; data[]->xData #);
            
         #);
       
   if);
     

-- GraphicalEditorWindowItemEditorInit: DoPart --
do
     (#
        theDoPart: ^astInterface.beta.doPart;
        theImperatives: ^astInterface.beta.imperatives;
		
     do
        theClassData.className[]->className[];
        true->private.initializing;
        inherited->THIS(windowItemEditor).inherited;
        10->trace (#  do 'init windowitem'->xT #);
        (if theClassData.vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        4->trace (#  do 'type -> makeData -> defaultData[]'->xT;  #);
        initialize;
        (*  defaultData.data.storage.scan
         *       (# 
         *       do (current.key[], current.value[]) -> data.data.define;
         *       #);
         *)
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.children.append; 
        if);
        INNER init;
        false->private.initializing;
        6
          ->trace
            (# 
            do
               comp.name->xT;
               ' defaultdata: '->xT;
               xN;
               defaultData[]->xData
            #);
        6
          ->trace
            (# 
            do comp.name->xT; ' data '->xT; xN; data[]->xData
            #);
        
     #);
     

-- GraphicalEditorWindowItemEditorNewData: DoPart --
do
     (# width,height: @integer; vertical: @boolean
     do
        &parameters[]->data[];
        data.init;
        (0,0)->data.position;
        (if vertical then
            '-vertical'->(name.copy).append->getDefaultSize->(width,height)
         else
            name[]->getDefaultSize->(width,height)
        if);
        10
          ->trace
            (# 
            do
               name[]->xT;
               '.newData'->xT;
               xN;
               'width = '->xT;
               width->xI;
               'height = '->xT;
               height->xI
            #);
        (if width = 0 then 300->width if);
        (if height = 0 then 200->height if);
        (width,height)->data.size;
        (if hasBindings then
            true->data.bindLeft;
            false->data.bindRight;
            true->data.bindTop;
            false->data.bindBottom;
            
        if);
        (if hasBorder then
            borderStyles.shadowOut->data.borderStyle;
            false->data.borderVisible;
            
        if);
        
     #);
   INNER  
   
-- windowItemEditorNewNode: DoPart --
do
     (# theAttributes: ^astInterface.beta.attributes; instanceName: ^text; 
     do
        owner.getMainAttributes->theAttributes[];
        (theAttributes[],className[])->newUniqueName->instanceName[];
        (theAttributes.frag[],instanceName[],className[])
          ->betaGram.newSingularItem->node[];
        
     #);
   INNER ;
-- windowitemEditornew: DoPart --
do
     (# inst: ^instantiator; theDoPart: ^astInterface.beta.doPart
     do
        className[]->lookup->inst[];
        false->inherited;
        10->trace (#  do 'new windowitem'->xT #);
        (if vertical then
            '-vertical'->(className.copy).append->newData->data[]
         else
            className[]->newData->data[]
        if);
        makeData->defaultData[];
        newNode;
        node[]->getClassData->theClassData[];
        realCreateOpen->theDoPart[];
        node[]->owner.appendAttribute;
        (if inst[] <> none then
            (if inst.path[] <> none then
                (node.frag.father,inst.path[])->addInclude
            if)
        if);
        true->createTheWindowItem;
        applyObjectData;
        (if owner[] <> none then
            THIS(windowitemEditor)[]->owner.appendChild; 
        if);
        (data[],true)->changeData;
        theDoPart[]->initDopart;
        
     #);
   INNER ;
     
-- windowItemEditorInitDopart: DoPart --
do 8->trace (#  do 'init dopart, node = '->xT; xN; node[]->xA #); INNER  
-- windowitemEditorMousedown: DoPart --
do
   INNER ;
   (if skip then
       false->private.skip
    else
       (if not (readOnly or inherited) then
           INNER mouseDown;
           (if theEvent.doubleClick then
               showPropertyInspector; 
            else
               (if not done then
                     (# actualMode: @integer; 
                     do
                        mode->actualMode;
                        (if theEvent.shiftKey then
                            (if selected then
                                deSelect; 
                             else
                                select; 
                            if);
                            
                         else
                            (if not selected then
                                selection.clear; select; 
                            if);
                            
                        if);
                        (if selected then
                            pt
                              ->theWindowItem.delay
                                (#  do theEvent[]->selection.drag;  #);
                            
                        if);
                        
                     #);
                   
               if);
               
           if);
           
       if);
       
   if);
     
-- IBwindowitemEditorapplyObjectData: DoPart --
do
     (# r: @rectangle; x,y,width,height: @integer; 
     do
        data.position->(x,y);
        data.size->(width,height);
        11
          ->trace
            (# 
            do
               comp.name->xT;
               '.applyObjectData'->xT;
               xN;
               'width: '->xT;
               width->xI;
               'height: '->xT;
               height->xI
            #);
        (if owner[] <> none then
            (x,y)->r.topLeft; (width,height)->r.size; r[]->frame
         else
            item.position->r.topLeft; (width,height)->r.size; r[]->frame
        if);
        
     #);
   (if hasBindings then
       data.bindLeft->item.bindLeft;
       data.bindRight->item.bindRight;
       data.bindTop->item.bindTop;
       data.bindBottom->item.bindBottom;
       
   if);
   (* data.visible -> theWindowItem.visible;
    *    data.hilite -> theWindowItem.hilite;
    *    data.enabled -> theWindowItem.enabled; 
    *)
   (if hasBorder then
       data.borderStyle->theWindowItem.border.style;
       data.borderVisible->theWindowItem.border.visible;
       
   if);
   INNER ;
     
-- windowItemEditorGetPublicAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       node[]->betaGram.getAttributes->theAttributes[]; 
   if);
     
-- windowItemEditorGetPrivateAttributes: DoPart --
do
     (#
        theDescriptorForm: ^astInterface.beta.descriptorForm;
        theObjectDescriptor: ^astInterface.beta.objectDescriptor;
        theMainPart: ^astInterface.beta.mainPart;
        
     do
        (if privateFrag[] <> none then
            privateFrag.root[]->theDescriptorForm[];
            theDescriptorForm.getObjectDescriptor->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            
        if);
        
     #);
   INNER ;
     
-- windowItemEditorGetMainAttributes: DoPart --
do
   INNER ;
   (if theAttributes[] = none then
       getPrivateAttributes->theAttributes[];
       (if theAttributes[] = none then
           getPublicAttributes->theAttributes[]; 
       if);
       
   if);
     
-- windowItemEditorOutline: DoPart --
do not theWindowItem.border.visible->value; INNER  

-- GraphicalEdioterWindowItemEditorCreateWindowItem: DoPart --
do 
   &wrapper[]->item[];
   (if owner[] <> none then
       owner.getMainCanvas->item.open;
       makeWindowItem -> theWindowItem[];
       item[]->theWindowItem.open;
    else
       THIS(editorWindow).private.adorner.inside->item.open;
       
       makeWindowItem->theWindowItem[];
       item[]->theWindowItem.open;
       item[]->THIS(editorWindow).private.adorner.interior;
       
   if);
   (0, 0) -> theWindowItem.position;
   (if not initial then applyObjectData;  if);
   theWindowItem.disableDefaultBehaviour;
   &handleMouseDown[]->theWindowItem.prependAction;
   &handleRefresh[]->theWindowItem.appendAction;
   &handleFrameChanged[]->item.appendAction;
   (if inherited then
       (theWindowItem[],none )->makeDelegateMousedownAction; 
   if);
   none ->theWindowItem.theCursor;
   INNER ;
     
-- makeDelegateMousedownAction: DoPart --
do
   (if enclosing[] = none then findEnclosing->enclosing[];  if);
   &aWindowItem.mousedownAction
     (# p: @point; 
     do
        theEvent.localPosition->p;
        (p,aWindowItem[],enclosing.theWindowItem[])->translate->p;
        (theEvent[],p)->enclosing.mouseDown;
        
     #)[]->aWindowitem.appendAction;
     
