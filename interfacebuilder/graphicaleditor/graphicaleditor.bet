ORIGIN '~beta/guienv/guienvall';
INCLUDE '../resourcesupport/parameters'
        'dictionary'
        '../resourcesupport/easyinterface'
        '../prettyprinter/prettyprinter'
        '~beta/mps/astlevel'
        '~beta/betaast/betacfl'
        '~beta/betaast/gram'
        '../dialogs/textlist'
        '../fragmenthandler/fragmenthandler'
        '~beta/containers/list'
        '~beta/containers/sets'
		'../component/component'
        'editorwindow'
        '../support/draganddrop';
BODY 'private/graphicaleditorprivate';
-- lib: Attributes --
entryExists: booleanValue
  (# name: ^text;  enter name[] <<SLOT entryExistsBody:DoPart>> #);
entryReadable: booleanValue
  (# name: ^text; 
  enter name[]
  <<SLOT entryReadableBody:DoPart>>
  #);
entryWriteable:
 booleanValue
  (# name: ^text;  enter name[] <<SLOT entryWriteAbleBody:DoPart>> #);
  

-- guienvLib: Attributes --
displayMessage:
  (# msg: ^text;  enter msg[] do (none ,msg[],'Alert')->noteUser;  #);
graphicalEditorEnv:
  (#
     <<SLOT graphicalEditorEnvLib:Attributes>>;
     graphicalEditor: editorWindow
       (#
          <<SLOT graphicalEditorLib:Attributes>>;
          readOnly: @boolean;
          menubarType::< 
            (#
               open::< 
                 (# 
                 <<SLOT InterfaceBuilderGraphicalEditorWindowMenubarOpen:DoPart>>
                 #);
               
            #);
          mousedownInItem:: 
            (#  <<SLOT graphicalEditorMousedownInItem:DoPart>> #);
          node:
            ^astInterface.beta.
               attributeDecl;
		  comp: @component;
          privateAttributes:
            (# value: @boolean
            enter
              (# 
              enter value
              <<SLOT GraphicalEditorEnterPrivateAttributes:DoPart>>
              #)
            exit
              (# 
              <<SLOT GraphicalEditorExitPrivateAttributes:DoPart>>
              exit value
              #)
            #);
          privateDoParts:
            (# value: @boolean
            enter
              (# 
              enter value
              <<SLOT GraphicalEditorEnterPrivateDoParts:DoPart>>
              #)
            exit
              (# 
              <<SLOT GraphicalEditorExitPrivateDoPart:DoPart>>
              exit value
              #)
            #);
          componentEditorList: sequence
            (#
               element:: componentEditor;
               copy:
                 (# theCopy: ^componentEditorList; 
                 <<SLOT windowItemEditorListCopy:DoPart>>
                 exit theCopy[]
                 #);
               set:
                 (#
                    theOther:
                      ^componentEditorList;
                    
                 enter theOther[]
                 <<SLOT windowItemEditorListSet:DoPart>>
                 #);
               
            #);
          componentEditor:
            (#
               <<SLOT componentEditorLib:Attributes>>;
               node: ^astInterface.beta.attributeDecl;
			   comp: @component;
               className: ^text;
               owner: ^componentEditor;
               windowitemType:< windowitem;
               theWindowitem: ^windowitemType;
               accept:< booleanValue
                 (# dragee: ^proxy enter dragee[] do INNER #);
               recieve:<
                 (# dragee: ^proxy; bounds: ^rectangle; 
                 enter (bounds[],dragee[])
                 do INNER ; 
                 #);
               wrapper: reciever
                 (#
                    drageeType:: proxy;
                    hilite::  (#  <<SLOT wrapperHilite:DoPart>> #);
                    lowlite:: 
                      (# 
                      <<SLOT wrapperLowlite:DoPart>>
                      #);
                    accept:: 
                      (# 
                      do dragee[]->THIS(componentEditor).accept->value
                      #);
                    recieve:: 
                      (# 
                      do (bounds[],dragee[])->THIS(componentEditor).recieve
                      #);
                    eventHandler::< 
                      (#
                         handlingChildFrameChanged: @boolean;
                         onFrameChanged::< 
                           (# 
                           do
                              (if not handlingChildFrameChanged then
                                  size->theWindowItem.size
                              if)
                           #);
                         onChildFrameChanged::< 
                           (# 
                           do
                              true->handlingChildFrameChanged;
                              theWindowItem.size->size;
                              false->handlingChildFrameChanged
                           #)
                      #)
                 #);
               item: ^wrapper;
               vertical: @boolean;
               defaultData,data: ^parameters;
               privateFrag: ^astInterface.fragmentForm;
               editAttributes:
                 (# 
                 <<SLOT GraphicalEditorWindowItemEditorEditAttributes:DoPart>>
                 #);
               editVirtual:
                 (# name: ^text; 
                 enter name[]
                 <<SLOT GraphicalEditorWindowItemEditorEditVirtual:DoPart>>
                 #);
               init:<
                 (#
                    inherited: @boolean;
                    initialize:< (# done: @boolean;  do INNER #);
                    
                 enter
                 (owner[],node[],data[],inherited,privateFrag[])
                 do node[] -> comp.node[];
				 	INNER
                 #);
               newData:<
                 (# data: ^parameters; name: ^text; 
                 enter name[]
                 do INNER
                 exit data[]
                 #);
               new:<
                 (# newNode:< (#  do INNER; node[] -> comp.node[]; #); 
                 enter (owner[],className[])
                 do INNER
                 #);
               initDopart:<
                 (# theDoPart: ^astInterface.beta.doPart
                 enter theDoPart[]
                 do INNER
                 #);
              select:
                 (# 
                 <<SLOT windowItemEditorSelect:DoPart>>
                 #);
               deSelect: (#  <<SLOT windowItemEditorDeSelect:DoPart>> #);
               close:< (#  do INNER #);
               mousedown:<
                 (#
                    done: @boolean;
                    theEvent: ^windowItem.eventHandler.mouseDown;
                    pt: @point;
                    
                 enter (theEvent[],pt)
                 do INNER
                 #);
               applyObjectData:< (#  do INNER #);
               findEditor:<
                 (#
                    pt: @point;
                    ignoreEditor: ^componentEditor;
                    theEditor: ^componentEditor;
                    
                 enter (pt,ignoreEditor[])
                 do INNER
                 exit theEditor[]
                 #);
               appendChild:<
                 (# child: ^componentEditor;
                 enter child[]
                 do INNER;
                 #);
               deleteChild:<
                 (# child: ^componentEditor;
                 enter child[]
                 do INNER;
                 #);
               getPublicAttributes:<
                 (# theAttributes: ^astInterface.beta.attributes; 
                 do INNER
                 exit theAttributes[]
                 #);
               getPrivateAttributes:<
                 (# theAttributes: ^astInterface.beta.attributes; 
                 do INNER
                 exit theAttributes[]
                 #);
               getMainAttributes:<
                 (# theAttributes: ^astInterface.beta.attributes; 
                 do INNER
                 exit theAttributes[]
                 #);
               getMainNode:<
                 (# theNode: ^astInterface.beta.attributeDecl; 
                 do node[]->theNode[]; INNER ; 
                 exit theNode[]
                 #);
               getMainCanvas:<
                 (# theCanvas: ^canvas; 
                 do theWindowItem[]->theCanvas[]; INNER ; 
                 exit theCanvas[]
                 #);
			   copy:
			     (# frag: ^astInterface.fragmentForm;
				 	newNode: ^astInterface.expanded;
				 	theCopy: ^componentEditor;
				 enter (frag[], newNode[])
				 <<SLOT componentEditorCopy: doPart>>
				 exit theCopy[]
				 #);
               outline:< booleanValue (#  do INNER #);
               createTheWindowItem:<
                 (# initial: @boolean;  enter initial do INNER #);
               hasBorder:< booleanValue (#  do true->value; INNER #);
               hasBindings:< booleanValue (#  do true->value; INNER #);
			   children:
                 @componentEditorList;
			   selected, inherited: @boolean;
            #);
                    
          proxy:
            (#
               palette: @boolean;
               moveTo:<
                 (# theCanvasEditor: ^componentEditor; newFrame: ^rectangle; 
                 enter (theCanvasEditor[],newFrame[])
                 do INNER ; 
                 #);
               
            #);
          
          (* 
           * Mode
           *)
          selectMode: (#  exit 1 #);
          hierarkiMode: (#  exit 2 #);
          resizeMode: (#  exit 3 #);
          mode:
            (# value: @integer; 
            enter
              (#  enter value <<SLOT graphicalEditorEnterMode:DoPart>> #)
            exit
              (# 
              <<SLOT graphicalEditorExitMode:DoPart>>
              exit value
              #)
            #);
          (*
           * Init
           *)
          init:< (#  enter node[] <<SLOT GraphicalEditorInit:DoPart>> #);
          new:<
            (# 
            enter node[]
            <<SLOT GraphicalEditorNew:DoPart>>
            #);
          (*
           * Selection
           *)
          canUndo: booleanValue
            (#  <<SLOT graphicalEditorCanUndo:DoPart>> #);
          undo:
            (# 
            <<SLOT graphicalEditorUndo:DoPart>>
            #);
          undoText:
            (# value: ^text; 
            <<SLOT graphicalEditorUndoText:DoPart>>
            exit value[]
            #);
          canRedo: booleanValue
            (# 
            <<SLOT graphicalEditorCanRedo:DoPart>>
            #);
          redo: (#  <<SLOT graphicalEditorRedo:DoPart>> #);
          redoText:
            (# value: ^text; 
            <<SLOT graphicalEditorRedoText:DoPart>>
            exit value[]
            #);
          canPaste: booleanValue
            (#  <<SLOT graphicalEditorCanPaste:DoPart>> #);
          paste:
            (# 
            <<SLOT graphicalEditorPaste:DoPart>>
            #);
          selection: @componentEditorList
            (#
               <<SLOT selectionLib:Attributes>>;
               append:: 
                 (# 
                 <<SLOT selectionAppend:DoPart>>
                 #);
               prepend::  (#  <<SLOT selectionPrepend:DoPart>> #);
               delete:: 
                 (# 
                 <<SLOT selectionDelete:DoPart>>
                 #);
               clear::  (#  <<SLOT selectionClear:DoPart>> #);
               (* Actions *)
               deleteAll:
                 (# 
                 <<SLOT GraphicalEditorSelectionDelete:DoPart>>
                 #);
               alignLeft:
                 (#  <<SLOT GraphicalEditorSelectionAlignLeft:DoPart>> #);
               alignRight:
                 (# 
                 <<SLOT GraphicalEditorSelectionAlignRight:DoPart>>
                 #);
               alignTop:
                 (#  <<SLOT GraphicalEditorSelectionAlignTop:DoPart>> #);
               alignBottom:
                 (# 
                 <<SLOT GraphicalEditorSelectionAlignBottom:DoPart>>
                 #);
               alignHorCenter:
                 (# 
                 <<SLOT GraphicalEditorSelectionAlignHorCenter:DoPart>>
                 #);
               alignVerCenter:
                 (# 
                 <<SLOT GraphicalEditorSelectionAlignVerCenter:DoPart>>
                 #);
               fitToContents:
                 (# 
                 <<SLOT GraphicalEditorSelectionFitToContents:DoPart>>
                 #);
               showSpacingDialog:
                 (# 
                 <<SLOT GraphicalEditorSelectionShowSpacingDialog:DoPart>>
                 #);
               doCopy:
                 (# 
                 <<SLOT graphicalEditorSelectionDoCopy:DoPart>>
                 #);
               doCut: (#  <<SLOT graphicalEditorSelectionDoCut:DoPart>> #);
               
            #);
          open::< 
            (# width,height: @integer; 
            enter (width,height)
            <<SLOT graphicalEditorOpen:DoPart>>
            #);
          close::< 
            (# 
            <<SLOT graphicalEditorClose:DoPart>>
            #);
          eventHandler::< 
            (#
               onMouseDown::< 
                 (#  <<SLOT graphicalEditorOnMouseDown:DoPart>> #);
               onAboutToClose::< 
                 (# 
                 <<SLOT graphicalEditorOnAboutToClose:DoPart>>
                 #);
               onActivate::< 
                 (#  <<SLOT graphicalEditorOnActivate:DoPart>> #);
               onDeactivate::< 
                 (# 
                 <<SLOT graphicalEditorOnDeactivate:DoPart>>
                 #)
            #);
          clearSelection:: 
            (#  <<SLOT graphicalEditorClearSelection:DoPart>> #);
          onSelectEntire:: 
            (# 
            <<SLOT graphicalEditorOnSelectEntire:DoPart>>
            #);
          private: @<<SLOT graphicalEditorPrivateAttributes:Descriptor>>;
          
       #);
     instantiator:
       (#
          <<SLOT instantiatorLib:Attributes>>;
          init:<
           (#  <<SLOT instantiatorInit:DoPart>> #);
          copyName:
            (#
               newName: ^text;
               copy: ^instantiator
            enter newName[]
            <<SLOT instantiatorCopyName:DoPart>>
            exit copy[]
            #);
          scanAttributes:
            (#
               whenPartObject:<
                 (# current: ^astInterface.beta.attributeDecl
                 enter current[]
                 do INNER
                 #)
            <<SLOT instantiatorScanAttributes:DoPart>>
            #);
          theGraphicalEditor:
            ^graphicalEditor;
          editorType:< theGraphicalEditor.componentEditor;
          theWindowItemEditor: ^editorType;
          name: ^text;
          grouping: ^text;
          node: ^astInterface.beta.patternDecl;
          path: ^text;
          icon: ^pixmap;
          width,height: @integer;
          scripts: ^textList;
          
       enter theGraphicalEditor[]
       do &editorType[]->theWindowItemEditor[]; none ->theGraphicalEditor[]; 
       exit theWindowItemEditor[]
       #);
     factory: @
       (#
          insert:
            (#
               name: ^text;
               grouping: ^text;
               inst: ^instantiator;
               icon: ^pixmap;
               scripts: ^textList;
               path: ^text;
               width,height: @integer;
               
            enter (icon[],name[],inst[],path[],grouping[],width,height)
            do
               name[]->inst.name[];
               icon[]->inst.icon[];
               path[]->inst.path[];
               grouping[]->inst.grouping[];
               width->inst.width;
               height->inst.height;
               inst.init;
               (name[],inst[])->insts.define;
               
            #);
          scan:
            (# current: ^instantiator
            do
               insts.storage.scan
                 (#  do current.elm[]->THIS(scan).current[]; INNER scan #)
            #);
          instantiate:
            (#
               theGraphicalEditor: ^graphicalEditor;
               name: ^text;
               theWindowItemEditor: ^graphicalEditor.componentEditor;
               
            enter (theGraphicalEditor[],name[])
            <<SLOT factoryInstantiate:DoPart>>
            exit theWindowItemEditor[]
            #);
          defined: booleanValue
            (# name: ^text;  enter name[] <<SLOT factoryDefined:DoPart>> #);
          lookup:
            (# name: ^text; theInstantiator: ^instantiator; 
            enter name[]
            <<SLOT factoryLookup:DoPart>>
            exit theInstantiator[]
            #);
          init:
            (#  <<SLOT factoryInit:DoPart>> #);
          insts:
            @dictionary (# element:: instantiator;  #);
          
       #);
     insertCustom:
       (#
          theInstantiator: ^instantiator;
          name: ^text;
          path: ^text;
          iconName: ^text;
          iconID: @integer;
          width,height: @integer;
          grouping: ^text;
          
       enter
       (name[],theInstantiator[],path[],grouping[],iconName[],iconID,width,
        height)
       <<SLOT graphicalEditorEnvInsertCustom:DoPart>>
       #);
     addPatternToPalette:
       (#
          node:
            ^astInterface.beta.
               patternDecl;
          
       enter node[]
       <<SLOT graphicalEditorEnvAddPatternToPalette:DoPart>>
       #);
     commands:<
       (#
          dynamicCompilationAvailable:< booleanValue (#  do INNER ;  #);
          evaluateFile:<
            (# name: ^text; theOrigin: ^object; P: ##object; 
            enter (name[],theOrigin[])
            do INNER ; 
            exit P##
            #);
          compilePattern:<
            (# node: ^astInterface.beta.patternDecl;
               theOrigin: ^object;
               structure: ##object;
            enter (node[], theOrigin[])
            do INNER
            exit structure##
            #);
          compileFile:<
            (# fname, pname: ^text;
               theOrigin: ^object;
               structure: ##object;
            enter (fname[], pname[], theOrigin[])
            do inner
            exit structure##
            #);
          prettyPrintGroup:<
            (# group: ^astInterface.fragmentGroup; name: ^text
            enter (group[],name[])
            do INNER
            #);
          showParseErrors:< (# msg: ^text;  enter msg[] do INNER ;  #);
          autoSaveGroup:<
            (# fg: ^astInterface.fragmentGroup; 
            enter fg[]
            do INNER ; 
            #);
          saveFragmentGroup:<
            (# fg: ^astInterface.fragmentGroup; 
            enter fg[]
            do INNER ; 
            #);
          quitApplication:< (#  do INNER #);
          openAstEditor:< openAstEditorMethod;
          createSourceFile:<
            (#
               fileName,fragName: ^text;
               group: ^astInterface.fragmentGroup;
               frag: ^astInterface.fragmentForm;
               
            enter (fileName[],fragName[])
            <<SLOT createSourceFile:DoPart>>
            exit frag[]
            #);
          
       #);
     MPS: ^astInterface;
     betaGram: ^astInterface.beta;
     pretty: ^astInterface.prettyPrinter;
     gram: @grammar;
     theFragServer: ^fragmentServer;
     com: @commands;
     makeFragmentForm:
       (# frag: ^astInterface.fragmentForm; 
       do
          betaGram[]->mps.newFragmentForm
            ->frag[];
          
       exit frag[]
       #);
     platform: integerValue
       (# 
       <<SLOT graphicalEditorPlatform:DoPart>>
       #);
     winnt: (#  exit 1 #);
     mac: (#  exit 2 #);
     X11: (#  exit 3 #);
     attributeList: list (# element:: betaGram.attributeDecl;  #);
     imperativeList: list (# element:: betaGram.imp;  #);
     checkIdentifier: booleanValue
       (#
          name: ^text;
          frag: ^astInterface.fragmentForm;
          nameDecl: ^astInterface.beta.nameDcl;
          
       enter name[]
       <<SLOT checkIdentifierDoPart:DoPart>>
       #);
     createNewWindow:
       (# name: ^text
       enter name[]
       <<SLOT createNewWindow:DoPart>>
       #);
     createWindow:
       (# frag: ^astInterface.fragmentForm; name,className: ^text; 
       enter (frag[],name[],className[])
       <<SLOT friggApplicationCreateWindow:DoPart>>
       #);
     openAstEditorMethod:
       (# node: ^astInterface.AST; title: ^text; 
       enter (node[],title[])
       do INNER ; 
       #);
     onGroupOpen:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER ;  #);
     onGroupChanged:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER ;  #);
     onGroupSaved:<
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER ;  #);
     init:<
       (# 
       enter (theFragServer[],MPS[],betaGram[],pretty[])
       <<SLOT graphicalEditorEnvInit:DoPart>>
       #);
     find:
       (# node: ^astInterface.beta.attributeDecl; editor: ^graphicalEditor; 
       enter node[]
       <<SLOT graphicalEditorEnvFind:DoPart>>
       exit editor[]
       #);
     getClassName:
     	(# 	node: ^astInterface.beta.attributeDecl;
     		className: ^text;
     	enter node[]
     	<<SLOT graphicalEditorEnvGetClassName: doPart>>
     	exit className[]
     	#);
     getVertical:
     	(# node: ^astInterface.beta.attributeDecl;
     	   vertical: @boolean;
     	enter node[]
     	<<SLOT graphicalEditorEnvGetVertical: doPart>>
     	exit vertical
     	#);
     trace:
       (#
          xT:
            (# xT: ^text
            enter xT[]
            do xT[]->tracestream.putText
            #);
          xC:
            (# c: @char; 
            enter c
            do c->tracestream.put; 
            #);
          xI:
            (# n: @integer
            enter n
            do
               ' '->tracestream.put;
               n->tracestream.putint;
               ' '->tracestream.put
            #);
          xB:
            (# b: @boolean
            enter b
            do
               (if b then
                   ' true '
                     ->traceStream.puttext
                else
                   ' false '->traceStream.puttext
               if)
            #);
          xA:
            (# T: ^astInterface.AST; 
            enter T[]
            do
               (if T[] = none then
                   ' NONE '->traceStream.putText; 
                else
                   (T[],traceStream[])->pretty.printNode; 
               if);
               xN;
               
            #);
          xN: (#  do tracestream.newline #);
          xData:
            (# d: ^parameters
            enter d[]
            do
               d.data.storage.scan
                 (# 
                 do
                    current.key[]->xT;
                    (if current.value.type
                     // textType then
                        (current.value.asTextAtom).value[]->xT; xN
                     // boolType then
                        (current.value.asBoolAtom).value->xB; xN
                     // intType then
                        (current.value.asIntAtom).value->xI; xN
                    if)
                 #)
            #);
          no: @integer;
          
       enter no
       do (if switch[no] then Xn; '$'->xC; no->xI; ':'->xC; INNER ;  if); 
       #);
     traceStream: ^stream;
     switch: [255] @boolean;
     private: @<<SLOT graphicalEditorEnvPrivate:Descriptor>>;
     
  #);
  

-- graphicalEditorLib: Attributes --
verScrollbar: scrollbar (# vertical::  (#  do true->value #);  #);
verSeparator: separator (# vertical::  (#  do true->value #);  #);
  

