ORIGIN '../followsemanticlink';
INCLUDE '~beta/betaast/v5.1/betasematt';
INCLUDE '~beta/betaast/v5.1/gram';


-- followSemanticLinkBody: doPart --
do (# betagrammar: @grammar;
      myIndexToNode:
        (#
           inx: @integer;
           as: ^astInterface.ast;
           indexOutOfRange:< mps.astInterfaceException;
           noSuchSymbol:< mps.astInterfaceException;
           grammarGenRefArrayError:< mps.astInterfaceException;
           symbol,val: @integer;
           errorMsg:
             (# n: @integer; msg: ^text
             enter n
             do
                '*** Error in IndexToNode:'->msg[];
                '\nIndex='->msg.puttext;
                inx->msg.putint;
                '\nSymbol='->msg.puttext;
                symbol->msg.putint;
                '\nVal='->msg.puttext;
                val->msg.putint;
                msg.newline
             exit msg[]
             #);
           ff: ^astInterface.fragmentForm;
           
        enter (inx,ff[])
        do
           l:
             (if true
              // (0 < inx) and (inx <= ff.a.range) then
                 ff.a[inx]->val->tos'%GetSignedBits[4,12]'->symbol;
                 (if true
                  // (0 < symbol) and (symbol <= ff.grammar.genRefArray.range) then
                     (if ff.grammar.genRefArray[symbol]->as[]
                      // none then (* IndexToNode: genRefArray problem *)
                         errorMsg->grammarGenRefArrayError; leave l
                     if)
                  else
                     (if symbol
                      // mps.prodNo.unExpanded then
                         &mps.UnExpanded[]->as[]
                      // mps.prodNo.optional then
                         &mps.Optional[]->as[]
                      // mps.prodNo.nameDecl then
                         &mps.NameDecl[]->as[]
                      // mps.prodNo.nameAppl then
                         &mps.NameAppl[]->as[]
                      // mps.prodNo.string then
                         &mps.String[]->as[]; 
                      // mps.prodNo.Const then
                         &mps.Const[]->as[]; 
                      // mps.prodNo.Comment then
                         &mps.Comment[]->as[]
                      // mps.prodNo.SlotDesc then
                         &mps.SlotDesc[]->as[]
                      else
                         (* IndexToNode: no match for symbol! *)
                         none ->as[]; errorMsg->noSuchSymbol; leave l
                     if)
                 if);
                 inx->as.index;
                 ff[]->as.frag[]
              // (0 = inx) then (* Zero index is the same as a NONE ast *)
                 none ->as[]
              else
                 (* IndexToNode: index out of range *)
                 none ->as[]; errorMsg->indexOutOfRange
             if)
        exit as[]
        #);

      myIsRealOpen:
        (# fg: ^astInterface.fragmentGroup; isOpen: @boolean
        enter fg[]
        do
           scanner: fg.fragmentList.scan
             (# 
             do
                (if current.type = mps.formType then
                    (if (current.f[] <> none ) then
                        true->isOpen
                     else
                        false->isOpen; leave scanner
                    if)
                if)
             #)
        exit isOpen
        #);

      myGetGroup:
        (* Private: The inverse of GetIndex; If the group is not open then open it *)
        (#
           ff,f: ^astInterface.FragmentForm;
           Index: @integer;
           importException:< mps.AstInterfaceException;
           error: ^stream;
           openForm:
             (# fg: ^astInterface.fragmentGroup; name: ^Text; i: @Integer; 
             enter name[]
             do
                '-'->name.findAll (#  do inx->i #);
                ((1,i-1)->name.sub,screen[])->mps.top.open->fg[];
                ((i+1,name.lgth)->name.sub,screen[])->fg.open->f[];
                
             #);
           
        enter (ff[],index)
        do
           thisOp:
             (# 
             do
                (if (ff[] = none ) then leave thisOp;  if);
                (if (ff.import.impL[] = none ) then leave thisOp;  if);
                (if (index > ff.import.impL.l.range) then leave thisOp;  if);
                (if (index = 0) then leave thisOp;  if);
                (if (ff.import.impL.l[index][] = none ) then leave thisOp;  if);
                (if (ff.import.impL.l[index].f[]->f[])
                 // none then
                    (# t: ^text
                    do
                       (ff.father).fullName->mps.stripPathName->t[];
                       (if t[]
                        // none then
                           (ff.import.impL.l[index].n.copy,
                           mps.thePathHandler.currentDirectory)
                             ->mps.thePathHandler.convertFilePath->openForm;
                           f[]->ff.import.impL.l[index].f[]
                        else
                           (ff.import.impL.l[index].n.copy,t[])
                             ->mps.thePathHandler.convertFilePath->openForm;
                           f[]->ff.import.impL.l[index].f[]
                       if);
                       
                    #);
                    (if f[]
                     // none then
                        (# t: ^text
                        do
                           &text[]->t[];
                           'Import error!! '->t.putLine;
                           'There is something wrong with the file "'->t.putText;
                           (ff.father).diskFileName->t.putText;
                           '"\n. It refers to the fragment "'->t.putText;
                           ff.import.impL.l[index].n[]->t.putText;
                           '" which was not found \n\n.'->t.putText;
                           t[]->ImportException
                        #)
                    if)
                if)
             #)
        exit f[]
        #);
      myValueToAst: (* Private *)
        (#
           val: @integer; a: ^astInterface.Ast; ff,f: ^astInterface.fragmentForm
        enter (val,ff[])
        do
           (if val
            // 0 then none ->a[]
            else
               (ff[],val->tos'%getShort[0]')->myGetGroup->f[];
               val->tos'%getShort[1]'->tos'%ShiftLeft[1]'->val;
               (if f[] <> none then
                   (if not (f.father).isRealOpen then
                       (f.father).fullName->putText;
                       '-'->put;
                       ' was not real open'->putLine;
                       (f.father).realOpen
                   if);
                   (if val <> 0 then
                       (val,f[])
                         ->myindextoNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->a[]
                   if)
               if)
           if)
        exit a[]
        #);
      myGetNodeAttribute:
        (# aplNode,val: ^astInterface.ast; attributNo: @integer
        enter (attributNo,aplNode[])
        do
           attributNo->aplNode.checkAttributNo;
           (aplNode.frag.a[aplNode.index+ (*offset.attribute*) 2+attributno-1],
           aplNode.frag[])->myValueToAst->val[]
        exit val[]
        #);
      myDclRef:
        (# aplNode,dclNode: ^astInterface.ast
        enter aplNode[]
        do ((1,aplNode[])->myGetNodeAttribute)->dclNode[]; 
        exit dclNode[]
        #);
      myVirtDcl:
        (# aplNode,dclNode: ^astInterface.ast; f: ^astInterface.ast
        enter aplNode[]
        do
           aplNode.father->f[];
           f.father->f[];
           ((1,f[])->myGetNodeAttribute)->dclNode[]
        exit dclNode[]
        #);
      
      theNode,fatherNode,testNode: ^astInterface.ast;
   do 
      thisCommand:
        (# 
        do
           (if node.kind
            // mps.kinds.nameAppl // mps.kinds.nameDecl then
               node.father->theNode[]->testNode[]
            else
               node[]->theNode[]->testNode[]
           if);
           checkForSemanticErrors:
             (if testNode.hasSemanticError then
                 (if testNode.semanticError <> 0 then
                     leave thisCommand
                 if)
              else
                 testNode.father->testNode[];
                 (if testNode[] <> none then restart checkForSemanticErrors if)
             if);
           (if theNode[] = none then
               'followSemanticLink: theNode is none!!'->putLine
            else
               (if theNode.symbol
                // betaGrammar.nameApl then
                   (#
                      theNameApl: ^astInterface.beta.nameApl;
                   do
                      theNode[]->theNameApl[];
                      theNameApl[]->myDclRef->destNode[];
                      
                   #)
                // betaGrammar.nameDcl then
                   (#
                      theNameDcl: ^astInterface.beta.nameDcl;
                      f: ^astInterface.ast
                   do
                      theNode.father->f[];
                      (if f.symbol
                       // betaGrammar.names then
                          f.father->f[];
                          (if f.symbol
                           // betaGrammar.bindingDecl
                           // betaGrammar.finalDecl then
                              theNode[]->theNameDcl[];
                              theNameDcl[]->myVirtDcl->destNode[];
                              
                              
                          if)
                      if);
                   #)
               if)
           if)
        #)
   #)  
   
-- setSemanticLinkBody: doPart --
do (# 
      thePrefix: ^astInterface.beta.prefix;
      theNameApl: ^astInterface.beta.nameApl;
      theNames: ^astInterface.beta.names;
      theNameDcl: ^astInterface.beta.nameDcl;
      gram: @grammar;
   do gram.prefix -> node.suffixWalkForProd 
      (# 
      do current[] -> thePrefix[];
         thePrefix.getAttributeDenotation -> theNameApl[];
         super.getNames -> theNames[];
         1 -> theNames.get -> theNameDcl[];
         theNameDcl[] -> theNameApl.dclRef;
      #);
      
   #);
