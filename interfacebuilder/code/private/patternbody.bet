ORIGIN '../pattern';
INCLUDE '../generate';
INCLUDE '../../mpsstuff/mpsutils';
INCLUDE '../../datastructures/sequence';

-- fragmentGroupLib: attributes --

scanBody:
  (# current: ^fragmentGroup;
     groupList: @sequence
       (# element:: fragmentGroup;
       #);
     targetMachine: ^text;
     openGroup:
       (# name: ^text;
          fg: ^fragmentGroup;
          path: ^text;
       enter name[]
       do 
          name[] -> current.fullPath -> path[];
          path[] -> safeOpen -> fg[];
       exit fg[]
       #);
  enter targetMachine[]
  do groupList.init;
     this(fragmentGroup)[] -> groupList.append;
     
     traverse:
       (if not groupList.empty then
           groupList.deleteFirst -> current[];
           
           inner scanBody;
           current.prop.scanProp
           (# doProp::
                (# 
                do (if true
                    //'body' -> prop.equalNCS then
                       scanParameters
                       (# doString::
                            (# fg: ^fragmentGroup;
                            do s[] -> openGroup -> fg[];
                               (if fg[] <> none then
                                   fg[] -> groupList.append;
                               if);
                            #);
                       #);
                    //'mdbody' -> prop.equalNCS then
                       (# foundAny: @boolean;
                          thisMachine: @boolean;
                       do scanParameters
                          (# doName::
                               (# 
                               do targetMachine[]->n.equal->thisMachine;
                               #);
                             doString::
                               (# fg: ^fragmentGroup;
                               do (if thisMachine then
                                      true -> foundAny;
                                      s[] -> openGroup -> fg[];
                                      (if fg[] <> none then
                                          fg[] -> groupList.append;
                                      if);
                                  if);
                               #);
                          #);
                          (if not foundAny then
                              scanParameters
                              (# doName::
                                   (# 
                                   do 'default' -> n.equal->thisMachine;
                                   #);
                                 doString::
                                   (# fg: ^fragmentGroup;
                                   do (if thisMachine then
                                          true -> foundAny;
                                          s[] -> openGroup -> fg[];
                                          (if fg[] <> none then
                                              fg[] -> groupList.append;
                                          if);
                                      if);
                                   #);
                              #);
                          if);
                       #);
                   if);
                #);
           #);
           restart traverse;
       if);
  #);

-- patternGetPrivateFragment: doPart --
do (# findFragment:
        (# name: ^text;
           frag: ^fragmentForm;
           group: ^fragmentGroup;
        enter name[]
        do node.frag.father -> group[];
           search:
             (if group[] <> none then
                 'sun4s' -> group.scanBody
                 (# 
                 do name[] -> current.findFragment -> frag[];
                    (if frag[] <> none then
                        leave search;
                    if);
                 #);
             if);
        exit frag[]
        #);
      theAttributeDecl: ^ast;
      theSimpleDecl: ^simpleDecl;
      theRefSpec: ^ast;
      theStaticItem: ^staticItem;
      theObjSpec: ^ast;
      theUnExpanded: ^unExpanded;
      theSlotDesc: ^slotDesc;
      slotName: ^text;
      
   do (node[], 'private') -> findAttribute -> theAttributeDecl[];
      (if theAttributeDecl[] <> none then
          (if theAttributeDecl.symbol = simpleDecl then
              theAttributeDecl[] -> theSimpleDecl[];
              theSimpleDecl.getReferenceSpecification -> theRefSpec[];
              (if theRefSpec.symbol = staticItem then
                  theRefSpec[] -> theStaticItem[];
                  theStaticItem.getObjectSpecification -> theObjSpec[];
                  (if theObjSpec.kind = kinds.unExpanded then
                      theObjSpec[] -> theUnExpanded[];
                      (if theUnExpanded.isSlot then
                          theUnExpanded.theSlot -> theSlotDesc[];
                          theSlotDesc.name -> slotName[];
                          slotName[] -> findFragment -> frag[];
                          (if frag[] = none then
                              failure;
                          if);
                       else
                          failure;
                      if);
                   else
                      failure;
                  if);
               else
                  failure;
              if);
           else
              failure;
          if);
       else
          failure;
      if);
   #);
