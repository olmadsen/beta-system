ORIGIN '~beta/betaast/betacfl';
INCLUDE '~beta/sysutils/objinterface'
        '../graphicaleditor/constants';
BODY 'private/generatebody';
-- betaAttributes: Attributes --
makeOptional:
  (# cat: @integer; frag: ^fragmentForm; theOptional: ^optional; 
  enter (cat,frag[])
  <<SLOT makeOptional:DoPart>>
  exit theOptional[]
  #);
generate:
(* Superpattern for all ast creating methods *)
  (#
     frag: ^fragmentForm;
     ASTtype:< AST;
     theAst: ^ASTtype;
     failure:< exception
       (# 
       do
          'failed to create ast in call of '->msg.putText;
          THIS(generate)[]->getPatternName->msg.putText;
          INNER ;
          
       #);
     
  enter frag[]
  <<SLOT MPSDoGenerate:DoPart>>
  exit theAst[]
  #);
newObjectDescriptor: generate
  (#
     ASTtype::< objectDescriptor;
     prefixName: ^text;
     (* prefix = none means empty *)
     
  enter prefixName[]
  <<SLOT MPSnewObjectDescriptor:DoPart>>
  #);
newDescriptorForm: generate
  (# ASTtype::< descriptorForm; prefixName: ^text; 
  enter prefixName[]
  <<SLOT MPSnewDescriptorForm:DoPart>>
  #);
newNameApl: generate
  (# ASTtype::< nameApl; name: ^text; 
  enter name[]
  <<SLOT MPSnewNameApl:DoPart>>
  #);
newNameDcl: generate
  (# ASTtype::< nameDcl; name: ^text; 
  enter name[]
  <<SLOT MPSnewNameDcl:DoPart>>
  #);
newNames: generate
  (# ASTtype::< names; name: ^text; 
  enter name[]
  <<SLOT MPSnewNames:DoPart>>
  #);
newComment: generate
  (#
     ASTtype::<
      comment;
     theText: ^text;
     
  enter theText[]
  <<SLOT MPSnewComment:DoPart>>
  #);
generateAttribute: generate
  (# name: ^text; prefixName: ^text; ASTtype::< attributeDecl; 
  enter (name[],prefixName[])
  do INNER
  #);
newStaticAttribute: generateAttribute
(* returns a new attributeDecl like name: @prefix  *)
  (# ASTtype::< simpleDecl;  <<SLOT MPSnewStaticAttribute:DoPart>> #);
newSingularItem: generateAttribute
(* returns a new attributeDecl like name: @prefix (#  #) *)
  (# ASTtype::< simpleDecl;  <<SLOT MPSnewSingularItem:DoPart>> #);
newVirtualDefinition: generateAttribute
(* returns a new attribute like name :< [prefix] (# #);  *)
  (# ASTtype::< virtualDecl;  <<SLOT MPSnewVirtualDefinition:DoPart>> #);
newVirtualBinding: generateAttribute
(* returns a new attributeDecl like name ::< [prefix] (#  #)  *)
  (# ASTtype::< bindingDecl;  <<SLOT MPSnewVirtualBinding:DoPart>> #);
newPatternAttribute: generateAttribute
  (# ASTtype::< patternDecl; 
  <<SLOT MPSnewPatternAttribute:DoPart>>
  #);
find:
  (#
     name: ^text;
     theAttributes: ^attributes;
     theAttributeDecl: ^attributeDecl;
     
  enter (theAttributes[],name[])
  <<SLOT MPSfind:DoPart>>
  exit theAttributeDecl[]
  #);
manipulateAttribute:
  (#
     theAttributeDecl: ^AttributeDecl;
     failure:< object;
     
  enter theAttributeDecl[]
  do INNER ; 
  #);
appendAttribute: manipulateAttribute
  (# theAttribute: ^AttributeDecl; 
  enter theAttribute[]
  <<SLOT MPSappendAttribute:DoPart>>
  #);
setObjectDescriptor: manipulateAttribute
  (# theObjectDescriptor: ^objectDescriptor; 
  enter theObjectDescriptor[]
  <<SLOT MPSsetObjectDescriptor:DoPart>>
  #);
getObjectDescriptor: manipulateAttribute
  (#
     theObjectDescriptor:
       ^objectDescriptor;
     
  <<SLOT MPSgetObjectDescriptor:DoPart>>
  exit theObjectDescriptor[]
  #);
setName: manipulateAttribute
  (# name: ^text; 
  enter name[]
  <<SLOT MPSAttributeSetName:DoPart>>
  #);
getName: manipulateAttribute
  (# name: ^text;  <<SLOT MPSAttributeGetName:DoPart>> exit name[] #);
setPrefix: manipulateAttribute
  (# prefixName: ^text; 
  enter prefixName[]
  <<SLOT MPSAttributeSetPrefix:DoPart>>
  #);
getPrefix: manipulateAttribute
  (# prefixName: ^text; 
  <<SLOT MPSAttributeGetPrefix:DoPart>>
  exit prefixName[]
  #);
getPrefixNode: manipulateAttribute
  (# thePrefix: ^AST;
  <<SLOT MPSAttributeGetPrefixNode: doPart>>
  exit thePrefix[]
  #);
setPrefixNode: manipulateAttribute
  (# thePrefix: ^AST;
  enter thePrefix[]
  <<SLOT MPSAttributeSetPrefixNode: doPart>>
  #);

getPrefixNameApl: manipulateAttribute
  (# prefixNameApl: ^nameApl; 
  <<SLOT MPSattributeGetPrefixNameApl:DoPart>>
  exit prefixNameApl[]
  #);
getAttributes: manipulateAttribute
  (# theAttributes: ^attributes; 
  <<SLOT MPSattributeGetAttributes:DoPart>>
  exit theAttributes[]
  #);
findAttribute: manipulateAttribute
  (#
     name: ^text;
     foundAttribute: ^attributeDecl;
     
  enter name[]
  do
     <<SLOT MPSAttributeFindAttribute:Descriptor>>
  exit foundAttribute[]
  #);
manipulateObjectDescriptor:
  (# theObjectDescriptor: ^objectDescriptor; 
  enter theObjectDescriptor[]
  do INNER ; 
  #);
setDopart: manipulateObjectDescriptor
  (# theDoPart: ^AST enter theDoPart[] <<SLOT MPSsetDopart:DoPart>> #);
getDopart: manipulateObjectDescriptor
  (# theDopart: ^doPart; 
  <<SLOT MPSgetDopart:DoPart>>
  exit theDopart[]
  #);
newDopart: generate
  (# ASTtype:: doPart; 
  <<SLOT MPSnewDoPart:DoPart>>
  #);
newSlotDoPart: generate
  (# ASTtype:: unExpanded; name: ^text; 
  enter name[]
  <<SLOT MPSnewSlotDoPart:DoPart>>
  #);
newOpenStatement: generate
  (#
     objectName: ^text;
     isPrivate: @boolean;
     ASTtype::< imp;
     
  enter (objectName[],isPrivate)
  <<SLOT MPSnewOpenStatement:DoPart>>
  #);
newInitFromResourceStatement: generate
  (# objectID: @integer; ASTtype::< imp; storeName: ^text; 
  enter (storeName[],objectID)
  <<SLOT MPSnewInitFromResourceStatement:DoPart>>
  #);
newBooleanBinding: generate
  (#
     ASTtype::< finalDecl;
     value: @boolean;
     name: ^text;
     
  enter (name[],value)
  <<SLOT generateNewBooleanBinding:DoPart>>
  #);
newBooleanAssignment: generate
  (# ASTtype::< imp; name: ^text; value: @boolean; 
  enter (name[],value)
  <<SLOT generateNewBooleanAssignment:DoPart>>
  #);
newAssignment: generate
  (#
     ASTtype::< imp;
     name: ^text;
     value: ^evaluation;
     
  enter (name[],value[])
  <<SLOT generateNewAssignment:DoPart>>
  #);
newTextEvaluation: generate
  (# ASTtype::< evaluation; value: ^text; 
  enter value[]
  <<SLOT generateNewTextEvaluation:DoPart>>
  #);
newIntEvaluation: generate
  (#
     ASTtype::< evaluation;
     value: @integer;
     consts: ^constants;
     
  enter (value,consts[])
  <<SLOT generateNewIntEvaluation:DoPart>>
  #);
newPointEvaluation: generate
  (# ASTtype::< evaluation; x,y: @integer; 
  enter (x,y)
  <<SLOT generateNewPointEvaluation:DoPart>>
  #);
newTrippleEvaluation: generate
  (#
     ASTtype::< evaluation;
     x,y,z: @integer;
     
  enter (x,y,z)
  <<SLOT generateNewTrippleEvaluation:DoPart>>
  #);
newBoolEvaluation: generate
  (# ASTtype::< evaluation; value: @boolean; 
  enter value
  <<SLOT generateNewBoolEvaluation:DoPart>>
  #);
findAssignment:
  (#
     theImperatives: ^imperatives;
     name: ^text;
     theAssignment: ^imp;
     
  enter (theImperatives[],name[])
  <<SLOT generateFindAssignment:DoPart>>
  exit theAssignment[]
  #);
evaluateAssignment:
  (# theEvaluation: ^evaluation; failure:< object; 
  enter theEvaluation[]
  <<SLOT generateEvaluateAssignment:DoPart>>
  #);
evaluateRect: evaluateAssignment
  (# x,y,width,height: @integer; 
  <<SLOT generateEvaluateRect:DoPart>>
  exit (x,y,width,height)
  #);
evaluatePoint: evaluateAssignment
  (# x,y: @integer;  <<SLOT generateEvalutePoint:DoPart>> exit (x,y) #);
evaluateColor: evaluateAssignment
  (# red,green,blue: @integer; 
  <<SLOT generateEvaluteColor:DoPart>>
  exit
  (red,
   green,blue)
  #);
evaluateInt: evaluateAssignment
  (# consts: ^constants; value: @integer; 
  enter consts[]
  <<SLOT generateEvaluteInt:DoPart>>
  exit value
  #);
evaluateBool: evaluateAssignment
  (# value: @boolean; 
  <<SLOT generateEvaluteBool:DoPart>>
  exit
  value
  #);
evaluateText: evaluateAssignment
  (# value: ^text;  <<SLOT generateEvaluteText:DoPart>> exit value[] #);
newAttributes: generate
  (#
     ASTtype::< attributes;
     theAttributeDecl: ^attributeDecl;
     
  enter theAttributeDecl[]
  <<SLOT newAttributesDoPart:DoPart>>
  #);
newFragment:
  (# name: ^text; frag: ^fragmentForm; 
  enter name[]
  <<SLOT MPSnewFragment:DoPart>>
  exit frag[]
  #);
newDescriptorFrag: newFragment
  (#  <<SLOT MPSnewDescriptorFrag:DoPart>> #);
newDoPartFrag:
 newFragment (#  <<SLOT MPSnewDoPartFrag:DoPart>> #);
newAttributesFrag: newFragment
  (# 
  <<SLOT MPSnewAttributesFrag:DoPart>>
  #);
  

-- fragmentGroupLib: Attributes --
originProperty:
  (# value: ^text; 
  enter (#  enter value[] <<SLOT MPSSetOriginProperty:DoPart>> #)
  exit
    (# 
    <<SLOT MPSGetOriginProperty:DoPart>>
    exit
    value[]
    #)
  #);
deleteFragment:
  (# frag: ^fragmentForm; 
  enter frag[]
  do frag.name->fragmentList.deleteLocalName; 
  #);
findFragment:
  (# name: ^text; frag: ^fragmentForm; 
  enter name[]
  <<SLOT MPSFragmentGroupFindFragment:DoPart>>
  exit frag[]
  #);
findBodyFragment:
  (#
     name: ^text;
     frag: ^fragmentForm;
     
  enter name[]
  <<SLOT MPSFragmentGroupFindBodyFragment:DoPart>>
  exit frag[]
  #);
  

-- listLib: Attributes --
empty: booleanValue (#  <<SLOT listEmpty:DoPart>> #);   

-- astInterfaceLib: Attributes --
safeOpen:
  (# name: ^text; group: ^fragmentGroup; 
  enter name[]
  <<SLOT AstInterfaceSafeOpen:DoPart>>
  exit group[]
  #);
  

