<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>

<HEAD>
<TITLE>CVS Usage in BETA Projects</TITLE>
<LINK REL=stylesheet HREF="http://www.daimi.au.dk/~beta/doc/style/miadoc.css" TYPE=text/css>
<LINK REL=stylesheet HREF="plans.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:pa@mjolner.dk">
</HEAD>

<BODY>
<H1>CVS Usage in BETA Projects</H1>

<H2>Content</H2>

<UL>
<LI><A HREF="#intro">Introduction</A>
<LI><A HREF="#req">Requirements</A>
<LI><A HREF="#example">Example</A>
<LI><A HREF="#basic">Basic Commands</A>
<UL>
<LI><A HREF="#get">Getting a Working Copy of the Repository</A>
<LI><A HREF="#update">Merging other Peoples Changes into your Copy</A>
<LI><A HREF="#commit">Publishing your Changes to other People</A>
</UL>
<LI><A HREF="#commands">More Commands</A>
<UL>
<LI><A HREF="#import">Putting a new Project under CVS</A>
<LI><A HREF="#add">Adding a File to the Project</A>
<LI><A HREF="#rm">Removing a File from the Project</A>
<LI><A HREF="#updatenot">Testing if Update is needed</A>
<LI><A HREF="#diff">Viewing Changes</A>
<LI><A HREF="#log">Viewing the CVS Log</A>
<LI><A HREF="#rtag">Tagging the Repository</A>
<LI><A HREF="#branch">Creating a Correction Branch</A>
<LI><A HREF="#status">Getting status of files in a working directory</A>
<LI><A HREF="#join">Merging in changes from a correction branch</A>
<LI><A HREF="#adddir">Adding a Directory to the Project</A>
<LI><A HREF="#rmdir">Removing a Directory from the Project</A>
<LI><A HREF="#cvstell">Listing Changed Files</A>
<LI><A HREF="#binary">Handling Binary Files</A>
</UL>
<LI><A HREF="cvs_use_nt.html">Using Windows CVS with Windows NT</A>
<LI><A HREF="cvs_use_mac.html">Using CVS on Macintosh</A>
<LI><A HREF="#seealso">Other sources of information</A>
</UL>


<H2><A NAME="intro">Introduction</A></H2>

CVS stands for Concurrent Versions System. It is built upon another
revision system called RCS, that will not be described here.
<P>
CVS lets groups of people work simultaneously on groups
of files (for instance program sources).
<P>
It works by holding a central `repository' (also denoted `project') of 
the most recent version of
the files.  You may at any time create a personal copy of these files by
`checking out' the files from the repository into one of your
directories.  If at a later date newer versions of the files are put in
the repository, you can `update' your copy.
<P>
You may edit your copy of the files freely.  If new versions of the files
have been put in the repository in the meantime, doing an `update' merges
the changes in the central repository into your copy.
<P>
When you are satisfied with the changes you have made in your copy of
the files, you can `commit' them into the central repository.
<P>

<H2><A NAME="req">Requirements</A></H2>

To use the BETA repository at devise, the following two requirements
must be met:

<OL>
<LI>You must be a member of the netgroup `beta'
You can check whether you are in the group by executing the following
in the shell:
<BLOCKQUOTE><PRE>
ypmatch beta group
</PRE></BLOCKQUOTE>
If you are not in the group, contact the 
<A HREF="mailto:staff@daimi.aau.dk">staff</A>.
<P>
<LI>You must have the CVSROOT environment variable set.
You should set it as follows:
<BLOCKQUOTE><PRE>
setenv CVSROOT /users/beta/.CVSHOME
</PRE></BLOCKQUOTE>
</OL>


<H2><A NAME="example">Example</A></H2>

In the following, the existing CVS project 
<CODE>objectserver</CODE> will
be used as an example.
<P>
The `project' is organized as a CVS repository with the name
<CODE>objectserver</CODE>, and the release versions in the  different
<CODE>$BETALIB/objectserver</CODE> directories are simply `snapshots' of the 
repository in different stages.
<P>
The changes to the repository will often have been created in
a private working copy of the repository, that some user checked
out at some time, modified, and then committed.

<H2><A NAME="basic">Basic Commands</A></H2>

There are only a few commands, that you need to know to use CVS.

<H3><A NAME="get">Getting a Working Copy of the Repository</A></H3>

In order to get a copy of the repository in its current state,
you perform a check-out of it:
<BLOCKQUOTE><PRE>
cvs get objectserver
</PRE></BLOCKQUOTE>

This will create a directory named <CODE>objectserver</CODE> in the
current directory. Sometimes you will want to call the directory
something else. If you e.g. wanted the check-out
to create a directory named <CODE>objectserver.smith</CODE> to
indicate that this directory "belongs" to user <CODE>smith</CODE>, you
would do it as follows:

<BLOCKQUOTE><PRE>
cvs get -d objectserver.smith objectserver
</PRE></BLOCKQUOTE>

Once you have your private working copy of the project, you will
want to do two things from your working directory:

<OL>
<LI><A HREF="#update">Merge other Peoples Changes into your Copy</A>
<LI><A HREF="#commit">Publish your Changes to other People</A>
</OL>


<H3><A NAME="update">Merging other Peoples Changes into your Copy</A></H3>

If someone else has published some changes, that you want to merge into
your working copy of the project, you do this by performing an `update'
from your working directory:

<BLOCKQUOTE><PRE>
cvs update   (or simply "cvs up")
</PRE></BLOCKQUOTE>

This will merge into your local files any changes that has been
made to the repository since your last `get' or `update'.
<P>
<CODE>update</CODE> keeps you informed of its progress by
printing a line for each file, preceded by one
character indicating the status of the file (there are more than 
the ones below, but these are the most important):
<P>
<DL COMPACT>
<DT><CODE>U <VAR>file</VAR></CODE>
<DD>The file was brought up to date with respect to the
repository.  This is done for any file that exists in
the repository but not in your source, and for files
that you haven't changed but are not the most recent
versions available in the repository.
<P>
<DT><CODE>M <VAR>file</VAR></CODE>
<DD>The file is modified in  your  working  directory.
<P>
<SAMP>`M'</SAMP> can indicate one of two states for a file
you're working on: either there were no modifications
to the same file in the repository, so that your file
remains as you last saw it; or there were modifications
in the repository as well as in your copy, but they
were merged successfully, without conflict, in your
working directory.
<P>
CVS will print some messages if it merges your work,
and a backup copy of your working file (as it looked
before you ran <CODE>update</CODE>) will be made.  The exact
name of that file is printed while <CODE>update</CODE> runs.
<P>
<DT><CODE>C <VAR>file</VAR></CODE>
<DD>A conflict was detected while trying to merge your
changes to <VAR>file</VAR> with changes from the source
repository.  <VAR>file</VAR> (the copy in your working
directory) is now the output of the rcsmerge(1) command
on the two revisions; an unmodified copy of your file
is also in your working directory, with the name
<TT>`.#<VAR>file</VAR>.<VAR>revision</VAR>'</TT> where <VAR>revision</VAR>
is the RCS revision that your modified file started
from.  (Note that some systems automatically purge
files that begin with <TT>`.#'</TT> if they have not been
accessed for a few days.  If you intend to keep a copy
of your original file, it is a very good idea to rename
it.)
<P>
<DT><CODE>? <VAR>file</VAR></CODE>
<DD><VAR>file</VAR> is in your working directory, but does not
correspond to anything in the source repository, and is
not in the list of files for CVS to ignore.
<P>
Note that no warning message like this is printed for
spurious directories that CVS encounters.  The
directory, and all its contents, are silently ignored.
</DL>
<P>

<H3><A NAME="commit">Publishing your Changes to other People</A></H3>

Once you have made some changes to your local working copy of the files,
and you are certain, that these changes will work for other people too,
the time has come to publish these changes. You do this by making a
`commit' from your working directory:

<BLOCKQUOTE><PRE>
cvs commit   (or simply "cvs com")
</PRE></BLOCKQUOTE>

This will check your changes into the repository.
<P>
CVS will ask you for a short description of the changes, that you
have made. It will ask so for each directory in your working directory.
<P>
You may specify the description on the command line. E.g. if you
have already described in detail in a <CODE>CHANGES</CODE> file, 
what you have made, you can do this:

<BLOCKQUOTE><PRE>
cvs commit -m 'See CHANGES'
</PRE></BLOCKQUOTE>

If, on the other hand, you prefer detailed information to
be put into the CVS log, you may use the script

<BLOCKQUOTE><PRE>
$BETALIB/bin/admin/cvscom
</PRE></BLOCKQUOTE>

which for each file that you have changed first display a diff
illustrating your changes, and then ask you for a textual description
of these changes before actually committing the file.
<P>
A `commit' requires, that you have made an `update' to merge
in changes from the repository (CVS can only merge <EM>from</EM> the
repository, not <EM>to</EM> it).
If you forget to do this, <CODE>cvs commit</CODE> will complain

<BLOCKQUOTE><PRE>
up-to-date check failed for file
</PRE></BLOCKQUOTE>

for each file, that was changed in the repository.
Then just do the update, resolve any possible conflicts and commit again.

<H2><A NAME="commands">More Commands</A></H2>

<H3><A NAME="import">Putting a new Project under CVS</A></H3>

Imagine, that the <CODE>objectserver</CODE>repository had not
been created. Then how would you create it?
There are several ways to do this, but the following is the recommended.
<OL>

<LI>Create the complete source directory.
Imagine, that the directory 
<BLOCKQUOTE><PRE>
$BETALIB/objectserver.non-cvs
</PRE></BLOCKQUOTE>

exists, and that the initial CVS repository should be based on the
contents of this directory. You would start by making sure, that only
relevant source files are present in the directory. Be sure to remove
<CODE>.ast</CODE> files etc.
<P>
<LI>Import the Directory
You would then import the directory into the repository:
<BLOCKQUOTE><PRE>
cvs import objectserver DEVISE v1_0 
</PRE></BLOCKQUOTE>
This will create the objectserver repository in the CVSROOT and
give it the symbolic tag <CODE>v1_0</CODE> 
(see <A HREF="#rtag">Tagging the Repository</A>
below) , and specify <CODE>DEVISE</CODE> as `vendor'.
<P>
<LI>Bring the local Copy up to date with Repository:
<P>
The import command has only affected the repository, not the local
directory. You should then 
check out the CVS controlled directory using a normal check-out:

<BLOCKQUOTE><PRE>
cd $BETALIB
cvs get objectserver
</PRE></BLOCKQUOTE>

In this case, the original directory was named
<CODE>objectserver.non-cvs</CODE>. Had it been named
<CODE>objectserver</CODE> itself (a common situation), this
non-CVS controlled directory should be renamed before the check-out.
</OL>

<P>
To import a directory, where some of the files are to be treated as
<EM>binary files</EM>, see <A HREF="#binary">Handling Binary
Files</A>.
<P>
<H3><A NAME="add">Adding a File to the Project</A></H3>

If you have created a new file, e.g. <CODE>newstuff.bet</CODE> in the 
<CODE>objectserver/private</CODE> directory, that should be added to
the repository, you do it as follows:

<BLOCKQUOTE><PRE>
cd objectserver/private
cvs add newstuff.bet
</PRE></BLOCKQUOTE>

A subsequent <CODE>cvs commit</CODE> will then add the file to the 
repository.

<H3><A NAME="rm">Removing a File from the Project</A></H3>

If you have realized that the file <CODE>tempstuff.bet</CODE> should
be removed from the <CODE>objectserver</CODE> repository, first you
must remove the file from your working directory, and then from the
repository. The following will save you a little typing in a C-shell:

<BLOCKQUOTE><PRE>
rm tempstuff.bet
cvs !!   (expands to "cvs rm tempstuff.bet" in a UNIX C-shell)
</PRE></BLOCKQUOTE>

A subsequent <CODE>cvs commit</CODE> will then remove the file from the 
repository.

<H3><A NAME="updatenot">Testing if Update is needed</A></H3>
If you are uncertain whether your working version is actually up to
date, but dare not to update it unconditionally, you may start with
issuing the command

<BLOCKQUOTE><PRE>
cvs -n update   (or simply "cvs -n up")
</PRE></BLOCKQUOTE>

which prints out almost the same status lines as a regular update, but does
not actually change any files. The status printed is not exactly the same
as for a <CODE>cvs update</CODE>. The status will be:

<DL COMPACT>
<DT><CODE>U <VAR>file</VAR></CODE>
<DD>The file has not been modified by you, but has changed in the Repository. 
<P>
<DT><CODE>M <VAR>file</VAR></CODE>
<DD>The file has been modified by you and has not changed in the Repository. 
<P>
<DT><CODE>C <VAR>file</VAR></CODE>
<DD>The file has been modified by you, <EM>and</EM> has changed in the Repository. 
<P>
</DL>


<H3><A NAME="diff">Viewing Changes</A></H3>

At any time, you may view changes made by you in your working directory
by issuing

<BLOCKQUOTE><PRE>
cvs diff
</PRE></BLOCKQUOTE>

This will show all changes made by you in all files since your last
commit. You may specify that you only want the diff for a particular
file:

<BLOCKQUOTE><PRE>
cvs diff myfile.bet
</PRE></BLOCKQUOTE>

and you may add standard <CODE>diff</CODE> options, e.g. specify that
you want a context-diff:

<BLOCKQUOTE><PRE>
cvs diff -c myfile.bet
</PRE></BLOCKQUOTE>

You may also compare your file with a specific earlier version in the
repository (using the <CODE>-r</CODE> option) and even compare two
old versions (using two <CODE>-r</CODE> options). You would get the 
revision numbers by looking at the <A HREF="#log">CVS log</A>.

<H3><A NAME="log">Viewing the CVS Log</A></H3>

In your working directory, you may view the CVS log by issuing

<BLOCKQUOTE><PRE>
cvs log
</PRE></BLOCKQUOTE>

which will print out all revision numbers and comments specified at
commit time for all files in your working directory.

As with <CODE>diff</CODE> you may do it for a particular file:

<BLOCKQUOTE><PRE>
cvs log myfile.bet
</PRE></BLOCKQUOTE>

<H3><A NAME="rtag">Tagging the Repository</A></H3>

When you have committed your changes, you may want to mark the files
in the repository in their current state. This will allow you to get
the files in exactly the state they were in ar marking time at a later
time.  This is also a prerequisite for creating a 
<A HREF="#branch">branch</A> at a later time, based on the files in
their current state.
<P>
So you should at least create a mark when a project is frozen!
<P>
You do this as follows:

<OL>
<LI>Make sure that all changes are committed
<P><LI>Check the CVS log to find out what tag names have already
    been used. In this example, you decide e.g. to use the mark
    <CODE>r4.2_final</CODE>.
<P><LI>Issue this command:
<PRE>
cvs rtag r4.2_final objectserver
</PRE>

</OL>

<H3><A NAME="branch">Creating a Correction Branch</A></H3>

Imagine that a serious bug has been found in the current working
version of <CODE>$BETALIB/objectserver</CODE>
and that it should be fixed in the (frozen) <CODE>$OLDBETALIB/objectserver</CODE>.
<P>
If you did not use CVS, you would probably create a copy of
<CODE>objectserver</CODE> in
<CODE>$OLDBETALIB/objectserver</CODE> and fix the error there.
<P>
In CVS you do more or less the same, but you retain the possibility
to make even more changes in the correction version by creating a 
CVS <EM>correction branch</EM>.
<P>
First it is a prerequisite, that when the CVS controlled 
<CODE>$OLDBETALIB/objectserver</CODE> was frozen/released, a symbolic <A
HREF="#rtag">tag</A> was made to the repository.
To find out the tags for a repository you can do like this from the working directory:
<PRE>
cvs log -hq &lt;a file from the project&gt;
</PRE>
or you can do this from any directory:
<PRE>
cvs history -T | grep objectserver
</PRE>


<P>
Imagine, that the tag you decided to branch from, was named <CODE>r4_1_final</CODE>.
<P>
You then create the branch by making a so-called <EM>branch-tag</EM>
based on the <CODE>r4_1_final</CODE> tag:

<OL>
<LI>Create the branch-tag:
<BLOCKQUOTE><PRE>
cvs rtag  -r r4_1_final  -b r4_1_correction_branch  objectserver
</PRE></BLOCKQUOTE>
This will give you the tag <CODE>r4_1_correction_branch</CODE>, that
you can get the correction branch from.
<P>
<LI>Check out the correction branch:
<BLOCKQUOTE><PRE>
cvs get -r r4_1_correction_branch -d $OLDBETALIB/objectserver objectserver
</PRE></BLOCKQUOTE>
This will check out the <CODE>r4_1_correction_branch</CODE> of
<CODE>objectserver</CODE>, into the directory 
<CODE>$OLDBETALIB/objectserver</CODE>.
</OL>

From now on you can change, update, commit etc. independently in
directories created from <CODE>r4_1_correction_branch</CODE> and the
main-branch of <CODE>objectserver</CODE>.

<H3><A NAME="status">Getting status of files in a working directory</A></H3>

If you are in doubt what explicit version/tag you have gotten in your
working directory, you can use <CODE>cvs status</CODE>.
<P>
If want to verify, e.g. that it is the correction branch with branch tag
<CODE>r4_1_correction_branch</CODE> of <CODE>objectserver</CODE> you have
checked out in your working directory, you do this: 

<PRE>
cvs status -v CHANGES
</PRE>

which would give you the current status of the <CODE>CHANGES</CODE> file.
If this says:

<PRE>
Sticky Tag:          r4_1_correction_branch (branch: 1.1.2)
</PRE>

it means, that it is the correction branch you have checked out.
By examining the tag information it also displays, you can also
determine what version the branch was based upon (in this example the
numbers in the parentheses indicate, that it is a branch tag, and
that the branch was taken at RCS revision 1.1 of <CODE>CHANGES</CODE>).





<H3><A NAME="join">Merging in changes from a correction branch</A></H3>

If you have checked out a correction branch, and you then later
want to merge in the changes made in this branch to the head (main)
revision, here is how to do it. 
There is a general discussion in the 
<A HREF="http://www.loria.fr/~molli/cvs/cvs-FAQ/cvsfaq28.html#4C.14">CVS FAQ item 4C.14</A>, but here I wil try to examplify the methods using the above
examples.

<OL>
<LI>First make sure, that everything done in the branch has been committed:
<PRE>
	cvs commit
</PRE>
<P>
<LI>Then there are two ways to perform the merge:
<OL>
<LI>You can change an existing directory, containing the branch, to 
become a non-branch directory with the branch changes merged in:
<OL>
<LI>cd to the directory containing the branch, and update to the head revision:
<PRE>
cd &lt;branch-directory&gt;
cvs update -A
</PRE>
Now the changes you had done in the files in the current directory
(in the branch) will be gone, but changes made in the head revision
since you created the branch will be present. The changes made in
the branch will not be lost, of course, since you checked them into the
repository by <CODE>cvs commit</CODE> above.
<LI>Join the changes from the branch into your working directory:
<PRE>
cvs update -j r4_1_correction_branch
</PRE>
You may get some conflicts from this update, that you will have
to fix manually.
<LI>Finally you can commit the changes from your local directory
into the repository, and thereby making the merge applicable
by others:
<PRE>
cvs commit
</PRE>
</OL>
<LI>If you want to create a new directory containing the merge, you
can check out the head revision and join in the branch in one command:
<OL>
<LI>Get the merged revision:
<PRE>
cvs get -j r4_1_correction_branch -d objectserver.merged objectserver
cd objectserver.merged
</PRE>
(or use some other name than <CODE>objectserver.merged</CODE> to indicate
that it will contain the merge between the head revision and 
r4_1_correction_branch).
As above you may get conflicts, and you should watch out for 
new files from the branch.
<LI>The you can commit the changes from 
<CODE>objectserver.merged</CODE>
into the repository, and thereby making the merge applicable
by others:
<PRE>
cd objectserver.merged
cvs commit
</PRE>
</OL>
</OL>
</OL>

<H3><A NAME="adddir">Adding a Directory to the Project</A></H3>

If you want to add a new <EM>directory</EM> to your project,
you just do it as you would have added a file - using 
<CODE>cvs add</CODE>. For instance, if you want to add a directory
called <CODE>astserver</CODE> in the <CODE>private</CODE> subdirectory
of the <CODE>objectserver</CODE> project, you would do this:

<BLOCKQUOTE><PRE>
cd objectserver/objectserver.smith/private
mkdir astserver
cvs add astserver
</PRE></BLOCKQUOTE>

Unlike <CODE>cvs add</CODE> of a <EM>file</EM>, adding a directory
immediately affects the repository - you do not have to do a subsequent
<CODE>cvs commit</CODE>.
<P>
After the addition of the directory, you may add files from the 
directory in the normal way.
<P>
There is one more special thing about adding a directory: Imagine, that
Mr. Jones has checked out the <CODE>objectserver</CODE> project in
a directory named <CODE>objectserver.jones</CODE>. 
Then probably he would 
expect that doing a <CODE>cvs update</CODE> in his directory after
you have added the <CODE>astserver</CODE> directory would create
the <CODE>astserver</CODE> directory in his working directory.
<P>
<EM>But</EM> CVS has the feature/bug, that if you remove one of
the directories in the working directory, CVS will silently ignore
this lacking directory in subsequent <CODE>cvs update</CODE>'s. This is
in opposition to the way CVS treats missing <EM>files</EM>: If a file
has been deleted, a subsequent <CODE>cvs update</CODE> will restore it.
The advantage of CVS ignoring a missing directory (in my opinion) is,
that if you e.g. have a project with subdirectories containing 
macintosh-, windows-, and UNIX implementations, and you only work on the
 UNIX implementation, you may delete the
macintosh-, and windows-directories from your local working copy
(and thus save disk space), without getting complaints from CVS.
<P>
To work around this default behavious, specify <CODE>-d</CODE> for
the <CODE>cvs update</CODE> command - this will make CVS create
missing directories.

<BLOCKQUOTE><PRE>
cd objectserver
cvs up -d
</PRE></BLOCKQUOTE>

<H3><A NAME="rmdir">Removing a Directory from the Project</A></H3>

This is not easy. The FAQ says that you can do it like this 
(I haven't tried):

<OL>
<LI>Physically remove all files in the directory.
<LI>A <CODE>cvs rm &lt;directory&gt;</CODE> will then
    schedule all removed files for removal.
<LI>A <CODE>cvs commit</CODE> will remove all the files from the
repsoitory.
<LI>The directory itself cannot be removed by any CVS command. You'll have to remove the working directory and the matching directory in the Repository (<EM>carefull!)</EM>.
</OL>

<H3><A NAME="cvstell">Listing Changed Files</A></H3>

If you want to know what files in your local directory contains changes
compared to the repository, you can do this:

<BLOCKQUOTE><PRE>
$BETALIB/bin/admin/cvstell
</PRE></BLOCKQUOTE>

or the equivalent

<BLOCKQUOTE><PRE>
cvs diff |&amp; grep RCS
</PRE></BLOCKQUOTE>

Both methods will report the names of the files in the repository,
for which you have made changes in your local copy.

<H3><A NAME="binary">Handling Binary Files</A></H3>

You can add binary files under CVS too. But to prevent CVS from 
expanding keywords and changing newlines (e.g from PC newlines to UNIX 
newlines), you will have to add the binary files specially:

<PRE>
cvs add -kb &lt;file&gt;
</PRE>

After this, the binary file will be treated correctly by CVS.
<P>
If you have already added a file normally, you can tell CVS to treat
it as a binary file by using

<PRE>
cvs admin -kb &lt;file&gt;
</PRE>

If you are <EM>importing</EM> a whole directory tree, and want to
treat certain files binary, based on their extension, you can do
it as such:

<PRE>
cvs import -W "*.gif -k 'b'" -W "*.doc -k 'b'" -W "*.pdf -k 'b'" my_project DEVISE v1_0
</PRE>

This will make files with names ending with '.gif', '.doc', and '.pdf'
binary, but others non-binary.
<P>
See 
<A HREF="http://www.loria.fr/~molli/cvs/doc/cvs_81.html#SEC83">
CVS Reference Manual: Handling Binary Files
</A> for the full story!


<DT><H2><A NAME="seealso">Other sources of information</A></H2>
<DL><p>
   <DT>Excellent article in <A HREF="http://www.ssc.com/lj/issue21/index.html">Linux Journal January 1996</A>: <EM><A HREF="http://www.ssc.com/lj/issue21/1118.html">CVS: Version Control Beyond RCS</A></EM>
   <DT><A HREF="http://www.loria.fr/~molli/cvs/doc/cvs_toc.html">CVS Reference Manual</A>
   <DT><A HREF="http://www.cs.utah.edu/csinfo/texinfo/cvs/cvs_tutorial_toc.html">CVS Tutorial</A>
   <DT><A HREF="http://www.loria.fr/~molli/cvs/cvstrain/cvstrain.html">CVS training Manual</A>
   <DT><A HREF="http://www.cs.utah.edu/csinfo/texinfo/cvs/pcl-cvs_toc.html">Pcl-cvs - The Emacs Front-End to CVS</A>
   <DT><A HREF="http://www.cyclic.com/cyclic-pages/experiences.html">A User Experience with CVS</A>
   <DT><A HREF="http://www.loria.fr/~molli/cvs/cvs-FAQ/cvsfaq0.html">CVS FAQ</A>
   <DT><A HREF="ftp://prep.ai.mit.edu/pub/gnu/cvs-1.8.tar.gz">Download CVS Source (version 1.8, 1373 Kb)</A>
    </DL><p>
</DT>

</HTML>
