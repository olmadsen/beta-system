<H2><INX>ClassificationSet</INX></H2>
 ClassificationSet is a subpattern of the set pattern. ClassificationSet is used for dynamic classification of elements. ClassificationSet defines two additional attributes:<P>
<UL>
<LI>subsets: is a set containing the subsets of this classificationSet.
<LI>insertSubset: takes a classificationSet and inserts it as a subset of this classificationSet.  The exception illegalSubset will be invoked if the subset inserted contains elements, that are not instances of a subpattern of the element type of this classificationSet.
<LI>superSet: if this classificationSet is a subset of another classificationSet, superSet will reference that classificationSet.
<LI>scanUnclassified: like scan except that it only scans those elements that are not member of any subsets of this classificationSet.
</UL>
Let us illustrate by an abstract example, assuming that css1 contains the elements a, b and c, css2 contains the elements c, d and e, and finally cs contains the elements b and f:<BR>
 <IMG SRC="containers-8-image-2.gif"> <P>
 Then after 
<BETA>
  css1[]->cs.insertSubset
</BETA>
 cs will contain the original elements, and the css1 subset:<P>
 <IMG SRC="containers-8-image-3.gif"><P>
 Note that the element b, originally located in both cs and css1, now is located exclusively in css1. In this situation, cs.scan(# ... #) will run through the elements a, b, c, d, e and f. and css1.scan(# ... #) will run through the elements b and f.<P>
 If we then execute 
<BETA>
  css2[]->cs.insertSubset
</BETA>
 we will have the following situation:<P>
 <IMG SRC="containers-8-image-4.gif"><P>
 Note again, that c is exclusively in css2. If we now execute 
<BETA>
  g[]->css1.insert; f[]->css2.insert; b[]->cs.delete
</BETA>
 we will have the following situation:<P>
 <IMG SRC="containers-8-image-5.gif"><P>
 Finally, 
<BETA>
  css1.scanUnclassified(# ... #)
</BETA>
 will only scan the elements a and b, whereas
<BETA>
  css1.scan(# ... #)
</BETA>
 will scan all elements (i.e. a, b, c, d, e, f and g).<P>
<!-- TOC -->

