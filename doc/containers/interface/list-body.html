<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>List Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="list">List Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'container';
LIB_DEF 'list' '../lib';
BODY 'private/listBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
--- lib: attributes ---
<B>list</B><A name="list.1(122)"></A>: container
  (* This list pattern defines a double-linked list data structure.
   * Most operations either enters or exits a list position.  List
   * positions are references into a particular place in the list,
   * containing an element.  These positions are instances of
   * theCellType.
   * 
   *     list
   *       cyclicList --- prev and next operations to impl. cyclic list
   *       priorityList --- elements ordered by priority
   *       recList --- allows for recursive lists (in separate fragment)
   * 
   * Defines the following new operations: prepend, append, head,
   *     tail, last, preample, at, locate, concatenate, splitBefore,
   *     splitAfter, insertBefore, insertAfter, delete, deleteBefore,
   *     deleteAfter, scanReverse, iterate, iterateFrom,
   *     iterateReverse, iterateReverseFrom
   *)
  (# &lt;&lt;SLOT listLib: attributes&gt;&gt;;
     <B>theCellType</B><A name="list.1.theCellType.2(123)"></A><A name="theCellType.2(123)"></A>::&lt; 
       (* theCellType is the pattern from which the individual list
        * positions are created. It defines the succ and pred
        * references to the list positions immediately before/after
        * this position in the list (NONE means the end of the list
        * (either end).  The elm attribute refers to the element at
        * this position in the list.
        *)
       (# succ, pred: ^theCelltype; 
       do INNER
       #);
     <B>clear</B><A name="list.1.clear.2(124)"></A><A name="clear.2(124)"></A>::&lt; (# ... #);
     <B>size</B><A name="list.1.size.2(125)"></A><A name="size.2(125)"></A>::&lt; (# ... #);
     <B>empty</B><A name="list.1.empty.2(126)"></A><A name="empty.2(126)"></A>::&lt; (# ... #);
     <B>has</B><A name="list.1.has.2(127)"></A><A name="has.2(127)"></A>::
       (# ... #);
     <B>copy</B><A name="list.1.copy.2(128)"></A><A name="copy.2(128)"></A>::&lt;(#
            ... 
            #);
     <B>prepend</B><A name="list.1.prepend.2(129)"></A><A name="prepend.2(129)"></A>: (* insert elm as first element *)
       (# elm: ^element; 
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>append</B><A name="list.1.append.2(130)"></A><A name="append.2(130)"></A>: (* insert elm as last element *)
       (# elm: ^element; 
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>head</B><A name="list.1.head.2(131)"></A><A name="head.2(131)"></A>: 
       (* returns the position element of the first position in the
        * list
        *)
       (# position: ^theCellType
         ...
       exit position[]
       #);
     <B>tail</B><A name="list.1.tail.2(132)"></A><A name="tail.2(132)"></A>: 
       (* returns a copy of THIS(list), except the first element *)
       (# lst: ^list
         ...
       exit lst[]
       #);
     <B>last</B><A name="list.1.last.2(133)"></A><A name="last.2(133)"></A>: 
       (* returns the position element of the last position in the
        * list
        *)
       (# position: ^theCellType
         ...
       exit position[]
       #);
     <B>preample</B><A name="list.1.preample.2(134)"></A><A name="preample.2(134)"></A>: 
       (* returns a copy of THIS(list), except the last element *)
       (# lst: ^list
         ...
       exit lst[]
       #);
     <B>concatenate</B><A name="list.1.concatenate.2(135)"></A><A name="concatenate.2(135)"></A>: 
       (* returns a new list, containing the concatenated list *)
       (# otherList, newlist: ^list; 
       enter otherList[]
       ...
       exit newlist[]
       #);
     <B>insertBefore</B><A name="list.1.insertBefore.2(136)"></A><A name="insertBefore.2(136)"></A>: (* if position=NONE, insert elm as last element *)
       (# elm: ^element; position, newPosition: ^theCellType
       enter (elm[], position[])
       ...
       exit newPosition[]
       #);
     <B>insertAfter</B><A name="list.1.insertAfter.2(137)"></A><A name="insertAfter.2(137)"></A>: (* if position=NONE, insert elm as first element *)
       (# elm: ^element; position, newPosition: ^theCellType
       enter (elm[], position[])
       ...
       exit newPosition[]
       #);
     <B>delete</B><A name="list.1.delete.2(138)"></A><A name="delete.2(138)"></A>: (* if position=NONE, delete nothing *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>deleteBefore</B><A name="list.1.deleteBefore.2(139)"></A><A name="deleteBefore.2(139)"></A>: 
       (* if position=NONE, delete last position element *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>deleteAfter</B><A name="list.1.deleteAfter.2(140)"></A><A name="deleteAfter.2(140)"></A>: 
       (* if position=NONE, delete first position element *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>splitBefore</B><A name="list.1.splitBefore.2(141)"></A><A name="splitBefore.2(141)"></A>: 
       (* splits this(list) into two lists, where the elements before
        * position (excluding position) is placed in preList and the
        * rest of this(list) is placed in postList.  PositionElm will
        * be the head of postList.  If position=NONE, preList will
        * become a copy of the entire list and postList will become
        * NONE
        *)
       (# position: ^theCellType;
          preList, postList: ^list;
          listSplitBeforePrivate: @...
       enter position[]
       do listSplitBeforePrivate; INNER
       exit (preList[], postList[])
       #);
     <B>splitAfter</B><A name="list.1.splitAfter.2(142)"></A><A name="splitAfter.2(142)"></A>: 
       (* splits this(list) into two lists, where the elements before
        * position (including position) is placed in preList and the
        * rest of this(list) is placed in postList. PositionElm will
        * be the last element in postList If position=NONE, preList
        * will become a copy of the entire list and postList will
        * become NONE
        *)
       (# position: ^theCellType;
          preList, postList: ^list;
          listSplitAfterPrivate: @...
       enter position[]
       do listSplitAfterPrivate; INNER
       exit (preList[], postList[])
       #);
     <B>at</B><A name="list.1.at.2(143)"></A><A name="at.2(143)"></A>: (* returns the position of elm in the list *)
       (# elm: ^element;
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>locate</B><A name="list.1.locate.2(144)"></A><A name="locate.2(144)"></A>: 
       (* returns the position of the element in the list, satisfying
        * predicate.  This operation is similar to find, except that
        * it returns the position, not the element.
        *)
       (# predicate:&lt; cellPredicate;
          notFound:&lt; Notification
            (# 
            do none-&gt;position[];
               'Element not found in list'-&gt;msg.putLine;
               INNER
            #);
          start:&lt; object;
          end:&lt; object;
          position: ^theCellType;
       ...
       exit position[]
       #);
     <B>find</B><A name="list.1.find.2(145)"></A><A name="find.2(145)"></A>::
       (#
       ...
       #);
     <B>thescanner</B><A name="list.1.thescanner.2(146)"></A><A name="thescanner.2(146)"></A>::&lt; (* private *)
       (# theCell:^theCelltype;
          notdone:@boolean;
       ...
       #);
     <B>theReverseScanner</B><A name="list.1.theReverseScanner.2(147)"></A><A name="theReverseScanner.2(147)"></A>:&lt; (* private *)
       (# 
          w:^elementPredicate;
          s:^scanreverse;
          aCell:^theCellType;
          notdone:@boolean;
       enter (s[],w[])
       ...
       #);
     <B>theFromScanner</B><A name="list.1.theFromScanner.2(148)"></A><A name="theFromScanner.2(148)"></A>:&lt; (* private *)
       (# 
          w:^elementPredicate;
          s:^scanFrom;
          aCell:^theCellType;
          notdone:@boolean;
       enter (s[],w[],aCell[])
       ...
       #);
     <B>scanReverse</B><A name="list.1.scanReverse.2(149)"></A><A name="scanReverse.2(149)"></A>: 
       (* similar to scan, except that it scans the list in reverse
        * direction
        *)
       (# first:@boolean;
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
       ...
       #);
     <B>scanFrom</B><A name="list.1.scanFrom.2(150)"></A><A name="scanFrom.2(150)"></A>:
       (* similar to scan, except that it scans the list from the
        * given position
        *)
       (# 
          first:@boolean;
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
          position:^theCelltype; (* start cell *)
       enter position[]
       ...
       #);
     <B>scanReverseFrom</B><A name="list.1.scanReverseFrom.2(151)"></A><A name="scanReverseFrom.2(151)"></A>: 
       (* similar to scanReverse, except that it scans the list in
        * reverse direction from the given position
        *)
       (# where:&lt; elementPredicate;
          position: ^theCellType;
          current: ^element;
          theCell:^theCelltype;
          start:&lt; object;
          end:&lt; object;
       enter position[]
       ...
       #);
     <B>iterate</B><A name="list.1.iterate.2(152)"></A><A name="iterate.2(152)"></A>: 
       (* similar to scan, except that "current" refers to the
        * current cell in the list.  If furthermore the list is an
        * instance of the recList subpattern, iterate respects the
        * sublist structure by not scanning the elements in the
        * sublists (as scan does). I.e. during an iterate of a
        * recList, "current" may refer to a cell containing either an
        * element, or a sublist.
        *)
       (# where:&lt; cellPredicate;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIteratePrivate: @...
       ...
       #);
     <B>iterateFrom</B><A name="list.1.iterateFrom.2(153)"></A><A name="iterateFrom.2(153)"></A>: 
       (* similar to iterate, except that it takes a position, and
        * starts the iteration from that position.
        *)
       (# where:&lt; cellPredicate;
          position: ^theCellType;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateFromPrivate: @...
       enter position[]
       ...
       #);
     <B>iterateReverse</B><A name="list.1.iterateReverse.2(154)"></A><A name="iterateReverse.2(154)"></A>: 
       (* similar to iterate, except that it iterates backwards.
        *)
       (# where:&lt; cellPredicate;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateReversePrivate: @...
       ...
       #);
     <B>iterateReverseFrom</B><A name="list.1.iterateReverseFrom.2(155)"></A><A name="iterateReverseFrom.2(155)"></A>: 
       (* similar to iterateReverse, except that it takes a position,
        * and starts the reverse iteration from that position.
        *)
       (# where:&lt; cellPredicate;
          position: ^theCellType;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateReverseFromPrivate: @...
       enter position[]   
       ...
       #);
     <B>cellPredicate</B><A name="list.1.cellPredicate.2(156)"></A><A name="cellPredicate.2(156)"></A>: booleanValue
       (* This pattern is used as the superpattern for the predicates
        * in the locate and iterate operations.
        *)
       (# current: ^theCellType
       enter current[]
       do true-&gt;value;
          INNER
       #);
     <B>doEnter</B><A name="list.1.doEnter.2(157)"></A><A name="doEnter.2(157)"></A>::&lt;
       (# containerType::&lt;list;
          doneInInner:@boolean
       ...
       #);
     <B>private</B><A name="list.1.private.2(158)"></A><A name="private.2(158)"></A>:@...;
  do INNER
  #) (* list *);

<B>cyclicList</B><A name="cyclicList.1(159)"></A>: list
  (* Add operations next and prev to enable traverse the list as a
   * cycle list
   *)
  (# <B>theCellType</B><A name="cyclicList.1.theCellType.2(160)"></A><A name="theCellType.2(160)"></A>::&lt;
       (# prev:
            (# position: ^theCellType
            do pred[]-&gt;position[];
               (if position[]=NONE then last-&gt;position[] if);
            exit position[]
            #);
          next:
            (# position: ^theCellType
            do succ[]-&gt;position[];
               (if position[]=NONE then head-&gt;position[] if);
            exit position[]
            #);
       #);
  #);

<B>priorityList</B><A name="priorityList.1(161)"></A>: list
  (* implements a priority list where the elements added to the list
   * are ordered according to their priority (implemented by the
   * ordering relation 'less')
   *)
  (# <B>less</B><A name="priorityList.1.less.2(162)"></A><A name="less.2(162)"></A>:&lt; booleanValue
       (# left,right: ^element enter (left[],right[]) do INNER #);
     <B>add</B><A name="priorityList.1.add.2(163)"></A><A name="add.2(163)"></A>:
       (# elm: ^element; added: @boolean
       enter elm[]
       do loop:
            iterate
            (#
            do (if (elm[],current.elm[])-&gt;less then
                   (elm[],current[])-&gt;insertBefore;
                   true-&gt;added;
                   leave loop
               if)
            #);
          (if not added then elm[]-&gt;append if)
       #)
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>List Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
