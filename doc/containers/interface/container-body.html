<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Container Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="container">Container Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'container' '../lib';
BODY 'private/containerBody';
(*
 * COPYRIGHT
 * 
 *       Copyright (C) Mjolner Informatics, 1992-95
 * 
 *       All rights reserved.
 *)
-- lib: Attributes --
<B>container</B><A name="container.1(1)"></A>:
(* The top most pattern in the data structures hierarchy.
 * Container is an abstract superpattern and the currently available
 * subpatterns are (indentation specifies specialization): 
 * 
 *   container
 *     collection
 *       multiSet
 *         set
 *           classificationSet --- allows for sets of sets, etc.
 *       hashTable
 *         extensibleHashTable --- allows for extending the index
 *                                  range
 *     list
 *       recList --- allows for recursive lists
 *     arrayContainer --- includes bubble/shell/quicksort
 *     sequentialContainer
 *       stack
 *       queue
 *       prioqueue
 *       deque
 *)
  (#
     &lt;&lt;SLOT containerLib:Attributes&gt;&gt;;
     <B>element</B><A name="container.1.element.2(2)"></A><A name="element.2(2)"></A>:&lt; Object
     (* The qualification of the objects, contained in this
      * container.  When using one of the subpatterns of container,
      * further binding of element is used to restrict the kinds of
      * objects, that can be inserted into the container.  None of
      * the predefined container types specializes element.
      *) ;
     <B>init</B><A name="container.1.init.2(3)"></A><A name="init.2(3)"></A>:&lt;
     (* Should be invoked before any usages of any type of
      * container
      *) Object;
     <B>clear</B><A name="container.1.clear.2(4)"></A><A name="clear.2(4)"></A>:&lt;
     (* Removes all elements currently in the container, making it
      * empty
      *) Object;
     <B>empty</B><A name="container.1.empty.2(5)"></A><A name="empty.2(5)"></A>:&lt; booleanObject; (* Returns true if the container is empty *)
     <B>size</B><A name="container.1.size.2(6)"></A><A name="size.2(6)"></A>:&lt; integerValue
     (* Returns the number of elements currently in the container
      *) ;
     <B>capacity</B><A name="container.1.capacity.2(7)"></A><A name="capacity.2(7)"></A>:&lt; integerValue
     (* Returns the current capacity of this container. Some
      * specializations may dynamically extend its capacity.  In
      * this case, capacity returns the current capacity (subject to
      * extension at some later stage).  If -1 is returned, the
      * capacity of the container is infinite (limited only by
      * memory).
      *) (#  do - 1-&gt;value; INNER #);
     <B>equal</B><A name="container.1.equal.2(8)"></A><A name="equal.2(8)"></A>:&lt; booleanValue
     (* Defines the equality test, used in the various subpatterns
      * of container in the implementation of the different
      * operations.  Users of container patterns must further bind
      * equal to contain the proper equality test for the specified
      * element type.  Default equality test for equal references
      * (i.e. the same object)
      *)
       (# left,right: ^element
       enter (left[],right[])
       do (left[] = right[])-&gt;value; INNER
       #);
     <B>has</B><A name="container.1.has.2(9)"></A><A name="has.2(9)"></A>:&lt; booleanValue
     (* Takes an element, and checks whether it is in the container
      *)
       (#
          elm: ^element;
          doneInInner: @boolean;
       enter elm[]
       do false-&gt;value;
          INNER has;
       #);
     <B>theScanner</B><A name="container.1.theScanner.2(10)"></A><A name="theScanner.2(10)"></A>:&lt;  (* private *)
       (# w:^s.where;
          s:^scan;
          aCell:^theCellType;
       enter (s[],w[])
       ...
       #);
     <B>scan</B><A name="container.1.scan.2(11)"></A><A name="scan.2(11)"></A>:
     (* Scans through the container, invoking INNER for each
      * element in the container, for which "where" returns true.
      * "Start" is invoked at the start of the scanning, and "end"
      * is invoked at the end of the scan.  In each turn of the
      * scan, "current" refers to the current element in the
      * container.  The elements will be scanned in unpredictable
      * order, unless otherwise explicitly mentioned otherwise in
      * the subpatterns
      *)
       (# 
          first:@boolean; (* private *)
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
       ...
       #);
     <B>find</B><A name="container.1.find.2(12)"></A><A name="find.2(12)"></A>:&lt;
     (* Searches through the container, executing INNER for the
      * element found and returning the first element found that
      * satisfies the predicate.  "Start" is invoked at the start of
      * the search, and "end" is invoked at the end of the search.
      * In each turn of the scan, "current" refers to the current
      * element in the container.  If no element satisfying the
      * predicate is found, the notification "notFound" is invoked.
      *)
       (#
          predicate:&lt; elementPredicate;
          current: ^element;
          notFound:&lt; Notification
            (# 
            do none-&gt;current[];
               'Element not found in container'-&gt;msg.putLine; INNER
            #);
          start:&lt; object;
          end:&lt; object;
       ...
       exit current[]
       #);
     <B>copy</B><A name="container.1.copy.2(13)"></A><A name="copy.2(13)"></A>:&lt;
     (* Default copy is one-level (shallow) copying.  I.e. copying
      * the container and all objects in the container.  Only
      * elements satisfying "predicate" will be copied.  During the
      * copying, "current" will refer to the element being
      * considered for copying.  If another copying in needed, this
      * can be done by further binding "copy", and assigning "true"
      * to "doneInInner", which will result in the default copying
      * being ignored
      *)
       (#
          doneInInner: @boolean;
          theCopy: ^container;
          predicate:&lt; elementPredicate;
          current: ^element;
       do INNER ;
       exit theCopy[]
       #);
     <B>emptyContainer</B><A name="container.1.emptyContainer.2(14)"></A><A name="emptyContainer.2(14)"></A>: Exception
     (* Invoked if some operation not valid for empty containers
      * are invoked on an empty container
      *) (#  do 'Empty container'-&gt;msg.putLine; INNER #);
     <B>emptyContainerError</B><A name="container.1.emptyContainerError.2(15)"></A><A name="emptyContainerError.2(15)"></A>:&lt; emptyContainer
     (* Used to handle emptyContainer errors, not handled by local
      * exception handlers in operations for containers
      *) ;
     <B>illegalCellReference</B><A name="container.1.illegalCellReference.2(16)"></A><A name="illegalCellReference.2(16)"></A>:&lt; Exception
     (* Invoked if some operation tries to reference a non-existing
      * cell
      *)
       (# 
       do 'Reference to nonexisting cellObject in container'-&gt;msg.putLine;
          INNER
       #);
     <B>elementPredicate</B><A name="container.1.elementPredicate.2(17)"></A><A name="elementPredicate.2(17)"></A>: booleanValue
     (* This pattern is used as the superpattern for all predicates
      * in the find, scan and copy operations.
      *) (# current: ^element enter current[] do true-&gt;value; INNER #);
     <B>theCellType</B><A name="container.1.theCellType.2(18)"></A><A name="theCellType.2(18)"></A>:&lt; (* Private *)
     (* This pattern is used as the common superpattern for all
      * data structure cells, used by implementations of the
      * subpatterns of container.
      *)
       (# elm:^element;
          copy:&lt;
            (# theCellCopy: ^theCellType
            do &amp;theCellType[]-&gt;theCellCopy[]; 
               elm[]-&gt;theCellCopy.elm[];
               INNER
            exit theCellCopy[]
            #)
       do INNER
       #);
     <B>doEnter</B><A name="container.1.doEnter.2(19)"></A><A name="doEnter.2(19)"></A>:&lt;
       (# containerType:&lt;container;
          theOther: ^containerType; 
          thePred:@elementPredicate;
       enter theOther[]
       ...
       #)
  enter doEnter
     (* will copy the contents of theOther[] into THIS(container),
      * but only elements verified with thePred;
      *)
  do INNER
  exit THIS(container)[]
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Container Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
