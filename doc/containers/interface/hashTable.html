<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>HashTable Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="list.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="dictionary.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>HashTable Interface</H1>
<PRE CLASS=interface>
ORIGIN 'collection';
LIB_DEF 'hashtable' '../lib';
BODY 'private/hashTableBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-94
 *       All rights reserved.
 *)
--- lib:attributes ---
<b>hashTable</b><A name="hashTable.1(78)"></A><A name="collection.:_subpatterns.2:hashTable.3"></A>: collection
  (* A hashTable is an efficient data structure for storing a unknown
   * number of elements for quick access.  Defines the following new
   * operations: range, hashFunction, scanIndexed, findIndexed and
   * statistics.  The available subpatterns are (indentation specifies
   * specialization):
   *       hashTable
   *          extensibleHashTable
   *)
  (# &lt;&lt;SLOT hashTableLib:attributes&gt;&gt;;
     <b>init</b><A name="hashTable.1:init.2(79)"></A><A name="init.2(79)"></A>::&lt; (# ... #);
     <b>clear</b><A name="hashTable.1:clear.2(80)"></A><A name="clear.2(80)"></A>::&lt; (# ... #);
     <b>size</b><A name="hashTable.1:size.2(81)"></A><A name="size.2(81)"></A>::&lt; (# ... #);     
     <b>rangeInitial</b><A name="hashTable.1:rangeInitial.2(82)"></A><A name="rangeInitial.2(82)"></A>:&lt; integerValue
       (* This pattern is used to define the value domain for the
        * hashFunction and thus the number of indices in
        * this(hashTable).
        *)
       (# do 17-&gt;value; INNER #);
     <b>range</b><A name="hashTable.1:range.2(83)"></A><A name="range.2(83)"></A><A name="hashTable.1:integerValue.2:_subpatterns.3:range.4"></A>: integerValue
       (* This pattern returns the number of indices in
        * this(hashTable).
        *)
       (# ... #);
     <b>indexValue</b><A name="hashTable.1:indexValue.2(84)"></A><A name="indexValue.2(84)"></A><A name="hashTable.1:integerValue.2:_subpatterns.3:indexValue.4"></A>: integerValue
       (#
       do INNER;
          (if value &lt; 0 then -value-&gt;value if);
          value mod range-&gt;value;
          (if value = 0 then 
              range-&gt;value;
          if)
       #);
     <b>index</b><A name="hashTable.1:index.2(85)"></A><A name="index.2(85)"></A><A name="hashTable.1:indexValue.2:_subpatterns.3:index.4"></A>: indexValue(# enter value do INNER #); 
     <b>theIndex</b><A name="hashTable.1:theIndex.2(86)"></A><A name="theIndex.2(86)"></A>: @index;
     <b>hashFunction</b><A name="hashTable.1:hashFunction.2(87)"></A><A name="hashFunction.2(87)"></A>:&lt; indexValue
       (* This pattern is invoked on all elements inserted into
        * THIS(hashTable).  The default behaviour will generate many
        * collisions, and specialization is therefore strongly advised
        *)
       (# e: ^element
       enter e[] 
       do 0-&gt;value;
          INNER;
       #);     
     <b>empty</b><A name="hashTable.1:empty.2(88)"></A><A name="empty.2(88)"></A>::&lt; (# ... #);
     <b>has</b><A name="hashTable.1:has.2(89)"></A><A name="has.2(89)"></A>::&lt; (# ... #);
     <b>insert</b><A name="hashTable.1:insert.2(90)"></A><A name="insert.2(90)"></A>::&lt; (# ... #);
     <b>delete</b><A name="hashTable.1:delete.2(91)"></A><A name="delete.2(91)"></A>::&lt; (# ... #);
     <b>copy</b><A name="hashTable.1:copy.2(92)"></A><A name="copy.2(92)"></A>::&lt; (# ... #);
     <b>theScanner</b><A name="hashTable.1:theScanner.2(93)"></A><A name="theScanner.2(93)"></A>::&lt;(# ... #);
     <b>scanIndexed</b><A name="hashTable.1:scanIndexed.2(94)"></A><A name="scanIndexed.2(94)"></A>:
       (* enters an index value, and scans all elements in
        * this(hashTable) with the same index value (i.e. all
        * collisions on that index value.  That is, scanIndexed is
        * similar to scan, except that it only scans the elements
        * which happen to be indexed at the same index in the
        * hashTable.  Each time INNER is invoked, current refers to
        * the actual element.  Note that if you want to scan all
        * element with the same index as some known element, elm, you
        * can do so by: elm[]-&gt;table.hashFunction-&gt;table.scanIndexed(#
        * ... do ... #)
        *)
       (# inx: @integer;
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
       enter theIndex-&gt;inx
       ...
       #);
     <b>find</b><A name="hashTable.1:find.2(95)"></A><A name="find.2(95)"></A>::
       (# 
       ...
       #);
     <b>findIndexed</b><A name="hashTable.1:findIndexed.2(96)"></A><A name="findIndexed.2(96)"></A>:
       (* enters an index value, and seeks among the elements for the
        * first element, for which predicate holds true.  If such an
        * element is found, INNER is called, and then that element is
        * returned by findIndexed.  While INNER is invoked, current
        * refers to the element found.  Note that findIndexed behavies
        * somewhat similar to Find, except that findIndexed only scans
        * through the elements in the hashTable with the given hash
        * index (i.e. the collisions).  This implies that findIndexed
        * takes advantage of the fact that this is a hashTable,
        * meaning that findIndexed is a lot faster than Find.  Note
        * that if you want to find some element with the same index as
        * some known element, elm1, you can do so by:
        * elm1[]-&gt;table.hashFunction -&gt;table.findIndexed(#
        * predicate::&lt; (# ... do ... #) #); -&gt;elm2[]
        *)
       (# inx: @integer;
          predicate:&lt; elementPredicate;
          current: ^element;
          notFound:&lt; Notification
            (#
            do 'Element not found in hashtable'-&gt;msg.putline;
               INNER
            #);
          start:&lt; object;
          end:&lt; object;
       enter theIndex-&gt;inx
       ...
       exit current[]
       #);
     <b>statistics</b><A name="hashTable.1:statistics.2(97)"></A><A name="statistics.2(97)"></A>:
       (* calculates statistics on the current status of
        * this(hashTable).  Returns a histogram in the form of a
        * table, where each entry in the table contains the number on
        * collisions for that hash index.  Also returned are the
        * maximum, minimum and avegare number of collisions found in
        * the hashTable.  The local print pattern prints this
        * information on some stream
        *)
       (# histogram: [range] @integer;
          max, min, average, usedIndices: @integer;
          print:
            (# s: ^stream; i: @integer
            enter s[]     
            do 'Histogram: '-&gt;s.putText;
               '('-&gt;s.put;
               1-&gt;i; histogram[i]-&gt;s.putInt;
               loop: (if i&lt;range then
                         ','-&gt;s.put;
                         i+1-&gt;i; histogram[i]-&gt;s.putInt;
                         restart loop
                     if);
               ')'-&gt;s.putline;
               'Maximum Collisions: '-&gt;s.putText; max-&gt;s.putInt; s.newline;
               'Minimum Collisions: '-&gt;s.putText; min-&gt;s.putInt; s.newline;
               'Average Collisions: '-&gt;s.putText; average-&gt;s.putInt; s.newline;
               INNER
            #)
       do maxInt-&gt;min; minInt-&gt;max;
          (for i:range repeat
               i-&gt;scanIndexed(# do histogram[i]+1-&gt;histogram[i] #)
          for);
          (for i:range repeat
               (if histogram[i]&gt;max then histogram[i]-&gt;max if);
               (if histogram[i]&lt;min then histogram[i]-&gt;min if);
               (if histogram[i]&gt;0 then
                   average + histogram[i]-&gt;average;
                   usedIndices+1-&gt;usedIndices
               if);
          for);
          (if usedIndices = 0 then 0-&gt;average
           else average div usedIndices-&gt;average
          if);
          INNER
       exit (histogram, max, min, average, usedIndices)
       #);
     <b>theCellType</b><A name="hashTable.1:theCellType.2(98)"></A><A name="theCellType.2(98)"></A>::&lt; (* Private *)
       (# next: (* Private *) ^theCellType #);
     <b>private</b><A name="hashTable.1:private.2(99)"></A><A name="private.2(99)"></A>:@...;
  do INNER
  #) (* hashTable *);

(*-----------------------------------------------------------------*)   
(*--- extensibleHashTable------------------------------------------*)   
(*-----------------------------------------------------------------*)   

<b>ExtensibleHashTable</b><A name="ExtensibleHashTable.1(100)"></A><A name="hashTable.:_subpatterns.2:ExtensibleHashTable.3"></A>: hashTable
  (* ExtensibleHashTable makes it possible to extend the range of
   * index values dynamically.  If the range of index value is
   * extended, the user of this(extensibleHashTable) needs to take
   * special care that the hash index of the existing objects in the
   * table is not changed, otherwise the table may not work properly.
   * In order to cope with hashFunctions that might be dependent on
   * the range of index values, extensibleHashTable defines a rehash
   * function which may be invoked to rearrange the hash indeces of
   * the existing elements in the table.  Note that rehash'ing the
   * table is a relatively costy operation, and should therefore only
   * be invoked when absolutely needed.  To make extending a table
   * safe from eventual changes in the hash indeces of elements
   * already in the tabel, the following is advised: table.extend(# do * table.rehash #) Defines two new operations: extend, rehash
   *)
  (# &lt;&lt;SLOT extensibleHashTableLib:attributes&gt;&gt;;
     <b>extend</b><A name="ExtensibleHashTable.1:extend.2(101)"></A><A name="extend.2(101)"></A>:
       (* extends this(extensibleHashTable) with the given number of
        * index values
        *)
       (# increment: @integer
       enter increment
       ...
       #);
     <b>rehash</b><A name="ExtensibleHashTable.1:rehash.2(102)"></A><A name="rehash.2(102)"></A>:
       (* takes all elements in this(extensibleHashTable) and
        * calculates new hash indexes for all of them
        *)
       (# ... #);
  do INNER
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="list.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="dictionary.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
