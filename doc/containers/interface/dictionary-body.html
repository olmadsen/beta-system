<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Dictionary Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="dictionary">Dictionary Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'container';
BODY 'private/dictionaryBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1997
 *       All rights reserved.
 *)
--- lib:attributes ---
<B>dictionary</B><A name="dictionary.1(83)"></A>: container
  (* A dictionary is an efficient data structure for storing associations
   * between two objects (the Key and the Entry).  The Key object acts as the
   * lookup value for the Entry object, such that the Entry object can be
   * located in the dictionary given the Key object.
   * 
   * Defines the operations: 
   *      hashFunction, associate, disassociate, lookup, scanAssociations
   *)
  (# &lt;&lt;SLOT dictionaryLib:attributes&gt;&gt;;
     
     <B>key</B><A name="dictionary.1:key.2(84)"></A><A name="key.2(84)"></A>:&lt; object
       (* The qualification of the Key objects of THIS(dictionary) *);
     <B>keyEqual</B><A name="dictionary.1:keyEqual.2(85)"></A><A name="keyEqual.2(85)"></A>:&lt; booleanValue
       (* Defines the equality test on key objetcs.  Users of
        * container patterns must further bind equal to contain the
        * proper equality test for the specified key type.  Default
        * equality test for equal references (i.e. the same object)
        *)
       (# left,right: ^key
       enter (left[],right[])
       do (left[] = right[])-&gt;value; INNER
       #);
     <B>init</B><A name="dictionary.1:init.2(86)"></A><A name="init.2(86)"></A>::&lt; (# ... #);
     <B>clear</B><A name="dictionary.1:clear.2(87)"></A><A name="clear.2(87)"></A>::(# ... #);
     <B>empty</B><A name="dictionary.1:empty.2(88)"></A><A name="empty.2(88)"></A>::(# ... #);
     <B>size</B><A name="dictionary.1:size.2(89)"></A><A name="size.2(89)"></A>::(# ... #);
     <B>has</B><A name="dictionary.1:has.2(90)"></A><A name="has.2(90)"></A>::(# ... #);
     <B>find</B><A name="dictionary.1:find.2(91)"></A><A name="find.2(91)"></A>::(# ... #);
     <B>copy</B><A name="dictionary.1:copy.2(92)"></A><A name="copy.2(92)"></A>::(# ... #);
     <B>hashFunction</B><A name="dictionary.1:hashFunction.2(93)"></A><A name="hashFunction.2(93)"></A>:&lt; integerValue
       (* Internally, the dictionary is organized as a hashTable, and this
        * pattern is invoked on all Keys defined in THIS(dictionary) to define
        * the location of the association.  The default behaviour will generate
        * many collisions, and specialization is therefore strongly advised
        *)
       (# k: ^key
       enter k[] 
       do INNER
       #);
     <B>associate</B><A name="dictionary.1:associate.2(94)"></A><A name="associate.2(94)"></A>:
       (* Associates the element 'e' with the key 'k' *)
       (# k: ^key; e: ^element
       enter (k[], e[])
       ...
       #);
     <B>lookup</B><A name="dictionary.1:lookup.2(95)"></A><A name="lookup.2(95)"></A>:
       (* Returns the element associated with the key 'k'.  Returns
        * NONE of no associations exists with key 'k'
        *)
       (# k: ^key; e: ^element
       enter k[]
       ...
       exit e[]
       #);
     <B>disassociate</B><A name="dictionary.1:disassociate.2(96)"></A><A name="disassociate.2(96)"></A>:
       (* Removes an possible association between key 'k' and element
        * 'e'.  Does nothing if no associateion exists.
        *)
       (# k: ^key; e: ^element
       enter k[]
       ...
       exit e[]
       #);
     <B>scanAssociations</B><A name="dictionary.1:scanAssociations.2(97)"></A><A name="scanAssociations.2(97)"></A>:
       (* Scans this(dictionary).  For each assiciation in
        * this(dictionary), 'k' will refer to the key and 'e' will
        * refer to the associated element
        *)
       (# where:&lt; elementPredicate(# k: ^key enter k[] do INNER #);
          k: ^key; e: ^element;
          start:&lt; object;
          end:&lt; object;
       ...
       #);
     <B>theScanner</B><A name="dictionary.1:theScanner.2(98)"></A><A name="theScanner.2(98)"></A>::&lt;
       (# 
       ...
       #);
     <B>storage</B><A name="dictionary.1:storage.2(99)"></A><A name="storage.2(99)"></A>: (* Private *) @...;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Dictionary Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
