<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>List Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="recList.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="arrayContainer.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>List Interface</H1>
<PRE CLASS=interface>
ORIGIN 'container';
LIB_DEF 'list' '../lib';
BODY 'private/listBody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
--- lib: attributes ---
<B>list</B><A name="list.1(118)"></A>: container
  (* This list pattern defines a double-linked list data structure.
   * Most operations either enters or exits a list position.  List
   * positions are references into a particular place in the list,
   * containing an element.  These positions are instances of
   * theCellType.
   * 
   *     list
   *       cyclicList --- prev and next operations to impl. cyclic list
   *       priorityList --- elements ordered by priority
   *       recList --- allows for recursive lists (in separate fragment)
   * 
   * Defines the following new operations: prepend, append, head,
   *     tail, last, preample, at, locate, concatenate, splitBefore,
   *     splitAfter, insertBefore, insertAfter, delete, deleteBefore,
   *     deleteAfter, scanReverse, iterate, iterateFrom,
   *     iterateReverse, iterateReverseFrom
   *)
  (# &lt;&lt;SLOT listLib: attributes&gt;&gt;;
     <B>theCellType</B><A name="list.1:theCellType.2(119)"></A><A name="theCellType.2(119)"></A>::&lt; 
       (* theCellType is the pattern from which the individual list
        * positions are created. It defines the succ and pred
        * references to the list positions immediately before/after
        * this position in the list (NONE means the end of the list
        * (either end).  The elm attribute refers to the element at
        * this position in the list.
        *)
       (# succ, pred: ^theCelltype; 
       do INNER
       #);
     <B>clear</B><A name="list.1:clear.2(120)"></A><A name="clear.2(120)"></A>::&lt; (# ... #);
     <B>size</B><A name="list.1:size.2(121)"></A><A name="size.2(121)"></A>::&lt; (# ... #);
     <B>empty</B><A name="list.1:empty.2(122)"></A><A name="empty.2(122)"></A>::&lt; (# ... #);
     <B>has</B><A name="list.1:has.2(123)"></A><A name="has.2(123)"></A>::
       (# ... #);
     <B>copy</B><A name="list.1:copy.2(124)"></A><A name="copy.2(124)"></A>::&lt;(#
            ... 
            #);
     <B>prepend</B><A name="list.1:prepend.2(125)"></A><A name="prepend.2(125)"></A>: (* insert elm as first element *)
       (# elm: ^element; 
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>append</B><A name="list.1:append.2(126)"></A><A name="append.2(126)"></A>: (* insert elm as last element *)
       (# elm: ^element; 
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>head</B><A name="list.1:head.2(127)"></A><A name="head.2(127)"></A>: 
       (* returns the position element of the first position in the
        * list
        *)
       (# position: ^theCellType
         ...
       exit position[]
       #);
     <B>tail</B><A name="list.1:tail.2(128)"></A><A name="tail.2(128)"></A>: 
       (* returns a copy of THIS(list), except the first element *)
       (# lst: ^list
         ...
       exit lst[]
       #);
     <B>last</B><A name="list.1:last.2(129)"></A><A name="last.2(129)"></A>: 
       (* returns the position element of the last position in the
        * list
        *)
       (# position: ^theCellType
         ...
       exit position[]
       #);
     <B>preample</B><A name="list.1:preample.2(130)"></A><A name="preample.2(130)"></A>: 
       (* returns a copy of THIS(list), except the last element *)
       (# lst: ^list
         ...
       exit lst[]
       #);
     <B>concatenate</B><A name="list.1:concatenate.2(131)"></A><A name="concatenate.2(131)"></A>: 
       (* returns a new list, containing the concatenated list *)
       (# otherList, newlist: ^list; 
       enter otherList[]
       ...
       exit newlist[]
       #);
     <B>insertBefore</B><A name="list.1:insertBefore.2(132)"></A><A name="insertBefore.2(132)"></A>: (* if position=NONE, insert elm as last element *)
       (# elm: ^element; position, newPosition: ^theCellType
       enter (elm[], position[])
       ...
       exit newPosition[]
       #);
     <B>insertAfter</B><A name="list.1:insertAfter.2(133)"></A><A name="insertAfter.2(133)"></A>: (* if position=NONE, insert elm as first element *)
       (# elm: ^element; position, newPosition: ^theCellType
       enter (elm[], position[])
       ...
       exit newPosition[]
       #);
     <B>delete</B><A name="list.1:delete.2(134)"></A><A name="delete.2(134)"></A>: (* if position=NONE, delete nothing *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>deleteBefore</B><A name="list.1:deleteBefore.2(135)"></A><A name="deleteBefore.2(135)"></A>: 
       (* if position=NONE, delete last position element *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>deleteAfter</B><A name="list.1:deleteAfter.2(136)"></A><A name="deleteAfter.2(136)"></A>: 
       (* if position=NONE, delete first position element *)
       (# deletedPosition, position: ^theCellType;
          empty:&lt; emptyContainer
       enter position[]
       ...
       exit deletedPosition[]
       #);
     <B>splitBefore</B><A name="list.1:splitBefore.2(137)"></A><A name="splitBefore.2(137)"></A>: 
       (* splits this(list) into two lists, where the elements before
        * position (excluding position) is placed in preList and the
        * rest of this(list) is placed in postList.  PositionElm will
        * be the head of postList.  If position=NONE, preList will
        * become a copy of the entire list and postList will become
        * NONE
        *)
       (# position: ^theCellType;
          preList, postList: ^list;
          listSplitBeforePrivate: @...
       enter position[]
       do listSplitBeforePrivate; INNER
       exit (preList[], postList[])
       #);
     <B>splitAfter</B><A name="list.1:splitAfter.2(138)"></A><A name="splitAfter.2(138)"></A>: 
       (* splits this(list) into two lists, where the elements before
        * position (including position) is placed in preList and the
        * rest of this(list) is placed in postList. PositionElm will
        * be the last element in postList If position=NONE, preList
        * will become a copy of the entire list and postList will
        * become NONE
        *)
       (# position: ^theCellType;
          preList, postList: ^list;
          listSplitAfterPrivate: @...
       enter position[]
       do listSplitAfterPrivate; INNER
       exit (preList[], postList[])
       #);
     <B>at</B><A name="list.1:at.2(139)"></A><A name="at.2(139)"></A>: (* returns the position of elm in the list *)
       (# elm: ^element;
          position: ^theCellType
       enter elm[]
       ...
       exit position[]
       #);
     <B>locate</B><A name="list.1:locate.2(140)"></A><A name="locate.2(140)"></A>: 
       (* returns the position of the element in the list, satisfying
        * predicate.  This operation is similar to find, except that
        * it returns the position, not the element.
        *)
       (# predicate:&lt; cellPredicate;
          notFound:&lt; Notification
            (# 
            do none-&gt;position[];
               'Element not found in list'-&gt;msg.putLine;
               INNER
            #);
          start:&lt; object;
          end:&lt; object;
          position: ^theCellType;
       ...
       exit position[]
       #);
     <B>find</B><A name="list.1:find.2(141)"></A><A name="find.2(141)"></A>::
       (#
       ...
       #);
     <B>thescanner</B><A name="list.1:thescanner.2(142)"></A><A name="thescanner.2(142)"></A>::&lt; (* private *)
       (# theCell:^theCelltype;
          notdone:@boolean;
       ...
       #);
     <B>theReverseScanner</B><A name="list.1:theReverseScanner.2(143)"></A><A name="theReverseScanner.2(143)"></A>:&lt; (* private *)
       (# 
          w:^elementPredicate;
          s:^scanreverse;
          aCell:^theCellType;
          notdone:@boolean;
       enter (s[],w[])
       ...
       #);
     <B>theFromScanner</B><A name="list.1:theFromScanner.2(144)"></A><A name="theFromScanner.2(144)"></A>:&lt; (* private *)
       (# 
          w:^elementPredicate;
          s:^scanFrom;
          aCell:^theCellType;
          notdone:@boolean;
       enter (s[],w[],aCell[])
       ...
       #);
     <B>scanReverse</B><A name="list.1:scanReverse.2(145)"></A><A name="scanReverse.2(145)"></A>: 
       (* similar to scan, except that it scans the list in reverse
        * direction
        *)
       (# first:@boolean;
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
       ...
       #);
     <B>scanFrom</B><A name="list.1:scanFrom.2(146)"></A><A name="scanFrom.2(146)"></A>:
       (* similar to scan, except that it scans the list from the
        * given position
        *)
       (# 
          first:@boolean;
          where:&lt; elementPredicate;
          current: ^element;
          start:&lt; object;
          end:&lt; object;
          position:^theCelltype; (* start cell *)
       enter position[]
       ...
       #);
     <B>scanReverseFrom</B><A name="list.1:scanReverseFrom.2(147)"></A><A name="scanReverseFrom.2(147)"></A>: 
       (* similar to scanReverse, except that it scans the list in
        * reverse direction from the given position
        *)
       (# where:&lt; elementPredicate;
          position: ^theCellType;
          current: ^element;
          theCell:^theCelltype;
          start:&lt; object;
          end:&lt; object;
       enter position[]
       ...
       #);
     <B>iterate</B><A name="list.1:iterate.2(148)"></A><A name="iterate.2(148)"></A>: 
       (* similar to scan, except that "current" refers to the
        * current cell in the list.  If furthermore the list is an
        * instance of the recList subpattern, iterate respects the
        * sublist structure by not scanning the elements in the
        * sublists (as scan does). I.e. during an iterate of a
        * recList, "current" may refer to a cell containing either an
        * element, or a sublist.
        *)
       (# where:&lt; cellPredicate;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIteratePrivate: @...
       ...
       #);
     <B>iterateFrom</B><A name="list.1:iterateFrom.2(149)"></A><A name="iterateFrom.2(149)"></A>: 
       (* similar to iterate, except that it takes a position, and
        * starts the iteration from that position.
        *)
       (# where:&lt; cellPredicate;
          position: ^theCellType;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateFromPrivate: @...
       enter position[]
       ...
       #);
     <B>iterateReverse</B><A name="list.1:iterateReverse.2(150)"></A><A name="iterateReverse.2(150)"></A>: 
       (* similar to iterate, except that it iterates backwards.
        *)
       (# where:&lt; cellPredicate;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateReversePrivate: @...
       ...
       #);
     <B>iterateReverseFrom</B><A name="list.1:iterateReverseFrom.2(151)"></A><A name="iterateReverseFrom.2(151)"></A>: 
       (* similar to iterateReverse, except that it takes a position,
        * and starts the reverse iteration from that position.
        *)
       (# where:&lt; cellPredicate;
          position: ^theCellType;
          current: ^theCellType;
          start:&lt; object;
          end:&lt; object;
          listIterateReverseFromPrivate: @...
       enter position[]   
       ...
       #);
     <B>cellPredicate</B><A name="list.1:cellPredicate.2(152)"></A><A name="cellPredicate.2(152)"></A>: booleanValue
       (* This pattern is used as the superpattern for the predicates
        * in the locate and iterate operations.
        *)
       (# current: ^theCellType
       enter current[]
       do true-&gt;value;
          INNER
       #);
     <B>private</B><A name="list.1:private.2(153)"></A><A name="private.2(153)"></A>:@...;
  do INNER
  #) (* list *);

<B>cyclicList</B><A name="cyclicList.1(154)"></A>: list
  (* Add operations next and prev to enable traverse the list as a
   * cycle list
   *)
  (# <B>theCellType</B><A name="cyclicList.1:theCellType.2(155)"></A><A name="theCellType.2(155)"></A>::&lt;
       (# prev:
            (# position: ^theCellType
            do pred[]-&gt;position[];
               (if position[]=NONE then last-&gt;position[] if);
            exit position[]
            #);
          next:
            (# position: ^theCellType
            do succ[]-&gt;position[];
               (if position[]=NONE then head-&gt;position[] if);
            exit position[]
            #);
       #);
  #);

<B>priorityList</B><A name="priorityList.1(156)"></A>: list
  (* implements a priority list where the elements added to the list
   * are ordered according to their priority (implemented by the
   * ordering relation 'less')
   *)
  (# <B>less</B><A name="priorityList.1:less.2(157)"></A><A name="less.2(157)"></A>:&lt; booleanValue
       (# left,right: ^element enter (left[],right[]) do INNER #);
     <B>add</B><A name="priorityList.1:add.2(158)"></A><A name="add.2(158)"></A>:
       (# elm: ^element; added: @boolean
       enter elm[]
       do loop:
            iterate
            (#
            do (if (elm[],current.elm[])-&gt;less then
                   (elm[],current[])-&gt;insertBefore;
                   true-&gt;added;
                   leave loop
               if)
            #);
          (if not added then elm[]-&gt;append if)
       #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="recList.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="arrayContainer.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
