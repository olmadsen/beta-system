<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Motif Manager Widgets</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING34></A>


<P><A HREF=xwindows-35.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-33.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-27.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P> MotifEnv</P>


<A NAME=HEADING34-0></A>
<H1> Motif Manager Widgets</H1>
<P> The following figure shows the patterns constituting the MotifEnv manager patterns. Patterns from XtEnv are shaded gray.</P>
<P> </P>
<center><IMG ALIGN=TOP SRC=images/motifenv/managers-hierarchy.gif></center>
<P> </P>
<P> </P>
<P> The following is a brief description of most of the Motif Manager
patterns. The Menu related patterns (special RowColumns, not shown in
the figure) are described <A HREF="xwindows-35.html">later</A>:</P>


<UL>
<LI><CODE>Manager</CODE><A NAME=MARKER-2-300></A>: a pattern used as a supporting superpattern for other composite patterns. It supports the visual resources, graphics contexts, and traversal resources necessary for the graphics and traversal mechanisms.

<P></P>
<LI><CODE>BulletinBoard</CODE><A NAME=MARKER-2-301></A>: a composite widget that provides simple geometry management for child widgets. It does not force positioning on its children, but can be set to reject geometry requests that result in overlapping children. BulletinBoard is the base widget for most dialog widgets and is also used as a general container widget. If its parent is a DialogShell, BulletinBoard passes title and input mode (based on dialog style) information to the parent, which is responsible for appropriate communication with the window manager.

<P></P>
<LI><CODE>Form</CODE><A NAME=MARKER-2-302></A>: a BulletinBoard with no input semantics of its own. Constraints are placed on children of the Form to define attachments for each of the child's four sides. These attachments can be to the Form, to another child widget or gadget, to a relative position within the Form, or to the initial position of the child. The attachments determine the layout behavior of the Form when resizing occurs.

<P></P>
<LI><CODE>DrawingArea</CODE><A NAME=MARKER-2-303></A>: an empty widget that is easily adaptable to a variety of purposes. It does no drawing and defines no behavior except for invoking callbacks. Callbacks notify the application when graphics need to be drawn (exposure events or widget resize) and when the widget receives input from the keyboard or mouse. Applications are responsible for defining appearance and behavior as needed in response to DrawingArea callbacks.

<P></P>
<LI><CODE>Frame</CODE><A NAME=MARKER-2-304></A>: a very simple manager used to enclose a single child in a border drawn by the Frame. It uses the Manager class resources for border drawing and performs geometry management so that its size always matches its child's size plus the margins defined for it. Frame is most often used to enclose other managers when the application developer desires the manager to have the same border appearance as the primitive widgets. 

<P></P>
<LI><CODE>RowColumn</CODE><A NAME=MARKER-2-305></A>: a general purpose
row/column manager capable of containing any widget type as a
child. In general, it requires no special knowledge about how its
children function and provides nothing beyond support for several
different layout styles. However, it can be configured as a menu, in
which case, it expects only certain children, and it configures to a
particular layout. The menus supported are: MenuBar, Pulldown or Popup
MenuPanes, and OptionMenu. The type of layout performed is controlled
by how the application has set the various layout resources. Menus are
described in detail later in this document. It can be configured to
lay out its children in either rows or columns. In addition, the
application can specify how the children are laid out, as follows: 
<OL>
<LI>the children are packed tightly together into either rows or
columns,
<LI>each child is placed in an identically sized box (producing a
symmetrical look), or 
<LI>a specific layout (the current x and y
positions of the children control their location). 
</OL>

In addition, the
application has control over both the spacing that occurs between each
row and column and the margin spacing present between the edges of the
RowColumn widget and any children that are placed against it. By
default the RowColumn widget has no 3-D visuals associated with it; if
an application wishes to have a 3-D shadow placed around this widget,
it can create the RowColumn as a child of a Frame widget.

<P></P>
<LI><CODE>Radiobox</CODE><A NAME=MARKER-2-306></A>: Utility pattern to instantiate a RowColumn widget of type XmWORK_AREA. Typically, this is a composite widget that contains multiple ToggleButtonGadgets. The RadioBox arbitrates and ensures that at most one ToggleButtonGadget is on at any time. This pattern provides initial values for several RowColumn resources. It initializes packing to XmPACK_COLUMN, radioBehavior to True, isHomogeneous to True, and entryClass to xmToggleButtonGadgetClass. In a RadioBox the ToggleButton or ToggleButtonGadget resource indicatorType defaults to XmONE_OF_MANY, and the ToggleButton or ToggleButtonGadget resource visibleWhenOff defaults to True.

<P></P>
<LI><CODE>ScrolledWindow</CODE><A NAME=MARKER-2-307></A>: combines one or two ScrollBar widgets and a viewing area to implement a visible window onto some other (usually larger) data display. The visible part of the window can be scrolled through the larger display by the use of ScrollBars.

<P></P>
<LI><CODE>MainWindow</CODE><A NAME=MARKER-2-308></A>: provides a standard layout for the primary window of an application. This layout includes a MenuBar, a CommandWindow, a work region, a MessageWindow, and ScrollBars. Any or all of these areas are optional. The work region and ScrollBars in the MainWindow behave identically to the work region and ScrollBars in the ScrolledWindow widget. The user can think of the MainWindow as an extended ScrolledWindow with an optional MenuBar and optional CommandWindow and MessageWindow. In a fully-loaded MainWindow, the MenuBar spans the top of the window horizontally. The CommandWindow spans the MainWindow horizontally just below the MenuBar, and the work region lies below the CommandWindow. The MessageWindow is below the work region. A MainWindow can also create three Separator widgets that provide a visual separation of MainWindow's four components.

<P></P>
<LI><CODE>Scale</CODE><A NAME=MARKER-2-309></A>: used by an application to indicate a value from within a range of values, and it allows the user to input or modify a value from the same range. A Scale has an elongated rectangular region similar to a ScrollBar. A slider inside this region indicates the current value along the Scale. The user can also modify the Scale's value by moving the slider within the rectangular region of the Scale. A Scale can also include a label set located outside the Scale region. These can indicate the relative value at various positions along the scale. A Scale can be either input/output or output only. An input/output Scale's value can be set by the application and also modified by the user with the slider. An output-only Scale is used strictly as an indicator of the current value of something and cannot be modified interactively by the user.

<P></P>
<LI><CODE>PanedWindow</CODE><A NAME=MARKER-2-310></A>: a Composite that lays out children in a vertically tiled format. Children appear in top-to-bottom fashion, with the first child inserted appearing at the top of the PanedWindow and the last child inserted appearing at the bottom. The user can adjust the size of the panes. To facilitate this adjustment, a pane control sash is created for most children. The sash appears as a square box positioned on the bottom of the pane that it controls. The user can adjust the size of a pane by using the mouse or keyboard. The PanedWindow is also a Constraint, which means that it creates and manages a set of constraints for each child.
</UL>
<A NAME=HEADING34-18></A>
<H1> Examples using Motif Manager Widgets</H1>
<P> The following example shows one usage of the very useful RowColumn widget. Here six PushButtonGadgets are placed in three horizontal rows.</P>
<A NAME=HEADING34-20></A>
<A NAME=rowcol.bet><H4 CLASS=betacaption>rowcol.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/rowcolumn';
INCLUDE '~beta/Xt/motif/pushbuttongadget';

-- PROGRAM: descriptor --
MotifEnv
(# rowCol: @RowColumn
     (# buttons: [6]^PushButtonGadget;
        init::&lt; 
          (# t: @text;
          do (for i: 6 repeat 
                  &amp;PushButtonGadget[] -&gt; buttons[i][];
                  buttons[i].init;
                  t.clear; 'Button ' -&gt; t.putText;
                  i -&gt; t.putInt;
                  t[] -&gt; buttons[i].labelString;
             for);
             XmHORIZONTAL -&gt; orientation;
             XmPACK_COLUMN -&gt; packing;
             3 -&gt; numColumns; 
          #);
     #);
do rowCol.init;
#)
</PRE>
<P> Notice that when the orientation is horizontal, the numColumns<A NAME=MARKER-2-311></A> resource specifies the number of rows. When the program is run, the following window appears:</P>
<P> </P>
<blockquote><IMG ALIGN=TOP SRC=images/motifenv/rowcol.gif></blockquote>
<P> </P>
<P> </P>

<P> The following example shows how the BulletinBoard can be used: Six children are placed at absolute (x,y) positions.</P>
<A NAME=HEADING34-54></A>
<A NAME=bulletin.bet><H4 CLASS=betacaption>bulletin.bet</H4></A>
 
<PRE CLASS=beta>
ORIGIN  '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/bulletinboard';
INCLUDE '~beta/Xt/motif/texts';
INCLUDE '~beta/Xt/motif/pushbutton';

-- PROGRAM: descriptor --
MotifEnv
(# board: @BulletinBoard
     (# button: PushButton
          (# activateCallback::&lt; 
               (#
               do (for i: buttons.range repeat
                       (if buttons[i][]= this(button)[] then
                           editors[i].value -&gt; screen.putLine;
                       if)
                  for)
               #);
          #);
        buttons: [3] ^button;
        editors: [3] ^MotifText;
        init::&lt; 
          (#
          do (for i: buttons.range repeat
                  &amp;button[] -&gt; buttons[i][];
                  buttons[i].init; 
                  10 -&gt; buttons[i].x;
                  10 + (30*(i-1)) -&gt; buttons[i].y;
             for);
             (for i: editors.range repeat
                  &amp;MotifText[] -&gt; editors[i][];
                  editors[i].init;
                  100 -&gt; editors[i].x;
                  10 + (30*(i-1)) -&gt; editors[i].y;
             for);
             ' Name: ' -&gt; buttons[1].labelString;
             ' Phone: ' -&gt; buttons[2].labelString;
             ' Address: ' -&gt; buttons[3].LabelString;
          #);
     #);
do board.init;
#)
</PRE>
<P> When the program is run, the following window appears:</P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/bulletin.gif></BLOCKQUOTE>
<P> </P>
<P> The three text entry fields have been filled out.</P>
<P> </P>
<P> The next example shows one way to use the Form<A NAME=MARKER-2-312></A> widget: Three PushButtons<A NAME=MARKER-2-313></A> are aligned above each other using the Form constraint resources of the children. Notice that this could be done much easier using a RowColumn<A NAME=MARKER-2-314></A> widget.</P>
<A NAME=HEADING34-105></A>
<A NAME=form.bet><H4 CLASS=betacaption>form.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/form';
INCLUDE '~beta/Xt/motif/pushbutton';

-- PROGRAM: descriptor --
MotifEnv
(# window: @Form
     (# button1: @PushButton(# #);
        button2: @PushButton(# #);
        button3: @PushButton(# #);
        init::&lt; 
          (# 
          do button1.init;
             button2.init;
             button3.init;
             XmATTACH_FORM -&gt; button1.topAttachment;
             XmATTACH_FORM -&gt; button1.leftAttachment;
             XmATTACH_FORM -&gt; button1.rightAttachment;
             XmATTACH_WIDGET -&gt; button2.topAttachment;
             button1 -&gt; button2.topWidget;
             XmATTACH_FORM -&gt; button2.leftAttachment;
             XmATTACH_FORM -&gt; button2.rightAttachment;
             XmATTACH_WIDGET -&gt; button3.topAttachment;
             button2 -&gt; button3.topWidget;
             XmATTACH_FORM -&gt; button3.leftAttachment;
             XmATTACH_FORM -&gt; button3.rightAttachment;
             XmATTACH_FORM -&gt; button3.bottomAttachment;
          #);
     #);
do window.init
#)
</PRE>

<P>
In general specific constraints may be put on each edge of the
children. Here one PushButton<A NAME=MARKER-2-315></A> - button1 - is attached to the Form
itself on three sides. This means that button1 will attempt to resize
these three edges if the Form is resized. A second PushButton -
button2 - is then attached vertically to button1: Its topAttachment
resource is specified as the constant XmATTACH_WIDGET, and button1 is
then specified as the topWidget of button2. Likewise a third button -
button3 - is attached vertically to button2. When the application is
run, the following window appears: </P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/form.gif></BLOCKQUOTE>
<P> </P>

<P> Several special variants of the RowColumn<A NAME=MARKER-2-316></A>
widget are supplied by MotifEnv. This includes various menus described
later, and it also includes the pattern RadioBox<A
NAME=MARKER-2-317></A>, used to create a traditional &quot;radio
panel&quot; of buttons. The following example demonstrates the
RadioBox pattern:</P>

<A NAME=HEADING34-146></A>
<A NAME=radiobox.bet><H4 CLASS=betacaption>radiobox.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/rowcolumn';
INCLUDE '~beta/Xt/motif/togglebuttongadget';
INCLUDE '~beta/Xt/motif/pushbuttongadget';

-- PROGRAM: descriptor --
MotifEnv
(# main: @RowColumn
     (# panel: @RadioBox
          (# r1, r2, r3, r4, r5, r6: @ToggleButtonGadget
               (# valueChangedCallback::&lt; 
                    (# 
                    do name -&gt; screen.puttext; 
                       (if data.set then ' set' -&gt; putLine
                        else ' unset' -&gt; putLine
                       if)
                    #);
               #);
             init::&lt; 
               (#
               do ('Choice 1', panel) -&gt; r1.init;
                  ('Choice 2', panel) -&gt; r2.init;
                  ('Choice 3', panel) -&gt; r3.init;
                  ('Choice 4', panel) -&gt; r4.init;
                  ('Choice 5', panel) -&gt; r5.init;
                  ('Choice 6', panel) -&gt; r6.init;
               #);
          #);
        quit: @PushButtonGadget
          (# init::&lt; (# do 'Quit' -&gt; labelString #);
             activateCallback::&lt; (# do stop #)
          #);
        init::&lt; (# do panel.init; quit.init #);
     #)
do main.init
#)
</PRE>
<P> When this program is run, the window shown below with six
ToggleButtonGadget<A NAME=MARKER-2-318></A>s and one
PushButtonGadget<A NAME=MARKER-2-319></A> (Quit) appears. The window
is shown in a state, where the third item is selected. Notice, that
the button appears to be pushed inwards.</P>

<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/radiobox.gif></BLOCKQUOTE>
<P> </P>


<P> Many standard applications consists of one main window, with a menu bar with menus and a working area that can be scrolled. For this purpose, a MainWindow widget with support for this setup is provided. The following is an excerpt of an application using the MainWindow<A NAME=MARKER-2-320></A> widget: </P>
<A NAME=HEADING34-191></A>
<A NAME=mainwindow.bet><H4 CLASS=betacaption>mainwindow.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/allmotif'
--PROGRAM: descriptor--
MotifEnv
(# main: @MainWindow
     (# work: @ArrowButtonGadget;
        mbar: @MenuBar
          (# specification of menu bar not shown ... #);
        init::&lt; 
          (# 
          do mbar.init;     work.init;
             200 -&gt; height; 300 -&gt; work.height;        
             200 -&gt; width;  300 -&gt; work.width;  
          #);
     #);
   fallbackResources::&lt;
     (# init::&lt;
          (# 
          do '*XmMainWindow.scrollingPolicy: XmAUTOMATIC' 
               -&gt; addtext
          #);
     #);
do main.init;
#)
</PRE>

<P> For work area, an ArrowButtonGadget<A NAME=MARKER-2-321></A> is used. This could be any other widget. In the initialization, the ArrowButtonGadget is made bigger than the working area of the MainWindow. This will force the scroll bars to appear. </P>



<P> The scrollingPolicy resource of the MainWindow cannot be changed on the fly, but only at creation time. Thus the easiets way to do it, is to specify it in a standard X Toolkit resource file, but the fallbackResources virtual of XtEnv can also be used as is done here. Setting the scrollingPolicy<A NAME=MARKER-2-322></A> to XmAUTOMATIC will make scrollbars appear when needed.</P>
<P> When the program is run the following window appears:</P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/mainwindow.gif></BLOCKQUOTE>
<P> </P>
<P> The window is shown in a situation, where the File menu has been posted. It will later be shown how to program the menu bar with this File menu.</P>

<P> The next example shows how to use the special purpose Scale<A NAME=MARKER-2-323></A> widget, useful for adding, e.g., a potentiometer-like control to a panel of controls.</P>
<A NAME=HEADING34-230></A>
<A NAME=scale.bet><H4 CLASS=betacaption>scale.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/scale';
-- PROGRAM: descriptor --
MotifEnv
(# volume: @Scale
     (# init::&lt;
          (# 
          do 0 -&gt; minimum;
             100 -&gt; maximum;
             XmVERTICAL -&gt; orientation;
             'Volume' -&gt; titleString;
             true -&gt; showValue;
          #);
        valueChangedCallback::&lt;
          (# 
          do 'New volume: ' -&gt; screen.puttext;
             data.value -&gt; screen.putint;
             screen.newline;
          #);
     #);
do volume.init;
#)
</PRE>
<P> The following window will appear when the program is run:</P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/scale.gif></BLOCKQUOTE>
<P> </P>


<P> The valueChangedCallback is called after the scale has been changed. In this case the callback data<A NAME=MARKER-2-324></A> is furtherbound to XmScaleCallbackStruct<A NAME=MARKER-2-325></A>, that has an attribute called  value, that contains the current value of the Scale.</P>




<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>X Libraries - Reference Manual</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=xwindows-35.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-33.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-27.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>



</BODY>
</HTML>
