<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Motif Menus</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING35></A>


<P><A HREF=xwindows-36.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-34.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-27.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P> MotifEnv</P>


<A NAME=HEADING35-0></A>
<H1> Motif Menus</H1>
<P> The following figure shows the menu-related patterns of MotifEnv. Patterns from XtEnv are shaded gray, and other MotifEnv patterns are shaded light-gray:</P>
<P> </P>
<P> </P>
<center><IMG ALIGN=TOP SRC=images/motifenv/menus-hierarchy.gif></center>
<P> </P>
<P> </P>
<P> The following is a brief presentation of the menu-related patterns:</P>

<UL>
<LI><CODE>PopupMenu</CODE><A NAME=MARKER-2-326></A>: Utility pattern used to instantiate a RowColumn widget of type XmMENU_POPUP. When the Popup MenuPane is created, a MenuShell widget is automatically created as the parent of the MenuPane. The PopupMenu is used as the first MenuPane within a PopupMenu system; all other MenuPanes are of the Pulldown type. A Popup MenuPane displays a 3-D shadow, unless the feature is disabled by the application. The shadow appears around the edge of the MenuPane. A PopupMenu is &quot;popped up&quot; using manageChild, and &quot;popped down&quot; using unmanageChild. The menu can be positioned before being managed using the local  position pattern.

<P></P>
<LI><CODE>PullDownMenu</CODE><A NAME=MARKER-2-327></A>: Utility pattern to create a RowColumn of type XmMENU_PULLDOWN. When creating a PulldownMenu, a MenuShell is automatically created as the parent of PulldownMenu. If the parent specified is a PopupMenu or a PulldownMenu, the MenuShell is created as a child of the parent's MenuShell; otherwise, it is created as a child of the specified parent widget. A PulldownMenu displays a 3-D shadow, unless the feature is disabled by the application. The shadow appears around the edge of the PulldownMenu. A PulldownMenu is used when creating submenus that are to be attached to a CascadeButton or a CascadeButtonGadget. This is the case for all MenuPanes that are part of a PulldownMenu system (a MenuBar), the MenuPane associated with an OptionMenu, and any MenuPanes that cascade from a Popup MenuPane. 

<P></P>
<LI><CODE>PulldownMenus</CODE> that are to be associated with an OptionMenu<A NAME=MARKER-2-328></A> must be created before the OptionMenu is created.
<LI> The PulldownMenu must be attached to a CascadeButton<A NAME=MARKER-2-329></A> or CascadeButtonGadget<A NAME=MARKER-2-330></A> that resides in a MenuBar, a Popup MenuPane, a Pulldown MenuPane, or an OptionMenu. This is done by using the button resource subMenuId<A NAME=MARKER-2-331></A>.
<LI> To function correctly when incorporated into a menu, the PulldownMenu's hierarchy must be considered; this hierarchy depends on the type of menu system that is being built as follows:
<UL>
<LI> If the PulldownMenu is to be pulled down from a MenuBar, its parent must be the MenuBar.
<LI> If the PulldownMenu is to be pulled down from a PopupMenu or another PulldownMenu, its parent must be that PopupMenu or PulldownMenu.
<LI> If the PulldownMenu is to be pulled down from an OptionMenu, its parent must be the same as the OptionMenu parent.
</UL>

<P></P>
<LI><CODE>OptionMenu</CODE><A NAME=MARKER-2-332></A>: Utility pattern for instantiating a RowColumn widget of type XmMENU_OPTION. An OptionMenu widget is a specialized RowColumn manager composed of a label, a selection area, and a single Pulldown MenuPane. When an application creates an OptionMenu widget, it supplies the label string and the PulldownMenu. In order to succeed, there must be a valid subMenuId resource set. When the OptionMenu is created, the PulldownMenu must have been created as a child of the OptionMenu's parent and must be specified. The LabelGadget<A NAME=MARKER-2-333></A> and the selection area (a CascadeButtonGadget<A NAME=MARKER-2-334></A>) are created by the OptionMenu. An OptionMenu is laid out with the label displayed on one side of the widget and the selection area on the other side. The selection area has a dual purpose; it displays the label of the last item selected from the associated PulldownMenu, and it provides the means for posting the PulldownMenu. The PulldownMenu is posted by moving the mouse pointer over the selection area and pressing a mouse button defined by OptionMenu's RowColumn parent. The PulldownMenu is posted and positioned so that the last selected item is directly over the selection area. The mouse is then used to arm the desired menu item. When the mouse button is released, the armed menu item is selected and the label within the selection area is changed to match that of the selected item. The OptionMenu also operates by using the keyboard interface mechanism. If the application has established a mnemonic with the OptionMenu, typing Alt with the mnemonic causes the PulldownMenu to be posted with traversal enabled. The standard traversal keys can then be used to move within the Menu. Selection can occur as the result of pressing the Return key or typing a mnemonic or accelerator for one of the menu items. An application may use the menuHistory resource to indicate which item in the PulldownMenu should be treated as the current choice and have its label displayed in the selection area. By default, the first item in the PulldownMenu is used.

<P></P>
<LI><CODE>MenuBar</CODE><A NAME=MARKER-2-335></A>: Utility pattern for instantiating a RowColumn widget of type XmMENU_BAR. A MenuBar is generally used for building a Pulldown menu system. Typically, a MenuBar is created and placed along the top of the application window, and several CascadeButtons are inserted as the children. Each of the CascadeButtons has a PulldownMenu associated with it. These PulldownMenus must have been created as children of the MenuBar. The user interacts with the MenuBar by using either the mouse or the keyboard. A MenuBar displays a 3-D shadow along its border. The application controls the shadow attributes using the visual-related resources supported by Manager. A MenuBar widget is homogeneous in that it accepts only children that are specializations of CascadeButton or CascadeButtonGadget. Attempting to insert a child of a different class results in a warning message. If a MenuBar does not have enough room to fit all of its subwidgets on a single line, the MenuBar attempts to wrap the remaining entries onto additional lines if allowed by the geometry manager of the parent widget.
</UL>
<A NAME=HEADING35-18></A>
<H1> Examples using Motif Menus</H1>
<P> The following is an example of using an option menu.</P>
<A NAME=HEADING35-20></A>
<A NAME=optionmenu.bet><H4 CLASS=betacaption>optionmenu.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/rowcolumn';
INCLUDE '~beta/Xt/motif/pushbuttongadget';

-- PROGRAM: descriptor -- 
MotifEnv
(# main: @RowColumn
     (# menuPane: @PulldownMenu
          (# item1,item2,item3,item4: @PushButtonGadget
               (# activateCallback::&lt; 
                    (# do name-&gt;puttext; ' selected'-&gt;putLine #);  
               #);
             init::&lt;
               (#
               do ('Option1', menuPane) -&gt;item1.init;
                  ('Option2', menuPane) -&gt;item2.init;
                  ('Option3', menuPane) -&gt;item3.init;
                  ('Option4', menuPane) -&gt;item4.init;
               #);
          #);
        optMenu: @OptionMenu
          (# init::&lt; 
               (# subMenu::&lt; (# do menuPane -&gt; value #);
               do 'Choose an option:' -&gt; labelString;
                  menuPane.item2 -&gt; menuHistory;
               #);
          #);
        quit: @PushButtonGadget
          (# init::&lt; (# do 'Quit' -&gt; labelString #);
             activateCallback::&lt; (# do stop #)
          #);
        init::&lt; 
          (#
          do XmHORIZONTAL -&gt; orientation;
             menuPane.init;
             optMenu.init;
             quit.init; 
          #);
     #);
do main.init; 
#)
</PRE>

<P> First a menu pane to use in the option menu is created: This is a
PullDownMenu<A NAME=MARKER-2-336></A> with four PushButtonGadget<A
NAME=MARKER-2-337></A>s as items. Then the option menu widget is
created. This will glue the menu pane, a label and a button
together. Notice, that specification of the menu pane for the option
menu is done using the subMenu virtual local to the init virtual. This
is because the OptionMenu widget needs to know what menu pane to use
already when the OptionMenu is created.</P>

<P> When the program is run, the following window appears:</P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/optionmenu.gif></BLOCKQUOTE>
<P> </P>
<P> As can be seen, the OptionMenu<A NAME=MARKER-2-338></A> starts out with Option2 selected. This was specified in the program using the menuHistory resource. When the OptionMenu button is clicked, the menu pops up, and a new option can be selected:</P>
<P> </P>
<BLOCKQUOTE><IMG ALIGN=TOP SRC=images/motifenv/optionmenu-armed.gif></BLOCKQUOTE>
<P> </P>
<P> </P>
<P> The following example shows how to create and use a PopupMenu:</P>
<A NAME=HEADING35-76></A>
<A NAME=popupmenu.bet><H4 CLASS=betacaption>popupmenu.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/primitive';
INCLUDE '~beta/Xt/motif/rowcolumn';
INCLUDE '~beta/Xt/motif/separatorgadget';
INCLUDE '~beta/Xt/motif/pushbuttongadget';

-- PROGRAM: descriptor -- 
MotifEnv
(# theMenu: @PopupMenu
     (# item1,item2,item3,item4: @PushButtonGadget
          (# activateCallback::&lt; 
               (# do name -&gt; puttext; ' selected' -&gt; putLine #);  
          #);
        quit: @PushButtonGadget
          (# activateCallback::&lt; (# do stop #)#);
        init::&lt;
          (# sep: ^SeparatorGadget; 
          do ('Item1', theMenu) -&gt;item1.init;
             ('Item2', theMenu) -&gt;item2.init;
             ('Item3', theMenu) -&gt;item3.init;
             ('Item4', theMenu) -&gt;item4.init;
             &amp;SeparatorGadget[] -&gt; sep[]; sep.init; 
             ('Quit', theMenu) -&gt; quit.init;
          #);
     #);
   main: @Primitive
     (# eventHandler::&lt;
          (# bp: @ButtonPress
               (# 
               do event -&gt; theMenu.position;
                  theMenu.manageChild 
               #);
             init::&lt; (# do bp.enable #);
          #);
        init::&lt; (# do 100 -&gt; width; 100 -&gt; height;#);
     #);
do main.init; 
   ('theMenu', main) -&gt; theMenu.init;
#)
</PRE>

<P> The PopupMenu is created having five PushButtonGadget<A
NAME=MARKER-2-339></A>s and one SeparatorGadget<A
NAME=MARKER-2-340></A> as children. In the example, this menu is to be
popped up from a Primitive. This is done, by further binding the
eventhandler<A NAME=MARKER-2-341></A> of the Primitive: a
ButtonPress<A NAME=MARKER-2-342></A> eventprocessor is instantiated
and enabled. When a button is pressed within the Primitive, the
do-part of this eventprocessor is invoked. This will do two things: 
<OL>
<LI>The event causing the invocation is handled to the local position<A
NAME=MARKER-2-343></A> pattern of the PopupMenu<A
NAME=MARKER-2-344></A>. This will place the menu in a way so that the
first menu item is just where the mouse was pressed. The position
pattern uses informations in the event object for this. 
<LI>The menu is
popped up. This is done by using the manageChild<A
NAME=MARKER-2-345></A> atttribute.
</OL>
</P> 

<P> When the program is executed, the window shown left below
appears. When a mouse button is then pressed, the menu pops up as
shown in the right window below.</P>

<BLOCKQUOTE>
<NOBR>
<IMG ALIGN=TOP SRC=images/motifenv/popupmenu.gif>
<IMG ALIGN=TOP SRC=../images/trans5x5.gif width=100 height=5>
<IMG ALIGN=TOP SRC=images/motifenv/popupmenu-armed.gif>
</NOBR>
</BLOCKQUOTE>

</TD></TR></TABLE><P> </P>

<P> The next example shows how to create a pulldown menu system using
a MenuBar<A NAME=MARKER-2-346></A>, and also it shows how to create
hierarchical menus using CascadeButtonGadgets.</P>

<A NAME=HEADING35-139></A>
<A NAME=pulldownmenu.bet><H4 CLASS=betacaption>pulldownmenu.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/motifenv';
INCLUDE '~beta/Xt/motif/rowcolumn';
INCLUDE '~beta/Xt/motif/cascadebutton';
INCLUDE '~beta/Xt/motif/pushbuttongadget';
INCLUDE '~beta/Xt/motif/cascadebuttongadget';

-- PROGRAM: descriptor --
MotifEnv
(# menus: @MenuBar
     (# menubutton: @CascadeButton
          (* The button that activates the menu *)
          (# init::&lt; (# do 'Menu' -&gt; labelString #)#);
        menu: @PulldownMenu
          (# item1: @PushButtonGadget
               (# activateCallback::&lt; 
                    (# do 'Item1 selected' -&gt; putLine #);
               #);
             item2: @CascadeButtonGadget
               (# submenu: @PullDownMenu
                    (# cascade1: @PushButtonGadget
                         (# activateCallback::&lt; 
                             (# do 'Cascade 1 selected'-&gt;putLine #);
                         #);
                       cascade2: @PushButtonGadget
                         (# activateCallback::&lt; 
                             (# do 'Cascade 2 selected'-&gt;putLine #);
                         #);
                       init::&lt; 
                         (# do cascade1.init; cascade2.init #);
                    #);
                  init::&lt; (# do submenu.init; submenu-&gt;subMenuId #);
               #);
             quit: @PushButtonGadget
               (# activateCallback::&lt; (# do stop #)#);
             init::&lt; (# do item1.init; item2.init; quit.init #);
          #);
        init::&lt;
          (# 
          do menubutton.init;
             menu.init;
             menu -&gt; menubutton.subMenuId;
     #)#);
do menus.init;
#)
</PRE>
<P> A MenuBar<A NAME=MARKER-2-347></A> can contain CascadeButton<A
NAME=MARKER-2-348></A>s, each having a PullDownMenu<A
NAME=MARKER-2-349></A> attached. In the example only one CascadeButton
is created, thus the menu bar will only contain one menu. The
CascadeButton - menubutton - is initialized first. Its label string is
set to "Menu". Then the PulldownMenu is
initialized. It contains three items, the first and last one being
normal PushButtonGadgets. The second item, however, is a
CascadeButtonGadget. This is used to bind a sub menu to the main
menu. The submenu is a normal PullDownMenu, which is initialized, and
then attached to the CascadeButtonGadget using the subMenuId resource
of the CascadeButtonGadget. Finally the main menu is attached to the
CascadeButton in the MenuBar, by using the  submenuId resource of the
CascadeButton in the MenuBar.</P>

<P> When the program is executed, a window containing a menu bar with
just one button appears. Below in the window shown left, the menu
button has been activated, and the menu has been posted. Notice the
arrow in the second menu item, indicating that the item has a sub
menu. If the second item is activated, the submenu will pop up, as
shown in the right window below.</P>

<P> </P>
<BLOCKQUOTE>
<NOBR>
<IMG ALIGN=TOP SRC=images/motifenv/pulldownmenu.gif>
<IMG ALIGN=TOP SRC=../images/trans5x5.gif width=100 height=5>
<IMG ALIGN=TOP SRC=images/motifenv/pulldownmenu-cascading.gif>
</NOBR>
</BLOCKQUOTE>

<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>X Libraries - Reference Manual</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=xwindows-36.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-34.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-27.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>



</BODY>
</HTML>
