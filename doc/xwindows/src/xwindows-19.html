<H1> Composite Athena Widgets</H1>
<P> The following figure illustrates the inheritance hierarchy among the composite Athena widgets. Widgets from XtEnv are shaded gray:</P>
<P> </P>
<center><IMG ALIGN=TOP SRC=images/awenv/composite-hierarchy.gif></center>
<P> </P>
<A NAME=HEADING19-5></A>
<H1> Box </H1>
<P> The Box<A NAME=MARKER-2-174></A> widget provides geometry management of arbitrary widgets in a box of a specified dimension. The children are rearranged when resizing events occur either on the Box or its children, or when children are managed or unmanaged. The Box widget always attempts to pack its children as tightly as possible within the geometry allowed by its parent. </P>
<P> Box widgets are commonly used to manage a related set of buttons and are often called ButtonBox<A NAME=MARKER-2-175></A> widgets, but the children are not limited to buttons. The Box's children are arranged on a background that has its own specified dimensions and colour.</P>
<A NAME=HEADING19-8></A>
<H1> Form </H1>
<P> The Form<A NAME=MARKER-2-176></A> widget can contain an arbitrary number of children or subwidgets. The Form provides geometry management for its children, which allows individual control of the position of each child. Any combination of children can be added to a Form. The initial positions of the children may be computed relative to the positions of other children. When the Form is resized, it computes new positions and sizes for its children. This computation is based upon information provided for each child.</P>
<P> The default width of the Form is the minimum width needed to enclose the children after computing their initial layout, with a margin of defaultDistance at the right and bottom edges. If a width and height is assigned to the Form that is too small for the layout, the children will be clipped by the right and bottom edges of the Form.</P>
<H2> Extra attributes for children of Form </H2>

<P> Each child of the Form widget has a set of operations available to control the layout. These attributes allow the Form widget's children to specify individual layout requirements. Available attributes include the patterns fromHoriz<A NAME=MARKER-2-177></A>, fromVert<A NAME=MARKER-2-178></A>, horizDistance<A NAME=MARKER-2-179></A>, vertDistance<A NAME=MARKER-2-180></A>, resizable<A NAME=MARKER-2-181></A>, bottom<A NAME=MARKER-2-182></A>, left<A NAME=MARKER-2-183></A>, right<A NAME=MARKER-2-184></A>, top<A NAME=MARKER-2-185></A>, see the <A HREF="interfaces/Athena/index.html">Interface Descriptions</A> for details.</P>
<P> The above mentioned patterns are actually attributes of the Core pattern. But they only function and should only be used for aggregation components of a Form.</P>
<H2> Form's Layout semantics<A NAME=MARKER-2-186></A></H2>
<P> The Form widget uses two different sets of layout semantics. One is used when initially laying out the buttons. The other is used when the Form is resized. </P>
<P> The first layout method uses the fromVert<A NAME=MARKER-2-187></A> and fromHoriz<A NAME=MARKER-2-188></A> attributes to place the children of the Form<A NAME=MARKER-2-189></A>. A single pass is made through the Form widget's children in the order that they were created. Each child is then placed in the Form widget below or to the right of the widget specified by the fromVert and fromHoriz<A NAME=MARKER-2-190></A> attributes. The distance the new child is placed from its left or upper neighbour is determined by the horizDistance and vertDistance attributes. This implies some things about how the order of creation affects the possible placement of the children. </P>
<P> The second layout method is used when the Form is resized. It does not matter what causes this resize, and it is possible for a resize to happen before the widget becomes visible (due to constraints imposed by the parent of the Form). This layout method uses the bottom<A NAME=MARKER-2-191></A>, top<A NAME=MARKER-2-192></A>, left<A NAME=MARKER-2-193></A>, and right<A NAME=MARKER-2-194></A> attributes. These attributes are used to determine what will happen to each edge of the child when the Form is resized. If a value of Chain&lt;something&gt; is specified, the edge of the child will remain a fixed distance from the chain edge of the form. For example if ChainLeft<A NAME=MARKER-2-195></A> is specified for the right attribute of a child then the right edge of that child will remain a fixed distance from the left edge of the widget. If a value of Rubber<A NAME=MARKER-2-196></A> is specified, that edge will grow by the same percentage that the Form grew. For instance if the Form grows by 50% the left edge of the child (if specified as Rubber will be 50% farther from the left edge of the Form). One must be very careful when specifying these attributes, for when they are specified incorrectly children may overlap or completely occlude other children when the Form widget is resized.</P>
<A NAME=HEADING19-19></A>
<H1> Dialog</H1>
<P> The Dialog<A NAME=MARKER-2-197></A> widget implements a commonly used interaction semantic to prompt for auxiliary input from a user. For example, you can use a Dialog widget when an application requires a small piece of information, such as a filename, from the user. A Dialog widget, which is simply a special case of the Form widget, provides a convenient way to create a preconfigured Form.</P>
<P> The typical Dialog widget contains three areas. The first line contains a description of the function of the Dialog widget, for example, the string 'Filename:'. The second line contains an area into which the user types input. The third line can contain buttons that let the user confirm or cancel the Dialog input. Any of these areas may be omitted by the application.</P>
<H2> Extra attributes for children of Dialog: </H2>

<P> Children of Dialog have the same extra attributes as children of Form. </P>
<A NAME=HEADING19-25></A>
<H1> Paned</H1>
<P> The Paned<A NAME=MARKER-2-198></A> widget manages children in a vertically or horizontally tiled fashion. The panes may be dynamically resized by the user by using the grips that appear near the right or bottom edge of the border between two panes.</P>
<P> The Paned widget may accept any widget pattern as a pane except Grip<A NAME=MARKER-2-199></A>. Grip widgets have a special meaning for the Paned widget, and adding a Grip as its own pane will confuse the Paned widget.</P>
<P> The grips allow the panes to be resized by the user. The semantics of how these panes resize is somewhat complicated, and warrants further explanation here. When the mouse pointer is positioned on a grip and pressed, an arrow is displayed that indicates the pane that is to be to be resized. While keeping the mouse button down, the user can move the grip up and down (or left and right). This, in turn, changes the size of the pane. The size of the Paned widget will not change. Instead, it chooses another pane (or panes) to resize.</P>
<H2> Extra attributes for children of Paned </H2>

<P> Each child of the Paned widget has a set of operations available to control the layout. These attributes allow the Paned widget's children to specify individual layout requirements.</P>
<P> Available attributes include the patterns allowResize<A NAME=MARKER-2-200></A>, maxSize<A NAME=MARKER-2-201></A>, minSize<A NAME=MARKER-2-202></A>, preferredPaneSize<A NAME=MARKER-2-203></A>, resizeToPreferred<A NAME=MARKER-2-204></A>, showGrip<A NAME=MARKER-2-205></A>, and skipAdjust<A NAME=MARKER-2-206></A>. See the <A HREF="interfaces/Athena/index.html">Interface Descriptions</A> for details.</P>
<P> The above mentioned patterns are actually attributes of the Core pattern. But they only function and should only be used for aggregation components of a Paned widget.</P>
<A NAME=HEADING19-34></A>
<H1> ViewPort</H1>
<P> The Viewport<A NAME=MARKER-2-207></A> widget consists of a frame window, one or two Scrollbars, and an inner window. The size of the frame window is determined by the viewing size of the data that is to be displayed and the dimensions to which the Viewport is created. The inner window is the full size of the data that is to be displayed and is clipped by the frame window. The Viewport widget controls the scrolling of the data directly. No application code are required for the scrolling.</P>
<P> When the geometry of the frame window is equal in size to the inner window, or when the data does not require scrolling, the ViewPort widget automatically removes any scrollbars. The forceBar option causes the Viewport widget to display all scrollbars permanently.</P>
<H2> Layout Semantics</H2>
<P> The Viewport widget manages a single child widget. When the size of the child is larger than the size of the Viewport, the user can interactively move the child within the Viewport by repositioning the scrollbars.</P>
<P> The default size of the Viewport before it is realized is the width and/or height of the child. After it is realized, the Viewport will allow its child to grow vertically or horizontally if allowVert<A NAME=MARKER-2-208></A> or allowHoriz<A NAME=MARKER-2-209></A> are set, respectively. If the corresponding vertical or horizontal scrollbar is not enabled, the Viewport will propagate the geometry request to its own parent and the child will be allowed to change size only if the Viewport's parent allows it. Regardless of whether or not scrollbars are enabled in the corresponding direction, if the child requests a new size smaller than the Viewport size, the change will be allowed only if the parent of the Viewport allows the Viewport to shrink to the appropriate dimension.</P>
<P> Although the Viewport is a subpattern of the Form<A NAME=MARKER-2-210></A>, none of the attributes for the children of Form mentioned on above must be supplied for any of the children of the Viewport. These attributes are managed internally, and are not meant for public consumption.</P>





