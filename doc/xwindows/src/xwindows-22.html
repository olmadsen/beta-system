<H1> Menus</H1>

<P> The Athena widget set provides support for single paned popup and pulldown menus. Menus<A NAME=MARKER-2-215></A> are implemented as a Menu container (the SimpleMenu<A NAME=MARKER-2-216></A> widget) and a collection of objects that will comprise the menu entries. The SimpleMenu widget is itself a direct subpattern of the OverrideShell<A NAME=MARKER-2-217></A> widget pattern, therefore no other shell is necessary when creating a menu. The children of a SimpleMenu must be subpatterns of the Sme<A NAME=MARKER-2-218></A> (Simple Menu Entry) object.</P>

<P> The Athena widget set provides four patterns of Sme objects that may be used to build menus.</P>

<UL>
<LI><CODE>Sme</CODE><A NAME=MARKER-2-219></A>. The base pattern of all menu entries. It may be used as a menu entry itself to provide a blank entry in a menu.

<P></P>
<LI><CODE>SmeBSB</CODE><A NAME=MARKER-2-220></A>. This menu entry provides a selectable entry containing a text string. Support is also provided that allows a bitmap to be placed in the left and right margins.

<P></P>
<LI><CODE>SmeLine</CODE><A NAME=MARKER-2-221></A>. This menu entry provides an unselectable entry containing a separator line.

<P></P>
<LI><CODE>SmeCascade</CODE><A NAME=MARKER-2-222></A>. This menu entry provides cascading menu entries.
</UL>
<P> </P>

<P> To allow easy creation of pulldown menus, a MenuButton<A NAME=MARKER-2-223></A> widget is also provided.</P>
<P> The default configuration for the menus is click-move-release, and it is this interface that will be described. The menus will typically be activated by clicking a pointer button while the pointer is over a MenuButton, causing the menu to appear in a fixed location relative to that button; this is a pulldown menu. Menus may also be activated when a specific pointer and key sequence is used anywhere in the application; this is a popup menu. In this case the menu will position itself under the cursor. Typically menus will be placed so the pointer cursor is on the first menu entry, or the last entry selected by the user.</P>
<P> The menu will remain on the screen as long as the pointer button is held down. Moving the pointer will highlight different menu items. If the pointer leaves the menu, or moves over an entry that cannot be selected then no menu entry will highlighted. When the desired menu entry has been highlighted, release the pointer button to remove the menu, and cause the callback associated with this entry to be invoked.</P>
<P> The following figure illustrates the inheritance hierarchy among the menu-related Athena widgets. Widgets from xtenv are shaded gray and other Athena widgets are dotted. Notice that Sme is a specialization of the abstract superclass RectObj<A NAME=MARKER-2-224></A> of Core. This means that Sme is not a widget, but what is called a &quot;gadget<A NAME=MARKER-2-225></A>&quot;, i.e. a &quot;windowless widget<A NAME=MARKER-2-226></A>&quot; that uses its parent window to draw in. For normal use this destinction is of no concern.</P>
<P> </P>
<center><IMG ALIGN=TOP SRC=images/awenv/awenvmenu-hierarchy.gif></center>
<P> </P>
<A NAME=HEADING22-18></A>
<H1> SimpleMenu</H1>
<P> The SimpleMenu<A NAME=MARKER-2-227></A> widget is a container for the menu entries. It is a direct subpattern of OverrideShell<A NAME=MARKER-2-228></A>. This is the only part of the menu that actually contains a window. The SimpleMenu serves as the glue to bind the individual menu entries together into a menu.</P>
<A NAME=HEADING22-20></A>
<H1> MenuButton</H1>
<P> The MenuButton<A NAME=MARKER-2-229></A> widget is an area, often rectangular, that contains a text label or bitmap image. When the pointer cursor is on the button, the button becomes highlighted by drawing a rectangle around its perimeter. This highlighting indicates that the button is ready for selection. When a pointer button is pressed, the MenuButton widget will pop up a menu.</P>
<A NAME=HEADING22-22></A>
<H1> Sme </H1>

<P> The Sme<A NAME=MARKER-2-230></A> (simple menu entry) object is the base pattern for all menu entries. While this object is mainly intended to be specialized, it may be used in a menu to add blank space between menu entries. The name Blank<A NAME=MARKER-2-231></A> may be used as an alias for an Sme without specialization.</P>
<A NAME=HEADING22-25></A>
<H1> SmeBSB</H1>

<P> The SmeBSB<A NAME=MARKER-2-232></A> (simple menu entry composed of a bitmap, a string and a bitmap) object is used to create a menu entry that contains a string, and optional bitmaps in its left and right margins. Since each menu entry is an independent object, the application is able to change the font, colour, height, and other attributes of the menu entries, on an entry by entry basis. The name Item<A NAME=MARKER-2-233></A> may be used as an alias for an SmeBSB without specialization.</P>
<A NAME=HEADING22-28></A>
<H1> SmeLine</H1>

<P> The SmeLine<A NAME=MARKER-2-234></A> object is used to add a horizontal line or menu separator to a menu. Since each menu entry is an independent object, the application is able to change the colour, height, and other attributes of the menu entries, on an entry by entry basis. This entry is not selectable, and will not highlight when the pointer cursor is over it. The name Line<A NAME=MARKER-2-235></A> may be used as an alias for an SmeLine without specialization.</P>
<A NAME=HEADING22-31></A>
<H1> SmeCascade</H1>

<P> The SmeCascade<A NAME=MARKER-2-236></A> object is used to add a cascading submenu to another menu. When the user points inside this item, the submenu is popped of to the right of the item. The user can then select among the items of the cascaded menu. The name Cascade may be used as an alias for an SmeCascade without specialization.</P>
<P> Since each menu entry is an independent object, the application is able to change the colour, height, and other attributes of the menu entries, on an entry by entry basis. </P>





