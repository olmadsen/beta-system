<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Basic XtEnv widget patterns</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING10></A>


<P><A HREF=xwindows-11.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-9.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-8.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P> XtEnv</P>


<A NAME=HEADING10-0></A>
<H1> Basic XtEnv widget patterns</H1>
<A NAME=HEADING10-1></A>
<H1> Core</H1>
<P> The core<A NAME=MARKER-2-49></A> widget pattern is the most fundamental widget pattern, and serves as the superpattern for all other widget patterns. The core pattern defines characteristics common to all widgets, such as geometry<A NAME=MARKER-2-50></A>, name<A NAME=MARKER-2-51></A>, parent<A NAME=MARKER-2-52></A>, sensitiveness<A NAME=MARKER-2-53></A>, color<A NAME=MARKER-2-54></A>, callback handling<A NAME=MARKER-2-55></A>, translations<A NAME=MARKER-2-56></A> and accelerators<A NAME=MARKER-2-57></A>. It also defines various converters used to specify some of the other characteristics, e.g. it defines textToFont<A NAME=MARKER-2-58></A>, used to specify font resources.</P>

<P> Core also defines an initialization method<A NAME=MARKER-2-59></A> called init for the widget. This method must be called before anything can be done with the widget. It calls INNER such that specializations can add to the initialization behaviour.</P>
<P> init has an optional enter-part. The enter-part consists of two parameters: the father-widget<A NAME=MARKER-2-60></A> and the name<A NAME=MARKER-2-61></A> of the widget.</P>

<P> The father-widget is the widget, that shall contain this widget as a child. If the enter-part is not specified, the father-widget will be the enclosing widget of this widget according to BETA's scope-rules, see below<A NAME=MARKER-2-62></A>. If this widget is not defined within the scope of the intended father-widget, the father-widget has to be specified in the enter-part.</P>

<P> The name<A NAME=MARKER-2-63></A> of the widget is very important for the internal working of Xt as it is through this name, widgets are accessed. But the name is seldom important for the BETA-programmer. For some widgets the name is used as the default value for some of the widgets attributes. E.g. the name of a menu-item is used as the default value for the item-text presented to user when showing the menu. The name is also used if the programmer wants to change the default-values for some of attributes of some of the widgets used in the application. This can be done via a resourcefile (see <A HREF=bibliography.html#oreilly90a>[Nye &amp; O'Reilly 90a]</A>, chapter 9). If the enter-part is not specified, the name will be the BETA-name of the descriptor for the widget.</P>
<P> Below some elaboration on the default father<A NAME="MARKER-2-64"></A><A NAME="MARKER-2-65"></A> and default name<A NAME="MARKER-2-67"></A><A NAME="MARKER-2-68"></A> of a widget is presented.</P>

<P> Consider the following program: </P>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/awenv';
--- program: descriptor ---
AwEnv
(# faculty: label
     (# init:: (# do 2-&gt; borderwidth #) #);
   University: @box
     (# Physics, Mathematics: @faculty; 
        init:: (# do Physics.init; Mathematics.init #);
     #)
do University.init;
#)
</PRE>
<P> The idea was that a window with two labels named Physics and Mathematics should appear. But executing it will give the error message </P>
<PRE CLASS=beta>
Xt Error: There must be only one non-shell widget which is son
of Toplevel. The widget causing the conflict is named faculty. 
</PRE>
<P> This is because the program uses the init pattern of the widgets without specifying the father and name of the widgets. To be precise, this is what happens: When the init pattern of a widget is invoked, it first checked to see if the father is NONE. This will be the case if no father is specified in the enter part of init. </P>

<P> If so, a search is started in the static environment of the widget pattern. If a specialization of a Core widget is found, this widget is used as the father. This search is continued until a pattern with no enclosing pattern is found. In this case the widget named TopLevel<A NAME=MARKER-2-66></A> (in xtenv) is used as the father. The widget TopLevel is an instance of the pattern TopLevelShell, which among its characteristics has the constraint that it wants to have exactly one non-shell child. </P>
<P> Now consider the example program: The first thing that happens is that the init attribute of University is invoked. Since no father is specified, a search for one is started from the University pattern. This search finds the pattern AwEnv(#...#), which is not a Core, and which has no enclosing pattern. Thus University will get the father widget TopLevel. </P>
<P> The final binding of University.init then invokes Physics.init. Physics is an instance of the pattern faculty, which is declared in the same scope as University. Thus the search for a father for Physics is identical to the search for the father of University, and Physics also gets TopLevel as its father. This is when the error occurs. The reason why the name reported in the error message is faculty is explained below. </P>
<P> Notice that it did not matter that the instantiation of the Physics object is done within University: the default father is searched for starting from the pattern declaration of the object. </P>
<P> In general there are three possible solutions to the problem in the example: </P>
<OL>
<LI>Supply the father and name when initializing the faculty widgets: 
<PRE CLASS=beta>
do (&quot;Physics&quot;, University)-&gt;Physics.init;
   (&quot;Mathematics&quot;, University)-&gt;Mathematics.init;
</PRE>
In this case, no search for a default father is needed for the faculty widgets. 
<LI>Make (possibly empty) specializations of faculty inside University: 
<PRE CLASS=beta>
Physics: @faculty(##);
Mathematics: @faculty(##);
</PRE>
Now the search for a default father of Physics will start at the pattern faculty(##) inside University, so the University pattern will be the first found in this search, and hence the University widget will become the father of the Physics widget. Likewise for Mathematics. 
<LI>Move the declaration of the faculty pattern inside the University pattern. This will give the same search path as in solution 2. (Conceptually, this might also be the best place to declare faculty in the first place.) 
</OL>
<P> The above example was a simple one. In more complicated cases, the reason for an error of this kind can be trickier to spot. If your program uses the fragment system to move declarations of useful widgets into a library, this kind of error is likely to occur. </P>
<P> Remember that if an instance of an unspecialized widget is used, the widget pattern being declared in, say, the XtEnvLib attributes slot of xtenv, then the search for a default father is started at the XtEnv pattern, and therefore no father widget is found. In this case the widget will get TopLevel as father. Solutions 1 or 2 above will be appropriate in these cases. </P>

<P> The default name used for widgets sometimes also needs special attention: The following BETA program creates a window containing &quot;Label&quot; </P>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/awenv'
--- program: descriptor --- 
AwEnv
(# Hello: @Label;
do Hello.init; 
#)       
</PRE>
<P> whereas the following program creates a window containing &quot;Hello&quot; </P>
<PRE CLASS=beta>
ORIGIN '~beta/Xt/awenv'
--- program: descriptor --- 
AwEnv
(# Hello: @Label(##);
do Hello.init; 
#)       
</PRE>
<P> Here is the reason why: The connection between the names used for widgets in BETA and the external names used in the external widgets interfaced to from BETA is that the pattern name of the BETA widget is used for the external widget name by default. </P>
<P> In the first example, the Hello widget is an instance of the pattern Label, and in the second example the widget is the only possible instance of the singular pattern Label(##), which is named Hello. </P>
<P> The appearance of the windows in this case comes from the fact that the Athena Label widget uses the external name of the widget as default label-string, if it is not specified otherwise. </P>
<P> A variant of this problem is the case where you specify a list of widgets using the same pattern: </P>
<PRE CLASS=beta>
hello1, hello2: @Label(##);
</PRE>
<P> In this case the default name will always be the first name in the list, hello1. To avoid this behavior, use the scheme </P>
<PRE CLASS=beta>
hello1: @Label(##);
hello2: @Label(##);
</PRE>
<P> or specify the name explicitly instead.</P>

<P> Every widget contains an instance of the pattern eventHandler<A NAME=MARKER-2-69></A>, which allows the application program to do something when a particular event occurs. It is a low-level facility which is seldom needed as most widget patterns uses callbacks to notify the application-program when something interesting happens. eventhandler has local patterns keypress<A NAME=MARKER-2-70></A>, keyrelease<A NAME=MARKER-2-71></A>, buttonpress<A NAME=MARKER-2-72></A>, ... , exposure<A NAME=MARKER-2-73></A>, ... that can be used. If an instance of one of these patterns is enabled, it will be invoked, when the corresponding X-event<A NAME=MARKER-2-74></A> occurs. The eventhandler has a local attribute called event<A NAME=MARKER-2-75></A>, which is an instance of a virtual pattern, qualified with XAnyEvent<A NAME=MARKER-2-76></A> (defined in <A HREF="interface/X11/events.html">events.bet</A>). XAnyEvent is an abstract super-pattern for all X Events:</P>
<PRE CLASS=beta>
XAnyEvent: ExternalRecord (* Unspecified event *)
  (# type: @
       (* Type of THIS(XAnyEvent) *)
       long(# pos::&lt; (# do 0-&gt;value #)#);
     serial: @
       (* number of last request processed by server *)
       long(# pos::&lt; (# do 4-&gt;value #)#);
     send_event: @
       (* true if this came from a SendEvent request *)
       long(# pos::&lt; (# do 8-&gt;value #)#);
     display: @
       (* Display the event was read from *)
       long(# pos::&lt; (# do 12-&gt;value #)#);
     window: @
       (* window on which event was requested in event mask *)
       long(# pos::&lt; (# do 16-&gt;value #)#);
     
     init: 
       (* Used to allocate an XAnyEvent from within BETA *)
       (# do ... #);
     
     &lt;&lt;SLOT XAnyEventLib: attributes&gt;&gt;
  enter ptr
  exit ptr
  #);
</PRE>
<P> The different X events are then modelled as sub-patterns of XAnyEvent, e.g.</P>
<PRE CLASS=beta>
XButtonEvent<A NAME=MARKER-2-77></A>: XAnyEvent
  (# root: @
       (* root window that the event occured on *)
       long(# pos::&lt;(# do 20-&gt;value#)#);
     subwindow: @
       (* child window *)
       long(# pos::&lt;(# do 24-&gt;value#)#);
     time: @
       (* milliseconds *)
       long(# pos::&lt;(# do 28-&gt;value#)#);
     x: @
       (* pointer x coordinate in event window *)
       long(# pos::&lt;(# do 32-&gt;value#)#);
     y: @
       (* pointer y coordinate in event window *)
       long(# pos::&lt;(# do 36-&gt;value#)#);
     x_root: @
       (* x coordinate relative to root *)
       long(# pos::&lt;(# do 40-&gt;value#)#);
     y_root: @
       (* y coordinate relative to root *)
       long(# pos::&lt;(# do 44-&gt;value#)#);
     state: @
       (* key or button mask *)
       long(# pos::&lt;(# do 48-&gt;value#)#);
     button: @
       (* detail *)
       long(# pos::&lt;(# do 52-&gt;value#)#);
     same_screen: @
       (* same screen flag *)
       long(# pos::&lt;(# do 56-&gt;value#)#);
            
     shiftModified: 
       (# exit { true iff SHIFT was held down } #);
     controlModified: 
       (# exit { true iff CONTROL was held down } #);
     ...

     &lt;&lt;SLOT XButtonEventLib: attributes&gt;&gt;
  #);
</PRE>
<P> Notice that some event types have some local utility patterns, in XButtonEvent<A NAME=MARKER-2-78></A>, e.g., shiftModified<A NAME=MARKER-2-79></A>, which is used to determine if the SHIFT modifier key<A NAME=MARKER-2-80></A> was held down when the button-event occurred.</P>
<P> See the example-programs <A HREF=xwindows-12.html#draw.bet>draw.bet</A> and <A HREF=xwindows-12.html#drawWithRefresh.bet>drawWithRefresh.bet</A> later in this report for examples of using the eventhandler, and some of the attributes of X Events.</P>
<A NAME=HEADING10-158></A>
<H1> Composite</H1>
<P> Composite<A NAME=MARKER-2-81></A> widgets are intended to be containers<A NAME=MARKER-2-82></A> for other widgets. They have the ability to manage child widgets and they are responsible for handling the geometry for them.</P>
<P> The Composite widget pattern is an abstract superpattern. It is never instantiated directly in an application, only subpatterns are instantiated.</P>
<A NAME=HEADING10-161></A>
<H1> Constraint</H1>
<P> The Constraint<A NAME=MARKER-2-83></A> widget pattern is a subpattern of the composite pattern, and does thus also manage the layout of children. Constraint widgets let the application provide layout information for each child. This information often takes the form of some constraints on the child's position and/or size. This is a more powerful way to arrange children because it allows you to provide different rules for how each child will be laid out.</P>
<P> The constraint widget is also an abstract superpattern.</P>
<A NAME=HEADING10-164></A>
<H1> Shell</H1>
<P> Widgets negotiate their size and positions with their parent widget (i.e. the widget that directly contain them). Widgets at the top of the hierarchy do not have any parent widget. Instead they must deal with the outside world. To provide for this, each top-level widget is encapsulated in a special widget, called a Shell<A NAME=MARKER-2-84></A> widget.</P>
<P> The Shell widget pattern is a subpattern of the composite widget pattern, but can have only one child. Shell widgets are special purpose widgets that provide an interface between other widgets and the window manager<A NAME=MARKER-2-85></A>. A shell widget negotiates the geometry of the widget with the window manager, and sets the properties required by the window manager. </P>
<P> The Shell widget pattern is also an abstract superpattern.</P>
<A NAME=HEADING10-168></A>
<H1> WMShell</H1>
<P> The WMShell<A NAME=MARKER-2-86></A> is an abstract super pattern that contains attributes needed by the common window manager<A NAME=MARKER-2-87></A> protocol, e.g. attibutes used to specify icon<A NAME=MARKER-2-88></A>s, preferred size<A NAME=MARKER-2-89></A> and aspect ratio<A NAME=MARKER-2-90></A> etc.</P>
<A NAME=HEADING10-170></A>
<H1> ToplevelShell</H1>

<P> ToplevelShell widgets are used for normal top-level windows. xtenv creates the main toplevel widget<A NAME="MARKER-2-91"></A> topLevel<A NAME=MARKER-2-92></A> of the applications. Some applications have multiple permanent top-level windows, and should use ToplevelShell to accomplish this.</P>
<A NAME=HEADING10-173></A>
<H1> TransientShell</H1>
<P> A TransientShell<A NAME=MARKER-2-93></A> is similar to a toplevel shell except for the way it interacts with the window manager with respect to iconifying. If an applications toplevel window (transientFor<A NAME=MARKER-2-94></A>) is iconified, the window manager normally iconifies all transient shells created by the application.</P>
<A NAME=HEADING10-175></A>
<H1> OverrideShell</H1>
<P> An OverrideShell<A NAME=MARKER-2-95></A> instructs the window manager<A NAME=MARKER-2-96></A> to completely ignore it. OverrideShell's completely bypass the window manager and therefore have no added window manager decorations. They are typically used for popup-menus.</P>
<A NAME=HEADING10-177></A>
<H1> VendorShell</H1>
<P> The VendorShell<A NAME=MARKER-2-97></A> is an abstract super class with implementation dependent resources defined by the different widget sets using it.</P>




<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>X Libraries - Reference Manual</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=xwindows-11.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=xwindows-9.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=xwindows-8.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>



</BODY>
</HTML>
