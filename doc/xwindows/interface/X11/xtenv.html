<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Xtenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="events.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Xtenv Interface</H1>
<PRE CLASS=interface>
ORIGIN 'xtlib';
BODY 'private/xtenvbody'; 
BODY 'private/errorhandlerbody';

(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-97 
 *       All rights reserved.
 *)

--- LIB: attributes --- 

<B>XtEnv</B><A name="XtEnv.1(1)"></A>: XtLib
  (* XtEnv is the BETA interface to the X Toolkit Intrinsics(Xt). Xt
   * contains the basic classes common for many user-interface
   * toolkits build on top of X windows, but does not contain any
   * higher level user interface elements.  It is typically used
   * together with a widget set containing such user interface
   * elements build on top of the Intrinsics.
   *)
  (# &lt;&lt;SLOT xtenvLib: attributes&gt;&gt;;

     <B>topLevel</B><A name="XtEnv.1:topLevel.2(2)"></A><A name="topLevel.2(2)"></A>: @ToplevelShell;
     (* The default top level shell created and initialized at
      * startup of THIS(XtEnv)
      *)
     <B>fallbackResources</B><A name="XtEnv.1:fallbackResources.2(3)"></A><A name="fallbackResources.2(3)"></A>:&lt; 
       (* Specification of resources being set at startup of
        * THIS(XtEnv).  In init, resources may be specified like
        * '*button.label: Push Me' -&gt; addText; i.e. very much the same
        * way as resources are specified in your .Xdefaults file.
        *) 
       StringArray(##);
     <B>options</B><A name="XtEnv.1:options.2(4)"></A><A name="options.2(4)"></A>:&lt; XrmOptionDescRecList
       (* Furtherbinding of this virtual lets the resource manager of
        * Xt set values for additional resources from the command
        * line.  
        * Example: 
        *  init::&lt; 
        *    (# 
        *    do ('-bp', '*borderPixmap', XrmoptionsSepArg, '')-&gt;add
        *    #)
        * will allow the "borderPixmap" resource to be specified by 
        * the "-bp" option.
        *)
       (# <B>init</B><A name="XtEnv.1:options.2:init.3(5)"></A><A name="init.3(5)"></A>:&lt; object #);
     <B>appName</B><A name="XtEnv.1:appName.2(6)"></A><A name="appName.2(6)"></A>:&lt;
       (* The name of the application executing THIS(XtEnv). If not
        * set by a further binding of this virtual, the first command
        * line argument - i.e. the program name - is used (leading
        * path component is stripped)
        *)
       (# <B>value</B><A name="XtEnv.1:appName.2:value.3(7)"></A><A name="value.3(7)"></A>: ^text;
       do INNER; ...;
       exit value[]
       #);
     <B>appClass</B><A name="XtEnv.1:appClass.2(8)"></A><A name="appClass.2(8)"></A>:&lt;
       (* The class name of the application executing THIS(XtEnv). If
        * not set by a further binding of this virtual, the first
        * command line argument - i.e. the program name - is used
        * (leading path component is stripped, and the first letter is
        * capitalized. If the first letter is 'x', the second letter
        * is capitalized too.
        *)
       (# <B>value</B><A name="XtEnv.1:appClass.2:value.3(9)"></A><A name="value.3(9)"></A>: ^text;
       do INNER; ...;
       exit value[]
       #);
     <B>appContext</B><A name="XtEnv.1:appContext.2(10)"></A><A name="appContext.2(10)"></A>: (* The "Application Context" of THIS(XtEnv) *)
       (# <B>value</B><A name="XtEnv.1:appContext.2:value.3(11)"></A><A name="value.3(11)"></A>: @XtAppContext;
       ...
       exit value
       #);
     
     (* X Toolkit Exceptions *)
     <B>XtException</B><A name="XtEnv.1:XtException.2(12)"></A><A name="XtException.2(12)"></A>: Exception
       (# do ...; INNER #);
     <B>XtObjectInstantiation</B><A name="XtEnv.1:XtObjectInstantiation.2(13)"></A><A name="XtObjectInstantiation.2(13)"></A>:&lt; XtException
       (* Raised on attempt to instantiate an XtObject *)
       (# do ...; INNER #);
     <B>RectObjectInstantiation</B><A name="XtEnv.1:RectObjectInstantiation.2(14)"></A><A name="RectObjectInstantiation.2(14)"></A>:&lt; XtException
       (* Raised on attempt to instantiate a RectObject *)
       (# do ...; INNER #);
     <B>FatherNotCore</B><A name="XtEnv.1:FatherNotCore.2(15)"></A><A name="FatherNotCore.2(15)"></A>:&lt; XtException
       (* Raised from XtObject.init, if the father specified is not a
        * Core or specialization thereof.
        *)
       (# <B>name</B><A name="XtEnv.1:FatherNotCore.2:name.3(16)"></A><A name="name.3(16)"></A>: ^text
       enter name[]
       do ...; INNER
       #);
     <B>MultipleToplevelChildren</B><A name="XtEnv.1:MultipleToplevelChildren.2(17)"></A><A name="MultipleToplevelChildren.2(17)"></A>:&lt; XtException
       (* Raised if more than one non-shell widget has specified
        * TopLevel as father.
        *)
       (# <B>name</B><A name="XtEnv.1:MultipleToplevelChildren.2:name.3(18)"></A><A name="name.3(18)"></A>: ^text
       enter name[]
       do ...; INNER
       #);
     <B>NoToplevelSon</B><A name="XtEnv.1:NoToplevelSon.2(19)"></A><A name="NoToplevelSon.2(19)"></A>:&lt; XtException
       (* Raised if no non-shell widget uses Toplevel as father *)
       (# do ...; INNER #);
     <B>ResourceSetError</B><A name="XtEnv.1:ResourceSetError.2(20)"></A><A name="ResourceSetError.2(20)"></A>:&lt; XtException
       (* Raised on attempt to set a resource for an uninitialized
        * widget
        *)
       (# do ...; INNER #);
     
     <B>ErrorHandler</B><A name="XtEnv.1:ErrorHandler.2(21)"></A><A name="ErrorHandler.2(21)"></A>: 
       (* Errors arising from the X Toolkit itself can be caught by
        * instatiating and installing an instance of ErrorHandler
        * before any widget is initialized.
        *)
       (# <B>xterror</B><A name="XtEnv.1:ErrorHandler.2:xterror.3(22)"></A><A name="xterror.3(22)"></A>:&lt; XtException
            (# message: ^text;
            enter message[]
            do '\nX Toolkit Error: ' -&gt; msg.puttext;
               message[] -&gt; msg.putline;
               INNER;
            #);
          <B>xliberror</B><A name="XtEnv.1:ErrorHandler.2:xliberror.3(23)"></A><A name="xliberror.3(23)"></A>:&lt; Exception
            (# message: ^text;
            enter message[]
            do 'Xlib Error: ' -&gt; msg.puttext;
               message[] -&gt; msg.putline;
               INNER;
            #);
          <B>install</B><A name="XtEnv.1:ErrorHandler.2:install.3(24)"></A><A name="install.3(24)"></A>: ...
       #);

     <B>WarningHandler</B><A name="XtEnv.1:WarningHandler.2(25)"></A><A name="WarningHandler.2(25)"></A>: 
       (* Warnings arising from the X Toolkit itself can be caught by
        * instatiating and installing an instance of WarningHandler
        * before any widget is initialized.
        *)
       (# <B>xtwarning</B><A name="XtEnv.1:WarningHandler.2:xtwarning.3(26)"></A><A name="xtwarning.3(26)"></A>:&lt; XtException
            (# message: ^text;
            enter message[]
            do '\nX Toolkit Warning: ' -&gt; msg.puttext;
               message[] -&gt; msg.putline;
               INNER;
            #);
          <B>install</B><A name="XtEnv.1:WarningHandler.2:install.3(27)"></A><A name="install.3(27)"></A>: ...
       #);

     <B>XtObject</B><A name="XtEnv.1:XtObject.2(28)"></A><A name="XtObject.2(28)"></A>:
       (* Models widgets and gadgets, and defines callback handling.
        * Widgets are specializations of Core whereas gadges only
        * inherit from the XtObject specialization RectObj.  XtObject
        * is an ABSTRACT class, do not try to instantiate directly
        * from it.
        *)
       (# &lt;&lt;SLOT XtObjectLib: attributes&gt;&gt;;
          
          <B>thewidget</B><A name="XtEnv.1:XtObject.2:thewidget.3(29)"></A><A name="thewidget.3(29)"></A>: @widget;
          
          <B>callbacks</B><A name="XtEnv.1:XtObject.2:callbacks.3(30)"></A><A name="callbacks.3(30)"></A>: @...;
          
          <B>parent</B><A name="XtEnv.1:XtObject.2:parent.3(31)"></A><A name="parent.3(31)"></A>: IntegerValue
            (* Returns the parent of THIS(XtObject) *)
            (# do thewidget -&gt; XtParent -&gt; value #);
          <B>name</B><A name="XtEnv.1:XtObject.2:name.3(32)"></A><A name="name.3(32)"></A>: 
            (* Returns the name of THIS(XtObject) *)
            (# n: ^text;
            ...
            exit n[]
            #);
          
          <B>init</B><A name="XtEnv.1:XtObject.2:init.3(33)"></A><A name="init.3(33)"></A>:&lt;
            (* Initialization method for THIS(XtObject). This method
             * must be called before anything can be done with
             * THIS(XtObject). It calls INNER such that
             * specializations can add to the initialization
             * behaviour.
             * 
             * init has an enter-part, but when calling init, it is
             * optional to specify the enter-part. The enter-part
             * consists of two parameters: the father-widget and the
             * name of THIS(XtObject).
             * 
             * The father-widget is the widget, that shall contain
             * this widget as a child. If the enter-part is not
             * specified, the father-widget will be the enclosing
             * widget of this widget according to BETAs scope-rules,
             * i.e. the Core, which statically encloses the pattern,
             * THIS(XtObject) is an instance of.  If no such enclosing
             * widget is found, topLevel is used.  If THIS(XtObject)
             * wants to have a father-widget, that it is not defined
             * within the scope of, the father-widget has to be
             * specified in the enter-part.
             * 
             * The name of the XtObject is very important for the
             * internal working of Xt as it is through this name,
             * XtObjects are accessed.  But the name is seldom
             * important for the BETA-programmer.  For some widgets
             * the name is used as the default value for some of the
             * widgets attributes.  E.g. the name of a menu-item is
             * used as the default value for the item-text presented
             * to user when showing the menu. The name is also used if
             * the programmer wants to change the default-values for
             * some of attributes of some of the widgets used in the
             * application. This can be done via a resourcefile. If
             * the enter-part is not specified, the name will be the
             * BETA-name of the descriptor for THIS(XtObject).
             *)
            (# <B>name</B><A name="XtEnv.1:XtObject.2:init.3:name.4(34)"></A><A name="name.4(34)"></A>: ^text;
               <B>fatherWidget</B><A name="XtEnv.1:XtObject.2:init.3:fatherWidget.4(35)"></A><A name="fatherWidget.4(35)"></A>: @widget;
               
               <B>widgetClass</B><A name="XtEnv.1:XtObject.2:init.3:widgetClass.4(36)"></A><A name="widgetClass.4(36)"></A>:&lt; IntegerObject
                 (# 
                 do INNER; ...;
                 #);
               <B>getFatherWidget</B><A name="XtEnv.1:XtObject.2:init.3:getFatherWidget.4(37)"></A><A name="getFatherWidget.4(37)"></A>:&lt; IntegerObject;
               (* Virtual pattern that can be used to specify a
                * father for THIS(XtObject). If no father-widget is
                * specified in the enter part, getFatherWidget is
                * tried first, and only if this exits 0, the
                * statically enclosing widget is used.
                *)
               <B>doNotManageChild</B><A name="XtEnv.1:XtObject.2:init.3:doNotManageChild.4(38)"></A><A name="doNotManageChild.4(38)"></A>: @boolean;
               (* If this boolean is set to true, THIS(XtObject) is
                * not managed after INNER
                *)
            enter (name[],fatherWidget)
            do ...;
               INNER; ...;
            #);
          (* BETA interface to Xt resources *)
          <B>RoIntegerResource</B><A name="XtEnv.1:XtObject.2:RoIntegerResource.3(39)"></A><A name="RoIntegerResource.3(39)"></A>:
            (* Read Only *)
            (# get:
                 (# value: @integer 
                 ...
                 exit value
                 #);
               resourceName:&lt; IntegerObject;
            exit get
            #);
          <B>IntegerResource</B><A name="XtEnv.1:XtObject.2:IntegerResource.3(40)"></A><A name="IntegerResource.3(40)"></A>: RoIntegerResource
            (# set: 
                 (# value: @integer 
                 enter value 
                 ...
                 #);
            enter set
            #);
          <B>RoShortResource</B><A name="XtEnv.1:XtObject.2:RoShortResource.3(41)"></A><A name="RoShortResource.3(41)"></A>:
            (# get:
                 (# value: @int16 
                   ...
                 exit value
                 #);
               resourceName:&lt; IntegerObject;
            exit get
            #);
          <B>ShortResource</B><A name="XtEnv.1:XtObject.2:ShortResource.3(42)"></A><A name="ShortResource.3(42)"></A>: RoShortResource
            (# set: 
                 (# value: @int16 
                 enter value 
                 ...
                 #);
            enter set
            #);
          <B>RoCharResource</B><A name="XtEnv.1:XtObject.2:RoCharResource.3(43)"></A><A name="RoCharResource.3(43)"></A>: 
            (* Read Only *)
            (# get:
                 (# value: @char;
                 ...
                 exit value
                 #);
               resourceName:&lt; IntegerObject;
            exit get
            #);
          <B>CharResource</B><A name="XtEnv.1:XtObject.2:CharResource.3(44)"></A><A name="CharResource.3(44)"></A>: RoCharResource
            (# set: 
                 (# value: @char 
                 enter value 
                 ...
                 #);
            enter set
            #);
          <B>RoBooleanResource</B><A name="XtEnv.1:XtObject.2:RoBooleanResource.3(45)"></A><A name="RoBooleanResource.3(45)"></A>:
            (* Read Only *)
            (# get:
                 (# value: @boolean;
                 ...
                 exit value
                 #);
               resourceName:&lt; IntegerObject;
            exit get
            #);
          <B>BooleanResource</B><A name="XtEnv.1:XtObject.2:BooleanResource.3(46)"></A><A name="BooleanResource.3(46)"></A>: RoBooleanResource
            (# set: 
                 (# value: @boolean 
                 enter value 
                 ...
                 #);
            enter set
            #);
          <B>StringResource</B><A name="XtEnv.1:XtObject.2:StringResource.3(47)"></A><A name="StringResource.3(47)"></A>:
            (# set: 
                 (# t: ^text
                 enter t[]
                 ...
                 #);
               get:
                 (# t: ^text;
                 ...
                 exit t[]
                 #);
               resourceName:&lt; IntegerObject;
               strprivate: @...;
            enter set
            exit get
            #);
          <B>StringArrayResource</B><A name="XtEnv.1:XtObject.2:StringArrayResource.3(48)"></A><A name="StringArrayResource.3(48)"></A>:
            (# set: 
                 (# theString: ^StringArray;
                 enter theString[]
                 ...
                 #);
               get:
                 (# theString: ^StringArray;
                 ...
                 exit theString[]
                 #);
               resourceName:&lt; IntegerObject;
            enter set
            exit get
            #);
          
          <B>destroy</B><A name="XtEnv.1:XtObject.2:destroy.3(49)"></A><A name="destroy.3(49)"></A>:&lt; 
            (* Removes THIS(XtObject) completely. Nothing can be done
             * with it afterwards, and no attributes can be accessed.
             *)
            (# do INNER; ... #);
          <B>destroyCallback</B><A name="XtEnv.1:XtObject.2:destroyCallback.3(50)"></A><A name="destroyCallback.3(50)"></A>:&lt; callbackProc
            (* Virtual pattern corresponding to the Xt
             * "destroyCallbacks" resource. This virtual pattern will
             * be called when the widget is destroyed.
             *)          
            (# do INNER; ...; #);
          <B>callback</B><A name="XtEnv.1:XtObject.2:callback.3(51)"></A><A name="callback.3(51)"></A>:&lt; callbackProc;
          (* Virtual pattern corresponding to the "callback" Xt
           * resource of some widgets. This is a hook provided by many
           * widgets to allow applications to add functionality when
           * some widget-specific condition occur. E.g. a menu-item
           * widget will call this vir- tual method when the item has
           * been selected by the user.
           *)
          
          (* Private *)
          <B>installCallbacks</B><A name="XtEnv.1:XtObject.2:installCallbacks.3(52)"></A><A name="installCallbacks.3(52)"></A>:&lt;
            (* Install various callbacks *)
            (# do ...; INNER #);

       exit theWidget
       #) (* XtObject *);
     
     <B>RectObj</B><A name="XtEnv.1:RectObj.2(53)"></A><A name="RectObj.2(53)"></A>: XtObject
       (* Models widgets and gadgets, and defines geometry resources
        * and sensitivity.  RectObj is an ABSTRACT class, do not try
        * to instantiate directly from it.
        *)
       (# &lt;&lt;SLOT RectObjLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:RectObj.2:init.3(54)"></A><A name="init.3(54)"></A>::&lt;
            (# widgetClass::&lt; (# do INNER; ... #);
            do INNER;
            #);
          
          <B>x</B><A name="XtEnv.1:RectObj.2:x.3(55)"></A><A name="x.3(55)"></A>: 
            (* The x position of the top-left corner of this widget
             * in the father-widget. Normally it has no effect to set
             * this resource, except for Shell widgets in cooperation
             * with certain window managers.
             *)
            ShortResource(# resourceName::&lt; XtNx #);
          <B>y</B><A name="XtEnv.1:RectObj.2:y.3(56)"></A><A name="y.3(56)"></A>: 
            (* The y position of the top-left corner of this widget
             * in the father-widget. Normally it has no effect to set
             * this resource, except for Shell widgets in cooperation
             * with certain window managers.
             *)
            ShortResource(# resourceName::&lt; XtNy #);
          <B>width</B><A name="XtEnv.1:RectObj.2:width.3(57)"></A><A name="width.3(57)"></A>:
            (* The width of this widget. *)
            ShortResource(# resourceName::&lt; XtNwidth #);
          <B>height</B><A name="XtEnv.1:RectObj.2:height.3(58)"></A><A name="height.3(58)"></A>: 
            (* The height of this widget. *)
            ShortResource(# resourceName::&lt; XtNheight #);
          <B>borderwidth</B><A name="XtEnv.1:RectObj.2:borderwidth.3(59)"></A><A name="borderwidth.3(59)"></A>: 
            (* The width of the border of this widget. *)
            ShortResource(# resourceName::&lt; XtNborderwidth #);
          <B>ancestorSensitive</B><A name="XtEnv.1:RectObj.2:ancestorSensitive.3(60)"></A><A name="ancestorSensitive.3(60)"></A>: 
            (* The sensitivity state of the ancestors of
             * THIS(RectObj). A RectObj is insensitive if ether it or
             * any of its ancestors is insensitive. This attribute
             * cannot be changed, although it may be queried.
             *)
            RoBooleanResource(# resourceName::&lt; XtNancestorSensitive #);
          <B>sensitive</B><A name="XtEnv.1:RectObj.2:sensitive.3(61)"></A><A name="sensitive.3(61)"></A>: 
            (* A boolean which controls whether this(RectObj)
             * responds to user input. Input events will not be given
             * if either ancestorSensitive or sensitive is False.
             *)
            BooleanResource(# resourceName::&lt; XtNSensitive #);
          
          <B>translateCoords</B><A name="XtEnv.1:RectObj.2:translateCoords.3(62)"></A><A name="translateCoords.3(62)"></A>:
            (* Coordinates are typically given in the local
             * coordinate-system of the window. This pattern
             * translates local coordinates to global coordinates.
             *)
            (# x,y: @integer;
               x2,y2: @shortRef
            enter (x,y)
            do (thewidget,x,y,x2[],y2[]) -&gt; xtTranslateCoords;
            exit (x2,y2)
            #);
       #); (* RectObj *)
     
     <B>Core</B><A name="XtEnv.1:Core.2(63)"></A><A name="Core.2(63)"></A>: RectObj
       (* The Core widget class is the most fundamental widget class,
        * and serves as the superclass for all other widget
        * classes. The Core widget class is an abstract super
        * pattern. It is not designed to be used directly in
        * applications. The Core class defines characteristics common
        * to all widgets, in addition to the attributes inherited from
        * XtObject and RectObj.
        *)
       (# &lt;&lt;SLOT coreLib: attributes&gt;&gt;;

          <B>init</B><A name="XtEnv.1:Core.2:init.3(64)"></A><A name="init.3(64)"></A>::&lt;
            (* Initialization method for THIS(Core). This method must
             * be called before anything can be done with
             * THIS(Core). It calls INNER such that specializations
             * can add to the initialization behaviour.  See the
             * explanation on default father bindings in XtObject.init
             *)
            (# widgetClass::&lt; 
                 (# 
                 do INNER; 
                    (if value=0 then CoreWidgetClass -&gt; value if)
                 #);
            do ev.init; (* Initialization of the eventhandler for
                         * THIS(Core)
                         *)
               INNER;
            #);
          
          (* Core resources *)
          <B>depth</B><A name="XtEnv.1:Core.2:depth.3(65)"></A><A name="depth.3(65)"></A>: 
            (* Holds the number of bits per pixel used for indexing
             * into the colormap (read only).
             *)
            IntegerResource(# resourceName::&lt; XtNDepth #);
          <B>mappedWhenManaged</B><A name="XtEnv.1:Core.2:mappedWhenManaged.3(66)"></A><A name="mappedWhenManaged.3(66)"></A>: 
            (* If this resource is True, then the window of
             * THIS(Core) will automatically be mapped when it is
             * realized an managed (after INNER in init unless
             * doNotManage is true)
             *)
            BooleanResource(# resourceName::&lt; XtNMappedWhenManaged #);
          <B>borderColor</B><A name="XtEnv.1:Core.2:borderColor.3(67)"></A><A name="borderColor.3(67)"></A>: 
            (* A pixel value which indexes THIS(Core)'s colormap to
             * derive the border colour of THIS(Core)'s window.
             *)
            IntegerResource(# resourceName::&lt; XtNBorderColor #);
          <B>borderPixmap</B><A name="XtEnv.1:Core.2:borderPixmap.3(68)"></A><A name="borderPixmap.3(68)"></A>: 
            (* The border pixmap of THIS(Core)'s window. *)
            IntegerResource(# resourceName::&lt; XtNBorderPixmap #);
          <B>colormap</B><A name="XtEnv.1:Core.2:colormap.3(69)"></A><A name="colormap.3(69)"></A>:
            (* The colormap that THIS(Core) will use. *)
            IntegerResource(# resourceName::&lt; XtNColormap #);
          <B>screenResource</B><A name="XtEnv.1:Core.2:screenResource.3(70)"></A><A name="screenResource.3(70)"></A>: 
            (* The screen where THIS(Core) is placed. *)
            IntegerResource(# resourceName::&lt; XtNScreen #);
          <B>backGround</B><A name="XtEnv.1:Core.2:backGround.3(71)"></A><A name="backGround.3(71)"></A>: 
            (* A pixel value which indexes THIS(Core)s colormap to
             * derive the background colour of THIS(Core)s window. You
             * can set either background or backgroundPixMap, but not
             * both. Whichever is set later takes priority.
             *)
            IntegerResource(# resourceName::&lt; XtNBackGround #);
          <B>backGroundPixmap</B><A name="XtEnv.1:Core.2:backGroundPixmap.3(72)"></A><A name="backGroundPixmap.3(72)"></A>: 
            (* The background pixmap of THIS(Core)'s window. *)
            IntegerResource(# resourceName::&lt; XtNBackGroundPixmap #);
          <B>accelerators</B><A name="XtEnv.1:Core.2:accelerators.3(73)"></A><A name="accelerators.3(73)"></A>: 
            (* A list of event to action bindings to be executed by
             * THIS(Core), even though the event occurred in another
             * widget.
             *)
            IntegerResource(# resourceName::&lt; XtNaccelerators #);
          <B>translations</B><A name="XtEnv.1:Core.2:translations.3(74)"></A><A name="translations.3(74)"></A>: 
            (* The event bindings associated with THIS(Core). See
             * also the translation handling routines below
             *)
            IntegerResource(# resourceName::&lt; XtNtranslations #);
          <B>display</B><A name="XtEnv.1:Core.2:display.3(75)"></A><A name="display.3(75)"></A>: IntegerValue
            (* The display where THIS(Core) is placed. *)
            (# do theWidget -&gt; xtDisplayOfObject -&gt; value #);
          <B>window</B><A name="XtEnv.1:Core.2:window.3(76)"></A><A name="window.3(76)"></A>: IntegerValue
            (* The window associated with THIS(Core) *)
            (# do theWidget -&gt; xtWindowOfObject -&gt; value #);
          <B>screenOfObject</B><A name="XtEnv.1:Core.2:screenOfObject.3(77)"></A><A name="screenOfObject.3(77)"></A>: IntegerValue
            (# do theWidget -&gt; xtScreenOfObject -&gt; value #);
          
          (* Patterns for handling realization, mapping and geometry
           * management
           *)
          <B>realize</B><A name="XtEnv.1:Core.2:realize.3(78)"></A><A name="realize.3(78)"></A>: 
            (* Realize THIS(Core) and all its child widgets on the
             * screen if the father widget of THIS(Core) is realized
             * or if it is toplevel.
             *)
            (# do theWidget -&gt; xtRealizeWidget #);
          <B>unrealize</B><A name="XtEnv.1:Core.2:unrealize.3(79)"></A><A name="unrealize.3(79)"></A>: 
            (* Removes THIS(Core) from the screen. All children of
             * THIS(Core) is also unrealized. Unrealizing a widget
             * also unmanaged it. Thus the geometry of its siblings
             * may be affected by the unrealization. An unrealized
             * widget can be realized again later.
             *)
            (# do theWidget -&gt; xtUnRealizeWidget #);         
          <B>map</B><A name="XtEnv.1:Core.2:map.3(80)"></A><A name="map.3(80)"></A>: 
            (* Makes THIS(Core) visible, if it is already realized *)
            (# do theWidget -&gt; xtMapWidget #);
          <B>unMap</B><A name="XtEnv.1:Core.2:unMap.3(81)"></A><A name="unMap.3(81)"></A>: 
            (* Makes THIS(Core) invisible on the screen. The
             * difference from unRealize is, that a widget that is
             * unmapped is still managed, and the geometry of the
             * siblings of THIS(Core) will thus not change by
             * unmapping THIS(Core).
             *)
            (# do theWidget -&gt; xtUnMapWidget #);
          <B>manageChild</B><A name="XtEnv.1:Core.2:manageChild.3(82)"></A><A name="manageChild.3(82)"></A>: 
            (* Makes THIS(Core)'s geometry be managed *)
            (# do theWidget -&gt; xtManageChild #);
          <B>unManageChild</B><A name="XtEnv.1:Core.2:unManageChild.3(83)"></A><A name="unManageChild.3(83)"></A>:
            (* Makes THIS(Core)'s geometry be unmanaged *)
            (# do thewidget -&gt; XtUnmanageChild #);
          
          (* Translation handling routines. See also
           * XtEnv.translationTable
           *)
          <B>overrideTranslations</B><A name="XtEnv.1:Core.2:overrideTranslations.3(84)"></A><A name="overrideTranslations.3(84)"></A>:
            (* Merge the new translations t into the existing widget
             * translations, ignoring any #replace, #augment, or
             * #override directives that may have been specified in
             * the translation string. If the new translations contain
             * an event or event sequence that already existed in
             * THIS(Core)'s translations, the new translations
             * override the existing ones.
             *)
            (# t: @integer enter t ... #);
          <B>augmentTranslations</B><A name="XtEnv.1:Core.2:augmentTranslations.3(85)"></A><A name="augmentTranslations.3(85)"></A>: 
            (* Merge the new translations t into the existing widget
             * translations, ignoring any #replace, #augment, or
             * #override directives that may have been specified in
             * the translation string. If the new translations contain
             * an event or event sequence that already existed in
             * THIS(Core)'s translations, the new translations are
             * ignored
             *)
            (# t: @integer enter t ... #);
          <B>uninstallTranslations</B><A name="XtEnv.1:Core.2:uninstallTranslations.3(86)"></A><A name="uninstallTranslations.3(86)"></A>: 
            (* Remove the entire translation table for THIS(Core) *)
            (# do theWidget -&gt; xtunInstallTranslations #);
          
          (* Installing accelerators *)
          <B>installAccelerators</B><A name="XtEnv.1:Core.2:installAccelerators.3(87)"></A><A name="installAccelerators.3(87)"></A>:
            (* Merge the accelerators of source with the translations
             * of THIS(Core).  This will allow events occurring in
             * THIS(Core) to invoke actions in source
             *)
            (# source: @widget;
            enter source
            do (thewidget, source) -&gt; XtInstallAccelerators
            #);
          <B>installAllAccelerators</B><A name="XtEnv.1:Core.2:installAllAccelerators.3(88)"></A><A name="installAllAccelerators.3(88)"></A>:
            (* Merge the accelerators of source and all subwidgets of
             * source with the translations of THIS(Core).  This will
             * allow events occurring in THIS(Core) to invoke actions
             * in source
             *)
            (# source: @widget;
            enter source
            do (thewidget, source) -&gt; XtInstallAllAccelerators
            #);
          
          (* Various convenience routines for conversions *)
          <B>textToFont</B><A name="XtEnv.1:Core.2:textToFont.3(89)"></A><A name="textToFont.3(89)"></A>:
            (* A procedure that converts a text specifying a name of
             * a font to something which can be used in
             * font-assignments.
             *)
            (# fn: ^text;
               f: @integer;
            enter fn[]
            do (display, fn) -&gt; XLoadQueryFont -&gt; f;
            exit f
            #);
          <B>BitmapFileToPixmap</B><A name="XtEnv.1:Core.2:BitmapFileToPixmap.3(90)"></A><A name="BitmapFileToPixmap.3(90)"></A>:
            (* Takes the name of a file which contains a bitmap to be
             * used as a pixelmap.  Reads in this file and returns
             * something that can be used in pixelmap-assignments.
             *)
            (# filename: ^text;
               pixmap: @integer;
            enter filename[]
            do ...;
            exit pixmap
            #);
          <B>BitmapFileToBitmap</B><A name="XtEnv.1:Core.2:BitmapFileToBitmap.3(91)"></A><A name="BitmapFileToBitmap.3(91)"></A>:
            (* Takes the name of a file which contains a
             * bitmap. Reads in this file and returns something that
             * can be used in bitmap-assignments.
             *)
            (# filename: ^text;
               bitmap: @integer;
            enter filename[]
            do ...;
            exit bitmap
            #);
          <B>SymbolToCursor</B><A name="XtEnv.1:Core.2:SymbolToCursor.3(92)"></A><A name="SymbolToCursor.3(92)"></A>:
            (* Reads in one of the predefined cursors and returns
             * something that can be used in cursor-assignments. The
             * enter parameter is a constant that defines the
             * cursor. The constants XCXcursor, XCArrow, etc. can be
             * used. See xlib.bet for the complete list.
             *)
            (# symbol: @integer;
               cursor: @integer
            enter symbol
            do (display, symbol) -&gt; XCreateFontCursor -&gt; cursor
            exit cursor
            #);
          
          <B>eventHandler</B><A name="XtEnv.1:Core.2:eventHandler.3(93)"></A><A name="eventHandler.3(93)"></A>:&lt;
            (* This virtual pattern allows the application program to
             * do something when a particular event occurs. It is a
             * low-level facility which is seldom needed as most
             * widget classes uses callbacks (like "callback") to
             * notify the application-program when something
             * interesting happens. eventhandler has local patterns
             * keypress, keyrelease, buttonpress, exposure, etc., that
             * can be used.  If an instance of one of these patterns
             * is enabled, it will be invoked, when the corresponding
             * X-event occurs.
             *)
            (# 
               <B>eventProcessor</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4(94)"></A><A name="eventProcessor.4(94)"></A>:
                 (* Prefix for event handling patterns *)
                 (#
                    <B>EventDesc</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:EventDesc.5(95)"></A><A name="EventDesc.5(95)"></A>:&lt; XAnyEvent;
                    <B>event</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:event.5(96)"></A><A name="event.5(96)"></A>: 
                      (* The event being processed *)
                      @EventDesc; 
                    <B>mask</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:mask.5(97)"></A><A name="mask.5(97)"></A>:&lt; 
                      (* Specify the mask for the X11 event to
                       * process
                       *)
                      (# eventMask, nonmaskable: @integer;
                      do INNER
                      #);
                    <B>enable</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:enable.5(98)"></A><A name="enable.5(98)"></A>:&lt;
                      (* Enables THIS(EventProcessor). After this,
                       * THIS(EventProcessor) will be called everytime
                       * the corresponding event occurs
                       *)
                      (# do ...; INNER #);
                    <B>disable</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:disable.5(99)"></A><A name="disable.5(99)"></A>:&lt;
                      (* Disable THIS(EventProcessor). Afterwards
                       * THIS(EventProcessor) will not be called in
                       * response to the corresponding event anymore
                       *)
                      (# do ...; INNER #);
                    <B>private</B><A name="XtEnv.1:Core.2:eventHandler.3:eventProcessor.4:private.5(100)"></A><A name="private.5(100)"></A>: @...;
                 do INNER
                 #); (* eventProcessor *)
               <B>init</B><A name="XtEnv.1:Core.2:eventHandler.3:init.4(101)"></A><A name="init.4(101)"></A>:&lt; object;
               
               (* Predefined Eventprocessors *)
               <B>keyPress</B><A name="XtEnv.1:Core.2:eventHandler.3:keyPress.4(102)"></A><A name="keyPress.4(102)"></A>: eventProcessor
                 (# mask::&lt; (# ... #);
                    eventDesc::&lt; XKeyEvent;
                 do INNER
                 #);
               <B>keyRelease</B><A name="XtEnv.1:Core.2:eventHandler.3:keyRelease.4(103)"></A><A name="keyRelease.4(103)"></A>: eventProcessor
                 (# mask::&lt; (# ... #);
                    eventDesc::&lt; XKeyEvent;
                 do INNER
                 #);
               <B>buttonPress</B><A name="XtEnv.1:Core.2:eventHandler.3:buttonPress.4(104)"></A><A name="buttonPress.4(104)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XButtonEvent;
                 do INNER
                 #);
               <B>buttonRelease</B><A name="XtEnv.1:Core.2:eventHandler.3:buttonRelease.4(105)"></A><A name="buttonRelease.4(105)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XButtonEvent;
                 do INNER
                 #);
               <B>EnterWindow</B><A name="XtEnv.1:Core.2:eventHandler.3:EnterWindow.4(106)"></A><A name="EnterWindow.4(106)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XEnterWindowEvent;
                 do INNER
                 #);
               <B>LeaveWindow</B><A name="XtEnv.1:Core.2:eventHandler.3:LeaveWindow.4(107)"></A><A name="LeaveWindow.4(107)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XLeaveWindowEvent;
                 do INNER
                 #);
               <B>PointerMotion</B><A name="XtEnv.1:Core.2:eventHandler.3:PointerMotion.4(108)"></A><A name="PointerMotion.4(108)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>PointerMotionHint</B><A name="XtEnv.1:Core.2:eventHandler.3:PointerMotionHint.4(109)"></A><A name="PointerMotionHint.4(109)"></A>: eventProcessor
                 (# mask::&lt; (# ... #); 
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>Button1Motion</B><A name="XtEnv.1:Core.2:eventHandler.3:Button1Motion.4(110)"></A><A name="Button1Motion.4(110)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>Button2Motion</B><A name="XtEnv.1:Core.2:eventHandler.3:Button2Motion.4(111)"></A><A name="Button2Motion.4(111)"></A>: eventProcessor
                 (# mask::&lt;(# ... #); 
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>Button3Motion</B><A name="XtEnv.1:Core.2:eventHandler.3:Button3Motion.4(112)"></A><A name="Button3Motion.4(112)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>Button4Motion</B><A name="XtEnv.1:Core.2:eventHandler.3:Button4Motion.4(113)"></A><A name="Button4Motion.4(113)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>Button5Motion</B><A name="XtEnv.1:Core.2:eventHandler.3:Button5Motion.4(114)"></A><A name="Button5Motion.4(114)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>ButtonMotion</B><A name="XtEnv.1:Core.2:eventHandler.3:ButtonMotion.4(115)"></A><A name="ButtonMotion.4(115)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XMotionEvent;
                 do INNER
                 #);
               <B>KeyMapState</B><A name="XtEnv.1:Core.2:eventHandler.3:KeyMapState.4(116)"></A><A name="KeyMapState.4(116)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XKeymapEvent;
                 do INNER
                 #);
               <B>Exposure</B><A name="XtEnv.1:Core.2:eventHandler.3:Exposure.4(117)"></A><A name="Exposure.4(117)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XExposeEvent;
                 do INNER 
                 #);
               <B>VisibilityChange</B><A name="XtEnv.1:Core.2:eventHandler.3:VisibilityChange.4(118)"></A><A name="VisibilityChange.4(118)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XVisibilityEvent;
                 do INNER 
                 #);
               <B>StructureNotify</B><A name="XtEnv.1:Core.2:eventHandler.3:StructureNotify.4(119)"></A><A name="StructureNotify.4(119)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                 do INNER
                 #);
               <B>ResizeRedirect</B><A name="XtEnv.1:Core.2:eventHandler.3:ResizeRedirect.4(120)"></A><A name="ResizeRedirect.4(120)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XResizeRequestEvent;
                 do INNER
                 #);
               <B>SubstructureNotify</B><A name="XtEnv.1:Core.2:eventHandler.3:SubstructureNotify.4(121)"></A><A name="SubstructureNotify.4(121)"></A>: eventProcessor
                 (# mask::&lt; (# ... #);
                 do INNER
                 #);
               <B>SubStructureRedirect</B><A name="XtEnv.1:Core.2:eventHandler.3:SubStructureRedirect.4(122)"></A><A name="SubStructureRedirect.4(122)"></A>: eventProcessor
                 (# mask::&lt;(# ... #); 
                 do INNER
                 #);
               <B>FocusChange</B><A name="XtEnv.1:Core.2:eventHandler.3:FocusChange.4(123)"></A><A name="FocusChange.4(123)"></A>: eventProcessor
                 (# mask::&lt;(# ... #); 
                 do INNER 
                 #);
               <B>PropertyChange</B><A name="XtEnv.1:Core.2:eventHandler.3:PropertyChange.4(124)"></A><A name="PropertyChange.4(124)"></A>: eventProcessor
                 (# mask::&lt;(# ... #); 
                    eventDesc::&lt; XPropertyEvent;
                 do INNER 
                 #);
               <B>ColormapChange</B><A name="XtEnv.1:Core.2:eventHandler.3:ColormapChange.4(125)"></A><A name="ColormapChange.4(125)"></A>: eventProcessor
                 (# mask::&lt;(# ... #);
                    eventDesc::&lt; XColormapEvent;
                do INNER
                 #);
               <B>OwnerGrabButton</B><A name="XtEnv.1:Core.2:eventHandler.3:OwnerGrabButton.4(126)"></A><A name="OwnerGrabButton.4(126)"></A>: eventProcessor
                 (# mask::&lt;(# ... #); 
                 do INNER
                 #);
            #);
          <B>ev</B><A name="XtEnv.1:Core.2:ev.3(127)"></A><A name="ev.3(127)"></A>: @eventHandler; (* One static instance of eventHandler *)
       #) (* core *);
     
     <B>Composite</B><A name="XtEnv.1:Composite.2(128)"></A><A name="Composite.2(128)"></A>: Core
       (* Composite widgets are intended to be containers for other
        * widgets.  They have the ability to manage child widgets and
        * they are responsible for handling the geometry for them.
        * 
        * The composite widgets pattern is an abstract
        * superpattern. It is never instantiated directly in an
        * application, only subclasses are instantiated.
        *)
       (# &lt;&lt;SLOT compositeLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:Composite.2:init.3(129)"></A><A name="init.3(129)"></A>::&lt; 
            (# widgetClass::&lt; 
                 (# 
                 do INNER; 
                    (if value=0 then CompositeWidgetClass-&gt;value if)
                 #)
            do INNER
            #);
          <B>NumChildren</B><A name="XtEnv.1:Composite.2:NumChildren.3(130)"></A><A name="NumChildren.3(130)"></A>: 
            (* Returns the number of children in this composite
             * widget.
             *)
            IntegerResource(# resourceName::&lt; XtNnumChildren #);
       #) (* composite *);
     
     <B>Constraint</B><A name="XtEnv.1:Constraint.2(131)"></A><A name="Constraint.2(131)"></A>: Composite
       (* The Constraint pattern is a subpattern of the composite,
        * and does thus also manage the layout of children. Constraint
        * widgets let the application provide layout information for
        * each child. This information often takes the form of some
        * constraints on the child's position and/or size. This is a
        * more powerful way to arrange children because it allows you
        * to provide different rules for how each child will be laid
        * out.
        * 
        * Constraint is an abstract superpattern. It is never
        * instantiated directly in an application, only subclasses are
        * instantiated.
        *)
       (# &lt;&lt;SLOT constraintLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:Constraint.2:init.3(132)"></A><A name="init.3(132)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER; 
                    (if value=0 then constraintWidgetClass-&gt;value if)
                 #)
            do INNER
            #);
       #) (* constraint *);
     
     <B>Shell</B><A name="XtEnv.1:Shell.2(133)"></A><A name="Shell.2(133)"></A>: Composite
       (* Widgets negotiate their size and positions with their
        * parent widget (i.e. the widget that directly contain
        * them). Widgets at the top of the hierarchy do not have any
        * parent widget. Instead they must deal with the outside
        * world. To provide for this, each top-level widget is
        * encapsulated in a special widget, called a Shell widget.
        * 
        * The Shell pattern is a subpattern of Composite, but can have
        * only one child.  Shell widgets are special purpose widgets
        * that provide an interface between other widgets and the
        * window manager. A shell widget negotiates the geometry of
        * the widget with the window manager, and sets the properties
        * required by the window manager.
        * 
        * Shell is an abstract superpattern. It is never instantiated
        * directly in an application, only subclasses are
        * instantiated.
        *)
       (# &lt;&lt;SLOT shellLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:Shell.2:init.3(134)"></A><A name="init.3(134)"></A>::&lt;
            (# widgetClass::&lt;
                 (#
                 do INNER;
                    (if value=0 then shellWidgetClass -&gt; value if);
                    ...;
                 #)
            do true -&gt; doNotManageChild; INNER;
            #);
          
          (* Popping up THIS(Shell) *)
          <B>popUp</B><A name="XtEnv.1:Shell.2:popUp.3(135)"></A><A name="popUp.3(135)"></A>: 
            (* Call this to popup a shell and its enclosed widgets *)
            (# <B>grapKind</B><A name="XtEnv.1:Shell.2:popUp.3:grapKind.4(136)"></A><A name="grapKind.4(136)"></A>: @integer 
                 (* grabKind controls Xt's event dispatching within
                  * the application. It may be one of XtGrabNone - no
                  * restrictions on event dispatching
                  * XtGrabNonExclusive - all pop ups (i.e. in a menu
                  * cascade) will get events XtGrabExclusive - only
                  * the most recent pop up will get events
                  *)
            enter grapKind 
            do (theWidget,grapKind) -&gt; xtPopUp
            #);
          <B>popUpSpringLoaded</B><A name="XtEnv.1:Shell.2:popUpSpringLoaded.3(137)"></A><A name="popUpSpringLoaded.3(137)"></A>:
            (* Like popUp, except that a passive grap of the pointer
             * is made.  This is useful for main menus, whereas popUp
             * is preferable for dialogs.
             *)
            (# do theWidget -&gt; xtPopUpSpringLoaded #);
          <B>popDown</B><A name="XtEnv.1:Shell.2:popDown.3(138)"></A><A name="popDown.3(138)"></A>: 
            (* Call this to popdown a shell and its enclosed widgets.
             *)
            (# do theWidget -&gt; xtPopDown #);
          
          (* Shell resources *)
          <B>allowShellResize</B><A name="XtEnv.1:Shell.2:allowShellResize.3(139)"></A><A name="allowShellResize.3(139)"></A>:
            (* This attribute controls whether or not the widget
             * contained by the shell is allowed to try to resize
             * itself.
             *)
            BooleanResource(# resourceName::&lt;XtNAllowShellResize#);
          <B>geometry</B><A name="XtEnv.1:Shell.2:geometry.3(140)"></A><A name="geometry.3(140)"></A>: 
            (* If this attribute is specified, it will override the
             * x, y, width and height of THIS(Shell). The format of
             * this string is 
             *   [&lt;width&gt;x&lt;height&gt; [{+ -}&lt;xoffset&gt;{+-}&lt;yoffset&gt;].  
             * An example is "80x100-300+2" which
             * specifies a window 80 pixels wide and 100 pixels high
             * positioned with the right edge positioned 300 pixels
             * from the right edge of the screen and the top edge 2
             * pixels from the top of the screen.
             *)
            StringResource(# resourceName::&lt; XtNGeometry #);
          <B>overRideReDirect</B><A name="XtEnv.1:Shell.2:overRideReDirect.3(141)"></A><A name="overRideReDirect.3(141)"></A>: 
            (* This attribute determine whether or not the window
             * manager may interpose itself between THIS(Shell) and
             * the root window of the display.
             *)
            BooleanResource(# resourceName::&lt;XtNOverrideRedirect#);
          <B>saveUnder</B><A name="XtEnv.1:Shell.2:saveUnder.3(142)"></A><A name="saveUnder.3(142)"></A>:
            (* If this is true then save unders will be active for
             * THIS(Shell).
             *)
            BooleanResource(# resourceName::&lt; XtNSaveUnder #);
          
          <B>installCallBacks</B><A name="XtEnv.1:Shell.2:installCallBacks.3(143)"></A><A name="installCallBacks.3(143)"></A>::&lt;
            (* Install the popup and popdown callbacks *)
            (# do ...; INNER #);
          
          <B>popUpCallback</B><A name="XtEnv.1:Shell.2:popUpCallback.3(144)"></A><A name="popUpCallback.3(144)"></A>:&lt; object                   
            (* This pattern will be called when THIS(Shell) is popped
             * up.
             *);
          <B>popDownCallback</B><A name="XtEnv.1:Shell.2:popDownCallback.3(145)"></A><A name="popDownCallback.3(145)"></A>:&lt; object
            (* This pattern will be called when THIS(Shell) is popped
             * down.
             *);
          
       #) (* Shell *);
     
     <B>OverrideShell</B><A name="XtEnv.1:OverrideShell.2(146)"></A><A name="OverrideShell.2(146)"></A>: Shell
       (* An overrideShell instructs the window manager to completely
        * ignore it. OverrideShells completely bypass the window
        * manager and therefore have no added window manager
        * decorations.  They are typically used for popup-menues.
        *)
       (# &lt;&lt;SLOT overideShellLib: attributes&gt;&gt;;

          <B>init</B><A name="XtEnv.1:OverrideShell.2:init.3(147)"></A><A name="init.3(147)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER;
                    (if value=0 then 
                        OverrideShellWidgetClass-&gt;value
                    if)
                 #)
            do INNER
            #);
       #) (* overideShell *);
     
     <B>WMShell</B><A name="XtEnv.1:WMShell.2(148)"></A><A name="WMShell.2(148)"></A>: Shell
       (* The WMShell is an abstract super class that contains
        * attributes needed by the common window manager protocol.
        *)
       (# &lt;&lt;SLOT wmShellLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:WMShell.2:init.3(149)"></A><A name="init.3(149)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER;
                    (if value=0 then WMShellWidgetClass-&gt;value if)
                 #)
            do INNER
            #);
          
          (* WM Shell resources *)
          <B>baseHeight</B><A name="XtEnv.1:WMShell.2:baseHeight.3(150)"></A><A name="baseHeight.3(150)"></A>: 
            (* Size hint to the window manager describing height of
             * fixed components
             *)
            IntegerResource(# resourceName::&lt; XtNBaseHeight #);
          <B>baseWidth</B><A name="XtEnv.1:WMShell.2:baseWidth.3(151)"></A><A name="baseWidth.3(151)"></A>: 
            (* Size hint to the window manager describing width of
             * fixed components
             *)
            IntegerResource(# resourceName::&lt; XtNBaseWidth #);
          <B>heightInc</B><A name="XtEnv.1:WMShell.2:heightInc.3(152)"></A><A name="heightInc.3(152)"></A>: 
            (* Size hint describing desired height increment *)
            IntegerResource(# resourceName::&lt; XtNHeightInc #);
          <B>widthInc</B><A name="XtEnv.1:WMShell.2:widthInc.3(153)"></A><A name="widthInc.3(153)"></A>: 
            (* Size hint describing desired width increment *)
            IntegerResource(# resourceName::&lt; XtNWidthInc #);
          <B>iconMask</B><A name="XtEnv.1:WMShell.2:iconMask.3(154)"></A><A name="iconMask.3(154)"></A>: (* Mask used with icon pixmap. *)
            IntegerResource(# resourceName::&lt; XtNIconMask #);
          <B>iconPixmap</B><A name="XtEnv.1:WMShell.2:iconPixmap.3(155)"></A><A name="iconPixmap.3(155)"></A>: (* Picture for icon. *)
            IntegerResource(# resourceName::&lt; XtNIconPixmap #);
          <B>iconWindow</B><A name="XtEnv.1:WMShell.2:iconWindow.3(156)"></A><A name="iconWindow.3(156)"></A>: (* Window for icon. *)
            IntegerResource(# resourceName::&lt; XtNIconWindow #);
          <B>iconX</B><A name="XtEnv.1:WMShell.2:iconX.3(157)"></A><A name="iconX.3(157)"></A>: (* Icon x position *)
            IntegerResource(# resourceName::&lt; XtNIconX #);
          <B>iconY</B><A name="XtEnv.1:WMShell.2:iconY.3(158)"></A><A name="iconY.3(158)"></A>: (* Icon y position *)
            IntegerResource(# resourceName::&lt; XtNIconY #);
          <B>input</B><A name="XtEnv.1:WMShell.2:input.3(159)"></A><A name="input.3(159)"></A>: 
            (* If this attribute is true the window manager will set
             * the keyboard focus to this application or not,
             * according to its pointer-following or click-to-type
             * model of keyboard input.  If it is false, the window
             * manager will not set keyboard focus to this
             * application.
             *)
            BooleanResource(# resourceName::&lt; XtNInput #);
          <B>maxAspectX</B><A name="XtEnv.1:WMShell.2:maxAspectX.3(160)"></A><A name="maxAspectX.3(160)"></A>: 
            (* Size hint describing maximum horizontal aspect ratio *)
            IntegerResource(# resourceName::&lt; XtNMaxAspectX #);
          <B>maxAspectY</B><A name="XtEnv.1:WMShell.2:maxAspectY.3(161)"></A><A name="maxAspectY.3(161)"></A>: 
            (* Size hint describing maximum vertical aspect ratio *)
            IntegerResource(# resourceName::&lt; XtNMaxAspectY #);
          <B>maxHeight</B><A name="XtEnv.1:WMShell.2:maxHeight.3(162)"></A><A name="maxHeight.3(162)"></A>: 
            (* Size hint describing maximum acceptable height *)
            IntegerResource(# resourceName::&lt; XtNMaxHeight #);
          <B>maxWidth</B><A name="XtEnv.1:WMShell.2:maxWidth.3(163)"></A><A name="maxWidth.3(163)"></A>: 
            (* Size hint describing maximum acceptable width *)
            IntegerResource(# resourceName::&lt; XtNMaxWidth #);
          <B>minAspectX</B><A name="XtEnv.1:WMShell.2:minAspectX.3(164)"></A><A name="minAspectX.3(164)"></A>:
            (* Size hint describing minimum horizontal aspect ratio *)
            IntegerResource(# resourceName::&lt; XtNminAspectX #);
          <B>minAspectY</B><A name="XtEnv.1:WMShell.2:minAspectY.3(165)"></A><A name="minAspectY.3(165)"></A>: 
            (* Size hint describing minimum vertical aspect ratio *)
            IntegerResource(# resourceName::&lt; XtNminAspectY #);
          <B>minHeight</B><A name="XtEnv.1:WMShell.2:minHeight.3(166)"></A><A name="minHeight.3(166)"></A>: 
            (* Size hint describing minimum acceptable height *)
            IntegerResource(# resourceName::&lt; XtNminHeight #);
          <B>minWidth</B><A name="XtEnv.1:WMShell.2:minWidth.3(167)"></A><A name="minWidth.3(167)"></A>: 
            (* Size hint describing minimum acceptable width *)
            IntegerResource(# resourceName::&lt; XtNminWidth #);
          <B>title</B><A name="XtEnv.1:WMShell.2:title.3(168)"></A><A name="title.3(168)"></A>: (* The text to be used in the title bar *)
            StringResource(# resourceName::&lt; XtNTitle #);
          <B>transient</B><A name="XtEnv.1:WMShell.2:transient.3(169)"></A><A name="transient.3(169)"></A>:
            (* True if THIS(WMShell) is transient. Is true for a
             * transientShell and false otherwise
             *)
            BooleanResource(# resourceName::&lt; XtNtransient #);
          <B>waitForWM</B><A name="XtEnv.1:WMShell.2:waitForWM.3(170)"></A><A name="waitForWM.3(170)"></A>: 
            (* WaitForWM and wmTimeOut controls the response to
             * delays by the window manager in response to geometry
             * change requests. By default waitForWm is true and
             * wmTimeout is 5 seconds. If a response for a geometry
             * request does not arrive within 5 seconds, Xt assumes
             * that the window manager is not functioning.
             *)
            BooleanResource(# resourceName::&lt; XtNwaitForWm #);
          <B>wmTimeOut</B><A name="XtEnv.1:WMShell.2:wmTimeOut.3(171)"></A><A name="wmTimeOut.3(171)"></A>: (* See waitForWM *)
            IntegerResource(# resourceName::&lt; XtNwmTimeOut #);
          <B>winGravity</B><A name="XtEnv.1:WMShell.2:winGravity.3(172)"></A><A name="winGravity.3(172)"></A>: 
            (* This attribute controls how to reposition the widget
             * contained by the shell when the window changes. The
             * value can be NorthWestGravity, NorthGravity,...,
             * SouthEastGravity (compas directions), CenterGravity,
             * and UnmapGravity.
             *)
            IntegerResource(# resourceName::&lt; XtNwinGravity #);
          <B>windowGroup</B><A name="XtEnv.1:WMShell.2:windowGroup.3(173)"></A><A name="windowGroup.3(173)"></A>:
            (* This attribute links popup windows to the main window
             *)
            IntegerResource(# resourceName::&lt; XtNWindowGroup #);
       #) (* WMShell *);
     
     <B>VendorShell</B><A name="XtEnv.1:VendorShell.2(174)"></A><A name="VendorShell.2(174)"></A>: WMShell
       (* The VendorShell is an abstract super class with
        * implementation dependent resources defined by the different
        * widget sets using it.
        *)
       (# &lt;&lt;SLOT VendorShellLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:VendorShell.2:init.3(175)"></A><A name="init.3(175)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER; 
                    (if value=0 then 
                        VendorShellWidgetClass-&gt;value
                    if)
                 #)
            do INNER
            #);
       #);

     <B>TransientShell</B><A name="XtEnv.1:TransientShell.2(176)"></A><A name="TransientShell.2(176)"></A>: VendorShell
       (* A transient shell is similar to a toplevel shell except for
        * the way it interacts with the window manager with respect to
        * iconifying. If an applications toplevel window
        * (transientFor) is iconified, the window manager normally
        * iconifies all transient shells created by the application.
        *)
       (# &lt;&lt;SLOT transientShellLib: attributes&gt;&gt;;

          <B>init</B><A name="XtEnv.1:TransientShell.2:init.3(177)"></A><A name="init.3(177)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER; 
                    (if value=0 then 
                        TransientShellWidgetClass-&gt;value
                    if)
                 #)
            do INNER
            #);
          
          <B>transientFor</B><A name="XtEnv.1:TransientShell.2:transientFor.3(178)"></A><A name="transientFor.3(178)"></A>: 
            (* The widget, that THIS(TransientShell) is transient
             * for. Default value is topLevel.
             *)
            IntegerResource(# resourceName::&lt; XtNTransientFor #);
       #) (* transientShell *);
     
     <B>ToplevelShell</B><A name="XtEnv.1:ToplevelShell.2(179)"></A><A name="ToplevelShell.2(179)"></A>: VendorShell
       (* ToplevelShell widgets are used for normal top-level
        * windows. XtEnv creates the main toplevel widget, "topLevel",
        * of the application.  Some applications have multiple
        * permanent top-level windows, and should use ToplevelShell to
        * accomplish this.
        *)
       (# &lt;&lt;SLOT toplevelShellLib: attributes&gt;&gt;;
          
          <B>init</B><A name="XtEnv.1:ToplevelShell.2:init.3(180)"></A><A name="init.3(180)"></A>::&lt;
            (# widgetClass::&lt;
                 (# 
                 do INNER; 
                    (if value=0 then 
                        ToplevelShellWidgetClass-&gt;value
                    if)
                 #)
            do INNER
            #);
          
          <B>iconName</B><A name="XtEnv.1:ToplevelShell.2:iconName.3(181)"></A><A name="iconName.3(181)"></A>: (* The text to be used for the icon *)
            StringResource(# resourceName::&lt; XtNiconname #);
          <B>iconic</B><A name="XtEnv.1:ToplevelShell.2:iconic.3(182)"></A><A name="iconic.3(182)"></A>:  
            (* This attribute may be used by an application to
             * request that the window manager iconify or deiconify
             * THIS(ToplevelShell).  If set before realization it is
             * also a method to change initialState
             *)
            BooleanResource(# resourceName::&lt; XtNiconic #);
       #) (* toplevelShell *);
     
     <B>Display</B><A name="XtEnv.1:Display.2(183)"></A><A name="Display.2(183)"></A>:
       (* This pattern allows an application to have windows open on
        * more than one workstation at the same time. After
        * THIS(Display) have been opened, THIS(Display).shell can be
        * used as a toplevel widget on that display. When children
        * have been added to THIS(Display).shell, it must be realized
        * to show the window on screen.
        *)
       (# <B>displayString</B><A name="XtEnv.1:Display.2:displayString.3(184)"></A><A name="displayString.3(184)"></A>: ^text
            (* A text that contains the enter-parameter to open (the
             * name of the display
             *);
          <B>shell</B><A name="XtEnv.1:Display.2:shell.3(185)"></A><A name="shell.3(185)"></A>: @ToplevelShell
            (* After THIS(display) have been opened this specifies
             * the toplevel window on the display.
             *);
          <B>open</B><A name="XtEnv.1:Display.2:open.3(186)"></A><A name="open.3(186)"></A>:
            (* Opens the display. Takes as enter parameter the name
             * of the display to open. An example of a displayname is
             * "www.daimi.au.dk:0.0" which specifies screen
             * number 0 on cpu number 0 on the host
             * www.daimi.au.dk.
             *)
            (# DisplayError:&lt; XtException
                 (* Called if opening of the display fails *)
                 (# ... #);
            enter displayString[]
            do ...;
            #);
          <B>close</B><A name="XtEnv.1:Display.2:close.3(187)"></A><A name="close.3(187)"></A>:
            (* Close the display connection, and properly dispose all
             * resources is has created.
             *)
            (# ... #);
          <B>private</B><A name="XtEnv.1:Display.2:private.3(188)"></A><A name="private.3(188)"></A>: @...;
       #);
     
     <B>Timer</B><A name="XtEnv.1:Timer.2(189)"></A><A name="Timer.2(189)"></A>:
       (* This pattern allow the application to be notified when a
        * period of time have elapsed, while being able to do other
        * things during that time.
        *)
       (# <B>on</B><A name="XtEnv.1:Timer.2:on.3(190)"></A><A name="on.3(190)"></A>: @boolean
            (* A boolean that specifies if the timer is on for the
             * time being
             *);
          <B>start</B><A name="XtEnv.1:Timer.2:start.3(191)"></A><A name="start.3(191)"></A>:
            (* Starts THIS(Timer). Takes as enter parameter the
             * number of milliseconds the timer should run before
             * invoking timeout.
             *)
            (# ms: @integer
            enter ms
            ...
            #);
          <B>disable</B><A name="XtEnv.1:Timer.2:disable.3(192)"></A><A name="disable.3(192)"></A>: (* Disables THIS(Timer) *)
            (# ... #);     
          <B>timeOut</B><A name="XtEnv.1:Timer.2:timeOut.3(193)"></A><A name="timeOut.3(193)"></A>:&lt;
            (* This method is called when the specified number of
             * milliseconds have elapsed if it have not been disabled
             * in the meantime. It is called only once, so to have
             * THIS(Timer) timing out repeatedly, it must be
             * re-started after each timeout.
             *)
            (# ... #);
          <B>private</B><A name="XtEnv.1:Timer.2:private.3(194)"></A><A name="private.3(194)"></A>: @...;
       #);
     
     <B>WorkProc</B><A name="XtEnv.1:WorkProc.2(195)"></A><A name="WorkProc.2(195)"></A>:
       (* The WorkProc-pattern is a means for doing background
        * processing while the application is idle waiting for an
        * event. After a WorkProc have been started, the virtual
        * method "job" is invoked by XtEnv when no events are
        * pending. It is invoked through a BETA component, such that a
        * further binding of job may suspend itself in order not to
        * let the user's response time suffer from time consuming
        * background processing. Next time there are no events
        * pending, job is resumed at the suspended place. More than
        * one Workproc Can be started at a time.
        *)
       (# <B>start</B><A name="XtEnv.1:WorkProc.2:start.3(196)"></A><A name="start.3(196)"></A>: (* Starts THIS(WorkProc) *)
            (# ... #);
          <B>disable</B><A name="XtEnv.1:WorkProc.2:disable.3(197)"></A><A name="disable.3(197)"></A>: (* Disables THIS(WorkProc) *)
            (# ... #);
          <B>job</B><A name="XtEnv.1:WorkProc.2:job.3(198)"></A><A name="job.3(198)"></A>:&lt; 
            (* Called by XtEnv when no events are pending. The BETA
             * suspend- imperative can be used to let XtEnv
             * temporarily come into the foreground again.
             *)
            (# finished: @boolean
            do false -&gt; finished;
               INNER;
               true -&gt; finished;
               suspend;
            exit finished
            #);
          <B>private</B><A name="XtEnv.1:WorkProc.2:private.3(199)"></A><A name="private.3(199)"></A>: @...;
       #);
     
     <B>AcceleratorTable</B><A name="XtEnv.1:AcceleratorTable.2(200)"></A><A name="AcceleratorTable.2(200)"></A>: IntegerObject
       (* Can be used for the advanced programmer to change the
        * translations used by Xt. The value exited can be used to set
        * the "accelerators" resource of a widget.
        *)
       (# <B>parse</B><A name="XtEnv.1:AcceleratorTable.2:parse.3(201)"></A><A name="parse.3(201)"></A>: 
            (* Parses up an accelerator specification and converts it
             * to the interior format of Xt.
             *)
            (# spec: ^text
            enter spec[]
            do spec -&gt; XtParseAcceleratorTable -&gt; value
            exit value
            #);
       #);
     
     <B>TranslationTable</B><A name="XtEnv.1:TranslationTable.2(202)"></A><A name="TranslationTable.2(202)"></A>: IntegerObject
       (* Can be used for the advanced programmer to change the
        * translations used by Xt. The value exited can be used as
        * input to Core.overrideTranslations etc.
        *)
       (# <B>parse</B><A name="XtEnv.1:TranslationTable.2:parse.3(203)"></A><A name="parse.3(203)"></A>: 
            (* Parses up a translationtable specification and
             * converts it to the interior format of Xt.
             *)
            (# spec: ^text
            enter spec[] 
            do spec -&gt; XtParseTranslationTable -&gt; value
            exit value
            #);
       #);
     
     <B>RegisteredAction</B><A name="XtEnv.1:RegisteredAction.2(204)"></A><A name="RegisteredAction.2(204)"></A>:
       (* Used to register an X Toolkit action: After
        * THIS(RegisteredAction) has been installed, it can be used as
        * an Xt action, e.g. be used in translations.  When the action
        * is invoked, INNER is called. theObj is a reference to the
        * widget or gadget, the action was imposed on, event is the
        * event that caused the action to be invoked.
        *)
       (# <B>theObj</B><A name="XtEnv.1:RegisteredAction.2:theObj.3(205)"></A><A name="theObj.3(205)"></A>: ^XtObject;
          <B>eventDesc</B><A name="XtEnv.1:RegisteredAction.2:eventDesc.3(206)"></A><A name="eventDesc.3(206)"></A>:&lt; XAnyEvent;
          <B>event</B><A name="XtEnv.1:RegisteredAction.2:event.3(207)"></A><A name="event.3(207)"></A>: @eventDesc;
          <B>params</B><A name="XtEnv.1:RegisteredAction.2:params.3(208)"></A><A name="params.3(208)"></A>,<B> numParams</B><A name="XtEnv.1:RegisteredAction.2:numParams.3(209)"></A><A name="numParams.3(209)"></A>: @integer;
          <B>private</B><A name="XtEnv.1:RegisteredAction.2:private.3(210)"></A><A name="private.3(210)"></A>: @...;

          <B>install</B><A name="XtEnv.1:RegisteredAction.2:install.3(211)"></A><A name="install.3(211)"></A>:
            (* Install THIS(RegisteredAction). If name is specified,
             * the action will be installed with that name, otherwise
             * the pattern name of THIS(RegisteredAction) is used.
             *)
            (# name: ^text;
            enter name[]
            do ...;
            #);
       do INNER
       #);
     
     <B>StringArray</B><A name="XtEnv.1:StringArray.2(212)"></A><A name="StringArray.2(212)"></A>: 
       (* A StringArray is a list of externally allocated text's. *)
       (# <B>initialSize</B><A name="XtEnv.1:StringArray.2:initialSize.3(213)"></A><A name="initialSize.3(213)"></A>:&lt; IntegerObject(# do 25 -&gt; value; INNER #);
          <B>init</B><A name="XtEnv.1:StringArray.2:init.3(214)"></A><A name="init.3(214)"></A>:&lt; 
            (* Initializes THIS(StringArray) *)
            (# do ...; INNER #);
          <B>clear</B><A name="XtEnv.1:StringArray.2:clear.3(215)"></A><A name="clear.3(215)"></A>:&lt; (* Reset THIS(StringArray) *)
            (# do ...; INNER #);
          <B>number</B><A name="XtEnv.1:StringArray.2:number.3(216)"></A><A name="number.3(216)"></A>:
            (* Number of texts currently in THIS(StringArray) *)
            IntegerValue(# ... #);
          <B>getText</B><A name="XtEnv.1:StringArray.2:getText.3(217)"></A><A name="getText.3(217)"></A>: 
            (* Exits a copy of the text of THIS(StringArray) added as
             * number n
             *)
            (# n: @integer;
               t: ^text;
            enter n
            do ...;
            exit t[]
            #);
          <B>changeText</B><A name="XtEnv.1:StringArray.2:changeText.3(218)"></A><A name="changeText.3(218)"></A>: 
            (* Changes the text of THIS(StringArray) added as number
             * n
             *)
            (# n: @integer;
               newtext: ^text;
            enter (n, newtext[]) 
            do ...;
            #);
          <B>addText</B><A name="XtEnv.1:StringArray.2:addText.3(219)"></A><A name="addText.3(219)"></A>: 
            (* Adds a new text to
             * THIS(StringArray). THIS(StringArray) is extended if
             * needed.
             *)
            (# t: ^text;
            enter t[] 
            do ...;
            #);
          &lt;&lt;SLOT StringArrayLib: attributes&gt;&gt;;
          <B>private</B><A name="XtEnv.1:StringArray.2:private.3(220)"></A><A name="private.3(220)"></A>: @...;
          <B>address</B><A name="XtEnv.1:StringArray.2:address.3(221)"></A><A name="address.3(221)"></A>:
            (* Address of externally allocated string array  *)
            IntegerValue(# ... #);
       exit address
       #);

     <B>private</B><A name="XtEnv.1:private.2(222)"></A><A name="private.2(222)"></A>: @...;
     
     (* Aliases to use in Composite *)
     <B>bcore</B><A name="XtEnv.1:bcore.2(223)"></A><A name="bcore.2(223)"></A>: core(##);
     
     (* sbrandt: Additions needed be XsystemEnv: *)
     <B>doSetup</B><A name="XtEnv.1:doSetup.2(224)"></A><A name="doSetup.2(224)"></A>: 
       (# 
       do (if not setupDone then
              ...; 
              true -&gt; setupDone 
          if)
       #);
     <B>setupDone</B><A name="XtEnv.1:setupDone.2(225)"></A><A name="setupDone.2(225)"></A>: @Boolean;
     <B>XsystemEnvPresent</B><A name="XtEnv.1:XsystemEnvPresent.2(226)"></A><A name="XsystemEnvPresent.2(226)"></A>: @Boolean; 
     (* TRUE if this is a XsystemEnv program.  In this case,
      * callbacks are executed by a separate thread as synchronisation
      * via semaphores between x-callbacks and other coroutines would
      * not be possible otherwise. (It could lead to suspend of
      * coroutines with C stackparts.  If TRUE,
      * XsystemEnvHandleCallback should not be NONE.
      *)
     <B>XsystemEnvHandleCallbackP</B><A name="XtEnv.1:XsystemEnvHandleCallbackP.2(227)"></A><A name="XsystemEnvHandleCallbackP.2(227)"></A>: 
       (# <B>cb</B><A name="XtEnv.1:XsystemEnvHandleCallbackP.2:cb.3(228)"></A><A name="cb.3(228)"></A>: ^Object; enter cb[] do INNER #);
     <B>XsystemEnvHandleCallback</B><A name="XtEnv.1:XsystemEnvHandleCallback.2(229)"></A><A name="XsystemEnvHandleCallback.2(229)"></A>: 
       ^XsystemEnvHandleCallbackP;
     
  do doSetup;
     INNER; ...
  #) (* xtenv *)

--- compositeLib: attributes ---

(* Redefinition of patterns within Composites: Use the Composite as
 * default father
 *)
<B>core</B><A name="core.1(230)"></A>: bcore
  (# <B>init</B><A name="core.1:init.2(231)"></A><A name="init.2(231)"></A>::&lt; (# <B>getFatherWidget</B><A name="core.1:init.2:getFatherWidget.3(232)"></A><A name="getFatherWidget.3(232)"></A>::&lt; (# do this(composite)-&gt;value #) do INNER #)#)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="events.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
