<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Awenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="awenv">Awenv Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'xtenv';
BODY 'private/awenvbody';
INCLUDE 'athena/awlib';
(*
 * The BETA interface to the Athena widget set. The Athena widget set
 * is build on top of Xt and it contains user interface elements like
 * scrollbars, commands buttons, menus, etc.
 * 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-97 
 *       All rights reserved.
 *)

--- xtenvlib: attributes --- 

<B>Sme</B><A name="Sme.1(1)"></A>: RectObj
  (* The Sme (simple menu entry) gadget is the base class for all
   * menu entries. While this pattern is mainly intended to be a
   * superpattern, it may be used in a menu to add blank space between
   * menu entries.
   *)
  (# &lt;&lt;SLOT smeLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Sme.1:init.2(2)"></A><A name="init.2(2)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then SmeObjectClass -&gt; value if) 
            #)
       do INNER
       #);
  #) (* Sme *);

<B>SmeBSB</B><A name="SmeBSB.1(3)"></A>: sme
  (* The SmeBSB (simple menu entry composed of a bitmap, a string and
   * a bitmap) gadget is used to create a menu entry that contains a
   * string, and optional bitmaps in its left and right margins. Since
   * each menu entry is an independent object, the application is able
   * to change the font, colour, height, and other attributes of the
   * menu entries, on an entry by entry basis.
   *)
  (# &lt;&lt;SLOT smeBSBLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="SmeBSB.1:init.2(4)"></A><A name="init.2(4)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then SmeBSBObjectClass -&gt; value if)
            #)
       do INNER;
       #);
     
     (* SmeBSB resources *)
     <B>label</B><A name="SmeBSB.1:label.2(5)"></A><A name="label.2(5)"></A>:
       (* This is a the string that will be displayed in the menu
        * entry. The exact location of this string within the bounds
        * of the menu entry is controlled by the leftMargin,
        * right-Margin, vertSpace, and justify attributes.
        *)
       StringResource(# resourceName::&lt; XtNlabel #);
     <B>font</B><A name="SmeBSB.1:font.2(6)"></A><A name="font.2(6)"></A>: (* The font used to display the text label *)
       IntegerResource(# resourceName::&lt; XtNFont #);
     <B>foreground</B><A name="SmeBSB.1:foreground.2(7)"></A><A name="foreground.2(7)"></A>: 
       (* A pixel value which indexes the SimpleMenu's colormap to
        * derive the foreground colour of the menu entry's window.
        * This colour is also used to render all 1's in the left and
        * right bitmaps.
        *)
       IntegerResource(# resourceName::&lt; XtNForeGround #);
     <B>justify</B><A name="SmeBSB.1:justify.2(8)"></A><A name="justify.2(8)"></A>: 
       (* How the label is to be rendered between the left and right
        * margins when the space is wider than the actual text. This
        * attribute may be specified with the values XtJustifyLeft,
        * XtJustifyCenter, or XtJustifyRight.
        *)
       IntegerResource(# resourceName::&lt; XtNJustify #);
     <B>leftBitmap</B><A name="SmeBSB.1:leftBitmap.2(9)"></A><A name="leftBitmap.2(9)"></A>: 
       (* The bitmap to display in the left margin of the menu entry.
        * All 1's in the bitmap will be rendered in the foreground
        * colour, and all 0's will be drawn in the background colour
        * of the SimpleMenu widget. It is the programmers
        * responsibility to make sure that the menu entry is tall
        * enough, and the appropriate margin wide enough to accept the
        * bitmap. If care is not taken the bitmap may extend into
        * another menu entry, or into this entry's label. See also
        * fileToBitmap.
        *)
       IntegerResource(# resourceName::&lt; XtNleftBitmap #);
     <B>rightBitmap</B><A name="SmeBSB.1:rightBitmap.2(10)"></A><A name="rightBitmap.2(10)"></A>: 
       (* The bitmap to display in the right margin of the menu
        * entry.  See also leftBitmap
        *)
       IntegerResource(# resourceName::&lt; XtNrightBitmap #);
     <B>leftMargin</B><A name="SmeBSB.1:leftMargin.2(11)"></A><A name="leftMargin.2(11)"></A>:
       (* The amount of space (in pixels) that will be left between
        * the left edge of the menu entry and the label string.
        *)
       ShortResource(# resourceName::&lt; XtNleftMargin #);
     <B>rightMargin</B><A name="SmeBSB.1:rightMargin.2(12)"></A><A name="rightMargin.2(12)"></A>:
       (* The amount of space (in pixels) that will be left between
        * the right edge of the menu entry and the label string.
        *)
       ShortResource(# resourceName::&lt; XtNrightMargin #);
     <B>vertSpace</B><A name="SmeBSB.1:vertSpace.2(13)"></A><A name="vertSpace.2(13)"></A>: 
       (* The amount of vertical padding, expressed as a percentage
        * of the height of the font, that is to be placed around the
        * label of a menu entry. The label and bitmaps are always
        * centered vertically within the menu. The default value for
        * this attribute (25) causes the default height to be 125% of
        * the height of the font.
        *)
       IntegerResource(# resourceName::&lt; XtNVertSpace #);
     
     <B>installcallbacks</B><A name="SmeBSB.1:installcallbacks.2(14)"></A><A name="installcallbacks.2(14)"></A>::&lt; 
       (* Install the "callback" virtual, so that it is invoked when
        * the user has selected THIS(SmeBSB).
        *)
       (# do ...; INNER #);
  #) (* SmeBSB *);

<B>SmeLine</B><A name="SmeLine.1(15)"></A>: sme
  (* The SmeLine gadget is used to add a horizontal line or menu
   * separator to a menu. Since each menu entry is an independent
   * object, the application is able to change the colour, height, and
   * other attributes of the menu entries, on an entry by entry
   * basis. THIS(SmeLine) is not selectable, and will not highlight
   * when the pointer cursor is over it.
   *)
  (# &lt;&lt;SLOT smeLineLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="SmeLine.1:init.2(16)"></A><A name="init.2(16)"></A>::&lt;
       (# widgetClass::&lt;
            (# do INNER;
               (if value=0 then SmeLineObjectClass -&gt; value if)
            #)
       do INNER
       #);
     
     (* SmeLine resources *)
     <B>foreground</B><A name="SmeLine.1:foreground.2(17)"></A><A name="foreground.2(17)"></A>: 
       (* A pixel value which indexes the colormap of the SimpleMenu
        * of which THIS(SmeLine) is a child to derive the foreground
        * colour used to draw the separator line.
        *)
       IntegerResource(# resourceName::&lt; XtNForeGround #);
     <B>lineWidth</B><A name="SmeLine.1:lineWidth.2(18)"></A><A name="lineWidth.2(18)"></A>: 
       (* The width of the horizontal line that is to be
        * displayed. I.e., it is actually the height.
        *)
       IntegerResource(# resourceName::&lt; XtNLineWidth #);
     <B>stipple</B><A name="SmeLine.1:stipple.2(19)"></A><A name="stipple.2(19)"></A>: 
       (* If a bitmap is specified for this attribute, the line will
        * be stippled through it. This allows the menu separator to be
        * rendered as something more exciting than just a line. For
        * instance, if you define a stipple that is a chain link, then
        * your menu separators will look like chains.
        *)
       IntegerResource(# resourceName::&lt; XtNStipple #);
  #) (* SmeLine *);

<B>SmeCascade</B><A name="SmeCascade.1(20)"></A>: smeBSB
  (* The SmeCascade object is used to add a cascading submenu to
   * another menu.  When the user points inside THIS(SmeCascade), the
   * submenu is popped up to the right of the item. The user can then
   * select among the items of the cascaded menu.
   * 
   * Since each menu entry is an independent object, the application
   * is able to change the colour, height, and other attributes of the
   * menu entries, on an entry by entry basis.
   *)
  (# &lt;&lt;SLOT smeCascadeLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="SmeCascade.1:init.2(21)"></A><A name="init.2(21)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then SmeCascadeObjectClass -&gt; value if) 
            #)
       do INNER
       #);
     
     <B>subMenu</B><A name="SmeCascade.1:subMenu.2(22)"></A><A name="subMenu.2(22)"></A>: 
       (* The submenu that is popped up when THIS(SmeCascade) is
        * selected.
        *)
       IntegerResource(# resourceName::&lt; XtNSubMenu #);
  #) (* SmeCascade *);

<B>SimpleMenu</B><A name="SimpleMenu.1(23)"></A>: OverrideShell
  (* The SimpleMenu widget is a container for the menu entries.  This
   * is the only part of the menu that actually contains a window. The
   * SimpleMenu serves as the glue to bind the individual menu entries
   * together into a menu.  The SimpleMenu widget is itself a direct
   * subclass of OverrideShell, therefore no other shell is necessary
   * when creating a menu. The children of a SimpleMenu must be
   * subclasses of Sme (Simple Menu Entry).  See also MenuButton.
   *)
  (# &lt;&lt;SLOT simpleMenuLIB: attributes&gt;&gt;;
     
     (* Convenient aliases for menu entries *)
     <B>item</B><A name="SimpleMenu.1:item.2(24)"></A><A name="item.2(24)"></A>: smeBSB(# #);
     <B>blank</B><A name="SimpleMenu.1:blank.2(25)"></A><A name="blank.2(25)"></A>: sme(# #);
     <B>line</B><A name="SimpleMenu.1:line.2(26)"></A><A name="line.2(26)"></A>: smeLine(# #);
     <B>cascade</B><A name="SimpleMenu.1:cascade.2(27)"></A><A name="cascade.2(27)"></A>: smeCascade(# #);
     
     <B>init</B><A name="SimpleMenu.1:init.2(28)"></A><A name="init.2(28)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then simpleMenuWidgetClass-&gt;value if)
            #);
       do INNER;
       #);
     
     (* SimpleMenu resources *)
     <B>backingStore</B><A name="SimpleMenu.1:backingStore.2(29)"></A><A name="backingStore.2(29)"></A>: 
       IntegerResource(# resourceName::&lt; XtNBackingStore #);
     <B>bottomMargin</B><A name="SimpleMenu.1:bottomMargin.2(30)"></A><A name="bottomMargin.2(30)"></A>: 
       (* The amount of space between the bottom of the menu and the
        * menu entry closest to that edge.
        *)
       ShortResource(# resourceName::&lt; XtNBottomMargin #);
     <B>topMargin</B><A name="SimpleMenu.1:topMargin.2(31)"></A><A name="topMargin.2(31)"></A>: 
       (* The amount of space between the top of the menu and the
        * menu entry closest to that edge.
        *)
       ShortResource(# resourceName::&lt; XtNTopMargin #);
     <B>cursor</B><A name="SimpleMenu.1:cursor.2(32)"></A><A name="cursor.2(32)"></A>: 
       (* The shape of the mouse pointer whenever it is in this
        * widget.
        *)
       IntegerResource(# resourceName::&lt; XtNCursor #);
     <B>label</B><A name="SimpleMenu.1:label.2(33)"></A><A name="label.2(33)"></A>: 
       (* This label will be placed at the top of THIS(SimpleMenu),
        * and will not be highlighted.  menuLabel will return the
        * corresponding widget object.
        *)
       IntegerResource(# resourceName::&lt; XtNLabel #);
     <B>menuLabel</B><A name="SimpleMenu.1:menuLabel.2(34)"></A><A name="menuLabel.2(34)"></A>: IntegerValue
       (* The widget showing the label *)
       (# do (thewidget, 'menuLabel') -&gt; XtNameToWidget -&gt; value #);
     <B>labelClass</B><A name="SimpleMenu.1:labelClass.2(35)"></A><A name="labelClass.2(35)"></A>: 
       (* Specifies the type of Sme object created as the menu
        * label. Can be smeObjectClass, smeBSBObjectClass or
        * SmeLineObjectClass
        *)
       IntegerResource(# resourceName::&lt; XtNlabelClass #);
     <B>menuOnScreen</B><A name="SimpleMenu.1:menuOnScreen.2(36)"></A><A name="menuOnScreen.2(36)"></A>: 
       (* If this attribute is True then when the menu is on the
        * screen it will always be fully visible.
        *)
       BooleanResource(# resourceName::&lt; XtNmenuOnScreen #);
     <B>popupOnEntry</B><A name="SimpleMenu.1:popupOnEntry.2(37)"></A><A name="popupOnEntry.2(37)"></A>:
       (* When the menu is popped up, it will by default pop it up
        * with the first item selected. To popup the menu under
        * another entry, set this attribute to the menu entry that
        * should be under the pointer, when it is popped up. This
        * allows the application to offer the user a default menu
        * entry, that can be selected without moving the pointer.
        *)
       IntegerResource(# resourceName::&lt; XtNpopupOnEntry #);
     <B>rowHeight</B><A name="SimpleMenu.1:rowHeight.2(38)"></A><A name="rowHeight.2(38)"></A>: 
       (* If this attribute is 0 (default) then each menu entry will
        * be given its desired height. Otherwise all menu entries will
        * be forced to be rowheight pixels high.
        *)
       ShortResource(# resourceName::&lt; XtNrowHeight #);
     
     (* Redeclarations of Sme and subpatterns to use THIS(SimpleMenu)
      * as father, if no father is specified in init
      *)
     <B>SmeBSB</B><A name="SimpleMenu.1:SmeBSB.2(39)"></A><A name="SmeBSB.2(39)"></A>: bsmeBSB
       (# init::&lt; 
            (# getFatherWidget::&lt; (# do THIS(SimpleMenu).theWidget-&gt;value #);
            do INNER
            #)
       #);
     <B>Sme</B><A name="SimpleMenu.1:Sme.2(40)"></A><A name="Sme.2(40)"></A>: bsme
       (# init::&lt;
            (# getFatherWidget::&lt;(# do THIS(SimpleMenu).theWidget-&gt;value #);
            do INNER
            #)
       #);
     <B>SmeLine</B><A name="SimpleMenu.1:SmeLine.2(41)"></A><A name="SmeLine.2(41)"></A>: bsmeLine
       (# init::&lt;
            (# getFatherWidget::&lt; (# do THIS(SimpleMenu).theWidget-&gt;value #);
            do INNER
            #)
       #);
     <B>SmeCascade</B><A name="SimpleMenu.1:SmeCascade.2(42)"></A><A name="SmeCascade.2(42)"></A>: bsmeCascade
       (# init::&lt;
            (# getFatherWidget::&lt; (# do THIS(SimpleMenu).theWidget-&gt;value #);
            do ...; INNER
            #)
       #);
  #) (* SimpleMenu *);

<B>MenuButton</B><A name="MenuButton.1(43)"></A>: Command
  (# &lt;&lt;SLOT menuButtonLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="MenuButton.1:init.2(44)"></A><A name="init.2(44)"></A>::&lt;
       (# widgetClass::&lt;
            (#
            do INNER; 
               (if value=0 then menuButtonWidgetClass -&gt; value if)
            #)
       do ...;
          INNER 
       #);
     
     <B>menuName</B><A name="MenuButton.1:menuName.2(45)"></A><A name="menuName.2(45)"></A>: 
       StringResource(# resourceName::&lt; XtNMenuName #);
     
     <B>setMenu</B><A name="MenuButton.1:setMenu.2(46)"></A><A name="setMenu.2(46)"></A>: 
       (# m: ^simpleMenu
       enter m[]
       do m.name -&gt; menuName
       #);
  #) (* MenuButton *);

<B>Simple</B><A name="Simple.1(47)"></A>: Core
  (* The simple widget is not very useful by itself, as it has no
   * semantics of its own. Its main purpose is to be used as a common
   * superclass for the other simple Athena widgets. Provides a
   * rectangular area with a settable mouse cursor and special border.
   *)
  (# &lt;&lt;SLOT simpleLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Simple.1:init.2(48)"></A><A name="init.2(48)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then simpleWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     <B>cursor</B><A name="Simple.1:cursor.2(49)"></A><A name="cursor.2(49)"></A>: 
       (* The image that will be displayed as the pointer cursor
        * whenever it is in THIS(Simple).
        *)
       IntegerResource(# resourceName::&lt; XtNCursor #);
     <B>insensitiveBorder</B><A name="Simple.1:insensitiveBorder.2(50)"></A><A name="insensitiveBorder.2(50)"></A>:
       (* This may contain a pixelmap, that will be tiled into the
        * widget's border, if the widget becomes insensitive.
        *)
       IntegerResource(# resourceName::&lt; XtNInsensitiveBorder #);
  #) (* Simple *);

<B>StripChart</B><A name="StripChart.1(51)"></A>: Simple
  (* The StripChart widget is used to provide a real time graphical
   * chart of a single value.  This widget is used by xload to provide
   * the load graph.  It will read data from an application, and
   * update the chart at the update interval specified.
   *)
  (# &lt;&lt;SLOT stripChartLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="StripChart.1:init.2(52)"></A><A name="init.2(52)"></A>::&lt;
       (# widgetClass::&lt;
            (#
            do INNER; 
               (if value=0 then stripChartWidgetClass-&gt;value if)
            #)
       do INNER;
       #);
     <B>foreground</B><A name="StripChart.1:foreground.2(53)"></A><A name="foreground.2(53)"></A>:
       (* A pixel value which indexes the widget's colormap to derive
        * the color that will be used to draw the graph.
        *)
       IntegerResource(# resourceName::&lt; XtNForeground #);
     <B>highlight</B><A name="StripChart.1:highlight.2(54)"></A><A name="highlight.2(54)"></A>:
       (* A pixel value which indexes the widget's colormap to derive
        * the color that will be used to draw the scale lines on the
        * graph.
        *)
       IntegerResource(# resourceName::&lt; XtNHighLight #);
     <B>jumpScroll</B><A name="StripChart.1:jumpScroll.2(55)"></A><A name="jumpScroll.2(55)"></A>: 
       (* When the graph reaches the right edge of the window it must
        * be scrolled to the left.  This attribute specifies the
        * number of pixels it will jump.  Smooth scrolling can be
        * achieved by setting this attribute to 1.
        *)
       IntegerResource(# resourceName::&lt; XtNJumpScroll #);
     <B>minScale</B><A name="StripChart.1:minScale.2(56)"></A><A name="minScale.2(56)"></A>:
       (* The minimum scale for the graph.  The number of divisions
        * on the graph will always be greater than or equal to this
        * value.
        *)
       IntegerResource(# resourceName::&lt; XtNMinScale #);
     <B>update</B><A name="StripChart.1:update.2(57)"></A><A name="update.2(57)"></A>: 
       (* The number of seconds between graph updates.  Each update
        * is represented on the graph as a 1 pixel wide line.  Every
        * update seconds the getValue virtual pattern will be called
        * to get a new graph point, and this point will be added to
        * the right end of THIS(StripChart).
        *)
       IntegerResource(# resourceName::&lt; XtNUpdate #);
     
     <B>getValue</B><A name="StripChart.1:getValue.2(58)"></A><A name="getValue.2(58)"></A>:&lt;
       (* This virtual method will be called every "update" seconds
        * to get a new graph point. This pattern must be further bound
        * by the application to compute the new value. The value is an
        * integer-quotient that should be between 0 and 1. The value
        * is set by a call to the local pattern setQuotient. E.g. the
        * new value is set to 1/2 by the call (1,2) -&gt; setQuotient
        *)
       (# <B>valueAddr</B><A name="StripChart.1:getValue.2:valueAddr.3(59)"></A><A name="valueAddr.3(59)"></A>: @integer;
          <B>setQuotient</B><A name="StripChart.1:getValue.2:setQuotient.3(60)"></A><A name="setQuotient.3(60)"></A>: 
            (# q,r: @integer
            enter (q,r)
            do (valueAddr,q,r) -&gt; setDoubleFromQuot
            #)
       enter valueAddr
       do INNER
       #);
     <B>installCallbacks</B><A name="StripChart.1:installCallbacks.2(61)"></A><A name="installCallbacks.2(61)"></A>::&lt; (* Install the getValue virtual *)
       (# do ...; INNER #);
  #) (* StripChart *);

<B>Toggle</B><A name="Toggle.1(62)"></A>: Command
  (* The Toggle widget is an area, often rectangular, containing a
   * text label or bitmap image.  This widget maintains a Boolean
   * state (e.g. True/False or On/Off) and changes state whenever it
   * is selected.  When the pointer is on the button, the button may
   * become highlighted by drawing a rectangle around its perimeter.
   * This highlighting indicates that the button is ready for
   * selection.  When pointer button 1 is pressed and released, the
   * Toggle widget indicates that it has changed state by reversing
   * its foreground and background colors, and its virtual method
   * callback is invoked.  If the pointer is moved out of the widget
   * before the button is released, the widget reverts to its normal
   * foreground and background colors, and releasing the button has no
   * effect.  This behavior allows the user to cancel an action.
   * 
   * Toggle buttons may also be part of a radio group.  A radio group
   * is a list of at least two Toggle buttons in which no more than
   * one Toggle may be set at any time.  A radio group is identified
   * by any one of its members.
   *)
  (# &lt;&lt;SLOT toggleLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Toggle.1:init.2(63)"></A><A name="init.2(63)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then toggleWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     
     <B>radiodata</B><A name="Toggle.1:radiodata.2(64)"></A><A name="radiodata.2(64)"></A>:
       (* Specifies the data that will be returned by GetCurrent when
        * this is the currently set widget in the radio group.  This
        * value is also used to identify the Toggle that will be set
        * by a call to SetCurrent.  The value 0 will be returned by
        * GetCurrent if no widget in a radio group is currently set.
        * Programmers must not specify 0 as radioData.
        *)
       IntegerResource(# resourceName::&lt; XtNRadioData #);
     <B>radiogroup</B><A name="Toggle.1:radiogroup.2(65)"></A><A name="radiogroup.2(65)"></A>:
       (* Specifies another Toggle widget that is in the radio group
        * to which this Toggle widget should be added.  A radio group
        * is a group of at least two Toggle widgets, only one of which
        * may be set at a time.  If this value is NULL (the default)
        * then the Toggle will not be part of any radio group and can
        * change state without affecting any other Toggle widgets.  If
        * the widget specified in this attribute is not already in a
        * radio group then a new radio group will be created
        * containing these two Toggle widgets.  No Toggle widget can
        * be in multiple radio groups.  The behavior of a radio group
        * of one toggle is undefined.
        *)
       IntegerResource(# resourceName::&lt; XtNRadioGroup #);
     <B>state</B><A name="Toggle.1:state.2(66)"></A><A name="state.2(66)"></A>: 
       (* Specifies whether the Toggle widget is set (True) or unset
        * (False).
        *)
       BooleanResource(# resourceName::&lt; XtNState #);
     
     <B>getCurrent</B><A name="Toggle.1:getCurrent.2(67)"></A><A name="getCurrent.2(67)"></A>: IntegerValue
       (* Use this pattern to get the radiodata of the current set
        * Toggle in the group. If no toggle in the radio group is
        * selected then 0 is returned.
        *)
       (# do theWidget -&gt; XawToggleGetCurrent -&gt; value #);
     <B>setCurrent</B><A name="Toggle.1:setCurrent.2(68)"></A><A name="setCurrent.2(68)"></A>: 
       (* To change the Toggle that is currently set in a radiogroup
        * use this pattern.  It takes as enter-parameter the radiodata
        * of the Toggle to set.
        *)
       (# data: @integer
       enter data
       do (theWidget,data) -&gt; xawToggleSetCurrent
       #);
     <B>unsetCurrent</B><A name="Toggle.1:unsetCurrent.2(69)"></A><A name="unsetCurrent.2(69)"></A>:
       (* Unsets all Toggle widgets in a radiogroup *) 
       (# do theWidget -&gt; XawToggleUnsetCurrent #);
  #) (* Toggle *);

<B>Label</B><A name="Label.1(70)"></A>: Simple
  (* A Label widget is a text string or bitmap displayed within a
   * rectangular region of the screen. The label may contain multiple
   * lines of characters.  The Label widget will allow its string to
   * be left, right, or center justified. Normally, this widget can be
   * neither selected nor directly edited by the user. It is intended
   * for use as an output device only.
   *)
  (# &lt;&lt;SLOT labelLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Label.1:init.2(71)"></A><A name="init.2(71)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then labelWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     
     (* Label resources *)
     <B>label</B><A name="Label.1:label.2(72)"></A><A name="label.2(72)"></A>: 
       (* A text that specifies the text to be displayed in the
        * widget's window if no bitmap is specified. The default is
        * the name of the widget.  Newline characters will become
        * newlines.
        *)
       StringResource(# resourceName::&lt; XtNlabel #);
     <B>bitmap</B><A name="Label.1:bitmap.2(73)"></A><A name="bitmap.2(73)"></A>: 
       (* A bitmap to display instead of the label. The default size
        * of the widget will be just large enough to contain the
        * bitmap and the widget's internal width and height.
        *)
       IntegerResource(# resourceName::&lt; XtNBitmap #);
     <B>font</B><A name="Label.1:font.2(74)"></A><A name="font.2(74)"></A>: (* The text font to use when displaying the label. *)
       IntegerResource(# resourceName::&lt; XtNFont #);
     <B>foreground</B><A name="Label.1:foreground.2(75)"></A><A name="foreground.2(75)"></A>: 
       (* A pixel value which indexes the widget's colormap to derive
        * the foreground colour of the widgets window.
        *)
       IntegerResource(# resourceName::&lt; XtNForeground #);
     <B>internalHeight</B><A name="Label.1:internalHeight.2(76)"></A><A name="internalHeight.2(76)"></A>:
       (* The minimum amount of space to leave between the label or
        * bitmap and the horizontal edges of the window
        *)
       ShortResource(# resourceName::&lt; XtNinternalHeight #);
     <B>internalWidth</B><A name="Label.1:internalWidth.2(77)"></A><A name="internalWidth.2(77)"></A>: 
       (* The minimum amount of space to leave between the label or
        * bitmap and the vertical edges of the window
        *)
       ShortResource(# resourceName::&lt; XtNinternalWidth #);
     <B>justify</B><A name="Label.1:justify.2(78)"></A><A name="justify.2(78)"></A>: 
       (* Specifies left, center, or right alignment of label within
        * the widget. This value may be specified with the symbolic
        * constants XtJustifyLeft, XtJustifyCenter, or
        * XtJustifyRight. This value only has noticeable effect when
        * the width of the widget is larger than necessary to display
        * the label.
        *)
       IntegerResource(# resourceName::&lt; XtNjustify #);
     <B>resize</B><A name="Label.1:resize.2(79)"></A><A name="resize.2(79)"></A>: 
       (* A boolean which specifies whether the widget should attempt
        * to resize to its preferred dimensions whenever one of it
        * attribute are modified. This attempt to resize may be denied
        * by the parent of this widget. The parent is always free to
        * resize the widget regardless of the state of resize.
        *)
       BooleanResource(# resourceName::&lt; XtNresize #);
  #) (* label *);

<B>Grip</B><A name="Grip.1(80)"></A>: Simple
  (* The Grip widget provides a small rectangular region in which
   * user input events (such as ButtonPress or ButtonRelease) may be
   * handled. The most common use for the Grip widget is as an
   * attachment point for visually repositioning an object, such as
   * the pane border in a Paned widget.
   *)
  (# &lt;&lt;SLOT gripLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Grip.1:init.2(81)"></A><A name="init.2(81)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then gripWidgetClass -&gt; value if) 
            #)
       do INNER
       #);
     
     <B>foreground</B><A name="Grip.1:foreground.2(82)"></A><A name="foreground.2(82)"></A>: 
       (* A pixel value which indexes the widget's colormap to derive
        * the colour used to flood fill the entire Grip widget.
        *)
       IntegerResource(# resourceName::&lt; XtNForeground #);
     
     <B>installCallbacks</B><A name="Grip.1:installCallbacks.2(83)"></A><A name="installCallbacks.2(83)"></A>::&lt; 
       (* Install the "callback" virtual. "callback" will be called
        * when a user event occurs.
        *)
       (# do ...; INNER #);
  #) (* Grip *);

<B>Scrollbar</B><A name="Scrollbar.1(84)"></A>: Simple
  (* The Scrollbar widget is a rectangular area containing a slide
   * region and a thumb (also known as a slide bar).  A Scrollbar can
   * be used alone, as a value generator, or it can be used within a
   * composite widget (for example, a Viewport).  A Scrollbar can be
   * oriented either vertically or horizontally.
   * 
   * When a Scrollbar is created, it is drawn with the thumb in a
   * contrasting color.  The thumb is normally used to scroll client
   * data and to give visual feedback on the percentage of the client
   * data that is visible.
   * 
   * Each pointer button invokes a specific action.  That is, given
   * either a vertical or horizontal orientation, the pointer button
   * actions will scroll or return data as appropriate for that
   * orientation.  Pointer buttons 1 and 3 do not move the thumb
   * automatically.  Instead, they return the pixel position of the
   * cursor on the scroll region.  When pointer button 2 is clicked,
   * the thumb moves to the current pointer position.  When pointer
   * button 2 is held down and the pointer is moved, the thumb follows
   * the pointer.
   * 
   * The pointer cursor in the scroll region changes depending on the
   * current action.  When no pointer button is pressed, the cursor
   * appears as a double-headed arrow that points in the direction
   * that scrolling can occur.  When pointer button 1 or 3 is pressed,
   * the cursor appears as a single-headed arrow that points in the
   * logical direction that the client will move the data.  When
   * pointer button 2 is pressed, the cursor appears as an arrow that
   * points to the thumb.
   * 
   * While scrolling is in progress, the application receives
   * notification through callback virtual patterns.  For both
   * discrete scrolling actions, the callback gives the pixel position
   * of the pointer when the button was released.  For continuous
   * scrolling, the callback routine gives the current relative
   * position of the thumb.  When the thumb is moved using pointer
   * button 2, the callback procedure is invoked continuously.  When
   * either button 1 or 3 is pressed, the callback procedure is
   * invoked only when the button is released and the further binding
   * af the callback procedure is responsible for moving the thumb.
   *)
  (# &lt;&lt;SLOT scrollbarLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Scrollbar.1:init.2(85)"></A><A name="init.2(85)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then scrollbarWidgetClass-&gt;value if)
            #)
       do INNER 
       #);
     <B>resolution</B><A name="Scrollbar.1:resolution.2(86)"></A><A name="resolution.2(86)"></A>:&lt; (* The resolution to use in floatRessource *)
       IntegerObject(# do 100 -&gt; value ; INNER #);     
     
     (* Scrollbar resources *)
     <B>floatResource</B><A name="Scrollbar.1:floatResource.2(87)"></A><A name="floatResource.2(87)"></A>: 
       (# set: (* Set THIS(floatResource) to value/resolution *)
            (# value: @integer;
            enter value
            do ...;
            #);
          get: (* Exits resolution*value of THIS(floatResource) *)
            (# value: @integer
            do ...;
            exit value
            #);
          resourceName:&lt; IntegerObject;
       enter set
       exit get
       #);
     <B>cursor</B><A name="Scrollbar.1:cursor.2(88)"></A><A name="cursor.2(88)"></A>: 
       IntegerResource(# resourceName::&lt; XtNCursor #); 
     <B>foreground</B><A name="Scrollbar.1:foreground.2(89)"></A><A name="foreground.2(89)"></A>: 
       (* A pixel value which indexes the widget's colormap to derive
        * the color used to draw the thumb.
        *)
       IntegerResource(# resourceName::&lt; XtNforeGround#); 
     <B>length</B><A name="Scrollbar.1:length.2(90)"></A><A name="length.2(90)"></A>: 
       (* The height of a vertical scrollbar or the width of a
        * horizontal scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNlength #); 
     <B>minimumThumb</B><A name="Scrollbar.1:minimumThumb.2(91)"></A><A name="minimumThumb.2(91)"></A>: 
       (* The smallest size, in pixels, to which the thumb can
        * shrink.
        *)
       ShortResource(# resourceName::&lt; XtNMinimumThumb #); 
     <B>scrollDCursor</B><A name="Scrollbar.1:scrollDCursor.2(92)"></A><A name="scrollDCursor.2(92)"></A>: 
       (* This cursor is used when scrolling backward in a vertical
        *         scrollbar.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollDCursor #); 
     <B>scrollHCursor</B><A name="Scrollbar.1:scrollHCursor.2(93)"></A><A name="scrollHCursor.2(93)"></A>: 
       (* This cursor is used when a horizontal scrollbar is
        * inactive.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollHCursor #); 
     <B>scrollLCursor</B><A name="Scrollbar.1:scrollLCursor.2(94)"></A><A name="scrollLCursor.2(94)"></A>: 
       (* This cursor is used when scrolling forward in a horizontal
        * scrollbar.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollLCursor #); 
     <B>scrollRCursor</B><A name="Scrollbar.1:scrollRCursor.2(95)"></A><A name="scrollRCursor.2(95)"></A>: 
       (* This cursor is used when scrolling backward in a horizontal
        * scrollbar, or when thumbing a vertical scrollbar.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollRCursor #); 
     <B>scrollUCursor</B><A name="Scrollbar.1:scrollUCursor.2(96)"></A><A name="scrollUCursor.2(96)"></A>: 
       (* This cursor is used when scrolling forward in a vertical
        * scrollbar, or when thumbing a horizontal scrollbar.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollUCursor #); 
     <B>scrollVCursor</B><A name="Scrollbar.1:scrollVCursor.2(97)"></A><A name="scrollVCursor.2(97)"></A>: 
       (* This cursor is used when a vertical scrollbar is inactive.
        *)
       IntegerResource(# resourceName::&lt; XtNScrollVCursor #); 
     <B>thumb</B><A name="Scrollbar.1:thumb.2(98)"></A><A name="thumb.2(98)"></A>: 
       (* This pixmap is used to tile (or stipple) the thumb of the
        * scrollbar.  If no tiling is desired, then set this attribute
        * to 0.  This resource will accept either a bitmap or a pixmap
        * that is the same depth as the window.
        *)
       IntegerResource(# resourceName::&lt; XtNThumb #); 
     <B>thickness</B><A name="Scrollbar.1:thickness.2(99)"></A><A name="thickness.2(99)"></A>:
       (* The width of a vertical scrollbar or the height of a
        * horizontal scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNThickNess #); 
     <B>orientation</B><A name="Scrollbar.1:orientation.2(100)"></A><A name="orientation.2(100)"></A>: 
       (* The orientation is the direction that the thumb will be
        * allowed to move. This value can be either XtOrientVertical
        * or XtOrientHorizontal. The "vertical" pattern provides a
        * more convenient interface.
        *)
       IntegerResource(# resourceName::&lt; XtNOrientation #); 
     <B>shown</B><A name="Scrollbar.1:shown.2(101)"></A><A name="shown.2(101)"></A>: 
       (* This is the size of the thumb, expressed as a percentage
        * (0-100) of the length of the scrollbar.
        *)
       floatResource(# resourceName::&lt; XtNShown #);
     <B>topOfThumb</B><A name="Scrollbar.1:topOfThumb.2(102)"></A><A name="topOfThumb.2(102)"></A>: 
       (* The location of the top of the thumb, as a percentage
        * (0-100) of the length of the scrollbar.
        *)
       floatResource(# resourceName::&lt; XtNTopOfThumb #); 
     <B>vertical</B><A name="Scrollbar.1:vertical.2(103)"></A><A name="vertical.2(103)"></A>: 
       (* A boolean that specifies whether the direction of the
        * scrollbar is vertical or horizontal.
        *)
       (# isVertical: @boolean
       enter isVertical
       do (if isVertical then
              XtOrientVertical -&gt; orientation
           else 
              XtOrientHorizontal -&gt; orientation
          if)
       #);
     
     <B>jumpProc</B><A name="Scrollbar.1:jumpProc.2(104)"></A><A name="jumpProc.2(104)"></A>:&lt; 
       (* This pattern is invoked on each new postion when button 2
        * is down and moves the thumb interactively.
        *)
       (# percent: @integer enter percent do INNER #);
     <B>scrollProc</B><A name="Scrollbar.1:scrollProc.2(105)"></A><A name="scrollProc.2(105)"></A>:&lt; 
       (* This pattern is invoked when pointer button 1 or 3 are
        * pressed for incremental scrolling.The local attribute
        * position is a signed integer. Button 1 returns a positive
        * value, and button 3 returns a negative value. In both cases,
        * the magnitude of the value is the distance of the pointer in
        * pixels from the top (or left) of the Scrollbar. The value
        * will never be greater than the length of the Scrollbar.
        *)
       (# position: @integer enter position do INNER #);
     <B>installCallBacks</B><A name="Scrollbar.1:installCallBacks.2(106)"></A><A name="installCallBacks.2(106)"></A>::&lt;
       (* Install the jumpProc and scrollProc virtuals *)
       (# do ...; INNER #);
  #) (* Scrollbar *);

<B>Command</B><A name="Command.1(107)"></A>: Label
  (* The Command widget is an area, often rectangular, that contains
   * a text label or bitmap image.  Those selectable areas are often
   * referred to as "buttons". When the pointer cursor is on a button,
   * it becomes highlighted by drawing a rectangle around its
   * perimeter. This highlighting indicates that the button is ready
   * for selection. When pointer button 1 is pressed, the Command
   * widget indicates that it has been selected by reversing its
   * foreground and background colours. When the button is released,
   * the Command widget's virtual pattern callback will be invoked. If
   * the pointer is moved out of the widget before the button is
   * released, the widget reverts to its normal foreground and
   * background colours, and releasing the button has no effect. This
   * behaviour allows the user to cancel an action.
   *)
  (# &lt;&lt;SLOT commandLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Command.1:init.2(108)"></A><A name="init.2(108)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then commandWidgetClass -&gt; value if)
            #)
       do INNER 
       #);
     
     (* Constants used for specifying shapeStyle *)
     <B>rectangle</B><A name="Command.1:rectangle.2(109)"></A><A name="rectangle.2(109)"></A>: (# exit XmuShapeRectangle #);
     <B>oval</B><A name="Command.1:oval.2(110)"></A><A name="oval.2(110)"></A>: (# exit XmuShapeOval #);
     <B>ellipse</B><A name="Command.1:ellipse.2(111)"></A><A name="ellipse.2(111)"></A>: (# exit XmuShapeEllipse #);
     <B>roundedRectangle</B><A name="Command.1:roundedRectangle.2(112)"></A><A name="roundedRectangle.2(112)"></A>: (# exit XmuShapeRoundedRectangle #);
     
     <B>shapeStyle</B><A name="Command.1:shapeStyle.2(113)"></A><A name="shapeStyle.2(113)"></A>: IntegerResource
       (* Nonrectangular buttons may be created using this pattern.
        * Nonrectangular buttons are supported only on a X Window
        * server that supports the Shape Extension. If nonrectangular
        * buttons are specified for a server lacking this extension,
        * the shape is ignored and the widgets will be
        * rectangular. The following shapes are currently supported:
        * rectangle, oval, ellipse, and roundedRectangle.
        *)
       (# resourceName::&lt; XtNshapeStyle #);
     <B>cornerRoundPercent</B><A name="Command.1:cornerRoundPercent.2(114)"></A><A name="cornerRoundPercent.2(114)"></A>: ShortResource
       (* When a ShapeStyle of roundedRectangle is used, this
        * attribute controls the radius of the rounded corner. The
        * radius of the rounded corners is specified as a percentage
        * of the length of the shortest side of the widget.
        *)
       (# resourceName::&lt; XtNCornerRoundPercent #);
     <B>highlightThickness</B><A name="Command.1:highlightThickness.2(115)"></A><A name="highlightThickness.2(115)"></A>: 
       (* The thickness of the rectangle that is used to highlight
        * the internal border of this widget, alerting the user that
        * it is ready to be selected. The default value is 2 pixels if
        * the shapeStyle is rectangle, and 0 pixels (no highlighting)
        * otherwise.
        *) 
       ShortResource(# resourceName::&lt; XtNHighlightThickness #);
     
     <B>installCallbacks</B><A name="Command.1:installCallbacks.2(116)"></A><A name="installCallbacks.2(116)"></A>::&lt; 
       (* Install the "callback" virtual *)
       (# do ...; INNER #);
  #) (* Command *);

<B>Form</B><A name="Form.1(117)"></A>: Constraint
  (* The Form widget can contain an arbitrary number of children or
   * subwidgets. The Form provides geometry management for its
   * children, which allows individual control of the position of each
   * child. Any combination of children can be added to a Form. The
   * initial positions of the children may be computed relative to the
   * positions of other children. When the Form is resized, it
   * computes new positions and sizes for its children. This
   * computation is based upon information provided for each child.
   * 
   * The default width of the Form is the minimum width needed to
   * enclose the children after computing their initial layout, with a
   * margin of defaultDistance at the right and bottom edges. If a
   * width and height is assigned to the Form that is too small for
   * the layout, the children will be clipped by the right and bottom
   * edges of the Form.
   *)
  (# &lt;&lt;SLOT FormLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Form.1:init.2(118)"></A><A name="init.2(118)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then formWidgetClass -&gt; value if)
            #)
       do INNER 
       #);
     
     <B>defaultDistance</B><A name="Form.1:defaultDistance.2(119)"></A><A name="defaultDistance.2(119)"></A>: 
       (* The default internal spacing for the children. This is the
        * default value for the attributes horizDistance and
        * vertDistance for the children.
        *)
       IntegerResource(# resourceName::&lt; XtNDefaultDistance #);
     
     (* Convenience routines for chaining the children *)
     <B>FixChildSize</B><A name="Form.1:FixChildSize.2(120)"></A><A name="FixChildSize.2(120)"></A>:
       (* Chain vertical edges to left, horizontal edges to top *)
       (# child: ^THIS(xtenv).core;
       enter child[]
       do ...;
       #);
     
     (* Constants used for specifying constraints on children *)
     <B>chainTop</B><A name="Form.1:chainTop.2(121)"></A><A name="chainTop.2(121)"></A>: (# exit XawChainTop #);
     <B>chainLeft</B><A name="Form.1:chainLeft.2(122)"></A><A name="chainLeft.2(122)"></A>: (# exit XawChainLeft #);
     <B>chainBottom</B><A name="Form.1:chainBottom.2(123)"></A><A name="chainBottom.2(123)"></A>: (# exit XawChainBottom #);
     <B>chainRight</B><A name="Form.1:chainRight.2(124)"></A><A name="chainRight.2(124)"></A>: (# exit XawChainRight #);
     <B>rubber</B><A name="Form.1:rubber.2(125)"></A><A name="rubber.2(125)"></A>: (# exit XawRubber #);
     
     <B>doLayout</B><A name="Form.1:doLayout.2(126)"></A><A name="doLayout.2(126)"></A>: 
       (* Force or defer re-layout of THIS(form). Takes a boolean
        * parameter that specifies if changes to the children should
        * result in a new layout. When making several changes to the
        * children of a Form widget after the Form has been realized,
        * it is a good idea to disable relayout until after all
        * changes have been made.
        *)
       (# doIt: @boolean
       enter doIt
       do (if doit then
              (thewidget,1) -&gt; xawFormDoLayout
           else
              (thewidget,0) -&gt; xawFormDoLayout
          if);
       #);
  #) (* Form *);

<B>Paned</B><A name="Paned.1(127)"></A>: Constraint
  (* The Paned widget manages children in a vertically or
   * horizontally tiled fashion. The panes may be dynamically resized
   * by the user by using the grips that appear near the right or
   * bottom edge of the border between two panes.
   * 
   * The Paned widget may accept any widget class as a pane except
   * Grip. Grip widgets have a special meaning for the Paned widget,
   * and adding a Grip as its own pane will confuse the Paned widget.
   * 
   * The grips allow the panes to be resized by the user. The
   * semantics of how these panes resize is somewhat complicated, and
   * warrants further explanation here. When the mouse pointer is
   * positioned on a grip and pressed, an arrow is displayed that
   * indicates the pane that is to be to be resized. While keeping the
   * mouse button down, the user can move the grip up and down (or
   * left and right). This, in turn, changes the size of the pane. The
   * size of the Paned widget will not change.  Instead, it chooses
   * another pane (or panes) to resize.
   *)
  (# &lt;&lt;SLOT panedLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Paned.1:init.2(128)"></A><A name="init.2(128)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER; 
               (if value=0 then panedWidgetClass -&gt; value if) 
            #)
       do INNER
       #);
     
     <B>cursor</B><A name="Paned.1:cursor.2(129)"></A><A name="cursor.2(129)"></A>: 
       (* The cursor to use when the mouse pointer is over the Paned
        * widget, but not in any of its children (children may also
        * inherit this cursor). It should be noted that the internal
        * borders are actually part of the Paned widget, not the
        * children.
        *)
       IntegerResource(# resourceName::&lt; XtNcursor #);
     <B>gripCursor</B><A name="Paned.1:gripCursor.2(130)"></A><A name="gripCursor.2(130)"></A>: 
       (* The cursor to use when the grips are not active. The
        * default value is verticalGripCursor or horizontalGripCursor
        * depending on the orientation of the Paned widget.
        *)
       IntegerResource(# resourceName::&lt; XtNGripCursor #);
     <B>horizontalBetweenCursor</B><A name="Paned.1:horizontalBetweenCursor.2(131)"></A><A name="horizontalBetweenCursor.2(131)"></A>: 
       (* The cursor to be used for the grip when changing the
        * boundary between two panes. This attribute allows the
        * cursors to be different depending on the orientation of the
        * Paned widget.
        *)
       IntegerResource(# resourceName::&lt;XtNhorizontalBetweenCursor #);
     <B>verticalBetweenCursor</B><A name="Paned.1:verticalBetweenCursor.2(132)"></A><A name="verticalBetweenCursor.2(132)"></A>:
       (* The cursor to be used for the grip when changing the
        * boundary between two panes. This attribute allows the
        * cursors to be different depending on the orientation of the
        * Paned widget.
        *)
       IntegerResource(# resourceName::&lt; XtNverticalBetweenCursor #);
     <B>horizontalGripCursor</B><A name="Paned.1:horizontalGripCursor.2(133)"></A><A name="horizontalGripCursor.2(133)"></A>: 
       (* The cursor to be used for the grips when they are not
        * active. This attribute allows the cursors to be different
        * depending on the orientation of the Paned widget.
        *)
       IntegerResource(# resourceName::&lt; XtNhorizontalGripCursor #);
     <B>verticalGripCursor</B><A name="Paned.1:verticalGripCursor.2(134)"></A><A name="verticalGripCursor.2(134)"></A>: 
       (* The cursor to be used for the grips when they are not
        * active. This attribute allows the cursors to be different
        * depending on the orientation of the Paned widget.
        *)
       IntegerResource(# resourceName::&lt; XtNverticalGripCursor #);
     <B>gripIndent</B><A name="Paned.1:gripIndent.2(135)"></A><A name="gripIndent.2(135)"></A>: 
       (* The amount of space left between the right (or bottom) edge
        * of the Paned widget and all the grips.
        *)
       ShortResource(# resourceName::&lt; XtNGripIndent #);
     <B>gripTranslation</B><A name="Paned.1:gripTranslation.2(136)"></A><A name="gripTranslation.2(136)"></A>: 
       (* Translation table that will be applied to all grips *)
       IntegerResource(# resourceName::&lt; XtNGripTranslation #);
     <B>internalBorderWidth</B><A name="Paned.1:internalBorderWidth.2(137)"></A><A name="internalBorderWidth.2(137)"></A>:
       (* The width of the internal borders. This is the amount of
        * space left between the panes.
        *)
       ShortResource(# resourceName::&lt; XtNInternalBorderWidth #);
     <B>internalBorderColor</B><A name="Paned.1:internalBorderColor.2(138)"></A><A name="internalBorderColor.2(138)"></A>: 
       (* A pixel value which indexes the widget's colormap to derive
        * the internal border colour of the widget's window.
        *)
       IntegerResource(# resourceName::&lt; XtNInternalBorderColor #);
     <B>leftCursor</B><A name="Paned.1:leftCursor.2(139)"></A><A name="leftCursor.2(139)"></A>: 
       (* The cursor used to indicate that the left pane is the
        * important one to resize when the Paned widget is oriented
        * horizontally.
        *)
       IntegerResource(# resourceName::&lt; XtNLeftCursor #);
     <B>rightCursor</B><A name="Paned.1:rightCursor.2(140)"></A><A name="rightCursor.2(140)"></A>:
       (* The cursor used to indicate that the right pane is the
        * important one to resize when the Paned widget is oriented
        * horizontally.
        *)
       IntegerResource(# resourceName::&lt; XtNRightCursor #);
     <B>lowerCursor</B><A name="Paned.1:lowerCursor.2(141)"></A><A name="lowerCursor.2(141)"></A>:
       (* The cursor used to indicate that the pane below is the
        * important one to resize when the Paned widget is oriented
        * vertically.
        *)
       IntegerResource(# resourceName::&lt; XtNLowerCursor #);
     <B>upperCursor</B><A name="Paned.1:upperCursor.2(142)"></A><A name="upperCursor.2(142)"></A>: 
       (* The cursor used to indicate that the pane above is the
        * important one to resize when the Paned widget is oriented
        * vertically.
        *)
       IntegerResource(# resourceName::&lt; XtNUpperCursor #);
     <B>orientation</B><A name="Paned.1:orientation.2(143)"></A><A name="orientation.2(143)"></A>: 
       (* The orientation to stack the panes. This value can be
        * either XtOrientVertical or XtOrientHorizontal.  The
        * "vertical" pattern provides a more convenient interface.
        *)
       IntegerResource(# resourceName::&lt; XtNOrientation #);
     <B>refigureMode</B><A name="Paned.1:refigureMode.2(144)"></A><A name="refigureMode.2(144)"></A>: 
       (* This attribute allows pane layout to be suspended. If the
        * value is False, then no layout actions will be taken. This
        * may improve efficiency when adding or removing more than one
        * pane from the Paned widget.
        *)
       BooleanResource(# resourceName::&lt; XtNRefigureMode #);
     <B>vertical</B><A name="Paned.1:vertical.2(145)"></A><A name="vertical.2(145)"></A>: 
       (* A boolean that specifies the orientation of the stack of
        * panes.
        *)
       (# isVertical: @boolean
       enter isVertical
       do (if isVertical then
              XtOrientVertical -&gt; orientation
           else
              XtOrientHorizontal -&gt; orientation
          if)
       #);
     
     <B>GetNumSub</B><A name="Paned.1:GetNumSub.2(146)"></A><A name="GetNumSub.2(146)"></A>: IntegerValue
       (* Exits the number of panes in THIS(Paned) *)
       (# do theWidget -&gt; XawPanedGetNumSub -&gt; value #);
  #) (* Paned *);

<B>Dialog</B><A name="Dialog.1(147)"></A>: Form
  (* The Dialog widget implements a commonly used interaction
   * semantic to prompt for auxiliary input from a user. For example,
   * you can use a Dialog widget when an application requires a small
   * piece of information, such as a filename, from the user. A Dialog
   * widget, which is simply a special case of the Form widget,
   * provides a convenient way to create a preconfigured Form.
   * 
   * The typical Dialog widget contains three areas. The first line
   * contains a description of the function of the Dialog widget, for
   * example, the string 'Filename:'. The second line contains an area
   * into which the user types input. The third line can contain
   * buttons that let the user confirm or cancel the Dialog input. Any
   * of these areas may be omitted by the application.
   *)
  (# &lt;&lt;SLOT dialogLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Dialog.1:init.2(148)"></A><A name="init.2(148)"></A>::&lt;
       (# widgetClass::&lt;
            (#
            do INNER;
               (if value=0 then dialogWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     
     <B>label</B><A name="Dialog.1:label.2(149)"></A><A name="label.2(149)"></A>: (* A string to be displayed at the top of THIS(Dialog) *)
       StringResource(# resourceName::&lt; XtNLabel #);
     <B>value</B><A name="Dialog.1:value.2(150)"></A><A name="value.2(150)"></A>: 
       (* An initial value for the string field that the user will
        * enter text into. By default, no text entry field is
        * available to the user.  Specifying an initial value for
        * value activates the text entry field.  If string input is
        * desired, but no initial value is to be specified then set
        * this attribute to '' (empty text).
        *)
       StringResource(# resourceName::&lt; XtNValue #);
     <B>icon</B><A name="Dialog.1:icon.2(151)"></A><A name="icon.2(151)"></A>: 
       (* A pixmap image to be displayed immediately to the left of
        * the label of THIS(Dialog).
        *)
       IntegerResource(# resourceName::&lt; XtNIcon #);
     <B>getValue</B><A name="Dialog.1:getValue.2(152)"></A><A name="getValue.2(152)"></A>: (* Returns the text in the value field *)
       (# value: ^text; do ... exit value[] #);
     <B>labelWidget</B><A name="Dialog.1:labelWidget.2(153)"></A><A name="labelWidget.2(153)"></A>: IntegerValue
       (* The subwidget holding the label *)
       (# do (thewidget, 'label') -&gt; XtNameToWidget -&gt; value #);
     <B>iconWidget</B><A name="Dialog.1:iconWidget.2(154)"></A><A name="iconWidget.2(154)"></A>: IntegerValue
       (* The subwidget holding the icon *)
       (# do (thewidget, 'icon') -&gt; XtNameToWidget -&gt; value #);
     <B>valueWidget</B><A name="Dialog.1:valueWidget.2(155)"></A><A name="valueWidget.2(155)"></A>: IntegerValue
       (* The subwidget holding the value *)
       (# do (thewidget, 'value') -&gt; XtNameToWidget -&gt; value #);
  #) (* Dialog *);

<B>Box</B><A name="Box.1(156)"></A>: Composite
  (* The Box widget provides geometry management of arbitrary widgets
   * in a box of a specified dimension. The children are rearranged
   * when resizing events occur either on the Box or its children, or
   * when children are managed or unmanaged. The Box widget always
   * attempts to pack its chil- dren as tightly as possible within the
   * geometry allowed by its parent.
   * 
   * Box widgets are commonly used to manage a related set of buttons
   * and are often called ButtonBox widgets, but the children are not
   * limited to buttons. The Box's children are arranged on a
   * background that has its own specified dimensions and colour.
   *)
  (#  &lt;&lt;SLOT boxLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="Box.1:init.2(157)"></A><A name="init.2(157)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then boxWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     
     (* Box resources *)
     <B>hSpace</B><A name="Box.1:hSpace.2(158)"></A><A name="hSpace.2(158)"></A>: 
       (* The amount of space, in pixels, to leave between the
        * children. This attribute also specifies the amount of space
        * left between the outermost children and the vertical edge of
        * THIS(Box).
        *)
       ShortResource(# resourceName::&lt; XtNHSpace #);
     <B>vSpace</B><A name="Box.1:vSpace.2(159)"></A><A name="vSpace.2(159)"></A>: 
       (* The amount of space, in pixels, to leave between the
        * children. This attribute also specifies the amount of space
        * left between the outermost children and the horizontal edge
        * of THIS(Box).
        *)
       ShortResource(# resourceName::&lt; XtNVSpace #);
     <B>orientation</B><A name="Box.1:orientation.2(160)"></A><A name="orientation.2(160)"></A>: 
       (* Specifies whether the preferred shape of THIS(Box) is tall
        * and narrow (XawOrientVertical) or short and wide
        * (XawOrientHorizontal).  The "vertical" pattern provides a
        * more convenient interface.
        *)
       IntegerResource(# resourceName::&lt; XtNOrientation #);
     <B>vertical</B><A name="Box.1:vertical.2(161)"></A><A name="vertical.2(161)"></A>: 
       (* A boolean that specifies whether the preferred shape of
        * THIS(Box) is tall and narrow or short and wide. When
        * THIS(Box) is a child of a parent which enforces width
        * constraints, it is usually better to specify true (the
        * default). When the parent enforces height constraints, it is
        * usually better to specify false.
        *)
       (# isVertical: @boolean
       enter isVertical
       do (if isVertical then
              XtOrientVertical -&gt; orientation
           else
              XtOrientHorizontal -&gt; orientation
          if)
       #);
  #) (* box *);

<B>ViewPort</B><A name="ViewPort.1(162)"></A>: Form
  (* The ViewPort widget consists of a frame window, one or two
   * Scrollbars, and an INNER window.  The size of the frame window is
   * determined by the viewing size of the data that is to be
   * displayed and the dimensions to which the ViewPort is
   * created. The INNER window is the full size of the data that is to
   * be displayed and is clipped by the frame window. The ViewPort
   * widget controls the scrolling of the data directly. No
   * application code are required for the scrolling.
   * 
   * When the geometry of the frame window is equal in size to the
   * INNER window, or when the data does not require scrolling, the
   * ViewPort widget automatically removes any scrollbars. The
   * forceBar option causes the ViewPort widget to display all
   * scrollbars permanently.
   *)
  (# &lt;&lt;SLOT ViewPortLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="ViewPort.1:init.2(163)"></A><A name="init.2(163)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then ViewPortWidgetClass -&gt; value if)
            #)
       do INNER
       #);
     
     <B>allowHoriz</B><A name="ViewPort.1:allowHoriz.2(164)"></A><A name="allowHoriz.2(164)"></A>: 
       (* If this attributes is False then THIS(ViewPort) will never
        * create a horizontal scrollbar. If it is True then the
        * scrollbar will only appear when it is needed, unless
        * forceBars is True.
        *)
       BooleanResource(# resourceName::&lt; XtNAllowHoriz #);
     <B>allowVert</B><A name="ViewPort.1:allowVert.2(165)"></A><A name="allowVert.2(165)"></A>:
       (* If this attributes is False then THIS(ViewPort) will never
        * create a vertical scrollbar. If it is True then the
        * scrollbar will only appear when it is needed, unless
        * forceBars is True.
        *)
       BooleanResource(# resourceName::&lt; XtNAllowVert #);
     <B>forceBars</B><A name="ViewPort.1:forceBars.2(166)"></A><A name="forceBars.2(166)"></A>: 
       (* When True the scrollbars that have been allowed will always
        * be visible on the screen. If False the scrollbars will be
        * visible only when the INNER window is larger than the frame.
        *)
       BooleanResource(# resourceName::&lt; XtNForceBars #);
     <B>useBottom</B><A name="ViewPort.1:useBottom.2(167)"></A><A name="useBottom.2(167)"></A>:
       (* By default the scrollbars appear on the left and top of the
        * screen.  This attribute allows the horizontal scrollbar to
        * be placed on the bottom edge of THIS(ViewPort).
        *)
       BooleanResource(# resourceName::&lt; XtNuseBottom #);
     <B>useRight</B><A name="ViewPort.1:useRight.2(168)"></A><A name="useRight.2(168)"></A>:
       (* By default the scrollbars appear on the left and top of the
        * screen.  This attribute allows the vertical scrollbar to be
        * placed on the right edge of THIS(ViewPort).
        *)
       BooleanResource(# resourceName::&lt; XtNuseRight #);
  #) (* ViewPort *);

<B>ListWidget</B><A name="ListWidget.1(169)"></A>: Simple
  (* The List widget contains a list of strings formatted into rows
   * and columns. When one of the strings is selected, it is
   * highlighted, and the List widget's virtual pattern callback is
   * invoked.  Only one string may be selected at a time.
   *)
  (# &lt;&lt;SLOT listWidgetLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="ListWidget.1:init.2(170)"></A><A name="init.2(170)"></A>::&lt; (# widgetClass::&lt; (# do ... #);
       do INNER;
       #);
     <B>strings</B><A name="ListWidget.1:strings.2(171)"></A><A name="strings.2(171)"></A>:&lt; StringArray
       (* Further bind to specify initial contents *)
       (# #);
     <B>getStrings</B><A name="ListWidget.1:getStrings.2(172)"></A><A name="getStrings.2(172)"></A>: 
       (* The current content of THIS(ListWidget). Updated by "init"
        * and "change".
        *)
       (# s: ^StringArray 
       do ...
       exit s[]
       #);
     
     (* ListWidget resources *)
     <B>list</B><A name="ListWidget.1:list.2(173)"></A><A name="list.2(173)"></A>:
       (* An array of text strings displayed in THIS(ListWidget). *)
       StringArrayResource(# resourceName::&lt; XtNList #);
     <B>columnSpacing</B><A name="ListWidget.1:columnSpacing.2(174)"></A><A name="columnSpacing.2(174)"></A>: 
       (* The amount of space, in pixels, between each of the columns
        * in THIS(ListWidget).
        *)
       ShortResource(# resourceName::&lt; XtNColumnSpacing #);
     <B>rowSpacing</B><A name="ListWidget.1:rowSpacing.2(175)"></A><A name="rowSpacing.2(175)"></A>: 
       (* The amount of space, in pixels, between each of the rows in
        * THIS(ListWidget).
        *)
       ShortResource(# resourceName::&lt; XtNRowSpacing #);
     <B>defaultColumns</B><A name="ListWidget.1:defaultColumns.2(176)"></A><A name="defaultColumns.2(176)"></A>: 
       (* The default number of columns. This value is used when
        * neither the width nor the height of THIS(ListWidget) is
        * specified or when forceColumns is True.
        *)
       IntegerResource(# resourceName::&lt; XtNDefaultColumns #);
     <B>forceColumns</B><A name="ListWidget.1:forceColumns.2(177)"></A><A name="forceColumns.2(177)"></A>: 
       (* If this boolean is true it forces the default number of
        * columns to be used regardless of THIS(ListWidget)'s current
        * size.
        *)
       BooleanResource(# resourceName::&lt; XtNForceColumns #);
     <B>foreground</B><A name="ListWidget.1:foreground.2(178)"></A><A name="foreground.2(178)"></A>: 
       (* A pixel value which indexes the widget's colormap to derive
        * the colour used to paint the text of the list elements.
        *)
       IntegerResource(# resourceName::&lt; XtNForeground #);
     <B>pasteBuffer</B><A name="ListWidget.1:pasteBuffer.2(179)"></A><A name="pasteBuffer.2(179)"></A>:
       (* If this attribute is set to True then the name of the
        * currently selected list element will be put into the
        * clipboard of the X Window System.
        *)
       BooleanResource(# resourceName::&lt; XtNPasteBuffer #);
     <B>internalHeight</B><A name="ListWidget.1:internalHeight.2(180)"></A><A name="internalHeight.2(180)"></A>: 
       (* The minimum amount of space to leave between edges of the
        * list and the horizontal edges of THIS(ListWidget)
        *)
       IntegerResource(# resourceName::&lt; XtNinternalHeight #);
     <B>internalWidth</B><A name="ListWidget.1:internalWidth.2(181)"></A><A name="internalWidth.2(181)"></A>:
       (* The minimum amount of space to leave between edges of the
        * list and the vertical edges of THIS(ListWidget)
        *)
       IntegerResource(# resourceName::&lt; XtNinternalWidth #);
     <B>longest</B><A name="ListWidget.1:longest.2(182)"></A><A name="longest.2(182)"></A>: 
       (* Specifies the width, in pixels, of the longest string in
        * the current list. THIS(ListWidget) will compute this value
        * if zero (the default) is specified.
        *) 
       IntegerResource(# resourceName::&lt; XtNlongest #);
     <B>numberStrings</B><A name="ListWidget.1:numberStrings.2(183)"></A><A name="numberStrings.2(183)"></A>: 
       (* The number of strings in the current list. If a value of
        * zero (the default) is specified, the List widget will
        * compute it.
        *)
       IntegerResource(# resourceName::&lt; XtNNumberStrings #);
     
     <B>change</B><A name="ListWidget.1:change.2(184)"></A><A name="change.2(184)"></A>: 
       (* To change the elements of THIS(ListWidget) this method must
        * be called.  It takes as enter parameter a StringArray (list)
        * and a boolean (resize). List specifies the new list to
        * display. If resize is true, it specifies that
        * THIS(ListWidget) should try to resize itself after making
        * the change.
        *)
       (# list: ^StringArray;
          resize: @boolean
       enter (list[],resize)
       do ...;
       #);
     
     <B>callback</B><A name="ListWidget.1:callback.2(185)"></A><A name="callback.2(185)"></A>::&lt;
       (* This pattern is invoked when an item in the list have been
        * selected.  Current.listindex is an integer which contains
        * the index of the item that have been selected. The indexing
        * starts from 0, e.g. if the second item of the list have been
        * selected, current.listIndex will be 1. Current.string exits
        * the string in the selected item.
        *)
       (# current: @XawListReturnStruct
       do theWidget -&gt; XawListShowCurrent -&gt; current.ptr;
          INNER;
       #);
     <B>installcallbacks</B><A name="ListWidget.1:installcallbacks.2(186)"></A><A name="installcallbacks.2(186)"></A>::&lt; (* Install the "callback" virtual *)
       (# do ...; INNER #);
     <B>private</B><A name="ListWidget.1:private.2(187)"></A><A name="private.2(187)"></A>: @...;
  #) (* ListWidget *);

<B>AsciiText</B><A name="AsciiText.1(188)"></A>: Simple 
  (* The AsciiText widget provides a window that will allow an
   * application to display and edit one or more lines of
   * text. Options are provided to allow the user to add Scrollbars to
   * its window, search for a specific string, and modify the text in
   * the buffer.
   *)
  (# &lt;&lt;SLOT asciiTextLIB: attributes&gt;&gt;;
     
     <B>init</B><A name="AsciiText.1:init.2(189)"></A><A name="init.2(189)"></A>::&lt;
       (# widgetClass::&lt;
            (# 
            do INNER;
               (if value=0 then asciiTextWidgetClass -&gt; value if)
            #)
       do INNER 
       #);
     <B>installCallbacks</B><A name="AsciiText.1:installCallbacks.2(190)"></A><A name="installCallbacks.2(190)"></A>::&lt;
       (* Install the "callback" virtual. It will be called every
        * time the text buffer changes
        *) 
       (# do ...; INNER #);
     
     (* AsciiText resources *)
     <B>string</B><A name="AsciiText.1:string.2(191)"></A><A name="string.2(191)"></A>: 
       (* If type is AsciiString then this string contains the buffer
        * to be displayed in the widget. If type is AsciiFile then the
        * string contains the name of the file to be displayed.
        *)
       StringResource(# resourceName::&lt; XtNString #);
     <B>editType</B><A name="AsciiText.1:editType.2(192)"></A><A name="editType.2(192)"></A>: 
       (* This is the type of editing that will be allowed in
        * THIS(AsciiText).  Legal values are read, edit, and append.
        *)
       IntegerResource(# resourceName::&lt; XtNEditType #);
     <B>autoFill</B><A name="AsciiText.1:autoFill.2(193)"></A><A name="autoFill.2(193)"></A>: 
       (* If this attribute is True THIS(AsciiText) will
        * automatically break a line when the user attempts to type
        * into the right margin.  The attribute has no effect on files
        * or text inserted into the asciiText widget. It only checks
        * to see if the action should be taken when a user enters a
        * new character.
        *)
       BooleanResource(# resourceName::&lt; XtNAutoFill #);
     <B>bottomMargin</B><A name="AsciiText.1:bottomMargin.2(194)"></A><A name="bottomMargin.2(194)"></A>: 
       (* The amount of space, in pixels, between the bottom edge of
        * the window and the bottom edge of the text within the
        * window. If there is a scrollbar active on this edge, then
        * this is the space between the text and the scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNBottomMargin #);
     <B>topMargin</B><A name="AsciiText.1:topMargin.2(195)"></A><A name="topMargin.2(195)"></A>:
       (* The amount of space, in pixels, between the top edge of the
        * window and the top edge of the text within the window. If
        * there is a scrollbar active on this edge, then this is the
        * space between the text and the scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNTopMargin #);
     <B>rightMargin</B><A name="AsciiText.1:rightMargin.2(196)"></A><A name="rightMargin.2(196)"></A>:
       (* The amount of space, in pixels, between the right edge of
        * the window and the right edge of the text within the
        * window. If there is a scrollbar active on this edge, then
        * this is the space between the text and the scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNRightMargin #);
     <B>leftMargin</B><A name="AsciiText.1:leftMargin.2(197)"></A><A name="leftMargin.2(197)"></A>: 
       (* The amount of space, in pixels, between the left edge of
        * the window and the left edge of the text within the
        * window. If there is a scrollbar active on this edge, then
        * this is the space between the text and the scrollbar.
        *)
       ShortResource(# resourceName::&lt; XtNLeftMargin #);
     <B>displayPosition</B><A name="AsciiText.1:displayPosition.2(198)"></A><A name="displayPosition.2(198)"></A>: 
       (* The position in the text buffer of the character that is
        * currently displayed in the upper left hand corner of the
        * text display.
        *)
       IntegerResource(# resourceName::&lt; XtNdisplayPosition #);
     <B>insertPosition</B><A name="AsciiText.1:insertPosition.2(199)"></A><A name="insertPosition.2(199)"></A>: 
       (* This is the location of the insert point. It is expressed
        * in characters from the beginning of the text. The cursor
        * will always be forced to be on the screen. This attribute
        * may therefore be used to scroll the text display to a
        * certain character position.
        *)
       IntegerResource(# resourceName::&lt; XtNinsertPosition #);
     <B>resize</B><A name="AsciiText.1:resize.2(200)"></A><A name="resize.2(200)"></A>: 
       (* Controls whether or not THIS(AsciiText) attempts to resize
        * itself when it is no longer able to display the full text
        * buffer in the associated window. Any attempt by
        * THIS(AsciiText) to resize itself is always subject to the
        * constraints imposed by its parent.  The values resizeNever,
        * resizeWidth, resizeHeight, and resizeBoth are all acceptable
        * for this attribute.
        *)
       BooleanResource(# resourceName::&lt; XtNresize #);
     <B>scrollHorizontal</B><A name="AsciiText.1:scrollHorizontal.2(201)"></A><A name="scrollHorizontal.2(201)"></A>: 
       (* This attribute controls the placement of scrollbar on the
        * left edge of THIS(AsciiText). The values accepted are
        * scrollAlways, scrollWhenNeeded, and scrollNever. If
        * scrollWhenNeeded is specified, the appropriate scrollbar
        * will only appear when there is text in the buffer that is
        * not able to fit within the bounds of the current window.
        * The scrollbar will disappear when the text once again fits
        * within the window.
        *)
       IntegerResource(# resourceName::&lt; XtNscrollHorizontal #);
     <B>scrollVertical</B><A name="AsciiText.1:scrollVertical.2(202)"></A><A name="scrollVertical.2(202)"></A>:
       (* This attribute controls the placement of scrollbar on the
        * bottom edge of THIS(AsciiText). The values accepted are
        * scrollAlways, scrollWhenNeeded, and scrollNever. If
        * scrollWhenNeeded is specified, the appropriate scrollbar
        * will only appear when there is text in the buffer that is
        * not able to fit within the bounds of the current window.
        * The scrollbar will disappear when the text once again fits
        * within the window.
        *)
       IntegerResource(# resourceName::&lt; XtNscrollVertical #);
     <B>selectTypes</B><A name="AsciiText.1:selectTypes.2(203)"></A><A name="selectTypes.2(203)"></A>: 
       (* Specifies the selection type array that is used when
        * multi-click is activated. Only for the advanced programmer.
        *)
       IntegerResource(# resourceName::&lt; XtNselectTypes #);
     <B>textSink</B><A name="AsciiText.1:textSink.2(204)"></A><A name="textSink.2(204)"></A>: 
       (* The TextSink subwidget used by THIS(AsciiText). Only to be
        * used by the advanced programmer
        *)
       IntegerResource(# resourceName::&lt; XtNtextSink #);
     <B>textSource</B><A name="AsciiText.1:textSource.2(205)"></A><A name="textSource.2(205)"></A>:
       (* The TextSource subwidget used by THIS(AsciiText). Only to
        * be used by the advanced programmer
        *)
       IntegerResource(# resourceName::&lt; XtNtextSource #);
     <B>wrap</B><A name="AsciiText.1:wrap.2(206)"></A><A name="wrap.2(206)"></A>: 
       (* When the text in any one line is wider than the window
        * there are several possible actions. This attribute allows
        * the user to decide what will happen. The accepted values for
        * this attribute are wrapNever, wrapLine, and wrapWord.  With
        * wrapLine all text that is beyond the right edge of the
        * window will be displayed on the next line. With wrapWord the
        * same action occurs but the text is broken at a word boundary
        * if possible. If no wrapping is enabled then the text will
        * extend off the edge of the window, and a small rectangle
        * will be painted in the right margin to alert the user that
        * this line is too long.
        *)
       IntegerResource(# resourceName::&lt; XtNwrap #);
     <B>dataCompression</B><A name="AsciiText.1:dataCompression.2(207)"></A><A name="dataCompression.2(207)"></A>: 
       (* The AsciiText uses an algorithm that may cause the text
        * buffer to grow to about twice the size of the actual text
        * over time, as the text is edited. On systems where CPU
        * cycles are cheaper than memory, it is helpful to spend some
        * extra time to compress this buffer back to its minimum
        * size. If this attribute is True, the asciiText will compress
        * its data to the minimum size required every time the text
        * string is saved, or the value of the string is queried.
        *)
       BooleanResource(# resourceName::&lt; XtNdataCompression #);
     <B>echo</B><A name="AsciiText.1:echo.2(208)"></A><A name="echo.2(208)"></A>: 
       (* Whether or not to echo characters to the screen. The buffer
        * can still be edited, but nothing is displayed. This mode can
        * be useful for entering passwords and other sensitive
        * information.
        *)
       IntegerResource(# resourceName::&lt; XtNecho #);
     <B>font</B><A name="AsciiText.1:font.2(209)"></A><A name="font.2(209)"></A>: 
       (* This is font for rendering all text and must be a character
        * cell font
        *)
       IntegerResource(# resourceName::&lt; XtNfont #);
     <B>foreground</B><A name="AsciiText.1:foreground.2(210)"></A><A name="foreground.2(210)"></A>:
       (* A pixel value which indexes the asciiText widget's colormap
        * to derive the foreground colour.
        *)
       IntegerResource(# resourceName::&lt; XtNForeground #);
     <B>length</B><A name="AsciiText.1:length.2(211)"></A><A name="length.2(211)"></A>: 
       (* If the useStringInPlace resource is False (default), this
        * resource has no effect. If that resource is true, however,
        * then the length resource specifies the length of the buffer
        * passed to the text widget in the string resource.
        *)
       IntegerResource(# resourceName::&lt; XtNlength #);
     <B>pieceSize</B><A name="AsciiText.1:pieceSize.2(212)"></A><A name="pieceSize.2(212)"></A>: 
       (* This is the size of the internal chunks into which the text
        * buffer is broken down for memory management. The larger this
        * value the less segmented your memory will be, but the slower
        * your editing will be.  THIS(AsciiText) will always allocate
        * a chunk of memory this size to stuff the string into, so
        * when using small strings, having this buffer large can waste
        * memory.
        *)
       IntegerResource(# resourceName::&lt; XtNpieceSize #);
     <B>type</B><A name="AsciiText.1:type.2(213)"></A><A name="type.2(213)"></A>: 
       (* This attribute may be either asciiString or asciiFile. The
        * value of this attribute determines whether the string
        * attribute contains the name of a file to be opened or a
        * buffer to be displayed by THIS(AsciiText).
        *)
       IntegerResource(# resourceName::&lt; XtNtype #);
     <B>useStringInPlace</B><A name="AsciiText.1:useStringInPlace.2(214)"></A><A name="useStringInPlace.2(214)"></A>: 
       (* Setting this resource to Trus will disable the memoru
        * management provided by the Text widget, updating the string
        * resource in place.  Using the string in place can be much
        * more efficient for text widgets that display static data, or
        * when the programmer wishes to impose strict constraints on
        * the contents of the string. When using the string in place
        * be sure that: The length of the string is specified by
        * setting the length resource, the type of THIS(AsciiText) is
        * asciiString, and that the string exists for the lifetime of
        * THIS(AsciiText), or until it has been reset.
        *) 
       IntegerResource(# resourceName::&lt; XtNUseStringInPlace #);
     <B>displayNonPrinting</B><A name="AsciiText.1:displayNonPrinting.2(215)"></A><A name="displayNonPrinting.2(215)"></A>:
       (* If this attributes is True, THIS(AsciiText) will display
        * all non-printable characters as the string ^@. If False,
        * THIS(AsciiText) will just leave a blank space where a
        * non-printable character exists in the text buffer.
        *)
       BooleanResource(# resourceName::&lt; XtNdisplayNonprinting #);
     
     (* Text selection *)
     <B>selection</B><A name="AsciiText.1:selection.2(216)"></A><A name="selection.2(216)"></A>: @
       (* The text that is selected by the AsciiText widget. Is
        * expressed as a start- and an end-position. The first
        * character in the text buffer is at position 0
        *)
       (# set:
            (# begin,end: @integer
            enter (begin,end)
            do (theWidget,begin,end) -&gt; XawTextSetSelection;
            #);
          unset: (* Unhighlight the previous highlighted text *)
            (# do theWidget -&gt; XawTextUnsetSelection #);
          get:
            (# begin,end: @XawTextPosition;
            do (theWidget,begin[],end[]) -&gt; xawTextGetSelectionPos;
            exit (begin,end)
            #);
       enter set
       exit get
       #);
     
     (* Conversion between text buffer positions and line and column
      * position
      *)
     <B>posToLineAndColumn</B><A name="AsciiText.1:posToLineAndColumn.2(217)"></A><A name="posToLineAndColumn.2(217)"></A>: 
       (* Convert a text buffer position to the line number and the
        * column number on that line.  Ranges: The position of the
        * first character in the buffer is 0.  The line number for the
        * first line is 1.  The first character on a line is at column
        * 1.  If the position entered is negative, 0 is used, and if
        * it is larger than the last position in the text buffer, the
        * last position is used instead.  The colunm number may be
        * incorrect if TABs are present on the line.
        *)
       (# position: @integer;
          line, column: @integer;
       enter position
       do ...;
       exit (line, column)
       #);
     <B>lineAndColumnToPos</B><A name="AsciiText.1:lineAndColumnToPos.2(218)"></A><A name="lineAndColumnToPos.2(218)"></A>: 
       (* Converts a line number and a column number to a text buffer
        * position.  Ranges: The position of the first character in
        * the buffer is 0.  The line number for the first line is 1.
        * The first character on a line is at column 1.  If the
        * entered line or column number is not positive, 1 is used
        * instead. If the entered line number is larger than the
        * number of the last line in the text buffer, the number of
        * the last line is used instead. If the entered column number
        * is larger than the number of columns on the line, the column
        * of the last character on the line is used instead.  The text
        * buffer position may be incorrect if TABS are present on the
        * line.
        *)
       (# line, column: @integer;
          position: @integer;
       enter (line,column)
       do ...
       exit position
       #);
     <B>displayCaret</B><A name="AsciiText.1:displayCaret.2(219)"></A><A name="displayCaret.2(219)"></A>:
       (* Make the caret be visible/invisible *)
       (# displayIt: @boolean;
       enter displayIt
       do (if displayIt then
              (theWidget, 1) -&gt; XawTextDisplayCaret;
           else
              (theWidget, 0) -&gt; XawTextDisplayCaret;
          if)
       #);
     <B>save</B><A name="AsciiText.1:save.2(220)"></A><A name="save.2(220)"></A>:
       (* If type is asciiFile, this operation saves the contents of
        * the text buffer in the file specified in the string
        * resource.
        *)
       (# do ... #);
     <B>saveAs</B><A name="AsciiText.1:saveAs.2(221)"></A><A name="saveAs.2(221)"></A>:
       (* Saves the contents of the text buffer in the file with the
        * name entered
        *)
       (# filename: ^text;
       enter filename[]
       do ...
       #);
     <B>changed</B><A name="AsciiText.1:changed.2(222)"></A><A name="changed.2(222)"></A>: 
       (* Exits a boolean indicating if the text buffer has been
        * changed since it was last saved or queried for changes.
        *)
       (# value: @boolean do ... exit value #);
     
     (* Constants for setting various resources *)
     
     <B>read</B><A name="AsciiText.1:read.2(223)"></A><A name="read.2(223)"></A>: (# exit XawTextRead #);
     <B>edit</B><A name="AsciiText.1:edit.2(224)"></A><A name="edit.2(224)"></A>: (# exit XawTextEdit #);
     <B>append</B><A name="AsciiText.1:append.2(225)"></A><A name="append.2(225)"></A>: (# exit XawTextAppend #);
     
     <B>resizeNever</B><A name="AsciiText.1:resizeNever.2(226)"></A><A name="resizeNever.2(226)"></A>: (# exit XawTextResizeNever #);
     <B>resizeWidth</B><A name="AsciiText.1:resizeWidth.2(227)"></A><A name="resizeWidth.2(227)"></A>: (# exit XawTextResizeWidth #);
     <B>resizeHeight</B><A name="AsciiText.1:resizeHeight.2(228)"></A><A name="resizeHeight.2(228)"></A>: (# exit XawTextResizeHeight #);
     <B>resizeBoth</B><A name="AsciiText.1:resizeBoth.2(229)"></A><A name="resizeBoth.2(229)"></A>: (# exit XawTextResizeBoth #);
     
     <B>scrollAlways</B><A name="AsciiText.1:scrollAlways.2(230)"></A><A name="scrollAlways.2(230)"></A>: (# exit XawTextScrollAlways #);
     <B>scrollWhenNeeded</B><A name="AsciiText.1:scrollWhenNeeded.2(231)"></A><A name="scrollWhenNeeded.2(231)"></A>: (# exit XawTextScrollWhenNeeded #); 
     <B>scrollNever</B><A name="AsciiText.1:scrollNever.2(232)"></A><A name="scrollNever.2(232)"></A>: (# exit XawTextScrollNever #); 
     
     <B>wrapNever</B><A name="AsciiText.1:wrapNever.2(233)"></A><A name="wrapNever.2(233)"></A>: (# exit XawTextwrapNever #);
     <B>wrapLine</B><A name="AsciiText.1:wrapLine.2(234)"></A><A name="wrapLine.2(234)"></A>: (# exit XawTextwrapLine #);
     <B>wrapWord</B><A name="AsciiText.1:wrapWord.2(235)"></A><A name="wrapWord.2(235)"></A>: (# exit XawTextwrapWord #);
     
     <B>asciiFile</B><A name="AsciiText.1:asciiFile.2(236)"></A><A name="asciiFile.2(236)"></A>: (# exit XawAsciiFile #);
     <B>asciiString</B><A name="AsciiText.1:asciiString.2(237)"></A><A name="asciiString.2(237)"></A>: (# exit XawAsciiString #);
     
  #) (* AsciiText *);

(* Alises to use in Composite *)
<B>blabel</B><A name="blabel.1(238)"></A>: label(# #);  
<B>bcommand</B><A name="bcommand.1(239)"></A>: command(# #); 
<B>bmenuButton</B><A name="bmenuButton.1(240)"></A>: menuButton(# #);
<B>btoggle</B><A name="btoggle.1(241)"></A>: toggle(# #);
<B>bsimple</B><A name="bsimple.1(242)"></A>: simple(# #);
<B>bstripChart</B><A name="bstripChart.1(243)"></A>: stripChart(# #);
<B>bgrip</B><A name="bgrip.1(244)"></A>: grip(# #);
<B>bscrollbar</B><A name="bscrollbar.1(245)"></A>: scrollbar(# #);
<B>bform</B><A name="bform.1(246)"></A>: form(# #);
<B>bpaned</B><A name="bpaned.1(247)"></A>: paned(# #);
<B>bdialog</B><A name="bdialog.1(248)"></A>: dialog(# #);
<B>bbox</B><A name="bbox.1(249)"></A>: box(# #);
<B>bViewPort</B><A name="bViewPort.1(250)"></A>: ViewPort(# #);
<B>blistWidget</B><A name="blistWidget.1(251)"></A>: listWidget(# #);
<B>basciiText</B><A name="basciiText.1(252)"></A>: asciiText(# #);
<B>bsme</B><A name="bsme.1(253)"></A>: sme(# #);
<B>bsmeBSB</B><A name="bsmeBSB.1(254)"></A>: smeBSB(# #);
<B>bsmeLine</B><A name="bsmeLine.1(255)"></A>: smeLine(# #);
<B>bsmeCascade</B><A name="bsmeCascade.1(256)"></A>: smeCascade(# #);

--- compositeLib: attributes ---

(* Redefinition of patterns within Composites: Use the Composite as
 * default father
 *)
<B>Label</B><A name="Label.1(257)"></A>: bLabel
  (# <B>init</B><A name="Label.1:init.2(258)"></A><A name="init.2(258)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #);
       do INNER #)
  #);
<B>Command</B><A name="Command.1(259)"></A>: bCommand
  (# <B>init</B><A name="Command.1:init.2(260)"></A><A name="init.2(260)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Toggle</B><A name="Toggle.1(261)"></A>: bToggle
  (# <B>init</B><A name="Toggle.1:init.2(262)"></A><A name="init.2(262)"></A>::&lt; 
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>MenuButton</B><A name="MenuButton.1(263)"></A>: bMenuButton
  (# <B>init</B><A name="MenuButton.1:init.2(264)"></A><A name="init.2(264)"></A>::&lt;
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Simple</B><A name="Simple.1(265)"></A>: bSimple
  (# <B>init</B><A name="Simple.1:init.2(266)"></A><A name="init.2(266)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #);
       do INNER #)
  #);
<B>StripChart</B><A name="StripChart.1(267)"></A>: bStripChart
  (# <B>init</B><A name="StripChart.1:init.2(268)"></A><A name="init.2(268)"></A>::&lt; 
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Grip</B><A name="Grip.1(269)"></A>: bGrip
  (# <B>init</B><A name="Grip.1:init.2(270)"></A><A name="init.2(270)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Scrollbar</B><A name="Scrollbar.1(271)"></A>: bScrollbar
  (# <B>init</B><A name="Scrollbar.1:init.2(272)"></A><A name="init.2(272)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Form</B><A name="Form.1(273)"></A>: bForm
  (# <B>init</B><A name="Form.1:init.2(274)"></A><A name="init.2(274)"></A>::&lt; 
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>Paned</B><A name="Paned.1(275)"></A>: bPaned
  (# <B>init</B><A name="Paned.1:init.2(276)"></A><A name="init.2(276)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #);
       do INNER #)
  #);
<B>Dialog</B><A name="Dialog.1(277)"></A>: bDialog
  (# <B>init</B><A name="Dialog.1:init.2(278)"></A><A name="init.2(278)"></A>::&lt; 
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #);
       do INNER #)
  #);
<B>Box</B><A name="Box.1(279)"></A>: bBox
  (# <B>init</B><A name="Box.1:init.2(280)"></A><A name="init.2(280)"></A>::&lt; 
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #);
       do INNER #)
  #);
<B>ViewPort</B><A name="ViewPort.1(281)"></A>: bViewPort
  (# <B>init</B><A name="ViewPort.1:init.2(282)"></A><A name="init.2(282)"></A>::&lt;
       (# getFatherWidget::&lt; (# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>ListWidget</B><A name="ListWidget.1(283)"></A>: bListWidget
  (# <B>init</B><A name="ListWidget.1:init.2(284)"></A><A name="init.2(284)"></A>::&lt; 
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);
<B>AsciiText</B><A name="AsciiText.1(285)"></A>: bAsciiText
  (# <B>init</B><A name="AsciiText.1:init.2(286)"></A><A name="init.2(286)"></A>::&lt;
       (# getFatherWidget::&lt;(# do THIS(composite).theWidget-&gt;value #); 
       do INNER #)
  #);

--- CoreLIB: attributes ---

(* Extra Constraint Attributes for children of paned.  Each child of
 * the Paned widget has a set of operations available to control the
 * layout.  These attributes allow the Paned widget's children to
 * specify individual layout requirements.
 *)
<B>allowResize</B><A name="allowResize.1(287)"></A>: 
  (* If this value is False, the Paned widget will disallow all
   * geometry requests from this child.
   *)
  BooleanResource(# <B>resourceName</B><A name="allowResize.1:resourceName.2(288)"></A><A name="resourceName.2(288)"></A>::&lt; XtNAllowResize #);
<B>minSize</B><A name="minSize.1(289)"></A>: 
  (* The absolute minimum size for this pane. This value will never
   * be overridden by the Paned widget. This may case some panes to
   * pushed off the bottom (or right) edge of the paned widget.
   *)
  IntegerResource(# <B>resourceName</B><A name="minSize.1:resourceName.2(290)"></A><A name="resourceName.2(290)"></A>::&lt; XtNMin #);
<B>maxSize</B><A name="maxSize.1(291)"></A>: 
  (* The absolute maximum size for this pane. This value will never
   * be overridden by the Paned widget. This may case some panes to
   * pushed off the bottom (or right) edge of the paned widget.
   *)
  IntegerResource(# <B>resourceName</B><A name="maxSize.1:resourceName.2(292)"></A><A name="resourceName.2(292)"></A>::&lt; XtNMax #);
<B>preferredPaneSize</B><A name="preferredPaneSize.1(293)"></A>: 
  (* Normally the paned widget asks the child to determine the pre-
   * ferred size of the child's pane. There are times when the
   * application programmer has a better idea of the preferred size of
   * a pane. Setting this attribute causes the value passed to be
   * interpreted as the preferred size, in pixels, of this pane.
   *)
  IntegerResource(# <B>resourceName</B><A name="preferredPaneSize.1:resourceName.2(294)"></A><A name="resourceName.2(294)"></A>::&lt; XtNpreferredPaneSize #);
<B>resizeToPreferred</B><A name="resizeToPreferred.1(295)"></A>:  
  (* Determines whether or not to resize each pane to its preferred
   * size when the Paned widget is resized.
   *)
  BooleanResource(# <B>resourceName</B><A name="resizeToPreferred.1:resourceName.2(296)"></A><A name="resourceName.2(296)"></A>::&lt; XtNresizeToPreferred#);
<B>showGrip</B><A name="showGrip.1(297)"></A>: 
  (* If True then a grip will be shown for this pane. The grip
   * associated with a pane is either below or to the right of the
   * pane. No grip is ever shown for the last pane.
   *)
  BooleanResource(# <B>resourceName</B><A name="showGrip.1:resourceName.2(298)"></A><A name="resourceName.2(298)"></A>::&lt; XtNShowGrip #);
<B>skipAdjust</B><A name="skipAdjust.1(299)"></A>:
  (* This attribute is used to determine which pane is forced to be
   * resized. Setting this value to True make this pane less likely to
   * be forced to be resized.
   *)
  BooleanResource(# <B>resourceName</B><A name="skipAdjust.1:resourceName.2(300)"></A><A name="resourceName.2(300)"></A>::&lt; XtNSkipAdjust #);

(* Extra Constraint Attributes for children of Form.  Each child of the
 * Form widget has a set of operations available to control the
 * layout.  These attributes allow the Form widget's children to
 * specify individual layout requirements.
 *)
<B>fromHoriz</B><A name="fromHoriz.1(301)"></A>: 
  (* Which widget this child should be placed to the right of.  If
   * this attribute is not specified then this widget will be
   * positioned relative to the edge of the parent.
   *)
  IntegerResource(# <B>resourceName</B><A name="fromHoriz.1:resourceName.2(302)"></A><A name="resourceName.2(302)"></A>::&lt; XtNFromHoriz #);
<B>fromVert</B><A name="fromVert.1(303)"></A>: 
  (* Which widget this child should be placed underneath.  If this
   * attribute is not specified then this widget will be positioned
   * relative to the edge of the parent.
   *)
  IntegerResource(# <B>resourceName</B><A name="fromVert.1:resourceName.2(304)"></A><A name="resourceName.2(304)"></A>::&lt; XtNFromVert #);
<B>horizDistance</B><A name="horizDistance.1(305)"></A>: 
  (* The amount of space, in pixels, between this child and its left
   *    neighbour.
   *)
  IntegerResource(# <B>resourceName</B><A name="horizDistance.1:resourceName.2(306)"></A><A name="resourceName.2(306)"></A>::&lt; XtNhorizDistance #);
<B>vertDistance</B><A name="vertDistance.1(307)"></A>: 
  (* The amount of space, in pixels, between this child and its upper
   *    neighbour
   *)
  IntegerResource(# <B>resourceName</B><A name="vertDistance.1:resourceName.2(308)"></A><A name="resourceName.2(308)"></A>::&lt; XtNvertDistance #);
<B>resizable</B><A name="resizable.1(309)"></A>: 
  (* If this attribute is False then the parent widget will ignore
   * all geometry request made by this child. The parent may still
   * resize this child itself, however.
   *)
  BooleanResource(# <B>resourceName</B><A name="resizable.1:resourceName.2(310)"></A><A name="resourceName.2(310)"></A>::&lt; XtNResizable #);
(* The following four resources specify what to do with the
 * corresponding edge of the child when the parent is resized. The
 * value may be chainBottom, chainLeft, chainRight, chainTop or rubber
 *)
<B>bottom</B><A name="bottom.1(311)"></A>: IntegerResource(# <B>resourceName</B><A name="bottom.1:resourceName.2(312)"></A><A name="resourceName.2(312)"></A>::&lt; XtNBottom #);
<B>left</B><A name="left.1(313)"></A>: IntegerResource(# <B>resourceName</B><A name="left.1:resourceName.2(314)"></A><A name="resourceName.2(314)"></A>::&lt; XtNLeft #);
<B>right</B><A name="right.1(315)"></A>: IntegerResource(# <B>resourceName</B><A name="right.1:resourceName.2(316)"></A><A name="resourceName.2(316)"></A>::&lt; XtNRight #);
<B>top</B><A name="top.1(317)"></A>: IntegerResource(# <B>resourceName</B><A name="top.1:resourceName.2(318)"></A><A name="resourceName.2(318)"></A>::&lt; XtNTop #);

--- LIB: attributes ---

<B>AwEnv</B><A name="AwEnv.1(319)"></A>: XtEnv
  (# &lt;&lt;SLOT AwEnvLIB: attributes&gt;&gt;;
  do INNER
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Awenv Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
