<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Textactions Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="heapview.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Textactions Interface</H1>
<PRE CLASS=interface>
ORIGIN '../awenv';

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-97
 *       All rights reserved.
 *)

-- AsciiTextLib: attributes --

(* motion bindings *)

<B>forward_character</B><A name="forward_character.1(351)"></A>:
  (* Move the insert point forward one character in the buffer.  If
   * the insert point is at the end or beginning of a line this action
   * will move the insert point to the next line.
   *)
  (# do 'forward-character' -&gt; CallAction #);
<B>backward_character</B><A name="backward_character.1(352)"></A>:
  (* Move the insert point backward one character in the buffer.  If
   * the insert point is at the end or beginning of a line this action
   * will move the insert point to the previous line.
   *)
  (# do 'backward-character' -&gt; CallAction #);
<B>forward_word</B><A name="forward_word.1(353)"></A>:
  (* Move the insert point to the next word boundary.  A word
   * boundary is defined as a Space, Tab or Carriage Return.
   *)
  (# do 'forward-word' -&gt; CallAction #);
<B>backward_word</B><A name="backward_word.1(354)"></A>:
  (* Move the insert point to the previous word boundary.  A word
   * boundary is defined as a Space, Tab or Carriage Return.
   *)
  (# do 'backward-word' -&gt; CallAction #);
<B>forward_paragraph</B><A name="forward_paragraph.1(355)"></A>:
  (* Move the insert point to the next paragraph boundary.  A
   * paragraph boundary is defined as two Carriage Returns in a row
   * with only Spaces or Tabs between them.
   *)
  (# do 'forward-paragraph' -&gt; CallAction #);
<B>backward_paragraph</B><A name="backward_paragraph.1(356)"></A>:
  (* Move the insert point to the previous paragraph boundary.  A
   * paragraph boundary is defined as two Carriage Returns in a row
   * with only Spaces or Tabs between them.
   *)
  (# do 'backward-paragraph' -&gt; CallAction #);
<B>beginning_of_line</B><A name="beginning_of_line.1(357)"></A>:
  (* Move to the beginning of the current line.  If the insert point
   * is already at the beginning of the line then no action is taken.
   *)
  (# do 'beginning-of-line' -&gt; CallAction #);
<B>end_of_line</B><A name="end_of_line.1(358)"></A>:
  (* Move to the beginning of the current line.  If the insert point
   * is already at the beginning of the line then no action is taken.
   *)
  (# do 'end-of-line' -&gt; CallAction #);
<B>next_line</B><A name="next_line.1(359)"></A>:
  (* Move the insert point down one line.  If the insert point is
   * currently N characters from the beginning of the line then it
   * will be N characters from the beginning of the next line.  If N
   * is past the end of the line, the insert point is placed at the
   * end of the line.
   *)
  (# do 'next-line' -&gt; CallAction #);
<B>previous_line</B><A name="previous_line.1(360)"></A>:
  (* Move the insert point up one line.  If the insert point is
   * currently N characters from the beginning of the line then it
   * will be N characters from the beginning of the previous line.  If
   * N is past the end of the line, the insert point is placed at the
   * end of the line.
   *)
  (# do 'previous-line' -&gt; CallAction #);
<B>next_page</B><A name="next_page.1(361)"></A>:
  (* Move the insert point down one page in the file.  One page is
   * defined as the current height of the text widget.  The insert
   * point is always placed at the first character of the top line by
   * this action.
   *)
  (# do 'next-page' -&gt; CallAction #);
<B>previous_page</B><A name="previous_page.1(362)"></A>:
  (* Move the insert point up one page in the file.  One page is
   * defined as the current height of the text widget.  The insert
   * point is always placed at the first character of the top line by
   * this action.
   *)
  (# do 'previous-page' -&gt; CallAction #);
<B>beginning_of_file</B><A name="beginning_of_file.1(363)"></A>:
  (* Place the insert point at the beginning of the current text
   * buffer.  The text widget is then scrolled the minimum amount
   * necessary to make the new insert point location visible.
   *)
  (# do 'beginning-of-file' -&gt; CallAction #);
<B>end_of_file</B><A name="end_of_file.1(364)"></A>:
  (* Place the insert point at the end of the current text buffer.
   * The text widget is then scrolled the minimum amount necessary to
   * make the new insert point location visible.
   *)
  (# do 'end-of-file' -&gt; CallAction #);
<B>scroll_one_line_up</B><A name="scroll_one_line_up.1(365)"></A>:
  (* Scroll the current text field up by one line.  This does not
   * move the insert point.  Other than the scrollbars this is the
   * only way that the insert point may be moved off of the visible
   * text area.  The widget will be scrolled so that the insert point
   * is back on the screen as soon as some other action is executed.
   *)
  (# do 'scroll-one-line-up' -&gt; CallAction #);
<B>scroll_one_line_down</B><A name="scroll_one_line_down.1(366)"></A>:
  (* Scroll the current text field down by one line.  This does not
   * move the insert point.  Other than the scrollbars this is the
   * only way that the insert point may be moved off of the visible
   * text area.  The widget will be scrolled so that the insert point
   * is back on the screen as soon as some other action is executed.
   *)
  (# do 'scroll-one-line-down' -&gt; CallAction #);

(* delete bindings *)

<B>delete_next_character</B><A name="delete_next_character.1(367)"></A>:
  (* Remove the character immediately after the insert point.  If a
   * Carriage Return is removed then the next line is appended to the
   * end of the current line.
   *)
  (# do 'delete-next-character' -&gt; CallAction #);
<B>delete_previous_character</B><A name="delete_previous_character.1(368)"></A>:
  (* Remove the character immediately before the insert point.  If a
   * Carriage Return is removed then the next line is appended to the
   * end of the current line.
   *)
  (# do 'delete-previous-character' -&gt; CallAction #);
<B>delete_next_word</B><A name="delete_next_word.1(369)"></A>:
  (* Remove all characters between the insert point location and the
   * next word boundary.  A word boundary is defined as a Space, Tab
   * or Carriage Return.
   *)
  (# do 'delete-next-word' -&gt; CallAction #);
<B>delete_previous_word</B><A name="delete_previous_word.1(370)"></A>:
  (* Remove all characters between the insert point location and the
   * previous word boundary.  A word boundary is defined as a Space,
   * Tab or Carriage Return.
   *)
  (# do 'delete-previous-word' -&gt; CallAction #);
<B>delete_selection</B><A name="delete_selection.1(371)"></A>:
  (* This action removes all characters in the current selection.
   * The selection can be set with the selection actions.
   *)
  (# do 'delete-selection' -&gt; CallAction #);

(* kill bindings *)

<B>kill_word</B><A name="kill_word.1(372)"></A>:
  (* Act exactly like the delete-next-word action, but stuffs the
   * word that was killed into the kill buffer (CUT_BUFFER_1).
   *)
  (# do 'kill-word' -&gt; CallAction #);
<B>backward_kill_word</B><A name="backward_kill_word.1(373)"></A>:
  (* Act exactly like the delete-previous-word action, but stuffs the
   * word that was killed into the kill buffer (CUT_BUFFER_1).
   *)
  (# do 'backward-kill-word' -&gt; CallAction #);
<B>kill_selection</B><A name="kill_selection.1(374)"></A>:
  (* This action deletes the current selection and stuffs the deleted
   * text into the kill buffer (CUT_BUFFER_1).
   *)
  (# do 'kill-selection' -&gt; CallAction #);
<B>kill_to_end_of_line</B><A name="kill_to_end_of_line.1(375)"></A>:
  (* This action deletes the entire line to the right of the insert
   * point position, and stuffs the deleted text into the kill buffer
   * (CUT_BUFFER_1).
   *)
  (# do 'kill-to-end-of-line' -&gt; CallAction #);
<B>kill__paragraph</B><A name="kill__paragraph.1(376)"></A>:
  (* This action deletes the current paragraph, if between paragraphs
   * it deletes the paragraph above the insert point, and stuffs the
   * deleted text into the kill buffer (CUT_BUFFER_1).
   *)
  (# do 'kill-paragraph' -&gt; CallAction #);
<B>kill_to_end_of_paragraph</B><A name="kill_to_end_of_paragraph.1(377)"></A>:
  (* This action deletes everything between the current insert point
   * location and the next paragraph boundary, and stuffs the deleted
   * text into the kill buffer (CUT_BUFFER_1).
   *)
  (# do 'kill-to-end-of-paragraph' -&gt; CallAction #);

(* unkill bindings *)

<B>unkill</B><A name="unkill.1(378)"></A>:
  (* Undo previous kill, i.e., paste the contents of the kill buffer
   * (CUT_BUFFER_1) at the insertion point
   *)
  (# do 'unkill' -&gt; CallAction #);
<B>stuff</B><A name="stuff.1(379)"></A>:
  (* Paste the contents of CUT_BUFFER_0 at the insertion point *)
  (# do 'stuff' -&gt; CallAction #);

(* new line stuff *)

<B>newline_and_indent</B><A name="newline_and_indent.1(380)"></A>:
  (* This action inserts a newline into the text and adds spaces to
   * that line to indent it to match the previous line [ This action
   * is still a bit buggy ].
   *)
  (# do 'newline-and-indent' -&gt; CallAction #);
<B>newline_and_backup</B><A name="newline_and_backup.1(381)"></A>:
  (* This action inserts a newline into the text after the insert
   * point.
   *)
  (# do 'newline-and-backup' -&gt; CallAction #);
<B>newline</B><A name="newline.1(382)"></A>:
  (* This action inserts a newline into the text before the insert
   * point.
   *)
  (# do 'newline' -&gt; CallAction #);

(* Selection stuff *)

<B>select_word</B><A name="select_word.1(383)"></A>:
  (* This action selects the word in which the insert point is
   * currently located.  If the insert point is between words then it
   * will select the previous word.
   *)
  (# do 'select-word' -&gt; CallAction #);
<B>select_all</B><A name="select_all.1(384)"></A>:
  (* This action selects the entire text buffer. *)
  (# do 'select-all' -&gt; CallAction #);
<B>select_start</B><A name="select_start.1(385)"></A>:
  (* This action sets the insert point to the current pointer
   * location.  It will then begin a selection at this location.  If
   * many of these selection actions occur quickly in succession then
   * the selection count mechanism will be invoked.
   *)
  (# do 'select-start' -&gt; CallAction #);
<B>select_adjust</B><A name="select_adjust.1(386)"></A>:
  (* This action allows a selection started with the select-start
   * action to be modified, as described above.
   *)
  (# do 'select-adjust' -&gt; CallAction #);
<B>select_end</B><A name="select_end.1(387)"></A>:
  (* This action ends a text selection that began with the
   * select-start action, and asserts ownership of the selection or
   * selections specified.  A name can be a selection (e.g. PRIMARY)
   * or a cut buffer (e.g CUT_BUFFER0).  Note that case is important.
   * If no names are specified, PRIMARY is asserted.
   *)
  (# <B>name</B><A name="select_end.1:name.2(388)"></A><A name="name.2(388)"></A>: ^text;
  enter name[]
  do (if name[]=NONE then
         'select-end' -&gt; CallAction
      else
         ('select-end', name[]) -&gt; CallArgAction
     if);
  #);
<B>extend_start</B><A name="extend_start.1(389)"></A>:
  (* This action finds the nearest end of the current selection, and
   * moves it to the current pointer location.
   *)
  (# do 'extend-start' -&gt; CallAction #);
<B>extend_adjust</B><A name="extend_adjust.1(390)"></A>:
  (* This action allows a selection started with an extend-start
   * action to be modified.
   *)
  (# do 'extend-adjust' -&gt; CallAction #);
<B>extend_end</B><A name="extend_end.1(391)"></A>:
  (* This action ends a text selection that began with the
   * extend-start action, and asserts ownership of the selection or
   * selections specified.  A name can be a selection (e.g. PRIMARY)
   * or a cut buffer (e.g CUT_BUFFER0).  Note that case is important.
   * If no names are given, PRIMARY is asserted.
   *)
  (# <B>name</B><A name="extend_end.1:name.2(392)"></A><A name="name.2(392)"></A>: ^text;
  enter name[]
  do (if name[]=NONE then
         'extend-end' -&gt; CallAction
      else
         ('extend-end', name[]) -&gt; CallArgAction
     if);
  #);
<B>insert_selection</B><A name="insert_selection.1(393)"></A>:
  (* This action retrieves the value of the first (left-most) named
   * selection that exists or the cut buffer that is not empty and
   * inserts it into the Text widget at the current insert point
   * location. A name can be a selection (e.g. PRIMARY) or a cut
   * buffer (e.g CUT_BUFFER0).  Note that case is important.
   *)
  (# <B>name</B><A name="insert_selection.1:name.2(394)"></A><A name="name.2(394)"></A>: ^text;
  enter name[]
  do (if name[]=NONE then
         'insert-selection' -&gt; CallAction
      else
         ('insert-selection', name[]) -&gt; CallArgAction
     if);
  #);

(* Miscellaneous *)

<B>redraw_display</B><A name="redraw_display.1(395)"></A>:
  (* This action recomputes the location of all the text lines on the
   * display, scrolls the text to vertically center the line
   * containing the insert point on the screen, clears the entire
   * screen, and redisplays it.
   *)
  (# do 'redraw-display' -&gt; CallAction #);
<B>insert_file</B><A name="insert_file.1(396)"></A>:
  (* This action activates the insert file popup.  The filename
   * option specifies the default filename to put in the filename
   * buffer of the popup.  If no filename is specified the the buffer
   * is empty at startup.
   *)
  (# <B>filename</B><A name="insert_file.1:filename.2(397)"></A><A name="filename.2(397)"></A>: ^text;
  enter filename[]
  do (if filename[]=NONE then
         'insert-file' -&gt; CallAction
      else
         ('insert-file', filename[]) -&gt; CallArgAction
     if);
  #);
<B>search</B><A name="search.1(398)"></A>:
  (* This action activates the search popup.  The direction must be
   * specified as either forward or backward.  The string is optional
   * and is used as an initial value for the Search for: string.
   *)
  (# <B>string</B><A name="search.1:string.2(399)"></A><A name="string.2(399)"></A>: ^text;
  enter string[]
  do (if string[]=NONE then
         'search' -&gt; CallAction
      else
         ('search', string[]) -&gt; CallArgAction
     if);
  #);
<B>insert_char</B><A name="insert_char.1(400)"></A>:
  (* This action may only be attached to a key event. It calls
   * XLookupString to translate the event into a (rebindable) Latin-1
   * character (sequence) and inserts that sequence into the text at
   * the insert point position.
   *)
  (# <B>event</B><A name="insert_char.1:event.2(401)"></A><A name="event.2(401)"></A>: @XKeyEvent;
  enter event
  do (thewidget, 'insert-char', event, 0, 0) -&gt; XtCallActionProc
  #);
<B>insert_string</B><A name="insert_string.1(402)"></A>:
  (* This action inserts each string into the text at the insert
   * point location.  Any string beginning with the characters "0x"
   * and containing only valid hexadecimal digits in the remainder is
   * interpreted as a hexadecimal constant and the corresponding
   * single character is inserted instead.
   *)
  (# <B>string</B><A name="insert_string.1:string.2(403)"></A><A name="string.2(403)"></A>: ^text;
  enter string[]
  do (if string[]=NONE then
         'insert-string called with no string' -&gt; screen.putline;
      else
         ('insert-string', string[]) -&gt; CallArgAction
     if);
  #);
<B>focus_in</B><A name="focus_in.1(404)"></A>:
  (* Currently does nothing. *)
  (# do 'focus-in' -&gt; CallAction #);
<B>focus_out</B><A name="focus_out.1(405)"></A>:
  (* Currently does nothing. *)
  (# do 'focus-out' -&gt; CallAction #);
<B>display_caret</B><A name="display_caret.1(406)"></A>:
  (* This action allows the insert point to be turned on and off.
   * The state argument specifies the desired state of the insert
   * point.  This value may be any of the string values accepted for
   * Boolean resources (e.g. on, True, off, False, etc.).  If no
   * arguments are specified, the default value is True.  The when
   * argument specifies, for EnterNotify or LeaveNotify events whether
   * or not the focus field in the event is to be examined.  If the
   * second argument is not specified, or specified as something other
   * than always then if the action is bound to an EnterNotify or
   * LeaveNotify event, the action will be taken only if the focus
   * field is True.  An augmented binding that might be useful is:
   * 
   *    Text.Translations: #override \ &lt;FocusIn&gt;: display-caret(on)
   *            \n\ &lt;FocusOut&gt;: display-caret(off)
   *)
  (# <B>state</B><A name="display_caret.1:state.2(407)"></A><A name="state.2(407)"></A>: ^text;
  enter state[]
  do (if state[]=NONE then
         'display-caret called with no state' -&gt; screen.putline;
      else
         ('display-caret', state[]) -&gt; CallArgAction
     if);
  #);
<B>multiply</B><A name="multiply.1(408)"></A>:
  (* The multiply action allows the user to multiply the effects of
   * many of the text actions.  Thus the following action sequence
   * multiply(10) delete-next-word() will delete 10 words.  It does
   * not matter whether these actions take place in one event or many
   * events.  Using the default translations the key sequence
   * Control-u, Control-d will delete 4 characters.  Multiply actions
   * can be chained, thus multiply(5) multiply(5) is the same as
   * multiply(25).  If the string reset is passed to the multiply
   * action the effects of all previous multiplies are removed and a
   * beep is sent to the display.
   *)
  (# <B>value</B><A name="multiply.1:value.2(409)"></A><A name="value.2(409)"></A>: @integer;
     <B>valuetext</B><A name="multiply.1:valuetext.2(410)"></A><A name="valuetext.2(410)"></A>: @text;
  enter value
  do value -&gt; valuetext.putint;
     ('multiply', valuetext[]) -&gt; CallArgAction
  #);
<B>form_paragraph</B><A name="form_paragraph.1(411)"></A>:
  (* This action removes all the Carriage Returns from the current
   * paragraph and reinserts them so that each line is as long as
   * possible, while still fitting on the current screen.  Lines are
   * broken at word boundaries if at all possible.  This action
   * currently works only on Text widgets that use ASCII text.
   *)
  (# do 'form-paragraph' -&gt; CallAction #);  
<B>transpose_characters</B><A name="transpose_characters.1(412)"></A>:
  (* This action will swap the position of the character to the left
   * of the insert point with the character to the right of the insert
   * point.  The insert point will then be advanced one character.
   *)
  (# do 'transpose-characters' -&gt; CallAction #);
<B>no_op</B><A name="no_op.1(413)"></A>:
  (* The no-op action makes no change to the text widget, and is
   * mainly used to override translations.  This action takes one
   * optional argument.  If this argument is true then a beep is sent
   * to the display.
   *)
  (# <B>ringbell</B><A name="no_op.1:ringbell.2(414)"></A><A name="ringbell.2(414)"></A>: @boolean;
  enter ringbell
  do (if not ringbell then
         'no-op' -&gt; CallAction
      else
         ('no-op', 'RingBell') -&gt; CallArgAction
     if);
  #);

-- XtObjectLib: attributes --

(* Gennerally applicable interface for calling actions directly *)

<B>CallAction</B><A name="CallAction.1(415)"></A>: 
  (* Call action with no params *)
  (# <B>action</B><A name="CallAction.1:action.2(416)"></A><A name="action.2(416)"></A>: ^text 
  enter action[] 
  do (thewidget, action, 0, 0, 0) -&gt; XtCallActionProc
  #);

<B>CallArgAction</B><A name="CallArgAction.1(417)"></A>: 
  (* Call action with one argument *)
  (# <B>action</B><A name="CallArgAction.1:action.2(418)"></A><A name="action.2(418)"></A>: ^text;
     <B>arg</B><A name="CallArgAction.1:arg.2(419)"></A><A name="arg.2(419)"></A>: ^text;
     <B>params</B><A name="CallArgAction.1:params.2(420)"></A><A name="params.2(420)"></A>: @StringArray(# initialsize::&lt; (# do 1-&gt;value #)#);
  enter (action[], arg[])
  do params.init;
     arg[] -&gt; params.addText;
     (thewidget, action, 0, params, params.number) -&gt; XtCallActionProc;
     params.clear;
  #);

<B>CallArgsAction</B><A name="CallArgsAction.1(421)"></A>: 
  (* Call action with several params *)
  (# <B>action</B><A name="CallArgsAction.1:action.2(422)"></A><A name="action.2(422)"></A>: ^text;
     <B>args</B><A name="CallArgsAction.1:args.2(423)"></A><A name="args.2(423)"></A>: ^StringArray;
  enter (action[], args[])
  do (thewidget, action, 0, args, args.number) -&gt; XtCallActionProc;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="heapview.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
