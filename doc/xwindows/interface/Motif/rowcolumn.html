<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Rowcolumn Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="scrolledwindow.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="frame.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Rowcolumn Interface</H1>
<PRE CLASS=interface>
ORIGIN 'manager';
BODY 'private/rowcolumnbody';

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-97 
 *       All rights reserved.
 *)

-- XtEnvLib: attributes -- 

<B>RowColumn</B><A name="RowColumn.1(636)"></A>: Manager
  (* The RowColumn widget is a general purpose RowColumn manager
   * capable of containing any widget type as a child. In general,
   * it requires no special knowledge about how its children
   * function and provides nothing beyond support for several
   * different layout styles.  However, it can be configured as a
   * menu, in which case, it expects only certain children, and it
   * configures to a particular layout.  The menus supported are:
   * MenuBar, Pulldown or Popup MenuPanes, and OptionMenu.  The
   * type of layout performed is controlled by how the application
   * has set the various layout resources.  It can be configured to
   * lay out its children in either rows or columns.  In addition,
   * the application can specify how the children are laid out, as
   * follows:
   * 
   *  + the children are packed tightly together into either rows
   *    or columns
   * 
   *  + each child is placed in an identically sized box (producing
   *    a symmetrical look)
   * 
   *  + a specific layout (the current x and y positions of the
   *    children control their location) In addition, the
   *    application has control over both the spacing that occurs
   *    between each row and column and the margin spacing present
   *    between the edges of the RowColumn widget and any children
   *    that are placed against it.  By default the RowColumn
   *    widget has no 3-D visuals associated with it; if an
   *    application wishes to have a 3-D shadow placed around this
   *    widget, it can create the RowColumn as a child of a Frame
   *    widget.
   *)
  (# <B>init</B><A name="RowColumn.1:init.2(637)"></A><A name="init.2(637)"></A>::&lt; 
       (# WidgetClass::&lt;
            (#
            do INNER; 
               (if value=0 then xmRowColumnWidgetClass-&gt;value if)
            #)
       do INNER 
       #);
     
     (* Resources *)
     <B>resizeWidth</B><A name="RowColumn.1:resizeWidth.2(638)"></A><A name="resizeWidth.2(638)"></A>: 
       (* Requests a new width if necessary, when set to True.
        * When set to False, THIS(RowColumn) does not request a new
        * width regardless of any changes to THIS(RowColumn) or its
        * children.
        *)
       BooleanResource(# resourceName::&lt; XmNresizeWidth #);
     <B>resizeHeight</B><A name="RowColumn.1:resizeHeight.2(639)"></A><A name="resizeHeight.2(639)"></A>: 
       (* Requests a new height if necessary, when set to True.
        * When set to False, THIS(RowColumn) does not request a new
        * height regardless of any changes to THIS(RowColumn) or
        * its children.
        *)
       BooleanResource(# resourceName::&lt; XmNresizeHeight #);
     <B>adjustLast</B><A name="RowColumn.1:adjustLast.2(640)"></A><A name="adjustLast.2(640)"></A>: 
       (* Extends the last row of children to the bottom edge of
        * THIS(RowColumn) (when orientation is XmHORIZONTAL) or
        * extends the last column to the right edge of
        * THIS(RowColumn) (when orientation is XmVERTICAL).  This
        * feature is disabled by setting adjustLast to False.
        *)
       BooleanResource(# resourceName::&lt; XmNadjustLast #);
     <B>marginWidth</B><A name="RowColumn.1:marginWidth.2(641)"></A><A name="marginWidth.2(641)"></A>: 
       (* Specifies the amount of blank space between the left
        * edge of THIS(RowColumn) and the first item in each row,
        * and the right edge of THIS(RowColumn) widget and the last
        * item in each row. The default value is 0 for Pulldown and
        * Popup MenuPanes, and three pixels for other RowColumn
        * types.
        *)
       ShortResource(# resourceName::&lt; XmNmarginWidth #);
     <B>marginHeight</B><A name="RowColumn.1:marginHeight.2(642)"></A><A name="marginHeight.2(642)"></A>: 
       (* Specifies the amount of blank space between the top edge
        * of THIS(RowColumn) and the first item in each column, and
        * the bottom edge of THIS(RowColumn) and the last item in
        * each column.  The default value is 0 for Pulldown and
        * Popup MenuPanes, and three pixels for other RowColumn
        * types.
        *)
       ShortResource(# resourceName::&lt; XmNmarginHeight #);
     <B>isAligned</B><A name="RowColumn.1:isAligned.2(643)"></A><A name="isAligned.2(643)"></A>: 
       (* Specifies text alignment for each item within
        * THIS(RowColumn); this applies only to items that are
        * subpatterns ofLabel or LabelGadget.  However, if the item
        * is a Label widget or gadget and its parent is either a
        * Popup MenuPane or a Pulldown MenuPane, alignment is not
        * performed; the Label is treated as the title within the
        * MenuPane, and the alignment set by the application is not
        * overridden.  entryAlignment controls the type of textual
        * alignment.
        *)
       BooleanResource(# resourceName::&lt; XmNisAligned #);
     <B>adjustMargin</B><A name="RowColumn.1:adjustMargin.2(644)"></A><A name="adjustMargin.2(644)"></A>: 
       (* Specifies whether the INNER minor margins of all items
        * contained within THIS(RowColumn) are forced to the same
        * value.  The INNER minor margin corresponds to the
        * marginLeft, marginRight, marginTop, and marginBottom
        * resources supported by Label and LabelGadget. A vertical
        * orientation causes marginLeft and marginRight for all
        * items in a particular column to be forced to the same
        * value; the value is the largest margin specified for one
        * of the Label items.  This keeps all text within each row
        * or column lined up with all other text in its row or
        * column.  If the rowColumnType is either XmMENU_POPUP or
        * XmMENU_PULLDOWN and this resource is True, only button
        * children have their margins adjusted.
        *)
       BooleanResource(# resourceName::&lt; XmNadjustMargin #);
     <B>radioBehavior</B><A name="RowColumn.1:radioBehavior.2(645)"></A><A name="radioBehavior.2(645)"></A>: 
       (* Specifies a Boolean value that when True, indicates that
        * THIS(RowColumn) should enforce a RadioBox-type behavior
        * on all of its children that are ToggleButtons or
        * ToggleButtonGadgets.  When the value of this resource is
        * True, the defaults for two resources for ToggleButton and
        * ToggleButtonGadget children change: indicatorType
        * defaults to XmONE_OF_MANY and visibleWhenOff defaults to
        * True.  RadioBox behavior dictates that when one toggle is
        * selected and the user selects another toggle, the first
        * toggle is unselected automatically.  THIS(RowColumn)
        * usually does not enforce this behavior if the
        * application, rather than the user, changes the state of a
        * toggle.  THIS(RowColumn) does enforce this behavior if a
        * toggle child is selected using the state pattern of
        * ToggleButton(Gadget) with a notify argument of True.  The
        * default value is False, except if THIS(RowColumn) is a
        * RadioBox
        *)
       BooleanResource(# resourceName::&lt; XmNradioBehavior #);
     <B>radioAlwaysOne</B><A name="RowColumn.1:radioAlwaysOne.2(646)"></A><A name="radioAlwaysOne.2(646)"></A>: 
       (* If True, forces the active ToggleButton or
        * ToggleButtonGadget to be automatically selected after
        * having been unselected (if no other toggle was
        * activated).  If False, the active toggle may be
        * unselected.  The default value is True.  This resource is
        * important only when radioBehavior is True.  The
        * application can always add and subtract toggles from
        * THIS(RowColumn) regardless of the selected/unselected
        * state of the toggle.  The application can also manage and
        * unmanage toggle children of THIS(RowColumn) at any time
        * regardless of state.  Therefore, the application can
        * sometimes create a RowColumn that has radioAlwaysOne set
        * to True and none of the toggle children selected.  The
        * result is undefined if the value of this resource is True
        * and the application sets more than one ToggleButton at a
        * time.
        *)
       BooleanResource(# resourceName::&lt; XmNradioAlwaysOne #);
     <B>isHomogeneous</B><A name="RowColumn.1:isHomogeneous.2(647)"></A><A name="isHomogeneous.2(647)"></A>: 
       (* Indicates if THIS(RowColumn) should enforce exact
        * homogeneity among the items it contains; if True, only
        * the widgets that are of the class indicated by entryClass
        * are allowed as children of THIS(RowColumn).  This is most
        * often used for MenuBars or RadioBoxes.  Attempting to
        * insert a child that is not a member of the specified
        * class generates a warning message.  The default value is
        * False, except for a MenuBar or a RadioBox, when the
        * default is True.
        *)
       BooleanResource(# resourceName::&lt; XmNisHomogeneous #);
     <B>entryClass</B><A name="RowColumn.1:entryClass.2(648)"></A><A name="entryClass.2(648)"></A>: 
       (* Specifies the only widget class that can be added to
        * THIS(RowColumn); this resource is meaningful only when
        * the isHomogeneous resource is set to True.  Both widget
        * and gadget variants of the specified class may be added
        * to THIS(RowColumn).  When rowColumnType is set to
        * XmWORK_AREA and radioBehavior is True, the default value
        * for entryClass is xmToggleButtonGadgetClass. When
        * rowColumnType is set to XmMENU_BAR, the value of
        * entryClass is forced to xmCascadeButtonWidgetClass.
        *)
       IntegerResource(# resourceName::&lt; XmNentryClass #);
     <B>menuHelpWidget</B><A name="RowColumn.1:menuHelpWidget.2(649)"></A><A name="menuHelpWidget.2(649)"></A>: 
       (* Specifies the CascadeButton, which is treated as the
        * Help widget if rowColumnType is set to XmMENU_BAR.  The
        * MenuBar always places the Help widget at a lower corner
        * of the menu.  If THIS(RowColumn) is any type other than
        * XmMENU_BAR, this resource is not meaningful.
        *)
       IntegerResource(# resourceName::&lt; XmNmenuHelpWidget #);
     <B>labelString</B><A name="RowColumn.1:labelString.2(650)"></A><A name="labelString.2(650)"></A>: 
       (* A text string, which displays the label to one side of
        * the selection area when rowColumnType is set to
        * XmMENU_OPTION.  This resource is not meaningful for all
        * other RowColumn types.  This resource needs to be set
        * directly on the LabelGadget child, hence this special
        * pattern.
        *)
       (# setText: 
            (* Set THIS(labelString) as in MotifString.setText *)
            (# t: ^text
            enter t[]
            do ...
            #);
          getText: 
            (* Get the value of THIS(labelString) as in
             *              MotifString.getText
             *)
            (# t: ^text
            do ...
            exit t[]
            #);
          set: 
            (* Set THIS(labelString) directly as in
             * MotifString.set
             *)
            (# value: @integer;
            enter value
            do ...
            #);
          get: 
            (* Get the value of THIS(labelString) directly as in
             * MotifString.get
             *)
            (# value: @Integer
            do ...
            exit value
            #);
          resourceName: @XmNlabelString;
       enter setText
       exit getText
       #);
     <B>subMenuId</B><A name="RowColumn.1:subMenuId.2(651)"></A><A name="subMenuId.2(651)"></A>: 
       (* Specifies the Pulldown MenuPane to be associated with an
        * OptionMenu.  This resource is useful only when
        * rowColumnType is set to XmMENU_OPTION.  The default value
        * is 0.
        *)
       IntegerResource(# resourceName::&lt; XmNsubMenuId #);
     <B>menuHistory</B><A name="RowColumn.1:menuHistory.2(652)"></A><A name="menuHistory.2(652)"></A>: 
       (* Specifies the last menu entry to be activated.  It is
        * also useful for specifying the current selection for an
        * OptionMenu.  If rowColumnType is set to XmMENU_OPTION,
        * the specified menu item is positioned under the cursor
        * when the menu is displayed. If THIS(RowColumn) has the
        * radioBehavior resource set to True, the widget field
        * associated with this resource contains the widget ID of
        * the last ToggleButton or ToggleButtonGadget to change
        * from unselected to selected.  The default value is the
        * the first child in THIS(RowColumn).
        *)
       IntegerResource(# resourceName::&lt; XmNmenuHistory #);
     <B>popupEnabled</B><A name="RowColumn.1:popupEnabled.2(653)"></A><A name="popupEnabled.2(653)"></A>: 
       (* Allows the menu system to enable keyboard input
        * (accelerators and mnemonics) defined for a Popup MenuPane
        * and any of its submenus.  The Popup MenuPane needs to be
        * informed whenever its accessibility to the user changes
        * because posting of the Popup MenuPane is controlled by
        * the application. The default value for this resource is
        * True (keyboard input - accelerators and mnemonics -
        * defined for the Popup MenuPane and any of its submenus is
        * enabled).
        *)
       BooleanResource(# resourceName::&lt; XmNpopupEnabled #);
     <B>numColumns</B><A name="RowColumn.1:numColumns.2(654)"></A><A name="numColumns.2(654)"></A>: 
       (* Specifies the number of minor dimension extensions that
        * are made to accommodate the entries; this attribute is
        * meaningful only when packing is set to XmPACK_COLUMN.
        * For vertically-oriented RowColumns, this attribute
        * indicates how many columns are built; the number of
        * entries per column is adjusted to maintain this number of
        * columns, if possible.  For horizontally-oriented
        * RowColumn widgets, this attribute indicates how many rows
        * are built.  The default value is 1.
        *)
       ShortResource(# resourceName::&lt; XmNnumColumns #);
     <B>entryAlignment</B><A name="RowColumn.1:entryAlignment.2(655)"></A><A name="entryAlignment.2(655)"></A>: 
       (* Specifies the alignment type for children that are
        * subclasses of Label or LabelGadget when isAligned is
        * enabled.  The following are textual alignment types:
        * 
        *  + XmALIGNMENT_BEGINNING - the default
        * 
        *  + XmALIGNMENT_CENTER
        * 
        *  + XmALIGNMENT_END
        *)
       CharResource(# resourceName::&lt; XmNentryAlignment #);
     <B>entryVerticalAlignment</B><A name="RowColumn.1:entryVerticalAlignment.2(656)"></A><A name="entryVerticalAlignment.2(656)"></A>: 
       (* Specifies the vertical alignment type for children that are
        * subclasses of Label or LabelGadget when isAligned is
        * enabled.  The following are textual alignment types:
        * 
        *  + XmALIGNMENT_BEGINNING - the default
        * 
        *  + XmALIGNMENT_CENTER
        * 
        *  + XmALIGNMENT_END
        *)
       CharResource(# resourceName::&lt; XmNentryVerticalAlignment #);
     <B>rowColumnType</B><A name="RowColumn.1:rowColumnType.2(657)"></A><A name="rowColumnType.2(657)"></A>: 
       (* Specifies the type of RowColumn widget to be created. It
        * is a non-standard resource that cannot be changed after
        * it is set. The set of possible settings for this resource
        * are:
        * 
        *  + XmWORK_AREA - the default
        * 
        *  + XmMENU_BAR
        * 
        *  + XmMENU_PULLDOWN
        * 
        *  + XmMENU_POPUP
        * 
        *  + XmMENU_OPTION This resource cannot be changed after
        *    the RowColumn widget is created.
        *)
       CharResource(# resourceName::&lt; XmNrowColumnType #);
     <B>packing</B><A name="RowColumn.1:packing.2(658)"></A><A name="packing.2(658)"></A>: 
       (* Specifies how to pack the items contained within
        * THIS(RowColumn).  This can be set to XmPACK_TIGHT,
        * XmPACK_COLUMN or XmPACK_NONE.  When a RowColumn widget
        * packs the items it contains, it determines its major
        * dimension using the value of the orientation resource.
        * XmPACK_TIGHT indicates that given the current major
        * dimension (for example, vertical if orientation is
        * XmVERTICAL), entries are placed one after the other until
        * the RowColumn widget must wrap.  THIS(RowColumn) wraps
        * when there is no room left for a complete child in that
        * dimension.  Wrapping occurs by beginning a new row or
        * column in the next available space.  Wrapping continues,
        * as often as necessary, until all of the children are laid
        * out. In the vertical dimension (columns), boxes are set
        * to the same width; in the horizontal dimension (rows),
        * boxes are set to the same depth.  Each entry's position
        * in the major dimension is left unaltered (for example, y
        * is left unchanged when orientation is XmVERTICAL); its
        * position in the minor dimension is set to the same value
        * as the greatest entry in that particular row or column.
        * The position in the minor dimension of any particular row
        * or column is independent of all other rows or columns.
        * XmPACK_COLUMN indicates that all entries are placed in
        * identically sized boxes.  The box is based on the largest
        * height and width values of all the children widgets.  The
        * value of the numColumns resource determines how many
        * boxes are placed in the major dimension, before extending
        * in the minor dimension.  XmPACK_NONE indicates that no
        * packing is performed.  The x and y attributes of each
        * entry are left alone, and THIS(RowColumn) widget attempts
        * to become large enough to enclose all entries.  The
        * default value is XmPACK_TIGHT except when building an
        * OptionMenu or a RadioBox, when the default is
        * XmPACK_COLUMN.
        *)
       CharResource(# resourceName::&lt; XmNpacking #);
     <B>mnemonic</B><A name="RowColumn.1:mnemonic.2(659)"></A><A name="mnemonic.2(659)"></A>: 
       (* This resource is useful only when rowColumnType is set
        * to XmMENU_OPTION. Specifies a keysym for a key that, when
        * pressed by the user along with the Alt modifier, posts
        * the associated Pulldown MenuPane.  The first character in
        * the OptionMenu label string that exactly matches the
        * mnemonic in the character set specified in
        * mnemonicCharSet is underlined.  The user can post the
        * menu by pressing either the shifted or the unshifted
        * mnemonic key.  The default is no mnemonic.
        *)
       IntegerResource(# resourceName::&lt; XmNmnemonic #);
     <B>mnemonicCharSet</B><A name="RowColumn.1:mnemonicCharSet.2(660)"></A><A name="mnemonicCharSet.2(660)"></A>:
       (* Specifies the character set of the mnemonic for an
        * OptionMenu.  The default is determined dynamically
        * depending on the current language environment.
        *)
       IntegerResource(# resourceName::&lt; XmNmnemonicCharset #);
     <B>whichButton</B><A name="RowColumn.1:whichButton.2(661)"></A><A name="whichButton.2(661)"></A>: 
       (* Specifies the mouse button to which a menu system is
        * sensitive.  The default for XmMENU_POPUP is Menu.  The
        * default for XmMENU_OPTION, XmMENU_BAR, and XmWORK_AREA is
        * Return.  This resource is not useful for RowColumn
        * widgets of type XmMENU_PULLDOWN.  This resource is
        * obsolete; it has been replaced by XmNmenuPost and is
        * present for compatibility with older releases of
        * OSF/Motif.
        *)
       IntegerResource(# resourceName::&lt; XmNwhichButton #);
     <B>orientation</B><A name="RowColumn.1:orientation.2(662)"></A><A name="orientation.2(662)"></A>: 
       (* Determines whether THIS(RowColumn) layouts are row-major
        * or column- major. In a column-major layout, the children
        * of THIS(RowColumn) are laid out in columns top to bottom
        * within the THIS(RowColumn).  In a row-major layout the
        * children of THIS(RowColumn) are laid out in rows.
        * XmVERTICAL resource value selects a column-major layout.
        * XmHORIZONTAL resource value selects a row-major layout.
        * The default value is XmVERTICAL, except when creating a
        * MenuBar, when the default is XmHORIZONTAL.
        *)
       CharResource(# resourceName::&lt; XmNorientation #);
     <B>entryBorder</B><A name="RowColumn.1:entryBorder.2(663)"></A><A name="entryBorder.2(663)"></A>: 
       (* Imposes a uniform border width upon all children of
        * THIS(RowColumn).  The default value is 0, which disables
        * the feature.
        *)
       ShortResource(# resourceName::&lt; XmNentryBorder #);
     <B>menuAccelerator</B><A name="RowColumn.1:menuAccelerator.2(664)"></A><A name="menuAccelerator.2(664)"></A>: 
       (* This resource is useful only when THIS(RowColumn) has
        * been configured to operate as a Popup MenuPane or a
        * MenuBar.  The format of this resource is similar to the
        * left side specification of a translation string, with the
        * limitation that it must specify a key event.  For a Popup
        * MenuPane, when the accelerator is typed by the user, the
        * Popup MenuPane is posted.  For a MenuBar, when the
        * accelerator is typed by the user, the first item in the
        * MenuBar is highlighted, and traversal is enabled in the
        * MenuBar.  The accelerator can be disabled by setting the
        * popupEnabled resource to False.
        *)
       StringResource(# resourceName::&lt; XmNmenuAccelerator #);
     <B>menuPost</B><A name="RowColumn.1:menuPost.2(665)"></A><A name="menuPost.2(665)"></A>:
       (* Specifies an X event description indicating an event
        * that posts a menu system.  The default for XmMENU_POPUP
        * is Menu Press.  The default for XmMENU_OPTION,
        * XmMENU_BAR, and XmWORK_AREA is Return Press.  This
        * resource is not useful for RowColumn widgets of type
        * XmMENU_PULLDOWN.
        *)
       StringResource(# resourceName::&lt; XmNmenuPost #);
     <B>entryCallback</B><A name="RowColumn.1:entryCallback.2(666)"></A><A name="entryCallback.2(666)"></A>:
       (* Disables the activateCallback and valueChangedCallback
        * callbacks for all CascadeButton, DrawnButton, PushButton,
        * and ToggleButton widgets and gadgets contained within
        * THIS(RowColumn).  If the application supplies this
        * resource, the activateCallback and valueChangedCallback
        * callbacks are then revectored to the entryCallback.  This
        * allows an application to supply a single callback pattern
        * for handling all items contained in THIS(RowColumn).  The
        * callback reason is XmCR_ACTIVATE.  If the application
        * does not supply this resource, the activateCallback and
        * valueChangedCallback callbacks for each item in
        * THIS(RowColumn) work as normal. The application must
        * supply this resource at startup is created.  Changing
        * this resource after creation is not supported.
        *)
       IntegerResource(# resourceName::&lt; XmNentryCallback #);
     <B>spacing</B><A name="RowColumn.1:spacing.2(667)"></A><A name="spacing.2(667)"></A>:
       (* Specifies the horizontal and vertical spacing between
        * items contained within THIS(RowColumn).  The default
        * value is three pixels for XmOPTION_MENU and XmWORK_AREA
        * and 0 for other RowColumn types.
        *)
       ShortResource(# resourceName::&lt; XmNspacing #);
     
     (* Utility patterns *)
     <B>getPostedFromWidget</B><A name="RowColumn.1:getPostedFromWidget.2(668)"></A><A name="getPostedFromWidget.2(668)"></A>: IntegerValue
       (* Returns the widget from which a menu was posted.  An
        * application can use this pattern during the activate
        * callback to determine the context in which the menu
        * callback should be interpreted.
        *)
       (# menu: @widget
       enter menu
       do ...
       #);

     (* Callbacks *)
     <B>RowColumnCallback</B><A name="RowColumn.1:RowColumnCallback.2(669)"></A><A name="RowColumnCallback.2(669)"></A>: MotifCallback
       (* Prefix for RowColumn callbacks *)
       (# callData::&lt; XmRowColumnCallbackStruct do INNER #);
     
     <B>mapCallback</B><A name="RowColumn.1:mapCallback.2(670)"></A><A name="mapCallback.2(670)"></A>::&lt; RowColumnCallback
       (* Invoked when the window associated with THIS(RowColumn)
        * is about to be mapped.  The callback reason is XmCR_MAP.
        *);
     <B>unmapCallback</B><A name="RowColumn.1:unmapCallback.2(671)"></A><A name="unmapCallback.2(671)"></A>::&lt; RowColumnCallback
       (* Called after the window associated with THIS(RowColumn)
        * has been unmapped.  The callback reason is XmCR_UNMAP.
        *);
     (* Inherited callbacks *)
     <B>helpCallback</B><A name="RowColumn.1:helpCallback.2(672)"></A><A name="helpCallback.2(672)"></A>::&lt; RowColumnCallback;
     
     <B>installCallbacks</B><A name="RowColumn.1:installCallbacks.2(673)"></A><A name="installCallbacks.2(673)"></A>::&lt; (* Private *) 
       (# do ...; INNER #);
     
     &lt;&lt;SLOT RowColumnLib: attributes&gt;&gt;
  #) (* RowColumn *);

<B>PopupMenu</B><A name="PopupMenu.1(674)"></A>: RowColumn
  (* A PopupMenu is a RowColumn widget of type XmMENU_POPUP.  When
   * the Popup MenuPane is created, a MenuShell widget is
   * automatically created as the parent of the MenuPane.  The
   * PopupMenu is used as the first MenuPane within a PopupMenu
   * system; all other MenuPanes are of the Pulldown type.  A Popup
   * MenuPane displays a 3-D shadow, unless the feature is disabled
   * by the application.  The shadow appears around the edge of the
   * MenuPane.  A PopupMenu is "popped up" using manageChild, and
   * "popped down" using unmanageChild.  The menu can be positioned
   * before being managed using the "position" pattern below.
   *)
  (# <B>init</B><A name="PopupMenu.1:init.2(675)"></A><A name="init.2(675)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
       do true -&gt; doNotManageChild;
          INNER 
       #);
     
     (* Utility patterns *)
     <B>position</B><A name="PopupMenu.1:position.2(676)"></A><A name="position.2(676)"></A>:
       (* Positions THIS(PopupMenu) using the information in the
        * specified event. The x_root and y_root values in the
        * specified event are used to determine the menu position.
        *)
       (# event: @XButtonPressedEvent
       enter event
       do ...
       #);
     
     &lt;&lt;SLOT PopupMenuLib: attributes&gt;&gt;
  #) (* PopupMenu *);

<B>PulldownMenu</B><A name="PulldownMenu.1(677)"></A>: RowColumn
  (* A PulldownMenu is a RowColumn of type XmMENU_PULLDOWN.  When
   * creating a PulldownMenu, a MenuShell is automatically created
   * as the parent of PulldownMenu.  If the parent specified is a
   * PopupMenu or a PulldownMenu, the MenuShell is created as a
   * child of the parent's MenuShell; otherwise, it is created as a
   * child of the specified parent widget.  A PulldownMenu displays
   * a 3-D shadow, unless the feature is disabled by the
   * application.  The shadow appears around the edge of the
   * PulldownMenu.  A PulldownMenu is used when creating submenus
   * that are to be attached to a CascadeButton or a
   * CascadeButtonGadget.  This is the case for all MenuPanes that
   * are part of a PulldownMenu system (a MenuBar), the MenuPane
   * associated with an OptionMenu, and any MenuPanes that cascade
   * from a Popup MenuPane.  PulldownMenus that are to be
   * associated with an OptionMenu must be created before the
   * OptionMenu is created.  The PulldownMenu must be attached to a
   * CascadeButton or CascadeButtonGadget that resides in a
   * MenuBar, a Popup MenuPane, a Pulldown MenuPane, or an
   * OptionMenu.  This is done by using the button resource
   * subMenuId.  To function correctly when incorporated into a
   * menu, the PulldownMenu's hierarchy must be considered; this
   * hierarchy depends on the type of menu system that is being
   * built as follows:
   * 
   *  + If the PulldownMenu is to be pulled down from a MenuBar,
   *    its parent must be the MenuBar.
   * 
   *  + If the PulldownMenu is to be pulled down from a PopupMenu
   *    or another PulldownMenu, its parent must be that PopupMenu
   *    or PulldownMenu.
   * 
   *  + If the PulldownMenu is to be pulled down from an
   *    OptionMenu, its parent must be the same as the OptionMenu
   *    parent.
   *)
  (# <B>init</B><A name="PulldownMenu.1:init.2(678)"></A><A name="init.2(678)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
       do true -&gt; doNotManageChild;
          INNER 
       #);
     
     &lt;&lt;SLOT PulldownMenuLib: attributes&gt;&gt;
  #) (* PulldownMenu *);

<B>MenuBar</B><A name="MenuBar.1(679)"></A>: RowColumn
  (* A MenuBar is a RowColumn widget of type XmMENU_BAR.  A
   * MenuBar is generally used for building a Pulldown menu system.
   * Typically, a MenuBar is created and placed along the top of
   * the application window, and several CascadeButtons are
   * inserted as the children.  Each of the CascadeButtons has a
   * PulldownMenu associated with it. These PulldownMenus must have
   * been created as children of the MenuBar.  The user interacts
   * with the MenuBar by using either the mouse or the keyboard.  A
   * MenuBar displays a 3-D shadow along its border.  The
   * application controls the shadow attributes using the
   * visual-related resources supported by Manager.  A MenuBar
   * widget is homogeneous in that it accepts only children that
   * are specializations of CascadeButton or CascadeButtonGadget.
   * Attempting to insert a child of a different class results in a
   * warning message.  If a MenuBar does not have enough room to
   * fit all of its subwidgets on a single line, the MenuBar
   * attempts to wrap the remaining entries onto additional lines
   * if allowed by the geometry manager of the parent widget.
   *)
  (# <B>init</B><A name="MenuBar.1:init.2(680)"></A><A name="init.2(680)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
       do INNER 
       #);
     
     &lt;&lt;SLOT MenuBarLib: attributes&gt;&gt;
  #) (* MenuBar *);

<B>OptionMenu</B><A name="OptionMenu.1(681)"></A>: RowColumn
  (* An OptionMenu is a RowColumn widget of type XmMENU_OPTION.
   * An OptionMenu widget is a specialized RowColumn manager
   * composed of a label, a selection area, and a single Pulldown
   * MenuPane.  When an application creates an OptionMenu widget,
   * it supplies the label string and the PulldownMenu.  In order
   * to succeed, there must be a valid subMenuId resource set.
   * When the OptionMenu is created, the PulldownMenu must have
   * been created as a child of the OptionMenu's parent and must be
   * specified.  The LabelGadget and the selection area (a
   * CascadeButtonGadget) are created by the OptionMenu.  An
   * OptionMenu is laid out with the label displayed on one side of
   * the widget and the selection area on the other side.  The
   * selection area has a dual purpose; it displays the label of
   * the last item selected from the associated PulldownMenu, and
   * it provides the means for posting the PulldownMenu.  An
   * OptionMenu typically does not display any 3-D visuals around
   * itself or the internal LabelGadget.  By default, the internal
   * CascadeButtonGadget has a visible 3-D shadow.  The application
   * may change this by getting the CascadeButtonGadget ID using
   * the getButtonGadget pattern, and then calling XtSetValues
   * using the standard visual-related resources.  The PulldownMenu
   * is posted by moving the mouse pointer over the selection area
   * and pressing a mouse button defined by OptionMenu's RowColumn
   * parent.  The PulldownMenu is posted and positioned so that the
   * last selected item is directly over the selection area.  The
   * mouse is then used to arm the desired menu item.  When the
   * mouse button is released, the armed menu item is selected and
   * the label within the selection area is changed to match that
   * of the selected item.  The OptionMenu also operates by using
   * the keyboard interface mechanism.  If the application has
   * established a mnemonic with the OptionMenu, typing Alt with
   * the mnemonic causes the PulldownMenu to be posted with
   * traversal enabled. The standard traversal keys can then be
   * used to move within the Menu.  Selection can occur as the
   * result of pressing the Return key or typing a mnemonic or
   * accelerator for one of the menu items.  An application may use
   * the menuHistory resource to indicate which item in the
   * PulldownMenu should be treated as the current choice and have
   * its label displayed in the selection area.  By default, the
   * first item in the PulldownMenu is used.
   *)
  (# <B>init</B><A name="OptionMenu.1:init.2(682)"></A><A name="init.2(682)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
          subMenu:&lt; IntegerValue
            (* Pulldown MenuPane to post - MUST be specified *);
       do INNER 
       #);
     
     (* Utility patterns *)
     <B>getButtonGadget</B><A name="OptionMenu.1:getButtonGadget.2(683)"></A><A name="getButtonGadget.2(683)"></A>: IntegerValue
       (* Obtains the widget ID for the internally created
        *         CascadeButtonGadget.
        *)
       (# do ... #);
     <B>getLabelGadget</B><A name="OptionMenu.1:getLabelGadget.2(684)"></A><A name="getLabelGadget.2(684)"></A>: IntegerValue
       (* Obtains the widget ID for the internally created
        * LabelGadget.
        *)
       (# do ... #);
     
     &lt;&lt;SLOT OptionMenuLib: attributes&gt;&gt;
  #) (* OptionMenu *);

<B>RadioBox</B><A name="RadioBox.1(685)"></A>: RowColumn
  (* A RadioBox is a RowColumn widget of type XmWORK_AREA.
   * Typically, this is a composite widget that contains multiple
   * ToggleButtonGadgets. The RadioBox arbitrates and ensures that
   * at most one ToggleButtonGadget is on at any time.  This
   * pattern provides initial values for several RowColumn
   * resources.  It initializes packing to XmPACK_COLUMN,
   * radioBehavior to True, isHomogeneous to True, and entryClass
   * to xmToggleButtonGadgetClass.  In a RadioBox the ToggleButton
   * or ToggleButtonGadget resource indicatorType defaults to
   * XmONE_OF_MANY, and the ToggleButton or ToggleButtonGadget
   * resource visibleWhenOff defaults to True.
   *)
  (# <B>init</B><A name="RadioBox.1:init.2(686)"></A><A name="init.2(686)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
       do INNER 
       #);
     
     &lt;&lt;SLOT RadioBoxLib: attributes&gt;&gt;
  #) (* RadioBox *);

(* Aliases used in CompositeLib *) 
<B>mRowColumn</B><A name="mRowColumn.1(687)"></A>: RowColumn (# #);
<B>mMenuBar</B><A name="mMenuBar.1(688)"></A>: MenuBar(# #);
<B>mOptionMenu</B><A name="mOptionMenu.1(689)"></A>: OptionMenu(# #);
<B>mPopupMenu</B><A name="mPopupMenu.1(690)"></A>: PopupMenu (# #);
<B>mPulldownMenu</B><A name="mPulldownMenu.1(691)"></A>: PulldownMenu(# #);
<B>mRadioBox</B><A name="mRadioBox.1(692)"></A>: RadioBox(# #);

--- CompositeLib: attributes ---

(* Redefinitions of widgets within composites making the composite
 * the default father of the widgets
 *)
<B>RowColumn</B><A name="RowColumn.1(693)"></A>: mRowColumn
  (# <B>init</B><A name="RowColumn.1:init.2(694)"></A><A name="init.2(694)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #);
<B>PopupMenu</B><A name="PopupMenu.1(695)"></A>: mPopupMenu
  (# <B>init</B><A name="PopupMenu.1:init.2(696)"></A><A name="init.2(696)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #);
<B>PulldownMenu</B><A name="PulldownMenu.1(697)"></A>: mPullDownMenu
  (# <B>init</B><A name="PulldownMenu.1:init.2(698)"></A><A name="init.2(698)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #);
<B>MenuBar</B><A name="MenuBar.1(699)"></A>: MMenuBar
  (# <B>init</B><A name="MenuBar.1:init.2(700)"></A><A name="init.2(700)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #);
<B>OptionMenu</B><A name="OptionMenu.1(701)"></A>: MOptionMenu
  (# <B>init</B><A name="OptionMenu.1:init.2(702)"></A><A name="init.2(702)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #);
<B>RadioBox</B><A name="RadioBox.1(703)"></A>: MRadioBox
  (# <B>init</B><A name="RadioBox.1:init.2(704)"></A><A name="init.2(704)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="scrolledwindow.html"><IMG ALIGN=BOTTOM SRC="../../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="frame.html"><IMG ALIGN=BOTTOM SRC="../../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../../index.html"><IMG ALIGN=BOTTOM SRC="../../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
