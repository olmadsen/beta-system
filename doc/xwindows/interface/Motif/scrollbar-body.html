<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Scrollbar Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="scrollbar">Scrollbar Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'primitive';
BODY 'private/scrollbarbody';

(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-97 
 *       All rights reserved.
 *)

-- XtEnvLib: attributes --

<B>ScrollBar</B><A name="ScrollBar.1(186)"></A>: Primitive
  (* The ScrollBar widget allows the user to view data that is too
   * large to be displayed all at once.  ScrollBars are usually
   * located inside a ScrolledWindow and adjacent to the widget that
   * contains the data to be viewed.  When the user interacts with the
   * ScrollBar, the data within the other widget scrolls.  A ScrollBar
   * consists of two arrows placed at each end of a rectangle.  The
   * rectangle is called the scroll region.  A smaller rectangle,
   * called the slider, is placed within the scroll region.  The data
   * is scrolled by clicking either arrow, selecting on the scroll
   * region, or dragging the slider.  When an arrow is selected, the
   * slider within the scroll region is moved in the direction of the
   * arrow by an amount supplied by the application.  If the mouse
   * button is held down, the slider continues to move at a constant
   * rate.  The ratio of the slider size to the scroll region size
   * typically corresponds to the relationship between the size of the
   * visible data and the total size of the data.  For example, if 10
   * percent of the data is visible, the slider typically occupies 10
   * percent of the scroll region.  This provides the user with a
   * visual clue to the size of the invisible data.
   *)
  (# <B>init</B><A name="ScrollBar.1:init.2(187)"></A><A name="init.2(187)"></A>::&lt; 
       (# WidgetClass::&lt;
            (#
            do INNER; 
               (if value=0 then xmScrollbarWidgetClass-&gt;value if)
            #)
       do INNER
       #);
     
     (* ScrollBar resources *)
     <B>value</B><A name="ScrollBar.1:value.2(188)"></A><A name="value.2(188)"></A>: 
       (* Specifies the slider's position, between minimum and
        * (maximum - sliderSize).
        *)
       IntegerResource(# resourceName::&lt; XmNvalue #);
     <B>minimum</B><A name="ScrollBar.1:minimum.2(189)"></A><A name="minimum.2(189)"></A>: 
       (* Specifies the slider's minimum value. *)
       IntegerResource(# resourceName::&lt; XmNminimum #);
     <B>maximum</B><A name="ScrollBar.1:maximum.2(190)"></A><A name="maximum.2(190)"></A>: 
       (* Specifies the slider's maximum value. *)
       IntegerResource(# resourceName::&lt; XmNmaximum #);
     <B>sliderSize</B><A name="ScrollBar.1:sliderSize.2(191)"></A><A name="sliderSize.2(191)"></A>: 
       (* Specifies the length of the slider between the values of 1
        * and (maximum - minimum).  When (maximum - minimum) is less
        * than 100, the default value is the lesser of 10 and (maximum
        * - minimum); otherwise, the default value is (maximum -
        * minimum) divided by 10.
        *)
       IntegerResource(# resourceName::&lt; XmNsliderSize #);
     <B>showArrows</B><A name="ScrollBar.1:showArrows.2(192)"></A><A name="showArrows.2(192)"></A>: 
       (* Specifies whether the arrows are displayed. *)
       BooleanResource(# resourceName::&lt; XmNshowArrows #);
     <B>orientation</B><A name="ScrollBar.1:orientation.2(193)"></A><A name="orientation.2(193)"></A>: 
       (* Specifies whether THIS(ScrollBar) is displayed vertically
        * or horizontally.  This resource can have values of
        * XmVERTICAL and XmHORIZONTAL
        *)
       CharResource(# resourceName::&lt; XmNorientation #);
     <B>processingDirection</B><A name="ScrollBar.1:processingDirection.2(194)"></A><A name="processingDirection.2(194)"></A>: 
       (* Specifies whether the value for maximum should be on the
        * right or left side of minimum for horizontal ScrollBars or
        * above or below minimum for vertical ScrollBars.  This
        * resource can have values of XmMAX_ON_TOP, XmMAX_ON_BOTTOM,
        * XmMAX_ON_LEFT, and XmMAX_ON_RIGHT.  If THIS(ScrollBar) is
        * oriented vertically, the default value is XmMAX_ON_BOTTOM.
        * If THIS(ScrollBar) is oriented horizontally, the default
        * value may depend on the value of the stringDirection
        * resource.
        *)
       CharResource(# resourceName::&lt; XmNprocessingDirection #);
     <B>increment</B><A name="ScrollBar.1:increment.2(195)"></A><A name="increment.2(195)"></A>: 
       (* Specifies the amount by which the value increases or
        * decreases when the user takes an action that moves the
        * slider by one increment.  The actual change in value is the
        * lesser of increment and (previous value - minimum) when the
        * slider moves to the end of THIS(ScrollBar) with the minimum
        * value, and the lesser of increment and (maximum - sliderSize
        * - previous value) when the slider moves to the end of
        * THIS(ScrollBar) with the maximum value.
        *)
       IntegerResource(# resourceName::&lt; XmNincrement #);
     <B>pageIncrement</B><A name="ScrollBar.1:pageIncrement.2(196)"></A><A name="pageIncrement.2(196)"></A>: 
       (* Specifies the amount by which the value increases or
        * decreases when the user takes an action that moves the
        * slider by one page increment.  The actual change in value is
        * the lesser of pageIncrement and (previous value - minimum)
        * when the slider moves to the end of THIS(ScrollBar) with the
        * minimum value, and the lesser of pageIncrement and (maximum-
        * sliderSize - previous value) when the slider moves to the
        * end of THIS(ScrollBar) with the maximum value.
        *)
       IntegerResource(# resourceName::&lt; XmNpageIncrement #);
     <B>initialDelay</B><A name="ScrollBar.1:initialDelay.2(197)"></A><A name="initialDelay.2(197)"></A>: 
       (* Specifies the amount of time in milliseconds to wait before
        * starting continuous slider movement while a button is
        * pressed in an arrow or the scroll region.
        *)
       IntegerResource(# resourceName::&lt; XmNinitialDelay #);
     <B>repeatDelay</B><A name="ScrollBar.1:repeatDelay.2(198)"></A><A name="repeatDelay.2(198)"></A>: 
       (* Specifies the amount of time in milliseconds to wait
        * between subsequent slider movements after the initialDelay
        * has been processed.
        *)
       IntegerResource(# resourceName::&lt; XmNrepeatDelay #);
     <B>troughColor</B><A name="ScrollBar.1:troughColor.2(199)"></A><A name="troughColor.2(199)"></A>:
       (* Specifies the color of the slider trough. *)
       IntegerResource(# resourceName::&lt; XmNtroughColor #);
     
     (* Utility patterns *)
     <B>values</B><A name="ScrollBar.1:values.2(200)"></A><A name="values.2(200)"></A>:
       (* A pattern that accesses THIS(ScrollBar)'s increment values
        *)
       (# value: @integer
            (* The slider position between the minimum and maximum
             * resources.
             *);
          slider_size: @integer
            (* The size of the slider as a value between zero and the
             * absolute value of maximum minus minimum.  The size of
             * the slider varies, depending on how much of the slider
             * scroll area it represents.
             *);
          increment: @integer
            (* The amount of increment and decrement *);
          page_increment: @integer
            (* The amount of page increment and decrement *);
          get:
            (# 
            do ...
            exit (value, slider_size, increment, page_increment)
            #);
          set:
            (# notify: @boolean
                 (* If true, the valueChangedCallback is called *);
            enter (value, slider_size, increment, 
                   page_increment, notify)
            do ...
            #);
       enter set
       exit get
       #);
     
     (* Callbacks *)
     <B>ScrollBarCallback</B><A name="ScrollBar.1:ScrollBarCallback.2(201)"></A><A name="ScrollBarCallback.2(201)"></A>: MotifCallback
       (* Prefix for callbacks in THIS(ScrollBar) *)
       (# callData::&lt; XmScrollBarCallbackStruct do INNER #);
     
     <B>valueChangedCallback</B><A name="ScrollBar.1:valueChangedCallback.2(202)"></A><A name="valueChangedCallback.2(202)"></A>::&lt; ScrollBarCallback
       (* Called when the slider is released after being dragged.  It
        * is also called in place of incrementCallback,
        * decrementCallback, pageIncrementCallback,
        * pageDecrementCallback, toTopCallback, or toBottomCallback
        * when one of these callbacks would normally be called but the
        * value of the corresponding resource is NULL.  The reason
        * passed to the callback is XmCR_VALUE_CHANGED.
        *); 
     <B>incrementCallback</B><A name="ScrollBar.1:incrementCallback.2(203)"></A><A name="incrementCallback.2(203)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves
        * THIS(ScrollBar) by one increment and the value increases.
        * The reason passed to the callback is XmCR_INCREMENT
        *);
     <B>decrementCallback</B><A name="ScrollBar.1:decrementCallback.2(204)"></A><A name="decrementCallback.2(204)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves
        * THIS(ScrollBar) by one increment and the value decreases.
        * The reason passed to the callback is XmCR_DECREMENT.
        *);
     <B>pageIncrementCallback</B><A name="ScrollBar.1:pageIncrementCallback.2(205)"></A><A name="pageIncrementCallback.2(205)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves
        * THIS(ScrollBar) by one page increment and the value
        * increases.  The reason passed to the callback is
        * XmCR_PAGE_INCREMENT.
        *);
     <B>pageDecrementCallback</B><A name="ScrollBar.1:pageDecrementCallback.2(206)"></A><A name="pageDecrementCallback.2(206)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves
        * THIS(ScrollBar) by one page increment and the value
        * decreases.  The reason passed to the callback is
        * XmCR_PAGE_DECREMENT.
        *);
     <B>toTopCallback</B><A name="ScrollBar.1:toTopCallback.2(207)"></A><A name="toTopCallback.2(207)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves the slider
        * to the end of THIS(ScrollBar) with the minimum value.  The
        * reason passed to the callback is XmCR_TO_TOP
        *);
     <B>toBottomCallback</B><A name="ScrollBar.1:toBottomCallback.2(208)"></A><A name="toBottomCallback.2(208)"></A>::&lt; ScrollBarCallback
       (* Called when the user takes an action that moves the slider
        * to the end of THIS(ScrollBar) with the maximum value.  The
        * reason passed to the callback is XmCR_TO_BOTTOM.
        *);
     <B>dragCallback</B><A name="ScrollBar.1:dragCallback.2(209)"></A><A name="dragCallback.2(209)"></A>::&lt; ScrollBarCallback
       (* Called on each incremental change of position when the
        * slider is being dragged.  The reason sent by the callback is
        * XmCR_DRAG.
        *);
     (* Inherited callbacks *)
     <B>helpCallback</B><A name="ScrollBar.1:helpCallback.2(210)"></A><A name="helpCallback.2(210)"></A>::&lt; ScrollBarCallback;

     <B>installCallbacks</B><A name="ScrollBar.1:installCallbacks.2(211)"></A><A name="installCallbacks.2(211)"></A>::&lt; (* Private *)
       (# do ...; INNER #);
     
     &lt;&lt;SLOT ScrollbarLib: attributes&gt;&gt;
  #) (* Scrollbar *);

(* Alias used in CompositeLib *) 
<B>mScrollbar</B><A name="mScrollbar.1(212)"></A>: Scrollbar(# #);

--- CompositeLib: attributes ---

(* Redefinitions of widget within composites making the composite the
 * default father of the widget
 *)
<B>Scrollbar</B><A name="Scrollbar.1(213)"></A>: mScrollbar
  (# <B>init</B><A name="Scrollbar.1:init.2(214)"></A><A name="init.2(214)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Scrollbar Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
