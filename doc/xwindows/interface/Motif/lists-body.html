<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Lists Interface</TITLE>
<LINK REL="stylesheet" HREF="../../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="lists">Lists Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'primitive';
BODY 'private/listsbody';
INCLUDE 'scrolledwindow';

(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-97 
 *       All rights reserved.
 *)

-- XtEnvLib: attributes -- 

<B>MotifList</B><A name="MotifList.1(307)"></A>: Primitive
  (* MotifList allows a user to select one or more items from a
   * group of choices.  Items are selected from the list in a
   * variety of ways, using both the pointer and the keyboard.
   * MotifList operates on a StringArray that are defined by the
   * application.  Each string becomes an item in the MotifList,
   * with the first string becoming the item in position 1, the
   * second string becoming the item in position 2, and so on.
   *)
  (# <B>init</B><A name="MotifList.1:init.2(308)"></A><A name="init.2(308)"></A>::&lt; 
       (# WidgetClass::&lt;
            (#
            do INNER; 
               (if value=0 then xmListWidgetClass-&gt;value if)
            #)
       do INNER 
       #);
     
     (* Resources *)
     <B>listSpacing</B><A name="MotifList.1:listSpacing.2(309)"></A><A name="listSpacing.2(309)"></A>: 
       (* Specifies the spacing between list items.  This spacing
        * increases by the value of the highlightThickness resource
        * in Primitive.
        *)
       IntegerResource(# resourceName::&lt; XmNlistSpacing #);
     <B>listMarginWidth</B><A name="MotifList.1:listMarginWidth.2(310)"></A><A name="listMarginWidth.2(310)"></A>: 
       (* Specifies the width of the margin between the list
        * border and the items.
        *)
       ShortResource(# resourceName::&lt; XmNlistMarginWidth #);
     <B>listMarginHeight</B><A name="MotifList.1:listMarginHeight.2(311)"></A><A name="listMarginHeight.2(311)"></A>: 
       (* Specifies the height of the margin between the list
        * border and the items.
        *)
       ShortResource(# resourceName::&lt; XmNlistMarginHeight #);
     <B>fontList</B><A name="MotifList.1:fontList.2(312)"></A><A name="fontList.2(312)"></A>: 
       (* Specifies the font list associated with the list items.
        * This is used in conjunction with the visibleItemsCount
        * resource to determine the height of the List widget.  If
        * this value is unspecified at initialization, it is
        * initialized by looking up the parent hierarchy of the
        * widget for an ancestor that is a specialization of
        * BulletinBoard, VendorShell, or MenuShell.  If such an
        * ancestor is found, the font list is initialized to the
        * appropriate default font list of the ancestor widget
        * (defaultFontList for VendorShell and MenuShell,
        * textFontList for BulletinBoard).
        *)
       IntegerResource(# resourceName::&lt; XmNfontList #);
     <B>stringDirection</B><A name="MotifList.1:stringDirection.2(313)"></A><A name="stringDirection.2(313)"></A>: 
       (* Specifies the initial direction to draw the strings.
        * The values are XmSTRING_DIRECTION_L_TO_R and
        * XmSTRING_DIRECTION_R_TO_L.  The value of this resource is
        * determined at creation time.  If THIS(MotifList)'s parent
        * is a manager, this value is inherited from
        * THIS(MotifList)'s parent, otherwise it is set to
        * XmSTRING_DIRECTION_L_TO_R.
        *)
       IntegerResource(# resourceName::&lt; XmNstringDirection #);
     <B>items</B><A name="MotifList.1:items.2(314)"></A><A name="items.2(314)"></A>: MotifStringArrayResource
       (* Points to an array of MotifStrings, that are to be
        * displayed as the list items.
        *)
       (# resourceName::&lt; XmNitems;
          counterName::&lt; XmNitemCount;
       #);
     <B>itemCount</B><A name="MotifList.1:itemCount.2(315)"></A><A name="itemCount.2(315)"></A>: 
       (* Specifies the total number of items.  This number must
        * match the items resource.  It is automatically updated by
        * THIS(MotifList) whenever an item is added to or deleted
        * from THIS(MotifList).
        *)
       IntegerResource(# resourceName::&lt; XmNitemCount #);
     <B>selectedItems</B><A name="MotifList.1:selectedItems.2(316)"></A><A name="selectedItems.2(316)"></A>: MotifStringArrayResource
       (* Array of MotifStrings that represents the list items
        * that are currently selected, either by the user or by the
        * application.
        *)
       (# resourceName::&lt; XmNselectedItems;
          counterName::&lt; XmNselectedItemCount;
       #);
     <B>selectedItemCount</B><A name="MotifList.1:selectedItemCount.2(317)"></A><A name="selectedItemCount.2(317)"></A>: 
       (* Specifies the number of strings in the selected items
        *         list.
        *)
       IntegerResource(# resourceName::&lt; XmNselectedItemCount #);
     <B>visibleItemCount</B><A name="MotifList.1:visibleItemCount.2(318)"></A><A name="visibleItemCount.2(318)"></A>: 
       (* Specifies the number of items that can fit in the
        * visible space of the list work area.  THIS(MotifList)
        * uses this value to determine its height.
        *)
       IntegerResource(# resourceName::&lt; XmNvisibleItemCount #);
     <B>selectionPolicy</B><A name="MotifList.1:selectionPolicy.2(319)"></A><A name="selectionPolicy.2(319)"></A>: 
       (* Defines the interpretation of the selection action.
        * This can be one of the following:
        * 
        *  + XmSINGLE_SELECT - An item is selected when mouse
        *    button 1 is clicked on it. The previously selected item
        *    is deselected. Only one item can be selected at a time.
        * 
        *  + XmMULTIPLE_SELECT - An unselected item is selected
        *    when mouse button 1 is clicked on it. Previously selected
        *    items remains seleted.  A selected item is deselected
        *    when mouse button 1 is clicked on it.
        * 
        *  + XmEXTENDED_SELECT - When mouse button 1 is pressed and
        *    held down while dragged up or down, all items between the
        *    initial item and the pointer are selected. Releasing
        *    mouse button 1 stops the selection proces, and those
        *    items selected remains selected.
        * 
        *  + XmBROWSE_SELECT - An item is selected when mouse
        *    button 1 is pressed on it. Dragging the pointer up or
        *    down from that point causes each succeeding item to be
        *    selected while the preceding item is deselected. When the
        *    mouse button is released, the item on which the pointer
        *    rests is selected.  This is the default.
        *)
       CharResource(# resourceName::&lt; XmNselectionPolicy #);
     <B>automaticSelection</B><A name="MotifList.1:automaticSelection.2(320)"></A><A name="automaticSelection.2(320)"></A>: 
       (* Invokes singleSelectionCallback when the user moves into
        * a new item if the value is True and the selection mode is
        * either XmBROWSE_SELECT or XmEXTENDED_SELECT.  If False,
        * no selection callbacks are invoked until the user
        * releases the mouse button.
        *)
       BooleanResource(# resourceName::&lt; XmNautomaticSelection #);
     <B>doubleClickInterval</B><A name="MotifList.1:doubleClickInterval.2(321)"></A><A name="doubleClickInterval.2(321)"></A>: 
       (* If a button click is followed by another button click
        * within the time span specified by this resource (in
        * milliseconds), the button clicks are considered a
        * double-click action, rather than two single-click
        * actions.  The default value is the display's multi-click
        * time.
        *)
       IntegerResource(# resourceName::&lt; XmNdoubleClickInterval #);

     (* Utility patterns *)
     <B>addItem</B><A name="MotifList.1:addItem.2(322)"></A><A name="addItem.2(322)"></A>:
       (* Adds an item to THIS(MotifList) at the given position.
        * If unselected is False, when the item is inserted, it is
        * compared with the current selectedItems list.  If the new
        * item matches an item on the selected list, it appears
        * selected. If unselected is True, the item does not appear
        * selected, even if it matches an item in the current
        * selectedItems list.
        *)
       (# item: @MotifString;
          position: @integer;
          unselected: @boolean;
       enter (item, position, unselected)
       do ...
       #);
     <B>addItems</B><A name="MotifList.1:addItems.2(323)"></A><A name="addItems.2(323)"></A>:
       (* Adds the specified items to THIS(MotifList) at the given
        * position.  The first item_count items of the items array
        * are added.  When the items are inserted into
        * THIS(MotifList), they are compared with the current
        * selectedItems list.  If the any of the new items matches
        * an item on the selected list, it appears selected.
        *)
       (# items: ^MotifStringArray;
          position: @integer;
       enter (items[], position)
       do ...
       #);
     <B>getItemPos</B><A name="MotifList.1:getItemPos.2(324)"></A><A name="getItemPos.2(324)"></A>:
       (* Obtain item number 'pos' *)
       (# pos: @integer;
          item: @MotifString;
       enter pos
       do ...
       exit item
       #);
     <B>getItemsPos</B><A name="MotifList.1:getItemsPos.2(325)"></A><A name="getItemsPos.2(325)"></A>:
       (* Obtain item number 'pos1' to 'pos2' *)
       (# pos1, pos2: @integer;
          theitems: ^MotifStringArray;
       enter (pos1, pos2)
       do ...
       exit theitems[]
       #);
     <B>deleteItem</B><A name="MotifList.1:deleteItem.2(326)"></A><A name="deleteItem.2(326)"></A>:
       (* Deletes a specified item from THIS(MotifList).  A
        * warning message appears if the item does not exist.
        *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>deleteItems</B><A name="MotifList.1:deleteItems.2(327)"></A><A name="deleteItems.2(327)"></A>:
       (* Deletes the specified items from THIS(MotifList).  A
        * warning message appears if the items do not exist.
        *)
       (# items: ^MotifStringArray;
       enter items[]
       do ...
       #);
     <B>deletePos</B><A name="MotifList.1:deletePos.2(328)"></A><A name="deletePos.2(328)"></A>:
       (* Deletes an item at a specified position.  A warning
        * message appears if the position does not exist.
        *)
       (# position: @integer
       enter position
       do ...
       #);
     <B>deleteItemsPos</B><A name="MotifList.1:deleteItemsPos.2(329)"></A><A name="deleteItemsPos.2(329)"></A>:
       (* Deletes the specified number of items from the list
        * starting at the specified position.
        *)
       (# item_count, position: @integer
       enter (item_count, position)
       do ...
       #);
     <B>deleteAllItems</B><A name="MotifList.1:deleteAllItems.2(330)"></A><A name="deleteAllItems.2(330)"></A>:
       (* Deletes all items from THIS(MotifList) *)
       (# position: @integer
       enter position
       do ...
       #);
     <B>replaceItem</B><A name="MotifList.1:replaceItem.2(331)"></A><A name="replaceItem.2(331)"></A>:
       (* Replaces the specified item of THIS(MotifList) with the
        * corresponding new item.
        *)
       (# old_item, new_item: @MotifString;
       enter (old_item, new_item)
       do ...
       #);
     <B>replaceItemPos</B><A name="MotifList.1:replaceItemPos.2(332)"></A><A name="replaceItemPos.2(332)"></A>:
       (* Replaces an item of THIS(MotifList) with new_item, at
        * the specified position in THIS(MotifList).
        *)
       (# new_item: @MotifString;
          position: @integer;
       enter (new_item, position)
       do ...
       #);
     <B>replaceItems</B><A name="MotifList.1:replaceItems.2(333)"></A><A name="replaceItems.2(333)"></A>:
       (* Replaces each specified item of THIS(MotifList) with a
        * corresponding new item.
        *)
       (# old_items, new_items: ^MotifStringArray;
       enter (old_items[], new_items[])
       do ...
       #);
     <B>replaceItemsPos</B><A name="MotifList.1:replaceItemsPos.2(334)"></A><A name="replaceItemsPos.2(334)"></A>:
       (* Replaces items of THIS(MotifList) with new_items,
        * starting at the specified position in THIS(MotifList).
        *)
       (# new_items: ^MotifStringArray;
          position: @integer;
       enter (new_items[], position)
       do ...
       #);
     <B>selectItem</B><A name="MotifList.1:selectItem.2(335)"></A><A name="selectItem.2(335)"></A>: 
       (* Highlights and adds the specified item to the current
        * selected list. The notify parameter specifies a Boolean
        * value that when True invokes the selection callback for
        * the current mode.  From an application interface view,
        * calling this function with notify True is
        * indistinguishable from a user-initiated selection action.
        *)
       (# item: @MotifString;
          notify: @boolean;
       enter (item, notify)
       do ...
       #);
     <B>selectPos</B><A name="MotifList.1:selectPos.2(336)"></A><A name="selectPos.2(336)"></A>: 
       (* Highlights an item at the specified position and adds it
        * to the list of selected items. The notify parameter
        * specifies a Boolean value that when True invokes the
        * selection callback for the current mode.  From an
        * application interface view, calling this function with
        * notify True is indistinguishable from a user-initiated
        * selection action.
        *)
       (# position: @integer;
          notify: @boolean;
       enter (position, notify)
       do ...
       #);
     <B>deselectItem</B><A name="MotifList.1:deselectItem.2(337)"></A><A name="deselectItem.2(337)"></A>: 
       (* Unhighlights and removes the specified item from the
        * selected list.
        *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>deselectPos</B><A name="MotifList.1:deselectPos.2(338)"></A><A name="deselectPos.2(338)"></A>: 
       (* Unhighlights the item at the specified position and
        * deletes it from the list of selected items.
        *)
       (# position: @integer;
       enter position
       do ...
       #);
     <B>deselectAllItems</B><A name="MotifList.1:deselectAllItems.2(339)"></A><A name="deselectAllItems.2(339)"></A>: 
       (* Unhighlights and removes all items from the selected
        *         list.
        *)
       (# 
       do ...
       #);
     <B>setPos</B><A name="MotifList.1:setPos.2(340)"></A><A name="setPos.2(340)"></A>: 
       (* Makes the item at the given position the first visible
        * position in THIS(MotifList).  Setting pos to 1 indicates
        * that the first item in the list is the first visible
        * item; setting pos to 2 indicates that the second item is
        * the first visible item; and so on.  Setting pos to 0
        * indicates that the last item in the list is the first
        * visible item.
        *)
       (# position: @integer;
       enter position
       do ...
       #);
     <B>setBottomPos</B><A name="MotifList.1:setBottomPos.2(341)"></A><A name="setBottomPos.2(341)"></A>: 
       (* Makes the item at the specified position the last
        * visible item in THIS(MotifList).  Setting pos to 1
        * indicates that the first item in the list is the last
        * visible item; setting pos to 2 indicates that the second
        * item is the last visible item; and so on.  Setting pos to
        * 0 indicates that the last item in the list is the last
        * visible item.
        *)
       (# position: @integer;
       enter position
       do ...
       #);
     <B>setItem</B><A name="MotifList.1:setItem.2(342)"></A><A name="setItem.2(342)"></A>: 
       (* Makes an existing item the first visible item in
        * THIS(MotifList).  The item can be any valid item in the
        * list.
        *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>setBottomItem</B><A name="MotifList.1:setBottomItem.2(343)"></A><A name="setBottomItem.2(343)"></A>: 
       (* Makes an existing item the last visible item in
        * THIS(MotifList).  The item can be any valid item in the
        * list.
        *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>setAddMode</B><A name="MotifList.1:setAddMode.2(344)"></A><A name="setAddMode.2(344)"></A>: 
       (* Allows applications control over Add Mode in the
        * extended selection model. If add_mode is True, Add Mode
        * is activated.  If add_mode is False, Add Mode is
        * deactivated.
        *)
       (# add_mode: @integer;
       enter add_mode
       do ...
       #);
     <B>itemExists</B><A name="MotifList.1:itemExists.2(345)"></A><A name="itemExists.2(345)"></A>: BooleanValue
       (* Checks if a specified item is present in the list. *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>itemPos</B><A name="MotifList.1:itemPos.2(346)"></A><A name="itemPos.2(346)"></A>: IntegerValue
       (* Exits the position of the first instance of the
        * specified item in a List.
        *)
       (# item: @MotifString;
       enter item
       do ...
       #);
     <B>getMatchPos</B><A name="MotifList.1:getMatchPos.2(347)"></A><A name="getMatchPos.2(347)"></A>: IntegerValue
       (* Exits an array of positions where a specified item is
        * found in THIS(MotifList).
        *)
       (# item: @MotifString;
          position_list: [1]@integer;
       enter item
       do ...
       exit position_list
       #);
     <B>getSelectedPos</B><A name="MotifList.1:getSelectedPos.2(348)"></A><A name="getSelectedPos.2(348)"></A>: IntegerValue
       (* Exits an array of the positions of the selected items in
        * THIS(MotifList).
        *)
       (# position_list: [1]@integer;
       do ...
       exit position_list
       #);
     <B>setHorizPos</B><A name="MotifList.1:setHorizPos.2(349)"></A><A name="setHorizPos.2(349)"></A>: 
       (* Scrolls to the specified position in the list.  If
        * THIS(MotifList).listSizePolicy is set to XmCONSTANT or
        * XmRESIZE_IF_POSSIBLE and the horizontal ScrollBar is
        * currently visible, the value resource of the horizontal
        * ScrollBar is set to the specified position and the
        * visible portion of the list is updated with the new
        * value.  This is equivalent to moving the horizontal
        * ScrollBar to the specified position.
        *)
       (# position: @integer;
       enter position
       do ...
       #);
     
     (* Callbacks *)
     <B>MotifListCallBack</B><A name="MotifList.1:MotifListCallBack.2(350)"></A><A name="MotifListCallBack.2(350)"></A>: MotifCallBack
       (* Prefix for MotifList specific Callbacks *)
       (# callData::&lt; XmListCallBackStruct do INNER #);
     
     <B>singleSelectionCallback</B><A name="MotifList.1:singleSelectionCallback.2(351)"></A><A name="singleSelectionCallback.2(351)"></A>:&lt; MotifListCallBack
       (* Called when an item is selected in single selection
        * mode.  The reason is XmCR_SINGLE_SELECT.
        *); 
     <B>multipleSelectionCallback</B><A name="MotifList.1:multipleSelectionCallback.2(352)"></A><A name="multipleSelectionCallback.2(352)"></A>:&lt; MotifListCallBack
       (* Called when an item is selected in multiple selection
        * mode.  The reason is XmCR_MULTIPLE_SELECT.
        *); 
     <B>extendedSelectionCallback</B><A name="MotifList.1:extendedSelectionCallback.2(353)"></A><A name="extendedSelectionCallback.2(353)"></A>:&lt; MotifListCallBack
       (* Called when items are selected using the extended
        * selection mode. The reason is XmCR_EXTENDED_SELECT.
        *); 
     <B>browseSelectionCallback</B><A name="MotifList.1:browseSelectionCallback.2(354)"></A><A name="browseSelectionCallback.2(354)"></A>:&lt; MotifListCallBack
       (* Called when an item is selected in the browse selection
        * mode.  The reason is XmCR_BROWSE_SELECT.
        *); 
     <B>defaultActionCallback</B><A name="MotifList.1:defaultActionCallback.2(355)"></A><A name="defaultActionCallback.2(355)"></A>:&lt; MotifListCallBack
       (* Called when an item is double clicked.  The reason is
        * XmCR_DEFAULT_ACTION.
        *);       
     (* Inherited callbacks *)
     <B>helpCallback</B><A name="MotifList.1:helpCallback.2(356)"></A><A name="helpCallback.2(356)"></A>::&lt; MotifListCallback;
     
     <B>installCallbacks</B><A name="MotifList.1:installCallbacks.2(357)"></A><A name="installCallbacks.2(357)"></A>::&lt; (* Private *)
       (# do ...; INNER #);
     
     &lt;&lt;SLOT MotifListLib: attributes&gt;&gt;
  #) (* MotifList *);

<B>ScrolledList</B><A name="ScrolledList.1(358)"></A>: MotifList
  (* A ScrolledList is a MotifList that is contained within a
   * ScrolledWindow.
   *)
  (# <B>init</B><A name="ScrolledList.1:init.2(359)"></A><A name="init.2(359)"></A>::&lt; (# WidgetClass::&lt; (# do ... #);
       do INNER 
       #);

     (* Resources belonging to the INNER MotifList *)
     <B>horizontalScrollbar</B><A name="ScrolledList.1:horizontalScrollbar.2(360)"></A><A name="horizontalScrollbar.2(360)"></A>:
       (* The horizontal Scrollbar. *)
       IntegerResource(# resourceName::&lt; XmNhorizontalScrollbar #);
     <B>listSizePolicy</B><A name="ScrolledList.1:listSizePolicy.2(361)"></A><A name="listSizePolicy.2(361)"></A>:
       (* Controls the reaction of THIS(MotifList) when an item
        * grows horizontally beyond the current size of
        * THIS(MotifList) work area.  If the value is XmCONSTANT,
        * THIS(MotifList) viewing area does not grow, and a
        * horizontal ScrollBar is added for a ScrolledList.  If
        * this resource is set to XmVARIABLE, the List grows to
        * match the size of the longest item, and no horizontal
        * ScrollBar appears.  When the value of this resource is
        * XmRESIZE_IF_POSSIBLE, THIS(MotifList) attempts to grow or
        * shrink to match the width of the widest item.  If it
        * cannot grow to match the widest size, a horizontal
        * ScrollBar is added for a ScrolledList if the longest item
        * is wider than THIS(MotifList) viewing area.  The size
        * policy must be set at the time THIS(MotifList) widget is
        * created, i.e. from a resource file, or in
        * fallbackResources. It cannot be changed after creation.
        *)
       CharResource(# resourceName::&lt; XmNlistSizePolicy #);
     <B>scrollBarDisplayPolicy</B><A name="ScrolledList.1:scrollBarDisplayPolicy.2(362)"></A><A name="scrollBarDisplayPolicy.2(362)"></A>:
       (* Controls the display of vertical ScrollBars in a
        * ScrolledList.  When the value of this resource is
        * XmAS_NEEDED, a vertical ScrollBar is displayed only when
        * the number of items in THIS(MotifList) exceeds the number
        * of Visible items.  When the value is XmSTATIC, a vertical
        * ScrollBar is always displayed.
        *)
       CharResource(# resourceName::&lt; XmNscrollBarDisplayPolicy #);
     <B>scrollbarPlacement</B><A name="ScrolledList.1:scrollbarPlacement.2(363)"></A><A name="scrollbarPlacement.2(363)"></A>:
       (* Specifies the positioning of the ScrollBars in relation
        * to the visible items. The following are the values:
        * 
        *  + XmTOP_LEFT - The horizontal ScrollBar is placed above
        *    the visible items, and the vertical ScrollBar to the left
        *    of the visible items.
        * 
        *  + XmBOTTOM_LEFT - The horizontal ScrollBar is placed
        *    below the visible items, and the vertical ScrollBar to
        *    the left of the visible items.
        * 
        *  + XmTOP_RIGHT - The horizontal ScrollBar is placed above
        *    the visible items, and the vertical ScrollBar to the
        *    right of the visible items.
        * 
        *  + XmBOTTOM_RIGHT - The horizontal ScrollBar is placed
        *    below the visible items, and the vertical ScrollBar to
        *    the right of the visible items.
        *)
       IntegerResource(# resourceName::&lt; XmNscrollBarPlacement #);
     <B>scrolledWindowMarginWidth</B><A name="ScrolledList.1:scrolledWindowMarginWidth.2(364)"></A><A name="scrolledWindowMarginWidth.2(364)"></A>: 
       (* Specifies the margin width on the right and left sides
        * of the ScrolledWindow.
        *)
       IntegerResource
         (# resourceName::&lt; XmNscrolledWindowMarginWidth #);
     <B>scrolledWindowMarginHeight</B><A name="ScrolledList.1:scrolledWindowMarginHeight.2(365)"></A><A name="scrolledWindowMarginHeight.2(365)"></A>: 
       (* Specifies the margin height on the top and bottom of the
        * ScrolledWindow.
        *)
       IntegerResource
         (# resourceName::&lt; XmNscrolledWindowMarginHeight #);
     <B>spacing</B><A name="ScrolledList.1:spacing.2(366)"></A><A name="spacing.2(366)"></A>: 
       (* Specifies the distance that separates the ScrollBars
        * from the visible items.
        *)
       IntegerResource(# resourceName::&lt; XmNspacing #);
     <B>verticalScrollBar</B><A name="ScrolledList.1:verticalScrollBar.2(367)"></A><A name="verticalScrollBar.2(367)"></A>: 
       (* The horizontal Scrollbar. *)
       IntegerResource(# resourceName::&lt; XmNverticalScrollBar #);
     
     (* Utility patterns *)
     <B>getScrolledWindow</B><A name="ScrolledList.1:getScrolledWindow.2(368)"></A><A name="getScrolledWindow.2(368)"></A>:
       (* Used to obtain the SrcolledWindow widget automatically
        * created as surrounding the list widget of
        * THIS(ScrolledList).  This can be used to manipulate
        * resources belonging to the ScrolledWindow, e.g. geometric
        * resources.
        *)
       (# scrolled: ^ScrolledWindow;
       do &amp;ScrolledWindow[] -&gt; scrolled[];
          theWidget -&gt; XtParent -&gt; scrolled.thewidget;
       exit scrolled[]
       #);

     &lt;&lt;SLOT ScrolledListLib: attributes&gt;&gt;
  #) (* ScrolledList *);

(* Aliases used in CompositeLib *) 
<B>mList</B><A name="mList.1(369)"></A>: MotifList(# #);
<B>mScrolledList</B><A name="mScrolledList.1(370)"></A>: ScrolledList(# #);

--- CompositeLib: attributes ---

(* Redefinitions of widgets within composites making the composite
 * the default father of the widgets
 *)
<B>MotifList</B><A name="MotifList.1(371)"></A>: mList
  (# <B>init</B><A name="MotifList.1:init.2(372)"></A><A name="init.2(372)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #); 
       do INNER 
       #)
  #);
<B>ScrolledList</B><A name="ScrolledList.1(373)"></A>: mScrolledList
  (# <B>init</B><A name="ScrolledList.1:init.2(374)"></A><A name="init.2(374)"></A>::&lt; (# GetFatherWidget::&lt; (# do THIS(Composite)-&gt;value #);
       do INNER 
       #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Lists Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
