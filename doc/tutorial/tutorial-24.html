<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> 12 Text Manipulation</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING24></A>


<P><A HREF=tutorial-25.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-23.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P>Libraries Tutorial</P>


<A NAME=HEADING24-0></A>
<H1> 12 Text Manipulation</H1>
<P> The basic BETA environment defines a Text<A NAME=MARKER-2-84></A> pattern for manipulating texts. Text constants have been used a lot in the previous examples. Here we explore more on the many facilities of the text concept. Constant texts can be assigned to text variables and texts can be added: </P>
<PRE CLASS=beta>
(# t: @text;(* declare t as a static ref. to a text object *)
   r: ^text;(* declare t as a dynamic ref. to a text object *)
   i: @integer;
do 'foo' -&gt; t;       (* assign a constant to t = 'foo'   *)
   ' ' -&gt; t.append;  (* append  one blank to t = 'foo '  *)
   ' ' -&gt; t.prepend; (* prepend one blank to t = ' foo ' *)
   t.length -&gt; i;    (* assign the length of t to i (5)  *)
   (2,4) -&gt; t.sub -&gt; r[]; (* get substring 'foo' from t *)
#)
</PRE>

<P> Users do not have to bother about extending the text when adding or manipulating. The length of the text object will automatically be adjusted. Many functions on texts uses a current position in the text (t.pos). For example:</P>
<PRE CLASS=beta>
(# t: @text;
do 'foo'-&gt;t; (* sets pos to t.length *)
   'bar'-&gt;t.puttext; (* adds 'bar' after current pos: t='foobar'*)
   1-&gt;t.pos;
   'bar'-&gt;t.puttext; (* t = 'barbar' *)
#)
</PRE>
<P> Texts sub-strings can be fetched and assigned to another text object reference, and texts can be inserted at a specified position:</P>
<PRE CLASS=beta>
(# t: @text;   (* declare t as a static ref.  to a text object *)
   r: ^text;   (* declare t as a dynamic ref. to a text object *)
do ' foo ' -&gt; t;          (* assign a constant to t = ' foo ' *)
   (2,4) -&gt; t.sub -&gt; r[]; (* get substring 'foo' from t *)
   ('bar',5) -&gt; t.insert; (* insert substring 'bar' in t = ' foobar ' *)
#)
</PRE>
<P> Texts can be compared using the equal function. </P>

<PRE CLASS=beta>
(# t: @text;
   b: @boolean;
do ...
   'foo' -&gt; t.equal -&gt; b;    (* case sensitive comparison *)
   'foo' -&gt; t.equalNCS -&gt; b; (* not case sensitive comparison *)
#)
</PRE>
<P> The following example program is an extended version of the character counting programs constructed before. The program can count either characters or lines in the input file. In addition to text comparison, the program uses two new features.</P>
<P>  getline: reads from input, i.e. what the user types. Waits until the user has typed a newline</P>

<P>  ascii.newline: ascii is an object defined in betaenv containing attributes for manipulating and comparing ASCII characters. newline is a generic definition of the newline character. ascii also contains conversion functions, e.g. toLower, definition of white space, e.g. isWhiteSpace, etc.</P>
<A NAME=HEADING24-16></A>
<H4 CLASS=betacaption><A NAME="fig:Program 12.1: FileCount.bet"> Program 12.1: FileCount.bet</A></H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/file'
---- program: descriptor ----

(# (* ----------------------------------------------
    *   count.bet: Simple file handling program
    *              -Counting lines/characters-
    * ----------------------------------------------*)
   
   inFile: @file;
   Ch: @char;
   nc: @integer;
   answer: ^text;
   lines, chars: @Boolean;
do
   (if NoofArguments 
    // 2 then 
       2->Arguments->inFile.name ;
       inFile.openRead;  (* OPENING *)
       'Count what in \''->Puttext;   inFile.name->PutText;
       '\' (lines/chars)? '->PutText;
       GetLine->answer[]; (* read from keybord ­ what the user types *)
       (if true
	//('lines'->answer.equal) then true->lines;
	//('chars'->answer.equal) then true->chars;
	else 
	   'Unknown input'->PutLine;
	   Stop; (* end execution *)
       if);
       Loop: 
	 (if inFile.eos//false then
	     inFile.Get->Ch; 
	     (if true
	      //lines then (if Ch//ascii.newline then nc + 1->nc if);
	      //chars then nc + 1->nc;
	     if);
	     restart Loop
	 if);
       NewLine;
       nc->PutInt; 
       (if true
	//lines then ' lines '->PutText;
	//chars then ' characters '->PutText;
       if);
       'in file \''->Puttext;
       inFile.name->PutText;
       '\'\n\n'->PutText;
       inFile.close;
    else 
       'Missing Argument'->putline;
   if)
#)
</PRE>
<P> The output running FileCount on itself is:</P>
<PRE CLASS=beta>
nil% FileCount FileCount.bet
Count what in 'FileCount.bet' (lines/chars)? lines

46 lines in file 'FileCount.bet'

nil% FileCount FileCount.bet
Count what in 'FileCount.bet' (lines/chars)? chars 

1238 characters in file 'FileCount.bet'
</PRE>
<P> Finally, the table below lists some of the useful attributes of texts:</P>

<TABLE BORDER=1><CAPTION>
</CAPTION><TR VALIGN=TOP><TD>
t.length
</TD><TD>Returns number of characters of text
</TD></TR><TR VALIGN=TOP><TD>t.pos
</TD><TD>Returns current position
</TD></TR><TR VALIGN=TOP><TD>t.empty -&gt; b
</TD><TD>Returns True if t is empty
</TD></TR><TR VALIGN=TOP><TD>t.clear -&gt; b
</TD><TD>Sets the length to zero
</TD></TR><TR VALIGN=TOP><TD>c -&gt; t.put
</TD><TD>Appends the character c to t 
</TD></TR><TR VALIGN=TOP><TD>t.get -&gt; c
</TD><TD>Returns the character at current position, and increments position by 1
</TD></TR><TR VALIGN=TOP><TD>t.peek -&gt; c
</TD><TD>Returns the character at current position, without updating the position
</TD></TR><TR VALIGN=TOP><TD>r[] -&gt; t.puttext
</TD><TD>Adds r to t starting at current position
</TD></TR><TR VALIGN=TOP><TD>r[] -&gt; t.prepend
</TD><TD>Prepends the text r to t
</TD></TR><TR VALIGN=TOP><TD>r[] -&gt; t.append
</TD><TD>Appends the text r to t
</TD></TR><TR VALIGN=TOP><TD>i -&gt; t.putint
</TD><TD>Inserts the integer i to t starting at current position 
</TD></TR><TR VALIGN=TOP><TD>t.getint -&gt; i
</TD><TD>Reads the next integer from t starting at current position
</TD></TR><TR VALIGN=TOP><TD>t.getAtom -&gt; r[]
</TD><TD>Reads characters until next white-space and returns the text
</TD></TR><TR VALIGN=TOP><TD>t.getLine -&gt; r[]
</TD><TD>Reads characters from t until next newline and returns that text.
</TD></TR><TR VALIGN=TOP><TD>i -&gt; t.inxget -&gt; c
</TD><TD>Returns the character at position i 
</TD></TR><TR VALIGN=TOP><TD>(c,i) -&gt; t.inxput
</TD><TD>Replaces the character at position i 
</TD></TR><TR VALIGN=TOP><TD>t.copy -&gt; r[]
</TD><TD>Returns a copy of t
</TD></TR><TR VALIGN=TOP><TD>r[]-&gt;(t.copy).append-&gt;s[]
</TD><TD>Returns s[] where s = t cat r<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-3">[3]</A></EM>
</TD></TR><TR VALIGN=TOP><TD>r[]-&gt;(t.copy).prepend-&gt;s[]
</TD><TD>Returns s[] where s = r cat t
</TD></TR><TR VALIGN=TOP><TD>t.scanAtom(# do ... #)
</TD><TD>Scans from current position until next white-space and call INNER for each char
</TD></TR><TR VALIGN=TOP><TD>t.scanAll(# do ... #)
</TD><TD>Scans all the elements in t and calls INNER for each char
</TD></TR><TR VALIGN=TOP><TD>(i,j) -&gt; t.sub -&gt; r[]
</TD><TD>Returns the text from position i to position j from t
</TD></TR><TR VALIGN=TOP><TD>(i,j) -&gt; t.delete
</TD><TD>Deletes characters in the range i:j
</TD></TR><TR VALIGN=TOP><TD>r[] -&gt; t.less
</TD><TD>Tests whether r is less than t. Lexicographic ordering is used
</TD></TR><TR VALIGN=TOP><TD>r[]-&gt;t.greater
</TD><TD>Tests whether r is greater than t. Lexicographic ordering is used
</TD></TR><TR VALIGN=TOP><TD>t.makeLC
</TD><TD>Converts all characters to lower case 
</TD></TR><TR VALIGN=TOP><TD>t.makeUC
</TD><TD>Converts all characters to upper case
</TD></TR><TR VALIGN=TOP><TD>c -&gt; findAll(# do ... #)
</TD><TD>Calls INNER for each occurrence of c in t
</TD></TR><TR VALIGN=TOP><TD>t.EOSerror
</TD><TD>Called when reading past length of the text
</TD></TR></TABLE>
<P> </P>

<P> Please see the basic libraries manual <A HREF="../bibliography/index.html#mia90-8">[MIA 90-8]</A> for more details about the text concept.</P>






<HR>

<A NAME=FOOTNOTE-3>[3] </A>
 Actually this is an example of how to combine patterns that exits references. Append is called on the reference returned by copy. This facility is called computed remote.













<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Libraries Tutorial</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=tutorial-25.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-23.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
