<H1>Text Manipulation</H1>
<P> The basic BETA environment defines a <INX>Text</INX> pattern for manipulating texts. Text constants have been used a lot in the previous examples. Here we explore more on the many facilities of the text concept. Constant texts can be assigned to text variables and texts can be added: </P>
<BETA>
(# t: @text;(* declare t as a static ref. to a text object *)
   r: ^text;(* declare t as a dynamic ref. to a text object *)
   i: @integer;
do 'foo' -> t;       (* assign a constant to t = 'foo'   *)
   ' ' -> t.append;  (* append  one blank to t = 'foo '  *)
   ' ' -> t.prepend; (* prepend one blank to t = ' foo ' *)
   t.length -> i;    (* assign the length of t to i (5)  *)
   (2,4) -> t.sub -> r[]; (* get substring 'foo' from t *)
#)
</BETA>

<P> Users do not have to bother about extending the text when adding or manipulating. The length of the text object will automatically be adjusted. Many functions on texts uses a current position in the text (t.pos). For example:</P>
<BETA>
(# t: @text;
do 'foo'->t; (* sets pos to t.length *)
   'bar'->t.puttext; (* adds 'bar' after current pos: t='foobar'*)
   1->t.pos;
   'bar'->t.puttext; (* t = 'barbar' *)
#)
</BETA>
<P> Texts sub-strings can be fetched and assigned to another text object reference, and texts can be inserted at a specified position:</P>
<BETA>
(# t: @text;   (* declare t as a static ref.  to a text object *)
   r: ^text;   (* declare t as a dynamic ref. to a text object *)
do ' foo ' -> t;          (* assign a constant to t = ' foo ' *)
   (2,4) -> t.sub -> r[]; (* get substring 'foo' from t *)
   ('bar',5) -> t.insert; (* insert substring 'bar' in t = ' foobar ' *)
#)
</BETA>
<P> Texts can be compared using the equal function. </P>

<BETA>
(# t: @text;
   b: @boolean;
do ...
   'foo' -> t.equal -> b;    (* case sensitive comparison *)
   'foo' -> t.equalNCS -> b; (* not case sensitive comparison *)
#)
</BETA>
<P> The following example program is an extended version of the character counting programs constructed before. The program can count either characters or lines in the input file. In addition to text comparison, the program uses two new features.</P>
<P>  getline: reads from input, i.e. what the user types. Waits until the user has typed a newline</P>

<P>  ascii.newline: ascii is an object defined in betaenv containing attributes for manipulating and comparing ASCII characters. newline is a generic definition of the newline character. ascii also contains conversion functions, e.g. toLower, definition of white space, e.g. isWhiteSpace, etc.</P>
<A NAME=HEADING24-16></A>
<BETA SRC="$BETALIB/demo/tutorial/FileCount.bet" LIST="FileCount.bet">

<P> The output running FileCount on itself is:</P>
<BETA>
nil% FileCount FileCount.bet
Count what in 'FileCount.bet' (lines/chars)? lines

46 lines in file 'FileCount.bet'

nil% FileCount FileCount.bet
Count what in 'FileCount.bet' (lines/chars)? chars 

1238 characters in file 'FileCount.bet'
</BETA>
<P> Finally, the table below lists some of the useful attributes of texts:</P>

<TABLE BORDER=1><CAPTION>
</CAPTION><TR VALIGN=TOP><TD>
t.length
</TD><TD>Returns number of characters of text
</TD></TR><TR VALIGN=TOP><TD>t.pos
</TD><TD>Returns current position
</TD></TR><TR VALIGN=TOP><TD>t.empty -> b
</TD><TD>Returns True if t is empty
</TD></TR><TR VALIGN=TOP><TD>t.clear -> b
</TD><TD>Sets the length to zero
</TD></TR><TR VALIGN=TOP><TD>c -> t.put
</TD><TD>Appends the character c to t 
</TD></TR><TR VALIGN=TOP><TD>t.get -> c
</TD><TD>Returns the character at current position, and increments position by 1
</TD></TR><TR VALIGN=TOP><TD>t.peek -> c
</TD><TD>Returns the character at current position, without updating the position
</TD></TR><TR VALIGN=TOP><TD>r[] -> t.puttext
</TD><TD>Adds r to t starting at current position
</TD></TR><TR VALIGN=TOP><TD>r[] -> t.prepend
</TD><TD>Prepends the text r to t
</TD></TR><TR VALIGN=TOP><TD>r[] -> t.append
</TD><TD>Appends the text r to t
</TD></TR><TR VALIGN=TOP><TD>i -> t.putint
</TD><TD>Inserts the integer i to t starting at current position 
</TD></TR><TR VALIGN=TOP><TD>t.getint -> i
</TD><TD>Reads the next integer from t starting at current position
</TD></TR><TR VALIGN=TOP><TD>t.getAtom -> r[]
</TD><TD>Reads characters until next white-space and returns the text
</TD></TR><TR VALIGN=TOP><TD>t.getLine -> r[]
</TD><TD>Reads characters from t until next newline and returns that text.
</TD></TR><TR VALIGN=TOP><TD>i -> t.inxget -> c
</TD><TD>Returns the character at position i 
</TD></TR><TR VALIGN=TOP><TD>(c,i) -> t.inxput
</TD><TD>Replaces the character at position i 
</TD></TR><TR VALIGN=TOP><TD>t.copy -> r[]
</TD><TD>Returns a copy of t
</TD></TR><TR VALIGN=TOP><TD>r[]->(t.copy).append->s[]
</TD><TD>Returns s[] where s = t cat r
<FOOTNOTE>Actually this is an example of how to combine patterns that
exits references. Append is called on the reference returned by
copy. This facility is called computed remote</FOOTNOTE> 
</TD></TR><TR VALIGN=TOP><TD>r[]->(t.copy).prepend->s[]
</TD><TD>Returns s[] where s = r cat t
</TD></TR><TR VALIGN=TOP><TD>t.scanAtom(# do ... #)
</TD><TD>Scans from current position until next white-space and call INNER for each char
</TD></TR><TR VALIGN=TOP><TD>t.scanAll(# do ... #)
</TD><TD>Scans all the elements in t and calls INNER for each char
</TD></TR><TR VALIGN=TOP><TD>(i,j) -> t.sub -> r[]
</TD><TD>Returns the text from position i to position j from t
</TD></TR><TR VALIGN=TOP><TD>(i,j) -> t.delete
</TD><TD>Deletes characters in the range i:j
</TD></TR><TR VALIGN=TOP><TD>r[] -> t.less
</TD><TD>Tests whether r is less than t. Lexicographic ordering is used
</TD></TR><TR VALIGN=TOP><TD>r[]->t.greater
</TD><TD>Tests whether r is greater than t. Lexicographic ordering is used
</TD></TR><TR VALIGN=TOP><TD>t.makeLC
</TD><TD>Converts all characters to lower case 
</TD></TR><TR VALIGN=TOP><TD>t.makeUC
</TD><TD>Converts all characters to upper case
</TD></TR><TR VALIGN=TOP><TD>c -> findAll(# do ... #)
</TD><TD>Calls INNER for each occurrence of c in t
</TD></TR><TR VALIGN=TOP><TD>t.EOSerror
</TD><TD>Called when reading past length of the text
</TD></TR></TABLE>
<P> </P>

<P> Please see the basic libraries manual <A HREF="../bibliography/index.html#mia90-8">[MIA 90-8]</A> for more details about the text concept.</P>










