<H1> 10 Files</H1>
<P> Our objective in this section is to open a file and analyze the characters that it contains. This means that we will be doing input for the first time. At first, we will merely count the characters in the file but we will also use command-line arguments to apply the program to various files.</P>

<P> File handling in BETA is quite painless. Files for both input and output are implemented through a single pattern: file. This pattern is not in the standard environment betaenv but in an extended library called file which includes betaenv so it is sufficient to replace betaenv by file in the ORIGIN statement.</P>
<P> A complete program skeleton to read a file called data1 is as follows:</P>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/file'
--- program: descriptor ---
(# F: @File;
do 'data1' -&gt; F.Name;
   F.openRead;

   (*... use F ...*)

   F.close;
#)
</PRE>
<P> Here, F is declared as a file variable. The external file name is provided then openread is invoked. After use, the close operation should be called. Here we have used only three attributes of the pattern file:</P>

<UL>
<LI> Name
<LI> OpenRead
<LI> Close
</UL>
<P> Other useful attributes/operations are:</P>
<UL>
<LI> OpenWrite: creates an empty file or erases the current contents of an existing one
<LI> OpenAppend: positions for writing at end of existing data
<LI> OpenReadWrite: to allow Get, Put and Pos operations
<LI> Get: returns the next character
<LI> Put: writes or appends a character
<LI> Eos: end-of-file check
</UL>
<P> The standard while &lt;not end-of-file&gt; loop for sequentially handling the contents of a file translates into the following BETA code:</P>

<PRE CLASS=beta>
Loop: 
  (if not F.Eos then
      F.get -&gt; ch;(* reading the next element *)
      ...
      restart Loop
  if);
</PRE>
<P> Here is the whole program for counting the characters in the file data1. We have added visual feedback to the user by printing '.' on the screen for every 10 characters read. Note that using the input/output predicates directly (i.e. put or get) without . notation (i.e. f.get) accesses the standard streams (keyboard and screen).</P>
<A NAME=HEADING20-23></A>
<H4 CLASS=betacaption><A NAME="fig:Program 10.1: CountChar.bet"> Program 10.1: CountChar.bet</A></H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/file'
---- program: descriptor ----

(# (* 
    *   CountChar.bet: Simple file handling program
    *                  -Counting characters-
    *)

   inFile: @file;
   Ch:     @char;
   nc:     @integer;
do
   'data1' -&gt;  inFile.name;  inFile.openRead;  (* OPENING *)
   'Reading: '-&gt; puttext;   inFile.name -&gt; putline;
  Loop:
    (if not inFile.eos then
        inFile.get -&gt; ch; 
        nc + 1 -&gt; nc;
        (if nc mod 10 = 0 then '.' -&gt; put  if);
        restart Loop
    if);
    newline;
    nc -&gt; putint; ' characters in file' -&gt; putline;
    inFile.close;
#)
</PRE>
<P> The output looks like this:</P>
<PRE CLASS=beta>
nil% CountChar
Reading: data1
....
41 characters in file
</PRE>
<P> If the file data1 is not present, execution gives the following error message.</P>

<PRE CLASS=beta>
nil% CountChar

**** Exception processing
File exception for 'data1'
No such file

# Beta execution aborted: Stop is called
# Look at CountChar.dump'
</PRE>












