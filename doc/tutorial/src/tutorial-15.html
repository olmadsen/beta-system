<H2>Attribute Access</H2>
<P> So far we have concentrated on showing that BETA objects can behave either as classical data variables or as procedures. The example patterns that we showed often had local attributes (of primitive types) used either to implement value or to hold temporary results of computations. </P>

<P> BETA objects also function as structured (or record) data and the local attributes are accessible via the traditional dot notation. For the POINT P1 defined in the previous section, the examples below show how its local attributes X and Y can be both read and set directly:</P>
<BETA>
0 -> P1.X; 123 -> P1.Y;
P1.X -> putint;
</BETA>
<P> Notice, that the first line is equivalent to: (0,123) -&gt; P1.</P>
<P> The local attributes can have any type and could be function objects. Below, we use a modified Point pattern which has a third attribute dist to compute the distance from the origin.</P>

<BETA>
Point: (# X,Y: @real;
          dist: @(# exit (X*X + Y*Y) -> sqrt #);
       enter (X,Y)  
       exit  (X,Y)
       #);

P1,P2 : @Point;
</BETA>
<P> This third attribute is read-only (because it has no enter list) but can be consulted just like X and Y:</P>
<BETA>
(3,4) -> P1; 
P1.dist -> putint;(* will print &quot;5&quot;  *) 
</BETA>

<P> Many object-oriented languages enforce encapsulation by disallowing direct reading or writing of the local variables and restrict access to the invocation of the local methods. Smalltalk is the obvious example of this approach but even Simula, where by default all local data and methods are accessible, introduced a Hidden/Protected mechanism to allow protection. This is meant to enforce separation of the provided behavior from the details of implementation. </P>
<P> In the BETA language, there is no provision for hiding the internal details of an object. The mechanisms for protection as well as those for modularization and configuration management are relegated to a separate <INX>fragment system</INX> which is described in the last section of this tutorial.</P>

