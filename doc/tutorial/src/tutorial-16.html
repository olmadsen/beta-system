<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> 8 Dynamic Data Structures</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING16></A>


<P><A HREF=tutorial-17.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-15.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P>Libraries Tutorial</P>


<A NAME=HEADING16-0></A>
<H1> 8 Dynamic Data Structures</H1>
<P> The variables that we have declared so far (with @) are said to be static objects and the variable names are said to be static references.</P>
<P> Advanced programming requires more than just static data structures. In particular, list processing is based on the notion of dynamically created objects linked by pointers. Recursive procedures also rely on dynamically allocated activation records. More to the point, objects are generally created on demand with a new operator.</P>

<P> In BETA, pointers or dynamic references as they are called are declared very much as in C using the * token. Below, we declare refA and refB to be references to Point objects whereas the declaration for P1 and P2 cause storage space to be reserved for 2 points and associate (permanently) the names P1 and P2 to those points.</P>
<PRE CLASS=beta>
refA, refB: ^Point;
P1,P2: @Point;
</PRE>
<P> Initially, refA and refB point nowhere and have the value NONE whereas P1 and P2 designate real live points. Thus, we can assign data to P1 but not to refA.</P>
<PRE CLASS=beta>
P1 -&gt; P2;      (* OK *)
P1 -&gt; refA;    (* run-time error because refA is NONE *)
</PRE>
<P> This seems normal but reread these two imperatives carefully. Anyone having used pointers in other languages should notice that the BETA pointer concept is a little different that most other languages. We have used (correctly) the same notation for the variable and for the pointer. If this were C, with:</P>
<PRE CLASS=beta>
Point p1,p2;
Point *refA,*refB;
</PRE>
<P> then refA would represent the address of a Point and *refA would be used to denote the contents of that Point. In C, the assignments would have read</P>
<PRE CLASS=beta>
p2 = p1;
*refA = p1;
</PRE>
<P> Now we can return to the BETA approach to dynamic data which is quite different from the traditional one. </P>

<P> In BETA, a pointer is treated as a reference which may point to different objects (or to NONE) at different times during execution whereas a variable is considered to be a reference which will always denote the same object. Thus both are references but one is static and the other dynamic and they will be used in the same way to access the data. The concept of pointer storage address is avoided.</P>
<P> In BETA, simple use of a reference (static or dynamic) in an evaluation refers to the contents of the object referenced. Thus, assuming that refA and refB designate Points (and not NONE) then,</P>
<PRE CLASS=beta>
(0.0, 0.0) -&gt; P1 -&gt; refA -&gt; refB -&gt; P2 ;
</PRE>
<P> means that the contents (or value) of each point is set to (0,0).</P>

<P> To manipulate references to objects and not just the contents, we need to use a reference operator. In BETA, this is a postfix operator written [] (read box). Thus the following imperative:</P>
<PRE CLASS=beta>
refA[] -&gt; refB[];
</PRE>
<P> has the effect that refB now points to (references) the same object as refA. </P>
<P> BETA's approach is the converse of C's: BETA uses a referencing operator and C uses a dereferencing operator.</P>
<P> </P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION>
<TR VALIGN=TOP><TH><P> Assignment Type</P>
</TH><TH><P> BETA</P>
</TH><TH><P> C</P>
</TH></TR>
<TR VALIGN=TOP><TH><P> Content</P>
</TH><TD><P> refA -&gt; refB;</P>
</TD><TD><P> *refB = *refA;</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Reference</P>
</TH><TD><P> refA[] -&gt; refB[];</P>
</TD><TD><P> refB = refA;</P>
</TD></TR></TABLE><P> </P>

<P> In BETA, it is also possible to make a dynamic reference denote a static object. This can also be done in C:</P>
<PRE CLASS=beta>
BETA:	P1[] -&gt; refA[] 
C:		refA = &amp;P1; 
</PRE>

<P> This is one way to give dynamic references values other than NONE. The other and more obvious one involves dynamic creation of new objects at run-time. In BETA, the new operator is written &amp;. Thus,</P>
<PRE CLASS=beta>
&amp;Point
</PRE>
<P> causes a new point object to be created. Now, comes a delicate aspect. </P>
<P> To create a new object and to get the address of this new Point, we also need the reference operator:</P>
<PRE CLASS=beta>
&amp;Point[] -&gt; refA[];
</PRE>
<P> As mentioned in section 3.2.3 of the BETA book, this is a subtle point: </P>
<P> 'The difference between &amp;P and &amp;P[] is very important: the expression &amp;P means 'generate a new instance of P and execute it'; the expression &amp;P[] means 'generate a new instance of P without executing it and return a reference to this new object'.'</P>
<P> In C a Point is allocated like this:</P>
<PRE CLASS=beta>
refA = (Point*) malloc(sizeof(Point));
</PRE>
<P> The following program shows the use of static and dynamic references. This uses a Point user-type with integer attributes. There are 2 static references, P1 and P2, and a dynamic reference, refA. At various points in the program refA points to either P1 or P2 or to a dynamically allocated object. Note that access to Points via the static or dynamic variables is syntactically identical. We assign various values to the three references and use dump to show the contents of the first attributes of all three. This shows that effectively refA designates various Points during execution. At the end, we show the use of a dynamically generated Point in a cascaded assignment. In this case, the purpose is just to show that it can be done and what happens. Useful version of this dynamic generation will be shown later.</P>

<PRE CLASS=beta>
(111,333) -&gt; &amp;Point -&gt; P1;
</PRE>
<P> What happens here is that </P>
<UL>
<LI>1) a new Point object is created, 
<LI>2) the values (111,333) are assigned to the variables in the enter list of the new Object, 
<LI>3) the (empty) do part of the object is executed, 
<LI>4) a value assignment is done between the exit list of the Point and the enter list of P1 and 
<LI>5) finally, the (empty) do part of P1 is executed. The newly created Point is inaccessible and the space it occupies will be reclaimed by the garbage collector.
</UL>
<P> Instead using the reference operator gives: </P>

<PRE CLASS=beta>
(111,333) -&gt; &amp;Point[] -&gt; refA[];
</PRE>
<P> What happens here is that </P>
<UL>
<LI>1) a new Point object is created, 
<LI>2) the values (111,333) are assigned to the variables in the enter list of the new object, 
<LI>3) a reference assignment is done between newly created object and refA. refA now refers to the new object.
</UL>
<A NAME=HEADING16-93></A>
<H4 CLASS=betacaption><A NAME="fig:Program 8: StaticAndDynamic.bet"> Program 8: StaticAndDynamic.bet</A></H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv'
---- program: descriptor ----
(#
  (* Static and Dynamic references *)

   Point: (# X,Y: @integer;
          enter (X,Y)
          exit  (X,Y)
          #);

   refA : ^Point;
   P1,P2: @Point;

Dump:
  (#
  do 'P1: ' -&gt; puttext;
     P1.X -&gt; screen.putint(# format::(# do 3-&gt;width#)#);
     ', P2: ' -&gt; puttext; P2.X -&gt; putint;
     ', refA: ' -&gt; puttext; refA.X -&gt; putint;
     newline;
  #);

do
   'Dynamic references' -&gt; putline;
   newline;

   &amp;Point[] -&gt; refA[];

   (1,1) -&gt; P1-&gt; P2 -&gt; refA;
   Dump;

   (2,2) -&gt; P2;
   (3,3) -&gt; refA;
   Dump;

   P1[] -&gt; refA[];  Dump;
   P2[] -&gt; refA[];  Dump;

   (1,1) -&gt; P1; (2,2) -&gt; P2; (3,3) -&gt; refA;
   Dump;

   (111,333) -&gt; &amp;Point -&gt; P1;
   Dump;
   Newline;
#)
</PRE>
<P> The results from execution are shown below:</P>
<PRE CLASS=beta>
Dynamic references

P1:   1, P2: 1, refA: 1
P1:   1, P2: 2, refA: 3
P1:   1, P2: 2, refA: 1
P1:   1, P2: 2, refA: 2
P1:   1, P2: 3, refA: 3
P1: 111, P2: 3, refA: 3
</PRE>











<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Libraries Tutorial</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=tutorial-17.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-15.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
