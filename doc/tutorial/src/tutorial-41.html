<H2><INX>Interface</INX> and <INX>Implementation</INX></H2>
<P> The fragment system can be used to separate interface from implementation. In the putBoxed example above we included the implementation of the operation in the interface. We can move the implementation of putBoxed to another file using a dopart slot. This is specified as follows:</P>

<BETA>
  putBoxed: 
     (* print the text with a box surrounding: 
      * 'text'->putBoxed results in '[text]'
      *)
    (# t: ^Text;
    enter t[]
    <<SLOT putBoxed: dopart>>
    #);
</BETA>
<P> Here we have described only the interface of putBoxed, i.e. it can be seen that the operation takes a text as a argument (and the comment states that the operation will print the text with a surrounding box). The implementation is hidden. The implementation can be described in a dopart fragment:</P>

<BETA>
---putBoxed: dopart---
    do '['->put; t[]-> puttext; ']'->put;
</BETA>
<P> In order to make things work we must specify where the implementation can be found. This is done using a <INX>BODY</INX> specification in the putBoxed.bet file:</P>
<P> The file with the ---putBoxed: dopart--- fragment must specify where the dopart fragment is to be filled. This is done using the ORIGIN:</P>
<BETA LIST="putBoxed.bet">
ORIGIN '~beta/basiclib/betaenv';
BODY 'putBoxedBody'
---LIB: Attributes---
  putBoxed: 
     (* print the text with a box surrounding: 
      * 'text'->putBoxed results in '[text]'
      *)
    (# t: ^Text;
    enter t[]
    <<SLOT putBoxed: dopart>>
    #);
</BETA>
<A NAME=HEADING41-9></A>
<A NAME=HEADING41-12></A>
<BETA LIST="putBoxedBody.bet">
ORIGIN 'putBoxed'
---putBoxed: dopart---
    do '['->put; t[]-> puttext; ']'->put;
</BETA>

<P> Another major advantage of separating the implementation from the interface is separate compilation. The putBoxed.bet and the putBoxedBody.bet file can be separately compiled, and the putBoxedBody.bet file can be changed and recompiled without recompiling the interface file putBoxed.bet or any of the programs that are using the library putBoxed.</P>
<P> The HelloWorld program using the putBoxed library has not changed:</P>
<A NAME=HEADING41-17></A>
<BETA SRC="$BETALIB/demo/tutorial/HelloWorld.bet" LIST="HelloWorld.bet">

<P> And the expanded BETA program, using the files: betaenv, HelloWorld, putBoxed, and putBoxedBody is (exactly as above):</P>
<A NAME=HEADING41-20></A>
<BETA LIST="HelloWorld with filled program and LIB slot">
(* The basic BETA environment betaenv *)
(# ...
   put: (# c: @char; enter c do ... #);
   puttext: (# t: ^text; enter t[] do ... #);
   putline: (# t: ^text; enter t[] do t[]->puttext; newline #);
   newline: (# do ... #);
   text: (# ... #);
   putBoxed: 
     (* print the text with a box surrounding: 
      * 'text'->putBoxed results in '[text]'
      *)
    (# t: ^Text;
    enter t[]
    do '['->put; t[]-> puttext; ']'->put;
    #);
   ...
do (* initialize for execution *)
   (#
   do 'Hello World!'->putline;
   #)
   (* terminate execution *)
#)
</BETA>

<P> The fragment system is described in abstract terms in the BETA book <A HREF="../bibliography/index.html#mmn93">[MMN 93]</A>. That description also suggests many ideas of how to use the fragment system. The current implementation of the fragment system is described in the compiler manual <A HREF="../bibliography/index.html#mia90-2">[MIA 90-2]</A>.</P>












