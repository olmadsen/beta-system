<H2> 7.1 Patterns and Variables</H2>
<P> In BETA, a descriptor can be given a name. Thereafter, the name becomes a short-hand form for the full description. The association of name and descriptor is written amongst the declarations and is known as a pattern declaration<A NAME=MARKER-2-52></A>. It has the following syntax:</P>

<PRE CLASS=beta>
&lt;pattern-name&gt;: &lt;prefix&gt; &lt;descriptor&gt;  
</PRE>
<P> Thereafter, the pattern name or the descriptor can be used interchangeably and the term pattern is used to mean either form. prefix is an optional name of a pattern that pattern-name inherits from.</P>
<P> As we have seen previously, variable declarations are characterized by the @ token:</P>

<PRE CLASS=beta>
&lt;variable-names&gt;: @&lt;pattern&gt;
</PRE>
<P> Examples:</P>
<PRE CLASS=beta>
POINT: (# X,Y: @real;
 enter (X,Y)  
 exit (X,Y)
 #);

P1,P2: @Point;
P3: @(# X,Y: @real;
enter (X,Y)  exit (X,Y)
      #);
</PRE>
<P> P1 and P2 are considered to be objects of the same class. Note also that case is immaterial in BETA: POINT being the same as PoINt or point. </P>
<P> Thereafter, the following assignments are allowed:</P>
<PRE CLASS=beta>
P1 -&gt; p2;
(0,0) -&gt; p1 -&gt; p2 -&gt; p3;
</PRE>

<P> Note that BETA uses structural equivalence in its value assignments and comparisons. This is not as strict as in other languages and assignment is possible between variables of any two patterns with similar enter and exit lists. This was shown above (with identical lists) and if we define another pattern complex with two reals as value, assignment will be allowed between Point and complex objects.</P>
<PRE CLASS=beta>
C1: @(# Re,Im: @real;
     enter (Re, Im) 
     exit (Re, Im)
     #);
</PRE>







<!-- TOC -->




