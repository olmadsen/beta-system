<H2>Concurrency and User Interface Environments</H2>
<P> Graphical user interface environments are usually event-driven in the sense that actions in the program are executed as a response to user input events. To handle this, a separate implementation of systemenv exists for the different user interface library guienv:</P>
<UL>
<LI> Use ~beta/basiclib/systemenv as origin for programs not using event-driven user-interface libraries. 
<LI> Use ~beta/guienv/guienvsystemenv as origin for programs using GUIEnv interface library.
</UL>
<P> Please note, that programs should only use one of the systemenv, xsystemenv, and guienvsystemenv fragments.</P>

<P> Suppose that we like to extend the texteditor above with a clock that should be updated every second. A clock can easily be made using the basic systemenv:</P>
<A NAME=HEADING39-9></A>
<BETA SRC="$BETALIB/demo/tutorial/Clock.bet" LIST="Clock.bet">

<P> Here we simply print out the current system time on the screen. Notice, that we have included a new library called time in '~beta/sysutils/time'. This library contains facilities for getting the date and time, time usage, and for formatting times for nice printing. Running the program shown above gives the following result:</P>
<BETA>
Tue Aug 23 11:48:35 1994
Tue Aug 23 11:48:36 1994
Tue Aug 23 11:48:37 1994
Tue Aug 23 11:48:38 1994
Tue Aug 23 11:48:39 1994
Tue Aug 23 11:48:40 1994
Tue Aug 23 11:48:41 1994
Tue Aug 23 11:48:42 1994
Tue Aug 23 11:48:43 1994
Tue Aug 23 11:48:44 1994
Tue Aug 23 11:48:45 1994
Tue Aug 23 11:48:46 1994
Tue Aug 23 11:48:47 1994
Tue Aug 23 11:48:48 1994
Tue Aug 23 11:48:49 1994
</BETA>
<P> Now we want to integrate this clock in our GUIEnv texteditor program, so we can always see the time in the low left corner of the window. We need to use the '~beta/guienv/guienvsystemenv':</P>
<BETA>
ORIGIN  '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/fields'
        '~beta/guienv/stddialogs'
        '~beta/basiclib/file'
        '~beta/sysutils/time'
-- program: descriptor --
systemenv
(# 
   setWindowEnv:: (* tell systemenv that myguienv is the
                   * the graphical user interface
                   *)
     (# do myguienv[] -> theWindowEnv[] #);
   
   updateClock: @|System
     (# 
     do cycle
        (#
        do 1 -> sleep; 
           systemtime -> formattime -> ... ;
                            (* put time into the clock *)
        #);
     #);
                
   myguienv: @guienv (* inherit from guienv *)
     (# (* guienv code as before *)
     #);

do (* fork updateClock as a separate system *)
   updateClock[] -> fork;
#)
</BETA>
<P> We need to specify to systemenv what graphical user interface system we are using. This is done by extending the virtual setWindowEnv like the following:</P>

<BETA>
setWindowEnv::(# do myguienv[] -> theWindowEnv[] #);
</BETA>
<P> In order to do that, we have changed the guienv into a static object called myguienv. myguienv will automatically be started by systemenv.</P>
<P> Finally, we need to create a user interface element that can show the time. We use a staticText, that we position below the TextEditor field:</P>

<BETA>
clock: @staticText
  (# open::
       (# w,h: @integer;
       do systemtime -> formattime -> label;
          theWindow.size -> (w,h);
          (5,h-16) -> position; (50,15) -> size;
          True -> BindBottom; False -> BindTop;
       #);
  #);
</BETA>
<P> The complete program is:</P>

<A NAME=HEADING39-26></A>
<BETA SRC="$BETALIB/demo/tutorial/ClockTextEditor.bet" LIST="ClockTextEditor.bet">

<P> The following figure shows a snapshot of the program running on Motif:</P>
<P> <IMG SRC=clocktexteditor.gif></P>
<P> </P>
<A NAME=HEADING39-30></A>
<H2>Changes from the Original Design</H2>
<P> The abstractions defined here are based on the ones described in chapter 12 of the BETA book. The implementation is identical to the design in the BETA book, except for the following changes:</P>
<UL>
<LI>1. The syntax of fork is
<LI> S[]-&gt;fork  and not <INX>S.fork.</INX>
<LI>2. The syntax of conc is
</UL>
<INX HIDDEN>conc</INX>
<BETA>
	conc(# do S1[]->start; S2[]->start; S3[]->start #)
</BETA>
<UL>
<LI> and not conc(# do S1.start; S2.start; S3.start #).
<LI>3. The syntax of alt is
</UL>
<INX HIDDEN>alt</INX>
<BETA>
	alt (# do S1[]->start; S2[]->start; S3[]->start #)
</BETA>
<UL>
<LI> and not alt(# do S1.start; S2.start; S3.start #).
</UL>

<P> This implementation of systemenv includes some new facilities, not described in the BETA book:</P>
<UL>
<LI>4. semaphore had an additional attribute: tryP, which is a non-blocking call of P.
<LI>5. In addition to s[]-&gt;fork, s[]-&gt;kill is possible, and in addition to pause, 100 -&gt; sleep is possible.
<LI>6. system has a new virtual attribute, onKilled, that is invoked before the system terminates
<LI>7. systemenv has a new virtual attribute, deadlocked, that is invoked if all processes are deadlocked.
<LI>8. Finally, systemenv defines three new attributes to cope with event driven user interfaces: windowEnvType, theWindowEnv, and setWindowEnv. See further details on cooperation with user interface environments below.
</UL>

<P> In order to implement real concurrency, an interrupt mechanism must be implemented. This is currently not done. A component/system will thus keep the control until it makes an explicit or implicit SUSPEND. An implicit SUSPEND is made when a component must wait for a <INX>semaphore</INX>, or executes the pause and sleep patterns.</P>

<P> The systemenv libraries are thoroughly described in the manual <A HREF="../bibliography/index.html#mia94-25">[MIA 94-25]</A></P>












