<H2><INX>Primitive Types</INX></H2>
<P> In the previous section, all examples of static and dynamic references dealt with a user defined type, Point. Could we have done the same thing with one of the four primitive types in BETA: integer, char, boolean or real? The answer is no. For these 4 types, it is not legal to apply neither the new nor the reference operators. Similarly, we shall see later that other limitations apply and these types cannot be used as prefixes for other object definitions.</P>
<P> Thus the following expressions are illegal:</P>
<BETA>
RefInt: ^integer;(* ILLEGAL *)
&real -> ...(* ILLEGAL *)
</BETA>
<P> The reason is that for safe pointer operation, each object that can be designated by a dynamic reference (pointer) needs extra space for administrative data. In the case of primitive types, this overhead can be overwhelming and it has been chosen to handle them differently (and more efficiently) than other patterns. This is the same approach used in Simula, Pascal and Eiffel.</P>
<P> In Smalltalk, another approach was used: the language tries to treat all objects (and types) in exactly the same way. This makes for a very powerful system but, in spite of considerable research, Smalltalk programs are still bulky and notoriously slow.</P>
<P> With the &amp; operator, C allows pointers to anything and this is a major source of errors in C code that neither the compiler nor the run-time system can help to control.</P>

<P> For situations where one would like to use primitive objects in
ways identical to user-defined objects, BETA has defined 4 special
patterns: <INX>IntegerObject</INX>, <INX>CharObject</INX>,
<INX>RealObject</INX> and <INX>BooleanObject</INX>. These are completely compatible with their primitive counterparts (assignment, comparison, etc.) but dynamic creation (&amp;), the reference operator ([]), inheritance, etc., are allowed on them.</P>


