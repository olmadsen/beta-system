<H1>Repetitions (Arrays)</H1>
<P> In BETA arrays are called <INX>repetitions</INX>. </P>
<BETA>
A: [10] @integer;
</BETA>

<P> This repetition describes a set of static references to integers. 10 is called the range of the repetition (the upper bound). In spite that the lower bound is always 1, repetitions are flexible since the upper range is accessible as a local attribute of the repetition, they can be assigned, extended and sub-range access is possible (slices).</P>
<P> BETA repetitions compared to its C counterpart:</P>
<P> </P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION>
<TR VALIGN=TOP><TH><P> Language</P>
</TH><TH><P> BETA</P>
</TH><TH><P> C</P>
</TH></TR>
<TR VALIGN=TOP><TH><P> Declaration</P>
</TH><TD><P> A: [10] @integer;</P>
</TD><TD><P> int [10] A;</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Lower</P>
</TH><TD><P> 1</P>
</TD><TD><P> 0</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Upper</P>
</TH><TD><P> A.range</P>
</TD><TD><P> 9</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Size</P>
</TH><TD><P> A.range</P>
</TD><TD><P> 10</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Access</P>
</TH><TD><P> A[i]</P>
</TD><TD><P> A[i]</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Assignment</P>
</TH><TD><P> A -> B;</P>
</TD><TD><P> not possible</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Extend</P>
</TH><TD><P> 10 -> A.extend</P>
</TD><TD><P> not possible</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Slices</P>
</TH><TD><P> A[2..3]</P>
</TD><TD><P> not possible</P>
</TD></TR></TABLE>

<P> It should be noted that it is not possible to take the address of a repetition, i.e. A[] is illegal (legal in C as &amp;A).</P>
<P> In the current Mj&oslash;lner implementation, it is possible to declare repetitions of types: char, boolean, integer, real, and any object reference:</P>

<BETA>
(# Record: (# ... #);
   A: [100] ^Record;
do &Record[] -> A[1][]; (* create a new instance of Record and 
                         * assign it to first entry in A *)
    ...
#)
</BETA>
<P> Besides assigning values to the elements of a repetition, whole repetitions can be assigned to other repetitions regardless of their ranges, e.g.:</P>
<BETA>
a: [10] @integer;
b: [1] @integer;
do (for i: A.range repeat (* initialize a *)
        i -> a[i]; (* put i into i'th position in repetition a *)
    for);
    14 -> b[1]; (* a is [1,2,3,4,5,6,7,8,9,10], and 
                 * b is [14]
                 *)
    a -> b;     (* make repetition assignment:
                 * a is [1,2,3,4,5,6,7,8,9,10], and 
                 * b is [1,2,3,4,5,6,7,8,9,10]
                 *)
</BETA>

<P> The next program illustrates how to use repetitions in a simple sorting program called quick sort, originating from C.A.R Hoare. Given a repetition, one element is chosen and the others partitioned into two subsets: those less than and those greater than or equal to the partition element. The same process is then applied recursively to the two subsets. When a subset has fewer than two elements it does not need any sorting and the recursion stops.</P>
<P> In BETA it is illegal to use the reference operator on repetitions, and since the quick sort algorithm is inherently recursive with the repetition as function argument in each <INX>recursion</INX>, we face a problem. However, this problem is easily solved in BETA. We simply define a pattern containing a repetition, and using an object of this type as the argument to quick sort.</P>
<BETA>
  numberRepetition: (# r: [1] @Integer #);
  qsort:
    (# nr: ^numberRepetition;
    enter (nr[], ...)
    do ....
  #);
  numbers: @numberRepetition;
do
  ...
  qsort(numbers[],...);
</BETA>
<P> So the limitation of not being allowed to take a reference to repetitions is easily circumvented.</P>

<P> The quick sort algorithm also uses a swap operation, that swaps two elements in the repetition. This operation can be define locally inside (statically <INX>nested</INX> inside) qsort, so swap can operate on the same repetition:</P>
<BETA>
  qsort:
    (# nr: ^numberRepetition;
       swap:
         (# i,j: @Integer;
            temp: @Integer;
         enter (i,j)
         do nr.r[i] -> temp;
            nr.r[j] -> nr.r[i];
            temp -> nr.r[j];
         #);
    enter (nr[], ...)
    do ...
    #);
</BETA>
<P> The complete code including a loop for reading numbers to be sorted from the keyboard follows below:</P>
<A NAME=HEADING18-129></A>
<BETA SRC="$BETALIB/demo/tutorial/QuickSort.bet" LIST="QuickSort.bet">

<P> Running the program and typing some numbers results in the following output:</P>
<BETA>
nil% QuickSort
Type some numbers: 9 8 4 6 3 8 2 7 12 45 2 78 5 6 1 0 2
Sorted numbers: 0 1 2 2 2 3 4 5 6 6 7 8 8 9 12 45 78 
</BETA>












