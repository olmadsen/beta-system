<H1> 9 Repetitions (Arrays)</H1>
<P> In BETA arrays are called repetitions<A NAME=MARKER-2-71></A>. </P>
<PRE CLASS=beta>
A: [10] @integer;
</PRE>

<P> This repetition describes a set of static references to integers. 10 is called the range of the repetition (the upper bound). In spite that the lower bound is always 1, repetitions are flexible since the upper range is accessible as a local attribute of the repetition, they can be assigned, extended and sub-range access is possible (slices).</P>
<P> BETA repetitions compared to its C counterpart:</P>
<P> </P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION>
<TR VALIGN=TOP><TH><P> Language</P>
</TH><TH><P> BETA</P>
</TH><TH><P> C</P>
</TH></TR>
<TR VALIGN=TOP><TH><P> Declaration</P>
</TH><TD><P> A: [10] @integer;</P>
</TD><TD><P> int [10] A;</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Lower</P>
</TH><TD><P> 1</P>
</TD><TD><P> 0</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Upper</P>
</TH><TD><P> A.range</P>
</TD><TD><P> 9</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Size</P>
</TH><TD><P> A.range</P>
</TD><TD><P> 10</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Access</P>
</TH><TD><P> A[i]</P>
</TD><TD><P> A[i]</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Assignment</P>
</TH><TD><P> A -&gt; B;</P>
</TD><TD><P> not possible</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Extend</P>
</TH><TD><P> 10 -&gt; A.extend</P>
</TD><TD><P> not possible</P>
</TD></TR>
<TR VALIGN=TOP><TH><P> Slices</P>
</TH><TD><P> A[2..3]</P>
</TD><TD><P> not possible</P>
</TD></TR></TABLE>

<P> It should be noted that it is not possible to take the address of a repetition, i.e. A[] is illegal (legal in C as &amp;A).</P>
<P> In the current Mj&oslash;lner implementation, it is possible to declare repetitions of types: char, boolean, integer, real, and any object reference:</P>

<PRE CLASS=beta>
(# Record: (# ... #);
   A: [100] ^Record;
do &amp;Record[] -&gt; A[1][]; (* create a new instance of Record and 
                         * assign it to first entry in A *)
    ...
#)
</PRE>
<P> Besides assigning values to the elements of a repetition, whole repetitions can be assigned to other repetitions regardless of their ranges, e.g.:</P>
<PRE CLASS=beta>
a: [10] @integer;
b: [1] @integer;
do (for i: A.range repeat (* initialize a *)
        i -&gt; a[i]; (* put i into i'th position in repetition a *)
    for);
    14 -&gt; b[1]; (* a is [1,2,3,4,5,6,7,8,9,10], and 
                 * b is [14]
                 *)
    a -&gt; b;     (* make repetition assignment:
                 * a is [1,2,3,4,5,6,7,8,9,10], and 
                 * b is [1,2,3,4,5,6,7,8,9,10]
                 *)
</PRE>

<P> The next program illustrates how to use repetitions in a simple sorting program called quick sort, originating from C.A.R Hoare. Given a repetition, one element is chosen and the others partitioned into two subsets: those less than and those greater than or equal to the partition element. The same process is then applied recursively to the two subsets. When a subset has fewer than two elements it does not need any sorting and the recursion stops.</P>
<P> In BETA it is illegal to use the reference operator on repetitions, and since the quick sort algorithm is inherently recursive with the repetition as function argument in each recursion<A NAME=MARKER-2-74></A>, we face a problem. However, this problem is easily solved in BETA. We simply define a pattern containing a repetition, and using an object of this type as the argument to quick sort.</P>
<PRE CLASS=beta>
  numberRepetition: (# r: [1] @Integer #);
  qsort:
    (# nr: ^numberRepetition;
    enter (nr[], ...)
    do ....
  #);
  numbers: @numberRepetition;
do
  ...
  qsort(numbers[],...);
</PRE>
<P> So the limitation of not being allowed to take a reference to repetitions is easily circumvented.</P>

<P> The quick sort algorithm also uses a swap operation, that swaps two elements in the repetition. This operation can be define locally inside (statically nested<A NAME=MARKER-2-75></A> inside) qsort, so swap can operate on the same repetition:</P>
<PRE CLASS=beta>
  qsort:
    (# nr: ^numberRepetition;
       swap:
         (# i,j: @Integer;
            temp: @Integer;
         enter (i,j)
         do nr.r[i] -&gt; temp;
            nr.r[j] -&gt; nr.r[i];
            temp -&gt; nr.r[j];
         #);
    enter (nr[], ...)
    do ...
    #);
</PRE>
<P> The complete code including a loop for reading numbers to be sorted from the keyboard follows below:</P>
<A NAME=HEADING18-129></A>
<H4 CLASS=betacaption><A NAME="fig:Program 9.1: QuickSort.bet"> Program 9.1: QuickSort.bet</A></H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';
---program: descriptor---
(# (* Hoare QuickSort program illustrating how to use 
    * repetitions, simple pattern declarations,
    * block structure and recursion.
    *)
   numberRepetition: (# r: [1] @Integer #);
   qsort: 
     (# nr: ^numberRepetition;
        left, right, last: @Integer;
        swap: 
          (# i,j: @Integer;
             temp: @Integer;
          enter (i,j)
          do nr.r[i]-&gt;temp;
             nr.r[j]-&gt;nr.r[i];
             temp-&gt;nr.r[j];
          #);
     enter (nr[], left, right)
     do L: (if left &gt;= right then (* stop if rep. contains *) 
               leave L;           (* fewer than two elements *)
            else
               (* move partition element to nr.r[1] *)
               (left, (left+right)/2) -&gt; swap;
               left-&gt;last;
               (* partition *)
               (for i: right-left repeat
                    (if nr.r[i+left] &lt; nr.r[left] then
                        last+1-&gt;last;
                        (last,i+left) -&gt; swap;
                    if);
               for);
               (left,last) -&gt; swap; (* restore partition elem. *)
               (nr[],left,last) -&gt; qsort;
               (nr[],last+1,right) -&gt; qsort;
           if);
     #);
   numbers: @numberRepetition;
   t: ^Text;
   i: @Integer;
do
   (* initialize a repetition with numbers typed
    * by the user
    *)
   'Type some numbers: '-&gt;puttext;
   getline-&gt;t[]; (* read all what the user types until newline *)
   1-&gt;i;
   t.reset;
   L: (if not t.eos then
          (* parse the text;
           * assuming that the user only types numbers
           *)
          (if i&gt;numbers.r.range then 
              (* remember to extend the repetition *)
              numbers.r.range-&gt;numbers.r.extend;
          if);
          t.getint-&gt;numbers.r[i];
          i+1-&gt;i;
          restart L;
      if);
   
   (* sort the repetition *)
   (numbers[],1,i-1) -&gt; qsort;
   
   'Sorted numbers: '-&gt;puttext;
   (for j: i-1 repeat
        numbers.r[j]-&gt;putint; ' '-&gt;put;
   for);
   newline;
#)
</PRE>
<P> Running the program and typing some numbers results in the following output:</P>
<PRE CLASS=beta>
nil% QuickSort
Type some numbers: 9 8 4 6 3 8 2 7 12 45 2 78 5 6 1 0 2
Sorted numbers: 0 1 2 2 2 3 4 5 6 6 7 8 8 9 12 45 78 
</PRE>












