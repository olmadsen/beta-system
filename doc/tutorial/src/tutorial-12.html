<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> 6 Assignment and Procedure Calls</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING12></A>


<P><A HREF=tutorial-13.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-11.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P>Libraries Tutorial</P>


<A NAME=HEADING12-0></A>
<H1> 6 Assignment and Procedure Calls</H1>
<P> We have previously mentioned that BETA strives for minimalism along with orthogonality. So far we have hidden this fact by programming in a standard fashion and presenting the programs with traditional concepts such as variables, functions, assignment statements, etc. Now we shall begin the study of BETA's particularities by considering assignment.</P>

<P> We have already noticed that BETA evaluates expressions left to right and uses an unusual assignment operator, -&gt;. Our examples have shown simple examples of assignment such as:</P>
<PRE CLASS=beta>
i+1 -&gt; i;
</PRE>
<P> In BETA, we can do more: assignment is defined to operate on lists of values with single value assignment being a special case. Thus we can say:</P>
<PRE CLASS=beta>
(1,2,3) -&gt; (i,j,k);
</PRE>
<P> Which has the same effect as the series of simple assignments:</P>
<PRE CLASS=beta>
1 -&gt; i; 2-&gt; j; 3 -&gt; k;
</PRE>
<P> We can also cascade such assignments:</P>
<PRE CLASS=beta>
(a,b,c) -&gt; (m,n,o) -&gt; (x,y,z) ;
</PRE>
<P> If we just consider the first items in the lists, the above statement means that we take the value of a and pass it on to m, then we take the value of m and we pass it on to x. </P>
<P> If the number or types of the items in lists do not match, an error is signaled:</P>
<PRE CLASS=beta>
(111, 222) -&gt; i;
</PRE>
<P> or</P>
<PRE CLASS=beta>
'string' -&gt; i; (*  where i is an integer *)
</PRE>
<P> So far, this is all pretty obvious but, in BETA, the destination of an assignment is not restricted to being a simple variable or a list of such variables; the target of an assignment can also be a more complex object with an enter list. In that case, assignment takes place between the values in the list on the left and the variables named in the target's enter list.</P>

<P> If both the source S and target T of an assignment are complex objects, the assignment: </P>
<PRE CLASS=beta>
S -&gt; T; 
</PRE>
<P> becomes a multiple assignment between the exit list of S, (O1, ..., Oi, ...) and the enter list of T (I1, ..., Ii, ...). In addition, the do part of S is executed before this multiple assignment and the do part of T is executed after. In other words, this happens:</P>
<UL>
<LI>1. Execute do of S
<LI>2. (O1,...Oi...) -&gt; (I1,...Ii...) 
<LI>3. Execute do of T
</UL>
<P> For cascaded assignments:</P>
<PRE CLASS=beta>
S -&gt; T -&gt; U;
</PRE>
<P> We have:</P>
<UL>
<LI>1. Execute S
<LI>2. Output of S -&gt; input of T
<LI>3. Execute T
<LI>4. Output of T -&gt; input of U
<LI>5. Execute U
</UL>
<P> Note that the body of each object mentioned in the assignment is executed once. Of course, defining assignment between complex structures or objects in terms of assignment between individual exit expressions and enter variables is a recursive explanation which eventually leads to assignment between primitive objects like integers which has an obvious interpretation in terms of machine code. This is described in great detail in section 5.8 of the BETA Book. </P>
<P> Note that absence of a do part has no effect on assignment: it is equivalent to a null statement; but absence of an enter or and exit part has great importance. An object without an exit part cannot appear as a source in an assignment. Similarly, an object without an enter cannot appear as a target.</P>

<P> This property is exploited in the math fragment to define read-only objects or constants. These have only an exit list:</P>
<PRE CLASS=beta>
e:  (# exit 2.7182818284590452354 #);
Pi: (# exit 3.14159265358979323846 #);
</PRE>
<P> BETA's generalized definition of assignment means that there is no fundamental difference between assignments and procedure calls. Following from this argument is the fact that procedure declarations and type declarations will be syntactically identical. To illustrate this, consider the following declarations. The first is a type definition for a complex numbers with two real attributes. The second is a procedure that adds reals numbers.</P>

<PRE CLASS=beta>
complex: (# Re,Im: @real;
         enter (Re,Im)
         exit  (Re,Im)
         #);

add: (#  A,B: @real;
     enter (A,B)
     exit A+B
     #);
</PRE>
<P> These definitions have been purposely made alike. There is no do part in either; the computation for add being done by an expression in the exit list. Each has 2 local real attributes. Each has an enter list and an exit list, meaning that objects of the type complex and those of the type add can be assigned values and can provide values and thus can be used on both sides of an assignment statement. For example:</P>
<PRE CLASS=beta>
(1.0, 3.3) -&gt; complex -&gt; (x,y);

(1.0, 3.3) -&gt; add  -&gt; x;
</PRE>

<P> In the case of complex, the output value is an exact duplicate of its local state and of the input values: complex objects will be used mainly for their storage potential (as variables). With add, the output value is computed from the state (input) values: add objects are more useful for this computational aspect. In actual fact, complex would seldom be used directly in such an assignment; it would more properly be used as a model for variables which would in turn be used in assignments. </P>
<PRE CLASS=beta>
(# c1,c2:  @complex;
do (1.0, 3.3) -&gt; c1;
   c1 -&gt; c2;
#)
</PRE>
<P> The point, however, is that BETA does not distinguish between types and functions. It considers both as examples of a more fundamental concept: the object, which can be used for many things depending on how the programmer chooses to define and use it.</P>
<P> The program below shows the examples that we have talked about:</P>
<A NAME=HEADING12-48></A>
<H4 CLASS=betacaption><A NAME="fig:Program 6: MultipleAssigment.bet"> Program 6: MultipleAssigment.bet</A></H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv'
---- program: descriptor ----
(#
   (*   Multiple assignment and function calls  *)

   i,j,k : @integer;
   Nines: (# exit 99999  #);    (* Constant  *)

   complex: (# Re,Im: @integer;
            enter (Re,Im)
            exit  (Re,Im)
            #);
   add: (#  A,B: @integer;
        enter (A,B)
        exit A+B
        #);

do
   'Examples using multiple assignment and function calls' -&gt; 
      putline; newline;

   'Outputting a constant: Nines= ' -&gt; puttext;
   Nines -&gt; putint;
   newline; newline;

   '(1,2,3) -&gt; (i,j,k); '-&gt; putline; newline;

   (1,2,3) -&gt; (i,j,k);
   ' I= '-&gt; puttext;  i -&gt; putint;
   ', J= '-&gt; puttext;  j -&gt; putint;
   ', K= '-&gt; puttext;  k -&gt; putint; newline; 

   newline; '(i,j) -&gt; (j,i):   ' -&gt; puttext;

   (i,j) -&gt; (j,i);
   ' I= '-&gt; puttext;  i -&gt; putint;
   ', J= '-&gt; puttext;  j -&gt; putint; newline;

   'Note that (x,y) -&gt; (y,x) doesn''t imply swap semantics.' -&gt;
     putline; newline;

   '  (*** More examples ***)' -&gt; putline; newline;

   (111,999) -&gt; complex -&gt; (i,j);
   (111,999) -&gt;  add  -&gt; k ;

   ' I= '-&gt; puttext;  i -&gt; putint;
   ', J= '-&gt; puttext;  j -&gt; putint;
   ', K= '-&gt; puttext;  k -&gt; putint; newline;
#)
</PRE>
<P> Now for its output:</P>
<PRE CLASS=beta>
Examples using multiple assignment and function calls

Outputting a constant: Nines= 99999

(1,2,3) -&gt; (i,j,k); 

 I= 1, J= 2, K= 3

(i,j) -&gt; (j,i):    I= 1, J= 1
Note that (x,y) -&gt; (y,x) doesn't imply swap semantics.

  (*** More examples ***)

 I= 111, J= 999, K= 1110
</PRE>










<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Libraries Tutorial</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=tutorial-13.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=tutorial-11.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
