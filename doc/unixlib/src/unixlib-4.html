<H1> Using the unixFile Fragment</H1>
<P> A program using the <A NAME=MARKER-unixFile>unixFile</A> fragment will have the following structure:</P>
<PRE CLASS=beta>
INCLUDE '~beta/unixlib/unixFile'
--- program: descriptor ---
(# ...
   uf: @unixFile;
do ...
   ('a','r') -&gt; uf.entry.permission.add;
   ...
#)
</PRE>
<A NAME=HEADING4-11></A>
<H1> Unix Entry Example</H1>
<P> An example of using unixEntry: First the user is asked if symbolic links should be followed or not. If the unixEntry specified on the command line exists, it is then various other UNIX specific attributes are examined. It is examined whether the entry is a <A NAME=MARKER-symbolic>symbolic</A> <A NAME=MARKER-link>link</A> or not, only if links should not be followed.</P>
<P> Finally it is attempted to change the owner of it to 675: </P>

<H4 CLASS=betacaption>unixEntry.bet</H4>
<PRE CLASS=beta>
ORIGIN '~beta/unixlib/unixfile';
INCLUDE '~beta/sysutils/time';
---- PROGRAM: descriptor ----

(* An example of using UnixEntry: First the user is asked if symbolic links should
 * be followed or not. If the UnixEntry specified on the command
 * line exists, it is then various other unix specific attributes are examined.
 * It is examined whether the entry is a symbolic link or not, only if links should
 * not be followed.
 * Finally it is attempted to change the owner of it to 675.
 *)

(# e: @unixentry; follow: @boolean;
do (if noOfArguments &lt;&gt; 2 //true then
       'Usage: ' -&gt; puttext; 1-&gt;arguments-&gt;puttext; ' path' -&gt; putline;
       stop;
   if);
   2 -&gt; arguments -&gt; e.path;
   
   'Examine symbolic links themselves? (y/n) ' -&gt; puttext;
   (Keyboard.get='n') -&gt; e.followlinks;
   
   e.path -&gt; puttext;
   (if e.exists
    // true then
       ' exists. It' -&gt; putline;
       (if e.followlinks // false then
           (if e.isSymbolicLink // true then
               '  is a symbolic link' -&gt; putline;;
           if);    
       if);
       '  was last modified ' -&gt; puttext;
       e.modtime -&gt; formattime -&gt; putline;
       '  has inode: '-&gt;puttext; e.inode -&gt; putint; newline;
       '  has owner id: '-&gt;puttext; e.owner -&gt; putint; newline;
       '  the owner '-&gt; puttext;
       (if ('u','w') -&gt; e.permission.has
        // true then 'has write permission to the disk entry' -&gt; putline;
        // false then 'does not have write permission to the disk entry' 
           -&gt; putline;
       if);
       'Now lets try to change the owner id to 675.' -&gt; puttext;
       675 -&gt; e.owner;
       ' That succeeded!' -&gt; putline;   
    // false then
       ' does not exist.' -&gt; putline;
   if);
#)
</PRE>
<A NAME=HEADING4-66></A>
<H1> Split executable file</H1>
<P> A simple example of using unixFile: The file 'in.bet' is read word by word, and each word is printed on the output file specified on the command line. This output file has been opened with openExeWrite, meaning that the resulting file will be executable. After this, the output file is opened again, this time with openExeAppend, meaning that the output file will be executable after the line of text has been appended to it.: </P>

<H4 CLASS=betacaption>splitexe.bet</H4>
<PRE CLASS=beta>
ORIGIN '~beta/unixlib/unixfile';
---- PROGRAM: descriptor ----

(* A simple example of using UnixFile: The file 'input' is read word by word,
 * and each word is printed on the output file specified on the command line.
 * This output file has been opened with OpenExeWrite, mening that the resulting
 * file will be executable.
 * After this, the output file is opened again, this time with OpenExeAppend,
 * meaning that the output file will be executable after the line of text
 * has been appended to it.
 *)

(# inFile, outFile: @ unixfile;
do (if noOfArguments &lt;&gt; 2 //true then
       'Usage: ' -&gt; puttext; 1-&gt;arguments-&gt;puttext; ' out-file' -&gt; putline;
       stop;
   if);
   2 -&gt; arguments -&gt; outFile.name;
   outFile.OpenExeWrite;
   
   'input' -&gt; inFile.name;
   inFile.OpenRead;
   
   readFile: 
     (# 
     do (if inFile.eos
         // false then 
            inFile.getAtom -&gt; outFile.putText;
            outFile.newLine;
            restart readFile
         // true then
            leave readFile
        if)
     #);
   inFile.close;
   outFile.close;
   
   (* Now we'll append a little too *)
   outfile.OpenExeAppend;
   'This is one line appended' -&gt; outfile.putline;
   outfile.newline;
   outfile.close;

   'The tokens from the file ''input'' has been put into the file' -&gt; putline;
   ''''-&gt;put; outFile.name -&gt; puttext; 
   ''', and an extra line of text has been appended.' -&gt; putline;
#)
</PRE>





