\part{}
\section{User Manual}
\subsection{Notation}
The specification of the syntax of input to the parser generator is
given in {\em extended} BNF.
In this notation a set of additional metasymbols is introduced.
These may be used in the specification in the following way:

\begin{description}
\item[\{ \}] clauses enclosed in these parantheses are grouped into a single
clause
\item[*] the clause preceding this symbol may be repeated zero or
more times, 
\item[+] the clause preceding this symbol may be
repeated one or more times, 
\item[?] the clause preceding this
symbol is optional. 
\end{description}

Finally, the metasymbol $::=$ is replaced by the symbol
${\rightarrow}$.

\subsection{Syntax of input to the parser generator}

$\nonterminal{PARSER -- GENERATOR -- SYMBOL} \rightarrow$\\
\hspace*{2cm}
$\begin{array}{l}
 \{\nonterminal{OPTIONLIST}\} ?\\
 \{\nonterminal{METASYMBOL -- DEFINITION}\} ?\\
 \{\nonterminal{TERMINAL -- DEFINITION}\} ?\\
 \{\nonterminal{STRINGCH -- DEFINITION}\} ?\\
 \{\nonterminal{GOALSYMBOL -- DEFINITION}\} ?\\
 \{\nonterminal{COMMENT -- DEFINITION}\} ?\\
 \{\nonterminal{GRAMMAR -- RULE} \mid \nonterminal{METASYMBOL --
DEFINITION}\}^*\\
 \nonterminal{ENDCH}
\end{array}$

\subsubsection{Metasymbols}

$\nonterminal{METASYMBOL-DEFINITION} \rightarrow
\mbox{METASYMBOLS} \nonterminal{M1} \nonterminal{M2}\nonterminal{M3}
\nonterminal{M4}$\\ 
$\nonterminal{M1} \rightarrow \mbox{M1} = \nonterminal{CH}$\\
$\nonterminal{M2} \rightarrow \mbox{M2} = \nonterminal{CH}$\\
$\nonterminal{M3} \rightarrow \mbox{M3} = \nonterminal{CH}$\\
$\nonterminal{M4} \rightarrow \mbox{M4} = \nonterminal{CH}$\\

$\nonterminal{CR}$ is any
character other than a letter, a digit or a space.

The metasymbols must be different.
The correspondence to the use in BNF is:

\begin{tabbing}
\hspace*{2cm}\=M1xx\=works asxx \= $::=$\\
\>M2\>works as \> $|$\\
\>M3\>works as \> ${<}$ and ${>}$\\
\>M4\>
indicates the termination of a sequence of alternatives in a
grammar rule.
\end{tabbing}

Default metasymbols are:
\begin{center}
M1$==$, M2$=/$, M3$=<$, and M4$=;$
\end{center}

In the following M1, M2, M3, and M4 denote the current metasymbols.

\subsubsection{Terminals}
$\nonterminal{TERMINAL -- DEFINITION} \rightarrow
\nonterminal{TERMINAL}^* \mbox{M4}$

All terminal symbols used in the grammar must be listed.
A terminal symbol consists of at most 10 character.
The characters set has been divided into two groups:

\begin{itemize}
\item letter and digits
\item all other characters except space
\end{itemize}

All the characters forming a terminal must belong to the same set of the above
groups.
Terminals consisting of symbols from group 1 must start with a letter.
No terminal may contain the current M4.\\
The terminal symbols in the list must be delimited by spaces and/or
end-of-lines.

The following terminals have a special interpretation.
If they are used in the grammar, they must be listed among the 
other terminals.

\begin{specialdescription}{ABCDEFG}
\item[EMPTY] denotes the empty string.
\item[NAME] denotes an identifier. (A sequence of letters and
digits with the first symbol being a letter.)
\item[KONST] denotes a constant. (A sequence of letters and digits
with the first symbol being a digit.)
\item[STRING] denotes a string constant. (A string is a sequence
of characters surrounded by a string-escape-character. If the
string-escape-character is used in the string, it must be
written two times per occurrence.
\item[ERROR] denotes an error symbol. The use
of the error-symbol is explained in Section 5.3.
\end{specialdescription}

\subsubsection{Stringch}
$\nonterminal{STRINGCH -- DEFINITION} \rightarrow \mbox{STRINGCH} =
\nonterminal{CH} \mbox{M4}$

Defines the string-escape-character to be the character $<$CH$>$. It
must not be contained in any other terminal symbol. No default value
exists.

\subsubsection{Grammar-rule}
$\begin{array}{lll}
\nonterminal{GRAMMAR - RULES} &\rightarrow &
\nonterminal{NONTERMINAL} \mbox{M1} \nonterminal{ALTERNATIVE}\\
&& \{\mbox{M2} \nonterminal{ALTERNATIVE}\}^* \mbox{M4}\\
\nonterminal{ALTERNATIVE} & \rightarrow &
\{\nonterminal{NONTERMINAL} \mid \nonterminal{TERMINAL}\} ^+\\
\nonterminal{NONTERMINAL} &\rightarrow & \mbox{M3 a sequence of
characters M3}
\end{array}$

The sequence of characters must not contain the current M3.
Spaces are skipped.
A nonterminal may consist of up to 30 characters.
Terminals and nonterminals in a rule must be separated by spaces or end of
lines.

If EMPTY is used it must be the only symbol in that alternative.

The terminals in a grammar rule must not contain any of the metasymbols
currently defined.
If they have to, the metasymbols must be redefined.
It is not necessary for all alternatives to the same lefthandside of a grammar
rule to be defined at the same time, they may be defined later.

\subsubsection{Goalsymbol}
$\nonterminal{GOALSYMBOL -- DEFINITION} \rightarrow
\nonterminal{GOALSYMBOL} =  \nonterminal{NONTERMINAL} \;\mbox{M4}$

Defines the nonterminal to be the goalsymbol of the grammar.
If this command is not present, the first nonterminal met among the grammar
rules is assumed to be the goalsymbol.

The parser generator always adds the following grammar
rule (production no. 0):

\[
\nonterminal{BOBS -- GOAL} \rightarrow
\nonterminal{GOALSYMBOL} \mbox{END--OF--FILE}
\]

\subsubsection{Endcharacter}
$\nonterminal{ENDCH} \rightarrow \mbox{M4}$

The input to the parser generator must be terminated by the currently defined
M4.

\subsubsection{Comment}

$\nonterminal{COMMENT} \rightarrow \nonterminal{COMMENT} =
\nonterminal{COMMENT -- BEGIN} \mbox{M4} \nonterminal{COMMENT --
END} \;\mbox{M4}$\\
$\nonterminal{COMMENT -- BEGIN}\; \rightarrow
\nonterminal{TERMINAL}$\\
$\nonterminal{COMMENT -- END} \rightarrow
\;\mbox{a sequence of characters}$\\

$\nonterminal{TERMINAL} \;\mbox{must be defined in the}
\nonterminal{TERMINAL -- DEFINITION}$ (4.2.2)
The sequence of characters of $\nonterminal{COMMENT -- END}$ must
not include the current M4. Spaces are skipped.

In the input string to be parsed the following is considered to 
be a comment:

$\nonterminal{COMMENT -- BEGIN}$ any sequence of characters 
(except $\nonterminal{COMMENT -- END}$)\\
\hspace*{11,5cm}$\nonterminal{COMMENT -- END}$

See also Section 5.1.

\subsubsection{Options}

\begin{tabular}{lll}
$\nonterminal{OPTIONLIST}$ & $\rightarrow$ & $OPTION
(\nonterminal{OPTION -- NUMBER}$\\ & & $\{, \nonterminal{OPTION --
NUMBER}\}^*)$ 
\end{tabular}


$\nonterminal{OPTION -- NUMBER}$ is an integer.
Most of the options are for test purposes only, and some may cause an error in
the generated parser.
The options are implemented as switches, which means that 
if the same number is used twice, the option is returned to the
original position.

For most users, the rest of this section is of no interest, and 
may be skipped.

The following numbers are valid:

\begin{specialdescription}{33,34}
\item[1] The internal representations of the terminal symbols are printed.
\item[2] The LR(0) tables are printed.
\item[3] The terminal symbols may be collected in sets where all terminals
in such a set are given the same internal value. 
Let T1, T2, $\ldot$, TN be terminals.
If in the list of terminals (4.2.2) you write:\\
\hspace*{2cm}T1 T2 M1 T3 M1 $\ldot$ M1 TN M1\\
then T1, T2, $\ldot$, TN are all given the same internal value.
There must be exactly one space between a terminal and M1.
In all outputs, T1, T2, $\ldot$, TN-1 will appear as TN.
\item[4] The lenght of the terminal symbols may be greater than 10 characters.
All characters are significant but only the 10 first appear in output.
\item[5]  The terminal symbols may consist of characters from both character
groups (see chapter 4.2.2).
The terminal symbols must be separated by blanks or an end-of-line.
(The lexical analyser in the skeleton compiler must be modified for these
terminals.)
\item[6] The internal values of the nonterminal symbols are printed.
\item[7] The SLR(1) lookahead symbols for each nonterminal are printed.
(Caution: option 27 must be used.)
\item[12] The inadequate LR(0) tables are printed.
\item[14] The internal form of the LR(0) tables is printed.
\item[15] The internal form of the LR(0) tables and the generated lookback
tables are printed.
\item[16] The internal array ``PROD'' is printed.
\item[17] The internal array ``TILSTAND'' is printed.
\item[18] The terminal heads and tails which a nonterminal can
produce are printed.
\item[19] Test information of ``VHRECURS'' is printed.
\item[20] The bit matrix of the grammar is printed.
\item[21] Test information of ``LOOKBACK'' is printed.
\item[22] The largest lookahead set is not removed from a lookahead table.
(The table is treated like a lookahead--error table.)
\item[23] The internal form of the productions is printed before the grammar is
modified.
\item[24] The internal form of the productions is printed after the grammar is
modified.
\item[25] No attempt is made to test for left and right recursion.
\item[27] The grammar is treated as an SLR(1) grammar instead of an LALR(1)
grammar. 
In this case one has to use option 31 too.
\item[28] No attempt is made to remove the single productions.
\item[29] Tables which have the same tail are not folded together.
\item[30] The LR(0) items are printed in a readable form.
\item[31] The empty string is eliminated from the grammar.
\item[32] Files PARSIN and PARSOUT (see appendix A) are ignored.
Only parse tables are produced (on file TABLES).
\item[33,34] See appendix B.
\end{specialdescription}

\subsection{Constants}
The following constants define the maximum sizes of the data structures in the
parser--generator.

Most of the constants are totally internal to the program and should only be
changed with care.

\begin{specialdescription}{ABCDEFGHIJ}
\item[CONST 1] Maximum number of productions.
\item[CONST 2] Maximum number of terminal and nonterminal symbols.
\item[CONST 3] Maximum size of array FCQ.
\item[CONST 4] Maximum size of array RHS.
\item[CONST 5] Maximum number of elements in a basis set of an LR(0) table.
\item[CONST 7] Maximum size of final parse tables.
\item[CONST 8] Maximum number of lookahead elements for a nonterminal.
\item[CONST 9] Maximum size of aray STACK in procedure LR0.
\item[CONST 10] Maximum number of parse tables.
\item[CONST 11] Maximum number of nonterminals.
\item[CONST 12] Maximum number of terminals.
\item[CONST 13] Equal CONST2DIV (SETMAX=1) = 1  \footnote{CONST
SETMAX = 58 in the CDC version.}
\item[CONST 14] Maximum size of a parse table.
\item[CONST 16] Maximum number of options.
\item[CONST 18] Maximum number of options.
\end{specialdescription}

\subsection{Error messages}
Two types of error messages can occur:
\begin{itemize}
\item system errors
\item errors according to the grammar.
\end{itemize}

\subsubsection{System errors}
One of the data structures in the parser generator has caused an error.
The appropriate constant must be changed in the parser generator.

\subsubsection{Errors according to the input grammar}
There might be errors:
\begin{itemize}
\item in input to the parser generator,
\item according to the grammar checks and grammar transformations,
\item in the parse tables, which are not LALR(1).
\end{itemize}

\subsection{Examples on using the Parser Generator}
Following are two examples. 
First a complete example of input of a grammar and the produced output.
The second example shows a grammar which is not LALR(1).
See also the appendix.

\begin{eksempel}
\mbox{}
\end{eksempel}
The symbol FI has been removed from productions 16 and 18.
This makes the grammar non LALR(1).
Only the grammar and the non LALR tables are shown.

There are two tables (or states) which are not LALR(1).
In the first table the symbols ELSE and; cause the errors.
For instance if the next symbol on input is ELSE, the parser cannot decide
whether it should reduce by production 18 or continue reading according to
production 16.

In the second table it is; which gives problems.

\section{The Skeleton Compiler}
When using the parser--generator, the Skeleton--compiler must reside on file
PARSIN.
The parser--generator then delivers the Skeleton--compiler with initialized
constants on the file PARSOUT.
The parse tables associated with the user's grammar are delivered on the file
TABLES.
It would have been more handy to incorporate the parse tables in the
Skeleton--compiler as a set of initializations, but this is however not
possible in Standard PASCAL.

The Skeleton--compiler consists of
\begin{itemize}
\item PROCEDURE PARSER,
\item PROCEDURE CODE, and
\item some global declarations.
\end{itemize}

The procedure PARSER is the major part of the Skeleton--compiler.
It consists of procedures for doing:
\begin{itemize}
\item Lexical analysis,
\item Context--free syntax analysis (parsing), and
\item Error recovery.
\end{itemize}

We shall not discuss these procedures her, but the reader is referred to
section 5.1 for a specification of how the input string to the lexical analyser
must look.
The use of the special tokens NAME, KONST, and STRINGz is
explained in section 5.2.2.
Error recovery is treated in section 5.3.

The procedure CODE is an almost empty procedure which has to be written by the
user.
CODE is called from the parser each time a reduction is performed  during the
parsing of a string.
In this way CODE will act as an interface between the parser and the semantic
part of a compiler based on the Skeleton--compiler.

Among the global declarations is a stack which may be used by the user (see
section 5.2.3).

\subsection{Input/Output of the Skeleton--compiler}
Input to the Skeleton--compiler:
\begin{itemize}
\item On file INPUT: a string in the language generated by the grammar.
Terminals in this string must be separated by spaces and/or end-of-lines.
However two terminals may be concatenated if they are not in the same group of
characters (see section 4.2.2.).
Terminals from group 2 may be concatenated if the concatenation does not
together form the head of another terminal.
Spaces and/or end-of-lines are only allowed as separators between terminals and
are considered as blind characters.
A comment may appear between any two terminals.
It may be necessary to surround $\nonterminal{COMMENT--BEGIN}$ by
spaces in order to avoid that $\nonterminal{COMMENT--BEGIN}$
concatenated with the preceeding terminal and/or the beginning of a
comment forms the head of some terminal.
\item On file TABLES; the parse tables of the grammar. 
\end{itemize}
Output from the Skeleton--compiler (on file OUTPUT):
\begin{itemize}
\item A listing of the input string.
Possible syntax errors in the string are marked (see section 5.3).
\item A snapshot of the parse.
Contains a general print-out of the steps in the parse of the actual input
string.
It is intended as an aid to the user and may be removed.
\end{itemize}

\subsection{Adding Semantics}
As mentioned, the procedure CODE is called from the parser each time a
reduction is performed.
CODE has as parameter the number of the applied production.
The productions are numbered according to the listing produced by the
parser-generator (see section 2.1.4).

Inside CODE, an appropriate action must be taken for each production in the
grammar.

Besides filling out the body of CODE, the user is free to add new global
declarations (procedures, variables, etc.).

As the parsing method is LR, the reductions will be performed in the order of a
so-called {\bf right-parse}.
It is fundamental for using the BOBS-system, that the notion of a right-parse
is understood.
A definition of a right-parse is given in part IV.
The snapshot of the parse may be an aid in understanding the order of the
reductions.

\subsubsection{Using NAME, KONST, and STRING}
If the symbols NAME, KONST, and STRING are used on the right
side of a production, then the user can get the string of characters
actually comprising the NAME, KONST, or STRING.
This is done by means of:

\begin{tabbing}
\hspace{1cm} \= proc \= \kill
         \> {\bf PROCEDURE} GETSTRING (NO. INTEGER;\\
          \>  \> {\bf VAR} STR: STRING {\bf VAR} LENGTH:
INTEGER); 
\end{tabbing}

where STRING = {\bf PACKED ARRAY}[1..STRINGMAX] 
{\bf OF} CHAR;

Suppose CODE is called with the number of production

\[x_0 \rightarrow X_1 {\ldot} X_i {\ldot} X_n\]

If $x_i$ is NAME, KONST, or STRING, then

\[
\mbox{GETSTRING} (i,S,L)\; \mbox{or GETSTRING}(-(n-i+1),S,L)
\]
will deliver the corresponding string og characters in S[1],
$\ldot$,S[L].\\
$(S[L+1],\ldot,S[STRINGMAX]$ are undefined.)

If $X_i$ is neither NAME, KONST, nor STRING, then the call of
GETSTRING will deliver an arbitrary string (usually the empty
string).

\subsubsection{Using the Semantic Stack}
In order fully to understand this section, the user must have s
ome knowledge of
how an LR-parser works.
The essence of this is given in part IV.

A stack is a useful tool when implementing the semantics of a 
language, especially if the language contains constructions, which
may be nested. For this reason, the Skeleton--compiler contains a
stack which operates in parallel with the parse stack:


\hspace*{1cm} ATTSTACK: {\bf ARRAY}[STACKINX] {\bf OF} ATTRIBUTES;\\
\hspace*{1cm} ATTRIBUTES = {\bf RECORD} \ldot {\bf END};


The user may define fields in record ATTRIBUTES.
A field in this record will be called an attribute, and the entire
record an attribute record.

During parsing each symbol on the parse stack has a corresponding
attribute record on ATTSTACK.
When a reduction is performed and CODE is called, the topmost
elements of ATTSTACK correspond to the symbols on the right side of
the applied production.

In CODE the values of these attribute records of the right-side
symbols may then be used in the semantic action.
The semantic action of the applied production should define the
value of the attribute record of the left-side symbol.

In order to access the relevant attribute records, CODE is supplied
with two parameters:

\hspace*{1cm}
OLDTOP, NEWTOP: STACKINX;

OLDTOP is the index in ATTSTACK of the topmost element before
the reduction (at entry to CODE). 
NEWTOP is the index of the topmost element after the reduction is
performed (after exit from CODE).
If the right side of the applied production has the length $N$, the
OLDTOP = NEWTOP+N-1.
NEWTOP is furthermore the index of the attribute record which will
correspond to the left side of the applied production.
I.e.\ the attribute record of the first symbol on the right side
will be used (after modifications done by the user) as the
attribute record of the left side.

Let the applied production be
\[
A \rightarrow x_1 x_2 {\ldot} x_n
\]

At entry to CODE the situation is:

\begin{quotation}
ATTSTACK:
\end{quotation}


\vspace*{5cm}


$\hat{X}_i (i = 1,2 \ldot, n)$ denotes the attribute record of
$X_i$. 
Then 

\hspace*{1cm}ATTSTACK[NEWTOP+i-1] or\\
\hspace*{1cm}ATTSTACK[OLDTOP-n-+]

is the attribute record of $X_i$. If $i = 1$, then

\hspace*{2cm}ATTSTACK[NEWTOP] or\\
\hspace*{2cm}ATTSTACK[OLDTOP-n+1]

is also the attribute record of $A$.

Lastly we would like to make some remarks concerning some relevant
theoretical models for specifying semantics.

Attribute grammars [21], Syntax Directed Translation Schemes [20],
and Attributed Translations [22] may all be implemented by using
the ATT STACK.

However only certain restricted classes of these models are
efficient to implement.

The following models should be straightforward to implement:
\begin{itemize}
\item attribute grammars using only synthesized attributes [21]
\item postfix simple syntax directed translation schemes [20]
\item generalized syntax directed translation schemes with
translation elements which are not only string--valued and with the
string translation grammars being postfix and simple [20]
\item attributed polish translation grammars using only synthesized
attributes [22].
\end{itemize}

The latter two models are in principle identical and are a
combination of the first two alternatives.
Informally the semantic action of a production in these models is:

\begin{itemize}
\item on basis of the attribute records of the right-side symbols
do:
   \begin{itemize}
     \item output some symbols,
     \item define the value of the attribute record of the
      left-side symbol.
    \end{itemize}
\end{itemize}

Translation schemes which are not postfix (polish) and/or simple,
may also be implemented.
This requires that the attribute record contains pointers to the
translation elements, which have to be built in the form of a tree;
for a further study see Aho \& Ullmann [20, chapter 9].

The implementation of inherited attributes or translations is
inefficient in the BOBS--system.
The only way to do it is to build the entire syntax tree and then
perform the evaluation of the attributes.

However in practice it suffices to keep the inherited (or context)
information (e.g. \ a symbol table) in global variables, and update
this information appropriately.

We conclude this section by advocating the following model for
specifying the semantics:
\begin{itemize}
\item make the grammar postfix, i.e. \ code only has to be outputted
at the time of a reduction,
\item define a suitable set of (synthesized) attributes for each
nonterminal,
\item define a set of global variables for collecting declarative
information (i.e. \ a symbol table).
\end{itemize}

\subsection{Error Recovery}
The parser will take error action if the user specifies a string
which is not in the language generated by the grammar.
The error will be detected at the earliest possible point: that is,
the part of the input string which has been read up till this point
will constitute a correct prefix of some string in the language
where the next symbol read is not a valid continuation of the
already read part.
The symbol at which an error is detected will be marked with a
$\uparrow$ and a number. 
The number refers to the error message table which is part of the
output from the parser generator (see 2.1.4).
The number indicates in the error message table a set of terminals
that would have been valid continuations at that point of the input
string.
Note that the set of terminals does not always contain all valid
continuations.

When an error has been detected, the parser tries to continue
parsing.
This can be done in the following way:

Let $A \rightarrow \alpha$ be a production.
Assume that an error happens in a part of the input which later may
reduce to $\alpha$ and then to $A$.
We then have recognized part of $\alpha$. Let $\alpha = \alpha'\;
\alpha''$ where $\alpha'$ is recognized ($\alpha'$ may be empty).
The parse stack then contains $\varphi \;\alpha' \;\delta$, for
some  $\varphi$ and $\delta$.
 This means that $\delta$ and some of
the input symbols (if there were no errors) could reduce to
$\alpha''$ and then $\alpha'\;\alpha''$ to $A$.
A possible way of recovering would be to assume that $\alpha''$ has
been recognized.
This can approximately be done by deleting $\delta$ from the stack
and skip symbols on input until meeting one which may follow
$\alpha''$.

In practice the parser is simultaneously looking for several right
sides of different productions which may reduce to different
nonterminals.
For this reason the user must specify the so--called error
productions in order to indicate the nonterminals that the recovery
algorithm should try to reduce to.

An error production has the form
\[
A \rightarrow \alpha \;\mbox{error} \; \beta
\]
where error is a special terminal (se Section 4.2.2), and $\alpha$
and $\beta$ are (possibly empty strings) of nonterminals and
terminals.

Let $A \rightarrow \alpha \gamma$ be another A-production.
Let the stack at a given time during the parse contain $\varphi\;
\alpha\; \delta$ for some $\varphi$ and $\delta$.
Assume that $\delta$ and some terminal string $x$ may reduce
to $\gamma$ and then $\alpha\gamma$ to A.
Assume that $x$ is a prefix of some terminal string which is a
valid continuation on input with the above stack.

Suppose that an error appears in this situation, i.e.\ the next
input symbol is not a valid continuation.
The parser will then replace $\gamma$ by error $\beta$ in
the following way:
\begin{itemize}
\item $\delta$ is deleted from the stack
\item the symbol error is read
\item input symbols are skipped until meeting one which may begin
$\beta$.\\
If $\beta$ is the impty string one skips to a symbol which
may follow $A$ after $\alpha$ error is reduced to $A$.
\end{itemize}

As $A \rightarrow \alpha$ error $\beta$ is a usual production.
CODE will be called with the number of the error production.
In this way the user is informed when syntax errors appear.

In general more than one error production may be applicable.
In this case the parser will choose the one which gives rise to
fewest skips on input.

As error productions are normal productions they may give rise to
LR--conflicts which of course must be eliminated.

In order to obtain a successful recovery the user must specify a
reasonable set of error productions.
All parts of the grammar shold be covered as should different
levels in nested constructions.

In general, an error production $A \rightarrow \alpha$ error
$\beta$ only makes sense if $\alpha$ is a prefix of some other
production with $A$ as leftside, and $\beta$ should in a similar
way be a postfix.
It is often sufficient to let $\alpha$ and/or $\beta$ be the empty
string.

\subsection{Examples}
Here is an example of using the skeleton--compiler and tables as
produced by the parser generator in example 4.1.

\begin{eksempel}
\mbox{}
\end{eksempel}

\begin{eksempel}
\mbox{}
\end{eksempel}
This example shows how a simple translation can be implemented.
We define a small language with simple control structures,
assignments, expressions and Algol like blocks with dclaration of
variables.
A variable must be declared before it is used and double
declarations in a block may not appear.
All language constructs are translated into an equivalent one.
The major transformations are : variables are added the nesting
depth of the block in which they are declared, expressions are
transformed to postfix polish, the control structures are extended
with line numbers indicating possible jumps.
The grammar has been transformed in order to make the translation
polish.

The following pages contain
\begin{itemize}
\item a listing of the grammar,
\item all global label, const, type, and var declarations of the
skeleton compiler, including the ones added for the semantic
example,
\item the part of the procedure CODE which has been added for the
semantic example, and
\item an example of a translation.
\end{itemize}
















