\documentclass[12pt]{article}
\usepackage{latexsym} 
\usepackage{graphics} 
%\usepackage[textures]{latexsym,epsfig} 

\parindent 0em
\parskip 1.5ex

\begin{document}
\title{THE BOBS-SYSTEM}
\author{S{\o}ren Henrik Eriksen\thanks{A/S Regnecentralen, Aarhus}\\
Bent B{\ae}k Jensen\thanks{KTAS, K{\o}benhavn}\\
Bent Bruun Kristensen\thanks{Department of Computer Science, Institute of Eletronic Systems,
Aalborg University Center, DK-9000 Aalborg}\\
Ole Lehrmann Madsen}
\date{June 1993}
\maketitle
\newpage

\begin{abstract}
The BOBS-System is an LALR(1) parser-generator. This paper is a user
manual for the system: Consisting of a general description of the system,
a reference manual, and a summary of parsing terminology. These sections 
can be read without knowledge of parsing theory.

Furthermore, the implementation of the system is described. This is done
by giving references to literature containing descriptions of some of the
algorithms used, and by giving abstract algorithms for other parts of
the system. This section requires that the reader is familiar with LR-parsing.
\end{abstract}
\newpage
\tableofcontents
\newpage


\section*{PREFACE to the Third Edition}
This third edition is identical to the first and second edition
except that some minor errors have been corrected, appendix B has
been added and section 6.1.2 has been replaced by a reference to a
more appropriate source.

\section*{INTRODUCTION}
This paper is a description of a parser-generator system called 
the BOBS-system.

We consider the LR-grammars \cite{3}. 
These are, in ascending order of complexity, LR(0), SLR(k), LALR(k),
L(m)R(k) and LR(k) as defined in \cite{1,2}.

The BOBS-system is an implementation of a parser-generator in the
programming language PASCAL \cite{12} for the SLR(1) and LALR(1)
grammars.

This paper is divided into four parts: part 1 is a general 
description of the system; part 2 is a user manual; in part 3 we
describe the program organization and some algorithms of special
interest; and part 4 contains an introduction to the terminology
which we use. (Readers not familiar with the terminology should 
read this part first.)
\newpage
\part{}
\section{The history of the BOBS-system}
The work was started as an undergraduate project in 1971 under the
guidance of Peter Kornerup. 
The aim of the project was to implement a parser-generator system
for SLR(1)-grammars.
This was fulfilled in March 1972.
The first version was implemented in the earliest version of the
programming language Pascal \cite{6} on a CDC 6400.

A revised version was released in December 1972, and a user manual
\cite{7} appeared in March 1973.
At the same time a short introductory description of the system \cite{8}
was published.

During 1973 the system was extended and modified \cite{9} as a result of
our experiences in using the system.
A new lexical analyser and a new error-recovery method were
implemented.
A new look-ahead algorithm was constructed and implemented,
extending the system to accept LALR(1)-grammars.

During 1974 a new user manual was written.
In October 1974 this manual and system description \cite{8} were
published in \cite{10}.

Since December 1974 a modified version of the system has been
distributed from the University of Texas at Austin by W.F. Burger.
This version is called ``BOBSW -- A Parser Generator'' \cite{11}.

In October 1976 a new modified version of the system was finished.
First of all the parser generator has been translated (more or
less) mechanically into standard Pascal \cite{12}, so that the system is
no longer dependent on the earliest Pascal compiler on the CDC 6400.
Next the parser generator has been extended to handle grammars,
whose grammar rules contain empty productions, without eliminating
such productions.
A new skeleton compiler has been implemented.
This means new lexical, syntax and error-recovery algorithms, and
implementation of a user semantic stack.

\section{Global design of the system}
The system consists of two programs:
\begin{itemize}
\item the parser-generator,
\item the skeleton compiler.
\end{itemize}

\subsection{The parser-generator}
The parser-generator is divided into the following modules:
\begin{itemize}
\item imput of the source grammar,
\item grammar checks and grammar transformations,
\item generation of the LALR(1)-tables.
\end{itemize}

\subsubsection{Specification of the source grammar}
The source grammar must be specified in a slightly modified BNF
(Backus Naur Form).

\subsubsection{Grammar checks and grammar transformations}
It has turned out that the implemented grammar checks and
transformations are very useful when designing a grammar for a
language.

The system cannot produce the LALR(1)-tables for an ambiguous
grammar or grammar containing unused nonterminal symbols.

The system performs the following grammar checks:

Test for unused nonterminal symbols:
\begin{itemize}
\item the system checks that every nonterminal except the
goal-symbol appears on both the left and the right side of a
production,
\item the system checks that all nonterminals can be derived from
the goal symbol (the start symbol),
\item the system checks that all nonterminals can derive a string
only containing terminals.
\end{itemize}
Test for ambiguity:
\begin{itemize}
\item the system checks whether any nonterminal is both left and
right recursive. 
If so, the grammar is ambiguous.
\end{itemize}

The system can perform the following transformations on the grammar:
\begin{itemize}
\item If identical productions exist, the grammar can be modified
by removing the unnecessary productions.
\item If any nonterminal can derive the empty string, the grammar
can be modified by eliminating this production.
The modified grammar generates the same language.
\item If there exist single productions, the grammar can be
modified by eliminating all such.
In a single production the left and right side both consist of only
a single nonterminal, and the left side nonterminal does not appear
on the left side of any other production.
\end{itemize}

\subsubsection{Construction of the LALR(1)-tables}
The first step is to construct the LR(0) parse tables and check
whether the grammar is LR(0) or not.
If this fails, the parse tables are extended by means of LALR(1)
lookahead.
If this fails too, the system reports the parse tables in which the
lookahead information is insufficient.
The user must then change the grammar.

If the grammar happens to be LALR(1), the parse tabels are
compressed through a series of various optimizations.

\subsubsection{Output from the parser-generator}
The system delivers the following output:
\begin{itemize}
\item a listing of the source grammar, exactly as the user has
written it. 
Any error according to the input syntax is marked;
\item the results of the above mentioned grammar checks and
transformations:
\item the modified grammar written in BNF.
Each production is assigned a unique number;
\item a description of any parse tables which are not LALR(1);
\item an error message table for use by the user when parsing an
erroneous string;
\item a file containing the parse tables and a file containing the
skeleton compiler (a Pascal program).
\end{itemize}

In addition there exist several other output facilities, mentioned
in Section 4.2.7 but they are of little interest here.

\subsubsection{SLR(1)}
As mentioned in Section 1 the system was originally designed for
SLR(1) grammars.
The possibility of using SLR(1)look-aheads instead of LALR(1) still
exists.

\subsection{The skeleton compiler}
The second part of the system is a Pascal program, which is
delivered as output from the parser-generator.
The unmodified skeleton compiler will check the syntac of an input
string written in the language defined by the source grammar.
However, the user may add semantic actions to the skeleton compiler.

The skeleton compiler is devided into the following modules:
\begin{itemize}
\item the semantic interface
\item the parser part
   \begin{itemize}
   \item lexical analysis
   \item syntax analysis
   \item error recoverly
   \end{itemize}
\end{itemize}

\subsubsection{The semantic interface}
When a reduction is performed, a procedure ``CODE'' is called with
the production (reduction) as a parameter.
The user may then decide what semantic actions to perform.
This is done by writing the body of the procedure ``CODE''.
The user may, of cource, add new procedures and declarations.

\subsubsection{The parser part}
In this part of the program the user does not have to change
anything.

\paragraph{\em 2.2.2.1 {Lexical analysis}}
Characters from the input are read and collected into single
logical items called tokens.
A token corresponds to a terminal symbol of the grammar.

\paragraph{\em 2.2.2.2 {Syntax analysis}}
The syntax analyser uses the parse tables constructed by the
generator to parse the string of tokens delivered from the lexical
analyser.

\paragraph{\em 2.2.2.3 {Error recovery}}
If an error is discovered during parsing, an error recovery
algorithm is called.
The purpose of the recovery algorithm is to mark the symbol causing
the error detection, to recover from the erroneous situation, and
to initialize a continuation of the parsing.

\section{Evaluation}
The system has been used in a variety of different projects. 
A compiler for the language Pascal \cite{6, 13} has been based on the
system.
The Pascal grammar consists of more than 250 productions and the
constructed LALR(1) tables occupy about 1000 60 bit words on a CDC
6400.
Compared with the Z\"{u}rich Pascal Compiler (version 6.\ Sept.\ 72)
the core requirements and execution time are nearly the same.

Inside the department the system has been used for various
compilers and assemblers.
It is also used in a compiler course, in which the students have to
write a small compiler.

At the Danish Data Archive (an institution under the Danish Social
Science Research Council) and at the Institute of Economics,
University of Aarhus, a modified version of the system is used to
implement interactive special purpose languages, which are designed
to ease the use of libraries of statistical programs, the handling
of files and the controlling of data bases. 
This system consists of about 20 grammars each containing from 160
to 250 productions.

As the work has been moving along, new projects have arisen.
Automatic error recovery in LR-parsing has been studied \cite{14}.
Also problems of defining semantics have been studied. 
One project \cite{15} was to extend the system with the Oxford semantics
\cite{16}.
Furthermore the use of attribute grammars in practical translator
writing systems has been studied \cite{17}.

We conclude that the system is usable in practice and that
experience has shown that it is easy to modify grammars to become
LALR(1), even for users who are not familiar with LR-parsing theory.















