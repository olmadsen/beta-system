<H1>Adding the City Map</H1>

<P> Having the program skeleton set up, the next issue considered, is
the map of the city that is to be displayed in the Canvas. One way to
display this map is to use an instance of the Predefined Graphical
Object <INX>Rect</INX>, which describes a Rectangle, and
then fill it with a <INX>TiledSolidColor</INX> using the
<INX>BitMap</INX> for tiling. A TiledSolidColor is a
solid color, e.g. black, which also has a Bitmap, a so called <INX>tile</INX>. When filling with a <INX>TiledSolidColor</INX>, only the
bits in the tile, which are TRUE, will be painted. The tile will be
replicated as many times as needed to fill out the Shape, hence the
name.</P>

<P> Given that the bit map of the city map is in the file 
<CODE>~beta/bifrost/bitmaps/Aarhus.pbm</CODE>
 in the <INX>PBM format</INX> discussed in 
<A HREF="../bibliography/index.html#mia91-13">[MIA 91-13]</A>, 
<A HREF="../bifrost-ref/bifrost-ref-18.html">Chapter 5</A>,  
the TiledSolidColor may be declared as follows in <INX>subway2.bet</INX>:</P>

<BETA>
aarhus: @TiledSolidColor
      (# bits: @bitMap
            (#
            do 'Reading in map ... ' -> puttext;
               '~beta/bifrost/bitmaps/Aarhus.pbm' 
                 -> readFromPBMfile;
               'done' -> putline;
               (0,0) -> hotspot;
            #);   
         
         init::
            (#
            do black -> name;
               bits -> thetile;
            #)
      #);
</BETA>

<P> The BitMap is read from the PBM file using
<INX>ReadFromPBMFile</INX>. This may take a while, and to inform the
user of what is going on, some explanatory text is written out on the
screen. The <INX>hotspot</INX> of the BitMap is set to (0,0). This is
to control the placement of the BitMap within the Rect, that it will
be used to fill out.</P> 

<P> In the TiledSolidColor, <INX>init</INX> simply
evaluates the BitMap, and assigns the result of the evaluation, which
is a reference to the BitMap, to the <INX>theTile</INX>attribute of the <INX>TiledSolidColor</INX>. It also
evaluates the pattern <INX>black</INX> and assigns the
result to the <INX>name</INX> attribute. This will make
the bits of the tile, which are set, appear black on the screen. The
black pattern is declared in the fragment <CODE>~beta/bifrost/ColorNames</CODE>
which must be INCLUDEd in subway2.bet.</P>

<P> With this definition of the TiledSolidColor, the Rect may then be
declared as follows:</P>

<INX HIDDEN>map</INX>
<BETA>
map: @Rect
   (# 
      init::
         (#
         do (* Make THIS(Rect) the size of the aarhus-bitmap *)
            aarhus.init;
            (0,aarhus.bits.height) -> upperleft;
            aarhus.bits.width -> width;
            aarhus.bits.height -> height;
            aarhus[] -> setpaint;
         #)
    #);
</BETA>
<P> In the Rect, init first initializes the TiledSolidColor called
aarhus which in turns reads the bitmap from the PBM file as described
above. Then <INX>upperleft</INX>, <INX>width</INX> and <INX>height</INX>
are set using the dimensions of the BitMap. Finally a
reference to the TiledSolidColor is given to the <INX>setpaint</INX>
attribute of the Rect, thus making <INX>aarhus</INX> be
used as the paint to fill the Rect with. The shape of the Rect has a
default hotspot in the upper left corner. When a graphical object is
filled with a TiledSolidColor, the <INX>hotspot</INX> of theTile of
the TiledSolidColor is placed in the hotspot of the Shape of the
graphical object, and theTile is then replicated as needed to fill out
the entire Shape. Thus having defined the hotspot of <INX>aarhus.bits</INX>
to (0,0) and made the Rect have the exact dimensions of the
BitMap, the BitMap will be shown exactly once within the Rect.</P>

<P> All that is needed now is to initialize and draw the Rect. It is
initialized in myCanvas.open:</P>

<BETA>
open:: 
  (# 
  do (* Make THIS(BifrostCanvas) the size of the map *)
     map.init;
     (map.width, map.height)->Size->theWindow.size;
  #);
</BETA>

<P> Instead of the arbitrary size used in subway1.bet, the Canvas is
given the same dimensions as the Rect containing the BitMap. Now the
Rect is ready to be drawn when the Canvas has become visible on the
screen. Thus myCanvas.onOpen becomes: </P>

<BETA>
onOpen:: (# do map[] -> draw; #);
</BETA>

<P> The predefined graphical object Rect is defined in a separate fragment, <CODE>~beta/bifrost/<INX>PredefinedGO</INX></CODE>, which must be INCLUDEd in <INX>subway2.bet</INX>. </P>





