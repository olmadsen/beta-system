<H1>Appendix A. The Final Program</H1>
<A NAME="subway7.bet"><H4 class=betacaption>subway7.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/bifrost/Bifrost';
INCLUDE '~beta/bifrost/PredefinedGO';
INCLUDE '~beta/bifrost/Palette';
INCLUDE '~beta/bifrost/ColorNames';

-- PROGRAM: descriptor --

bifrost
(# 
   (* Add a Palette *)
   
   theWindow: @window
     (# color: @
          (* The color used for stations and rails *)
          SolidColor; 
        fill: @
          (* The color used to fill station backgrounds *)
          SolidColor;
        
        paletteOpen: @boolean;
        
        aarhus: @TiledSolidColor
          (# bits: @bitMap
               (# 
               do 'Reading in map ... '-&gt;puttext;
                  '~beta/bifrost/bitmaps/Aarhus.pbm'-&gt;readFromPBMfile;
                  'done'-&gt;putline;
                  (0,0)-&gt;hotspot;
               #);   
             
             init:: 
               (# 
               do black-&gt;name;
                  bits-&gt;thetile;
               #)
          #);
        
        (* Constants corresponding to palette selections *)
        MoveMode: (# exit 1 #);
        StationMode: (# exit 2 #);
        RailMode: (# exit 3 #);
        Quit: (# exit 4 #);
        
        PaletteWindow: @window
          (# Mode: @Palette
               (# changed:: 
                    (# 
                    do (if selection=Quit then Terminate if);
                    #);
                  open::
                    (# G: @GraphicalObject;
                       T: @GraphicText;
                       L: @myCanvas.Rail;
                       S: @myCanvas.Station;
                    do G.init;
                       (  0, 32)-&gt;G.theShape.open;
                       (  0, 10)-&gt;G.theShape.lineto;
                       (  5, 15)-&gt;G.theShape.lineto;
                       ( 11,  0)-&gt;G.theShape.lineto;
                       ( 15,  2)-&gt;G.theShape.lineto;
                       (  9, 16)-&gt;G.theShape.lineto;
                       ( 16, 16)-&gt;G.theShape.lineto;
                       G.theShape.close;
                       blackpaint[]-&gt;G.setpaint;
                       G[]-&gt;append;
                       
                       ((0,0), 'S')-&gt;S.init;
                       S[]-&gt;append;
                       
                       L.init;
                       ((0,0), (50,30))-&gt;L.coordinates;
                       L[]-&gt;append;
                       
                       T.init;
                       ((100,20),Helvetica,Italic,20,false,'Quit')-&gt;T.inittext;
                       blackpaint[]-&gt;T.setpaint;
                       T[]-&gt;append;
                       
                       StationMode-&gt;selection;
                       (size, (4,4)) -&gt; AddPoints -&gt; palettewindow.size;
                    #);
               #) (* Mode *);
             open:: 
               (# s: @point;
               do hide (* initially invisible *);
                  false-&gt;paletteOpen; 
                  (NONE, 80, 50, true)-&gt;Mode.open;
                  'Mode'-&gt;title;
                  myCanvas.size-&gt;s;
                  (myCanvas.position, (s.x, 0)) -&gt;AddPoints -&gt; position;
               #);
          #);
        
        myCanvas: @BifrostCanvas
          (# 
             map: @Rect
               (# 
                  init:: 
                    (# 
                    do (* Make THIS(Rect) the size of the
                        * aarhus-bitmap
                        *)
                       aarhus.init;
                       (0,aarhus.bits.height)-&gt;upperleft;
                       aarhus.bits.width-&gt;width;
                       aarhus.bits.height-&gt;height;
                       aarhus[]-&gt;setpaint;
                    #)
               #);
             
             Rail: Line
               (# init:: (# do color[]-&gt;setpaint; 2-&gt;width; #) #);
             
             Station: Picture
               (# name: @text;
                  label: @GraphicText;
                  position: @point; (* Transformed position *)
                  Circle: Ellipse
                    (# radius: @
                         (# r: @integer
                         enter (# 
                               enter r 
                               do r-&gt;horizontalradius-&gt;verticalradius;
                               #)
                         exit r
                         #);
                    #);
                  
                  filledcircle, circleoutline: @Circle;

                  rails: @list
                    (# 
                       element:: 
                         (# r: ^rail;
                            mypoint, 
                            otherpoint: ^PredefinedShape.invalidatepoint;
                         #);
                    #);
                  
                  move:: 
                    (# 
                    do (* Move is called by interactiveMove.
                        * Furtherbind to move the rails too
                        *)
                       
                       (* TM describes the current
                        * transformation.  Make position be the
                        *transformed* position
                        *)
                       circleoutline.center
                         -&gt; TM.transformpoint
                         -&gt; position;
                       
                       (* Since the rails are not members of
                        * THIS(Picture), they are not updated by
                        * interactivemove.  We check what areas
                        * they "damage", and the call of "repair"
                        * that interactivemoveperforms will take
                        * care of updating these areas.
                        *)
                       rails.scan
                       (# 
                       do current.r.getbounds-&gt;damaged;
                          position-&gt;current.mypoint; 
                          (* Changes either current.r.begin or
                           * current.r.end
                           *)
                          current.r.getbounds-&gt;damaged;
                       #);
                    #);
                  
                  shapedesc:: 
                    (# 
                       (* Picture.InteractiveMove uses
                        * hiliteoutline to draw/erase the feedback
                        * for all members of the Picture.  Here we
                        * furtherbind the descriptor for
                        * THIS(PictureShape) to erase / draw
                        * feedback for the rails too
                        *)
                       
                       hiliteoutline:: 
                         (# 
                         do (* TM is a transformation to apply
                             * before the highlighting. In this
                             * case it's just a translation, and
                             * this translation is only to be
                             * used for the endpoint of the rail
                             * belonging to THIS(Station).
                             * Hiliteoutline is called multiple
                             * times by InteractiveMove to draw
                             * and erase the feedback. The
                             * drawing is automatically performed
                             * in XOR-mode, i.e., the immediate
                             * line is erased simply by drawing
                             * it again.  This is the reason why
                             * there is no check to see if the
                             * line is to be drawn or erased
                             *)
                            rails.scan
                            (# 
                            do (if TM[]=NONE then
                                   (* No transformation *)
                                   (current.otherpoint-&gt;CanvasToDevice,
                                   position-&gt;CanvasToDevice)
                                     -&gt; immediateline;
                                else
                                   (current.otherpoint-&gt;CanvasToDevice,
                                   position
                                     -&gt;TM.transformpoint
                                     -&gt;CanvasToDevice)
                                     -&gt; immediateline;
                               if);
                            #);
                            (* Notice that immediateline expects
                             * device coordinates
                             *)
                         #);
                    #);
                  
                  init:: 
                    (# ch: @char;
                       r: @rectangle;
                       c: @point;
                    enter (position, ch)
                    do (* Initialize filledcircle *)
                       filledcircle.init;
                       10-&gt;filledcircle.radius;
                       position-&gt;filledcircle.center;
                       fill[]-&gt;filledcircle.setPaint;
                       
                       (* Initialize circleoutline *)
                       circleoutline.init;
                       11-&gt;circleoutline.radius;
                       position-&gt;circleoutline.center;
                       true-&gt;circleoutline.theshape.stroked;
                       2-&gt;circleoutline.theshape.strokewidth;
                       color[]-&gt;circleoutline.setPaint;
                       
                       (* Center the label within the circles *)
                       ch-&gt;name.put;
                       label.init;
                       (position, Times, Bold, 20, false, name[])
                         -&gt; label.inittext;
                       label.getbounds-&gt;r;
                       (r.x+(r.width) div 2, r.y-(r.height+1) div 2)-&gt;c;
                       (circleoutline.center,c)-&gt;subpoints-&gt;label.move;
                       color[]-&gt;label.setPaint;
                       
                       (* Add circles and label to THIS(Picture)
                        *)
                       filledcircle[]-&gt;add;
                       circleoutline[]-&gt;add;
                       label[]-&gt;add;
                    #);
               #); 
             
             makeStation: @
               (# pos: @point;
                  aStation: ^station;
                  ch: @char;
               enter pos
               do &amp;station[]-&gt;aStation[];
                  (pos, ch)-&gt;aStation.init;
                  ch+1-&gt;ch;
                  aStation[]-&gt;draw;
               #);
             
             interactiveCreateRail: @
               (# r: ^rail;
                  hitstation, otherstation: ^Station;
                  e: ^Station.rails.element;
               enter hitstation[] 
               do &amp;rail[]-&gt;r[];
                  r.init;
                  (r[], hitstation.position, NoModifier)
                    -&gt; interactiveCreateShape;
                  
                  (* Check if r ends in another station *)
                  scan: thePicture.ScanGOsReverse
                    (# 
                    do (if (myCanvas[], r.end) -&gt; go.containspoint then
                           (if go[]
                            //map[]
                            //hitstation[] then (* ignore *)
                            else
                               (if go##=Station## then
                                   (* r ends in another station;
                                    * connect with hitstation
                                    *)
                                   go[]-&gt;otherstation[];
                                   otherstation.position
                                     -&gt; r.end; (* Small
                                                * adjustment
                                                *)
                                   
                                   (* Add r to hitstation and
                                    * otherstation
                                    *)
                                   &amp;hitstation.rails.element[]-&gt;e[];
                                   r[]-&gt;e.r[];
                                   r.theshape.begin[]-&gt;e.mypoint[];
                                   r.theshape.end[]-&gt;e.otherpoint[];
                                   e[]-&gt;hitstation.rails.append;
                                   &amp;otherstation.rails.element[]-&gt;e[];
                                   r[]-&gt;e.r[];
                                   r.theshape.end[]-&gt;e.mypoint[];
                                   r.theshape.begin[]-&gt;e.otherpoint[];
                                   e[]-&gt;otherstation.rails.append;
                                   r-&gt;draw;
                                   (* It looks better if the
                                    * stations cover the ends of
                                    * the rail.  Instead of
                                    * lowering the rail in the
                                    * BifrostCanvas (which would put the
                                    * rail behind the map) we
                                    * raise the two stations
                                    *)
                                   hitstation[]-&gt;bringForward;
                                   otherstation[]-&gt;bringforward;
                                   leave scan
                               if);
                           if);
                       if);
                    #);
               #);             

             open:: 
               (# 
               do (* Make THIS(BifrostCanvas) the size of the map *)
                  map.init;
                  (map.width, map.height)-&gt;Size-&gt;theWindow.size;
                  (* The first Station will have label "A" *)
                  'A'-&gt;makeStation.ch;
               #);
             
             eventhandler:: 
               (# 
                  onOpen:: (# do map[]-&gt;draw; #);
                  
                  onMouseDown:: 
                    (# 
                       (* Actions for Stations *)
                       StationAction: (# s: ^Station enter s[] do INNER #);
                       MoveIt: StationAction
                         (# do (s[],mousepos,NoModifier)-&gt;interactivemove #);
                       MakeRail: StationAction
                         (# do s[]-&gt;interactiveCreateRail #);
                       
                       (* Control pattern for finding a station and
                        * performing an action on it.
                        *)
                       findStation: 
                         (# s: ^Station;
                            action: ##StationAction;
                         enter action##
                         do (* Find out what was hit - if any *)
                            scan: thePicture.ScanGOsReverse
                              (# 
                              do (if (myCanvas[], mousepos)-&gt;go.containspoint then
                                     (if go[]
                                      =map[] then (* ignore *)
                                      else
                                         (if go##=Station## then
                                             (* We hit a station *)
                                             go[]-&gt;s[];
                                             (if action##&lt;&gt;NONE then s[]-&gt;action;
                                             if);
                                             leave scan
                                         if);
                                     if);
                                 if);
                              #);
                         exit s[]
                         #);
                       
                       hitstation: ^Station;
                       
                    do mousepos-&gt;devicetocanvas-&gt;mousepos;
                       
                       (if paletteOpen then  (* Palette determines mode *)
                           (if palettewindow.mode.selection
                            // MoveMode then MoveIt##-&gt;findStation;
                            // StationMode then mousepos-&gt;makeStation;
                            // RailMode then MakeRail##-&gt;findStation;
                           if);
                        else (* Mode-less *)
                           (if findStation-&gt;hitstation[]
                            // NONE then
                               mousepos-&gt;makeStation;
                            else
                               (* We hit a station *)
                               (if shiftmodified then hitstation[]-&gt;MakeRail;
                                else hitstation[]-&gt;MoveIt;
                               if);
                           if);
                       if);
                    #);
                  onKeyDown:: 
                    (# 
                    do (if ch
                        //'Q' then Terminate
                        //'P' then 
                           (if not paletteOpen then
                               palettewindow.show; 
                            else
                               palettewindow.hide;
                           if);
                           not paletteopen -&gt; paletteopen;
                       if)
                    #);
               #);
          #);
        open:: 
          (# 
          do (* Initialize colors for Stations and Rails *)
             color.init; IndianRed-&gt;color.name;
             fill.init;  PaleGreen-&gt;fill.name;
             (* Initialize the BifrostCanvas *)
             (* Open the BifrostCanvas *)
             myCanvas.open;
             (* Open the Palette *)
             palettewindow.open;
             'Type \'P\' to open the Palette'-&gt;putline;
          #)
     #) (* theWindow *)
do theWindow.open;
   1-&gt;Arguments-&gt;theWindow.title;
#)
</PRE>
<!---------------------------------------------------------->
<HR>
<P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left">
<ADDRESS>Appendix A. The Final Program</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<A HREF=snapshot.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A> 
<A HREF=readings.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A> 
<A HREF=../index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A>

</BODY>
</HTML>
