<H1> <A NAME="LINK-bifrost-tut-_Toc402456566"><A NAME=MARKER-9-61></A>Making Stations</A></H1>

<IMG ALIGN=right SRC=station.gif>

The next step is to create stations on top of the map in the
window. First a Station <A NAME=MARKER-2-63></A>pattern is
declared. One way to present the stations is by a filled circle with a
letter centered inside, denoting the station, as shown to the right.
Since the graphical object representing a station thus
contains several other graphical objects, it is declared as a Picture
in subway3.bet<A NAME=MARKER-2-64></A>:</P>


<H4 class=betacaption>subway3.bet</H4>

<PRE CLASS=beta>
Station: Picture
  (# name: @text;
     label: @GraphicText;
     position: @point;
     Circle: Ellipse
       (# radius: @
            (# r: @integer
            enter (# 
                  enter r 
                  do r-&gt;horizontalradius-&gt;verticalradius;
                  #)
            exit r
            #);
       #);
     
     filledcircle, circleoutline: @Circle;

     init:: 
       (# ch: @char;
          r: @rectangle;
          c: @point;
       enter (position, ch)
       do (* Initialize filledcircle *)
          filledcircle.init;
          10-&gt;filledcircle.radius;
          position-&gt;filledcircle.center;
          fill[]-&gt;filledcircle.setPaint;
          
          (* Initialize circleoutline *)
          circleoutline.init;
          11-&gt;circleoutline.radius;
          position-&gt;circleoutline.center;
          true-&gt;circleoutline.theshape.stroked;
          2-&gt;circleoutline.theshape.strokewidth;
          color[]-&gt;circleoutline.setPaint;
          
          (* Center the label within the circles *)
          ch-&gt;name.put;
          label.init;
          (position, Times, Bold, 20, false, name[])
            -&gt; label.inittext;
          label.getbounds-&gt;r;
          (r.x+(r.width) div 2, r.y-(r.height+1) div 2)-&gt;c;
          (circleoutline.center,c)-&gt;subpoints-&gt;label.move;
          color[]-&gt;label.setPaint;

          (* Add circles and label to THIS(Picture) *)
          filledcircle[]-&gt;add;
          circleoutline[]-&gt;add;
          label[]-&gt;add;
        #);
     #); 
</PRE>
<P> In a Station, init enters the position to display the station, and a character to display as a label in it. The Picture is actually made up of two circles, a stroked one displaying the outline of the Station and a filled one for the background. To simplify matters a Circle <A NAME=MARKER-2-65></A>pattern is defined; all it does is to extend the Ellipse pattern with a radius <A NAME=MARKER-2-66></A>attribute for setting horizontalradius <A NAME=MARKER-2-67></A>and verticalradius  <A NAME=MARKER-2-68></A>to the same value. Notice the use of a pattern in the enter part of radius. This is to assure that horizontalradius and verticalradius are only changed when a value is entered to radius, not when it is only used to exit its value. The filled Circle uses a Paint called fill<A NAME=MARKER-2-69></A>, and the stroked one uses a Paint called color<A NAME=MARKER-2-70></A>. These are both SolidColors</P>

<PRE CLASS=beta>
color: @SolidColor;
  (* The color used for stations and rails *)
fill: @SolidColor; 
  (* The color used to fill station backgrounds *)
</PRE>

<P> and are initialized in open in theWindow, just before the Canvas is opened:</P>

<PRE CLASS=beta>
open:: 
  (# 
  do (* Initialize colors for Stations and Rails *)
     color.init; IndianRed-&gt;color.name;
     fill.init;  PaleGreen-&gt;fill.name;
     (* Initialize and open the BifrostCanvas *)
     myCanvas.open
  #)
</PRE>

<P> To display the label inside the circles, a GraphicText <A NAME=MARKER-2-71></A>is used. This Predefined Graphical Object has an attribute for the text to display. Thus the first thing to do is to put the char ch into a text name. Then the GraphicText is initialized, its attributes are set using inittext<A NAME=MARKER-2-72></A>, and it is centered within the circles by moving it a certain distance. This distance is calculated using the bounding box<A NAME=MARKER-2-73></A> of the GraphicText. The subpoints <A NAME=MARKER-2-74></A>pattern simply exits the coordinatewise difference between the two points entered. The GraphicText is given the same Paint as the outline of the Station.</P>
<P> Finally, the three graphical objects just defined and initialized are added to the Picture, and the Station is ready to be displayed.</P>
<P> To create a Station and display it when the mouse is pressed in the window, the onMouseDown <A NAME=MARKER-2-75></A>virtual is extended:</P>

<PRE CLASS=beta>
onMouseDown:: 
  (# 
  do (* Transform mousepos to BifrostCanvas coordinates *)
     mousepos-&gt;devicetocanvas-&gt;mousepos;
     mousepos-&gt;makeStation;
  #);
</PRE>

<P> Local to onMouseDown is a Point called mousepos<A NAME=MARKER-2-76></A>, which is the position of the mouse in the window at the time of the button press. This position is reported in device coordinates, i.e., screen coordinates, so in this case, the first thing to do is to transform mousepos to Canvas coordinates using the devicetocanvas <A NAME=MARKER-2-77></A>attribute of the Canvas pattern. Once this is done, an item called makeStation is invoked to create the Station.</P>

<A NAME=MARKER-2-78></A>
<PRE CLASS=beta>
makeStation: @
   (# pos: @point;
      aStation: ^station;
      ch: @char;
   enter pos
   do &amp;station[] -&gt; aStation[];
      (pos, ch) -&gt; aStation.init;
      ch+1 -&gt; ch;
      aStation[] -&gt; draw;
   #);
</PRE>

<P> makeStation is a static item because it must remember the ch attribute, which is used as the label of the station being created. All it does is to instantiate a Station, increment ch by one (such that the next Station created will be labelled with the next letter in the alphabet), and finally draw the Station just created in myCanvas. As mentioned in the introduction, this means that the Station will now be the front most graphical object in the Picture used by the Canvas to &quot;remember&quot; its Graphical Objects. To make the first Station appear with the right label, makeStation.ch must be initialized. An appropriate place to do this is in open of myCanvas, which then becomes</P>

<PRE CLASS=beta>
open:: 
  (# 
  do (* Make THIS(BifrostCanvas) the size of the map *)
     map.init;
     (map.width, map.height)-&gt;Size-&gt;theWindow.size;
     (* The first Station will have label &quot;A&quot; *)
     'A'-&gt;makeStation.ch;
  #);
</PRE>

<P> <B>Exercise</B>: The above solution for makeStation limits the number of Stations to the number of characters in the alphabeth. Describe a solution without this limitation.</P>


