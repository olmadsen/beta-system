<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Making Rails</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING8></A>


<P><A HREF=move_rail.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=move_station.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P>Bifrost Tutorial</P>


<A NAME=HEADING8-0></A>
<H1> <A NAME="LINK-bifrost-tut-_Toc402456568"><A NAME=MARKER-9-87></A>Making Rails</A></H1>
<P> As mentioned earlier, a Rail should appear as a straight line between the two Stations it connects. Thus, in subway5.bet<A NAME=MARKER-2-89></A>, the pattern Rail is as follows</P>

<PRE CLASS=beta><A NAME=MARKER-2-90></A>Rail: Line<A NAME=MARKER-2-91></A>
   (# init:: (# do color[] -&gt; setpaint; 2 -&gt; width; #) #);
</PRE>

<P> It is simply a Line using the same Paint as is used for the outline of Stations, and which has a width of 2 pixels.</P>
<P> Then comes the question of creating the rails. Again onMouseDown has to be changed.</P>

<PRE CLASS=beta><A NAME=MARKER-2-92></A>onMouseDown:: 
  (# 
  do mousepos-&gt;devicetocanvas-&gt;mousepos;
     
     scan: 
       (# (* Find out what was hit - if any *)
       do thePicture.ScanGOsReverse
          (# 
          do (if (myCanvas[], mousepos)-&gt;go.containspoint then
                 (if go = map[] then (* ignore *)
                  else
                     (if go##=Station## then
                         (* We hit a station *)
                         (if shiftmodified then
                             go[]-&gt;interactiveCreateRail;
                          else 
                             (go[],mousepos,NoModifier)
                               -&gt; interactivemove;
                         if);
                         leave scan
                     if);
                 if);
             if);
          #);
          (* No Station was hit *)
          mousepos-&gt;makeStation;
       #);
  #);
</PRE>

<P> Firstly, in the scanning of graphical objects, now three possibilities exist for what can be hit: Either the map, a Station, or a Rail. Once again hitting the map is taken as if nothing was hit, but if something else was hit, it must be determined what kind of graphical object it was. This is done by comparing the structure reference<A NAME=MARKER-2-93></A> of go with the pattern reference<A NAME=MARKER-2-94></A> Station##. If a Station has been hit, it must be determined whether it should be moved as before, or interaction for connecting it with another Station should be started. Here it is chosen to start connecting it with another Station, if the mouse button press was modified by holding down the SHIFT key<A NAME=MARKER-2-95></A>, or otherwise to move the Station as before.</P>
<P> </P>

<P><B>Exercise</B>: The structure comparison can be a fairly
expensive operation in BETA, and some would say, that using such tests
for types, is not a truly object-oriented programming style. Write a
variant of onMouseDown, that does not use structure comparisons.
<BR>
<B>Hint</B>: Declare a pattern HitPicture with a virtual onHit, and let both
Station and Rail be specializations of HitPicture.</P>

<P> </P>
<P> The creation of a Rail, connecting the Station with another one,
is accomplished using an item called interactiveCreateRail:</P>

<PRE CLASS=beta><A NAME=MARKER-2-96></A>interactiveCreateRail: @
   (# r: ^rail;
      hitstation, otherstation: ^Station;
      ......
   enter hitstation[] 
   do &amp;rail[] -&gt; r[];
      r.init;
      (r[], hitstation.position, NoModifier)
        -&gt; interactiveCreateShape;
      
      (* Check if r ends in another station *)
      scan: thePicture.ScanGOsReverse
         (#
         do (if (myCanvas[], r.end) -&gt; go.containspoint then
                (if go[]
                 // map[]
                 // hitstation[] then (* ignore *)
                else
                    (if go##=Station## then
                        (* r ends in another station;
                         * connect with hitstation
                         *)
                        go[] -&gt; otherStation[];
                        ......

                        r -&gt; draw;
                        (* It looks better if the stations 
                         * cover the ends of the rail. 
                         * Instead of lowering the rail in the 
                         * BifrostCanvas (which would put the rail 
                         * behind the map) we raise the two 
                         * stations
                         *)
                        hitstation[] -&gt; bringForward;
                        otherstation[] -&gt; bringforward;
                        leave scan
                     if);
                 if);
             if);
          #);
    #);
</PRE>

<P> The first thing to do is to instantiate and initialize a
Rail. Then a reference to this Rail is passed to
interactiveCreateShape<A NAME=MARKER-2-97></A>, with the position of
hitStation as starting point, i.e. the feedback, which in this case is
a &quot;rubber line<A NAME=MARKER-2-98></A>&quot;, will begin in
hitStation<A NAME=MARKER-2-99></A>.position. The feedback is ended
when the user releases the mouse button. </P>

<IMG ALIGN=right SRC=railbad.gif>
Then it must be determined if the mouse was released on top of another
Station. This is done in the same fashion as the way it was determined
if a Station was hit in onMouseDown. If the mouse was released on top
of another Station, a reference to this Station is kept in
otherStation<A NAME=MARKER-2-100></A>. In this case, first the two
Stations must be connected; this issue is considered below. Then the
Rail must be drawn, and finally a few rearrangements are done to
improve the appearance of the connection.</P><BR clear=all>

<IMG ALIGN=right SRC=rail.gif>
Instead of leaving the Rail on top of the two Stations after it is
drawn, it looks nicer if the Rail is moved behind the Stations, see
the illustration to the right. One way of doing this is to use
SendBehind <A NAME=MARKER-2-101></A>for the Rail. However, this will
put the Rail to the very back of the Picture of myCanvas, and would
thus put the Rail behind the map too. Instead the two Stations can be
brought to the top of the Picture of myCanvas using BringForward<A
NAME=MARKER-2-102></A>.</P><BR clear=all>

<P> What is left is the question of how to make the two Stations know
that they are connected with a Rail. At least they need to know this
in order to change the Rails when the Stations are moved; this issue
is considered in the next section. Since the rails are to be
considered bi-directional, both Stations connected by a Rail have to
know about the Rail, and where the other Station is. To accomplish
this, each Station will have a list of references to Rails that
connects it with other Stations. Furthermore references to the two end
points of each Rail is kept in the list. These references are
qualified with PredefinedShape.invalidatePoint<A NAME=MARKER-2-103></A>,
which is an ordinary Point, with the exception that changing it will
cause some recalculations of the Shape of the Rail (the Shape is
&quot;invalidated&quot;). This is used internally by Bifrost, e.g. to
control how often the bounding box needs to be recalculated. Using the
standard List <A NAME=MARKER-2-104></A>from the 
<A HREF="../containers/index.html">Container</A> libraries
(automatically INCLUDEd by Bifrost), 
this can be expressed as follows:</P>

<PRE CLASS=beta>Station: Picture
   (# ......    
      rails: @list
         (# element::
               (# r: ^rail;
                  mypoint, 
                  otherpoint: ^PredefinedShape.invalidatepoint;
               #);
         #);
      ......
   #);
</PRE>

<P> Using this data structure, the issue of connecting the two
Stations in interactiveCreateRail can be solved as follows:</P>

<PRE CLASS=beta><A NAME=MARKER-2-105></A>interactiveCreateRail: @
   (# r: ^rail;
      hitstation, otherstation: ^Station;
      e: ^Station.rails.element;
   enter hitstation[] 
   do ... instantiate, init and interactively create r,
          as above ...
      (* Check if r ends in another station *)
      scan: thePicture.ScanGOsReverse
         (#
         do (if (myCanvas[], r.end) -&gt; go.containspoint then
                (if go[]
                 // map[]
                 // hitstation[] then (* ignore *)
                else
                    (if go##=Station## then
                        (* r ends in another station;
                         * connect with hitstation
                         *)
                        go[] -&gt; otherstation[];
                        otherstation.position
                          -&gt; r.end; (* Small adjustment *)
                         
                        (* Add r to hitstation and 
                         * otherstation.
                         *)
                        &amp;hitstation.rails.element[] -&gt; e[];
                        r[] -&gt; e.r[];
                        r.theshape.begin[] -&gt; e.mypoint[];
                        r.theshape.end[]   -&gt; e.otherpoint[];
                        e[] -&gt; hitstation.rails.append;
                        &amp;otherstation.rails.element[] -&gt; e[];
                        r[] -&gt; e.r[];
                        r.theshape.end[]   -&gt; e.mypoint[];
                        r.theshape.begin[] -&gt; e.otherpoint[];
                        e[] -&gt; otherstation.rails.append;

                        ... draw r and rearrange as above ...
                        leave scan
                     if);
                 if);
             if);
          #);
    #);
</PRE>

<P> First a small adjustment is done: The mouse may have been released
anywhere within otherStation<A NAME=MARKER-2-106></A>. It looks better
if the Rail goes through the center of otherStation, so the end point
of r is changed to otherStation.position, which was set to the center
of otherStation when otherStation was initialized. However, both
hitStation and otherStation may have been moved since they were
initialized, so the use of hitStation.position and
otherStation.position as above is not correct if something else isn't
done. What needs to be done is to update the position <A
NAME=MARKER-2-107></A>attribute each time a Station is moved. This can
be done in the move virtual, which is called by interactiveMove<A
NAME=MARKER-2-108></A>. The easiest way to update position is to use
the center of one of the two circles constituting the Station and
applying the transformation matrix TM<A NAME=MARKER-2-109></A><EM><A
REL=FOOTNOTE HREF="#FOOTNOTE-2">[2]</A></EM> of the Station. Notice
that all moving, scaling and rotating of a graphical object is
remembered by changing TM, not by changing the coordinates of the
defining points of the shape of the graphical object.</P>


<PRE CLASS=beta>Station: Picture
   (# 
      ......    
      move::
         (# 
         do (* Move is called by interactiveMove *)
            
            (* TM describes the current transformation.
             * Make position be the *transformed* position
             *)
            circleoutline.center
              -&gt; TM.transformpoint
              -&gt; position;
         #);
      .....
   #);
</PRE>

<P> Now the Stations can be connected with Rails, but one problem remains: If a Station is moved after some Rails have been added to it, the Rails will not move with the Station. In the next section this problem will be addressed.</P>

<HR>

<A NAME=FOOTNOTE-2>[2] </A>
  The use of 3x3 matrices for describing geometrical transformations is described in detail in  <A HREF="../bibliography/index.html#mia91-13">[MIA 91-13]</A>, <A HREF="../bifrost-ref/bifrost-ref-5.html">Chapter 3.</A>

<!-- TOC -->



<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Bifrost Tutorial</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=move_rail.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=move_station.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF=../index.html><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF=index.html#_toc><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
