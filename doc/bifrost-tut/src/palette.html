<H1> <A NAME="LINK-bifrost-tut-_Toc402456570"><A NAME=MARKER-9-123></A>Adding a Palette</A></H1>

<IMG ALIGN=right SRC=palette.gif>
To illustrate the use of multiple Canvasses, the application can be
elaborated a bit: Some users may find it annoying to remember to hold
down the Shift modifier to be able to create rails. Except for the
Shift-modification, the application as described above is
&quot;mode-less&quot;, i.e., a given user action always results in the
same action in the application. As an alternative, the application can
be changed, so that it may be put into different modes. To control
what is the current mode, a Palette <A NAME=MARKER-2-125></A>can be
put into a separate window. This Palette could look like the one shown
to the right. The item with the arrow, indicates &quot;Move-mode<A
NAME=MARKER-2-126></A>&quot;, where all that can be done is moving the
Stations around. The second item contains a Station, and denotes
&quot;Station-mode<A NAME=MARKER-2-127></A>&quot;, where all that can
be done is creation of Stations. The third item contains a Rail, and
denotes &quot;Rail-Mode<A NAME=MARKER-2-128></A>&quot;, where all that
can be done is creation of Rails. Finally the last item is used to
quit the application, using the mouse. In the Bifrost library, a
pattern exists, which is intended to make such palettes out of
graphical objects. The pattern is in <CODE>~beta/bifrost/Palette</CODE>, which the
application thus needs to INCLUDE. Then, in subway7.bet<A
NAME=MARKER-2-129></A>, the Palette may be specified in the following
way:</P>


<PRE CLASS=beta>
(* Constants corresponding to palette selections *)
MoveMode:    (# exit 1 #);
StationMode: (# exit 2 #);
RailMode:    (# exit 3 #);
Quit:        (# exit 4 #);

PaletteWindow: @window
  (# Mode: @Palette
       (# changed:: 
            (# 
            do (if selection=Quit then Terminate if);
            #);
          open::
            (# <A NAME="create_arrow">G: @GraphicalObject;</A>
               <A NAME="create_quit">T: @GraphicText;</A>
               L: @myCanvas.Rail;
               S: @myCanvas.Station;
            do G.init;
               (  0, 32)-&gt;G.theShape.open;
               (  0, 10)-&gt;G.theShape.lineto;
               (  5, 15)-&gt;G.theShape.lineto;
               ( 11,  0)-&gt;G.theShape.lineto;
               ( 15,  2)-&gt;G.theShape.lineto;
               (  9, 16)-&gt;G.theShape.lineto;
               ( 16, 16)-&gt;G.theShape.lineto;
               G.theShape.close;
               blackpaint[]-&gt;G.setpaint;
               G[]-&gt;append;
               
               ((0,0), 'S')-&gt;S.init;
               S[]-&gt;append;
               
               L.init;
               ((0,0), (50,30))-&gt;L.coordinates;
               L[]-&gt;append;
               


               T.init;
               ((100,20),Helvetica,Italic,20,false,'Quit')
                 -&gt;T.inittext;
               blackpaint[]-&gt;T.setpaint;
               T[]-&gt;append;
               
               StationMode-&gt;selection;
               (size, (4,4)) -&gt; AddPoints -&gt; palettewindow.size;
             #);
        #) (* Mode *);
      open:: (* PaletteWindow *)
        (# s: @point;
        do hide (* initially invisible *);
           false-&gt;paletteOpen; 
           (NONE, 80, 50, true)-&gt;Mode.open;
           'Mode'-&gt;title;
           myCanvas.size-&gt;s;
           (myCanvas.position, (s.x, 0)) -&gt;AddPoints -&gt; position;
        #);
  #);
</PRE>
<P> First a standard Lidskjalv window called PaletteWindow is created
to contain the Palette. In the Palette, which is called Mode, open
sets up the contents of the Palette. Mode.open is called from
PaletteWindow.open. It enters a position - <CODE>(10, 10)</CODE> -,
the size of each field in the Palette - 80 times 50, and finally a
boolean spcifying if the sequence of graphical
objects should be placed next to each other (a horizontal Palette<A
NAME=MARKER-2-130></A>), or below each other (a vertical Palette<A
NAME=MARKER-2-131></A>), which is chosen here. The window is given a
title &quot;Mode&quot;, and is placed next to the window containing
the subway system.</P>

<P> In Mode.open the four graphical objects are specified and appended: First the arrow<A NAME=MARKER-2-132></A> is made as an instance of GraphicalObject<A NAME=MARKER-2-133></A>. In a GraphicalObject, the Shape may be directly manipulated. Here the shape definition language<A NAME=MARKER-2-134></A> is used to add the line Segments, that define the outline of the arrow. Then blackpaint<A NAME=MARKER-2-135></A>, which is a local attribute of Palette, is specified as the Paint, and finally the GraphicalObject is appended to the Palette. Likewise instances of Station<A NAME=MARKER-2-136></A>, Rail<A NAME=MARKER-2-137></A>, and GraphicText <A NAME=MARKER-2-138></A>are initialized and appended. Finally the initial selection of the Palette is set. The selection <A NAME=MARKER-2-139></A>attribute of a Palette is an integer holding the number of the currently selected item of the Palette. The number of an item is set to the current number of items after the item has been appended to the Palette. To improve the readability of the program four constant patterns have been defined, exiting the integers corresponding to the selection of the Palette.</P>
<P> The Palette must then be opened. An appropriate place to do this is in when opening the main window:</P>

<PRE CLASS=beta>
open:: 
  (# 
  do (* Initialize colors for Stations and Rails *)
     color.init; IndianRed-&gt;color.name;
     fill.init;  PaleGreen-&gt;fill.name;
     (* Open the BifrostCanvas *)
     myCanvas.open;
     (* Open the Palette *)
     palettewindow.open;
    'Type ''P'' to open the Palette'-&gt;putline;
  #)
</PRE>
<P> Notice, that because hide is called in PaletteWindow.open, the window is not immediately shown when opened: It should be possible to open and close the Palette when the user wants to. The application should behave like before when the Palette is not shown, i.e., Rails are created by Shift-clicking a Station and there are no other modes. But when the Palette is shown, it should define the current mode, as described above. The state of the Palette can be toggled when the user types a 'P':</P>

<PRE CLASS=beta>
paletteOpen: @boolean;

onKeyDown:: 
  (# 
  do (if ch
      //'Q' then Terminate
      //'P' then 
         (if not paletteOpen then
             palettewindow.show; 
          else
             palettewindow.hide;
         if);
         not paletteopen -&gt; paletteopen;
     if)
  #);
  
</PRE>
<P> The current state of the Palette, i.e., shown or hidden, is determined by the boolean paletteOpen<A NAME=MARKER-2-140></A>. This boolean is then used in onMouseDown to determine what to do.</P>

<PRE CLASS=beta><A NAME=MARKER-2-141></A>onMouseDown:: 
  (# 
     (* Actions for Stations *)
     StationAction: (# s: ^Station enter s[] do INNER #);
     MoveIt: StationAction
       (# do (s[],mousepos,NoModifier)-&gt;interactivemove #);
     MakeRail: StationAction
       (# do s[]-&gt;interactiveCreateRail #);
     
     (* Control pattern for finding a station and
      * performing an action on it.
      *)
     findStation: 
       (# s: ^Station;
          action: ##StationAction;
       enter action##
       do (* Find out what was hit - if any *)
          scan: thePicture.ScanGOsReverse
            (# 
            do (if (myCanvas[], mousepos)-&gt;go.containspoint then
                   (if go[]
                    // map[] then (* ignore *)
                    else
                       (if go##=Station## then
                           (* We hit a station *)
                           go[]-&gt;s[];
                           (if action##&lt;&gt;NONE then s[]-&gt;action if);
                           leave scan
                       if);
                    if);
                if);
            #);
       exit s[]
       #);
     hitstation: ^Station;
                       
  do mousepos-&gt;devicetocanvas-&gt;mousepos;
                       
     (if paletteOpen then  (* Palette determines mode *)
         (if palettewindow.mode.selection
          // MoveMode then MoveIt##-&gt;findStation;
          // StationMode then mousepos-&gt;makeStation;
          // RailMode then MakeRail##-&gt;findStation;
          if);
      else (* Mode-less *)
          (if findStation-&gt;hitstation[]
           // NONE then
              mousepos-&gt;makeStation;
           else
              (* We hit a station *)
              (if shiftmodified then hitstation[]-&gt;MakeRail;
               else hitstation[]-&gt;MoveIt;
              if);
           if);
      if);
  #);
</PRE>
<P> If the Palette is open, as mentioned, Mode.selection determines the current mode and otherwise the behavior should be as before. Because of the more complex control structure, a slightly different approach is taken: There are several places in the code, where it should be known whether a Station was hit or not. A general control pattern findStation is defined. This will search for a Station that is hit, in the same way as before. If a hit Station is found, an action can be performed on it. This action is specified to findStation <A NAME=MARKER-2-142></A>by using a pattern reference. Using findStation, the control structure becomes much shorter:</P>
<UL>
<LI> In &quot;Move-Mode&quot; all button presses on Stations leads to an invocation of InteractiveMove, regardless of the state of the Shift-modifier.
<LI> In &quot;Station-Mode&quot; all mouse presses leads to creation of a Station, regardless of if the button press was on top of another Station. There is no need to know if a Station was hit or not.
<LI> In &quot;Rail-Mode&quot;, all button presses on Stations start the interaction for creating a Rail, regardless of the state of the Shift-modifier.
</UL>
<P> If the Palette is not open, the behavior should be as before. As can be seen the old behavior can also be specified using findStation and the action patterns.</P>
<P> The use of pattern variables for the action in findStation could just as well be changed to normal object references (qualified by StationAction). This is mostly a matter of taste.</P>







<!-- TOC -->




