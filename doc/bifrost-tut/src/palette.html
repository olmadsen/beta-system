<H1>Adding a Palette</H1>

<IMG ALIGN=right SRC=palette.gif>
To illustrate the use of multiple Canvasses, the application can be
elaborated a bit: Some users may find it annoying to remember to hold
down the Shift modifier to be able to create rails. Except for the
Shift-modification, the application as described above is
'mode-less', i.e., a given user action always results in the
same action in the application. As an alternative, the application can
be changed, so that it may be put into different modes. To control
what is the current mode, a <INX>Palette</INX>can be
put into a separate window. This Palette could look like the one shown
to the right. The item with the arrow, indicates
'<INX>Move-mode</INX>', 
where all that can be done is moving the
Stations around. The second item contains a Station, and denotes
'<INX>Station-mode</INX>', where all that can
be done is creation of Stations. The third item contains a Rail, and
denotes '<INX>Rail-Mode</INX>', where all that
can be done is creation of Rails. Finally the last item is used to
quit the application, using the mouse. In the Bifrost library, a
pattern exists, which is intended to make such palettes out of
graphical objects. The pattern is in <CODE>~beta/bifrost/Palette</CODE>, which the
application thus needs to INCLUDE. Then, in <INX>subway7.bet</INX>, 
the Palette may be specified in the following
way:


<A NAME="create_arrow"><A NAME="create_quit">
<BETA>
(* Constants corresponding to palette selections *)
MoveMode:    (# exit 1 #);
StationMode: (# exit 2 #);
RailMode:    (# exit 3 #);
Quit:        (# exit 4 #);

PaletteWindow: @window
  (# Mode: @Palette
       (# changed:: 
            (# 
            do (if selection=Quit then Terminate if);
            #);
          open::
            (# G: @GraphicalObject;</A>
               T: @GraphicText;</A>
               L: @myCanvas.Rail;
               S: @myCanvas.Station;
            do G.init;
               (  0, 32)->G.theShape.open;
               (  0, 10)->G.theShape.lineto;
               (  5, 15)->G.theShape.lineto;
               ( 11,  0)->G.theShape.lineto;
               ( 15,  2)->G.theShape.lineto;
               (  9, 16)->G.theShape.lineto;
               ( 16, 16)->G.theShape.lineto;
               G.theShape.close;
               blackpaint[]->G.setpaint;
               G[]->append;
               
               ((0,0), 'S')->S.init;
               S[]->append;
               
               L.init;
               ((0,0), (50,30))->L.coordinates;
               L[]->append;
               


               T.init;
               ((100,20),Helvetica,Italic,20,false,'Quit')
                 ->T.inittext;
               blackpaint[]->T.setpaint;
               T[]->append;
               
               StationMode->selection;
               (size, (4,4)) -> AddPoints -> palettewindow.size;
             #);
        #) (* Mode *);
      open:: (* PaletteWindow *)
        (# s: @point;
        do hide (* initially invisible *);
           false->paletteOpen; 
           (NONE, 80, 50, true)->Mode.open;
           'Mode'->title;
           myCanvas.size->s;
           (myCanvas.position, (s.x, 0)) ->AddPoints -> position;
        #);
  #);
</BETA>
<P> First a standard Lidskjalv window called PaletteWindow is created
to contain the Palette. In the Palette, which is called Mode, open
sets up the contents of the Palette. Mode.open is called from
PaletteWindow.open. It enters a position - <CODE>(10, 10)</CODE> -,
the size of each field in the Palette - 80 times 50, and finally a
boolean spcifying if the sequence of graphical
objects should be placed next to each other 
(a <INX>horizontal Palette</INX>), 
or below each other 
(a <INX>vertical Palette</INX>), 
which is chosen here. The window is given a
title 'Mode', and is placed next to the window containing
the subway system.</P>

<P> In Mode.open the four graphical objects are specified and
appended: First the <INX>arrow</INX> is made as an instance of
<INX>GraphicalObject</INX>. In a GraphicalObject, the Shape may be
directly manipulated. Here the <INX>shape definition language</INX> is
used to add the line Segments, that define the outline of the
arrow. Then <INX>blackpaint</INX>, which is a local attribute of
Palette, is specified as the Paint, and finally the GraphicalObject is
appended to the Palette. Likewise instances of <INX>Station</INX>,
<INX>Rail</INX>, and <INX>GraphicText</INX> are initialized and
appended. Finally the initial selection of the Palette is set. The
<INX>selection</INX> attribute of a Palette is an integer holding the
number of the currently selected item of the Palette. The number of an
item is set to the current number of items after the item has been
appended to the Palette. To improve the readability of the program
four constant patterns have been defined, exiting the integers
corresponding to the selection of the Palette.</P>

<P> The Palette must then be opened. An appropriate place to do this
is in when opening the main window:</P>


<BETA>
open:: 
  (# 
  do (* Initialize colors for Stations and Rails *)
     color.init; IndianRed->color.name;
     fill.init;  PaleGreen->fill.name;
     (* Open the BifrostCanvas *)
     myCanvas.open;
     (* Open the Palette *)
     palettewindow.open;
    'Type ''P'' to open the Palette'->putline;
  #)
</BETA>

<P> Notice, that because hide is called in PaletteWindow.open, the
window is not immediately shown when opened: It should be possible to
open and close the Palette when the user wants to. The application
should behave like before when the Palette is not shown, i.e., Rails
are created by Shift-clicking a Station and there are no other
modes. But when the Palette is shown, it should define the current
mode, as described above. The state of the Palette can be toggled when
the user types a 'P':</P>


<BETA>
paletteOpen: @boolean;

onKeyDown:: 
  (# 
  do (if ch
      //'Q' then Terminate
      //'P' then 
         (if not paletteOpen then
             palettewindow.show; 
          else
             palettewindow.hide;
         if);
         not paletteopen -> paletteopen;
     if)
  #);
  
</BETA>
<P> The current state of the Palette, i.e., shown or hidden, is
determined by the boolean <INX>paletteOpen</INX>. This boolean is then
used in onMouseDown to determine what to do.</P>

<INX HIDDEN>onMouseDown</INX>
<BETA>onMouseDown:: 
  (# 
     (* Actions for Stations *)
     StationAction: (# s: ^Station enter s[] do INNER #);
     MoveIt: StationAction
       (# do (s[],mousepos,NoModifier)->interactivemove #);
     MakeRail: StationAction
       (# do s[]->interactiveCreateRail #);
     
     (* Control pattern for finding a station and
      * performing an action on it.
      *)
     findStation: 
       (# s: ^Station;
          action: ##StationAction;
       enter action##
       do (* Find out what was hit - if any *)
          scan: thePicture.ScanGOsReverse
            (# 
            do (if (myCanvas[], mousepos)->go.containspoint then
                   (if go[]
                    // map[] then (* ignore *)
                    else
                       (if go##=Station## then
                           (* We hit a station *)
                           go[]->s[];
                           (if action##&lt;&gt;NONE then s[]->action if);
                           leave scan
                       if);
                    if);
                if);
            #);
       exit s[]
       #);
     hitstation: ^Station;
                       
  do mousepos->devicetocanvas->mousepos;
                       
     (if paletteOpen then  (* Palette determines mode *)
         (if palettewindow.mode.selection
          // MoveMode then MoveIt##->findStation;
          // StationMode then mousepos->makeStation;
          // RailMode then MakeRail##->findStation;
          if);
      else (* Mode-less *)
          (if findStation->hitstation[]
           // NONE then
              mousepos->makeStation;
           else
              (* We hit a station *)
              (if shiftmodified then hitstation[]->MakeRail;
               else hitstation[]->MoveIt;
              if);
           if);
      if);
  #);
</BETA>

<P> If the Palette is open, as mentioned, Mode.selection determines
the current mode and otherwise the behavior should be as
before. Because of the more complex control structure, a slightly
different approach is taken: There are several places in the code,
where it should be known whether a Station was hit or not. A general
control pattern findStation is defined. This will search for a Station
that is hit, in the same way as before. If a hit Station is found, an
action can be performed on it. This action is specified to 
<INX>findStation</INX>
by using a pattern reference. Using findStation, the
control structure becomes much shorter:</P>

<UL>
<LI> In 'Move-Mode' all button presses on Stations leads to an invocation of InteractiveMove, regardless of the state of the Shift-modifier.
<LI> In 'Station-Mode' all mouse presses leads to creation of a Station, regardless of if the button press was on top of another Station. There is no need to know if a Station was hit or not.
<LI> In 'Rail-Mode', all button presses on Stations start the interaction for creating a Rail, regardless of the state of the Shift-modifier.
</UL>
<P> If the Palette is not open, the behavior should be as before. As can be seen the old behavior can also be specified using findStation and the action patterns.</P>
<P> The use of pattern variables for the action in findStation could just as well be changed to normal object references (qualified by StationAction). This is mostly a matter of taste.</P>



