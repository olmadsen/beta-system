#!/usr/local/bin/perl -s

# use strict;

sub usage
{
    print STDERR "usage: makedoc [-f] [-p] [-v] [-d] <manual>.book | <file>.html\n";
    print STDERR "  -f   use full urls in HREFs (http://www.mjolner.com/...)\n";
    print STDERR "  -p   do not generate PDF\n";
    print STDERR "  -h   print this summary\n";
    print STDERR "  -s   special treatment of headings in interface files\n";
    print STDERR "  -v   verbose output\n";
    print STDERR "  -d   debug makedoc script\n";
    print STDERR "  If .book file is given as argument, a full manual set is generated.\n";
    print STDERR "  If a single HTML file is given as input, that file is preprocessed.\n";
    exit(1);
}

# TODO:
#   use strict and -w, and define remaining global variables below.
#   Fix titles for src-generated files (OK for intsrcfiles)
#   Fix prev/next TITLE for src-generated files (OK for intsrcfiles)
#   Eliminate global $filenumber
#   Continuation indications in all but first column in index 'foo, continued'.
# IDEAS:
#   Possibly a CAP attribute for INX (to appear in index instead of indexed word)?
#   remove trailing numbers from interface index anchors?
#   print.html to supplement PDF? Problem with internal links).


# Global variables
# arrays
my @srcfiles = ();         # array of file names from src subdirectory
my @dstfiles = ();         # array of file names to store output files in
my @intsrcfiles = ();      # array of file names to convert to interface files
my @intdstfiles = ();      # array of file names to store output interface files in
my @programs = ();         # used to build list of programs
my @figures = ();          # used to build list of figures
my @headings = ();         # used to build table of contents
my @intheadings = ();      # used to build interface descriptions part of table of contents
my @index = ();            # used to build index
my @num_h = (0,0,0,0,0,0); # array of occurrences of headings 1 to 6

# Variables that may be set by ../build
$skippdf        = 0  if (!defined($skippdf));
$book_file_name = "" if (!defined($book_file_name));
$verbose        = 0  if (!defined($verbose));
$debug          = 0  if (!defined($debug));

# Other variables
my $numinxcolumns = 3;     # Number of columns in alphabetic index
my $src = "src/";
my $dst = "";
my $intsrc = "";
my $intdst = "";
my $filenumber = 0;        # used to index @srcfiles and @headings
my $num_beta   = 0;        # Number of occurences of <BETA LIST> 
my $num_fig    = 0;        # Number of occurences of <FIG>
my $num_foot   = 0;        # Number of occurences of <FOOTNOTE>
my $foot_ruler_done   = 0; # Has a footnote ruler been generated for page?
my $num_inx    = 0;        # Number of occurences of <INX>
my $headinglevel      = 0;        # Current heading level
my $srcline    = "";       # Used to read files from src directory into
my $special_headers = 0;
my $insert_validhtml40 = 0;
my $fullpath   = 0;
my $css =                "../style/miadoc.css";
my $jsdir =              "../javascript";
my $imagedir =           "../images";
my $mainfile =           "../index.html";
my $tocfile =            "index.html";
my $indexfile =          "inx.html";
my $programsfile =       "programs.html";
my $figuresfile =        "figures.html";
my $pdftitlefile =       "pdftitle.html";
my $do_program_list = 0;
my $do_figure_list = 0;
my $leftmargin=25;
my $tab_width = 8;
my $htmldoc="htmldoc";

# Variables used by grammar processing only
my @gramfiles = ();

sub set_default_variable_values
{
    if ($fullpath){
	local $url = "http://www.mjolner.com/mjolner-system/documentation";
	$css = "$url/style/miadoc.css";
	$jsdir = "$url/javascript";
	$imagedir = "$url/images";
	$mainfile = "$url/index.html";
    }
    if (-d "/users/beta/GNU/bin/sun4s/"){
	$ENV{'PATH'} .= ":/users/beta/GNU/bin/sun4s/";
	$ENV{'LD_LIBRARY_PATH'} .= ":/usr/local/lib:/users/beta/GNU/bin/sun4s/";
    }
}

sub read_file
{
    local ($filename) = @_;
    local ($line);
    if (!open(FILE, "$filename")){
	print STDERR "***Cannot open $filename for reading: $!\n";
	exit 1;
    }

    $line="";
    while (<FILE>) {
	$line .= &untabify($_);
    };
    close (FILE);
    return $line;
}

sub read_gif_dim
{
    local ($filename) = @_;
    local ($buffer,$header, $width, $height);
    open(GIF, "$filename") || die "***Cannot open GIF file $filename for reading: $!\n";
    binmode GIF;
    read GIF, $buffer, 10 || die "***Cannot read header of GIF file $filename: !$\n";
    close GIF;
    ($header, $width, $height) = unpack "A6 v2", $buffer;
    if ($header =~ /^GIF8[79]a$/) {
        return ($width, $height);
    } else {
        print STDERR "***$filename: Unknown GIF file format $header\n";
	return (0,0);
    }
}

sub rename_file
{
    local ($old, $new) = @_;
    rename $old, $new || die "Cannot rename file $old to $new: $!\n";
}

sub SmartMkdir {
    my ($path) = @_;
    my ($full) = '';
    foreach $dir (split '/', $path) {
	$full .= $dir . '/';
	if (!-d $full){
	    print STDERR "mkdir $full\n" if ($verbose);
	    if (!mkdir ($full, 0755)){
		print STDERR "Cannot create directory \"$full\": $!\n";
		return;
	    }
	}
    }
}
sub go_up
{
    local ($path, $up) = @_;

    if ($fullpath){
	return $path;
    } else {
	return "../" x($up) . $path;
    }
}

sub untabify
{
    local($line) = @_;
    while($line =~ /\011/)
    {
        $line =~ s/\011/" " x ($tab_width - (length($`) % $tab_width))/ge;
    }
    return $line;
}

sub expand 
{
    local ($path) = @_;
    while ($path =~ m/\$(\w+)/){
	local $var = $1;
	if (!defined($ENV{$var})){
	    print "Expand $path: Warning: $var not in environment\n";
	} else {
	    $path = $` . $ENV{$var} . $';
	}
    }
    return $path;
}

sub remove_tag()
{
    local ($tag) = @_;

    if ($tag =~ m/<.*<.*>/){
	print STDERR "Warning: unquoted '<' in tag:\n\t$tag";
    }
    return "";
}

sub untag
{
    local ($string) = @_;
    $string =~ s/(<[^>]+>)/&remove_tag($1)/sgoe;
    return $string;
}

sub quote_html
{
    local ($string) = @_;

    #print STDERR "quote: $string\n";
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    return $string;
}

sub unquote_html
{
    local ($string) = @_;

    #print STDERR "unquote: '$string' yields";
    $string =~ s/&gt;/>/g;
    $string =~ s/&lt;/</g;
    $string =~ s/&amp;/&/g;
    #print STDERR " '$string'\n";
    return $string;
}
  
sub quote_special
{
    local ($string) = @_;
    #print STDERR "quote_special: '$string' yields";
    # special feature used for quoting through index generation
    $string =~ s/&([a-zA-Z]+;)/\007$1/g;
    $string =~ s/:/\006/g;
    #print STDERR " '$string'\n";
    return $string;
}


sub unquote_special
{    
    local ($string) = @_;
    # Used by index generation
    $string =~ s/\007([a-zA-Z]+;)/&$1/g;
    $string =~ s/\006/:/g;
    return $string;
}
     
sub strip_extension
{
    local ($string) = @_;
    if ( $string =~ m/([^\.]+)\..*/ ) {
	$string = $1;
    }
    return $string;
}

sub strip_prefix
{
    local ($path, $prefix) = @_;
    $path  = &trim_path($path);
    $refix = &trim_path($prefix);
    $path =~ s%^$prefix/%%;
    return $path;
}

sub strip_path
{
    local ($string) = @_;
    if ( $string =~ m%.*/([^/]+$)% ) {
	$string = $1;
    }
    return $string;
}

sub strip_dirs
{
    local ($path, $numdirs) = @_;
    $path = &trim_path($path);
    do{
	$path =~ s%^[^/]*/%%;
	$numdirs--;
    } while ($numdirs>0);
    return $path;
}

sub trim_path
{
    local ($path) = @_;
    # delete double slashes
    $path =~ s%//+%/%g;
    # delete trailing slash
    $path =~ s%/$%%;
    # delete initial ./
    $path =~ s%^\./%%;
    return $path;
}

sub countdirs
{
    local ($path) = @_;
    local $numdirs = 0;
    $path = &trim_path($path);
    $path =~ s%/%$numdirs++%ge;
    #print STDERR "numdirs($path)=$numdirs\n";
    return $numdirs;
}

sub legal_identifier

{
    local ($id) = @_[0];
    return ($id =~ m/[a-zA-Z_]\w*/);
}

sub num_chars
# Occurences of $ch in $string
{
    local ($ch, $string) = @_;
    local ($i, $num);
    $num=0;
    for ($i=0; $i<length($string); $i++){
	$num++ if (substr($string, $i, 1) eq "$ch");
    }
    #print STDERR "num_chars($ch, $string) = $num\n";
    return $num;
}

sub get_file_size
{
    local ($filename) = @_;
    local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	= stat($filename);
    if ($size>(1024*1024)){
	return sprintf "%.2fMb", $size/(1024*1024);
    }
    if ($size>1024){
	return sprintf "%.0fkb", $size/1024;
    }
    return sprintf "%d bytes", $size;
}

sub print_lastmod
{
    local ($filename) = @_;
    local @month_names = ("January","February","March","April","May","June","July","August","September","October","November","December");
    local @day_names   = ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday");
    local @sup = ();
    local ($sup_date, $lastmod, $prompt);
    if ($filename ne ""){
	local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	    = stat($filename);
	$lastmod = $mtime;
	$prompt = "Modified";
   } else {
	$lastmod = time;
	$prompt = "Generated";
    }
    local ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime($lastmod);
    $sup[1] = $sup[21] = $sup[31] = "st";
    $sup[2] = $sup[22] = "nd";
    $sup[3] = $sup[23] = "rd";
    if (($date==1)  || ($date==2)  || ($date==3) ||
	($date==21) || ($date==22) || ($date==23) ||
	($date==31)) {
	$sup_date = $sup[$date];
    } else {
	$sup_date ="th";
    }
    # Y2K hack
    $year %= 100;
    if ($year >= 98 ){
	$year = "19" . $year;
    } else {
	if ($year<10){
	    $year = "0" . $year;
	}
	$year = "20" . $year;
    }
 
    print "<DIV STYLE=\"font:smaller\">";
    print "[$prompt: $day_names[$day] $month_names[$month] $date<SUP>$sup_date</SUP> $year at $hour:$min]\n";
    print "</DIV>\n";
}

sub print_valid_html_button()
{
    local ($up) = @_;
    local ($imagedir1);

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }

    print<<EOT if ($insert_validhtml40);
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="${imagedir1}/vh401.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
EOT
}

sub print_rel_link
{
    local ($type, $href) = @_;
    $type = ucfirst ($type);
    print<<EOT;
<LINK REL="$type" HREF="$href">
EOT
}

sub print_nav_link
{
    local ($type, $href, $title) = @_;
    local ($label) = ucfirst ($type);
    if ($href eq ""){
	print "document.write(\'\\<A NAME=\"$label\" CLASS=\"SideBarDisabled\" TITLE=\"$title\"\\>$label\\</A\\>\\<BR\\>');\n";
    } else {
	print "document.write(\'\\<A HREF=\"$href\" onClick=\"out\(\);\" CLASS=\"SideBar\" TITLE=\"$title\"\\>$label\\</A\\>\\<BR\\>');\n";
    }
}

sub print_layer_begin
{

    local ($up) = @_;
    local ($imagedir1);

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }
    
    print<<EOT;
<LAYER id="SideBar" onMouseover="pull()" onMouseout="draw()" style="position:absolute;left:-95px;width:80px;layer-background-color:#669999;padding:5px;line-height:25px; ">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
<!--
if (document.all){
  document.write('\\<DIV id="SideBar2" onMouseover="pull()" onMouseout="draw()" STYLE="position:absolute;left:-80px;top:15px;width:100px;background-color:#669999;padding:5px;line-height:25px;" TITLE=\"Navigation Bar: Slides out when cursor is moved out\"\\>');
}
if (document.all && (navigator.userAgent.indexOf("Mac")==-1)) {
  document.write('\\<IMG SRC="$imagedir1/navigation-light.gif" STYLE="position:absolute;left:84;top:5" WIDTH=13 HEIGHT=63 ALT=""\\>');
} else {
  document.write('\\<IMG SRC="$imagedir1/navigation-light.gif" ALIGN=RIGHT WIDTH=13 HEIGHT=63 ALT=""\\>');
}
EOT
}

sub print_layer_end
{
    print<<EOT;
if (document.all)
  document.write('\\</DIV\\>');
else
  document.write('&nbsp;');
SetupSideBar();
//-->
</SCRIPT>
</LAYER>
EOT
}

sub print_head_begin
{
    local ($title, $up) = @_;
    local ($jsdir1, $css1);

    if ($up){
	$jsdir1 = &go_up($jsdir,$up);
	$css1   = &go_up($css,$up);
    } else {
	$jsdir1 = $jsdir;
	$css1   = $css;
    }

    print<<EOT;


<!-- **************************************** -->
<!-- *** AUTOGENERATED FILE - DO NOT EDIT *** -->
<!-- **************************************** -->


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>$title</TITLE>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/ns-resize.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/sidebar.js">
</SCRIPT>
<LINK REL="stylesheet" HREF="$css1" TYPE="text/css">
EOT
}

sub print_header
{
    local ($title, $prev, $prevtip, $next, $nexttip, $inx, $up) = @_;

    print_head_begin($title, $up);
    &print_rel_link("next", $next) if ($next ne "");
    &print_rel_link("prev", "$prev") if ($prev ne "");
    &print_rel_link("start", &go_up($mainfile,$up));
    &print_rel_link("first", &go_up($tocfile,$up));
    &print_rel_link("last", &go_up($inx,$up));
    &print_rel_link("contents", &go_up($tocfile,$up));
    &print_rel_link("index", &go_up($inx,$up)) if ($inx ne "");
    &print_rel_link("copyright", &go_up("../copyright.html", $up));
    &print_rel_link("help", &go_up("../help.html", $up));
    #&print_rel_link("search", &one_up("search.html"));    
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");

    print "<SCRIPT TYPE=\"text/javascript\" LANGUAGE=\"JavaScript1.2\">\n";
    print "<!--\n";
    print "var next     = '$next';\n" if ($next ne "");
    print "var prev     = '$prev';\n" if ($prev ne "");
    print "var content  = '" . &go_up($tocfile,$up) . "';\n";
    print "var inx      = '" . &go_up($inx,$up) . "';\n" if ($inx ne "");
    print "var help     = '" . &go_up("../help.html",$up) . "';\n";
    print "var manuals  = '" . &go_up($mainfile,$up) . "';\n";
    print "//-->\n";
    print "</SCRIPT>\n";

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px" onLoad="window.status='Type ? for Help'; return true">
<A NAME="_top"></A>
EOT

    $nexttip = "Next: $nexttip" if ($next ne "");
    $prevtip = "Previous: $prevtip" if ($prev ne "");

    &print_layer_begin($up);
    &print_nav_link("next", $next, $nexttip);
    &print_nav_link("previous", $prev, $prevtip);
    &print_nav_link("Page Top", "#_top", "Top of Page");
    &print_nav_link("content", &go_up($tocfile,$up), "Table of Contents");
    &print_nav_link("index", &go_up($inx,$up), "Alphabetic Index") if ($inx ne "");
    &print_nav_link("PDF", &go_up($pdf,$up), "Portable Document Format version of manual");
    print "document.write('\<HR ALIGN=LEFT WIDTH=60\>');\n";
    &print_nav_link("Help", &go_up("../help.html",$up), "Help on these Online Manuals");
    &print_nav_link("manuals", &go_up($mainfile,$up), "Manuals Main Entry");
    #&print_index_nav_toc;
    &print_layer_end;

}

sub print_src_header
{
    local ($title) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    if ($filenumber==$#srcfiles){
	# last file
	if ($#intsrcfiles>0){
	    # Cannot use find_next_interface_file here, 
	    # since intheadings is not yet created.
	    # And can't call build_intheadings yet, since last file is
	    # not yet updated, i.e. num_h[*] are not yet updated.
	    # Copy the stuff in build_intheadings
	    local ($intdstfile) = $intdstfiles[0];
	    local ($intsrcfile) = $intsrcfiles[0];
	    if ($intsrcfile eq ""){
		# Special case used to force a new interface chapter
		$nexttip = "" . $num_h[1]+1 . " $intdstfile";
		($nexttip, $next) = &parse_int_chap($nexttip);
		$next .= "/index.html";
	    } else {
		print STDERR "Error: print_src_header: No interface header?\n";
		#$num_h[1]++; # pretend we're at next chapter now
		#$nexttip =  &generate_int_title($intsrcfile);
		#$num_h[1]--; # go back again
		#$num_h[2]--; # was counted up by generate_int_title
		#$next = intdstfile;
	    }
	} else {
	    $next = $indexfile;
	    $nexttip = "Alphabetic Index";
	}
    } else {
	$next = $dstfiles[$filenumber+1];
	$nexttip = $next;
    }
    if ($filenumber==0){
	# first file
	if ($do_figure_list){
	    $prev = $figuresfile;
	    $prevtip = "List of Figures";
	} elsif ($do_program_list){
	    $prev = $programsfile;
	    $prevtip = "List of Programs";
	} else {
	    $prev = $tocfile;
	    $prevtip = "Table of Contents";
	}
    } else {
	$prev = $dstfiles[$filenumber-1];
	$prevtip = $prev;
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0)
}

sub print_trailer
{
    local ($title, $up, $sourcefile) = @_;
    local ($w) = 40;
    local ($copyrightfile) = &go_up("../copyright.html", $up);
    #if ($copyright eq ""){ $w = 50; }
    &print_valid_html_button($up);

    print<<EOT;
<P></P>
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="$w%" align="left"><ADDRESS>$title</ADDRESS></TD>
EOT
    print<<EOT if ($w==40);
<TD width="20%" align="center"><FONT size=-1><A HREF="$copyrightfile">&#169;</A> $copyrightyears <A HREF=\"http://www.mjolner.com\">Mj&oslash;lner Informatics</A></FONT></TD>
EOT
    print<<EOT;
<TD width="$w%" align="right">
EOT
    
    print_lastmod("$sourcefile");

    print<<EOT;
</TD>
</TABLE>
<P></P>
</BODY>
</HTML>
EOT
}

sub print_toc_header
{
    local ($next, $nexttip);

    if ($do_program_list){
	$next = $programsfile;
	$nexttip = "List of Programs";
    } elsif ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } elsif ($#gramfiles>=0){
	local ($gram, $graminx);
	($gram, $nexttip, $next, $graminx) = &gram_names(0);
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, "", "No Previous Page", $next, $nexttip, $indexfile, 0)
}

sub print_index_nav_toc
{
    local ($i, $ch, $n);
    print "document.write('\\<HR ALIGN=LEFT WIDTH=60\\>')\n";
    $n=0;
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	$n++;
	if ($caps{$ch}){
	    print "document.write('\\<A HREF=\"#_$ch\" CLASS=\"SideBarFixed\" TITLE=\"Entries starting with $ch\" onClick=\"out();\"\\>$ch\\</A\\>";
	} else {
	    print "document.write('\\<A NAME=\"_$ch\" CLASS=\"SideBarFixedDisabled\" TITLE=\"No entries starting with $ch\"\\>$ch\\</A\\>";
	}
	if ($i==90){
	    print("');\n");
	} elsif ($n%4==0){
	    print "\\<BR\\>');\n";
	} else {
	    print " \\&nbsp;');\n";
	}
    }
}

sub print_index_header
{
    local ($title) = @_;
    local ($next, $prev, $nexttip, $prevtip);

    if ($#intsrcfiles>0){
	# Previous was last interface file
	($prev, $prevtip) = &find_prev_interface_file($#intsrcfiles+1, 0);
    } else {
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
    }
    print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0);
}

sub find_next_interface_file
{
    local ($number, $up) = @_;
    local ($next, $nexttip);
    #print STDERR "\nfind_next_interface_file($number, $up) = ";
    $number++;
    if ($number>$#intsrcfiles){
	# passed last interface file
	$next = $indexfile;
	$nexttip = "Alphabetic Index";
    } else {
	($nexttip, $next) = split("\@", $intheadings[$number]);
	if ($next eq ""){
	    #print STDERR "find_next_interface_file: int chap: $nexttip\n";
	    ($nexttip, $next) = &parse_int_chap($nexttip);
	    $next .= "/index.html";
	} 
    }
    $next = &go_up($next, $up);
    #print STDERR "($next, $nexttip)\n";
    return ($next, $nexttip);
}

sub find_prev_interface_file
{
    local ($number, $up) = @_;
    local ($prev, $prevtip);
    #print STDERR "\nfind_prev_interface_file($number, $up) = ";
    $number--;
    if ($number<0){
	# passed first interface file
	$prev = $dstfiles[$#dstfiles];
	$prevtip = ucfirst(&strip_extension(&strip_path($prev))) . " Interface";
    } else {
	($prevtip, $prev) = split("\@", $intheadings[$number]);
	if ($prev eq ""){
	    # Found interface chapter
	    ($prevtip, $prev) = &parse_int_chap($prevtip);
	    $prev .= "/index.html";
	} 
    }
    $prev = &go_up($prev, $up);
    #print STDERR "($prev, $prevtip)\n";
    return ($prev, $prevtip);
}

sub print_interface_toc_header
{
    local ($title, $up, $intfilenumber) = @_;
    local ($next, $nexttip, $prev, $prevtip, $nextno) = 0;
    
    ($next, $nexttip) = &find_next_interface_file($intfilenumber, $up);
    if ($intfilenumber==0){
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
	$prev = &go_up($prev,$up);
    } else {
	($prev, $prevtip) = &find_prev_interface_file($intfilenumber, $up);
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, $up)
}

sub print_interface_header
{
    local ($title,$up) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    print_head_begin($title, $up);

    ($next, $nexttip) = &find_next_interface_file($filenumber, $up);
    ($prev, $prevtip) = &find_prev_interface_file($filenumber, $up);

    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, $up)
}

sub read_command_line()
{
    #print "book: ", $book_file_name , "\n";
    return if ($book_file_name ne ""); # called from ../build
    # Command line options
    &usage() if (defined($h));
    $special_headers = 1 if (defined($s));
    $verbose = 1 if (defined($v));
    $debug = 1 if (defined($d));
    $fullpath = 1 if (defined($f));
    $skippdf = 1 if (defined($p));
    if ($#ARGV == 0){ 
	local ($file) = $ARGV[0];
	if ($file =~ m/\.book$/){
	    $book_file_name = $file;
	}
    } else {
	&usage();
    };
}


sub read_book_file
{
    if (! -f "$book_file_name"){
	die "Book file \"$book_file_name\" does not exist!\n";
    }
    open SEQUENCE, "$book_file_name" || die "Cannot open \"$book_file_name\" file: !$\n";
    while (<SEQUENCE>){
	chomp;
	# remove comments
	s/\#.*$//;
	# remove initial whitespace
	s/^\s*//;
	# remove trailing whitespace
	s/\s*$//;
	# skip blank lines
	next if (m/^$/);
	if (-f "${src}$_"){
	    push @srcfiles, $src . $_;
	    push @dstfiles, $dst . &strip_path($_);
	} elsif (m/^date:\s*(.*)$/){ 
	    $date = $1;
	} elsif (m/^inx:\s*(.*)$/){ 
	    $indexfile = $1;
	} elsif (m/^toc:\s*(.*)$/){ 
	    $tocfile = $1;
	} elsif (m/^pdf:\s*(.*)$/){
	    $pdf= $1;
	} elsif (m/^src:\s*(.*)$/){ 
	    $src = &trim_path(&expand($1)) . "/";
	} elsif (m/^dst:\s*(.*)$/){ 
	    $dst = &trim_path(&expand($1)) . "/";
	    &SmartMkdir($dst);
	} elsif (m/^intsrc:\s*(.*)$/){ 
	    $intsrc = &trim_path(&expand($1)) . "/";
	} elsif (m/^intdst:\s*(.*)$/){ 
	    $intdst = &trim_path(&expand($1)) . "/";
	    if (($intdst =~ m%^\.\./%) || ($intdst =~ m%^/%)){
		print STDERR "Illegal intdst: $intdst.\n";
		print STDERR "intdst: must be a local directory\n";
		exit 1;
	    }
	    &SmartMkdir($intdst);
	    push @intsrcfiles, "";
	    push @intdstfiles, $intdst;
	} elsif (m/^mia:\s*(.*)$/){ 
	    $mia = $1;
	} elsif (m/^title:\s*(.*)$/){ 
	    $title = $1;
	} elsif (m/^copyright:\s*(.*)$/){ 
	    $copyrightyears = $1; 
	} elsif (m/^list:\s*(.*)$/){ 
	    local $lists= $1;
	    if ($lists =~ m/\bprograms?\b/i){
		$do_program_list = 1;
		}
	    if ($lists =~ m/\bfig\b|\bfigures?\b/i){
		$do_figure_list = 1;
	    }
	} elsif (m/^int:\s*(.*)$/){ 
	    push @intsrcfiles, &expand($intsrc . "$1");
	    push @intdstfiles, $intdst . &strip_extension(&strip_path(&expand("$1"))) . ".html";
	} elsif (m/^gram:\s*(.*)$/){
	    push @gramfiles, &expand($1);
	} else {
	    print STDERR "$book_file_name: Unrecognized line: \n$_\n\t- ignored.\n";
	}
    }

    if (($#intsrcfiles>-1) && ($intdst eq "")){
	# intdst was not specified - use default "interfaces"
	$intdst = "interfaces";
	# Prepend "interfaces/" to all intdstfiles
	for ($filenumber=0; $filenumber<=$#intdstfiles; $filenumber++){
	    $intdstfiles[$filenumber] = "interfaces/$intdstfiles[$filenumber]";
	}
	&SmartMkdir($intdst); 
	unshift @intsrcfiles, "";
	unshift @intdstfiles, $intdst;
    }

    if ($debug){
	print STDERR "read book file $book_file_name.\n";
	print STDERR "  date:      $date\n";
	print STDERR "  mia:       $mia\n";
	print STDERR "  title:     $title\n";
	print STDERR "  copyright: $copyrightyears\n";
	print STDERR "  pdf:       $pdf\n";
	print STDERR "  lists:     \n";
        print STDERR "    programs\n" if $do_program_list;
        print STDERR "    figures\n"  if $do_figure_list;
	print STDERR "  sequence:\n    ";
	print STDERR join("\n    ",@srcfiles);
	print STDERR "\n  intsrcfiles:\n    ";
	print STDERR join("\n    ",@intsrcfiles);
	print STDERR "\n";
    }
}

sub error
{
    local ($char_pos, $msg) = @_;
    print STDERR "$srcfiles[$filenumber]:char $char_pos: ***$msg\n";
}

sub parse_special_tags
{
    local ($done, $before, $match, $remaining, $number, $i);
    local ($htmlfile) = $dstfiles[$filenumber];
    local ($full_length) = length($srcline);

    $_=$srcline;
    $done = $before = $match = $remaining = "";

    while(m%\<H[1-6]|\</H[1-6]\>|\<BETA|\</BETA\>|\<FIG|\</FIG\>|\<GIF|\</GIF\>|\<INX|\</INX\>|\s*\<FOOTNOTE>|\</FOOTNOTE\>%i ){
	$before = $`;
	$match  = $&; 
	$remaining  = $';

	$done .= $before;
	# perform stuff on $match
	if  ($match =~ m%\<H([1-6])%i){
	    ################# Found heading start. #########################
	    $done .= $match;
	    local ($h, $heading, $anchor, $headanchors, $headinx, $attributes);
	    $h = $1;
	    if ($remaining =~ m%^[^>]*\>%si){
		# Matched <Hn xxx>
		$attributes = $1; # xxx - currently not used for anything
		$done .= $&;
		$remaining = $';
	    }
	    if ($h<$headinglevel){
		# Going from sub section to section/chapter
		for (; $headinglevel>$h; $headinglevel--){
		    $num_h[$headinglevel]=0;
		}
	    }
	    if ($h>$headinglevel){
		# Going from section/chapter to (sub)section
		$headinglevel++;
		for (; $headinglevel<$h; $headinglevel++){
		    $num_h[$headinglevel]++;
		}
	    }
	    $num_h[$h]++;
	    # Generate number for heading
	    $number = "";
	    for ($i=1; $i<=$h; $i++){
		$number .= "$num_h[$i].";
	    }
	    chop $number; # remove trailing dot
	    # Start anchor to refer from TOC
	    $anchor = "H${h}_$num_h[$h]";
	    $done .= "<A NAME=\"$anchor\">";
	    if ($remaining =~ m%\</H$h\>%si){
		$heading = $`;
		$remaining = $';
		$heading =~ s/^\s*//; # remove leading whitespace
		# Check for index entries in heading. Move them outside
		while ($heading =~ m%<INX>([^<]*)</INX>%si){
		    $remaining = "<INX HIDDEN>$1</INX>" . $remaining;
		    $heading = $` . $1 . $';
		}
		# Check for anchors in heading. Move them outside
		$headanchors = "";
		while ($heading =~ m%(<A NAME=[^>]+>)([^<]*)(</A>)%si){
		    $headanchors .= $1 . $3;
		    $heading = $` . $2 . $';
		}
		$heading = "$number $heading";
		$done .= $heading . "</A>$headanchors</H$h>";
	    } else {
		&error($full_length-length($remaining), "Unterminated heading? (<H$h>)");
	    }
	    push (@headings, "$heading\@$htmlfile\#$anchor");
	} elsif ($match =~ m%\</H[1-6]\>%i){
	    # Found heading end
	    &error($full_length-length($remaining), "Unmatched end-of-heading? ($&)");
	    $done .= $match;
	} elsif ($match =~ m%\<BETA%i){
	    ##################### Found BETA start ########################
	    local $beta = "";
	    local $caption = "";
	    local $list = 0;
	    local $listcap = "";
	    local $attributes = "";
	    local $id = "";
	    local $anchor = "";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <BETA xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <BETA> attributes:'$attributes'\n" if ($debug);
		$remaining = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    }
	    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
		$beta=&read_file(&expand($1));
	    } elsif ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
		$beta=&read_file(&expand($1));
	    }
	    if ($beta ne ""){
		# Found SRC
		# eat closing tag, if present
		if ($remaining =~ m%^\s*\<\/BETA\>%si){
		    $remaining = $';
		}
	    } else {
		# No SRC. Handle stuff until (and including) end-tag
		#print STDERR "No SRC. Handle stuff until (and including) end-tag\n" if ($debug);
		if ($remaining =~ m%\<\/BETA\>%si){
		    $beta = &untabify($`); # ...
		    #print STDERR "beta='$beta'\n" if ($debug);
		    $remaining = $';
		} else {
		    &error($full_length-length($remaining), "<BETA> with no SRC and no end-tag met.");
		}
	    }
	    # Generate output into $done variable
	    if ($list){
		$num_beta++;
		if ($listcap eq ""){
		    if ($caption eq ""){
			&error($full_length-length($remaining), 
			       "<BETA> tag with LIST attribute and no caption found.Using \"Program " . $num_beta . "\" for caption.");
			$listcap = $caption = "Program " . $num_beta;
		    } else {
			$listcap = $caption;
		    }
		}
		if ($caption eq ""){
		    $caption = $listcap;
		}
		$listcap = "" . $num_beta . " " . $listcap;
		$caption = "Program " . $num_beta . ": " . $caption;
		if ($id ne ""){
		    $anchor = "BETA_$id";
		} else {
		    $anchor = "BETA_$num_beta";
		} 
		push (@programs, "$listcap\@$htmlfile\#$anchor");
		$done .= "<A NAME=\"$anchor\">";
	    }
	    if ($caption ne ""){
		$done .= "<H4 CLASS=betacaption>$caption</H4>";
	    }
	    if ($list){
		$done .= "</A>";
	    } 
	    $done .= "\n";
	    $done .= "<PRE CLASS=BETA>\n";
	    # Trim $beta for whitespace
	    $beta =~ s/^\s*//;
	    $beta =~ s/\s*$//;
	    $done .= &quote_html($beta); 
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\</BETA\>%i){
	    # Found BETA end
	    &error($full_length-length($remaining), "Unmatched end-of-beta? (</BETA>)");
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\<INX%i){
	    ################# Found INX start #########################
	    local ($entry, $anchor) = ("", "");
	    local $attributes = "";
	    local $anchor = "";
	    local $hidden = 0;
	    #print STDERR "$htmlfile: INX start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <INX xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <INX> attributes:'$attributes'\n";
		$remaining = $';
	    }	    
	    $num_inx++;
	    if ($attributes =~ m%HIDDEN%i){
		$hidden = 1;
	    }
	    # Start anchor to refer from index
	    $anchor = "INX_$num_inx";
	    $done .= "<A NAME=\"$anchor\"><SPAN CLASS=INDEXED TITLE=Indexed>";
	    if ($remaining =~ m%\</INX\>%i){
		$entry = $`;
		$remaining = $';
		# delete initial whitespace
		$entry =~ s%^\s+%%;
		# delete trailing whitespace
		$entry =~ s%\s+$%%;
		#print STDERR "$htmlfile: INX entry: $entry\n";
		if ($entry eq ""){
		    &error($full_length-length($remaining), "Empty index entry? <<INX></INX>)");
		}
		$done .= $entry unless $hidden;
		$done .= "</SPAN></A>";
	    } else {
		&error($full_length-length($remaining), "Unterminated index entry? (<INX>)");
	    }
	    # We unquote HTML when pushing to index to get alphabetic
	    # sorting of index right. However, colons must be encoded
	    # in order not to disturb index calculation
	    push (@index, &quote_special(&unquote_html(&untag($entry))) . ".0\@$htmlfile\#$anchor");
	} elsif ($match =~ m%\</INX\>%i){
	    # Found INX end
	    &error($full_length-length($remaining), "Unmatched end-of-index-entry? (</INX>)");
	    $done .= $match;
	} elsif ($match =~ m%\<FOOTNOTE>%si){
	    ################# Found FOOTNOTE start #########################
	    local ($footnote, $anchor) = ("", "");
	    local $attributes = "";
	    local $anchor = "";
	    #print STDERR "$htmlfile: FOOTNOTE start\n";
	    $num_foot++;
	    $anchor = "FN_$num_foot";
	    $done .= "<A REL=FOOTNOTE HREF=\"#$anchor\"><EM><SUP>[$num_foot]</SUP></EM></A>";
	    if ($remaining =~ m%\</FOOTNOTE\>%si){
		$footnote = $`;
		$remaining = $';
		#print STDERR "$htmlfile: FOOTNOTE: $footnote\n";
		# delete initial whitespace
		$footnote =~ s%^\s+%%;
		# delete trailing whitespace
		$footnote =~ s%\s+$%%;
		if ($footnote eq ""){
		    &error($full_length-length($remaining), "Empty footnote? <<FOOTNOTE></FOOTNOTE>)");
		}
		# Put foot note at end of $remaining: This will ensure
		# handling of e.g. INX in the foot note.
		if ($foot_ruler_done){
		    $remaining .= "\n<BR>\n";
		} else {
		    $remaining .= "\n<P></P>\n<HR ALIGN=LEFT WIDTH=\"30%\">\n";
		    $foot_ruler_done = 1;
		}
		$remaining .= "<A NAME=\"$anchor\">[$num_foot] $footnote</A>\n";
	    } else {
		&error($full_length-length($remaining), "Unterminated fotnote? (<FOOTNOTE>)");
	    }
	} elsif ($match =~ m%\</FOOTNOTE\>%i){
	    # Found FOOTNOTE end
	    &error($full_length-length($remaining), "Unmatched end-of-footnote? (</FOOTNOTE>)");
	    $done .= $match;
	} elsif ($match =~ m%\<FIG%i){
	    ######################## Found FIG start ####################
	    local $list = 0;
	    local $figure = "";
	    local $caption = "";
	    local $listcap = "";
	    local $id = "";
	    local $attributes = "";
	    local $anchor = "";
	    #print STDERR "$htmlfile: FIG start\n";
	    $num_fig++;
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <FIG xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <FIG> attributes:'$attributes'\n";
		$remaining = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    }
	    # Handle rest until (and including) end tag
	    if ($remaining =~ m%\</FIG\>%si){
		$figure = $`;
		$remaining = $';
		#print STDERR "$htmlfile: figure: $figure\n";
		if ($figure =~ m%^\s*$%s){
		    &error($full_length-length($remaining), "Empty figure? (<FIG></FIG>)");
		}
	    } else {
		&error($full_length-length($remaining), "Unterminated figure tag? (<FIG>)");
	    }
	    $listcap =~ s%^\s+%%s;
	    $listcap =~ s%\s+$%%s;
	    $caption =~ s%^\s+%%s;
	    $caption =~ s%\s+$%%s;
	    if ($listcap eq ""){
		if ($caption eq ""){
		    if ($list){
			&error($full_length-length($remaining), "<FIG> tag with LIST attribute and no caption found.\nUsing \"Figure " . $num_fig . "\" for caption.");
			#$caption = "Figure $num_fig";
		    }
		} else {
		    $listcap = $caption;
		}
	    }
	    if ($caption eq ""){
		$caption = $listcap;
	    }
	    if ($listcap eq ""){
		$listcap = "" . $num_fig . " " . "Figure $num_fig";
	    } else {
		$listcap = "" . $num_fig . " " . $listcap;
	    }
	    if ($caption eq ""){
		$caption = "Figure " . $num_fig;
	    } else {
		$caption = "Figure " . $num_fig . ": " . $caption;
	    }
	    if ($id ne ""){
		$anchor = "FIG_$id";
	    } else {
		$anchor = "FIG_$num_fig";
	    } 
	    #printf STDERR "listcap: '$listcap'\n";
	    #printf STDERR "caption: '$caption'\n";

	    $done .= "\n<P></P>\n<A NAME=\"$anchor\">";
	    $done .= "<STRONG CLASS=figure>$caption</STRONG>\n</A>\n";
	    $done .= "<P></P>\n";
	    # Must put $figure into $remaining to get processing of e.g.
	    # <INX>, <BETA> in the figure.
	    $remaining = $figure . $remaining;
	    if ($list){
		push (@figures, "$listcap\@$htmlfile\#$anchor");
	    }
	} elsif ($match =~ m%\</FIG\>%i){
	    # Found FIG end
	    &error($full_length-length($remaining), "Unmatched end-of-figure? (</FIG>)");
	    $done .= $match;
	} elsif ($match =~ m%\<GIF%i){
	    ######################## Found GIF start ####################
	    local ($attributes, $alt, $source, $tit, $height, $width, $align, $map,, $border, $info);
	    local ($iw,$ih);
	    $attributes = $alt = $source = $tit = $height = $width = $align = $map = $border = "";
	    #print STDERR "$htmlfile: GIF start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <GIF xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <GIF> attributes:'$attributes'\n";
		$remaining = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
		$source = $1;
	    } elsif ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
		$source = $1;
	    }
	    if ($attributes =~ m%ALT\s*=\s*\"([^\"]+)\"%i){
		$alt = $1;
	    } elsif ($attributes =~ m%ALT\s*=\s*([^\s]+)%i){
		$alt = $1;
	    }
	    if ($attributes =~ m%TITLE\s*=\s*\"([^\"]+)\"%i){
		$tit = $1;
	    } elsif ($attributes =~ m%TITLE\s*=\s*([^\s]+)%i){
		$tit = $1;
	    }
	    if ($attributes =~ m%WIDTH\s*=\s*\"([^\"]+)\"%i){
		$width = $1;
	    } elsif ($attributes =~ m%WIDTH\s*=\s*([^\s]+)%i){
		$width = $1;
	    }
	    if ($attributes =~ m%HEIGHT\s*=\s*\"([^\"]+)\"%i){
		$height = $1;
	    } elsif ($attributes =~ m%HEIGHT\s*=\s*([^\s]+)%i){
		$height = $1;
	    }
	    if ($attributes =~ m%ALIGN\s*=\s*\"([^\"]+)\"%i){
		$align = $1;
	    } elsif ($attributes =~ m%ALIGN\s*=\s*([^\s]+)%i){
		$align = $1;
	    }
	    if ($attributes =~ m%USEMAP\s*=\s*\"([^\"]+)\"%i){
		$map = $1;
	    } elsif ($attributes =~ m%USEMAP\s*=\s*([^\s]+)%i){
		$map = $1;
	    }
	    if ($attributes =~ m%BORDER\s*=\s*\"([^\"]+)\"%i){
		$border = $1;
	    } elsif ($attributes =~ m%BORDER\s*=\s*([^\s]+)%i){
		$border = $1;
	    }

	    if ($source eq ""){
		&error($full_length-length($remaining), "GIF tag with no SRC");
	    }
	    ($iw, $ih) = &read_gif_dim($source);
	    if ($width eq "" || $height eq ""){
		$width = $iw if ($width eq "");
		$height = $ih if ($height eq "");
	    }
	    $tit = $alt if ($alt ne "" && $tit eq "");
	    $alt .= " " if ($alt ne "");
	    $tit .= " " if ($tit ne "");
	    $info  = "[" . &get_file_size($source) . " ${width}x$height GIF]";
	    $alt .= $info;
	    $tit .= $info;
	    $border = "0" if ($border eq "");
	    #$tit = $alt = "" if ($map ne "");
	    
	    $done .= "<IMG SRC=\"$source\"";
	    $done .= " WIDTH=\"$width\" HEIGHT=\"$height\"";
	    $done .= " ALIGN=\"$align\"" if ($align ne "");
	    $done .= " USEMAP=\"$map\"" if ($map ne "");
	    $done .= " BORDER=\"$border\"";
	    $done .= " ALT=\"$alt\"";
	    $done .= " TITLE=\"$tit\"" if ($tit ne "");
	    $done .= ">";
	} elsif ($match =~ m%\</GIF\>%i){
	    # Found GIF end
	    &error($full_length-length($remaining), "GIF tags have no end-tag (</GIF>)");
	    
	} else {
	    # Hmmm, error? Should not happen.
	    $done .= $match;
	}
	
	# handle rest of input in next iteration
	$_ = $remaining;
    }

    $srcline=$done . $_;
}

sub make_special_header
{
    local ($title, $htmlfile) = @_;
    local ($intnum) = "" . $num_h[1] . "." . ++$num_h[2];
    local ($anchor) = "H$num_h[1]_$num_h[2]";

    push (@intheadings, "$intnum $title\@$htmlfile#$anchor");

    $title = "\005\/PRE\006\005H2\006\005A name=\"$anchor\"\006$intnum\007nbsp;$title\005\/A\006\005\/H2\006\005PRE CLASS=interface\006\n";

    return $title;
}

sub parse_special_header
{
    local ($contents, $htmlfile) = @_;

    $contents =~ s/\(\*\*+\*\)\s+\(\*+\s+([^\*]+)\s+\*+\)\s+\(\*\*+\*\)\s+/make_special_header($1, $htmlfile)/seg;


    # Delete copyrigth comments of the form
    # (*
    #  * COPYRIGHT
    #  *       Copyright Mjolner Informatics, 199x-9x
    #  *       All rights reserved.
    #  *)
    #$contents =~ s/\(\*\s+\*\s+COPYRIGHT[\s\w\*\,\-\.]+\*\)\s*//sg;
    
    return $contents;
}

sub generate
{
    local ($file, $title) = @_;
    printf STDERR "Reading $file ...\n" if $debug;
    $srcline = &read_file("$file");
    printf STDERR "Writing HTML ...\n" if $debug;
    &parse_special_tags();
    &print_src_header($title);
    print $srcline;
    &print_trailer($title, 0, $file);
}

sub process_file
{
    local ($srcfile, $dstfile) = @_;
    $foot_ruler_done = 0;
    print STDERR "Generating $dstfile\nfrom       $srcfile\n" if $verbose;

    printf STDERR "Opening $dstfile for writing ... " if $debug;
    if (!open (STDOUT, ">$dstfile")){
	die "\nCannot open $dstfile for writing: $!\n";
    }
    &generate("$srcfile", $title);
    close (STDOUT);

    printf STDERR "done\n\n" if $verbose==1;


}

sub process_src_files
{
    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	&process_file($srcfiles[$filenumber], $dstfiles[$filenumber]);
    }
}

sub open_headings_to_level
{
    local ($hlevel) = @_;
    for (; $headinglevel<$hlevel; $headinglevel++){
	print "  " x ($headinglevel+1), "<DL>\n";
    }
}

sub close_headings_to_level
{
    local ($hlevel) = @_;
    #print STDERR "close_headings_to_level($hlevel): headinglevel=$headinglevel\n";
    for (; $headinglevel>$hlevel; $headinglevel--){
	print "  " x ($headinglevel), "</DL>\n";
    }
}

sub print_toc
{

    local ($headinfo, $link, $heading, $headnum, $hlevel);

    #print STDERR "\nheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @headings);
    #print STDERR "\n++++++++++++++++++++\n";


    print<<EOT;
<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
<DT><A HREF="$tocfile#_toc"><B>Contents</B></A><DD>
  <DL>
EOT
    
    if ($do_program_list){
	print "    <DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
    }
    if ($do_figure_list){
	print "    <DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
    }
    $headinglevel = 1;
    for ($headnum=0; $headnum<=$#headings; $headnum++){
	local ($b1, $b2) = ("", "");
	$headinfo = $headings[$headnum];
	($heading, $link) = split("\@", $headinfo);
	# Find heading level for link 
	$link =~ m/\#H([1-6])/i;
	$hlevel = $1;
	if ($hlevel>$headinglevel){
	    &open_headings_to_level($hlevel);
	} elsif ($hlevel<$headinglevel){
	    &close_headings_to_level($hlevel);
	}
	if ($headinglevel==1){
	    $b1 = "<B>";
	    $b2 = "</B>";
	}
	print "  " x ($headinglevel), "<DT><A HREF=\"$link\">$b1$heading$b2</A><DD>\n";
    }
    &close_headings_to_level(1);

    print_interface_toc("");

    if (-f $indexfile){
	local ($i, $ch);
	print "  <DT><A HREF=\"$indexfile\"><B>Index</B></A><DD>\n";
	&open_headings_to_level(2);
	for ($i=65; $i<=90; $i++){
	    $ch = sprintf ("%c", $i);
	    if ($caps{$ch}){
		print "    <A HREF=\"$indexfile\#_$ch\">$ch</A> &nbsp; \n";
	    } else {
		# no indices starting with $ch
		print "    <SPAN CLASS=disabled>$ch</SPAN> &nbsp; \n";
	    }
	}
    }
    &close_headings_to_level(1);

    if ($skippdf){
	print "  <DT><SPAN CLASS=disabled><B>PDF</B></SPAN>\n";
    } else {
	print "  <DT><A HREF=\"$pdf\"><B>PDF</B></A> (";
	print &get_file_size($pdf);
	print ")\n";
    }
    print<<EOT;
  <DD>
  </DL>
</DL>
</DIV>
EOT

}

sub generate_toc_page
{
    printf STDERR "\nWriting title page $tocfile ... " if $verbose==1;
    open (STDOUT, ">$tocfile") || die "\nCannot open $tocfile for writing: $!\n";
    &print_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<P>
<CENTER>
<B>
Mj&oslash;lner Informatics Report<BR>
$mia<BR>
$date</B>
<P>
</CENTER>
EOT

    &print_toc;

    print<<"EOT";
<TABLE align=center border=1 cellpadding=3>
<TR><TD align=center>
<DIV style="font-size: smaller">
<A HREF="../copyright.html">Copyright &#169;</A> $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mj&oslash;lner Informatics
</DIV>
</TD></TR>
</TABLE>
<P></P>
EOT
    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n\n" if $verbose==1;
}

sub read_and_abstract_beta
{
    local ($betafile, $htmlfile) = @_;
    local ($was_blank);

    $betaline = &read_file("$betafile");

    # single-line editing.
    $betaline =~ s/<<.*\bOBJECTDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDOPART\b.*>>/.../gi;    
    
    # Uppercase inner
    $betaline =~ s/\bINNER\b/INNER/gi;
    # Remove trailing blanks
    $betaline =~ s/^(.*)\s*$/$1\n/;
    
    # Squeze multiple blank lines down into one
    # next if /\S/ ? ($was_blank=0) : $was_blank++;
    

    # Now perform multiline editing
    if ($special_headers){
	$betaline = &parse_special_header($betaline, $htmlfile);
    }

    # delete RCS/CVS stuff
    $betaline =~ s/\$\Revision:[^\$]*\$//s;
    $betaline =~ s/\$\RCSfile:[^\$]*\$//s; 
    $betaline =~ s/\$\Date:[^\$]*\$//s;
    $betaline =~ s/\$\Author:[^\$]*\$//s;

    $betaline =~ s/\bdo\s*\.\.\./do .../gis;
    $betaline =~ s/\bINNER(;?)\s*\.\.\./INNER$1 .../gs;
    #$betaline =~ s/do\b\s*/do /gis; # No contracts do' ' in comments too
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s*\#\)/\(\# do INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do INNER$1 ... \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s*\#\)/\(\# do ... INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do ... INNER$1 ... \#\)/gs;
    $betaline =~ s/(:< *)\s*\(\#(.*)\#\);?/$1(\#$2\#);/gs;
    $betaline =~ s/\.\.\.  /... /gs;

    # Delete other lines containing the word "private" or the word "implpart"
    #$betaline =~ s/.*private.*\n+//gi;
    $betaline =~ s/.*implpart.*\n+//gi;

}

sub generate_int_title
{
    local ($betafile) = @_;
    local ($inttitle) = ucfirst(&strip_extension(&strip_path("$betafile"))) . " Interface";

    # Add number for title
    $inttitle = "" . $num_h[1] . "." . ++$num_h[2] . " " . $inttitle;
    return $inttitle;
}

sub generate_interface_file
{
    local ($betafile, $htmlfile) = @_;
    local ($inttitle) = &generate_int_title($betafile);

    printf STDERR "\nMaking $htmlfile\n  from $betafile ... \n" if $verbose==1;
    &read_and_abstract_beta($betafile, $htmlfile);

    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";

    local ($up) = &countdirs($htmlfile); # $htmlfile assumed being local path
    print_interface_header($inttitle, $up);
    print<<EOT;
<H1>$inttitle</H1>
<PRE CLASS=interface>
EOT

    $_ = $betaline;		

    # Mark '(#', '#)' and ':' in comments to avoid interference with
    # subsequent matchings.

    $remaining = $_;			# in case of no comments at all
    $betaline = "";

    printf STDERR "Substituting special symbols...\n" if $debug;
    
    while ( /\(\*|\*\)/ ) {
	$before = $`;
	$match  = $&;
	$remaining  = $';
	if ( $match eq '*)' ) {
	    $before =~ s/:/\001/g;
	    $before =~ s/\(\#/\002/g;
	    $before =~ s/\#\)/\003/g;
	}
	$betaline .= $before.$match;
	$_ = $remaining;
    }
    $_ = $betaline.$remaining;
    
    # Substitute ':' in slots with \004
    s/(\<\<\s*SLOT\s*\w+\s*):(\s*\w+\s*\>\>)/$1\004$2/gi;
    
    # Substitute ':' in fragmentIds with \004
    #   (assumes entire fragment syntax on one line - I think)
    s/(\-\-+\s*\w+\s*):(\s*\w+\s*\-\-+)/$1\004$2/g;
    
    # quote HTML
    s/&/\008/g;
    s/</\021/g;
    s/>/\022/g;
    
    # Run through $_, matching for pattern-begin and pattern-end, while
    # keeping track of scope level.
    # Insert nested index-information for declarations at the outermost
    # $scope levels.
    $scope  = 2;

    $patterns = "";
    $revpatterns = "";
    $level  = 1;
    $betaline = "";
    $prefix = "";

    printf STDERR "Searching for idx-comments/patterns/colons .....\n" if $debug;
    if   (! m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	printf STDERR "  None found - emitting without markup\n" if $debug;
	$betaline = $_;
    }
    while(m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	$before = $`;
	$match  = $&; 
	$idxop  = $1; $idxlev = $2; # if index information present
	$remaining  = $';
	if ( "$idxop" ne "" ) {
	    # index pseudo comment found
	    if ( "$idxop" eq "+" ) { $scope++; }
	    elsif ( "$idxop" eq "-" ) { $scope--; }
	    if ( "$idxop" eq "=" || "$idxop" eq "\001" ) {
		if ( "$idxlev" eq "" ) {
		    print "No level specified in idx= command";
		    return;
		}
		$scope = $idxlev;
	    }
	    $match = ""; # delete comment
	    $remaining = "\n".$remaining;
	    # $match = "\nINDEXLEVEL: $scope\n";
	}
	elsif ( "$match" eq "(#" ) {
	    # add previously found identifier in scope description
	    if ( "$patternid" ne "" ) {
		$patterns .= "$patternid.$level:";
		printf STDERR "***  %s\n", $patternid if $trace==1;
	    } else {	
		if (($htmlfile eq "betaenv.html") && ($level == 1)){
		    $patterns .= "betaenv.1:";
		    printf STDERR "  BETAENV\n" if $trace==1;
		} else {
		    $patterns .= "ANONYMOUS.$level:";
		    printf STDERR "  ANONYMOUS\n" if $trace==1;
		}
	    }
	    $level += 1;
	    $patternid = "";
	    # $match = "BEGIN";
	    # $match = "\n[PATTERNS: $patterns]\n";
	}
	elsif ( "$match" eq "#)" ){	
	    # check if $before ends with "#".
	    if ( ($before =~ /\#$/ ) && ( ! ( $before =~ /\#\#$/ ) ) ) {
		# found something like 
		#   "... ->F##)
		# i.e. a pattern variable at end of a parenthesed
		# evaluation.
		# This is NOT a pattern end!
		printf STDERR "\n******* NOTICE: In the text ending like this:\n";
		printf STDERR substr($betaline.$before.$match, -100, 100);
		printf STDERR "\n******* the '##)' is not considered a pattern end.";
		printf STDERR "\n******* Please check if this is correct.\n\n";	
		# Just precede.
	    } else {
		# This is really a pattern end
		$level -= 1;
		if ( $patterns =~ m/:\w+.\w+:$/ ) {
		    $patterns = $`.":";
		}
		elsif ( $patterns =~ m/^\w+.\w+:$/ ) {
		    $patterns = "";
		} else {
		    $betaline .= $before.$match;
		    print "*** PATTERNS is wrong: $patterns";
		    print "*** context:";
		    print "\n------------\n";
		    print substr($betaline, -100,100);
		    print "\n------------\n";
		}
		# $match .= "\n[PATTERNS: $patterns]\n";
	    }
	}
	elsif ( $match =~ m/:/ )  { # a colon was found
	    if ( $level <= $scope ){
		# Identifiers must start with alpha or _.
		# In betaenv, there is "exit T[1:lgth], which would
		# cause 1: to be identified as identifier.
		# However, if [a-zA-Z_] is used instead of \w,
		# the "[1:" does not get into the output (:-(
		if ( $before =~ m/(\w+[\w\s,]*)\s*$/ ) {
		    $head = $`;
		    @ids = split( ',' , $1); # list of identifiers, e.g.: x, y, z
		    $tail = "";
		    $prefix = "";
		    if ( $remaining =~ m/^\s*\(\*/ ) {
			# move comment after colon but before prefix from $remaining to $tail
			$tail = $&;            # the stuff matched by the regexp
			$remaining = $';           # the stuff after the match
			$remaining =~ m/\*\)\s*/;  # MUST succeed if comment matches
			$tail .= $`.$&;        # the stuff before the last match and the match itself
			$remaining = $';           # the stuff after the match
		    }
		    
		    if ( $remaining  =~ m/^\s*(\w+)\s*\(\#/ ) { 
			$prefix = $1;
		    } else {
			# the match for prefix failed.
			# look ahead and check if there was a comment after the prefix
			# and try the match again.
			# don't change $tail or $remaining (historical: superpattern index generation)
			if ( $remaining =~ m/^\s*(\w+)\s*\(\*/ ) {
			    # there was a comment after the word after the colon
			    $possibleprefix = $1;
			    # set $peekafter to the stuff after the match, i.e. start of comment text
			    $peekafter = $';
			    $peekafter =~ m/\*\)\s*/;  # MUST succeed if comment matches
			    # set $peektext to the stuff after the match, i.e. what's after the comment
			    $peekafter = $';           
			    if ( $peekafter  =~ m/^\s*\(\#/ ) {
				# there was a pattern-begin after the comment
				$prefix = $possibleprefix; 
			    }
			}
		    }
		}
		
		$marker = $match;
		$match = "";

		if ( @ids == 1 ) {
		    # keep identifier for next "(#" found
		    $patternid = $ids[0];
		    $patternid =~ s/\s//g;
		} else {
		    $patternid = "";
		}

		$before = $head;
		foreach $id ( @ids ) {
		    #print STDERR "IDS: @ids\n";
		    $id =~ m/(\w+)/; # MUST succeed
		    $anchor += 1;
		    $idxid = "$1.$level"; # $id without whitespace.
		    $idxid .= "($anchor)";
		    if (&legal_identifier($id)){
			$bid = "<SPAN CLASS=INDEXED TITLE=Indexed>$id</SPAN>";
		    } else {
			$bid = $id;
		    }
		    $idxid2 = $idxid;
		    #$idxid2 =~ s/\(\d+\)$//;
		    #$idxid2 =~ s/\./_/g;
		    $patterns2 = $patterns;
		    #$patterns2 =~ s/\./_/g;
		    if ( "$patterns2" eq "" ){
			$before .= "$bid<A name=\"$idxid2\"></A>";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "111. {$idxid2\@$htmlfile}\n";
		    } else { 
			# inner scope
			$before .= "$bid<A name=\"$patterns2$idxid2\"></A><A name=\"$idxid2\"></A>";
			#print STDERR "222. {$idxid2\@$htmlfile}\n";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "333. {$patterns2$idxid2\@$htmlfile}\n";
			push (@index, "$patterns2$idxid2\@$htmlfile");
		    } # inner scope
		    $before .= ",";
		} # foreach id
		$before =~ s/,$//;
		$before .= $marker.$tail;
	    } # $level <= $scope
	} # colon was found
	else {
	    print "Something is wrong in while loop !!!";
	    return;
	} # "switch" on $match finished
	
	$betaline .= $before.$match;
	$_ = $remaining;
    } # while

    $_ = $betaline."\n";

    printf STDERR "Cleaning up...\n" if $debug;

    # Clean up
    s/\001/:/g;
    s/\002/\(\#/g;
    s/\003/\#\)/g;
    s/\004/:/g;
    s/\005/</g;
    s/\006/>/g;
    s/\007/&/g;
    s/\008/&amp;/g;
    s/\021/&lt;/g;
    s/\022/&gt;/g;

    printf STDERR "Writing interface ... " if $debug;
    print;
    
    print<<EOT;
</PRE>
EOT
    print_trailer("$inttitle", $up, $betafile);

    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub parse_int_chap
{
    local ($heading) = @_;
    local ($headnum, $intpath);

    $heading =~ m%^(\d+) (.*)$%;
    $headnum = $1;
    $intpath = &trim_path($2);
    $heading = &strip_path($intpath);
    if ($heading eq "interfaces"){
	$heading = "Interface Descriptions";
    } else {
	$heading = ucfirst($heading) . " Interface";
    }
    $heading = "$headnum $heading";

    return ($heading, $intpath);
}

sub print_interface_toc
{

    local ($prefix) = @_;

    local ($headinfo, $link, $heading, $headnum, $intpath);
    local ($h);

    #print STDERR "\nintheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#intsrcfiles>1){
	foreach $headinfo (@intheadings){
	    ($heading, $link) = split("\@", $headinfo);
	    if ($link eq ""){
		# Found new interface chapter
		($heading, $intpath) = &parse_int_chap($heading);
		next if ($intpath !~ m%^$prefix%);
		# close previous chapter(s)
		&close_headings_to_level(1);
		$headinglevel = 1;
		#print STDERR "\nInterface chapter: $heading\n";
		$link = &strip_prefix("$intpath/index.html", $prefix);
		print "    ", "<DT><A HREF=\"$link\"><I><B>$heading</B></I></A><DD>\n";
		print "    <DL>\n";
	    } else {
		if ($prefix ne ""){
		    #print STDERR "link: $link, prefix: $prefix\n";
		    next if ($link !~ m%^$prefix%);
		    $link = &strip_prefix($link, $prefix);
		}
		$headinglevel = 2;
		print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	    }
	}
	# terminate last interface chapter(s)
	&close_headings_to_level(1);
	$headinglevel = 1;
    }

}

sub generate_interface_toc_page
{
    local ($intfilenumber, $inttocdir, $title) = @_;
    local ($inttocfile) = "$inttocdir/index.html";
    local ($up) = &countdirs($inttocfile);
    printf STDERR "\nWriting interface toc page $inttocfile ... " if $verbose==1;
    open (STDOUT, ">$inttocfile") || die "\nCannot open $inttocfile for writing: $!\n";
    &print_interface_toc_header($title, $up, $intfilenumber);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_interface_toc($inttocdir);

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, $up, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub build_intheadings
{
    local (@old_num_h) = @num_h;
    # Build @intheadings. Needed before generations because of Next-links
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # Special case used to force a new interface chapter
	    $num_h[1]++;
	    $num_h[2] = $num_h[3] = $num_h[4] = $num_h[5] = $num_h[6] = 0;
	    #print STDERR "\npush(\@intheadings, $num_h[1] $intdstfile\@)\n";
	    push (@intheadings, "$num_h[1] $intdstfile\@");
	} else {
	    local ($inttitle) = &generate_int_title($intsrcfile);
	    push (@intheadings, "$inttitle\@$intdstfile");
	}
    }
    @num_h = @old_num_h;
}

sub process_interface_files
{
    local ($intheading);

    return if ($#intsrcfiles<=0);

    printf STDERR "Generating %d interface descriptions...\n", $#intsrcfiles+1  if $verbose;

    &build_intheadings;

    #print STDERR "intheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";
    
    # Generate interface files
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # new interface chapter
	    $num_h[1]++;
	} else {
	    &generate_interface_file($intsrcfile, $intdstfile);
	}
    }
    
    # Generate interface toc pages
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($headinfo) = $intheadings[$filenumber];
	local ($heading, $link) = split ("\@", $headinfo);
	local ($intdstfile);
	if ($link eq ""){
	    # Found interface chapter heading
	    # print STDERR "Found interface chapter heading: \n\t$heading\n";
	    ($heading, $intdstfile) = &parse_int_chap($heading);
	    &generate_interface_toc_page($filenumber, $intdstfile, $heading);
	} 
    }
}


sub print_index_toc
{
    local ($i, $ch);
    print "<HR>\n<DIV style=\"text-align:center\">\n";
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	if ($caps{$ch}){
	    print "<STRONG><A HREF=\"#_$ch\">$ch</A></STRONG> &nbsp; \n";
	} else {
	    # no indices starting with $ch
	    print "<STRONG CLASS=disabled>$ch</STRONG> &nbsp; \n";
	}	    
    }
    print "<HR>\n</DIV>\n\n";
}

sub calculate_index()
{
    #print STDERR "\nindex: ", "+"x20, "\n", join ("\n", @index), "\n", "+"x20, "\n";

    # Sort index ignoring case
    @index = sort {lc($a) cmp lc($b)} @index;
    local ($prev_id, $prev_no, $initial_ch, $htmlfile, $i, %entries);

    local ($italic, $itaend) = ("", "");
    local (@index_lines) = ();

    #print STDERR "sorted index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "++++++++++++++++++++\n";

    $html_index = "";
    $prev_id = "";
    $prev_no = 1;

    local ($index_line) = "";

    for($i = 0; $i <= $#index; $i++) {

	# delete traling file name (after '@')
	$index[$i] =~ s/(.+)\@(.+)/$1/;
	# save target file name
	$htmlfile = $2;
	$_ = $index[$i];

	
	# In foo.1 delete .1
	s/\.(\d+)//g;
	if ($1 eq "0"){
	    # Last .N was a .0:
	    # Reference to src file (not interface file)
	    $is_src = 1;
	    #print STDERR "$_ is src\n";
	} else {
	    # Reference to interface file
	    $is_src = 0;
	    # In betaenv: exit T[1:lgth] is taken to be
	    # an identifer with name 1. Prevent this.
	    if (!&legal_identifier($_)){
		printf STDERR "skipped illegal identifier: $_\n" if $verbose;
		next;
	    }
	}
	# delete other numbers (?) 
	s/\(\d+\)//g;
	# walk through scopes
	while ( m/[ :](\w+)\.(\d+)[:\}]/ ) {
	    $id = $1; $level = $2;
	    $indents = $indent x ($level-1);
	    s/([ \:])$id\.$level([\:])/$1$indents$id$2/;
	}
	
	# Generate caps heading at first occurrence of a letter.
	$initial_ch = substr($index[$i], 0, 1);
	#print STDERR "initial_ch: '$initial_ch'\n";
	if ("$initial_ch" eq "\006"){
	    # Colon
	    $initial_ch = ":";
	} elsif ("$initial_ch" eq "\007"){
	    # Quoted special character like &szlig;
	    $index[$i] =~ m/^(\007[a-zA-Z]+;)/;
	    $initial_ch = $1;
	} else {
	    $initial_ch = ucfirst (substr($index[$i], 0, 1));
	}
	#print STDERR "initial_ch after: '$initial_ch'\n";
	if (! $caps{$initial_ch} ){
	    # Emit entries for previous letter
	    if ($index_line ne ""){
		push @index_lines, $index_line;
		$index_line = "";
	    }
	    $html_index .= &build_index_table(@index_lines);
	    @index_lines = ();
	    # Emit heading for initial_ch
	    $html_index .= "</DIV>\n";
	    $html_index .= "<H2><A name=\"_$initial_ch\">";
	    $html_index .= &quote_html(&unquote_special($initial_ch));
	    $html_index .= "<\/A><\/H2>\n";
	    $html_index .= "<DIV CLASS=index>\n";
	    $caps{$initial_ch} = 1;
	}

	# Block levels are present as such in the entries:
	#   foo:
	#     (# bar:
	#          (# kuk: 
	#               (# ... #)
	#          #)
	#     #);
	#
	# Index entries:
	#    foo
	#    foo:bar
	#    foo:bar:kuk
	#
	# Should print as this:
	#    foo
	#      bar
	#       kuk
	#
	
	# print STDERR "$index[$i]\n";

	# Handle ANONYMOUS especially
	if ($_ =~ m/^ANONYMOUS:/){
	    if (!$entries{"ANONYMOUS"}){
		print STDERR "Treating ANONYMOUS specially\n" if $verbose;
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "&nbsp;"x(4) . "<I>Anonymous pattern</I>";
		$entries{"ANONYMOUS"} = 1;
	    }
	}
	# Handle betaenv specially
	if ( ($index[$i] =~ m/^betaenv.1/) && ($htmlfile eq "betaenv.html")){
	    if (!$entries{"betaenv"}){
		print STDERR "Treating betaenv specially\n" if $verbose;
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "&nbsp;"x(4) . "<I><A HREF=\"betaenv.html\">betaenv</I></A>";
		$entries{"betaenv"} = 1;
	    }
	}
	if ($_ =~ m/(.*):([^:]+)/){
	    # Scopes present
	    $scopes = $1;
	    $id = $2;
	    # We are in a specific scope. There cannot be identical index entries
	    # here (BETA semantic error!). So no need to check for prev_id.
	    $prev_id="";
	    $prev_no=0;
	    if ($entries{$scopes}){
		# foo:bar already emitted
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		# indent with double-spaces
		push @index_lines, "&nbsp;"x(2*(2+&num_chars(':', $scopes))) . "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		$entries{$_} = 1;
	    } else {
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "Index Error: $_ ($scopes) ($id)";
	    }
	} else {
	    # No scopes present
	    if ($is_src){
		# Things like "<program>" may be indexed in src files
		$_ = &unquote_special(&quote_html("$_"));
	    }
	    $id = $_;
	    if ($prev_id eq $id){
		# Second or more occurrence of $id
		$prev_no++;
		if (($prev_no % 10) == 0){
		    # break line of references
		    if ($index_line ne ""){
			push @index_lines, $index_line; 
			$index_line = "&nbsp;"x(2);
		    }
		}
		# emit " [n]"
		if ($is_src){
		    $index_line .= "&nbsp;<A href=\"$htmlfile\"><B>[" . $prev_no . "]</B></A>";
		} else {
		    $index_line .= "&nbsp;<A href=\"$htmlfile\#" . $index[$i] . "\">${italic}[" . $prev_no . "]$itaend</A>";
		}
	    } else {
		# First occurrence of $id
		if ($index_line ne ""){
		    # Emit last line of entries
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		$prev_no=1;
		if ($is_src){
		    $index_line = "<A href=\"$htmlfile\"><B>" . $id . "</B></A>";
		} else {
		    $index_line = "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		}
		$prev_id = $id;
	    }
	    $entries{$_} = 1;
	}
    }
    if ($index_line ne ""){
	push @index_lines, $index_line; 
	$index_line = "";
    }
    # Emit entries for last letter
    $html_index .= &build_index_table(@index_lines);
    @index_lines = ();
}

sub generate_index_page
{
    return if ($#index<0);
    printf STDERR "\nMaking index page $indexfile ... " if $verbose==1;
    open (STDOUT, ">$indexfile") || die "\nCannot open $indexfile for writing: $!\n";
    &calculate_index();
    print_index_header("$title: Index");
    print<<EOT;
<H1>Index</H1>
The entries in the alphabetic index consists of selected words from the
body files of this manual - these are in <B>bold</B> font - as well as the
identifiers defined in the public interfaces of the libraries 
- set in regular font.
<BR>
In the manual, the identifiers, which can be found in the index
are <SPAN CLASS=INDEXED>typeset like this</SPAN>. This can help localizing the
identifier, when the link from the index if followed - especially in the case
where the browser does not scroll the line to the top, e.g. because there
is less than a page of text left. 
<BR>
The small table of letters below links directly to the section of identifiers
starting with the corresponding letters. 
EOT
    #print "The table is also present in the navigation bar to the left.\n";
    print "<P>\n";
    &print_index_toc;
    print "<DIV CLASS=index>\n";
    print $html_index;
    print "</DIV>\n";
    print_trailer("$title: Index", 0, "");
    close(STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub print_program_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nprograms:++++++++++++++++++++\n";
    #print STDERR join ("\n", @programs);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#programs>=0){
	print "    ", "<DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#programs; $headnum++){
	    $headinfo = $programs[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_program_list_page
{
    local ($title) = "List of Programs";
    local ($next, $nexttip);
    if (!$do_program_list){ 
	return;
    }
    printf STDERR "\nWriting list of programs to $programsfile ... " if $verbose==1;
    open (STDOUT, ">$programsfile") || die "\nCannot open $programsfile for writing: $!\n";
    if ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, $tocfile, "Table of Contents", $next, $indexfile, $nexttip, 0);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_program_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub print_figure_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nfigures:++++++++++++++++++++\n";
    #print STDERR join ("\n", @figures);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#figures>=0){
	print "    ", "<DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#figures; $headnum++){
	    $headinfo = $figures[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_figure_list_page
{
    local ($title) = "List of Figures";
    local ($prev, $prevtip, $next, $nexttip);

    if (!$do_figure_list){ 
	return;
    }
    printf STDERR "\nWriting list of figures to $figuresfile ... " if $verbose==1;
    open (STDOUT, ">$figuresfile") || die "\nCannot open $figuresfile for writing: $!\n";
    
    if ($do_program_list){
	$prev = $programsfile;
	$prevtip = "List of Programs";
    } else {
	$prev = $tocfile;
	$prevtip = "Table of Contents";
    }
    $next = $dstfiles[0];
    $nexttip = $next;
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_figure_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub filter_for_pdf
{
    local ($file, $distfile) = @_;
    local ($contents);
    local ($done, $before, $match, $remaining, $number, $i);

    #print STDERR "filter_for_pdf($file, $distfile)\n";

    #print STDERR "rename_file($file, $distfile)\n";
    &rename_file($file, $distfile);
    #print STDERR "read_file($distfile)\n";
    $contents = &read_file($distfile);

    ### This eats too much because it matches from start of first
    ### script to end of last.
    # $contents =~ s%\<SCRIPT.+\<\/SCRIPT\>%%gsi;
    #
    # However it suffices to filter out <LAYER> ... </LAYER>
    # And there is only one on each page.
    # NOTE: Could probably skip this too, when SCRIPT contents is properly
    # SGML commented out. However, we don't need it in the PDF anyway...
    $contents =~ s%\<LAYER.+\<\/LAYER\>%%gsi;

    # We might as well filter out <LINK REL=...> too
    # Hmm, no - removes style sheet too.
    # $contents =~ s%\<LINK REL=[^>]+>%%gi;

    # And htmldoc has problems with &COPY; / &#169;
    # No - not htmldoc 1.8.8
    #$contents =~ s%\&COPY;%(C)%gi;
    #$contents =~ s%\&\#169;%(C)%gi;
    # However, the copyright file is not present as part of pdf
    # Remove link:
    $contents =~ s%<A HREF="[./]*copyright.html">&#169;</A>%&#169;%gi;

    # Remove definitions of javascript variables used
    # for navigation
    # Not needed when <SCRIPT> content properly SGML commented out
    #$contents =~ s/var next     = '[^']+';//;
    #$contents =~ s/var prev     = '[^']+';//;
    #$contents =~ s/var content  = '[^']+';//;
    #$contents =~ s/var inx      = '[^']+';//;
    #$contents =~ s/var help     = '[^']+';//;
    #$contents =~ s/var manuals  = '[^']+';//;

    # Remove modification notices
    $contents =~ s&\<TD width\=\"40\%\" align\=\"right\">\s*\<DIV STYLE=\".+\"\>\[Modified:[^\]]+\]\s*</DIV>\s*</TD>&&gsi;
    $contents =~ s&\<TD width\=\"40\%\" align\=\"right\">\s*\<DIV STYLE=\".+\"\>\[Generated:[^\]]+\]\s*</DIV>\s*</TD>&&gsi;
    # Then the middle column of the footer may be 50% and right aligned:
    $contents =~ s&<TD width="20%" align="center">&<TD width="50%" align="right">&gi;
    # And the left column may be 50%:
    $contents =~ s&<TD width="40%" align="left">&<TD width="50%" align="left">&gi;

    #print STDERR "open($file)\n";
    open (STDOUT, ">$file") || die "Cannot open $file for writing: $!\n";
    print $contents;
    close STDOUT;
}

sub generate_pdf
{
    local ($cmd, $v) = ("", "");
    local (@sequence) = ();
    local ($fileno) = 0;
    if ($skippdf){
	print STDERR "Skipping PDF generation (-p option)\n" if $verbose;
    } else {
	if ($pdf eq ""){
	    $pdf = $book_file_name;
	    $pdf =~ s/\.book$/.pdf/;
	}
	&generate_pdf_titlepage();
	# Construct list of generated files
	push @sequence, $pdftitlefile;
	if ($do_program_list){
	    push @sequence, $programsfile;
	}
	if ($do_figure_list){
	    push @sequence, $figuresfile;
	}
	push @sequence, @dstfiles;
	foreach $f (@intdstfiles){
	    # Ignore intdst directories
	    push @sequence, $f if (-f $f);
	}
	if ($#gramfiles>=0){
	    for ($fileno=0; $fileno<=$#gramfiles; $fileno++){
		local ($g, $t, $h, $i) = &gram_names($fileno);
		push @sequence, $h;  # grammar file
		push @sequence, $i;  # grammar index file
	    }
	}
	push @sequence, $indexfile if (-f $indexfile);

	# htmldoc does not handle <script>...</script> too well
	# We filter it out in copies of the files in sequence
	foreach $f (@sequence){
	    &filter_for_pdf($f, "$f-dist")
	}

	# run htmldoc
	$v = "-v" if $verbose;
	$cmd = "$htmldoc $v -t pdf -f $pdf --toclevels 4 --bodycolor \#ffffff --size A4 --left 1.0in --right 0.5in --top 0.5in --bottom 0.5in --header .t. --footer h.1 --tocheader .t. --tocfooter l.i --firstpage p1 --compression=9 --fontsize 11.0 --fontspacing 1.2 --headingfont Helvetica --bodyfont Helvetica --headfootsize 11.0 --headfootfont Helvetica " . join (' ', @sequence);

	print STDERR "Generating $pdf\n" if ($verbose);
	print STDERR "$cmd\n" if $debug;
	$ENV{'LD_LIBRARY_PATH'} .= ":/usr/local/lib"; # for libz.so
	if (system("$cmd")!=0){
	    print STDERR "***Error in htmldoc execution!\n";
	    print STDERR "   Generation of PDF requires the program htmldoc to be\n";
	    print STDERR "   executable via your path.\n";
	    print STDERR "   It must be version 1.8.8 or later.\n";
	    print STDERR "   You may download htmldoc from\n\tftp://ftp.easysw.com/pub/htmldoc/\n";
	};
	unlink @sequence;
	foreach $f (@sequence){
	    if ($f eq $pdftitlefile){
		unlink "$f-dist";
	    } else {
		&rename_file("$f-dist", $f);
	    }
	}
	if (-f $pdf){
	    print STDERR "Wrote $pdf\n" if $verbose;
	} else {
	    print STDERR "\n***FAILED to generate $pdf!\n\n";
	}
    }
}

sub generate_pdf_titlepage()
{
    open STDOUT, ">$pdftitlefile" || die "Cannot open $pdftitlefile for writing: $!\n";
    if ($mia ne ""){
	&print_header("$mia: $title", "", "", "", "", "", 0);
    } else {
	&print_header("$title", "", "", "", "", "", 0);
    }
    print<<"EOT";
<H1>Copyright Notice</H1>
<center><B>
Mjlner Informatics Report<BR>
$mia<BR>
$date
</B>
<P>
<TABLE border=1 cellpadding=3>
<TR><TD align=center>
Copyright &#169; $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mjlner Informatics
</TD></TR>
</TABLE>
</center>
<HR BREAK>
</BODY>
</HTML>
EOT

    close STDOUT;
}

### Routines for processing grammar files

sub make_gram_anchor
{
    local ($name) = @_;
    push (@index, $name);
    $name = "<A CLASS=indexed TITLE=Indexed NAME=\"" . lc($name) . "\">&lt;$name&gt;</A>";
    return $name;
}

sub isLexem
{
    local ($name) = @_;
    $name = lc($name);
    return (($name eq "const") || ($name eq "string") || ($name eq "nameappl") || ($name eq "namedecl"));
}

sub make_gram_href1
{ 
    local ($string) = @_;
    if ($string =~ m/<([-\w]+)>/) {
	return "&lt;$1&gt;" if (&isLexem($1));
	return "<A HREF=\"#" . "\L$1" . "\">&lt;$1&gt;<\/A\>";
    } else {
	return $string;
    }
}
sub make_gram_href2
{ 
    local ($string) = @_;
    if ($string =~ m/<([-\w]+):([-\w]+)>/) {
	return "&lt;$1:$2&gt;" if (&isLexem($2));
	return "<A HREF=\"#" . "\L$2" . "\">&lt;$1:$2&gt;<\/A\>";
    } else {
	return $string;
    }
}
sub make_gram_comment
{
    local ($string) = @_;
    if ($string =~ m/\(\*(.*\*\))/) {
	$string =~ s/&/&amp\;/g;
	$string =~ s/>/&gt\;/g;
	$string =~ s/</&lt\;/g;
    }
    return $string;
}
sub make_gram_hrefs
{
    local ($string) = @_;
    $string =~ s/(\(\*.*\*\))/&make_gram_comment($1)/ge;
    $string =~ s/(<[-\w]+>)/&make_gram_href1($1)/ge;
    $string =~ s/(<[-\w]+:[-\w]+>)/&make_gram_href2($1)/ge;
    return $string;
}

sub make_gram_h2
{
    local ($string) = @_;
    return "</PRE>\n<H2>$string</H2>\n<PRE CLASS=gram>";
}

sub quote_gram_strings
# boldface literals and quote HTML in string constants
{
    local ($line) = @_;
    local ($processedline) = "";

    while (1){
	if ($line =~ m/\'([^\']+)\'/){
	    $processedline .= $`;
	    $remaining = $';
	    $literal = $1;
	    $literal = &quote_html($literal);
	    # HTML tags are generated as <+...+> to avoid
	    # interpreting, e.g. <B> as a rule in later
	    # processing. The plus signs are removed by unquote_html.
	    $literal = "<+B+>$literal<+/B+>" if ($in_gram_rules);
	    $literal = "\'$literal\'";
	    $processedline .= $literal;
	    $line = $remaining;
	} else {
	    $processedline .= $line;
	    last;
	}
    }
    return $processedline;
}

sub unplus_gram_html
# replace '<+' with '<' and , '+>' with '>'
{
    local ($string) = @_;
    $string =~ s/\<\+/\</g;
    $string =~ s/\+\>/\>/g;
    return $string;
}

sub print_gram_file()
{
    local ($fileno) = @_;
    local ($gramfile, $title, $htmlfile, $inxfile) = &gram_names($fileno);
    local ($prev, $prevtip, $next, $nexttip);
    if ($fileno==0){
	# first gram file
	$prev = $tocfile;
	$prevtip = "Table of Contents";
    } else {
	local ($prevgram, $previnx);
	($prevgram, $prevtip, $prev, $previnx) = &gram_names($fileno-1);
	$prev = $previnx;
	$prevtip = $prevtip . ": Alphabetic Index of Leftsides";
    }
    $next = $inxfile;
    $nexttip = $title . ": Alphabetic Index of Leftsides";
    &print_header($title, $prev, $prevtip, $next, $nexttip, $inxfile, 0);
    
    print<<"EOT";
<A NAME=H1></A>
<H1>$title</H1>
<PRE CLASS=gram>
EOT

    open (GRAM, "$gramfile") || die "cannot open $gramfile: $!\n";
    while(<GRAM>){
	$line = $_;
	chomp($line);
	$line = &untabify($line);
	if (/^\s*Option\s*$/i){
	    $line=&make_gram_h2($line);
	} elsif (/^\s*Rule\s*$/i){
	    $line=&make_gram_h2($line);
	    $in_gram_rules = 1;
	} elsif (/^\s*Attribute\s*$/i){
	    $line=&make_gram_h2($line);
	} elsif ($in_gram_rules){
	    $line = &quote_gram_strings($line);
	    if ($line =~ m/^(\s*)<([-\w]+)>(\s*)::/) {
		# line with rule definition
		#   <name>   :: ...
		#             ^ matched to here
		$w1 = $1; $name = $2; $w2 = $3; 
		$rest = $';
		$name = &make_gram_anchor($name);
		# insert link from rightsides to corresponding leftsides:
		$rest = &make_gram_hrefs($rest);
		$line = $w1 . $name . $w2 . "::" . $rest;
	    } else {
		#line without rule definition
		$line = &make_gram_hrefs($line);
	    }
	    $line = &unplus_gram_html($line);
	} else {
	    # Not yet in rules section
	    $line = &quote_html($line);
	}
	print "$line\n";
    }
    close(GRAM);

    print<<EOT;
</PRE>
EOT

    &print_trailer($title, 0, $gramfile);
    push (@headings, "$title\@$htmlfile#H1");
}

sub build_index_table
{
    local (@lines) = @_;
    local ($row, $result, $num);
    
    local ($col, $numcol, $percent);
    $numcol = $numinxcolumns;;
    $percent = int(100/$numcol);

    $num = $#lines+1;
    return "" if ($num == 0);
    # round up to nearest multiplum of $numcol
    $num = int(($num+($numcol-1))/$numcol) * $numcol;

    $result = "<TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH=\"100%\">\n";
    $result .= "<TR>\n";
    for ($col=1; $col<=$numcol; $col++){
	$result .= "<TD WIDTH=\"$percent%\">\n";
 	for ($row=0; $row<($num/$numcol); $row++){
	    $result .= "<BR>\n" if ($row>0);
	    $result .= "$lines[$row+($col-1)*($num/$numcol)]";
	}
	$result .= "<BR>\n";
	$result .= "</TD>\n";
    }
    $result .= "</TABLE>\n";
    return $result;
}

sub calculate_gram_index()
{
    local ($initial_ch, $i);

    # Sort index ignoring case
    @index = sort {lc($a) cmp lc($b)} @index;

    local (@index_lines) = ();
        
    for ($i = 0; $i <= $#index; $i++) {
	$initial_ch = ucfirst (substr($index[$i], 0, 1));
	if (! $caps{$initial_ch} ){
	    # Emit entries for previous letter
	    $html_index .= &build_index_table(@index_lines);
	    @index_lines = ();
	    # Generate caps heading at first occurrence of a letter.
	    $html_index .= "\n<H3><A name=\"_$initial_ch\">$initial_ch<\/A><\/H3>\n";
	    $caps{$initial_ch} = 1;
	}
	# Generate index line
	push @index_lines, "<A href=\"$htmlfile\#" . lc($index[$i]) . "\">&lt;" . $index[$i] . "&gt</A>";
    }
    # Emit entries for last letter
    $html_index .= &build_index_table(@index_lines);
    @index_lines = ();
}

sub print_gram_index_file()
{
    local ($fileno) = @_;
    local ($gramfile, $title, $htmlfile, $inxfile) = &gram_names($fileno);
    local ($prev, $prevtip, $next, $nexttip);
    local ($prevgram, $previnx);

    $prev = $htmlfile;
    $prevtip = $title;
    if ($fileno==$#gramfiles){
	# last gram-inx file - we don't have a global index
	$next = "";
	$nexttip = "";
    } else {
	local ($nextgram, $nextinx);
	($nextgram, $nexttip, $next, $nextinx) = &gram_names($fileno+1);
    }

    $title = "$title: Alphabetic Index of Leftsides";
    &print_header($title, $prev, $prevtip, $next, $nexttip, $htmlfile, 0);

    print<<EOT;
<A NAME=H2></A>
<H2>Index</H2>
The entries in the alphabetic index consists of all left-sides in the grammar.
<BR>
The small table of letters below links directly to the section of identifiers
starting with the corresponding letters. 
EOT
    print "<P>\n";
    &calculate_gram_index();
    &print_index_toc;
    print $html_index;
    &print_trailer($title, 0, "");
    push (@headings, "Index\@$inxfile#H2");
}

sub gram_names
{
    local ($fileno) = @_;
    local ($gramfile, $title, $basename, $htmlfile, $inxfile);
    
    $gramfile = $gramfiles[$fileno];
    $title=$gramfile;
    $title=~s%.*/%%; # delete path
    $title=~s/-meta.gram//; # delete -meta.gram
    $basename=lc($title);
    $htmlfile=$basename . ".html";
    $inxfile=lc($title) . "-inx.html";
    $title=ucfirst($basename) . " Grammar";

    return ($gramfile, $title, $htmlfile, $inxfile);
}

sub process_gram_file 
{
    local ($fileno) = @_;
    local ($file, $title, $htmlfile, $inxfile) = &gram_names($fileno);

    print STDERR "Generating $htmlfile\nfrom       $file\n" if $verbose;
    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";
    &print_gram_file($fileno);
    close (STDOUT);
    printf STDERR "done.\n" if $verbose;

    print STDERR "Generating $inxfile\n" if $verbose;
    open (STDOUT, ">$inxfile") || die "\nCannot open $gram_inxfile for writing: $!\n";
    &print_gram_index_file($fileno);
    close (STDOUT);
    printf STDERR "done.\n" if $verbose;

}

sub process_grammar_files
{   local ($fileno) = 0;
    for ($fileno=0; $fileno<=$#gramfiles; $fileno++){
	&process_gram_file($fileno);
    }
    $title = "Mjlner System: Grammars"; # For title page
}

### main #######

# variables
&set_default_variable_values();

&read_command_line();

if ($book_file_name eq ""){
    print STDERR "Processing single file \"$ARGV[0]\"\n" if $verbose;
    @srcfiles = ($ARGV[0]);
    &generate($ARGV[0], "PREVIEW");
} else {
    #print STDERR "reading book file\n";
    &read_book_file;
    if ($#gramfiles>=0){
	if ($#srcfiles>=0){
	    print STDERR "Ignoring src html files when grammars specified!\n";
	}
	if ($#intsrcfiles>=0){
	    print STDERR "Ignoring interface files when grammars specified!\n";
	}
	print STDERR "Processing grammar files (only)\n" if ($verbose);
	&process_grammar_files();
    } else {
	&process_src_files;
	&process_interface_files;
	&generate_program_list_page;
	&generate_figure_list_page;
	&generate_index_page;
    }
    &generate_pdf;
    &generate_toc_page;
}
1;
