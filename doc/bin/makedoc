#!/usr/local/bin/perl -s

# use strict;

sub usage
{
    print "usage: makedoc [-f] [-p] [-v] [-d] <manual>.book | <file>.html\n";
    print "  -f   use full urls in HREFs (http://www.mjolner.com/...)\n";
    print "  -p   do not generate PDF\n";
    print "  -h   print this summary\n";
    print "  -s   special treatment of headings in interface files\n";
    print "  -v   verbose output\n";
    print "  -d   debug makedoc script\n";
    print "  If .book file is given as argument, a full manual set is generated.\n";
    print "  If a single HTML file is given as input, that file is preprocessed.\n";
    exit(1);
}

# TODO:
#   use strict and -w, and define remaining global variables below.
#   Fix titles for src-generated files (OK for intsrcfiles)
#   Fix prev/next TITLE for src-generated files (OK for intsrcfiles)
#   Eliminate global $filenumber
# IDEAS:
#   Possibly a <FOOTNOTE> tag.
#   Possibly a CAP attribute for INX (to appear in index instead of indexed word)?
#   remove trailing numbers from interface index anchors?
#   Two-column index?
#   print.html to supplement PDF? Possibly Problem with internal links 
#   (fix as for pdf generation or possibly even USE pdf prepered html files).


# Global variables
# arrays
my @srcfiles = ();         # array of file names from src subdirectory
my @dstfiles = ();         # array of file names to store output files in
my @intsrcfiles = ();      # array of file names to convert to interface files
my @intdstfiles = ();      # array of file names to store output interface files in
my @programs = ();         # used to build list of programs
my @figures = ();          # used to build list of figures
my @headings = ();         # used to build table of contents
my @intheadings = ();      # used to build interface descriptions part of table of contents
my @index = ();            # used to build index
my @num_h = (0,0,0,0,0,0); # array of occurrences of headings 1 to 6

# variables
my $src = "src/";
my $dst = "";
my $intsrc = "";
my $intdst = "";
my $book_file_name = "";   # Name of BOOK file
my $filenumber = 0;        # used to index @srcfiles and @headings
my $num_beta   = 0;        # Number of occurences of <BETA LIST> 
my $num_fig    = 0;        # Number of occurences of <FIG>
my $num_inx    = 0;        # Number of occurences of <INX>
my $headinglevel      = 0;        # Current heading level
my $srcline    = "";       # Used to read files from src directory into
my $verbose    = 0;
my $debug      = 0;
my $special_headers = 0;
my $insert_validhtml40 = 0;
my $fullpath   = 0;
my $skippdf    = 0;
my $css =                "../style/miadoc.css";
my $jsdir =              "../javascript";
my $imagedir =           "../images";
my $mainfile =           "../index.html";
my $tocfile =            "index.html";
my $indexfile =          "inx.html";
my $programsfile =       "programs.html";
my $figuresfile =        "figures.html";
my $pdftitlefile =       "pdftitle.html";
my $do_program_list = 0;
my $do_figure_list = 0;
my $leftmargin=25;
my $tab_width = 8;
my $htmldoc="htmldoc";

sub set_default_variable_values
{
    if ($fullpath){
	local $url = "http://www.mjolner.com/mjolner-system/documentation";
	$css = "$url/style/miadoc.css";
	$jsdir = "$url/javascript";
	$imagedir = "$url/images";
	$mainfile = "$url/index.html";
    }
}

sub read_file
{
    local ($filename) = @_;
    local ($line);
    if (!open(FILE, "$filename")){
	print STDERR "***Cannot open $filename for reading: $!\n";
	exit 1;
    }

    $line="";
    while (<FILE>) {
	$line .= &untabify($_);
    };
    close (FILE);
    return $line;
}

sub rename_file
{
    local ($old, $new) = @_;
    rename $old, $new || die "Cannot rename file $old to $new: $!\n";
}

sub SmartMkdir {
    my ($path) = @_;
    my ($full) = '';
    foreach $dir (split '/', $path) {
	$full .= $dir . '/';
	if (!-d $full){
	    print STDERR "mkdir $full\n" if ($verbose);
	    if (!mkdir ($full, 0755)){
		print STDERR "Cannot create directory \"$full\": $!\n";
		return;
	    }
	}
    }
}
sub go_up
{
    local ($path, $up) = @_;

    if ($fullpath){
	return $path;
    } else {
	return "../" x($up) . $path;
    }
}

sub untabify
{
    local($line) = @_;
    while($line =~ /\011/)
    {
        $line =~ s/\011/" " x ($tab_width - (length($`) % $tab_width))/ge;
    }
    return $line;
}

sub expand 
{
    local ($path) = @_;
    while ($path =~ m/\$(\w+)/){
	local $var = $1;
	if (!defined($ENV{$var})){
	    print "Expand $path: Warning: $var not in environment\n";
	} else {
	    $path = $` . $ENV{$var} . $';
	}
    }
    return $path;
}

sub remove_tag()
{
    local ($tag) = @_;

    if ($tag =~ m/<.*<.*>/){
	print STDERR "Warning: unquoted '<' in tag:\n\t$tag";
    }
    return "";
}

sub untag
{
    local ($string) = @_;
    $string =~ s/(<[^>]+>)/&remove_tag($1)/sgoe;
    return $string;
}

sub quote_html
{
    local ($string) = @_;

    #print STDERR "quote: $string\n";
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    # Used by index generation
    $string =~ s/\007([a-zA-Z]+;)/&$1/g;
    return $string;
}

sub unquote_html
{
    local ($string) = @_;

    #print STDERR "unquote: '$string' yields";
    $string =~ s/&gt;/>/g;
    $string =~ s/&lt;/</g;
    $string =~ s/&amp;/&/g;
    # special feature used for quoting through index generation
    $string =~ s/&([a-zA-Z]+;)/\007$1/g;
    #print STDERR " '$string'\n";
    return $string;
}

sub quote_colon
{
    local ($string) = @_;
    $string =~ s/:/&#58;/g;
    return $string;
}

sub unquote_colon
{
    local ($string) = @_;
    $string =~ s/&#58;/:/g;
    return $string;
}
	       
sub strip_extension
{
    local ($string) = @_;
    if ( $string =~ m/([^\.]+)\..*/ ) {
	$string = $1;
    }
    return $string;
}

sub strip_prefix
{
    local ($path, $prefix) = @_;
    $path  = &trim_path($path);
    $refix = &trim_path($prefix);
    $path =~ s%^$prefix/%%;
    return $path;
}

sub strip_path
{
    local ($string) = @_;
    if ( $string =~ m%.*/([^/]+$)% ) {
	$string = $1;
    }
    return $string;
}

sub strip_dirs
{
    local ($path, $numdirs) = @_;
    $path = &trim_path($path);
    do{
	$path =~ s%^[^/]*/%%;
	$numdirs--;
    } while ($numdirs>0);
    return $path;
}

sub trim_path
{
    local ($path) = @_;
    # delete double slashes
    $path =~ s%//+%/%g;
    # delete trailing slash
    $path =~ s%/$%%;
    # delete initial ./
    $path =~ s%^\./%%;
    return $path;
}

sub countdirs
{
    local ($path) = @_;
    local $numdirs = 0;
    $path = &trim_path($path);
    $path =~ s%/%$numdirs++%ge;
    #print STDERR "numdirs($path)=$numdirs\n";
    return $numdirs;
}

sub legal_identifier

{
    local ($id) = @_[0];
    return ($id =~ m/[a-zA-Z_]\w*/);
}

sub num_chars
# Occurences of $ch in $string
{
    local ($ch, $string) = @_;
    local ($i, $num);
    $num=0;
    for ($i=0; $i<length($string); $i++){
	$num++ if (substr($string, $i, 1) eq "$ch");
    }
    #print STDERR "num_chars($ch, $string) = $num\n";
    return $num;
}

sub print_lastmod
{
    local ($filename) = @_;
    local @month_names = ("January","February","March","April","May","June","July","August","September","October","November","December");
    local @day_names   = ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday");
    local @sup = ();
    local ($sup_date, $lastmod, $prompt);
    if ($filename ne ""){
	local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	    = stat($filename);
	$lastmod = $mtime;
	$prompt = "Modified";
   } else {
	$lastmod = time;
	$prompt = "Generated";
    }
    local ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime($lastmod);
    $sup[1] = $sup[21] = $sup[31] = "st";
    $sup[2] = $sup[22] = "nd";
    $sup[3] = $sup[23] = "rd";
    if (($date==1)  || ($date==2)  || ($date==3) ||
	($date==21) || ($date==22) || ($date==23) ||
	($date==31)) {
	$sup_date = $sup[$date];
    } else {
	$sup_date ="th";
    }
    # Y2K hack
    $year %= 100;
    if ($year >= 98 ){
	$year = "19" . $year;
    } else {
	if ($year<10){
	    $year = "0" . $year;
	}
	$year = "20" . $year;
    }
 
    print "<DIV STYLE=\"font:smaller\">";
    print "[$prompt: $day_names[$day] $month_names[$month] $date<SUP>$sup_date</SUP> $year at $hour:$min]\n";
    print "</DIV>\n";
}

sub print_valid_html_button()
{
    local ($up) = @_;
    local ($imagedir1);

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }

    print<<EOT if ($insert_validhtml40);
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="${imagedir1}/vh401.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
EOT
}

sub print_rel_link
{
    local ($type, $href) = @_;
    $type = ucfirst ($type);
    print<<EOT;
<LINK REL="$type" HREF="$href">
EOT
}

sub print_nav_link
{
    local ($type, $href, $title) = @_;
    local ($label) = ucfirst ($type);
    if ($href eq ""){
	print "document.write(\'\\<A NAME=\"$label\" CLASS=\"SideBarDisabled\" TITLE=\"$title\"\\>$label\\</A\\>\\<BR\\>');\n";
    } else {
	print "document.write(\'\\<A HREF=\"$href\" onClick=\"out\(\);\" CLASS=\"SideBar\" TITLE=\"$title\"\\>$label\\</A\\>\\<BR\\>');\n";
    }
}

sub print_layer_begin
{

    local ($up) = @_;
    local ($imagedir1);

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }
    
    print<<EOT;
<LAYER id="SideBar" onMouseover="pull()" onMouseout="draw()" style="position:absolute;left:-95px;width:80px;layer-background-color:#669999;padding:5px;line-height:25px; ">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
if (document.all){
  document.write('\\<DIV id="SideBar2" onMouseover="pull()" onMouseout="draw()" STYLE="position:absolute;left:-80px;top:15px;width:100px;background-color:#669999;padding:5px;line-height:25px;" TITLE=\"Navigation Bar: Slides out when cursor is moved out\"\\>');
}
if (document.all && (navigator.userAgent.indexOf("Mac")==-1)) {
  document.write('\\<IMG SRC="$imagedir1/navigation-light.gif" STYLE="position:absolute;left:84;top:5" WIDTH=13 HEIGHT=63 ALT=""\\>');
} else {
  document.write('\\<IMG SRC="$imagedir1/navigation-light.gif" ALIGN=RIGHT WIDTH=13 HEIGHT=63 ALT=""\\>');
}
EOT
}

sub print_layer_end
{
    print<<EOT;
if (document.all)
  document.write('\\</DIV\\>');
else
  document.write('&nbsp;');
SetupSideBar();
</SCRIPT>
</LAYER>
EOT
}

sub print_head_begin
{
    local ($title, $up) = @_;
    local ($jsdir1, $css1);

    if ($up){
	$jsdir1 = &go_up($jsdir,$up);
	$css1   = &go_up($css,$up);
    } else {
	$jsdir1 = $jsdir;
	$css1   = $css;
    }

    print<<EOT;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<!-- Autogenerated file - do not edit -->
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>$title</TITLE>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/ns-resize.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/sidebar.js">
</SCRIPT>
<LINK REL="stylesheet" HREF="$css1" TYPE="text/css">
EOT
}

sub print_std_rel_links
{
    local ($up) = @_;
    if ($up){
	&print_rel_link("start", &go_up($mainfile,$up));
	&print_rel_link("first", &go_up($tocfile,$up));
	&print_rel_link("last", &go_up($indexfile,$up));
	&print_rel_link("contents", &go_up($tocfile,$up));
	&print_rel_link("index", &go_up($indexfile,$up));
	&print_rel_link("copyright", &go_up("../copyright.html", $up));
	&print_rel_link("help", &go_up("../help.html", $up));
	#&print_rel_link("search", &one_up("search.html"));
    } else {
	&print_rel_link("start", $mainfile);
	&print_rel_link("first", $tocfile);
	&print_rel_link("last", $indexfile);
	&print_rel_link("contents", $tocfile);
	&print_rel_link("index", $indexfile);
	&print_rel_link("copyright", "../copyright.html");
	&print_rel_link("help", "../help.html");
	#&print_rel_link("search", "search.html");
    }
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");

}

sub print_std_nav_links
{
    local ($up) = @_;
    &print_nav_link("Page Top", "#_top", "Top of Page");
    if ($up){
	&print_nav_link("content", &go_up($tocfile,$up), "Table of Contents");
	&print_nav_link("index", &go_up($indexfile,$up), "Alphabetic Index");
	&print_nav_link("PDF", &go_up($pdf,$up), "Portable Document Format version of manual");
	print "document.write('\<HR ALIGN=LEFT WIDTH=60\>');\n";
	&print_nav_link("Help", &go_up("../help.html",$up), "Help on these Online Manuals");
	&print_nav_link("manuals", &go_up($mainfile,$up), "Manuals Main Entry");
    } else {
	&print_nav_link("content", $tocfile, "Table of Contents");
	&print_nav_link("index", $indexfile, "Alphabetic Index");
	&print_nav_link("PDF", $pdf, "Portable Document Format version of manual");
	print "document.write('\<HR ALIGN=LEFT WIDTH=60\>');\n";
	&print_nav_link("Help", "../help.html", "Help on these Online Manuals");
	&print_nav_link("manuals", $mainfile, "Manuals Main Entry");
    }
}

sub print_header
{
    local ($title, $prev, $prevtip, $next, $nexttip, $up) = @_;

    print_head_begin($title, $up);
    &print_rel_link("next", $next) if ($next ne "");
    &print_rel_link("prev", "$prev") if ($prev ne "");
    &print_std_rel_links($up);

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
<A NAME="_top"></A>
EOT

    $nexttip = "Next: $nexttip" if ($next ne "");
    $prevtip = "Previous: $prevtip" if ($prev ne "");
    &print_layer_begin($up);
    &print_nav_link("next", $next, $nexttip);
    &print_nav_link("previous", $prev, $prevtip);
    &print_std_nav_links($up);
    &print_layer_end;

}

sub print_src_header
{
    local ($title) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    if ($filenumber==$#srcfiles){
	# last file
	if ($#intsrcfiles>0){
	    # Cannot use find_next_interface_file here, 
	    # since intheadings is not yet created.
	    # And can't call build_intheadings yet, since last file is
	    # not yet updated, i.e. num_h[*] are not yet updated.
	    # Copy the stuff in build_intheadings
	    local ($intdstfile) = $intdstfiles[0];
	    local ($intsrcfile) = $intsrcfiles[0];
	    if ($intsrcfile eq ""){
		# Special case used to force a new interface chapter
		$nexttip = "" . $num_h[1]+1 . " $intdstfile";
		($nexttip, $next) = &parse_int_chap($nexttip);
		$next .= "/index.html";
	    } else {
		print STDERR "Error: print_src_header: No interface header?\n";
		#$num_h[1]++; # pretend we're at next chapter now
		#$nexttip =  &generate_int_title($intsrcfile);
		#$num_h[1]--; # go back again
		#$num_h[2]--; # was counted up by generate_int_title
		#$next = intdstfile;
	    }
	} else {
	    $next = $indexfile;
	    $nexttip = "Alphabetic Index";
	}
    } else {
	$next = $dstfiles[$filenumber+1];
	$nexttip = $next;
    }
    if ($filenumber==0){
	# first file
	if ($do_figure_list){
	    $prev = $figuresfile;
	    $prevtip = "List of Figures";
	} elsif ($do_program_list){
	    $prev = $programsfile;
	    $prevtip = "List of Programs";
	} else {
	    $prev = $tocfile;
	    $prevtip = "Table of Contents";
	}
    } else {
	$prev = $dstfiles[$filenumber-1];
	$prevtip = $prev;
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, 0)
}

sub print_trailer
{
    local ($title, $up, $sourcefile) = @_;
    local ($w) = 40;
    local ($copyrightfile) = &go_up("../copyright.html", $up);
    #if ($copyright eq ""){ $w = 50; }
    &print_valid_html_button($up);

    print<<EOT;
<P></P>
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="$w%" align="left"><ADDRESS>$title</ADDRESS></TD>
EOT
    print<<EOT if ($w==40);
<TD width="20%" align="center"><FONT size=-1><A HREF="$copyrightfile">&#169;</A> $copyrightyears <A HREF=\"http://www.mjolner.com\">Mj&oslash;lner Informatics</A></FONT></TD>
EOT
    print<<EOT;
<TD width="$w%" align="right">
EOT
    
    print_lastmod("$sourcefile");

    print<<EOT;
</TD>
</TABLE>
<P></P>
</BODY>
</HTML>
EOT
}

sub print_toc_header
{
    local ($next, $nexttip);

    if ($do_program_list){
	$next = $programsfile;
	$nexttip = "List of Programs";
    } elsif ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, "", "No Previous Page", $next, $nexttip, 0)
}

sub print_index_nav_toc
{
    local ($i, $ch, $n);
    print "document.write('\\<HR ALIGN=LEFT WIDTH=60\\>')\n";
    $n=0;
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	$n++;
	if ($caps{$ch}){
	    print "document.write('\\<A HREF=\"#_$ch\" CLASS=\"SideBarFixed\" TITLE=\"Entries starting with $ch\" onClick=\"out();\"\\>$ch\\</A\\>";
	} else {
	    print "document.write('\\<A NAME=\"_$ch\" CLASS=\"SideBarFixedDisabled\" TITLE=\"No entries starting with $ch\"\\>$ch\\</A\\>";
	}
	if ($i==90){
	    print("');\n");
	} elsif ($n%4==0){
	    print "\\<BR\\>');\n";
	} else {
	    print " \\&nbsp;');\n";
	}
    }
}

sub print_index_header
{
    local ($title) = @_;
    local ($next, $prev);

    print_head_begin($title, 0);
    if ($#intsrcfiles>0){
	# Previous was last interface file
	($prev, $prevtip) = &find_prev_interface_file($#intsrcfiles+1, 0);
	&print_rel_link("prev", $prev);
    } else {
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
	&print_rel_link("prev", $prev);
    }
    &print_std_rel_links(0);

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
<A NAME="_top"></A>
EOT

    &print_layer_begin(0);
    &print_nav_link("next", "", "No next page");
    &print_nav_link("previous", $prev, "Previous: $prevtip");
    print_std_nav_links(0);

    #&print_index_nav_toc;
    
    &print_layer_end;

}

sub find_next_interface_file
{
    local ($number, $up) = @_;
    local ($next, $nexttip);
    #print STDERR "\nfind_next_interface_file($number, $up) = ";
    $number++;
    if ($number>$#intsrcfiles){
	# passed last interface file
	$next = $indexfile;
	$nexttip = "Alphabetic Index";
    } else {
	($nexttip, $next) = split("\@", $intheadings[$number]);
	if ($next eq ""){
	    #print STDERR "find_next_interface_file: int chap: $nexttip\n";
	    ($nexttip, $next) = &parse_int_chap($nexttip);
	    $next .= "/index.html";
	} 
    }
    $next = &go_up($next, $up);
    #print STDERR "($next, $nexttip)\n";
    return ($next, $nexttip);
}

sub find_prev_interface_file
{
    local ($number, $up) = @_;
    local ($prev, $prevtip);
    #print STDERR "\nfind_prev_interface_file($number, $up) = ";
    $number--;
    if ($number<0){
	# passed first interface file
	$prev = $dstfiles[$#dstfiles];
	$prevtip = ucfirst(&strip_extension(&strip_path($prev))) . " Interface";
    } else {
	($prevtip, $prev) = split("\@", $intheadings[$number]);
	if ($prev eq ""){
	    # Found interface chapter
	    ($prevtip, $prev) = &parse_int_chap($prevtip);
	    $prev .= "/index.html";
	} 
    }
    $prev = &go_up($prev, $up);
    #print STDERR "($prev, $prevtip)\n";
    return ($prev, $prevtip);
}

sub print_interface_toc_header
{
    local ($title, $up, $intfilenumber) = @_;
    local ($next, $nexttip, $prev, $prevtip, $nextno) = 0;
    
    ($next, $nexttip) = &find_next_interface_file($intfilenumber, $up);
    if ($intfilenumber==0){
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
	$prev = &go_up($prev,$up);
    } else {
	($prev, $prevtip) = &find_prev_interface_file($intfilenumber, $up);
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, $up)
}

sub print_interface_header
{
    local ($title,$up) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    print_head_begin($title, $up);

    ($next, $nexttip) = &find_next_interface_file($filenumber, $up);
    ($prev, $prevtip) = &find_prev_interface_file($filenumber, $up);

    &print_header($title, $prev, $prevtip, $next, $nexttip, $up)
}

sub read_command_line()
{
    # Command line options
    &usage() if (defined($h));
    $special_headers = 1 if (defined($s));
    $verbose = 1 if (defined($v));
    $debug = 1 if (defined($d));
    $fullpath = 1 if (defined($f));
    $skippdf = 1 if (defined($p));
    if ($#ARGV == 0){ 
	local ($file) = $ARGV[0];
	if ($file =~ m/\.book$/){
	    $book_file_name = $file;
	}
    } else {
	&usage();
    };
}


sub read_book_file
{
    if (! -f "$book_file_name"){
	die "Book file \"$book_file_name\" does not exist!\n";
    }
    open SEQUENCE, "$book_file_name" || die "Cannot open \"$book_file_name\" file: !$\n";
    while (<SEQUENCE>){
	chomp;
	# remove comments
	s/\#.*$//;
	# skip blank lines
	next if (m/^\s*$/);
	if (-f "${src}$_"){
	    push @srcfiles, $src . $_;
	    push @dstfiles, $dst . &strip_path($_);
	} else { 
	    if (m/^date:\s*(.*)$/){ 
		$date = $1;
	    };
	    if (m/^inx:\s*(.*)$/){ 
		$indexfile = $1;
	    };
	    if (m/^toc:\s*(.*)$/){ 
		$tocfile = $1;
	    };
	    if (m/^pdf:\s*(.*)$/){
		$pdf= $1;
	    };
	    if (m/^src:\s*(.*)$/){ 
		$src = &trim_path(&expand($1)) . "/";
	    };
	    if (m/^dst:\s*(.*)$/){ 
		$dst = &trim_path(&expand($1)) . "/";
		&SmartMkdir($dst);
	    };
	    if (m/^intsrc:\s*(.*)$/){ 
		$intsrc = &trim_path(&expand($1)) . "/";
	    };
	    if (m/^intdst:\s*(.*)$/){ 
		$intdst = &trim_path(&expand($1)) . "/";
		if (($intdst =~ m%^\.\./%) || ($intdst =~ m%^/%)){
		    print STDERR "Illegal intdst: $intdst.\n";
		    print STDERR "intdst: must be a local directory\n";
		    exit 1;
		}
		&SmartMkdir($intdst);
		push @intsrcfiles, "";
		push @intdstfiles, $intdst;
	    };
	    if (m/^mia:\s*(.*)$/){ $mia = $1 };
	    if (m/^title:\s*(.*)$/){ $title = $1 };
	    if (m/^copyright:\s*(.*)$/){ 
		$copyrightyears = $1; 
	    };
	    if (m/^list:\s*(.*)$/){ 
		local $lists= $1;
		if ($lists =~ m/\bprograms?\b/i){
		    $do_program_list = 1;
		}
		if ($lists =~ m/\bfig\b|\bfigures?\b/i){
		    $do_figure_list = 1;
		}
	    };
	    if (m/^int:\s*(.*)$/){ 
		push @intsrcfiles, &expand($intsrc . "$1");
		push @intdstfiles, $intdst . &strip_extension(&strip_path(&expand("$1"))) . ".html";
	    }
	}
    }

    if (($#intsrcfiles>-1) && ($intdst eq "")){
	# intdst was not specified - use default "interface"
	$intdst = "interface";
	# Prepend "interface/" to all intdstfiles
	for ($filenumber=0; $filenumber<=$#intdstfiles; $filenumber++){
	    $intdstfiles[$filenumber] = "interface/$intdstfiles[$filenumber]";
	}
	&SmartMkdir($intdst); 
	unshift @intsrcfiles, "";
	unshift @intdstfiles, $intdst;
    }

    if ($debug){
	print STDERR "read book file $book_file_name.\n";
	print STDERR "  date:      $date\n";
	print STDERR "  mia:       $mia\n";
	print STDERR "  title:     $title\n";
	print STDERR "  copyright: $copyrightyears\n";
	print STDERR "  pdf:       $pdf\n";
	print STDERR "  lists:     \n";
        print STDERR "    programs\n" if $do_program_list;
        print STDERR "    figures\n"  if $do_figure_list;
	print STDERR "  sequence:\n    ";
	print STDERR join("\n    ",@srcfiles);
	print STDERR "\n  intsrcfiles:\n    ";
	print STDERR join("\n    ",@intsrcfiles);
	print STDERR "\n";
    }
}

sub parse_special_tags
{
    local ($done, $before, $match, $after, $number, $i);
    local ($htmlfile) = $dstfiles[$filenumber];

    $_=$srcline;
    $done = $before = $match = $after = "";

    while(m%\<H[1-6]\>|\</H[1-6]\>|\<BETA|\</BETA\>|\<FIG|\</FIG\>|\<INX|\</INX\>%i ){
	$before = $`;
	$match  = $&; 
	$after  = $';

	$done .= $before;
	# perform stuff on $match
	if  ($match =~ m%\<H([1-6])\>%i){
	    ################# Found heading start. #########################
	    $done .= $match;
	    local ($h, $heading, $anchor, $headanchors, $headinx);
	    $h = $1;
	    if ($h<$headinglevel){
		# Going from sub section to section/chapter
		for (; $headinglevel>$h; $headinglevel--){
		    $num_h[$headinglevel]=0;
		}
	    }
	    if ($h>$headinglevel){
		# Going from section/chapter to (sub)section
		$headinglevel++;
		for (; $headinglevel<$h; $headinglevel++){
		    $num_h[$headinglevel]++;
		}
	    }
	    $num_h[$h]++;
	    # Generate number for heading
	    $number = "";
	    for ($i=1; $i<=$h; $i++){
		$number .= "$num_h[$i].";
	    }
	    chop $number; # remove trailing dot
	    # Start anchor to refer from TOC
	    $anchor = "H${h}_$num_h[$h]";
	    $done .= "<A NAME=\"$anchor\">";
	    if ($after =~ m%\</H$h\>%si){
		$heading = $`;
		$after = $';
		$heading =~ s/^\s*//; # remove leading whitespace
		# Check for index entries in heading. Move them outside
		while ($heading =~ m%<INX>([^<]*)</INX>%si){
		    $after = "<INX HIDDEN>$1</INX>" . $after;
		    $heading = $` . $1 . $';
		}
		# Check for anchors in heading. Move them outside
		$headanchors = "";
		while ($heading =~ m%(<A NAME=[^>]+>)([^<]*)(</A>)%si){
		    $headanchors .= $1 . $3;
		    $heading = $` . $2 . $';
		}
		$heading = "$number $heading";
		$done .= $heading . "</A>$headanchors</H$h>";
	    } else {
		printf STDERR "$htmlfile: ***Unterminated heading? (<H$h>)\n";
	    }
	    push (@headings, "$heading\@$htmlfile\#$anchor");
	} elsif ($match =~ m%\</H[1-6]\>%i){
	    # Found heading end
	    print STDERR "$htmlfile: ***Unmatched end-of-heading? ($&)\n";
	    $done .= $match;
	} elsif ($match =~ m%\<BETA%i){
	    ##################### Found BETA start ########################
	    local $beta = "";
	    local $caption = "";
	    local $list = 0;
	    local $listcap = "";
	    local $attributes = "";
	    local $id = "";
	    local $anchor = "";
	    if ($after =~ m%^([^>]*)\>%si){
		# Matched <BETA xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <BETA> attributes:'$attributes'\n" if ($debug);
		$after = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    }
	    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
		$beta=&read_file(&expand($1));
	    } elsif ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
		$beta=&read_file(&expand($1));
	    }
	    if ($beta ne ""){
		# Found SRC
		# eat closing tag, if present
		if ($after =~ m%^\s*\<\/BETA\>%si){
		    $after = $';
		}
	    } else {
		# No SRC. Handle stuff until (and including) end-tag
		#print STDERR "No SRC. Handle stuff until (and including) end-tag\n" if ($debug);
		if ($after =~ m%\<\/BETA\>%si){
		    $beta = &untabify($`); # ...
		    #print STDERR "beta='$beta'\n" if ($debug);
		    $after = $';
		} else {
		    printf STDERR "$htmlfile: <BETA> with no SRC and no end-tag met.\n";
		}
	    }
	    # Generate output into $done variable
	    if ($list){
		$num_beta++;
		if ($listcap eq ""){
		    if ($caption eq ""){
			print STDERR "$htmlfile: <BETA> tag with LIST attribute and no caption found.\n";
			print STDERR "Using \"Program " . $num_beta . "\" for caption.\n";
			$listcap = $caption = "Program " . $num_beta;
		    } else {
			$listcap = $caption;
		    }
		}
		if ($caption eq ""){
		    $caption = $listcap;
		}
		$listcap = "" . $num_beta . " " . $listcap;
		$caption = "Program " . $num_beta . ": " . $caption;
		if ($id ne ""){
		    $anchor = "BETA_$id";
		} else {
		    $anchor = "BETA_$num_beta";
		} 
		push (@programs, "$listcap\@$htmlfile\#$anchor");
		$done .= "<A NAME=\"$anchor\">";
	    }
	    if ($caption ne ""){
		$done .= "<H4 CLASS=betacaption>$caption</H4>";
	    }
	    if ($list){
		$done .= "</A>";
	    } 
	    $done .= "\n";
	    $done .= "<PRE CLASS=BETA>\n";
	    # Trim $beta for whitespace
	    $beta =~ s/^\s*//;
	    $beta =~ s/\s*$//;
	    $done .= &quote_html($beta); 
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\</BETA\>%i){
	    # Found BETA end
	    print STDERR "$htmlfile: ***Unmatched end-of-beta? (</BETA>)\n";
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\<INX%i){
	    ################# Found INX start #########################
	    local ($entry, $anchor) = ("", "");
	    local $attributes = "";
	    local $anchor = "";
	    local $hidden = 0;
	    #print STDERR "$htmlfile: INX start\n";
	    if ($after =~ m%^([^>]*)\>%si){
		# Matched <INX xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <INX> attributes:'$attributes'\n";
		$after = $';
	    }	    
	    $num_inx++;
	    if ($attributes =~ m%HIDDEN%i){
		$hidden = 1;
	    }
	    # Start anchor to refer from index
	    $anchor = "INX_$num_inx";
	    $done .= "<A NAME=\"$anchor\"><SPAN CLASS=INDEXED TITLE=Indexed>";
	    if ($after =~ m%\</INX\>%i){
		$entry = $`;
		#print STDERR "$htmlfile: INX entry: $entry\n";
		if ($entry eq ""){
		    print STDERR "$htmlfile: Empty index entry? <<INX></INX>)\n";
		}
		$done .= $entry unless $hidden;
		$done .= "</SPAN></A>";
		$after = $';
	    } else {
		printf STDERR "Unterminated index entry? (<INX>)\n";
	    }
	    push (@index, &quote_colon(&unquote_html(&untag($entry))) . ".0\@$htmlfile\#$anchor");
	} elsif ($match =~ m%\</INX\>%i){
	    # Found INX end
	    print STDERR "$htmlfile: ***Unmatched end-of-index-entry? (</INX>)\n";
	    $done .= $match;
	} elsif ($match =~ m%\<FIG%i){
	    ######################## Found FIG start ####################
	    local $list = 0;
	    local $figure = "";
	    local $caption = "";
	    local $listcap = "";
	    local $id = "";
	    local $attributes = "";
	    local $anchor = "";
	    #print STDERR "$htmlfile: FIG start\n";
	    $num_fig++;
	    if ($after =~ m%^([^>]*)\>%si){
		# Matched <FIG xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <FIG> attributes:'$attributes'\n";
		$after = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    }
	    # Handle rest until (and including) end tag
	    if ($after =~ m%\</FIG\>%si){
		$figure = $`;
		$after = $';
		#print STDERR "$htmlfile: figure: $figure\n";
		if ($figure =~ m%^\s*$%s){
		    print STDERR "$htmlfile: Empty figure? (<FIG></FIG>)\n";
		}
	    } else {
		printf STDERR "Unterminated figure tag? (<FIG>)\n";
	    }
	    $listcap =~ s%^\s+%%s;
	    $listcap =~ s%\s+$%%s;
	    $caption =~ s%^\s+%%s;
	    $caption =~ s%\s+$%%s;
	    if ($listcap eq ""){
		if ($caption eq ""){
		    if ($list){
			print STDERR "$htmlfile: <FIG> tag with LIST attribute and no caption found.\n";
			print STDERR "Using \"Figure " . $num_fig . "\" for caption.\n";
			#$caption = "Figure $num_fig";
		    }
		} else {
		    $listcap = $caption;
		}
	    }
	    if ($caption eq ""){
		$caption = $listcap;
	    }
	    if ($listcap eq ""){
		$listcap = "" . $num_fig . " " . "Figure $num_fig";
	    } else {
		$listcap = "" . $num_fig . " " . $listcap;
	    }
	    if ($caption eq ""){
		$caption = "Figure " . $num_fig;
	    } else {
		$caption = "Figure " . $num_fig . ": " . $caption;
	    }
	    if ($id ne ""){
		$anchor = "FIG_$id";
	    } else {
		$anchor = "FIG_$num_fig";
	    } 
	    #printf STDERR "listcap: '$listcap'\n";
	    #printf STDERR "caption: '$caption'\n";

	    $done .= "\n<P></P>\n<A NAME=\"$anchor\">";
	    $done .= "<STRONG CLASS=figure>$caption</STRONG>\n</A>\n";
	    $done .= "<P></P>\n";
	    # Must put $figure into $after to get processing of e.g.
	    # <INX>, <BETA> in the figure.
	    $after = $figure . $after;
	    if ($list){
		push (@figures, "$listcap\@$htmlfile\#$anchor");
	    }
	} elsif ($match =~ m%\</FIG\>%i){
	    # Found FIG end
	    print STDERR "$htmlfile: ***Unmatched end-of-figure? (</FIG>)\n";
	    $done .= $match;
	} else {
	    # Hmmm, error? Should not happen.
	    $done .= $match;
	}
	
	# handle rest of input in next iteration
	$_ = $after;
    }

    $srcline=$done . $_;
}

sub make_special_header
{
    local ($title, $htmlfile) = @_;
    local ($intnum) = "" . $num_h[1] . "." . ++$num_h[2];
    local ($anchor) = "H$num_h[1]_$num_h[2]";

    push (@intheadings, "$intnum $title\@$htmlfile#$anchor");

    $title = "\005\/PRE\006\005H2\006\005A name=\"$anchor\"\006$intnum\007nbsp;$title\005\/A\006\005\/H2\006\005PRE CLASS=interface\006\n";

    return $title;
}

sub parse_special_header
{
    local ($contents, $htmlfile) = @_;

    $contents =~ s/\(\*\*+\*\)\s+\(\*+\s+([^\*]+)\s+\*+\)\s+\(\*\*+\*\)\s+/make_special_header($1, $htmlfile)/seg;


    # Delete copyrigth comments of the form
    # (*
    #  * COPYRIGHT
    #  *       Copyright Mjolner Informatics, 199x-9x
    #  *       All rights reserved.
    #  *)
    #$contents =~ s/\(\*\s+\*\s+COPYRIGHT[\s\w\*\,\-\.]+\*\)\s*//sg;
    
    return $contents;
}

sub generate
{
    local ($file, $title) = @_;
    printf STDERR "Reading $file ...\n" if $debug;
    $srcline = &read_file("$file");
    printf STDERR "Writing HTML ...\n" if $debug;
    &parse_special_tags();
    &print_src_header($title);
    print $srcline;
    &print_trailer($title, 0, $file);
}

sub process_file
{
    local ($srcfile, $dstfile) = @_;
    print STDERR "Generating $dstfile\nfrom       $srcfile\n" if $verbose;

    printf STDERR "Opening $dstfile for writing ... " if $debug;
    if (!open (STDOUT, ">$dstfile")){
	die "\nCannot open $dstfile for writing: $!\n";
    }
    &generate("$srcfile", $title);
    close (STDOUT);

    printf STDERR "done\n\n" if $verbose==1;


}

sub process_src_files
{
    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	&process_file($srcfiles[$filenumber], $dstfiles[$filenumber]);
    }
}

sub open_headings_to_level
{
    local ($hlevel) = @_;
    for (; $headinglevel<$hlevel; $headinglevel++){
	print "  " x ($headinglevel+1), "<DL>\n";
    }
}

sub close_headings_to_level
{
    local ($hlevel) = @_;
    #print STDERR "close_headings_to_level($hlevel): headinglevel=$headinglevel\n";
    for (; $headinglevel>$hlevel; $headinglevel--){
	print "  " x ($headinglevel), "</DL>\n";
    }
}

sub print_toc
{

    local ($headinfo, $link, $heading, $headnum, $hlevel);

    #print STDERR "\nheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @headings);
    #print STDERR "\n++++++++++++++++++++\n";


    print<<EOT;
<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
<DT><A HREF="$tocfile#_toc"><B>Contents</B></A><DD>
  <DL>
EOT
    
    if ($do_program_list){
	print "    <DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
    }
    if ($do_figure_list){
	print "    <DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
    }
    $headinglevel = 1;
    for ($headnum=0; $headnum<=$#headings; $headnum++){
	local ($b1, $b2) = ("", "");
	$headinfo = $headings[$headnum];
	($heading, $link) = split("\@", $headinfo);
	# Find heading level for link 
	$link =~ m/\#H([1-6])_/i;
	$hlevel = $1;
	if ($hlevel>$headinglevel){
	    &open_headings_to_level($hlevel);
	} elsif ($hlevel<$headinglevel){
	    &close_headings_to_level($hlevel);
	}
	if ($headinglevel==1){
	    $b1 = "<B>";
	    $b2 = "</B>";
	}
	print "  " x ($headinglevel), "<DT><A HREF=\"$link\">$b1$heading$b2</A><DD>\n";
    }
    &close_headings_to_level(1);

    print_interface_toc("");

    print<<EOT;
  <DT><A HREF="$indexfile"><B>Index</B></A><DD>
    <DL>
EOT
    local ($i, $ch);
    for ($i=65; $i<=90; $i++){
        $ch = sprintf ("%c", $i);
        if ($caps{$ch}){
            print "    <A HREF=\"$indexfile\#_$ch\">$ch</A> &nbsp; \n";
        } else {
            # no indices starting with $ch
            print "    <SPAN CLASS=disabled>$ch</SPAN> &nbsp; \n";
        }
    }
    print<<EOT;
    </DL>
  <DT><A HREF="$pdf"><B>PDF</B></A><DD>
  </DL>
</DL>
</DIV>
EOT

}

sub generate_toc_page
{
    printf STDERR "\nWriting title page $tocfile ... " if $verbose==1;
    open (STDOUT, ">$tocfile") || die "\nCannot open $tocfile for writing: $!\n";
    &print_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<P>
<CENTER>
<B>
Mj&oslash;lner Informatics Report<BR>
$mia<BR>
$date</B>
<P>
</CENTER>
EOT

    &print_toc;

    print<<"EOT";
<TABLE align=center border=1 cellpadding=3>
<TR><TD align=center>
<DIV style="font-size: smaller">
<A HREF="../copyright.html">Copyright &#169;</A> $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mj&oslash;lner Informatics
</DIV>
</TD></TR>
</TABLE>
<P></P>
EOT
    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub read_and_abstract_beta
{
    local ($betafile, $htmlfile) = @_;
    local ($was_blank);

    $betaline = &read_file("$betafile");

    # single-line editing.
    $betaline =~ s/<<.*\bOBJECTDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDOPART\b.*>>/.../gi;    
    
    # Uppercase inner
    $betaline =~ s/\bINNER\b/INNER/gi;
    # Remove trailing blanks
    $betaline =~ s/^(.*)\s*$/$1\n/;
    
    # Squeze multiple blank lines down into one
    # next if /\S/ ? ($was_blank=0) : $was_blank++;
    

    # Now perform multiline editing
    if ($special_headers){
	$betaline = &parse_special_header($betaline, $htmlfile);
    }

    # delete RCS/CVS stuff
    $betaline =~ s/\$\Revision:[^\$]*\$//s;
    $betaline =~ s/\$\RCSfile:[^\$]*\$//s; 
    $betaline =~ s/\$\Date:[^\$]*\$//s;
    $betaline =~ s/\$\Author:[^\$]*\$//s;

    $betaline =~ s/\bdo\s*\.\.\./do .../gis;
    $betaline =~ s/\bINNER(;?)\s*\.\.\./INNER$1 .../gs;
    #$betaline =~ s/do\b\s*/do /gis; # No contracts do' ' in comments too
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s*\#\)/\(\# do INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do INNER$1 ... \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s*\#\)/\(\# do ... INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do ... INNER$1 ... \#\)/gs;
    $betaline =~ s/(:< *)\s*\(\#(.*)\#\);?/$1(\#$2\#);/gs;
    $betaline =~ s/\.\.\.  /... /gs;

    # Delete other lines containing the word "private" or the word "implpart"
    #$betaline =~ s/.*private.*\n+//gi;
    $betaline =~ s/.*implpart.*\n+//gi;

}

sub generate_int_title
{
    local ($betafile) = @_;
    local ($inttitle) = ucfirst(&strip_extension(&strip_path("$betafile"))) . " Interface";

    # Add number for title
    $inttitle = "" . $num_h[1] . "." . ++$num_h[2] . " " . $inttitle;
    return $inttitle;
}

sub generate_interface_file
{
    local ($betafile, $htmlfile) = @_;
    local ($inttitle) = &generate_int_title($betafile);

    printf STDERR "\nMaking $htmlfile\n  from $betafile ... \n" if $verbose==1;
    &read_and_abstract_beta($betafile, $htmlfile);

    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";

    local ($up) = &countdirs($htmlfile); # $htmlfile assumed being local path
    print_interface_header($inttitle, $up);
    print<<EOT;
<H1>$inttitle</H1>
<PRE CLASS=interface>
EOT

    $_ = $betaline;		

    # Mark '(#', '#)' and ':' in comments to avoid interference with
    # subsequent matchings.

    $after = $_;			# in case of no comments at all
    $betaline = "";

    printf STDERR "Substituting special symbols...\n" if $debug;
    
    while ( /\(\*|\*\)/ ) {
	$before = $`;
	$match  = $&;
	$after  = $';
	if ( $match eq '*)' ) {
	    $before =~ s/:/\001/g;
	    $before =~ s/\(\#/\002/g;
	    $before =~ s/\#\)/\003/g;
	}
	$betaline .= $before.$match;
	$_ = $after;
    }
    $_ = $betaline.$after;
    
    # Substitute ':' in slots with \004
    s/(\<\<\s*SLOT\s*\w+\s*):(\s*\w+\s*\>\>)/$1\004$2/gi;
    
    # Substitute ':' in fragmentIds with \004
    #   (assumes entire fragment syntax on one line - I think)
    s/(\-\-+\s*\w+\s*):(\s*\w+\s*\-\-+)/$1\004$2/g;
    
    # quote HTML
    s/&/\008/g;
    s/</\021/g;
    s/>/\022/g;
    
    # Run through $_, matching for pattern-begin and pattern-end, while
    # keeping track of scope level.
    # Insert nested index-information for declarations at the outermost
    # $scope levels.
    $scope  = 2;

    $patterns = "";
    $revpatterns = "";
    $level  = 1;
    $betaline = "";
    $prefix = "";

    printf STDERR "Searching for idx-comments/patterns/colons .....\n" if $debug;
    if   (! m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	printf STDERR "  None found - emitting without markup\n" if $debug;
	$betaline = $_;
    }
    while(m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	$before = $`;
	$match  = $&; 
	$idxop  = $1; $idxlev = $2; # if index information present
	$after  = $';
	if ( "$idxop" ne "" ) {
	    # index pseudo comment found
	    if ( "$idxop" eq "+" ) { $scope++; }
	    elsif ( "$idxop" eq "-" ) { $scope--; }
	    if ( "$idxop" eq "=" || "$idxop" eq "\001" ) {
		if ( "$idxlev" eq "" ) {
		    print "No level specified in idx= command";
		    return;
		}
		$scope = $idxlev;
	    }
	    $match = ""; # delete comment
	    $after = "\n".$after;
	    # $match = "\nINDEXLEVEL: $scope\n";
	}
	elsif ( "$match" eq "(#" ) {
	    # add previously found identifier in scope description
	    if ( "$patternid" ne "" ) {
		$patterns .= "$patternid.$level:";
		printf STDERR "***  %s\n", $patternid if $trace==1;
	    } else {	
		if (($htmlfile eq "betaenv.html") && ($level == 1)){
		    $patterns .= "betaenv.1:";
		    printf STDERR "  BETAENV\n" if $trace==1;
		} else {
		    $patterns .= "ANONYMOUS.$level:";
		    printf STDERR "  ANONYMOUS\n" if $trace==1;
		}
	    }
	    $level += 1;
	    $patternid = "";
	    # $match = "BEGIN";
	    # $match = "\n[PATTERNS: $patterns]\n";
	}
	elsif ( "$match" eq "#)" ){	
	    # check if $before ends with "#".
	    if ( ($before =~ /\#$/ ) && ( ! ( $before =~ /\#\#$/ ) ) ) {
		# found something like 
		#   "... ->F##)
		# i.e. a pattern variable at end of a parenthesed
		# evaluation.
		# This is NOT a pattern end!
		printf STDERR "\n******* NOTICE: In the text ending like this:\n";
		printf STDERR substr($betaline.$before.$match, -100, 100);
		printf STDERR "\n******* the '##)' is not considered a pattern end.";
		printf STDERR "\n******* Please check if this is correct.\n\n";	
		# Just precede.
	    } else {
		# This is really a pattern end
		$level -= 1;
		if ( $patterns =~ m/:\w+.\w+:$/ ) {
		    $patterns = $`.":";
		}
		elsif ( $patterns =~ m/^\w+.\w+:$/ ) {
		    $patterns = "";
		} else {
		    $betaline .= $before.$match;
		    print "*** PATTERNS is wrong: $patterns";
		    print "*** context:";
		    print "\n------------\n";
		    print substr($betaline, -100,100);
		    print "\n------------\n";
		}
		# $match .= "\n[PATTERNS: $patterns]\n";
	    }
	}
	elsif ( $match =~ m/:/ )  { # a colon was found
	    if ( $level <= $scope ){
		# Identifiers must start with alpha or _.
		# In betaenv, there is "exit T[1:lgth], which would
		# cause 1: to be identified as identifier.
		# However, if [a-zA-Z_] is used instead of \w,
		# the "[1:" does not get into the output (:-(
		if ( $before =~ m/(\w+[\w\s,]*)\s*$/ ) {
		    $head = $`;
		    @ids = split( ',' , $1); # list of identifiers, e.g.: x, y, z
		    $tail = "";
		    $prefix = "";
		    if ( $after =~ m/^\s*\(\*/ ) {
			# move comment after colon but before prefix from $after to $tail
			$tail = $&;            # the stuff matched by the regexp
			$after = $';           # the stuff after the match
			$after =~ m/\*\)\s*/;  # MUST succeed if comment matches
			$tail .= $`.$&;        # the stuff before the last match and the match itself
			$after = $';           # the stuff after the match
		    }
		    
		    if ( $after  =~ m/^\s*(\w+)\s*\(\#/ ) { 
			$prefix = $1;
		    } else {
			# the match for prefix failed.
			# look ahead and check if there was a comment after the prefix
			# and try the match again.
			# don't change $tail or $after (historical: superpattern index generation)
			if ( $after =~ m/^\s*(\w+)\s*\(\*/ ) {
			    # there was a comment after the word after the colon
			    $possibleprefix = $1;
			    # set $peekafter to the stuff after the match, i.e. start of comment text
			    $peekafter = $';
			    $peekafter =~ m/\*\)\s*/;  # MUST succeed if comment matches
			    # set $peektext to the stuff after the match, i.e. what's after the comment
			    $peekafter = $';           
			    if ( $peekafter  =~ m/^\s*\(\#/ ) {
				# there was a pattern-begin after the comment
				$prefix = $possibleprefix; 
			    }
			}
		    }
		}
		
		$marker = $match;
		$match = "";

		if ( @ids == 1 ) {
		    # keep identifier for next "(#" found
		    $patternid = $ids[0];
		    $patternid =~ s/\s//g;
		} else {
		    $patternid = "";
		}

		$before = $head;
		foreach $id ( @ids ) {
		    #print STDERR "IDS: @ids\n";
		    $id =~ m/(\w+)/; # MUST succeed
		    $anchor += 1;
		    $idxid = "$1.$level"; # $id without whitespace.
		    $idxid .= "($anchor)";
		    if (&legal_identifier($id)){
			$bid = "<SPAN CLASS=INDEXED TITLE=Indexed>$id</SPAN>";
		    } else {
			$bid = $id;
		    }
		    $idxid2 = $idxid;
		    #$idxid2 =~ s/\(\d+\)$//;
		    #$idxid2 =~ s/\./_/g;
		    $patterns2 = $patterns;
		    #$patterns2 =~ s/\./_/g;
		    if ( "$patterns2" eq "" ){
			$before .= "$bid<A name=\"$idxid2\"></A>";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "111. {$idxid2\@$htmlfile}\n";
		    } else { 
			# inner scope
			$before .= "$bid<A name=\"$patterns2$idxid2\"></A><A name=\"$idxid2\"></A>";
			#print STDERR "222. {$idxid2\@$htmlfile}\n";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "333. {$patterns2$idxid2\@$htmlfile}\n";
			push (@index, "$patterns2$idxid2\@$htmlfile");
		    } # inner scope
		    $before .= ",";
		} # foreach id
		$before =~ s/,$//;
		$before .= $marker.$tail;
	    } # $level <= $scope
	} # colon was found
	else {
	    print "Something is wrong in while loop !!!";
	    return;
	} # "switch" on $match finished
	
	$betaline .= $before.$match;
	$_ = $after;
    } # while

    $_ = $betaline."\n";

    printf STDERR "Cleaning up...\n" if $debug;

    # Clean up
    s/\001/:/g;
    s/\002/\(\#/g;
    s/\003/\#\)/g;
    s/\004/:/g;
    s/\005/</g;
    s/\006/>/g;
    s/\007/&/g;
    s/\008/&amp;/g;
    s/\021/&lt;/g;
    s/\022/&gt;/g;

    printf STDERR "Writing interface ... " if $debug;
    print;
    
    print<<EOT;
</PRE>
EOT
    print_trailer("$inttitle", $up, $betafile);

    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub parse_int_chap
{
    local ($heading) = @_;
    local ($headnum, $intpath);

    $heading =~ m%^(\d+) (.*)$%;
    $headnum = $1;
    $intpath = &trim_path($2);
    $heading = &strip_path($intpath);
    if ($heading eq "interface"){
	$heading = "Interface Descriptions";
    } else {
	$heading = ucfirst($heading) . " Interface";
    }
    $heading = "$headnum $heading";

    return ($heading, $intpath);
}

sub print_interface_toc
{

    local ($prefix) = @_;

    local ($headinfo, $link, $heading, $headnum, $intpath);
    local ($h);

    #print STDERR "\nintheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#intsrcfiles>1){
	foreach $headinfo (@intheadings){
	    ($heading, $link) = split("\@", $headinfo);
	    if ($link eq ""){
		# Found new interface chapter
		($heading, $intpath) = &parse_int_chap($heading);
		next if ($intpath !~ m%^$prefix%);
		# close previous chapter(s)
		&close_headings_to_level(1);
		$headinglevel = 1;
		#print STDERR "\nInterface chapter: $heading\n";
		$link = &strip_prefix("$intpath/index.html", $prefix);
		print "    ", "<DT><A HREF=\"$link\"><I><B>$heading</B></I></A><DD>\n";
		print "    <DL>\n";
	    } else {
		if ($prefix ne ""){
		    #print STDERR "link: $link, prefix: $prefix\n";
		    next if ($link !~ m%^$prefix%);
		    $link = &strip_prefix($link, $prefix);
		}
		$headinglevel = 2;
		print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	    }
	}
	# terminate last interface chapter(s)
	&close_headings_to_level(1);
	$headinglevel = 1;
    }

}

sub generate_interface_toc_page
{
    local ($intfilenumber, $inttocdir, $title) = @_;
    local ($inttocfile) = "$inttocdir/index.html";
    local ($up) = &countdirs($inttocfile);
    printf STDERR "\nWriting interface toc page $inttocfile ... " if $verbose==1;
    open (STDOUT, ">$inttocfile") || die "\nCannot open $inttocfile for writing: $!\n";
    &print_interface_toc_header($title, $up, $intfilenumber);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_interface_toc($inttocdir);

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, $up, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub build_intheadings
{
    local (@old_num_h) = @num_h;
    # Build @intheadings. Needed before generations because of Next-links
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # Special case used to force a new interface chapter
	    $num_h[1]++;
	    $num_h[2] = $num_h[3] = $num_h[4] = $num_h[5] = $num_h[6] = 0;
	    #print STDERR "\npush(\@intheadings, $num_h[1] $intdstfile\@)\n";
	    push (@intheadings, "$num_h[1] $intdstfile\@");
	} else {
	    local ($inttitle) = &generate_int_title($intsrcfile);
	    push (@intheadings, "$inttitle\@$intdstfile");
	}
    }
    @num_h = @old_num_h;
}

sub process_interface_files
{
    local ($intheading);

    return if ($#intsrcfiles<=0);

    printf STDERR "Generating %d interface descriptions...\n", $#intsrcfiles+1  if $verbose;

    &build_intheadings;

    #print STDERR "intheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";
    
    # Generate interface files
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # new interface chapter
	    $num_h[1]++;
	} else {
	    &generate_interface_file($intsrcfile, $intdstfile);
	}
    }
    
    # Generate interface toc pages
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($headinfo) = $intheadings[$filenumber];
	local ($heading, $link) = split ("\@", $headinfo);
	local ($intdstfile);
	if ($link eq ""){
	    # Found interface chapter heading
	    # print STDERR "Found interface chapter heading: \n\t$heading\n";
	    ($heading, $intdstfile) = &parse_int_chap($heading);
	    &generate_interface_toc_page($filenumber, $intdstfile, $heading);
	} 
    }
}


sub print_index_toc
{
    local ($i, $ch);
    print "<HR>\n<DIV style=\"text-align:center\">\n";
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	if ($caps{$ch}){
	    print "<STRONG><A HREF=\"#_$ch\">$ch</A></STRONG> &nbsp; \n";
	} else {
	    # no indices starting with $ch
	    print "<STRONG CLASS=disabled>$ch</STRONG> &nbsp; \n";
	}	    
    }
    print "<HR>\n</DIV>\n\n";
}

sub calculate_index()
{
    #print STDERR "index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "++++++++++++++++++++\n";

    # Sort index ignoring case
    @index = sort {lc($a) cmp lc($b)} @index;
    local ($prev_id, $prev_no, $initial_ch, $htmlfile, $i, %entries);

    local ($italic, $itaend) = ("", "");

    #print STDERR "sorted index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "++++++++++++++++++++\n";

    $html_index = "";
    $prev_id = "";
    $prev_no = 1;

    for($i = 0; $i <= $#index; $i++) {
	# delete traling file name (after '@')
	$index[$i] =~ s/(.+)\@(.+)/$1/;
	# save target file name
	$htmlfile = $2;
	$_ = $index[$i];

	
	# In foo.1 delete .1
	s/\.(\d+)//g;
	if ($1 eq "0"){
	    # Last .N was a .0:
	    # Reference to src file (not interface file)
	    $is_src = 1;
	    #print STDERR "$_ is src\n";
	} else {
	    # Reference to interface file
	    $is_src = 0;
	    # In betaenv: exit T[1:lgth] is taken to be
	    # an identifer with name 1. Prevent this.
	    if (!&legal_identifier($_)){
		printf STDERR "skipped illegal identifier: $_\n" if $verbose;
		next;
	    }
	}
	# delete other numbers (?) 
	s/\(\d+\)//g;
	# walk through scopes
	while ( m/[ :](\w+)\.(\d+)[:\}]/ ) {
	    $id = $1; $level = $2;
	    $indents = $indent x ($level-1);
	    s/([ \:])$id\.$level([\:])/$1$indents$id$2/;
	}
	
	# Generate caps heading at first occurrence of a letter.
	$initial_ch = substr($index[$i], 0, 1);
	if ("$initial_ch" eq "\007"){
	    # Quoted special character like &szlig;
	    $index[$i] =~ m/^(\007[a-zA-Z]+;)/;
	    $initial_ch = $1;
	} else {
	    $initial_ch = ucfirst (substr($index[$i], 0, 1));
	}
	if (! $caps{$initial_ch} ){
	    $html_index .= "</DIV>\n";
	    $html_index .= "<H2><A name=\"_$initial_ch\">";
	    $html_index .= &quote_html($initial_ch);
	    $html_index .= "<\/A><\/H2>\n";
	    $html_index .= "<DIV CLASS=index>\n";
	    $caps{$initial_ch} = 1;
	}

	# Block levels are present as such in the entries:
	#   foo:
	#     (# bar:
	#          (# kuk: 
	#               (# ... #)
	#          #)
	#     #);
	#
	# Index entries:
	#    foo
	#    foo:bar
	#    foo:bar:kuk
	#
	# Should print as this:
	#    foo
	#      bar
	#       kuk
	#
	
	# print STDERR "$index[$i]\n";

	# Handle ANONYMOUS especially
	if ($_ =~ m/^ANONYMOUS:/){
	    if (!$entries{"ANONYMOUS"}){
		print STDERR "Treating ANONYMOUS specially\n" if $verbose;
		$html_index .= "<BR>\n" . "&nbsp;"x(4) . "<I>Anonymous pattern</I>";
		$entries{"ANONYMOUS"} = 1;
	    }
	}
	# Handle betaenv specially
	if ( ($index[$i] =~ m/^betaenv.1/) && ($htmlfile eq "betaenv.html")){
	    if (!$entries{"betaenv"}){
		print STDERR "Treating betaenv specially\n" if $verbose;
		$html_index .= "<BR>\n" . "&nbsp;"x(4) . "<I><A HREF=\"betaenv.html\">betaenv</I></A>";
		$entries{"betaenv"} = 1;
	    }
	}
	if ($_ =~ m/(.*):([^:]+)/){
	    # Scopes present
	    $scopes = $1;
	    $id = $2;
	    # We are in a specific scope. There cannot be identical index entries
	    # here (BETA semantic error!). So no need to check for prev_id.
	    $prev_id="";
	    $prev_no=0;
	    if ($entries{$scopes}){
		# foo:bar already emitted
		$html_index .= "<BR>\n";
		# indent with double-spaces
		$html_index .= "&nbsp;"x(2*(2+&num_chars(':', $scopes)));
		$html_index .= "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		$entries{$_} = 1;
	    } else {
		$html_index .= "Index Error: $_ ($scopes) ($id)<BR>\n";
	    }
	} else {
	    # No scopes present
	    if ($is_src){
		# Things like "<program>" may be indexed in src files
		$_ = &quote_html(&unquote_colon("$_"));
	    }
	    $id = $_;
	    if ($prev_id eq $id){
		# Second or more occurrence of $id
		$prev_no++;
		if (!($prev_no % 10)){
		    # break line of references
		    $html_index .= "<BR>\n" . "&nbsp;"x(2);
		}
		if ($is_src){
		    $html_index .= "&nbsp;<A href=\"$htmlfile\"><B>[" . $prev_no . "]</B></A>";
		} else {
		    $html_index .= "&nbsp;<A href=\"$htmlfile\#" . $index[$i] . "\">${italic}[" . $prev_no . "]$itaend</A>";
		}
	    } else {
		$prev_no=1;
		$html_index .= "<BR>\n";
		if ($is_src){
		    $html_index .= "&nbsp;"x(2) . "<A href=\"$htmlfile\"><B>" . $id . "</B></A>";
		} else {
		    $html_index .= "&nbsp;"x(2) . "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		}
		$prev_id = $id;
	    }
	    $entries{$_} = 1;
	}
    }
}

sub generate_index_page
{
    return if ($#index<0);
    printf STDERR "\nMaking index page $indexfile ... " if $verbose==1;
    open (STDOUT, ">$indexfile") || die "\nCannot open $indexfile for writing: $!\n";
    &calculate_index();
    print_index_header("$title: Index");
    print<<EOT;
<H1>Index</H1>
The entries in the alphabetic index consists of selected words from the
body files of this manual - these are in <B>bold</B> font - as well as the
identifiers defined in the public interfaces of the libraries 
- set in regular font.
<BR>
In the manual, the identifiers, which can be found in the index
are <SPAN CLASS=INDEXED>typeset like this</SPAN>. This can help localizing the
identifier, when the link from the index if followed - especially in the case
where the browser does not scroll the line to the top, e.g. because there
is less than a page of text left. 
<BR>
The small table of letters below links directly to the section of identifiers
starting with the corresponding letters. 
EOT
    #print "The table is also present in the navigation bar to the left.\n";
    print "<P>\n";
    &print_index_toc;
    print "<DIV CLASS=index>\n";
    print $html_index;
    print "</DIV>\n";
    print_trailer("$title: Index", 0, "");
    close(STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub print_program_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nprograms:++++++++++++++++++++\n";
    #print STDERR join ("\n", @programs);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#programs>=0){
	print "    ", "<DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#programs; $headnum++){
	    $headinfo = $programs[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_program_list_page
{
    local ($title) = "List of Programs";
    local ($next, $nexttip);
    if (!$do_program_list){ 
	return;
    }
    printf STDERR "\nWriting list of programs to $programsfile ... " if $verbose==1;
    open (STDOUT, ">$programsfile") || die "\nCannot open $programsfile for writing: $!\n";
    if ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, $tocfile, "Table of Contents", $next, $nexttip, 0);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_program_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub print_figure_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nfigures:++++++++++++++++++++\n";
    #print STDERR join ("\n", @figures);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#figures>=0){
	print "    ", "<DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#figures; $headnum++){
	    $headinfo = $figures[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_figure_list_page
{
    local ($title) = "List of Figures";
    local ($prev, $prevtip, $next, $nexttip);

    if (!$do_figure_list){ 
	return;
    }
    printf STDERR "\nWriting list of figures to $figuresfile ... " if $verbose==1;
    open (STDOUT, ">$figuresfile") || die "\nCannot open $figuresfile for writing: $!\n";
    
    if ($do_program_list){
	$prev = $programsfile;
	$prevtip = "List of Programs";
    } else {
	$prev = $tocfile;
	$prevtip = "Table of Contents";
    }
    $next = $dstfiles[0];
    $nexttip = $next;
    &print_header($title, $prev, $prevtip, $next, $nexttip, 0);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_figure_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub filter_for_pdf
{
    local ($file, $distfile) = @_;
    local ($contents);
    local ($done, $before, $match, $after, $number, $i);

    #print STDERR "filter_for_pdf($file, $distfile)\n";

    #print STDERR "rename_file($file, $distfile)\n";
    &rename_file($file, $distfile);
    #print STDERR "read_file($distfile)\n";
    $contents = &read_file($distfile);

    ### This eats too much because it matches from start of first
    ### script to end of last.
    # $contents =~ s%\<SCRIPT.+\<\/SCRIPT\>%%gsi;
    #
    # However it suffices to filter out <LAYER> ... </LAYER>
    $contents =~ s%\<LAYER.+\<\/LAYER\>%%gsi;

    # We might as well filter out <LINK REL=...> too
    # Hmm, no - removes style sheet too.
    # $contents =~ s%\<LINK REL=[^>]+>%%gi;

    # And htmldoc has problems with &COPY; / &#169;
    # No - not htmldoc 1.8.8
    #$contents =~ s%\&COPY;%(C)%gi;
    #$contents =~ s%\&\#169;%(C)%gi;
    # However, the copyright file is not present as part of pdf
    # Remove link:
    $contents =~ s%<A HREF="[./]*copyright.html">&#169;</A>%&#169;%gi;

    # Remove modification notices
    $contents =~ s&\<TD width\=\"40\%\" align\=\"right\">\s*\<DIV STYLE=\".+\"\>\[Modified:[^\]]+\]\s*</DIV>\s*</TD>&&gsi;
    $contents =~ s&\<TD width\=\"40\%\" align\=\"right\">\s*\<DIV STYLE=\".+\"\>\[Generated:[^\]]+\]\s*</DIV>\s*</TD>&&gsi;
    # Then the middle column of the footer may be 50% and right aligned:
    $contents =~ s&<TD width="20%" align="center">&<TD width="50%" align="right">&gi;
    # And the left column may be 50%:
    $contents =~ s&<TD width="40%" align="left">&<TD width="50%" align="left">&gi;

    #print STDERR "open($file)\n";
    open (STDOUT, ">$file") || die "Cannot open $file for writing: $!\n";
    print $contents;
    close STDOUT;
}

sub generate_pdf
{
    local ($cmd, $v) = ("", "");
    local (@sequence) = ();
    if ($skippdf){
	print STDERR "Skipping PDF generation (-p option)\n" if $verbose;
    } else {
	if ($pdf eq ""){
	    $pdf = $book_file_name;
	    $pdf =~ s/\.book$/.pdf/;
	}
	&generate_pdf_titlepage();
	# Construct list of generated files
	push @sequence, $pdftitlefile;
	if ($do_program_list){
	    push @sequence, $programsfile;
	}
	if ($do_figure_list){
	    push @sequence, $figuresfile;
	}
	push @sequence, @dstfiles;
	foreach $f (@intdstfiles){
	    # Ignore intdst directories
	    push @sequence, $f if (-f $f);
	}
	push @sequence, $indexfile if (-f $indexfile);

	# htmldoc does not handle <script>...</script> too well
	# We filter it out in copies of the files in sequence
	foreach $f (@sequence){
	    &filter_for_pdf($f, "$f-dist")
	}

	# run htmldoc
	$v = "-v" if $verbose;
	$cmd = "$htmldoc $v -t pdf -f $pdf --toclevels 4 --bodycolor \#ffffff --size A4 --left 1.0in --right 0.5in --top 0.5in --bottom 0.5in --header .t. --footer h.1 --tocheader .t. --tocfooter l.i --firstpage p1 --compression=9 --fontsize 11.0 --fontspacing 1.2 --headingfont Helvetica --bodyfont Helvetica --headfootsize 11.0 --headfootfont Helvetica " . join (' ', @sequence);

	print STDERR "Generating $pdf\n" if ($verbose);
	print STDERR "$cmd\n" if $debug;
	$ENV{'LD_LIBRARY_PATH'} = "/usr/local/lib";
	if (system("$cmd")!=0){
	    print STDERR "***Error in htmldoc execution!\n";
	    print STDERR "   Generation of PDF requires the program htmldoc to be\n";
	    print STDERR "   executable via your path.\n";
	    print STDERR "   It must be version 1.8.8 or later.\n";
	    print STDERR "   You may download htmldoc from\n\tftp://ftp.easysw.com/pub/htmldoc/\n";
	};
	unlink @sequence;
	foreach $f (@sequence){
	    if ($f eq $pdftitlefile){
		unlink "$f-dist";
	    } else {
		&rename_file("$f-dist", $f);
	    }
	}
	if (-f $pdf){
	    print STDERR "Wrote $pdf\n" if $verbose;
	} else {
	    print STDERR "\n***FAILED to generate $pdf!\n\n";
	}
    }
}

sub generate_pdf_titlepage()
{
    open STDOUT, ">$pdftitlefile" || die "Cannot open $pdftitlefile for writing: $!\n";
    &print_header("$mia: $title", "", "", "", "", 0);
    print<<"EOT";
<H1>Copyright Notice</H1>
<center><B>
Mjlner Informatics Report<BR>
$mia<BR>
$date
</B>
<P>
<TABLE border=1 cellpadding=3>
<TR><TD align=center>
Copyright &#169; $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mjlner Informatics
</TD></TR>
</TABLE>
</center>
<HR BREAK>
</BODY>
</HTML>
EOT

    close STDOUT;
}

### main #######

# variables
&set_default_variable_values();

&read_command_line();

if ($book_file_name eq ""){
    print STDERR "Processing single file \"$ARGV[0]\"\n" if $verbose;
    @srcfiles = ($ARGV[0]);
    &generate($ARGV[0], "PREVIEW");
} else {
    &read_book_file;
    &process_src_files;
    &process_interface_files;
    &generate_program_list_page;
    &generate_figure_list_page;
    &generate_index_page;
    &generate_toc_page;
    &generate_pdf;

}
