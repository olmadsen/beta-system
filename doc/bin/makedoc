#!/usr/local/bin/perl -s

# use strict;

sub usage
{
    print STDERR "usage: makedoc [-f] [-p] [-h] [-s] [-i] [-e] [-v] [-d] <manual>.book | <file>.html\n";
    print STDERR "  -f   use full urls in HREFs (http://www.mjolner.com/...)\n";
    print STDERR "  -p   do not generate PDF\n";
    print STDERR "  -x   no index file\n";
    print STDERR "  -h   print this summary\n";
    print STDERR "  -s   split interface files at special comments\n";
    print STDERR "  -i   ignore errors (don't stop after errors)\n";
    print STDERR "  -e   treat warnings as errors (i.e. stop after warning)\n";
    print STDERR "  -v   verbose output\n";
    print STDERR "  -d   debug makedoc script\n";
    print STDERR "  If .book file is given as argument, a full manual set is generated.\n";
    print STDERR "  If a single HTML file is given as input, that file is preprocessed.\n";
    exit(1) unless $ignoreerrors;
}

# TODO:
#   use strict and -w, and define remaining global variables below.
#   Fix titles for src-generated files (OK for intsrcfiles)
#   Fix prev/next TITLE for src-generated files (OK for intsrcfiles)
#   Eliminate global $filenumber
#   Continuation indications in all but first column in index 'foo, continued'.
#   Handle Appendix headings specially: No numbering.
# IDEAS:
#   Possibly a CAP attribute for INX (to appear in index instead of indexed word)?
#   remove trailing numbers from interface index anchors?
#   print.html to supplement PDF? Problem with internal links).


# Global variables
# arrays
my @srcfiles = ();         # array of file names from src subdirectory
my @srcdirs  = ();         # array of src dir names
my @dstfiles = ();         # array of file names to store output files in
my @dstdirs  = ();         # array of dst dir names
my @intsrcfiles = ();      # array of file names to convert to interface files
my @intdstfiles = ();      # array of file names to store output interface files in
my @programs = ();         # used to build list of programs
my @figures = ();          # used to build list of figures
my @headings = ();         # used to build table of contents
my @intheadings = ();      # used to build interface descriptions part of table of contents
my @index;                 # used to build index
undef @index;
my @num_h = (0,0,0,0,0,0); # array of occurrences of headings 1 to 6
my %caps;
undef %caps;
my $noindex = 0;           # No index present

# Variables that may be set by ../build
$skippdf        = 0  if (!defined($skippdf));
$book_file_name = "" if (!defined($book_file_name));
$verbose        = 0  if (!defined($verbose));
$debug          = 0  if (!defined($debug));
$ignoreerrors   = 0  if (!defined($ignoreerrors));
$errorwarnings  = 0  if (!defined($errorwarnings));

# Other variables
my $numinxcolumns = 3;     # Number of columns in alphabetic index
my $src = "src/";
my $dst = "";
my $intsrc = "";
my $intdst = "";
my $filenumber = 0;        # used to index @srcfiles and @headings
my $num_beta   = 0;        # Number of occurences of <BETA LIST> 
my $num_fig    = 0;        # Number of occurences of <FIG>
my $num_foot   = 0;        # Number of occurences of <FOOTNOTE>
my $foot_ruler_done   = 0; # Has a footnote ruler been generated for page?
my $num_inx    = 0;        # Number of occurences of <INX>
my $headinglevel      = 0;        # Current heading level
my $srcline    = "";       # Used to read files from src directory into
my $full_length = 0;       # length of (unexpanded) src/int files
my $special_headers = 0;
my $insert_validhtml40 = 0;
my $fullpath   = 0;
my $css =                "../style/miadoc.css";
my $jsdir =              "../javascript";
my $imagedir =           "../images";
my $mainfile =           "../index.html";
my $tocfile =            "index.html";
my $indexfile =          "inx.html";
my $programsfile =       "programs.html";
my $figuresfile =        "figures.html";
my $pdftitlefile =       "pdftitle.html";
my $do_program_list = 0;
my $do_figure_list = 0;
my $leftmargin=25;
my $tab_width = 8;
my $htmldoc="htmldoc";

# Variables used by grammar processing only
my @gramfiles = ();

sub set_default_variable_values
{
    if ($fullpath){
	local $url = "http://www.mjolner.com/mjolner-system/documentation";
	$css = "$url/style/miadoc.css";
	$jsdir = "$url/javascript";
	$imagedir = "$url/images";
	$mainfile = "$url/index.html";
    }
    if (-d "/users/beta/GNU/bin/sun4s/"){
	$ENV{'PATH'} .= ":/users/beta/GNU/bin/sun4s/";
	$ENV{'LD_LIBRARY_PATH'} .= ":/usr/local/lib:/users/beta/GNU/bin/sun4s/";
    }
}

sub read_file_with_length
{
    local ($filename) = @_;
    local ($line, $filelength);
    if (!open(FILE, "$filename")){
	print STDERR "***Cannot open $filename for reading: $!\n";
	exit 1 unless $ignoreerrors;
    }

    $line="";
    $filelength = 0;
    while (<FILE>) {
	$filelength += length($_);
	$line .= &untabify($_);
    };
    close (FILE);
    return ($line, $filelength);
}

sub read_file
{
    local ($filename) = @_;
    local ($line);
    if (!open(FILE, "$filename")){
	print STDERR "***Cannot open $filename for reading: $!\n";
	exit 1 unless $ignoreerrors;
    }

    $line="";
    while (<FILE>) {
	$line .= &untabify($_);
    };
    close (FILE);
    return ($line);
}

sub read_gif_dim
{
    local ($filename) = @_;
    local ($buffer,$header, $width, $height);
    open(GIF, "$filename") || die "***Cannot open GIF file $filename for reading: $!\n";
    binmode GIF;
    read GIF, $buffer, 10 || die "***Cannot read header of GIF file $filename: !$\n";
    close GIF;
    ($header, $width, $height) = unpack "A6 v2", $buffer;
    if ($header =~ /^GIF8[79]a$/) {
        return ($width, $height);
    } else {
        print STDERR "***$filename: Unknown GIF file format $header\n";
	return (0,0);
    }
}

sub read_png_dim
{
    local ($filename) = @_;
    local ($ihdr, $width_height,$header, $width, $height);
    local (@png_signature) = (137, 80, 78, 71, 13, 10, 26, 10);
    $width = $height = 0;

    open(PNG, "$filename") || die "***Cannot open PNG file $filename for reading: $!\n";
    binmode PNG;
    read PNG, $header, 8 || die "***Cannot read header of PNG file $filename: !$\n";
    read PNG, $ihdr, 8   || die "***Cannot read IHDR of PNG file $filename: !$\n";
    read PNG, $width_height, 8 || die "***Cannot read width&height of PNG file $filename: !$\n";
    
    close PNG;
    @header = unpack "C8", $header;
    if (@header != @png_signature){
	print STDERR "***$filename: Unknown PNG file format $header\n";
	return (0,0);
    } else {
	#print STDERR "$filename: PNG signature OK\n";
    }
    ($width, $height) = unpack "N2", $width_height;
    return ($width, $height);
}

sub rename_file
{
    local ($old, $new) = @_;
    rename $old, $new || die "Cannot rename file $old to $new: $!\n";
}

sub SmartMkdir {
    my ($path) = @_;
    my ($full) = '';
    foreach $dir (split '/', $path) {
	$full .= $dir . '/';
	if (!-d $full){
	    print STDERR "mkdir $full\n" if ($verbose);
	    if (!mkdir ($full, 0755)){
		print STDERR "Cannot create directory \"$full\": $!\n";
		return;
	    }
	}
    }
}
sub go_up
{
    local ($path, $up) = @_;

    if ($path eq ""){
	return $path;
    } elsif ($fullpath){
	return $path;
    } else {
	return "../" x($up) . $path;
    }
}

sub untabify
{
    local($line) = @_;
    while($line =~ /\011/)
    {
        $line =~ s/\011/" " x ($tab_width - (length($`) % $tab_width))/ge;
    }
    return $line;
}

sub expand 
{
    local ($path) = @_;
    while ($path =~ m/\$(\w+)/){
	local $var = $1;
	if (!defined($ENV{$var})){
	    print "Expand $path: Warning: $var not in environment\n";
	} else {
	    $path = $` . $ENV{$var} . $';
	}
    }
    return $path;
}

sub remove_tag()
{
    local ($tag) = @_;

    if ($tag =~ m/<.*<.*>/){
	print STDERR "Warning: unquoted '<' in tag:\n\t$tag";
    }
    return "";
}

sub untag
{
    local ($string) = @_;
    $string =~ s/(<[^>]+>)/&remove_tag($1)/sgoe;
    return $string;
}

sub quote_html
{
    local ($string) = @_;

    #print STDERR "quote: $string\n";
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    return $string;
}

sub unquote_html
{
    local ($string) = @_;

    #print STDERR "unquote: '$string' yields";
    $string =~ s/&gt;/>/g;
    $string =~ s/&lt;/</g;
    $string =~ s/&amp;/&/g;
    #print STDERR " '$string'\n";
    return $string;
}
  
sub quote_special
{
    local ($string) = @_;
    #print STDERR "quote_special: '$string' yields";
    # special feature used for quoting through index generation
    $string =~ s/&([a-zA-Z]+;)/\007$1/g;
    $string =~ s/:/;\006/g;
    #print STDERR " '$string'\n";
    return $string;
}


sub unquote_special
{    
    local ($string) = @_;
    # Used by index generation
    $string =~ s/\007([a-zA-Z]+;)/&$1/g;
    $string =~ s/;\006/:/g;
    return $string;
}

sub is_local 
{
    local ($file) = @_;
    # define locality to "./". Works for $file="../xxxx" too
    return (-f "./" . $file);
}

sub copy_file
{
    local ($from, $to) = @_;
    $to = "$to/" . &strip_path($from) if (-d $to);
    # FIXME: will link work on PC?
    #printf STDERR "from: %f\n", -M $from, "\n";
    #printf STDERR "to:   %f\n", -M $to, "\n";
    if ((! -f $to) || (-M $to > -M $from)){
	print STDERR "Copying file '$from'\n          to '$to'\n" if ($verbose);
	link $from, $to || die "Copy of '$from' to '$to' failed: $!\n";
    } else {
	print STDERR "NOT Copying file '$from'\n          to '$to'\n" if ($debug);

    }
}

sub strip_extension
{
    local ($string) = @_;
    if ( $string =~ m/([^\.]+)\..*/ ) {
	$string = $1;
    }
    return $string;
}

sub strip_prefix
{
    local ($path, $prefix) = @_;
    $path  = &trim_path($path);
    $refix = &trim_path($prefix);
    $path =~ s%^$prefix/%%;
    return $path;
}

sub strip_path
{
    local ($string) = @_;
    if ( $string =~ m%.*/([^/]+$)% ) {
	$string = $1;
    }
    return $string;
}

sub strip_dirs
{
    local ($path, $numdirs) = @_;
    $path = &trim_path($path);
    do{
	$path =~ s%^[^/]*/%%;
	$numdirs--;
    } while ($numdirs>0);
    return $path;
}

sub trim_path
{
    local ($path) = @_;
    # delete double slashes
    $path =~ s%//+%/%g;
    # delete trailing slash
    $path =~ s%/$%%;
    # delete initial ./
    $path =~ s%^\./%%;
    return $path;
}

sub countdirs
{
    local ($path) = @_;
    local $numdirs = 0;
    $path = &trim_path($path);
    $path =~ s%/%$numdirs++%ge;
    #print STDERR "numdirs($path)=$numdirs\n";
    return $numdirs;
}

sub legal_identifier

{
    local ($id) = @_;
    return ($id =~ m/[a-zA-Z_]\w*/);
}

sub num_chars
# Occurences of $ch in $string
{
    local ($ch, $string) = @_;
    local ($i, $num);
    $num=0;
    for ($i=0; $i<length($string); $i++){
	$num++ if (substr($string, $i, 1) eq "$ch");
    }
    #print STDERR "num_chars($ch, $string) = $num\n";
    return $num;
}

sub get_file_size
{
    local ($filename) = @_;
    local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	= stat($filename);
    if ($size>(1024*1024)){
	return sprintf "%.2fMb", $size/(1024*1024);
    }
    if ($size>1024){
	return sprintf "%.0fkb", $size/1024;
    }
    return sprintf "%d bytes", $size;
}

sub print_lastmod
{
    local ($filename) = @_;
    local @month_names = ("January","February","March","April","May","June","July","August","September","October","November","December");
    local @day_names   = ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday");
    local @sup = ();
    local ($sup_date, $lastmod, $prompt);
    if ($filename ne ""){
	local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	    = stat($filename);
	$lastmod = $mtime;
	$prompt = "Modified";
   } else {
	$lastmod = time;
	$prompt = "Generated";
    }
    local ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime($lastmod);
    $sup[1] = $sup[21] = $sup[31] = "st";
    $sup[2] = $sup[22] = "nd";
    $sup[3] = $sup[23] = "rd";
    if (($date==1)  || ($date==2)  || ($date==3) ||
	($date==21) || ($date==22) || ($date==23) ||
	($date==31)) {
	$sup_date = $sup[$date];
    } else {
	$sup_date ="th";
    }
    # Y2K hack
    $year %= 100;
    if ($year >= 70 ){
	$year = "19" . $year;
    } else {
	if ($year<10){
	    $year = "0" . $year;
	}
	$year = "20" . $year;
    }
 
    print "<DIV STYLE=\"font:smaller\">";
    printf "[$prompt: $day_names[$day] $month_names[$month] $date<SUP>$sup_date</SUP> $year at $hour:%02d]\n", $min;
    print "</DIV>\n";
}

sub check_valid_html_tag()
{
    local ($tag) = @_;
    $tag =~ s%^</?%%;
    $tag =~ s%>$%%;
    return ($tag =~ m%^(A|ABBR|ACRONYM|ADDRESS|applet|AREA|B|BASE|basefont|BDO|BIG|BLOCKQUOTE|BODY|BR|BUTTON|CAPTION|center|CITE|CODE|COL|COLGROUP|DD|DEL|DFN|dir|DIV|DL|DT|EM|FIELDSET|font|FORM|FRAME|FRAMESET|H1|H2|H3|H4|H5|H6|HEAD|HR|HTML|I|IFRAME|IMG|INPUT|INS|isindex|KDB|LABEL|LEGEND|LI|LINK|MAP|menu|META|NOFRAMES|NOSCRIPT|OBJECT|OL|OPTGROUP|OPTION|P|PARAM|PRE|Q|s|SAMP|SCRIPT|SELECT|SMALL|SPAN|strike|STRONG|STYLE|SUB|SUP|TABLE|TBODY|TD|TEXTAREA|TFOOT|TH|THEAD|TITLE|TR|TT|u|UL|VAR|NOBR)$%i);
}
    
sub print_valid_html_button()
{
    local ($up) = @_;
    local ($imagedir1);

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }

    print<<EOT if ($insert_validhtml40);
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="${imagedir1}/vh401.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
EOT
}

sub print_meta
{
    local ($name, $content) = @_;
    print "<META NAME=\"$name\" CONTENT=\"$content\">\n";
}

sub print_rel_link
{
    local ($type, $href) = @_;
    $type = ucfirst ($type);
    print "<LINK REL=\"$type\" HREF=\"$href\">\n";
}

sub print_nav_link
{
    local ($num, $type, $href, $title) = @_;
    local ($label) = ucfirst ($type);
    print "lnk[$num] = \"$href\"\n";
    print "itm[$num] = \"$label\"\n";
    print "ttl[$num] = \"$title\"\n";
}

sub print_head_begin
{
    local ($title, $up) = @_;
    local ($jsdir1, $css1);

    if ($up){
	$jsdir1 = &go_up($jsdir,$up);
	$css1   = &go_up($css,$up);
    } else {
	$jsdir1 = $jsdir;
	$css1   = $css;
    }

    print<<EOT;


<!-- **************************************** -->
<!-- *** AUTOGENERATED FILE - DO NOT EDIT *** -->
<!-- **************************************** -->


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>$title</TITLE>
<LINK REL="stylesheet" HREF="$css1" TYPE="text/css">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/ns-resize.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/fix-styles.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/navigation.js"></SCRIPT>
EOT
}

sub print_header
{
    local ($title, $prev, $prevtip, $next, $nexttip, $inx, $up) = @_;
    local ($imagedir1);

    #print STDERR "print_header($title, $prev, $prevtip, $next, $nexttip, $inx, $up)\n";

    if ($up){
	$imagedir1 = &go_up($imagedir,$up);
    } else {
	$imagedir1 = $imagedir;
    }

    $inx = "" if ($noindex);
    $pdf = "" if ($skippdf);

    $nexttip = "Next: $nexttip" if ($next ne "");
    $prevtip = "Previous: $prevtip" if ($prev ne "");

    print_head_begin($title, $up);
    &print_meta("AUTHOR", "Mjølner Informatics A/S");
    &print_meta("COPYRIGHT", "&#169; $copyrightyears Mjølner Informatics A/S");
    &print_meta("DOCNUMBER", "$mia");
    &print_rel_link("next", $next) if ($next ne "");
    &print_rel_link("prev", "$prev") if ($prev ne "");
    &print_rel_link("start", &go_up($mainfile,$up));
    &print_rel_link("first", &go_up($tocfile,$up));
    &print_rel_link("last", &go_up($inx,$up));
    &print_rel_link("contents", &go_up($tocfile,$up));
    &print_rel_link("index", &go_up($inx,$up)) if ($inx ne "");
    &print_rel_link("copyright", &go_up("../copyright.html", $up));
    &print_rel_link("help", &go_up("../help.html", $up));
    #&print_rel_link("search", &one_up("search.html"));    
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");

    print<<EOT;
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
<!--
var lnk = new Array(8);
var itm = new Array(8);
var ttl = new Array(8);
var img = '$imagedir1';

EOT
    &print_nav_link(0, "Next",     $next, $nexttip);
    &print_nav_link(1, "Previous", $prev, $prevtip);
    &print_nav_link(2, "Page Top", "#_top", "Top of Page");
    &print_nav_link(3, "Content",  &go_up($tocfile,$up), "Table of Contents");
    if ($inx eq ""){
	&print_nav_link(4, "Index", "", "No Alphabetic Index");
    } else {
	&print_nav_link(4, "Index", &go_up($inx,$up), "Alphabetic Index");
    }
    if ($pdf eq ""){
	&print_nav_link(5, "PDF", "", "No PDF File Available");
    } else {
	&print_nav_link(5, "PDF",   &go_up($pdf,$up), "Portable Document Format version of page for easy printing");
    }
    &print_nav_link(6, "Help",     &go_up("../help.html",$up), "Help on these online manuals");
    &print_nav_link(7, "Manuals",  &go_up($mainfile,$up), "Online Manuals Main Page");

    print<<EOT;
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="on_load();">

<!-- Generic stuff - Some versions of Netscape fail if the following is moved to a js-file -->

<LAYER id="SideBar" onMouseover="pull()" onMouseout="draw()" style="position:absolute;left:-95px;width:80px;layer-background-color:#669999;padding:5px;line-height:25px; ">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
<!--
if (document.getElementById || document.all){
  document.write('\<DIV id="SideBar2" onMouseover="pull(event)" onMouseout="draw(event)" STYLE="position:absolute;left:-80px;top:15px;width:100px;background-color:#669999;padding:5px;line-height:25px;" TITLE="Navigation Bar: Slides out when cursor is moved out"\>');
}
if ((document.all && (navigator.userAgent.indexOf("Mac")==-1))) {
  document.write('\<IMG SRC="'+img+'/navigation-light.gif" STYLE="position:absolute;left:84;top:5" WIDTH=13 HEIGHT=63 ALT=""\>');
} else {
  document.write('\<IMG SRC="'+img+'/navigation-light.gif" ALIGN=RIGHT WIDTH=13 HEIGHT=63 ALT=""\>');
}
for (i=0;i<=lnk.length-1;i++){
  if (lnk[i] != ""){
    document.write('<A HREF="'+lnk[i]+'" onClick="out();" CLASS=SideBar TITLE="'+ttl[i]+'">'+itm[i]+'</A><BR>\\n');
  } else {
    document.write('<A HREF="javascript:warn(\\''+ttl[i]+'\\')" onClick="out();" CLASS=SideBarDisabled TITLE="'+ttl[i]+'">'+itm[i]+'</A><BR>\\n');
  }
  if (i==5){
    document.write('<HR ALIGN=LEFT WIDTH=60>\\n');
  }
}
if (document.getElementById || document.all)
  document.write('\</DIV\>\\n');
else
  document.write('&nbsp;\\n');
SetupSideBar();
//-->
</SCRIPT>
</LAYER>
<!-- end generic stuff -->

<A NAME="_top"></A>
EOT

}

sub print_src_header
{
    local ($title) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    if ($filenumber==$#srcfiles){
	# last file
	if ($#intsrcfiles>0){
	    # Cannot use find_next_interface_file here, 
	    # since intheadings is not yet created.
	    # And can't call build_intheadings yet, since last file is
	    # not yet updated, i.e. num_h[*] are not yet updated.
	    # Copy the stuff in build_intheadings
	    local ($intdstfile) = $intdstfiles[0];
	    local ($intsrcfile) = $intsrcfiles[0];
	    if ($intsrcfile eq ""){
		# Special case used to force a new interface chapter
		$nexttip = "" . $num_h[1]+1 . " $intdstfile";
		($nexttip, $next) = &parse_int_chap($nexttip);
		$next .= "/index.html";
	    } else {
		print STDERR "Error: print_src_header: No interface header?\n";
	    }
	} else {
	    $next = $indexfile;
	    $nexttip = "Alphabetic Index";
	}
    } else {
	$next = $dstfiles[$filenumber+1];
	$nexttip = $next;
    }
    if ($filenumber==0){
	# first file
	if ($do_figure_list){
	    $prev = $figuresfile;
	    $prevtip = "List of Figures";
	} elsif ($do_program_list){
	    $prev = $programsfile;
	    $prevtip = "List of Programs";
	} else {
	    $prev = $tocfile;
	    $prevtip = "Table of Contents";
	}
    } else {
	$prev = $dstfiles[$filenumber-1];
	$prevtip = $prev;
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0)
}

sub print_trailer
{
    local ($title, $up, $sourcefile) = @_;
    local ($w) = 40;
    local ($copyrightfile) = &go_up("../copyright.html", $up);
    #if ($copyright eq ""){ $w = 50; }
    &print_valid_html_button($up);

    print<<EOT;
<!-- Footer -->
<P></P>
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="$w%" align="left"><ADDRESS>$title</ADDRESS></TD>
EOT
    print<<EOT if ($w==40);
<TD width="20%" align="center"><FONT size=-1><A HREF="$copyrightfile">&#169;</A> $copyrightyears <A HREF=\"http://www.mjolner.com\">Mj&oslash;lner Informatics</A></FONT></TD>
EOT
    print<<EOT;
<TD width="$w%" align="right">
EOT
    
    print_lastmod("$sourcefile");

    print<<EOT;
</TD>
</TABLE>
<P></P>
<!-- End Footer -->
</BODY>
</HTML>
EOT
}

sub print_toc_header
{
    local ($next, $nexttip);

    if ($do_program_list){
	$next = $programsfile;
	$nexttip = "List of Programs";
    } elsif ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } elsif ($#gramfiles>=0){
	local ($gram, $graminx);
	($gram, $nexttip, $next, $graminx) = &gram_names(0);
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, "", "No Previous Page", $next, $nexttip, $indexfile, 0)
}

sub print_index_header
{
    local ($title) = @_;
    local ($next, $prev, $nexttip, $prevtip);

    if ($#intsrcfiles>0){
	# Previous was last interface file
	($prev, $prevtip) = &find_prev_interface_file($#intsrcfiles+1, 0);
    } else {
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
    }
    $next = "";
    $nexttip = "No Next Page";
    print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0);
}

sub find_next_interface_file
{
    local ($number, $up) = @_;
    local ($next, $nexttip);
    #printf STDERR "\nfind_next_interface_file(%d, %d) = ", $number, $up;
    $number++;
    if ($special_headers){
	# Find heading number n, which does not have local anchor
	local ($i,$n);
	$n=-1;
	for ($i=0; $i<=$#intheadings; $i++){
	    ($nexttip, $next) = split("\@", $intheadings[$i]);
	    #print STDERR "check: \"$next\"";
	    if ($next !~ m%\#H\d+_\d+$%){
		$n++;
		#printf STDERR " - counts (n=$n)\n";
	    } else {
		#print STDERR "\n";
	    };
	    if ($n==$number){
		# Found the real index
		#print STDERR "Real index for $number is $i\n";
		$number = $i;
		last;
	    } elsif ($i==$#intheadings){
		# Not found
		$number = $#intheadings+1;
	    }
	}
    } 
    if ($number>$#intheadings){
	# passed last interface file
	$next = $indexfile;
	$nexttip = "Alphabetic Index";
    } else {
	($nexttip, $next) = split("\@", $intheadings[$number]);
	if ($next eq ""){
	    #print STDERR "find_next_interface_file: int chap: $nexttip\n";
	    ($nexttip, $next) = &parse_int_chap($nexttip);
	    $next .= "/index.html";
	} 
	
    }
    $next = &go_up($next, $up);
    #print STDERR "($next, $nexttip)\n";
    return ($next, $nexttip);
}

sub find_prev_interface_file
{
    local ($number, $up) = @_;
    local ($prev, $prevtip);
    #print STDERR "\nfind_prev_interface_file($number, $up) = ";
    $number--;
    if ($special_headers){
	# Find heading number n, which does not have local anchor
	local ($i,$n);
	$n=-1;
	for ($i=0; $i<=$#intheadings; $i++){
	    ($prevtip, $prev) = split("\@", $intheadings[$i]);
	    #print STDERR "check: \"$prev\"";
	    if ($prev !~ m%\#H\d+_\d+$%){
		$n++;
		#printf STDERR " - counts (n=$n)\n";
	    } else {
		#print STDERR "\n";
	    };
	    if ($n==$number){
		# Found the real index
		#print STDERR "Real index for $number is $i\n";
		$number = $i;
		last;
	    } 
	}
    } 
    if ($number<0){
	# passed first interface file
	$prev = $dstfiles[$#dstfiles];
	$prevtip = ucfirst(&strip_extension(&strip_path($prev))) . " Interface";
    } else {
	($prevtip, $prev) = split("\@", $intheadings[$number]);
	if ($prev eq ""){
	    # Found interface chapter
	    ($prevtip, $prev) = &parse_int_chap($prevtip);
	    $prev .= "/index.html";
	} 
    }
    $prev = &go_up($prev, $up);
    #print STDERR "($prev, $prevtip)\n";
    return ($prev, $prevtip);
}

sub print_interface_toc_header
{
    local ($title, $up, $intfilenumber) = @_;
    local ($next, $nexttip, $prev, $prevtip, $nextno) = 0;
    
    
    ($next, $nexttip) = &find_next_interface_file($intfilenumber, $up);
    #print STDERR "print_interface_toc_header: up=$up, next=$next\n";
    if ($intfilenumber==0){
	$prev = $dstfiles[$#dstfiles];
	$prevtip = $prev;
	$prev = &go_up($prev,$up);
    } else {
	($prev, $prevtip) = &find_prev_interface_file($intfilenumber, $up);
    }
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, $up)
}

sub print_interface_header
{
    local ($title,$up) = @_;
    local ($next, $nexttip, $prev, $prevtip);

    ($next, $nexttip) = &find_next_interface_file($filenumber, $up);
    ($prev, $prevtip) = &find_prev_interface_file($filenumber, $up);

    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, $up)
}

sub read_command_line()
{
    #print "book: ", $book_file_name , "\n";
    return if ($book_file_name ne ""); # called from ../build
    # Command line options
    &usage() if (defined($h));
    $special_headers = 1 if (defined($s));
    $verbose = 1 if (defined($v));
    $debug = 1 if (defined($d));
    $fullpath = 1 if (defined($f));
    $skippdf = 1 if (defined($p));
    $errorwarnings = 1 if (defined($e));
    $ignoreerrors = 1 if (defined($i));
    $noindex = 1 if (defined($x));
    if ($#ARGV == 0){ 
	local ($file) = $ARGV[0];
	if ($file =~ m/\.book$/){
	    $book_file_name = $file;
	}
    } else {
	&usage();
    };
}


sub read_book_file
{
    my ($line) = 0;

    if (! -f "$book_file_name"){
	die "Book file \"$book_file_name\" does not exist!\n";
    }
    open SEQUENCE, "$book_file_name" || die "Cannot open \"$book_file_name\" file: !$\n";
    while (<SEQUENCE>){
	$line++;
	chomp;
	# remove comments
	s/\#.*$//;
	# remove initial whitespace
	s/^\s*//;
	# remove trailing whitespace
	s/\s*$//;
	# skip blank lines
	next if (m/^$/);
	if (-f "${src}$_"){
	    push @srcfiles, $src . $_;
	    push @srcdirs, $src;
	    push @dstfiles, $dst . &strip_path($_);
	    $dst = "./" if ($dst eq "");
	    push @dstdirs, $dst;
	} elsif (m/^options:\s*(.*)$/){
	    local ($options) = $1;
	    if ($options !~ m%^\s*$%){
		printf STDERR "Fixed options (from $book_file_name): $options\n";
		$special_headers=1 if ($options =~ m%-s%);
		$verbose  = 1 if ($options =~ m%-v%);
		$debug    = 1 if ($options =~ m%-d%);
		$fullpath = 1 if ($options =~ m%-f%);
		$skippdf  = 1 if ($options =~ m%-p%);
		$noindex  = 1 if ($options =~ m%-x%);
	    }
	} elsif (m/^date:\s*(.*)$/){ 
	    $date = $1;
	} elsif (m/^inx:\s*(.*)$/){ 
	    $indexfile = $1;
	} elsif (m/^toc:\s*(.*)$/){ 
	    $tocfile = $1;
	} elsif (m/^pdf:\s*(.*)$/){
	    $pdf= $1;
	} elsif (m/^src:\s*(.*)$/){ 
	    $src = &trim_path(&expand($1)) . "/";
	} elsif (m/^dst:\s*(.*)$/){ 
	    $dst = &trim_path(&expand($1)) . "/";
	    &SmartMkdir($dst);
	} elsif (m/^intsrc:\s*(.*)$/){ 
	    $intsrc = &trim_path(&expand($1)) . "/";
	} elsif (m/^intdst:\s*(.*)$/){ 
	    $intdst = &trim_path(&expand($1)) . "/";
	    if (($intdst =~ m%^\.\./%) || ($intdst =~ m%^/%)){
		print STDERR "Illegal intdst: $intdst.\n";
		print STDERR "intdst: must be a local directory\n";
		exit 1 unless $ignoreerrors;
	    }
	    &SmartMkdir($intdst);
	    push @intsrcfiles, "";
	    push @intdstfiles, $intdst;
	} elsif (m/^mia:\s*(.*)$/){ 
	    $mia = $1;
	} elsif (m/^title:\s*(.*)$/){ 
	    $title = $1;
	} elsif (m/^copyright:\s*(.*)$/){ 
	    $copyrightyears = $1; 
	} elsif (m/^list:\s*(.*)$/){ 
	    local $lists= $1;
	    if ($lists =~ m/\bprograms?\b/i){
		$do_program_list = 1;
		}
	    if ($lists =~ m/\bfig\b|\bfigures?\b/i){
		$do_figure_list = 1;
	    }
	} elsif (m/^int:\s*(.*)$/){ 
	    push @intsrcfiles, &expand($intsrc . "$1");
	    push @intdstfiles, $intdst . &strip_extension(&strip_path(&expand("$1"))) . ".html";
	} elsif (m/^gram:\s*(.*)$/){
	    push @gramfiles, &expand($1);
	} else {
	    print STDERR "$book_file_name: line $line: Unrecognized variable or non-existing file:\n$_\n\t- ignored.\n";
	}
    }

    if (($#srcfiles==-1) && ($#intsrcfiles==-1) && ($#gramfiles==-1)){
	print STDERR "$book_file_name: No source files, interface files, or gram files specified.\n";
	print STDERR "Book file ignored.\n";
	return -1;
    }

    if (($#intsrcfiles>-1) && ($intdst eq "")){
	# intdst was not specified - use default "interfaces"
	$intdst = "interfaces";
	# Prepend "interfaces/" to all intdstfiles
	for ($filenumber=0; $filenumber<=$#intdstfiles; $filenumber++){
	    $intdstfiles[$filenumber] = "interfaces/$intdstfiles[$filenumber]";
	}
	&SmartMkdir($intdst); 
	unshift @intsrcfiles, "";
	unshift @intdstfiles, $intdst;
    }

    if ($debug){
	print STDERR "read book file $book_file_name.\n";
	print STDERR "  date:      $date\n";
	print STDERR "  mia:       $mia\n";
	print STDERR "  title:     $title\n";
	print STDERR "  copyright: $copyrightyears\n";
	print STDERR "  pdf:       $pdf\n";
	print STDERR "  lists:     \n";
        print STDERR "    programs\n" if $do_program_list;
        print STDERR "    figures\n"  if $do_figure_list;
	print STDERR "  sequence:\n    ";
	print STDERR join("\n    ",@srcfiles);
	print STDERR "\n  intsrcfiles:\n    ";
	print STDERR join("\n    ",@intsrcfiles);
	print STDERR "\n";
    }

    return 0;
}

sub warning
{
    local ($file, $char_pos, $msg) = @_;
    print STDERR "==>$file:char-pos $char_pos:\n";
    print STDERR "   Warning: $msg\n";
    if ($errorwarnings){
	print STDERR "Treating warnings as errors.\n";
	exit(1) unless $ignoreerrors;
    }
}
sub error
{
    local ($file, $char_pos, $msg) = @_;
    print STDERR "==>$file:char-pos $char_pos:\n";
    print STDERR "   ERROR: $msg\n";
    exit(1) unless $ignoreerrors;
}

sub src_warning
{
    local ($char_pos, $msg) = @_;
    &warning("$srcfiles[$filenumber]", $char_pos, $msg);
}
sub src_error
{
    local ($char_pos, $msg) = @_;
    &error("$srcfiles[$filenumber]", $char_pos, $msg);
}

sub parse_image_attributes
{
    local ($attributes) = @_;
    local (%attributes); undef %attributes;

    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
	$attributes{'SRC'} = $1;
    } elsif ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
	$attributes{'SRC'} = $1;
    }
    if ($attributes =~ m%ALT\s*=\s*\"([^\"]+)\"%i){
	$attributes{'ALT'} = $1;
    } elsif ($attributes =~ m%ALT\s*=\s*([^\s]+)%i){
	$attributes{'ALT'} = $1;
    }
    if ($attributes =~ m%TITLE\s*=\s*\"([^\"]+)\"%i){
	$attributes{'TITLE'} = $1;
    } elsif ($attributes =~ m%TITLE\s*=\s*([^\s]+)%i){
	$attributes{'TITLE'} = $1;
    }
    if ($attributes =~ m%WIDTH\s*=\s*\"([^\"]+)\"%i){
	$attributes{'WIDTH'} = $1;
    } elsif ($attributes =~ m%WIDTH\s*=\s*([^\s]+)%i){
	$attributes{'WIDTH'} = $1;
    }
    if ($attributes =~ m%HEIGHT\s*=\s*\"([^\"]+)\"%i){
	$attributes{'HEIGHT'} = $1;
    } elsif ($attributes =~ m%HEIGHT\s*=\s*([^\s]+)%i){
	$attributes{'HEIGHT'} = $1;
    }
    if ($attributes =~ m%ALIGN\s*=\s*\"([^\"]+)\"%i){
	$attributes{'ALIGN'} = $1;
    } elsif ($attributes =~ m%ALIGN\s*=\s*([^\s]+)%i){
	$attributes{'ALIGN'} = $1;
    }
    if ($attributes =~ m%USEMAP\s*=\s*\"([^\"]+)\"%i){
	$attributes{'USEMAP'} = $1;
    } elsif ($attributes =~ m%USEMAP\s*=\s*([^\s]+)%i){
	$attributes{'USEMAP'} = $1;
    }
    if ($attributes =~ m%BORDER\s*=\s*\"([^\"]+)\"%i){
	$attributes{'BORDER'} = $1;
    } elsif ($attributes =~ m%BORDER\s*=\s*([^\s]+)%i){
	$attributes{'BORDER'} = $1;
    }
    if ($attributes =~ m%STYLE\s*=\s*\"([^\"]+)\"%i){
	$attributes{'STYLE'} = $1;
    } elsif ($attributes =~ m%STYLE\s*=\s*([^\s]+)%i){
	$attributes{'STYLE'} = $1;
    }
    return %attributes;
}

sub build_img_tag
{
    local ($info, %att) = @_;
    local $img = "";

    if (defined($att{'ALT'}) && $att{'ALT'} ne "" &&
	defined($att{'TITLE'}) && $att{'TITLE'} eq ""){
	$att{'TITLE'} = $att{'ALT'};
    }
    $att{'ALT'}   .= " \n" if (defined($att{'ALT'}) && $att{'ALT'} ne "");
    $att{'TITLE'} .= " \n" if (defined($att{'TITLE'}) && $att{'TITLE'} ne "");
    $att{'ALT'}   .= $info;
    $att{'TITLE'} .= $info;
    $att{'BORDER'} = "0" if (defined($att{'BORDER'}) && $att{'BORDER'} eq "");
    #$att{'TITLE'} = $att{'ALT'} = "" if ($map ne "");

    $img .= "<IMG SRC=\"$att{'SRC'}\"";
    $img .= " WIDTH=\"$att{'WIDTH'}\""   if defined($att{'WIDTH'});
    $img .= " HEIGHT=\"$att{'HEIGHT'}\"" if defined($att{'HEIGHT'});
    $img .= " ALIGN=\"$att{'ALIGN'}\""   if defined($att{'ALIGN'});
    $img .= " USEMAP=\"$att{'USEMAP'}\"" if defined($att{'USEMAP'});
    $img .= " STYLE=\"$att{'STYLE'}\""   if defined($att{'STYLE'});
    $img .= " BORDER=\"$att{'BORDER'}\"" if defined($att{'BORDER'});
    $img .= " ALT=\"$att{'ALT'}\""       if defined($att{'ALT'});
    $img .= " TITLE=\"$att{'TITLE'}\""   if defined($att{'TITLE'});
    $img .= ">";

    return $img;
};

sub parse_special_tags
{
    # FIXME: parsing of none-image attributes could be handled with a function
    # parse_special_attributes, just like parse_image_attributes.
    local ($done, $before, $match, $remaining, $number, $i);
    local ($htmlfile) = $dstfiles[$filenumber];

    $_=$srcline;
    $done = $before = $match = $remaining = "";

    ### find tags:
    while(m%\<\w+|\</\w+\>|<!--|-->|<[^!a-zA-Z]|>|&[^a-zA-Z\#]%){
	####### Found a tag start/end or assignment arrow #######
	$before = $`;
	$match  = $&; 
	$remaining  = $';

	#print STDERR "match: $match\n";

	$done .= $before;
	# perform stuff on $match
	if  ($match =~ m%\<H([1-6])%i){
	    ################# Found heading start. #########################
	    $done .= $match;
	    local ($h, $heading, $anchor, $headanchors, $headinx, $attributes);
	    local ($betacaption) = 0;
	    $attributes = "";
	    $h = $1;
	    print STDERR "Heading start H$h, headinglevel=$headinglevel\n" if ($debug);
	    if ($remaining =~ m%(^[^>]*)\>%si){
		# Matched <Hn xxx>
		$attributes = $1; # xxx
		$done .= $&; # complete start tag
		$remaining = $';
	    }
	    print STDERR "H$h attributes: '$attributes'\n" if ($debug);
	    if ($attributes =~ m%class\s*=\s*betacaption%i){
		$betacaption=1;
	    }
	    local ($heading_char_pos) = $full_length-length($remaining);
	    if ($h<$headinglevel){
		# Going from sub section to section/chapter
		for (; $headinglevel>$h; $headinglevel--){
		    $num_h[$headinglevel]=0;
		}
	    }
	    if ($h>$headinglevel){
		if (($h<4) && ($h>$headinglevel+1)){
		    # First 3 heading levels must be contigous to produce
		    # a correct navigation panel (with 3 levels) in PDF
		    &src_warning($heading_char_pos, "Non-contigous increment in heading level? (H$headinglevel->H$h).\n   Corrupt PDF navigation pane may result.");
		}
		$headinglevel++;
		for (; $headinglevel<$h; $headinglevel++){
		    $num_h[$headinglevel]++;
		}
	    }
	    if ($betacaption){
		$num_beta++;
		# Start anchor to refer from TOC
		$anchor = "BETA_$num_beta";
	    } else {
		$num_h[$h]++;
		# Generate number for heading
		$number = "";
		for ($i=1; $i<=$h; $i++){
		    $number .= "$num_h[$i].";
		}
		chop $number; # remove trailing dot
		# Start anchor to refer from TOC
		$anchor = "H${h}_$num_h[$h]";
	    }
	    $done .= "<A NAME=\"$anchor\">";
	    if ($remaining =~ m%\</H$h\>%si){
		$heading = $`;
		$remaining = $';
		$heading =~ s/^\s*//; # remove leading whitespace
		# Check for heading closings inside heading (typically wrong close tag)
		if ($heading =~ m%</H[1-6]>%i){
		    &src_warning($full_length-length($remaining)-length($') - length("</H$h>"), "Closing $& inside <H$h> at char-pos $heading_char_pos");
		}
		# Check for heading starts inside heading
		if ($heading =~ m%<H[1-6]>%i){
		    &src_warning($full_length-length($remaining)-length($') - length("</H$h>"), "Nested $& inside <H$h> at char-pos $heading_char_pos");
		}
		# Check for index entries in heading. Move them outside
		while ($heading =~ m%<INX>([^<]*)</INX>%si){
		    $remaining = "<INX HIDDEN>$1</INX>" . $remaining;
		    $heading = $` . $1 . $';
		}
		# Check for anchors in heading. Move them outside
		$headanchors = "";
		while ($heading =~ m%(<A NAME=[^>]+>)([^<]*)(</A>)%si){
		    $headanchors .= $1 . $3;
		    $heading = $` . $2 . $';
		}
		if ($betacaption){
		    $done .= "Program $num_beta: $heading</A>$headanchors</H$h>"; # end tag
		} else {
		    $heading = "$number $heading";
		    $done .= $heading . "</A>$headanchors</H$h>"; # end tag
		}
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated heading? (<H$h>)");
	    }
	    if ($betacaption){
		push (@programs, "$num_beta $heading\@$htmlfile\#$anchor");
	    } else {
		push (@headings, "$heading\@$htmlfile\#$anchor");
	    }
	} elsif ($match =~ m%\</H[1-6]\>%i){
	    # Found heading end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-heading? ($&)");
	    $done .= $match;
	} elsif ($match =~ m%\<BETA%i){
	    ##################### Found BETA start ########################
	    local $beta = "";
	    local $caption = "";
	    local $list = 0;
	    local $listcap = "";
	    local $attributes = "";
	    local $id = "";
	    local $anchor = "";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <BETA xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <BETA> attributes:'$attributes'\n" if ($debug);
		$remaining = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    }
	    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
		$beta=&read_file(&expand($1));
	    } elsif ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
		$beta=&read_file(&expand($1));
	    }
	    if ($beta ne ""){
		# Found SRC
		# eat closing tag, if present
		if ($remaining =~ m%^\s*\<\/BETA\>%si){
		    $remaining = $';
		}
	    } else {
		# No SRC. Handle stuff until (and including) end-tag
		#print STDERR "No SRC. Handle stuff until (and including) end-tag\n" if ($debug);
		if ($remaining =~ m%\<\/BETA\>%si){
		    $beta = &untabify($`); # ...
		    #print STDERR "beta='$beta'\n" if ($debug);
		    $remaining = $';
		} else {
		    &src_warning($full_length-length($remaining), "<BETA> with no SRC and no end-tag met.");
		}
	    }
	    # Generate output into $done variable
	    if ($list){
		$num_beta++;
		if ($listcap eq ""){
		    if ($caption eq ""){
			&src_warning($full_length-length($remaining), 
			       "<BETA> tag with LIST attribute and no caption found.\n   Using \"Program " . $num_beta . "\" for caption.");
			$listcap = $caption = "Program " . $num_beta;
		    } else {
			$listcap = $caption;
		    }
		}
		if ($caption eq ""){
		    $caption = $listcap;
		}
		$listcap = "" . $num_beta . " " . $listcap;
		$caption = "Program " . $num_beta . ": " . $caption;
		if ($id ne ""){
		    $anchor = "BETA_$id";
		} else {
		    $anchor = "BETA_$num_beta";
		} 
		push (@programs, "$listcap\@$htmlfile\#$anchor");
		$done .= "<A NAME=\"$anchor\"></A>";
	    }
	    if ($caption ne ""){
		$done .= "<P></P><H4 CLASS=betacaption>$caption</H4>";
	    }
	    $done .= "\n";
	    # Have to use <PRE> also because of HTMLDOC
	    $done .= "<BLOCKQUOTE>\n<TABLE BORDER=3 class=beta><TR><TD><PRE>";
	    # Trim $beta for whitespace
	    $beta =~ s/^\s*//;
	    $beta =~ s/\s*$//;
	    $done .= &quote_html($beta); 
	    $done .= "</PRE></TD></TR></TABLE>\n</BLOCKQUOTE>\n";
	} elsif ($match =~ m%\</BETA\>%i){
	    # Found BETA end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-beta? (</BETA>)");
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\<INX%i){
	    ################# Found INX start #########################
	    local ($entry, $anchor) = ("", "");
	    local $attributes = "";
	    local $hidden = 0;
	    #print STDERR "$htmlfile: INX start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <INX xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <INX> attributes:'$attributes'\n";
		$remaining = $';
	    }	    
	    $num_inx++;
	    if ($attributes =~ m%HIDDEN%i){
		$hidden = 1;
	    }
	    # Start anchor to refer from index
	    $anchor = "INX_$num_inx";
	    $done .= "<A NAME=\"$anchor\"><SPAN CLASS=INDEXED TITLE=Indexed>";
	    if ($remaining =~ m%\</INX\>%i){
		local ($add_space, $after_inx);
		$entry = $`;
		$remaining = $';
		$add_space = ($remaining =~ m%^\w+%);
		$after_inx = $& if ($add_space);
		if ($after_inx eq "s"){
		    # special case: e.g <inx>coroutine</inx>s
		    $add_space = 0;
		    $after_inx = "";
		}
		# delete initial whitespace
		$entry =~ s%^\s+%%;
		# delete trailing whitespace
		$entry =~ s%\s+$%%;
		#print STDERR "$htmlfile: INX entry: $entry\n";
		if ($entry eq ""){
		    &src_warning($full_length-length($remaining), "Empty index entry? <<INX></INX>)");
		}
		$done .= $entry unless $hidden;
		$done .= "</SPAN></A>";
		if ($add_space){
		    $done .= " ";
		    &src_warning($full_length-length($remaining), "added space after </INX> in </INX>$after_inx") if $verbose;
		}
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated index entry? (<INX>)");
	    }
	    # We unquote HTML when pushing to index to get alphabetic
	    # sorting of index right. However, colons must be encoded
	    # in order not to disturb index calculation
	    push (@index, &quote_special(&unquote_html(&untag($entry))) . ".0\@$htmlfile\#$anchor");
	} elsif ($match =~ m%\</INX\>%i){
	    # Found INX end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-index-entry? (</INX>)");
	    $done .= $match;
	} elsif ($match =~ m%\<FOOTNOTE%si){
	    ################# Found FOOTNOTE start #########################
	    local ($footnote, $anchor) = ("", "");
	    local $attributes = "";
	    #print STDERR "$htmlfile: FOOTNOTE start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <FOOTNOTE xxx>
		# $attributes = $1; # xxx
		#print STDERR "$htmlfile: <FOTNOTE> attributes:'$attributes'\n";
		$remaining = $';
	    }	
	    $num_foot++;
	    $anchor = "FN_$num_foot";
	    $done .= "<A REL=FOOTNOTE HREF=\"#$anchor\"><EM><SUP>[$num_foot]</SUP></EM></A>";
	    if ($remaining =~ m%\</FOOTNOTE\>%si){
		$footnote = $`;
		$remaining = $';
		#print STDERR "$htmlfile: FOOTNOTE: $footnote\n";
		# delete initial whitespace
		$footnote =~ s%^\s+%%;
		# delete trailing whitespace
		$footnote =~ s%\s+$%%;
		if ($footnote eq ""){
		    &src_warning($full_length-length($remaining), "Empty footnote? <<FOOTNOTE></FOOTNOTE>)");
		}
		# Put foot note at end of $remaining: This will ensure
		# handling of e.g. INX in the foot note.
		if ($foot_ruler_done){
		    $remaining .= "\n<BR>\n";
		} else {
		    $remaining .= "\n<P></P>\n<HR ALIGN=LEFT WIDTH=\"30%\">\n";
		    $foot_ruler_done = 1;
		}
		$remaining .= "<A NAME=\"$anchor\">[$num_foot] $footnote</A>\n";
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated fotnote? (<FOOTNOTE>)");
	    }
	} elsif ($match =~ m%\</FOOTNOTE\>%i){
	    # Found FOOTNOTE end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-footnote? (</FOOTNOTE>)");
	    $done .= $match;
	} elsif ($match =~ m%\<FIG%i){
	    ######################## Found FIG start ####################
	    local $list = 0;
	    local $figure = "";
	    local $caption = "";
	    local $listcap = "";
	    local $id = "";
	    local $attributes = "";
	    local $anchor = "";
	    #print STDERR "$htmlfile: FIG start\n";
	    $num_fig++;
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <FIG xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <FIG> attributes:'$attributes'\n";
		$remaining = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%ID\s*=\s*\"([^\"]+)\"%i){
		$id = $1;
	    } elsif ($attributes =~ m%ID\s*=\s*([^\s]+)%i){
		$id = $1;
	    }
	    if ($attributes =~ m%CAP\s*=\s*\"([^\"]+)\"%i){
		$caption = $1;
	    } elsif ($attributes =~ m%CAP\s*=\s*([^\s]+)%i){
		$caption = $1;
	    }
	    if ($attributes =~ m%LIST\s*=\s*\"([^\"]+)\"%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s*=\s*([^\s]+)%i){
		$list=1;
		$listcap = $1;
	    } elsif ($attributes =~ m%LIST\s%i){
		$list=1;
	    } elsif ($attributes =~ m%LIST$%i){
		$list=1;
	    }
	    # Handle rest until (and including) end tag
	    if ($remaining =~ m%\</FIG\>%si){
		$figure = $`;
		$remaining = $';
		#print STDERR "$htmlfile: figure: $figure\n";
		if ($figure =~ m%^\s*$%s){
		    &src_warning($full_length-length($remaining), "Empty figure? (<FIG></FIG>)");
		}
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated figure tag? (<FIG>)");
	    }
	    $listcap =~ s%^\s+%%s;
	    $listcap =~ s%\s+$%%s;
	    $caption =~ s%^\s+%%s;
	    $caption =~ s%\s+$%%s;
	    if ($listcap eq ""){
		if ($caption eq ""){
		    if ($list){
			&src_warning($full_length-length($remaining), "<FIG> tag with LIST attribute and no caption found.\n   Using \"Figure " . $num_fig . "\" for caption.");
			#$caption = "Figure $num_fig";
		    }
		} else {
		    $listcap = $caption;
		}
	    }
	    if ($caption eq ""){
		$caption = $listcap;
	    }
	    if ($listcap eq ""){
		$listcap = "" . $num_fig . " " . "Figure $num_fig";
	    } else {
		$listcap = "" . $num_fig . " " . $listcap;
	    }
	    if ($caption eq ""){
		$caption = "Figure " . $num_fig;
	    } else {
		$caption = "Figure " . $num_fig . ": " . $caption;
	    }
	    if ($id ne ""){
		$anchor = "FIG_$id";
	    } else {
		$anchor = "FIG_$num_fig";
	    } 
	    #printf STDERR "listcap: '$listcap'\n";
	    #printf STDERR "caption: '$caption'\n";

	    $done .= "\n<P></P>\n<A NAME=\"$anchor\">";
	    $done .= "<STRONG CLASS=figure>$caption</STRONG>\n</A>\n";
	    $done .= "<P></P>\n";
	    # Must put $figure into $remaining to get processing of e.g.
	    # <INX>, <BETA> in the figure.
	    $remaining = $figure . $remaining;
	    if ($list){
		push (@figures, "$listcap\@$htmlfile\#$anchor");
	    }
	} elsif ($match =~ m%\</FIG\>%i){
	    # Found FIG end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-figure? (</FIG>)");
	    $done .= $match;
	} elsif ($match =~ m%\<GIF%i){
	    ######################## Found GIF start ####################
	    local ($attributes, $info);
	    local ($iw,$ih);
	    local ($file);
	    $attributes = $info = $file = "";
	    #print STDERR "$htmlfile: GIF start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <GIF xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <GIF> attributes:'$attributes'\n";
		$remaining = $';
	    }
	    local (%att) = &parse_image_attributes($attributes);

	    if ($att{'SRC'} eq ""){
		&src_warning($full_length-length($remaining), "GIF tag with no SRC");
	    }
	    $file = &expand($att{'SRC'});
	    if ($file ne $att{'SRC'}){
		# expansion mattered
		$att{'SRC'} = $file;
	    }
	    if (! -f $file){
		$file = $dstdirs[$filenumber] . $file;
	    }
	    if (!is_local($file)){
		#print STDERR "$file is not local\n";
		# Need to copy file to $dstdirs[$filenumber]
		$att{'SRC'} = &strip_path($att{'SRC'});
		if (-d "$dstdirs[$filenumber]/images"){
		    # use images subdir
		    #print STDERR "using dstdir/images\n";
		    &copy_file($file, "$dstdirs[$filenumber]" . "images");
		    $att{'SRC'} = "images/$att{'SRC'}";
		    $file = "$dstdirs[$filenumber]" . "$att{'SRC'}";
		} else {
		    #print STDERR "using dstdir\n";
		    &copy_file($file, "$dstdirs[$filenumber]");
		    $file = "$dstdirs[$filenumber]" . "$att{'SRC'}";
		}
	    }
	    ($iw, $ih) = &read_gif_dim($file);
	    $att{'WIDTH'} = $iw if (!defined($att{'WIDTH'}) || $att{'WIDTH'} eq "");
	    $att{'HEIGHT'} = $ih if (!defined($att{'HEIGHT'}) || $att{'HEIGHT'} eq "");
	    $info  = "[" . &get_file_size($file);
	    $info .= " $att{'WIDTH'}x$att{'HEIGHT'} GIF]";

	    $done .= &build_img_tag($info, %att);
	} elsif ($match =~ m%\</GIF\>%i){
	    # Found GIF end
	    &src_warning($full_length-length($remaining), "GIF tags have no end-tag (</GIF>)");
	    
	} elsif ($match =~ m%\<PNG%i){
	    ######################## Found PNG start ####################
	    local ($attributes, $info);
	    local ($iw,$ih);
	    local ($file);
	    $attributes = $info = $file = "";
	    #print STDERR "$htmlfile: PNG start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <PNG xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <PNG> attributes:'$attributes'\n";
		$remaining = $';
	    }
	    local (%att) = &parse_image_attributes($attributes);

	    if ($att{'SRC'} eq ""){
		&src_warning($full_length-length($remaining), "PNG tag with no SRC");
	    }
	    $file = &expand($att{'SRC'});
	    if ($file ne $att{'SRC'}){
		# expansion mattered
		$att{'SRC'} = $file;
	    }
	    if (! -f $file){
		$file = $dstdirs[$filenumber] . $file;
	    }
	    if (!is_local($file)){
		#print STDERR "$file is not local\n";
		# Need to copy file to $dstdirs[$filenumber]
		$att{'SRC'} = &strip_path($att{'SRC'});
		if (-d "$dstdirs[$filenumber]/images"){
		    # use images subdir
		    #print STDERR "using dstdir/images\n";
		    &copy_file($file, "$dstdirs[$filenumber]" . "images");
		    $att{'SRC'} = "images/$att{'SRC'}";
		    $file = "$dstdirs[$filenumber]" . "$att{'SRC'}";
		} else {
		    #print STDERR "using dstdir\n";
		    &copy_file($file, "$dstdirs[$filenumber]");
		    $file = "$dstdirs[$filenumber]" . "$att{'SRC'}";
		}
	    }
	    ($iw, $ih) = &read_png_dim($file);
	    $att{'WIDTH'}  = $iw if (!defined($att{'WIDTH'}));
	    $att{'HEIGHT'} = $ih if (!defined($att{'HEIGHT'}));
	    $info  = "[" . &get_file_size($file);
	    $info .= " $att{'WIDTH'}x$att{'HEIGHT'} PNG]";

	    $done .= &build_img_tag($info, %att);

	} elsif ($match =~ m%\</PNG\>%i){
	    # Found PNG end
	    &src_warning($full_length-length($remaining), "PNG tags have no end-tag (</PNG>)");
	    
	} elsif ($match =~ m%\<WARNING%i){
	    ################# Found WARNING start #########################
	    local ($message) = ("", "");
	    local $attributes = "";
	    local $large = 0;
	    #print STDERR "$htmlfile: WARNING start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <WARNING xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <WARNING> attributes:'$attributes'\n";
		$remaining = $';
	    }	    
	    if ($attributes =~ m%LARGE%i){
		$large = 1;
	    }
	    if ($remaining =~ m%\</WARNING\>%i){
		$message = $`;
		$remaining = $';
		#print STDERR "$htmlfile: WARNING message: $message\n";
		if ($message eq ""){
		    &src_warning($full_length-length($remaining), "Empty warning? <<WARNING></WARNING>)");
		}
		$done .= "<IMG SRC=\"../images/warning.gif\"";
		$done .= " ALT=\"Warning!\" ALIGN=LEFT";
		if ($large){
		    $done .= " WIDTH=32 HEIGHT=32>\n";
		    $done .= "<FONT size=\"+1\"><B>Warning</B>: $message</FONT>\n";
		} else {
		    $done .= " WIDTH=16 HEIGHT=16>\n";
		    $done .= "<B>Warning</B>: $message\n";
		}
		$done .= "<BR CLEAR=LEFT>";
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated warning? (<WARNING>)");
	    }
	} elsif ($match =~ m%\</WARNING\>%i){
	    # Found WARNING end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-warning? (</WARNING>)");
	    $done .= $match;

	} elsif ($match =~ m%\<NOTICE%i){
	    ################# Found NOTICE start #########################
	    local ($message) = ("", "");
	    local $attributes = "";
	    local $large = 0;
	    #print STDERR "$htmlfile: NOTICE start\n";
	    if ($remaining =~ m%^([^>]*)\>%si){
		# Matched <NOTICE xxx>
		$attributes = $1; # xxx
		#print STDERR "$htmlfile: <NOTICE> attributes:'$attributes'\n";
		$remaining = $';
	    }	    
	    if ($attributes =~ m%LARGE%i){
		$large = 1;
	    }
	    if ($remaining =~ m%\</NOTICE\>%i){
		$message = $`;
		$remaining = $';
		#print STDERR "$htmlfile: NOTICE message: $message\n";
		if ($message eq ""){
		    &src_warning($full_length-length($remaining), "Empty notice? <<NOTICE></NOTICE>)");
		}
		$done .= "<IMG SRC=\"../images/handright.gif\"";
		$done .= " ALT=\"Notice!\" ALIGN=LEFT";
		if ($large){
		    $done .= " WIDTH=32 HEIGHT=17>\n";
		    $done .= "<FONT size=\"+1\"><B>Notice</B>: $message</FONT>\n";
		} else {
		    $done .= " WIDTH=24 HEIGHT=13>\n";
		    $done .= "<B>Notice</B>: $message\n";
		}
		$done .= "<BR CLEAR=LEFT>";
	    } else {
		&src_warning($full_length-length($remaining), "Unterminated notice? (<NOTICE>)");
	    }
	} elsif ($match =~ m%\</NOTICE\>%i){
	    # Found NOTICE end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-notice? (</NOTICE>)");
	    $done .= $match;

	} elsif ($match =~ m%\<!--%i){
	    # Found HTML comment begin
	    $done .= $match;
	    if ($remaining =~ m%^[^>]*-->%si){
		# Matched rest of comment
		$done .= $&; 
		$remaining = $';
	    }	
	} elsif ($match =~ m%-->%i){
	    # Found HTML comment end
	    &src_warning($full_length-length($remaining), "Unmatched end-of-comment? (-->)");
	    $done .= $match;

	    #### ERROR CHECKING: ####

	} elsif ($match =~ m%^<([^!a-zA-Z])$%){
	    # Found unquoted <
	    # Looks like unknown tag for browser
	    &src_warning($full_length-length($remaining), "Found unquoted less-than (<).\n            Emitting &lt; instead.");
	    $done .= "-&lt;" . $1

	} elsif ($match =~ m%^>$%){
	    # Found unquoted > 
	    # Normally displayed in browser, though, hence only notified
	    # about if verbose
	    &src_warning($full_length-length($remaining), "Found unquoted greater-than (>).\n            Emitting &gt; instead.") if ($verbose);
	    $done .= "&gt;"

	} elsif ($match =~ m%^&([^a-zA-Z\#])$%){
	    # Found unquoted & 
	    &src_warning($full_length-length($remaining), "Found unquoted ampersand (&).\n            Emitting &amp; instead.");
	    $done .= "&amp;" . $1;

	} else {
	    # other tag found
	    local ($tag) = $match;
	    if ($match =~ m%^<\w+$%){
		# start tag - eat rest of tag
		if ($remaining =~ m%^([^>]*\>)%si){
		    # Matched <TAG xxx>
		    $tag .= $1; 
		    $remaining = $';
		}
	    }
	    if (!&check_valid_html_tag($match)){
		&src_warning($full_length-length($remaining), "Illegal tag met: $tag");
	    }
	    $done .= $tag;
	}
	
	# handle rest of input in next iteration
	$_ = $remaining;
    }

    $srcline=$done . $_;
}

sub make_special_header
{
    local ($title, $htmlfile,$build_headings) = @_;
    local ($intnum) = "" . $num_h[1] . "." . ++$num_h[2];
    local ($anchor) = "H$num_h[1]_$num_h[2]";

    if ($build_headings){
	# Called from build_intheadings
	push (@intheadings, "$intnum $title\@$htmlfile#$anchor");
    }

    $title = "\005\/PRE\006\005H2\006\005A name=\"$anchor\"\006$intnum\007nbsp;$title\005\/A\006\005\/H2\006\005PRE CLASS=interface\006\n";

    return $title;
}

sub parse_special_header
{
    local ($contents, $htmlfile, $build_headings) = @_;

    $contents =~ s/\(\*\*+\*\)\s+\(\*+\s+([^\*]+)\s+\*+\)\s+\(\*\*+\*\)\s+/make_special_header($1, $htmlfile,$build_headings)/seg;

    return $contents;
}

sub generate
{
    local ($file, $title) = @_;
    printf STDERR "Reading $file ...\n" if $debug;
    ($srcline, $full_length) = &read_file_with_length("$file");
    #open (SRC, ">$file.src");
    #print SRC $srcline;
    #close SRC;
    printf STDERR "Writing HTML ...\n" if $debug;
    &parse_special_tags();
    &print_src_header($title);
    print $srcline;
    &print_trailer($title, 0, $file);
}

sub process_file
{
    local ($srcfile, $dstfile) = @_;
    $foot_ruler_done = 0;
    print STDERR "Generating $dstfile\nfrom       $srcfile\n" if $verbose;

    printf STDERR "Opening $dstfile for writing ... " if $debug;
    if (!open (STDOUT, ">$dstfile")){
	die "\nCannot open $dstfile for writing: $!\n";
    }
    &generate("$srcfile", $title);
    close (STDOUT);

    printf STDERR "done\n\n" if $verbose==1;


}

sub process_src_files
{
    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	&process_file($srcfiles[$filenumber], $dstfiles[$filenumber]);
    }
}

sub open_headings_to_level
{
    local ($hlevel) = @_;
    for (; $headinglevel<$hlevel; $headinglevel++){
	print "  " x ($headinglevel+1), "<DL><DT><DD>\n";
    }
}

sub close_headings_to_level
{
    local ($hlevel) = @_;
    #print STDERR "close_headings_to_level($hlevel): headinglevel=$headinglevel\n";
    for (; $headinglevel>$hlevel; $headinglevel--){
	print "  " x ($headinglevel), "</DL>\n";
    }
}

sub print_toc
{

    local ($headinfo, $link, $heading, $headnum, $hlevel);

    #print STDERR "\nheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @headings);
    #print STDERR "\n++++++++++++++++++++\n";


    print<<EOT;
<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
<DT><A HREF="$tocfile#_toc"><B>Contents</B></A><DD>
  <DL>
EOT
    
    if ($do_program_list){
	print "    <DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
    }
    if ($do_figure_list){
	print "    <DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
    }
    $headinglevel = 1;
    for ($headnum=0; $headnum<=$#headings; $headnum++){
	local ($b1, $b2) = ("", "");
	$headinfo = $headings[$headnum];
	($heading, $link) = split("\@", $headinfo);
	# Find heading level for link 
	$link =~ m/\#H([1-6])/i;
	$hlevel = $1;
	if ($hlevel>$headinglevel){
	    &open_headings_to_level($hlevel);
	} elsif ($hlevel<$headinglevel){
	    &close_headings_to_level($hlevel);
	}
	if ($headinglevel==1){
	    $b1 = "<B>";
	    $b2 = "</B>";
	}
	print "  " x ($headinglevel), "<DT><A HREF=\"$link\">$b1$heading$b2</A><DD>\n";
    }
    &close_headings_to_level(1);

    print_interface_toc("");

    if (-f $indexfile){
	local ($i, $ch);
	print "  <DT><A HREF=\"$indexfile\"><B>Index</B></A><DD>\n";
	&open_headings_to_level(2);
	&print_index_toc($indexfile);
    }
    &close_headings_to_level(1);

    if ($skippdf){
	print "  <DT><SPAN CLASS=disabled><B>PDF</B></SPAN>\n";
    } else {
	print "  <DT><A HREF=\"$pdf\"><B>PDF</B></A> (";
	print &get_file_size($pdf);
	print ")\n";
    }
    print<<EOT;
  <DD>
  </DL>
</DL>
</DIV>
EOT

}

sub generate_toc_page
{
    printf STDERR "\nWriting title page $tocfile ... " if $verbose==1;
    open (STDOUT, ">$tocfile") || die "\nCannot open $tocfile for writing: $!\n";
    &print_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<P>
<CENTER>
<B>
Mj&oslash;lner Informatics Report<BR>
$mia<BR>
$date</B>
<P>
</CENTER>
EOT

    &print_toc;

    print<<"EOT";
<TABLE align=center border=1 cellpadding=3>
<TR><TD align=center>
<DIV style="font-size: smaller">
<A HREF="../copyright.html">Copyright &#169;</A> $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mj&oslash;lner Informatics
</DIV>
</TD></TR>
</TABLE>
<P></P>
EOT
    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n\n" if $verbose==1;
}

sub read_and_abstract_beta
{
    local ($betafile, $htmlfile) = @_;
    local ($was_blank);

    ($betaline, $full_length) = &read_file("$betafile");

    # single-line editing.
    $betaline =~ s/<<.*\bOBJECTDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDESCRIPTOR\b.*>>/.../gi;
    $betaline =~ s/<<.*\bDOPART\b.*>>/.../gi;    
    
    # Uppercase inner
    $betaline =~ s/\bINNER\b/INNER/gi;
    # Remove trailing blanks
    $betaline =~ s/^(.*)\s*$/$1\n/;
    
    # Squeze multiple blank lines down into one
    # next if /\S/ ? ($was_blank=0) : $was_blank++;
    

    # Now perform multiline editing
    if ($special_headers){
	$betaline = &parse_special_header($betaline, $htmlfile,0);
    }

    # delete RCS/CVS stuff
    $betaline =~ s/\${1}Revision\$//s;
    $betaline =~ s/\${1}RCSfile\$//s; 
    $betaline =~ s/\${1}Date\$//s;
    $betaline =~ s/\${1}Author\$//s;

    $betaline =~ s/\bdo\s*\.\.\./do .../gis;
    $betaline =~ s/\bINNER(;?)\s*\.\.\./INNER$1 .../gs;
    #$betaline =~ s/do\b\s*/do /gis; # No contracts do' ' in comments too
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s*\#\)/\(\# do INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do INNER$1 ... \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s*\#\)/\(\# do ... INNER$1 \#\)/gs;
    $betaline =~ s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do ... INNER$1 ... \#\)/gs;
    $betaline =~ s/(:< *)\s*\(\#(.*)\#\);?/$1(\#$2\#);/gs;
    $betaline =~ s/\.\.\.  /... /gs;

    # Delete other lines containing the word "private" or the word "implpart"
    #$betaline =~ s/.*private.*\n+//gi;
    $betaline =~ s/.*implpart.*\n+//gi;

}

sub generate_int_title
{
    local ($betafile) = @_;
    local ($inttitle) = ucfirst(&strip_extension(&strip_path("$betafile"))) . " Interface";

    # Add number for title
    $inttitle = "" . $num_h[1] . "." . ++$num_h[2] . " " . $inttitle;
    return $inttitle;
}

sub generate_interface_file
{
    local ($betafile, $htmlfile) = @_;

    local ($inttitle) = &generate_int_title($betafile);

    printf STDERR "\nGenerating $htmlfile\n      from $betafile ... \n" if $verbose==1;
    &read_and_abstract_beta($betafile, $htmlfile);

    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";

    local ($up) = &countdirs($htmlfile); # $htmlfile assumed being local path
    print_interface_header($inttitle, $up);
    print<<EOT;
<H1>$inttitle</H1>
<PRE CLASS=interface>
EOT

    local ($intline)     = $betaline;

    $_ = $betaline;		

    # Mark '(#', '#)' and ':' in comments to avoid interference with
    # subsequent matchings.

    $remaining = $_;			# in case of no comments at all
    $betaline = "";

    printf STDERR "Substituting special symbols...\n" if $debug;
    
    while ( /\(\*|\*\)/ ) {
	$before = $`;
	$match  = $&;
	$remaining  = $';
	if ( $match eq '*)' ) {
	    $before =~ s/:/\001/g;
	    $before =~ s/\(\#/\002/g;
	    $before =~ s/\#\)/\003/g;
	}
	$betaline .= $before.$match;
	$_ = $remaining;
    }
    $_ = $betaline.$remaining;
    
    # Substitute ':' in slots with \004
    s/(\<\<\s*SLOT\s*\w+\s*):(\s*\w+\s*\>\>)/$1\004$2/gi;
    
    # Substitute ':' in fragmentIds with \004
    #   (assumes entire fragment syntax on one line - I think)
    s/(\-\-+\s*\w+\s*):(\s*\w+\s*\-\-+)/$1\004$2/g;
    
    # quote HTML
    s/&/\010/g;
    s/</\021/g;
    s/>/\022/g;
    
    # Run through $_, matching for pattern-begin and pattern-end, while
    # keeping track of scope level.
    # Insert nested index-information for declarations at the outermost
    # $scope levels.
    $scope  = 2;

    $patterns = "";
    $revpatterns = "";
    $level  = 1;
    $betaline = "";
    $prefix = "";
    $idxop = "";

    printf STDERR "Searching for idx-comments/patterns/colons .....\n" if $debug;
    if   (! m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	printf STDERR "  None found - emitting without markup\n" if $debug;
	$betaline = $_;
    }
    while(m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	$before = $`;
	$match  = $&; 
	$idxop  = $1; $idxlev = $2; # if index information present
	$remaining  = $';
	if ( defined($idxop) && ("$idxop" ne "") ) {
	    # index pseudo comment found
	    if ( "$idxop" eq "+" ) { $scope++; }
	    elsif ( "$idxop" eq "-" ) { $scope--; }
	    if ( "$idxop" eq "=" || "$idxop" eq "\001" ) {
		if ( "$idxlev" eq "" ) {
		    print "No level specified in idx= command";
		    return;
		}
		$scope = $idxlev;
	    }
	    $match = ""; # delete comment
	    $remaining = "\n".$remaining;
	    # $match = "\nINDEXLEVEL: $scope\n";
	}
	elsif ( "$match" eq "(#" ) {
	    # add previously found identifier in scope description
	    if ( "$patternid" ne "" ) {
		$patterns .= "$patternid.$level:";
		printf STDERR "***  %s\n$patternid" if ($debug==1);
	    } else {	
		if (($htmlfile eq "betaenv.html") && ($level == 1)){
		    $patterns .= "betaenv.1:";
		    printf STDERR "  BETAENV\n" if ($debug==1);
		} else {
		    $patterns .= "ANONYMOUS.$level:";
		    printf STDERR "  ANONYMOUS\n" if ($debug==1);
		}
	    }
	    $level += 1;
	    $patternid = "";
	    # $match = "BEGIN";
	    # $match = "\n[PATTERNS: $patterns]\n";
	}
	elsif ( "$match" eq "#)" ){	
	    # check if $before ends with "#".
	    if ( ($before =~ /\#$/ ) && ( ! ( $before =~ /\#\#$/ ) ) ) {
		# found something like 
		#   "... ->F##)
		# i.e. a pattern variable at end of a parenthesed
		# evaluation.
		# This is NOT a pattern end!
		local ($intfile) = $intsrcfiles[$filenumber];
		local ($msg);
		$msg = "'##)' is not considered a pattern end. Please check this!";
		$intfile = &strip_extension(&strip_path($intfile)) . ".int";
		if (!open (INT, ">$intfile")){
		    print STDERR "$msg\n   (cannot write $intfile)\n";
		} else {
		    print INT $intline;
		    close INT;
		    &warning("./$intfile", $full_length-length($remaining), $msg);
		}
		# Just precede.
	    } else {
		# This is really a pattern end
		$level -= 1;
		if ( $patterns =~ m/:\w+.\w+:$/ ) {
		    $patterns = $`.":";
		}
		elsif ( $patterns =~ m/^\w+.\w+:$/ ) {
		    $patterns = "";
		} else {
		    $betaline .= $before.$match;
		    print "*** PATTERNS is wrong: $patterns";
		    print "*** context:";
		    print "\n------------\n";
		    print substr($betaline, -100,100);
		    print "\n------------\n";
		}
		# $match .= "\n[PATTERNS: $patterns]\n";
	    }
	}
	elsif ( $match =~ m/:/ )  { # a colon was found
	    if ( $level <= $scope ){
		# Identifiers must start with alpha or _.
		# In betaenv, there is "exit T[1:lgth], which would
		# cause 1: to be identified as identifier.
		# However, if [a-zA-Z_] is used instead of \w,
		# the "[1:" does not get into the output (:-(
		if ( $before =~ m/(\w+[\w\s,]*)\s*$/ ) {
		    $head = $`;
		    @ids = split( ',' , $1); # list of identifiers, e.g.: x, y, z
		    $tail = "";
		    $prefix = "";
		    if ( $remaining =~ m/^\s*\(\*/ ) {
			# move comment after colon but before prefix from $remaining to $tail
			$tail = $&;            # the stuff matched by the regexp
			$remaining = $';           # the stuff after the match
			$remaining =~ m/\*\)\s*/;  # MUST succeed if comment matches
			$tail .= $`.$&;        # the stuff before the last match and the match itself
			$remaining = $';           # the stuff after the match
		    }
		    
		    if ( $remaining  =~ m/^\s*(\w+)\s*\(\#/ ) { 
			$prefix = $1;
		    } else {
			# the match for prefix failed.
			# look ahead and check if there was a comment after the prefix
			# and try the match again.
			# don't change $tail or $remaining (historical: superpattern index generation)
			if ( $remaining =~ m/^\s*(\w+)\s*\(\*/ ) {
			    # there was a comment after the word after the colon
			    $possibleprefix = $1;
			    # set $peekafter to the stuff after the match, i.e. start of comment text
			    $peekafter = $';
			    $peekafter =~ m/\*\)\s*/;  # MUST succeed if comment matches
			    # set $peektext to the stuff after the match, i.e. what's after the comment
			    $peekafter = $';           
			    if ( $peekafter  =~ m/^\s*\(\#/ ) {
				# there was a pattern-begin after the comment
				$prefix = $possibleprefix; 
			    }
			}
		    }
		}
		
		$marker = $match;
		$match = "";

		if ( @ids == 1 ) {
		    # keep identifier for next "(#" found
		    $patternid = $ids[0];
		    $patternid =~ s/\s//g;
		} else {
		    $patternid = "";
		}

		$before = $head;
		foreach $id ( @ids ) {
		    #print STDERR "IDS: @ids\n";
		    $id =~ m/(\w+)/; # MUST succeed
		    $anchor += 1;
		    $idxid = "$1.$level"; # $id without whitespace.
		    $idxid .= "($anchor)";
		    if (&legal_identifier($id)){
			$bid = "<SPAN CLASS=INDEXED TITLE=Indexed>$id</SPAN>";
		    } else {
			$bid = $id;
		    }
		    $idxid2 = $idxid;
		    #$idxid2 =~ s/\(\d+\)$//;
		    #$idxid2 =~ s/\./_/g;
		    $patterns2 = $patterns;
		    #$patterns2 =~ s/\./_/g;
		    if ( "$patterns2" eq "" ){
			$before .= "$bid<A name=\"$idxid2\"></A>";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "111. {$idxid2\@$htmlfile}\n";
		    } else { 
			# inner scope
			$before .= "$bid<A name=\"$patterns2$idxid2\"></A><A name=\"$idxid2\"></A>";
			#print STDERR "222. {$idxid2\@$htmlfile}\n";
			push (@index, "$idxid2\@$htmlfile");
			#print STDERR "333. {$patterns2$idxid2\@$htmlfile}\n";
			push (@index, "$patterns2$idxid2\@$htmlfile");
		    } # inner scope
		    $before .= ",";
		} # foreach id
		$before =~ s/,$//;
		$before .= $marker.$tail;
	    } # $level <= $scope
	} # colon was found
	else {
	    print "Something is wrong in while loop !!!";
	    return;
	} # "switch" on $match finished
	
	$betaline .= $before.$match;
	$_ = $remaining;
    } # while

    $_ = $betaline."\n";

    printf STDERR "Cleaning up...\n" if $debug;

    # Clean up
    s/\001/:/g;
    s/\002/\(\#/g;
    s/\003/\#\)/g;
    s/\004/:/g;
    s/\005/</g;
    s/\006/>/g;
    s/\007/&/g;
    s/\010/&amp;/g;
    s/\021/&lt;/g;
    s/\022/&gt;/g;

    printf STDERR "Writing interface ... " if $debug;
    print;
    
    print<<EOT;
</PRE>
EOT
    print_trailer("$inttitle", $up, $betafile);

    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub parse_int_chap
{
    local ($heading) = @_;
    local ($headnum, $intpath);

    $heading =~ m%^(\d+) (.*)$%;
    $headnum = $1;
    $intpath = &trim_path($2);
    $heading = &strip_path($intpath);
    if ($heading eq "interfaces"){
	$heading = "Interface Descriptions";
    } else {
	$heading = ucfirst($heading) . " Interface";
    }
    $heading = "$headnum $heading";

    return ($heading, $intpath);
}

sub print_interface_toc
{

    local ($prefix) = @_;

    local ($headinfo, $link, $heading, $headnum, $intpath);
    local ($h);

    #print STDERR "\nintheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#intsrcfiles>1){
	foreach $headinfo (@intheadings){
	    ($heading, $link) = split("\@", $headinfo);
	    if ($link eq ""){
		# Found new interface chapter
		($heading, $intpath) = &parse_int_chap($heading);
		next if ($intpath !~ m%^$prefix%);
		# close previous chapter(s)
		&close_headings_to_level(1);
		$headinglevel = 1;
		#print STDERR "\nInterface chapter: $heading\n";
		$link = &strip_prefix("$intpath/index.html", $prefix);
		print "    ", "<DT><A HREF=\"$link\"><I><B>$heading</B></I></A><DD>\n";
		print "    <DL>\n";
	    } else {
		if ($prefix ne ""){
		    #print STDERR "link: $link, prefix: $prefix\n";
		    next if ($link !~ m%^$prefix%);
		    $link = &strip_prefix($link, $prefix);
		}
		$headinglevel = 2;
		print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	    }
	}
	# terminate last interface chapter(s)
	&close_headings_to_level(1);
	$headinglevel = 1;
    }

}

sub generate_interface_toc_page
{
    local ($intfilenumber, $inttocdir, $title) = @_;
    local ($inttocfile) = "$inttocdir/index.html";
    local ($up) = &countdirs($inttocfile);
    printf STDERR "\nWriting interface toc page $inttocfile ... " if $verbose==1;
    open (STDOUT, ">$inttocfile") || die "\nCannot open $inttocfile for writing: $!\n";
    $headinglevel = 1;
    $num_h[2] = $num_h[3] = $num_h[4] = $num_h[5] = $num_h[6] = 0;
    &print_interface_toc_header($title, $up, $intfilenumber);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_interface_toc($inttocdir);

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, $up, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub build_intheadings
{
    local (@old_num_h) = @num_h;
    # Build @intheadings. Needed before generations because of Next-links
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # Special case used to force a new interface chapter
	    $num_h[1]++;
	    $num_h[2] = $num_h[3] = $num_h[4] = $num_h[5] = $num_h[6] = 0;
	    #print STDERR "\npush(\@intheadings, $num_h[1] $intdstfile\@)\n";
	    push (@intheadings, "$num_h[1] $intdstfile\@");
	} else {
	    local ($inttitle) = &generate_int_title($intsrcfile);
	    push (@intheadings, "$inttitle\@$intdstfile");
	    if ($special_headers){
		&parse_special_header(&read_file($intsrcfile), $intdstfile,1);
	    }
	}
    }
    @num_h = @old_num_h;
    #print STDERR "intheadings:\n";
    #for ($filenumber=0; $filenumber<=$#intheadings; $filenumber++){
    #    print STDERR "$filenumber : $intheadings[$filenumber]\n";
    #}
}

sub process_interface_files
{
    local ($intheading);

    return if ($#intsrcfiles<=0);

    printf STDERR "Generating %d interface descriptions...\n", $#intsrcfiles+1  if $verbose;

    &build_intheadings;

    #print STDERR "intheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";
    
    # Generate interface files
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($intdstfile) = $intdstfiles[$filenumber];
	local ($intsrcfile) = $intsrcfiles[$filenumber];
	if ($intsrcfile eq ""){
	    # new interface chapter
	    $num_h[1]++;
	    $num_h[2] = $num_h[3] = $num_h[4] = $num_h[5] = $num_h[6] = 0;
	} else {
	    &generate_interface_file($intsrcfile, $intdstfile);
	}
    }
    
    # Generate interface toc pages
    for ($filenumber=0; $filenumber<=$#intsrcfiles; $filenumber++){
	local ($headinfo) = $intheadings[$filenumber];
	local ($heading, $link) = split ("\@", $headinfo);
	local ($intdstfile);
	if ($link eq ""){
	    # Found interface chapter heading
	    # print STDERR "Found interface chapter heading: \n\t$heading\n";
	    ($heading, $intdstfile) = &parse_int_chap($heading);
	    &generate_interface_toc_page($filenumber, $intdstfile, $heading);
	} 
    }
}


sub print_index_toc
{
    local ($file) = @_;
    local ($ch);
    #local @keys = keys(%caps);
    #local @values = values(%caps);
    #print STDERR "caps:\n";
    #while ($#keys>=0){
    #   print STDERR "  caps{", pop(@keys), "}==", pop(@values), "\n";
    #}
    foreach $ch (sort {lc($a) cmp lc($b)} keys(%caps)){
	next unless defined $caps{$ch};
	local $entry = &unquote_special(&quote_html(&quote_special($ch)));
	if ($caps{$ch}==1){
	    print "<STRONG><A HREF=\"$file#_$entry\">$entry</A></STRONG> \n";
	} else {
	    # no indices starting with $ch
	    print "<STRONG CLASS=disabled>$entry</STRONG> \n";
	}	
    }
}

sub calculate_index()
{
    #print STDERR "\nindex: ", "+"x20, "\n", join ("\n", @index), "\n", "+"x20, "\n";

    # Sort index ignoring case
    @index = sort {lc($a) cmp lc($b)} @index;
    local ($prev_id, $prev_no, $initial_ch, $htmlfile, $i, %entries);

    local ($italic, $itaend) = ("", "");
    local (@index_lines);

    #print STDERR "\nsorted index: ", "+"x20, "\n", join ("\n", @index), "\n", "+"x20, "\n";

    undef @index_lines;
    undef %entries;
    undef %caps;
    #print STDERR "\n";
    for ($i=65; $i<=90; $i++){
	local $ch = sprintf ("%c", $i);
	#print STDERR "caps{$ch}=0\n";
	$caps{$ch} = 0;    
    }
    $html_index = "";
    $prev_id = "";
    $prev_no = 1;

    local ($index_line) = "";

    for($i = 0; $i <= $#index; $i++) {

	# delete traling file name (after '@')
	$index[$i] =~ s/(.+)\@(.+)/$1/;
	# save target file name
	$htmlfile = $2;
	$_ = $index[$i];

	
	# In foo.1 delete .1
	s/\.(\d+)//g;
	if ($1 eq "0"){
	    # Last .N was a .0:
	    # Reference to src file (not interface file)
	    $is_src = 1;
	    #print STDERR "$_ is src\n";
	} else {
	    # Reference to interface file
	    $is_src = 0;
	    # In betaenv: exit T[1:lgth] is taken to be
	    # an identifer with name 1. Prevent this.
	    if (!&legal_identifier($_)){
		printf STDERR "skipped illegal identifier: $_\n" if $verbose;
		next;
	    }
	}
	# delete other numbers (?) 
	s/\(\d+\)//g;
	# walk through scopes
	while ( m/[ :](\w+)\.(\d+)[:\}]/ ) {
	    $id = $1; $level = $2;
	    $indents = $indent x ($level-1);
	    s/([ \:])$id\.$level([\:])/$1$indents$id$2/;
	}
	
	# Generate caps heading at first occurrence of a letter.
	$initial_ch = substr($index[$i], 0, 1);
	#print STDERR "initial_ch: '$initial_ch'\n";
	# Check for special cases - see quote_special
	if ("$initial_ch" eq ";"){
	    local ($second_ch) = substr($index[$i], 1, 1);
	    #print STDERR "possible quoted colon: \"$index[$i]\"\n";
	    #print STDERR "second_ch: \"$second_ch\"\n";
	    if ("$second_ch" eq "\006"){
		# Quoted colon
		#print STDERR "quoted colon\n";
		$initial_ch = ":";
	    }
	} elsif ("$initial_ch" eq "\007"){
	    # Quoted special character like &szlig;
	    $index[$i] =~ m/^(\007[a-zA-Z]+;)/;
	    $initial_ch = $1;
	} else {
	    $initial_ch = ucfirst (substr($index[$i], 0, 1));
	}
	#print STDERR "initial_ch after: '$initial_ch'\n";
	#printf STDERR "caps{initial_ch}=%d\n", $caps{$initial_ch};
	if (! $caps{&unquote_special(&quote_html($initial_ch))} ){
	    # Emit entries for previous letter
	    if ($index_line ne ""){
		push @index_lines, $index_line;
		$index_line = "";
	    }
	    $html_index .= &build_index_table(@index_lines);
	    @index_lines = ();
	    #print STDERR "***Emit heading for " . &unquote_special(&quote_html($initial_ch)) . "\n";
	    #$html_index .= "***Emit heading for " . &unquote_special(&quote_html($initial_ch)). "\n";
	    $html_index .= "</DIV>\n";
	    $html_index .= "<H2><A NAME=\"_" . &unquote_special(&quote_html($initial_ch)) . "\">";
	    $html_index .= &unquote_special(&quote_html($initial_ch));
	    $html_index .= "<\/A><\/H2>\n";
	    $html_index .= "<DIV CLASS=index>\n";
	    #print STDERR "caps{", &unquote_special(&quote_html($initial_ch)), "}=1\n";
	    $caps{&unquote_special(&quote_html($initial_ch))} = 1;
	}

	# Block levels are present as such in the entries:
	#   foo:
	#     (# bar:
	#          (# kuk: 
	#               (# ... #)
	#          #)
	#     #);
	#
	# Index entries:
	#    foo
	#    foo:bar
	#    foo:bar:kuk
	#
	# Should print as this:
	#    foo
	#      bar
	#       kuk
	#
	
	# print STDERR "$index[$i]\n";

	# Handle ANONYMOUS especially
	if ($_ =~ m/^ANONYMOUS:/){
	    if (!$entries{"ANONYMOUS"}){
		print STDERR "Treating ANONYMOUS specially\n" if $verbose;
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "&nbsp;"x(4) . "<I>Anonymous pattern</I>";
		$entries{"ANONYMOUS"} = 1;
	    }
	}
	# Handle betaenv specially
	if ( ($index[$i] =~ m/^betaenv.1/) && ($htmlfile eq "betaenv.html")){
	    if (!$entries{"betaenv"}){
		print STDERR "Treating betaenv specially\n" if $verbose;
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "&nbsp;"x(4) . "<I><A HREF=\"betaenv.html\">betaenv</I></A>";
		$entries{"betaenv"} = 1;
	    }
	}
	if ($_ =~ m/(.*):([^:]+)/){
	    # Scopes present
	    $scopes = $1;
	    $id = $2;
	    # We are in a specific scope. There cannot be identical index entries
	    # here (BETA semantic error!). So no need to check for prev_id.
	    $prev_id="";
	    $prev_no=0;
	    if ($entries{$scopes}){
		# foo:bar already emitted
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		# indent with double-spaces
		push @index_lines, "&nbsp;"x(2*(2+&num_chars(':', $scopes))) . "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		$entries{$_} = 1;
	    } else {
		if ($index_line ne ""){
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		push @index_lines, "Index Error: $_ ($scopes) ($id)";
	    }
	} else {
	    # No scopes present
	    if ($is_src){
		# Things like "<program>" may be indexed in src files
		$_ = &unquote_special(&quote_html("$_"));
	    }
	    $id = $_;
	    if ($prev_id eq $id){
		# Second or more occurrence of $id
		$prev_no++;
		if (($prev_no % 10) == 0){
		    # break line of references
		    if ($index_line ne ""){
			push @index_lines, $index_line; 
			$index_line = "&nbsp;"x(2);
		    }
		}
		# emit " [n]"
		if ($is_src){
		    $index_line .= "&nbsp;<A href=\"$htmlfile\"><B>[" . $prev_no . "]</B></A>";
		} else {
		    $index_line .= "&nbsp;<A href=\"$htmlfile\#" . $index[$i] . "\">${italic}[" . $prev_no . "]$itaend</A>";
		}
	    } else {
		# First occurrence of $id
		if ($index_line ne ""){
		    # Emit last line of entries
		    push @index_lines, $index_line; 
		    $index_line = "";
		}
		$prev_no=1;
		if ($is_src){
		    $index_line = "<A href=\"$htmlfile\"><B>" . $id . "</B></A>";
		} else {
		    $index_line = "<A href=\"$htmlfile\#" . $index[$i] . "\">$italic" . $id . "$itaend</A>";
		}
		$prev_id = $id;
	    }
	    $entries{$_} = 1;
	}
    }
    if ($index_line ne ""){
	push @index_lines, $index_line; 
	$index_line = "";
    }
    # Emit entries for last letter
    $html_index .= &build_index_table(@index_lines);
    @index_lines = ();
}

sub generate_index_page
{
    return if ($#index<0);
    printf STDERR "\nMaking index page $indexfile ... " if $verbose==1;
    open (STDOUT, ">$indexfile") || die "\nCannot open $indexfile for writing: $!\n";
    &calculate_index();
    print_index_header("$title: Index");
    print<<EOT;
<H1>Index</H1>
The entries in the alphabetic index consists of selected words and symbols from the
body files of this manual - these are in <B>bold</B> font - as well as the
identifiers defined in the public interfaces of the libraries 
- set in regular font.
<BR>
In the manual, the entries, which can be found in the index
are <SPAN CLASS=INDEXED>typeset like this</SPAN>. This can help localizing the
identifier, when the link from the index if followed - especially in the case
where the browser does not scroll the line to the top, e.g. because there
is less than a page of text left. 
<BR>
In the small table of letters and symbols below, each entry links directly to 
the section of the index containing entries starting with the corresponding letter
or symbol. 
EOT
    #print "The table is also present in the navigation bar to the left.\n";
    print "<P>\n";
    print "<HR>\n<CENTER>\n";
    &print_index_toc("");
    print "</CENTER>\n<HR>\n\n";
    print "<DIV CLASS=index>\n";
    print $html_index;
    print "</DIV>\n";
    print_trailer("$title: Index", 0, "");
    close(STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub print_program_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nprograms:++++++++++++++++++++\n";
    #print STDERR join ("\n", @programs);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#programs>=0){
	print "    ", "<DT><A HREF=\"$programsfile\"><B>List of Programs</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#programs; $headnum++){
	    $headinfo = $programs[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_program_list_page
{
    #local ($title) = "List of Programs";
    local ($next, $nexttip);
    if (!$do_program_list){ 
	return;
    }
    printf STDERR "\nWriting list of programs to $programsfile ... " if $verbose==1;
    open (STDOUT, ">$programsfile") || die "\nCannot open $programsfile for writing: $!\n";
    if ($do_figure_list){
	$next = $figuresfile;
	$nexttip = "List of Figures";
    } else {
	$next = $dstfiles[0];
	$nexttip = $next;
    }
    &print_header($title, $tocfile, "Table of Contents", $next, $nexttip, $indexfile, 0);

    print<<EOT;
<H1>List of Programs</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_program_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer("List of Programs", 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub print_figure_list
{

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nfigures:++++++++++++++++++++\n";
    #print STDERR join ("\n", @figures);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#figures>=0){
	print "    ", "<DT><A HREF=\"$figuresfile\"><B>List of Figures</B></A><DD>\n";
	print "    <DL>\n";
	for ($headnum=0; $headnum<=$#figures; $headnum++){
	    $headinfo = $figures[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }
}

sub generate_figure_list_page
{
    #local ($title) = "List of Figures";
    local ($prev, $prevtip, $next, $nexttip);

    if (!$do_figure_list){ 
	return;
    }
    printf STDERR "\nWriting list of figures to $figuresfile ... " if $verbose==1;
    open (STDOUT, ">$figuresfile") || die "\nCannot open $figuresfile for writing: $!\n";
    
    if ($do_program_list){
	$prev = $programsfile;
	$prevtip = "List of Programs";
    } else {
	$prev = $tocfile;
	$prevtip = "Table of Contents";
    }
    $next = $dstfiles[0];
    $nexttip = $next;
    &print_header($title, $prev, $prevtip, $next, $nexttip, $indexfile, 0);

    print<<EOT;
<H1>List of Figures</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_figure_list;

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer("List of Figures", 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub filter_for_pdf
{
    local ($file, $distfile) = @_;
    local ($contents);
    local ($done, $before, $match, $remaining, $number, $i);

    #print STDERR "filter_for_pdf($file, $distfile)\n";

    #print STDERR "rename_file($file, $distfile)\n";
    &rename_file($file, $distfile);
    #print STDERR "read_file($distfile)\n";
    $contents = &read_file($distfile);

    # Filter out the <LAYER> ... </LAYER>
    # NOTE: Could probably skip this too, when SCRIPT contents is properly
    # SGML commented out. However, we don't need it in the PDF anyway...
    $contents =~ s%\<LAYER.+\<\/LAYER\>%%gsi;

    # We might as well filter out <LINK REL=...> too
    # Hmm, no - removes style sheet too.
    # $contents =~ s%\<LINK REL=[^>]+>%%gi;

    # The copyright file is not present as part of pdf
    # Remove link:
    $contents =~ s%<A HREF="[./]*copyright.html">&#169;</A>%&#169;%gi;

    # Remove entire footer
    $contents =~ s/<!-- Footer -->.*<!-- End Footer -->//is;

    #print STDERR "open($file)\n";
    open (STDOUT, ">$file") || die "Cannot open $file for writing: $!\n";
    print $contents;
    close STDOUT;
}

sub generate_pdf
{
    local ($cmd, $v) = ("", "");
    local (@sequence) = ();
    local ($fileno) = 0;
    if ($skippdf){
	print STDERR "Skipping PDF generation (-p option)\n" if $verbose;
    } else {
	if ($pdf eq ""){
	    $pdf = $book_file_name;
	    $pdf =~ s/\.book$/.pdf/;
	}
	print STDERR "Generating $pdf\n" if ($verbose);
	&generate_pdf_titlepage();
	print STDERR "Building PDF sequence\n" if ($verbose);
	# Construct list of generated files
	if ($do_program_list){
	    push @sequence, $programsfile;
	}
	if ($do_figure_list){
	    push @sequence, $figuresfile;
	}
	push @sequence, @dstfiles;
	foreach $f (@intdstfiles){
	    # Ignore intdst directories
	    push @sequence, $f if (-f $f);
	}
	if ($#gramfiles>=0){
	    for ($fileno=0; $fileno<=$#gramfiles; $fileno++){
		local ($g, $t, $h, $i) = &gram_names($fileno);
		push @sequence, $h;  # grammar file
		push @sequence, $i;  # grammar index file
	    }
	}
	push @sequence, $indexfile if (-f $indexfile);

	print STDERR "Filtering HTML for PDF\n" if ($verbose);
	foreach $f (@sequence){
	    &filter_for_pdf($f, "$f-dist")
	}
	&filter_for_pdf($pdftitlefile, "$pdftitlefile-dist");
	# run htmldoc
	$v = "-v" if $verbose;
	$cmd = "$htmldoc $v -t pdf -f $pdf --titlefile $pdftitlefile --compression=9 --linkstyle plain --linkcolor #00557A --toclevels 3 --bodycolor \#FFFFFF --size A4 --left 1.0in --right 0.5in --top 0.5in --bottom 0.5in --header .t. --footer h.1 --tocheader .t. --tocfooter l.i --firstpage p1 --compression=9 --fontsize 11.0 --fontspacing 1.2 --headingfont Arial --bodyfont Arial --headfootsize 11.0 --headfootfont Arial " . join (' ', @sequence);

	print STDERR "Calling HTMLDOC\n" if ($verbose);
	print STDERR "$cmd\n" if $debug;
	$ENV{'LD_LIBRARY_PATH'} .= ":/usr/local/lib"; # for libz.so
	if (system("$cmd")!=0){
	    print STDERR "***Error in htmldoc execution!\n";
	    print STDERR "   Generation of PDF requires the program htmldoc to be\n";
	    print STDERR "   executable via your path.\n";
	    print STDERR "   It must be version 1.8.8 or later.\n";
	    print STDERR "   You may download htmldoc from\n\tftp://ftp.easysw.com/pub/htmldoc/\n";
	};
	print STDERR "Restoring original HTML files\n" if ($verbose);
	unlink @sequence;
	foreach $f (@sequence){
	    &rename_file("$f-dist", $f);
	}
	unlink "$pdftitlefile";
	unlink "$pdftitlefile-dist";
	if (-f $pdf){
	    print STDERR "Wrote $pdf\n" if $verbose;
	} else {
	    print STDERR "\n***FAILED to generate $pdf!\n\n";
	}
    }
}

sub generate_pdf_titlepage()
{
    open STDOUT, ">$pdftitlefile" || die "Cannot open $pdftitlefile for writing: $!\n";
    &print_header("$title", "", "", "", "", "", 0);
    print<<"EOT";
<P></P>
&nbsp;
<P></P>
<H1 ALIGN=CENTER>$title</H1>
<P></P>
&nbsp;
<P></P>
<center><B>
Mjølner Informatics Report<BR>
$mia<BR>
$date
</B>
<P></P>
&nbsp;
<P></P>
&nbsp;
<P></P>
&nbsp;
<P></P>
<TABLE border=1 cellpadding=3>
<TR><TD align=center>
Copyright &#169; $copyrightyears <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A>.<BR>
All rights reserved.<BR>
No part of this document may be copied or distributed<BR>
without the prior written permission of Mjølner Informatics
</TD></TR>
</TABLE>
</center>
<HR BREAK>
</BODY>
</HTML>
EOT

    close STDOUT;
}

### Routines for processing grammar files

sub make_gram_anchor
{
    local ($name) = @_;
    push (@index, $name);
    $name = "<A CLASS=indexed TITLE=Indexed NAME=\"" . lc($name) . "\">&lt;$name&gt;</A>";
    return $name;
}

sub isLexem
{
    local ($name) = @_;
    $name = lc($name);
    return (($name eq "const") || ($name eq "string") || ($name eq "nameappl") || ($name eq "namedecl"));
}

sub make_gram_href1
{ 
    local ($string) = @_;
    if ($string =~ m/<([-\w]+)>/) {
	return "&lt;$1&gt;" if (&isLexem($1));
	return "<A HREF=\"#" . "\L$1" . "\">&lt;$1&gt;<\/A\>";
    } else {
	return $string;
    }
}
sub make_gram_href2
{ 
    local ($string) = @_;
    if ($string =~ m/<([-\w]+):([-\w]+)>/) {
	return "&lt;$1:$2&gt;" if (&isLexem($2));
	return "<A HREF=\"#" . "\L$2" . "\">&lt;$1:$2&gt;<\/A\>";
    } else {
	return $string;
    }
}
sub make_gram_comment
{
    local ($string) = @_;
    if ($string =~ m/\(\*(.*\*\))/) {
	$string =~ s/&/&amp\;/g;
	$string =~ s/>/&gt\;/g;
	$string =~ s/</&lt\;/g;
    }
    return $string;
}
sub make_gram_hrefs
{
    local ($string) = @_;
    $string =~ s/(\(\*.*\*\))/&make_gram_comment($1)/ge;
    $string =~ s/(<[-\w]+>)/&make_gram_href1($1)/ge;
    $string =~ s/(<[-\w]+:[-\w]+>)/&make_gram_href2($1)/ge;
    return $string;
}

sub make_gram_h2
{
    local ($string) = @_;
    return "</PRE>\n<H2>$string</H2>\n<PRE CLASS=gram>";
}

sub quote_gram_strings
# boldface literals and quote HTML in string constants
{
    local ($line) = @_;
    local ($processedline) = "";

    while (1){
	if ($line =~ m/\'([^\']+)\'/){
	    $processedline .= $`;
	    $remaining = $';
	    $literal = $1;
	    $literal = &quote_html($literal);
	    # HTML tags are generated as <+...+> to avoid
	    # interpreting, e.g. <B> as a rule in later
	    # processing. The plus signs are removed by unquote_html.
	    $literal = "<+B+>$literal<+/B+>" if ($in_gram_rules);
	    $literal = "\'$literal\'";
	    $processedline .= $literal;
	    $line = $remaining;
	} else {
	    $processedline .= $line;
	    last;
	}
    }
    return $processedline;
}

sub unplus_gram_html
# replace '<+' with '<' and , '+>' with '>'
{
    local ($string) = @_;
    $string =~ s/\<\+/\</g;
    $string =~ s/\+\>/\>/g;
    return $string;
}

sub print_gram_file()
{
    local ($fileno) = @_;
    local ($gramfile, $title, $htmlfile, $inxfile) = &gram_names($fileno);
    local ($prev, $prevtip, $next, $nexttip);
    if ($fileno==0){
	# first gram file
	$prev = $tocfile;
	$prevtip = "Table of Contents";
    } else {
	local ($prevgram, $previnx);
	($prevgram, $prevtip, $prev, $previnx) = &gram_names($fileno-1);
	$prev = $previnx;
	$prevtip = $prevtip . ": Alphabetic Index of Leftsides";
    }
    $next = $inxfile;
    $nexttip = $title . ": Alphabetic Index of Leftsides";
    &print_header($title, $prev, $prevtip, $next, $nexttip, $inxfile, 0);
    
    print<<"EOT";
<A NAME=H1></A>
<H1>$title</H1>
<PRE CLASS=gram>
EOT

    open (GRAM, "$gramfile") || die "cannot open $gramfile: $!\n";
    while(<GRAM>){
	$line = $_;
	chomp($line);
	$line = &untabify($line);
	if (/^\s*Option\s*$/i){
	    $line=&make_gram_h2($line);
	} elsif (/^\s*Rule\s*$/i){
	    $line=&make_gram_h2($line);
	    $in_gram_rules = 1;
	} elsif (/^\s*Attribute\s*$/i){
	    $line=&make_gram_h2($line);
	} elsif ($in_gram_rules){
	    $line = &quote_gram_strings($line);
	    if ($line =~ m/^(\s*)<([-\w]+)>(\s*)::/) {
		# line with rule definition
		#   <name>   :: ...
		#             ^ matched to here
		$w1 = $1; $name = $2; $w2 = $3; 
		$rest = $';
		$name = &make_gram_anchor($name);
		# insert link from rightsides to corresponding leftsides:
		$rest = &make_gram_hrefs($rest);
		$line = $w1 . $name . $w2 . "::" . $rest;
	    } else {
		#line without rule definition
		$line = &make_gram_hrefs($line);
	    }
	    $line = &unplus_gram_html($line);
	} else {
	    # Not yet in rules section
	    $line = &quote_html($line);
	}
	print "$line\n";
    }
    close(GRAM);

    print<<EOT;
</PRE>
EOT

    &print_trailer($title, 0, $gramfile);
    push (@headings, "$title\@$htmlfile#H1");
}

sub build_index_table
{
    local (@lines) = @_;
    local ($row, $result, $num);
    
    local ($col, $numcol, $percent);
    $numcol = $numinxcolumns;;
    $percent = int(100/$numcol);

    $num = $#lines+1;
    return "" if ($num == 0);
    # round up to nearest multiplum of $numcol
    $num = int(($num+($numcol-1))/$numcol) * $numcol;

    $result = "<TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH=\"100%\">\n";
    $result .= "<TR>\n";
    for ($col=1; $col<=$numcol; $col++){
	$result .= "<TD WIDTH=\"$percent%\">\n";
 	for ($row=0; $row<($num/$numcol); $row++){
	    my ($ix) = $row+($col-1)*($num/$numcol);
	    $result .= "<BR>\n" if ($row>0);
	    $result .= "$lines[$ix]" if ($ix<=$#lines);
	}
	$result .= "<BR>\n";
	$result .= "</TD>\n";
    }
    $result .= "</TABLE>\n";
    return $result;
}

sub calculate_gram_index()
{
    local ($initial_ch, $i);
    local (@index_lines);

    # Sort index ignoring case
    #print STDERR "\ngram index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "\n++++++++++++++++++++\n";

    @index = sort {lc($a) cmp lc($b)} @index;

    $html_index = "";
    $prev_id = "";
    $prev_no = 1;
    local ($index_line) = "";
    undef @index_lines;
    undef %entries;
    undef %caps;
        
    for ($i = 0; $i <= $#index; $i++) {
	$initial_ch = ucfirst (substr($index[$i], 0, 1));
	if (! $caps{$initial_ch} ){
	    # Emit entries for previous letter
	    $html_index .= &build_index_table(@index_lines);
	    @index_lines = ();
	    # Generate caps heading at first occurrence of a letter.
	    $html_index .= "\n<H3><A name=\"_$initial_ch\">$initial_ch<\/A><\/H3>\n";
	    $caps{$initial_ch} = 1;
	}
	# Generate index line
	push @index_lines, "<A href=\"$htmlfile\#" . lc($index[$i]) . "\">&lt;" . $index[$i] . "&gt</A>";
    }
    # Emit entries for last letter
    $html_index .= &build_index_table(@index_lines);
    @index_lines = ();
}

sub print_gram_index_file()
{
    local ($fileno) = @_;
    local ($gramfile, $title, $htmlfile, $inxfile) = &gram_names($fileno);
    local ($prev, $prevtip, $next, $nexttip);
    local ($prevgram, $previnx);
    local ($nextgram, $nextinx);

    $prev = $htmlfile;
    $prevtip = $title;
    if ($fileno==$#gramfiles){
	# last gram-inx file - we don't have a global index
	$next = "";
	$nexttip = "No Next Page";
    } else {
	($nextgram, $nexttip, $next, $nextinx) = &gram_names($fileno+1);
    }

    $title = "$title: Alphabetic Index of Leftsides";
    &print_header($title, $prev, $prevtip, $next, $nexttip, "", 0);

    print<<EOT;
<A NAME=H2></A>
<H2>Index</H2>
The entries in the alphabetic index consists of all left-sides in the grammar.
<BR>
The small table of letters below links directly to the section of identifiers
starting with the corresponding letters. 
EOT
    print "<P>\n";
    &calculate_gram_index();
    &print_index_toc("");
    print $html_index;
    &print_trailer($title, 0, "");
    push (@headings, "Index\@$inxfile#H2");
}

sub gram_names
{
    local ($fileno) = @_;
    local ($gramfile, $title, $basename, $htmlfile, $inxfile);
    
    $gramfile = $gramfiles[$fileno];
    $title=$gramfile;
    $title=~s%.*/%%; # delete path
    $title=~s/-meta.gram//; # delete -meta.gram
    $basename=lc($title);
    $htmlfile=$basename . ".html";
    $inxfile=lc($title) . "-inx.html";
    $title=ucfirst($basename) . " Grammar";

    return ($gramfile, $title, $htmlfile, $inxfile);
}

sub process_gram_file 
{
    undef @index;

    local ($fileno) = @_;
    local ($file, $title, $htmlfile, $inxfile) = &gram_names($fileno);

    print STDERR "Generating $htmlfile\nfrom       $file\n" if $verbose;
    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";
    &print_gram_file($fileno);
    close (STDOUT);
    printf STDERR "done.\n" if $verbose;

    print STDERR "Generating $inxfile\n" if $verbose;
    open (STDOUT, ">$inxfile") || die "\nCannot open $gram_inxfile for writing: $!\n";
    &print_gram_index_file($fileno);
    close (STDOUT);
    printf STDERR "done.\n" if $verbose;

}

sub process_grammar_files
{   local ($fileno) = 0;
    # No common index
    $indexfile = "";
    for ($fileno=0; $fileno<=$#gramfiles; $fileno++){
	&process_gram_file($fileno);
    }
    $title = "Mjølner System: Grammars"; # For title page
}

### main #######

# variables
&set_default_variable_values();

&read_command_line();

if ($book_file_name eq ""){
    print STDERR "Processing single file \"$ARGV[0]\"\n" if $verbose;
    @srcfiles = ($ARGV[0]);
    &generate($ARGV[0], "PREVIEW");
} else {
    #print STDERR "reading book file\n";
    return if (&read_book_file() == -1);
    if ($#gramfiles>=0){
	if ($#srcfiles>=0){
	    print STDERR "Ignoring src html files when grammars specified!\n";
	}
	if ($#intsrcfiles>=0){
	    print STDERR "Ignoring interface files when grammars specified!\n";
	}
	print STDERR "Processing grammar files (only)\n" if ($verbose);
	&process_grammar_files();
    } else {
	&process_src_files;
	&process_interface_files;
	&generate_program_list_page;
	&generate_figure_list_page;
	&generate_index_page;
    }
    &generate_pdf;
    &generate_toc_page;
}
1;
