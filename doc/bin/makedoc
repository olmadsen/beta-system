#!/usr/local/bin/perl -s

# use strict;

sub usage
{
    print "usage: makedoc [-f] [-p] [-v] [-d] <manual>.book | <file>.html\n";
    print "  -f   use full urls in HREFs (http://www.mjolner.com/...)\n";
    print "  -p   do not generate PDF\n";
    print "  -v   verbose output\n";
    print "  -d   debug makedoc script\n";
    print "  If .book file is given as argument, a full manual set is generated.\n";
    print "  If a single HTML file is given as input, that file is preprocessed.\n";
    exit(1);
}

# TODO:
#   remove numbers from interface index entries?
#   Implement <FIG> and <INX>
#   use strict and -w, and define remaining global variables below.
#   JLK: Top should mean "top of page". What to call "Top manual index"?
#   Fix titles for src-generated files (OK for interfaces)
#   Fix prev/next TITLE for src-generated files (OK for interfaces)
#   list of programs
#   list of figures
#   help file (+rel link)
#   copyright file (+rel link)
#   Top link (refering top of current page)

# Global variables
# arrays
my @srcfiles = ();         # array of file names from src subdirectory
my @interfaces = ();       # array of file names to convert to interface files
my @headings = ();         # used to build table of contents
my @intheadings = ();      # used to build interface descriptions part of table of contents
my @index = ();            # used to build index
my @num_h = (0,0,0,0,0,0); # array of occurrences of headings 1 to 6

# variables
my $book_file_name = "";   # Name of BOOK file
my $filenumber = 0;        # used to index @srcfiles and @headings
my $num_beta   = 0;        # Number of occurences of <BETA>
my $num_fig    = 0;        # Number of occurences of <FIG>
my $num_inx    = 0;        # Number of occurences of <INX>
my $level      = 0;        # Current heading level
my $srcline    = "";       # Used to read files from src directory into
my $verbose    = 0;
my $debug      = 0;
my $insert_validhtml40 = 0;
my $fullpath   = 0;
my $skippdf    = 0;
my $css = "../style/miadoc.css";
my $jsdir = "../javascript";
my $imagedir = "../images";
my $mainfile = "../index.html";
my $inttocfile = "interface/index.html";
my $tocfile = "index.html";
my $indexfile = "inx.html";
my $leftmargin=25;

sub set_default_variable_values
{
    if ($fullpath){
	local $url = "http://www.mjolner.com/mjolner-system/documentation";
	$css = "$url/style/miadoc.css";
	$jsdir = "$url/javascript";
	$imagedir = "$url/images";
	$mainfile = "$url/index.html";
    }
}

sub read_file
{
    local ($filename) = @_;
    local ($line);
    if (!open(FILE, "$filename")){
	print "Cannot open $filename for reading: $!\n";
	return;
    }

    $line="";
    while (<FILE>) {
	$line .= $_;
    };
    close (FILE);
    return $line;
}

sub one_up
{
    local ($path) = @_;

    if ($fullpath){
	return $path;
    } else {
	return "../" . $path;
    }
}

sub expand 
{
    local ($path) = @_;
    while ($path =~ m/\$(\w+)/){
	local $var = $1;
	if (!defined($ENV{$var})){
	    print "Expand $path: Warning: $var not in environment\n";
	} else {
	    $path = $` . $ENV{$var} . $';
	}
    }
    return $path;
}

sub quote_html
{
    local ($string) = @_;

    #print STDERR "quote: $string\n";
    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    return $string;
}
	       
sub strip_extension
{
    local ($string) = @_;
    if ( $string =~ m/([^\.]+)\..*/ ) {
	$string = $1;
    }
    return $string;
}

sub strip_path
{
    local ($string) = @_;
    if ( $string =~ m%.*/([^/]+$)% ) {
	$string = $1;
    }
    return $string;
}

sub legal_identifier

{
    local ($id) = @_[0];
    return ($id =~ m/[a-zA-Z_]\w*/);
}

sub num_chars
# Occurences of $ch in $string
{
    local ($ch, $string) = @_;
    local ($i, $num);
    $num=0;
    for ($i=0; $i<length($string); $i++){
	$num++ if (substr($string, $i, 1) eq "$ch");
    }
    #print STDERR "num_chars($ch, $string) = $num\n";
    return $num;
}

sub print_lastmod
{
    local ($filename) = @_;
    local @month_names = ("January","February","March","April","May","June","July","August","September","October","November","December");
    local @day_names   = ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday");
    local @sup = ();
    local ($sup_date, $lastmod, $prompt);
    if ($filename ne ""){
	local ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,@rest)
	    = stat($filename);
	$lastmod = $mtime;
	$prompt = "Modified";
   } else {
	$lastmod = time;
	$prompt = "Generated";
    }
    local ($sec,$min,$hour,$date,$month,$year,$day,$yday,$isdst) = localtime($lastmod);
    $sup[1] = $sup[21] = $sup[31] = "st";
    $sup[2] = $sup[22] = "nd";
    $sup[3] = $sup[23] = "rd";
    if (($date==1)  || ($date==2)  || ($date==3) ||
	($date==21) || ($date==22) || ($date==23) ||
	($date==31)) {
	$sup_date = $sup[$date];
    } else {
	$sup_date ="th";
    }
    # Y2K hack
    $year %= 100;
    if ($year >= 98 ){
	$year = "19" . $year;
    } else {
	if ($year<10){
	    $year = "0" . $year;
	}
	$year = "20" . $year;
    }
 
    print "<DIV STYLE=\"font:smaller\">";
    print "[$prompt: $day_names[$day] $month_names[$month] $date<SUP>$sup_date</SUP> $year at $hour:$min]\n";
    print "</DIV>\n";
}

sub print_valid_html_button()
{
    local ($up1) = @_;
    local ($imagedir1);

    if ($up1){
	$imagedir1 = &one_up($imagedir);
    } else {
	$imagedir1 = $imagedir;
    }

    print<<EOT if ($insert_validhtml40);
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="${imagedir1}/vh401.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
EOT
}

sub print_rel_link
{
    local ($type, $href) = @_;
    $type = ucfirst ($type);
    print<<EOT;
<LINK REL="$type" HREF="$href">
EOT
}

sub print_nav_link
{
    local ($type, $href, $title) = @_;
    local ($label) = ucfirst ($type);
    if ($href ne ""){
	print "document.write(\'\\<A HREF=\"$href\" CLASS=\"SideBar\" TITLE=\"$title\"\\>$label\\</A\\>\\<BR\\>');\n";
    }
}

sub print_layer_begin
{

    local ($up1) = @_;
    local ($imagedir1);

    if ($up1){
	$imagedir1 = &one_up($imagedir);
    } else {
	$imagedir1 = $imagedir;
    }
    
    print<<EOT;
<LAYER id="SideBar" onMouseover="pull()" onMouseout="draw()" style="position:absolute;left:-95px;width:80px;layer-background-color:#00557A;padding:5px;line-height:25px; ">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
if (document.all){
  document.write('\\<DIV id="SideBar2" onMouseover="pull()" onMouseout="draw()" STYLE="position:absolute;left:-80px;top:15px;width:100px;background-color:#00557A;padding:5px;line-height:25px;" TITLE=\"Navigation Bar: Slides out when cursor is moved out\"\\>');
}
if (document.all && (navigator.userAgent.indexOf("Mac")==-1)) {
  document.write('\\<IMG SRC="$imagedir1/navigation.gif" STYLE="position:absolute;left:84;top:5" WIDTH=13 HEIGHT=63 ALT=""\\>');
} else {
  document.write('\\<IMG SRC="$imagedir1/navigation.gif" ALIGN=RIGHT WIDTH=13 HEIGHT=63 ALT=""\\>');
}
EOT
}

sub print_layer_end
{
    print<<EOT;
if (document.all)
  document.write('\\</DIV\\>');
else
  document.write('&nbsp;');
SetupSideBar();
</SCRIPT>
</LAYER>
EOT
}

sub print_head_begin
{
    local ($title, $up1) = @_;
    local ($jsdir1, $css1);

    if ($up1){
	$jsdir1 = &one_up($jsdir);
	$css1   = &one_up($css);
    } else {
	$jsdir1 = $jsdir;
	$css1   = $css;
    }

    print<<EOT;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<!-- Autogenerated file - do not edit -->
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>$title</TITLE>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/sidebar.js">
</SCRIPT>
<LINK REL="stylesheet" HREF="$css1" TYPE="text/css">
EOT
}

sub print_std_rel_links
{
    local ($up1) = @_;
    if ($up1){
	&print_rel_link("start", &one_up($mainfile));
	&print_rel_link("first", &one_up($tocfile));
	&print_rel_link("last", &one_up($indexfile));
	&print_rel_link("contents", &one_up($tocfile));
	&print_rel_link("index", &one_up($indexfile));
	#&print_rel_link("copyright", &one_up("copyright.html"));
	#&print_rel_link("help", &one_up("help.html"));
	#&print_rel_link("search", &one_up("search.html"));
    } else {
	&print_rel_link("start", $mainfile);
	&print_rel_link("first", $tocfile);
	&print_rel_link("last", $indexfile);
	&print_rel_link("contents", $tocfile);
	&print_rel_link("index", $indexfile);
	#&print_rel_link("copyright", "copyright.html");
	#&print_rel_link("help", "help.html");
	#&print_rel_link("search", "search.html");
    }
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");

}

sub print_std_nav_links
{
    local ($up1) = @_;
    if ($up1){
	&print_nav_link("content", &one_up($tocfile), "Table of Contents");
	&print_nav_link("index", &one_up($indexfile), "Alphabetic Index");
	&print_nav_link("PDF", &one_up($pdf), "Portable Document Format version of manual");
	&print_nav_link("manuals", &one_up($mainfile), "Manuals Main Entry");
    } else {
	&print_nav_link("content", $tocfile, "Table of Contents");
	&print_nav_link("index", $indexfile, "Alphabetic Index");
	&print_nav_link("PDF", $pdf, "Portable Document Format version of manual");
	&print_nav_link("manuals", $mainfile, "Manuals Main Entry");
    }
}

sub print_header
{
    local ($title) = @_;
    local ($next, $prev);

    print_head_begin($title, 0);

    if ($filenumber==$#srcfiles){
	# last file
	if ($#interfaces>0){
	    &print_rel_link("next", "interface/index.html");
	} else {
	    &print_rel_link("next", $indexfile);
	}
    } else {
	$next = &strip_extension(&strip_path($srcfiles[$filenumber+1]));
	&print_rel_link("next", "$next.html");
    }
    if ($filenumber==0){
	# first file
	&print_rel_link("prev", $tocfile);
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$filenumber-1]));
	&print_rel_link("prev", "$prev.html");
    }
    &print_std_rel_links(0);

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(0);
    if ($filenumber==$#srcfiles){
	# last src file
	if ($#interfaces>0){
	    &print_nav_link("next", "interface/index.html", "Next: Interface Descriptions");
	} else {
	    &print_nav_link("next", $indexfile, "Next: Alphabetic Index");
	}
    } else {
	$next = &strip_extension(&strip_path($srcfiles[$filenumber+1]));
	&print_nav_link("next", "$next.html", "Next: $next.html");
    }
    if ($filenumber==0){
	# first file
	&print_nav_link("previous", $tocfile, "Previous: Table of Contents");
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$filenumber-1]));
	&print_nav_link("previous", "$prev.html", "Previous: $prev.html");
    }
    &print_std_nav_links(0);
    &print_layer_end;

}

sub print_trailer
{
    local ($title, $up1, $sourcefile) = @_;

    &print_valid_html_button($up1);

    print<<EOT;
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>$title</ADDRESS></TD>
<TD width="20%" align="center">$copyright</TD>
<TD width="40%" align="right">
EOT
    
    print_lastmod("$sourcefile");

    print<<EOT;
</TD>
</TABLE>
<P></P>
</BODY>
</HTML>
EOT
}

sub print_toc_header
{
    local ($next) = &strip_extension(&strip_path($srcfiles[0]));

    print_head_begin($title, 0);

    &print_rel_link("next", "$next.html");
    &print_std_rel_links(0);

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(0);
    &print_nav_link("next", "$next.html", "Next: $next.html");
    print_std_nav_links(0);
    &print_layer_end;
}

sub print_index_header
{
    local ($title) = @_;
    local ($next, $prev);
    local ($i, $ch, $n);

    print_head_begin($title, 0);
    if ($#interfaces>0){
	# Previous was last interface file
	$prev = &strip_extension(&strip_path($interfaces[$#interfaces]));
	&print_rel_link("prev", "interface/$prev.html");
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$#srcfiles]));
	&print_rel_link("prev", "$prev.html");
    }
    &print_std_rel_links(0);

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(0);
    if ($#interfaces>0){
	# Previous was last interface file
	$prev = &strip_extension(&strip_path($interfaces[$#interfaces]));
	&print_nav_link("prev", "interface/$prev.html", "Previous: " . ucfirst($prev) . " Interface");
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$#srcfiles]));
	&print_nav_link("prev", "$prev.html", "$prev.html");
    }
    print_std_nav_links(0);

    print "document.write('\\<HR width=\"100%\"\\>')\n";
    $n=0;
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	$n++;
	if ($caps{$ch}){
	    print "document.write('\\<A HREF=\"#_$ch\" CLASS=\"SideBarFixed\" TITLE=\"Entries starting with $ch\" onClick=\"out();\"\\>$ch\\</A\\>";
	} else {
	    print "document.write('\\<A NAME=\"_$ch\" CLASS=\"SideBarFixed\" TITLE=\"[No entries start with $ch]\"\\>$ch\\</A\\>";
	}
	if ($i==90){
	    print("');\n");
	} elsif ($n%4==0){
	    print "\\<BR\\>');\n";
	} else {
	    print " \\&nbsp;');\n";
	}
    }
    &print_layer_end;

}

sub print_interface_toc_header
{
    local ($title) = @_;
    local ($next, $prev, $jsdir1);

    print_head_begin($title, 1);

    $next = &strip_extension(&strip_path($interfaces[0]));
    $prev = &strip_extension(&strip_path($srcfiles[$#srcfiles]));

    &print_rel_link("next", "$next.html");
    &print_rel_link("prev", &one_up("$prev.html"));
    &print_std_rel_links(1);

    $jsdir1 = &one_up($jsdir);
    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(1);
    &print_nav_link("next", "$next.html", "Next: " . ucfirst($next) . " Interface");
    &print_nav_link("previous", &one_up("$prev.html"), "Previous: $prev.html");
    print_std_nav_links(1);
    &print_layer_end;

}

sub print_interface_header
{
    local ($title) = @_;
    local ($next, $prev, $jsdir1);

    print_head_begin($title, 1);

    if ($filenumber==$#interfaces){
	# last interface file
	&print_rel_link("next", &one_up($indexfile));
    } else {
	$next = &strip_extension(&strip_path($interfaces[$filenumber+1]));
	&print_rel_link("next", "$next.html");
    }
    if ($filenumber==0){
	# first interface file
	&print_rel_link("prev", "index.html"); # interface/index.html
    } else {
	$prev = &strip_extension(&strip_path($interfaces[$filenumber-1]));
	&print_rel_link("prev", "$prev.html");
    }
    &print_std_rel_links(1);

    $jsdir1 = &one_up($jsdir);
    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(1);
    if ($filenumber==$#interfaces){
	# last interface file
	&print_nav_link("next", &one_up($indexfile), "Next: Alphabetic Index");
    } else {
	$next = &strip_extension(&strip_path($interfaces[$filenumber+1]));
	&print_nav_link("next", "$next.html", "Next: " . ucfirst($next) . " Interface");
    }
    if ($filenumber==0){
	# first interface file
	&print_nav_link("previous", "index.html", "Previous: Interface Descriptions"); # interface/index.html
    } else {
	$prev = &strip_extension(&strip_path($interfaces[$filenumber-1]));
	&print_nav_link("previous", "$prev.html", "Previous: " . ucfirst($prev) . " Interface");
    }
    print_std_nav_links(1);
    &print_layer_end;

}

sub read_command_line()
{
    # Command line options
    $verbose = 1 if (defined($v));
    $debug = 1 if (defined($d));
    $fullpath = 1 if (defined($f));
    $skippdf = 1 if (defined($p));
    if ($#ARGV == 0){ 
	local ($file) = $ARGV[0];
	if ($file =~ m/\.book$/){
	    $book_file_name = $file;
	}
    } else {
	&usage();
    };
}


sub read_book_file
{
    open SEQUENCE, $book_file_name || die "Cannot open \"$book_file_name\" file: !$\n";
    while (<SEQUENCE>){
	chomp;
	# remove comments
	s/\#.*$//;
	# skip blank lines
	next if (m/^\s*$/);
	if (-f "src/$_"){
	    push @srcfiles, "$_";
	} else {
	    if (m/^date:\s*(.*)$/){ $date = $1 };
	    if (m/^mia:\s*(.*)$/){ $mia = $1 };
	    if (m/^title:\s*(.*)$/){ $title = $1 };
	    if (m/^copyright:\s*(.*)$/){ 
		$copyrightyears = $1; 
		$copyright = 
		    "<FONT size=-1>&COPY; $copyrightyears <A HREF=\"http://www.mjolner.com\">Mj&oslash;lner Informatics</A></FONT>";

	    };
	    if (m/^pdf:\s*(.*)$/){ $pdf= $1 };
	    if (m/^int:\s*(.*)$/){ push @interfaces, &expand($1) };
	}
    }
    if ($debug){
	print STDERR "read book file $book_file_name.\n";
	print STDERR "  date:      $date\n";
	print STDERR "  mia:       $mia\n";
	print STDERR "  title:     $title\n";
	print STDERR "  copyright: $copyrightyears\n";
	print STDERR "  pdf:       $pdf\n";
	print STDERR "  sequence:\n    ";
	print STDERR join("\n    ",@srcfiles);
	print STDERR "\n  interfaces:\n    ";
	print STDERR join("\n    ",@interfaces);
	print STDERR "\n";
    }
}

sub parse_special_tags
{
    local ($done, $before, $match, $after, $number, $i, $attributes);
    local ($htmlfile) = &strip_extension(&strip_path("$srcfiles[$filenumber]")) . ".html";   

    #$*=1;
    $_=$srcline;
    $done = $before = $match = $after = "";

    while(m%\<H[1-6]\>|\</H[1-6]\>|\<BETA|\</BETA\>|\<FIG\>|\</FIG\>|\<INX\>|\</INX\>%i ){
	$before = $`;
	$match  = $&; 
	$after  = $';

	$done .= $before;
	# perform stuff on $match
	if  ($match =~ m%\<H([1-6])\>%i){
	    # Found heading start.
	    $done .= $match;
	    local ($h, $heading);
	    $h = $1;
	    if ($h<$level){
		# Going from sub section to section/chapter
		for (; $level>$h; $level--){
		    $num_h[$level]=0;
		}
	    }
	    if ($h>$level){
		# Going from section/chapter to (sub)section
		$level++;
		for (; $level<$h; $level++){
		    $num_h[$level]++;
		}
	    }
	    $num_h[$h]++;
	    # Generate number for heading
	    $number = "";
	    for ($i=1; $i<=$h; $i++){
		$number .= "$num_h[$i].";
	    }
	    chop $number; # remove trailing dot
	    # Start anchor to refer from TOC
	    $done .= "<A NAME=\"H${h}_$num_h[$h]\">";
	    if ($after =~ m%(.*)\</H$h\>%i){
		$heading = "$number&nbsp;$1";
		$done .= $heading . "</A></H$h>";
		$after = $';
	    } else {
		printf STDERR "Unterminated heading? (<H$h>)\n";
	    }
	    push (@headings, "$heading\@$htmlfile\#H${h}_$num_h[$h]");
	} elsif ($match =~ m%\</H[1-6]\>%i){
	    # Found heading end
	    print STDERR "***Unmatched end-of-heading? ($&)\n";
	    $done .= $match;
	} elsif ($match =~ m%\<BETA%i){
	    # Found BETA start
	    local $beta = "";
	    $done .= "<PRE CLASS=BETA>\n";
	    if ($after =~ m%^([^>]*)\>%si){
		# Matched <BETA xxx>
		$attributes = $1; # xxx
		#$attributes .= " "; # simpler match below
		print STDERR "<BETA> attributes:'$attributes'\n";
		$after = $';
	    }
	    # Handle attributes
	    if ($attributes =~ m%SRC\s*=\s*([^\s]+)%i){
		$beta=&read_file(&expand($1));
		# eat closing tag, if present
		if ($after =~ m%^\s*\<\/BETA\>%si){
		    $after = $';
		}
	    }
	    if ($attributes =~ m%SRC\s*=\s*\"([^\"]+)\"%i){
		$beta=&read_file(&expand($1));
		# eat closing tag, if present
		if ($after =~ m%^\s*\<\/BETA\>%si){
		    $after = $';
		}
	    }
	    # Handle stuff between until (and including) possible end-tag
	    if ($after =~ m%^(.*)\<\/BETA\>%si){
		# Matched <BETA xxx>...</BETA>
		if ($beta ne ""){
		    print STDERR "<BETA> tag with both SRC attribute and code met.\n";
		    print STDERR "Ignoring code between tags.\n";
		} else {
		    $beta = $1; # ...
		}
		$after = $';
	    } else {
		if ($beta eq ""){
		    printf STDERR "<BETA> with no end-tag met.\n";
		}
	    }
	    $done .= &quote_html($beta); 
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\</BETA\>%i){
	    # Found BETA end
	    print STDERR "***Unmatched end-of-beta? (</BETA>)\n";
	    $done .= "</PRE>\n";
	} elsif ($match =~ m%\<INX\>%i){
	    # Found INX start
	    local $entry = "";
	    print STDERR "INX start\n";
	    $num_inx++;
	    # Start anchor to refer from index
	    $done .= "<A NAME=\"INX_$num_inx\">";
	    if ($after =~ m%(.*)\</INX\>%i){
		$entry = $1;
		print STDERR "INX entry: $entry\n";
		if ($entry eq ""){
		    print STDERR "Empty index entry? <<INX></INX>)\n";
		}
		$done .= $entry . "</A>";
		$after = $';
	    } else {
		printf STDERR "Unterminated index entry? (<INX>)\n";
	    }
	    push (@index, "$entry.0\@$htmlfile\#INX_$num_inx");
	} elsif ($match =~ m%\</INX\>%i){
	    # Found INX end
	    $done .= $match;
	} elsif ($match =~ m%\<FIG\>%i){
	    # Found FIG start
	    $done .= $match;
	} elsif ($match =~ m%\</FIG\>%i){
	    # Found FIG end
	    print STDERR "***Unmatched end-of-inx? (</INX>)\n";
	    $done .= $match;
	} else {
	    # Hmmm, error? Should not happen.
	    $done .= $match;
	}
	
	# handle rest of input in next iteration
	$_ = $after;
    }

    $srcline=$done . $_;
    #$*=0;
}

sub generate
{
    local ($file, $title) = @_;
    printf STDERR "Reading $file ...\n" if $debug;
    $srcline = &read_file("$file");
    printf STDERR "Writing HTML ...\n" if $debug;
    &parse_special_tags();
    &print_header($title);
    print $srcline;
    &print_trailer($title, 0, $file);
}

sub process_file
{
    local ($file) = @_;
    print STDERR "Generating $file from src/$file\n" if $verbose;

    printf STDERR "Opening $file for writing ... " if $debug;
    if (!open (STDOUT, ">$file")){
	print "\nCannot open $file for writing: $!\n";
	return;
    }
    &generate("src/$file", $title);
    close (STDOUT);

    printf STDERR "done\n\n" if $verbose==1;


}

sub process_src_files
{
    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	&process_file($srcfiles[$filenumber]);
    }
}

sub print_toc
{

    local ($headinfo, $link, $heading, $headnum, $hlevel);

    #print STDERR "\nheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @headings);
    #print STDERR "\n++++++++++++++++++++\n";


    print<<EOT;
<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
<DT><A HREF="$tocfile#_toc"><B>Contents</B></A><DD>
  <DL>
EOT
    
    $level = 1;
    for ($headnum=0; $headnum<=$#headings; $headnum++){
	$headinfo = $headings[$headnum];
	($heading, $link) = split("\@", $headinfo);
	# Find heading level for link 
	$link =~ m/\#H([1-6])_/i;
	$hlevel = $1;
	if ($hlevel>$level){
	    for (; $level<$hlevel; $level++){
		print "  " x ($level+1), "<DL>\n";
	    }
	}
	if ($hlevel<$level){
	    for (; $level>$hlevel; $level--){
		print "  " x ($level), "</DL>\n";
	    }
	}
	print "  " x ($level), "<DT><A HREF=\"$link\">$heading</A><DD>\n";
    }

    print_interface_toc(0);

    print<<EOT;
  <DT><A HREF="$indexfile">Index</A><DD>
  </DL>
</DL>
</DIV>
EOT

}

sub make_toc_page
{
    printf STDERR "\nWriting title page $tocfile ... " if $verbose==1;
    open (STDOUT, ">$tocfile") || die "\nCannot open $tocfile for writing: $!\n";
    &print_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<P>
<CENTER>
<B>
Mj&oslash;lner Informatics Report<BR>
$mia<BR>
$date</B>
<P>
</CENTER>
EOT

    &print_toc;

    &print_trailer($title, 0, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub read_and_abstract_beta
{
    local ($was_blank);
    
    open (BETA, "$betafile") || die "\nCannot open $betafile for reading: $!\n";

    # Read entire BETA file into $betaline, while doing single-line editing.
    $betaline = "";
    while (<BETA>){
	s/<<.*\bOBJECTDESCRIPTOR\b.*>>/.../gi;
	s/<<.*\bDESCRIPTOR\b.*>>/.../gi;
	s/<<.*\bDOPART\b.*>>/.../gi;    
	    
	# Uppercase inner
	s/\bINNER\b/INNER/gi;
	# Remove trailing blanks
	s/^(.*)\s*$/$1\n/;
	
	# Squeze multiple blank lines down into one
	next if /\S/ ? ($was_blank=0) : $was_blank++;
	
	$betaline .= $_;
    }

    # Now perform multiline editing

    $*=1;
    $_=$betaline;

    # delete RCS/CVS stuff
    s/\$\Revision:[^\$]*\$//;
    s/\$\RCSfile:[^\$]*\$//; 
    s/\$\Date:[^\$]*\$//;
    s/\$\Author:[^\$]*\$//;

    s/\bdo\s*\.\.\./do .../gi;
    s/\bINNER(;?)\s*\.\.\./INNER$1 .../g;
    s/do\b\s*/do /gi;
    s/\(\#\s*do\s+INNER(;?)\s*\#\)/\(\# do INNER$1 \#\)/g;
    s/\(\#\s*do\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do INNER$1 ... \#\)/g;
    s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s*\#\)/\(\# do ... INNER$1 \#\)/g;
    s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do ... INNER$1 ... \#\)/g;
    s/(:< *)\s*\(\#(.*)\#\);?/$1(\#$2\#);/g;
    s/\.\.\.  /... /g;

    # Delete other lines containing the word "private" or the word "implpart"
    #s/.*private.*\n+//gi;
    s/.*implpart.*\n+//gi;

    $betaline = $_;
    $*=0;

    close (BETA);

}

sub make_interface_file
{
    local ($betafile) = @_;
    local ($htmlfile) = "interface/" . &strip_extension(&strip_path("$betafile")) . ".html";   
    local ($inttitle) = ucfirst(&strip_extension(&strip_path("$betafile"))) . " Interface";

    # Add number for title
    $inttitle = "" . $num_h[1] . "." . ++$num_h[2] . "&nbsp;" . $inttitle;
    push (@intheadings, "$inttitle\@$htmlfile");

    printf STDERR "\nMaking $htmlfile\n  from $betafile ... \n" if $verbose==1;
    &read_and_abstract_beta();

    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";

    print_interface_header($inttitle);
    print<<EOT;
<H1>$inttitle</H1>
<PRE CLASS=interface>
EOT

    $_ = $betaline;		

    # Mark '(#', '#)' and ':' in comments to avoid interference with
    # subsequent matchings.

    $after = $_;			# in case of no comments at all
    $betaline = "";

    printf STDERR "Substituting special symbols...\n" if $debug;
    
    while ( /\(\*|\*\)/ ) {
	$before = $`;
	$match  = $&;
	$after  = $';
	if ( $match eq '*)' ) {
	    $before =~ s/:/\001/g;
	    $before =~ s/\(\#/\002/g;
	    $before =~ s/\#\)/\003/g;
	}
	$betaline .= $before.$match;
	$_ = $after;
    }
    $_ = $betaline.$after;
    
    # Substitute ':' in slots with \004
    s/(\<\<\s*SLOT\s*\w+\s*):(\s*\w+\s*\>\>)/$1\004$2/gi;
    
    # Substitute ':' in fragmentIds with \004
    #   (assumes entire fragment syntax on one line - I think)
    s/(\-\-+\s*\w+\s*):(\s*\w+\s*\-\-+)/$1\004$2/g;
    
    # quote HTML
    s/&/\007/g;
    s/</\021/g;
    s/>/\022/g;
    
    # Run through $_, matching for pattern-begin and pattern-end, while
    # keeping track of scope level.
    # Insert nested index-information for declarations at the outermost
    # $scope levels.
    $scope  = 2;

    $*=0;
    $patterns = "";
    $revpatterns = "";
    $level  = 1;
    $betaline = "";
    $prefix = "";

    printf STDERR "Searching for idx-comments/patterns/colons .....\n" if $debug;
    if   (! m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	printf STDERR "  None found - emitting without markup\n" if $debug;
	$betaline = $_;
    }
    while(m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	$before = $`;
	$match  = $&; 
	$idxop  = $1; $idxlev = $2; # if index information present
	$after  = $';
	if ( "$idxop" ne "" ) {
	    # index pseudo comment found
	    if ( "$idxop" eq "+" ) { $scope++; }
	    elsif ( "$idxop" eq "-" ) { $scope--; }
	    if ( "$idxop" eq "=" || "$idxop" eq "\001" ) {
		if ( "$idxlev" eq "" ) {
		    print "No level specified in idx= command";
		    return;
		}
		$scope = $idxlev;
	    }
	    $match = ""; # delete comment
	    $after = "\n".$after;
	    # $match = "\nINDEXLEVEL: $scope\n";
	}
	elsif ( "$match" eq "(#" ) {
	    # add previously found identifier in scope description
	    if ( "$patternid" ne "" ) {
		$patterns .= "$patternid.$level:";
		printf STDERR "***  %s\n", $patternid if $trace==1;
	    } else {	
		if (($htmlfile eq "betaenv.html") && ($level == 1)){
		    $patterns .= "betaenv.1:";
		    printf STDERR "  BETAENV\n" if $trace==1;
		} else {
		    $patterns .= "ANONYMOUS.$level:";
		    printf STDERR "  ANONYMOUS\n" if $trace==1;
		}
	    }
	    $level += 1;
	    $patternid = "";
	    # $match = "BEGIN";
	    # $match = "\n[PATTERNS: $patterns]\n";
	}
	elsif ( "$match" eq "#)" ){	
	    # check if $before ends with "#".
	    if ( ($before =~ /\#$/ ) && ( ! ( $before =~ /\#\#$/ ) ) ) {
		# found something like 
		#   "... ->F##)
		# i.e. a pattern variable at end of a parenthesed
		# evaluation.
		# This is NOT a pattern end!
		printf STDERR "\n******* NOTICE: In the text ending like this:\n";
		printf STDERR substr($betaline.$before.$match, -100, 100);
		printf STDERR "\n******* the '##)' is not considered a pattern end.";
		printf STDERR "\n******* Please check if this is correct.\n\n";	
		# Just precede.
	    } else {
		# This is really a pattern end
		$level -= 1;
		if ( $patterns =~ m/:\w+.\w+:$/ ) {
		    $patterns = $`.":";
		}
		elsif ( $patterns =~ m/^\w+.\w+:$/ ) {
		    $patterns = "";
		} else {
		    $betaline .= $before.$match;
		    print "*** PATTERNS is wrong: $patterns";
		    print "*** context:";
		    print "\n------------\n";
		    print substr($betaline, -100,100);
		    print "\n------------\n";
		}
		# $match .= "\n[PATTERNS: $patterns]\n";
	    }
	}
	elsif ( $match =~ m/:/ )  { # a colon was found
	    if ( $level <= $scope ){
		# Identifiers must start with alpha or _.
		# In betaenv, there is "exit T[1:lgth], which would
		# cause 1: to be identified as identifier.
		# However, if [a-zA-Z_] is used instead of \w,
		# the "[1:" does not get into the output (:-(
		if ( $before =~ m/(\w+[\w\s,]*)\s*$/ ) {
		    $head = $`;
		    @ids = split( ',' , $1); # list of identifiers, e.g.: x, y, z
		    $tail = "";
		    $prefix = "";
		    if ( $after =~ m/^\s*\(\*/ ) {
			# move comment after colon but before prefix from $after to $tail
			$tail = $&;            # the stuff matched by the regexp
			$after = $';           # the stuff after the match
			$after =~ m/\*\)\s*/;  # MUST succeed if comment matches
			$tail .= $`.$&;        # the stuff before the last match and the match itself
			$after = $';           # the stuff after the match
		    }
		    
		    if ( $after  =~ m/^\s*(\w+)\s*\(\#/ ) { 
			$prefix = $1;
		    } else {
			# the match for prefix failed.
			# look ahead and check if there was a comment after the prefix
			# and try the match again.
			# don't change $tail or $after (historical: superpattern index generation)
			if ( $after =~ m/^\s*(\w+)\s*\(\*/ ) {
			    # there was a comment after the word after the colon
			    $possibleprefix = $1;
			    # set $peekafter to the stuff after the match, i.e. start of comment text
			    $peekafter = $';
			    $peekafter =~ m/\*\)\s*/;  # MUST succeed if comment matches
			    # set $peektext to the stuff after the match, i.e. what's after the comment
			    $peekafter = $';           
			    if ( $peekafter  =~ m/^\s*\(\#/ ) {
				# there was a pattern-begin after the comment
				$prefix = $possibleprefix; 
			    }
			}
		    }
		}
		
		$marker = $match;
		$match = "";

		if ( @ids == 1 ) {
		    # keep identifier for next "(#" found
		    $patternid = $ids[0];
		    $patternid =~ s/\s//g;
		} else {
		    $patternid = "";
		}

		$before = $head;
		foreach $id ( @ids ) {
		    #print STDERR "IDS: @ids\n";
		    $id =~ m/(\w+)/; # MUST succeed
		    $anchor += 1;
		    $idxid = "$1.$level($anchor)"; # $id without whitespace.
		    if (&legal_identifier($id)){
			$bid = "<B>$id</B>"; # boldface anchored identifier
		    } else {
			$bid = $id;
		    }
		    if ( "$patterns" eq "" ){
			$before .= "$bid<A name=\"$idxid\"></A>";
			push (@index, "$idxid\@$htmlfile");
			#print STDERR "111. {$idxid\@$htmlfile}\n";
		    } else { 
			# inner scope
			$before .= "$bid<A name=\"$patterns$idxid\"></A><A name=\"$idxid\"></A>";
			#print STDERR "222. {$idxid\@$htmlfile}\n";
			push (@index, "$idxid\@$htmlfile");
			#print STDERR "333. {$patterns$idxid\@$htmlfile}\n";
			push (@index, "$patterns$idxid\@$htmlfile");
		    } # inner scope
		    $before .= ",";
		} # foreach id
		$before =~ s/,$//;
		$before .= $marker.$tail;
	    } # $level <= $scope
	} # colon was found
	else {
	    print "Something is wrong in while loop !!!";
	    return;
	} # "switch" on $match finished
	
	$betaline .= $before.$match;
	$_ = $after;
    } # while

    $_ = $betaline."\n";

    printf STDERR "Cleaning up...\n" if $debug;

    # Clean up
    s/\001/:/g;
    s/\002/\(\#/g;
    s/\003/\#\)/g;
    s/\004/:/g;
    s/\005/</g;
    s/\006/>/g;
    s/\007/&amp;/g;
    s/\021/&lt;/g;
    s/\022/&gt;/g;

    printf STDERR "Writing interface ... " if $debug;
    print;
    
    print<<EOT;
</PRE>
EOT
    print_trailer("$inttitle", 1, $betafile);

    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub print_interface_toc
{

    local ($chop_interface_dir) = @_;

    local ($headinfo, $link, $heading, $headnum);

    #print STDERR "\nintheadings:++++++++++++++++++++\n";
    #print STDERR join ("\n", @intheadings);
    #print STDERR "\n++++++++++++++++++++\n";

    if ($#interfaces>0){
	$headinfo = $intheadings[0];
	($heading, $link) = split("\@", $headinfo);
	if ($chop_interface_dir){
	    $link =~ s%^interface/%%;
	    $heading =~ s%I>%B>%; 
	}
	print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	print "    <DL>\n";
	for ($headnum=1; $headnum<=$#intheadings; $headnum++){
	    $headinfo = $intheadings[$headnum];
	    ($heading, $link) = split("\@", $headinfo);
	    if ($chop_interface_dir){
		$link =~ s%^interface/%%;
	    }
	    print "    ", "<DT><A HREF=\"$link\">$heading</A><DD>\n";
	}
	print "    </DL>\n";
    }

}

sub make_interface_toc_page
{
    local ($title) = @_;
    printf STDERR "\nWriting interface toc page $inttocfile ... " if $verbose==1;
    open (STDOUT, ">$inttocfile") || die "\nCannot open $inttocfile for writing: $!\n";
    &print_interface_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
EOT

    &print_interface_toc(1);

    print<<EOT;
</DL>
</DIV>
<P></P>
EOT

    &print_trailer($title, 1, "");
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}


sub process_interface_files
{
    local ($intheading);

    print STDERR "Generating interface descriptions...\n" if $verbose;

    if (! -d "interface"){
	if (!mkdir("interface",0755)){
	    print STDERR "Cannot create directory \"interface\": $!\n";
	    return;
	}
    }

    $intheading = "" . ++$num_h[1] . "&nbsp;Interface Descriptions";

    push (@intheadings, "<I>$intheading:</I>\@interface/index.html");
    
    for ($filenumber=0; $filenumber<=$#interfaces; $filenumber++){
	&make_interface_file("$interfaces[$filenumber]");
    }

    &make_interface_toc_page($intheading);
    
}


sub print_index_toc
{
    local ($i, $ch);
    print "<HR>\n<DIV style=\"text-align:center\">\n";
    for ($i=65; $i<=90; $i++){
	$ch = sprintf ("%c", $i);
	if ($caps{$ch}){
	    print "<STRONG><A HREF=\"#_$ch\">$ch</A></STRONG> &nbsp; \n";
	} else {
	    # no indices starting with $ch
	    print "<STRONG CLASS=disabled>$ch</STRONG> &nbsp; \n";
	}	    
    }
    print "<HR>\n</DIV>\n\n";
}

sub calculate_index()
{
    #print STDERR "index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "++++++++++++++++++++\n";

    # Sort index ignoring case
    @index = sort {lc($a) cmp lc($b)} @index;
    local ($prev_id, $prev_no, $initial_ch, $htmlfile, $i, %entries);

    #print STDERR "sorted index:++++++++++++++++++++\n";
    #print STDERR join ("\n", @index);
    #print STDERR "++++++++++++++++++++\n";

    $html_index = "";
    $prev_id = "";
    $prev_no = 1;

    for($i = 0; $i <= $#index; $i++) {
	# delete traling file name (after '@')
	$index[$i] =~ s/(.+)\@(.+)/$1/;
	# save target file name
	$htmlfile = $2;
	$_ = $index[$i];

	# In betaenv: exit T[1:lgth] is taken to be
	# an identifer with name 1. Prevent this.
	if (!&legal_identifier($_)){
	    printf STDERR "skipped illegal identifier: $_\n" if $verbose;
	    next;
	}

	# In foo.1 delete .1
	s/(\s*\w+)\.(\d+)/$1/g;
	if ($2 eq "0"){
	    # Reference to src file (not interface file
	    $is_src = 1;
	} else {
	    $is_src = 0;
	}
	# delete other numbers (?) 
	s/\(\d+\)//g;
	# walk through scopes
	while ( m/[ :](\w+)\.(\d+)[:\}]/ ) {
	    $id = $1; $level = $2;
	    $indents = $indent x ($level-1);
	    s/([ \:])$id\.$level([\:])/$1$indents$id$2/;
	}
	
	# Generate caps heading at first occurrence of a letter.
	$initial_ch = ucfirst (substr($index[$i], 0, 1));
	if (! $caps{$initial_ch} ){
	    $html_index .= "</PRE><H2><A name=\"_$initial_ch\">$initial_ch<\/A><\/H2><PRE CLASS=interface>\n";
	    $caps{$initial_ch} = 1;
	}

	# Block levels are present as such in the entries:
	#   foo:
	#     (# bar:
	#          (# kuk: 
	#               (# ... #)
	#          #)
	#     #);
	#
	# Index entries:
	#    foo
	#    foo:bar
	#    foo:bar:kuk
	#
	# Should print as this:
	#    foo
	#      bar
	#       kuk
	#
	
	# print STDERR "$index[$i]\n";

	# Handle ANONYMOUS especially
	if ($_ =~ m/^ANONYMOUS:/){
	    if (!$entries{"ANONYMOUS"}){
		print STDERR "Treating ANONYMOUS specially\n" if $verbose;
		$html_index .= "\n  <I>Anonymous pattern</I>";
		$entries{"ANONYMOUS"} = 1;
	    }
	}
	# Handle betaenv specially
	if ( ($index[$i] =~ m/^betaenv.1/) && ($htmlfile eq "betaenv.html")){
	    if (!$entries{"betaenv"}){
		print STDERR "Treating betaenv specially\n" if $verbose;
		$html_index .= "\n  <I><A HREF=\"betaenv.html\">betaenv</I></A>";
		$entries{"betaenv"} = 1;
	    }
	}
	if ($_ =~ m/(.*):([^:]+)/){
	    # Scopes present
	    $scopes = $1;
	    $id = $2;
	    # We are in a specific scope. There cannot be identical index entries
	    # here (BETA semantic error!). So no need to check for prev_id.
	    $prev_id="";
	    $prev_no=0;
	    if ($entries{$scopes}){
		# foo:bar already emitted
		$html_index .= "\n";
		# indent with double-spaces
		$html_index .= "  " x (1+&num_chars(':', $scopes));
		$html_index .= "  <A href=\"$htmlfile\#" . $index[$i] . "\"><I>" . $id . "</I></A>";
		$entries{$_} = 1;
	    } else {
		$html_index .= "Index Error: $_ ($scopes) ($id)\n";
	    }
	} else {
	    # No scopes present
	    $id = $_;
	    if ($prev_id eq $id){
		# Second or more occurrence of $id
		$prev_no++;
		if (!($prev_no % 10)){
		    # break line of references
		    $html_index .= "\n   ";
		}
		if ($is_src){
		    $html_index .= " <A href=\"$htmlfile\">[" . $prev_no . "]</A>";
		} else {
		    $html_index .= " <A href=\"$htmlfile\#" . $index[$i] . "\"><I>[" . $prev_no . "]</I></A>";
		}
	    } else {
		$prev_no=1;
		$html_index .= "\n";
		if ($is_src){
		    $html_index .= "  <A href=\"$htmlfile\">" . $id . "</A>";
		} else {
		    $html_index .= "  <A href=\"$htmlfile\#" . $index[$i] . "\"><I>" . $id . "</I></A>";
		}
		$prev_id = $id;
	    }
	    $entries{$_} = 1;
	}
    }
}

sub make_index_page
{
    printf STDERR "\nMaking index page $indexfile ... " if $verbose==1;
    open (STDOUT, ">$indexfile") || die "\nCannot open $indexfile for writing: $!\n";
    &calculate_index();
    print_index_header("$title: Index");
    print<<EOT;
<H1>$title: Index</H1>
The entries in the alphabetic index consists of selected words from the
body files of this manual - these are in roman font - as well as the
identifiers defined in the public interfaces of the libraries - set in <I>italic</I> font.
<BR>
In the interface descriptions, the indexed identifiers are boldfaced.
<BR>
The small table of letters below links directly to the section of identifiers
starting with the corresponding letters. The table is also present in the 
navigation bar to the left.
<P>
EOT
    &print_index_toc;
    print "<PRE CLASS=interface>\n";
    print $html_index;
    print "</PRE>\n";
    print_trailer("$title: Index", 0, "");
    close(STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

### main #######


# variables
&set_default_variable_values();

&read_command_line();

if ($book_file_name eq ""){
    print STDERR "Processing single file \"$ARGV[0]\"\n" if $verbose;
    @srcfiles = ($ARGV[0]);
    &generate($ARGV[0], "PREVIEW");
} else {
    &read_book_file;
    &process_src_files;
    &process_interface_files;
    &make_toc_page;
    &make_index_page;
}
