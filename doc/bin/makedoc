#!/usr/local/bin/perl -s

sub usage
{
    print "usage: makedoc [-v] <manual>.book\n";
    print"   -v   verbose output\n";
    print"   -d   debug makedoc script\n";
    exit(1);
}

sub set_default_variable_values
{
    $insert_validhtml40 = 1;
    if ($fullpath){
	if ($extradir){
	    print "makedoc: Both -f and -x specified: -x is ignored\n";
	}
	$css = "http://www.mjolner.com/mjolner-system/documentation/style/miadoc.css";
	$jsdir = "http://www.mjolner.com/mjolner-system/documentation/javascript";
	$imagedir = "http://www.mjolner.com/mjolner-system/documentation/images/";
	$topfile = "http://www.mjolner.com/mjolner-system/documentation/index.html";
    } else {
	if ($extradir){
	    $css = "../../style/miadoc.css";
	    $jsdir = "../../javascript";
	    $imagedir = "../../images/";
	    $topfile = "../../index.html";
	} else {
	    $css = "../style/miadoc.css";
	    $jsdir = "../javascript";
	    $imagedir = "../images/";
	    $topfile = "../index.html";
	}
    }
    $lastmodscript = "$jsdir/lastmod.js";
    $tocfile = "index.html";
    $indexfile = "inx.html";

    $leftmargin=25;
}

sub one_up
{
    local ($path) = @_;

    if ($fullpath){
	return $path;
    } else {
	return "../" . $path;
    }
}

sub expand 
{
    local ($path) = @_;
    while ($path =~ m/\$(\w+)/){
	local $var = $1;
	if (!defined($ENV{$var})){
	    print "Expand $path: Warning: $var not in environment\n";
	} else {
	    $path = $` . $ENV{$var} . $';
	}
    }
    return $path;
}

sub strip_extension
{
    local ($string) = @_;
    if ( $string =~ m/([^\.]+)\..*/ ) {
	$string = $1;
    }
    return $string;
}

sub strip_path
{
    local ($string) = @_;
    if ( $string =~ m%.*/([^/]+$)% ) {
	$string = $1;
    }
    return $string;
}

sub legal_identifier

{
    local ($id) = @_[0];
    return ($id =~ m/[a-zA-Z_]\w*/);
}

sub print_valid_html_button()
{
    local ($up1) = @_;
    local ($imagedir1);

    if ($up1){
	$imagedir1 = &one_up($imagedir);
    } else {
	$imagedir1 = $imagedir;
    }

    print<<EOT if ($insert_validhtml40);
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="${imagedir1}vh401.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
EOT
}

sub print_rel_link
{
    local ($type, $href) = @_;
    $type = ucfirst ($type);
    print<<EOT;
<LINK REL="$type" HREF="$href">
EOT
}

sub print_nav_link
{
    local ($type, $href, $title) = @_;
    local ($label) = ucfirst ($type);
    if ($href ne ""){
	print "document.write(\'\\<A HREF=\"$href\" CLASS=\"SideBar\"\\ TITLE=\"$title\">$label\\</A\\>\\<BR\\>');\n";
    }
}

sub print_layer_begin
{

    local ($up1) = @_;
    local ($imagedir1);

    if ($up1){
	$imagedir1 = &one_up($imagedir);
    } else {
	$imagedir1 = $imagedir;
    }
    
    print<<EOT;
<LAYER id="SideBar" onMouseover="pull()" onMouseout="draw()" style="position:absolute;left:-95px;width:80px;layer-background-color:#00557A;padding:5px;line-height:25px; ">
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2">
if (document.all){
  document.write('\\<DIV id="SideBar2" onMouseover="pull()" onMouseout="draw()" STYLE="position:absolute;left:-80px;top:15px;width:100px;background-color:#00557A;padding:5px;line-height:25px;cursor:move;" TITLE=\"Navigation Bar: Slides out when cursor is moved out\"\\>');
}
if (document.all && (navigator.userAgent.indexOf("Mac")==-1)) {
  document.write('\\<IMG SRC="$imagedir1/navigation.gif" STYLE="position:absolute;left:84;top:5" WIDTH=13 HEIGHT=63 ALT=""\\>');
} else {
  document.write('\\<IMG SRC="$imagedir1/navigation.gif" ALIGN=RIGHT WIDTH=13 HEIGHT=63 ALT=""\\>');
}
EOT
}

sub print_layer_end
{
    print<<EOT;
if (document.all)
  document.write('\\</DIV\\>');
else
  document.write('&nbsp;');
SetupSideBar();
</SCRIPT>
</LAYER>
EOT
}

sub print_head_begin
{
    local ($title, $up1) = @_;
    local ($jsdir1, $css1);

    if ($up1){
	$jsdir1 = &one_up($jsdir);
	$css1   = &one_up($css);
    } else {
	$jsdir1 = $jsdir;
	$css1   = $css;
    }

    print<<EOT;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<!-- Autogenerated file - do not edit -->
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>$title</TITLE>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript1.2" SRC="$jsdir1/sidebar.js">
</SCRIPT>
<LINK REL="stylesheet" HREF="$css1" TYPE="text/css">
EOT
}

sub print_header
{
    local ($title) = @_;
    local ($next, $prev);

    print_head_begin($title, 0);

    if ($filenumber==$#srcfiles){
	# last file
	if ($#interfaces>0){
	    &print_rel_link("next", "interface/" . &strip_extension(&strip_path($interfaces[0])) . ".html");
	} else {
	    &print_rel_link("next", $indexfile);
	}
    } else {
	$next = &strip_extension(&strip_path($srcfiles[$filenumber+1]));
	&print_rel_link("next", "$next.html");
    }
    if ($filenumber==0){
	# first file
	&print_rel_link("prev", $tocfile);
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$filenumber-1]));
	&print_rel_link("prev", "$prev.html");
    }
    &print_rel_link("start", $topfile);
    &print_rel_link("first", &strip_extension(&strip_path($srcfiles[0])) . ".html");
    &print_rel_link("last", &strip_extension(&strip_path($srcfiles[$#srcfiles])) . ".html");
    &print_rel_link("contents", $tocfile);
    &print_rel_link("index", $indexfile);
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");
    #&print_rel_link("copyright", "copyright.html");
    #&print_rel_link("help", "help.html");
    #&print_rel_link("search", "search.html");

    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(0);
    if ($filenumber==$#srcfiles){
	# last file
	if ($#interfaces>0){
	    local ($intfile) = &strip_extension(&strip_path($interfaces[0]));
	    &print_nav_link("next", 
			    "interface/$intfile.html", 
			    "Next: " . ucfirst($intfile) . " Interface");
	} else {
	    &print_nav_link("next", $indexfile, "Next: Alphabetic Index");
	}
    } else {
	$next = &strip_extension(&strip_path($srcfiles[$filenumber+1]));
	&print_nav_link("next", "$next.html", "$next.html");
    }
    if ($filenumber==0){
	# first file
	&print_nav_link("previous", $tocfile, "Previous: Table of Contents");
    } else {
	$prev = &strip_extension(&strip_path($srcfiles[$filenumber-1]));
	&print_nav_link("previous", "$prev.html", "$prev.html");
    }
    &print_nav_link("top", $topfile, "Top: Manuals Main Entry");
    &print_nav_link("content", $tocfile, "Table of Contents");
    &print_nav_link("index", $indexfile, "Alphabetic Index");
    &print_nav_link("PDF", $pdf, "Portable Document Format version of manual");
    &print_layer_end;

}

sub print_trailer
{
    local ($title, $up1) = @_;
    local $lastmodscript1;
    if ($up1){
	$lastmodscript1 = &one_up($lastmodscript);
    } else {
	$lastmodscript1 = $lastmodscript;
    }

    &print_valid_html_button($up1);

    print<<EOT;
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>$title</ADDRESS></TD>
<TD width="20%" align="center">$copyright</TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE="JavaScript1.2" SRC="$lastmodscript1"></SCRIPT></TD>
</TABLE>
<P></P>
</BODY>
</HTML>
EOT
}

sub print_toc_header
{
    local ($next) = &strip_extension(&strip_path($srcfiles[0]));

    print_head_begin($title, 0);

    &print_rel_link("next", "$next.html");
    &print_rel_link("start", $topfile);
    &print_rel_link("first", &strip_extension(&strip_path($srcfiles[0])) . ".html");
    &print_rel_link("last", &strip_extension(&strip_path($srcfiles[$#srcfiles])) . ".html");
    &print_rel_link("contents", $tocfile);
    &print_rel_link("index", $indexfile);
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");
    #&print_rel_link("copyright", "copyright.html");
    #&print_rel_link("help", "help.html");
    #&print_rel_link("search", "search.html");


    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(0);
    &print_nav_link("next", "$next.html", "$next.html");
    &print_nav_link("top", $topfile, "Top: Manuals Main Entry");
    &print_nav_link("index", $indexfile, "Alphabetic Index");
    &print_nav_link("PDF", $pdf, "Portable Document Format version of manual");
    &print_layer_end;
}

sub print_interface_header
{
    local ($title) = @_;
    local ($next, $prev, $jsdir1);

    print_head_begin($title, 1);

    if ($filenumber==$#interfaces){
	# last interface file
	&print_rel_link("next", &one_up($indexfile));
    } else {
	$next = &strip_extension(&strip_path($interfaces[$filenumber+1]));
	&print_rel_link("next", "$next.html");
    }
    if ($filenumber==0){
	# first interface file
	&print_rel_link("prev", &one_up(&strip_extension(&strip_path($srcfiles[$#srcfiles]))));
    } else {
	$prev = &strip_extension(&strip_path($interfaces[$filenumber-1]));
	&print_rel_link("prev", "$prev.html");
    }
    &print_rel_link("start", &one_up($topfile));
    &print_rel_link("first", &one_up(&strip_extension(&strip_path($srcfiles[0]))) . ".html");
    &print_rel_link("last", &one_up($indexfile));
    &print_rel_link("contents", &one_up($tocfile));
    &print_rel_link("index", &one_up($indexfile));
    &print_rel_link("author", "mailto:support\@mjolner.com?Subject=MIADOC Manual Comment");
    #&print_rel_link("copyright", &one_up("copyright.html"));
    #&print_rel_link("help", &one_up("help.html"));
    #&print_rel_link("search", &one_up("search.html"));

    $jsdir1 = &one_up($jsdir);
    print<<EOT;
</HEAD>
<BODY style="margin-left:${leftmargin}px">
EOT

    &print_layer_begin(1);
    if ($filenumber==$#interfaces){
	# last interface file
	&print_nav_link("next", &one_up($indexfile), "Next: Alphabetic Index");
    } else {
	$next = &strip_extension(&strip_path($interfaces[$filenumber+1]));
	&print_nav_link("next", "$next.html", "Next: " . ucfirst($next) . " Interface");
    }
    if ($filenumber==0){
	# first interface file
	$prev = &one_up(&strip_extension(&strip_path($srcfiles[$#srcfiles])));
	&print_nav_link("previous", "$prev.html", "$prev.html");
    } else {
	$prev = &strip_extension(&strip_path($interfaces[$filenumber-1]));
	&print_nav_link("previous", "$prev.html", "Previous: " . ucfirst($prev) . " Interface");
    }
    &print_nav_link("top", &one_up($topfile), "Top: Manuals Main Entry");
    &print_nav_link("content", &one_up($tocfile), "Table of Contents");
    &print_nav_link("index", &one_up($indexfile), "Alphabetic Index");
    &print_nav_link("PDF", &one_up($pdf), "Portable Document Format version of manual");
    &print_layer_end;

}


sub read_book_file
{
    if ($#ARGV == 0){ 
	$book_file_name = $ARGV[0];
    } else {
	&usage();
    };
    
    open SEQUENCE, $book_file_name || die "Cannot open \"$book_file_name\" file: !$\n";
    while (<SEQUENCE>){
	chomp;
	# remove comments
	s/\#.*$//;
	# skip blank lines
	next if (m/^\s*$/);
	if (-f "src/$_"){
	    push @srcfiles, "$_";
	} else {
	    if (m/^date:\s*(.*)$/){ $date = $1 };
	    if (m/^mia:\s*(.*)$/){ $mia = $1 };
	    if (m/^title:\s*(.*)$/){ $title = $1 };
	    if (m/^copyright:\s*(.*)$/){ 
		$copyrightyears = $1; 
		$copyright = 
		    "<FONT size=-1>&COPY; $copyrightyears <A HREF=\"http://www.mjolner.com\">Mj&oslash;lner Informatics</A></FONT>";

	    };
	    if (m/^pdf:\s*(.*)$/){ $pdf= $1 };
	    if (m/^int:\s*(.*)$/){ push @interfaces, &expand($1) };
	}
    }
    if ($debug){
	print STDERR "read book file $book_file_name.\n";
	print STDERR "  date:      $date\n";
	print STDERR "  mia:       $mia\n";
	print STDERR "  title:     $title\n";
	print STDERR "  copyright: $copyrightyears\n";
	print STDERR "  pdf:       $pdf\n";
	print STDERR "  sequence:\n    ";
	print STDERR join("\n    ",@srcfiles);
	print STDERR "\n  interfaces:\n    ";
	print STDERR join("\n    ",@interfaces);
	print STDERR "\n";
    }
}

sub process_file
{
    local $file = $srcfiles[$filenumber];
    print STDERR "Generating $file from src/$file\n" if $verbose;

    printf STDERR "Reading src/$file ...\n" if $verbose==1;

    if (!open(SRC, "src/$file")){
	print "Cannot open src/$file for reading: $!\n";
	return;
    }

    $line="";
    while (<SRC>) {
	$line .= $_;
    };
    close (SRC);


    printf STDERR "Writing to $file ... " if $verbose==1;
    if (!open (STDOUT, ">$file")){
	print "\nCannot open $file for writing: $!\n";
	return;
    }
    &print_header($title);
    print $line;
    &print_trailer($title, 0);
    close (STDOUT);

    printf STDERR "\ndone\n\n" if $verbose==1;


}

sub process_src_files
{
    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	&process_file($srcfiles[$filenumber]);
    }
}

sub print_toc
{
    print<<EOT;
<A NAME="_toc"></A>

<DIV CLASS=toc>
<DL>
<DT><A HREF="index.html#_toc"><B>Contents</B></A><DD>
  <DL>
EOT

    for ($filenumber=0; $filenumber<=$#srcfiles; $filenumber++){
	print "  <DT><A HREF=\"$srcfiles[$filenumber]\">";
	print "$srcfiles[$filenumber]</A> (FIXME: extract heading)<DD>\n";
    }

    if ($#interfaces>0){
	print "  <DT><I>Interface Descriptions:</I> (FIXME)<DD>\n";
	print "    <DL>\n";
        for ($filenumber=0; $filenumber<=$#interfaces; $filenumber++){
	    local ($f);
	    $f = $interfaces[$filenumber];
	    $f = &strip_extension(&strip_path($f));
	    print "    <DT><A HREF=\"interface/$f.html\">";
	    print ucfirst($f) . " Interface</A><DD>\n";
	}
	print "    </DL>\n";
    }

    print<<EOT;
  <DT><A HREF="inx.html">Index</A> (FIXME)<DD>
  </DL>
</DL>
</DIV>
EOT

}

sub make_title_page
{
    printf STDERR "\nWriting title page index.html ... " if $verbose==1;
    open (STDOUT, ">index.html") || die "\nCannot open index.html for writing: $!\n";
    &print_toc_header($title);

    print<<EOT;
<H1>$title</H1>

<P>
<CENTER>
<B>
Mj&oslash;lner Informatics Report<BR>
$mia<BR>
$date</B>
<P>
</CENTER>
EOT

    &print_toc;

    &print_trailer($title, 0);
    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;
}

sub read_and_abstract_beta
{
    local ($was_blank);

    open (BETA, "$betafile") || die "\nCannot open $betafile for reading: $!\n";

    # Read entire BETA file into $betaline, while doing single-line editing.
    $betaline = "";
    while (<BETA>){
	s/<<.*\bOBJECTDESCRIPTOR\b.*>>/.../gi;
	s/<<.*\bDESCRIPTOR\b.*>>/.../gi;
	s/<<.*\bDOPART\b.*>>/.../gi;    
	    
	# Uppercase inner
	s/\bINNER\b/INNER/gi;
	# Remove trailing blanks
	s/^(.*)\s*$/$1\n/;
	
	# Squeze multiple blank lines down into one
	next if /\S/ ? ($was_blank=0) : $was_blank++;
	
	$betaline .= $_;
    }

    # Now perform multiline editing

    $*=1;
    $_=$betaline;

    # delete RCS/CVS stuff
    s/\$\Revision:[^\$]*\$//;
    s/\$\RCSfile:[^\$]*\$//; 
    s/\$\Date:[^\$]*\$//;
    s/\$\Author:[^\$]*\$//;

    s/\bdo\s*\.\.\./do .../gi;
    s/\bINNER(;?)\s*\.\.\./INNER$1 .../g;
    s/do\b\s*/do /gi;
    s/\(\#\s*do\s+INNER(;?)\s*\#\)/\(\# do INNER$1 \#\)/g;
    s/\(\#\s*do\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do INNER$1 ... \#\)/g;
    s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s*\#\)/\(\# do ... INNER$1 \#\)/g;
    s/\(\#\s*do\s+\.\.\.\s+INNER(;?)\s+\.\.\.\s*\#\)/\(\# do ... INNER$1 ... \#\)/g;
    s/(:< *)\s*\(\#(.*)\#\);?/$1(\#$2\#);/g;
    s/\.\.\.  /... /g;

    # Delete other lines containing the word "private" or the word "implpart"
    #s/.*private.*\n+//gi;
    s/.*implpart.*\n+//gi;

    $betaline = $_;
    $*=0;

    close (BETA);

}

sub make_interface_file
{
    local ($betafile) = @_;
    local ($htmlfile) = "interface/" . &strip_extension(&strip_path("$betafile")) . ".html";   
    local ($inttitle) = ucfirst(&strip_extension(&strip_path("$betafile"))) . " Interface";

    printf STDERR "\nMaking $htmlfile\n  from $betafile ... \n" if $verbose==1;
    &read_and_abstract_beta();

    open (STDOUT, ">$htmlfile") || die "\nCannot open $htmlfile for writing: $!\n";

    print_interface_header($inttitle);
    print<<EOT;
<H1>$inttitle</H1>
<PRE CLASS=interface>
EOT

    $_ = $betaline;		

    # Mark '(#', '#)' and ':' in comments to avoid interference with
    # subsequent matchings.

    $after = $_;			# in case of no comments at all
    $betaline = "";

    printf STDERR "Substituting special symbols...\n" if $verbose==1;
    
    while ( /\(\*|\*\)/ ) {
	$before = $`;
	$match  = $&;
	$after  = $';
	if ( $match eq '*)' ) {
	    $before =~ s/:/\001/g;
	    $before =~ s/\(\#/\002/g;
	    $before =~ s/\#\)/\003/g;
	}
	$betaline .= $before.$match;
	$_ = $after;
    }
    $_ = $betaline.$after;
    
    # Substitute ':' in slots with \004
    s/(\<\<\s*SLOT\s*\w+\s*):(\s*\w+\s*\>\>)/$1\004$2/gi;
    
    # Substitute ':' in fragmentIds with \004
    #   (assumes entire fragment syntax on one line - I think)
    s/(\-\-+\s*\w+\s*):(\s*\w+\s*\-\-+)/$1\004$2/g;
    
    # quote HTML
    s/&/\007/g;
    s/</\021/g;
    s/>/\022/g;
    
    # Run through $_, matching for pattern-begin and pattern-end, while
    # keeping track of scope level.
    # Insert nested index-information for declarations at the outermost
    # $scope levels.
    $scope  = 2;

    $*=0;
    $patterns = "";
    $revpatterns = "";
    $level  = 1;
    $betaline = "";
    $prefix = "";

    printf STDERR "Searching for idx-comments/patterns/colons .....\n" if $verbose==1;
    if   (! m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	printf STDERR "  None found - emitting without markup\n" if $verbose==1;
	$betaline = $_;
    }
    while(m/\n[ \t]*\(\*\s+idx([\+\-\=\001])\s*(\d*)\s*\*\)\s*\n|\(\#|\#\)|::?<?/i ){
	$before = $`;
	$match  = $&; 
	$idxop  = $1; $idxlev = $2; # if index information present
	$after  = $';
	if ( "$idxop" ne "" ) {
	    # index pseudo comment found
	    if ( "$idxop" eq "+" ) { $scope++; }
	    elsif ( "$idxop" eq "-" ) { $scope--; }
	    if ( "$idxop" eq "=" || "$idxop" eq "\001" ) {
		if ( "$idxlev" eq "" ) {
		    print "No level specified in idx= command";
		    return;
		}
		$scope = $idxlev;
	    }
	    $match = ""; # delete comment
	    $after = "\n".$after;
	    # $match = "\nINDEXLEVEL: $scope\n";
	}
	elsif ( "$match" eq "(#" ) {
	    # add previously found identifier in scope description
	    if ( "$patternid" ne "" ) {
		$patterns .= "$patternid.$level:";
		printf STDERR "***  %s\n", $patternid if $trace==1;
	    } else {	
		if (($outfile eq "betaenv.html") && ($level == 1)){
		    $patterns .= "betaenv.1:";
		    printf STDERR "  BETAENV\n" if $trace==1;
		} else {
		    $patterns .= "ANONYMOUS.$level:";
		    printf STDERR "  ANONYMOUS\n" if $trace==1;
		}
	    }
	    $level += 1;
	    $patternid = "";
	    # $match = "BEGIN";
	    # $match = "\n[PATTERNS: $patterns]\n";
	}
	elsif ( "$match" eq "#)" ){	
	    # check if $before ends with "#".
	    if ( ($before =~ /\#$/ ) && ( ! ( $before =~ /\#\#$/ ) ) ) {
		# found something like 
		#   "... ->F##)
		# i.e. a pattern variable at end of a parenthesed
		# evaluation.
		# This is NOT a pattern end!
		printf STDERR "\n******* NOTICE: In the text ending like this:\n";
		printf STDERR substr($betaline.$before.$match, -100, 100);
		printf STDERR "\n******* the '##)' is not considered a pattern end.";
		printf STDERR "\n******* Please check if this is correct.\n\n";	
		# Just precede.
	    } else {
		# This is really a pattern end
		$level -= 1;
		if ( $patterns =~ m/:\w+.\w+:$/ ) {
		    $patterns = $`.":";
		}
		elsif ( $patterns =~ m/^\w+.\w+:$/ ) {
		    $patterns = "";
		} else {
		    $betaline .= $before.$match;
		    print "*** PATTERNS is wrong: $patterns";
		    print "*** context:";
		    print "\n------------\n";
		    print substr($betaline, -100,100);
		    print "\n------------\n";
		}
		# $match .= "\n[PATTERNS: $patterns]\n";
	    }
	}
	elsif ( $match =~ m/:/ )  { # a colon was found
	    if ( $level <= $scope ){
		# Identifiers must start with alpha or _.
		# In betaenv, there is "exit T[1:lgth], which would
		# cause 1: to be identified as identifier.
		# However, if [a-zA-Z_] is used instead of \w,
		# the "[1:" does not get into the output (:-(
		if ( $before =~ m/(\w+[\w\s,]*)\s*$/ ) {
		    $head = $`;
		    @ids = split( ',' , $1); # list of identifiers, e.g.: x, y, z
		    $tail = "";
		    $prefix = "";
		    if ( $after =~ m/^\s*\(\*/ ) {
			# move comment after colon but before prefix from $after to $tail
			$tail = $&;            # the stuff matched by the regexp
			$after = $';           # the stuff after the match
			$after =~ m/\*\)\s*/;  # MUST succeed if comment matches
			$tail .= $`.$&;        # the stuff before the last match and the match itself
			$after = $';           # the stuff after the match
		    }
		    
		    if ( $after  =~ m/^\s*(\w+)\s*\(\#/ ) { 
			$prefix = $1;
		    } else {
			# the match for prefix failed.
			# look ahead and check if there was a comment after the prefix
			# and try the match again.
			# don't change $tail or $after (historical: superpattern index generation)
			if ( $after =~ m/^\s*(\w+)\s*\(\*/ ) {
			    # there was a comment after the word after the colon
			    $possibleprefix = $1;
			    # set $peekafter to the stuff after the match, i.e. start of comment text
			    $peekafter = $';
			    $peekafter =~ m/\*\)\s*/;  # MUST succeed if comment matches
			    # set $peektext to the stuff after the match, i.e. what's after the comment
			    $peekafter = $';           
			    if ( $peekafter  =~ m/^\s*\(\#/ ) {
				# there was a pattern-begin after the comment
				$prefix = $possibleprefix; 
			    }
			}
		    }
		}
		
		$marker = $match;
		$match = "";

		if ( @ids == 1 ) {
		    # keep identifier for next "(#" found
		    $patternid = $ids[0];
		    $patternid =~ s/\s//g;
		} else {
		    $patternid = "";
		}

		$before = $head;
		foreach $id ( @ids ) {
		    #print STDERR "IDS: @ids\n";
		    $id =~ m/(\w+)/; # MUST succeed
		    $anchor += 1;
		    $idxid = "$1.$level($anchor)"; # $id without whitespace.
		    if (&legal_identifier($id)){
			$bid = "<B>$id</B>"; # boldface anchored identifier
		    } else {
			$bid = $id;
		    }
		    if ( "$patterns" eq "" ){
			$before .= "$bid<A name=\"$idxid\"></A>";
			$index[$indexid++] = "$idxid\@$outfile";
			#print STDERR "111. {$idxid\@$outfile}\n";
		    } else { 
			# inner scope
			$before .= "$bid<A name=\"$patterns$idxid\"></A><A name=\"$idxid\"></A>";
			#print STDERR "222. {$idxid\@$outfile}\n";
			$index[$indexid++] = "$idxid\@$outfile";
			#print STDERR "333. {$patterns$idxid\@$outfile}\n";
			$index[$indexid++] = "$patterns$idxid\@$outfile";
		    } # inner scope
		    $before .= ",";
		} # foreach id
		$before =~ s/,$//;
		$before .= $marker.$tail;
	    } # $level <= $scope
	} # colon was found
	else {
	    print "Something is wrong in while loop !!!";
	    return;
	} # "switch" on $match finished
	
	$betaline .= $before.$match;
	$_ = $after;
    } # while

    $_ = $betaline."\n";

    printf STDERR "Cleaning up...\n" if $verbose==1;

    # Clean up
    s/\001/:/g;
    s/\002/\(\#/g;
    s/\003/\#\)/g;
    s/\004/:/g;
    s/\005/</g;
    s/\006/>/g;
    s/\007/&amp;/g;
    s/\021/&lt;/g;
    s/\022/&gt;/g;

    printf STDERR "Writing interface ... " if $verbose==1;
    print;
    
    print<<EOT;
</PRE>
EOT
    print_trailer("$inttitle", 1);

    close (STDOUT);
    printf STDERR "done.\n" if $verbose==1;

}

sub process_interface_files
{
    print STDERR "Generating interface descriptions...\n" if $verbose;

    if (! -d "interface"){
	if (!mkdir("interface",0755)){
	    print STDERR "Cannot create directory \"interface\": $!\n";
	    return;
	}
    }
    
    for ($filenumber=0; $filenumber<=$#interfaces; $filenumber++){
	&make_interface_file("$interfaces[$filenumber]");
    }

    
}

### main #######

# Command line options
$verbose = 1 if (defined($v));
$debug = 1 if (defined($d));

# variables
&set_default_variable_values();

&read_book_file;

&process_src_files;

&process_interface_files;

&make_title_page;
