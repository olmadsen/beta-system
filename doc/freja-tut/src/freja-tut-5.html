<H2><INX>Editing</INX></H2>

<H2><INX>Creating a New Diagram</INX></H2>
<P> To create a new diagram use <INX><em>Diagrams:New Diagram...</em></INX> in the source browser. Below the command New BETA program has been used:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/newdiagram.gif></CENTER>
<P> </P>
<P> The title of the diagram corresponds to the name and the category (attributes) of the new BETA fragment:</P>
<BETA>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/freja/associations';
-- lib: Attributes --
<<NameDecl>>: (#  #)  
</BETA>

<H3><INX>Creating a New Class</INX></H3>
<P> When an attribute or a title of a diagram is selected it is possible to create a new class using the Class command in the <EM>New</EM> menu [<b>tip:</b> you may also right-click the class or attribute and select <em>New:Local Class...</em> from a popup-menu]. Doing this you get a dialog where the name of the new class can be typed in.</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/newclass.gif></CENTER>
<P> </P>
<P> The BETA code corresponding to new class looks like this:</P>
<BETA>
Person:(# #)
</BETA>

<H3><INX>Adding Attributes and Operations</INX></H3>
<P> To add an attribute to a class, select the class and use <em>New:Attribute...</em>  [<b>tip:</b> you may also right-click the class and select <em>New:Attribute...</em> from a popup-menu]. As above a dialog is presented and you can now type in the name of the new attribute.</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/newattribute.gif></CENTER>
<P> </P>
<P> The corresponding BETA code looks like this:</P>
<BETA>
Person(# FirstName: @Text #)
</BETA>
<P> In the same manner as with attributes a new operation "display" can be added to the class using <EM>New:Operation...</EM>. This makes the diagram appear as follows:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/afternewattribute.gif></CENTER>
<P> </P>
Notice the first item in the diagram,  &lt;&lt;NameDecl&gt;&gt;() ..., is still there. This is meant as first template for a new class (the &lt;&lt;NameDecl&gt;&gt; part is a placeholder for the name of the class). In this case, where we have already created a new class using <em>New:Class...</em>, we could just delete this first item by selecting it and using <em>Edit:Clear</em>. However, we can also choose to use it as a template for a new class. To do this, select it and use the <em>Edit...</em> entry of the right-click popup-menu to replace "&lt;&lt;NameDecl&gt;&gt;" with the name "Reservation".

<H3>Specifying <INX>Specialization</INX></H3>
<P> In the following situation one class further, FlightReservation, has been added to the diagram. To specify that FlightReservation is a subclass of Reservation the <EM>Specialization</EM> command of the <EM>Relations </EM>menu is used. As the status message of the menubar states in the example below it is now possible to create a specilization by clicking the left mouse button on the subclass and hereafter clicking the right mouse button on to the superclass. </P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/specialization.gif></CENTER>
<P> </P>
<P> The result will look like this:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/afterspecialization.gif></CENTER>
<P> </P>
<P> The code correspondingly changes from:</P>
<BETA>
Reservation: (# ... #);
FlightReservation: (# ... #);
</BETA>
<P> to:</P>
<BETA>
Reservation: (# ... #);
FlightReservation: Reservation(# ... #);
</BETA>

<H3><INX>Specifying Aggregation</INX></H3>
<P> Below the class Flight has been added to the diagram.</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/aggregation.gif></CENTER>
<P> </P>
<P> We wish to specifify a by-reference aggregation between FlightReservation and Flight. To do this select <EM>Aggregation</EM> in the <EM>Relations</EM> menu. This brings up the following dialog:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/aggregationdialog.gif></CENTER>
<P> </P>
<P> The aggregation dialog makes it possible to:</P>
<UL>
<LI> give the aggregation a name
<LI> specifify the multiplicities of the whole and the part
<LI> specify the implementation of a one-to-many
<FOOTNOTE>An aggregation is said to be one-to-many if the multiplicity of the part is one and the multiplicity of the whole is more than one</FOOTNOTE>

aggregation; that is to specify if a repetition or one of  the basic container classes should be used in the resulting code (using the <em>Implementation</em> tab)
<LI> specify if the aggregation is to be implemented by-reference or by-value (using the <em>Implementation</em> tab)
<LI> give a textual description of the aggregation
<LI> set a number of preferences for the visual presentation of the aggregation (using the <em>Display Preferences</em> tab)
</UL>
<P> In this example we only specify the name of the aggregation (defaults are such that we get a one-to-one by-reference aggregation).</P>
<P> After choosing <EM>Ok</EM> in the dialog left click on the class designating the whole (FlightReservation) and, after that, right click on the class designating the part (Flight).</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/afteraggregation.gif></CENTER>
<P> </P>
<P> The BETA code correspondingly changes from:</P>
<BETA>
Flight: (# #);
FlightReservation: Reservation(#  #)
</BETA>
<P> to:</P>
<BETA>
Flight: (# ... #);
FlightReservation: Reservation(# theFlight: ^Flight #)
</BETA>
<P> As can be seen the name of the aggregation is reused in the code and the fact that we created a by-reference aggregation is reflected by the dynamic reference implementation of the new declaration (had we instead chosen by-value a static reference would have been declared).</P>

<H3><INX>Specifying Association</INX></H3>
<P> Below a new class Company has been added to the diagram.</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/association.gif></CENTER>
<P> </P>
<P> We wish to specify a one-to-many association between Company and Person. To do this select <EM>Association</EM> in the <EM>Relations</EM> menu. This brings up the following dialog:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/associationdialog.gif></CENTER>
<P> </P>
<P> The Association dialog makes it possible to:</P>
<UL>
<LI> give the association a name
<LI> specify role names for both sides of the association
<LI> specify multiplicities for both sides of the association
<LI> specify if the association should be embeded or not; that is to specify if the generated code is to result in a separate association class or if it is to be embedded in the source and destination classes (using the <em>Implementation</em> tab) (see below)
<LI> give a textual description of the association
<LI> set a number of preferences for the visual presentation of the association (using the <em>Display Preferences</em> tab)
</UL>
<P> In this example we specify the name of the association, WorksFor, the name of the source role, employee, the name of the destination role, employer, and the multiplicities. Specifying that the multiplicity of the employee end of the association is more than one (in this case '*') automatically sets the implementation to the default, List. </P>
<P> After choosing <EM>Ok</EM> in the dialog left click on the class designating the source (Person) and right click on the class designating the destination (Company).</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/afterassociation.gif></CENTER>
<P> </P>
<P> The resulting code looks like this:</P>
<BETA>
Person: (# ...; employer: ^WorksFor #);
Company: (# employee: ^WorksFor #);
WorksFor: OneToManyAssociation
  (# oneType:: Company; manyElmType:: Person #)
</BETA>
<P> Where the things added to code are the employer and employee declarations and the WorksFor class.</P>
<P> Had the embed option been chosen the code would have looked like this:</P>
<BETA>
Person: (# ...; employer:@AssociationOne(# element:: Company #) #);
Company: (# employee:@AssociationMany(# element:: Person #) #)
</BETA>
<P> Notice that in this case no separate association class is generated.</P>

<H3><INX>Completing the Code in Code Editor</INX></H3>
<P> Consider the following design diagram which could be considered as complete at the design level:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/completemodel.gif></CENTER>
<P> To fill out the code details, the code editor, the textual representation editor must be activated:</P>
<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/codeeditor.gif></CENTER>
<P> </P>
<P> The textual representation of the design might, however, not be complete. For example, it still contains operations with empty do-parts. To fill out the do-part of the getFlightNo operation in the FlightReservation Class select the entire getFlightNo pattern in the code editor. Enter text edit mode and type in the appropriate action sequence. For example:
<BETA>
getFlightNo:
  (#
     do theFlight.no->putint
   #)
</BETA>
Notice: When entering text edit mode with the entire getFlightNo pattern selected we are warned that such editing <I>might</I> have the consequence that parts of the diagram have to be rebuildt. In this case, however, we choose to ignore the warning and enter text edit mode anyway. As it turns out the diagram was not affected at all by the edit because only a do-part was changed (action sequences do not have a visual representation in the diagrams; only static structures have).
<P> After filling out more code in the code editor, e.g.  further action sequences of the objects, the compiler is activated in the <EM>Compile/Run </EM>menu of the code editor.</P>
<P> If the compiler reports a semantic error, the corresponding node is also selected in Freja.</P>
<P> When the program is semantically correct and it can be executed and tested. In this phase Freja will typically not be activated. When the program has been tested and considered fulfilling the requirements, the design diagrams may have become obsolete, and need to be updated, i.e. reverse engineering is necessary. This is done by activating Freja on the BETA program. </P>



