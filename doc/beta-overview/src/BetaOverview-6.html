<H1>4  Subprocedure</H1>

The previous section has showed examples of patterns used as classes
and procedures. For class patterns, examples of subpatterns have been
given. Subpatterns may, also be used for procedure patterns. For
attributes, subpatterns may add new attributes and extend definitions
of virtual patterns in the superpattern. In addition a subpattern may
specify further imperatives which have to be combined with the
imperatives of the superpattern. The combination of the imperatives is
handled by the <EM>inner</EM> construct. Consider the following
objects:

<PRE CLASS=beta>
mutex: @ Semaphore;
sharedVar: @Integer
</PRE>

The variable <CODE>sharedVar</CODE> is shared by a number of
concurrent processes. Mutual access to the variable is handled by the
semaphore <CODE>mutex</CODE>. <EM>Update</EM> of <CODE>shared</CODE>
should then be performed as follows:

<PRE CLASS=beta>
mutex.P; m+sharedVar -> sharedVar; mutex.V
</PRE>

This pattern of actions must be used whenever <CODE>shared</CODE> and
other shared objects have to be accessed. Instead of manipulating the
semaphore directly it is possible to encapsulate these operations in
an abstract procedure pattern. Consider the following pattern
<CODE>entry</CODE>:

<PRE CLASS=beta>
 entry: (#<EM>do</EM> mutex.P; <EM>inner</EM>; mutex.V #)
</PRE>

Execution of <CODE>entry</CODE> locks <CODE>mutex</CODE> before the
<EM>inner</EM> and releases it afterwards. <EM>inner</EM> may then in
subpatterns of <CODE>entry</CODE> be replaced by arbitrary
imperatives. Consider the following subpattern of <CODE>entry</CODE>:

<PRE CLASS=beta>
updateShared: entry
  (# m: @ integer
  <EM>enter</EM> m
  <EM>do</EM> sharedVar+m-> sharedVar
  #)
</PRE>

<P>Execution of an imperative

<PRE CLASS=beta>
123 -> updateShared
</PRE>

<P>will then result in execution of the actions</P>

<PRE CLASS=beta>
mutex.P; sharedVar+123->sharedVar; mutex.V
</PRE>

<P>We may now define an abstract superpattern corresponding to a monitor:
</P>

<PRE CLASS=beta>
monitor: <EM>(#</EM> mutex: <EM>@</EM> semaphore; entry: <EM>(#do</EM>
  mutex.P; <EM>inner</EM>; mutex.V <EM>#)</EM>; init:<EM>&lt;
  (#do</EM> mutex.V<EM>{</EM>initially open<EM>}</EM>; <EM>inner</EM>
  <EM>#)</EM> <EM>#);</EM>
</PRE>

<P>A (singular) monitor object may now be declared as follows:
</P>

<PRE CLASS=beta>
shared: <EM>@</EM> monitor
  <EM>(#</EM>var: <EM>@</EM> Integer;
     update: entry<EM>(#</EM> m: @ Integer <EM>enter</EM> m <EM>do</EM> var+m->var <EM>#)</EM>;
     get: entry<EM>(# </EM>v: @ Integer<EM> do </EM>var<EM>-></EM>v<EM> exit</EM> v <EM>#)</EM>
  <EM>#)</EM>
</PRE>

<P>Semaphore is the basic mechanism in BETA for synchronization. They
can express most synchronization problems, but may be complicated to
use. It is therefore mandatory that high level abstraction mechanisms
like <CODE>monitor</CODE> can be defined. In section 8 below, further
details about concurrency in BETA will be given.
</P>







<!-- TOC -->




