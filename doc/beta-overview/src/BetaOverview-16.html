<H1>8.2.2  Rendezvous example</H1>
<DL>
<DT><DD>The next example shows an example of using the library patterns for describing synchronized rendezvous. The example shows a drink machine that provides coffee and soup. A customer operates the machine by pushing either <CODE>makeCoffe</CODE> or <CODE>makeSoup</CODE>. If <CODE>makeCoffe</CODE> has been pushed, then the customer may obtain the coffee by means of <CODE>getCoffee</CODE>. Similarly if <CODE>makeSoup</CODE> has been pushed then the soup may be obtained by means of <CODE>getSoup</CODE>. 
</DL>
<P> The <CODE>System</CODE> pattern has a <CODE>port</CODE> attribute which may be used to define synchronization ports. The drink machine described below has three such ports, <CODE>activate</CODE>, <CODE>coffeeReady</CODE>, and <CODE>soupReady</CODE>. A <CODE>port</CODE> object has a pattern attribute <CODE>entry</CODE> which may be used to define procedure patterns associated with <CODE>port</CODE>. For the <CODE>port</CODE> <CODE>activate</CODE>, two procedure patterns <CODE>makeCoffee</CODE> and <CODE>makeSoup</CODE> are defined. For <CODE>coffeeReady</CODE> and <CODE>soupReady</CODE>, the procedure patterns <CODE>getCoffee</CODE> and <CODE>getSoup</CODE> are defined.</P>
<P> An execution of a port-entry operation like<CODE> aDrinkMachine.makeCoffee</CODE> will only be executed if the <CODE>DrinkMachine</CODE> has executed a corresponding accept by means of <CODE>activate.accept</CODE>.</P>
<UL>
<LI>Initially a <CODE>DrinkMachine</CODE> is ready to accept either <CODE>makeCoffee</CODE> or <CODE>makeSoup</CODE>.
<LI>If e.g. <CODE>makeCoffee</CODE> is executed, then when "the coffee has been made", the <CODE>DrinkMachine</CODE> is willing to accept the operation <CODE>getCoffee</CODE>. This is signalled by executing an accept on the port <CODE>coffeeReady</CODE>. Technically this is implemented by assigning a reference to <CODE>coffeeReady</CODE> to the port reference <CODE>drinkReady</CODE>. The do-part of <CODE>DrinkMachine</CODE>, then makes an accept on <CODE>drinkReady</CODE>.
<LI>When the operation <CODE>getCoffe</CODE> has been executed, the <CODE>DrinkMachine</CODE> is again ready to accept a new operation associated with the <CODE>activate</CODE> port.
</UL>
<PRE CLASS=beta>
DrinkMachine: System
  (# activate: @ port;
     makeCoffee: activate.entry(# <EM>do</EM> ... coffeeReady[]<EM>-></EM>drinkReady[] #);
     makeSoup: activate.entry(# <EM>do</EM> ... soupReady[]<EM>-></EM>drinkReady[] #);
     coffeeReady, soupReady: @ port;
     getCoffee: coffeeReady.entry(# <EM>do</EM> ... <EM>exit</EM> someCoffee [] #);
     getSoup: soupReady.entry(#<EM>do ... exit</EM> someSoup [] #);
     drinkReady: ^ port
  <EM>do</EM> cycle(#<EM>do</EM> activate.accept; drinkReady.accept #)
  #)
</PRE>
<DL>
<DT><DD>The <CODE>DrinkMachine</CODE> may be used in the following way:
</DL>
<PRE CLASS=beta>
   aDrinkMachine: @ | DrinkMachine
   ...
<EM>do</EM> aDrinkMachine.makeCoffee; aDrinkMachine.getCoffee;
   aDrinkMachine.makeSoup; aDrinkMachine.getSoup;
</PRE>
<DL>
<DT><DD>As it may bee seen the use of the patterns <CODE>System</CODE>, <CODE>port</CODE> and <CODE>entry</CODE> makes it possible to describe a concurrent program in the style of Ada tasks that synchronize their execution by means of rendezvous. A <CODE>port</CODE>-object defines two semaphores for controlling the execution of the associated <CODE>entry</CODE> patterns. The actual details will not be given in this paper. 
</DL>
<P> It is possible to specialize the <CODE>DrinkMachine</CODE> into a machine that accepts further operations:</P>
<PRE CLASS=beta>
ExtendedDrinkMachine: DrinkMachine
  (# makeTea: activate.entry(#<EM>do</EM> ... teaReady[]<EM>-></EM>drinkReady[] #);
     teaReady: @ port;
     getTea: teaReady.entry(# ... <EM>exit</EM> someTea[] #)
  #)
</PRE>
<DL>
<DT><DD>The <CODE>ExtendedDrinkMachine</CODE> inherits the operations and protocol from <CODE>DrinkMachi-ne</CODE> and adds new operations to the protocol.
</DL>
<P> The basic mechanisms in BETA for providing concurrency are component-objects (providing threads), the fork-imperative (for initiating concurrent execution) and the semaphore (for providing synchronization). As it has been mentioned already, these mechanism are inadequate for many situations. The abstraction mechanisms of BETA makes it possible to define higher-level abstractions for concurrency and synchronization. In this paper some examples have been given. Many researchers have proposed several alternative mechanisms for handling concurrency and synchronization. The motivation for this is due to problems with current proposals. </P>







<!-- TOC -->




