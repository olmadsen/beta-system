<H1>1  Introduction</H1>

BETA is a modern object-oriented language from the Scandinavian school
of object-orientation where the first object-oriented language Simula
[DMN70] was developed. BETA supports the object-oriented perspective
on programming and contains comprehensive facilities for procedural
and functional programming. BETA has powerful abstraction mechanisms
for supporting identification of objects, classification and
composition. BETA is a <EM>strongly typed</EM> language like Simula,
Eiffel [Mey88] and C++ [Str86], with most type checking being carried
out at compile-time. It is well known that it is not possible to
obtain all type checking a compile time without sacrificing the
expressiveness of the language. BETA has an optimum balance between
compile-time type checking and run-time type checking.

<P> The purpose of this paper is to present an overview of the BETA
language and give examples on the use of most constructs. The reader
is assumed to be familiar with one or more object-oriented languages
like Simula, Eiffel, C++, or Smalltalk [GR83]. For more details about
BETA see [KMMN83,KKMN87,MMN92].</P>

<H2> Powerful abstraction mechanisms</H2>

BETA has powerful abstraction mechanisms that provide excellent
support for <EM>design</EM> and <EM>implementation</EM>, including
data definition for persistent data. The powerful abstraction
mechanisms greatly enhances reusability of designs and
implementations.

<P> The abstraction mechanisms include: <EM>class</EM>,
<EM>procedure</EM>, <EM>function</EM>, <EM>coroutine</EM>,
<EM>process</EM>, <EM>exception</EM> and many more, all unified into
the ultimate abstraction mechanism: the <EM>pattern</EM>. In addition
to the pattern, BETA has <EM>subpattern</EM>, <EM>virtual pattern</EM>
and <EM>pattern variable</EM>. This unification gives a uniform
treatment of abstraction mechanisms and a number of new ones. Most
object-oriented languages have classes, subclasses and virtual
procedures, and some have procedure variables. Since a pattern is a
generalization of abstraction mechanisms like class, procedure,
function, etc., the notions of subpattern, virtual pattern and pattern
variable also applies to these abstraction mechanisms. In addition to
the above mentioned abstraction mechanisms, the pattern subsumes
notions such as generic package and task type as known from Ada.</P>

<P> The subpattern covers subclasses as in most other object-oriented
languages. In addition, procedures may be organized in a subprocedure
hierarchy in the same way as classes may be organized in a subclass
hierarchy. Since patterns may also be used to describe functions,
coroutines, concurrent processes, and exceptions, these may also be
organized in a pattern hierarchy.</P> <P> The notion of virtual
pattern covers virtual procedures like in Simula, Eiffel and C++. In
addition, virtual patterns cover virtual classes, virtual coroutines,
virtual concurrent processes, and virtual exceptions. Virtual classes
provide a more general alternative to generic classes as in Eiffel or
templates as in C++.</P>

<P> BETA includes the notion of pattern variable. This implies that
patterns are first class values, that may be passed around as
parameters to other patterns. By using pattern variables instead of
virtual patterns, it is possible dynamically to change the behavior of
an object after its generation. Pattern variables cover procedure
variables (i.e. a variable that my be assigned different
procedures). Since patterns may be used as classes, it is also
possible to have variables that can be assigned classes, etc.</P>

<P> BETA does not only allow for passive objects as in Smalltalk, C++,
and Eiffel. BETA objects may also act as coroutines, making it
possible to model alternating sequential processes and quasi-parallel
processes. BETA coroutines may be executed concurrent (non pre-emptive
scheduling in current implementation). The basic mechanism for
synchronization is semaphores, but high-level abstractions for
synchronization and communication, hiding all details about
semaphores, are easy to implement, and the standard library includes
<EM>monitors</EM>, and <EM>Ada-like rendezvous</EM>. The user may
easily define new concurrency abstractions including schedulers for
processes.</P>

<P> BETA supports the three main subfunctions of abstraction:</P>

<P><B> Identification of objects.</B></P>

<DL>
<DT><DD>It is possible to describe objects that are not generated as
instances of a class pattern, so-called "class-less objects". This is
in many cases useful when there is only one object of a kind. In most
object-oriented languages, it is necessary to define superfluous
classes for such objects. In analysis and design, it is absolutely
necessary to be able to describe singular objects without having them
as instances of classes.
</DL>

<P><B> Classification.</B></P>

<DL>
<DT><DD>Classification is supported by patterns, subpatterns, and
virtual patterns that makes it possible to describe classification
hierarchies of objects and patterns (i.e. objects, classes,
procedures, functions, coroutines, processes, exceptions, etc.).
</DL>

<P> <B>Composition (aggregation).</B></P>

<DL>
<DT><DD>Objects and patterns may be defined as a composition of other
objects and patterns. The support for composition includes:
</DL>

<UL>
<LI><EM>Whole/part composition</EM>: An attribute of an object may be
a part object. This makes it possible to describe objects in terms of
their physical parts.

<LI><EM>Reference composition</EM>: An attribute may be a reference to
another object. Reference composition forms the basis for modeling
arbitrary relations between objects.

<LI><EM>Localization (block-structure)</EM>: An attribute of an object
may be a (nested) pattern. This is known from Algol 60 as
<EM>block-structure</EM>. The block-structure makes it easy to create
arbitrary nested pattern. This makes it possible for objects to have
local patterns used as classes, procedures, etc. Local patterns
greatly enhances the modelling capabilities of an object-oriented
language.
</UL>

<P><B> Inheritance</B></P>

<DL>
<DT><DD>In BETA, inheritance is not only restricted to inheritance
from superpatterns. It is also possible to inherit from a part
object. Virtual patterns in the part object may be redefined to
influence the enclosing object. Multiple inheritance is supported
through inheritance from multiple part objects. This gives a much
cleaner structure than inheritance from multiple superpatterns.
</DL>

<P><B> Conceptual framework</B></P>

<DL>
<DT><DD>BETA is intended for modeling and design as well as
implementation. During the design of BETA the development of the
underlying conceptual framework have been just as important as the
language itself. For a description of the conceptual framework, see
[KM93]
</DL>


