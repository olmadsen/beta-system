<H1>9  Inheritance</H1>
<DL>
<DT><DD>The subpattern mechanism combined with the possibility of redefining/extending virtual procedures is widely recognized as a major benefit of object-oriented languages. This mechanism is often called inheritance since a subpattern is said to inherit properties (code) from its superpattern. Inheritance makes it easy to define new patterns from other patterns. In practice this has implied that subpatterns is often used for sheer inheritance of code without any concern for the relation between a pattern and its subpatterns in terms of generalization/specialization. The use of multiple inheritance is in most cases justified in inheritance of code and may lead to complicated inheritance structures.
</DL>
<P> In BETA subpatterns is intended for representing classification and inheritance of code is a (useful) side effect. In BETA it is not possible to define a pattern with multiple subpatterns corresponding to multiple inheritance. There are indeed cases where it is useful to represent classification hierarchies that are not tree structured. However, a technical solution that justifies the extra complexity has not yet been found.</P>
<P> BETA does support multiple inheritance, but in the form of inheritance from part objects. A compound object inherits from its parts as well as its superpattern. The reason that this has not been more widely explored/accepted is that in most languages inheritance from part objects lacks the possibility of redefining/extending virtual procedures in the same way as for inheritance from superpatterns. Block structure and singular objects makes this possible in BETA. </P>
<P> Assume that we have a set of patterns for handling addresses. An address has properties such as, street name, street no., city, etc., and a virtual procedure for printing the address. In addition we have a pattern defining an address register.</P>
<PRE CLASS=beta>
Address:
  (# streetName: @ text; streetNo: @ integer; city: @ text; ...
     print:&lt; (# <EM>do</EM> <EM>inner</EM>; streetName<EM>-></EM>putText; streetNo<EM>-></EM>putInt; {etc.} #);
  #);
AddressRegister: Register(# element::&lt; Address #)
</PRE>

<DL>
<DT><DD>We may use the <CODE>Address</CODE> pattern for defining part objects of <CODE>Employee</CODE>- and <CODE>Company</CODE>-objects:
  </DL>

<PRE CLASS=beta>
Employee:
  (# name: @ text; {the name of the employee}
     adr: @ address(# print::&lt; (#<EM>do</EM> name<EM>-></EM>putText #)#)
  #);
Company: 
  (# name: @ text; {the name of the company}
     adr: @ address(# print::&lt;(# <EM>do </EM>name<EM>-></EM>putText #) #)
  #);
</PRE>
<DL>
<DT><DD>The object <CODE>adr</CODE> of <CODE>Employee</CODE> is defined as a singular <CODE>Address</CODE> object where the virtual <CODE>print</CODE> pattern is defined to print the <CODE>name</CODE> of the <CODE>Employee</CODE>. As it can be seen it is possible to define a part object and define its virtual procedures to have an effect on the whole object. The <CODE>Company</CODE> pattern is defined in a similar way.
</DL>
<P> It is possible to handle the address aspect of employees and companies. An example is an address register:</P>
<PRE CLASS=beta>
   Areg: @ AddressRegister;
   ...
<EM>do</EM>employee1.adr[]<EM>-></EM>Areg.insert; employee2.adr[]<EM>-></EM>Areg.insert;
   company1.adr[]<EM>-></EM>Areg.insert; company2.adr[]<EM>-></EM>Areg.insert;
   Areg.scan(#<EM>do</EM> thisAdress.print #)
</PRE>
<DL>
<DT><DD>The <CODE>Areg</CODE> register will contain <CODE>Address</CODE> objects which are either part of <CODE>Employee</CODE> objects or <CODE>Company</CODE> objects. For the purpose of the register this does not matter. When the print procedure of one of these <CODE>Address</CODE> objects is invoked it will call the print procedure associated withe either <CODE>Employee</CODE> or <CODE>Company</CODE>. The scanning of the <CODE>Areg</CODE> register is an example of invoking the <CODE>print</CODE> pattern.
</DL>
<P> The example shows that in BETA inheritance from part objects may be used as an alternative to inheritance from superpatterns. The choice in a given situation depends of course on the actual concepts and phenomena to be modelled. In the above example it seems reasonable to model the address as a part instead of defining <CODE>Employe</CODE> and <CODE>Company</CODE> as specializations of <CODE>Address</CODE>.</P>
<P> In general it is possible to specify multiple inheritance from part objects since it is possible to have several part objects like the <CODE>Address</CODE> object above. This form of multiple inheritance provides most of the functionality of multiple inheritance from C++ and Eiffel. It is simpler since the programmer must be explicit about the combination of virtual operations. It does, however, not handle so-called overlapping superclasses. The programmer must also explicitly redefine the attributes of the component classes. This may be tedious if there is a large number of attributes. However, a renaming mechanism for making this easier has been proposed. Multiple inheritance from part objects should be used when there is a <EM>part</EM>-<EM>of</EM> relationship between the components and the compound. This also covers situations where implementations are inherited. It should not be used as a replacement for multiple specialization hierarchies. A more detailed discussion of using part objects for inheritance may be found in [MM 92].</P>
<P> In [&Oslash;st90] it is shown how a common example of using multiple inheritance for modeling windows with titles and borders may be handled using block structure. Since a window may have a title, a border or both, the following class hierarchy using multiple inheritance is often used:
  
  <IMG ALIGN=TOP SRC=WindowHierarchy.gif></P>

<DL>
<DT><DD>In [&Oslash;st90] its is shown how such windows may be described using nested patterns:
</DL>
<PRE CLASS=beta>
Window:
   (# Title: (# ... #);
      Border: (# ... #);
   ...
   #);
aWindow: @ Window(# T: @Title; B: @Border #)
</PRE>
<DL>
<DT><DD>The descriptions for title and border are made using nested patterns. For a given window, like <CODE>aWindow</CODE>, a title object and a border object may be instantiated. If e.g. two titles are needed, two instances of <CODE>Title</CODE> are made. For details see [&Oslash;st90]. This examples illustrates that another situation where multiple inheritance may be avoided.
</DL>







<!-- TOC -->




