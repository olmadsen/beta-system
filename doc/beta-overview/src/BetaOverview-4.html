<H1>2  Patterns and Objects</H1>

Most object-oriented languages supporting the object-oriented
perspective have constructs such as class, subclass, virtual
procedure, and qualified reference variable. These constructs all
originated with Simula. Eiffel and C++ include these constructs
although a different terminology is used. Subclass is called deferred
class in Eiffel and derived class in C++. Virtual procedure is called
deferred routine in Eiffel, and virtual function in C++. Qualified
reference is called reference field in Eiffel, and reference in
C++. The mentioned constructs are also the basic elements of
Smalltalk. Virtual procedure correspond to method, and qualified
reference to instance variable. For the latter a major difference is
that instance variables have no qualification (type). In addition to
virtual procedures, Simula, C++, and BETA have non-virtual procedures
.

<P> In this section, the BETA version of the above constructs will be
described and compared with other languages using the Simula
terminology. The example used in the following is a company with
different kinds of employees, including salesmen and
workers. <CODE>Employee</CODE> is an abstract superpattern describing
the common properties of all employees.</P>

<PRE CLASS=beta>
Employee:
  (# name: @ text;
     birthday: @ Date;
     dept: ^ Department;
     totalHours: @ Integer;
     RegisterWork:
       (# noOfHours: @ Integer
       <EM>enter</EM> noOfHours
       <EM>do</EM> noOfHours + totalhours -> totalHours
       #);
     ComputeSalary:&lt;
     (# salary: @ integer
     <EM>do</EM> <EM>inner</EM>
     <EM>exit</EM> salary
     #);
  #);
</PRE>

<EM>The elements of the <CODE>Employee </CODE>
pattern 
has the following meaning:</EM>

<UL>
<LI>The attributes <CODE>name</CODE>, <CODE>birthday</CODE>,
<CODE>dept</CODE> and <CODE>totalHours</CODE> are reference attributes
denoting instances of the patterns <CODE>Text</CODE>,
<CODE>Date</CODE>, <CODE>Department</CODE> and <CODE>Integer</CODE>
respectively.

<LI><CODE>Name</CODE>, <CODE>birthday</CODE>, and
<CODE>totalHours</CODE> refer to part objects. A part-object is a
fixed part of its enclosed object and is generated together with the
enclosing object. Simula and Smalltalk does not have part objects,
whereas Eiffel and C++ have some support.

<LI><CODE>Dept</CODE> is a dynamic reference that either has the value
<CODE>NONE</CODE> or refers to a separate instance of the pattern
<CODE>Department. </CODE>A dynamic reference is similar to a qualified
reference in Simula.

<LI>The attributes <CODE>RegisterWork, </CODE>and
<CODE>ComputeSalary</CODE> are pattern attributes describing actions
to be executed. They correspond to procedures in most other
languages. The enter-part describes the input-parameters of a pattern
and the exit-part describes its output
parameters. <CODE>RegisterWork</CODE> has one input parameter
<CODE>noOfHours</CODE> and <CODE>ComputeSalary</CODE> has one output
parameter, <CODE>salary</CODE>.

<LI><CODE>RegisterWork</CODE> is a non virtual pattern attribute. This
means that its complete description is given as part of the
description of <CODE>Employee</CODE>. It is similar to non virtual
procedure attributes in Simula.  <LI><CODE>ComputeSalary</CODE> is a
virtual pattern attribute. Only part of its description is given since
the computation of the salary is different for salesmen and
workers. The description of a virtual pattern may be extended in
subpatterns of <CODE>Employee</CODE>. A virtual pattern attribute is
similar to a virtual procedure in Simula.

<LI><CODE>Employee</CODE>, <CODE>RegisterWork</CODE> and
<CODE>ComputeSalary</CODE> are all examples of patterns.<CODE>
Employee</CODE> is an example of a pattern used as a class and is
therefore called a class pattern. <CODE>RegisterWork</CODE> and
<CODE>ComputeSalary</CODE> are examples of patterns used as procedures
and are therefore called procedure patterns. Technically there is no
difference between class patterns and procedure patterns.
</UL>

The following patterns are subpatterns of<CODE>
Employee</CODE> corresponding to salesmen and workers.

<PRE CLASS=beta>
Worker: Employee
  (# seniority: @ integer;
     ComputeSalary::&lt; 
     (# <EM>do</EM> noOfHours*80+seniority*4 ->salary; 0->totalHours #)
  #);
Salesman: Employee
  (# noOfSoldUnits: @ integer;
     ComputeSalary::&lt; 
     (#
     <EM>do</EM> noOfHours*80+noOfSoldUnits*6->salary; 
        0->noOfSoldUnits->totalHours
     #)
  #)
</PRE>

<UL>
<LI>The class pattern <CODE>Worker</CODE> adds the attribute<CODE>
seniority</CODE> and extends the definition of
<CODE>ComputeSalary</CODE>. The salary for a worker is a function of
the <CODE>noOfHours</CODE> being worked and the <CODE>seniority</CODE>
of the worker.

<LI>The class pattern <CODE>Salesman</CODE> adds the attribute
<CODE>noOfSoldUnits</CODE> and describes another extension of
<CODE>Computesalary</CODE>.The salary for a salesman is a function of
the <CODE>noOfHours</CODE> being worked and the
<CODE>noOfSoldUnits</CODE>.

<LI> The symbols <CODE>::&lt;</CODE> describes that the definition of
<CODE>ComputeSalary</CODE> from the superpattern <CODE>Employee</CODE>
is extended. The extension of a virtual pattern is in this example
similar to redefining a virtual procedure in Simula. Note, however,
that the virtual concept of BETA differs in an important way from that
of most object-oriented languages. Further details are given below.
</UL>

The above examples have shown examples of instantiating patterns in
the form of part object attributes (like <CODE>birthday: @
Date</CODE>). An instance of, say <CODE>Worker</CODE>, may in a
similar way be generated by a declaration of the form:

<PRE CLASS=beta>
mary: @ Worker
</PRE>

The above examples have also shown an example of a dynamic reference
(like <CODE>dept: ^Department</CODE>). Such a reference is initially
<CODE>NONE</CODE>, i.e. it refers to no object. A dynamic reference to
instances of <CODE>Worker</CODE> may be declared as followed:


<PRE CLASS=beta>
theForeman: ^ Worker
</PRE>

<CODE>TheForeman</CODE> may be assigned a reference to the object
referred by <CODE>mary</CODE> by execution of the following
imperative:

<PRE CLASS=beta>
mary[] -> theForeman[]
</PRE>

Note that the opposite assignment
(<CODE>theForeman[]<EM>->mary[]</EM></CODE>) is not legal since
<CODE>mary</CODE> is a constant reference. An instance of
<CODE>Worker</CODE> may be generated and its reference assigned to
<CODE>theForeman</CODE> by executing the following imperative

<PRE CLASS=beta>
&amp;Worker[] -> theForeman[]
</PRE>

A few additional comments about constructs used so far:

<UL>
<LI>The symbol <CODE>&amp;</CODE> means <CODE>new</CODE> .

<LI>The symbol -> is used for assignment of state.

<LI>An expression <CODE>R[]</CODE> denotes the reference to the object
referred by <CODE>R</CODE> whereas an expression <CODE>R</CODE>
denotes the object itself. The above assignment thus means that the
qualified reference <CODE>theForeman</CODE> is assigned a reference to
the generated instance of <CODE>Worker</CODE>.

<LI>An assignment of the form <CODE>mary <EM>-> theForeman</EM></CODE>
means that the state of the object referred by <CODE>mary</CODE> is
enforced upon the state of the object referred by
<CODE>theForeman</CODE>. This form of assignment is called value
assignment. In this paper it will only be used for instances of simple
patterns like <CODE>Integer</CODE>. If <CODE>X</CODE> and
<CODE>Y</CODE> are <CODE>Integer</CODE> objects then <CODE>X <EM>->
Y</EM></CODE> means that the value of <CODE>X</CODE> is assigned to
the object <CODE>Y</CODE>.
<LI>
</UL>

In this section, it was shown how the most common OO constructs may be
expressed in BETA. In the following sections, examples of the more
unique constructs will be given.








<!-- TOC -->




