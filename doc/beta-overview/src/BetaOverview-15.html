<H1>8.2.1  Monitor example</H1>
<DL>
<DT><DD>The following example describes a company with a number of salesmen, workers and carriers. The salesmen obtain orders from customers and store them in an order pool. The workers obtain orders from the order pool, process them and deliver the resulting item in an item pool. The carriers pick up the items from the item pool and bring them to the customer. Salesmen, workers and carriers are described as active objects whereas the order- and item pools are represented as monitor objects.
</DL>
<PRE CLASS=beta>
(# Salesman: Employee
     (# getOrder: (# ... <EM>exit</EM> anOrder[] #)
     <EM>do</EM> cycle(#<EM>do</EM> getOrder <EM>-></EM> JobPool.put #)
     #);
   S1,S2, ...: @ | Salesman;
   JobPool: @ monitor
     (# jobs: @ register(# type::&lt; order #);
        put: entry(# ord: ^ order <EM>enter</EM> ord[] <EM>do</EM> ord[]<EM> -></EM>jobs.insert #);
        get: entry(# ord: ^ order <EM>do</EM> jobs.remove<EM> -></EM> ord[] <EM>exit</EM> ord[] #)
     #);
   Worker: Employee
     (# processJob: (# ...<EM> enter</EM> anOrder[] <EM>do</EM> ... <EM>exit</EM> anItem[] #)
     <EM>do</EM> cycle(#<EM>do</EM> JobPool.get <EM>-></EM> processJob <EM>-></EM> ItemPool.put #)
     #);
   W1,W2,...: @ | Worker;
   ItemPool: 					@ monitor(# ... #);
   Carrier: Employee
     (# DeliverItem: (# <EM>enter</EM> anItem[] <EM>do</EM> ... #)
     <EM>do</EM> cycle(#<EM>do</EM> ItemPool.get <EM>-></EM>DeliverItem #)
     #);
   C1,C2, ...: @ | Carrier;
   <EM>do</EM> 		JobPool.init; ItemPool.init; 
   conc(#<EM>do</EM> S1.start; ... W1.start; ... C1.start; ... #)
#)
</PRE>
<DL>
<DT><DD>The procedure pattern <CODE>conc</CODE> is another example of a high-level concurrency pattern from the Mj&oslash;lner BETA library. It corresponds to the parbegin/parend imperative of Dijkstra [Dij68] in the sense that it does not terminate execution until execution of components being started (by <CODE>S1.start</CODE>, etc.) have terminated their execution.
</DL>







<!-- TOC -->




