<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Objinterface Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="pathhandler.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="heapinfo.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Objinterface Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'sysutilsobjint' '../lib';
BODY 'private/objinterfacebody';

(* The lowlevel BETA interface to BETA objects
 *
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
--- LIB: attributes ---

(* Possible values of protoType.scanRefs.refType if isStatic is FALSE: *)
<B>REFTYPE_DYNAMIC</B><A name="REFTYPE_DYNAMIC.1(126)"></A>: (# exit 0 #);
<B>REFTYPE_OFFLINE</B><A name="REFTYPE_OFFLINE.1(127)"></A>: (# exit 1 #);
<B>REFTYPE_ORIGIN</B><A name="REFTYPE_ORIGIN.1(128)"></A>: (# exit 2 #);

(* Possible values of protoType.scanSimples.simpleType. 
 * Must be disjoint from the REFTYPEs, as they're 
 * assigned to the same repetitions. *)

<B>SIMPLETYPE_INT16</B><A name="SIMPLETYPE_INT16.1(129)"></A>: (# exit 64 #); 
<B>SIMPLETYPE_INT32</B><A name="SIMPLETYPE_INT32.1(130)"></A>: (# exit 65 #);
<B>SIMPLETYPE_REAL64</B><A name="SIMPLETYPE_REAL64.1(131)"></A>: (# exit 66 #);

(* The following are used by the objectserializer, not by scanSimples,
 * but they are intermixed in the ObjectServer.  Therefore their valueset 
 * must be disjoint.
 *)
<B>SIMPLETYPE_HANDLED</B><A name="SIMPLETYPE_HANDLED.1(132)"></A>: (# exit 67 #); (* handled by previous entry in memory *)
<B>SIMPLETYPE_BIN32</B><A name="SIMPLETYPE_BIN32.1(133)"></A>:   (# exit 68 #); (* 4 bytes binary data *)
<B>SIMPLETYPE_INT16BIN16</B><A name="SIMPLETYPE_INT16BIN16.1(134)"></A>: (# exit 69 #);
<B>SIMPLETYPE_BIN16INT16</B><A name="SIMPLETYPE_BIN16INT16.1(135)"></A>: (# exit 70 #);
<B>SIMPLETYPE_INT16INT16</B><A name="SIMPLETYPE_INT16INT16.1(136)"></A>: (# exit 71 #);

(* no need yet: SIMPLETYPE_BIN16INT16: (# exit 71 #); *)

<B>COMProtoTypes</B><A name="COMProtoTypes.1(137)"></A>: (# exit true #);
<B>DISP_OFF</B><A name="DISP_OFF.1(138)"></A>: (# exit 24 #);

<B>protoType</B><A name="protoType.1(139)"></A>:
  (* Pattern used to access various attributes of the BETA prototype located
   * at address 'address'
   *)
  (# <B>beta</B><A name="protoType.1:beta.2(140)"></A><A name="beta.2(140)"></A>: @...;
     <B>address</B><A name="protoType.1:address.2(141)"></A><A name="address.2(141)"></A>: @integer; (* The memory address of THIS(prototype) *)
                         
     <B>GCtab</B><A name="protoType.1:GCtab.2(142)"></A><A name="GCtab.2(142)"></A>: IntegerValue
       (* Value of the GCtab field, i.e. distance to the allocation
        * tables in THIS(Prototype), used by the garbage collector.
        *)
       (# ... #);
     <B>OriginOff</B><A name="protoType.1:OriginOff.2(143)"></A><A name="OriginOff.2(143)"></A>: IntegerValue
       (* Value of the OriginOff field, i.e. the offset of the Origin field
        * in having THIS(Prototype).
        *)
       (# ... #);
     <B>GPart</B><A name="protoType.1:GPart.2(144)"></A><A name="GPart.2(144)"></A>: IntegerValue 
       (* Address for generation entry point corresponding to THIS(Prototype)
        *)
       (# ... #);
     <B>Size</B><A name="protoType.1:Size.2(145)"></A><A name="Size.2(145)"></A>: Integervalue
       (* The size in longs of objects having THIS(prototype) *)
       (# ... #);
     <B>Prefix</B><A name="protoType.1:Prefix.2(146)"></A><A name="Prefix.2(146)"></A>: IntegerValue
       (* The prototype of the prefix *)
       (# ... #);
     <B>LabId</B><A name="protoType.1:LabId.2(147)"></A><A name="LabId.2(147)"></A>:
       (* exit the name of used in 'beta.dump' for the pattern corresponding 
        * to THIS(Prototype) 
        *)
       (# id: ^text;
          doIt: @...
       do doIt
       exit id[]
       #);
     <B>GroupId</B><A name="protoType.1:GroupId.2(148)"></A><A name="GroupId.2(148)"></A>:
       (* exit the name of the file, the pattern corresponding to
        * THIS(Prototype) is declared in. This is also used in 'beta.dump'.
        * This method is pretty slow as it involves a search through a
        * linked list. 
        *)
       (# id: ^text;
       do ...
       exit id[]
       #);
     <B>scanRefs</B><A name="protoType.1:scanRefs.2(149)"></A><A name="scanRefs.2(149)"></A>: 
       (* Scan through references in THIS(Prototype). The boolean isStatic
        * indicates whether the current reference is static or dynamic.
        * If isStatic is TRUE, thisProto contains the address of the
        * prototype of the static inlined partobject.
        * If isStatic is FALSE, refType indicates whether the dynamic reference
        * is an origin reference, a reference to an offline allocated static
        * part, or an ordinary dynamic reference. Possible values are
        * REFTYPE_DYNAMIC, REFTYPE_OFFLINE and REFTYPE_ORIGIN.
        * thisOffset tells at what offset the reference is placed in objects 
        * having THIS(prototype).
        * thisAddr is the memory address thisOffset is found in.
        *)
       (# isStatic: @boolean;
          thisOffset,thisAddr,thisProto,thisOriginOff: @integer;
          refType: @Integer;
       do ...
       #);
     <B>scanSimples</B><A name="protoType.1:scanSimples.2(150)"></A><A name="scanSimples.2(150)"></A>:
       (* Scan through "simple values" in THIS(Prototype). 
        * thisOffset tells at what offset the value is placed in objects 
        * having THIS(prototype).
        * simpleType holds the type of the value. Possible types are
        * SIMPLETYPE_INT32, SIMPLETYPE_INT16, SIMPLETYPE_REAL64.
        *)
       (# thisOffset, simpleType: @Integer;
       do ...
       #);
     <B>astIndex</B><A name="protoType.1:astIndex.2(151)"></A><A name="astIndex.2(151)"></A>: IntegerValue
       (* exit the astIndex corresponding to this prototype.
        * Please note, that the value returned is not immediately useful
        * for accessing the ast through MPS.  The value returned _must_
        * be multiplied with 2 (two) in order to be useful for MPS.
        * I.e. you should write something like:
        *          pt.astindex*2-&gt;ff.indexToNode
        * where pt: @prototype and ff: @fragmentForm
        *)
       (# ... #);
     <B>formIndex</B><A name="protoType.1:formIndex.2(152)"></A><A name="formIndex.2(152)"></A>: IntegerValue
       (* exit the index of the form containing the objectDescriptor
        * corresponding to this prototype. The value returned is an index
        * into the fragmentList of the group. *)
       (# ... #);
  enter address
  exit address
  #); (* Prototype *)

<B>getProtoTypeForStruc</B><A name="getProtoTypeForStruc.1(153)"></A>:
  (* exit the prototype corresponding to structure## *)
  (# <B>structure</B><A name="getProtoTypeForStruc.1:structure.2(154)"></A><A name="structure.2(154)"></A>: ##object;
     <B>protoAdr</B><A name="getProtoTypeForStruc.1:protoAdr.2(155)"></A><A name="protoAdr.2(155)"></A>: @Integer;
  enter structure##
  ...
  exit protoAdr
  #);

<B>getProtoType</B><A name="getProtoType.1(156)"></A>:
  (* exit the prototype for obj *)
  (# <B>obj</B><A name="getProtoType.1:obj.2(157)"></A><A name="obj.2(157)"></A>: ^object;
     <B>protoAdr</B><A name="getProtoType.1:protoAdr.2(158)"></A><A name="protoAdr.2(158)"></A>: @Integer;
  enter obj[]
  ...
  exit protoAdr
  #);

<B>isComponent</B><A name="isComponent.1(159)"></A>: BooleanValue
  (* Exits true if obj is a component. *)
  (# <B>obj</B><A name="isComponent.1:obj.2(160)"></A><A name="obj.2(160)"></A>: ^Object;
  enter obj[]
  ...
  #);

<B>objectToComponent</B><A name="objectToComponent.1(161)"></A>:
  (* Exits the component part of the object entered *)
  (# <B>comp</B><A name="objectToComponent.1:comp.2(162)"></A><A name="comp.2(162)"></A>: ^|Object;
     <B>obj</B><A name="objectToComponent.1:obj.2(163)"></A><A name="obj.2(163)"></A>: ^Object;
  enter obj[]
  do ...
  exit comp[]
  #);

<B>componentToObject</B><A name="componentToObject.1(164)"></A>:
  (* Exits the item part of the object entered *)
  (# <B>comp</B><A name="componentToObject.1:comp.2(165)"></A><A name="comp.2(165)"></A>: ^|Object;
     <B>obj</B><A name="componentToObject.1:obj.2(166)"></A><A name="obj.2(166)"></A>: ^Object;
  enter comp[]
  do ...
  exit obj[]
  #);

<B>getPatternName</B><A name="getPatternName.1(167)"></A>:
  (* exit the name of the pattern obj is an instance of *)
  (# <B>obj</B><A name="getPatternName.1:obj.2(168)"></A><A name="obj.2(168)"></A>: ^object;
     <B>name</B><A name="getPatternName.1:name.2(169)"></A><A name="name.2(169)"></A>: ^text
  enter obj[]
  do ...;
  exit name[]
  #);

<B>getOrigin</B><A name="getOrigin.1(170)"></A>:
  (* exit the object that is the origin of obj. The origin of a BETA object is
   * the object statically enclosing the *pattern* the object is an instance
   * of.
   *)
  (# <B>obj</B><A name="getOrigin.1:obj.2(171)"></A><A name="obj.2(171)"></A>: ^object;
     <B>doIt</B><A name="getOrigin.1:doIt.2(172)"></A><A name="doIt.2(172)"></A>: @...
  enter obj[]
  do doIt
  exit obj[]
  #);

<B>getProtoField</B><A name="getProtoField.1(173)"></A>: IntegerValue
  (* exit the value of the protoType Field for obj *)
  (# <B>obj</B><A name="getProtoField.1:obj.2(174)"></A><A name="obj.2(174)"></A>: ^object;
  enter obj[]
  ...
  #);

<B>putProtoField</B><A name="putProtoField.1(175)"></A>:
  (* Put 'value' into the prototype field of 'obj *)
  (# <B>value</B><A name="putProtoField.1:value.2(176)"></A><A name="value.2(176)"></A>: @integer;
     <B>obj</B><A name="putProtoField.1:obj.2(177)"></A><A name="obj.2(177)"></A>: ^Object;
  enter (obj[], value)
  ...
  #);

<B>getGCField</B><A name="getGCField.1(178)"></A>: IntegerValue
  (# <B>obj</B><A name="getGCField.1:obj.2(179)"></A><A name="obj.2(179)"></A>: ^object;
  enter obj[]
  ...
  #);

<B>addressToObject</B><A name="addressToObject.1(180)"></A>:
  (* Given a memory address, exit the BETA object at that address.
   * You must have a static instance of addressToObject when using it.
   *)
  (# <B>addr</B><A name="addressToObject.1:addr.2(181)"></A><A name="addr.2(181)"></A>: @integer;
     <B>obj</B><A name="addressToObject.1:obj.2(182)"></A><A name="obj.2(182)"></A>: ^object;
  enter addr
  ...
  exit obj[]
  #);

<B>printObject</B><A name="printObject.1(183)"></A>:
  (* Print obj in textual form on the stream s. If s is NONE, Screen is used *)
  (# <B>obj</B><A name="printObject.1:obj.2(184)"></A><A name="obj.2(184)"></A>: ^object;
     <B>s</B><A name="printObject.1:s.2(185)"></A><A name="s.2(185)"></A>: ^stream;
  enter (obj[],s[])
  do ...
  #);

<B>extGetCstring</B><A name="extGetCstring.1(186)"></A>: external
  (* Given the address of a zero-terminated string, returns the string. *)
  (# <B>stringAdr</B><A name="extGetCstring.1:stringAdr.2(187)"></A><A name="stringAdr.2(187)"></A>: @Integer;
     <B>s</B><A name="extGetCstring.1:s.2(188)"></A><A name="s.2(188)"></A>: [1]@Char;
  enter stringAdr
  do 'copyInput' -&gt; callC;
  exit s
  #);

<B>assignRef</B><A name="assignRef.1(189)"></A>: external
  (* Given the address of an object in objAdr, and the address of a reference
   * field in another object in fieldAdr, assignRef puts the object reference
   * into the field.
   * Use this instead of directly assigning the object address to the field
   * as this will sooner or later give GC problems. *)
  (# <B>fieldAdr</B><A name="assignRef.1:fieldAdr.2(190)"></A><A name="fieldAdr.2(190)"></A>,<B> objAdr</B><A name="assignRef.1:objAdr.2(191)"></A><A name="objAdr.2(191)"></A>: @Integer;
  enter (fieldAdr, objAdr)
  #);

<B>group_header</B><A name="group_header.1(192)"></A>: data
  (# <B>data_start</B><A name="group_header.1:data_start.2(193)"></A><A name="data_start.2(193)"></A>: ^group_header;
     <B>protoTableAdr</B><A name="group_header.1:protoTableAdr.2(194)"></A><A name="protoTableAdr.2(194)"></A>: @Integer;
     <B>data_end</B><A name="group_header.1:data_end.2(195)"></A><A name="data_end.2(195)"></A>: ^group_header;
     <B>code_start</B><A name="group_header.1:code_start.2(196)"></A><A name="code_start.2(196)"></A>: @Integer;
     <B>code_end</B><A name="group_header.1:code_end.2(197)"></A><A name="code_end.2(197)"></A>: @Integer;
     <B>groupNameAddr</B><A name="group_header.1:groupNameAddr.2(198)"></A><A name="groupNameAddr.2(198)"></A>: @integer;
     <B>unique_group_id_hash</B><A name="group_header.1:unique_group_id_hash.2(199)"></A><A name="unique_group_id_hash.2(199)"></A>: @Integer;
     <B>unique_group_id_modtime</B><A name="group_header.1:unique_group_id_modtime.2(200)"></A><A name="unique_group_id_modtime.2(200)"></A>: @Integer;
     <B>ptr</B><A name="group_header.1:ptr.2(201)"></A><A name="ptr.2(201)"></A>: @Integer
  #);

<B>NextGroup</B><A name="NextGroup.1(202)"></A>: external
  (* current is a pointer to a group header. NextGroup returns the
   * group after current in the executable. If current is NONE, the
   * first group is returned.
   *)
  (# <B>current</B><A name="NextGroup.1:current.2(203)"></A><A name="current.2(203)"></A>: ^group_header;
  enter current[]
  exit current[]
  #);
<B>NameOfGroup</B><A name="NameOfGroup.1(204)"></A>: external
  (* Returns the groupname address of the group whose header is
   * given as parameter.
   *)
  (# <B>group</B><A name="NameOfGroup.1:group.2(205)"></A><A name="group.2(205)"></A>: ^group_header;
     <B>nameAdr</B><A name="NameOfGroup.1:nameAdr.2(206)"></A><A name="nameAdr.2(206)"></A>: @Integer;
  enter group[]
  exit nameAdr
  #);
<B>AddGroup</B><A name="AddGroup.1(207)"></A>: external
  (* Add new_group to list of known data-segment headers 
   * in runtime system - used by e.g. NextGroup.
   *)
  (# <B>new_group</B><A name="AddGroup.1:new_group.2(208)"></A><A name="new_group.2(208)"></A>: @integer (* address of start of data segment *)
  enter new_group
  #);
<B>IsPrototypeOfGroup</B><A name="IsPrototypeOfGroup.1(209)"></A>: External
  (* Exits true if data_addr is the address of
   * a prototype in the fragment group corresponding
   * to gh.
   *)
  (# <B>gh</B><A name="IsPrototypeOfGroup.1:gh.2(210)"></A><A name="gh.2(210)"></A>: ^group_header;
     <B>data_addr</B><A name="IsPrototypeOfGroup.1:data_addr.2(211)"></A><A name="data_addr.2(211)"></A>: @integer;
     <B>is_proto_in_group</B><A name="IsPrototypeOfGroup.1:is_proto_in_group.2(212)"></A><A name="is_proto_in_group.2(212)"></A>: @boolean;
  enter (gh[], data_addr)
  exit is_proto_in_group
  #);
<B>IsPrototypeOfProcess</B><A name="IsPrototypeOfProcess.1(213)"></A>: External
  (* Exits true if data_addr is the address of
   * a prototype in the fragment groups constituting
   * the current program.
   *)
  (# <B>data_addr</B><A name="IsPrototypeOfProcess.1:data_addr.2(214)"></A><A name="data_addr.2(214)"></A>: @integer;
     <B>is_proto_in_group</B><A name="IsPrototypeOfProcess.1:is_proto_in_group.2(215)"></A><A name="is_proto_in_group.2(215)"></A>: @boolean;
  enter data_addr
  exit is_proto_in_group
  #);

(* Prototype constants for special object types *)
<B>ComponentPTValue</B><A name="ComponentPTValue.1(216)"></A>:   (# exit -1 #);
<B>StackObjectPTValue</B><A name="StackObjectPTValue.1(217)"></A>: (# exit -2 #);
<B>StructurePTValue</B><A name="StructurePTValue.1(218)"></A>:   (# exit -3 #);
<B>RefRepPTValue</B><A name="RefRepPTValue.1(219)"></A>:      (# exit -4 #);
<B>ValRepPTValue</B><A name="ValRepPTValue.1(220)"></A>:      (# exit -5 #);
<B>ByteRepPTValue</B><A name="ByteRepPTValue.1(221)"></A>:     (# exit -6 #);
<B>WordRepPTValue</B><A name="WordRepPTValue.1(222)"></A>:     (# exit -7 #);
<B>DoubleRepPTValue</B><A name="DoubleRepPTValue.1(223)"></A>:   (# exit -8 #);
<B>DopartObjectPTValue</B><A name="DopartObjectPTValue.1(224)"></A>:(# exit -9 #);
<B>DynItemRepPTValue</B><A name="DynItemRepPTValue.1(225)"></A>:  (# exit -10 #);
<B>DynCompRepPTValue</B><A name="DynCompRepPTValue.1(226)"></A>:  (# exit -11 #);

<B>getOIDforObject</B><A name="getOIDforObject.1(227)"></A>:
  (* exits a unique Object Identifier, that is valid for the
   * lifetime of this program run.  The object may die, though,
   * if no references to it exist.
   * Having an OID does NOT count as a root for the Garbage Collector.
   *)
  (# <B>obj</B><A name="getOIDforObject.1:obj.2(228)"></A><A name="obj.2(228)"></A>: ^Object;
     <B>OID</B><A name="getOIDforObject.1:OID.2(229)"></A><A name="OID.2(229)"></A>: @Integer;
  enter obj[]
  ...
  exit OID
  #);

<B>getObjectByOID</B><A name="getObjectByOID.1(230)"></A>:
  (* Finds the object associated with the Object Identifier.
   * Note! Having an OID does NOT count as a root for the Garbage Collector.
   *)
  (# <B>obj</B><A name="getObjectByOID.1:obj.2(231)"></A><A name="obj.2(231)"></A>: ^Object;
     <B>OID</B><A name="getObjectByOID.1:OID.2(232)"></A><A name="OID.2(232)"></A>: @Integer;
  enter OID
  ...
  exit obj[]
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="pathhandler.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="heapinfo.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
