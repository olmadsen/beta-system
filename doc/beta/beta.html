<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Beta Language Extensions and Clarifications</TITLE>
<LINK REV="made" HREF="mailto:pa@mjolner.com">
<LINK REL="stylesheet" HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>

<DIV>
<A NAME=HEADING2></A>

<DIV>
<P><A HREF=mia90-02-INX.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=mia90-02-TOC.html><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<A HREF=mia90-02-TOC.html><IMG ALIGN=BOTTOM SRC=../images/content.gif ALT=Contents BORDER=0></A>
<A HREF=mia90-02-INX.html><IMG ALIGN=BOTTOM SRC=../images/index.gif ALT=Index BORDER=0></A></P>
<P>BETA Language Extensions and Clarifications
<HR>

</DIV>

<A NAME=HEADING2-0></A>
<H1>Beta Language Extensions and Clarifications</H1>
<A NAME=HEADING2-1></A>
<H2> <A NAME="LINK-mia90-02.mif-_Toc401563569"><A NAME=MARKER-9-12></A>1  Introduction</A></H2>
<P> 
The BETA language is described thoroughly in 
<A HREF="../bibliography/#madsen93">[Madsen 93]</A>
which is the main reference to BETA.

This book is currently the only definition of the BETA language, but a
precise language definition is being worked on.</P>

<P> A short introduction to BETA and the Mj&oslash;lner System may
also be found in the Mj&oslash;lner Tutorial [MIA 94-24] and in
[Knudsen94].</P> 

<P> The BETA grammar is given in appendix B. </P>


This document describes extensions and clarifications
of the BETA language that have been made since the publication
of the BETA book.

<P> <B>In the  following, the reader is assumed to be familiar with <A
HREF="../bibliography/#madsen93">[Madsen 93]</A> 
</B></P>


<P> There are a few deviations from [MMN93Madsen93] in the current
implementation of BETA. These deviations are described below. </P>

<A NAME=HEADING2-95></A>
<H2> 2 Operations on Basic Patterns</H2>
<P> 1. The integer operations +, -, *, div, mod, =, &lt;&gt;, etc. will work on 32 bits. </P>
<P> 2. Assignment between instances of integer, and real is allowed. In assignments of reals to integers the values are truncated.</P>
<P>  Assignment between instances of integer and char is allowed. Character constants have their ASCII char value.  Assignment of an arbitrary integer value to char  instances may thus give meaningless results. </P>
<P>  Assignment between instances of integer and boolean is allowed, but will give a warning. In a future release these assignments will not be allowed and will give an error. The patterns true and false have the values 1 and 0 respectively. Assignment of an arbitrary integer value to boolean instances may thus give meaningless results. </P>
<P>  The following table shows legal combinations of operands and the result type. </P>
<P>  Entries not shown are illegal. Entries marked with <B>*</B> are illegal. Entries marked with <B>! </B>will give a warning, and will become illegal in a future release.</P>
<P> <I> Abbreviations: </I></P>
<P>   <B>int </B>means  <B>integer</B></P>
<P>   <B>bool</B> means <B>boolean</B></P>
<P>   <B>iref </B>means  <B>item reference</B></P>
<P>   <B>cref </B>means <B>component reference</B></P>
<P>   <B>sref </B>means <B>structure reference</B></P>
<P>  NONE is both an <B>iref</B>, a <B>cref</B> and an <B>sref</B>.</P>
<P>  For assignment and binary operators, the rows and columns of the tables show left and right operands respectively, and the elements of the tables show the result type.</P>
<P>  <B></B></P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR></TABLE><P> 3. The relational operators =, &lt;&gt;, &lt;, etc. do only work for the basic patterns integer, real, boolean, and char and for references (only =, &lt;&gt;) I.e. E1 = E2, where E1 and E2 are instances of some user-defined pattern will not work. </P>
<P>  The following tables show legal combinations of operands and the result type.  The notation is explained in item 2 above.</P>
<P>  <B>Binary operators:</B>
<PRE class=beta> = </PRE>

<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE><P> <B> Binary operators: </B>
<PRE class=beta> &lt;, &lt;=, &gt;, &gt;= </PRE>

<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE><P> 4.  Arithmetic/logical operators.</P>
<P> <A NAME=MARKER-2-16></A> The following tables show legal combinations of operands and the result type.  The notation is explained in item 2 above.</P>
<P> <B> Binary operators: </B>
<PRE class=beta> +, -, * </PRE> 

<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR></TABLE><P> <B></B></P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD></TR></TABLE><P> <B></B></P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR></TABLE><P>  <B>char</B> is likely to be eliminated as a legal operand for <B>/</B> in a future version.</P>
<P>   </P>
<P> <B> Binary operators: </B>
<PRE class=beta> and, or </PRE>

<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>bool</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE><P> 
<B> Unary operators: </B>
<PRE class=beta> +,  -</PRE>

<P>  <B>int</B>, <B>char</B>, <B>real</B> result type is the same as operand type</P>
<P> </P>
<P> <B> Unary operator: </B>  
<PRE class=beta> not </PRE>
<P>  <B>bool</B> result type is  <B>bool</B></P>
<P>  </P>
<P> 5. In if-imperatives </P>
<PRE class=beta> (if E0 // E1 then ... // E2 then ... if) </PRE>
<P>  the exit-lists of E0, E1, E2, ... must consist of exactly one integer, 
real, char, boolean or reference. </P>
<P> 6. Inserted items, i.e., </P>
<P> </P>
<PRE class=beta>   do ...; P; ...</PRE>
<P>  ([MMN93Madsen93], section 5.10.2) are implemented as dynamic items (&amp;P). However, the user is urged to use dynamic items for recursion in order to ensure compatability with future releases.</P>
<P> 7. Inserted components, i.e., </P>
<P> </P>
<PRE class=beta>   do ...; |(# ... #); ...</PRE>
<P>  ([MMN93Madsen93], section 5.10.3) have not been implemented. </P>
<P> 8. Virtual superpatterns, i.e., </P>
<P>  </P>
<PRE class=beta>
   A::&lt; (# ... #); (* Where A is some virtual *)
   B: A(# ... #)
</PRE>
<P>  have not been implemented. </P>
<P>  By using a <I>final binding</I>, this problem may often be overcome like this:</P>
<P> </P>
<PRE class =beta>
   A:: (# ... #); (* A is no longer virtual *)
   B: A(# ... #)
</PRE>
<P>  The situation may also occur in a more indirect way: </P>
<PRE class=beta>
     graph:
        (# node:&lt; (# ... #);
           nodeList: @list(# element::&lt; node #);
           ...
        #);
</PRE>
<P>    Here the virtual further binding of element in list is not allowed, since node is itself virtual. </P>
<P>    The current version of the compiler will allow final binding using a pattern that is itself virtual. That is, you can do this: </P>
<PRE class=beta>
      graph:
        (# node:&lt; (# ... #);
           nodeList: @list(# element:: node #);
           ...
        #);
</PRE>
<P>  General virtual prefixes behave much like multiple inheritance and will not be implemented in the near future. </P>
<P> 9. The labelled compound imperative </P>
<PRE class=beta>   A: (L: imp1; imp2; ...; impN :L)</PRE>
<P>  has been eliminated from the language. Instead the following construct may be used:</P>
<P> </P>
<PRE class=beta>   A: (# do imp1; imp2; ... ; impN; #)</PRE>
<P>  Inserted items with no declarations and no superpattern will be inlined in the enclosing code. There will thus be no execution overhead compared to the old (never implemented) labelled compound imperative statement.</P>
<P> 10. Consider the following example: </P>
<PRE class=beta>
     (#  
         A: (# X: ^P; (* reference to item qualified by P *)
         B: ^|P (* reference to component qualified by P *)
      do ...
         this(P)[] -&gt; X[];   (* legal use of this(P)[] *)
         this(P)[] -&gt; R[];   (* illegal use of this(P)[] *)
      #)
</PRE>
<P>  The illegal use is due to the fact that this(p)[] is considered a reference to an item object and not a component object. </P>
<P> 11. In declarations like:</P>
<PRE class=beta>
   P: &lt;AD&gt;(# ... #);
   X: @&lt;AD&gt;;
   Y: ^&lt;AD&gt;;
</PRE>
<P>  it is checked that &lt;AD&gt; is a <I>static</I> denotation, where <I>static</I> is defined as follows:</P>
<P>  &middot; A name A is always static</P>
<P>  &middot; In a remote-name R.A, R must be a static object</P>
<P>  &middot; Use of THIS(A).T is static</P>
<P>  &middot; Only in Y: ^P.T, can P be a pattern</P>
<P>  &middot; Denotations using R[e], and (foo).bar are <I>not</I> static</P>
<P>  This means that e.g. descriptors like:</P>
<PRE class=beta>
   R[e].A(# ... #)
   (foo).bar(# ... #)
   R.P(# ... #) where 'R' is a dynamic ref.
</PRE>
are only allowed in <I>imperatives</I>.</P>
<P>  For Y: ^R.P where R is a dynamic reference, the compiler will currently report a warning and suggest to use</P>
<P>   </P>
<P>   Y: ^A.P where A is the qualification of R.</P>
<P>  Note: that when using --noWarnQua, this warning will <I>not</I> be printed. A future release may change the warning to an error.</P>
<P> 12. There are some deviations with respect to the implementation of concurrency. Please consult [MIA90-8] before using the concurrency. </P>
<P> 13. It is in general not possible to use leave P or restart P where P is a pattern. P must in general be a label.  <I>However</I>, the following has been implemented:</P>
<PRE class=beta>
   P: (#
      do ...
         leave P
         ... 
         restart P;
         ...
      #)
</PRE>
<P>  Leave/restart from an inserted item, however, is <I>not</I> supported by the current version of the compiler:</P>
<PRE class=beta>
   P: (#
      do ...
         (#
         do ...
            leave P; (* ILLEGAL *)
            ... 
            restart P; (* ILLEGAL *)
            ...
         #)
         ...
      #)
</PRE>
<P> 14. A pattern where the object descriptor is described as a slot cannot be used as a super-pattern. I.e. the following is illegal: </P>
<PRE class=beta>   
   A: &lt;&lt;SLOT Pdesc: descriptor&gt;&gt;;
   B: P(# ... #);  (* illegal *)
</PRE>
<P>  Instead the following can often be used: </P>
<PRE class=beta>
   C: (# do &lt;&lt;SLOT Pdesc: descriptor&gt;&gt; #)
   D: P(# ... #); (* legal *)
</PRE>
<P> 15. The Program pattern as described in the chapter on exception handling in [MMN93Madsen93] has not been implemented. </P>
<P> 16. There are some restrictions on the use of fragments as described in section 6 below. </P>
<A NAME=HEADING2-967></A>
<H2> 3  Extensions</H2>
<A NAME=HEADING2-968></A>
<H3> 3.1  String Literals as References</H3>
<P> The pattern Text enters and exits a char-repetition. This means, that a text may be initialized using constant strings as follows:</P>
<PRE class=beta>
      t: @text;
   do 'hello' -&gt; t;
</PRE>
<P> Many operations involving texts, however, takes <I>references</I> to texts as enter/exit parameters. This is mainly for efficiency reasons.</P>
<P> To allow easy invocation of such operations on string literals, the following is <I>also</I> allowed:</P>
<PRE class=beta>
      t: ^text;
   do 'hello' -&gt; t[];
</PRE>
<P> The semantics of this is, that a text object is instantiated, initialized by the constant string, and finally assigned to the text reference.</P>
<A NAME=HEADING2-977></A>
<H3> 3.2  Special Ccharacters in Sstring Lliterals<A NAME=MARKER-2-17></A></H3>
<P> The following special characters are allowed in BETA string literals.</P>
<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> \a alert (bell) character</P>
<P> \b backspace<A NAME=MARKER-2-1></A></P>
<P> \f formfeed<A NAME=MARKER-2-2></A></P>
<P> \n newline<A NAME=MARKER-2-3></A></P>
<P> \r carriage return<A NAME=MARKER-2-4></A></P>
<P> \t horizontal tab<A NAME=MARKER-2-5></A></P>
</TD><TD><P> \v vertical tab<A NAME=MARKER-2-6></A></P>
<P> \\ backslash<A NAME=MARKER-2-7></A></P>
<P> \? question mark<A NAME=MARKER-2-8></A></P>
<P> \' single quote<A NAME=MARKER-2-9></A></P>
<P> \&quot; double quote<A NAME=MARKER-2-10></A></P>
<P> \ooo octal number<A NAME=MARKER-2-11></A></P>
</TD></TR></TABLE><P> Notice that you may now use \' as an alternative to '' to include a literal quote in a string. E.g.: 'Tom\'s Cottage'.  This has the consequence, though, that to type the backslash character, you must do it as: '\\'.</P>
<P> \ooo can also be \o or \oo, provided that the character immediately following it is not a digit.</P>
<P> </P>
<A NAME=HEADING2-1005></A>
<H3> 3.3  Simple If<A NAME=MARKER-2-18></A></H3>
<P> Often the following If statement is used:</P>
<PRE class=beta>
     b: @boolean;
 do (if b//TRUE 
     then ...
     else ...
    if);
</PRE>
<P> The current version of the compiler supports an extension to the BETA language called Simple If. This extension means, that the case-selector // may be omitted, if the evaluation on the left hand side exits a boolean. That is, the above may be written</P>
<PRE class=beta>
    b: @boolean;
 do (if b 
     then ...
     else ...
    if);
</PRE>
<P> Like in the general if-statement, the else part if optional.</P>
<A NAME=HEADING2-1021></A>
<H3> 3.4  Xor Primitive</H3>
<P> An xor primitive is supported as a basic operation on booleans. That is</P>
<PRE class=beta>
      b1, b2, b3: @boolean
   do b1 xor b2 -&gt; b3
</PRE>
is possible.</P>
<A NAME=HEADING2-1027></A>
<H3> 3.5  Short-circuit Boolean Expressions<A NAME=MARKER-2-19></A></H3>
<P> Boolean  expressions are implemented as short-circuit.</P>
<P> That is, in:</P>
<PRE class=beta>B1 or B2</PRE>
B2 is <I>not</I> evaluated if B1 is true.</P>

<P>Similarly in:</P>
<PRE class=beta>B1 and B2</PRE>
B2 is <I>not</I> evaluated if B1 is false.</P>

<A NAME=HEADING2-1032></A>
<H3> 3.6  ## for Objects</H3>
<P> You may now use P## as an alternative to P._struc, when P is an <I>object</I>. Previously ## was only allowed for <I>patterns</I>.</P>
<P> </P>


<H2> 4. Repetition Constructors</H2>
<H3> 4.1 Value Repetitions</H3>
<P>Consider a value repetition:
<PRE class=beta>
   R: [exp] @T
</PRE>
where T is a basic pattern.</P>

<P>A repetition object may be constructed and assigned to R 
in the following way:</P>
<PRE class=beta>
   (E1,E2,...,En) -> R
</PRE>
<P>where <tt>E1, E2, ... En </tt> are evaluations of type <tt>T</tt>.</P>
<P>A repetion object with <tt>range = n</tt> is constructed and 
<tt>R[i] = Ei</tt>, <tt>i</tt> in <tt>[1,n]<7tt>.
</p>
<H3> 4.2 Example</H3>
The following is an example of using repetitions constructors:
<PRE class=beta>
   (# a,b: @integer;
      R:[1] @integer
   do 10->a; 20 -> b
      (a,b,a+b) -> R;
      (for i: R.range repeat R[i] -> putint; ' '-> put for)
   #)
</PRE>
The above example will print the sequence
<PRE class=beta>10 20 30</PRE>
<H3> 4.3 Variabale number of enter parameters</H3>
Repetitions may be used to define patterns with a limited form
of a variable number of parameters. Consider the following example:
<PRE class=beta>
   foo:
      (# S: ^stream;
         V: [1] @integer;
         sep: @char
      enter(S[],V,x)
      do (for i: V.range repeat
              V[i] -> S.putint; sep -> S.put
         for)
      #)
</PRE>
Pattern <tt>foo</tt> may be used in the following way:
<PRE class=beta>(screen[],(1,2,3,4,5),'-') -> foo</PRE>
which will print the following sequence:
<PRE class=beta>1-2-3-4-5-</PRE>

<H3> 4.4 Text literals </H3>
Text literals like <tt>'Hello'</tt> may be considered as abbreviations
of char repetition constructors like <tt>('H','e','l','l','o')</tt>.
Consider:
<PRE class=beta>Q: [1]@char</PRE>
<p>The evaluation:</p>
<PRE class=beta>'Hello' -> Q</PRE>
may considered as an abbrevation for:
<PRE class=beta>('H','e','l','l','o') -> Q</PRE>

<HR>
<P>
<ADDRESS>BETA Compiler Extensions and Clarifications - 31 Jan 1999</ADDRESS>
<P><A HREF=mia90-02-INX.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=mia90-02-TOC.html><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<A HREF=mia90-02-TOC.html><IMG ALIGN=BOTTOM SRC=../images/content.gif ALT=Contents BORDER=0></A>
<A HREF=mia90-02-INX.html><IMG ALIGN=BOTTOM SRC=../images/index.gif ALT=Index BORDER=0></A></P>

</DIV>
</BODY>
</HTML>
