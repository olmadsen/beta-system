<body>
<H2> 9. Dynamic denotations </H2>

In declarations like:</P>
<PRE class=beta>
P: &lt;AD&gt;(# ... #);
X: @&lt;AD&gt;;
Y: ^&lt;AD&gt;;
</PRE>

<P> it is checked that &lt;AD&gt; is a <I>static</I> denotation, where
<I>static</I> is defined as follows:</P>

<P>  &middot; A name A is always static</P>
<P>  &middot; In a remote-name R.A, R must be a static object</P>
<P>  &middot; Use of THIS(A).T is static</P>
<P>  &middot; Only in Y: ^P.T, can P be a pattern</P>
<P>  &middot; Denotations using R[e], and (foo).bar are <I>not</I> static</P>
<P>  This means that e.g. descriptors like:</P>
<PRE class=beta>
R[e].A(# ... #)
(foo).bar(# ... #)
R.P(# ... #) where 'R' is a dynamic ref.
</PRE>
are only allowed in <I>imperatives</I>.</P>
<P>  For Y: ^R.P where R is a dynamic reference, the compiler will currently report a warning and suggest to use</P>
<P>   </P>
<P>   Y: ^A.P where A is the qualification of R.</P>
<P>  Note: that when using --noWarnQua, this warning will <I>not</I> be printed. A future release may change the warning to an error.</P>



</body>
