<body>
<H2> 3. Operations on Basic Patterns and References</H2>

<P> In this section the rules for basic patterns- and references
operations such as assignment, arithmetic operations, relational
operations, boolean operations, etc. are further specified.

<P> All expressions are evaluated as 32-bit values, either signed or
unsigned. If an expression is assigned to a a variable representing 8-
or 16-bit values, only the least significant 8- or 16-bits are
assigned.

<P> In the following a number of tables showing legal combinations of
operands and result type for the operations on basic patterns and
references will be given.

Entries not shown are illegal. Entries marked with <B>*</B> are
illegal.  Entries marked with <B>!</B> will give a compiler warning,
and may become illegal in a future version of BETA. The following
abbreviations will be used:

<P> <I> Abbreviations: </I></P>
<P> <B>int </B>represents an evaluation of type <B>integer</B></P>
<P> <B>bool</B> represents an evaluation of type <B>boolean</B></P>
<P> <B>iref </B>represents an evaluation of type <B>item reference</B></P>
<P> <B>cref </B>represents an evaluation of type
    <B>component reference</B></P>
<P> <B>sref </B>represents an evaluation of type 
    <B>structure reference</B></P>
<P>  NONE is both an <B>iref</B>, a <B>cref</B> and an <B>sref</B>.</P>

<H3> 3.1 Assignment </H3>
The following table shows the legal combinations of
the left and right side of an assignment for basic patterns and references:

<PRE class=beta>E -> V</PRE>

<P> The rows of the table shows possible types of of <tt>E</tt> and the
columns of the tables show possible types of of <tt>V</tt>.  The
elements of the table shows the result type, which for assignment are
the same as the type of <tt>V</tt>.

<P> Note that <tt>E</tt> and <tt>C</tt> stand for arbitrary evaluations
including values as in:
<PRE class=beta>a+b*10 -> c</PRE>
<P>and references as in:
<PRE class=beta>&P[] -> S[]</PRE>

<P>  </P>
<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR></TABLE>

<P> Notes:
<ul>
 <li> Assignment between integer, and real is allowed. 
 <li> In assignments of a real value to an integer value,
      the real value is truncated.
 <li> If an integer value is assigned to a variable of type int8, int8u,
      int16, int16u, the value may be truncated.
 <li> Assignment between integer and char/wchar is allowed. 
      Character constants have their ASCII or UniCode value.  
      Assignment of an arbitrary integer value to char/wchar 
      may result in truncation of the integer value.
 <li> Assignment between instances of integer and boolean is currently 
      allowed, but a warning is given. 
      In a future version of BETA these assignments may not be allowed 
      and may give an error. The patterns true and false have the values 1 
      and 0 respectively. Assignment of an arbitrary integer value to a
      boolean instances may result in truncation of the integer value.
</ul>

<H3> 3.2 Relational Operators</H3>

<H4> 3.2.1 Restrictions on Relational Expressions </H4>

The relational operators:

<PRE class=beta>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</PRE>

can only be used for the basic patterns integer, real, boolean, and
char.

<P>
The relational operators:

<PRE class=beta>=, &lt;&gt;</PRE>

can in addition be used for references.

<P>It is <B>not</B> possible to compare a list of values as in:

<PRE class=beta>
(# P: (# ... exit(e1,e2,e3) #);
   A: (# ... exit(f1,f2,f3) #);
   B: @boolean
do P = A -> B;
   P = (g1,g2,g3) -> b
#)   
</PRE>

<H4> 3.2.2 Type Rules for Relational Expressions </H4>

The following table shows the legal combinations of types for
expressions of the form:

<PRE class=beta>E1 = E2</PRE>
and
<PRE class=beta>E1 <> E2</PRE>

<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>iref</B></P>
</TD><TD><P> <B>cref</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>!</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:

<PRE class=beta>E1 < E2</PRE>
<PRE class=beta>E1 <= E2</PRE>
<PRE class=beta>E1 > E2</PRE>
<PRE class=beta>E1 >= E2</PRE>


<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>sref</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE><P> 

<H3> 3.3  Arithmetic Operators.</H3>
<P> <A NAME=MARKER-2-16></A> 

<P> The following table shows the legal combinations of types for 
expressions of the form:

<PRE class=beta>E1 + E2</PRE>
<PRE class=beta>E1 - E2</PRE>
<PRE class=beta>E1 * E2</PRE>

<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR></TABLE>

<P> The following table shows the legal combinations of types for 
expressions on the form :
<PRE class=beta>E1 div E2</PRE>

<P>Note that the <tt>div</tt> operator is integer division.

<P>
<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>int</B></P>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:
<PRE class=beta>E1 / E2</PRE>

<P>Note that the <tt>/</tt> operator is a a real operator. The result
is always a real, even if the operands are integers. If integer division
is wanted, use the <tt>div</tt> operator.

<P>
<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>int</B></P>
</TD><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B></P>
</TD><TD><P> <B>real</B></P>
</TD><TD><P> <B>*</B></P>
</TD><TD><P> <B>real</B></P>
</TD></TR></TABLE><P>  

<B>char</B> is likely to be eliminated as a legal operand for <B>/</B> 
in a future version.</P>


<H3> 3.4 Boolean Operators </H3>
<H4> 3.4.1 Xor Primitive</H4>

<P> An xor primitive is supported as a basic operation on booleans. 
If <tt>E1</tt> and <tt>E2</tt> are boolean expressions then the expression

<PRE class=beta>E1 xor E2</PRE>

is an exclusive or between <tt>E1</tt> and <tt>E2</tt>.


<H4> 3.4.2  Short-circuit Boolean Expressions</A></H4>

<P> Boolean expressions are implemented as <em>short-circuit boolean
expressions</em><A NAME=MARKER-2-19>.</P>

<P> That is, in:</P>
<PRE class=beta>B1 or B2</PRE>
B2 is <I>not</I> evaluated if B1 is true.</P>

<P>Similarly in:</P>
<PRE class=beta>B1 and B2</PRE>
B2 is <I>not</I> evaluated if B1 is false.</P>

<H4> 3.4.3 Type rules for boolean expressions </H4>

<P> The following table shows the legal combinations of types for
expressions of the form:

<PRE class=beta>E1 and E2</PRE>
<PRE class=beta>E1 or E2</PRE>
<PRE class=beta>E1 xor E2</PRE>

<TABLE border class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> </P>
</TD><TD><P> <B>bool</B></P>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B></P>
</TD><TD><P> <B>bool</B></P>
</TD></TR></TABLE><P> 


<H3> Unary Operators: </H3>
<P> For unary expressions of the form:
<PRE class=beta>+ E</PRE>
<PRE class=beta>- E</PRE>

<P> The legal types for <tt>E</tt> are: <B>int</B>, <B>char</B>, or
<B>real</B>.  The result type is the same as operand type</P>

<P>For a unary expression of the form:
<PRE class=beta>not E</PRE>

<P> The type of <tt>E</tt> must be <B>bool</B> and the result type is
<B>bool</B></P>

</body>
