
<H1>Operations on Basic Patterns and References</H1>

<P> In this section the rules for basic patterns- and references
operations such as assignment, arithmetic operations, relational
operations, boolean operations, etc. are further specified.

<P> All expressions are evaluated as 32-bit values, either signed or
unsigned. If an expression is assigned to a a variable representing 8-
or 16-bit values, only the least significant 8- or 16-bits are
assigned.

<P> In the following a number of tables showing legal combinations of
operands and result type for the operations on basic patterns and
references will be given.

Entries not shown are illegal. Entries marked with <B>*</B> are
illegal.  Entries marked with <B>!</B> will give a compiler warning,
and may become illegal in a future version of BETA. The following
abbreviations will be used:

<P> <I> Abbreviations: </I>
<P> <B>int </B>represents an evaluation of type <B>integer</B>
<P> <B>bool</B> represents an evaluation of type <B>boolean</B>
<P> <B>iref </B>represents an evaluation of type <B>item reference</B>
<P> <B>cref </B>represents an evaluation of type
    <B>component reference</B>
<P> <B>sref </B>represents an evaluation of type 
    <B>structure reference</B>
<P>  NONE is both an <B>iref</B>, a <B>cref</B> and an <B>sref</B>.

<H2>Assignment </H2>
The following table shows the legal combinations of
the left and right side of an assignment for basic patterns and references:

<BETA>E -> V</BETA>

<P> The rows of the table shows possible types of of <tt>E</tt> and the
columns of the tables show possible types of of <tt>V</tt>.  The
elements of the table shows the result type, which for assignment are
the same as the type of <tt>V</tt>.

<P> Note that <tt>E</tt> and <tt>C</tt> stand for arbitrary evaluations
including values as in:
<BETA>a+b*10 -> c</BETA>
<P>and references as in:
<BETA>&P[] -> S[]</BETA>

<P>  
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>sref</B>
</TD></TR></TABLE>

<P> Notes:
<ul>
 <li> Assignment between integer, and real is allowed. 
 <li> In assignments of a real value to an integer value,
      the real value is truncated.
 <li> If an integer value is assigned to a variable of type int8, int8u,
      int16, int16u, the value may be truncated.
 <li> Assignment between integer and char/wchar is allowed. 
      Character constants have their ASCII or UniCode value.  
      Assignment of an arbitrary integer value to char/wchar 
      may result in truncation of the integer value.
 <li> Assignment between instances of integer and boolean is currently 
      allowed, but a warning is given. 
      In a future version of BETA these assignments may not be allowed 
      and may give an error. The patterns true and false have the values 1 
      and 0 respectively. Assignment of an arbitrary integer value to a
      boolean instances may result in truncation of the integer value.
</ul>

<H2>Relational Operators</H2>

<H3>Restrictions on Relational Expressions </H3>

The relational operators:

<BETA>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</BETA>

can only be used for the basic patterns integer, real, boolean, and
char.

<P>
The relational operators:

<BETA>=, &lt;&gt;</BETA>

can in addition be used for references.

<P>It is <B>not</B> possible to compare a list of values as in:

<BETA>
(# P: (# ... exit(e1,e2,e3) #);
   A: (# ... exit(f1,f2,f3) #);
   B: @boolean
do P = A -> B;
   P = (g1,g2,g3) -> b
#)   
</BETA>

<H3>Type Rules for Relational Expressions </H3>

The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 = E2</BETA>
and
<BETA>E1 <> E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 < E2</BETA>
<BETA>E1 <= E2</BETA>
<BETA>E1 > E2</BETA>
<BETA>E1 >= E2</BETA>


<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE><P> 

<H2><INX>Arithmetic Operators</INX>.</H2>

<P> The following table shows the legal combinations of types for 
expressions of the form:

<BETA>E1 + E2</BETA>
<BETA>E1 - E2</BETA>
<BETA>E1 * E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD></TR></TABLE>

<P> The following table shows the legal combinations of types for 
expressions on the form :
<BETA>E1 div E2</BETA>

<P>Note that the <tt>div</tt> operator is integer division.

<P>
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:
<BETA>E1 / E2</BETA>

<P>Note that the <tt>/</tt> operator is a a real operator. The result
is always a real, even if the operands are integers. If integer division
is wanted, use the <tt>div</tt> operator.

<P>
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD></TR></TABLE><P>  

<B>char</B> is likely to be eliminated as a legal operand for <B>/</B> 
in a future version.


<H2>Boolean Operators </H2>
<H3>Xor Primitive</H3>

<P> An xor primitive is supported as a basic operation on booleans. 
If <tt>E1</tt> and <tt>E2</tt> are boolean expressions then the expression

<BETA>E1 xor E2</BETA>

is an exclusive or between <tt>E1</tt> and <tt>E2</tt>.


<H3>Short-circuit Boolean Expressions</H3>

<P> Boolean expressions are implemented as 
<INX><em>short-circuit boolean expressions</em></INX>.

<P> That is, in:
<BETA>B1 or B2</BETA>
B2 is <I>not</I> evaluated if B1 is true.

<P>Similarly in:
<BETA>B1 and B2</BETA>
B2 is <I>not</I> evaluated if B1 is false.

<H3>Type rules for boolean expressions </H3>

<P> The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 and E2</BETA>
<BETA>E1 or E2</BETA>
<BETA>E1 xor E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>bool</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE><P> 


<H3> Unary Operators: </H3>
<P> For unary expressions of the form:
<BETA>+ E</BETA>
<BETA>- E</BETA>

<P> The legal types for <tt>E</tt> are: <B>int</B>, <B>char</B>, or
<B>real</B>.  The result type is the same as operand type

<P>For a unary expression of the form:
<BETA>not E</BETA>

<P> The type of <tt>E</tt> must be <B>bool</B> and the result type is
<B>bool</B>


