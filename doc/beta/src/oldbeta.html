<H1 align=center>BETA Language Modifications - Reference Manual</H1>

<center>
 <B>Mj&oslash;lner Informatics Report, MIA 99-41, August 1999</B>
</center>

<H2>Introduction</H2>

<P> The BETA language is described in 
<A HREF="../bibliography/index.html#mmn93">[MMN 93]</A> 
which is the main
reference to BETA.  The BETA book is a tutorial description of BETA.
As of today there is no language definition manual, but one
in preparation.
Short introductions to BETA  may be found in 
<A HREF="../bibliography/index.html#madsen99">[Madsen 99]</A>,
and <A HREF="../bibliography/index.html#mia94-26">[MIA 94-26]</A>. In addition the following documents are available:

<ul>
 <li> A structured context-free  
     <A HREF="../grammars/beta.html">grammar for BETA </A>.
  <li>A summary of 
      <a href=../beta-intro/Terminology.html>BETA Terminology</a>.
  <li> A
       <a href=../beta-intro/Quick-Reference-Card.html>Quick Reference Card</a> for BETA.
</ul>

<P>
This document describes modifications of the BETA language that have
been made since the publication of the BETA book.  These include 
modifications, clarifications as well as extensions:

<ul>
  <li> A number of new basic patterns have been introduced.
  <li> The operations on basic patterns such as integer, char, boolean
and real, and references are further specified.
  <li> Repetition constructors have been introduced.
  <li> Text literals are further specified and extended and support
for UniCode text has been included.
  <li> For imperatives, the type of a general imperative must
be a basic pattern or a reference, a simple if-imperative has been 
introduced, the labeled compound imperative has been eliminated.
There are various restrictions with respect to leave/restart
of patterns. Inserted objects are implemented as dynamic objects.
  <li> Virtual superpatterns are not implemented, but a final pattern
may be used as a superpattern.
  <li> The use of <tt>this(p)[]</tt> for component objects
is specified.
  <li> Low level primitives for bit manipulation.
  <li> Finally there are some changes regarding dynamic denotations,
concurrency, exception handling, structure objects and the fragment system.
</ul>

<P> In the  following, the above mentioned changes will be described
in detail. <B>The reader is assumed to be familiar with <A
HREF="../bibliography/index.html#mmn93">[MMN 93]</A> 
</B>



<H1>Basic Patterns</H1>

The BETA book defines the following basic patterns: <tt>boolean</tt>,
<tt>char</tt>, <tt>integer</tt>, and <tt>real</tt>.

To support different sizes of integers and characters, a number of new
basic patterns have been introduced. The following table shows the
current basic patterns of BETA and their representation.

<P>
<TABLE border class=opaque>
<TR><TD><CODE>int8</CODE>  </TD><TD><DD>signed 8-bit integer</TD>
<TR><TD><CODE>int8u</CODE> </TD><TD><DD>unsigned 8-bit integer</TD>
<TR><TD><CODE>int16</CODE> </TD><TD><DD>signed 16-bit integer</TD>
<TR><TD><CODE>int16u</CODE></TD><TD><DD>unsigned 8-bit integers
                            (replaces pattern <CODE>shortInt</CODE>)</TD>
<TR><TD><CODE>int32</CODE> </TD><TD><DD>signed 32-bit integer 
                            (identical to <CODE>integer</CODE>)</TD>
<TR><TD><CODE>int32u</CODE></TD><TD><DD>unsigned 32-bit integer</TD>
<TR><TD><CODE>integer</CODE></TD><TD><DD>signed 32-bit integer 
                            (identical to <CODE>int32</CODE></TD>
<TR><TD><CODE>char</CODE>  </TD><TD><DD>8-bit ASCII character</TD>
<TR><TD><CODE>wchar</CODE>  </TD><TD><DD>16-bit UniCode character</TD>
<TR><TD><CODE>boolean</CODE>  </TD><TD><DD>boolean value <CODE>true</CODE>
or <CODE>false</CODE></TD>
<TR><TD><CODE>real</CODE>  </TD><TD><DD>64-bit floating point number</TD>
</TABLE>

<P>
Notes:

<ul>
    <li> Pattern <CODE> shortint</CODE> will be eliminated and should 
no longer be used.
    <li> Pattern <CODE>wchar</CODE> will eventually replace pattern
<CODE>char</CODE>. I.e. characters will in the future be represented
as 16-bit UniCode characters.
</ul>


<H1>Operations on Basic Patterns and References</H1>

<P> In this section the rules for basic patterns- and references
operations such as assignment, arithmetic operations, relational
operations, boolean operations, etc. are further specified.

<P> All expressions are evaluated as 32-bit values, either signed or
unsigned. If an expression is assigned to a a variable representing 8-
or 16-bit values, only the least significant 8- or 16-bits are
assigned.

<P> In the following a number of tables showing legal combinations of
operands and result type for the operations on basic patterns and
references will be given.

Entries not shown are illegal. Entries marked with <B>*</B> are
illegal.  Entries marked with <B>!</B> will give a compiler warning,
and may become illegal in a future version of BETA. The following
abbreviations will be used:

<P> <I> Abbreviations: </I>
<P> <B>int </B>represents an evaluation of type <B>integer</B>
<P> <B>bool</B> represents an evaluation of type <B>boolean</B>
<P> <B>iref </B>represents an evaluation of type <B>item reference</B>
<P> <B>cref </B>represents an evaluation of type
    <B>component reference</B>
<P> <B>sref </B>represents an evaluation of type 
    <B>structure reference</B>
<P>  NONE is both an <B>iref</B>, a <B>cref</B> and an <B>sref</B>.

<H2>Assignment </H2>
The following table shows the legal combinations of
the left and right side of an assignment for basic patterns and references:

<BETA>E -> V</BETA>

<P> The rows of the table shows possible types of of <tt>E</tt> and the
columns of the tables show possible types of of <tt>V</tt>.  The
elements of the table shows the result type, which for assignment are
the same as the type of <tt>V</tt>.

<P> Note that <tt>E</tt> and <tt>C</tt> stand for arbitrary evaluations
including values as in:
<BETA>a+b*10 -> c</BETA>
<P>and references as in:
<BETA>&P[] -> S[]</BETA>

<P>  
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>sref</B>
</TD></TR></TABLE>

<P> Notes:
<ul>
 <li> Assignment between integer, and real is allowed. 
 <li> In assignments of a real value to an integer value,
      the real value is truncated.
 <li> If an integer value is assigned to a variable of type int8, int8u,
      int16, int16u, the value may be truncated.
 <li> Assignment between integer and char/wchar is allowed. 
      Character constants have their ASCII or UniCode value.  
      Assignment of an arbitrary integer value to char/wchar 
      may result in truncation of the integer value.
 <li> Assignment between instances of integer and boolean is currently 
      allowed, but a warning is given. 
      In a future version of BETA these assignments may not be allowed 
      and may give an error. The patterns true and false have the values 1 
      and 0 respectively. Assignment of an arbitrary integer value to a
      boolean instances may result in truncation of the integer value.
</ul>

<H2>Relational Operators</H2>

<H3>Restrictions on Relational Expressions </H3>

The relational operators:

<BETA>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</BETA>

can only be used for the basic patterns integer, real, boolean, and
char.

<P>
The relational operators:

<BETA>=, &lt;&gt;</BETA>

can in addition be used for references.

<P>It is <B>not</B> possible to compare a list of values as in:

<BETA>
(# P: (# ... exit(e1,e2,e3) #);
   A: (# ... exit(f1,f2,f3) #);
   B: @boolean
do P = A -> B;
   P = (g1,g2,g3) -> b
#)   
</BETA>

<H3>Type Rules for Relational Expressions </H3>

The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 = E2</BETA>
and
<BETA>E1 <> E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>iref</B>
</TD><TD><P> <B>cref</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>!</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>iref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>cref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 < E2</BETA>
<BETA>E1 <= E2</BETA>
<BETA>E1 > E2</BETA>
<BETA>E1 >= E2</BETA>


<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>sref</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>sref</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE><P> 

<H2><INX>Arithmetic Operators</INX>.</H2>

<P> The following table shows the legal combinations of types for 
expressions of the form:

<BETA>E1 + E2</BETA>
<BETA>E1 - E2</BETA>
<BETA>E1 * E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD></TR></TABLE>

<P> The following table shows the legal combinations of types for 
expressions on the form :
<BETA>E1 div E2</BETA>

<P>Note that the <tt>div</tt> operator is integer division.

<P>
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>int</B>
</TD></TR></TABLE>


<P> The following table shows the legal combinations of types for
expressions of the form:
<BETA>E1 / E2</BETA>

<P>Note that the <tt>/</tt> operator is a a real operator. The result
is always a real, even if the operands are integers. If integer division
is wanted, use the <tt>div</tt> operator.

<P>
<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>int</B>
</TD><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>int</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>char</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>real</B>
</TD><TD><P> <B>real</B>
</TD><TD><P> <B>*</B>
</TD><TD><P> <B>real</B>
</TD></TR></TABLE><P>  

<B>char</B> is likely to be eliminated as a legal operand for <B>/</B> 
in a future version.


<H2>Boolean Operators </H2>
<H3>Xor Primitive</H3>

<P> An xor primitive is supported as a basic operation on booleans. 
If <tt>E1</tt> and <tt>E2</tt> are boolean expressions then the expression

<BETA>E1 xor E2</BETA>

is an exclusive or between <tt>E1</tt> and <tt>E2</tt>.


<H3><INX>Short-circuit Boolean Expressions</INX></H3>

<P> Boolean expressions are implemented as short-circuit.
<P> That is, in:
<BETA>B1 or B2</BETA>
B2 is <I>not</I> evaluated if B1 is true.

<P>Similarly in:
<BETA>B1 and B2</BETA>
B2 is <I>not</I> evaluated if B1 is false.

<H3>Type rules for boolean expressions </H3>

<P> The following table shows the legal combinations of types for
expressions of the form:

<BETA>E1 and E2</BETA>
<BETA>E1 or E2</BETA>
<BETA>E1 xor E2</BETA>

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> 
</TD><TD><P> <B>bool</B>
</TD></TR><TR VALIGN=TOP><TD><P> <B>bool</B>
</TD><TD><P> <B>bool</B>
</TD></TR></TABLE><P> 


<H3> Unary Operators: </H3>
<P> For unary expressions of the form:
<BETA>+ E</BETA>
<BETA>- E</BETA>

<P> The legal types for <tt>E</tt> are: <B>int</B>, <B>char</B>, or
<B>real</B>.  The result type is the same as operand type

<P>For a unary expression of the form:
<BETA>not E</BETA>

<P> The type of <tt>E</tt> must be <B>bool</B> and the result type is
<B>bool</B>

<H1>Repetition Constructors</H1>
<H2>Value Repetitions</H2>
<P>Consider a value repetition:
<BETA>
R: [exp] @T
</BETA>
where T is a basic pattern.

<P>A repetition object may be constructed and assigned to R 
in the following way:
<BETA>
(E1,E2,...,En) -> R
</BETA>
<P>where <tt>E1, E2, ... En </tt> are evaluations of type <tt>T</tt>.
<P>A repetition object with <tt>range = n</tt> is constructed and 
<tt>R[i] = Ei</tt>, <tt>i</tt> in <tt>[1,n]</tt>.

<P>A repetition object consisting of one element may be constructed
using:
<BETA>E -> R</BETA>

<H2>Example</H2>
The following is an example of using repetitions constructors:
<BETA>
(# a,b: @integer;
   R:[1] @integer
do 10->a; 20 -> b
   (a,b,a+b) -> R;
   (for i: R.range repeat R[i] -> putint; ' '-> put for)
#)
</BETA>
The above example will print the sequence
<BETA>10 20 30</BETA>
<H2>Variable number of enter parameters</H2>
Repetitions may be used to define patterns with a limited form
of a variable number of parameters. Consider the following example:
<BETA>
foo:
   (# S: ^stream;
      V: [1] @integer;
      sep: @char
   enter(S[],V,x)
   do (for i: V.range repeat
           V[i] -> S.putint; sep -> S.put
      for)
   #)
</BETA>
Pattern <tt>foo</tt> may be used in the following way:
<BETA>(screen[],(1,2,3,4,5),'-') -> foo</BETA>
which will print the following sequence to the screen:
<BETA>1-2-3-4-5-</BETA>

<H2> 5. Pattern <tt>text</tt> and <tt>wtext</tt></H2>
Pattern <tt>text</tt> represents 8-bit ASCII texts.

<P>Pattern <tt>wtext</tt> represents 16-bit UniCode texts.
For details see the library <tt>basiclib/wtext.bet</tt>.
Operations supporting conversion between <tt>text</tt> and
<tt>wtext</tt> are available. In a future version of BETA,
<tt>wtext</tt> may replace <tt>text</tt>. 

<H2>String Literals as References</H2>

<P> The pattern <tt>Text</tt> enters and exits a char-repetition. This means,
that a text may be initialized using constant strings as follows:

<BETA>
   t: @text;
do 'hello' -> t;
</BETA>

<P> Many operations involving texts, however, takes <I>references</I>
to texts as enter/exit parameters. This is mainly for efficiency
reasons. <P> To allow easy invocation of such operations on string
literals, the following is <I>also</I> allowed:

<BETA>
   t: ^text;
do 'hello' -> t[];
</BETA>

<P> The semantics of this is, that a text object is instantiated,
initialized by the constant string, and finally assigned to the text
reference. It thus corresponds to the following code:
<BETA>
do &text[] -> t[];
   'hello' -> t
</BETA>


<H2><INX>Special Characters in String Literals</INX></H2>

<P> The following special characters are allowed in BETA string literals.

<TABLE border class=opaque><CAPTION><P> 
</CAPTION><TR VALIGN=TOP><TD><P> \a alert (bell) character
<P> \b <INX>backspace</INX>
<P> \f <INX>formfeed</INX>
<P> \n <INX>newline</INX>
<P> \r carriage <INX>return</INX>
<P> \t horizontal <INX>tab</INX>
</TD><TD><P> \v vertical <INX>tab</INX>
<P> \\ <INX>backslash</INX>
<P> \? question <INX>mark</INX>
<P> \' single <INX>quote</INX>
<P> \&quot; double <INX>quote</INX>
<P> \ooo octal <INX>number</INX>
</TD></TR></TABLE>

<P> <tt>\ooo</tt> can also be <tt>\o</tt> or <tt>\oo</tt>, if the
character immediately following <tt>\o</tt> or <tt>\oo</tt>
respectively, is not a digit.

<P>Previous versions of BETA has allowed <tt>''</tt> to represent a
quote <tt>'</tt> in strings as in <tt>'Tom''s Cottage'</tt>.  <b>This
is no longer allowed</b>. Quote must be represented using <tt>\'</tt>
as in:

<BETA> 'Tom\'s Cottage' </BETA>

<H2>Text Literal Concatenation </H2>

A text literal cannot contain newlines. Alternatively a text literal
may be written as a sequence of strings separated by white space as in:

<BETA>
'Lisa Nelson, '
'2454 West Street, '
'Palo Alto, CA 94304' -> T[]
</BETA>

This corresponds to:

<BETA>
'Lisa Nelson, 2454 West Street, Palo Alto, CA 94304' -> T[]
</BETA>

<H2>Text literals </H2>
Text literals like <tt>'Hello'</tt> may be considered as abbreviations
of char repetition constructors like <tt>('H','e','l','l','o')</tt>.
Consider:
<BETA>Q: [1]@char</BETA>
<p>The evaluation:
<BETA>'Hello' -> Q</BETA>
may considered as an abbreviation for:
<BETA>('H','e','l','l','o') -> Q</BETA>

<H1>Imperatives </H1>

<H2>General If-Imperative </H2>
A general if-imperative has the form:

<BETA>
(if E0 
 // E1 then ... 
 // E2 then ... 
 ...
 // En then ...
if) 
</BETA>

<P> with a possible else-part.

<P> The value of <tt>E0</tt>, <tt>E1</tt>, <tt>E2</tt>, ...,
<tt>En</tt> must be of type int, bool, char, real, iref or cref.

<P> It is thus not possible to compare a list of values as in:

<PRE class_beta>
(# P: (# ... exit(e1,e2,e3) #);
   A: (# ... exit(f1,f2,f3) #);
do (if P
    // A then ...
    // (g1,g2,g3) then ...
   if)
#)
</BETA>


<H2><INX>Simple If</INX>-Imperative</H2>
<P> Often the following If imperative is used:
<BETA>
(if boolExp // true
 then ...
 else ...
if);
</BETA>

<P> The current version of the compiler supports an extension to the BETA 
language called Simple If Imperative. This extension means, that the 
case-selector // may be omitted, if the evaluation on the left hand side 
exits a boolean. That is, the above may be written
<BETA>
(if boolExp
 then ...
 else ...
if);
</BETA>
<P> Like in the general if-statement, the else part is optional.


<H2>The labeled compound imperative </H2>
The labeled compound imperative:

<BETA>(L: imp1; imp2; ...; impN :L)</BETA>

<P>  has been eliminated from the language. 
Instead the following construct may be used:

<BETA>L: (# do imp1; imp2; ... ; impN; #)</BETA>

<P> Inserted items with no declarations and no superpattern will be
inlined in the enclosing code. There will thus be no execution
overhead compared to the old (never implemented) labeled compound
imperative statement.

<H2>Leave- and Restart Imperative </H2>
It is in general not possible to use leave P or restart P where P is a pattern. P must in general be a label.  <I>However</I>, the following has been implemented:

<BETA>
P: (#
   do ...
      leave P
      ... 
      restart P;
      ...
   #)
</BETA>
<P>  Leave/restart from an inserted item, however, is <I>not</I> supported by the current version of the compiler:
<BETA>
P: (#
   do ...
      (#
      do ...
         leave P; (* ILLEGAL *)
         ... 
         restart P; (* ILLEGAL *)
         ...
      #)
      ...
   #)
</BETA>


<H2>Inserted items</H2>

If P is a pattern then an inserted item ([MMN93], section 5.10.2) may
be specified as:

<BETA>(# ...  do ...; P; ... #)</BETA>

<P> Inserted items are implemented as dynamic items (&amp;P). 

<P> Inserted components ([MMN93Madsen93], section 5.10.3):

<BETA>do ...; |(# ... #); ...</BETA>

<P> have not been implemented. 

<H1>Virtual Patterns and Final Patterns as Superpatterns </H1>

A virtual pattern <b>cannot</b> be used as a super pattern as
shown in the following example:

<BETA>
A::< (# ... #);
B: A(# ... #)
</BETA>
 
<P>Previous version of BETA has supported the use of virtual patterns
as super patterns, but due to efficiency considerations virtual
super patterns are no longer supported.

<P> A virtual pattern that has been <I>final bound</I> may be used as
a superpattern as shown in the following example:

<PRE class =beta>
A:: (# ... #); 
B: A(# ... #)
</BETA>

<P>The situation may also occur in a more indirect way: 
<BETA>
graph:
   (# node:< (# ... #);
      nodeList: @list(# element::< node #);
      ...
   #);
</BETA>
<P>    Here the virtual further binding of element in list is <B>not</B> 
allowed, since node is itself virtual. 

<P> The current version of the compiler will allow final binding using
a pattern that is itself virtual. That is, you can do this: 

<BETA>
graph:
  (# node:< (# ... #);
     nodeList: @list(# element:: node #);
     ...
  #);
</BETA>

<H2> 8. The Use of <tt>this(P)</tt> for Component Objects </H3>

Consider the following example: 
<BETA>
P: (#  A: (# X: ^P; (* reference to item qualified by P *)
       B: ^|P (* reference to component qualified by P *)
   do this(P)[] -> X[];   (* legal use of this(P)[] *)
      this(P)[] -> R[];   (* illegal use of this(P)[] *)
   #)
</BETA>

<P>The compiler assumes that <tt>this(P)[]</tt> is a reference to an
item object. Since an item reference cannot be assigned to a component
reference the evaluation <tt>this(P)[] -> R[]</tt> is illegal.

<P> It is, however, possible to use a run-time routine to convert
an item reference to a component reference, provided that the item
is part of a component. Consider:

<BETA>
(# P: (# B: |^ P
      do this(P)[] -> objectToComponent -> B[] 
      #);
   X: |@ P;
   Y: @ P;
do X;  (* OK *)
   Y; (* a run-time error will happen *)
#)
</BETA>

When <tt>X</tt> is executed, the P-object is part of the component 
X and <tt>objectToComponent</tt> will return a reference to X.

<P> When <tt>Y</tt> is executed, the P-object is not part of a
component and <tt>objectToComponent</tt> will fail.

<P>It is also possible to get a reference to the item-part of a component
by using the pattern <tt>componentToObject</tt> as shown in:
<BETA>X[] -> componentToObject</BETA>

<P>The patterns <tt>objectToComponent</tt> and <tt>componentToObject</tt>
are placed in the library:
<BETA>sysutils/objinterface.bet</BETA>

<H1>Dynamic denotations </H1>

In declarations like:
<BETA>
P: &lt;AD&gt;(# ... #);
X: @&lt;AD&gt;;
Y: ^&lt;AD&gt;;
</BETA>

<P> it is checked that &lt;AD&gt; is a <I>static</I> denotation, where
<I>static</I> is defined as follows:

<P>  &middot; A name A is always static
<P>  &middot; In a remote-name R.A, R must be a static object
<P>  &middot; Use of THIS(A).T is static
<P>  &middot; Only in Y: ^P.T, can P be a pattern
<P>  &middot; Denotations using R[e], and (foo).bar are <I>not</I> static
<P>  This means that e.g. descriptors like:
<BETA>
R[e].A(# ... #)
(foo).bar(# ... #)
R.P(# ... #) where 'R' is a dynamic ref.
</BETA>
are only allowed in <I>imperatives</I>.
<P>  For Y: ^R.P where R is a dynamic reference, the compiler will currently report a warning and suggest to use
<P>   
<P>   Y: ^A.P where A is the qualification of R.
<P>  Note: that when using --noWarnQua, this warning will <I>not</I> be printed. A future release may change the warning to an error.

<H1>Concurrency </H1>

<P> There are some deviations with respect to the implementation of
concurrency. Please consult [MIA90-8] before using the
concurrency. 

<H1>Exception Handling </H1>

The <tt>Program</tt> pattern as described in the chapter on exception
handling in [MMN93] has not been implemented. 



<H1>Pattern Variables/Structure Objects </H1>

If <tt>P</tt> is a pattern then <tt>P##</tt> is a structure object
denoting the pattern <tt>P</tt>.

<P>Similarly if <tt>R</tt> is an object, then according to the BETA
book, a structure object corresponding to the descriptor/pattern used to
instantiate <tt>R</tt> may be obtained using <tt>P._struc</tt>.

<P> The expression <tt>R##</tt>, may also be used instead of
<tt>P._struc</tt>.


<H1>Low Level Primitives </H1>
Low level primitives for bit manipulation are described in:
<ul>
  <li><a href=../beta/lowlevel.html>Low Level Primitives</a>
</ul>

<H1>The Fragment System </H1>
A further specification including modifications of the fragment system
is given in:
<ul>
  <li><a href=fragment.html>The Fragment System: Further Specification</a>
</ul>


