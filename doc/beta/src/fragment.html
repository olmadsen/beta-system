<H1 align=center>The Fragment System: Further Specification</H1>
<A NAME=HEADING2-1></A>
<center>
<B>Mj&oslash;lner Informatics Report, MIA 99-42, August 1999</B>
</center>

<H2> <A NAME="LINK-mia90-02.mif-_Toc401563569"><A NAME=MARKER-9-12></A>1.  Introduction</A></H2>


<P> The Mj&oslash;lner System is based on the notion of
<em>fragment</em>. The fragment system must be used for splitting a
large program into smaller units (fragments). The fragment system is
used to support modularization, separation of interface and
implementation parts, variant control and separate compilation. It is
highly recommended to use the fragment system, since this may improve
the structure of the program. </P>

<P> The principles of the fragment system are described in 
<A HREF="../bibliography/index.html#mmn93">[MMN93,Chapter 17]</A>. 
Chapter 17 of [MMN93] is also published in
<A HREF="../bibliography/index.html#knudsen94">[Knudsen 94]</A>. 
In the following it is assumed that the reader is
familiar with this description.</P>

<P> The description in [MMN93] is slightly more idealized than
the actual implementation in the Mj&oslash;lner System: 
In [MMN93], the syntax of the fragment language is given
in terms of diagrams. The fragment language implemented by the
Mj&oslash;lner System has a textual syntax. In this paper,
the textual syntax corresponding to the diagrams in [MMN93]
is presented. 

<P>The description of the fragment system in [MMN93]
is further specified, including a description of implementation
restrictions compared to [MMN93].

<H2> 2. Restrictions </H3>
The following restrictions apply for the implementation
of the fragment system:

<ul>
 <li>
In the Mj&oslash;lner System, slots have been implemented for
the syntactic categories:
<PRE class=beta>
&lt;&lt;objectDescriptor>>
&lt;&lt;mainPart>>
&lt;&lt;doPart&gt;&gt;
&lt;&lt;attributes&gt;&gt;
</PRE>

<li> The alias <tt>descriptor</tt> can be used instead of
<tt>objectDescriptor</tt>. </P>

<li>
A fragment form of the category <tt>&lt;&lt;attributes&gt;&gt;</tt>,
may only contain pattern declarations. It cannot contain any other
kind of declarations, including virtual pattern declarations, virtual
pattern bindings, static or dynamic declarations.</P>

<li> In the current system, fragments are organized in groups. A group
is stored as a file. The BETA compiler accepts a BETA program in the
form of one or more files. Each file must contain a group of fragments
(i.e. one or more fragments). </P>

<li> A pattern where the object descriptor is described as a slot
cannot be used as a super-pattern. I.e. the following is illegal: </P>

<PRE class=beta>   
A: &lt;&lt;SLOT Pdesc: descriptor&gt;&gt;;
B: A(# ... #);  (* illegal *)
</PRE>
<P>  Instead the following can often be used: </P>
<PRE class=beta>
C: (# do &lt;&lt;SLOT Pdesc: descriptor&gt;&gt; #)
D: C(# ... #); (* legal *)
</PRE>

</ul>

<A NAME=HEADING2-1045></A>
<H2> 3.  Fragment Language Syntax</H2>

<P> In the following some of the examples of fragments using the
diagrammatic syntax from [MMN93] will be given followed by the syntax
used by the Mj&oslash;lner System. The first example shows the
simplest possible BETA fragment-group: </P>

<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><tt> NAME 'mini1'</tt>
</TD></TR><TR VALIGN=TOP><TD><tt> ORIGIN 'betaenv'</tt>
</TD></TR><TR VALIGN=TOP><TD><tt> PROGRAM: descriptor</tt>
</TD></TR><TR VALIGN=TOP><TD> (#
 do 'Hello world!' -&gt; PutLine 
 #)</TD></TR></TABLE>
</BLOCKQUOTE>

<P> The fragment-group is stored in the file <tt>mini1.bet</tt>, which
is also the name of the fragment-group. The following syntax is is
used by the Mj&oslash;lner System: </P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv'
-- program: descriptor --
(#
do 'Hello world!'-&gt;PutLine
#)
</PRE>

<P> The origin betaenv has been expanded into a complete file name for
betaenv. </P>

<P> The next example is an example defining a library fragment:</P>
<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>NAME 'mylib'
</TD></TR><TR VALIGN=TOP><TD>ORIGIN 'betaenv'
</TD></TR><TR VALIGN=TOP><TD>LIB: attributes
</TD></TR><TR VALIGN=TOP><TD>Hello: (# do 'Hello' -&gt; PutText #);
World: (# do 'World' -&gt; PutText #)
</TD></TR></TABLE>
</BLOCKQUOTE>

<P> This fragment is stored in a file <tt>mylib.bet</tt> and the
corresponding syntax in the Mj&oslash;lner System is: </P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv'
-- LIB: attributes --
Hello: (# do 'Hello' -&gt; PutText #);
World: (# do 'World' -&gt; PutText #)
</PRE>

<P> The following fragments is an example of a fragment including the
library: <tt>mylib.bet</tt></P>

<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>NAME 'mini2'
</TD></TR><TR VALIGN=TOP><TD>ORIGIN 'betaenv'
</TD></TR><TR VALIGN=TOP><TD>INCLUDE 'mylib'
</TD></TR><TR VALIGN=TOP><TD>PROGRAM: descriptor
</TD></TR><TR VALIGN=TOP><TD>(#
do Hello; World; newLine
#)</P>
</TD></TR></TABLE>
</BLOCKQUOTE>

<P> This fragment is stored in a file <tt>mini2.bet</tt> and has the
following syntax:</P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'mylib';
-- program: descriptor --
(#
do Hello; World; newLine
#)
</PRE>

<P> The following example shows a fragment with a body: </P>
<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>NAME 'textlib'
</TD></TR><TR VALIGN=TOP><TD>ORIGIN 'betaenv'
</TD></TR><TR VALIGN=TOP><TD>INCLUDE 'mylib'
</TD></TR><TR VALIGN=TOP><TD>LIB: attributes
</TD></TR><TR VALIGN=TOP><TD>SpreadText:
   {A blank is inserted between all chars in the text 'T'}
   (# T: @text>
   enter T
   &lt;&lt;SLOT SpreadText:DoPart&gt;&gt;
   exit T
   #);
BreakIntoLines:
   {'T' refers to a text which is to be split into lines.}
   {'w' is the width of the lines.}
   (# T: ^ Text; w: @ Integer
   enter(T[],w)
   &lt;&lt;SLOT BreakIntoLines: DoPart&gt;&gt;
   #)
</TD></TR></TABLE>
</BLOCKQUOTE>

<P> It is stored in a file <tt>textlib.bet</tt> and has the following
syntax:

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
BODY 'textlibbody';
---LIB: attributes---
SpreadText:
  (* A blank is inserted between all chars in the text 'T' *)
  (# T: @text
  enter T
  &lt;&lt;SLOT SpreadText: DoPart&gt;&gt;
  exit T
  #);
BreakIntoLines:
  (* 'T' refers to the text to be split into lines. *)
  (* 'w' is the width of the lines. *)
  (# T: ^ Text; w: @ Integer
  enter(T[],w)
  &lt;&lt;SLOT BreakIntoLines: DoPart&gt;&gt;
  #)
</PRE>

<P> The body of textlib is shown in the next example:</P>
<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>NAME 'textlibbody'
</TD></TR><TR VALIGN=TOP><TD>ORIGIN 'textlib'
</TD></TR><TR VALIGN=TOP><TD>SpreadText: DoPart
</TD></TR><TR VALIGN=TOP><TD>do (# L: @integer
   do (for i: (T.length-&gt;L)-1 repeat
           (' ',L-i+1) -&gt; T.InsertCh
      for)
   #)
</TD></TR><TR VALIGN=TOP><TD>BreakIntoLines: DoPart
</TD></TR><TR VALIGN=TOP><TD>do T.scan
   (# sepInx,i,l: @integer;
   do i+1-&gt;i; l+1-&gt;l;
      (if (ch&lt;=' ' ) then i-&gt;sepInx if);
      (if l=w then
          (nl,sepInx)-&gt;T.InxPut;
          i-sepInx-&gt;l
      if);
   #);
   T.newline;
</TD></TR></TABLE>
</BLOCKQUOTE>

<P> This fragment is stored in a file <tt>textlibbody.bet</tt>. The
corresponding syntax is:</P>

<PRE class=beta>
ORIGIN 'textlib'
-- Spreadtext: DoPart --
do (# L: @Integer
   do ...
   #)
--BreakIntoLines: DoPart --
do ...
</PRE>

<P> Notice, that when local variables are needed in a <tt>DoPart</tt> slot, it
may be necessary to make an inserted item in the <tt>DoPart</tt>. Alternatively
a Private descriptor slot may be declared in the interface, and the L
attribute moved to the Private fragment, which should then be placed
in textlibbody.bet too.</P> 

<P> Finally a general outline of a fragment group with several
include, body and fragments is shown in the next example:</P>

<BLOCKQUOTE>
<TABLE BORDER=1 class=beta><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>NAME F
</TD></TR><TR VALIGN=TOP><TD>ORIGIN G
</TD></TR><TR VALIGN=TOP><TD>INCLUDE A1
</TD></TR><TR VALIGN=TOP><TD>INCLUDE A2
</TD></TR><TR VALIGN=TOP><TD>...
</TD></TR><TR VALIGN=TOP><TD>INCLUDE Am
</TD></TR><TR VALIGN=TOP><TD>BODY B1
</TD></TR><TR VALIGN=TOP><TD>BODY B2
</TD></TR><TR VALIGN=TOP><TD>...
</TD></TR><TR VALIGN=TOP><TD>BODY Bk
</TD></TR><TR VALIGN=TOP><TD>F1: S1
</TD></TR><TR VALIGN=TOP><TD>ff1
</TD></TR><TR VALIGN=TOP><TD>F2: S2
</TD></TR><TR VALIGN=TOP><TD>ff2
</TD></TR><TR VALIGN=TOP><TD>...
</TD></TR><TR VALIGN=TOP><TD>Fn: Sn
</TD></TR><TR VALIGN=TOP><TD>ffn
</TD></TR></TABLE>
</BLOCKQUOTE>

<P> This fragment group is stored in a file <tt>F.bet</tt> and the
syntax is:</P>

<PRE class=beta>
ORIGIN 'G';
INCLUDE 'A1' 'A2'... 'Am;
BODY 'B1' 'B2' ...  'Bk';
Prop1; Prop2; ... Propl
-- F1: S1 --
ff1
-- F2: S2 --
ff2
...
-- Fn: Sn --
ffn</P>
</PRE>

<P> <tt>Prop1, Prop2, ..., Propl</tt> are <I>properties</I> that may
be defined for a fragment. Formally the <tt>ORIGIN, INCLUDE</tt>, and
<tt>BODY</tt> parts are also properties. In section 5 a list of
possible properties is given. </P>

<A NAME=HEADING2-1377></A>

<H2> 4. Fragment Denotations<A NAME=MARKER-2-20></A></H2>

<P> In the examples above, terms like</P>

<PRE class=beta>INCLUDE '~beta/basiclib/betaenv'</PRE>

<P> were used. Below we will use the term FragmentDenotation for the
'fragment path' given in, e.g., the <tt>INCLUDE</tt> property. The
other properties, that accept FragmentDenotations as arguments are
explained in section 5.</P>

<P> Notice that a FragmentDenotation is <I>not</I> the same as a file
name, although it resembles a UNIX file path, and although it normally
corresponds directly to a (set of) file(s):</P>
<ol>
<li>
The separator in the FragmentDenotation is always the
<tt>'/'</tt> character. Although this is a UNIX convention,
the <tt>'/'</tt> must also  be used on Macintosh and Windows.

<li>
As explained in section 3, the notation <tt>'~beta'</tt> is
legal in FragmentDenotations on all platforms, and simply means 'the
place BETA is installed'. As mentioned, the meaning of
<tt>'~beta'</tt> can be controlled by using the BETALIB
environment variable, please consult 
<A HREF="../bibliography/index.html#mia99-36">[MIA 99-36]</A> for details.</P>

<li>
The notation <tt>'.'</tt> means <tt>'current
directory/folder'</tt> on all platforms, and the notation
<tt>'..'</tt> means <tt>'father directory/folder'</tt>,
i.e. the directory containing a given directory.</P>

<li>
It is not allowed to specify an extension
(e.g. <tt>'.bet'</tt> or <tt>'.ast'</tt>) in a
FragmentDenotation.</P>
</ol>

<P> There are some restrictions in the legal fragment <I>file</I>
names, which also apply to the FragmentDenotations, please see section
9.</P>

<A NAME=HEADING2-1388></A>

<H2> 5.  Fragment Properties </H2>

<P> The fragment system allows arbitrary properties to be associated
with fragments. The BETA compiler recognizes the following properties:
For most users, only <tt>ORIGIN</tt>, <tt>INCLUDE</tt>, and
<tt>BODY</tt> are relevant. </P>

<P> <B>ORIGIN <I>&lt;TextConst&gt;</I></B></P>

<P> The origin of a fragment is a fragment which is used when binding
fragment-forms to slots.</P>

<P> <B>INCLUDE <I>&lt;StringList&gt;</I></B></P>

<P> Specifies one or more fragments that are always included when
using this fragment.</P>

<P> <B>BODY <I>&lt;StringList&gt;</I></B></P>

<P> Specifies one or more fragments that fills the slots in this
fragment file, but are not visible.</P>

<P> <B>MDBODY <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> Specifies one or more machine dependent fragments that fills the
slots in this fragment file dependent on the machine type. See section
9 for further description.</P>

<P> <B>BUILD <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> The <A REL=BELOW
HREF="../compiler/compiler-ref.html#HEADING2-1804"><tt>BUILD</tt>
Property</A> is used to specify rules for keeping external
(i.e. non-BETA) sources up to date, and to include the external files
in the link directive. The <tt>BUILD</tt> property unifies the
<tt>OBJFILE</tt> and <tt>MAKE</tt> properties.


<P> <B>OBJFILE <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> The object file is included in the linker-directive. This is
typically an External library which is interfaced to via the External
interface described in [MIA90-8]. See also BUILD and section 9.</P>

<P> <B>BETARUN <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> The standard BETA run-time system is replaced with the one in the
object-file. See also section 9. </P>

<P> <B>MAKE <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> Specifies one or more makefiles to be executed before linking. See
also section 9. The Makefile is executed relative to the directory,
where the file containing the MAKE property is placed. See also
BUILD</P>

<P> <B>RESOURCE <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> Specifies one or more resource files to be included in the
applicatiiton. Only used on Macintosh and Windows NT platforms. See
also section 9.</P>

<P> <B>LIBFILE <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> Is similar to OBJFILE, but specifies inclusion of a library. See
also section 9.</P>

<P> <B>LINKOPT <I>&lt;MachineSpecificationList&gt;</I></B></P>

<P> Machine dependent options to append to link directive for programs
using the fragment. Only used on UNIX platforms. See also section
9.</P>

<P> The terms <tt>&lt;MachineSpecificationList&gt;</tt>,
<tt>&lt;StringList&gt;</tt>, and <tt>&lt;TextConst&gt;</tt> are
syntactically explained in the grammar:</P>

<ul>
  <LI><A HREF="../grammars/property.html">Property Grammar</A>
</ul>

<A NAME=HEADING2-1417></A>

<H2> 6.  Modularization of Data Structures<A NAME=MARKER-2-21></A></H2>

<P> This section gives some advices that can be used when modularizing
data structures. Consider the following program library
(<tt>stack.bet</tt>): </P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv'
--- Lib: attributes ---
stack:
  (# element:&lt; object;
     A: [100] ^element;
     top: @integer;
     push: 
       (# e: ^element;
       enter e[]
       do top+1-&gt;top;
 	  e[] -&gt; A[top][];
       #);
     pop: 
       (# e: ^element;
       do A[top][] -&gt; e[];
 	  top-1-&gt;top;
       exit e[] 
       #);
     top: 
       (# e: ^element;
       do A[top][]-&gt;e[];
       exit e[] 
       #);
  #)
</PRE>

<P> If we want to separate the interface and the implementation, this
can be modularized in the following way:</P>

<P> <A NAME=MARKER-2-22></A><I>Introduce the following SLOTs:</I></P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
BODY 'stackImpl'
--- Lib: attributes ---
stack:  
  (# element:&lt; object;
     private: @&lt;&lt;SLOT private: descriptor&gt;&gt;;
     push: 
      (# e: ^element;
      enter e[]
      &lt;&lt;SLOT pushBody: DoPart&gt;&gt; 
      #);
     pop: 
      (# e: ^element;
      &lt;&lt;SLOT popBody: DoPart&gt;&gt; 
      exit e[] 
      #);
     top: 
      (# e: ^element;
      &lt;&lt;SLOT topBody: DoPart&gt;&gt; 
      exit e[] 
      #);
  #) 
</PRE>

<P> <I>Create a new fragment file stackImpl.bet:</I></P>

<PRE class=beta>
ORIGIN 'stack';
-- private: descriptor -- 
(# A: [100] ^element;
   top: @integer;
#)
-- pushBody: DoPart -- 
do private.top+1-&gt;private.top;
   e[] -&gt; private.A[private.top][];
-- popBody: DoPart -- 
do private.A[private.top][] -&gt; e[];
   private.top-1-&gt;private.top;
-- topBody: DoPart -- 
do private.A[private.top][]-&gt;e[]
</PRE>

<P> The reason why the data representation (<tt>A</tt> and
<tt>Top</tt>) is put into a descriptor slot instead of an attributes
slot is that attributes slots may only contain patterns, no static
items (objects) or object references. This is due to the
implementation of separate compilation. Therefore it is necessary to
put static items into an attribute (in this case private) that is
declared by means of a descriptor slot. Because of this all accesses
to the representation must be done via the private variable (see
<tt>pushBody</tt>, <tt>popBody</tt> and <tt>topBody</tt>). Notice that
the parameters are visible in the interface. If the operations had
local variables they should not be shown in the interface. </P>

<A NAME=HEADING2-1483></A>

<H2> 7.  Modularization with INNER</H2> 

<P> Programs fragments with do-parts that contain an <tt>INNER</tt>
imperative e.g.:</P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
--- lib: attributes ---
A: (# do imp1; imp2; INNER; imp3 #)
</PRE>

<P>can be modularized in the following two ways depending on whether
the <tt>INNER</tt> imperative should be visible in the interface or
not. </P> 

<P>If the <tt>INNER</tt> is preferred visible in the interface, the
interface fragment could look like (<tt>fooLib1.bet</tt>):</P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
BODY 'fooImpl1'
-- lib: attributes --
A: (# 
   do &lt;&lt;SLOT imp12slot: descriptor&gt;&gt;;
      INNER;
      &lt;&lt;SLOT imp3slot: descriptor&gt;&gt;
   #) 
</PRE>

<P> and the implementation fragment (<tt>fooImpl1.bet</tt>):</P>

<PRE class=beta>
ORIGIN 'fooLib1'
-- imp12slot: descriptor --
(# do imp1; imp2 #)
-- imp3slot: descriptor --
(# do imp3 #)
</PRE>

<P> In this case a <tt>DoPart</tt> slot might be used instead
(<tt>fooLib2.bet</tt>):</P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
BODY 'fooImpl2'
-- lib: attributes --
A: (# &lt;&lt;SLOT imp12slot: DoPart&gt;&gt; #) 
</PRE>

<P> with the implementation fragment (<tt>fooImpl2.bet</tt>):
<PRE class=beta>
ORIGIN 'fooLib2'
-- imp12slot: DoPart --
do imp1; imp2; INNER; imp3
</PRE>

<P> Using do-parts like this, then although the <tt>INNER</tt> is not
visible in the interface, the A pattern may still be specialized and
behave as if the <tt>INNER</tt> was in the interface. Notice, that
when specializing a pattern with no <tt>INNER</tt> in the do-part, the
compiler will normally complain about this. But when the pattern being
specialized contains a <tt>SLOT</tt>, the compiler will assume, that
the <tt>SLOT</tt> contains an <tt>INNER</tt>. Thus it is possible to
specialize the <tt>A</tt> pattern in <tt>foolib2</tt>.</P>

<P>But if the <tt>INNER</tt> imperative is placed 'inside' some
structure e.g.:

<PRE class=beta>
A: (# 
   do (if E1 
       // E2 then INNER
       // E3 then imp
      if)
   #)
</PRE>

<P> you might not want to show the if imperative in the interface. In
this case a variant of the <tt>INNER</tt> construct may be used, in
which case the interface fragment could be (<tt>fooLib3.bet</tt>):</P>

<PRE class=beta>
ORIGIN '~beta/basiclib/betaenv';
BODY 'fooImpl3'
--- lib: attributes ---
A: (# do &lt;&lt;SLOT Abody: descriptor&gt;&gt; #);
</PRE>

and the implementation fragment (<tt>fooImpl3.bet</tt>):
<PRE class=beta>
ORIGIN 'fooLib3'
--- Abody: descriptor ---
(# 
do (if E1 
    // E2 then INNER A
    // E3 then imp
   if)
#)
</PRE>

<P> If a 'normal' <tt>INNER</tt> had been used instead of <tt>INNER
A</tt>, it would mean that specializations of the pattern containing
the <tt>INNER</tt> in the do-part combine the actions at this
point. But the pattern containing the <tt>INNER</tt> in the do-part,
in this case would be the anonymous pattern in the <tt>ABody</tt>
descriptor fragment. By using <tt>INNER A</tt>, it is ensured, that
the control flow descents to the specialization of <tt>A</tt> although
the <tt>INNER</tt> is inside the <tt>ABody</tt> descriptor.</P>

<P> A <tt>DoPart</tt> slot could also be used here, as in the previous
example.</P>

<A NAME=HEADING2-1537></A>

<H2>8.  Formal Syntax of Fragment Language</H2>
<P> The formal syntax of the BETA fragment-system is: </P>
<PRE CLASS=beta> 
<P> &lt;TranslationUnit&gt; ::= &lt;Properties&gt; &lt;FormPart&gt; 
<P> &lt;FormPart&gt; ::* &lt;FormDef&gt;
<P> &lt;FormDef&gt; ::= -- &lt;FormDefinition&gt;
<P> &lt;FormDefinition&gt; ::| &lt;DescriptorForm&gt; 
<P>                    | &lt;AttributesForm&gt; 
<P>                    | &lt;DopartForm&gt;
<P>                    | &lt;MainpartForm&gt;
<P> &lt;DescriptorForm&gt; ::= &lt;NameDcl&gt; : descriptor -- &lt;ObjectDescriptor&gt; 
<P> &lt;AttributesForm&gt; ::= &lt;NameDcl&gt; : attributes -- &lt;Attributes&gt; 
<P> &lt;DopartForm&gt; ::= &lt;NameDcl&gt; : doPart -- &lt;DoPart&gt; 
<P> &lt;MainpartForm&gt; ::= &lt;NameDcl&gt; : mainPart -- &lt;MainPart&gt; 
</PRE>

The grammar for <tt>&lt;Properties&gt;</tt> may be found at:
<ul>
  <LI><A HREF="../grammars/property.html">Property Grammar</A>
</ul>

<p>Notes:
<ul>
<li> The symbol <tt>--</tt> may consist of two or more dashes
(<tt>-</tt>).

<li> The old style <tt>INCLUDE</tt> and fragment syntax 
(<tt>--INCLUDE</tt> fragment) is no longer supported.
</ul>

<A NAME=HEADING2-1594></A>

<H2> 9. File Name Restrictions<A NAME=MARKER-2-23></A></H2>

<P> Because of implementations details, the current version of the
fragment system imposes the following restrictions on file names used
for BETA programs.</P>

<P> 1. It is not allowed for a program to use two files with the same
name, say <tt>foo.bet</tt> (ignoring case), which both contains
fragments of category <tt>Attributes</tt>.</P>

<P> 2. It is not allowed for a program to use a file named, say,
<tt>foo.bet</tt>, if <tt>foo.bet </tt>contains a fragment of category
<tt>Attributes</tt>, and if there is a <tt>SLOT</tt> of category
<tt>ObjectDescriptor/Descriptor</tt> or <tt>DoPart</tt> named
<tt>foo</tt> in any of the files involved in the program. Again case
is irrelevant.</P>

<P> 3. It is not allowed to use the '-' (dash) character in fragment
file names.</P>

<P> 4.  Because the <tt>FragmentDenotation</tt> separator character is
<tt>'/'</tt> it is not allowed to use the <tt>'/'</tt> in fragment
file names, not even on platforms where the file system would allow
it.</P>

<P> 5.  In general, it is advisable to restrict the characters used in
the fragment file names to be: <tt>a-z</tt>, <tt>A-Z</tt>,
<tt>0-9</tt>, and <tt>'_'</tt>.  If other characters are used in the
fragment file names, there is a danger, that the supporting tools
(such as linkers) will complain.</P>

<P> The symptom on breaking rule 1 or 2 is typically a '<tt>Multiple
defined symbol M1FOO'</tt> and the like, in the linking phase, the
symptom for breaking rule 3 is that the compiler or the mjolner tool
(<A HREF="../bibliography/index.html#mia99-39">[MIA 99-39]</A>,
<A HREF="../bibliography/index.html#mia99-40">[MIA 99-40]</A>,
<A HREF="../bibliography/index.html#mia99-34">[MIA 99-34]</A>)
 may become
confused. Finally the symptom on breaking rule 5 may be a complaint
from the assembler about illegal characters.</P>

<P> Except for rule 3, these restrictions only apply to the
<I>file</I> names. The <I>directories / olders</I> containing the
files, may be freely named.</P>


A pattern where the object descriptor is described as a slot cannot be
used as a super-pattern. I.e. the following is illegal: </P>

<PRE class=beta>
A: &lt;&lt;SLOT Pdesc: descriptor&gt;&gt;; 
B: P(# ... #);  (* illegal *)
</PRE>
<P>  Instead the following can often be used: </P>
<PRE class=beta>
C: (# do &lt;&lt;SLOT Pdesc: descriptor&gt;&gt; #) 
D: P(# ... #); (* legal *)
</PRE>



