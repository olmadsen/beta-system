<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>

<HEAD>




<TITLE> The BetaDBC Interface</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING5></A>


<P><A HREF=betadbc-6.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=betadbc-4.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P>The BetaDBC Library</P>


<A NAME=HEADING5-0></A>
<H1> The BetaDBC Interface</H1>
<P> The BetaDBC interface is built around the concept of a connection that models a connection to a relational DBMS. The BetaDBC interface to a connection is (see below for the full interface):</P>
<PRE CLASS=beta>
Connection: (*)
  (# &lt;&lt;SLOT ConnectionLib:Attributes&gt;&gt;;
     declareVar: (*) ...;
     declareInteger: (*) declareVar ...;
     declareReal: (*) declareVar ...;
     declareText: (*) declareVar ...;
     declareBoolean: (*) declareVar ...;
     declareDate: (*) declareVar ...;
     declareTime: (*) declareVar ...;
     SQLStatement: (*) ...;
     directSQLStatement: (*) SQLStatement ...;
     preparedSQLStatement: (*) directSQLStatement ...;
     resultSet: (*) ...;
     open:&lt; (*) ...;
     close:&lt; ...;
     connectionException:&lt; BDBCException ...;
     connectionWarning:&lt; BDBCWarning ...;
     private: @&lt;&lt;SLOT ConnectionPrivate:Descriptor&gt;&gt;
  #);
</PRE>
<A NAME=HEADING5-23></A>
<H2> Data Sources</H2>
<P> In order to use a connection a data source must be created (See the tutorial for specifics.). To communicate with an existing data source the user must first create an instance of the connection pattern. Calling the open method on a connection:</P>
<PRE CLASS=beta>
open:&lt; (*)
  (# name: ^text;
     userName: ^text;
     password: ^text;
     openConnectionException:&lt; BDBCException (#  do INNER #);
     openConnectionWarning:&lt; BDBCWarning (#  do INNER #)
  enter (name[],userName[],password[])
  &lt;&lt;SLOT ConnectionOpen:DoPart&gt;&gt;
  #);
</PRE>
<P> then makes it possible to communicate with the data source. When calling open the name of the data source must be supplied whereas user name and/or password may be omitted as appropriate. Consider as an example the statement</P>
<PRE CLASS=beta>
('ullman97','marius',none)-&gt;sqlCon.open
</PRE>
<P> The statement opens a connection to the data source name &quot;ullman97&quot; for the user &quot;marius&quot; without specifying a password.</P>
<A NAME=HEADING5-41></A>
<H2> Shared variables</H2>
<P> Definition of shared variables are done via the &quot;declare...&quot; methods. To e.g. declare a text studioName as a shared variable named &quot;studioName&quot; use</P>
<P> </P>
<PRE CLASS=beta>
studioName: @text;

...

do 'studioName'-&gt;declareText
   (# set::(# do value-&gt;studioName #);
      get::(# do studioName[]-&gt;value[] #)
   #)
</PRE>
<A NAME=HEADING5-54></A>
<H2> SQL Statements</H2>
<P> Data manipulation and definition is done using the SQL statement patterns. The SQL statement patterns have the following interfaces:</P>
<PRE CLASS=beta>
SQLStatement:(*)
  (# &lt;&lt;SLOT SQLStatementLib:Attributes&gt;&gt;;
     execute:&lt;(*) ...;
     close:(*) ...;
     execException:&lt; BetaDBCException ...;
     execWarning:&lt; BetaDBCWarning ...;
     private: @&lt;&lt;SLOT SQLStatementPrivate:Descriptor&gt;&gt;;
     get:&lt; ...;
     set:&lt; ...
  enter set
  do INNER
  exit get
  #);

directSQLStatement:(*) SQLStatement
  (# &lt;&lt;SLOT DirectSQLStatementLib:Attributes&gt;&gt;;
     currentMarker:(*) @ ...;
     marker:(*) ...;
     b: (*) marker ...;
     c: (*) marker ...;
     d: (*) marker ...;
     f: (*) marker ...;
     i: (*) marker ...;
     s: (*) marker ...;
     t: (*) marker ...;
     execute::  ...;
     execDirectException:&lt; BetaDBCException ...;
     execDirectWarning:&lt; BetaDBCWarning ...;
     private: @&lt;&lt;SLOT DirectSQLStatementPrivate:Descriptor&gt;&gt;;
     set::&lt;  ...;
     getExpanded:(*) ...
  do INNER
  #);

preparedSQLStatement:(*) ...
</PRE>
<P> To use a statement stmt, one must first open it and then associate it with an SQL statement as in</P>
<PRE CLASS=beta>
stmt.open
'SELECT title, length FROM Movie WHERE studioName = \'Disney\''-&gt;stmt
</PRE>
<P> Invoking execute on stmt will then cause the SQL statement to be executed at the database. A statement should be closed after use.</P>
<P> A preparedSQLStatement differs from a directSQLStatement in that a prepared statement is parsed and prepared by the data source when the statement is initialised, i.e. executing</P>
<P> the statement above will, if stmt is a preparedSQLStatement, cause the contents of the SQL statement to be sent to the database in order for it to be parsed and prepared for future execution. If stmt is a directSQLStatement no communication with the database will occur before calling execute.</P>
<P> In this way a prepared SQL statement is a little slower to initialise than a direct SQL statement but much faster to execute. Use a preparedSQLStatement only when an SQL statement has to be executed several times.<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-1">[1]</A></EM></P>
<PRE CLASS=beta>
	       
</PRE>
<P> The contents of a directSQLStatement can be any SQL statement with embedded shared variables and/or markers, i.e. a directSQLStatement stmt may be initialised as in</P>
<PRE CLASS=beta>
'SELECT title,length FROM Movie WHERE studioName = :studioName AND year = %i' 
  -&gt;stmt
</PRE>
<P> Here &quot;studioName&quot; is the name of a shared variable declared as shown above. The value of the %i marker may be set using the i pattern in directSQLStatement. Now suppose that the following statements have been executed</P>
<PRE CLASS=beta>
do ...; 'Disney'-&gt;studioName; 1990-&gt;stmt.i; ...
</PRE>
<P> When executing the SQL statement the SQL contents of the statement will then conceptually be</P>
<PRE CLASS=beta>
SELECT title,length FROM Movie WHERE studioName = 'Disney' AND year = 1990 
</PRE>
<P> i.e., before sending an SQL statement to a database the embedded shared variables and the markers are, conceptually, substituted for their current values. After execution the contents of the statement can be changed, the markers can be reset or the statement can be closed.</P>
<P> describe setXXXByName</P>
<P> A preparedSQLStatement is used similarly to a directSQLStatement.</P>
<A NAME=HEADING5-119></A>
<H2> Results</H2>
<P> Executing an SQL statement stmt will yield an instance of resultSet (here rs is a reference to a resultSet):</P>
<PRE CLASS=beta>
stmt.execute-&gt;rs[]
</PRE>
<P> A resultSet implements an interface to an SQL cursor in the following way</P>
<PRE CLASS=beta>
resultSet:(*)
  (# &lt;&lt;SLOT ResultSetLib:Attributes&gt;&gt;;
     columnCount:(*) integerValue ...;
     rowCount:(*) integerValue ...;
     column: (*)...;
     getColumn: (*)...;
     getColumnByName:(*) ...;
     result:(*)
       (# &lt;&lt;SLOT ResultLib:Attributes&gt;&gt;;
          marker:(*) ...;
          b: marker ...;
          c: marker ...;
          d: marker ...;
          f: marker ...;
          i: marker ...;
          s: marker ...;
          t: marker ...;
          private: @...
       #);
     scan:(*)
       (# current: @result;
          varNotDeclared:&lt;(*) exception ...;
          unknownColumn:&lt;(*) exception ...;
          pattern: ^text
       enter pattern[]
       ...
       #);
     resultSetException:&lt; BDBCException ...;
     resultSetWarning:&lt; BDBCWarning ...;
     private: @...
  #)
</PRE>
<P> Given a resultSet the scan method iterates over the tuples in the resultSet. There are three distinct ways to control the scan. Firstly, one may simply execute</P>
<PRE CLASS=beta>
rs.scan(# ... #)
</PRE>
<P> In the do-part of the scan one may then refer to the values of the columns in the result. This is done sequentially by referring to the markers of the current result.  If e.g. rs was retrieved as shown above,</P>
<PRE CLASS=beta>
rs.scan(# do current.s -&gt; putline; current.i-&gt;putint; newline #)
</PRE>
<P> will scan over the results in the resultSet and print the values of their columns on the screen.</P>
<P> Also, one may enter a string when evaluating a scan pattern as in:</P>
<PRE CLASS=beta>
':title %i'-&gt;rs.scan(# do title-&gt;putline; current.i-&gt;putint; newline #)
</PRE>
<P> Here title is a shared variable named &quot;title&quot;. This statement prints the same as above but by providing an input string it is here specified that the first column of each result should be assigned to the shared variable &quot;title&quot; and that the second column of each result is an integer that will be fetched via the i marker. In general one may in this way specify how each column of a result should be treated.</P>
<P> The two ways of scanning shown above may, in some circumstances, be problematic in that they assume a specific ordering of columns in the results. Therefore, the last way of doing a scan names the columns in the resultSet, as in e.g.:</P>
<PRE CLASS=beta>
'length%i title:title'-&gt;rs.scan
   (# do title-&gt;putline; current.i-&gt;putint; newline #)
</PRE>
<P> In this way the order of the columns in the result may be changed from &quot;title, length&quot; to &quot;length, title&quot; without any problems for the last way of scanning.</P>
<P> describe fetch</P>
<P> describe cursorType?</P>






<HR>

<A NAME=FOOTNOTE-1>[1] </A>
 Note that, currently, a preparedSQLStatement is implemented as a directSQLStatement.






<HR>
<P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left">
<ADDRESS>The BetaDBC Library</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=betadbc-6.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=betadbc-4.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>

<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
