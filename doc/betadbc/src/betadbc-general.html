<H1>How to use the BetaDBC interface</H1>

<H2>Introduction</H2>

<P>
This section is a step-by-step guide to get you started using BetaDBC.
</P>
<P>
The first time you connect to a database from a Beta program, it is a 3 step process:
</P>
<ul>
<li>Set up your system</li>
<li>Initialize database and users</li>
<li>Write some Beta code</li>
</ul>
<P>
Step 1 is necessary once per platform, step 2 is necessary once per database/user and step 3 is always necessary <code>:)</code>
</P>

<H2>Setting up your system</H2>
This may be the most troublesome of the 3 steps, but on the bright side you may not have to do it at all. Perhaps your systems administrator has already done it. If you are stuck with the job then proceed as follows:

<H3>On Windows</H3>
<P>
First: Install your database manager according to the installation guidelines that came with it.
</P>

Then:<br>
<ul>
<li>If your Beta system uses Microsoft tools (as opposed to GNU tools) and your database manager is Oracle or Frontbase, you are in luck. No further setup is required.<br>
<br>
</li>
<li>If your Beta system uses Microsoft tools and your database manager is MySQL you must do the following:<br>
Copy the file <code> mysql\lib\opt\libmySQL.lib </code><br>
into the directory <code> beta\lib\nti_ms\ </code><br>
<br>
</li>
<li>Otherwise you must connect to your database manager via ODBC. A driver for that purpose is either included in the standard database manager installation (example: Microsoft Access), or must be installed separately (example: MySQL).<br>

To set up the driver, click Start > Settings > Control Panel > ODBC Data Sources (32-bit)<br>
Click the tab 'User DNS'<br>
Look at the list 'User Data Sources'<br>
If you do not see a driver for your database manager, you need to download and install one.<br>
Click the driver of your database manager and click 'Configure'<br>
You can now adjust various parameters of the data source depending on the driver. In particular, you can probably set the name of the data source as well as a user name and password. These settings are used when you open a connection in a Beta program.
</li>
</ul>




<H3>On Unix</H3>
<P>
First: Install your database manager according to the installation guidelines that came with it.
</P>

Then:<br>
<ul>
<li>If your database manager is supported by a native BetaDBC library - currently Oracle, Frontbase and MySQL - you are in luck. No further setup is required.
<br><br>
</li>
<li> Otherwise you must connect to your database manager via ODBC. You will need a .odbc.ini file in your home directory. Create such a file if it does not exist. Suppose a driver for the PostgreSQL database manager is located in <code>/usr/local/lib/libcliPG.so</code>.  If you want to connect to the database 'mydb' on the database server 'delirium' insert the following in your <code>.odbc.ini</code> file ('ReadOnly = 0' tells the driver that you want to manipulate the 'mydb' database)

<BETA>
[mydatasource]
# data source containing the 'mydb' db on delirium
Driver = /usr/local/lib/libcliPG.so
Database = mydb
Servername = delirium
ReadOnly = 0
</BETA>

<P> This defines a data source named 'mydatasource', that you may use BetaDBC to connect to. In the example 'ReadOnly' is a driver specific attribute of the data source 'mydatasource'. See the documentation for the drivers used for definitions of driver specific attributes.</P>
</li>
</ul>

<H2>Initializing a database</H2>

<H3>Frontbase</H3>
sql92 is a small tool included in the FrontBase installation. It is used for creating databases and database users. By default it is located in <code>FrontBase/bin/sql92</code>
<P>
A small example:<br>
start sql92 and type the following:
</P>
<beta>
create database firstdb;
connect to firstdb user _system;
create user firstuser;
disconnect current;
connect to firstdb user firstuser;
disconnect current;
</beta>




<H3>MySQL</H3>
<p>
When the MySQL database manager is up and running it has by default only one user called 'root' whose password is empty. New users are created using eg. GRANT statements as follows:
</p>
Start MySQL as user 'root' on the database 'mysql':
<beta>
./bin/mysql -u root mysql
</beta>

Create a user called 'firstusr' whose password is 'firstpswd':
<beta>
mysql> GRANT ALL PRIVILEGES ON *.* TO firstusr@localhost IDENTIFIED BY 'firstpswd' WITH GRANT OPTION;
mysql> GRANT ALL PRIVILEGES ON *.* TO firstusr@"%" IDENTIFIED BY 'firstpswd' WITH GRANT OPTION;
</beta>
Additional users can be created in a similar fashion.

Now create a database for the user 'firstusr':
<beta>
./bin/mysqladmin -u firstusr -p create firstdb
</beta>
This creates a database 'firstdb' after prompting for the password.

The user 'firstusr' can now log on to the database 'firstdb':
<beta>
./bin/mysql -u firstusr -p firstdb
</beta>

Tables can now be created using standard SQL statements:
<beta>
mysql> CREATE TABLE test (name CHAR(200) NOT NULL, KEY index_name (name(10)));
</beta>







<H2>Writing the Beta code</H2>
<H3>Including an interface</H3>
<P>You must always INCLUDE the relevant interface</P>
<table>
<tr><td>If you use ODBC:</td>	<td><code>INCLUDE '~beta/betadbc/betadbc_odbc'</code></td></tr>
<tr><td>If you use native Oracle:</td>	<td><code>INCLUDE '~beta/betadbc/betadbc_oracle'</code></td></tr>
<tr><td>If you use native Frontbase:</td>	<td><code>INCLUDE '~beta/betadbc/betadbc_frontbase'</code></td></tr>
<tr><td>If you use native MySql:</td>	<td><code>INCLUDE '~beta/betadbc/betadbc_mysql'</code></td></tr>
</table>

<H3>Opening a connection</H3>
<P>You must first create an instance of the connection pattern.</P>
<BETA>
sqlCon: @Connection;
stmt: @sqlCon.directSqlStatement;
</BETA>

<P>Calling the open method on a connection...</P>
<BETA>
('access','marius',none)->sqlCon.open
</BETA>
<P>
...then makes it possible to communicate with the data source. The statement opens a connection to the data source name &quot;access&quot; for the user &quot;marius&quot; without specifying a password.</P>


<H3>SQL Statements</H3>
<P>Data manipulation and definition is done using the SQL statement pattern directSQLStatement. To use a directSQLStatement <code>stmt</code>, one must first open it and then associate it with an SQL statement as in</P>
<BETA>
stmt.open;
'SELECT title, length FROM Movie WHERE studioName = \'Disney\''->stmt;
</BETA>
or, equivalently
<BETA>
'SELECT title, length FROM Movie WHERE studioName = \'Disney\''->stmt.open;
</BETA>

<P> Invoking <code>stmt.execute</code> will then cause the SQL statement to be executed at the database. A statement should be closed after use: <code>stmt.close</code></P>

<H3>Declaring Shared Variables</H3>
<P>Definition of shared variables are done via the &quot;declare...&quot; methods. E.g. to declare a text studioName as a shared variable named &quot;studioName&quot; use</P>
<BETA>
studioName: @text;
...
do 'studioName'->declareText
   (# set::(# do value->studioName #);
      get::(# do studioName[]->value[] #)
   #)
</BETA>

<H3>Using shared variables</H3>
<P>The contents of a directSQLStatement can be any SQL statement with embedded shared variables and/or markers, i.e. a directSQLStatement stmt may be initialized as in</P>
<BETA>
'SELECT title,length FROM Movie WHERE studioName = :studioName AND year = %i'->stmt;
</BETA>

<P>Here &quot;studioName&quot; is the name of a shared variable declared as shown above. The value of the %i marker may be set using the i pattern in directSQLStatement. Now suppose that the following statements have been executed</P>
<BETA>
 'Disney'->studioName;
 1990->stmt.i;
</BETA>

<P> When executing the SQL statement the SQL contents of the statement will then conceptually be</P>

<BETA>
SELECT title,length FROM Movie WHERE studioName = 'Disney' AND year = 1990
</BETA>

<P> i.e., before sending an SQL statement to a database the embedded shared variables and the markers are, conceptually, substituted for their current values. After execution the contents of the statement can be changed, the markers can be reset or the statement can be closed.</P>

Also, embedded shared variables and markers can be named as in

<BETA>
'SELECT title,length FROM Movie WHERE studioName = :studioName AND year = theYear%i'->stmt;
</BETA>

In this case, the %i marker is named "theYear" and the statement may be used as

<BETA>
'Disney'->studioName; ('theYear',1990)->stmt.setIntegerByName
</BETA>

<p>
<i>Please note that the use of shared variables is only supported in the ODBC interface. Suggested workaround for the other interfaces: build your SQL statements dynamically using <code>append</code> or <code>putformat</code>.
</i>
</p>

<H3>Results</H3>
<P>Executing an SQL statement stmt will yield an instance of resultSet (in the following rs is a reference to a resultSet):</P>
<BETA>
rs: ^connection.resultSet
...
do stmt.execute->rs[]
</BETA>

<P> Given a resultSet, the scan method iterates over the tuples in the resultSet. There are three distinct ways to control the scan. First, one may simply execute</P>

<BETA>
rs.scan(# do ... #)
</BETA>

<P> In the do-part of the scan one may then refer to the values of the columns in the result. This is done sequentially by referring to the markers of the current result.  If, e.g., rs was retrieved as shown above,</P>

<BETA>
rs.scan(# do current.s -> putline; current.i->putint; newline #)
</BETA>

<P>will scan over the results in the resultSet and print the values of their columns on the screen.</P>

<P>Second, one may enter a string when evaluating a scan pattern as in:</P>

<BETA>
':title %i'->rs.scan(# do title->putline; current.i->putint; newline #)
</BETA>

<P> Here title is a shared variable named &quot;title&quot;. This statement prints the same as above but by providing an input string it is here specified that the first column of each result should be assigned to the shared variable &quot;title&quot; and that the second column of each result is an integer that will be fetched via the i marker. In general one may in this way specify how each column of a result should be treated.</P>
<P> The two ways of scanning shown above may, in some circumstances, be problematic in that they assume a specific ordering of columns in the results. Therefore, the third way of doing a scan names the columns in the resultSet, as in e.g.:</P>
<BETA>
'length%i title:title'->rs.scan
   (# do title->putline; current.i->putint; newline #)
</BETA>
<P> In this way the order of the columns in the result may be changed from &quot;title, length&quot; to &quot;length, title&quot; without any problems for the last way of scanning.</P>










<H3>Specifics for the native Oracle interface</H3>
<p>
Please note that the use of shared variables is only supported in the ODBC interface. Suggested workaround for the other interfaces: build your SQL statements dynamically using <code>append</code> or <code>putformat</code>.
</p>
<P>
For obscure reasons the datatype <code>boolean</code> is not supported by Oracle. Furthermore, the use of time/date datatypes is discouraged, and therefore sparingly suppported by the Oracle interface. Oracle recommends storing dates as text.
</P>

<P>
A small example using Oracle:<br>
The user <code>scott</code> with password <code>tiger</code> wants to connect to the default server (hence the empty text in the opening of the connection):
</P>
<BETA>
ORIGIN '~beta/betadbc/betadbc-oracle';
-- program: Descriptor --
(#
   oraCon: @Connection;
   stmt: @oraCon.DirectSQLStatement;

   do
   ('','scott','tiger')->oraCon.open;

   'create table Students("Name" varchar(100), "Age" integer);'->stmt.open;
   stmt.execute;
   stmt.close;
   'commit;'->stmt.open;
   stmt.execute;
   stmt.close;
   oraCon.close;
#)
</BETA>




<H3>Specifics for the native Frontbase interface</H3>
<P>
Please note that the use of shared variables is only supported in the ODBC interface. Suggested workaround for the other interfaces: build your SQL statements dynamically using <code>append</code> or <code>putformat</code>.
</p>
<P>
Selecting a host:<br> The Beta program must select the host on which the FrontBase server is running before opening a connection. Selecting the host is done by using <code><INX>selecthost</INX></code>
</P>
<p>
<P>
A small example using Frontbase:<br>
</P>
<BETA>
ORIGIN '~beta/betadbc/betadbc-frontbase';
-- program: Descriptor --
(#
   frontbaseCon: @Connection;
   stmt: @frontbaseCon.DirectSQLStatement;

   do
   'brage.mjolner.dk' -> frontbaseCon.selecthost;
   ('firstdb','firstuser','')->frontbaseCon.open;

   'create table Students("Name" varchar(100), "Age" integer);'->stmt.open;
   stmt.execute;
   stmt.close;
   frontbaseCon.close;
#)
</BETA>





<H3>Specifics for the native MySQL interface</H3>
<p>
Please note that the use of shared variables is only supported in the ODBC interface. Suggested workaround for the other interfaces: build your SQL statements dynamically using <code>append</code> or <code>putformat</code>.
</p>
<P>
Selecting a database:<br>
To utilize the MySQL interface in Beta you must select a database by using <CODE><INX>selectdb</INX></CODE> after opening a connection, as shown in this excerpt from the adhoc.bet demo:
</P>

<BETA>
ORIGIN '~beta/betadbc/betadbc-mysql';
INCLUDE '~beta/basiclib/formatio'
        '~beta/basiclib/numberio' '~beta/basiclib/file';
-- program: Descriptor --
(#
   sqlCon: @Connection; stmt: @sqlCon.DirectSQLStatement;
   res: ^sqlCon.resultSet
do
   'hi there'->putline;
   (2->arguments,3->arguments,4->arguments)->sqlCon.open;
   'firstdb'->sqlCon.selectdb;
...
</beta>
adhoc is then invoked as follows:
<beta>
./adhoc vertigo firstusr firstpswd
 </BETA>
<P>
Where vertigo is the host on which the MySQL server is running. It is possible to use 'localhost'.
</P>
