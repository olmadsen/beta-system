<H1> The BetaDBC Interface</H1>
<P> The BetaDBC interface is built around the concept of a connection that models a connection to a relational DBMS. The BetaDBC interface to a connection is (see below for the full interface):</P>
<BETA>
Connection: (*)
  (#
     <<SLOT ConnectionLib:Attributes>>;
     declareVar: (*) ...;
     declareInteger: (*) declareVar ...;
     declareReal: (*) declareVar ...;
     declareText: (*) declareVar ...;
     declareBoolean: (*) declareVar ...;
     declareTime: (*) declareVar ...;
     declareDate: (*) declareTime ...;
     declareClock: (*) declareTime ...;
     formatTime:< (*) ...;
     formatDate:< (*) ...;
     formatClock:< (*) ...;
     SQLStatement: (*) ...;
     directSQLStatement: (*) SQLStatement ...;
     preparedSQLStatement: (*) directSQLStatement ...;
     resultSet: (*) ...;
     open:< (*) ...;
     close:< ...;
     connectionException:< BetaDBCException ...;
     connectionNotification:< BetaDBCNotification ...;
     private: @<<SLOT ConnectionPrivate:Descriptor>>
  #)
</BETA>

<H2> Data Sources</H2>
<P> In order to use a connection a data source must be created (See the tutorial for specifics.). To communicate with an existing data source the user must first create an instance of the connection pattern. Calling the open method on a connection:</P>
<BETA>
open:< (*)
  (# name: ^text;
     userName: ^text;
     password: ^text;
     openConnectionException:< BetaDBCException (#  do INNER #);
     openConnectionNotification:< BetaDBCNotification (#  do INNER #)
  enter (name[],userName[],password[])
  <<SLOT ConnectionOpen:DoPart>>
  #);
</BETA>
<P> then makes it possible to communicate with the data source. When calling open the name of the data source must be supplied whereas user name and/or password may be omitted as appropriate. Consider as an example the statement</P>
<BETA>
('ullman97','marius',none)->sqlCon.open
</BETA>
<P> The statement opens a connection to the data source name &quot;ullman97&quot; for the user &quot;marius&quot; without specifying a password.</P>

<H2> Shared Variables</H2>
<P> Definition of shared variables are done via the &quot;declare...&quot; methods. To e.g. declare a text studioName as a shared variable named &quot;studioName&quot; use</P>
<P> </P>
<BETA>
studioName: @text;

...

do 'studioName'->declareText
   (# set::(# do value->studioName #);
      get::(# do studioName[]->value[] #)
   #)
</BETA>

<H2> SQL Statements</H2>
<P> Data manipulation and definition is done using the SQL statement patterns. The SQL statement patterns have the following interfaces:</P>
<BETA>
SQLStatement:(*)
  (# <<SLOT SQLStatementLib:Attributes>>;
     cursorType:<(*) ...;
     resultSetType:<(*) ...;
     execute:<(*) ...;
     open:(*) ...;
     close:(*) ...;
     SQLStatementException:< BetaDBCException ...;
     SQLStatementNotification:< BetaDBCNotification ...;
     get:< ...;
     set:< ...;
     private: @<<SLOT SQLStatementPrivate:Descriptor>>;
  enter set
  do INNER
  exit get
  #);

directSQLStatement:(*) SQLStatement
  (# <<SLOT DirectSQLStatementLib:Attributes>>;
     currentMarker:(*) @ ...;
     marker:(*) ...;
     b: (*) marker ...;
     c: (*) marker ...;
     d: (*) marker ...;
     f: (*) marker ...;
     i: (*) marker ...;
     s: (*) marker ...;
     t: (*) marker ...;
     setByName: (*) ...;
     setBooleanByName: (*) ...;
     setClockByName: (*) ...;
     setDateByName: (*) ...;
     setFloatByName: (*) ...;
     setIntegerByName: (*) ...;
     setTextByName: (*) ...;
     setTimeByName: (*) ...;
     execute::  ...;
     execDirectException:< BetaDBCException ...;
     execDirectNotification:< BetaDBCNotification ...;
     set::<  ...;
     getExpanded:(*) ...;
     private: @&ltc;<SLOT DirectSQLStatementPrivate:Descriptor>>;
  do INNER
  #);

preparedSQLStatement:(*)
  (# ... #)
</BETA>
<P> To use a statement stmt, one must first open it and then associate it with an SQL statement as in</P>
<BETA>
stmt.open;
'SELECT title, length FROM Movie WHERE studioName = \'Disney\''->stmt
</BETA>
<P> Invoking execute on stmt will then cause the SQL statement to be executed at the database. A statement should be closed after use.</P>
<P> A preparedSQLStatement differs from a directSQLStatement in that a prepared statement is parsed and prepared by the data source when the statement is initialised, i.e. executing</P>
<P> the statement above will, if stmt is a preparedSQLStatement, cause the contents of the SQL statement to be sent to the database in order for it to be parsed and prepared for future execution. If stmt is a directSQLStatement no communication with the database will occur before calling execute.</P>
<P> In this way a prepared SQL statement is a little slower to initialise than a direct SQL statement but much faster to execute. Use a preparedSQLStatement only when an SQL statement has to be executed several times.<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-1">[1]</A></EM></P>

<P> The contents of a directSQLStatement can be any SQL statement with embedded shared variables and/or markers, i.e. a directSQLStatement stmt may be initialised as in</P>
<BETA>
'SELECT title,length FROM Movie WHERE studioName = :studioName AND year = %i' 
  ->stmt
</BETA>
<P> Here &quot;studioName&quot; is the name of a shared variable declared as shown above. The value of the %i marker may be set using the i pattern in directSQLStatement. Now suppose that the following statements have been executed</P>
<BETA>
 'Disney'->studioName; 1990->stmt.i
</BETA>
<P> When executing the SQL statement the SQL contents of the statement will then conceptually be</P>
<BETA>
SELECT title,length FROM Movie WHERE studioName = 'Disney' AND year = 1990 
</BETA>
<P> i.e., before sending an SQL statement to a database the embedded shared variables and the markers are, conceptually, substituted for their current values. After execution the contents of the statement can be changed, the markers can be reset or the statement can be closed.</P>

Also, embedded shared variables and markers can be named as in

<BETA>
'SELECT title,length FROM Movie WHERE studioName = :studioName AND year = theYear%i' 
  ->stmt
</BETA>

In this case, the %i marker is named "theYear" and the statement may be used as

<BETA>
'Disney'->studioName; ('theYear',1990)->stmt.setIntegerByName
</BETA>



<P> A preparedSQLStatement is used similarly to a directSQLStatement.</P>

<H2> Results</H2>
<P> Executing an SQL statement stmt will yield an instance of resultSet (here rs is a reference to a resultSet):</P>
<BETA>
rs: ^connection.resultSet

...

do stmt.execute->rs[]
</BETA>
<P> A resultSet implements an interface to the result of an SQL query in the following way</P>
<BETA>
resultSet:(*)
  (# <<SLOT ResultSetLib:Attributes>>;
     columnCount:(*) integerValue ...;
     rowCount:(*) integerValue ...;
     column: (*)...;
     getColumn: (*)...;
     getColumnByName:(*) ...;
     cursorName:(*) ...;
     tuple:(*)
       (# <<SLOT ResultLib:Attributes>>;
          marker:(*) ...;
          b: marker ...;
          c: marker ...;
          d: marker ...;
          f: marker ...;
          i: marker ...;
          s: marker ...;
          t: marker ...;
          private: @...
       #);
     EOT: (*) ...;
     set:(*)
       (# varNotDeclared:<(*) exception ...;
          columnNotFound:<(*) exception ...;
          pattern: ^text
       #);
     fetch:(*) ...;
     scan:(*)
       (# current: ^tuple;
          varNotDeclared:<(*) exception ...;
          columnNotFound:<(*) exception ...;
          pattern: ^text
       enter pattern[]
       ...
       #);
     resultSetException:< BetaDBCException ...;
     resultSetNotification:< BetaDBCNotification ...;
     private: @...
  #)
</BETA>
<P> Given a resultSet, the scan method iterates over the tuples in the resultSet. There are three distinct ways to control the scan. First, one may simply execute</P>
<BETA>
rs.scan(# ... #)
</BETA>
<P> In the do-part of the scan one may then refer to the values of the columns in the result. This is done sequentially by referring to the markers of the current result.  If, e.g., rs was retrieved as shown above,</P>
<BETA>
rs.scan(# do current.s -> putline; current.i->putint; newline #)
</BETA>
<P> will scan over the results in the resultSet and print the values of their columns on the screen.</P>
<P> Second, one may enter a string when evaluating a scan pattern as in:</P>
<BETA>
':title %i'->rs.scan(# do title->putline; current.i->putint; newline #)
</BETA>
<P> Here title is a shared variable named &quot;title&quot;. This statement prints the same as above but by providing an input string it is here specified that the first column of each result should be assigned to the shared variable &quot;title&quot; and that the second column of each result is an integer that will be fetched via the i marker. In general one may in this way specify how each column of a result should be treated.</P>
<P> The two ways of scanning shown above may, in some circumstances, be problematic in that they assume a specific ordering of columns in the results. Therefore, the third way of doing a scan names the columns in the resultSet, as in e.g.:</P>
<BETA>
'length%i title:title'->rs.scan
   (# do title->putline; current.i->putint; newline #)
</BETA>
<P> In this way the order of the columns in the result may be changed from &quot;title, length&quot; to &quot;length, title&quot; without any problems for the last way of scanning.</P>

Results can also be fetched one at a time by using "fetch" instead of "scan". This is, e.g., useful for interleaving the processing of two result sets. For each result set there is a pointer pointing to a current result. If rs is is a resultSet and current is a result,

<BETA>
rs.fetch -> current[]
</BETA>

will fetch the current result and advance the pointer. "current" may be used as shown above.







<HR>

<A NAME=FOOTNOTE-1>[1] </A>
 Note that, currently, a preparedSQLStatement is implemented as a directSQLStatement.







