<H1> Tutorial</H1>
<P> The sample programs shown in the tutorial may be found in the tutorial directory accompanying BetaDBC. The examples use a database schema and examples from [Ullman 97]. It supposes that the reader is familiar with basic SQL and focuses on teaching the essentials of using BetaDBC. All examples take (up to) three command line arguments: a data source, a user name, and a password. If the data source used permits, the user name and/or password may be omitted.</P>

<H2> Creating a Data Source</H2>
<P> In order to use BetaDBC a suitable data source must be created. Currently, data sources are created outside BetaDBC. Different procedures must be followed depending on the operating system used. This will be changed in a future release of BetaDBC.</P>

<H2> Creating a Data Source on Windows 95 and NT</H2>
<P> In the 'Start' menu choose 'Settings' and 'Control Panel'. Start the ODBC (32 Bit) application from the 'Control Panel'. Press 'Add...' and choose the database driver that you want to use, then press 'Finish'. Follow the driver specific instructions.</P>

<H2> Creating a Data Source on Unix</H2>

<P> You will need a .odbc.ini file in your home directory. Create such a file if it does not exist. </P>
<P> Suppose a driver for the PostgreSQL database is located in &quot;/usr/local/lib/libcliPG.so&quot;.  If you want to connect to the database &quot;marius&quot; on the database server &quot;delirium&quot; insert the following in your .odbc.ini file ('ReadOnly = 0' tells the driver that you want to manipulate the &quot;marius&quot; database)</P>
<P> </P>
<BETA>
[ullman97]
# data source containing the 'marius' db on delirium
# this database contains the movie tables from ullman97
Driver = /usr/local/lib/libcliPG.so 
Database = marius
Servername = delirium
ReadOnly = 0
</BETA>
<P> </P>
<P> This defines a data source named &quot;ullman97&quot;, that you may use BetaDBC to connect to. Each data source at least specifies which ODBC. In the example &quot;ReadOnly&quot; is a driver specific attribute of the data source &quot;ullman97&quot;. See the documentation for the drivers used for definitions of driver specific attributes.</P>
<P> </P>
<P> In the following it is assumed that a suitable data source named &quot;ullman97&quot; has been created.</P>

<H2> Creating a Database</H2>
<P> Check this section with the new setup</P>
<P> The next step will then be to create and insert values into a database. Let's use the following sample database schema</P>
<BETA>
Movie (title, year, length, inColor, studioName, producerCNo)
StarsIn (movieTitle, movieYear, starName)
MovieStar (name, address, gender, birthdate)
MovieExec (name, address, certNo, netWorth)
Studio (name, address, presCNo)
</BETA>
<P> A series of SQL statements creating the database schema may be found in createmoviedbtables.txt. The text files used in this section are shown in section 6. </P>
<P> Create the tables corresponding to this schema by running the executesqlfile program also found in the tutorials directory:</P>
<BETA>
[postgres@delirium tutorial]$ ./executesqlfile createmovie.txt ullman97 marius
</BETA>
<P> How the executesqlfile program is implemented will be discussed later. You may now insert some values in the database by running</P>
<BETA>
[postgres@delirium tutorial]$ ./executesqlfile moviedbtables.txt ullman97 marius
</BETA>
<P> The tables may later be deleted by running</P>
<BETA>
[postgres@delirium tutorial]$ ./executesqlfile dropmovies.txt ullman97 marius
</BETA>

<H2> Querying and Retrieving from the Database</H2>
<P> This section will introduce the basics of BetaDBC: connecting to data sources, executing simple queries and retrieving the results.</P>
<P> Consider the simple SQL statement</P>
<BETA>
SELECT * 
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
</BETA>
<P> An application that uses BetaDBC, executes the above query and retrieves the result may look like:</P>
<BETA>
ORIGIN '../betadbc';
-- program: Descriptor --
(#
   sqlCon: @connection;
   stmt: @sqlCon.directSqlStatement;
   rs: ^sqlCon.resultSet
do
   (2->arguments,3->arguments,4->arguments)->sqlCon.open;   
   'SELECT title, length FROM Movie WHERE studioName  = \'Disney\' AND year = 1990'
     ->stmt.open;
   stmt.execute->rs[];
   rs.scan
     (# 
     do
        'title: '->puttext;
        current.s->putline;
        'length: '->puttext;
        current.i->putint;
        newline
     #);
   stmt.close
   sqlCon.close
#)
</BETA>
<P> The program starts out by declaring a connection, a directSQLStatement belonging to that connection and a resultSet belonging to that connection. The connection is used in order to connect to a data source in the first line of the program:</P>
<BETA>
(2->arguments,3->arguments,4->arguments)->sqlCon.open;
</BETA>
<P> Connection's open method takes as arguments a name of the connection, a username and a password. Thus an invocation of the program like</P>
<BETA>
[postgres@delirium tutorial]$ ./simple ullman97 marius foobar
</BETA>
<P> means that the first statement will be an attempt to connect the user &quot;marius&quot; with password &quot;foobar&quot; to the data source named &quot;ullman97&quot;. If this succeeds</P>
<BETA>
'SELECT title, length FROM Movie WHERE studioName = ''Disney'' AND year = 1990'
     ->stmt.open;
</BETA>
<P> will open the directSQLStatement &quot;stmt&quot; and set its content to the query we want to execute. Executing the query yields a resultSet holding a cursor for the result</P>
<BETA>
stmt.execute->rs[];
</BETA>
<P> The resultSet may then be scanned. During the scan 'current' will hold a reference to a tuple in the resultSet. The values of this result may then be accessed consecutively by using the marker attributes</P>
<BETA>
 rs.scan
     (# 
     do
        'title: '->puttext;
        current.s->putline;
        'length: '->puttext;
        current.i->putint;
        newline
     #);
</BETA>
<P> </P>
<P> Finally, in order to free resources, the directSQLStatement and the connection are closed.</P>

<H2> Executesqlfile</H2>
<P> The simple scheme presented in the last section can now be used for implementing the executesqlfile program. The executeLoop shows how to reuse an SQLStatement by simply replacing it's textual contents</P>
<BETA>
executeTxt[]->sqlCon.stmt
</BETA>

<H2> Embedded SQL - Using Shared Variables</H2>
<P> Using shared variables makes it possible to use the values of BETA objects in place of a concrete value in SQL statements. Since no preprocessor is used by BetaDBC, it is necessary to declare shared variables imperatively, as in</P>
<BETA>
   sqlCon:@connection
   studioName:@text;
do ...; 
   'studioName'
     ->sqlCon.declareText
       (# set:: (#  do value->studioName #);
          get:: (#  do studioName[]->value[] #)
       #);     
   ...
</BETA>
<P> Here a shared text variable named &quot;studioName&quot; is declared. The set pattern is final bound to describe how the shared variable's value is to be set. get is final bound to describe how the value of the shared variable is to be fetched.</P>
<P> Then, using embedded SQL syntax, one may use shared variables in SQL statements:</P>
<BETA>
   stmt:@sqlCon.directSQLStatement;
do ...;
   'INSERT INTO Studio(name, address) VALUES (:studioName, :studioAddr)'
     ->stmt.open;
   ...
</BETA>
<P> This means that when executing stmt, &quot;:studioName&quot; and &quot;:studioAddr&quot; will (conceptually) be replaced by the values of the BETA text variables &quot;studioName&quot; and &quot;studioAddr&quot;, and the resulting SQL statement will then be executed.</P>
<P> Using BetaDBC it is possible to declare most commonly used objects as shared variables (i.e., boolean, integer, real, text, date and time). The figure below shows a full program that will execute the statement above. &quot;stmt.getExpanded&quot; returns in a text how the SQL statement would look if it was executed at that point.</P>

<BETA>
ORIGIN '../betadbc';
-- program: Descriptor --
(# sqlCon: @connection;
   stmt: @sqlCon.directSqlStatement;
   studioName,studioAddr: @text
do (2->arguments,3->arguments,4->arguments)->sqlCon.open;
   'studioName'
     ->sqlCon.declareText
       (# set:: (#  do value->studioName #);
          get:: (#  do studioName[]->value[] #)
       #);
   'studioaddr'
     ->sqlCon.declareText
       (# set:: (#  do value->studioAddr #);
          get:: (#  do studioAddr[]->value[] #)
       #);
   'Input a studio name: '->puttext;
   getLine->studioName.puttext;
   ' and address: '->puttext;
   getLine->studioAddr.puttext;
   'INSERT INTO Studio(name, address) VALUES (:studioName, :studioAddr)'
     ->stmt.open;
   stmt.getExpanded->putline;
   stmt.close;
   sqlCon.close
#)
</BETA>


<H2>  Embedded SQL - Fetching Results</H2>

<P> Suppose that we are executing a statement that return a result. Embedded SQL can then also be used to fetch results directly into shared variables. In BetaDBC this is done through the use of the scan pattern. Suppose we are executing</P>
<BETA>
'SELECT MovieExec.name, netWorth FROM Studio, MovieExec 
 WHERE presCNo = certNo AND Studio.name = :studioName'
 
</BETA>
<P> Then, </P>
<BETA>
':presName :presNetWorth'
     ->(stmt.execute).scan(# ... #)
</BETA>
<P> will cause the first column in each result tuple to be assigned to the shared integer variable &quot;presName&quot;, and the second column to &quot;presNetWorth&quot;. The full code is shown below:</P>
<BETA>
ORIGIN '../betadbc';
INCLUDE '~beta/basiclib/formatio';
-- program: Descriptor --
(# sqlCon: @connection;
   stmt: @sqlCon.directSqlStatement;
   studioName,presName: @text;
   presNetWorth: @integer
do 'studioName'
     ->sqlCon.declareText
       (# set::  (#  do value->studioName #);
          get::  (#  do studioName[]->value[] #)
       #);
   'presName'
     ->sqlCon.declareText
       (# set::  (#  do value->presName #);
          get::  (#  do presName[]->value[] #)
       #);
   'presNetWorth'
     ->sqlCon.declareInteger
       (# set::  (#  do value->presNetWorth #);
          get::  (#  do presNetWorth->value #)
       #);
   (2->arguments,3->arguments,4->arguments)->sqlCon.open;
   'Input a studio name: '->puttext;
   getLine->studioName.puttext;
   'SELECT MovieExec.name, netWorth FROM Studio, MovieExec WHERE presCNo = certNo AND Studio.name = :studioName'
     ->stmt.open;
   stmt.getExpanded->putline;
   ':presName :presNetWorth'
     ->(stmt.execute).scan
       (# 
       do 'The net worth of the president %s \nof %s is %i $\n'
            ->putFormat
              (#  do presName[]->s; studioName[]->s; presNetWorth->i #)
       #);
   stmt.close;
   sqlCon.close
#)  
</BETA>

<H2> An Ad-hoc Query Evaluator</H2>
<P> We now have most of the building blocks to create an ad-hoc query evaluator, i.e., a program that connects to a data source and in a loop prompts for SQL statements that are to be executed on this data source. The following implements such a program.</P>
<P> As long as the user inputs anything but an empty line this input is sent to the data source as an SQL statement:</P>
<BETA>
getline->stmt;
(if (stmt).empty then leave L if);
stmt.execute->res[];
</BETA>
<P> If successful, the result is examined. First the column information of the resultSet is extracted:</P>
<BETA>
(for j: res.columnCount repeat
  '%s: %s\t'->putFormat
              (# 
              do (j->res.getColumn).name[]->s;
                 (j->res.getColumn).dataTypeName[]->s
              #)
for);
</BETA>
<P> Each resultSet has a columnCount yielding the number of columns in the resultSet. For each column, information such as name and dataTypeName (a DBMS specific datatype name) may be retrieved. </P>
<P> If the columnCount is non-zero, the results are fetched:</P>
<BETA>
(if res.columnCount > 0 then
    res.scan
      (# 
      do (for i: res.columnCount repeat
              (if (i->res.getColumn).DataType##
               // text## then
                  current.s->puttext
               // integerObject## then
                  current.i->putint
               // realObject## then
                  current.f->putreal
               // booleanObject## then
                  (if current.b then
                      'true'->puttext; 
                   else
                      'false'->puttext
                  if)
               // time## then
                  current.t->puttime
               else
                  'Unknown data type!!!'->puttext
              if);
              '\t'->puttext
         for);
         newline
      #)
   else
      'DML/DDL statement executed successfully!'->putLine
if)
</BETA>
<P> Again the information about columns in the resultSet is used. By evaluating</P>
<BETA>
(i->res.getColumn).DataType##
</BETA>
<P> the BETA pattern corresponding to the SQL datatype in column i is found.</P>





