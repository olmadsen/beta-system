<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Betadbc Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("betadbc");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="betadbc">Betadbc Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/timedate';
BODY 'private/betadbcbody';
-- lib: Attributes --
<B>Connection</B><A name="Connection.1(1)"></A>: (* A connection to a relational DBMS *)
  (#
     &lt;&lt;SLOT ConnectionLib:Attributes&gt;&gt;;
     <B>declareVar</B><A name="Connection.1.declareVar.2(2)"></A><A name="declareVar.2(2)"></A>:
     (* Used to declare a wrapper of a BETA object so that
      * the object may be used in SQLStatements *)
       (#
          &lt;&lt;SLOT DeclareVarLib:Attributes&gt;&gt;;
          varName: ^text;
          set:&lt;
          (* Furtherbind this to set the value of the object that you wrap *)
           object;
          get:&lt;
          (* Furtherbind this to get the value of 
           * the object that you wrap *) object;
          setAsText:&lt;
          (* Furtherbind in concrete subpatterns to set
           * the wrapped object's value to the value 'value' *)
            (# value: ^text
            enter value[]
            ...
            #);
          getAsText:&lt;
          (* Furtherbind in concrete subpatterns to get
           * the wrapped object's value as a text *)
            (# value: ^text
            ...
            exit value[]
            #)
       enter varName[]
       ...
       exit varName[]
       #);
     <B>declareInteger</B><A name="Connection.1.declareInteger.2(3)"></A><A name="declareInteger.2(3)"></A>: (* Declares a wrapper around an integer *) declareVar
       (#
          &lt;&lt;SLOT DeclareIntegerLib:Attributes&gt;&gt;;
          set::&lt; 
            (# value: @integer
            enter value
            ...
            #);
          get::&lt;  (# value: @integer do INNER exit value #);
          setAsText::&lt;  (#  ... #);
          getAsText::&lt; 
            (# 
            ...
            #)
       #);
     <B>declareReal</B><A name="Connection.1.declareReal.2(4)"></A><A name="declareReal.2(4)"></A>: (* Declares a wrapper around a real *) declareVar
       (#
          &lt;&lt;SLOT DeclareRealLib:Attributes&gt;&gt;;
          set::&lt; 
            (# value: @real
            enter value
            do INNER
            #);
          get::&lt; 
            (# value: @real
            do INNER
            exit value
            #);
          setAsText::&lt; 
            (# 
            ...
            #);
          getAsText::&lt;  (#  ... #);
       #);
     <B>declareText</B><A name="Connection.1.declareText.2(5)"></A><A name="declareText.2(5)"></A>:
     (* Declares a wrapper around a text *) declareVar
       (#
          &lt;&lt;SLOT DeclareTextLib:Attributes&gt;&gt;;
          set::&lt; 
            (# value: ^text
            enter value[]
            do INNER
            #);
          get::&lt; 
            (# value: ^text
            do INNER
            exit value[]
            #);
          setAsText::&lt; 
            (# 
            ...
            #);
          getAsText::&lt;  (#  ... #);
       #);
     <B>declareBoolean</B><A name="Connection.1.declareBoolean.2(6)"></A><A name="declareBoolean.2(6)"></A>:
     (* Declares a wrapper around a boolean *) declareVar
       (#
          &lt;&lt;SLOT DeclareBooleanLib:Attributes&gt;&gt;;
          set::&lt; 
            (# value: @boolean
            enter value
            do INNER
            #);
          get::&lt; 
            (# value: @boolean
            do INNER
            exit value
            #);
          setAsText::&lt; 
            (# 
            ...
            #);
          getAsText::&lt;  (#  ... #);
       #);
     <B>declareTime</B><A name="Connection.1.declareTime.2(7)"></A><A name="declareTime.2(7)"></A>: (* Declares a wrapper around a 'time' *) declareVar
       (#
          &lt;&lt;SLOT DeclareTimeLib:Attributes&gt;&gt;;
          set::&lt; 
            (# value: @time
            enter value
            do INNER
            #);
          get::&lt; 
            (# value: @time
            do INNER
            exit value
            #);
          setAsText::&lt; 
            (# 
            ...
            #);
          getAsText::&lt;  (#  ... #);
       #);
     <B>declareDate</B><A name="Connection.1.declareDate.2(8)"></A><A name="declareDate.2(8)"></A>:
     (* Declares a wrapper around a 'date'. Only the year, month and day 
      * attributes of the time value object are taken into account
      *) declareTime (# &lt;&lt;SLOT DeclareDateLib:Attributes&gt;&gt; #);
     <B>declareClock</B><A name="Connection.1.declareClock.2(9)"></A><A name="declareClock.2(9)"></A>:
     (* Declares a wrapper around a 'time'. Only the hour, minute and sec 
      * attributes of the time value object are taken into account *)
      declareTime (# &lt;&lt;SLOT DeclareClockLib:Attributes&gt;&gt; #);
     <B>formatTime</B><A name="Connection.1.formatTime.2(10)"></A><A name="formatTime.2(10)"></A>:&lt;
     (* Called by BetaDBC to format 'time' values
      * Furtherbind this if a date format other than 
      * 'YYYY-MM-DD HH:MM:SS' is needed *)
       (# t: @time; value: ^text
       enter t
       ...
       exit value[]
       #);
     <B>formatDate</B><A name="Connection.1.formatDate.2(11)"></A><A name="formatDate.2(11)"></A>:&lt;
     (* Called by BetaDBC to format 'date' values
      * Furtherbind this if a date format other than 
      * 'YYYY-MM-DD' is needed *)
       (# d: @time; value: ^text
       enter d
       ...
       exit value[]
       #);
     <B>formatClock</B><A name="Connection.1.formatClock.2(12)"></A><A name="formatClock.2(12)"></A>:&lt;
     (* Called by BetaDBC to format 'clock' values
      * Furtherbind this if a clock format other than 
      * 'HH:MM:SS' is needed *)
       (# c: @time; value: ^text
       enter c
       ...
       exit value[]
       #);
     <B>SQLStatement</B><A name="Connection.1.SQLStatement.2(13)"></A><A name="SQLStatement.2(13)"></A>:
     (* The abstract superpattern for all SQL statements.
      * To use an instance of a subclass of SQLStatement:
      *    1. Open the statement by calling 'open',
      *      1a. specifying an enter parameter to, or
      *      1b. setting the statement's SQL contents by evaluating the enter part.
      *    2. Call 'execute'. 
      *    3. Go to 1b., if necessary
      *    4. Call 'close'
      *)
       (#
          &lt;&lt;SLOT SQLStatementLib:Attributes&gt;&gt;;
          cursorType:&lt;
          (* The type of cursor that is created when 
           * an SQLStatement is executed *)
            (#
               insensitive:&lt;
               (* Should be furtherbound to set value to 'true'  
                * if the cursor should be insensitive to concurrent changes *)
                booleanValue;
               readOnly:&lt;
               (* Furtherbind to to set value to 'false' if modification by cursor is needed *)
               booleanValue (#  do true-&gt;value; INNER #);
               scrollable:&lt;
               (*
                Furtherbind this if the resulting resultSet should be scrollable
                
                *) booleanValue;
               name:&lt;
               (* Furtherbind this to set the name of the cursor.                
                If setName is not furtherbound a default name will be generated. *)
               (# value: ^text do INNER exit value[] #)
            #);
          resultSetType:&lt;
          (* The type of resultSet that will be opened
           * when executing this(SQLStatement) *) resultSet;
          execute:&lt; (* Executes this(SQLStatement) *)
            (# res: ^resultSetType
            ...
            exit res[]
            #);
          open:
          (* Opens this(SQLStatement).
           * An SQLStatement must be opened before use *)
            (# value: ^text
            enter value[]
            ...
            #);
          close:
          (* Closes this(SQLStatement). 
           * Call close when done with this(SQLStatement) *)
            (#  ... #);
          SQLStatementException:&lt;
           BetaDBCException (# do INNER #);
          SQLStatementNotification:&lt; BetaDBCNotification (# do INNER #);
          get:&lt; (# t: ^text ... exit t[] #);
          set:&lt;
            (# t: ^text
            enter t[]
            ...
            #);
          private: @...
       enter set
       do INNER
       exit get
       #);
     <B>directSQLStatement</B><A name="Connection.1.directSQLStatement.2(14)"></A><A name="directSQLStatement.2(14)"></A>:
     (* Use this statement type if a statement will be executed at most 
      * a few times. The contents may contain variable placeholders in the form
      *    :varname
      * designating that the shared variable named 'varname' 
      * will be bound to that place. In addition, also
      *    %b for booleans
      *    %c for clocks
      *    %d for dates
      *    %f for reals
      *    %i for integers
      *    %s for texts
      *    %t for time
      * may be used when setting the contents of this(directSQLStatement)
      * Furthermore, placeholders may be named as in
      *    aname%f or aname:varname
      * signifying that the value of the %f or :varname placeholder may be set/get
      * by calling setByName/getByName 
      * with "aname" as parameter
      *) SQLStatement
       (#
          &lt;&lt;SLOT DirectSQLStatementLib:Attributes&gt;&gt;;
          currentMarker:
          (* The current marker decides which non-variable placeholder will be set
           * if one of the subpatterns of "marker" is used
           *)
            (#
               set:
                 (# 
                 enter no
                 ...
                 #);
               get:
                 (# 
                 ...
                 exit no
                 #);
               no: @integer
            enter set
            exit get
            #);
          marker:
          (* Abstract superpattern for markers.
           * Advances currentMarker by 1
           *) (# t: ^text ... #);
          b:
          (* Set placeholder number 'currentMarker' 
           * to the boolean 'value' *) marker
            (# value: @boolean
            enter value
            ...
            #);
          c:
          (* Set placeholder number 'currentMarker' 
           * to the clock 'value' *) marker
            (# value: @time
            enter value
            ...
            #);
          d:
          (* Set placeholder number 'currentMarker' 
           * to the date 'value' *) marker
            (# value: @time
            enter value
            ...
            #);
          f:
          (* Set placeholder number 'currentMarker' 
           * to the real 'value' *) marker
            (# value: @real
            enter value
            ...
            #);
          i:
          (* Set placeholder number 'currentMarker' 
           * to the integer 'value' *) marker
            (# value: @integer
            enter value
            ...
            #);
          s:
          (* Set placeholder number 'currentMarker' 
           * to the text 'value' *) marker
            (# value: ^text
            enter value[]
            ...
            #);
          t:
          (* Set placeholder number 'currentMarker' 
           * to the time 'value' *) marker
            (# value: @time
            enter value
            ...
            #);
          setByName:
          (* Abstract superpattern for patterns that
           * sets the value of a named placeholder *)
            (#
               name: ^text;
               t: ^text;
               nameNotFound:&lt; exception
                 (# 
                 ...
                 #)
            enter name[]
            ...
            #);
          setBooleanByName:
          (* Set placeholder named 'name' 
           * to the boolean 'value' *) setByName
            (# value: @boolean
            enter value
            ...
            #);
          setClockByName:
          (* Set placeholder named 'name' 
           * to the clock 'value' *) setByName
            (# value: @time
            enter value
            ...
            #);
          setDateByName:
          (* Set placeholder named 'name'            * to the date 'value' *)
           setByName
            (# value: @time
            enter value
            ...
            #);
          setFloatByName:
          (* Set placeholder named 'name' 
           * to the real 'value' *) setByName
            (# value: @real
            enter value
            ...
            #);
          setIntegerByName:
          (* Set placeholder named 'name' 
           * to the integer 'value' *) setByName
            (# value: @integer
            enter value
            ...
            #);
          setTextByName:
          (* Set placeholder named 'name' 
           * to the text 'value' *) setByName
            (# value: ^text
            enter value[]
            ...
            #);
          setTimeByName:
          (* Set placeholder named 'name' 
           * to the time 'value' *) setByName
            (# value: @time
            enter value
            ...
            #);
          execute:: 
            (# 
            ...
            #);
          execDirectException:&lt; BetaDBCException (# do INNER #);
          execDirectNotification:&lt; BetaDBCNotification (# do INNER #);
          private: @...;
          set::&lt; 
            (#
               varNotDeclared:&lt;
                exception
                 (# name: ^text
                 enter name[]
                 ...
                 #)
            ...
            #);
          getExpanded:
          (* Get the contents of this(directSQLStatement)
           * as it would appear if the statement was executed now *)
            (# value: ^text
            ...
            exit value[]
            #)
       do INNER
       #);
     <B>preparedSQLStatement</B><A name="Connection.1.preparedSQLStatement.2(15)"></A><A name="preparedSQLStatement.2(15)"></A>:
     (* Use this statement type if a statement will be executed multiple 
      * times with different bindings.
      * ONLY IMPLEMENTED AS A DIRECT STATEMENT
      *) directSQLStatement
       (# &lt;&lt;SLOT preparedSQLStatementLib:Attributes&gt;&gt; do INNER #);
     <B>resultSet</B><A name="Connection.1.resultSet.2(16)"></A><A name="resultSet.2(16)"></A>:
     (* A result of an SQLStatement. 
      * If columnCount &lt;&gt; 0 then the resultSet is can be scanned or fetched from.
      * The tuples of a resultSet can be read at most once.
      *)
       (#
          &lt;&lt;SLOT resultSetLib:Attributes&gt;&gt;;
          columnCount:
          (* The number of columns in this(resultSet) *) integerValue
            (#  ... #);
          tupleCount:
          (* If the statement that created this(resultSet) was a
           * 1. INSERT, DELETE or UPDATE statement 
           *     tupleCount yield the number of tuples 
           *     affected by the statement 
           * 2. SELECT statement
           *     tupleCount MAY (i.e. does not in all circumstances) yield 
           *     the number of rows selected 
           *) integerValue (#  ... #);
          column:
          (* A column in this(resultSet) *)
            (#
               name: ^Text;
               no: @Integer;
               dataType:
               (* The BETA pattern corresponding to the SQL datatype 
                * for this column. If the SQL datatype is DATE, TIME or 
                * TIMESTAMP then the corresponding BETA pattern will 
                * be time 
                *) ##Object;
               dataTypeName: (* DBMS specific type name *) ^Text;
               dataTypeNo: (* ODBC specific numbering of SQL datatypes *)
                 @integer;
               nullAble: @Boolean
            #);
          getColumn: (* Gets the column number 'i' in this(resultSet) *)
            (# i: @Integer; res: ^column
            enter i
            ...
            exit res[]
            #);
          getColumnByName:
          (* Gets the column designated by 'name' in this(resultSet) *)
            (#
               name: ^text;
               res: ^column;
               nameNotFound:&lt; exception
                 (#  ... #)
            enter name[]
            ...
            exit res[]
            #);
          cursorName:
          (* Gets the name of the cursor that points to this(resultSet) *)
            (# value: ^text
            ...
            exit value[]
            #);
          tuple:
          (* A row in this(resultSet). If this(resultSet) has been set
           * with a value that contained non-variable placeholders,
           * the values may be retrieved by using the markers below 
           *)
            (#
               &lt;&lt;SLOT ResultLib:Attributes&gt;&gt;;
               marker:
               (* Gets the value of a non-variable placeholder and advances 
                * the placeholder currently referred to 
                *) (#  ... #);
               b: marker
                 (# value: @boolean
                 ...
                 exit value
                 #);
               c: marker
                 (# value: @time
                 ...
                 exit value
                 #);
               d: marker
                 (# value: @time
                 ...
                 exit value
                 #);
               f: marker
                 (# value: @real
                 ...
                 exit value
                 #);
               i: marker
                 (# value: @integer
                 ...
                 exit value
                 #);
               s: marker
                 (# value: ^text
                 ...
                 exit value[]
                 #);
               t: marker
                 (# value: @time
                 ...
                 exit value
                 #);
               private: @...
            #);
          EOT:
          (* If current = EOT then no more tuples are
           * available in this(resultSet) *)
            (# value: ^tuple ... exit value[] #);
          set:
          (* May called before using fetch on this(resultSet)
           * The pattern entered may either 
           * contain
           * 1. Named columns of the form
           *          'name1:var1 name2:%i name3:var2'
           *     which means that the column named 'name1'('name3') 
           *     is bound to the variable named 'var1'('var2') and the 
           *     column named 'name2' may be retrieved from the 
           *     current tuple using the 'i'-marker,
           * or
           * 2. Consecutive columns of the form
           *          ':var1 %i :var2'
           *     which means that the first (third) column in each result 
           *     is bound to the variable named 'var1'('var3') and that 
           *     the value of the second column may be retrieved from the 
           *     current tuple using the 'i'-marker
           *)
            (#
               varNotDeclared:&lt;
               (* Raised if variable used in the entered 
                * pattern was not found *) exception
                 (# name: ^text
                 enter name[]
                 ...
                 #);
               columnNotFound:&lt;
               (* Raised if this is a named scan and 
                * named column was not found *) exception
                 (# name: ^text
                 enter name[]
                 ...
                 #);
               pattern: ^text
            enter pattern[]
            ...
            #);
          fetch:
          (* Get the current tuple of the relation over which the resultSet ranges.
           * If no more tuples exist, 'current' will be EOT 
           * Advance current tuple if possible *)
            (# result: ^tuple
            ...
            exit result[]
            #);
          scan:
          (* Scans over the tuples of this(resultSet) starting from the current tuple.
           * A text pattern may be entered. See 'set' for details.
           *)
            (#
               current: ^tuple;
               varNotDeclared:&lt;
               (* Raised if variable used in the entered 
                * pattern was not found *) exception
                 (# name: ^text
                 enter name[]
                 ...
                 #);
               columnNotFound:&lt;
               (* Raised if this is a named scan and 
                * named column was not found *) exception
                 (# name: ^text
                 enter name[]
                 ...
                 #);
               pattern: ^text
            enter pattern[]
            ...
            #);
          resultSetException:&lt; BetaDBCException (# do INNER #);
          resultSetNotification:&lt; BetaDBCNotification (# do INNER #);
          private: @...
       #);
     <B>open</B><A name="Connection.1.open.2(17)"></A><A name="open.2(17)"></A>:&lt;
     (* Opens this(connection). The name of the connection 
      * to be opened must be supplied. 
      * Supplying userName and/or password is voluntary.
      *)
       (#
          name: ^text;
          userName: ^text;
          password: ^text;
          openConnectionException:&lt; BetaDBCException (# do INNER #);
          openConnectionNotification:&lt; BetaDBCNotification (# do INNER #)
       enter (name[],userName[],password[])
       ...
       #);
     <B>close</B><A name="Connection.1.close.2(18)"></A><A name="close.2(18)"></A>:&lt;
       (#
          closeException:&lt; BetaDBCException
            (# do INNER #);
          closeNotification:&lt; BetaDBCNotification
            (# do INNER #)
       ...
       #);
     <B>connectionException</B><A name="Connection.1.connectionException.2(19)"></A><A name="connectionException.2(19)"></A>:&lt; BetaDBCException (# do INNER #);
     <B>connectionNotification</B><A name="Connection.1.connectionNotification.2(20)"></A><A name="connectionNotification.2(20)"></A>:&lt; BetaDBCNotification (# do INNER #);
     <B>private</B><A name="Connection.1.private.2(21)"></A><A name="private.2(21)"></A>: @...
  #);
<B>BetaDBCException</B><A name="BetaDBCException.1(22)"></A>:
(* Low level interface for catching exceptions.
 * A general exception message is supplied in msg,
 * SQL states and native error codes in SQLState, 
 * NativeError in a comma-separated list.
 *) Exception
  (#
     <B>SQLState</B><A name="BetaDBCException.1.SQLState.2(23)"></A><A name="SQLState.2(23)"></A>: @text;
     <B>NativeError</B><A name="BetaDBCException.1.NativeError.2(24)"></A><A name="NativeError.2(24)"></A>: @text;
     <B>HandleType</B><A name="BetaDBCException.1.HandleType.2(25)"></A><A name="HandleType.2(25)"></A>: @integer;
     <B>Handle</B><A name="BetaDBCException.1.Handle.2(26)"></A><A name="Handle.2(26)"></A>: @integer
  enter (HandleType,Handle)
  ...
  #);
<B>BetaDBCNotification</B><A name="BetaDBCNotification.1(27)"></A>: BetaDBCException
  (#  do true-&gt;continue; INNER #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Betadbc Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
