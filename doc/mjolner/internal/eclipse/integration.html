<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Integration af MjolnerTool i Eclipse Framework</title>
</head>

<body bgcolor="#77A5BB">

<h1 align="center">Integration af MjolnerTool i Eclipse Framework</h1>
<p align="center">Denne side er et arbejdsnotat, der forsøger løbende at sammenfatte resultaterne af
den tekniske undersøgelse af muligheder for at integrere MjølnerTool i
Eclipse.</p>
<p align="center">Hovedkilden til informationer er <a href="http://www.eclipse.org">www.eclipse.org</a>.</p>
<hr>
<h3>Opbygning af Eclipse</h3>
<p>Det centrale i Eclipse er den såkaldte Workbench, som alt andet plugges ind
i. Workbenchen består af views, editorer og perspektiver.</p>
<ul>
  <li>en <i><b>editor</b></i> er et undervindue, som kan bruges til at browse
    eller redigere i en ressource</li>
  <li>et <b><i>view</i></b> er et undervindue, som præsenterer en slags
    overblik over en struktur, f.eks. et treeview over directories eller en
    liste af TODO-opgaver</li>
  <li>et <b><i>perspektiv </i></b>er en konfiguration af views, editorer og hvad
    dermed følger af toolbar-knapper, menu-indgange, osv. F.eks. har Eclipses
    medfølgende Java-development plugin et perspektiv, der tilbyder de mest
    anvendte funktioner i en IDE (et view med Javafiler, en editor, et klasse-
    og metodeview osv.).</li>
</ul>
<p>Ideen er, at basale ting som views og editorer kan udvides og specialiseres i
forskellige plugins, og at disse kan arbejde sammen med hinanden v.h.a. Eclipse
Framework.</p>
<p><img border="0" src="eclipse_opbygning.png" width="720" height="540"></p>
<p>I Eclipse defineres en række <b><i>extension points</i></b>. Plugins kan
lave <b><i>extensions</i></b> til extension points, og de kan også selv
definere nye extension points, som andre plugins så kan lave extensions til.
Extensions, extension points og andre informationer vedrørende interfacet til
en plugin bliver erklæret i dens tilhørende manifest-fil,
&quot;plugin.xml&quot;.</p>
<p>Ved opstart opbygges et registry over tilstedeværende plugins ud fra
manifest-filerne. En plugin
loades dynamisk, dvs. først når der er brug for den. Når plugin'en loades,
bruger den plugin-registryet til at finde ud af hvilke extension points der er
til rådighed og hvilke evt. extensions der måtte være til dens egne extension
points.</p>
<p>Eclipse Workbench er skrevet i Java med henblik på platformsuafhængighed,
og alle plugins skrives i Java. Hvordan integrerer man 10 tons platformsspecifik
betakode i dette?</p>
<p><img border="2" src="books.png" width="64" height="56"> Læs mere i <a href="http://www.eclipse.org/whitepapers/eclipse-overview.pdf">Eclipse
Platform: Technical Overview</a> (pdf)</p>
<h3>Forskellige slags integration</h3>
<p>Eclipse.org angiver 5 forskellige niveauer af integration, fra løs til tæt:</p>
<ol>
  <li><b>Ingen </b>overhovedet. Kort og godt, simpelt og nemt, men også lidt
    kedeligt...!</li>
  <li>Opstarts- eller &quot;<b>Launch</b>&quot;-faciliteter. Dette er måske det
    nemmeste sted at starte, hvis man har en del kode i forvejen: der laves en
    minimal plugin, som er i stand til at launche ens egen applikation, f.eks.
    hvis den tilhørende ressource (såsom .bet-filer) skal editeres.&nbsp;<br>
    <b><i>BEMÆRK</i></b>: eclipse-folkene underforstår, at den eksisterende
    kode er Java-kode. Dette kan så åbnes i et separat vindue.</li>
  <li><b>Data sharing</b>. F.eks. hvis man fra Mjølner ville editere en
    PNG-ressource, kunne man kalde en billedediterings-plugin, eller hvis man
    ville bruge en anden tekst-editor på sin kode, kunne man kalde en anden
    editor-plugin. Dette kræver, at billed- eller tekstdata udveksles mellem de
    to plugins, og dette fastsætter Eclipse nogle standarder for.</li>
  <li><b>API</b>. Data sharing tillader genbrug af tilstand men ikke af
    opførsel. Ved at bruge de API'er, de forskellige plugins hver især stiller
    til rådighed for omverdenen (v.h.a. et Java interface), kan værktøjerne
    udnytte funktioner, som andre allerede har implementeret.</li>
  <li><b>User Interface</b>. En plugin kan interagere med Eclipse og andre
    plugins på UI-niveau ved at tilføje event listeners til hinandens
    UI-komponenter. F.eks. kan man vælge at blive notificeret, når selektionen
    ændres i en Javakode-editor.</li>
</ol>
<p><img border="2" src="books.png" width="64" height="56"> Læs mere i <a href="http://www.eclipsecorner.org/articles/Article-Levels-Of-Integration/Levels%20Of%20Integration.html">Levels of Integration</a></p>
<h3>At integrere ikke-Java kode</h3>
<p><a href="newsgroup.html">MEJ-posting og svar</a> hertil på news.eclipse.org.
Resume heraf:&nbsp;</p>
<ul>
  <li>For non-UI kode kan man bruge JNI til at integrere. Men MjølnerTool har
    jo en hel del user interface.&nbsp;</li>
  <li>På Windows kan man bruge COM eller ActiveX til integration. Men hvad så
    med andre platforme?</li>
  <li>På både Windows og andre platforme kan man bruge native widgets og definere dem i SWT -
    Standard Widget Toolkit, som bruges i Eclipse i stedet for AWT. SWT tillader
    os at definere &quot;wrapper widgets&quot;, som i virkeligheden blot pakker
    en native widget, loadet fra dll, ind.</li>
  <li>Til en hurtig første integration kan kommandolinie-baserede
    legacy-værktøjer kaldes fra en &quot;halvtom&quot; plugin, der blot
    tilbyder GUI og processering af outputtet fra kommandolinie-værktøjerne.</li>
</ul>
<p>Ide: kan det lade sig gøre at pakke MjølnerTool ind som &quot;verdens
største native widget&quot;?</p>
<p><img border="0" src="MjolnerWidgetUsingJNI.png" width="720" height="540"></p>
<p><img border="2" src="books.png" width="64" height="56">  Læs mere i <a href="http://www.eclipsecorner.org/articles/Article-Writing%20Your%20Own%20Widget/Writing%20Your%20Own%20Widget.htm">Creating
Your Own Widgets using SWT</a></p>
<p><a href="http://www.javareference.com/articles/current/Swt-JFace.html">Artikel
hos Javareference.com om SWT og JFace vs. AWK m.m.</a>  (uafhængig, positiv
kommentar til Eclipses valg af SWT og JFace)</p>
<h3>Udenom C-laget</h3>
<p>Kan man slippe uden om at skrive en wrapper i C? På nuværende tidspunkt kan
Beta ikke compilere DLL'er, men hvis MjolnerTools forskellige dele kunne
compileres til en DLL eller til en samling af mindre DLL'er, så kunne filen
MjNativeWidget.c i figuren ovenfor undværes, og interfacet til Mjolner (som så
kaldes direkte fra JNI) kunne skrives i Beta.</p>
<p>Lad os antage, at hele Mjolner linkes til én stor DLL (eller shared object
library; i det flg. koncentrerer vi os om Windows-dll'er, men det virker
forhåbentlig på samme måde på Unix). MjolnerTools forskellige dele
compileres til mjolner.o, editor.o, freja.o osv., der sammen med betarun.o kan
linkes sammen til en generel mjolner.dll. I forbindelse med Eclipse er vi
ydermere interesseret i at have det Eclipse-specifikke interface til Mjolner,
som ligger i MjolnerWidget.bet, så MjolnerWidget.o skal også linkes sammen med
de andre .o-filer til, lad os kalde det: MjolnerWidget.dll.</p>
<h4>Eksempel: at kalde Debugger</h4>
<p>MjolnerWidget.dll er så det library, som loades og kaldes v.h.a. JNI, og det
indeholder hele Mjolner samt Eclipse's interface til Mjolner (kald det
Mjolner-interfacet). Når Eclipse-brugeren starter beta-debuggeren, kaldes en
funktion StartDebugger i Mjolner-interfacet. I MjolnerWidget.bet kunne den se
således ud:</p>
<p style="background-color: #C0C0C0; border-style: solid; border-width: 1"><font face="Courier New">(*
jint = int32 *)<br>
StartDebugger: External<br>
&nbsp;&nbsp;&nbsp; (# name: [0]@char;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid: @int32 (* jint *)<br>
&nbsp;&nbsp;&nbsp;&nbsp; enter name<br>
&nbsp;&nbsp;&nbsp;&nbsp; do cExternalEntry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... [dopart-ting]<br>
&nbsp;&nbsp;&nbsp;&nbsp; exit pid<br>
&nbsp;&nbsp;&nbsp; #);</font></p>
<p>Udfordringen på Beta-siden bliver at sætte dette rigtigt sammen til
MjolnerWidget.dll, så der heri bliver skabt:</p>
<ul>
  <li>et entrypoint __StartDebugger (som JNI kan kalde), svarende til patternet
    StartDebugger i kassen ovenfor</li>
  <li>et entrypoint M11MJOLNERWIDGET el.lign., svarende til [dopart-ting] i
    kassen ovenfor</li>
</ul>
<p>Her skal tungen holdes lige i munden med mapning af JNI-typer til Beta-typer,
f.eks. 'jint' til 'int32' i eksemplet. Betarun's rolle bliver at bidrage en
overordnet initialisering af runtime-systemet i form af det almindelige
dll-entrypoint DllMain(...). Heri sker så de sædvanlige procedurer fra
Betarun: kald af initialize, kald af betarun, som igen kalder Program.</p>
<p><img border="2" src="books.png" width="64" height="56">  <a href="http://www.cs.au.dk/~datpete/dll.html">PA's
links til DLL-informationer</a></p>
<h3>JNI - Java Native Interface</h3>
<p>JNI loader native code i samme proces som JVM'en og resten af Java-programmet
(Eclipse). Dette kræver overvejelser ang. hvordan Betarun skal opføre sig,
hvis man loader flere instanser af MjolnerTool - hvis man overhovedet skal kunne
dette.</p>
<p>&nbsp;</p>

<p><img border="2" src="books.png" width="64" height="56"> Se den til formålet
indkøbte bog af Sheng Liang: <i>&quot;The Java Native Interface. Programmer's
Guide and Specification&quot;</i> i Mjølners bibliotek.</p>

</body>

</html>
