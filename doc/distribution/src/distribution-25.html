<H1> Tracing object serializations</H1>

<P> When performing a remote invocation, one or more objects are serialized to be sent across the network connection. In some cases, large object graphs are serialized this way. Currently there is no way to specify a limitation on the serialization traversal (as is possible in the persistent store), and sometimes more objects than expected gets serialized, leading to unexpected errors. Most often the error message resulting is 'components not handled', that is triggered when trying to pack an active object (i.e. a component). A number of shellEnv attributes support the debugging of problems like these. These attributes are described below.</P>
<P> Serialization tracing is initiated by setting the TraceSer boolean to TRUE. When this has been done, the BeforeSer, AfterSer and AfterUnser virtuals are called as described below:</P>
<UL>
<LI>BeforeSer <A NAME=MARKER-2-63></A>is called just before an object is about to be serialized, either as a result of being sent in a remote request, or as a result of being returned as a result parameter. The object about to be serialized is given as parameter.
<LI>AfterSer <A NAME=MARKER-2-64></A>is called when the object has been serialized.
<LI>AfterUnser <A NAME=MARKER-2-65></A>is called when some object received, either as part of an incoming call, or as part of a the result received, has been unserialized.
<LI>Remoteable <A NAME=MARKER-2-66></A>instances are not actually serialized. Instead a network representation of the corresponding object reference is sent. In case of a non-remoteable, the object is serialized and all references it contains followed.
</UL>
<P> By further binding these virtuals, it is possible to trace what objects are serialized in remote calls. A simple dump of an object may be achieved using the printObject method found in ~beta/sysutils/objinterface.bet.</P>





