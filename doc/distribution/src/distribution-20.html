<H2> The <INX>errorHandler</INX>pattern</H2>
<P> The errorHandler supports flexible handling of network related errors. An errorHandler effectively defines a dynamic scope in which network errors may be caught and handled.</P>


<P> A dynamic chain of error handlers is maintained for each systemenv system coroutine (see <A HREF="../bibliography/index.html#mia90-08">[MIA 90-08]</A>). On entry to an errorHandler, default is to push the handler entered onto the front of the dynamic chain of error handlers related to the current system, thereby making it the active errorHandler. Likewise, when the errorHandler is left, it is removed from the dynamic chain of error handlers, and the previously active errorHandler becomes active again.</P>

<P> When a network related error occurs, a corresponding exception is raised in the active errorHandler. If the active error handler does not further bind the exception raised, the exception is automatically propagated to the previous handler in the dynamic chain.  The propagation of an exception continues until either some handler catches the exception (by further binding the corresponding errorHandler virtual), or until the end of the dynamic chain is reached. If that happens, the exception is propagated to the globalHandler. If even the globalHandler does not catch the error, default action is to kill the current shell. If an error occurs in a coroutine that never entered an errorHandler, the corresponding exception is raised directly in the globalHandler.</P>
<P> Note that by default each system coroutine has its own dynamic error handler chain. If the top of this chain is reached, control is passed to the globalHandler, and not, for example, to the handler chain of the system that forked the failing coroutine. </P>

<P> As described above, default is to push a newly entered errorHandler onto the currently active chain of error handlers. This means that exceptions not handled by some errorHandler eh are automatically propagated to the errorHandler that was active before entry to eh and, if eh was the first errorHandler entered by the current system coroutine, errors not handled by eh are propagated to the global handler. However, this default may be changed by supplying an errorHandler (prevHandler) as enter parameter when entering a new errorHandler eh. This way, exceptions not handled by eh will be propagated to prevHandler. As an example, this may be used to transfer errors automatically from a coroutine to the creator of that coroutine.</P>

<P> The <INX>error</INX>pattern is an abstract super pattern for all communication exception virtuals. The virtual subpatterns of error thus correspond to different kinds of network errors, as described in the next section.</P>

<H3> Error types</H3>
<P> The network errors handled by the subpatterns of error inside errorHandler are the following.</P>
<UL>
<LI><INX>connectionFailed</INX>is raised when a message send fails.
<LI><INX>connectionBroken</INX>is raised when message send succeded, but the connection to the remote shell was broken before an answer could be received.
<LI><INX>timeOut</INX>is raised if the remote shell failed to answer within the time limit specified by timeOutValue in the active errorHandler. Default timeOutValue is to wait for ever, specified by a timeOutValue of -1. Further bind timeOutValue to limit the allowed waiting time. timeOut is also raised if a createShell request did not finish within the time limit specified by timeOutValue.
<LI><INX>serverOverload</INX>is raised if the remote shell was busy and therefore refused to handle the request. The number of concurrently allowed requests is set by concurrentRequestLimit in globalHandler of the remote shell.
<LI><INX>unknownObject</INX>is raised if the remote shell did not know the object requested. This is a consequence of the remote shell doing a withDraw on the object requested. Thus unknownObject corresponds to the detection of a distributed dangling reference.
<LI><INX>unknownPattern</INX>is raised if one of the patterns needed to unpack objects was not present in the local or in the remote shell. If unknownPattern.local is FALSE, some pattern needed to unpack the request was missing in the remote shell. This means that the request has not been executed. If unknownPattern.local is TRUE, some pattern needed to unpack the answer was missing in the local shell, and thus the request has actually been executed in the server shell.
<LI><INX>wrongAnswer</INX>is raised if the answer from the remote shell did not have the expected format. This could mean that the remote shell is not the one we think it is, i.e. it could be another process at the same port.
</UL>

<H3> Error handling</H3>



<P> To handle network errors, further bind the corresponding error virtual as listed above. Within further bindings, one of the patterns ignore, continue or abort should be called as the last action. Note that if there are imperatives following the call to e.g. continue, they will not be executed! ignore, continue and abort are described below.</P>
<UL>
<LI><INX>abort</INX>: is default if the further binding of some error does not call either ignore, continue or abort. If abort is called and not further specified, the remote call that failed is aborted, and the shell killed. However, to prevent the calling shell from being killed, abort can be further specified. In the further specification, it is allowed to do a leave in the dopart. For example:
</UL>
<BETA>
do myLabel: errorHandler
     (# connectionFailed:: 
          (# 
          do abort (# do leave myLabel #)
          #);
     do server.op1; ...; server.opn;
     #);
</BETA>
<UL>
<LI> To ensure proper clean up, it is not allowed to leave the dopart of an error virtual outside the scope of an abort.
<LI> That is, the following code is not allowed. In the worst case it may lead to segmentation faults. In the best case, a number of communication resources may not be released properly.
</UL>
<BETA>
do myLabel: errorHandler
     (# connectionFailed:: 
          (# 
          do leave myLabel
          #);
     do server.op1; ...; server.opn;
     #);
</BETA>
<UL>
<LI><INX>ignore</INX>: Terminates the failing remote call, but pretends as if the remote call succeded. Control flow continues after the remote call causing the error. For example:
</UL>
<BETA>
do errorHandler
   (# connectionFailed:: (# do ignore #);
   do server1.op1; server2.op2;
   #);
</BETA>
<UL>
<LI> If the server.op1 remote call fails, control flow continues with the server.op2 call. This may of course result in rather strange program behaviour, but is the responsibility of the programmer. It makes no sense to further specify the ignore pattern since it never calls INNER.
<LI><INX>continue</INX>: Depending on the actual exception, retries or continues the operation that caused the error. For example. in the case of a timeOut, continue means that the communication subsystem will wait once again for the number of seconds specified in the timeOutValue virtual in effect. In the case of a connectionFailed, connection is retried. As with ignore, it makes no sense the further bind continue.
</UL>
<P> In order to maintain the errorHandler chain, it is not allowed to leave the dopart of an errorHandler directly. Leaving an errorHandler must be done from inside the dopart of a leaveHandler:</P>
<BETA>
do someLabel: errorHandler
   (#
   do ...;
      leaveHandler (# do leave someLabel #)
   #);
</BETA>
<P> However, from inside the error.abort pattern, the errorHandler currently handling the error may be left directly, as was shown in the abort example above.</P>

<IMG SRC="../images/handright.gif" ALT="Notice!" width=24 height=13 align=left>
<B>Notice</B>: 
It is not allowed to leave the dopart of an errorHandler outside the scope of a leaveHandler.
<BR clear=all>

<P> If multiple errorHandlers are left simultaneously, the <INX>leaveHandler</INX>nested inside the outermost errorHandler in the dynamic call chain must be used. For example:</P>
<BETA>
do e1: errorHandler
   (# leaveFirst: leaveHandler (# do INNER #);
   do e2: errorHandler
      (# leaveSecond: leaveHandler (# do INNER #)
      do e3: errorHandler
         (#
         do leaveFirst (# do leave e1 #);
         #)
      #)
   #);
</BETA>





