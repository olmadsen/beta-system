<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>bidl - Outstanding problems </TITLE>
<LINK REL=stylesheet HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>

<P>
<P>bidl - IDL to BETA Translation</P>
<HR>
<!---------------------------------------------------------->
<H2><A name="todo">Outstanding problems</A></H2>
<OL>

<H3>Important stuff</H3>
<OL type="a">
<LI>We must generate a <CODE>foo.info</CODE> file containing list
of types and imports of <CODE>foo.idl</CODE>. There are two reasons
for this: Firstly it will speed up reading of types from an already 
processed file. Secondly we are <EM>not</EM> allowed to distribute
the IDL files from the Microsoft Windows SDK. But it should be OK
to distribute the <CODE>foo.info</CODE> files.
<LI>In CreateStream in ObjIdl a parameter is declared as 
<CODE>OLECHAR*</CODE>. This is translated into <CODE>^text</CODE>.
This seems wrong. Should be <CODE>^wtext</CODE> instead.
</OL>


<H3>Less Important stuff</H3>

<OL>

<LI>Parsing</LI>
<OL type="a">
<LI>A complete grammar for MIDL (given that MIDL is the IDL variant we
choose)?
<LI>Resolve LALR(1) conflicts in current grammar.
</OL>

<LI>Perhaps handle <CODE>void **</CODE> using the forward decls?

<LI>Exception handling?</LI><BR>
Should we hide the <CODE>HRESULT</CODE>s, and generate BETA
exceptions. Compare with idl2java, which raise standard CORBA
exceptions. 

<LI>Wrapper patterns for propput/propget patterns are incorrectly
generated: The exit parameter should not be the HRESULT of the propget
pattern.

<LI>Possibly put temporary files in current directory instead
of in directory of IDL file - especially if --nocode). This will
prevent many permission problems.

<LI>Many code pieces are replicated more or less around in the code.
Some abstractions would be nice. Especially the (complex) handling of
struct and unions are almost identical (except for the body-part), and
should be abstracted.
But currently struct and unions are two different syntactic categories
which makes abstration less easy. Possibly
<CODE>&lt;struct_type&gt;</CODE> and <CODE>&lt;union_type&gt;</CODE>
in the grammar should be merged into a
<CODE>&lt;struct_or_union_type&gt;</CODE>
(where only the only the body parts is different (via an alternation
rule)). 

<LI>Possibly there may be a problem with too many open files when
handling imports in imports in ...
<BR>
This can be solved by closing files importing file when processing
imported file, and then reopening after imported file has been
processed. The BETA file will have to be reopened using
<CODE>openAppend</CODE>.

<LI>Currently imported files are processed before any processing of
importing file is done. This is not entirely correct, since the types
of the imported file should not be visible in importing file until
after the <CODE>import</CODE> statement. It is, however, harder to
handle type tables correctly when doing on-the-fly importing.

<LI>Property wrappers are not generated correctly. E.g.
<PRE>
[propput] HRESULT length([in] long v);
[propgetHRESULT length([retval, out] long * p);
</PRE>
generates
<PRE>
putlength:<
  (# result: @int32 (* HRESULT *);
     v: @int32 (* long *); 
  enter v
  do INNER;
  exit result
  #);
getlength:<
  (# result: @int32 (* HRESULT *);
     p: ^int32Holder (* long* *); 
  enter p[]
  do INNER;
  exit result
  #);
length: (* property *)
  (# enter putlength exit getlength #);
</PRE>
You can say that <CODE>enter putlength</CODE> is sort of OK (ignoring 
any possible error in the <CODE>HRESULT</CODE>, but
<CODE>exit getlength</CODE> is certainly not what is requested
(it's the <CODE>HRESULT</CODE> that is resturned - not the out parameter).

<LI>Handling of <CODE>void</CODE> types is not properly described.
Currently actually a <EM>parameter</EM> in an <EM>interface</EM>
which is <CODE>void *</CODE> or <CODE>void **</CODE> is translated
to <CODE>^IUnknown</CODE> and <CODE>^IUnknownHolder</CODE>, 
respectively, whereas any <EM>typedef</EM> involving
<CODE>void*</CODE> or <CODE>void**</CODE> will be treated as
<CODE>int32</CODE>. The problem is that <CODE>IUnknown</CODE> is
not known in <CODE>wTypes.Idl</CODE>, where most of the typedefs are.
A somewhat nicer solution could be to introduce a void type in bidl
too (<CODE>type_cat_void</CODE>), and to convert <EM>applications</EM>
of a void type to the <CODE>IUnknown</CODE> types <EM>if
<CODE>IUnknown</CODE> is known at the application-site</EM>, and to
<CODE>int32 if not.</CODE>

<LI>The following internal <CODE>bidl</CODE> patterns are not yet
implemented.
They each correspond to the syntactic category found be stripping
<CODE>do_</CODE> from their names:
<UL>
<LI>do_export_except_dcl 
<LI>do_export_attr_dcl 
<LI>do_raises_expr 
<LI>do_context_expr 
<LI>param_string_type 
<LI>param_type_spec_ref (used in <CODE>ObjIdl.Idl</CODE>!)
<LI>do_export_error 
<LI>do_except_dcl 
<LI>do_module 
<LI>do_definition_error 
<LI>do_type_dcl_error 
</UL>


</OL>
</OL>

<!---------------------------------------------------------->
<HR>
<P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>bidl - IDL to BETA Translation</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>

</BODY>
</HTML>


