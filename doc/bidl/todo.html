<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>bidl - Outstanding problems </TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>

<P>
<A HREF=references.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=typemap.html#interfaces><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<A HREF=contents.html><IMG ALIGN=BOTTOM SRC=../images/content.gif ALT=Contents BORDER=0></A>
<A><IMG ALIGN=BOTTOM SRC=../images/indexg.gif ALT=Index BORDER=0></A>
<P>
<P>bidl - IDL to BETA Translation</P>
<HR>
<!---------------------------------------------------------->
<H2><A name="todo">Outstanding problems</A></H2>
<OL>

<H3>Important stuff</H3>
<OL type="a">
<LI>We must generate a <CODE>foo.info</CODE> file containing list
of types and imports of <CODE>foo.idl</CODE>. There are two reasons
for this: Firstly it will speed up reading of types from an already 
processed file. Secondly we are <EM>not</EM> allowed to distribute
the IDL files from the Microsoft Windows SDK. But it should be OK
to distribute the <CODE>foo.info</CODE> files.
<LI>In CreateStream in ObjIdl a parameter is declared as 
<CODE>OLECHAR*</CODE>. This is translated into <CODE>^text</CODE>.
This seems wrong. Should be <CODE>^wtext</CODE> instead.
</OL>


<H3>Less Important stuff</H3>

<OL>

<LI>Support for all the <CODE>CoXXXX</CODE> functions.

<LI>Text interface<BR>
<OL type="a">
<LI>
Compileren kan i øjeblikket ikke håndtere <CODE>^text</CODE> som
formel parameter til en COM virtuel. Der genereres derfor 
<CODE>[0]@char</CODE> istedet.
<LI>
        Elvis og hardcore siger der er et Istring interface
        Dette bør måske være den form for tekster vi bruger i komponenter
        vi selv implementerer.
<LI>Der er nu lavet et <CODE>BSTR</CODE> pattern, integreret med
pattern <CODE>wtextHolder</CODE>. Et problem eksisterer dog for
<CODE>[in]</CODE> parametre af typen <CODE>BSTR</CODE>. Disse er nødt
til at være erklæret som <CODE>int32</CODE> istedet for
<CODE>BSTR</CODE>, da compilerne ikke accepterer <CODE>BSTR</CODE> som
formel enter parameter.
</OL>

<LI>Call by value of data

<PRE>
foo:< (# r: @myData enter r ....
</PRE>

Now allowed in compiler, but codegeneration is not correct.

<LI>Pointer-to-pointer types in general (can wait)</LI>

<LI>Special types (not needed to get started, though)
<OL type="a">
<LI>sequence
<LI>any (not a MIDL type, though...)
<LI>float
<LI>hyper
<LI>...
</OL>


<LI>Enums cannot be IntegerObjects, since these cannot be parameters
to external functions.

<LI>Parsing</LI>
<OL type="a">
<LI>A complete grammar for MIDL (given that MIDL is the IDL variant we
choose)?
<LI>Resolve LALR(1) conflicts in current grammar.
</OL>

<LI>The current definition of <CODE>HRESULT</CODE> cannot be used for
external parameter in BETA. Thus the representation used for the
HRESULT parameters are currently "int32", and it is up to the user to
convert it to something meaningful using the HRESULT pattern.

<LI>Perhaps handle <CODE>void **</CODE> using the forward decls?

<LI>Exception handling?</LI><BR>
Should we hide the <CODE>HRESULT</CODE>s, and generate BETA
exceptions. Compare with idl2java, which raise standard CORBA
exceptions. 

<LI>in-out VARIANTS<BR>
The current implementation of VARIANT will not work if the VARIANT
is in-out parameter: This allows callee to realloc VARIANT, which
will fail.

<LI>Wrapper patterns for propput/propget patterns are incorrectly
generated: The exit parameter should not be the HRESULT of the propget
pattern.

<LI>Possibly put temporary files in current directory instead
of in directory of IDL file - especially if --nocode). This will
prevent many permission problems.

<LI>Many code pieces are replicated more or less around in the code.
Some abstractions would be nice. Especially the (complex) handling of
struct and unions are almost identical (except for the body-part), and
should be abstracted.
But currently struct and unions are two different syntactic categories
which makes abstration less easy. Possibly
<CODE>&lt;struct_type&gt;</CODE> and <CODE>&lt;union_type&gt;</CODE>
in the grammar should be merged into a
<CODE>&lt;struct_or_union_type&gt;</CODE>
(where only the only the body parts is different (via an alternation
rule)). 

<LI>Possibly there may be a problem with too many open files when
handling imports in imports in ...
<BR>
This can be solved by closing files importing file when processing
imported file, and then reopening after imported file has been
processed. The BETA file will have to be reopened using
<CODE>openAppend</CODE>.

<LI>Currently imported files are processed before any processing of
importing file is done. This is not entirely correct, since the types
of the imported file should not be visible in importing file until
after the <CODE>import</CODE> statement. It is, however, harder to
handle type tables correctly when doing on-the-fly importing.

<LI>Property wrappers are not generated correctly. E.g.
<PRE>
[propput] HRESULT length([in] long v);
[propgetHRESULT length([retval, out] long * p);
</PRE>
generates
<PRE>
putlength:<
  (# result: @int32 (* HRESULT *);
     v: @int32 (* long *); 
  enter v
  do INNER;
  exit result
  #);
getlength:<
  (# result: @int32 (* HRESULT *);
     p: ^int32Holder (* long* *); 
  enter p[]
  do INNER;
  exit result
  #);
length: (* property *)
  (# enter putlength exit getlength #);
</PRE>
You can say that <CODE>enter putlength</CODE> is sort of OK (ignoring 
any possible error in the <CODE>HRESULT</CODE>, but
<CODE>exit getlength</CODE> is certainly not what is requested
(it's the <CODE>HRESULT</CODE> that is resturned - not the out parameter).

<LI>The <CODE>VARIANT</CODE> data type will not work as an in-out or
out parameter, since the data is inlied in the holder.
The solution should probably be something like the solution for
<CODE>GUID</CODE>.

<LI>Handling of <CODE>void</CODE> types is not properly described.
Currently actually a <EM>parameter</EM> in an <EM>interface</EM>
which is <CODE>void *</CODE> or <CODE>void **</CODE> is translated
to <CODE>^IUnknown</CODE> and <CODE>^IUnknownHolder</CODE>, 
respectively, whereas any <EM>typedef</EM> involving
<CODE>void*</CODE> or <CODE>void**</CODE> will be treated as
<CODE>int32</CODE>. The problem is that <CODE>IUnknown</CODE> is
not known in <CODE>wTypes.Idl</CODE>, where most of the typedefs are.
A somewhat nicer solution could be to introduce a void type in bidl
too (<CODE>type_cat_void</CODE>), and to convert <EM>applications</EM>
of a void type to the <CODE>IUnknown</CODE> types <EM>if
<CODE>IUnknown</CODE> is known at the application-site</EM>, and to
<CODE>int32 if not.</CODE>

<LI>The following internal <CODE>bidl</CODE> patterns are not yet
implemented.
They each correspond to the syntactic category found be stripping
<CODE>do_</CODE> from their names:
<UL>
<LI>do_export_except_dcl 
<LI>do_export_attr_dcl 
<LI>do_raises_expr 
<LI>do_context_expr 
<LI>param_string_type 
<LI>param_type_spec_ref (used in <CODE>ObjIdl.Idl</CODE>!)
<LI>do_export_error 
<LI>do_except_dcl 
<LI>do_module 
<LI>do_definition_error 
<LI>do_type_dcl_error 
</UL>


</OL>
</OL>

<!---------------------------------------------------------->
<HR>
<P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>bidl - IDL to BETA Translation</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>

<P>
<A HREF=references.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=typemap.html#interfaces><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<A HREF=contents.html><IMG ALIGN=BOTTOM SRC=../images/content.gif ALT=Contents BORDER=0></A>
<A><IMG ALIGN=BOTTOM SRC=../images/indexg.gif ALT=Index BORDER=0></A>

</BODY>
</HTML>


