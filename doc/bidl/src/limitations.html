<H2><A NAME="limitations">Limitations</A></H2>

<CODE>bidl</CODE> currently have a few limitations of both grammatical
and type-mapping kinds. In the cases where the problem is IDL
constructs,
that cannot be parsed or otherwise accepted by <CODE>bidl</CODE>,
the construct

<PRE>
#ifndef bidl
...
#endif /* bidl */
</PRE>

can be used in the IDL source files, since <CODE>bidl</CODE> defines
the symbol <CODE>bidl</CODE> in the preprocessing stage.
These <CODE>#ifdefs</CODE> can be constructed so that they do not
interfere with e.g. <A HREF="midl">midl</A>.
<P>
The current limitations are:

<OL>
<LI>Cannot handle <CODE>static</CODE> declarations. E.g. 
<PRE>
static unsigned short* MMC_CALLBACK = ((unsigned short *)(-1));
</PRE>
which is found in <CODE>mmc.idl</CODE>. Global data in IDL???
Can be fixed by #ifdef'ing out the declaration. Any possible
references to the symbol will be treated as <CODE>int32</CODE>
by <CODE>bidl</CODE>.

<LI>Cannot handle type casts. E.g. 

<PRE>
[switch_type(DWORD), switch_is((DWORD) tymed)]
</PRE>

which is found in <CODE>ObjIdl.Idl</CODE>. Since there is the
<CODE>switch_type</CODE> attribute, the type cast seems redundant
anyway.
<P>
Can be fixed by commenting out the type cast <CODE>(DWORD)</CODE>. 
It is not used by <CODE>bidl</CODE> anyway.

<LI>Cannot handle unicode string constants
The form
<PRE>
L"Hello, World!"
</PRE>

currently cannot be parsed. The meta programming system does not
support this kind of strings constants, and adding it to the
grammar will make 'L' and 'l' reserved words.
<P>
The fix is to remove the 'L' in the constants - the BETA compiler will
handle it instead.

<LI>Cannot handle constants like <CODE>1L</CODE>
<BR>
Numerical constants with size indicator, like e.g. <CODE>1L</CODE>
cannot be parsed. Fix by removing the <CODE>L</CODE> from the IDL.

<LI>AST overflows may occur<BR>
There is a limit to the size of the IDL files that can be handled,
see <A HREF="astoverflow.html#astoverflow">Handling AST overflows</A>.

<LI>Inlined arrays in structs are translated incorrectly<BR>
The following typedef
<PRE>
typedef struct tagfoo
{
  int  x;
  char y[4];
} foo;
</PRE>

is incorrectly translated to

<PRE>
foo: struct_tagfoo(# #);
struct_tagfoo: DATA
  (# x: @int32 (* int *);
     y: ^charHolder (* char *);
  #);
</PRE>

i.e. the <CODE>y</CODE> member is treated as a pointer
instead of 4 inlined <CODE>char</CODE>s.
</OL>

<!--++++++++++++++++++++++++++++++-->

