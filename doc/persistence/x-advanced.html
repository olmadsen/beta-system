<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<H1> Advanced Features </H1>

The following sections describe some advanced features of using
persistent stores.

<H1> References between different persistent stores</H1>
<P> References between objects saved in different persistent stores are allowed, but  beware that the support for such references is still somewhat experimental and requires special care in order to avoid problems. This section describes how to exploit cross store references<A NAME=MARKER-2-39></A>. The crossstore.bet demo program is an example usage of cross store references. The drawing below illustrates references between objects saved in different persistent stores. In memory, there is no difference between cross store references and other object references. However, on secondary storage these references cross boundaries between persistent object stores.</P>
<P> </P>
<blockquote><IMG ALIGN=TOP width=401 height=277 SRC=crossref.gif></blockquote>
<P> </P>
<A NAME=HEADING14-5></A>
<H1> Where are objects saved?</H1>

<P> When performing a checkpoint<A NAME=MARKER-2-40></A> on a persistent store, either explicitly by calling the checkpoint operation or implicitly by closing the store, the object graphs rooted in the persistent roots of the store are traversed and the objects met saved to the persistent store. However, if an object is met that has already been saved in another persistent store, only the identification of that object is saved, and the graph traversal is not continued in that particular direction. Thus, a checkpoint operation on a persistent store only saves objects already belonging to that store, or objects that do not yet belong to any persistent store at all. The result is that a persistent object is saved in the store that first sees the object during a checkpoint operation.</P>
<P> The description above of course demands that we are able to recognize objects that 'belong to' other persistent stores. However, when a persistent store is closed, objects that belonged to the store before the close operation will, after the close operation, semantically turn into copies of the objects belonging to the store. Thus, in order to maintain references between objects in different persistent stores, it is necessary to make explicit checkpoint operations and avoid the implicit checkpoint done by the close. The latter is done by further binding the doCheckpoint virtual:</P>
<PRE CLASS=beta>
PS.close (# doCheckpoint:: (# do false -&gt; value #)#);
</PRE>
<BLOCKQUOTE>
<P>When exploiting cross store references, avoid the implicit checkpoint operation by furtherbinding the doCheckpoint virtual on close operations. Instead explicit checkpoint operations should be executed on all stores before closing any store.</P>
</BLOCKQUOTE>
<A NAME=HEADING14-11></A>
<H1> Following references between persistent stores</H1>
<P> If a persistent root is fetched whose transitive closure contains references to objects in other persistent stores, these persistent stores must be open in order to fetch the objects referenced. However, if the store referred is not already open, the persistent store containing the reference is not able to open the store automatically since it has no idea whether it should be opened for reading or writing. Instead it calls the persistentstore.openpstore<A NAME=MARKER-2-41></A><A NAME=MARKER-2-42></A> virtual with the full pathname of the store needed, and expects the further binding to open and return the store.</P>

</BODY>
</HTML>
