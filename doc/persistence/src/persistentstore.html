<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<H1>Persistentstore Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface';

-- lib: Attributes --

<B>persistentstore</B><A name="persistentstore.1(1)"></A>:
  (#
     <B>host</B><A name="persistentstore.1:host.2(2)"></A><A name="host.2(2)"></A>,<B> path</B><A name="persistentstore.1:path.2(3)"></A><A name="path.2(3)"></A>: ^text;
     
     <B>numberOfUpdates</B><A name="persistentstore.1:numberOfUpdates.2(4)"></A><A name="numberOfUpdates.2(4)"></A>: 
       (# 
          result: @integer
       do assertOpen(# notOpen :: (# do true -&gt; continue #);
                    do (host,path) -&gt; getNumberOfUpdates -&gt; result
                    #)
       exit result
       #);
     <B>lastupdate</B><A name="persistentstore.1:lastupdate.2(5)"></A><A name="lastupdate.2(5)"></A>: @integer;
     
     <B>hostName</B><A name="persistentstore.1:hostName.2(6)"></A><A name="hostName.2(6)"></A>: (#  exit 'localhost' #);
     <B>rebinderItem</B><A name="persistentstore.1:rebinderItem.2(7)"></A><A name="rebinderItem.2(7)"></A>: ^rebindSpecialReference;
     <B>openCrossStoreItem</B><A name="persistentstore.1:openCrossStoreItem.2(8)"></A><A name="openCrossStoreItem.2(8)"></A>: ^openpstore;
     
     <B>assertOpen</B><A name="persistentstore.1:assertOpen.2(9)"></A><A name="assertOpen.2(9)"></A>:
       (# notOpen:&lt; PSException
            (# 
            do 'persistentstore.assertOpen: Store is not open'
                 -&gt; msg.putText;
               false -&gt; continue;
               INNER;
            #);
       do (if host[] &lt;&gt; none then
              (if path[] &lt;&gt; none then
                  INNER;
               else
                  notOpen;
              if);
           else
              notOpen;
          if);
       #);
     
     <B>assertInit</B><A name="persistentstore.1:assertInit.2(10)"></A><A name="assertInit.2(10)"></A>:
       (# notInitialized:&lt; PSException
            (# 
            do 'persistentstore.assertInitialized: Store is not initialized'
                 -&gt; msg.putText;
               false -&gt; continue;
               INNER;
            #);
       do (if rebinderItem[] &lt;&gt; none then
              (if openCrossStoreItem[] &lt;&gt; none then
                  INNER;
               else
                  notInitialized;
              if);
           else
              notInitialized;
          if);
       #);
     
     <B>markSpecialObject</B><A name="persistentstore.1:markSpecialObject.2(11)"></A><A name="markSpecialObject.2(11)"></A>: external (* defined in P/misc.c *)
       (# tag,theObj: @integer enter (tag,theObj) #);
     <B>putExt</B><A name="persistentstore.1:putExt.2(12)"></A><A name="putExt.2(12)"></A>: external (* defined in P/PStoreServer.c *)
       (#
          dooverwrite: @boolean;
          host,path,name: [1] @Char;
          obj,rcode: @integer
       enter (dooverwrite,host,path,name,obj)
       exit rcode
       #);
     <B>setForceAOAGC</B><A name="persistentstore.1:setForceAOAGC.2(13)"></A><A name="setForceAOAGC.2(13)"></A>: external (* defined in ioa.c *) 
       (#  #);
     <B>forceObjectToAOA</B><A name="persistentstore.1:forceObjectToAOA.2(14)"></A><A name="forceObjectToAOA.2(14)"></A>: external (* defined in P/misc.c *)
       (# theObj: @integer;  enter theObj #);
     <B>getNumberOfUpdates</B><A name="persistentstore.1:getNumberOfUpdates.2(15)"></A><A name="getNumberOfUpdates.2(15)"></A>: external (* defined in P/PStore.c *)
       (# host,path: [1] @Char; numUpdates:@integer
       enter (host,path)
       exit numUpdates
       #);
     <B>openReadExt</B><A name="persistentstore.1:openReadExt.2(16)"></A><A name="openReadExt.2(16)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>openWriteExt</B><A name="persistentstore.1:openWriteExt.2(17)"></A><A name="openWriteExt.2(17)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>createExt</B><A name="persistentstore.1:createExt.2(18)"></A><A name="createExt.2(18)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>closeExt</B><A name="persistentstore.1:closeExt.2(19)"></A><A name="closeExt.2(19)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       #);
     <B>getExt</B><A name="persistentstore.1:getExt.2(20)"></A><A name="getExt.2(20)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path,name: [1] @Char; theObj: @integer
       enter (host,path,name)
       exit theObj
       #);
     
     <B>ACCESSERRORERROR</B><A name="persistentstore.1:ACCESSERRORERROR.2(21)"></A><A name="ACCESSERRORERROR.2(21)"></A>: (#  exit 1 #);
     <B>NOTFOUNDERROR</B><A name="persistentstore.1:NOTFOUNDERROR.2(22)"></A><A name="NOTFOUNDERROR.2(22)"></A>: (#  exit 2 #);
     <B>ALREADYOPENERROR</B><A name="persistentstore.1:ALREADYOPENERROR.2(23)"></A><A name="ALREADYOPENERROR.2(23)"></A>: (#  exit 3 #);
     <B>EXISTSERROR</B><A name="persistentstore.1:EXISTSERROR.2(24)"></A><A name="EXISTSERROR.2(24)"></A>: (#  exit 4 #);
     <B>CREATIONERRORERROR</B><A name="persistentstore.1:CREATIONERRORERROR.2(25)"></A><A name="CREATIONERRORERROR.2(25)"></A>: (#  exit 5 #);
     
     <B>registerRebinderFunc</B><A name="persistentstore.1:registerRebinderFunc.2(26)"></A><A name="registerRebinderFunc.2(26)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callRebinder enter rebinderFunc## #);
     
     <B>registerOpenCrossStoreFunc</B><A name="persistentstore.1:registerOpenCrossStoreFunc.2(27)"></A><A name="registerOpenCrossStoreFunc.2(27)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callOpenCrossStore enter rebinderFunc## #);
     
     <B>registerBETAENVandPROGRAM</B><A name="persistentstore.1:registerBETAENVandPROGRAM.2(28)"></A><A name="registerBETAENVandPROGRAM.2(28)"></A>: external
       (# theProgram:@integer
       enter theProgram
       #);
     
     <B>init</B><A name="persistentstore.1:init.2(29)"></A><A name="init.2(29)"></A>:
       (# 
       do callRebinder## -&gt; registerRebinderFunc;
          &amp;rebindSpecialReference[] -&gt; rebinderItem[];
          callOpenCrossStore## -&gt; registerOpenCrossStoreFunc;
          &amp;openpstore[] -&gt; openCrossStoreItem[];
          (%getLongAt (@@ theProgram))-&gt; registerBETAENVandPROGRAM;
          INNER
       #);
     
     <B>callRebinder</B><A name="persistentstore.1:callRebinder.2(30)"></A><A name="callRebinder.2(30)"></A>: external
       (# objectTag,typeTag: @integer; target: ^Object; targetAbs: @integer
       enter (objectTag,typeTag)
       do CExternalentry;
          (objectTag,typeTag)-&gt;rebinderItem-&gt;target[];
          (%getLongAt (@@ target))-&gt;targetAbs
       exit targetAbs
       #);
     
     <B>callOpenCrossStore</B><A name="persistentstore.1:callOpenCrossStore.2(31)"></A><A name="callOpenCrossStore.2(31)"></A>: external
       (# host, path: [1] @Char; newps: ^persistentstore;
          hostText, pathText: ^text;
          
       enter (host, path)
       do CExternalentry;
          &amp;text[]-&gt; hostText[];
          &amp;text[]-&gt; pathText[];
          
          host -&gt; hostText;
          path -&gt; pathText;
          pathText[] -&gt; openCrossStoreItem -&gt; newps[];
          (* newps is not currently used by the system *)
       #);
     
     <B>UNKNOWNTAG</B><A name="persistentstore.1:UNKNOWNTAG.2(32)"></A><A name="UNKNOWNTAG.2(32)"></A>: (#  exit 0 #);
     <B>rebindSpecialReference</B><A name="persistentstore.1:rebindSpecialReference.2(33)"></A><A name="rebindSpecialReference.2(33)"></A>:&lt;
       (#
          target: ^Object;
          toSpecialObject:&lt;
            (#
               objectTag: @integer;
               NotHandled:&lt; PSException
                 (# 
                 do 'persistentstore.rebindSpecialReference: tag "'
                      -&gt;msg.putText;
                    objectTag-&gt;msg.putInt;
                    '" has not been rebound (returning NULL)'-&gt;msg.putText;
                    msg[]-&gt;putline;
                    true-&gt;continue;
                    INNER
                 #)
            enter objectTag
            do INNER
            #);
          toSpecialType:&lt;(# typeTag: @integer enter typeTag do INNER #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       do (if objectTag &lt;&gt; UNKNOWNTAG then
              objectTag-&gt;toSpecialObject
           else
              (if typeTag &lt;&gt; UNKNOWNTAG then typeTag-&gt;toSpecialType if)
          if);
          (* At this point it is assumed that 'target' now contains the 
           * reference to the object this special reference is 
           * to be rebound to *)
          (if target[] = none then
              PSexception
              (# 
              do 'handleSpecialReference: User code failed to rebind' 
                   -&gt; msg.putLine;
                 'reference to special object tagged '
                   -&gt; msg.putText;
                 objectTag -&gt; msg.putInt;
                 '.' -&gt; msg.putLine;
                 'Make sure the \'rebindSpecialReference\' virtual'           
                   -&gt; msg.putLine;
                 'has been implemented correctly.'
                   -&gt; msg.putLine;
                 false -&gt; continue;
              #)
          if);
       exit target[]
       #);
     <B>commit</B><A name="persistentstore.1:commit.2(34)"></A><A name="commit.2(34)"></A>: assertInit
       (#
          doUpdateInMemoryObjects:&lt; BooleanValue
            (#  do false-&gt;value; INNER #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       do INNER
       #);
     <B>reget</B><A name="persistentstore.1:reget.2(35)"></A><A name="reget.2(35)"></A>: assertInit
       (#
          NotFound:&lt; PSException
            (# 
            do 'persistentstore.reget: Root "'-&gt;msg.putText;
               fullname[]-&gt;msg.putText;
               '" has been overwritten by another client.'-&gt;msg.putText;
               'Your references are not longer valid.'-&gt;msg.puttext;
               msg[]-&gt;putline;
               true-&gt;continue;
               INNER
            #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     
     <B>open</B><A name="persistentstore.1:open.2(36)"></A><A name="open.2(36)"></A>: assertInit
       (#
          alreadyOpenMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          notFoundMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          accessErrorMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          
          alreadyOpen:&lt; PSexception
            (# 
            do alreadyOpenMessage-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               true -&gt; continue;
               INNER
            #);
          notFound:&lt; PSexception
            (# 
            do notFoundMessage-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER
            #);
          accessError:&lt; PSexception
            (# 
            do accessErrorMessage -&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               INNER
            #);
          name: ^Text;
          openFunc:&lt;
            (# host,path: [1] @Char; rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)-&gt;openFunc
               // (NOTFOUNDERROR) then
                  name[]-&gt;notFound
               // (ACCESSERRORERROR) then
                  name[]-&gt;accessError
               else
                  name[]-&gt;path[]; hostName-&gt;host[]; 
                  INNER
              if)
           else
              name[]-&gt;alreadyOpen; 
          if);
       #);
     
     <B>openRead</B><A name="persistentstore.1:openRead.2(37)"></A><A name="openRead.2(37)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openRead: "' -&gt; msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openRead: "'-&gt;msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openRead: No access to "'-&gt;msg[]; #);
          openFunc :: (# do (host, path) -&gt; openReadExt -&gt; rcode #);
       do INNER
       #);
     
     <B>openWrite</B><A name="persistentstore.1:openWrite.2(38)"></A><A name="openWrite.2(38)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openWrite: "' -&gt; msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openWrite: "' -&gt;msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openWrite: No access to"'-&gt;msg[]; #);
          openFunc :: (# do (host, path) -&gt; openWriteExt -&gt; rcode #);
       do INNER
       #);
     
     <B>create</B><A name="persistentstore.1:create.2(39)"></A><A name="create.2(39)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               INNER
            #);
          exists:&lt; PSexception
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already exists'-&gt;msg.putText;
               INNER
            #);
          creationError:&lt; PSexception
            (# 
            do 'persistentstore.create: Failed creating "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER
            #);
          name: ^Text;
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)-&gt;createExt
               // (EXISTSERROR) then
                  name[]-&gt;exists; 
               // (CREATIONERRORERROR) then
                  name[]-&gt;creationError
               else
                  hostName-&gt;host[]; name[]-&gt;path[]; 
              if)
           else
              name[]-&gt;alreadyOpen; 
          if);
          INNER
       #);
     
     <B>checkpoint</B><A name="persistentstore.1:checkpoint.2(40)"></A><A name="checkpoint.2(40)"></A>: assertInit (#  do setForceAOAGC; doGC;  #);
     
     <B>close</B><A name="persistentstore.1:close.2(41)"></A><A name="close.2(41)"></A>: assertInit
       (#
          danglersExists:&lt;
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill-&gt;todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue (#  do false-&gt;value; INNER #);
          
       do INNER;
          checkpoint;
          (host, path) -&gt; closeExt;
          none -&gt;path[];
          none -&gt;host[];
          
       #);
     
     <B>get</B><A name="persistentstore.1:get.2(42)"></A><A name="get.2(42)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (# 
            do 'persistentstore.get: Qua error getting "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER
            #);
          notFound:&lt; Exception
            (# 
            do 'persistentstore.get: "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER
            #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type## )
       do (@@ theObject,((host,path,name)-&gt;getExt))-&gt;assignRef;
          (if theObject[] = none then notFound if);
          INNER
       exit theObject[]
       #);
     <B>ALREADYTHEREERROR</B><A name="persistentstore.1:ALREADYTHEREERROR.2(43)"></A><A name="ALREADYTHEREERROR.2(43)"></A>: (#  exit 6 #);
     <B>HASOVERWRITTENERROR</B><A name="persistentstore.1:HASOVERWRITTENERROR.2(44)"></A><A name="HASOVERWRITTENERROR.2(44)"></A>: (#  exit 7 #);
     <B>put</B><A name="persistentstore.1:put.2(45)"></A><A name="put.2(45)"></A>: assertInit
       (#
          AlreadyThere:&lt; PSexception
            (# 
            do 'persistentstore.put: Root "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               'already there.'-&gt;msg.puttext;
               true-&gt;continue;
               INNER
            #);
          HasOverWritten:&lt; PSexception
            (# 
            do 'persistentstore.put: Root "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               'will overwrite an already existing root with same name at checkpoint time.'
                 -&gt;msg.puttext;
               true-&gt;continue;
               INNER
            #);
          dooverwrite:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       do (%getLongAt (@@ obj))-&gt;forceObjectToAOA;
          doGC;
          (if ((dooverwrite,host,path,name,(%getLongAt (@@ obj)))-&gt;putExt)
           // (ALREADYTHEREERROR) then
              AlreadyThere; (if dooverwrite then HasOverWritten if)
          if);
          INNER
       #);
     <B>scanRootNames</B><A name="persistentstore.1:scanRootNames.2(46)"></A><A name="scanRootNames.2(46)"></A>: assertInit (# current: ^Text;  do INNER #);
     <B>registerSpecialObject</B><A name="persistentstore.1:registerSpecialObject.2(47)"></A><A name="registerSpecialObject.2(47)"></A>: assertInit
       (#
          alreadyThere:&lt; Exception
            (# 
            do 'registerSpecialObject: Special object "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '" already exists: '-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type## )
       do 'registerSpecialObject: Registering of special objects and instances'-&gt; screen.putLine;
          'is implemented differently in the new persistence implementation.'-&gt; screen.putLine;
          'This call has no effect, and should be removed.' -&gt; screen.putLine;
          INNER
       #);
     <B>registerRuntimeType</B><A name="persistentstore.1:registerRuntimeType.2(48)"></A><A name="registerRuntimeType.2(48)"></A>: assertInit
       (# type: ##Object enter type## 
       do 'registerRuntimeType: This function is not implemented in the new'
            -&gt; screen.putLine;
          'persistent store, and the call should be removed.' -&gt; screen.putLine;
          
       #);
     <B>maxCountOnDanglerHit</B><A name="persistentstore.1:maxCountOnDanglerHit.2(50)"></A><A name="maxCountOnDanglerHit.2(50)"></A>:&lt; IntegerValue (#  do 100-&gt;value; INNER #);
     <B>OnDanglerHit</B><A name="persistentstore.1:OnDanglerHit.2(51)"></A><A name="OnDanglerHit.2(51)"></A>:&lt; Object;
     <B>AfterDanglerHit</B><A name="persistentstore.1:AfterDanglerHit.2(52)"></A><A name="AfterDanglerHit.2(52)"></A>:&lt;(# theObject: ^Object;  enter theObject[] do INNER #);
     <B>openpstore</B><A name="persistentstore.1:openpstore.2(53)"></A><A name="openpstore.2(53)"></A>:&lt;
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     <B>deletePersistentStore</B><A name="persistentstore.1:deletePersistentStore.2(54)"></A><A name="deletePersistentStore.2(54)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.delete: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" is currently open'-&gt;msg.putText;
               INNER ;
               
            #);
          accessError:&lt; PSexception
            (# 
            do 'persistetstore.delete: Unable to delete "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER ;
               
            #);
          notFound:&lt; PSexception
            (# 
            do 'persistetstore.delete: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER ;
               
            #);
          name: ^Text;
          storeDir: @directory; 
          
       enter name[]
       do assertOpen
          (# do path[] -&gt; storeDir.name;
             storeDir.delete
             (# 
                nosuch:: (# do PSexception
                            (# do 'delete error: ' -&gt; msg.putText;
                               path[] -&gt; msg.putText;
                               ' does not exist' -&gt; msg.putText;
                               true -&gt; continue;
                            #);
                         #);
                
                error:: (# do PSexception
                           (# do 'delete error: ' -&gt; msg.putText;
                              path[] -&gt; msg.putText;
                              ' could not be deleted (unknown error)' -&gt; msg.putText;
                              true -&gt; continue;
                           #);
                        #);
             #);
          #);
       #);
     <B>registerSpecialInstance</B><A name="persistentstore.1:registerSpecialInstance.2(55)"></A><A name="registerSpecialInstance.2(55)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (# 
            do 'registerSpecialInstance: Qua error on "'-&gt;msg.putText;
               tag-&gt;msg.putInt;
               '" instance'-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          notFound:&lt; Exception
            (# 
            do 'registerSpecialInstance: Special object "'-&gt;msg.putText;
               tag-&gt;msg.putInt;
               '" not registered.'-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
       enter (o[],tag)
       do (if tag &lt; 256 then
              (tag,%getLongAt (@@ o))-&gt;markSpecialObject;
           else
              PSexception
              (# do 'registerSpecialInstance: ' -&gt; msg.putText;
                 ' tag (' -&gt; msg.putText;
                 tag -&gt; msg.putInt;
                 ') must be less than 256' -&gt; msg.putText;
                 false -&gt; continue;
              #);
          if);
       #);
  do INNER ; 
  #);
<B>deletePersistentStore</B><A name="deletePersistentStore.1(56)"></A>:
  (#
     <B>alreadyOpen</B><A name="deletePersistentStore.1:alreadyOpen.2(57)"></A><A name="alreadyOpen.2(57)"></A>:&lt; PSexception(# do INNER #);
     <B>accessError</B><A name="deletePersistentStore.1:accessError.2(58)"></A><A name="accessError.2(58)"></A>:&lt; PSexception(# do INNER #);
     <B>notFound</B><A name="deletePersistentStore.1:notFound.2(59)"></A><A name="notFound.2(59)"></A>:&lt; PSexception(# do INNER #);
     <B>name</B><A name="deletePersistentStore.1:name.2(60)"></A><A name="name.2(60)"></A>: ^Text;
     
  enter name[]
  do PSexception
     (# do 'delete error: deletePersistentStore has been moved' -&gt;msg.putLine;
        'to reside within the persistentstore pattern.' -&gt;msg.putLine;
        'See the gcdemo demo for further details.' -&gt; msg.putLine;
        false -&gt; continue;
     #);
  #);

<B>PSexception</B><A name="PSexception.1(61)"></A>: exception (# <B>fullName</B><A name="PSexception.1:fullName.2(62)"></A><A name="fullName.2(62)"></A>: ^Text;  enter fullName[] do INNER #)
</PRE>


</BODY>
</HTML>
