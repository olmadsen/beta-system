<H1>Persistentstore Interface</H1>
<BETA>
ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-2000
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface';

-- lib: Attributes --

<B>persistentstore</B><A name="persistentstore.1(1)"></A>:
  (#
     <B>host</B><A name="persistentstore.1:host.2(2)"></A><A name="host.2(2)"></A>,<B> path</B><A name="persistentstore.1:path.2(3)"></A><A name="path.2(3)"></A>: ^text;
     
     <B>numberOfUpdates</B><A name="persistentstore.1:numberOfUpdates.2(4)"></A><A name="numberOfUpdates.2(4)"></A>: 
       (# 
          result: @integer
       do assertOpen(# notOpen :: (# do true -> continue #);
                    do (host,path) -> getNumberOfUpdates -> result
                    #)
       exit result
       #);
     <B>lastupdate</B><A name="persistentstore.1:lastupdate.2(5)"></A><A name="lastupdate.2(5)"></A>: @integer;
     
     <B>hostName</B><A name="persistentstore.1:hostName.2(6)"></A><A name="hostName.2(6)"></A>: (#  exit 'localhost' #);
     <B>rebinderItem</B><A name="persistentstore.1:rebinderItem.2(7)"></A><A name="rebinderItem.2(7)"></A>: ^rebindSpecialReference;
     <B>openCrossStoreItem</B><A name="persistentstore.1:openCrossStoreItem.2(8)"></A><A name="openCrossStoreItem.2(8)"></A>: ^openpstore;
     
     <B>assertOpen</B><A name="persistentstore.1:assertOpen.2(9)"></A><A name="assertOpen.2(9)"></A>:
       (# notOpen:< PSException
            (# 
            do 'persistentstore.assertOpen: Store is not open'
                 -> msg.putText;
               false -> continue;
               INNER;
            #);
       do (if host[] <> none then
              (if path[] <> none then
                  INNER;
               else
                  notOpen;
              if);
           else
              notOpen;
          if);
       #);
     
     <B>assertInit</B><A name="persistentstore.1:assertInit.2(10)"></A><A name="assertInit.2(10)"></A>:
       (# notInitialized:< PSException
            (# 
            do 'persistentstore.assertInitialized: Store is not initialized'
                 -> msg.putText;
               false -> continue;
               INNER;
            #);
       do (if rebinderItem[] <> none then
              (if openCrossStoreItem[] <> none then
                  INNER;
               else
                  notInitialized;
              if);
           else
              notInitialized;
          if);
       #);
     
     <B>markSpecialObject</B><A name="persistentstore.1:markSpecialObject.2(11)"></A><A name="markSpecialObject.2(11)"></A>: external (* defined in P/misc.c *)
       (# tag,theObj: @integer enter (tag,theObj) #);
     <B>putExt</B><A name="persistentstore.1:putExt.2(12)"></A><A name="putExt.2(12)"></A>: external (* defined in P/PStoreServer.c *)
       (#
          dooverwrite: @boolean;
          host,path,name: [1] @Char;
          obj,rcode: @integer
       enter (dooverwrite,host,path,name,obj)
       exit rcode
       #);
     <B>setForceAOAGC</B><A name="persistentstore.1:setForceAOAGC.2(13)"></A><A name="setForceAOAGC.2(13)"></A>: external (* defined in ioa.c *) 
       (#  #);
     <B>forceObjectToAOA</B><A name="persistentstore.1:forceObjectToAOA.2(14)"></A><A name="forceObjectToAOA.2(14)"></A>: external (* defined in P/misc.c *)
       (# theObj: @integer;  enter theObj #);
     <B>getNumberOfUpdates</B><A name="persistentstore.1:getNumberOfUpdates.2(15)"></A><A name="getNumberOfUpdates.2(15)"></A>: external (* defined in P/PStore.c *)
       (# host,path: [1] @Char; numUpdates:@integer
       enter (host,path)
       exit numUpdates
       #);
     <B>openReadExt</B><A name="persistentstore.1:openReadExt.2(16)"></A><A name="openReadExt.2(16)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>openWriteExt</B><A name="persistentstore.1:openWriteExt.2(17)"></A><A name="openWriteExt.2(17)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>createExt</B><A name="persistentstore.1:createExt.2(18)"></A><A name="createExt.2(18)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>closeExt</B><A name="persistentstore.1:closeExt.2(19)"></A><A name="closeExt.2(19)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       #);
     <B>getExt</B><A name="persistentstore.1:getExt.2(20)"></A><A name="getExt.2(20)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path,name: [1] @Char; theObj: @integer
       enter (host,path,name)
       exit theObj
       #);
     
     <B>ACCESSERRORERROR</B><A name="persistentstore.1:ACCESSERRORERROR.2(21)"></A><A name="ACCESSERRORERROR.2(21)"></A>: (#  exit 1 #);
     <B>NOTFOUNDERROR</B><A name="persistentstore.1:NOTFOUNDERROR.2(22)"></A><A name="NOTFOUNDERROR.2(22)"></A>: (#  exit 2 #);
     <B>ALREADYOPENERROR</B><A name="persistentstore.1:ALREADYOPENERROR.2(23)"></A><A name="ALREADYOPENERROR.2(23)"></A>: (#  exit 3 #);
     <B>EXISTSERROR</B><A name="persistentstore.1:EXISTSERROR.2(24)"></A><A name="EXISTSERROR.2(24)"></A>: (#  exit 4 #);
     <B>CREATIONERRORERROR</B><A name="persistentstore.1:CREATIONERRORERROR.2(25)"></A><A name="CREATIONERRORERROR.2(25)"></A>: (#  exit 5 #);
     
     <B>registerRebinderFunc</B><A name="persistentstore.1:registerRebinderFunc.2(26)"></A><A name="registerRebinderFunc.2(26)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callRebinder enter rebinderFunc## #);
     
     <B>registerOpenCrossStoreFunc</B><A name="persistentstore.1:registerOpenCrossStoreFunc.2(27)"></A><A name="registerOpenCrossStoreFunc.2(27)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callOpenCrossStore enter rebinderFunc## #);
     
     <B>registerBETAENVandPROGRAM</B><A name="persistentstore.1:registerBETAENVandPROGRAM.2(28)"></A><A name="registerBETAENVandPROGRAM.2(28)"></A>: external
       (# theProgram:@integer
       enter theProgram
       #);
     
     <B>init</B><A name="persistentstore.1:init.2(29)"></A><A name="init.2(29)"></A>:
       (# 
       do callRebinder## -> registerRebinderFunc;
          &rebindSpecialReference[] -> rebinderItem[];
          callOpenCrossStore## -> registerOpenCrossStoreFunc;
          &openpstore[] -> openCrossStoreItem[];
          (%getLongAt (@@ theProgram))-> registerBETAENVandPROGRAM;
          INNER
       #);
     
     <B>callRebinder</B><A name="persistentstore.1:callRebinder.2(30)"></A><A name="callRebinder.2(30)"></A>: external
       (# objectTag,typeTag: @integer; target: ^Object; targetAbs: @integer
       enter (objectTag,typeTag)
       do CExternalentry;
          (objectTag,typeTag)->rebinderItem->target[];
          (%getLongAt (@@ target))->targetAbs
       exit targetAbs
       #);
     
     <B>callOpenCrossStore</B><A name="persistentstore.1:callOpenCrossStore.2(31)"></A><A name="callOpenCrossStore.2(31)"></A>: external
       (# host, path: [1] @Char; newps: ^persistentstore;
          hostText, pathText: ^text;
          
       enter (host, path)
       do CExternalentry;
          &text[]-> hostText[];
          &text[]-> pathText[];
          
          host -> hostText;
          path -> pathText;
          pathText[] -> openCrossStoreItem -> newps[];
          (* newps is not currently used by the system *)
       #);
     
     <B>UNKNOWNTAG</B><A name="persistentstore.1:UNKNOWNTAG.2(32)"></A><A name="UNKNOWNTAG.2(32)"></A>: (#  exit 0 #);
     <B>rebindSpecialReference</B><A name="persistentstore.1:rebindSpecialReference.2(33)"></A><A name="rebindSpecialReference.2(33)"></A>:<
       (#
          target: ^Object;
          toSpecialObject:<
            (#
               objectTag: @integer;
               NotHandled:< PSException
                 (# 
                 do 'persistentstore.rebindSpecialReference: tag "'
                      ->msg.putText;
                    objectTag->msg.putInt;
                    '" has not been rebound (returning NULL)'->msg.putText;
                    msg[]->putline;
                    true->continue;
                    INNER
                 #)
            enter objectTag
            do INNER
            #);
          toSpecialType:<(# typeTag: @integer enter typeTag do INNER #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       do (if objectTag <> UNKNOWNTAG then
              objectTag->toSpecialObject
           else
              (if typeTag <> UNKNOWNTAG then typeTag->toSpecialType if)
          if);
          (* At this point it is assumed that 'target' now contains the 
           * reference to the object this special reference is 
           * to be rebound to *)
          (if target[] = none then
              PSexception
              (# 
              do 'handleSpecialReference: User code failed to rebind' 
                   -> msg.putLine;
                 'reference to special object tagged '
                   -> msg.putText;
                 objectTag -> msg.putInt;
                 '.' -> msg.putLine;
                 'Make sure the \'rebindSpecialReference\' virtual'           
                   -> msg.putLine;
                 'has been implemented correctly.'
                   -> msg.putLine;
                 false -> continue;
              #)
          if);
       exit target[]
       #);
     <B>commit</B><A name="persistentstore.1:commit.2(34)"></A><A name="commit.2(34)"></A>: assertInit
       (#
          doUpdateInMemoryObjects:< BooleanValue
            (#  do false->value; INNER #);
          doCheckpoint:< BooleanValue (#  do true->value; INNER #);
          
       do INNER
       #);
     <B>reget</B><A name="persistentstore.1:reget.2(35)"></A><A name="reget.2(35)"></A>: assertInit
       (#
          NotFound:< PSException
            (# 
            do 'persistentstore.reget: Root "'->msg.putText;
               fullname[]->msg.putText;
               '" has been overwritten by another client.'->msg.putText;
               'Your references are not longer valid.'->msg.puttext;
               msg[]->putline;
               true->continue;
               INNER
            #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     
     <B>open</B><A name="persistentstore.1:open.2(36)"></A><A name="open.2(36)"></A>: assertInit
       (#
          alreadyOpenMessage:< (# msg: ^text do INNER exit msg[] #);
          notFoundMessage:< (# msg: ^text do INNER exit msg[] #);
          accessErrorMessage:< (# msg: ^text do INNER exit msg[] #);
          
          alreadyOpen:< PSexception
            (# 
            do alreadyOpenMessage->msg.putText;
               fullName[]->msg.putText;
               '" already open'->msg.putText;
               true -> continue;
               INNER
            #);
          notFound:< PSexception
            (# 
            do notFoundMessage->msg.putText;
               fullName[]->msg.putText;
               '" not found'->msg.putText;
               INNER
            #);
          accessError:< PSexception
            (# 
            do accessErrorMessage ->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               INNER
            #);
          name: ^Text;
          openFunc:<
            (# host,path: [1] @Char; rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)->openFunc
               // (NOTFOUNDERROR) then
                  name[]->notFound
               // (ACCESSERRORERROR) then
                  name[]->accessError
               else
                  name[]->path[]; hostName->host[]; 
                  INNER
              if)
           else
              name[]->alreadyOpen; 
          if);
       #);
     
     <B>openRead</B><A name="persistentstore.1:openRead.2(37)"></A><A name="openRead.2(37)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openRead: "' -> msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openRead: "'->msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openRead: No access to "'->msg[]; #);
          openFunc :: (# do (host, path) -> openReadExt -> rcode #);
       do INNER
       #);
     
     <B>openWrite</B><A name="persistentstore.1:openWrite.2(38)"></A><A name="openWrite.2(38)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openWrite: "' -> msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openWrite: "' ->msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openWrite: No access to"'->msg[]; #);
          openFunc :: (# do (host, path) -> openWriteExt -> rcode #);
       do INNER
       #);
     
     <B>create</B><A name="persistentstore.1:create.2(39)"></A><A name="create.2(39)"></A>: assertInit
       (#
          alreadyOpen:< PSexception
            (# 
            do 'persistentstore.create: "'->msg.putText;
               fullName[]->msg.putText;
               '" already open'->msg.putText;
               INNER
            #);
          exists:< PSexception
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "'->msg.putText;
               fullName[]->msg.putText;
               '" already exists'->msg.putText;
               INNER
            #);
          creationError:< PSexception
            (# 
            do 'persistentstore.create: Failed creating "'->msg.putText;
               fullName[]->msg.putText;
               '"'->msg.putText;
               INNER
            #);
          name: ^Text;
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)->createExt
               // (EXISTSERROR) then
                  name[]->exists; 
               // (CREATIONERRORERROR) then
                  name[]->creationError
               else
                  hostName->host[]; name[]->path[]; 
              if)
           else
              name[]->alreadyOpen; 
          if);
          INNER
       #);
     
     <B>checkpoint</B><A name="persistentstore.1:checkpoint.2(40)"></A><A name="checkpoint.2(40)"></A>: assertInit (#  do setForceAOAGC; doGC;  #);
     
     <B>close</B><A name="persistentstore.1:close.2(41)"></A><A name="close.2(41)"></A>: assertInit
       (#
          danglersExists:<
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill->todo ; INNER
            exit todo #);
          doCheckpoint:< BooleanValue (#  do false->value; INNER #);
          
       do INNER;
          checkpoint;
          (host, path) -> closeExt;
          none ->path[];
          none ->host[];
          
       #);
     
     <B>get</B><A name="persistentstore.1:get.2(42)"></A><A name="get.2(42)"></A>: assertInit
       (#
          quaError:< Exception
            (# 
            do 'persistentstore.get: Qua error getting "'->msg.putText;
               name[]->msg.putText;
               '"'->msg.putText;
               INNER
            #);
          notFound:< Exception
            (# 
            do 'persistentstore.get: "'->msg.putText;
               name[]->msg.putText;
               '" not found'->msg.putText;
               INNER
            #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type## )
       do (@@ theObject,((host,path,name)->getExt))->assignRef;
          (if theObject[] = none then notFound if);
          INNER
       exit theObject[]
       #);
     <B>ALREADYTHEREERROR</B><A name="persistentstore.1:ALREADYTHEREERROR.2(43)"></A><A name="ALREADYTHEREERROR.2(43)"></A>: (#  exit 6 #);
     <B>HASOVERWRITTENERROR</B><A name="persistentstore.1:HASOVERWRITTENERROR.2(44)"></A><A name="HASOVERWRITTENERROR.2(44)"></A>: (#  exit 7 #);
     <B>put</B><A name="persistentstore.1:put.2(45)"></A><A name="put.2(45)"></A>: assertInit
       (#
          AlreadyThere:< PSexception
            (# 
            do 'persistentstore.put: Root "'->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               'already there.'->msg.puttext;
               true->continue;
               INNER
            #);
          HasOverWritten:< PSexception
            (# 
            do 'persistentstore.put: Root "'->msg.putText;
               fullName[]->msg.putText;
               '" '->msg.putText;
               'will overwrite an already existing root with same name at checkpoint time.'
                 ->msg.puttext;
               true->continue;
               INNER
            #);
          dooverwrite:< BooleanValue (#  do true->value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       do (%getLongAt (@@ obj))->forceObjectToAOA;
          doGC;
          (if ((dooverwrite,host,path,name,(%getLongAt (@@ obj)))->putExt)
           // (ALREADYTHEREERROR) then
              AlreadyThere; (if dooverwrite then HasOverWritten if)
          if);
          INNER
       #);
     <B>scanRootNames</B><A name="persistentstore.1:scanRootNames.2(46)"></A><A name="scanRootNames.2(46)"></A>: assertInit (# current: ^Text;  do INNER #);
     <B>registerSpecialObject</B><A name="persistentstore.1:registerSpecialObject.2(47)"></A><A name="registerSpecialObject.2(47)"></A>: assertInit
       (#
          alreadyThere:< Exception
            (# 
            do 'registerSpecialObject: Special object "'->msg.putText;
               name[]->msg.putText;
               '" already exists: '->msg.putText;
               INNER ;
               false->continue;
               
            #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type## )
       do 'registerSpecialObject: Registering of special objects and instances'-> screen.putLine;
          'is implemented differently in the new persistence implementation.'-> screen.putLine;
          'This call has no effect, and should be removed.' -> screen.putLine;
          INNER
       #);
     <B>registerRuntimeType</B><A name="persistentstore.1:registerRuntimeType.2(48)"></A><A name="registerRuntimeType.2(48)"></A>: assertInit
       (# type: ##Object enter type## 
       do 'registerRuntimeType: This function is not implemented in the new'
            -> screen.putLine;
          'persistent store, and the call should be removed.' -> screen.putLine;
          
       #);
     <B>maxCountOnDanglerHit</B><A name="persistentstore.1:maxCountOnDanglerHit.2(50)"></A><A name="maxCountOnDanglerHit.2(50)"></A>:< IntegerValue (#  do 100->value; INNER #);
     <B>OnDanglerHit</B><A name="persistentstore.1:OnDanglerHit.2(51)"></A><A name="OnDanglerHit.2(51)"></A>:< Object;
     <B>AfterDanglerHit</B><A name="persistentstore.1:AfterDanglerHit.2(52)"></A><A name="AfterDanglerHit.2(52)"></A>:<(# theObject: ^Object;  enter theObject[] do INNER #);
     <B>openpstore</B><A name="persistentstore.1:openpstore.2(53)"></A><A name="openpstore.2(53)"></A>:<
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     <B>deletePersistentStore</B><A name="persistentstore.1:deletePersistentStore.2(54)"></A><A name="deletePersistentStore.2(54)"></A>: assertInit
       (#
          alreadyOpen:< PSexception
            (# 
            do 'persistentstore.delete: "'->msg.putText;
               fullName[]->msg.putText;
               '" is currently open'->msg.putText;
               INNER ;
               
            #);
          accessError:< PSexception
            (# 
            do 'persistetstore.delete: Unable to delete "'->msg.putText;
               fullName[]->msg.putText;
               '"'->msg.putText;
               INNER ;
               
            #);
          notFound:< PSexception
            (# 
            do 'persistetstore.delete: "'->msg.putText;
               fullName[]->msg.putText;
               '" not found'->msg.putText;
               INNER ;
               
            #);
          name: ^Text;
          storeDir: @directory; 
          
       enter name[]
       do assertOpen
          (# do path[] -> storeDir.name;
             storeDir.delete
             (# 
                nosuch:: (# do PSexception
                            (# do 'delete error: ' -> msg.putText;
                               path[] -> msg.putText;
                               ' does not exist' -> msg.putText;
                               true -> continue;
                            #);
                         #);
                
                error:: (# do PSexception
                           (# do 'delete error: ' -> msg.putText;
                              path[] -> msg.putText;
                              ' could not be deleted (unknown error)' -> msg.putText;
                              true -> continue;
                           #);
                        #);
             #);
          #);
       #);
     <B>registerSpecialInstance</B><A name="persistentstore.1:registerSpecialInstance.2(55)"></A><A name="registerSpecialInstance.2(55)"></A>: assertInit
       (#
          quaError:< Exception
            (# 
            do 'registerSpecialInstance: Qua error on "'->msg.putText;
               tag->msg.putInt;
               '" instance'->msg.putText;
               INNER ;
               false->continue;
               
            #);
          notFound:< Exception
            (# 
            do 'registerSpecialInstance: Special object "'->msg.putText;
               tag->msg.putInt;
               '" not registered.'->msg.putText;
               INNER ;
               false->continue;
               
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
       enter (o[],tag)
       do (if tag < 256 then
              (tag,%getLongAt (@@ o))->markSpecialObject;
           else
              PSexception
              (# do 'registerSpecialInstance: ' -> msg.putText;
                 ' tag (' -> msg.putText;
                 tag -> msg.putInt;
                 ') must be less than 256' -> msg.putText;
                 false -> continue;
              #);
          if);
       #);
  do INNER ; 
  #);
<B>deletePersistentStore</B><A name="deletePersistentStore.1(56)"></A>:
  (#
     <B>alreadyOpen</B><A name="deletePersistentStore.1:alreadyOpen.2(57)"></A><A name="alreadyOpen.2(57)"></A>:< PSexception(# do INNER #);
     <B>accessError</B><A name="deletePersistentStore.1:accessError.2(58)"></A><A name="accessError.2(58)"></A>:< PSexception(# do INNER #);
     <B>notFound</B><A name="deletePersistentStore.1:notFound.2(59)"></A><A name="notFound.2(59)"></A>:< PSexception(# do INNER #);
     <B>name</B><A name="deletePersistentStore.1:name.2(60)"></A><A name="name.2(60)"></A>: ^Text;
     
  enter name[]
  do PSexception
     (# do 'delete error: deletePersistentStore has been moved' ->msg.putLine;
        'to reside within the persistentstore pattern.' ->msg.putLine;
        'See the gcdemo demo for further details.' -> msg.putLine;
        false -> continue;
     #);
  #);

<B>PSexception</B><A name="PSexception.1(61)"></A>: exception (# <B>fullName</B><A name="PSexception.1:fullName.2(62)"></A><A name="fullName.2(62)"></A>: ^Text;  enter fullName[] do INNER #)
</BETA>


