<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>
Persistence in BETA - Reference Manual
</TITLE></HEAD>
<H1><center>Persistence in BETA - Reference Manual</center></H1>
<center>
Mjølner Informatics Report - &#169; Mjølner Informatics 1999
</center>
<center>
One page for printing
</center>
<BODY onLoad='window.print()'>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Introduction</TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css TYPE=text/css">
</HEAD>
<BODY>

<H1> Introduction</H1>

<P> In the Mj&oslash;lner System objects generated by a BETA program
execution may be saved on secondary storage and restored in another
BETA program execution. Usually this property of a programming
language or system is referred to as object persistence<A NAME=MARKER-2-3></A>. Persistence in the Mj&oslash;lner System is
based on a <em>reachability model</em><A NAME=MARKER-2-4></A>, meaning
that default behaviour when saving an object on secondary storage is
to save everything reachable from the object in question.

<P> Mjølner supports a single-user persistent store model as well as a
multi-user shared persistent store. The multi-user persistent store
makes it possible to build an object-oriented database (OODB) using a
clienter/server model.  Persistence in Mjølner is based on a number of
frameworks:

<ul>
<li>
<B>Basic object management.</B> 
A program may saves its objects in a 
persistent store and these may later be re-fetched from another or the same program.
This framework supports single-user persistence.

<li>
<b>Concurrency control.</b> If two or more programs (clients) need to
acces the same persistent store at the same time, it is possible to
synchronize acces to the persistent store through a server. The server
implements a concurrency control mechanism that mediates the access to
the persistent store.  This framework supports multi-user persistent
store.

<li>
<b>Transaction management.</b>
Transaction management deals with the problem
of keeping a persistent store in a consistent state
when two or more clients concurrently access the store
or when failures happen during a program execution.
This framework adds functionality to a multi-user
<li>
<b>Notification control.</b>
When two or more clients use the same persistent store, a notification
mechanism is available for communication between the clients.
Notifications may be sent to cleints when e.g. objects are written
to the store by another client.
This framework adds functionality to a multi-user
persistent store.
</ul>

In addition to the above main features, the following 
features are also supported:

<ul>
<li>
In order to delay object fetch from secondary storage
until an object is actually needed, lazy object fetch <A NAME=MARKER-2-5></A>is supported. When using lazy fetch, only the
persistence root and a few more objects are initially fetched from
secondary storage. Fetch of other reachable objects is deferred until
their state is needed. At that time, the object is transparently
fetched from secondary storage.

<li> The basic object management supports reference between objects in
different persistent stores.

<li> Recognizing that saving the full transitive object closure may at
times be too coarse grained, the Mj&oslash;lner System allows the
programmer to control what part of the reachable object graph is
actually saved along. This allows pointers from persistent objects to
non-persistent objects despite the reachability based persistence
model.

</ul>

The persistence frameworks have gone through a number of iterations:

<ul>

<li>
The first ideas for persistence in Mjølner were presented in  [Agesen 89]
and a first implementation of single-user persistence was made by Claus Nørgaard.

<li> The first product-quality implementation of single-user
persistence was made by Søren Brandt.  Design considerations,
experience and recommendations for a re-design are documented in the
PhD Thesis of Søren Brandt [Brandt94].  This version of basic object management
has been part of the Mjølner System for many years and is
referred to as the <em>old basic object management</em>.

<li> A multi-user shared persistence store with concurrency control,
transaction management and notifications has recently been developed
by Johanna Wiederhold Tind [Tind97].

<li> Recently a new and more efficient implementation of the basic
object management has been implemented by Stephan Erbs Korsholm
[Korsholm99]. This work a.o. benefits from the work of Søren Brandt.
This version of the basic object management is referred to as 
the <em> new basic object management</em>. 

</ul>

The new basic object management will eventually replace the old
basic object management.  In release 5.0 of the Mjølner System the
old- as well as the new basic object management are included. We
recommed to use the new basic object management since it is much more
efficient than the old one.  However, as this is the first release
of the new basic object management, there may still be some errors or
problems that have not yet been discovered.

<p> The old and the new basic object management both work with the
shared persistent store.

<p>
The directory
<PRE CLASS=beta>
~beta/persiststore
</PRE>
contains the new basic object management as well as the shared
persistent store.

<p>
The directory

<PRE CLASS=beta>
~beta/persiststore/OLD
</PRE>
contains the old persistent store.

<p>
The interface to the old and the new persistent store is the same.
That is, it is possible to alternate between the old and the new store by
including either
<p>
<PRE CLASS=beta>
~beta/persiststore/persistentstore
</PRE>
<p>
or
<p>
<PRE CLASS=beta>
~beta/persiststore/OLD/persistentstore
</PRE>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Basic Definitions </TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css TYPE=text/css">
</HEAD>

<BODY>


<A NAME=HEADING4></A>


<H1>Basic Definitions<A NAME=mark-1></A></H1>

<P> A <em>persistent object</em> <A NAME=MARKER-2-6></A>is an object
that is saved on secondary storage during a program execution and thus
survives the program execution in which it was created. A persistent
object may be read by another program execution. Any BETA object can
in principle be persistent. In the current implementation, the
execution state (i.e. <em>component stacks</em><A NAME=MARKER-2-7></A>) is not saved. Furthermore, for certain types of
objects it may not be meaningful to make them persistent. This is
e.g. the case with user interface objects generated by libraries such
as xtenv, bifrost and macenv. Xtenv objects may e.g. have partial
state information about windows, widgets, etc., but this information
will not be sufficient to restore the screen.</P>

<P> By default, when an object is made persistent, all objects that
can be reached through references are also made persistent. This
includes statically enclosing objects<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-1">[1]</A></EM>. The set of objects that can be
reached from an object in this way is called the <em>transitive
closure</em> <A NAME=MARKER-2-8></A>of the object. </P>

<P> Persistent objects are saved in a <em>persistent store</em><A NAME=MARKER-2-9></A>, which is a collection of persistent objects. A
persistent store has a name. In the current implementation, the name
of a persistent store is the name of a file system directory
containing the files making up the persistent store. Several
persistent stores may exist and references between objects in
different persistent stores are supported. A persistent store is
itself a BETA object with a number of attributes. </P>

<P> An object may be pointed out to become a <em>persistent
root</em><A NAME=MARKER-2-10></A> by means of the put operation on the
persistent store. A persistent root must be given a logical name in
the form of a text string. On checkpoint <A NAME=MARKER-2-11></A>time,
all objects reachable from persistent roots are saved in the
persistent store.</P>






<HR>

<A NAME=FOOTNOTE-1>[1] </A>
 Objects that are instances of a nested pattern P.PP depends on, i.e. have a reference to, some instance of the enclosing pattern P. 





</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Objects and Patterns </TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css TYPE=text/css">
</HEAD>
<BODY>

<H1> Objects and Patterns </H1>
<P> An object generated as an instance of a pattern is only meaningful as an instance of that pattern. Consider the following example: </P>
<PRE CLASS=beta>
P: (# ... #);
R: ^P;

&amp;P[] -&gt; R[]; .... (* Save R *)
</PRE>
<P> The object referenced by R is an instance of P. When this object is later read by a program, it must be interpreted by that program execution as an instance of P. </P>
<P> It is not enough that the program reading the object has a declaration of a pattern P which has the same structure as the pattern P which was used to generate the object. It must be the very same pattern. </P>

<P> In order for this to work, it is necessary to give a new interpretation to the notion of betaenv<A NAME=MARKER-2-12></A>. This new interpretation is described in the next section. Before doing this we will shortly discuss what it means for objects to be instances of the same pattern.</P>
<P> Consider the following object descriptor:</P>
<PRE CLASS=beta>
(# T: (#  c: @ integer;
          A: (# b: @integer do c-&gt;b #);
          X: @ A;
          Y: @ A
      #);
   V: @ T;
   W: @ T
#)
</PRE>

<P> The outermost object has two internal objects V and W which are instances of the pattern T. Each of V and W has internal attributes c, A, X and Y. The attributes of V are different from the attributes of W. This should be obvious for c, X and Y, since they occupy different storage locations in V and W respectively. The pattern attribute A of V is also different from the pattern attribute A of W. The reason is that an instance of V.A is enclosed by V and may therefore refer to attributes of V -- V.A is said to have origin in V. The pattern W.A is an attribute of W and may refer to attributes of W -- W.A has origin in W. An instance of V.A is therefore NOT an instance of W.A. </P>
<P> The objects V.X and V.Y are thus instances of the same pattern V.A. Similarly the objects W.X and W.Y are instances of the same pattern W.A.</P>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Betaenv</TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css TYPE=text/css">
</HEAD>
<BODY>

<H1> Betaenv</H1>
<P> Betaenv is a fragment defining a pattern that currently encloses all BETA code being compiled and executed by the Mj&oslash;lner System. This means that each program execution creates a new betaenv object. Patterns described in different programs will thus never be identical, since they will always directly or indirectly be attributes of the betaenv instance created by the program execution. Cf. the above discussion.</P>

<P> To overcome this problem, the persistentstore treats all betaenv instances as if they were actually the same object, although in practice a new instance is created in each program execution. For example, consider the following library fragment:</P>
<H4 class=betacaption>mylib.bet</H4>
<PRE CLASS=beta>
ORIGIN 'betaenv'
---LIB:attributes---
  A: (# ... #);
  B: (# ... #);
</PRE>
<P> If mylib.bet is included by two or more different programs, then the pattern A will logically be the same pattern in both programs, since it is an attribute of the same betaenv object in all the corresponding program executions. The same is of course true for B and any other pattern declared in mylib.bet </P>
<BLOCKQUOTE>
<P>Patterns used for generating persistent objects should normally be defined in the lib:attributes library slot as in mylib above.</P>
</BLOCKQUOTE>
<P> However, by using the support for special objects as described in a later section, it is possible to obtain the same treatment of other patterns as just described for betaenv, i.e. treating instances of the pattern in different program executions as logically the same object. This also allows patterns used for generating persistent objects to be declared in attribute slots different from lib:attributes.</P>

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Fragments and Compiled Code</TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>

<H1> Fragments and Compiled Code</H1>

<P> A BETA pattern <A NAME=MARKER-2-13></A>is declared in some
fragment <A NAME=MARKER-2-14></A>of the BETA fragment system. The
fragment in turn is part of a fragment group<A NAME=MARKER-2-15></A>,
corresponding to a BETA source file. For a description of the fragment
system, see <A HREF="../bibliography/index.html#mia90-2">[MIA
90-2]</A>. To identify the pattern from which a persistent object was
created, the object has a reference to the fragment in which the
pattern is declared. The fragment is unique in the sense that it is
the version used for generating the code that instantiated the
object. In order to load an object into the memory of some program
execution, the program loading the object must be compiled from and
linked with the same version of the fragment from which the object was
originally created. Note that this does not prevent exchange of
objects between different platforms, since it is the fragments that
must correspond, not the compiled code<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-2">[2]</A></EM>.</P>

<BLOCKQUOTE>
<P>The current implementation does NOT check if the fragments used for
creating a persistent object has been changed since the object was
created. It is currently the responsibility of the user to keep track
of this. </P>
</BLOCKQUOTE>

<P> It should be obvious that changes to a fragment may cause
inconsistencies with previously generated persistent objects. Neither
is it allowed to change other fragments within the same fragment
group.</P> <P> The fragment used for generating a persistent object is
currently identified using the name without path of the fragment group
in which the pattern is declared. This means that a BETA program using
persistence cannot contain two source files with the same name. If
this restriction is violated, the program will stop with an error
message as soon as the first persistent store is opened. </P>

<BLOCKQUOTE>
<P>Multiple equally named BETA source files are not allowed when using
persistence and distribution libraries.</P>
</BLOCKQUOTE>

<P> The above problems related to the unique identification of
patterns will be avoided in future versions of the persistent
store.</P>

<HR>

<A NAME=FOOTNOTE-2>[2] </A> The current version of the persistent
 store does not support object exchange between little and big endian
 machines.

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> The Persistentstore Pattern</TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>

<H1> The Persistentstore Pattern</H1> <P> The Mj&oslash;lner System
includes a library defining a persistent store, which keeps track of a
directory of references to persistent objects. Some of these objects,
the persistent roots, may have a logical name. A BETA program using
persistent objects must include the persistent store library which is
contained in the file</P>

<BLOCKQUOTE>
<PRE>
<A HREF="interface/persistentstore.html">~beta/persistentstore/persistentstore</A>
</PRE>
</BLOCKQUOTE>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Basic Operations</H1>
<P> The basic operations of the persistent store are as follows:</P>
<UL>
<LI>create<A NAME=MARKER-2-16></A>, openRead<A NAME=MARKER-2-17></A>, openWrite <A NAME=MARKER-2-18></A>are used for creating and opening a persistent store in order to access its contents. The name parameter is interpreted as a pathname relative to the current working directory of the process. When opening a persistent store for reading, it is not possible to update the contents of the persistent store, although the objects fetched may be changed in memory.
<LI>put <A NAME=MARKER-2-19></A>points out an object to become a persistent root. This does not affect the contents of the persistent store, but registers the object is be saved in future checkpoint operations. At the same time the object is given a textual name to be used in get operations.
<LI>get <A NAME=MARKER-2-20></A>retrieves an object identified by its textual name from secondary storage. If the object is already in memory, a pointer to the in-memory version is returned without changing the state of the object. Usually the full transitive closure of the object is read from secondary storage at once. This default, however, may be changed by using lazy fetch.
<LI>checkpoint <A NAME=MARKER-2-21></A>saves the state of persistent objects on secondary storage. The transitive closures of all persistent roots in process memory are traversed, and all the objects saved. Checkpoint has no effect on stores opened by openRead.
<LI>close <A NAME=MARKER-2-22></A>closes the persistent store. By default close performs a checkpoint operation before closing the files making up the persistent store. In most uses of the persistent store, it is therefore not necessary to call checkpoint explicitly.
</UL>
<P> Other operations on persistent stores are supported. These operations are described in section 4 on advanced features. In addition to the persistentstore operations, the deletePersistentStore <A NAME=MARKER-2-23></A>pattern is available for deleting a persistent store.</P>
<P> A simple example using the persistentstore pattern is shown in  section 3.3.</P>



</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Restrictions</H1>

<P> In the single-user case at most one program at a time should open
a given persistent store in order to avoid problems with concurrent
access.

<p>
If multiple programs are going to use the same persistent store, the
multi-user version should be used.

<P> As already mentioned, application programs exploiting object
persistence should not include multiple source files with the same
name.</P>

<P> Component objects<A NAME=MARKER-2-25></A>, i.e. objects with their
own execution stack, are not allowed in the transitive closure of
persistent roots. If components are met during a checkpoint operation,
the program will terminate with an error message.</P>



</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Example</H1>
<P> The fragment TextHashTable.bet defines a pattern TextHashTable whose instances are to be made persistent. </P>

<H4 CLASS=betacaption>Program 1: TextHashTable.bet</H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/containers/hashTable';
INCLUDE '~beta/basiclib/texthash';

---lib: attributes---
TextHashTable: hashTable
  (# honey: @honeyman;
     init:: (# do honey.init #);
     element:: Text;
     rangeInitial:: (# do 300 -&gt; value #);
     hashfunction:: (# do e[]-&gt;honey.hash -&gt; value #);
  #);
</PRE>
<P> The fragment fooprod.bet describes a program that creates a new persistent store and saves some persistent objects:</P>
<H4 CLASS=betacaption>Program 2: fooprod.bet</H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/persistentstore/persistentstore';
INCLUDE 'TextHashTable';

--PROGRAM:descriptor--
(# PS: @persistentstore;
   H: ^TextHashTable;
do (* Create the persistent store *)
   PS.init;
   'myStore' -&gt; PS.create; 

   (* Create a table of objects. *)
   &amp;TextHashTable[] -&gt; H[]; 
   H.init;
   'first' -&gt; H.insert;
   'second' -&gt; H.insert;
   'third' -&gt; H.insert;

   (* Make the table a persistent root. *)
   (H[],'TextTable') -&gt; PS.put;

   (* Checkpoint and close the store. *)
   PS.close
#)
</PRE>
<P> The fragment foocons.bet describes a program that makes use of some persistent objects:</P>
<H4 CLASS=betacaption>Program 3: foocons.bet</H4>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/persistentstore/persistentstore';
INCLUDE 'TextHashTable';
--PROGRAM:descriptor--
(# PS: @persistentstore;
   H: ^TextHashTable;	
   T: ^Text;
   do PS.init;
      'myStore'-&gt;PS.openWrite;
      ('TextTable', TextHashTable##) -&gt; PS.get -&gt; H[]; 
      'fourth' -&gt; H.insert;
      H.scan  (# do current[] -&gt; putLine #);
      PS.close
#)
</PRE>
<P> Other example usages of the persistent store may be found in the directory BETALIB/demo/persistentstore. These demo programs, part of the Mj&oslash;lner System release 5.0, are listed below:</P>

<UL>
<LI>largeWrite.bet<A NAME=MARKER-2-29></A> and largeRead.bet<A NAME=MARKER-2-30></A> illustrate the use of lazy fetch, i.e. the ability to
delay object fetch from secondary storage until the objects are actually
needed. largeWrite saves a large hashtable in a persistent store. largeRead
in turn retrieves the hashtable from the store and then scans the table,
enforcing all objects to be fetched lazily. It then closes the store,
reopens it and fetches them once more.
<LI>build.bet and oobench.bet implements a simple benchmark of the
persistense framework. Run build to build the test store, then run oobench
to time vaious operations.
<LI>index.bet is a file indexer using a tree-like datastructure. The search
function finds all words beginning with a given character.
<LI>crossStoreDemo.bet demonstrates using multiple persistent stores from
one program.
</UL>



<P> Example of usages of the OLD persistent store may be found in the directory BETALIB/demo/persistentstore/OLD. These demo programs, part of the Mj&oslash;lner System release 5.0, are listed below:</P>

<UL>
<LI>largeWrite.bet, largeRead.bet work as described above.
<LI>showregister.bet<A NAME=MARKER-2-26></A> is an example of how to save a simple register in a persistent store. The register is built in a simple interaction with the user and finally saved. Later runs of showregister may read the saved register and perform simple queries. Finally the persistent store containing the register may be deleted.
<LI>hashdemo.bet<A NAME=MARKER-2-27></A> builds a simple hashtable of text strings. For each run of the program, an extra element is inserted into the table. If the persistent store does not already exist, it is created, and a new hashtable instance is made a persistent root. If the store already exists, the table is read, an extra element inserted, and the table scanned before the persistentstore is closed, implicitly implying a checkpoint operation.
<LI>structdemo.bet<A NAME=MARKER-2-28></A> is similar to hashdemo.bet, but illustrates the possibility of saving pattern variables in a persistent store. Pattern variables cannot become persistent roots, but as demonstrated by structdemo.bet, they are allowed in the transitive closure of a persistent root.
<LI>special.bet<A NAME=MARKER-2-31></A> is an example of how to limit the part of the transitive closure of persistents roots saved along during checkpoint operations. By registering the program pattern as a special object, even objects with origin<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-3">[3]</A></EM> in the program object can be made persistent roots. Furthermore, by registering the IntegerObject pattern as a runtime type,<A NAME=MARKER-2-32></A> references to all instances of IntegerObject are saved as NONE references. Runtime types and special objects<A NAME=MARKER-2-33></A> are described in detail in the next section.
<LI>crossstore.bet illustrates the handling of references between objects in different persistent stores. The same element is put into two different hashtables that in turn are saved in two different persistent stores. When one table is then fetched from its persistent store, it becomes necessary to open the persistentstore containing the shared element. The example shows how this must be taken care of by the programmer using the persistent store. The shared element is modified through the second table. On second run of the crossstore executable this modification is made visible through a scan of the first table. Details on references between different persistent stores are described in the following section.
</UL>






<HR>

<A NAME=FOOTNOTE-3>[3] </A>
 Instances of patterns nested in the program pattern.




</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Multi-User Shared Persistent Store</H1>

The multi-user shared persistent store makes it possible for two or
more programs (clients) to acces the same persistent store. Access to
the store has to be mediated through a server. The shared persistent store
consists of a number of frameworks that may be used to build clients
and servers. A client/server may contain part of the multi-user
functionality or all of it.

<p>
The following functionalty is supported

<ul>
<li>
<b>Concurrency control.</b>
Short description with references to Johannas Thesis
<li>
<b>Transactions.</b>
Short description with references to Johannas Thesis

<li>
<b>Notifications.</b>
Short description with reference to Johannas Thesis.

</ul>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Multi-User Shared Persistent Store Fragments</TITLE>
<LINK REL=stylesheet HREF="../style/miadoc.css" TYPE=text/css>
</HEAD>
<BODY>

<H1> Multi-User Shared Persistent Store Fragments</H1>

This will essentially be Appendix B of Johannas Thesis

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Multi-User Shared Persistent Store Example</H1>

This will essentially be Appendix C of Johannas Thesis
but based on the example made by Christian Damm.

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Advanced Features </H1>

The following sections describe some advanced features of using
persistent stores.


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<H1>Lazy object fetch<A NAME=MARKER-2-34></A></H1>
<BLOCKQUOTE>
<P><STRONG>Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense</STRONG></P>
</BLOCKQUOTE>

<P> When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.</P>

<P> By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.</P>
<P> In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.</P>
<P> So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references <A NAME=MARKER-2-35></A> are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-4">[4]</A></EM>, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].</P>
<BLOCKQUOTE>
<P>Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!</P>
</BLOCKQUOTE>
<P> In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit<A NAME=MARKER-2-36></A><A NAME=MARKER-2-37></A> and persistentstore.AfterDanglerHit<A NAME=MARKER-2-38></A> virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.</P>
<P> It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.</P>
<P> The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.</P>






<HR>

<A NAME=FOOTNOTE-4>[4] </A>
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> References between different persistent stores</H1>
<P> References between objects saved in different persistent stores are allowed, but  beware that the support for such references is still somewhat experimental and requires special care in order to avoid problems. This section describes how to exploit cross store references<A NAME=MARKER-2-39></A>. The crossstore.bet demo program is an example usage of cross store references. The drawing below illustrates references between objects saved in different persistent stores. In memory, there is no difference between cross store references and other object references. However, on secondary storage these references cross boundaries between persistent object stores.</P>
<P> </P>
<blockquote><IMG ALIGN=TOP width=401 height=277 SRC=crossref.gif></blockquote>
<P> </P>
<A NAME=HEADING14-5></A>
<H1> Where are objects saved?</H1>

<P> When performing a checkpoint<A NAME=MARKER-2-40></A> on a persistent store, either explicitly by calling the checkpoint operation or implicitly by closing the store, the object graphs rooted in the persistent roots of the store are traversed and the objects met saved to the persistent store. However, if an object is met that has already been saved in another persistent store, only the identification of that object is saved, and the graph traversal is not continued in that particular direction. Thus, a checkpoint operation on a persistent store only saves objects already belonging to that store, or objects that do not yet belong to any persistent store at all. The result is that a persistent object is saved in the store that first sees the object during a checkpoint operation.</P>
<P> The description above of course demands that we are able to recognize objects that &ograve;belong to&oacute; other persistent stores. However, when a persistent store is closed, objects that belonged to the store before the close operation will, after the close operation, semantically turn into copies of the objects belonging to the store. Thus, in order to maintain references between objects in different persistent stores, it is necessary to make explicit checkpoint operations and avoid the implicit checkpoint done by the close. The latter is done by further binding the doCheckpoint virtual:</P>
<PRE CLASS=beta>
PS.close (# doCheckpoint:: (# do false -&gt; value #)#);
</PRE>
<BLOCKQUOTE>
<P>When exploiting cross store references, avoid the implicit checkpoint operation by furtherbinding the doCheckpoint virtual on close operations. Instead explicit checkpoint operations should be executed on all stores before closing any store.</P>
</BLOCKQUOTE>
<A NAME=HEADING14-11></A>
<H1> Following references between persistent stores</H1>
<P> If a persistent root is fetched whose transitive closure contains references to objects in other persistent stores, these persistent stores must be open in order to fetch the objects referenced. However, if the store referred is not already open, the persistent store containing the reference is not able to open the store automatically since it has no idea whether it should be opened for reading or writing. Instead it calls the persistentstore.openpstore<A NAME=MARKER-2-41></A><A NAME=MARKER-2-42></A> virtual with the full pathname of the store needed, and expects the further binding to open and return the store.</P>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Limiting reachability based persistence</H1>
<A NAME=HEADING15-1></A>
<H1>Special objects<A NAME=MARKER-2-43></A></H1>
<P> For the primary intended usage, a special object is an object that is thought of as a single logical object that is always present in program executions using some persistent store. Support for special objects may thus be thought of as generic support for pointing out patterns that to some extend have only a single instance shared between all program executions using the pattern.</P>
<P> The state of special objects is never saved persistently. However, references to these objects should be saved so that they may be setup correctly when saved objects referencing a special object are re-instantiated in another process. Typical examples or special objects are application framework objects<A NAME=MARKER-2-44></A> that are known to be present in the program executions exchanging persistent objects, but should not be saved themselves. Examples of application framework objects are instances of guienv, XtEnv, systemenv and shellenv. These application framework objects, of which there should be at most one in each program execution, are not to be saved persistently, but instances of patterns nested inside the application frameworks should be allowed to persist. As already mentioned, betaenv is always treated as a special object.</P>
<P> Special objects are registered once in the lifetime of a persistent store by supplying name and type of the object to the persistentstore.registerSpecialObject<A NAME=MARKER-2-45></A> <A NAME=MARKER-2-46></A> method. The type is saved in the persistent store in order to be used for type checking when registering special object instances as described below. </P>
<P> In addition to the initial registration, an instance of the special object must be supplied by each process using the persistent store by calling the persistentstore.registerSpecialInstance<A NAME=MARKER-2-47></A> <A NAME=MARKER-2-48></A> method when the persistent store has been opened, but before any get operations are made. The instance given to the registerSpecialInstance method must be a subtype<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-5">[5]</A></EM> of the type given to the registerSpecialObject operation.</P>
<P> The demo program special.bet contains an example usage of special objects.</P>
<A NAME=HEADING15-7></A>
<H1>Runtime types<A NAME=MARKER-2-49></A></H1>
<P> Runtime types are patterns whose instances are used at runtime, but should not persist across program executions. As mentioned in section 2, an example of this is interface objects such as windows. Another example is objects used for caching purposes at runtime and referenced from persistent objects although the cache objects themselves should not be saved across program executions. By registering the pattern p as a runtime type, instances of p are not saved during checkpoint operations even though they are found in the transitive closure of a persistent root. Instead references to these objects are saved as NONE references. </P>
<P> Runtime types are registered by calling persistentstore.registerRuntimeType<A NAME=MARKER-2-50></A><A NAME=MARKER-2-51></A>. As runtime types registered using registerRuntimeType are not  saved persistently in the store, registerRuntimeType must be called for each runtime type in each session using the persistent store in question. If needed, it is of course possible to save a table of runtime types in a persistent store. The demo program structdemo.bet is an example of how a table of pattern variables may be saved in a persistent store.</P>
<P> The demo program special.bet contains an example usage of runtime types.</P>
<A NAME=HEADING15-11></A>
<H1> Combining runtime types and special objects</H1>
<P> Since references to special object instances are treated differently than references to instances of runtime types, it is a contradiction to register the same pattern as a special object and as a runtime type in the same persistent store. Doing so will result in a runtime error. </P>
<P> Furthermore, since it is not allowed to save an object without the knowledge that all its origins will be available when the object is to be reinstantiated, instances of runtime types should not be origins of objects saved. If an instance of a runtime type is needed as origin for some other object to be saved, the runtime type instance is saved anyway, disregarding the fact that it is an instance of a runtime type. </P>
<P> Different persistent stores used in the same program execution may have different sets of special objects and runtime types registered.</P>






<HR>

<A NAME=FOOTNOTE-5>[5] </A>
 The subtype relation is reflexive, i.e. any pattern is a subtype of itself.




</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Files used for storing objects</H1> 

<P> The name parameter to the create, openRead and openWrite
operations in the persistentstore pattern is interpreted as a
directory name relative to the current directory of the process. When
creating a new persistent store, this directory is created along with
the file db.  (Note, the old persistent store creates the files locg,
oinx and data.) For deleting the files making up a persistent store,
the deletePersistentStore pattern is available.</P>

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Known Bugs and Inconveniences</H1>



</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1>Garbage collection<A NAME=MARKER-2-52></A> and persistence</H1>
<P> With respect to garbage collection and persistence, there are two separate issues to consider, namely the usual in-memory garbage collection and garbage collection of the persistent store on secondary storage. These are considered in turn below.</P>
<A NAME=HEADING18-2></A>
<H1> In-memory garbage collection</H1>
<P> The persistent store kernel keeps track of persistent objects loaded into the current process by maintaining a table of references to these objects. This table is shared by all persistent stores in a program execution. As long as a persistent store is open, no objects from that store can thus become garbage, since they are at least referenced from the internal object table. Currently the only way to delete objects from the internal table is to close the store. Thus, to allow in-memory garbage collection of persistent objects, the persistent store in which these objects are saved must be closed.</P>
<P> A side-effect of deleting objects from the object table is is course that the persistence kernel no longer knows that these objects are persistent, and thus semantically these objects turn into in-memory copies of the real persistent objects, now only available on secondary storage.</P>
<A NAME=HEADING18-5></A>
<H1> Secondary storage garbage collection</H1>
<P> Currently there is no built-in support for garbage collection of persistent stores. Thus, once saved in a store, an object stays there until the store is deleted, even though the object may no longer be reachable from any persistent root. </P>
<H2> Secondary storage garbage collection using the OLD persistense implementation</H2>
<P><STRONG>Note, this technique does not work when using the new
persistense implementation.</STRONG>
<P> However, for small persistent stores whose objects fit into virtual memory of the computer at once, and that are not referenced from other persistent stores, it is possible to perform a simple garbage collection using the basic operations of the persistentstore pattern. This is illustrated by the PersistentGC.bet<A NAME=MARKER-2-53></A> demo fragment. PersistentGC simply reads the transitive closures of all persistence roots into memory, deletes the store, and then saves the persistence roots in a new store with the same name as the old store.</P>
<P> Note, however, that the fragments used to generate the objects saved in the store must be linked with the executable performing the collection.</P>
<P> The demo program gc.bet illustrates how to first delete a number of elements from the persistent table generated by largeWrite.bet, and then perform a garbage collection on the store, using PersistentGC.</P>

</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Persistent store identification and cross store references</H1>

<P> The persistent store identifies objects using a two-part object id<A NAME=MARKER-2-54></A>, each part being a 32 bit integer. The first part identifies the persistent store in which the object is saved, and the second part is a unique identification of the object within that store. Currently the persistent store id is simply the system time (in seconds) when the store was created. A persistent store containing references to other persistent store thus maintains a mapping from these creation times to the full pathname of the persistent stores, in order to be able to call the openpstore virtual with the correct pathname.</P>
<P> Unfortunately this identification is not entirely unique. The persistent store kernel ensures that no two stores created by the same process gets the same creationtime<A NAME=MARKER-2-55></A>, but there is currently no way to ensure that different processes do not create persistent stores with the same creation time. A process simultaneously opening two persistent stores with the same creation time will therefore in the best case receive wrong alreadyOpen exceptions, and in the worst case wrong in-memory object graphs may be created.</P>
<P> In future versions of the persistent store, this problem will be solved by using an alternative identification scheme.</P>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1> Bibliography</H1>
<P> </P>
<P> [Agesen 89]  Ole Agesen, Svend Fr&oslash;lund, Michael Hoffmann Olsen: Persistent and Shared Objects in BETA, Computer Science Department, Aarhus University, DAIMI IR-89, April 1989. </P>
<P> [Brandt 94] S&oslash;ren Brandt: Implementing Persistent and
Shared Object in BETA. Progress report. Technical Report, Computer
Science Department, Aarhus University, May 1994.</P>

<P> [Tind 97] Johanna Widerhold Tind: A Multi-User Persistence
Framework: Building Customized Database Solutions Using the BETA
Persistent Store, Master Thesis, Computer Science Department, Aarhus
University, 1997.

<P>
[Korsholm 99] Stephan Erbs Korsholhm: Transparent, Scalable, Efficient
OO-Persistence, Presented at the 1st ECOOP Workshop on Object-Oriented
Databases, ECOOP'99, Lisbon, Portugal, 1999.


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<H1>Persistentstore Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface';

-- lib: Attributes --

<B>persistentstore</B><A name="persistentstore.1(1)"></A>:
  (#
     <B>host</B><A name="persistentstore.1:host.2(2)"></A><A name="host.2(2)"></A>,<B> path</B><A name="persistentstore.1:path.2(3)"></A><A name="path.2(3)"></A>: ^text;
     
     <B>numberOfUpdates</B><A name="persistentstore.1:numberOfUpdates.2(4)"></A><A name="numberOfUpdates.2(4)"></A>: 
       (# 
          result: @integer
       do assertOpen(# notOpen :: (# do true -&gt; continue #);
                    do (host,path) -&gt; getNumberOfUpdates -&gt; result
                    #)
       exit result
       #);
     <B>lastupdate</B><A name="persistentstore.1:lastupdate.2(5)"></A><A name="lastupdate.2(5)"></A>: @integer;
     
     <B>hostName</B><A name="persistentstore.1:hostName.2(6)"></A><A name="hostName.2(6)"></A>: (#  exit 'localhost' #);
     <B>rebinderItem</B><A name="persistentstore.1:rebinderItem.2(7)"></A><A name="rebinderItem.2(7)"></A>: ^rebindSpecialReference;
     <B>openCrossStoreItem</B><A name="persistentstore.1:openCrossStoreItem.2(8)"></A><A name="openCrossStoreItem.2(8)"></A>: ^openpstore;
     
     <B>assertOpen</B><A name="persistentstore.1:assertOpen.2(9)"></A><A name="assertOpen.2(9)"></A>:
       (# notOpen:&lt; PSException
            (# 
            do 'persistentstore.assertOpen: Store is not open'
                 -&gt; msg.putText;
               false -&gt; continue;
               INNER;
            #);
       do (if host[] &lt;&gt; none then
              (if path[] &lt;&gt; none then
                  INNER;
               else
                  notOpen;
              if);
           else
              notOpen;
          if);
       #);
     
     <B>assertInit</B><A name="persistentstore.1:assertInit.2(10)"></A><A name="assertInit.2(10)"></A>:
       (# notInitialized:&lt; PSException
            (# 
            do 'persistentstore.assertInitialized: Store is not initialized'
                 -&gt; msg.putText;
               false -&gt; continue;
               INNER;
            #);
       do (if rebinderItem[] &lt;&gt; none then
              (if openCrossStoreItem[] &lt;&gt; none then
                  INNER;
               else
                  notInitialized;
              if);
           else
              notInitialized;
          if);
       #);
     
     <B>markSpecialObject</B><A name="persistentstore.1:markSpecialObject.2(11)"></A><A name="markSpecialObject.2(11)"></A>: external (* defined in P/misc.c *)
       (# tag,theObj: @integer enter (tag,theObj) #);
     <B>putExt</B><A name="persistentstore.1:putExt.2(12)"></A><A name="putExt.2(12)"></A>: external (* defined in P/PStoreServer.c *)
       (#
          dooverwrite: @boolean;
          host,path,name: [1] @Char;
          obj,rcode: @integer
       enter (dooverwrite,host,path,name,obj)
       exit rcode
       #);
     <B>setForceAOAGC</B><A name="persistentstore.1:setForceAOAGC.2(13)"></A><A name="setForceAOAGC.2(13)"></A>: external (* defined in ioa.c *) 
       (#  #);
     <B>forceObjectToAOA</B><A name="persistentstore.1:forceObjectToAOA.2(14)"></A><A name="forceObjectToAOA.2(14)"></A>: external (* defined in P/misc.c *)
       (# theObj: @integer;  enter theObj #);
     <B>getNumberOfUpdates</B><A name="persistentstore.1:getNumberOfUpdates.2(15)"></A><A name="getNumberOfUpdates.2(15)"></A>: external (* defined in P/PStore.c *)
       (# host,path: [1] @Char; numUpdates:@integer
       enter (host,path)
       exit numUpdates
       #);
     <B>openReadExt</B><A name="persistentstore.1:openReadExt.2(16)"></A><A name="openReadExt.2(16)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>openWriteExt</B><A name="persistentstore.1:openWriteExt.2(17)"></A><A name="openWriteExt.2(17)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>createExt</B><A name="persistentstore.1:createExt.2(18)"></A><A name="createExt.2(18)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       exit rcode
       #);
     <B>closeExt</B><A name="persistentstore.1:closeExt.2(19)"></A><A name="closeExt.2(19)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path: [1] @Char; rcode: @integer
       enter (host,path)
       #);
     <B>getExt</B><A name="persistentstore.1:getExt.2(20)"></A><A name="getExt.2(20)"></A>: external (* defined in P/PStoreServer.c *)
       (# host,path,name: [1] @Char; theObj: @integer
       enter (host,path,name)
       exit theObj
       #);
     
     <B>ACCESSERRORERROR</B><A name="persistentstore.1:ACCESSERRORERROR.2(21)"></A><A name="ACCESSERRORERROR.2(21)"></A>: (#  exit 1 #);
     <B>NOTFOUNDERROR</B><A name="persistentstore.1:NOTFOUNDERROR.2(22)"></A><A name="NOTFOUNDERROR.2(22)"></A>: (#  exit 2 #);
     <B>ALREADYOPENERROR</B><A name="persistentstore.1:ALREADYOPENERROR.2(23)"></A><A name="ALREADYOPENERROR.2(23)"></A>: (#  exit 3 #);
     <B>EXISTSERROR</B><A name="persistentstore.1:EXISTSERROR.2(24)"></A><A name="EXISTSERROR.2(24)"></A>: (#  exit 4 #);
     <B>CREATIONERRORERROR</B><A name="persistentstore.1:CREATIONERRORERROR.2(25)"></A><A name="CREATIONERRORERROR.2(25)"></A>: (#  exit 5 #);
     
     <B>registerRebinderFunc</B><A name="persistentstore.1:registerRebinderFunc.2(26)"></A><A name="registerRebinderFunc.2(26)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callRebinder enter rebinderFunc## #);
     
     <B>registerOpenCrossStoreFunc</B><A name="persistentstore.1:registerOpenCrossStoreFunc.2(27)"></A><A name="registerOpenCrossStoreFunc.2(27)"></A>: external (* defined in P/unswizzle.c *)
       (# rebinderFunc: ##callOpenCrossStore enter rebinderFunc## #);
     
     <B>registerBETAENVandPROGRAM</B><A name="persistentstore.1:registerBETAENVandPROGRAM.2(28)"></A><A name="registerBETAENVandPROGRAM.2(28)"></A>: external
       (# theProgram:@integer
       enter theProgram
       #);
     
     <B>init</B><A name="persistentstore.1:init.2(29)"></A><A name="init.2(29)"></A>:
       (# 
       do callRebinder## -&gt; registerRebinderFunc;
          &amp;rebindSpecialReference[] -&gt; rebinderItem[];
          callOpenCrossStore## -&gt; registerOpenCrossStoreFunc;
          &amp;openpstore[] -&gt; openCrossStoreItem[];
          (%getLongAt (@@ theProgram))-&gt; registerBETAENVandPROGRAM;
          INNER
       #);
     
     <B>callRebinder</B><A name="persistentstore.1:callRebinder.2(30)"></A><A name="callRebinder.2(30)"></A>: external
       (# objectTag,typeTag: @integer; target: ^Object; targetAbs: @integer
       enter (objectTag,typeTag)
       do CExternalentry;
          (objectTag,typeTag)-&gt;rebinderItem-&gt;target[];
          (%getLongAt (@@ target))-&gt;targetAbs
       exit targetAbs
       #);
     
     <B>callOpenCrossStore</B><A name="persistentstore.1:callOpenCrossStore.2(31)"></A><A name="callOpenCrossStore.2(31)"></A>: external
       (# host, path: [1] @Char; newps: ^persistentstore;
          hostText, pathText: ^text;
          
       enter (host, path)
       do CExternalentry;
          &amp;text[]-&gt; hostText[];
          &amp;text[]-&gt; pathText[];
          
          host -&gt; hostText;
          path -&gt; pathText;
          pathText[] -&gt; openCrossStoreItem -&gt; newps[];
          (* newps is not currently used by the system *)
       #);
     
     <B>UNKNOWNTAG</B><A name="persistentstore.1:UNKNOWNTAG.2(32)"></A><A name="UNKNOWNTAG.2(32)"></A>: (#  exit 0 #);
     <B>rebindSpecialReference</B><A name="persistentstore.1:rebindSpecialReference.2(33)"></A><A name="rebindSpecialReference.2(33)"></A>:&lt;
       (#
          target: ^Object;
          toSpecialObject:&lt;
            (#
               objectTag: @integer;
               NotHandled:&lt; PSException
                 (# 
                 do 'persistentstore.rebindSpecialReference: tag "'
                      -&gt;msg.putText;
                    objectTag-&gt;msg.putInt;
                    '" has not been rebound (returning NULL)'-&gt;msg.putText;
                    msg[]-&gt;putline;
                    true-&gt;continue;
                    INNER
                 #)
            enter objectTag
            do INNER
            #);
          toSpecialType:&lt;(# typeTag: @integer enter typeTag do INNER #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       do (if objectTag &lt;&gt; UNKNOWNTAG then
              objectTag-&gt;toSpecialObject
           else
              (if typeTag &lt;&gt; UNKNOWNTAG then typeTag-&gt;toSpecialType if)
          if);
          (* At this point it is assumed that 'target' now contains the 
           * reference to the object this special reference is 
           * to be rebound to *)
          (if target[] = none then
              PSexception
              (# 
              do 'handleSpecialReference: User code failed to rebind' 
                   -&gt; msg.putLine;
                 'reference to special object tagged '
                   -&gt; msg.putText;
                 objectTag -&gt; msg.putInt;
                 '.' -&gt; msg.putLine;
                 'Make sure the \'rebindSpecialReference\' virtual'           
                   -&gt; msg.putLine;
                 'has been implemented correctly.'
                   -&gt; msg.putLine;
                 false -&gt; continue;
              #)
          if);
       exit target[]
       #);
     <B>commit</B><A name="persistentstore.1:commit.2(34)"></A><A name="commit.2(34)"></A>: assertInit
       (#
          doUpdateInMemoryObjects:&lt; BooleanValue
            (#  do false-&gt;value; INNER #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       do INNER
       #);
     <B>reget</B><A name="persistentstore.1:reget.2(35)"></A><A name="reget.2(35)"></A>: assertInit
       (#
          NotFound:&lt; PSException
            (# 
            do 'persistentstore.reget: Root "'-&gt;msg.putText;
               fullname[]-&gt;msg.putText;
               '" has been overwritten by another client.'-&gt;msg.putText;
               'Your references are not longer valid.'-&gt;msg.puttext;
               msg[]-&gt;putline;
               true-&gt;continue;
               INNER
            #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     
     <B>open</B><A name="persistentstore.1:open.2(36)"></A><A name="open.2(36)"></A>: assertInit
       (#
          alreadyOpenMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          notFoundMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          accessErrorMessage:&lt; (# msg: ^text do INNER exit msg[] #);
          
          alreadyOpen:&lt; PSexception
            (# 
            do alreadyOpenMessage-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               true -&gt; continue;
               INNER
            #);
          notFound:&lt; PSexception
            (# 
            do notFoundMessage-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER
            #);
          accessError:&lt; PSexception
            (# 
            do accessErrorMessage -&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               INNER
            #);
          name: ^Text;
          openFunc:&lt;
            (# host,path: [1] @Char; rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)-&gt;openFunc
               // (NOTFOUNDERROR) then
                  name[]-&gt;notFound
               // (ACCESSERRORERROR) then
                  name[]-&gt;accessError
               else
                  name[]-&gt;path[]; hostName-&gt;host[]; 
                  INNER
              if)
           else
              name[]-&gt;alreadyOpen; 
          if);
       #);
     
     <B>openRead</B><A name="persistentstore.1:openRead.2(37)"></A><A name="openRead.2(37)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openRead: "' -&gt; msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openRead: "'-&gt;msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openRead: No access to "'-&gt;msg[]; #);
          openFunc :: (# do (host, path) -&gt; openReadExt -&gt; rcode #);
       do INNER
       #);
     
     <B>openWrite</B><A name="persistentstore.1:openWrite.2(38)"></A><A name="openWrite.2(38)"></A>: open
       (#
          alreadyOpenMessage :: (# do 'persistentstore.openWrite: "' -&gt; msg[]; #);
          notFoundMessage:: (# do 'persistentstore.openWrite: "' -&gt;msg[]; #);
          accessErrorMessage:: (# do 'persistentstore.openWrite: No access to"'-&gt;msg[]; #);
          openFunc :: (# do (host, path) -&gt; openWriteExt -&gt; rcode #);
       do INNER
       #);
     
     <B>create</B><A name="persistentstore.1:create.2(39)"></A><A name="create.2(39)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               INNER
            #);
          exists:&lt; PSexception
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already exists'-&gt;msg.putText;
               INNER
            #);
          creationError:&lt; PSexception
            (# 
            do 'persistentstore.create: Failed creating "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER
            #);
          name: ^Text;
          
       enter name[]
       do (if path[] = none then
              (if (hostName,name)-&gt;createExt
               // (EXISTSERROR) then
                  name[]-&gt;exists; 
               // (CREATIONERRORERROR) then
                  name[]-&gt;creationError
               else
                  hostName-&gt;host[]; name[]-&gt;path[]; 
              if)
           else
              name[]-&gt;alreadyOpen; 
          if);
          INNER
       #);
     
     <B>checkpoint</B><A name="persistentstore.1:checkpoint.2(40)"></A><A name="checkpoint.2(40)"></A>: assertInit (#  do setForceAOAGC; doGC;  #);
     
     <B>close</B><A name="persistentstore.1:close.2(41)"></A><A name="close.2(41)"></A>: assertInit
       (#
          danglersExists:&lt;
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill-&gt;todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue (#  do false-&gt;value; INNER #);
          
       do INNER;
          checkpoint;
          (host, path) -&gt; closeExt;
          none -&gt;path[];
          none -&gt;host[];
          
       #);
     
     <B>get</B><A name="persistentstore.1:get.2(42)"></A><A name="get.2(42)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (# 
            do 'persistentstore.get: Qua error getting "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER
            #);
          notFound:&lt; Exception
            (# 
            do 'persistentstore.get: "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER
            #);
          allowLazyFetch:&lt; BooleanValue
            (#  do THIS(persistentstore).allowLazyFetch-&gt;value; INNER #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type##)
       do (@@ theObject,((host,path,name)-&gt;getExt))-&gt;assignRef;
          (if theObject[] = none then notFound if);
          INNER
       exit theObject[]
       #);
     <B>ALREADYTHEREERROR</B><A name="persistentstore.1:ALREADYTHEREERROR.2(43)"></A><A name="ALREADYTHEREERROR.2(43)"></A>: (#  exit 6 #);
     <B>HASOVERWRITTENERROR</B><A name="persistentstore.1:HASOVERWRITTENERROR.2(44)"></A><A name="HASOVERWRITTENERROR.2(44)"></A>: (#  exit 7 #);
     <B>put</B><A name="persistentstore.1:put.2(45)"></A><A name="put.2(45)"></A>: assertInit
       (#
          AlreadyThere:&lt; PSexception
            (# 
            do 'persistentstore.put: Root "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               'already there.'-&gt;msg.puttext;
               true-&gt;continue;
               INNER
            #);
          HasOverWritten:&lt; PSexception
            (# 
            do 'persistentstore.put: Root "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" '-&gt;msg.putText;
               'will overwrite an already existing root with same name at checkpoint time.'
                 -&gt;msg.puttext;
               true-&gt;continue;
               INNER
            #);
          dooverwrite:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       do (%getLongAt (@@ obj))-&gt;forceObjectToAOA;
          doGC;
          (if ((dooverwrite,host,path,name,(%getLongAt (@@ obj)))-&gt;putExt)
           // (ALREADYTHEREERROR) then
              AlreadyThere; (if dooverwrite then HasOverWritten if)
          if);
          INNER
       #);
     <B>scanRootNames</B><A name="persistentstore.1:scanRootNames.2(46)"></A><A name="scanRootNames.2(46)"></A>: assertInit (# current: ^Text;  do INNER #);
     <B>registerSpecialObject</B><A name="persistentstore.1:registerSpecialObject.2(47)"></A><A name="registerSpecialObject.2(47)"></A>: assertInit
       (#
          alreadyThere:&lt; Exception
            (# 
            do 'registerSpecialObject: Special object "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '" already exists: '-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type##)
       do 'registerSpecialObject: Registering of special objects and instances'-&gt; screen.putLine;
          'is implemented differently in the new persistence implementation.'-&gt; screen.putLine;
          'This call has no effect, and should be removed.' -&gt; screen.putLine;
          INNER
       #);
     <B>registerRuntimeType</B><A name="persistentstore.1:registerRuntimeType.2(48)"></A><A name="registerRuntimeType.2(48)"></A>: assertInit
       (# type: ##Object enter type## 
       do 'registerRuntimeType: This function is not implemented in the new'
            -&gt; screen.putLine;
          'persistent store, and the call should be removed.' -&gt; screen.putLine;
          
       #);
     <B>allowLazyFetch</B><A name="persistentstore.1:allowLazyFetch.2(49)"></A><A name="allowLazyFetch.2(49)"></A>:&lt; BooleanValue;
     <B>maxCountOnDanglerHit</B><A name="persistentstore.1:maxCountOnDanglerHit.2(50)"></A><A name="maxCountOnDanglerHit.2(50)"></A>:&lt; IntegerValue (#  do 100-&gt;value; INNER #);
     <B>OnDanglerHit</B><A name="persistentstore.1:OnDanglerHit.2(51)"></A><A name="OnDanglerHit.2(51)"></A>:&lt; Object;
     <B>AfterDanglerHit</B><A name="persistentstore.1:AfterDanglerHit.2(52)"></A><A name="AfterDanglerHit.2(52)"></A>:&lt;(# theObject: ^Object;  enter theObject[] do INNER #);
     <B>openpstore</B><A name="persistentstore.1:openpstore.2(53)"></A><A name="openpstore.2(53)"></A>:&lt;
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     <B>deletePersistentStore</B><A name="persistentstore.1:deletePersistentStore.2(54)"></A><A name="deletePersistentStore.2(54)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.delete: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" is currently open'-&gt;msg.putText;
               INNER ;
               
            #);
          accessError:&lt; PSexception
            (# 
            do 'persistetstore.delete: Unable to delete "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER ;
               
            #);
          notFound:&lt; PSexception
            (# 
            do 'persistetstore.delete: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER ;
               
            #);
          name: ^Text;
          storeDir: @directory; 
          
       enter name[]
       do assertOpen
          (# do path[] -&gt; storeDir.name;
             storeDir.delete
             (# 
                nosuch:: (# do PSexception
                            (# do 'delete error: ' -&gt; msg.putText;
                               path[] -&gt; msg.putText;
                               ' does not exist' -&gt; msg.putText;
                               true -&gt; continue;
                            #);
                         #);
                
                error:: (# do PSexception
                           (# do 'delete error: ' -&gt; msg.putText;
                              path[] -&gt; msg.putText;
                              ' could not be deleted (unknown error)' -&gt; msg.putText;
                              true -&gt; continue;
                           #);
                        #);
             #);
          #);
       #);
     <B>registerSpecialInstance</B><A name="persistentstore.1:registerSpecialInstance.2(55)"></A><A name="registerSpecialInstance.2(55)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (# 
            do 'registerSpecialInstance: Qua error on "'-&gt;msg.putText;
               tag-&gt;msg.putInt;
               '" instance'-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          notFound:&lt; Exception
            (# 
            do 'registerSpecialInstance: Special object "'-&gt;msg.putText;
               tag-&gt;msg.putInt;
               '" not registered.'-&gt;msg.putText;
               INNER ;
               false-&gt;continue;
               
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
       enter (o[],tag)
       do (if tag &lt; 256 then
              (tag,%getLongAt (@@ o))-&gt;markSpecialObject;
           else
              PSexception
              (# do 'registerSpecialInstance: ' -&gt; msg.putText;
                 ' tag (' -&gt; msg.putText;
                 tag -&gt; msg.putInt;
                 ') must be less than 256' -&gt; msg.putText;
                 false -&gt; continue;
              #);
          if);
       #);
  do INNER ; 
  #);
<B>deletePersistentStore</B><A name="deletePersistentStore.1(56)"></A>:
  (#
     <B>alreadyOpen</B><A name="deletePersistentStore.1:alreadyOpen.2(57)"></A><A name="alreadyOpen.2(57)"></A>:&lt; PSexception(# do INNER #);
     <B>accessError</B><A name="deletePersistentStore.1:accessError.2(58)"></A><A name="accessError.2(58)"></A>:&lt; PSexception(# do INNER #);
     <B>notFound</B><A name="deletePersistentStore.1:notFound.2(59)"></A><A name="notFound.2(59)"></A>:&lt; PSexception(# do INNER #);
     <B>name</B><A name="deletePersistentStore.1:name.2(60)"></A><A name="name.2(60)"></A>: ^Text;
     
  enter name[]
  do PSexception
     (# do 'delete error: deletePersistentStore has been moved' -&gt;msg.putLine;
        'to reside within the persistentstore pattern.' -&gt;msg.putLine;
        'See the gcdemo demo for further details.' -&gt; msg.putLine;
        false -&gt; continue;
     #);
  #);

<B>PSexception</B><A name="PSexception.1(61)"></A>: exception (# <B>fullName</B><A name="PSexception.1:fullName.2(62)"></A><A name="fullName.2(62)"></A>: ^Text;  enter fullName[] do INNER #)
</PRE>


</BODY>
</HTML><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<H1>Index of Identifiers</A><A name="Index.identifiers"></H1>
<PRE CLASS=interface>
</PRE>
<HR>
<STRONG><A HREF="#_A">A</A></STRONG> &nbsp; 
<STRONG CLASS=disabled>B</STRONG> &nbsp; 
<STRONG><A HREF="#_C">C</A></STRONG> &nbsp; 
<STRONG><A HREF="#_D">D</A></STRONG> &nbsp; 
<STRONG><A HREF="#_E">E</A></STRONG> &nbsp; 
<STRONG><A HREF="#_F">F</A></STRONG> &nbsp; 
<STRONG><A HREF="#_G">G</A></STRONG> &nbsp; 
<STRONG><A HREF="#_H">H</A></STRONG> &nbsp; 
<STRONG><A HREF="#_I">I</A></STRONG> &nbsp; 
<STRONG CLASS=disabled>J</STRONG> &nbsp; 
<STRONG CLASS=disabled>K</STRONG> &nbsp; 
<STRONG><A HREF="#_L">L</A></STRONG> &nbsp; 
<STRONG><A HREF="#_M">M</A></STRONG> &nbsp; 
<STRONG><A HREF="#_N">N</A></STRONG> &nbsp; 
<STRONG><A HREF="#_O">O</A></STRONG> &nbsp; 
<STRONG><A HREF="#_P">P</A></STRONG> &nbsp; 
<STRONG CLASS=disabled>Q</STRONG> &nbsp; 
<STRONG><A HREF="#_R">R</A></STRONG> &nbsp; 
<STRONG><A HREF="#_S">S</A></STRONG> &nbsp; 
<STRONG CLASS=disabled>T</STRONG> &nbsp; 
<STRONG><A HREF="#_U">U</A></STRONG> &nbsp; 
<STRONG CLASS=disabled>V</STRONG> &nbsp; 
<STRONG CLASS=disabled>W</STRONG> &nbsp; 
<STRONG CLASS=disabled>X</STRONG> &nbsp; 
<STRONG CLASS=disabled>Y</STRONG> &nbsp; 
<STRONG CLASS=disabled>Z</STRONG> &nbsp; 
<HR>
<P></P>
<PRE CLASS=interface>
</PRE><H2><A name="_A">A</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#accessError.2(58)">accessError</A>
  <A href="persistentstore.html#ACCESSERRORERROR.2(21)">ACCESSERRORERROR</A>
  <A href="persistentstore.html#AfterDanglerHit.2(52)">AfterDanglerHit</A>
  <A href="persistentstore.html#allowLazyFetch.2(49)">allowLazyFetch</A>
  <A href="persistentstore.html#alreadyOpen.2(57)">alreadyOpen</A>
  <A href="persistentstore.html#ALREADYOPENERROR.2(23)">ALREADYOPENERROR</A>
  <A href="persistentstore.html#ALREADYTHEREERROR.2(43)">ALREADYTHEREERROR</A>
  <A href="persistentstore.html#assertInit.2(10)">assertInit</A>
  <A href="persistentstore.html#assertOpen.2(9)">assertOpen</A></PRE><H2><A name="_C">C</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#callOpenCrossStore.2(31)">callOpenCrossStore</A>
  <A href="persistentstore.html#callRebinder.2(30)">callRebinder</A>
  <A href="persistentstore.html#checkpoint.2(40)">checkpoint</A>
  <A href="persistentstore.html#close.2(41)">close</A>
  <A href="persistentstore.html#closeExt.2(19)">closeExt</A>
  <A href="persistentstore.html#commit.2(34)">commit</A>
  <A href="persistentstore.html#create.2(39)">create</A>
  <A href="persistentstore.html#createExt.2(18)">createExt</A>
  <A href="persistentstore.html#CREATIONERRORERROR.2(25)">CREATIONERRORERROR</A></PRE><H2><A name="_D">D</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#deletePersistentStore.1(56)">deletePersistentStore</A>
    <A href="persistentstore.html#deletePersistentStore.1:accessError.2(58)">accessError</A>
    <A href="persistentstore.html#deletePersistentStore.1:alreadyOpen.2(57)">alreadyOpen</A>
    <A href="persistentstore.html#deletePersistentStore.1:name.2(60)">name</A>
    <A href="persistentstore.html#deletePersistentStore.1:notFound.2(59)">notFound</A>
  <A href="persistentstore.html#deletePersistentStore.2(54)">deletePersistentStore</A></PRE><H2><A name="_E">E</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#EXISTSERROR.2(24)">EXISTSERROR</A></PRE><H2><A name="_F">F</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#forceObjectToAOA.2(14)">forceObjectToAOA</A>
  <A href="persistentstore.html#fullName.2(62)">fullName</A></PRE><H2><A name="_G">G</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#get.2(42)">get</A>
  <A href="persistentstore.html#getExt.2(20)">getExt</A>
  <A href="persistentstore.html#getNumberOfUpdates.2(15)">getNumberOfUpdates</A></PRE><H2><A name="_H">H</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#HASOVERWRITTENERROR.2(44)">HASOVERWRITTENERROR</A>
  <A href="persistentstore.html#host.2(2)">host</A>
  <A href="persistentstore.html#hostName.2(6)">hostName</A></PRE><H2><A name="_I">I</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#init.2(29)">init</A></PRE><H2><A name="_L">L</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#lastupdate.2(5)">lastupdate</A></PRE><H2><A name="_M">M</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#markSpecialObject.2(11)">markSpecialObject</A>
  <A href="persistentstore.html#maxCountOnDanglerHit.2(50)">maxCountOnDanglerHit</A></PRE><H2><A name="_N">N</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#name.2(60)">name</A>
  <A href="persistentstore.html#notFound.2(59)">notFound</A>
  <A href="persistentstore.html#NOTFOUNDERROR.2(22)">NOTFOUNDERROR</A>
  <A href="persistentstore.html#numberOfUpdates.2(4)">numberOfUpdates</A></PRE><H2><A name="_O">O</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#OnDanglerHit.2(51)">OnDanglerHit</A>
  <A href="persistentstore.html#open.2(36)">open</A>
  <A href="persistentstore.html#openCrossStoreItem.2(8)">openCrossStoreItem</A>
  <A href="persistentstore.html#openpstore.2(53)">openpstore</A>
  <A href="persistentstore.html#openRead.2(37)">openRead</A>
  <A href="persistentstore.html#openReadExt.2(16)">openReadExt</A>
  <A href="persistentstore.html#openWrite.2(38)">openWrite</A>
  <A href="persistentstore.html#openWriteExt.2(17)">openWriteExt</A></PRE><H2><A name="_P">P</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#path.2(3)">path</A>
  <A href="persistentstore.html#persistentstore.1(1)">persistentstore</A>
    <A href="persistentstore.html#persistentstore.1:ACCESSERRORERROR.2(21)">ACCESSERRORERROR</A>
    <A href="persistentstore.html#persistentstore.1:AfterDanglerHit.2(52)">AfterDanglerHit</A>
    <A href="persistentstore.html#persistentstore.1:allowLazyFetch.2(49)">allowLazyFetch</A>
    <A href="persistentstore.html#persistentstore.1:ALREADYOPENERROR.2(23)">ALREADYOPENERROR</A>
    <A href="persistentstore.html#persistentstore.1:ALREADYTHEREERROR.2(43)">ALREADYTHEREERROR</A>
    <A href="persistentstore.html#persistentstore.1:assertInit.2(10)">assertInit</A>
    <A href="persistentstore.html#persistentstore.1:assertOpen.2(9)">assertOpen</A>
    <A href="persistentstore.html#persistentstore.1:callOpenCrossStore.2(31)">callOpenCrossStore</A>
    <A href="persistentstore.html#persistentstore.1:callRebinder.2(30)">callRebinder</A>
    <A href="persistentstore.html#persistentstore.1:checkpoint.2(40)">checkpoint</A>
    <A href="persistentstore.html#persistentstore.1:close.2(41)">close</A>
    <A href="persistentstore.html#persistentstore.1:closeExt.2(19)">closeExt</A>
    <A href="persistentstore.html#persistentstore.1:commit.2(34)">commit</A>
    <A href="persistentstore.html#persistentstore.1:create.2(39)">create</A>
    <A href="persistentstore.html#persistentstore.1:createExt.2(18)">createExt</A>
    <A href="persistentstore.html#persistentstore.1:CREATIONERRORERROR.2(25)">CREATIONERRORERROR</A>
    <A href="persistentstore.html#persistentstore.1:deletePersistentStore.2(54)">deletePersistentStore</A>
    <A href="persistentstore.html#persistentstore.1:EXISTSERROR.2(24)">EXISTSERROR</A>
    <A href="persistentstore.html#persistentstore.1:forceObjectToAOA.2(14)">forceObjectToAOA</A>
    <A href="persistentstore.html#persistentstore.1:get.2(42)">get</A>
    <A href="persistentstore.html#persistentstore.1:getExt.2(20)">getExt</A>
    <A href="persistentstore.html#persistentstore.1:getNumberOfUpdates.2(15)">getNumberOfUpdates</A>
    <A href="persistentstore.html#persistentstore.1:HASOVERWRITTENERROR.2(44)">HASOVERWRITTENERROR</A>
    <A href="persistentstore.html#persistentstore.1:host.2(2)">host</A>
    <A href="persistentstore.html#persistentstore.1:hostName.2(6)">hostName</A>
    <A href="persistentstore.html#persistentstore.1:init.2(29)">init</A>
    <A href="persistentstore.html#persistentstore.1:lastupdate.2(5)">lastupdate</A>
    <A href="persistentstore.html#persistentstore.1:markSpecialObject.2(11)">markSpecialObject</A>
    <A href="persistentstore.html#persistentstore.1:maxCountOnDanglerHit.2(50)">maxCountOnDanglerHit</A>
    <A href="persistentstore.html#persistentstore.1:NOTFOUNDERROR.2(22)">NOTFOUNDERROR</A>
    <A href="persistentstore.html#persistentstore.1:numberOfUpdates.2(4)">numberOfUpdates</A>
    <A href="persistentstore.html#persistentstore.1:OnDanglerHit.2(51)">OnDanglerHit</A>
    <A href="persistentstore.html#persistentstore.1:open.2(36)">open</A>
    <A href="persistentstore.html#persistentstore.1:openCrossStoreItem.2(8)">openCrossStoreItem</A>
    <A href="persistentstore.html#persistentstore.1:openpstore.2(53)">openpstore</A>
    <A href="persistentstore.html#persistentstore.1:openRead.2(37)">openRead</A>
    <A href="persistentstore.html#persistentstore.1:openReadExt.2(16)">openReadExt</A>
    <A href="persistentstore.html#persistentstore.1:openWrite.2(38)">openWrite</A>
    <A href="persistentstore.html#persistentstore.1:openWriteExt.2(17)">openWriteExt</A>
    <A href="persistentstore.html#persistentstore.1:path.2(3)">path</A>
    <A href="persistentstore.html#persistentstore.1:put.2(45)">put</A>
    <A href="persistentstore.html#persistentstore.1:putExt.2(12)">putExt</A>
    <A href="persistentstore.html#persistentstore.1:rebinderItem.2(7)">rebinderItem</A>
    <A href="persistentstore.html#persistentstore.1:rebindSpecialReference.2(33)">rebindSpecialReference</A>
    <A href="persistentstore.html#persistentstore.1:reget.2(35)">reget</A>
    <A href="persistentstore.html#persistentstore.1:registerBETAENVandPROGRAM.2(28)">registerBETAENVandPROGRAM</A>
    <A href="persistentstore.html#persistentstore.1:registerOpenCrossStoreFunc.2(27)">registerOpenCrossStoreFunc</A>
    <A href="persistentstore.html#persistentstore.1:registerRebinderFunc.2(26)">registerRebinderFunc</A>
    <A href="persistentstore.html#persistentstore.1:registerRuntimeType.2(48)">registerRuntimeType</A>
    <A href="persistentstore.html#persistentstore.1:registerSpecialInstance.2(55)">registerSpecialInstance</A>
    <A href="persistentstore.html#persistentstore.1:registerSpecialObject.2(47)">registerSpecialObject</A>
    <A href="persistentstore.html#persistentstore.1:scanRootNames.2(46)">scanRootNames</A>
    <A href="persistentstore.html#persistentstore.1:setForceAOAGC.2(13)">setForceAOAGC</A>
    <A href="persistentstore.html#persistentstore.1:UNKNOWNTAG.2(32)">UNKNOWNTAG</A>
  <A href="persistentstore.html#PSexception.1(61)">PSexception</A>
    <A href="persistentstore.html#PSexception.1:fullName.2(62)">fullName</A>
  <A href="persistentstore.html#put.2(45)">put</A>
  <A href="persistentstore.html#putExt.2(12)">putExt</A></PRE><H2><A name="_R">R</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#rebinderItem.2(7)">rebinderItem</A>
  <A href="persistentstore.html#rebindSpecialReference.2(33)">rebindSpecialReference</A>
  <A href="persistentstore.html#reget.2(35)">reget</A>
  <A href="persistentstore.html#registerBETAENVandPROGRAM.2(28)">registerBETAENVandPROGRAM</A>
  <A href="persistentstore.html#registerOpenCrossStoreFunc.2(27)">registerOpenCrossStoreFunc</A>
  <A href="persistentstore.html#registerRebinderFunc.2(26)">registerRebinderFunc</A>
  <A href="persistentstore.html#registerRuntimeType.2(48)">registerRuntimeType</A>
  <A href="persistentstore.html#registerSpecialInstance.2(55)">registerSpecialInstance</A>
  <A href="persistentstore.html#registerSpecialObject.2(47)">registerSpecialObject</A></PRE><H2><A name="_S">S</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#scanRootNames.2(46)">scanRootNames</A>
  <A href="persistentstore.html#setForceAOAGC.2(13)">setForceAOAGC</A></PRE><H2><A name="_U">U</A></H2><PRE CLASS=interface>

  <A href="persistentstore.html#UNKNOWNTAG.2(32)">UNKNOWNTAG</A></PRE>



</BODY>
</HTML></BODY>
</HTML>
