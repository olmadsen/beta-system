<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Notificationmanager Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("notificationmanager");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="notificationmanager">Notificationmanager Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/distribution/basicshell';
INCLUDE 'notification'
        'samefile'
        '~beta/containers/hashTable'
        'perslib'
        '~beta/basiclib/file'
        '~beta/basiclib/directory'
        '~beta/containers/sets';
(* File notificationmanager.bet
 * ===========================
 * This file contains the interface to a notificationmanager serving
 * notification control. This file has to be included by the server, 
 * if it should provide notification control. 
 *)
-- shellEnvLib: Attributes --
<B>notificationmanagerinterface</B><A name="notificationmanagerinterface.1(190)"></A>: remoteable
  (#
     <B>subscribeNotification</B><A name="notificationmanagerinterface.1.subscribeNotification.2(191)"></A><A name="subscribeNotification.2(191)"></A>: entry
       (# theSubscription: ^subscription; 
       enter theSubscription[]
       do theSubscription[]-&gt;subscribeNotificationImpl; 
       #);
     <B>unsubscribeNotification</B><A name="notificationmanagerinterface.1.unsubscribeNotification.2(192)"></A><A name="unsubscribeNotification.2(192)"></A>: entry
       (# theSubscription: ^subscription; value: @boolean; 
       enter theSubscription[]
       do theSubscription[]-&gt;unsubscribeNotificationImpl; 
       exit value
       #);
     <B>unsubscribeAll</B><A name="notificationmanagerinterface.1.unsubscribeAll.2(193)"></A><A name="unsubscribeAll.2(193)"></A>: entry
       (# theClient: ^NPSClient; 
       enter theClient[]
       do theClient[]-&gt;unsubscribeAllImpl; 
       #);
     <B>notify</B><A name="notificationmanagerinterface.1.notify.2(194)"></A><A name="notify.2(194)"></A>: entry
       (# theNotification: ^notification; theClient: ^PSclient; 
       enter (theClient[],theNotification[])
       do (theClient[],theNotification[])-&gt;notifyImpl; 
       #);
     <B>subscribeNotificationImpl</B><A name="notificationmanagerinterface.1.subscribeNotificationImpl.2(195)"></A><A name="subscribeNotificationImpl.2(195)"></A>:&lt;
       (# theSubscription: ^subscription; 
       enter theSubscription[]
       do 'noti: A client subscribed to '-&gt;puttext;
          (if theSubscription.theEvent.type
           // create then
              'CREATE'-&gt;puttext; 
           // open then
              'OPEN'-&gt;puttext; 
           // close then
              'CLOSE'-&gt;puttext; 
           // update then
              'UPDATE'-&gt;puttext; 
           // lock then
              'LOCK'-&gt;puttext; 
           // unlock then
              'UNLOCK'-&gt;puttext; 
           // waitforlock then
              'WAITFORLOCK'-&gt;puttext; 
          if);
          INNER
       #);
     <B>unsubscribeNotificationImpl</B><A name="notificationmanagerinterface.1.unsubscribeNotificationImpl.2(196)"></A><A name="unsubscribeNotificationImpl.2(196)"></A>:&lt;
       (# theSubscription: ^subscription; value: @boolean; 
       enter theSubscription[]
       do INNER
       exit value
       #);
     <B>unsubscribeAllImpl</B><A name="notificationmanagerinterface.1.unsubscribeAllImpl.2(197)"></A><A name="unsubscribeAllImpl.2(197)"></A>:&lt;(# theClient: ^NPSclient;  enter theClient[] do INNER #);
     <B>notifyImpl</B><A name="notificationmanagerinterface.1.notifyImpl.2(198)"></A><A name="notifyImpl.2(198)"></A>:&lt;
       (# theNotification: ^notification; theClient: ^PSclient
       enter (theClient[],theNotification[])
       do (if false then
              'notificationmanager.notify: NotificationManager told to notify clients of '
                -&gt;puttext;
              (if theNotification.theEvent.type
               // create then
                  'CREATE'-&gt;putline; 
               // open then
                  'OPEN'-&gt;putline; 
               // close then
                  'CLOSE'-&gt;putline; 
               // update then
                  'UPDATE'-&gt;putline; 
               // lock then
                  'LOCK'-&gt;putline; 
               // unlock then
                  'UNLOCK'-&gt;putline; 
               // waitforlock then
                  'WAITFORLOCK'-&gt;putline; 
              if)
          if);
          INNER
       #);
     <B>init</B><A name="notificationmanagerinterface.1.init.2(199)"></A><A name="init.2(199)"></A>:&lt; (# do INNER #);
  do INNER
  #);
<B>notificationmanager</B><A name="notificationmanager.1(200)"></A>: notificationmanagerinterface
  (#
     <B>notifyImpl</B><A name="notificationmanager.1.notifyImpl.2(201)"></A><A name="notifyImpl.2(201)"></A>:: 
       (# 
       do (theClient[],theNotification[])-&gt;SubscriptionTable.sendNotifications
       #);
     <B>subscribeNotificationImpl</B><A name="notificationmanager.1.subscribeNotificationImpl.2(202)"></A><A name="subscribeNotificationImpl.2(202)"></A>:: 
       (# 
       do ' (total='-&gt;puttext;
          subscriptiontable.size+1-&gt;putint;
          ')'-&gt;putline;
          theSubscription[]-&gt;SubscriptionTable.insert
       #);
     <B>unsubscribeNotificationImpl</B><A name="notificationmanager.1.unsubscribeNotificationImpl.2(203)"></A><A name="unsubscribeNotificationImpl.2(203)"></A>:: 
       (#  do theSubscription[]-&gt;SubscriptionTable.delete-&gt;value;  #);
     <B>unsubscribeAllImpl</B><A name="notificationmanager.1.unsubscribeAllImpl.2(204)"></A><A name="unsubscribeAllImpl.2(204)"></A>:: 
       (#  do theClient[]-&gt;SubscriptionTable.deleteAllSubsMadeByClient;  #);
     ;
     <B>getNextString</B><A name="notificationmanager.1.getNextString.2(205)"></A><A name="getNextString.2(205)"></A>:
       (#
       (* soeger fra nuvaerende position og frem til og med naeste semikolon. 
        Returnerer herefter det foerste uden semikolon
        *) txtref,outtxt: ^text; start: @integer; 
       enter txtref[]
       do txtref.getpos-&gt;start;
          while:
            (# 
            do (if txtref.eos then
                   (start+1,txtref.getpos)-&gt;txtref.sub-&gt;outtxt[]; leave while
               if);
               (if txtref.get = ';' then
                   (start+1,txtref.getpos-1)-&gt;txtref.sub-&gt;outtxt[]; leave while
               if);
               restart while
            #);
          ;
          outtxt[]-&gt;chop-&gt;outtxt[];
          outtxt.reset;
          
       exit outtxt
       #);
     <B>getNextInteger</B><A name="notificationmanager.1.getNextInteger.2(206)"></A><A name="getNextInteger.2(206)"></A>:
       (# (* Kalder getNextString og konverterer resultatet til en integer *)
          txtref: ^text; outtxt: @text; result: @integer; 
       enter txtref[]
       do txtref[]-&gt;getNextString-&gt;outtxt;
          outtxt.reset;
          (if outtxt.length = 0 then
              - 1-&gt;result; 
           else
              outtxt.getint-&gt;result; 
          if);
          
       exit result
       #);
     <B>chop</B><A name="notificationmanager.1.chop.2(207)"></A><A name="chop.2(207)"></A>: (* Afskærer foran- og efterstillede mellemrum, linieskift *)
       (# t: ^text; 
       enter t[]
       do (* fjerner foranstillede mellemrum, linieskift *)
          t.reset;
          t.scan
            (# while::  (#  do (ch = '\n') or (ch = ' ')-&gt;value #) #);
          (if t.getpos &gt;= 1 then (1,t.getpos)-&gt;t.delete if);
          (* fjerner efterstillede mellemrum, linieskift *)
          t.length-&gt;t.setPos;
          loop
            (#
               while:: 
                 (# 
                 do ((t.length &gt;= 1) and
                     (((t.length-&gt;t.inxGet) = '\n') or
                      ((t.length-&gt;t.inxGet) = ' ')))-&gt;value;
                    
                 #)
            do (t.length,t.length)-&gt;t.delete; 
            #);
          
       exit t[]
       #);
     ;
     <B>SubscriptionTable</B><A name="notificationmanager.1.SubscriptionTable.2(208)"></A><A name="SubscriptionTable.2(208)"></A>: @Monitor
       (#
          scanClients: entry
            (#
               curClient: ^NPSClient;
               allClients:
               (* A client may appear more than once in theList. This
                set contains only one element per client *) @set
                 (# element:: NPSClient #)
            do private.theTable.scan
                 (#  do current.theClient[]-&gt;allClients.insert #);
               allClients.scan
                 (#  do current[]-&gt;curClient[]; INNER scanClients #)
            #);
          insert: entry
            (# theSubscription: ^subscription; 
            enter theSubscription[]
            do theSubscription[]-&gt;private.theTable.insert; private.saveinfo
            #);
          delete: entry
            (# theSubscription: ^subscription; found: @boolean; 
            enter theSubscription[]
            do false-&gt;found;
               theSubscription.theEvent.type
                 -&gt;private.theTable.scanIndexed
                   (# 
                   do (if
                      ((theSubscription.theClient[] = current.theClient[]) and
                       (current.theEvent[]-&gt;theSubscription.theEvent.match))
                       then
                          true-&gt;found; current[]-&gt;private.theTable.delete; 
                      if)
                   #);
               private.saveinfo
            exit found
            #);
          deleteAllSubsMadeByClient: entry
            (# theClient: ^NPSClient; 
            enter theClient[]
            do private.theTable.scan
                 (# 
                 do (if (theClient[] = current.theClient[]) then
                        current[]-&gt;private.theTable.delete; 
                    if);
                    
                 #);
               private.saveinfo;
               
            #);
          deleteDeadClient: entry
            (# theClient: ^NPSClient; 
            enter theClient[]
            do private.theTable.scan
                 (# 
                 do (if (theClient[] = current.theClient[]) then
                        current[]-&gt;private.theTable.delete
                    if);
                    
                 #);
               private.saveinfo
            #);
          sendNotifications: entry
            (#
               theNotification: ^notification;
               theClient: ^PSClient;
               ClientsToBeNotified: @list (# element:: NPSClient #)
            enter (theClient[],theNotification[])
            do theNotification.theEvent.type
                 -&gt;private.theTable.scanIndexed
                   (# 
                   do (if
                      ((current.theClient[] &lt;&gt; theClient[]) and
                       ((theNotification.theUser[]-&gt;current.user.equal) or
                        ('all'-&gt;current.user.equal)) and
                       (theNotification.theEvent[]-&gt;current.theEvent.match))
                       then
                          (if not
                          (current.theClient[]-&gt;ClientsToBeNotified.has) then
                              current.theClient[]-&gt;ClientsToBeNotified.append; 
                          if)
                       else
                      (* The client subscribed for the event but for some reason 
                       it should not be notified of it. *)
                          
                      if)
                   #);
               donotify: errorhandler
                 (#
                    wrongAnswer::&lt; 
                      (# 
                      do 'noti: wrongAnswer called!!! - continuing... (when notifying)'
                           -&gt;putline;
                         continue
                      #);
                    onFailure:
                      (# theError: ^error; c: ^NPSClient; 
                      enter theError[]
                      do 'Notification of client '-&gt;puttext;
                         theError.theobj[]-&gt;c[];
                         c.ri.shellAdr.astext-&gt;puttext;
                         ' failed'-&gt;putline;
                         theError.ignore;
                         
                      #);
                    connectionBroken:: 
                      (#  do THIS(connectionBroken)[]-&gt;onFailure #);
                    connectionFailed:: 
                      (#  do THIS(connectionFailed)[]-&gt;onFailure #);
                    timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
                    timeOutValue::  (#  do 2-&gt;sec #)
                 do ClientsToBeNotified.scan
                      (# 
                      do '-----------------&gt; notifying client'-&gt;putline;
                         theNotification[]-&gt;current.notify
                      #);
                    ClientstoBeNotified.clear
                 #)
            #);
          display: entry
            (# 
            do 'Subscriptions stored:'-&gt;putline;
               private.theTable.scan
                 (#  do '------------'-&gt;putline; current.display;  #)
            #);
          size: entry (#  exit private.theTable.size #);
          save: entry (#  do private.saveinfo #);
          load: entry (#  do private.loadinfo #);
          ;
          private: @
            (#
               theTable: @hashtable
                 (#
                    element:: subscription;
                    hashfunction::&lt;  (#  do e.theEvent.type-&gt;value #);
                    rangeInitial::&lt;  (#  do 6-&gt;value #);
                 #);
               filename: (#  exit 'datafiles/subscriptions.txt' #);
               saveinfo:
                 (# outFile: @file
                 do filename-&gt;outFile.name;
                    outFile.openwrite;
                    theTable.scan
                      (# aPSEvent: ^PSevent
                      do current.theEvent[]-&gt;aPSevent[];
                         ;
                         clientHostname:
                           (# 
                           do myErrorHandler
                                (# theEnsemble: ^ensemble
                                do current.theClient.getMyEnsemble
                                     -&gt;theEnsemble[];
                                   (if theEnsemble[] &lt;&gt; none then
                                       theEnsemble.hostname[]-&gt;outFile.puttext
                                    else
                                       'Noti.subscriptionTable.saveinfo: getMyEnsemble returned none!'
                                         -&gt;putline;
                                       'DefaultHostname'-&gt;outFile.puttext
                                   if)
                                #)
                           #);
                         ';'-&gt;outFile.put;
                         current.theClient.ri.shellAdr.astext-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         aPSevent.theinfo.psname.copy-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         aPSevent.type-&gt;outFile.putint;
                         ';'-&gt;outFile.put;
                         current.user.copy-&gt;outFile.putline
                      #);
                    outFile.close
                 #);
               loadinfo:
                 (#
                    inFile: @file;
                    hasInformedUser:
                    (* If there are items to recover, then the user should be notified - but
                     only once! *) @boolean
                 do filename-&gt;inFile.name;
                    inFile.touch (* to assure that a file _exists_.*) ;
                    inFile.openread;
                    loop
                      (#
                         while::  (#  do (not inFile.eos)-&gt;value;  #);
                         tmptext: ^text;
                         newSubscription: ^subscription;
                         aPSevent: ^PSevent;
                         hostname,shellAddress,pstorename,user: @text;
                         eventType: @integer
                      do (if not hasInformedUser then
                             'The notification manager will try to recover from the crash...'
                               -&gt;putline;
                             true-&gt;hasInformedUser
                         if);
                         inFile.getline-&gt;tmptext[];
                         ;
                         tmptext.reset;
                         tmptext[]-&gt;getNextString-&gt;hostname;
                         tmptext[]-&gt;getNextString-&gt;shellAddress;
                         tmptext[]-&gt;getNextString-&gt;pstorename;
                         tmptext[]-&gt;getNextInteger-&gt;eventType;
                         tmptext[]-&gt;getNextString-&gt;user;
                         ;
                         (if not ('DefaultHostname'-&gt;hostname.equalNCS) then
                             &amp;subscription[]-&gt;newSubscription[];
                             setup_event:
                               (# 
                               do &amp;PSevent[]-&gt;aPSevent[]
                                    -&gt;newSubscription.theEvent[];
                                  pstorename.copy-&gt;aPSevent.theinfo.psname[];
                                  eventType-&gt;newSubscription.theEvent.type
                               #);
                             setup_user:
                               (#  do user.copy-&gt;newSubscription.user[] #);
                             setup_client:
                               (#
                                  theClient: ^NPSclient;
                                  clientensemble: ^ensemble
                               do (ensemble##,hostname.copy)
                                    -&gt;theShell.myEnsemble.ns.get
                                      (#
                                         notFound:: 
                                           (# 
                                           do 'Ensemble not found.'
                                                -&gt;screen.putText
                                           #)
                                      #)-&gt;clientEnsemble[];
                                  (NPSclient##,shellAddress.copy)
                                    -&gt;clientensemble.ns.get
                                      (#
                                      (* notFound:: 
                                       (# 
                                       do 'Client not found '-&gt;screen.putText; 
                                       #) *) 
                                      #)-&gt;theClient[];
                                  (if theClient[] = none then
                                      ' =&gt; Client not found - is deleted'
                                        -&gt;putline
                                   else
                                      ' =&gt; Client found - subscription recovered'
                                        -&gt;putline;
                                      theClient[]-&gt;newSubscription.theClient[];
                                      newSubscription[]-&gt;theTable.insert
                                  if)
                               #)
                          else
                             'Default host name!'-&gt;putline; 
                         if)
                      #)
                 #)
            #);
          init::  (#  do private.theTable.init #)
       #);
     ;
     <B>myErrorHandler</B><A name="notificationmanager.1.myErrorHandler.2(209)"></A><A name="myErrorHandler.2(209)"></A>: errorhandler
       (#
          wrongAnswer::&lt; 
            (# 
            do 'noti: wrongAnswer called!!! - continuing...'-&gt;putline; continue
            #);
          onFailure:&lt;
            (# theError: ^error; 
            enter theError[]
            do INNER onFailure;
               (if theError.theObj## &lt;= NPSClient## then
               (* Get rid of the failing Client. *)
                   theError.ignore
                else
                   theError.abort; 
               if);
               
            #);
          connectionBroken::  (#  do THIS(connectionBroken)[]-&gt;onFailure #);
          connectionFailed::  (#  do THIS(connectionFailed)[]-&gt;onFailure #);
          timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
          timeOutValue::  (#  do 1-&gt;sec #)
       do INNER
       #);
     ;
     <B>getRidOfFailingClients</B><A name="notificationmanager.1.getRidOfFailingClients.2(210)"></A><A name="getRidOfFailingClients.2(210)"></A>: @|System
       (#
          noOfFailuresRequired:
          (* how many failed pings before a client should be deleted? *)
            (#  exit 10 #)
       do FailingClients.init;
          Cycle
            (# 
            do 6-&gt;sleep;
               failingClients.scanClients
                 (#  do false-&gt;curElement.failedAtThisPing #);
               subscriptionTable.scanClients
                 (# 
                 do myerrorhandler
                      (#
                         onFailure:: 
                           (# 
                           do (if theError.theObj## &lt;= PSClient## then
                                  theError.theObj[]
                                    -&gt;
                                      FailingClients.insert
                                      (* Get rid of the failing Client. *)
                              if)
                           #)
                      do curClient.ping
                      #)
                 #);
               FailingClients.scanClients
                 (# 
                 do (if curElement.failedAtThisPing then
                        curElement.noOfFailures+1-&gt;curElement.noOfFailures;
                        write_warning_on_screen:
                          (# 
                          do 'noti: Client not responding: '-&gt;puttext;
                             curElement.client.ri.shellAdr.astext-&gt;puttext;
                             ' ('-&gt;puttext;
                             curElement.noOfFailures-&gt;putint;
                             ':'-&gt;put;
                             noOfFailuresRequired-&gt;putint;
                             ').'-&gt;putline
                          #)
                     else
                        0-&gt;curElement.noOfFailures
                    if);
                    (if curElement.noOfFailures &gt;= noOfFailuresRequired then
                        'noti: DELETING DEAD CLIENT!! '-&gt;puttext;
                        curElement.client.ri.shellAdr.astext-&gt;putline;
                        curElement[]-&gt;FailingClients.theList.at
                          -&gt;FailingClients.theList.delete;
                        curElement.client[]-&gt;SubscriptionTable.deleteDeadClient
                    if)
                 #)
            #)
       #);
     <B>FailingClients</B><A name="notificationmanager.1.FailingClients.2(211)"></A><A name="FailingClients.2(211)"></A>: @Monitor
       (#
          insert: entry
            (# theClient: ^PSClient; theListElement: ^listElement
            enter theClient[]
            do theList.find
                 (#
                    predicate:: 
                      (#  do (current.client[] = theClient[])-&gt;value #)
                 #)-&gt;theListElement[];
               (if theListElement[] = none then
               (* the client has never failed before. It is inserte once and for all. *)
                   make_new_element:
                     (# 
                     do &amp;listElement[]-&gt;theListElement[];
                        theClient[]-&gt;theListElement.client[];
                        0-&gt;theListElement.noOfFailures;
                        false-&gt;theListElement.failedAtThisPing
                     #);
                   theListElement[]-&gt;theList.append
               if);
               true-&gt;theListElement.failedAtThisPing
            #);
          scanClients: entry
            (# curElement: ^listElement; 
            do theList.scan
                 (#  do current[]-&gt;curElement[]; INNER scanClients #);
               
            #);
          clear: entry (#  do theList.clear;  #);
          ;
          listElement:
            (#
               client: ^NPSClient;
               noOfFailures: @integer;
               failedAtThisPing: @boolean
            #);
          theList: @list (# element:: listElement #);
          init::  (#  do theList.init #)
       #);
     ;
     <B>init</B><A name="notificationmanager.1.init.2(212)"></A><A name="init.2(212)"></A>:: 
       (#
          createDirectory:
          (* Skaber directoriet path. Det antages, at path i forvejen eksisterer
           i hvert fald ind til naest-dybeste niveau, saadan, at der her hoejst skal 
           skabes ét directory. *)
            (# theDirectory: @directory; thePath: ^text
            enter thePath[]
            do thePath[]-&gt;theDirectory.name; theDirectory.touch
            #);
          clientensemble: ^ensemble
       do SubscriptionTable.init;
          ;
          subscriptionTable.load;
          subscriptionTable.save;
          ;
          'The notification manager has been started.'-&gt;screen.putline;
          (if false then getRidOfFailingClients[]-&gt;fork if)
       #)
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Notificationmanager Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
