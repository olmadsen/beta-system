<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Lockmanager Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("lockmanager");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="lockmanager">Lockmanager Interface</A></H1>

<PRE CLASS=interface>
(* File lockmanager.bet
 * ====================
 * This file contains the interface to a lockmanager serving
 * concurrency control.
 * This file is included by the file serverinterface.bet, because
 * every server starts a lockmanager.
 *)
ORIGIN '~beta/distribution/basicshell';
INCLUDE 'clientinterface'
        'samefile'
        'perslib'
        'sharedpsnotifications'
        'lockmanagerinterface'
        '~beta/basiclib/file'
        '~beta/basiclib/directory'
        '~beta/containers/sets';
-- shellEnvLib: Attributes --
<B>pStoreStatus</B><A name="pStoreStatus.1(132)"></A>:
  (#
     <B>pStoreName</B><A name="pStoreStatus.1.pStoreName.2(133)"></A><A name="pStoreName.2(133)"></A>: ^text;
     <B>lockingClient</B><A name="pStoreStatus.1.lockingClient.2(134)"></A><A name="lockingClient.2(134)"></A>: ^PSClient;
     <B>LockMode</B><A name="pStoreStatus.1.LockMode.2(135)"></A><A name="LockMode.2(135)"></A>: @integer;
     <B>LockPolicy</B><A name="pStoreStatus.1.LockPolicy.2(136)"></A><A name="LockPolicy.2(136)"></A>: @integer;
     <B>priority</B><A name="pStoreStatus.1.priority.2(137)"></A><A name="priority.2(137)"></A>: @integer;
     <B>hostname</B><A name="pStoreStatus.1.hostname.2(138)"></A><A name="hostname.2(138)"></A>: ^text
  #);
<B>MRSWinfo</B><A name="MRSWinfo.1(139)"></A>:
  (# <B>name</B><A name="MRSWinfo.1.name.2(140)"></A><A name="name.2(140)"></A>: ^text; <B>lockingClient</B><A name="MRSWinfo.1.lockingClient.2(141)"></A><A name="lockingClient.2(141)"></A>: ^PSClient; <B>LockMode</B><A name="MRSWinfo.1.LockMode.2(142)"></A><A name="LockMode.2(142)"></A>: @integer;  #);
<B>clientinfo</B><A name="clientinfo.1(143)"></A>: (# <B>theclient</B><A name="clientinfo.1.theclient.2(144)"></A><A name="theclient.2(144)"></A>: ^PSclient; <B>name</B><A name="clientinfo.1.name.2(145)"></A><A name="name.2(145)"></A>: ^text; <B>hostname</B><A name="clientinfo.1.hostname.2(146)"></A><A name="hostname.2(146)"></A>: ^text;  #);
<B>lockmanager</B><A name="lockmanager.1(147)"></A>: lockmanagerinterface
  (#
     <B>connectImpl</B><A name="lockmanager.1.connectImpl.2(148)"></A><A name="connectImpl.2(148)"></A>:: 
       (# 
       do 'lock: Client connecting...'-&gt;puttext;
          (theClient[],name[])-&gt;clientList.insert-&gt;value;
          (if value then theClient.registerClient if);
          ' done'-&gt;putline
       #);
     <B>disconnectImpl</B><A name="lockmanager.1.disconnectImpl.2(149)"></A><A name="disconnectImpl.2(149)"></A>:: 
       (# 
       do 'lock: Client disconnecting...'-&gt;puttext;
          (theClient[],name[])-&gt;clientList.delete;
          ' done'-&gt;putline
       #);
     <B>getLockImpl</B><A name="lockmanager.1.getLockImpl.2(150)"></A><A name="getLockImpl.2(150)"></A>:: 
       (# 
       do 'lock: Request for lock...'-&gt;puttext;
          (name[],theClient[],username[],lockmode,lockpolicy)
            -&gt;pStoreTable.getlock-&gt;value;
          (if value then ' granted'-&gt;putline else ' NOT granted'-&gt;putline if)
       #);
     <B>MRSWgetLockImpl</B><A name="lockmanager.1.MRSWgetLockImpl.2(151)"></A><A name="MRSWgetLockImpl.2(151)"></A>:: 
       (# 
       do 'lock: Request for lock...'-&gt;puttext;
          (name[],theClient[],lockmode)-&gt;MRSWTable.getlock;
          ' done'-&gt;putline
       #);
     <B>MRSWreleaseLockImpl</B><A name="lockmanager.1.MRSWreleaseLockImpl.2(152)"></A><A name="MRSWreleaseLockImpl.2(152)"></A>:: 
       (# 
       do 'lock: Releasing lock...'-&gt;puttext;
          (theClient[],name[])-&gt;MRSWTable.releaselock;
          ' done'-&gt;putline
       #);
     <B>releaseLockImpl</B><A name="lockmanager.1.releaseLockImpl.2(153)"></A><A name="releaseLockImpl.2(153)"></A>:: 
       (# 
       do 'lock: Releasing lock...'-&gt;puttext;
          (theClient[],name[])-&gt;pStoreTable.releaselock;
          ' done'-&gt;putline
       #);
     <B>deleteLockRequestImpl</B><A name="lockmanager.1.deleteLockRequestImpl.2(154)"></A><A name="deleteLockRequestImpl.2(154)"></A>:: 
       (#  do (theClient[],name[])-&gt;pStoreTable.deleteLockRequest;  #);
     <B>getPermissiontoDeletePSImpl</B><A name="lockmanager.1.getPermissiontoDeletePSImpl.2(155)"></A><A name="getPermissiontoDeletePSImpl.2(155)"></A>:: 
       (#  do name[]-&gt;clientList.GetpermissiontoDeletePS-&gt;ok;  #);
     ;
     <B>getNextString</B><A name="lockmanager.1.getNextString.2(156)"></A><A name="getNextString.2(156)"></A>:
       (#
       (* soeger fra nuvaerende position og frem til og med naeste semikolon. 
        Returnerer herefter det foerste uden semikolon
        *) txtref,outtxt: ^text; start: @integer; 
       enter txtref[]
       do txtref.getpos-&gt;start;
          while:
            (# 
            do (if txtref.eos then
                   (start+1,txtref.getpos)-&gt;txtref.sub-&gt;outtxt[]; leave while
               if);
               (if txtref.get = ';' then
                   (start+1,txtref.getpos-1)-&gt;txtref.sub-&gt;outtxt[]; leave while
               if);
               restart while
            #);
          ;
          outtxt[]-&gt;chop-&gt;outtxt[];
          outtxt.reset;
          
       exit outtxt
       #);
     <B>getNextInteger</B><A name="lockmanager.1.getNextInteger.2(157)"></A><A name="getNextInteger.2(157)"></A>:
       (# (* Kalder getNextString og konverterer resultatet til en integer *)
          txtref: ^text; outtxt: @text; result: @integer; 
       enter txtref[]
       do txtref[]-&gt;getNextString-&gt;outtxt;
          outtxt.reset;
          (if outtxt.length = 0 then
              - 1-&gt;result; 
           else
              outtxt.getint-&gt;result; 
          if);
          
       exit result
       #);
     <B>chop</B><A name="lockmanager.1.chop.2(158)"></A><A name="chop.2(158)"></A>: (* Afskærer foran- og efterstillede mellemrum, linieskift *)
       (# t: ^text; 
       enter t[]
       do (* fjerner foranstillede mellemrum, linieskift *)
          t.reset;
          t.scan
            (# while::  (#  do (ch = '\n') or (ch = ' ')-&gt;value #) #);
          (if t.getpos &gt;= 1 then (1,t.getpos)-&gt;t.delete if);
          (* fjerner efterstillede mellemrum, linieskift *)
          t.length-&gt;t.setPos;
          loop
            (#
               while:: 
                 (# 
                 do ((t.length &gt;= 1) and
                     (((t.length-&gt;t.inxGet) = '\n') or
                      ((t.length-&gt;t.inxGet) = ' ')))-&gt;value;
                    
                 #)
            do (t.length,t.length)-&gt;t.delete; 
            #);
          
       exit t[]
       #);
     ;
     <B>notificationServer</B><A name="lockmanager.1.notificationServer.2(159)"></A><A name="notificationServer.2(159)"></A>: ^notificationmanager;
     <B>nm</B><A name="lockmanager.1.nm.2(160)"></A><A name="nm.2(160)"></A>: ^notificationmanagement;
     ;
     <B>myErrorHandler</B><A name="lockmanager.1.myErrorHandler.2(161)"></A><A name="myErrorHandler.2(161)"></A>: errorhandler
       (#
          wrongAnswer::&lt; 
            (# 
            do 'lock: wrongAnswer called!!! - continuing...'-&gt;putline; continue
            #);
          onFailure:&lt;
            (# theError: ^error; 
            enter theError[]
            do INNER onFailure;
               (if theError.theObj## &lt;= PSClient## then
               (* Get rid of the failing Client. *)
                   theError.theObj[]-&gt;FailingClients.insert; theError.ignore
                else
                   theError.abort; 
               if)
            #);
          connectionBroken::  (#  do THIS(connectionBroken)[]-&gt;onFailure #);
          connectionFailed::  (#  do THIS(connectionFailed)[]-&gt;onFailure #);
          timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
          timeOutValue::  (#  do 1-&gt;sec #)
       do INNER
       #);
     ;
     <B>clientList</B><A name="lockmanager.1.clientList.2(162)"></A><A name="clientList.2(162)"></A>: @Monitor
       (#
          scanClients: entry
            (#
               curClient: ^PSClient;
               allClients:
               (* A client may appear more than once in theList. This
                set contains only one element per client *) @set
                 (# element:: PSclient #)
            do private.theList.scan
                 (#  do current.theClient[]-&gt;allClients.insert #);
               allClients.scan
                 (#  do current[]-&gt;curClient[]; INNER scanClients #)
            #);
          scanClientInfos: entry
            (# current: ^clientinfo
            do private.thelist.scan
                 (# 
                 do (if current[] = none then 'NONE'-&gt;putline if);
                    current[]-&gt;THIS(scanClientInfos).current[];
                    INNER scanClientInfos
                 #)
            #);
          getpermissiontoDeletePS: entry
            (# name: ^text; ok: @boolean; 
            enter name[]
            do true-&gt;ok;
               doscan: private.theList.scan
                 (# 
                 do (if (current.name[],name[])-&gt;sameFile then
                        false-&gt;ok; leave doscan; 
                    if)
                 #)
            exit ok
            #);
          append: entry
            (# elme: ^clientinfo; 
            enter elme[]
            do elme[]-&gt;private.theList.append
            #);
          insert: entry
            (#
               theClient: ^PSclient;
               name: ^text;
               newclientinfo: ^clientinfo;
               ok: @boolean
            enter (theClient[],name[])
            do L:
                 (# 
                 do true-&gt;ok;
                    private.theList.scan
                      (# 
                      do (if
                         ((current.theclient[] = theClient[]) and
                          ((current.name[],name[])-&gt;sameFile)) then
                             false-&gt;ok; leave L; 
                         if)
                      #);
                    (if ok then
                        &amp;clientinfo[]-&gt;newclientinfo[];
                        theclient[]-&gt;newclientinfo.theclient[];
                        name.copy-&gt;newclientinfo.name[];
                        myErrorHandler
                          (# theEnsemble: ^ensemble
                          do theClient.getMyEnsemble-&gt;theEnsemble[];
                             (if theEnsemble[] &lt;&gt; none then
                                 theEnsemble.hostname.copy
                                   -&gt;newClientInfo.hostname[]
                              else
                                 'lock:clientlist.insert: getMyEnsemble returned none!'
                                   -&gt;putline;
                                 'DEFAULT'-&gt;newClientInfo.hostname[]
                             if)
                          #);
                        newclientinfo[]-&gt;private.theList.append;
                        private.saveinfo
                    if);
                    
                 #)
            exit ok
            #);
          delete: entry
            (# theClient: ^PSclient; name: ^text; 
            enter (theClient[],name[])
            do L:
                 (# 
                 do private.theList.scan
                      (# 
                      do (if
                         ((current.theclient[] = theClient[]) and
                          ((current.name[],name[])-&gt;sameFile)) then
                             current[]-&gt;private.theList.at
                               -&gt;private.theList.delete;
                             private.saveinfo;
                             leave L
                         if)
                      #)
                 #)
            #);
          deleteDeadClient: entry
            (# theClient: ^PSclient; 
            enter theClient[]
            do private.theList.scan
                 (# 
                 do (if (current.theclient[] = theClient[]) then
                        current[]-&gt;private.theList.at-&gt;private.theList.delete
                    if)
                 #);
               private.saveinfo
            #);
          display: entry
            (# 
            do 'Client information:'-&gt;putline;
               private.theList.scan
                 (# 
                 do current.theClient.ri.shellAdr.astext-&gt;puttext;
                    ' running on '-&gt;puttext;
                    myErrorHandler
                      (# theEnsemble: ^ensemble
                      do current.theclient.getMyEnsemble-&gt;theEnsemble[];
                         (if theEnsemble[] &lt;&gt; none then
                             theEnsemble.hostname.copy-&gt;puttext
                          else
                             'lock:clientlist.display: getMyEnsemble returned none!'
                               -&gt;putline
                         if)
                      #);
                    ' is connected to the ps with name '-&gt;puttext;
                    current.name[]-&gt;puttext;
                    newline;
                    
                 #);
               
            #);
          size: entry (#  exit private.theList.size #);
          save: entry (#  do private.saveinfo #);
          load: entry (#  do private.loadinfo #);
          ;
          private: @
            (#
               theList: @list (# element:: clientinfo #);
               filename: (#  exit 'datafiles/clients.txt' #);
               loadinfo:
                 (#
                    inFile: @file;
                    hasInformedUser:
                    (* If there are items to recover, then the user should be notified - but
                     only once! *) @boolean
                 do filename-&gt;inFile.name;
                    inFile.touch (* to assure that a file _exists_.*) ;
                    inFile.openread;
                    loop
                      (#
                         while::  (#  do (not inFile.eos)-&gt;value;  #);
                         tmptext: ^text;
                         newclientinfo: ^clientinfo;
                         name,hostname,shellAddress: @text
                      do (if not hasInformedUser then
                             'The lockmanager will try to recover from the crash...'
                               -&gt;putline;
                             true-&gt;hasInformedUser
                         if);
                         inFile.getline-&gt;tmptext[];
                         ;
                         tmptext.reset;
                         tmptext[]-&gt;getNextString-&gt;name;
                         tmptext[]-&gt;getNextString-&gt;hostname;
                         tmptext[]-&gt;getNextString-&gt;shellAddress;
                         ;
                         &amp;clientinfo[]-&gt;newclientinfo[];
                         name.copy-&gt;newclientinfo.name[];
                         hostname.copy-&gt;newclientinfo.hostname[];
                         getclient:
                           (# theClient: ^PSclient; clientensemble: ^ensemble
                           do (ensemble##,hostname[])
                                -&gt;theShell.myEnsemble.ns.get
                                  (#
                                     notFound:: 
                                       (# 
                                       do 'Ensemble not found.'-&gt;screen.putText
                                       #)
                                  #)-&gt;clientEnsemble[];
                              (if clientEnsemble[] &lt;&gt; none then
                                  (PSclient##,shellAddress.copy)
                                    -&gt;clientensemble.ns.get
                                      (#
                                         notFound:: 
                                           (# 
                                           do (* 'Client not found '-&gt;screen.putText *)
                                           
                                           #)
                                      #)-&gt;theClient[];
                                  (if theClient[] = none then
                                      ' =&gt; Client not found - is deleted'
                                        -&gt;putline
                                   else
                                      ' =&gt; Client found - recovered'-&gt;putline;
                                      theclient[]-&gt;newclientinfo.theclient[];
                                      name.copy-&gt;newclientinfo.name[];
                                      myErrorHandler
                                        (# theEnsemble: ^ensemble
                                        do theclient.getMyEnsemble
                                             -&gt;theEnsemble[];
                                           (if theEnsemble[] &lt;&gt; none then
                                               theEnsemble.hostname.copy
                                                 -&gt;newclientinfo.hostname[]
                                            else
                                               'lock:init: getMyEnsemble returned none!'
                                                 -&gt;putline;
                                               'DEFAULT'
                                                 -&gt;newClientInfo.hostname[]
                                           if)
                                        #);
                                      newclientinfo[]-&gt;theList.append
                                  if)
                               else
                                  'lockmanager.clientList: could not find ensemble: "'
                                    -&gt;puttext;
                                  hostname[]-&gt;puttext;
                                  '".'-&gt;putline
                              if)
                           #)
                      #)
                 #);
               saveinfo:
                 (# outFile: @file
                 do filename-&gt;outFile.name;
                    outFile.openwrite;
                    theList.scan
                      (# 
                      do current.name[]-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         current.hostname[]-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         current.theClient.ri.shellAdr.astext-&gt;outFile.putline
                      #);
                    outFile.close
                 #)
            #);
          init::  (#  do private.theList.init #)
       #);
     <B>pStoreTable</B><A name="lockmanager.1.pStoreTable.2(163)"></A><A name="pStoreTable.2(163)"></A>: @Monitor
       (#
          append: entry
            (# elme: ^pStoreStatus; 
            enter elme[]
            do (if elme.priority = 1 then
                   elme[]-&gt;private.theList.append; 
                else
                   elme[]-&gt;private.theQueue.append; 
               if);
               private.saveinfo
            #);
          deleteDeadClient: entry
            (# theClient: ^PSclient
            enter theClient[]
            do private.theList.scan
                 (# 
                 do (if (theClient[] = current.lockingClient[]) then
                        current[]-&gt;private.theList.at-&gt;private.theList.delete;
                        current.pStoreName[]-&gt;private.setpriority
                    if)
                 #);
               private.theQueue.scan
                 (# 
                 do (if (theClient[] = current.lockingClient[]) then
                        current[]-&gt;private.theQueue.at-&gt;private.theQueue.delete
                    if)
                 #);
               private.saveinfo
            #);
          getlock: entry
            (#
               newpStoreStatus: ^pStoreStatus;
               ok: @boolean;
               name: ^text;
               uname: ^text;
               theClient: ^PSclient;
               lockmode: @integer;
               lockpolicy: @integer;
               notified: @boolean
               (* Has the notificationmanager been notified
                that we are trying to get a lock? *)
            enter (name[],theClient[],uname[],lockmode,lockpolicy)
            do &amp;pStorestatus[]-&gt;newpStoreStatus[];
               name[]-&gt;newpStoreStatus.pStoreName[];
               myErrorHandler
                 (# theEnsemble: ^ensemble
                 do theClient.getMyEnsemble-&gt;theEnsemble[];
                    (if theEnsemble[] &lt;&gt; none then
                        theEnsemble.hostname.copy-&gt;newpStoreStatus.hostname[]
                     else
                        'lock:pStoreTable.getlock: getMyEnsemble returned none!'
                          -&gt;putline;
                        'DEFAULT'-&gt;newpStoreStatus.hostname[]
                    if)
                 #);
               theClient[]-&gt;newpStoreStatus.lockingClient[];
               lockmode-&gt;newpStoreStatus.LockMode;
               lockpolicy-&gt;newpStoreStatus.LockPolicy;
               makeLock:
               (* Obtaining lock if possible. Doesn't continue until
                a lock has been obtained *)
                 (# 
                 do true
                      -&gt;ok
                      (* ok is only false if the lock cannot be obtained. So
                       next we scan all the statuses for the file and see if there 
                       is a conflict. *) ;
                    doscan:
                      (# 
                      do (if false then
                             'lock: Scanning pStoreTable to see if a lock can be given to the client.'
                               -&gt;putline
                         if);
                         private.theList.scan
                           (# 
                           do (if (current.pStoreName[],name[])-&gt;sameFile then
                                  (if true
                                   //
                                   ((lockmode = Read) and
                                    (current.lockmode = Read)) then
                                      true-&gt;ok; 
                                   //
                                   ((lockmode = Read) and
                                    (current.lockmode = Write)) then
                                      (if
                                      (((name[]-&gt;private.checkpolicy) = shared)
                                       and (lockpolicy = shared)) then
                                          true-&gt;ok; 
                                       else
                                          false-&gt;ok; 
                                      if);
                                      
                                   //
                                   ((lockmode = Write) and
                                    (current.lockmode = Write)) then
                                      false-&gt;ok; 
                                   //
                                   ((lockmode = Write) and
                                    (current.lockmode = Read)) then
                                      (if
                                      (((name[]-&gt;private.checkpolicy) = shared)
                                       and (lockpolicy = shared)) then
                                          true-&gt;ok; 
                                       else
                                          false-&gt;ok; 
                                      if);
                                      
                                  if);
                                  (if not ok then leave doscan if);
                                  
                              if);
                              
                           #)
                      #);
                    (if ok then (* A lock can be obtained immediately *)
                        1-&gt;newpStoreStatus.priority;
                        newpStoreStatus[]-&gt;private.theList.append;
                        private.saveinfo
                     else
                    (* A lock could NOT be obtained immediately. We queue the
                     client and wait for the lock. Also we make a notification to the 
                     notificationmanager  *)
                        0-&gt;newpStoreStatus.priority;
                        newpStoreStatus[]-&gt;private.theQueue.append;
                        private.saveinfo;
                        false-&gt;notified;
                        wait:
                        (* Waiting until a lock has been obtained... 
                         While we are waiting we try to notify the notificationmanager
                         about it.*)
                          (# 
                          do (if not notified
                             (* We have to notify the notificationmanagement
                              that a client is waiting for a lock. *) then
                                 (if notificationserver[] = none then
                                     getnotificationmanager:
                                       (# 
                                       do (NotificationManager##,
                                           'Notificationmanager')
                                            -&gt;theShell.myEnsemble.ns.get
                                              (#
                                                 notFound:: 
                                                   (# 
                                                   do ' notserver not found'
                                                        -&gt;putline;
                                                      leave
                                                      getnotificationmanager
                                                   #)
                                              #)-&gt;notificationServer[];
                                          
                                       #)
                                 if);
                                 (if notificationserver[] &lt;&gt; none then
                                     sendNotification:
                                       (# 
                                       do 'lockmanager.getlock: A client sent WAITFORLOCK event to notificationmanagement'
                                            -&gt;putline;
                                          (if nm[] = none then
                                              &amp;notificationmanagement[]-&gt;nm[];
                                              (notificationServer[],
                                               theShell.myensemble.hostname[])
                                                -&gt;nm.init
                                          if);
                                          (theclient[],uname[],name[],
                                           WAITFORLOCK)-&gt;nm.notify
                                       #)
                                 if);
                                 true-&gt;notified
                             if);
                             return;
                             pause;
                             mutex.P;
                             (if
                             (newpStoreStatus.priority = 1)
                             (* newpStoreStatus is initially referring to a pStoreStatus
                              in the queue (priority=0). If it has been moved to
                              the list then a lock has been obtained (priority=1). *)
                             then
                                 leave wait
                              else
                                 restart wait
                             if);
                             
                          #)
                    if)
                 #)
            exit ok
            #);
          releaseLock: entry
            (# thePS: ^pStoreStatus; name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            do L:
                 (# 
                 do private.theList.scan
                      (# 
                      do (if (current.pStoreName[],name[])-&gt;sameFile then
                             (if (theClient[] = current.lockingClient[]) then
                                 current[]-&gt;private.theList.at
                                   -&gt;private.theList.delete;
                                 private.saveinfo;
                                 name[]-&gt;private.setpriority;
                                 leave L;
                                 
                             if);
                             
                         if)
                      #);
                    
                 #);
               
            #);
          deleteLockRequest: entry
            (# thePS: ^pStoreStatus; name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            do L1:
                 (# 
                 do private.theList.scan
                      (# 
                      do (if (current.pStoreName[],name[])-&gt;sameFile then
                             (if (theClient[] = current.lockingClient[]) then
                                 current[]-&gt;private.theList.at
                                   -&gt;private.theList.delete;
                                 private.saveinfo;
                                 name[]-&gt;private.setpriority;
                                 leave L1
                             if)
                         if)
                      #)
                 #);
               L2:
                 (# 
                 do private.theQueue.scan
                      (# 
                      do (if (current.pStoreName[],name[])-&gt;sameFile then
                             (if (theClient[] = current.lockingClient[]) then
                                 current[]-&gt;private.theQueue.at
                                   -&gt;private.theQueue.delete;
                                 private.saveinfo;
                                 leave L2
                             if)
                         if)
                      #)
                 #)
            #);
          save: entry (#  do private.saveinfo;  #);
          load: entry (#  do private.loadinfo;  #);
          ;
          private: @
            (#
               filename: (#  exit 'datafiles/locks.txt' #);
               loadinfo:
                 (# inFile: @file
                 do filename-&gt;inFile.name;
                    inFile.touch (* to assure that a file _exists_.*) ;
                    inFile.openread;
                    loop
                      (#
                         while::  (#  do (not inFile.eos)-&gt;value;  #);
                         tmptext: ^text;
                         newpstorestatus: ^pstorestatus;
                         pstorename,shellAddress,hostname: @text;
                         lockmode,lockpolicy,priority: @integer
                      do inFile.getline-&gt;tmptext[];
                         ;
                         tmptext.reset;
                         tmptext[]-&gt;getNextString-&gt;pstorename;
                         tmptext[]-&gt;getNextString-&gt;shellAddress;
                         tmptext[]-&gt;getNextInteger-&gt;lockmode;
                         tmptext[]-&gt;getNextInteger-&gt;lockpolicy;
                         tmptext[]-&gt;getNextInteger-&gt;priority;
                         tmptext[]-&gt;getNextString-&gt;hostname;
                         ;
                         &amp;pstorestatus[]-&gt;newpstorestatus[];
                         pstorename.copy-&gt;newpStoreStatus.pStoreName[];
                         hostname.copy-&gt;newpStoreStatus.hostname[];
                         lockmode-&gt;newpStoreStatus.LockMode;
                         lockpolicy-&gt;newpStoreStatus.LockPolicy;
                         priority-&gt;newpStoreStatus.priority;
                         getclient:
                           (#
                              theClient: ^PSclient;
                              clientensemble: ^ensemble;
                              
                           do (ensemble##,hostname.copy)
                                -&gt;theShell.myEnsemble.ns.get
                                  (#
                                     notFound:: 
                                       (# 
                                       do 'Ensemble not found.'-&gt;screen.putText
                                       #)
                                  #)-&gt;clientEnsemble[];
                              (if clientEnsemble[] &lt;&gt; none then
                                  (PSclient##,shellAddress.copy)
                                    -&gt;clientensemble.ns.get
                                      (#
                                         notFound:: 
                                           (# 
                                           do (* ' - Client not found '-&gt;screen.putText *)
                                           
                                           #)
                                      #)-&gt;theClient[];
                                  (if theClient[] = none then
                                      ' =&gt; Client not found - is deleted'
                                        -&gt;putline
                                   else
                                      ' =&gt; Client found - lock recovered'
                                        -&gt;putline;
                                      theClient[]
                                        -&gt;newpStoreStatus.lockingClient[];
                                      (if newpstorestatus.priority = 1 then
                                          newpStoreStatus[]-&gt;theList.append
                                       else
                                          newpStoreStatus[]-&gt;theQueue.append
                                      if)
                                  if)
                               else
                                  'lockmanager.pStoreTable: could not find ensemble: "'
                                    -&gt;puttext;
                                  hostname[]-&gt;puttext;
                                  '".'-&gt;putline
                              if)
                           #)
                      #)
                 #);
               saveinfo:
                 (#
                    outFile: @file;
                    writePStoreStatus:
                      (# elm: ^pStoreStatus
                      enter elm[]
                      do elm.pstorename[]-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         elm.lockingClient.ri.shellAdr.astext-&gt;outFile.puttext;
                         ';'-&gt;outFile.put;
                         elm.lockmode-&gt;outFile.putint;
                         ';'-&gt;outFile.put;
                         elm.lockPolicy-&gt;outFile.putint;
                         ';'-&gt;outFile.put;
                         elm.priority-&gt;outFile.putint;
                         ';'-&gt;outFile.put;
                         elm.hostname[]-&gt;outFile.putline
                      #)
                 do filename-&gt;outFile.name;
                    outFile.openwrite;
                    theList.scan
                      (#  do current[]-&gt;writePStoreStatus #);
                    theQueue.scan
                      (#  do current[]-&gt;writePStoreStatus #);
                    outFile.close
                 #);
               theList: @list (# element:: pStoreStatus;  #);
               theQueue: @list (# element:: pStoreStatus;  #);
               checkpolicy:
                 (# policy: @integer; name: ^text; 
                 enter name[]
                 do shared-&gt;policy;
                    theList.scan
                      (# 
                      do (if (current.pStoreName[],name[])-&gt;sameFile then
                             (if (current.lockpolicy &lt; policy) then
                                 current.lockpolicy-&gt;policy; 
                             if);
                             
                         if);
                         
                      #);
                    
                 exit policy
                 #);
               setpriority:
                 (#
                    name: ^text;
                    lockmode: @integer;
                    lockpolicy: @integer;
                    ok: @boolean;
                    
                 enter name[]
                 do doscan: theQueue.scan
                      (# 
                      do (if (current.pStoreName[],name[])-&gt;sameFile then
                             current.lockmode-&gt;lockmode;
                             (current.lockpolicy,(name[]-&gt;checkpolicy))-&gt;min
                               -&gt;lockpolicy;
                             true-&gt;ok;
                             dolistscan: theList.scan
                               (# 
                               do (if (current.pStoreName[],name[])-&gt;sameFile
                                   then
                                      (if true
                                       //
                                       ((lockmode = Read) and
                                        (current.lockmode = Read)) then
                                          true-&gt;ok; 
                                       //
                                       ((lockmode = Read) and
                                        (current.lockmode = Write)) then
                                          (if (lockpolicy = shared) then
                                              true-&gt;ok; 
                                           else
                                              false-&gt;ok; 
                                          if);
                                          
                                       //
                                       ((lockmode = Write) and
                                        (current.lockmode = Write)) then
                                          false-&gt;ok; 
                                       //
                                       ((lockmode = Write) and
                                        (current.lockmode = Read)) then
                                          (if (lockpolicy = shared) then
                                              true-&gt;ok; 
                                           else
                                              false-&gt;ok; 
                                          if);
                                          
                                      if);
                                      (if not ok then leave dolistscan if);
                                      
                                  if);
                                  
                               #);
                             (if ok then
                                 1-&gt;current.priority;
                                 current[]-&gt;theQueue.at-&gt;theQueue.delete;
                                 current[]-&gt;theList.append;
                                 saveinfo;
                                 
                             if);
                             
                         if);
                         
                      #);
                    
                 #)
                 (*display: entry
                  (#
                  do 'Persistent Store information:'-&gt;putline;
                  theList.scan
                  (# do current.pStoreName[]-&gt;screen.puttext;
                  ' is locked by '-&gt;puttext;
                  current.lockingClient.ri.shellAdr.astext-&gt;puttext;
                  ' running on '-&gt;puttext;
                  current.lockingClient.myensemble.hostname[]-&gt;puttext; 
                  newline;
                  'Lockmode: '-&gt;puttext;
                  (if (current.lockmode = write) then
                  'Write lock'-&gt;putline;
                  else
                  'Read lock'-&gt;putline;
                  if);    
                  #);
                  #);
                  *)
            #);
          init::  (#  do private.theList.init #)
       #);
     <B>MRSWTable</B><A name="lockmanager.1.MRSWTable.2(164)"></A><A name="MRSWTable.2(164)"></A>: @Monitor
       (#
          deleteDeadClient: entry
            (# theClient: ^PSclient
            enter theClient[]
            do L1:
                 (# 
                 do private.readerList.scan
                      (# 
                      do (if (theClient[] = current.lockingClient[]) then
                             current[]-&gt;private.readerList.at
                               -&gt;private.readerList.delete
                         if)
                      #)
                 #);
               L2:
                 (# 
                 do private.writerList.scan
                      (# 
                      do (if (theClient[] = current.lockingClient[]) then
                             current[]-&gt;private.writerList.at
                               -&gt;private.writerList.delete
                         if)
                      #)
                 #)
            #);
          getlock: entry
            (#
               newMRSWinfo: ^MRSWinfo;
               ok: @boolean;
               name: ^text;
               theClient: ^PSclient;
               lockmode: @integer;
               
            enter (name[],theClient[],lockmode)
            do &amp;MRSWinfo[]-&gt;newMRSWinfo[];
               name[]-&gt;newMRSWinfo.name[];
               theClient[]-&gt;newMRSWinfo.lockingClient[];
               lockmode-&gt;newMRSWinfo.LockMode;
               L:
                 (# 
                 do true-&gt;ok;
                    (if (lockmode = read) then
                        doscan:
                          (# 
                          do private.writerList.scan
                               (# 
                               do (if (current.name[],name[])-&gt;sameFile then
                                      false-&gt;ok; leave doscan; 
                                  if);
                                  
                               #);
                             
                          #);
                        
                     else
                        doscan:
                          (# 
                          do private.writerList.scan
                               (# 
                               do (if (current.name[],name[])-&gt;sameFile then
                                      false-&gt;ok; leave doscan; 
                                  if);
                                  
                               #);
                             private.readerlist.scan
                               (# 
                               do (if (current.name[],name[])-&gt;sameFile then
                                      false-&gt;ok; leave doscan; 
                                  if);
                                  
                               #)
                          #)
                    if);
                    (if ok then
                        (if (lockmode = read) then
                            newMRSWinfo[]-&gt;private.readerList.append; 
                         else
                            newMRSWinfo[]-&gt;private.writerList.append; 
                        if);
                        
                     else
                        wait:
                          (# ok: @boolean; 
                          do return;
                             pause;
                             mutex.P;
                             true-&gt;ok;
                             (if (lockmode = read) then
                                 doscan:
                                   (# 
                                   do private.writerList.scan
                                        (# 
                                        do (if
                                           (current.name[],name[])-&gt;sameFile
                                            then
                                               false-&gt;ok; leave doscan; 
                                           if);
                                           
                                        #);
                                      
                                   #);
                                 
                              else
                                 doscan:
                                   (# 
                                   do private.writerList.scan
                                        (# 
                                        do (if
                                           (current.name[],name[])-&gt;sameFile
                                            then
                                               false-&gt;ok; leave doscan; 
                                           if);
                                           
                                        #);
                                      private.readerlist.scan
                                        (# 
                                        do (if
                                           (current.name[],name[])-&gt;sameFile
                                            then
                                               false-&gt;ok; leave doscan; 
                                           if);
                                           
                                        #);
                                      
                                   #);
                                 
                             if);
                             (if ok then
                                 (if (lockmode = read) then
                                     newMRSWinfo[]-&gt;private.readerList.append; 
                                  else
                                     newMRSWinfo[]-&gt;private.writerList.append; 
                                 if);
                                 leave wait
                              else
                                 restart wait
                             if);
                             
                          #);
                        
                    if);
                    
                 #);
               
            exit ok
            #);
          releaseLock: entry
            (# name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            do private.readerList.scan
                 (# 
                 do (if (current.Name[],name[])-&gt;sameFile then
                        (if (theClient[] = current.lockingClient[]) then
                            current[]-&gt;private.readerList.at
                              -&gt;private.readerList.delete
                        if)
                    if)
                 #);
               private.writerList.scan
                 (# 
                 do (if (current.Name[],name[])-&gt;sameFile then
                        (if (theClient[] = current.lockingClient[]) then
                            current[]-&gt;private.writerlist.at
                              -&gt;private.writerList.delete
                        if)
                    if)
                 #)
            #);
          ;
          private: @
            (#
               readerList: @list (# element:: MRSWinfo;  #);
               writerList: @list (# element:: MRSWinfo;  #)
            #);
          init:: 
            (#  do private.readerList.init; private.writerlist.init;  #)
       #);
     ;
     <B>getRidOfFailingClients</B><A name="lockmanager.1.getRidOfFailingClients.2(165)"></A><A name="getRidOfFailingClients.2(165)"></A>: @|System
       (#
          noOfFailuresRequired:
          (* how many failed pings before a client should be deleted? *)
            (#  exit 10 #);
          old_implementations:
            (#
               AlmostOriginalGetRidOfFailingClients: @|System
                 (#
                    async:
                      (#
                         theThread: @|System (#  do THIS(async) #);
                         forked: @Boolean;
                         
                      do (if forked then
                             INNER
                          else
                             true-&gt;forked; theThread[]-&gt;fork; 
                         if)
                      #);
                    myErrorHandler: errorhandler
                      (#
                         onFailure:
                           (# theError: ^error; 
                           enter theError[]
                           do (if theError.theObj## &lt;= PSClient## then
                              (* Get rid of the failing Client. *)
                                  theError.theObj[]-&gt;FailingClients.insert;
                                  theError.ignore;
                                  
                               else
                                  theError.abort; 
                              if);
                              
                           #);
                         connectionBroken:: 
                           (#  do THIS(connectionBroken)[]-&gt;onFailure #);
                         connectionFailed:: 
                           (#  do THIS(connectionFailed)[]-&gt;onFailure #);
                         timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
                         timeOutValue::  (#  do 2-&gt;sec #);
                         
                      do INNER
                      #)
                 do Cycle
                      (# 
                      do 2-&gt;sleep;
                         ClientList.scanClients
                           (# 
                           do curClient[]
                                -&gt;async
                                  (# myClient: ^PSClient
                                  enter myClient[]
                                  do myerrorhandler
                                       (#  do myClient.ping #);
                                     
                                  #)
                           #);
                         FailingClients.scanClients
                           (# 
                           do curElement.Client[]-&gt;ClientList.deleteDeadClient;
                              curElement.Client[]-&gt;pStoretable.deleteDeadClient;
                              curElement.Client[]-&gt;MRSWTable.deleteDeadClient
                           #);
                         FailingClients.clear
                      #)
                 #);
               MyOldGetRidOfFailingClients: @|System
                 (#
                    async:
                      (#
                         theThread: @|System (#  do THIS(async) #);
                         forked: @Boolean;
                         
                      do (if forked then
                             INNER
                          else
                             true-&gt;forked; theThread[]-&gt;fork; 
                         if)
                      #);
                    myErrorHandler: errorhandler
                      (#
                         wrongAnswer::&lt; 
                           (# 
                           do 'lock: wrongAnswer called!!! - continuing...'
                                -&gt;putline;
                              continue
                           #);
                         onFailure:
                           (# theError: ^error; 
                           enter theError[]
                           do (if theError.theObj## &lt;= PSClient## then
                              (* Get rid of the failing Client. *)
                                  theError.theObj[]-&gt;FailingClients.insert;
                                  theError.ignore
                               else
                                  theError.abort; 
                              if)
                           #);
                         connectionBroken:: 
                           (#  do THIS(connectionBroken)[]-&gt;onFailure #);
                         connectionFailed:: 
                           (#  do THIS(connectionFailed)[]-&gt;onFailure #);
                         timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
                         timeOutValue::  (#  do 1-&gt;sec #)
                      do INNER
                      #);
                    noOfFailuresRequired:
                    (* how many failed pings before a client should be deleted? *)
                    (#  exit 30 #);
                    sem: @Semaphore;
                    semCounter: @integer
                 do FailingClients.clear;
                    sem.V;
                    Cycle
                      (# 
                      do 4-&gt;sleep;
                         sem.P;
                         failingClients.scanClients
                           (#  do false-&gt;curElement.failedAtThisPing #);
                         sem.V;
                         (if clientList.private.theList.size &lt;&gt; 0 then
                             sem.P;
                             ClientList.scanClients
                               (# 
                               do semCounter+1-&gt;semCounter;
                                  curClient[]
                                    -&gt;async
                                      (# myClient: ^PSClient
                                      enter myClient[]
                                      do myerrorhandler
                                           (#  do myClient.ping #);
                                         semCounter-1-&gt;semcounter;
                                         (if semCounter = 0 then sem.V if)
                                      #)
                               #)
                         if);
                         sem.P;
                         FailingClients.scanClients
                           (# 
                           do (if curElement.failedAtThisPing then
                                  curElement.noOfFailures+1
                                    -&gt;curElement.noOfFailures;
                                  write_warning_on_screen:
                                    (# 
                                    do 'lock: Client not responding: '-&gt;puttext;
                                       curElement.client.ri.shellAdr.astext
                                         -&gt;puttext;
                                       ' ('-&gt;puttext;
                                       curElement.noOfFailures-&gt;putint;
                                       ':'-&gt;put;
                                       noOfFailuresRequired-&gt;putint;
                                       ').'-&gt;putline
                                    #)
                               else
                                  0-&gt;curElement.noOfFailures
                              if);
                              (if curElement.noOfFailures &gt;=
                              noOfFailuresRequired then
                                  'Lock: DELETING DEAD CLIENT!! '-&gt;puttext;
                                  curElement.client.ri.shellAdr.astext-&gt;putline;
                                  curElement[]-&gt;FailingClients.theList.at
                                    -&gt;FailingClients.theList.delete;
                                  curElement.client[]
                                    -&gt;ClientList.deleteDeadClient;
                                  curElement.client[]
                                    -&gt;pStoretable.deleteDeadClient;
                                  curElement.client[]
                                    -&gt;MRSWTable.deleteDeadClient
                              if)
                           #);
                         sem.V
                      #)
                 #)
            #)
       do FailingClients.init;
          Cycle
            (# 
            do 6-&gt;sleep;
               failingClients.scanClients
                 (#  do false-&gt;curElement.failedAtThisPing #);
               ClientList.scanClients
                 (# 
                 do myerrorhandler
                      (#
                         onFailure:: 
                           (# 
                           do (if theError.theObj## &lt;= PSClient## then
                                  theError.theObj[]
                                    -&gt;
                                      FailingClients.insert
                                      (* Get rid of the failing Client. *)
                              if)
                           #)
                      do curClient.ping
                      #)
                 #);
               FailingClients.scanClients
                 (# 
                 do (if curElement.failedAtThisPing then
                        curElement.noOfFailures+1-&gt;curElement.noOfFailures;
                        write_warning_on_screen:
                          (# 
                          do 'lock: Client not responding: '-&gt;puttext;
                             curElement.client.ri.shellAdr.astext-&gt;puttext;
                             ' ('-&gt;puttext;
                             curElement.noOfFailures-&gt;putint;
                             ':'-&gt;put;
                             noOfFailuresRequired-&gt;putint;
                             ').'-&gt;putline
                          #)
                     else
                        0-&gt;curElement.noOfFailures
                    if);
                    (if curElement.noOfFailures &gt;= noOfFailuresRequired then
                        'Lock: DELETING DEAD CLIENT!! '-&gt;puttext;
                        curElement.client.ri.shellAdr.astext-&gt;putline;
                        curElement[]-&gt;FailingClients.theList.at
                          -&gt;FailingClients.theList.delete;
                        curElement.client[]-&gt;ClientList.deleteDeadClient;
                        curElement.client[]-&gt;pStoretable.deleteDeadClient;
                        curElement.client[]-&gt;MRSWTable.deleteDeadClient
                    if)
                 #)
            #)
       #);
     <B>FailingClients</B><A name="lockmanager.1.FailingClients.2(166)"></A><A name="FailingClients.2(166)"></A>: @Monitor
       (#
          insert: entry
            (# theClient: ^PSClient; theListElement: ^listElement
            enter theClient[]
            do theList.find
                 (#
                    predicate:: 
                      (#  do (current.client[] = theClient[])-&gt;value #)
                 #)-&gt;theListElement[];
               (if theListElement[] = none then
               (* the client has never failed before. It is inserte once and for all. *)
                   make_new_element:
                     (# 
                     do &amp;listElement[]-&gt;theListElement[];
                        theClient[]-&gt;theListElement.client[];
                        0-&gt;theListElement.noOfFailures;
                        false-&gt;theListElement.failedAtThisPing
                     #);
                   theListElement[]-&gt;theList.append
               if);
               true-&gt;theListElement.failedAtThisPing
            #);
          scanClients: entry
            (# curElement: ^listElement; 
            do theList.scan
                 (#  do current[]-&gt;curElement[]; INNER scanClients #);
               
            #);
          clear: entry (#  do theList.clear;  #);
          ;
          listElement:
            (#
               client: ^PSClient;
               noOfFailures: @integer;
               failedAtThisPing: @boolean
            #);
          theList: @list (# element:: listElement #);
          init::  (#  do theList.init #)
       #);
     ;
     <B>init</B><A name="lockmanager.1.init.2(167)"></A><A name="init.2(167)"></A>:: 
       (#
          createDirectory:
          (* Skaber directoriet path. Det antages, at path i forvejen eksisterer
           i hvert fald ind til naest-dybeste niveau, saadan, at der her hoejst skal 
           skabes ét directory. *)
            (# theDirectory: @directory; thePath: ^text
            enter thePath[]
            do thePath[]-&gt;theDirectory.name; theDirectory.touch
            #)
       do clientList.init;
          pStoreTable.init;
          MRSWTable.init;
          ;
          'datafiles'-&gt;createDirectory (* to be sure the directory exists *) ;
          clientList.load;
          clientList.save;
          pStoreTable.load;
          PStoreTable.save;
          ;
          'The lock manager has been started.'-&gt;screen.putline;
          (if false then getRidOfFailingClients[]-&gt;fork if)
       #)
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Lockmanager Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
