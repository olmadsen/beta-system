<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Lockmanager Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("lockmanager");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="lockmanager">Lockmanager Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/distribution/basicshell';
INCLUDE 'clientinterface'
        'samefile'
        'perslib'
        'sharedpsnotifications'
        'lockmanagerinterface'
        '~beta/basiclib/file'
        '~beta/basiclib/directory'
        '~beta/containers/sets';
(* File lockmanager.bet
 * ====================
 * This file contains the interface to a lockmanager serving
 * concurrency control.
 * This file is included by the file serverinterface.bet, because
 * every server starts a lockmanager.
 *)
-- shellEnvLib: Attributes --
<B>pStoreStatus</B><A name="pStoreStatus.1(132)"></A>:
  (#
     <B>pStoreName</B><A name="pStoreStatus.1.pStoreName.2(133)"></A><A name="pStoreName.2(133)"></A>: ^text;
     <B>lockingClient</B><A name="pStoreStatus.1.lockingClient.2(134)"></A><A name="lockingClient.2(134)"></A>: ^PSClient;
     <B>LockMode</B><A name="pStoreStatus.1.LockMode.2(135)"></A><A name="LockMode.2(135)"></A>: @integer;
     <B>LockPolicy</B><A name="pStoreStatus.1.LockPolicy.2(136)"></A><A name="LockPolicy.2(136)"></A>: @integer;
     <B>priority</B><A name="pStoreStatus.1.priority.2(137)"></A><A name="priority.2(137)"></A>: @integer;
     <B>hostname</B><A name="pStoreStatus.1.hostname.2(138)"></A><A name="hostname.2(138)"></A>: ^text
  #);
<B>MRSWinfo</B><A name="MRSWinfo.1(139)"></A>:
  (# <B>name</B><A name="MRSWinfo.1.name.2(140)"></A><A name="name.2(140)"></A>: ^text; <B>lockingClient</B><A name="MRSWinfo.1.lockingClient.2(141)"></A><A name="lockingClient.2(141)"></A>: ^PSClient; <B>LockMode</B><A name="MRSWinfo.1.LockMode.2(142)"></A><A name="LockMode.2(142)"></A>: @integer;  #);
<B>clientinfo</B><A name="clientinfo.1(143)"></A>: (# <B>theclient</B><A name="clientinfo.1.theclient.2(144)"></A><A name="theclient.2(144)"></A>: ^PSclient; <B>name</B><A name="clientinfo.1.name.2(145)"></A><A name="name.2(145)"></A>: ^text; <B>hostname</B><A name="clientinfo.1.hostname.2(146)"></A><A name="hostname.2(146)"></A>: ^text;  #);
<B>lockmanager</B><A name="lockmanager.1(147)"></A>: lockmanagerinterface
  (#
     <B>connectImpl</B><A name="lockmanager.1.connectImpl.2(148)"></A><A name="connectImpl.2(148)"></A>:: 
       (# 
       do 'lock: Client connecting...'-&gt;puttext;
          (theClient[],name[])-&gt;clientList.insert-&gt;value;
          (if value then theClient.registerClient if);
          ' done'-&gt;putline
       #);
     <B>disconnectImpl</B><A name="lockmanager.1.disconnectImpl.2(149)"></A><A name="disconnectImpl.2(149)"></A>:: 
       (# 
       do 'lock: Client disconnecting...'-&gt;puttext;
          (theClient[],name[])-&gt;clientList.delete;
          ' done'-&gt;putline
       #);
     <B>getLockImpl</B><A name="lockmanager.1.getLockImpl.2(150)"></A><A name="getLockImpl.2(150)"></A>:: 
       (# 
       do 'lock: Request for lock...'-&gt;puttext;
          (name[],theClient[],username[],lockmode,lockpolicy)
            -&gt;pStoreTable.getlock-&gt;value;
          (if value then ' granted'-&gt;putline else ' NOT granted'-&gt;putline if)
       #);
     <B>MRSWgetLockImpl</B><A name="lockmanager.1.MRSWgetLockImpl.2(151)"></A><A name="MRSWgetLockImpl.2(151)"></A>:: 
       (# 
       do 'lock: Request for lock...'-&gt;puttext;
          (name[],theClient[],lockmode)-&gt;MRSWTable.getlock;
          ' done'-&gt;putline
       #);
     <B>MRSWreleaseLockImpl</B><A name="lockmanager.1.MRSWreleaseLockImpl.2(152)"></A><A name="MRSWreleaseLockImpl.2(152)"></A>:: 
       (# 
       do 'lock: Releasing lock...'-&gt;puttext;
          (theClient[],name[])-&gt;MRSWTable.releaselock;
          ' done'-&gt;putline
       #);
     <B>releaseLockImpl</B><A name="lockmanager.1.releaseLockImpl.2(153)"></A><A name="releaseLockImpl.2(153)"></A>:: 
       (# 
       do 'lock: Releasing lock...'-&gt;puttext;
          (theClient[],name[])-&gt;pStoreTable.releaselock;
          ' done'-&gt;putline
       #);
     <B>deleteLockRequestImpl</B><A name="lockmanager.1.deleteLockRequestImpl.2(154)"></A><A name="deleteLockRequestImpl.2(154)"></A>:: 
       (#  do (theClient[],name[])-&gt;pStoreTable.deleteLockRequest;  #);
     <B>getPermissiontoDeletePSImpl</B><A name="lockmanager.1.getPermissiontoDeletePSImpl.2(155)"></A><A name="getPermissiontoDeletePSImpl.2(155)"></A>:: 
       (#  do name[]-&gt;clientList.GetpermissiontoDeletePS-&gt;ok;  #);
     ;
     <B>getNextString</B><A name="lockmanager.1.getNextString.2(156)"></A><A name="getNextString.2(156)"></A>:
       (#
       (* soeger fra nuvaerende position og frem til og med naeste semikolon. 
        Returnerer herefter det foerste uden semikolon
        *) txtref,outtxt: ^text; start: @integer; 
       enter txtref[]
       ...
       exit outtxt
       #);
     <B>getNextInteger</B><A name="lockmanager.1.getNextInteger.2(157)"></A><A name="getNextInteger.2(157)"></A>:
       (#
       (* Kalder getNextString og konverterer resultatet til en integer *)
          txtref: ^text; outtxt: @text; result: @integer; 
       enter txtref[]
       ...
       exit result
       #);
     <B>chop</B><A name="lockmanager.1.chop.2(158)"></A><A name="chop.2(158)"></A>:
     (* Afskærer foran- og efterstillede mellemrum, linieskift *)
       (# t: ^text;  enter t[] ... exit t[] #);
     ;
     <B>notificationServer</B><A name="lockmanager.1.notificationServer.2(159)"></A><A name="notificationServer.2(159)"></A>: ^notificationmanager;
     <B>nm</B><A name="lockmanager.1.nm.2(160)"></A><A name="nm.2(160)"></A>: ^notificationmanagement;
     ;
     <B>myErrorHandler</B><A name="lockmanager.1.myErrorHandler.2(161)"></A><A name="myErrorHandler.2(161)"></A>: errorhandler
       (#
          wrongAnswer::&lt; 
            (# 
            do 'lock: wrongAnswer called!!! - continuing...'-&gt;putline; continue
            #);
          onFailure:&lt;
            (# theError: ^error; 
            enter theError[]
            do INNER onFailure;
               (if theError.theObj## &lt;= PSClient## then
               (* Get rid of the failing Client. *)
                   theError.theObj[]-&gt;FailingClients.insert; theError.ignore
                else
                   theError.abort; 
               if)
            #);
          connectionBroken::  (#  do THIS(connectionBroken)[]-&gt;onFailure #);
          connectionFailed::  (#  do THIS(connectionFailed)[]-&gt;onFailure #);
          timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
          timeOutValue::  (#  do 1-&gt;sec #)
       do INNER
       #);
     ;
     <B>clientList</B><A name="lockmanager.1.clientList.2(162)"></A><A name="clientList.2(162)"></A>: @Monitor
       (#
          scanClients: entry
            (#
               curClient: ^PSClient;
               allClients:
               (* A client may appear more than once in theList. This
                set contains only one element per client *) @set
                 (# element:: PSclient #)
            ...
            #);
          scanClientInfos:
           entry
            (# current: ^clientinfo
            ...
            #);
          getpermissiontoDeletePS: entry
            (# name: ^text; ok: @boolean; 
            enter name[]
            ...
            exit ok
            #);
          append: entry
            (# elme: ^clientinfo; 
            enter elme[]
            do elme[]-&gt;private.theList.append
            #);
          insert: entry
            (#
               theClient: ^PSclient;
               name: ^text;
               newclientinfo: ^clientinfo;
               ok: @boolean
            enter (theClient[],name[])
            ...
            exit ok
            #);
          delete: entry
            (# theClient: ^PSclient; name: ^text; 
            enter (theClient[],name[])
            ...
            #);
          deleteDeadClient: entry
            (# theClient: ^PSclient; 
            enter theClient[]
            ...
            #);
          display: entry (#  ... #);
          size: entry (#  exit private.theList.size #);
          save: entry (#  do private.saveinfo #);
          load: entry (#  do private.loadinfo #);
          ;
          private: @
            (#
               theList: @list (# element:: clientinfo #);
               filename: (#  exit 'datafiles/clients.txt' #);
               loadinfo:
                 (#
                    inFile: @file;
                    hasInformedUser:
                    (* If there are items to recover, then the user should be notified - but
                     only once! *) @boolean
                 ...
                 #);
               saveinfo:
                 (#
                    outFile:
                      @file
                 ...
                 #)
            #);
          init:: 
            (# 
            do private.
                 theList.init
            #)
       #);
     <B>pStoreTable</B><A name="lockmanager.1.pStoreTable.2(163)"></A><A name="pStoreTable.2(163)"></A>: @Monitor
       (#
          append: entry
            (# elme: ^pStoreStatus; 
            enter elme[]
            ...
            #);
          deleteDeadClient: entry
            (#
               theClient: ^PSclient
            enter theClient[]
            ...
            #);
          getlock: entry
            (#
               newpStoreStatus: ^pStoreStatus;
               ok: @boolean;
               name: ^text;
               uname: ^text;
               theClient: ^PSclient;
               lockmode: @integer;
               lockpolicy: @integer;
               notified: @boolean
               (* Has the notificationmanager been notified
                that we are trying to get a lock? *)
            enter (name[],theClient[],uname[],lockmode,lockpolicy)
            ...
            exit ok
            #);
          releaseLock: entry
            (# thePS: ^pStoreStatus; name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            ...
            #);
          deleteLockRequest: entry
            (# thePS: ^pStoreStatus; name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            ...
            #);
          save: entry (#  do private.saveinfo;  #);
          load: entry (#  do private.loadinfo;  #);
          ;
          private: @
            (#
               filename: (#  exit 'datafiles/locks.txt' #);
               loadinfo:
                 (# inFile: @file
                 ...
                 #);
               saveinfo:
                 (#
                    outFile: @file;
                    writePStoreStatus:
                      (# elm: ^pStoreStatus
                      enter elm[]
                      ...
                      #)
                 ...
                 #);
               theList: @list (# element:: pStoreStatus;  #);
               theQueue: @list (# element:: pStoreStatus;  #);
               checkpolicy:
                 (# policy: @integer; name: ^text; 
                 enter name[]
                 ...
                 exit policy
                 #);
               setpriority:
                 (#
                    name: ^text;
                    lockmode: @integer;
                    lockpolicy: @integer;
                    ok: @boolean;
                    
                 enter name[]
                 ...
                 #)
                 (*display: entry
                  (#
                  do 'Persistent Store information:'-&gt;putline;
                  theList.scan
                  (# do current.pStoreName[]-&gt;screen.puttext;
                  ' is locked by '-&gt;puttext;
                  current.lockingClient.ri.shellAdr.astext-&gt;puttext;
                  ' running on '-&gt;puttext;
                  current.lockingClient.myensemble.hostname[]-&gt;puttext; 
                  newline;
                  'Lockmode: '-&gt;puttext;
                  (if (current.lockmode = write) then
                  'Write lock'-&gt;putline;
                  else
                  'Read lock'-&gt;putline;
                  if);    
                  #);
                  #);
                  *)
            #);
          init::  (#  do private.theList.init #)
       #);
     <B>MRSWTable</B><A name="lockmanager.1.MRSWTable.2(164)"></A><A name="MRSWTable.2(164)"></A>: @Monitor
       (#
          deleteDeadClient: entry
            (# theClient: ^PSclient
            enter theClient[]
            ...
            #);
          getlock: entry
            (#
               newMRSWinfo: ^MRSWinfo;
               ok: @boolean;
               name: ^text;
               theClient: ^PSclient;
               lockmode: @integer;
               
            enter (name[],theClient[],lockmode)
            ...
            exit ok
            #);
          releaseLock: entry
            (# name: ^text; theClient: ^PSclient
            enter (theClient[],name[])
            ...
            #);
          ;
          private: @
            (#
               readerList: @list (# element:: MRSWinfo;  #);
               writerList: @list (# element:: MRSWinfo;  #)
            #);
          init:: 
            (#  do private.readerList.init; private.writerlist.init;  #)
       #);
     ;
     <B>getRidOfFailingClients</B><A name="lockmanager.1.getRidOfFailingClients.2(165)"></A><A name="getRidOfFailingClients.2(165)"></A>:
       @|...;
     <B>FailingClients</B><A name="lockmanager.1.FailingClients.2(166)"></A><A name="FailingClients.2(166)"></A>: @Monitor
       (#
          insert: entry
            (# theClient: ^PSClient; theListElement: ^listElement
            enter theClient[]
            ...
            #);
          scanClients: entry
            (#
               curElement:
                 ^listElement;
               
            ...
            #);
          clear: entry
            (# 
            do theList.
                 clear;
               
            #);
          ;
          listElement:
            (#
               client:
                 ^PSClient;
               noOfFailures: @integer;
               failedAtThisPing: @boolean
            #);
          theList: @list (# element:: listElement #);
          init::  (#  do theList.init #)
       #);
     ;
     <B>init</B><A name="lockmanager.1.init.2(167)"></A><A name="init.2(167)"></A>:: 
       (#
          createDirectory:
          (* Skaber directoriet path. Det antages, at path i forvejen eksisterer
           i hvert fald ind til naest-dybeste niveau, saadan, at der her hoejst skal 
           skabes ét directory. *)
            (# theDirectory: @directory; thePath: ^text
            enter thePath[]
            do thePath[]-&gt;theDirectory.name; theDirectory.touch
            #)
       ...
       #)
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Lockmanager Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
