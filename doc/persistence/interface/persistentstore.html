<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Persistentstore Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Persistentstore Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
(* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
BODY 'private/persistentstoreBody';

---- lib: attributes ----

<B>persistentstore</B><A name="persistentstore.1(1)"></A>:
  (# &lt;&lt;SLOT persistentstoreLib: attributes&gt;&gt;;
     <B>lastupdate</B><A name="persistentstore.1:lastupdate.2(2)"></A><A name="lastupdate.2(2)"></A>:@integer;
     <B>init</B><A name="persistentstore.1:init.2(3)"></A><A name="init.2(3)"></A>:
       (* used by the sharedpersistentstore 
        *)
       (#
       do ...;
       #);
     
     <B>commit</B><A name="persistentstore.1:commit.2(4)"></A><A name="commit.2(4)"></A>:
       (* used by the sharedpersistentstore
        * doUpdateInMemoryObjects is always true, when docheckpoint is
        * true. When doCheckpoint is false and doUpdateInMemoryObjects
        * is true, the InMemoryObjects (copies of the persistent objects)
        * are always refetched from disk, when the ps is accessed next time, 
        * - no matter if the persistentstore has being updated by another 
        * process in the meanwhile or not. In this way, the
        * user can regret changes to inmemory objects, which haven't
        * installed on disk. 
        * When doCheckpoint is false and doUpdateInMemoryObjects is false,
        * the in memory objects are, when the ps is accessed next time, 
        * only refetched from disk, when the persistentstore has been 
        * updated by another process in the meanwhile. By default, 
        * doUpdateInMemoryObjects is false.
        *)
       (# doUpdateInMemoryObjects:&lt; BooleanValue 
            (# do false-&gt; value; INNER #);
          doCheckpoint:&lt; BooleanValue 
            (# do true -&gt; value; INNER #);
       do ...
       #);
     
      <B>reget</B><A name="persistentstore.1:reget.2(5)"></A><A name="reget.2(5)"></A>:
       (* used by the sharedpersistentstore
        * NotFound exception is raised for every root object
        * that has been overwritten by another root object with 
        * the same name. The old root objects are deleted.
        *)
       (# NotFound:&lt; PSException
            (# 
            do 'persistentstore.reget: Root "' -&gt; msg.putText; 
               fullname[] -&gt; msg.putText;
               '" has been overwritten by another client.' -&gt; msg.putText;
               'Your references are not longer valid.'-&gt;msg.puttext;
               msg[]-&gt;putline;
               true-&gt;continue;
               INNER
            #);
          theObject: ^Object;
       enter theObject[]   
       do ...;
       #);
     
     <B>openRead</B><A name="persistentstore.1:openRead.2(6)"></A><A name="openRead.2(6)"></A>:
       (* Opens THIS(persistentstore) for reading, i.e. it is not
        * allowed to write objects to the store.  Checkpoint
        * operations will be ignored.
        * 
        * The name parameter is the name of the directory containing
        * the store and is interpreted as a path relative to the
        * current directory of the process.
        *)
       (# alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.openRead: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" already open' -&gt; msg.putText; 
               INNER
            #);
          notFound:&lt; PSexception 
            (# 
            do 'persistentstore.openRead: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" not found' -&gt; msg.putText; 
               INNER
            #);
          accessError:&lt; PSexception
            (# 
            do 'persistentstore.openRead: No access to "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" ' -&gt; msg.putText; 
               INNER 
            #);
          name: ^Text;
       enter name[]
       do ...;
       #);
    
     <B>openWrite</B><A name="persistentstore.1:openWrite.2(7)"></A><A name="openWrite.2(7)"></A>:
       (* Opens THIS(persistentstore) for writing, i.e. it is allowed
        * to update the objects saved in the store.
        * 
        * The name parameter is the name of the directory containing
        * the store and is interpreted as a path relative to the
        * current directory of the process.
        *)
       (# alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.openWrite: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" already open' -&gt; msg.putText; 
               INNER
            #);
          notFound:&lt; PSexception 
            (# 
            do 'persistentstore.openWrite: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" not found' -&gt; msg.putText; 
               INNER
            #);
          accessError:&lt; PSexception
            (# 
            do 'persistentstore.openWrite: No access to"' 
                 -&gt; msg.putText;  fullName[] -&gt; msg.putText; 
               '"' -&gt; msg.putText;
               INNER
            #);
          name: ^Text;
       enter name[]
       do ...;
       #);
     
     <B>create</B><A name="persistentstore.1:create.2(8)"></A><A name="create.2(8)"></A>:
       (* Creates a new persistentstore. The name entered is
        * interpreted as a path relative to the current directory of
        * the process. The new store is opened with write permission.
        *)
       (# alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.create: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" already open' -&gt; msg.putText; 
               INNER
            #);
          exists:&lt; PSexception 
            (* The old store is deleted if exists returns. 
             *)
            (# 
            do 'persistentstore.create: "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" already exists' -&gt; msg.putText; 
               INNER
            #);
          creationError:&lt; PSexception
            (# 
            do 'persistentstore.create: Failed creating "'
                 -&gt; msg.putText; fullName[] -&gt; msg.putText; 
               '"' -&gt; msg.putText;
               INNER
            #);
          name: ^Text;
       enter name[]
       do ...
       #);
     
     <B>checkpoint</B><A name="persistentstore.1:checkpoint.2(9)"></A><A name="checkpoint.2(9)"></A>:
       (* Saves the state of all objects in the transitive closure of
        * objects made persistent roots or fetched from this
        * persistentStore since open.  Checkpoint has no effect if the
        * store was opened by openRead.
        *)
       (# ... #);
     
     <B>close</B><A name="persistentstore.1:close.2(10)"></A><A name="close.2(10)"></A>:
       (* Performs a checkpoint, unless the doCheckpoint virtual
        * returns false, and then closes
        * THIS(persistentStore). Objects fetched from
        * THIS(persistentStore) will now turn into copies of the
        * objects saved in the store. This means that the fact that
        * the objects originally came from this store, is forgotten.
        * 
        * If allowLazyFetch is TRUE, dangling references may exist to
        * objects not yet fetched from this persistentstore. If this
        * is the case, the danglersExists virtual is called. Default
        * action is to kill the process, but other possibilities are
        * to either fetch the missing objects before closing, or
        * simply ignore the warning and close the store anyway. In the
        * latter case, usage of the objects mfetched could be fatal
        * when trying to access an object that was newer fetched from
        * the store. Ignoring should thus only be done if you are not
        * going to access the object (copies) fetched during the
        * "transaction" about to end.
        * 
        * choose todo to be 2 for sharedPersistentstores        
        *)
       (# danglersExists:&lt; 
            (# todo : @Integer;
               kill:   (# exit 0 #); 
               (* Kill the process. Default action. *)
               fetch:  (# exit 1 #); 
               (* Fetch the missing objects.        *)
               ignore: (# exit 2 #); 
               (* Ignore the dangling references.   *)
            do kill -&gt; todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue 
            (# do true -&gt; value; INNER #);
       do ...
       #);
     
     <B>get</B><A name="persistentstore.1:get.2(11)"></A><A name="get.2(11)"></A>:
       (* Reads the persistent root named "name" into memory and
        * returns a reference. If the object is already in memory, a
        * reference to the in-memory object is returned. In that case,
        * the state of the object is left untouched.
        *)
       (# quaError:&lt; Exception
            (# 
            do 'persistentstore.get: Qua error getting "' 
                 -&gt; msg.putText; name[] -&gt; msg.putText;
               '"' -&gt; msg.putText;
               INNER 
            #);
          notFound:&lt; Exception
            (# 
            do 'persistentstore.get: "' -&gt; msg.putText; 
               name[] -&gt; msg.putText;
               '" not found' -&gt; msg.putText;
               INNER
            #);
          allowLazyFetch:&lt; BooleanValue
            (# 
            do THIS(persistentstore).allowLazyFetch 
                 -&gt; value;
               INNER
            #);
          name: ^Text; type: ##Object;
          theObject: ^Object;
       enter (name[],type##)
       do ...;
       exit theObject[]
       #);
    
     <B>put</B><A name="persistentstore.1:put.2(12)"></A><A name="put.2(12)"></A>:
       (* Turns obj into a persistent root with textual name
        * "name". The state of obj is not saved until a checkpoint
        * operation is performed.
        * If dooverwrite is false, it is not possible to put a root, that
        * has the same name than a root already in the list of 
        * persistent roots. The AlreadyThere exception/warning is raised.
        * If dooverwrite is true (the default), a persistent root 
        * with the same name is overwritten. This causes the 
        * HasOverWritten exception/warning to be raised. 
        *)
       (# 
          
         AlreadyThere:&lt; PSexception 
            (# 
            do 'persistentstore.put: Root "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" ' -&gt; msg.putText; 'already there.'-&gt;msg.puttext;
               true-&gt;continue;
               INNER
               
            #);
     
          HasOverWritten:&lt; PSexception 
            (# 
            do 'persistentstore.put: Root "' 
                 -&gt; msg.putText; fullName[] -&gt; msg.putText;
               '" ' -&gt; msg.putText; 'will overwrite an already existing root with same name at checkpoint time.'-&gt;msg.puttext;
               true-&gt;continue;
               INNER
               
            #); 
          dooverwrite:&lt; BooleanValue 
            (# do true -&gt; value; INNER #);
          obj: ^Object; name: ^text;
       enter (obj[],name[])
       do ...
       #);
     
     <B>scanRootNames</B><A name="persistentstore.1:scanRootNames.2(13)"></A><A name="scanRootNames.2(13)"></A>:
       (* Iterates over the names of the persistent roots in this
        * persistent store.
        *)
       (# current: ^Text;
       do ...
       #);
     
     (* CLOSURE CONTROL
      * ===============
      * 
      * These attributes are used to limit the part of the
      * object graph saved during the checkpoint operation.
      * On the interface level of a persistentstore, there
      * is currently two ways of limiting the object graph:
      * 
      * 1. Special objects.
      * 
      *    Special objects are objects whose state is 
      *    NEVER saved persistently. However, references 
      *    to these objects should be saved so that they 
      *    may be setup correctly when saved objects 
      *    referencing special objects are reinstantiated 
      *    in another process. Typical examples or special
      *    objects are application framework objects that 
      *    are known to be present in the program 
      *    executions exchanging persistent objects, but 
      *    should not be saved themselves. Examples of 
      *    application framework objects are instances of 
      *    UIenv, systemEnv and shellEnv. (betaEnv is 
      *    always treated as a special object.)
      * 
      *    Special objects are registered once in the 
      *    lifetime of a persistent store by supplying 
      *    name and type of the object to the 
      *    "registerSpecialObject" method. The type is 
      *    saved in this persistentstore to be used for 
      *    type checking when registering special object 
      *    instances as described below. 
      * 
      *    In addition to the initial registration, an 
      *    instance of the special object must be supplied
      *    by each process using the persistent store by 
      *    calling the "registerSpecialInstance" method 
      *    when the persistentstore has been opened, but 
      *    before any get operations are made. The instance
      *    given to the registerSpecialInstance method must
      *    be a subtype of the type given to the 
      *    registerSpecialObject operation.
      * 
      * 2. Runtime types.
      * 
      *    Runtime types types of objects that are used at
      *    runtime, but should not persist across program
      *    executions. An example of this is user interface
      *    objects such as windows. Registering a 
      *    runtimeType means that instances of subtypes 
      *    are not saved, and the corresponding references
      *    saved as NONE references. As runtime types 
      *    registered using registerRuntimeType are not 
      *    saved persistently in the store, 
      *    'registerRuntimeType' must be called for each 
      *    runtime type in each session. It is of course
      *    possible to save a table of runtime types in a 
      *    persistent store if needed.
      * 
      * It is a selfcontradiction to register the type of 
      * a special object as a runtime type or vice versa. 
      * Doing so results in a runtime error.
      * 
      * Furthermore it is necessary to ensure that 
      * instances of runtime types are not origins of 
      * other objects saved. This is because it is not
      * possible to save an object without the knowledge 
      * that all its origins will be available when the 
      * object is to be reinstantiated.
      * 
      * Although it probably makes no sense, different 
      * instances of persistentstore may have different 
      * sets of specialObjects and runtimeTypes registered.
      *)
     
     <B>registerSpecialObject</B><A name="persistentstore.1:registerSpecialObject.2(14)"></A><A name="registerSpecialObject.2(14)"></A>:
       (* Special objects are registered once in the lifetime of a
        * persistent store by supplying name and type of the object
        * to this method. The type is saved in this persistentstore
        * to be used for type checking when registering special
        * object instances as described above.
        *)
        (# alreadyThere:&lt; Exception
            (# 
            do 'registerSpecialObject: Special object "' 
                 -&gt; msg.putText; name[] -&gt; msg.putText; 
               '" already exists: ' -&gt; msg.putText;
               INNER; 
               false -&gt; continue;
            #);
          name: ^Text; type: ##Object;
       enter (name[],type##)
       do ...
       #);
     
     <B>registerSpecialInstance</B><A name="persistentstore.1:registerSpecialInstance.2(15)"></A><A name="registerSpecialInstance.2(15)"></A>:
       (* In addition to the initial registration, an instance of the
        * special object must be supplied by each process using the
        * persistent store by calling this method when the
        * persistentstore has been opened, but before any 'get'
        * operations are made. The instance given to this method must
        * be a subtype of the type given to the 'registerSpecialObject'
        * operation.
        *)
       (# quaError:&lt; Exception
            (#
            do 'registerSpecialInstance: Qua error on "'
                 -&gt; msg.putText; name[] -&gt; msg.putText;
               '" instance' -&gt; msg.putText;
               INNER; 
               false -&gt; continue;
            #);
          notFound:&lt; Exception
            (# 
            do 'registerSpecialInstance: Special object "'
                 -&gt; msg.putText; name[] -&gt; msg.putText;
               '" not registered.' -&gt; msg.putText;
               INNER; 
               false -&gt; continue;
            #);
          o: ^Object; name: ^Text;
       enter (o[],name[])
       do ...
       #);
    
     <B>registerRuntimeType</B><A name="persistentstore.1:registerRuntimeType.2(16)"></A><A name="registerRuntimeType.2(16)"></A>:
       (* Runtime types types of objects that are used at runtime,
        * but should not persist across program
        * executions. Registering a runtimeType means that instances
        * of subtypes are not saved, and the corresponding references
        * saved as NONE references. As runtime types registered using
        * registerRuntimeType are not saved persistently in the store,
        * 'registerRuntimeType' must be called for each runtime type
        * in each session.
        *)
       (# type: ##Object
       enter type##
       do ...
       #);
     
     (* LAZY OPTIONS
      * ============
      * 
      * Attributes in this section are concerned with the 
      * lazy fetch of persistent objects. If used, object 
      * fetch from secondary storage may be delayed until 
      * the objects are actually needed. By using a trap
      * mechanism, fetching takes place transparently 
      * without applications being aware of it. *)
    
     <B>allowLazyFetch</B><A name="persistentstore.1:allowLazyFetch.2(17)"></A><A name="allowLazyFetch.2(17)"></A>:&lt;
       (* If not further specified, all objects in the transitive
        * closure of an object requested in a get operation are always
        * fetched at once. This default may be changed by
        * furtherbinding "allowLazyFetch" and setting "value" to
        * "true".  Default may be overridden "per get" by using the
        * allowLazyFetch virtual of get.
        *)
       BooleanValue;
     
     <B>maxCountOnDanglerHit</B><A name="persistentstore.1:maxCountOnDanglerHit.2(18)"></A><A name="maxCountOnDanglerHit.2(18)"></A>:&lt; IntegerValue
       (* When a reference to an object not yet fetched from
        * secondary storage is encountered, some number of objects
        * reachable from the object referred are fetched too. The
        * objects fetched are the 'value' first unfetched objects
        * encountered during a breadth-first traversal of the object
        * graph, using the object referred by the original dangling
        * reference as a root.
        * 
        * Object fetch continues until:
        * 
        *    1: No more unfetched objects are reachable from the root
        *       object.  or 2: maxCountOnDanglerHit objects have been
        *       fetched.
        *)
       (# do 100 -&gt; value; INNER #);
     
     <B>OnDanglerHit</B><A name="persistentstore.1:OnDanglerHit.2(19)"></A><A name="OnDanglerHit.2(19)"></A>:&lt;
       (* OnDanglerHit is called when a dangling reference is hit.
        *)
       Object;
     <B>AfterDanglerHit</B><A name="persistentstore.1:AfterDanglerHit.2(20)"></A><A name="AfterDanglerHit.2(20)"></A>:&lt; 
       (* When the object referred has been fetched, AfterDanglerHit
        * is called with the newly fetched object as parameter.
        *)
       (# theObject: ^Object;
       enter theObject[]
       do INNER
       #);
    
     <B>openpstore</B><A name="persistentstore.1:openpstore.2(21)"></A><A name="openpstore.2(21)"></A>:&lt;
       (* If this persistentstore contains references to objects in
        * other persistent stores, it may be necessary to open the
        * stores to be able to follow these references. When this
        * happens, the openpstore virtual is called. If the persistent
        * store named is not opened and returned in ps, the program
        * will terminate.
        *)
       (# psname: ^Text;
          ps: ^persistentstore;
       enter psname[]
       do INNER
       exit ps[]
       #);
     
     <B>psprivate</B><A name="persistentstore.1:psprivate.2(22)"></A><A name="psprivate.2(22)"></A>:...;
     <B>pspriv</B><A name="persistentstore.1:pspriv.2(23)"></A><A name="pspriv.2(23)"></A>: @psprivate;
  do INNER;
  #);

<B>deletePersistentStore</B><A name="deletePersistentStore.1(24)"></A>: 
  (* Deletes an existing persistentstore. It is not possible to
   * delete a persistentstore that is open in this program
   * execution. If tried anyway, the "alreadyOpen" exception is
   * raised. In case the process does not have sufficient access
   * priviliges to delete the store, the "accessError" exception is
   * raised.
   *)
  (# <B>alreadyOpen</B><A name="deletePersistentStore.1:alreadyOpen.2(25)"></A><A name="alreadyOpen.2(25)"></A>:&lt; PSexception
       (# 
       do 'persistentstore.delete: "' -&gt; msg.putText;
          fullName[] -&gt; msg.putText;
          '" is currently open' -&gt; msg.putText;
          INNER;
       #);
     <B>accessError</B><A name="deletePersistentStore.1:accessError.2(26)"></A><A name="accessError.2(26)"></A>:&lt; PSexception
       (# 
       do 'persistetstore.delete: Unable to delete "' -&gt; msg.putText; 
          fullName[] -&gt; msg.putText; '"' -&gt; msg.putText;
          INNER;
       #);
     <B>notFound</B><A name="deletePersistentStore.1:notFound.2(27)"></A><A name="notFound.2(27)"></A>:&lt; PSexception
       (# 
       do 'persistetstore.delete: "' -&gt; msg.putText; 
          fullName[] -&gt; msg.putText; '" not found' -&gt; msg.putText;
          INNER;
       #);
     <B>name</B><A name="deletePersistentStore.1:name.2(28)"></A><A name="name.2(28)"></A>: ^Text;
  enter name[]
  do ...
  #);

<B>PSexception</B><A name="PSexception.1(29)"></A>: exception
  (* PSexception is used in several exceptional situations where the
   * files making up an persistent store are not accessable. The
   * fullName parameter is the full path of the directory expected to
   * be a persistent store.
   *)
  (# <B>fullName</B><A name="PSexception.1:fullName.2(30)"></A><A name="fullName.2(30)"></A>: ^Text;
  enter fullName[]
  do INNER
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
