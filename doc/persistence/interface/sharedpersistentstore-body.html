<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Sharedpersistentstore Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("sharedpersistentstore");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="sharedpersistentstore">Sharedpersistentstore Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/distribution/basicshell';
INCLUDE '~beta/basiclib/private/betaenvbody'
        '~beta/sysutils/pathhandler'
        '~beta/basiclib/binfile'
        '~beta/basiclib/directory'
        'persistentstore'
        'lockmanagerinterface'
        'serverinterface'
        'sharedpsnotifications';
BODY 'private/sharedpersistentstorebody';
(* File sharedpersistentstore.bet
 * ===================
 * 
 * The sharedpersistentstore has the same interface as the persistent 
 * store except from the following:
 * - init has to be called in the beginning with references to the client 
 * and the server as input parameters.
 * - disconnect has to be called in the end, when the shared ps is no 
 * longer needed. If the persistent store is stil open, disconnect closes
 * it.
 * - Virtuals for closure control and for crossreferences have not 
 * been implemented yet.
 * 
 * Before a shared persisstent store creates (and thereby opens)
 * or opens a persistent store, the shared persistent store has to
 * lock the persistent store. This is done by calling server.getlock.
 * If it succeeds in getting the lock, a persistent store can be created
 * or opened. Otherwise the shared persistent store waits a second, checks
 * if some dead client is holding the lock and then makes another attempt-
 * until it succeeds.
 * When the persistent store is closed, the lock is released.
 *)
-- shellEnvLib: Attributes --
<B>shellErrorHandler</B><A name="shellErrorHandler.1(211)"></A>: errorhandler (# do INNER #);
<B>SharedPersistentStore</B><A name="SharedPersistentStore.1(212)"></A>:
  (#
     <B>PS</B><A name="SharedPersistentStore.1.PS.2(213)"></A><A name="PS.2(213)"></A>: @persistentstore;
     <B>nm</B><A name="SharedPersistentStore.1.nm.2(214)"></A><A name="nm.2(214)"></A>: ^notificationmanagement;
     <B>fullname</B><A name="SharedPersistentStore.1.fullname.2(215)"></A><A name="fullname.2(215)"></A>: ^text;
     <B>shortname</B><A name="SharedPersistentStore.1.shortname.2(216)"></A><A name="shortname.2(216)"></A>: ^text;
     <B>lockServer</B><A name="SharedPersistentStore.1.lockServer.2(217)"></A><A name="lockServer.2(217)"></A>: ^LockmanagerInterface;
     <B>client</B><A name="SharedPersistentStore.1.client.2(218)"></A><A name="client.2(218)"></A>: ^PSclient;
     <B>notificationServer</B><A name="SharedPersistentStore.1.notificationServer.2(219)"></A><A name="notificationServer.2(219)"></A>: ^notificationmanager;
     <B>serverEnsemblename</B><A name="SharedPersistentStore.1.serverEnsemblename.2(220)"></A><A name="serverEnsemblename.2(220)"></A>: ^text;
     <B>serverEnsemble</B><A name="SharedPersistentStore.1.serverEnsemble.2(221)"></A><A name="serverEnsemble.2(221)"></A>: ^ensemble;
     (* ref to server host *)
     <B>notificationserverensemble</B><A name="SharedPersistentStore.1.notificationserverensemble.2(222)"></A><A name="notificationserverensemble.2(222)"></A>: ^ensemble;
     <B>writelock</B><A name="SharedPersistentStore.1.writelock.2(223)"></A><A name="writelock.2(223)"></A>: @boolean;
     <B>readlock</B><A name="SharedPersistentStore.1.readlock.2(224)"></A><A name="readlock.2(224)"></A>: @boolean;
     <B>haslock</B><A name="SharedPersistentStore.1.haslock.2(225)"></A><A name="haslock.2(225)"></A>: @boolean;
     <B>committed</B><A name="SharedPersistentStore.1.committed.2(226)"></A><A name="committed.2(226)"></A>: @boolean;
     <B>LockErrorhandler</B><A name="SharedPersistentStore.1.LockErrorhandler.2(227)"></A><A name="LockErrorhandler.2(227)"></A>: errorhandler
       (#
          successful: @boolean;
          onFailure:
            (# theError: ^error; 
            enter theError[]
            ...
            #);
          connectionBroken::&lt;
            (# 
            do false-&gt;successful; INNER ; THIS(connectionBroken)[]-&gt;onFailure
            #);
          connectionFailed::&lt;
            (# 
            do false-&gt;successful; INNER ; THIS(connectionFailed)[]-&gt;onFailure
            #);
          timeOut::&lt;
            (# 
            do false-&gt;successful; INNER ; THIS(timeOut)[]-&gt;onFailure
            #);
          timeOutValue::&lt; (# do INNER #);
          
       do INNER
       #);
     &lt;&lt;SLOT sharedpersistentstoreLib:Attributes&gt;&gt;;
     (* initialization of the shared persistent store *)
     <B>open</B><A name="SharedPersistentStore.1.open.2(228)"></A><A name="open.2(228)"></A>:
       (#
          name: ^text;
          c: ^PSclient;
          theEnsemble: ^ensemble;
          notFound:&lt; PSexception
            (#  ... #);
          alreadyOpen:&lt;
           PSexception
            (#  ... #)
       enter
       (name[],c[],
        theEnsemble[])
       ...
       #);
     <B>Create</B><A name="SharedPersistentStore.1.Create.2(229)"></A><A name="Create.2(229)"></A>:
       (#
          name: ^text;
          alreadyOpen:&lt; PSexception
            (# 
            ...
            #);
          exists:&lt; PSexception
          (* The old store is deleted if exists returns. 
           *) (#  ... #);
          creationError:&lt;
           PSexception
            (#  ... #)
       enter name[]
       ...
       #);
     <B>getlock</B><A name="SharedPersistentStore.1.getlock.2(230)"></A><A name="getlock.2(230)"></A>:
       (#
          timeOutValue:&lt; IntegerValue (#  do - 1-&gt;value; INNER #);
          LockMode:&lt; IntegerValue (#  do Read-&gt;value; INNER #);
          LockPolicy:&lt; IntegerValue (#  do exclusive-&gt;value; INNER #)
       ...
       exit haslock
       #);
     <B>releaselock</B><A name="SharedPersistentStore.1.releaselock.2(231)"></A><A name="releaselock.2(231)"></A>:
       (# 
       ...
       #);
     <B>access</B><A name="SharedPersistentStore.1.access.2(232)"></A><A name="access.2(232)"></A>:
       (# doreget:&lt; BooleanValue (#  do true-&gt;value; INNER #); 
       ...
       #);
     (* only for clients with read-only access *)
     <B>reget</B><A name="SharedPersistentStore.1.reget.2(233)"></A><A name="reget.2(233)"></A>:
       (# theObject: ^Object; 
       enter theObject[]
       ...
       #);
     <B>commit</B><A name="SharedPersistentStore.1.commit.2(234)"></A><A name="commit.2(234)"></A>:
       (#
          doUpdateInMemoryObjects:&lt;
           Booleanvalue (#  do false-&gt;value; INNER #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       ...
       #);
     <B>Checkpoint</B><A name="SharedPersistentStore.1.Checkpoint.2(235)"></A><A name="Checkpoint.2(235)"></A>:
       (#
          NoAccessRight:&lt;
           PSexception
            (# 
            ...
            #);
          
       ...
       #);
     (* close may be call just after or replacing a commit *)
     <B>Close</B><A name="SharedPersistentStore.1.Close.2(236)"></A><A name="Close.2(236)"></A>:
       (#
          danglersExists:&lt;
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do ignore-&gt;todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       ...
       #);
     <B>Get</B><A name="SharedPersistentStore.1.Get.2(237)"></A><A name="Get.2(237)"></A>:
       (#
          quaError:&lt; Exception
            (# 
            ...
            #);
          notFound:&lt; Exception
            (#  ... #);
          name: ^Text;
          type: ##Object;
          theObject: ^object
       enter (name[],type##)
       ...
       exit theObject[]
       #);
     <B>Put</B><A name="SharedPersistentStore.1.Put.2(238)"></A><A name="Put.2(238)"></A>:
       (#
          dooverwrite:&lt; BooleanValue (#  do false-&gt;value; INNER #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       ...
       #);
     <B>scanRootNames</B><A name="SharedPersistentStore.1.scanRootNames.2(239)"></A><A name="scanRootNames.2(239)"></A>:
     (* Iterates over the names of the persistent roots in this
      * persistent store.
      *)
       (# current: ^Text; 
       ...
       #);
     <B>deletesharedpersistentstore</B><A name="SharedPersistentStore.1.deletesharedpersistentstore.2(240)"></A><A name="deletesharedpersistentstore.2(240)"></A>:
     (* Deletes an existing persistentstore. It is not possible to
      * delete a persistentstore that is open either in this process
      * or in another one.
      * If tried anyway, the "alreadyOpen" exception is
      * raised. In case the process does not have sufficient access
      * priviliges to delete the store, the "accessError" exception is
      * raised.
      *)
       (#
          alreadyOpen:&lt; PSexception
            (#  ... #);
          accessError:&lt;
           PSexception
            (#  ... #);
          notFound:&lt;
           PSexception
            (#  ... #);
          noConnection:&lt;
           PSexception
            (#  ... #);
          name: ^Text;
          ok: @boolean;
          fullname: ^text;
          serverensemble: ^ensemble;
          lockserver: ^lockmanagerInterface;
          
       enter (name[],serverensemble[])
       ...
       #);
     
  #);
<B>makeFileNames</B><A name="makeFileNames.1(241)"></A>:
  (# <B>name</B><A name="makeFileNames.1.name.2(242)"></A><A name="name.2(242)"></A>,<B>fullname</B><A name="makeFileNames.1.fullname.2(243)"></A><A name="fullname.2(243)"></A>: ^Text; <B>dirName</B><A name="makeFileNames.1.dirName.2(244)"></A><A name="dirName.2(244)"></A>: ^Text; <B>ph</B><A name="makeFileNames.1.ph.2(245)"></A><A name="ph.2(245)"></A>: @PathHandler; 
  enter name[]
  ...
  exit (dirName[])
  #);
<B>getfullname</B><A name="getfullname.1(246)"></A>:
  (#
     <B>name</B><A name="getfullname.1.name.2(247)"></A><A name="name.2(247)"></A>,<B>fullname</B><A name="getfullname.1.fullname.2(248)"></A><A name="fullname.2(248)"></A>: ^Text;
     <B>dirname</B><A name="getfullname.1.dirname.2(249)"></A><A name="dirname.2(249)"></A>: ^text;
     <B>ph</B><A name="getfullname.1.ph.2(250)"></A><A name="ph.2(250)"></A>: @PathHandler;
     
  enter name[]
  ...
  exit dirname[]
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Sharedpersistentstore Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
