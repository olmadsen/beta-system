<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Sharedpersistentstore Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("sharedpersistentstore");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="sharedpersistentstore">Sharedpersistentstore Interface</A></H1>

<PRE CLASS=interface>
(* File sharedpersistentstore.bet
 * ===================
 * 
 * The sharedpersistentstore has the same interface as the persistent 
 * store except from the following:
 * - init has to be called in the beginning with references to the client 
 * and the server as input parameters.
 * - disconnect has to be called in the end, when the shared ps is not 
 * longer needed. If the persistent store is stil open, disconnect closes
 * is.
 * - Virtuals for lazy object fetch (  ), for closure control ()
 * and for crossreferences have not been implemented yet.
 * 
 * Before a shared persisstent store creates (and thereby opens)
 * or opens a persistent store, the shared persistent store has to
 * lock the persistent store. This is done by calling server.getlock.
 * If it succeeds in getting the lock, a persistent store can be created
 * or opened. Otherwise the shared persistent store waits a second, checks
 * if some dead client is holding the lock and then makes another attempt-
 * until it succeeds.
 * When the persistent store is closed, the lock is released.
 *)
ORIGIN '~beta/distribution/basicshell';
INCLUDE '~beta/basiclib/private/betaenvbody'
        '../persistentstore'
        '~beta/sysutils/pathhandler'
        '~beta/basiclib/binfile'
        '~beta/basiclib/directory'
        'lockmanagerinterface'
        'serverinterface'
        'sharedpsnotifications';
BODY 'private/sharedpersistentstorebody';
(*BODY 'private/sharedpersistentstoreBody';*)
(* File sharedpersistentstore.bet
 * ===================
 * 
 * The sharedpersistentstore has the same interface as the persistent 
 * store except from the following:
 * - init has to be called in the beginning with references to the client 
 * and the server as input parameters.
 * - disconnect has to be called in the end, when the shared ps is not 
 * longer needed. If the persistent store is stil open, disconnect closes
 * is.
 * - Virtuals for lazy object fetch (  ), for closure control ()
 * and for crossreferences have not been implemented yet.
 * 
 * Before a shared persisstent store creates (and thereby opens)
 * or opens a persistent store, the shared persistent store has to
 * lock the persistent store. This is done by calling server.getlock.
 * If it succeeds in getting the lock, a persistent store can be created
 * or opened. Otherwise the shared persistent store waits a second, checks
 * if some dead client is holding the lock and then makes another attempt-
 * until it succeeds.
 * When the persistent store is closed, the lock is released.
 *)
(*BODY 'private/sharedpersistentstoreBody';*)
-- shellEnvLib: Attributes --
<B>shellErrorHandler</B><A name="shellErrorHandler.1(211)"></A>: errorhandler (# do INNER #);
<B>SharedPersistentStore</B><A name="SharedPersistentStore.1(212)"></A>:
  (#
     <B>PS</B><A name="SharedPersistentStore.1.PS.2(213)"></A><A name="PS.2(213)"></A>: @persistentstore
       (#
          allowLazyFetch:: THIS(sharedPersistentStore).allowLazyFetch;
          maxCountOnDanglerHit::&lt; 
            (# 
            do THIS(sharedPersistentStore).maxCountOnDanglerHit-&gt;value
            #);
          onDanglerHit::&lt;  (#  do 'Dangling reference hit...'-&gt;putText;  #);
          afterDanglerHit::&lt; 
            (# pt: @protoType; 
            do 'Object type was '-&gt;putText;
               theObject[]-&gt;getProtoType-&gt;pt;
               pt.labId-&gt;screen.putLine;
               
            #);
          
       #);
     <B>nm</B><A name="SharedPersistentStore.1.nm.2(214)"></A><A name="nm.2(214)"></A>: ^notificationmanagement;
     <B>fullname</B><A name="SharedPersistentStore.1.fullname.2(215)"></A><A name="fullname.2(215)"></A>: ^text;
     <B>shortname</B><A name="SharedPersistentStore.1.shortname.2(216)"></A><A name="shortname.2(216)"></A>: ^text;
     <B>lockServer</B><A name="SharedPersistentStore.1.lockServer.2(217)"></A><A name="lockServer.2(217)"></A>: ^LockmanagerInterface;
     <B>client</B><A name="SharedPersistentStore.1.client.2(218)"></A><A name="client.2(218)"></A>: ^PSclient;
     <B>notificationServer</B><A name="SharedPersistentStore.1.notificationServer.2(219)"></A><A name="notificationServer.2(219)"></A>: ^notificationmanager;
     <B>serverEnsemblename</B><A name="SharedPersistentStore.1.serverEnsemblename.2(220)"></A><A name="serverEnsemblename.2(220)"></A>: ^text;
     <B>serverEnsemble</B><A name="SharedPersistentStore.1.serverEnsemble.2(221)"></A><A name="serverEnsemble.2(221)"></A>: ^ensemble;
     (* ref to server host *)
     <B>notificationserverensemble</B><A name="SharedPersistentStore.1.notificationserverensemble.2(222)"></A><A name="notificationserverensemble.2(222)"></A>: ^ensemble;
     <B>writelock</B><A name="SharedPersistentStore.1.writelock.2(223)"></A><A name="writelock.2(223)"></A>: @boolean;
     <B>readlock</B><A name="SharedPersistentStore.1.readlock.2(224)"></A><A name="readlock.2(224)"></A>: @boolean;
     <B>haslock</B><A name="SharedPersistentStore.1.haslock.2(225)"></A><A name="haslock.2(225)"></A>: @boolean;
     <B>committed</B><A name="SharedPersistentStore.1.committed.2(226)"></A><A name="committed.2(226)"></A>: @boolean;
     <B>LockErrorhandler</B><A name="SharedPersistentStore.1.LockErrorhandler.2(227)"></A><A name="LockErrorhandler.2(227)"></A>: errorhandler
       (#
          successful: @boolean;
          onFailure:
            (# theError: ^error; 
            enter theError[]
            do (if theError.theObj## &lt;= LockmanagerInterface## then
               (* 'Warning: Communication with LockManager failed'-&gt;putline;*)
               (*'Get reference to server ensemble...'-&gt;putline;*)
                   getHost:
                     (# 
                     do (ensemble##,serverEnsembleName[])
                          -&gt;theShell.myEnsemble.ns.get
                            (#
                               notFound:: 
                                 (# 
                                 do serverEnsembleName[]-&gt;screen.putText;
                                    ' not found. '-&gt;putline;
                                    (*Try again: ' -&gt; screen.putText;
                                     keyboard.getLine -&gt; serverEnsembleName[];
                                     restart getHost*)
                                    
                                 #)
                            #)-&gt;serverEnsemble[];
                        (if serverEnsemble[]
                         // none then
                            'Please, start new Ensemble on '-&gt;puttext;
                            serverEnsemblename[]-&gt;putline;
                            5-&gt;sleep;
                            restart gethost
                        if);
                        
                     #);
                   getserver:
                     (# 
                     do (LockManagerInterface##,'Lockmanager')
                          -&gt;serverEnsemble.ns.get
                            (#
                               notFound:: 
                                 (# 
                                 do 'No Lockmanager on '-&gt;screen.putText;
                                    serverEnsembleName[]-&gt;screen.putLine;
                                    'Please, restart new server on '-&gt;puttext;
                                    serverEnsemblename[]-&gt;putline;
                                    5-&gt;sleep;
                                    restart getserver
                                 #)
                            #)-&gt;lockServer[];
                        
                     #);
                   theError.ignore;
                   
                else
                   theError.abort; 
               if)
            #);
          connectionBroken::&lt; 
            (# 
            do false-&gt;successful; INNER ; THIS(connectionBroken)[]-&gt;onFailure
            #);
          connectionFailed::&lt; 
            (# 
            do false-&gt;successful; INNER ; THIS(connectionFailed)[]-&gt;onFailure
            #);
          timeOut::&lt; 
            (# 
            do false-&gt;successful; INNER ; THIS(timeOut)[]-&gt;onFailure
            #);
          timeOutValue::&lt;  (# do INNER #);
          
       do INNER
       #);
     &lt;&lt;SLOT sharedpersistentstoreLib:Attributes&gt;&gt;;
     (* initialization of the shared persistent store *)
     <B>open</B><A name="SharedPersistentStore.1.open.2(228)"></A><A name="open.2(228)"></A>:
       (#
          name: ^text;
          c: ^PSclient;
          theEnsemble: ^ensemble;
          notFound:&lt; PSexception
            (# 
            do 'persistentstore.open: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER ;
               
            #);
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.open: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               INNER ;
               
            #)
       enter (name[],c[],theEnsemble[])
       ...
       #);
     <B>Create</B><A name="SharedPersistentStore.1.Create.2(229)"></A><A name="Create.2(229)"></A>:
       (#
          name: ^text;
          alreadyOpen:&lt; PSexception
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already open'-&gt;msg.putText;
               INNER ;
               
            #);
          exists:&lt; PSexception
          (* The old store is deleted if exists returns. 
           *)
            (# 
            do 'persistentstore.create: "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '" already exists'-&gt;msg.putText;
               INNER ;
               
            #);
          creationError:&lt; PSexception
            (# 
            do 'persistentstore.create: Failed creating "'-&gt;msg.putText;
               fullName[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER ;
               
            #)
       enter name[]
       ...
       #);
     <B>getlock</B><A name="SharedPersistentStore.1.getlock.2(230)"></A><A name="getlock.2(230)"></A>:
       (#
          timeOutValue:&lt;
           IntegerValue (#  do - 1-&gt;value; INNER #);
          LockMode:&lt; IntegerValue (#  do Read-&gt;value; INNER #);
          LockPolicy:&lt; IntegerValue (#  do exclusive-&gt;value; INNER #)
       ...
       exit haslock
       #);
     <B>releaselock</B><A name="SharedPersistentStore.1.releaselock.2(231)"></A><A name="releaselock.2(231)"></A>:
       (# 
       ...
       #);
     <B>access</B><A name="SharedPersistentStore.1.access.2(232)"></A><A name="access.2(232)"></A>:
       (# doreget:&lt; BooleanValue (#  do true-&gt;value; INNER #); 
       ...
       #);
     (* only for clients with read-only access *)
     <B>reget</B><A name="SharedPersistentStore.1.reget.2(233)"></A><A name="reget.2(233)"></A>:
       (# theObject: ^Object; 
       enter theObject[]
       ...
       #);
     <B>commit</B><A name="SharedPersistentStore.1.commit.2(234)"></A><A name="commit.2(234)"></A>:
       (#
          doUpdateInMemoryObjects:&lt;
           Booleanvalue (#  do false-&gt;value; INNER #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       ...
       #);
     <B>Checkpoint</B><A name="SharedPersistentStore.1.Checkpoint.2(235)"></A><A name="Checkpoint.2(235)"></A>:
       (#
          NoAccessRight:&lt;
           PSexception
            (# 
            do 'Persistentstore.checkpoint: '-&gt;msg.putText;
               'No appropriate lock has been obtained'-&gt;msg.putText;
               msg[]-&gt;putline;
               true-&gt;continue;
               INNER
            #);
          
       do (if writelock then
              PS.checkpoint;
              (* send notification to the server, if it is running a notificationmanager*)
              (if (nm[] &lt;&gt; none ) then
                  (client[],THIS(shellEnv).username,fullname[],Update)
                    -&gt;nm.notify;
                  
              if);
              
           else
              NoAccessRight; 
          if);
          
       #);
     (*close kan enten kaldes i stedet for commit eller efter commit*)
     <B>Close</B><A name="SharedPersistentStore.1.Close.2(236)"></A><A name="Close.2(236)"></A>:
       (#
          danglersExists:&lt;
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do ignore-&gt;todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       ...
       #);
     <B>Get</B><A name="SharedPersistentStore.1.Get.2(237)"></A><A name="Get.2(237)"></A>:
       (#
          quaError:&lt; Exception
            (# 
            do 'persistentstore.get: Qua error getting "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '"'-&gt;msg.putText;
               INNER ;
               
            #);
          notFound:&lt; Exception
            (# 
            do 'persistentstore.get: "'-&gt;msg.putText;
               name[]-&gt;msg.putText;
               '" not found'-&gt;msg.putText;
               INNER ;
               
            #);
          name: ^Text;
          type: ##Object;
          theObject: ^object
       enter (name[],type##)
       ...
       exit theObject[]
       #);
     <B>Put</B><A name="SharedPersistentStore.1.Put.2(238)"></A><A name="Put.2(238)"></A>:
       (#
          dooverwrite:&lt; BooleanValue
            (# 
            do false-&gt;value; INNER
            #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       ...
       #);
     <B>scanRootNames</B><A name="SharedPersistentStore.1.scanRootNames.2(239)"></A><A name="scanRootNames.2(239)"></A>:
     (* Iterates over the names of the persistent roots in this
      * persistent store.
      *)
       (# current: ^Text; 
       ...
       #);
     <B>allowLazyFetch</B><A name="SharedPersistentStore.1.allowLazyFetch.2(240)"></A><A name="allowLazyFetch.2(240)"></A>:&lt; BooleanValue;
     <B>maxCountOnDanglerHit</B><A name="SharedPersistentStore.1.maxCountOnDanglerHit.2(241)"></A><A name="maxCountOnDanglerHit.2(241)"></A>:&lt; IntegerValue (#  do 100-&gt;value; INNER #);
     
  <B>deletesharedpersistentstore</B><A name="SharedPersistentStore.1.deletesharedpersistentstore.2(242)"></A><A name="deletesharedpersistentstore.2(242)"></A>:
(* Deletes an existing persistentstore. It is not possible to
 * delete a persistentstore that is open either in this process
 * or in another one.
 * If tried anyway, the "alreadyOpen" exception is
 * raised. In case the process does not have sufficient access
 * priviliges to delete the store, the "accessError" exception is
 * raised.
 *)
  (#
     alreadyOpen:&lt; PSexception
       (# 
       do 'Error in persistentstore.delete: "'-&gt;msg.putText;
          fullName[]-&gt;msg.putText;
          '" is currently open.'-&gt;msg.putText;
          msg[]-&gt;putline;
          true-&gt;continue;
          INNER ;
          
       #);
     accessError:&lt; PSexception
       (# 
       do 'persistetstore.delete: Unable to delete "'-&gt;msg.putText;
          fullName[]-&gt;msg.putText;
          '"'-&gt;msg.putText;
          INNER ;
          
       #);
     notFound:&lt; PSexception
       (# 
       do 'persistetstore.delete: "'-&gt;msg.putText;
          fullName[]-&gt;msg.putText;
          '" not found'-&gt;msg.putText;
          INNER ;
          
       #);
     noConnection:&lt; PSexception
       (# 
       do 'persistetstore.delete: "'-&gt;msg.putText;
          'No communication to the server. The PS is not deleted'-&gt;msg.puttext;
          INNER ;
          
       #);
     name: ^Text;
     ok: @boolean;
     fullname: ^text;
     serverensemble: ^ensemble;
     lockserver: ^lockmanagerInterface;
     
  enter (name[],serverensemble[])
  do true-&gt;ok;
     'in delete'-&gt;putline;
     name[]-&gt;getfullname-&gt;fullname[];
     getlockmanager:
     (LockManagerInterface##,'Lockmanager')
       -&gt;serverEnsemble.ns.get
         (# notFound::  (#  do noConnection; leave getlockmanager;  #)
         #)-&gt;lockServer[];
     'efter getlock server'-&gt;putline;
     dogetpermission: errorhandler
       (#
          onFailure:
            (# theError: ^error; 
            enter theError[]
            do (if theError.theObj## &lt;= LockManagerInterface## then
                   false-&gt;ok; theError.ignore; leave dogetpermission; 
                else
                   theError.abort; 
               if)
            #);
          connectionBroken::  (#  do THIS(connectionBroken)[]-&gt;onFailure #);
          connectionFailed::  (#  do THIS(connectionFailed)[]-&gt;onFailure #);
          timeOut::  (#  do THIS(timeOut)[]-&gt;onFailure #);
          timeOutValue::&lt;  (#  do 5-&gt;sec #);
          
       do fullname[]-&gt;lockServer.getPermissiontoDeletePS-&gt;ok; 
       #);
     (if ok then
         'ok is true'-&gt;putline;
         dodelete:
         fullname[]
           -&gt;ps.deletePersistentStore
             (#
                accessError:: 
                  (# 
                  do fullName[]-&gt;THIS(deletesharedpersistentstore).accessError; 
                  #);
                alreadyOpen:: 
                  (# 
                  do fullName[]-&gt;THIS(deletesharedpersistentstore).alreadyOpen; 
                  #);
                notFound:: 
                  (# 
                  do fullName[]-&gt;THIS(deletesharedpersistentstore).notFound; 
                  #)
             #);
         
      else
         fullname[]-&gt;THIS(deletesharedpersistentstore).alreadyOpen; 
     if);
     
  #);
   
  #);
<B>makeFileNames</B><A name="makeFileNames.1(243)"></A>:
  (#
     <B>name</B><A name="makeFileNames.1.name.2(244)"></A><A name="name.2(244)"></A>,<B>fullname</B><A name="makeFileNames.1.fullname.2(245)"></A><A name="fullname.2(245)"></A>: ^Text;
     <B>dirName</B><A name="makeFileNames.1.dirName.2(246)"></A><A name="dirName.2(246)"></A>: ^Text;
     <B>ph</B><A name="makeFileNames.1.ph.2(247)"></A><A name="ph.2(247)"></A>: @PathHandler;
     
  enter name[]
  do ph.init;
     name.copy-&gt;fullname[];
     (fullname[],ph.CurrentDirectory)-&gt;ph.convertFilePath-&gt;fullname[];
     fullname.copy-&gt;dirName[];
     (if fullname.t[fullname.lgth] &lt;&gt; ph.directoryChar then
         fullname.lgth-&gt;fullname.pos; ph.directoryChar-&gt;fullname.put; 
     if);
     
  exit (dirName[])
  #);
<B>getfullname</B><A name="getfullname.1(248)"></A>:
  (# <B>name</B><A name="getfullname.1.name.2(249)"></A><A name="name.2(249)"></A>,<B>fullname</B><A name="getfullname.1.fullname.2(250)"></A><A name="fullname.2(250)"></A>: ^Text; <B>dirname</B><A name="getfullname.1.dirname.2(251)"></A><A name="dirname.2(251)"></A>: ^text; <B>ph</B><A name="getfullname.1.ph.2(252)"></A><A name="ph.2(252)"></A>: @PathHandler; 
  enter name[]
  do ph.init;
     name.copy-&gt;fullname[];
     (fullname[],ph.CurrentDirectory)-&gt;ph.convertFilePath-&gt;fullname[];
     fullname.copy-&gt;dirName[];
     (if fullname.t[fullname.lgth] &lt;&gt; ph.directoryChar then
         fullname.lgth-&gt;fullname.pos; ph.directoryChar-&gt;fullname.put; 
     if);
     
  exit dirname[]
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Sharedpersistentstore Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
