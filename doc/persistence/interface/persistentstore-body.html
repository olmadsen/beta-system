<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Persistentstore Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("persistentstore");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="persistentstore">Persistentstore Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv' (* 
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
;
INCLUDE '~beta/basiclib/directory'
        '~beta/basiclib/external'
        '~beta/basiclib/directory'
        '~beta/sysutils/objinterface'
        '~beta/containers/list';
BODY 'private/psbody';
-- lib: Attributes --
(* PSEXCEPTION
 * ===========
 * 
 * PSexception is used in several exceptional situations where the files
 * making up an persistent store are not accessable. The fullName parameter
 * is the full path of the directory expected to be a persistent store. *)
<B>PSexception</B><A name="PSexception.1(1)"></A>: exception (# <B>fullName</B><A name="PSexception.1.fullName.2(2)"></A><A name="fullName.2(2)"></A>: ^Text;  enter fullName[] do INNER #);
(* PERSISTENTSTORE
 * ===============
 *)
<B>persistentstore</B><A name="persistentstore.1(3)"></A>:
  (#
     &lt;&lt;SLOT PSlib:Attributes&gt;&gt;;
     <B>PSroot</B><A name="persistentstore.1.PSroot.2(4)"></A><A name="PSroot.2(4)"></A>:
       (# name: ^text; type: ##object; obj: ^Object
       enter (name[],type##,obj[])
       #);
     <B>PSrootsList</B><A name="persistentstore.1.PSrootsList.2(5)"></A><A name="PSrootsList.2(5)"></A>: list (# element:: PSroot #);
     <B>PSroots</B><A name="persistentstore.1.PSroots.2(6)"></A><A name="PSroots.2(6)"></A>: ^PSrootsList;
     <B>PSstoreID</B><A name="persistentstore.1.PSstoreID.2(7)"></A><A name="PSstoreID.2(7)"></A>: @integer;
     <B>assertOpen</B><A name="persistentstore.1.assertOpen.2(8)"></A><A name="assertOpen.2(8)"></A>:
       (#
          notOpen:&lt; PSException
            (# 
            ...
            #);
          
       ...
       #);
     <B>assertInit</B><A name="persistentstore.1.assertInit.2(9)"></A><A name="assertInit.2(9)"></A>:
       (#
          notInitialized:&lt; PSException
            (#  ... #);
          
       ...
       #);
     <B>numberOfUpdates</B><A name="persistentstore.1.numberOfUpdates.2(10)"></A><A name="numberOfUpdates.2(10)"></A>:
       (# result: @integer ... exit result #);
     <B>lastupdate</B><A name="persistentstore.1.lastupdate.2(11)"></A><A name="lastupdate.2(11)"></A>: @integer;
     <B>hostName</B><A name="persistentstore.1.hostName.2(12)"></A><A name="hostName.2(12)"></A>: (#  exit 'localhost' #);
     <B>openCrossStoreItem</B><A name="persistentstore.1.openCrossStoreItem.2(13)"></A><A name="openCrossStoreItem.2(13)"></A>: ^openpstore;
     <B>UNKNOWNTAG</B><A name="persistentstore.1.UNKNOWNTAG.2(14)"></A><A name="UNKNOWNTAG.2(14)"></A>: (#  exit 0 #);
     <B>rebinderItem</B><A name="persistentstore.1.rebinderItem.2(15)"></A><A name="rebinderItem.2(15)"></A>: ^rebindSpecialReference;
     <B>rebindSpecialReference</B><A name="persistentstore.1.rebindSpecialReference.2(16)"></A><A name="rebindSpecialReference.2(16)"></A>:&lt;
       (#
          target: ^Object;
          toSpecialObject:&lt;
            (#
               objectTag: @integer;
               NotHandled:&lt; PSException
                 (#  ... #)
            enter objectTag
            do INNER
            #);
          toSpecialType:&lt;
            (# typeTag: @integer
            enter typeTag
            do INNER
            #);
          objectTag,typeTag: @integer
       enter (objectTag,typeTag)
       ...
       exit target[]
       #);
     <B>commit</B><A name="persistentstore.1.commit.2(17)"></A><A name="commit.2(17)"></A>: assertInit
       (#
          doUpdateInMemoryObjects:&lt; BooleanValue
            (#  do false-&gt;value; INNER #);
          doCheckpoint:&lt; BooleanValue (#  do true-&gt;value; INNER #);
          
       do INNER
       #);
     <B>reget</B><A name="persistentstore.1.reget.2(18)"></A><A name="reget.2(18)"></A>: assertInit
       (#
          NotFound:&lt; PSException (#  ... #);
          theObject: ^Object;
          
       enter theObject[]
       do INNER
       #);
     <B>init</B><A name="persistentstore.1.init.2(19)"></A><A name="init.2(19)"></A>: (#  ... #);
     <B>create</B><A name="persistentstore.1.create.2(20)"></A><A name="create.2(20)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (#  ... #);
          exists:&lt; PSexception
          (* The old store is deleted if exists returns. 
           *) (#  ... #);
          creationError:&lt; PSexception
            (# 
            ...
            #);
          name: ^Text;
          
       enter name[]
       ...
       #);
     <B>abstractOpenOperation</B><A name="persistentstore.1.abstractOpenOperation.2(21)"></A><A name="abstractOpenOperation.2(21)"></A>: assertInit
       (#
          alreadyOpenMessage:&lt;
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          notFoundMessage:&lt;
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          accessErrorMessage:&lt;
            (# msg: ^text
            do INNER
            exit msg[]
            #);
          alreadyOpen:&lt; PSexception
            (# 
            ...
            #);
          notFound:&lt; PSexception (#  ... #);
          accessError:&lt; PSexception
            (#  ... #);
          name: ^Text;
          openFunc:&lt;
            (#
               host,path: [1] @Char;
               rcode: @integer
            enter (host,path)
            do INNER
            exit rcode
            #)
       enter name[]
       ...
       #);
     <B>openRead</B><A name="persistentstore.1.openRead.2(22)"></A><A name="openRead.2(22)"></A>: abstractOpenOperation
       (#
          alreadyOpenMessage:: 
            (#  ... #);
          notFoundMessage:: 
            (# 
            ...
            #);
          accessErrorMessage:: 
            (#  ... #);
          openFunc:: 
            (# 
            ...
            #);
          
       do INNER
       #);
     <B>openWrite</B><A name="persistentstore.1.openWrite.2(23)"></A><A name="openWrite.2(23)"></A>: abstractOpenOperation
       (#
          alreadyOpenMessage:: 
            (#  ... #);
          notFoundMessage:: 
            (# 
            ...
            #);
          accessErrorMessage:: 
            (#  ... #);
          openFunc:: 
            (# 
            ...
            #);
          
       do INNER
       #);
     <B>checkpoint</B><A name="persistentstore.1.checkpoint.2(24)"></A><A name="checkpoint.2(24)"></A>: assertInit (#  ... #);
     <B>close</B><A name="persistentstore.1.close.2(25)"></A><A name="close.2(25)"></A>: assertInit
       (#
          danglersExists:&lt;
            (#
               todo : @Integer;
               kill: (#  exit 0 #);
               (* Kill the process. Default action. *)
               fetch: (#  exit 1 #);
               (* Fetch the missing objects.        *)
               ignore: (#  exit 2 #);
               (* Ignore the dangling references.   *)
               
            do kill-&gt;todo ; INNER
            exit todo #);
          doCheckpoint:&lt; BooleanValue (#  do false-&gt;value; INNER #);
          
       ...
       #);
     <B>get</B><A name="persistentstore.1.get.2(26)"></A><A name="get.2(26)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (#  ... #);
          notFound:&lt;
           Exception (#  ... #);
          allowLazyFetch:&lt;
          (* Lazy Fetch is obsolete. This boolean is
           * here for backwards compatibility only
           * and will eventually be removed *) BooleanValue
            (# do INNER #);
          name: ^Text;
          type: ##Object;
          theObject: ^Object;
          
       enter (name[],type##)
       ...
       exit theObject[]
       #);
     <B>ALREADYTHEREERROR</B><A name="persistentstore.1.ALREADYTHEREERROR.2(27)"></A><A name="ALREADYTHEREERROR.2(27)"></A>: (#  exit 6 #);
     <B>HASOVERWRITTENERROR</B><A name="persistentstore.1.HASOVERWRITTENERROR.2(28)"></A><A name="HASOVERWRITTENERROR.2(28)"></A>: (#  exit 7 #);
     <B>put</B><A name="persistentstore.1.put.2(29)"></A><A name="put.2(29)"></A>: assertInit
       (#
          AlreadyThere:&lt; PSexception
            (# 
            ...
            #);
          HasOverWritten:&lt; PSexception
            (#  ... #);
          dooverwrite:&lt; BooleanValue
            (# 
            do true-&gt;value; INNER
            #);
          obj: ^Object;
          name: ^text;
          
       enter (obj[],name[])
       ...
       #);
     <B>scanRootNames</B><A name="persistentstore.1.scanRootNames.2(30)"></A><A name="scanRootNames.2(30)"></A>: assertInit
       (# current: ^Text; 
       do PSroots.scan
            (#  do current.name[]-&gt;THIS(scanRootNames).current[] #);
          INNER
       #);
     <B>registerSpecialObject</B><A name="persistentstore.1.registerSpecialObject.2(31)"></A><A name="registerSpecialObject.2(31)"></A>: assertInit
       (#
          alreadyThere:&lt; Exception
            (#  ... #);
          name: ^Text;
          type: ##Object;
          
       enter (name[],type##)
       ...
       #);
     <B>registerRuntimeType</B><A name="persistentstore.1.registerRuntimeType.2(32)"></A><A name="registerRuntimeType.2(32)"></A>: assertInit
       (# type: ##Object
       enter type##
       do 'registerRuntimeType: This function is not implemented in the new'
            -&gt;screen.putLine;
          'persistent store, and the call should be removed.'-&gt;screen.putLine;
          
       #);
     <B>allowLazyFetch</B><A name="persistentstore.1.allowLazyFetch.2(33)"></A><A name="allowLazyFetch.2(33)"></A>:&lt;
     (* Lazy Fetch is obsolete. This boolean is
      * here for backwards compatibility only
      * and will eventually be removed *) BooleanValue;
     <B>maxCountOnDanglerHit</B><A name="persistentstore.1.maxCountOnDanglerHit.2(34)"></A><A name="maxCountOnDanglerHit.2(34)"></A>:&lt; IntegerValue (#  do 100-&gt;value; INNER #);
     <B>OnDanglerHit</B><A name="persistentstore.1.OnDanglerHit.2(35)"></A><A name="OnDanglerHit.2(35)"></A>:&lt; Object;
     <B>AfterDanglerHit</B><A name="persistentstore.1.AfterDanglerHit.2(36)"></A><A name="AfterDanglerHit.2(36)"></A>:&lt;(# theObject: ^Object;  enter theObject[] do INNER #);
     <B>openpstore</B><A name="persistentstore.1.openpstore.2(37)"></A><A name="openpstore.2(37)"></A>:&lt;
       (# psname: ^Text; ps: ^persistentstore; 
       enter psname[]
       do INNER
       exit ps[]
       #);
     <B>deletePersistentStore</B><A name="persistentstore.1.deletePersistentStore.2(38)"></A><A name="deletePersistentStore.2(38)"></A>: assertInit
       (#
          alreadyOpen:&lt; PSexception
            (#  ... #);
          accessError:&lt; PSexception
            (# 
            ...
            #);
          notFound:&lt; PSexception (#  ... #);
          name: ^Text;
          storeDir: @directory;
          
       enter name[]
       ...
       #);
     <B>registerSpecialInstance</B><A name="persistentstore.1.registerSpecialInstance.2(39)"></A><A name="registerSpecialInstance.2(39)"></A>: assertInit
       (#
          quaError:&lt; Exception
            (#  ... #);
          notFound:&lt; Exception
            (# 
            ...
            #);
          o: ^Object;
          tag: @integer;
          (* The arguments to 'RegisterSpecialInstance' is now no longer 
           * an object and a name, but an object and an 8 bit integer value.
           * The integer tag will be the id of the special object. 
           *)
          
       enter (o[],tag)
       ...
       #);
     
  do INNER ; 
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Persistentstore Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
