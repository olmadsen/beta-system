HTMLPUBLIC"-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd"<!DOCTYPE HTML= PUBLIC= "-//W3C//DTD HTML 4.01 Transitional//EN"= "http://www.w3.org/TR/REC-html40/loose.dtd"=><HTML>


<HTML>(
)<HEAD><HEAD><HTML>(
)<HEAD>

<HTML>(
{<HEAD>})


<HEAD>(
)http-equivCONTENT<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1"><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1"><HEAD>(
)<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1"><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1"><HTML>(
{<HEAD>(
)})<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">

<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">})


<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
)<H1><H1><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
)<H1><H1><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
)})<H1><H1><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
)})})<H1>

<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>}) Lazy object fetch Lazy object fetch Lazy object fetch<H1>( Lazy object fetch)NAME<A NAME=MARKER-2-34><A NAME=MARKER-2-34><H1>( Lazy object fetch)<A NAME=MARKER-2-34><A NAME=MARKER-2-34><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch)})<A NAME=MARKER-2-34><A NAME=MARKER-2-34><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch)})})<A NAME=MARKER-2-34><A NAME=MARKER-2-34><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch)})})})<A NAME=MARKER-2-34> Lazy object fetch Lazy object fetch<H1>( Lazy object fetch{<A NAME=MARKER-2-34>})</A></A><A NAME=MARKER-2-34></A><A NAME=MARKER-2-34></A></H1></H1><H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1><H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>}<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
]})<BLOCKQUOTE><BLOCKQUOTE><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
]})<BLOCKQUOTE><BLOCKQUOTE><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
]})})<BLOCKQUOTE><BLOCKQUOTE><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
]})})})<BLOCKQUOTE>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>}]})


<BLOCKQUOTE>(
)<P><P><BLOCKQUOTE>(
)<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
)}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
)}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
)}]})})})<P>

<BLOCKQUOTE>(
{<P>})<STRONG><STRONG><P><STRONG><STRONG><BLOCKQUOTE>(
{<P>})<STRONG><STRONG><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>})}]})<STRONG><STRONG><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>})}]})})<STRONG><STRONG><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>})}]})})})<STRONG><P>(<STRONG>)Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistenseNote that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistenseNote that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG></STRONG><STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG><STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG></P></P><P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P><P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>



{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>}<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P><BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE></BLOCKQUOTE><BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE><BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>






{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>}]}<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

]}]}

<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>}]}]}) When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root. When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root. When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P></P><P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P><P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>






{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>}]}]}<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

]}]}]}

<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>}]}]}]}) By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject. By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject. By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P></P><P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P><P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>}]}]}]}<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
]}]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
]}]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>}]}]}]}]}) In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual. In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual. In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P></P><P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P><P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>}]}]}]}]}<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
]}]}]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
]}]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
]}]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
]}]}]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
]}]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>}]}]}]}]}]}) So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references  So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references  So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references <P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references )NAME<A NAME=MARKER-2-35><A NAME=MARKER-2-35><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references )<A NAME=MARKER-2-35><A NAME=MARKER-2-35><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references )}]}]}]}]}]})<A NAME=MARKER-2-35><A NAME=MARKER-2-35><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references )}]}]}]}]}]})})<A NAME=MARKER-2-35><A NAME=MARKER-2-35><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references )}]}]}]}]}]})})})<A NAME=MARKER-2-35> So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references  So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references <P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35>})</A></A><A NAME=MARKER-2-35></A><A NAME=MARKER-2-35></A> are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>}<A NAME=MARKER-2-35></A><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]})<EM><EM><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]})<EM><EM><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]})}]}]}]}]}]})<EM><EM><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]})}]}]}]}]}]})})<EM><EM><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]})}]}]}]}]}]})})})<EM> So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed]} are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>}]})RELHREF<A REL=FOOTNOTE HREF="#FOOTNOTE-4"><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><EM><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>}]})<A REL=FOOTNOTE HREF="#FOOTNOTE-4"><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>}]})}]}]}]}]}]})<A REL=FOOTNOTE HREF="#FOOTNOTE-4"><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>}]})}]}]}]}]}]})})<A REL=FOOTNOTE HREF="#FOOTNOTE-4"><A REL=FOOTNOTE HREF="#FOOTNOTE-4"><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>}]})}]}]}]}]}]})})})<A REL=FOOTNOTE HREF="#FOOTNOTE-4"><EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">)[4][4][4]<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A></A><A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A><A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A></EM></EM><EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM><EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94]., the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94]., the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94]. So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>}]}<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P></P><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P><P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>}]}]}]}]}]}<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
]}]}]}]}]}]})<BLOCKQUOTE><BLOCKQUOTE><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
]}]}]}]}]}]})<BLOCKQUOTE><BLOCKQUOTE><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
]}]}]}]}]}]})})<BLOCKQUOTE><BLOCKQUOTE><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
]}]}]}]}]}]})})})<BLOCKQUOTE>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
]}]}]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>}]}]}]}]}]}]})


<BLOCKQUOTE>(
)<P><P><BLOCKQUOTE>(
)<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
)}]}]}]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
)}]}]}]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
)}]}]}]}]}]}]})})})<P>

<BLOCKQUOTE>(
{<P>})Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P></P><P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P><P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>



{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>}<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P><BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE></BLOCKQUOTE><BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE><BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>}]}]}]}]}]}]}<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
]}]}]}]}]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
]}]}]}]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
]}]}]}]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
]}]}]}]}]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
]}]}]}]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>}]}]}]}]}]}]}]}) In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit)NAME<A NAME=MARKER-2-36><A NAME=MARKER-2-36><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit)<A NAME=MARKER-2-36><A NAME=MARKER-2-36><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit)}]}]}]}]}]}]}]})<A NAME=MARKER-2-36><A NAME=MARKER-2-36><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit)}]}]}]}]}]}]}]})})<A NAME=MARKER-2-36><A NAME=MARKER-2-36><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit)}]}]}]}]}]}]}]})})})<A NAME=MARKER-2-36> In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36>})</A></A><A NAME=MARKER-2-36></A><A NAME=MARKER-2-36></A>NAME<A NAME=MARKER-2-37><A NAME=MARKER-2-37><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>})<A NAME=MARKER-2-37><A NAME=MARKER-2-37><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>})}]}]}]}]}]}]}]})<A NAME=MARKER-2-37><A NAME=MARKER-2-37><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>})}]}]}]}]}]}]}]})})<A NAME=MARKER-2-37><A NAME=MARKER-2-37><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>})}]}]}]}]}]}]}]})})})<A NAME=MARKER-2-37> In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>}<A NAME=MARKER-2-36></A><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37>]})</A></A><A NAME=MARKER-2-37></A><A NAME=MARKER-2-37></A> and persistentstore.AfterDanglerHit and persistentstore.AfterDanglerHit and persistentstore.AfterDanglerHit In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>]}<A NAME=MARKER-2-37></A><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]})NAME<A NAME=MARKER-2-38><A NAME=MARKER-2-38><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]})<A NAME=MARKER-2-38><A NAME=MARKER-2-38><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]})}]}]}]}]}]}]}]})<A NAME=MARKER-2-38><A NAME=MARKER-2-38><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]})}]}]}]}]}]}]}]})})<A NAME=MARKER-2-38><A NAME=MARKER-2-38><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]})}]}]}]}]}]}]}]})})})<A NAME=MARKER-2-38> In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit]]} and persistentstore.AfterDanglerHit<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38>}]]})</A></A><A NAME=MARKER-2-38></A><A NAME=MARKER-2-38></A> virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays. virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays. virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays. In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>}]]}<A NAME=MARKER-2-38></A><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P></P><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P><P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>}]}]}]}]}]}]}]}<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
]}]}]}]}]}]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
]}]}]}]}]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
]}]}]}]}]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
]}]}]}]}]}]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
]}]}]}]}]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>}]}]}]}]}]}]}]}]}) It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs. It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs. It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P></P><P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P><P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>



{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>}]}]}]}]}]}]}]}]}<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
]}]}]}]}]}]}]}]}]})<P><P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
]}]}]}]}]}]}]}]}]})<P><P><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
]}]}]}]}]}]}]}]}]})})<P><P><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
]}]}]}]}]}]}]}]}]})})})<P>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
]}]}]}]}]}]}]}]}]}
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>}]}]}]}]}]}]}]}]}]}) The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch. The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch. The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P></P><P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P><P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>





















{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>}]}]}]}]}]}]}]}]}]}<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






]}]}]}]}]}]}]}]}]}]})<HR><HR><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






]}]}]}]}]}]}]}]}]}]})<HR><HR><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






]}]}]}]}]}]}]}]}]}]})})<HR><HR><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






]}]}]}]}]}]}]}]}]}]})})})<HR>
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






]}]}]}]}]}]}]}]}]}]}






<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>}]}]}]}]}]}]}]}]}]}]})





<HR>(

)NAME<A NAME=FOOTNOTE-4><A NAME=FOOTNOTE-4><HR>(

)<A NAME=FOOTNOTE-4><A NAME=FOOTNOTE-4><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

)}]}]}]}]}]}]}]}]}]}]})<A NAME=FOOTNOTE-4><A NAME=FOOTNOTE-4><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

)}]}]}]}]}]}]}]}]}]}]})})<A NAME=FOOTNOTE-4><A NAME=FOOTNOTE-4><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

)}]}]}]}]}]}]}]}]}]}]})})})<A NAME=FOOTNOTE-4>



<HR>(

{<A NAME=FOOTNOTE-4>})[4] [4] [4] <A NAME=FOOTNOTE-4>([4] )</A></A><A NAME=FOOTNOTE-4>([4] )</A><A NAME=FOOTNOTE-4>([4] )</A>
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.




 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.




 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.





{<A NAME=FOOTNOTE-4>([4] )</A>}<A NAME=FOOTNOTE-4>([4] )</A><HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]})</BODY></BODY><HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]})</BODY></BODY><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]})}]}]}]}]}]}]}]}]}]}]})</BODY></BODY><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]})}]}]}]}]}]}]}]}]}]}]})})</BODY></BODY><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]})}]}]}]}]}]}]}]}]}]}]})})})</BODY>

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



]}
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>}]})


</BODY>(
)</HTML></HTML></BODY>(
)</HTML></HTML><HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>(
)}]})</HTML></HTML><META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>(
)}]})}]}]}]}]}]}]}]}]}]}]})</HTML></HTML><HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>(
)}]})}]}]}]}]}]}]}]}]}]}]})})</HTML></HTML><HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>( Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>(
)}]})}]}]}]}]}]}]}]}]}]}]})})})</HTML></BODY>(
)<!DOCTYPE HTML= PUBLIC= "-//W3C//DTD HTML 4.01 Transitional//EN"= "http://www.w3.org/TR/REC-html40/loose.dtd"=>[<HTML>(
{<TABLE VALIGN=MIDDLE WIDTH="100%" CELLPADDING=0 CELLSPACING=2>(
{<TR>(
{<TD>(
{<a HREF="crossref.html">(<IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0>)</a>[

{<a HREF="advanced.html">(<IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0>)</a>[

{<a HREF="../index.html">(<IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0>)</a>[

{<a HREF="index.html">(<IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0>)</a>[

{<a HREF="inx.html">(<IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0>)</a>[

{<a HREF="print.html">(<IMG ALIGN=BOTTOM SRC="../images/print.gif" ALT=Print BORDER=0>)</a>[
]}]}]}]}]}]})</TD>[
{<TH ALIGN=right>( Persistence In BETA)</TH>[
]}]})</TR>[
]})</TABLE>[

]})</HTML>]<!DOCTYPE HTML= PUBLIC= "-//W3C//DTD HTML 4.01 Transitional//EN"= "http://www.w3.org/TR/REC-html40/loose.dtd"=>[<HTML>(
{<HEAD>(
{<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">(
{<H1>(Lazy object fetch{<A NAME=MARKER-2-34></A>})</H1>[
{<BLOCKQUOTE>(
{<P>(<STRONG>(Note that the new persistense always runs using lazy fetch. This section
is therefore only relevant to users of the old persistense)</STRONG>)</P>[
]})</BLOCKQUOTE>[

{<P>( When fetching an object from a persistent store using the get operation, the default is to eagerly fetch all objects in the transitive closure of the persistent root specified. However, since this may involve a huge number of objects not really needed by the current program execution, the persistent store offers the possibility to fetch the transitive closure lazily as the program goes along following references from the persistent root.)</P>[

{<P>( By further binding the persistentstore.allowLazyFetch virtual to trueObject, the default fetch strategy is changed to lazy fetch. Alternatively the fetch strategy may be set on a per get basis by further binding the get.allowLazyFetch virtual to trueObject.)</P>[
{<P>( In short, lazy fetch works as follows. Using the persistent store get operation, the object graph reachable from the persistent root is always fetched in a breadth-first manner, whether or not lazy fetch is applied. In the case of lazy fetch, instead of fetching the full object graph, only a limited number of objects are fetched from secondary storage and instantiated in the current process. The objects fetched are the persistentstore.maxFetchOnDanglerHitfirst objects met during the breadth-first traversal. The default number of objects fetched may be changed by further binding the maxFetchOnDanglerHit virtual.)</P>[
{<P>( So, what about the objects not fetched? Since these objects are not instantiated, it is impossible to setup usual in-memory references. Instead socalled dangling references {<A NAME=MARKER-2-35></A>[ are used. Simply stated, a dangling reference is a negative number uniquely identifying a persistent object to the current process. If a dangling reference is ever followed{<EM>(<A REL=FOOTNOTE HREF="#FOOTNOTE-4">([4])</A>)</EM>[, the same mechanism that checks for NONE references will trap to the persistent store kernel in order to transparently fetch the object needed from secondary storage. Also in this case the objects fetched are the maxFetchOnDanglerHit first objects met during a breadth-first traversal of the object graph rooted in the object needed. All dangling references in the process referencing newly fetched objects are replaced by genuine in-memory references. A more detailed description of the implementation of lazy object fetch may be found in [Brandt 94].]}]})</P>[
{<BLOCKQUOTE>(
{<P>(Note that the --noCheckNone (or -s 14 0 ) compiler switch suppressing the generation of runtime checks for NONE references cannot be used in programs using lazy object fetch!)</P>[
]})</BLOCKQUOTE>[
{<P>( In addition to maxFetchOnDanglerHit and allowLazyFetch, the persistentstore.OnDanglerHit{<A NAME=MARKER-2-36></A>[<A NAME=MARKER-2-37></A>[ and persistentstore.AfterDanglerHit{<A NAME=MARKER-2-38></A>[ virtuals are used in conjunction with lazy object fetch.  OnDanglerHit is called when a dangling reference has been hit, but before the object is actually fetched from secondary storage. AfterDanglerHit  is called when the object has been fetched, giving the object as parameter. When AfterDanglerHit returns, the program continues whatever it was doing when the dangling reference was hit. The purpose of these virtuals is to offer informative callbacks that may be used for example in interactive programs where lazy object fetch may otherwise result in inexplicable delays.]}]]})</P>[
{<P>( It should be noted that there are no semantic differences whatsoever between lazy and eager object fetch. The practical difference lies in different efficiency/memory usage trade-offs.)</P>[
{<P>( The demo programs largeWrite.bet and largeRead.bet together illustrates the use of lazy fetch.)</P>[






{<HR>(

{<A NAME=FOOTNOTE-4>([4] )</A>[
 Followed here means &quot;accessing the state of the object referred&quot;. Usual reference assignment on dangling references are not different from ordinary reference assignments.



{</BODY>(
)}]})}]}]}]}]}]}]}]}]}]}]})})})</HTML>]<!DOCTYPE HTML= PUBLIC= "-//W3C//DTD HTML 4.01 Transitional//EN"= "http://www.w3.org/TR/REC-html40/loose.dtd"=>[<HTML>(
{<center>(
  {<FONT SIZE="-1">(&#169; 
    {<A HREF="http://www.mjolner.com">(Mj&oslash;lner Informatics)</A>[
  ]})</FONT>[
]})</center>[

{<TABLE VALIGN=MIDDLE WIDTH="100%" CELLPADDING=0 CELLSPACING=2>(
{<TR>(
{<TD>(
{<a HREF="crossref.html">(<IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0>)</a>[
{<a HREF="advanced.html">(<IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0>)</a>[

{<a HREF="../index.html">(<IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0>)</a>[

{<a HREF="index.html">(<IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0>)</a>[

{<a HREF="inx.html">(<IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0>)</a>[

{<a HREF="print.html">(<IMG ALIGN=BOTTOM SRC="../images/print.gif" ALT=Print BORDER=0>)</a>[
]}]}]}]}]}]})</TD>[
{<TH ALIGN=right>( Persistence In BETA)</TH>[
]}]})})</TABLE>[

]}]})</HTML>]