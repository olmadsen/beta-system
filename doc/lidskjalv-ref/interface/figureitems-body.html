<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Figureitems Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="figureitems">Figureitems Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'guienv';
LIB_DEF 'guienvfigureitems' '../lib';
BODY 'private/figureitemsbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- windowLib: attributes --
<B>figureItem</B><A name="figureItem.1(215)"></A>: windowitem
  (* superclass for all vector graphics *)
  (# &lt;&lt;SLOT figureItemLib: attributes&gt;&gt;;
     <B>pen</B><A name="figureItem.1:pen.2(216)"></A><A name="pen.2(216)"></A>: @
       (* this item models the properties of the pen used to draw the
        * outline of THIS(figureItem)
        *)
       (# <B>foregroundColor</B><A name="figureItem.1:pen.2:foregroundColor.3(217)"></A><A name="foregroundColor.3(217)"></A>: 
            (* sets the foreground color of the pen used to draw
             * THIS(figureItem)
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>backgroundColor</B><A name="figureItem.1:pen.2:backgroundColor.3(218)"></A><A name="backgroundColor.3(218)"></A>: 
            (* sets the background color of the pen used to draw
             * THIS(figureItem)
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>stipple</B><A name="figureItem.1:pen.2:stipple.3(219)"></A><A name="stipple.3(219)"></A>:
            (* The pattern used for stippling when drawing with the
             * pen
             *)
            (# p: ^pixmap;
            enter (# enter p[] do ... #)
            exit (# do ... exit p[] #)
            #);
          <B>size</B><A name="figureItem.1:pen.2:size.3(220)"></A><A name="size.3(220)"></A>: 
            (* sets the size of the pen used to draw THIS(figureItem)
             *)
            (# value: @integer;
            enter (# enter value do ... #)
            exit (# do ... exit value #)
            #);
       #) (* pen *);
     <B>open</B><A name="figureItem.1:open.2(221)"></A><A name="open.2(221)"></A>::&lt; 
       (* The initialy pen characteristics of THIS(figureItem) are 
        *   stiple          = patterns.black
        *   foreGroundColor = colors.black
        *   backGroundColor = colors.white
        *   size      = 1
        *)
       (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>eventhandler</B><A name="figureItem.1:eventhandler.2(222)"></A><A name="eventhandler.2(222)"></A>::&lt;
       (# <B>onRefresh</B><A name="figureItem.1:eventhandler.2:onRefresh.3(223)"></A><A name="onRefresh.3(223)"></A>::&lt;(# do ...; #);
       #);
     <B>private</B><A name="figureItem.1:private.2(224)"></A><A name="private.2(224)"></A>: @...;
  #) (* figureItem *);
<B>line</B><A name="line.1(225)"></A>: figureItem
  (* straight line defined by a startPt and a endPt *)
  (# &lt;&lt;SLOT lineLib: attributes&gt;&gt;;
     <B>start</B><A name="line.1:start.2(226)"></A><A name="start.2(226)"></A>: 
       (# theStart: @point;
       enter (# enter theStart do ... #)
       exit (# do ... exit theStart #)
       #);
     <B>end</B><A name="line.1:end.2(227)"></A><A name="end.2(227)"></A>: 
       (# theEnd: @point;
       enter (# enter theEnd do ... #)
       exit (# do ... exit theEnd #)
       #);
     <B>open</B><A name="line.1:open.2(228)"></A><A name="open.2(228)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="line.1:eventhandler.2(229)"></A><A name="eventhandler.2(229)"></A>::&lt;
       (# <B>onRefresh</B><A name="line.1:eventhandler.2:onRefresh.3(230)"></A><A name="onRefresh.3(230)"></A>::&lt;(# do ... #);
          <B>onFrameChanged</B><A name="line.1:eventhandler.2:onFrameChanged.3(231)"></A><A name="onFrameChanged.3(231)"></A>::&lt;(# do ... #);
          <B>onHiliteChanged</B><A name="line.1:eventhandler.2:onHiliteChanged.3(232)"></A><A name="onHiliteChanged.3(232)"></A>::&lt;(#  do ... #);
       #);
     <B>private</B><A name="line.1:private.2(233)"></A><A name="private.2(233)"></A>: @...;
  #) (* line *);
<B>shape</B><A name="shape.1(234)"></A>: figureItem
  (* figures that can be filled *)
  (# &lt;&lt;SLOT shapeLib: attributes&gt;&gt;;
     <B>fill</B><A name="shape.1:fill.2(235)"></A><A name="fill.2(235)"></A>: @
       (* This item models the properties of the fill of THIS(shape)
        *)
       (# <B>tile</B><A name="shape.1:fill.2:tile.3(236)"></A><A name="tile.3(236)"></A>: 
            (* Sets the tile raster used to fill THIS(figureItem) *)
            (# p: ^pixmap;
            enter (# enter p[] do ... #)
            exit (# do ... exit p[] #)
            #);
          <B>foregroundColor</B><A name="shape.1:fill.2:foregroundColor.3(237)"></A><A name="foregroundColor.3(237)"></A>: 
            (* Sets the foreground color of the pen used to draw
             * THIS(figureItem).
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>backgroundColor</B><A name="shape.1:fill.2:backgroundColor.3(238)"></A><A name="backgroundColor.3(238)"></A>: 
            (* Sets the background color of the pen used to draw
             * THIS(figureItem).
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
       #);
     <B>open</B><A name="shape.1:open.2(239)"></A><A name="open.2(239)"></A>::&lt; 
       (* The fill of THIS(shape) is initially: 
        *   colorForeground = black
        *   colorBackground = white
        *)
       (# do ... #);
     <B>eventhandler</B><A name="shape.1:eventhandler.2(240)"></A><A name="eventhandler.2(240)"></A>::&lt;
       (# <B>onRefresh</B><A name="shape.1:eventhandler.2:onRefresh.3(241)"></A><A name="onRefresh.3(241)"></A>::&lt;(# do ... #);
          <B>onHiliteChanged</B><A name="shape.1:eventhandler.2:onHiliteChanged.3(242)"></A><A name="onHiliteChanged.3(242)"></A>::&lt;(#  do ... #);
       #);
     <B>private</B><A name="shape.1:private.2(243)"></A><A name="private.2(243)"></A>: @...;
  #) (* shape *);
<B>oval</B><A name="oval.1(244)"></A>: shape
  (* the oval is defined by a rectangle *)
  (# &lt;&lt;SLOT ovalLib: attributes&gt;&gt;;
     <B>open</B><A name="oval.1:open.2(245)"></A><A name="open.2(245)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="oval.1:eventhandler.2(246)"></A><A name="eventhandler.2(246)"></A>::&lt;
       (# <B>onRefresh</B><A name="oval.1:eventhandler.2:onRefresh.3(247)"></A><A name="onRefresh.3(247)"></A>::&lt;(# do ... #);
       #);
  #) (* oval *);
<B>rect</B><A name="rect.1(248)"></A>: shape
  (# &lt;&lt;SLOT rectLib: attributes&gt;&gt;;
     <B>open</B><A name="rect.1:open.2(249)"></A><A name="open.2(249)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="rect.1:eventhandler.2(250)"></A><A name="eventhandler.2(250)"></A>::&lt;
       (# <B>onRefresh</B><A name="rect.1:eventhandler.2:onRefresh.3(251)"></A><A name="onRefresh.3(251)"></A>::&lt;(# do ... #);
       #);
  #) (* rect *);
<B>roundRect</B><A name="roundRect.1(252)"></A>: shape
  (* rectangular shape with rounded corners *)
  (# &lt;&lt;SLOT roundRectLib: attributes&gt;&gt;;
     <B>open</B><A name="roundRect.1:open.2(253)"></A><A name="open.2(253)"></A>::&lt; (# do ... #);
     <B>roundness</B><A name="roundRect.1:roundness.2(254)"></A><A name="roundness.2(254)"></A>: 
       (* the corner roundness is specified by means of an Oval *)
       (# theOvalHeight,theOvalWidth: @integer;
       enter (# enter (theOvalHeight,theOvalWidth) do ... #)
       exit (# do ... exit (theOvalHeight,theOvalWidth) #)
       #);
     <B>eventhandler</B><A name="roundRect.1:eventhandler.2(255)"></A><A name="eventhandler.2(255)"></A>::&lt;
       (# <B>onRefresh</B><A name="roundRect.1:eventhandler.2:onRefresh.3(256)"></A><A name="onRefresh.3(256)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="roundRect.1:private.2(257)"></A><A name="private.2(257)"></A>: @...;
  #) (* roundRect *);
<B>wedge</B><A name="wedge.1(258)"></A>: shape
  (* a piece of cake *)
  (# &lt;&lt;SLOT wedgeLib: attributes&gt;&gt;;
     <B>open</B><A name="wedge.1:open.2(259)"></A><A name="open.2(259)"></A>::&lt; (# do ... #);
     <B>startAngle</B><A name="wedge.1:startAngle.2(260)"></A><A name="startAngle.2(260)"></A>: 
       (* evaluate the enter part to set the angle, where THIS(wedge)
        * starts.  Evaluate the exit part to get it
        *)
       (# angle: @integer;
       enter (# enter angle do ... #)
       exit (# do ... exit angle #)
       #);
     <B>endAngle</B><A name="wedge.1:endAngle.2(261)"></A><A name="endAngle.2(261)"></A>: 
       (* evaluate the enter part to set the angle, where THIS(wedge)
        * ends.  Evaluate the exit part to get it
        *)
       (# angle: @integer;
       enter (# enter angle do ... #)
       exit (# do ... exit angle #)
       #);
     <B>eventhandler</B><A name="wedge.1:eventhandler.2(262)"></A><A name="eventhandler.2(262)"></A>::&lt;
       (# <B>onRefresh</B><A name="wedge.1:eventhandler.2:onRefresh.3(263)"></A><A name="onRefresh.3(263)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="wedge.1:private.2(264)"></A><A name="private.2(264)"></A>: @...;
  #) (* wedge *);
<B>polygon</B><A name="polygon.1(265)"></A>: shape
  (# &lt;&lt;SLOT polygonLib: attributes&gt;&gt;;
     <B>points</B><A name="polygon.1:points.2(266)"></A><A name="points.2(266)"></A>: 
       (* set or get the points that represents THIS(polygon).  There
        * must be at least 3 points
        *)
       (# thePoints: [3] ^point;
       enter (# enter thePoints do ... #)
       exit (# do ... exit thePoints #)
       #);
     <B>open</B><A name="polygon.1:open.2(267)"></A><A name="open.2(267)"></A>::&lt;
       (#  
       do ...;
       #);
     <B>eventhandler</B><A name="polygon.1:eventhandler.2(268)"></A><A name="eventhandler.2(268)"></A>::&lt;
       (# <B>onRefresh</B><A name="polygon.1:eventhandler.2:onRefresh.3(269)"></A><A name="onRefresh.3(269)"></A>::&lt;(# do ... #);
          <B>onFrameChanged</B><A name="polygon.1:eventhandler.2:onFrameChanged.3(270)"></A><A name="onFrameChanged.3(270)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="polygon.1:private.2(271)"></A><A name="private.2(271)"></A>: @...;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Figureitems Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
