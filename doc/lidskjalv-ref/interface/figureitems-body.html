<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Figureitems Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("figureitems");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="figureitems">Figureitems Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'guienv';
LIB_DEF 'guienvfigureitems' '../lib';
BODY 'private/figureitemsbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- windowLib: attributes --
<B>figureItem</B><A name="figureItem.1(216)"></A>: windowitem
  (* superclass for all vector graphics *)
  (# &lt;&lt;SLOT figureItemLib: attributes&gt;&gt;;
     <B>pen</B><A name="figureItem.1.pen.2(217)"></A><A name="pen.2(217)"></A>: @
       (* this item models the properties of the pen used to draw the
        * outline of THIS(figureItem)
        *)
       (# <B>foregroundColor</B><A name="figureItem.1.pen.2.foregroundColor.3(218)"></A><A name="foregroundColor.3(218)"></A>: 
            (* sets the foreground color of the pen used to draw
             * THIS(figureItem)
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>backgroundColor</B><A name="figureItem.1.pen.2.backgroundColor.3(219)"></A><A name="backgroundColor.3(219)"></A>: 
            (* sets the background color of the pen used to draw
             * THIS(figureItem)
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>stipple</B><A name="figureItem.1.pen.2.stipple.3(220)"></A><A name="stipple.3(220)"></A>:
            (* The pattern used for stippling when drawing with the
             * pen
             *)
            (# p: ^pixmap;
            enter (# enter p[] do ... #)
            exit (# do ... exit p[] #)
            #);
          <B>size</B><A name="figureItem.1.pen.2.size.3(221)"></A><A name="size.3(221)"></A>: 
            (* sets the size of the pen used to draw THIS(figureItem)
             *)
            (# value: @integer;
            enter (# enter value do ... #)
            exit (# do ... exit value #)
            #);
       #) (* pen *);
     <B>open</B><A name="figureItem.1.open.2(222)"></A><A name="open.2(222)"></A>::&lt; 
       (* The initialy pen characteristics of THIS(figureItem) are 
        *   stiple          = patterns.black
        *   foreGroundColor = colors.black
        *   backGroundColor = colors.white
        *   size      = 1
        *)
       (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>eventhandler</B><A name="figureItem.1.eventhandler.2(223)"></A><A name="eventhandler.2(223)"></A>::&lt;
       (# <B>onRefresh</B><A name="figureItem.1.eventhandler.2.onRefresh.3(224)"></A><A name="onRefresh.3(224)"></A>::&lt;(# do ...; #);
       #);
     <B>private</B><A name="figureItem.1.private.2(225)"></A><A name="private.2(225)"></A>: @...;
  #) (* figureItem *);
<B>line</B><A name="line.1(226)"></A>: figureItem
  (* straight line defined by a startPt and a endPt *)
  (# &lt;&lt;SLOT lineLib: attributes&gt;&gt;;
     <B>start</B><A name="line.1.start.2(227)"></A><A name="start.2(227)"></A>: 
       (# theStart: @point;
       enter (# enter theStart do ... #)
       exit (# do ... exit theStart #)
       #);
     <B>end</B><A name="line.1.end.2(228)"></A><A name="end.2(228)"></A>: 
       (# theEnd: @point;
       enter (# enter theEnd do ... #)
       exit (# do ... exit theEnd #)
       #);
     <B>open</B><A name="line.1.open.2(229)"></A><A name="open.2(229)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="line.1.eventhandler.2(230)"></A><A name="eventhandler.2(230)"></A>::&lt;
       (# <B>onRefresh</B><A name="line.1.eventhandler.2.onRefresh.3(231)"></A><A name="onRefresh.3(231)"></A>::&lt;(# do ... #);
          <B>onFrameChanged</B><A name="line.1.eventhandler.2.onFrameChanged.3(232)"></A><A name="onFrameChanged.3(232)"></A>::&lt;(# do ... #);
          <B>onHiliteChanged</B><A name="line.1.eventhandler.2.onHiliteChanged.3(233)"></A><A name="onHiliteChanged.3(233)"></A>::&lt;(#  do ... #);
       #);
     <B>private</B><A name="line.1.private.2(234)"></A><A name="private.2(234)"></A>: @...;
  #) (* line *);
<B>shape</B><A name="shape.1(235)"></A>: figureItem
  (* figures that can be filled *)
  (# &lt;&lt;SLOT shapeLib: attributes&gt;&gt;;
     <B>fill</B><A name="shape.1.fill.2(236)"></A><A name="fill.2(236)"></A>: @
       (* This item models the properties of the fill of THIS(shape)
        *)
       (# <B>tile</B><A name="shape.1.fill.2.tile.3(237)"></A><A name="tile.3(237)"></A>: 
            (* Sets the tile raster used to fill THIS(figureItem) *)
            (# p: ^pixmap;
            enter (# enter p[] do ... #)
            exit (# do ... exit p[] #)
            #);
          <B>foregroundColor</B><A name="shape.1.fill.2.foregroundColor.3(238)"></A><A name="foregroundColor.3(238)"></A>: 
            (* Sets the foreground color of the pen used to draw
             * THIS(figureItem).
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
          <B>backgroundColor</B><A name="shape.1.fill.2.backgroundColor.3(239)"></A><A name="backgroundColor.3(239)"></A>: 
            (* Sets the background color of the pen used to draw
             * THIS(figureItem).
             *)
            (# theColor: @color;
            enter (# enter theColor do ... #)
            exit (# do ... exit theColor #)
            #);
       #);
     <B>open</B><A name="shape.1.open.2(240)"></A><A name="open.2(240)"></A>::&lt; 
       (* The fill of THIS(shape) is initially: 
        *   colorForeground = black
        *   colorBackground = white
        *)
       (# do ... #);
     <B>eventhandler</B><A name="shape.1.eventhandler.2(241)"></A><A name="eventhandler.2(241)"></A>::&lt;
       (# <B>onRefresh</B><A name="shape.1.eventhandler.2.onRefresh.3(242)"></A><A name="onRefresh.3(242)"></A>::&lt;(# do ... #);
          <B>onHiliteChanged</B><A name="shape.1.eventhandler.2.onHiliteChanged.3(243)"></A><A name="onHiliteChanged.3(243)"></A>::&lt;(#  do ... #);
       #);
     <B>private</B><A name="shape.1.private.2(244)"></A><A name="private.2(244)"></A>: @...;
  #) (* shape *);
<B>oval</B><A name="oval.1(245)"></A>: shape
  (* the oval is defined by a rectangle *)
  (# &lt;&lt;SLOT ovalLib: attributes&gt;&gt;;
     <B>open</B><A name="oval.1.open.2(246)"></A><A name="open.2(246)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="oval.1.eventhandler.2(247)"></A><A name="eventhandler.2(247)"></A>::&lt;
       (# <B>onRefresh</B><A name="oval.1.eventhandler.2.onRefresh.3(248)"></A><A name="onRefresh.3(248)"></A>::&lt;(# do ... #);
       #);
  #) (* oval *);
<B>rect</B><A name="rect.1(249)"></A>: shape
  (# &lt;&lt;SLOT rectLib: attributes&gt;&gt;;
     <B>open</B><A name="rect.1.open.2(250)"></A><A name="open.2(250)"></A>::&lt; (# do ... #);
     <B>eventhandler</B><A name="rect.1.eventhandler.2(251)"></A><A name="eventhandler.2(251)"></A>::&lt;
       (# <B>onRefresh</B><A name="rect.1.eventhandler.2.onRefresh.3(252)"></A><A name="onRefresh.3(252)"></A>::&lt;(# do ... #);
       #);
  #) (* rect *);
<B>roundRect</B><A name="roundRect.1(253)"></A>: shape
  (* rectangular shape with rounded corners *)
  (# &lt;&lt;SLOT roundRectLib: attributes&gt;&gt;;
     <B>open</B><A name="roundRect.1.open.2(254)"></A><A name="open.2(254)"></A>::&lt; (# do ... #);
     <B>roundness</B><A name="roundRect.1.roundness.2(255)"></A><A name="roundness.2(255)"></A>: 
       (* the corner roundness is specified by means of an Oval *)
       (# theOvalHeight,theOvalWidth: @integer;
       enter (# enter (theOvalHeight,theOvalWidth) do ... #)
       exit (# do ... exit (theOvalHeight,theOvalWidth) #)
       #);
     <B>eventhandler</B><A name="roundRect.1.eventhandler.2(256)"></A><A name="eventhandler.2(256)"></A>::&lt;
       (# <B>onRefresh</B><A name="roundRect.1.eventhandler.2.onRefresh.3(257)"></A><A name="onRefresh.3(257)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="roundRect.1.private.2(258)"></A><A name="private.2(258)"></A>: @...;
  #) (* roundRect *);
<B>wedge</B><A name="wedge.1(259)"></A>: shape
  (* a piece of cake *)
  (# &lt;&lt;SLOT wedgeLib: attributes&gt;&gt;;
     <B>open</B><A name="wedge.1.open.2(260)"></A><A name="open.2(260)"></A>::&lt; (# do ... #);
     <B>startAngle</B><A name="wedge.1.startAngle.2(261)"></A><A name="startAngle.2(261)"></A>: 
       (* evaluate the enter part to set the angle, where THIS(wedge)
        * starts.  Evaluate the exit part to get it
        *)
       (# angle: @integer;
       enter (# enter angle do ... #)
       exit (# do ... exit angle #)
       #);
     <B>endAngle</B><A name="wedge.1.endAngle.2(262)"></A><A name="endAngle.2(262)"></A>: 
       (* evaluate the enter part to set the angle, where THIS(wedge)
        * ends.  Evaluate the exit part to get it
        *)
       (# angle: @integer;
       enter (# enter angle do ... #)
       exit (# do ... exit angle #)
       #);
     <B>eventhandler</B><A name="wedge.1.eventhandler.2(263)"></A><A name="eventhandler.2(263)"></A>::&lt;
       (# <B>onRefresh</B><A name="wedge.1.eventhandler.2.onRefresh.3(264)"></A><A name="onRefresh.3(264)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="wedge.1.private.2(265)"></A><A name="private.2(265)"></A>: @...;
  #) (* wedge *);
<B>polygon</B><A name="polygon.1(266)"></A>: shape
  (# &lt;&lt;SLOT polygonLib: attributes&gt;&gt;;
     <B>points</B><A name="polygon.1.points.2(267)"></A><A name="points.2(267)"></A>: 
       (* set or get the points that represents THIS(polygon).  There
        * must be at least 3 points
        *)
       (# thePoints: [3] ^point;
       enter (# enter thePoints do ... #)
       exit (# do ... exit thePoints #)
       #);
     <B>open</B><A name="polygon.1.open.2(268)"></A><A name="open.2(268)"></A>::&lt;
       (#  
       do ...;
       #);
     <B>eventhandler</B><A name="polygon.1.eventhandler.2(269)"></A><A name="eventhandler.2(269)"></A>::&lt;
       (# <B>onRefresh</B><A name="polygon.1.eventhandler.2.onRefresh.3(270)"></A><A name="onRefresh.3(270)"></A>::&lt;(# do ... #);
          <B>onFrameChanged</B><A name="polygon.1.eventhandler.2.onFrameChanged.3(271)"></A><A name="onFrameChanged.3(271)"></A>::&lt;(# do ... #);
       #);
     <B>private</B><A name="polygon.1.private.2(272)"></A><A name="private.2(272)"></A>: @...;
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Figureitems Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
