<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Graphmath Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="graphics.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="scrolllists.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Graphmath Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'guienvgraphmath' '../lib';
BODY 'private/graphmathbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
<B>point</B><A name="point.1(662)"></A>: 
  (* A point is defined as the intersection between a vertical line
   * and a horisontal line in the coordinate plane
   *)
  (# &lt;&lt;SLOT pointLib: attributes&gt;&gt;;
     <B>v</B><A name="point.1:v.2(663)"></A><A name="v.2(663)"></A>,<B> h</B><A name="point.1:h.2(664)"></A><A name="h.2(664)"></A>: @integer;
     <B>add</B><A name="point.1:add.2(665)"></A><A name="add.2(665)"></A>: 
       (* adds the coordinates of p to the coordinates THIS(point) *)
       (# p: @point
       enter p
       do ...
       #);
     <B>subtract</B><A name="point.1:subtract.2(666)"></A><A name="subtract.2(666)"></A>: 
       (* subtracts the coordinates of p from the coordinates of
        * THIS(point)
        *)
       (# p: @point
       enter p
       do ...
       #);
     <B>isEqual</B><A name="point.1:isEqual.2(667)"></A><A name="isEqual.2(667)"></A>: booleanValue
       (* compares THIS(point) to p and returns true if they are
        * equal or false if not
        *)
       (# p: @point
       enter p
       do ...
       #);
  enter (h, v)
  exit  (h, v)
  #) (* point *);
<B>rectangle</B><A name="rectangle.1(668)"></A>: 
  (* rectangles are used to define areas on the screen, to assign
   * coordinate systems to graphic entities, and to specify the
   * location and sizes for various drawing commands.  A rectangle is
   * defined by two points topLeft, bottomRight, which denote the
   * top-left corner and the bottom-right corner of the rectangle
   *)
  (# &lt;&lt;SLOT rectangleLib: attributes&gt;&gt;;
     <B>topLeft</B><A name="rectangle.1:topLeft.2(669)"></A><A name="topLeft.2(669)"></A>:
       (# 
       enter (left, top)
       exit (left, top)
       #);
     <B>bottomRight</B><A name="rectangle.1:bottomRight.2(670)"></A><A name="bottomRight.2(670)"></A>:
       (# 
       enter (right, bottom)
       exit (right, bottom)
       #);
     <B>left</B><A name="rectangle.1:left.2(671)"></A><A name="left.2(671)"></A>,<B> top</B><A name="rectangle.1:top.2(672)"></A><A name="top.2(672)"></A>,<B> right</B><A name="rectangle.1:right.2(673)"></A><A name="right.2(673)"></A>,<B> bottom</B><A name="rectangle.1:bottom.2(674)"></A><A name="bottom.2(674)"></A>: @integer;
     
     <B>set</B><A name="rectangle.1:set.2(675)"></A><A name="set.2(675)"></A>:
       (* assigns the four boundary coordinates to THIS(rectangle) *)
       (# left, top, right, bottom: @integer
       enter (left, top, right, bottom)
       do ...
       #);
     <B>setFromPoints</B><A name="rectangle.1:setFromPoints.2(676)"></A><A name="setFromPoints.2(676)"></A>: 
       (* sets THIS(rectangle) to the smallest rectangle that
        * encloses the two given points p1, p2
        *)
       (# p1, p2: @point;
       enter (p1, p2)
       do ...
       #);
     <B>size</B><A name="rectangle.1:size.2(677)"></A><A name="size.2(677)"></A>: 
       (* evaluate the enter part to set the width and height.
        * Evaluate the exit part to get the width and height
        *)
       (# w, h: @integer;
       enter (#  enter (w, h) do ... #)
       exit (# do ... exit (w, h)  #)
       #);
     <B>offset</B><A name="rectangle.1:offset.2(678)"></A><A name="offset.2(678)"></A>: 
       (* moves THIS(rectangle) by adding delta.h to each horizontal
        * coordinate and delta.v to each vertical coordinate
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>inset</B><A name="rectangle.1:inset.2(679)"></A><A name="inset.2(679)"></A>: 
       (* shrinks or expands THIS(rectangle). The left and right
        * sides are moved in by the amount specified by delta.h; the
        * top and bottom are moved toward the center by the amount
        * specified by delta.v.  If delta.h or delta.v is negative,
        * the appropriate pair of sides is moved outward instead of
        * inward
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>intersection</B><A name="rectangle.1:intersection.2(680)"></A><A name="intersection.2(680)"></A>: booleanValue
       (* calculates the rectangle that is the intersection of src1
        * and src2, sets THIS(rectangle) to the intersection. Result
        * is set to true iff src1 and src2 indeed intersect
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do ...
       #);
     <B>union</B><A name="rectangle.1:union.2(681)"></A><A name="union.2(681)"></A>: 
       (* calculates the smallest rectangle that encloses src1 and
        * src2, and sets THIS(rectangle) to the result
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do ...
       #);
     <B>containsPoint</B><A name="rectangle.1:containsPoint.2(682)"></A><A name="containsPoint.2(682)"></A>: booleanValue
       (* determines whether the pixel below and to the right of the
        * given coordinate point is enclosed in the specified
        * rectangle, and returns true if so or false if not
        *)
       (# p: @point
       enter p
       do ...
       #);
     <B>pToAngle</B><A name="rectangle.1:pToAngle.2(683)"></A><A name="pToAngle.2(683)"></A>: 
       (* calculates an integer angle between a line from the center
        * of the rectangle to thePoint and a line from the center of
        * the rectangle pointing straight up (12 o'clock high). The
        * angle is in degrees from 0 to 359, measured clockwise from
        * 12 oUclock, with 90 degrees at 3 o'clock, 180 at 6 o'clock,
        * and 270 at 9 o'clock
        *)
       (# thePoint: @point; angle: @integer
       enter thePoint
       do ...
       exit angle
       #);
     <B>isEqual</B><A name="rectangle.1:isEqual.2(684)"></A><A name="isEqual.2(684)"></A>: booleanValue
       (* compares theRectangle to THIS(rectangle) and returns true
        * if they are equal or false if not. The two rectangles must
        * have identical boundary coordinates to be considered equal
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>isEmpty</B><A name="rectangle.1:isEmpty.2(685)"></A><A name="isEmpty.2(685)"></A>: booleanValue
       (* returns true if THIS(rectangle) is an empty rectangle or
        * false if not.  A rectangle is considered empty if the bottom
        * coordinate is less than or equal to the top or the right
        * coordinate is less than or equal to the left
        *)
       (# do ... #);
  enter (topLeft, bottomRight)
  exit  (topLeft, bottomRight)
  #) (* rectangle *);
<B>matrix</B><A name="matrix.1(686)"></A>: 
  (# &lt;&lt; slot matrixLib: attributes&gt;&gt;;
     (* a  b  0
      * c  d  0
      * tx ty 1
      *)
     <B>a</B><A name="matrix.1:a.2(687)"></A><A name="a.2(687)"></A>,<B> b</B><A name="matrix.1:b.2(688)"></A><A name="b.2(688)"></A>,<B> c</B><A name="matrix.1:c.2(689)"></A><A name="c.2(689)"></A>,<B> d</B><A name="matrix.1:d.2(690)"></A><A name="d.2(690)"></A>,<B> tx</B><A name="matrix.1:tx.2(691)"></A><A name="tx.2(691)"></A>,<B> ty</B><A name="matrix.1:ty.2(692)"></A><A name="ty.2(692)"></A>: @real;
     <B>inverse</B><A name="matrix.1:inverse.2(693)"></A><A name="inverse.2(693)"></A>: ^matrix;
     <B>mult</B><A name="matrix.1:mult.2(694)"></A><A name="mult.2(694)"></A>: (* Multiply two matrices *)
       (# A, B, res: ^matrix;
       enter (A[], B[])
       do ...
       exit res[]
       #);
     <B>transformPoint</B><A name="matrix.1:transformPoint.2(695)"></A><A name="transformPoint.2(695)"></A>: @
       (# p, result: @point;
       enter p
       do ...
       exit result
       #);
     <B>inverseTransformPoint</B><A name="matrix.1:inverseTransformPoint.2(696)"></A><A name="inverseTransformPoint.2(696)"></A>: @
       (# p1, p2: @point;
       enter p1
       do ...
       exit p2
       #);
     <B>transformRectangle</B><A name="matrix.1:transformRectangle.2(697)"></A><A name="transformRectangle.2(697)"></A>: @
       (# r, result: @rectangle;
       enter r
       do ...
       exit result
       #);
     <B>inverseTransformRectangle</B><A name="matrix.1:inverseTransformRectangle.2(698)"></A><A name="inverseTransformRectangle.2(698)"></A>: 
       (# r, result: @rectangle;
       enter r
       do ...
       exit result
       #);
     <B>getInverse</B><A name="matrix.1:getInverse.2(699)"></A><A name="getInverse.2(699)"></A>: @
       (# get: @...;
       do get;
       exit inverse[]
       #);
  enter (a, b, c, d, tx, ty)
  do INNER;
  exit (a, b, c, d, tx, ty)
  #);
<B>IDmatrix</B><A name="IDmatrix.1(700)"></A>: 
  (# <B>ID</B><A name="IDmatrix.1:ID.2(701)"></A><A name="ID.2(701)"></A>: ^matrix 
  do ...
  exit ID[]
  #);
<B>moveMatrix</B><A name="moveMatrix.1(702)"></A>: matrix   (* A matrix specifying a translation *)
  (# <B>itx</B><A name="moveMatrix.1:itx.2(703)"></A><A name="itx.2(703)"></A>,<B> ity</B><A name="moveMatrix.1:ity.2(704)"></A><A name="ity.2(704)"></A>: @integer;
  enter (itx, ity)
  do ...
  #);
<B>scaleMatrix</B><A name="scaleMatrix.1(705)"></A>: matrix  (* A matrix specifying a scaling *)
  (# 
  enter (a, d)
  do ...
  #);
<B>rotateMatrix</B><A name="rotateMatrix.1(706)"></A>: matrix (* A matrix specifying a rotation *)
  (# <B>theta</B><A name="rotateMatrix.1:theta.2(707)"></A><A name="theta.2(707)"></A>: @real;
  enter theta
  do ...
  #);
<B>ovalAngle</B><A name="ovalAngle.1(708)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the oval with center in (cx,cy) and
   * horizontal radius hr and verticalradius vr, i.e.
   *    (x,y) = (cx,cy) + (hr*cos(a),vr*sin(a))
   *)
  (# <B>cx</B><A name="ovalAngle.1:cx.2(709)"></A><A name="cx.2(709)"></A>,<B> cy</B><A name="ovalAngle.1:cy.2(710)"></A><A name="cy.2(710)"></A>,<B> hr</B><A name="ovalAngle.1:hr.2(711)"></A><A name="hr.2(711)"></A>,<B> vr</B><A name="ovalAngle.1:vr.2(712)"></A><A name="vr.2(712)"></A>,<B> x</B><A name="ovalAngle.1:x.2(713)"></A><A name="x.2(713)"></A>,<B> y</B><A name="ovalAngle.1:y.2(714)"></A><A name="y.2(714)"></A>: @integer;
     <B>a</B><A name="ovalAngle.1:a.2(715)"></A><A name="a.2(715)"></A>,<B> cos_a</B><A name="ovalAngle.1:cos_a.2(716)"></A><A name="cos_a.2(716)"></A>,<B> sin_a</B><A name="ovalAngle.1:sin_a.2(717)"></A><A name="sin_a.2(717)"></A>: @real;
     <B>angle</B><A name="ovalAngle.1:angle.2(718)"></A><A name="angle.2(718)"></A>: @...;
  enter (cx, cy, hr, vr, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
<B>circleAngle</B><A name="circleAngle.1(719)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the circle with center in (cx,cy) and
   * radius r, for some r i.e. (x,y) = (cx,cy) + (r*cos(a),r*sin(a))
   *)
  (# <B>cx</B><A name="circleAngle.1:cx.2(720)"></A><A name="cx.2(720)"></A>,<B> cy</B><A name="circleAngle.1:cy.2(721)"></A><A name="cy.2(721)"></A>,<B> x</B><A name="circleAngle.1:x.2(722)"></A><A name="x.2(722)"></A>,<B> y</B><A name="circleAngle.1:y.2(723)"></A><A name="y.2(723)"></A>: @integer;
     <B>a</B><A name="circleAngle.1:a.2(724)"></A><A name="a.2(724)"></A>,<B> cos_a</B><A name="circleAngle.1:cos_a.2(725)"></A><A name="cos_a.2(725)"></A>,<B> sin_a</B><A name="circleAngle.1:sin_a.2(726)"></A><A name="sin_a.2(726)"></A>: @real;
     <B>angle</B><A name="circleAngle.1:angle.2(727)"></A><A name="angle.2(727)"></A>: @...;
  enter (cx, cy, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
<B>region</B><A name="region.1(728)"></A>: 
  (* A region is a collection of spatially coherent points *)
  (# &lt;&lt;SLOT regionLib: attributes&gt;&gt;;
     <B>bounds</B><A name="region.1:bounds.2(729)"></A><A name="bounds.2(729)"></A>: 
       (# theRectangle: @rectangle;
       do ...
       exit theRectangle
       #);
     <B>allocate</B><A name="region.1:allocate.2(730)"></A><A name="allocate.2(730)"></A>: 
       (* allocates space for a new, variable-size region,
        * initializes it to the empty region defined by the rectangle
        * (0, 0)(0, 0)
        *)
       ...;
     <B>dispose</B><A name="region.1:dispose.2(731)"></A><A name="dispose.2(731)"></A>: 
       (* releases the memory occupied by THIS(region). Use this only
        * after you are completely through with a temporary region
        *)
       ...;
     <B>empty</B><A name="region.1:empty.2(732)"></A><A name="empty.2(732)"></A>: 
       (* destroys the previous structure of the given region, then
        * sets THIS(region) new to the empty region.
        *)
       ...;
     <B>setFromRectangle</B><A name="region.1:setFromRectangle.2(733)"></A><A name="setFromRectangle.2(733)"></A>: 
       (* destroys the previous structure of THIS(region), and then
        * sets the new structure to the rectangle specified by
        * theRectangle
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>offset</B><A name="region.1:offset.2(734)"></A><A name="offset.2(734)"></A>: 
       (* moves THIS(region) on the coordinate plane, a distance of
        * delta.h horizontally and delta.v vertically
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>inset</B><A name="region.1:inset.2(735)"></A><A name="inset.2(735)"></A>: 
       (* shrinks or expands THIS(region). All points on the region
        * boundary are moved inwards a distance of dv vertically and
        * dh horizontally; if dh or dv is negative, the points are
        * moved outwards in that direction.  It leaves THIS(region)
        * centered at the same position, but moves the outline in -
        * for positive values of dh and dv - or out - for negative
        * values of dh and dv
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>intersection</B><A name="region.1:intersection.2(736)"></A><A name="intersection.2(736)"></A>: 
       (* calculates the intersection of two regions src1 and src2,
        * and sets THIS(region) to the intersection. This does not
        * create THIS(region); space must already have been allocated
        * for it.  THIS(region) can be one of the source regions, if
        * desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>union</B><A name="region.1:union.2(737)"></A><A name="union.2(737)"></A>: 
       (* calculates the union of two regions src1 and src2, and sets
        * THIS(region) to the union. This does not create
        * THIS(region); space must already have been allocated for
        * THIS(region).  THIS(region) can be one of the source
        * regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>difference</B><A name="region.1:difference.2(738)"></A><A name="difference.2(738)"></A>: 
       (* subtracts src2 from src1 and sets THIS(region) to the
        * difference.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>symDiff</B><A name="region.1:symDiff.2(739)"></A><A name="symDiff.2(739)"></A>: 
       (* calculates the difference between the union and the
        * intersection of src1 and src2 and places the result in
        * dstRgn.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>containsPoint</B><A name="region.1:containsPoint.2(740)"></A><A name="containsPoint.2(740)"></A>: booleanValue
       (* checks whether the pixel below and to the right of pt is
        * within THIS(region), and returns true if so or false if not
        *)
       (# pt: @point
       enter pt
       do ...
       #);
     <B>containsRectangle</B><A name="region.1:containsRectangle.2(741)"></A><A name="containsRectangle.2(741)"></A>: booleanValue
       (* checks whether theRectangle intersects the specified
        * region, and returns true if the intersection encloses at
        * least one bit or false if not
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>isEqual</B><A name="region.1:isEqual.2(742)"></A><A name="isEqual.2(742)"></A>: booleanValue
       (* compares THIS(region) to theRegion and returns true if they
        * are equal or false if not. THIS(region) and theRegion must
        * have identical sizes, shapes, and locations to be considered
        * equal.  If THIS(region) and theRegion are empty regions true
        * is returned as well
        *)
       (# theRegion: ^region
       enter theRegion
       do ...
       #);
     <B>isEmpty</B><A name="region.1:isEmpty.2(743)"></A><A name="isEmpty.2(743)"></A>: booleanValue
       (* returns true if THIS(region) is an empty region or false if
        * not
        *)
       (# do ... #);
     <B>private</B><A name="region.1:private.2(744)"></A><A name="private.2(744)"></A>: @...;
  enter (# r: ^region  enter r[] do ... #)
  exit  (# r: ^region do ... exit r[] #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="graphics.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="scrolllists.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
