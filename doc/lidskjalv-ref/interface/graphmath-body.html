<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Graphmath Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="graphmath">Graphmath Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'guienvgraphmath' '../lib';
BODY 'private/graphmathbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
<B>point</B><A name="point.1(301)"></A>: 
  (* A point is defined as the intersection between a vertical line
   * and a horisontal line in the coordinate plane
   *)
  (# &lt;&lt;SLOT pointLib: attributes&gt;&gt;;
     <B>v</B><A name="point.1.v.2(302)"></A><A name="v.2(302)"></A>,<B> h</B><A name="point.1.h.2(303)"></A><A name="h.2(303)"></A>: @integer;
     <B>add</B><A name="point.1.add.2(304)"></A><A name="add.2(304)"></A>: 
       (* adds the coordinates of p to the coordinates THIS(point) *)
       (# p: @point
       enter p
       do ...
       #);
     <B>subtract</B><A name="point.1.subtract.2(305)"></A><A name="subtract.2(305)"></A>: 
       (* subtracts the coordinates of p from the coordinates of
        * THIS(point)
        *)
       (# p: @point
       enter p
       do ...
       #);
     <B>isEqual</B><A name="point.1.isEqual.2(306)"></A><A name="isEqual.2(306)"></A>: booleanValue
       (* compares THIS(point) to p and returns true if they are
        * equal or false if not
        *)
       (# p: @point
       enter p
       do ...
       #);
  enter (h, v)
  exit  (h, v)
  #) (* point *);
<B>rectangle</B><A name="rectangle.1(307)"></A>: 
  (* rectangles are used to define areas on the screen, to assign
   * coordinate systems to graphic entities, and to specify the
   * location and sizes for various drawing commands.  A rectangle is
   * defined by two points topLeft, bottomRight, which denote the
   * top-left corner and the bottom-right corner of the rectangle
   *)
  (# &lt;&lt;SLOT rectangleLib: attributes&gt;&gt;;
     <B>topLeft</B><A name="rectangle.1.topLeft.2(308)"></A><A name="topLeft.2(308)"></A>:
       (# 
       enter (left, top)
       exit (left, top)
       #);
     <B>bottomRight</B><A name="rectangle.1.bottomRight.2(309)"></A><A name="bottomRight.2(309)"></A>:
       (# 
       enter (right, bottom)
       exit (right, bottom)
       #);
     <B>left</B><A name="rectangle.1.left.2(310)"></A><A name="left.2(310)"></A>,<B> top</B><A name="rectangle.1.top.2(311)"></A><A name="top.2(311)"></A>,<B> right</B><A name="rectangle.1.right.2(312)"></A><A name="right.2(312)"></A>,<B> bottom</B><A name="rectangle.1.bottom.2(313)"></A><A name="bottom.2(313)"></A>: @integer;
     
     <B>set</B><A name="rectangle.1.set.2(314)"></A><A name="set.2(314)"></A>:
       (* assigns the four boundary coordinates to THIS(rectangle) *)
       (# left, top, right, bottom: @integer
       enter (left, top, right, bottom)
       do ...
       #);
     <B>setFromPoints</B><A name="rectangle.1.setFromPoints.2(315)"></A><A name="setFromPoints.2(315)"></A>: 
       (* sets THIS(rectangle) to the smallest rectangle that
        * encloses the two given points p1, p2
        *)
       (# p1, p2: @point;
       enter (p1, p2)
       do ...
       #);
     <B>size</B><A name="rectangle.1.size.2(316)"></A><A name="size.2(316)"></A>: 
       (* evaluate the enter part to set the width and height.
        * Evaluate the exit part to get the width and height
        *)
       (# w, h: @integer;
       enter (#  enter (w, h) do ... #)
       exit (# do ... exit (w, h)  #)
       #);
     <B>offset</B><A name="rectangle.1.offset.2(317)"></A><A name="offset.2(317)"></A>: 
       (* moves THIS(rectangle) by adding delta.h to each horizontal
        * coordinate and delta.v to each vertical coordinate
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>inset</B><A name="rectangle.1.inset.2(318)"></A><A name="inset.2(318)"></A>: 
       (* shrinks or expands THIS(rectangle). The left and right
        * sides are moved in by the amount specified by delta.h; the
        * top and bottom are moved toward the center by the amount
        * specified by delta.v.  If delta.h or delta.v is negative,
        * the appropriate pair of sides is moved outward instead of
        * inward
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>intersection</B><A name="rectangle.1.intersection.2(319)"></A><A name="intersection.2(319)"></A>: booleanValue
       (* calculates the rectangle that is the intersection of src1
        * and src2, sets THIS(rectangle) to the intersection. Result
        * is set to true iff src1 and src2 indeed intersect
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do ...
       #);
     <B>union</B><A name="rectangle.1.union.2(320)"></A><A name="union.2(320)"></A>: 
       (* calculates the smallest rectangle that encloses src1 and
        * src2, and sets THIS(rectangle) to the result
        *)
       (# src1, src2: @rectangle
       enter (src1, src2)
       do ...
       #);
     <B>containsPoint</B><A name="rectangle.1.containsPoint.2(321)"></A><A name="containsPoint.2(321)"></A>: booleanValue
       (* determines whether the pixel below and to the right of the
        * given coordinate point is enclosed in the specified
        * rectangle, and returns true if so or false if not
        *)
       (# p: @point
       enter p
       do ...
       #);
     <B>pToAngle</B><A name="rectangle.1.pToAngle.2(322)"></A><A name="pToAngle.2(322)"></A>: 
       (* calculates an integer angle between a line from the center
        * of the rectangle to thePoint and a line from the center of
        * the rectangle pointing straight up (12 o'clock high). The
        * angle is in degrees from 0 to 359, measured clockwise from
        * 12 oUclock, with 90 degrees at 3 o'clock, 180 at 6 o'clock,
        * and 270 at 9 o'clock
        *)
       (# thePoint: @point; angle: @integer
       enter thePoint
       do ...
       exit angle
       #);
     <B>isEqual</B><A name="rectangle.1.isEqual.2(323)"></A><A name="isEqual.2(323)"></A>: booleanValue
       (* compares theRectangle to THIS(rectangle) and returns true
        * if they are equal or false if not. The two rectangles must
        * have identical boundary coordinates to be considered equal
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>isEmpty</B><A name="rectangle.1.isEmpty.2(324)"></A><A name="isEmpty.2(324)"></A>: booleanValue
       (* returns true if THIS(rectangle) is an empty rectangle or
        * false if not.  A rectangle is considered empty if the bottom
        * coordinate is less than or equal to the top or the right
        * coordinate is less than or equal to the left
        *)
       (# do ... #);
  enter (topLeft, bottomRight)
  exit  (topLeft, bottomRight)
  #) (* rectangle *);
<B>matrix</B><A name="matrix.1(325)"></A>: 
  (# &lt;&lt; slot matrixLib: attributes&gt;&gt;;
     (* a  b  0
      * c  d  0
      * tx ty 1
      *)
     <B>a</B><A name="matrix.1.a.2(326)"></A><A name="a.2(326)"></A>,<B> b</B><A name="matrix.1.b.2(327)"></A><A name="b.2(327)"></A>,<B> c</B><A name="matrix.1.c.2(328)"></A><A name="c.2(328)"></A>,<B> d</B><A name="matrix.1.d.2(329)"></A><A name="d.2(329)"></A>,<B> tx</B><A name="matrix.1.tx.2(330)"></A><A name="tx.2(330)"></A>,<B> ty</B><A name="matrix.1.ty.2(331)"></A><A name="ty.2(331)"></A>: @real;
     <B>inverse</B><A name="matrix.1.inverse.2(332)"></A><A name="inverse.2(332)"></A>: ^matrix;
     <B>mult</B><A name="matrix.1.mult.2(333)"></A><A name="mult.2(333)"></A>: (* Multiply two matrices *)
       (# A, B, res: ^matrix;
       enter (A[], B[])
       do ...
       exit res[]
       #);
     <B>transformPoint</B><A name="matrix.1.transformPoint.2(334)"></A><A name="transformPoint.2(334)"></A>: @
       (# p, result: @point;
       enter p
       do ...
       exit result
       #);
     <B>inverseTransformPoint</B><A name="matrix.1.inverseTransformPoint.2(335)"></A><A name="inverseTransformPoint.2(335)"></A>: @
       (# p1, p2: @point;
       enter p1
       do ...
       exit p2
       #);
     <B>transformRectangle</B><A name="matrix.1.transformRectangle.2(336)"></A><A name="transformRectangle.2(336)"></A>: @
       (# r, result: @rectangle;
       enter r
       do ...
       exit result
       #);
     <B>inverseTransformRectangle</B><A name="matrix.1.inverseTransformRectangle.2(337)"></A><A name="inverseTransformRectangle.2(337)"></A>: 
       (# r, result: @rectangle;
       enter r
       do ...
       exit result
       #);
     <B>getInverse</B><A name="matrix.1.getInverse.2(338)"></A><A name="getInverse.2(338)"></A>: @
       (# get: @...;
       do get;
       exit inverse[]
       #);
  enter (a, b, c, d, tx, ty)
  do INNER;
  exit (a, b, c, d, tx, ty)
  #);
<B>IDmatrix</B><A name="IDmatrix.1(339)"></A>: 
  (# <B>ID</B><A name="IDmatrix.1.ID.2(340)"></A><A name="ID.2(340)"></A>: ^matrix 
  do ...
  exit ID[]
  #);
<B>moveMatrix</B><A name="moveMatrix.1(341)"></A>: matrix   (* A matrix specifying a translation *)
  (# <B>itx</B><A name="moveMatrix.1.itx.2(342)"></A><A name="itx.2(342)"></A>,<B> ity</B><A name="moveMatrix.1.ity.2(343)"></A><A name="ity.2(343)"></A>: @integer;
  enter (itx, ity)
  do ...
  #);
<B>scaleMatrix</B><A name="scaleMatrix.1(344)"></A>: matrix  (* A matrix specifying a scaling *)
  (# 
  enter (a, d)
  do ...
  #);
<B>rotateMatrix</B><A name="rotateMatrix.1(345)"></A>: matrix (* A matrix specifying a rotation *)
  (# <B>theta</B><A name="rotateMatrix.1.theta.2(346)"></A><A name="theta.2(346)"></A>: @real;
  enter theta
  do ...
  #);
<B>ovalAngle</B><A name="ovalAngle.1(347)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the oval with center in (cx,cy) and
   * horizontal radius hr and verticalradius vr, i.e.
   *    (x,y) = (cx,cy) + (hr*cos(a),vr*sin(a))
   *)
  (# <B>cx</B><A name="ovalAngle.1.cx.2(348)"></A><A name="cx.2(348)"></A>,<B> cy</B><A name="ovalAngle.1.cy.2(349)"></A><A name="cy.2(349)"></A>,<B> hr</B><A name="ovalAngle.1.hr.2(350)"></A><A name="hr.2(350)"></A>,<B> vr</B><A name="ovalAngle.1.vr.2(351)"></A><A name="vr.2(351)"></A>,<B> x</B><A name="ovalAngle.1.x.2(352)"></A><A name="x.2(352)"></A>,<B> y</B><A name="ovalAngle.1.y.2(353)"></A><A name="y.2(353)"></A>: @integer;
     <B>a</B><A name="ovalAngle.1.a.2(354)"></A><A name="a.2(354)"></A>,<B> cos_a</B><A name="ovalAngle.1.cos_a.2(355)"></A><A name="cos_a.2(355)"></A>,<B> sin_a</B><A name="ovalAngle.1.sin_a.2(356)"></A><A name="sin_a.2(356)"></A>: @real;
     <B>angle</B><A name="ovalAngle.1.angle.2(357)"></A><A name="angle.2(357)"></A>: @...;
  enter (cx, cy, hr, vr, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
<B>circleAngle</B><A name="circleAngle.1(358)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), assuming
   * that (x,y) is a point on the circle with center in (cx,cy) and
   * radius r, for some r i.e. (x,y) = (cx,cy) + (r*cos(a),r*sin(a))
   *)
  (# <B>cx</B><A name="circleAngle.1.cx.2(359)"></A><A name="cx.2(359)"></A>,<B> cy</B><A name="circleAngle.1.cy.2(360)"></A><A name="cy.2(360)"></A>,<B> x</B><A name="circleAngle.1.x.2(361)"></A><A name="x.2(361)"></A>,<B> y</B><A name="circleAngle.1.y.2(362)"></A><A name="y.2(362)"></A>: @integer;
     <B>a</B><A name="circleAngle.1.a.2(363)"></A><A name="a.2(363)"></A>,<B> cos_a</B><A name="circleAngle.1.cos_a.2(364)"></A><A name="cos_a.2(364)"></A>,<B> sin_a</B><A name="circleAngle.1.sin_a.2(365)"></A><A name="sin_a.2(365)"></A>: @real;
     <B>angle</B><A name="circleAngle.1.angle.2(366)"></A><A name="angle.2(366)"></A>: @...;
  enter (cx, cy, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
<B>region</B><A name="region.1(367)"></A>: 
  (* A region is a collection of spatially coherent points *)
  (# &lt;&lt;SLOT regionLib: attributes&gt;&gt;;
     <B>bounds</B><A name="region.1.bounds.2(368)"></A><A name="bounds.2(368)"></A>: 
       (# theRectangle: @rectangle;
       do ...
       exit theRectangle
       #);
     <B>allocate</B><A name="region.1.allocate.2(369)"></A><A name="allocate.2(369)"></A>: 
       (* allocates space for a new, variable-size region,
        * initializes it to the empty region defined by the rectangle
        * (0, 0)(0, 0)
        *)
       ...;
     <B>dispose</B><A name="region.1.dispose.2(370)"></A><A name="dispose.2(370)"></A>: 
       (* releases the memory occupied by THIS(region). Use this only
        * after you are completely through with a temporary region
        *)
       ...;
     <B>empty</B><A name="region.1.empty.2(371)"></A><A name="empty.2(371)"></A>: 
       (* destroys the previous structure of the given region, then
        * sets THIS(region) new to the empty region.
        *)
       ...;
     <B>setFromRectangle</B><A name="region.1.setFromRectangle.2(372)"></A><A name="setFromRectangle.2(372)"></A>: 
       (* destroys the previous structure of THIS(region), and then
        * sets the new structure to the rectangle specified by
        * theRectangle
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>offset</B><A name="region.1.offset.2(373)"></A><A name="offset.2(373)"></A>: 
       (* moves THIS(region) on the coordinate plane, a distance of
        * delta.h horizontally and delta.v vertically
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>inset</B><A name="region.1.inset.2(374)"></A><A name="inset.2(374)"></A>: 
       (* shrinks or expands THIS(region). All points on the region
        * boundary are moved inwards a distance of dv vertically and
        * dh horizontally; if dh or dv is negative, the points are
        * moved outwards in that direction.  It leaves THIS(region)
        * centered at the same position, but moves the outline in -
        * for positive values of dh and dv - or out - for negative
        * values of dh and dv
        *)
       (# delta: @point
       enter delta
       do ...
       #);
     <B>intersection</B><A name="region.1.intersection.2(375)"></A><A name="intersection.2(375)"></A>: 
       (* calculates the intersection of two regions src1 and src2,
        * and sets THIS(region) to the intersection. This does not
        * create THIS(region); space must already have been allocated
        * for it.  THIS(region) can be one of the source regions, if
        * desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>union</B><A name="region.1.union.2(376)"></A><A name="union.2(376)"></A>: 
       (* calculates the union of two regions src1 and src2, and sets
        * THIS(region) to the union. This does not create
        * THIS(region); space must already have been allocated for
        * THIS(region).  THIS(region) can be one of the source
        * regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>difference</B><A name="region.1.difference.2(377)"></A><A name="difference.2(377)"></A>: 
       (* subtracts src2 from src1 and sets THIS(region) to the
        * difference.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>symDiff</B><A name="region.1.symDiff.2(378)"></A><A name="symDiff.2(378)"></A>: 
       (* calculates the difference between the union and the
        * intersection of src1 and src2 and places the result in
        * dstRgn.  This does not create THIS(region); space must
        * already have been allocated for it. THIS(region) can be one
        * of the source regions, if desired
        *)
       (# src1, src2: ^region
       enter (src1[], src2[])
       do ...
       #);
     <B>containsPoint</B><A name="region.1.containsPoint.2(379)"></A><A name="containsPoint.2(379)"></A>: booleanValue
       (* checks whether the pixel below and to the right of pt is
        * within THIS(region), and returns true if so or false if not
        *)
       (# pt: @point
       enter pt
       do ...
       #);
     <B>containsRectangle</B><A name="region.1.containsRectangle.2(380)"></A><A name="containsRectangle.2(380)"></A>: booleanValue
       (* checks whether theRectangle intersects the specified
        * region, and returns true if the intersection encloses at
        * least one bit or false if not
        *)
       (# theRectangle: @rectangle
       enter theRectangle
       do ...
       #);
     <B>isEqual</B><A name="region.1.isEqual.2(381)"></A><A name="isEqual.2(381)"></A>: booleanValue
       (* compares THIS(region) to theRegion and returns true if they
        * are equal or false if not. THIS(region) and theRegion must
        * have identical sizes, shapes, and locations to be considered
        * equal.  If THIS(region) and theRegion are empty regions true
        * is returned as well
        *)
       (# theRegion: ^region
       enter theRegion
       do ...
       #);
     <B>isEmpty</B><A name="region.1.isEmpty.2(382)"></A><A name="isEmpty.2(382)"></A>: booleanValue
       (* returns true if THIS(region) is an empty region or false if
        * not
        *)
       (# do ... #);
     <B>private</B><A name="region.1.private.2(383)"></A><A name="private.2(383)"></A>: @...;
  enter (# r: ^region  enter r[] do ... #)
  exit  (# r: ^region do ... exit r[] #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Graphmath Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
