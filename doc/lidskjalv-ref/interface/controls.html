<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Controls Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="controlsactions.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Controls Interface</H1>
<PRE CLASS=interface>
ORIGIN 'guienv';
LIB_DEF 'guienvcontrols' '../lib';
BODY 'private/controlsbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- windowLib: attributes --
<B>control</B><A name="control.1(1)"></A>: windowitem
  (* a control is a graphical object in the window that the user can
   * use to perform actions. All user interaction with the control
   * that can result in an action should give some kind of visual
   * feedback.
   *)
  (# &lt;&lt;SLOT controlLib: attributes&gt;&gt;;
     <B>open</B><A name="control.1:open.2(2)"></A><A name="open.2(2)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>eventHandler</B><A name="control.1:eventHandler.2(3)"></A><A name="eventHandler.2(3)"></A>::&lt;(# onEnabledChanged::&lt; (# ... #);   
       #);
     <B>close</B><A name="control.1:close.2(4)"></A><A name="close.2(4)"></A>::&lt; (# do ... #);
     <B>private</B><A name="control.1:private.2(5)"></A><A name="private.2(5)"></A>: @...;
  #) (* control *);
<B>scrollbar</B><A name="scrollbar.1(6)"></A>: control
  (* A scrollbar controls the scrolling of a textfield or picture
   * etc.
   *)
  (# &lt;&lt;SLOT scrollbarLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="scrollbar.1:eventhandler.2(7)"></A><A name="eventhandler.2(7)"></A>::&lt;
       (# <B>thumbMoved</B><A name="scrollbar.1:eventhandler.2:thumbMoved.3(8)"></A><A name="thumbMoved.3(8)"></A>: event
            (* is called whenever a user has moved the thumb of
             * THIS(scrollbar)
             *)
            (# amount: @integer;
            enter amount
            do ...;
            #);
          <B>onThumbMoved</B><A name="scrollbar.1:eventhandler.2:onThumbMoved.3(9)"></A><A name="onThumbMoved.3(9)"></A>:&lt; thumbMoved;
          <B>pageDown</B><A name="scrollbar.1:eventhandler.2:pageDown.3(10)"></A><A name="pageDown.3(10)"></A>: event
            (* called when the user clicks in the page down area *)
            (# do ...; #);
          <B>onPageDown</B><A name="scrollbar.1:eventhandler.2:onPageDown.3(11)"></A><A name="onPageDown.3(11)"></A>:&lt; pageDown;
          <B>pageUp</B><A name="scrollbar.1:eventhandler.2:pageUp.3(12)"></A><A name="pageUp.3(12)"></A>: event
            (* called when the user clicks in the page up area *)
            (# do ... #);
          <B>onPageUp</B><A name="scrollbar.1:eventhandler.2:onPageUp.3(13)"></A><A name="onPageUp.3(13)"></A>:&lt; pageUp;
          <B>buttonDown</B><A name="scrollbar.1:eventhandler.2:buttonDown.3(14)"></A><A name="buttonDown.3(14)"></A>: event
            (* called when the user clicks at the down button *)
            (# do ... #);
          <B>onButtonDown</B><A name="scrollbar.1:eventhandler.2:onButtonDown.3(15)"></A><A name="onButtonDown.3(15)"></A>:&lt; buttonDown;
          <B>buttonUp</B><A name="scrollbar.1:eventhandler.2:buttonUp.3(16)"></A><A name="buttonUp.3(16)"></A>: event
            (* called when the user clicks at the up button *)
            (# do ... #);
          <B>onButtonUp</B><A name="scrollbar.1:eventhandler.2:onButtonUp.3(17)"></A><A name="onButtonUp.3(17)"></A>:&lt; buttonUp;
          <B>pageScrollAmountChanged</B><A name="scrollbar.1:eventhandler.2:pageScrollAmountChanged.3(18)"></A><A name="pageScrollAmountChanged.3(18)"></A>: event
            (* called when the scrollamount is changed *)
            (# do INNER; #);
          <B>onPageScrollAmountChanged</B><A name="scrollbar.1:eventhandler.2:onPageScrollAmountChanged.3(19)"></A><A name="onPageScrollAmountChanged.3(19)"></A>:&lt; pageScrollAmountChanged;
          <B>scrollAmountChanged</B><A name="scrollbar.1:eventhandler.2:scrollAmountChanged.3(20)"></A><A name="scrollAmountChanged.3(20)"></A>: event
            (* called when the scrollamount is changed *)
            (# do INNER; #);
          <B>onScrollAmountChanged</B><A name="scrollbar.1:eventhandler.2:onScrollAmountChanged.3(21)"></A><A name="onScrollAmountChanged.3(21)"></A>:&lt; scrollAmountChanged;
          <B>maxValueChanged</B><A name="scrollbar.1:eventhandler.2:maxValueChanged.3(22)"></A><A name="maxValueChanged.3(22)"></A>: event
            (* called when the max value is changed *)
            (# do INNER; #);
          <B>onMaxValueChanged</B><A name="scrollbar.1:eventhandler.2:onMaxValueChanged.3(23)"></A><A name="onMaxValueChanged.3(23)"></A>:&lt; maxValueChanged;
          <B>valueChanged</B><A name="scrollbar.1:eventhandler.2:valueChanged.3(24)"></A><A name="valueChanged.3(24)"></A>: event
            (* called when the value is changed *)
            (# do INNER; #);
          <B>onValueChanged</B><A name="scrollbar.1:eventhandler.2:onValueChanged.3(25)"></A><A name="onValueChanged.3(25)"></A>:&lt; valueChanged;
          <B>onFrameChanged</B><A name="scrollbar.1:eventhandler.2:onFrameChanged.3(26)"></A><A name="onFrameChanged.3(26)"></A>::&lt;(# do ... #);
          <B>onRefresh</B><A name="scrollbar.1:eventhandler.2:onRefresh.3(27)"></A><A name="onRefresh.3(27)"></A>::&lt;(# do ... #);
          <B>onMouseDown</B><A name="scrollbar.1:eventhandler.2:onMouseDown.3(28)"></A><A name="onMouseDown.3(28)"></A>::&lt;(# do ... #);
          <B>onActivate</B><A name="scrollbar.1:eventhandler.2:onActivate.3(29)"></A><A name="onActivate.3(29)"></A>::&lt;(# do ... #);
          <B>onDeactivate</B><A name="scrollbar.1:eventhandler.2:onDeactivate.3(30)"></A><A name="onDeactivate.3(30)"></A>::&lt;(# do ... #);
       #);
     <B>vertical</B><A name="scrollbar.1:vertical.2(31)"></A><A name="vertical.2(31)"></A>:&lt;
       (* Specifies if THIS(scrollbar) is vertical, false is the
        * default value
        *)
       booleanValue;
     <B>scrollAmount</B><A name="scrollbar.1:scrollAmount.2(32)"></A><A name="scrollAmount.2(32)"></A>:
       (* scrollAmount is the amount the scrollbars thumb will move,
        * when the user clicks in the up button or in the down button
        *)
       (# value: @integer
       enter (# enter value do ... #)
       exit (# do ... exit value #)
       #);
     <B>pageScrollAmount</B><A name="scrollbar.1:pageScrollAmount.2(33)"></A><A name="pageScrollAmount.2(33)"></A>:
       (* pageScrollAmount is the amount the scrollbars thumb will
        * move, when the user clicks in the page down or page up area
        *)
       (# value: @integer;
       enter (# enter value do ... #)
       exit (# do ... exit value #)
       #);
     <B>maxValue</B><A name="scrollbar.1:maxValue.2(34)"></A><A name="maxValue.2(34)"></A>: 
       (* this combines setMaxValue and getMaxValue.  Evaluate the
        * enter part to set the maximum value and evaluate the exit
        * part to get the maximum value
        *)
       (# value: @integer
       enter (# enter value do ... #)
       exit  (# do ... exit value #)
       #);
     <B>value</B><A name="scrollbar.1:value.2(35)"></A><A name="value.2(35)"></A>: 
       (* evaluate the enter part to set the value and evaluate the
        * exit part to the maximum value.  The thumb of the scrollbar
        * is drawn acording to maxValue and the current value. That
        * is, if maxValue is 100 and value is 50, the thumb will be
        * drawn in the middle of the scrollbar
        *)
       (#  pos: @integer;
       enter (# enter  pos do ... #)
       exit  (# do ... exit pos #)
       #);
     <B>length</B><A name="scrollbar.1:length.2(36)"></A><A name="length.2(36)"></A>: 
       (* the length is either the height or the width of the frame
        * depending of the orientation
        *)
       (# theLength: @integer;
       enter (# enter theLength do ... #)
       exit (# do ... exit theLength #)
       #);
     <B>open</B><A name="scrollbar.1:open.2(37)"></A><A name="open.2(37)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="scrollbar.1:close.2(38)"></A><A name="close.2(38)"></A>::&lt; (# do ...; #);
     <B>private</B><A name="scrollbar.1:private.2(39)"></A><A name="private.2(39)"></A>: @...;
  #) (* scrollbar *);

<B>button</B><A name="button.1(40)"></A>: control
  (* this is the abstract superpattern for all button-like controls *)
  (# &lt;&lt;SLOT buttonLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="button.1:eventhandler.2(41)"></A><A name="eventhandler.2(41)"></A>::&lt;
       (# <B>labelChanged</B><A name="button.1:eventhandler.2:labelChanged.3(42)"></A><A name="labelChanged.3(42)"></A>: event
            (* is called whenever the label is changed *)
            (# do INNER; #);
          <B>onLabelChanged</B><A name="button.1:eventhandler.2:onLabelChanged.3(43)"></A><A name="onLabelChanged.3(43)"></A>:&lt; labelChanged;
          <B>styleChanged</B><A name="button.1:eventhandler.2:styleChanged.3(44)"></A><A name="styleChanged.3(44)"></A>: event
            (* is called whenever the style is changed *)
            (# do INNER #);
          <B>onStyleChanged</B><A name="button.1:eventhandler.2:onStyleChanged.3(45)"></A><A name="onStyleChanged.3(45)"></A>:&lt; styleChanged;
          <B>onFrameChanged</B><A name="button.1:eventhandler.2:onFrameChanged.3(46)"></A><A name="onFrameChanged.3(46)"></A>::&lt;(# do ... #);
          <B>onRefresh</B><A name="button.1:eventhandler.2:onRefresh.3(47)"></A><A name="onRefresh.3(47)"></A>::&lt;(# do ... #);
          <B>onMouseDown</B><A name="button.1:eventhandler.2:onMouseDown.3(48)"></A><A name="onMouseDown.3(48)"></A>::&lt;(# do ... #);
       #);
     <B>label</B><A name="button.1:label.2(49)"></A><A name="label.2(49)"></A>:
       (* the label is the text displayed in THIS(button).  The event
        * labelChanged is called, when the label is changed
        *)
       (# theLabel: ^text;
       enter (# enter theLabel[] do ... #)
       exit (# do ... exit theLabel[]  #)
       #);
     <B>style</B><A name="button.1:style.2(50)"></A><A name="style.2(50)"></A>: 
       (* the text style used for drawing the label  *)
       (# theStyle: ^textStyle
       enter (# enter theStyle[] do ... #)
       exit  (# do ... exit theStyle[] #)
       #);
     <B>open</B><A name="button.1:open.2(51)"></A><A name="open.2(51)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="button.1:close.2(52)"></A><A name="close.2(52)"></A>::&lt; (# do ... #);
     <B>private</B><A name="button.1:private.2(53)"></A><A name="private.2(53)"></A>: @...;
  #) (* button *);
<B>pushButton</B><A name="pushButton.1(54)"></A>: button
  (* this is a button like the OK and Cancel buttons in dialogs *)
  (# &lt;&lt;SLOT pushButtonLib: attributes&gt;&gt;;
     <B>open</B><A name="pushButton.1:open.2(55)"></A><A name="open.2(55)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="pushButton.1:close.2(56)"></A><A name="close.2(56)"></A>::&lt; (# do ... #);
     <B>eventHandler</B><A name="pushButton.1:eventHandler.2(57)"></A><A name="eventHandler.2(57)"></A>::&lt;
       (# onMouseDown::&lt;(# ... #);
          onRefresh::&lt;(# ... #);
          onHiliteChanged::&lt;(# ... #);
       #);
     
     <B>private</B><A name="pushButton.1:private.2(58)"></A><A name="private.2(58)"></A>: @...;
  #) (* pushButton *);
<B>staticText</B><A name="staticText.1(59)"></A>: button
  (* normally a staticText is used to label editText fields *) 
  (# &lt;&lt;SLOT staticTextLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="staticText.1:eventhandler.2(60)"></A><A name="eventhandler.2(60)"></A>::&lt;
       (# <B>onRefresh</B><A name="staticText.1:eventhandler.2:onRefresh.3(61)"></A><A name="onRefresh.3(61)"></A>::&lt;(# do ...#);
       #);
     <B>open</B><A name="staticText.1:open.2(62)"></A><A name="open.2(62)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="staticText.1:close.2(63)"></A><A name="close.2(63)"></A>::&lt; (# do ... #);
     <B>private</B><A name="staticText.1:private.2(64)"></A><A name="private.2(64)"></A>: @...;
  #) (* staticText *);
<B>iconButton</B><A name="iconButton.1(65)"></A>: button
  (* an icon has a label, which is drawn centered just below the
   * image of the icon
   *) 
  (# &lt;&lt;SLOT iconButtonLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="iconButton.1:eventhandler.2(66)"></A><A name="eventhandler.2(66)"></A>::&lt;
       (# <B>showLabelChanged</B><A name="iconButton.1:eventhandler.2:showLabelChanged.3(67)"></A><A name="showLabelChanged.3(67)"></A>: event
            (* called when showLabel is changed *)
            (# do INNER #);
          <B>onShowLabelChanged</B><A name="iconButton.1:eventhandler.2:onShowLabelChanged.3(68)"></A><A name="onShowLabelChanged.3(68)"></A>:&lt; showLabelChanged;
          <B>iconChanged</B><A name="iconButton.1:eventhandler.2:iconChanged.3(69)"></A><A name="iconChanged.3(69)"></A>: event
            (* Called when the icon is changed *)
            (# do INNER #);
          <B>onIconChanged</B><A name="iconButton.1:eventhandler.2:onIconChanged.3(70)"></A><A name="onIconChanged.3(70)"></A>:&lt; iconChanged;
          <B>onRefresh</B><A name="iconButton.1:eventhandler.2:onRefresh.3(71)"></A><A name="onRefresh.3(71)"></A>::&lt; (# do ... #);
          <B>onHiliteChanged</B><A name="iconButton.1:eventhandler.2:onHiliteChanged.3(72)"></A><A name="onHiliteChanged.3(72)"></A>::&lt; (# do ... #);
          <B>onMouseDown</B><A name="iconButton.1:eventhandler.2:onMouseDown.3(73)"></A><A name="onMouseDown.3(73)"></A>::&lt; (# ... #);
       #);
     <B>showLabel</B><A name="iconButton.1:showLabel.2(74)"></A><A name="showLabel.2(74)"></A>: 
       (* if true, the label is shown centered under the image of the
        * Icon
        *)
       (# doShow: @boolean
       enter (# enter doShow do ... #)
       exit (# do ... exit doShow #)
       #);
     <B>icon</B><A name="iconButton.1:icon.2(75)"></A><A name="icon.2(75)"></A>:
       (# theIcon: ^pixmap;
       enter (# enter theIcon[] do ... #)
       exit (# do ...; exit theIcon[] #)
       #);
     <B>open</B><A name="iconButton.1:open.2(76)"></A><A name="open.2(76)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="iconButton.1:close.2(77)"></A><A name="close.2(77)"></A>::&lt; (# do ... #);
     <B>private</B><A name="iconButton.1:private.2(78)"></A><A name="private.2(78)"></A>: @...;
  #) (* iconButton *);
<B>optionButton</B><A name="optionButton.1(79)"></A>: button
  (* a optionButton has a menu, which pops up, when the user clicks
   * at the button. A normal way to use a optionButton is to set the
   * label of the button to the current selected item in the menu
   *)
  (# &lt;&lt;SLOT optionButtonLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="optionButton.1:eventhandler.2(80)"></A><A name="eventhandler.2(80)"></A>::&lt;
       (# <B>currentItemChanged</B><A name="optionButton.1:eventhandler.2:currentItemChanged.3(81)"></A><A name="currentItemChanged.3(81)"></A>: event
            (* called when currentItem is changed *)
            (# do INNER #);
          <B>onCurrentItemChanged</B><A name="optionButton.1:eventhandler.2:onCurrentItemChanged.3(82)"></A><A name="onCurrentItemChanged.3(82)"></A>:&lt; currentItemChanged;
          <B>popUpMenuChanged</B><A name="optionButton.1:eventhandler.2:popUpMenuChanged.3(83)"></A><A name="popUpMenuChanged.3(83)"></A>: event
            (* called when popUpMenu is changed *)
            (# do INNER #);
          <B>onPopUpMenuChanged</B><A name="optionButton.1:eventhandler.2:onPopUpMenuChanged.3(84)"></A><A name="onPopUpMenuChanged.3(84)"></A>:&lt; popUpMenuChanged;
          <B>onLabelChanged</B><A name="optionButton.1:eventhandler.2:onLabelChanged.3(85)"></A><A name="onLabelChanged.3(85)"></A>::&lt; (# do ... #);
          <B>onStyleChanged</B><A name="optionButton.1:eventhandler.2:onStyleChanged.3(86)"></A><A name="onStyleChanged.3(86)"></A>::&lt; (# do ... #);
          <B>onRefresh</B><A name="optionButton.1:eventhandler.2:onRefresh.3(87)"></A><A name="onRefresh.3(87)"></A>:: (# ... #);
       #);
     <B>currentItem</B><A name="optionButton.1:currentItem.2(88)"></A><A name="currentItem.2(88)"></A>: 
       (* the current item is the number of the item, which name is
        * currently shown in the popup box.  You can get a reference
        * to that item by calling: currentItem -&gt;
        * theMenu.getItemByNumber -&gt; theItem[];
        *)
       (# itemNo: @integer
       enter (# enter itemNo do ... #)
       exit (# do ... exit itemNo #)
       #);
     <B>popupMenu</B><A name="optionButton.1:popupMenu.2(89)"></A><A name="popupMenu.2(89)"></A>: 
       (* evaluate the enter part to set the menu that pops up in
        * THIS(optionButton). And evaluate the exit part to get the
        * menu
        *)
       (# popupMenu: ^menu;
       enter (# enter popupMenu[] do ... #)
       exit (# do ... exit PopupMenu[] #)
       #);
     <B>open</B><A name="optionButton.1:open.2(90)"></A><A name="open.2(90)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="optionButton.1:close.2(91)"></A><A name="close.2(91)"></A>::&lt; (# do ... #);
     <B>private</B><A name="optionButton.1:private.2(92)"></A><A name="private.2(92)"></A>: @...;
  #) (* optionButton *);
<B>toggleButton</B><A name="toggleButton.1(93)"></A>: button
  (* this is the abstract superpattern for all buttons that toggle
   * between two states (on/off buttons)
   *)
  (# &lt;&lt;SLOT toggleButtonLib: attributes&gt;&gt;;
     <B>eventhandler</B><A name="toggleButton.1:eventhandler.2(94)"></A><A name="eventhandler.2(94)"></A>::&lt;
       (# <B>stateChanged</B><A name="toggleButton.1:eventhandler.2:stateChanged.3(95)"></A><A name="stateChanged.3(95)"></A>: event
            (* this event is called whenever the state of
             * THIS(toggleButton) is changed
             *)
            (# do INNER #);
          <B>onStateChanged</B><A name="toggleButton.1:eventhandler.2:onStateChanged.3(96)"></A><A name="onStateChanged.3(96)"></A>:&lt; stateChanged;
          <B>onMouseUp</B><A name="toggleButton.1:eventhandler.2:onMouseUp.3(97)"></A><A name="onMouseUp.3(97)"></A>::&lt;(# ... #);
       #);
     <B>state</B><A name="toggleButton.1:state.2(98)"></A><A name="state.2(98)"></A>:
       (# theState: @boolean;
       enter (# enter theState do ... #)
       exit (# do ... exit theState #)
       #);
     <B>open</B><A name="toggleButton.1:open.2(99)"></A><A name="open.2(99)"></A>::&lt;(# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="toggleButton.1:close.2(100)"></A><A name="close.2(100)"></A>::&lt; (# do ... #);
     <B>private</B><A name="toggleButton.1:private.2(101)"></A><A name="private.2(101)"></A>: @...;
  #) (* toggleButton *);
<B>radioButton</B><A name="radioButton.1(102)"></A>: toggleButton
  (* a radioButton is mostly used in a radiobutton cluster, where
   * only one radioButton is set at a time. A radioButton is thus
   * useful to let the user choose among different alternatives
   *)
  (# &lt;&lt;SLOT radioButtonLib: attributes&gt;&gt;;
     <B>open</B><A name="radioButton.1:open.2(103)"></A><A name="open.2(103)"></A>::&lt; (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="radioButton.1:close.2(104)"></A><A name="close.2(104)"></A>::&lt; (# do ... #);
     <B>private</B><A name="radioButton.1:private.2(105)"></A><A name="private.2(105)"></A>: @...;
  #) (* radioButton *);
<B>checkBox</B><A name="checkBox.1(106)"></A>: toggleButton
  (* this is useful for setting options in dialogs *)
  (# &lt;&lt;SLOT checkBoxLib: attributes&gt;&gt;;
     <B>open</B><A name="checkBox.1:open.2(107)"></A><A name="open.2(107)"></A>::&lt; (# create::&lt; (# do ... #);
       do ...
       #);
     <B>close</B><A name="checkBox.1:close.2(108)"></A><A name="close.2(108)"></A>::&lt; (# do ... #);
     <B>private</B><A name="checkBox.1:private.2(109)"></A><A name="private.2(109)"></A>: @...;
  #) (* checkBox *);
<B>editText</B><A name="editText.1(110)"></A>: control
  (* this is a simple version of textField. Only one textStyle is
   * allowed.  The purpose of this control is to build dialogs
   *)
  (# &lt;&lt;SLOT editTextLib: attributes&gt;&gt;;
     <B>style</B><A name="editText.1:style.2(111)"></A><A name="style.2(111)"></A>: 
       (* an editText can only have one textStyle.  Evaluate the
        * enter part to set the textStyle.  Evaluate the exit part to
        * get the textStyle
        *)
       (# txStyle: ^textStyle
       enter (# enter txStyle[] do ... #)
       exit (# do ... exit txStyle[] #)
       #);
     <B>contents</B><A name="editText.1:contents.2(112)"></A><A name="contents.2(112)"></A>: 
       (* the contents of an editText is text.  Evaluate the enter
        * part to set the contents, and evaluate the exit part to get
        * the contents
        *)
       (# str: ^text 
       enter (# enter str[] do ... #)
       exit (# do ... exit str[] #)
       #);
     <B>eventhandler</B><A name="editText.1:eventhandler.2(113)"></A><A name="eventhandler.2(113)"></A>::&lt;
       (# <B>onFrameChanged</B><A name="editText.1:eventhandler.2:onFrameChanged.3(114)"></A><A name="onFrameChanged.3(114)"></A>::&lt;(# do ... #);
          <B>onKeyDown</B><A name="editText.1:eventhandler.2:onKeyDown.3(115)"></A><A name="onKeyDown.3(115)"></A>::&lt;(# do ... #);
          <B>onMouseDown</B><A name="editText.1:eventhandler.2:onMouseDown.3(116)"></A><A name="onMouseDown.3(116)"></A>::&lt;(# do ... #);
          <B>onRefresh</B><A name="editText.1:eventhandler.2:onRefresh.3(117)"></A><A name="onRefresh.3(117)"></A>::&lt;(# do ... #);
          <B>onEnableTarget</B><A name="editText.1:eventhandler.2:onEnableTarget.3(118)"></A><A name="onEnableTarget.3(118)"></A>::&lt;(# do ... #);
          <B>onDisableTarget</B><A name="editText.1:eventhandler.2:onDisableTarget.3(119)"></A><A name="onDisableTarget.3(119)"></A>::&lt;(# do ... #);
       #);
     <B>open</B><A name="editText.1:open.2(120)"></A><A name="open.2(120)"></A>::&lt; 
       (* the textStyle of THIS(editText) is initially set to the
        * system's textStyle
        *)
       (# create::&lt; (# do ... #);
       do ... 
       #);
     <B>close</B><A name="editText.1:close.2(121)"></A><A name="close.2(121)"></A>::&lt; (# do ... #);
     <B>private</B><A name="editText.1:private.2(122)"></A><A name="private.2(122)"></A>: @...;
  #) (* editText *);
<B>defaultButton</B><A name="defaultButton.1(123)"></A>: 
  (* the defaultButton in the window recieves a mouseUp event when
   * the user presses the return-key
   *)
  (# <B>theButton</B><A name="defaultButton.1:theButton.2(124)"></A><A name="theButton.2(124)"></A>: ^button
  enter (# enter theButton[] do ... #)
  exit (# do ... exit theButton[] #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="controlsactions.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
