<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Guienv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="stddialogs.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Guienv Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'guienv' '../lib';
INCLUDE '~beta/containers/list';
INCLUDE 'graphmath';
BODY  'private/guienvbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
<B>GUIenv</B><A name="GUIenv.1(1)"></A>: 
  (# &lt;&lt;SLOT guienvLib: attributes&gt;&gt;;
     <B>onStartApplication</B><A name="GUIenv.1:onStartApplication.2(2)"></A><A name="onStartApplication.2(2)"></A>:&lt; 
       (* is called when this application is started with no
        * documents. You can for example further bind this to show a
        * splash screen
        *)
       (# do INNER #);
     <B>onOpenDocument</B><A name="GUIenv.1:onOpenDocument.2(3)"></A><A name="onOpenDocument.2(3)"></A>:&lt;
       (* is called whenever a user opens a document created by this
        * application
        *)
       (# <B>fileName</B><A name="GUIenv.1:onOpenDocument.2:fileName.3(4)"></A><A name="fileName.3(4)"></A>: ^text;
       enter fileName[]
       do INNER
       #);
     <B>onQuit</B><A name="GUIenv.1:onQuit.2(5)"></A><A name="onQuit.2(5)"></A>:&lt;
       (* is called when application is going to quit, either
        * because terminate is called or because the system are
        * are going to shut down.
        * If okToQuit is set to false the application will
        * not quit.
        *)
       (# <B>okToQuit</B><A name="GUIenv.1:onQuit.2:okToQuit.3(6)"></A><A name="okToQuit.3(6)"></A>: @boolean;
       do true -&gt; okToQuit;
          INNER;
       exit okToQuit
       #);
     <B>terminate</B><A name="GUIenv.1:terminate.2(7)"></A><A name="terminate.2(7)"></A>:
       (* will terminate the entire application if invoked 
        * Terminate calls onQuit and will only quit if
        * onQuit returns true.
        *) 
       (# ... #);
     <B>applicationMenubar</B><A name="GUIenv.1:applicationMenubar.2(8)"></A><A name="applicationMenubar.2(8)"></A>:
       (* applicationMenubar is used to install a menubar with
        * functionality that is common for all parts for the
        * application.
        *)
       (# <B>theMenubar</B><A name="GUIenv.1:applicationMenubar.2:theMenubar.3(9)"></A><A name="theMenubar.3(9)"></A>: ^menubarType
       enter (# enter theMenubar[] ... #)
       exit (# ... exit theMenuBar[] #)
       #);
     <B>menubarType</B><A name="GUIenv.1:menubarType.2(10)"></A><A name="menubarType.2(10)"></A>:&lt;
       (* if further bound, an instance of menubarType is
        * automatically installed for the application. Further bind it
        * to standardMenubar if you want the standard menubar (file
        * and edit menu)
        *)
       menubar;
     <B>interfaceObject</B><A name="GUIenv.1:interfaceObject.2(11)"></A><A name="interfaceObject.2(11)"></A>: 
       (* superpattern for all objects used for interaction with the
        * user
        *)
       (# &lt;&lt;SLOT interfaceObjectLib: attributes&gt;&gt;;
          <B>theEventhandler</B><A name="GUIenv.1:interfaceObject.2:theEventhandler.3(12)"></A><A name="theEventhandler.3(12)"></A>: 
            (* The only instance of the eventhandler virtual *)
            @eventhandler;
          <B>eventhandler</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3(13)"></A><A name="eventhandler.3(13)"></A>:&lt;
            (* Encapsulates the patterns related to event handling *)
            (# &lt;&lt;SLOT eventhandlerLib: attributes&gt;&gt;;
               <B>event</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:event.4(14)"></A><A name="event.4(14)"></A>: 
                 (* the abstract superpattern of all events *)
                 (# &lt;&lt;SLOT eventLib: attributes&gt;&gt;;
                 ...
                 #) (* event *);
               <B>basicEvent</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4(15)"></A><A name="basicEvent.4(15)"></A>: event 
                 (* abstract superpattern for all events
                  * originating directly from the OS 
                  *)
                 (# &lt;&lt;SLOT basicEventLib: attributes&gt;&gt;;
                    <B>shiftKey</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:shiftKey.5(16)"></A><A name="shiftKey.5(16)"></A>: booleanValue
                      (* true if the shiftkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>altKey</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:altKey.5(17)"></A><A name="altKey.5(17)"></A>: booleanValue
                      (* true if the altkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>metaKey</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:metaKey.5(18)"></A><A name="metaKey.5(18)"></A>: booleanValue
                      (* true if the metakey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>controlKey</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:controlKey.5(19)"></A><A name="controlKey.5(19)"></A>: booleanValue
                      (* true if the controlkey was the down, when
                       * THIS(basicEvent) occurred
                       *)
                      (# 
                      ...
                      #);
                    <B>buttonState</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:buttonState.5(20)"></A><A name="buttonState.5(20)"></A>: integerValue
                      (* the number designating the button, which was
                       * pressed down, when THIS(basicEvent) occurred
                       * - 0 means 'no button'.  This value depe nds
                       * on the number of buttons on the mouse -
                       * Typically 1, 2 or 3.
                       *)
                      (# 
                      ...
                      #);
                    <B>when</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:when.5(21)"></A><A name="when.5(21)"></A>: integerValue
                      (* the tick count when THIS(basicEvent)
                       * occurred.  1 tick = 1/60 sec.
                       *)
                      (# 
                      ...
                      #);
                    <B>globalPosition</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:globalPosition.5(22)"></A><A name="globalPosition.5(22)"></A>: 
                      (* global coordinates of the mouse, when
                       * THIS(basicEvent) occurred
                       *)
                      (# p: @point;
                      ...
                      exit p
                      #);
                    <B>localPosition</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:basicEvent.4:localPosition.5(23)"></A><A name="localPosition.5(23)"></A>: 
                      (* local coordinates of the mouse, when
                       * THIS(basicEvent) occurred - relative to
                       * THIS(inteefaceObject)
                       *)
                      (# p: @point;
                      ...
                      exit p
                      #);
                 do INNER;
                 #);
               <B>mouseEvent</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:mouseEvent.4(24)"></A><A name="mouseEvent.4(24)"></A>: basicEvent
                 (* abstract superpattern for events related to the
                  * mouse
                  *)
                 (# &lt;&lt;SLOT mouseEventLib: attributes&gt;&gt;;
                    <B>doubleClick</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:mouseEvent.4:doubleClick.5(25)"></A><A name="doubleClick.5(25)"></A>: booleanValue
                      (* true if THIS(mouseEvent) is a doubleclick.
                       * For a mouse click to qualify as doubleclick
                       * it must happen close in time and space, and
                       * with the same mouse button
                       *)
                      (# 
                      ...
                      #);
                 do INNER;
                 #);
               <B>keyEvent</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:keyEvent.4(26)"></A><A name="keyEvent.4(26)"></A>: basicEvent
                 (* abstract superpattern for events related to the
                  * keyboard.
                  *)
                 (# &lt;&lt;SLOT keyEventLib: attributes&gt;&gt;;
                    <B>ch</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:keyEvent.4:ch.5(27)"></A><A name="ch.5(27)"></A>:
                      (* the key on the keyboard, related to
                       * THIS(keyEvent)
                       *)
                      (# theChar: @char;
                      ...
                      exit theChar
                      #);
                 do INNER
                 #);
               <B>mouseDown</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:mouseDown.4(28)"></A><A name="mouseDown.4(28)"></A>: mouseEvent
                 (* This event occurs when the user presses any mouse
                  * button down on THIS(interfaceObject)
                  *)
                 (# &lt;&lt;SLOT mouseDownLib: attributes&gt;&gt;;
                    <B>delay</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:mouseDown.4:delay.5(29)"></A><A name="delay.5(29)"></A>:
                      (* used to wait for period ticks to pass, while
                       * mouse.isStillDown is true, and then execute
                       * INNER.  If mouseStillDown becomes false
                       * before period ticks, INNER is not executed
                       *)
                      (# period: @integer
                      enter period
                      ...
                      #)
                 do INNER
                 #);
               <B>onMouseDown</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onMouseDown.4(30)"></A><A name="onMouseDown.4(30)"></A>:&lt; mouseDown;
               <B>mouseUp</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:mouseUp.4(31)"></A><A name="mouseUp.4(31)"></A>: mouseEvent 
                 (* This event occurs when the user releases any
                  * mouse button after having pressed it on
                  * THIS(interfaceObject)
                  *)
                 (# do INNER #);
               <B>onMouseUp</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onMouseUp.4(32)"></A><A name="onMouseUp.4(32)"></A>:&lt; mouseUp;
               <B>keyDown</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:keyDown.4(33)"></A><A name="keyDown.4(33)"></A>: keyEvent
                 (* Occurs when the user presses a key, related to
                  * THIS(interfaceObject)
                  *)
                 (# do INNER #);
               <B>onKeyDown</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onKeyDown.4(34)"></A><A name="onKeyDown.4(34)"></A>:&lt; keyDown;
               <B>refresh</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:refresh.4(35)"></A><A name="refresh.4(35)"></A>: basicEvent
                 (* This event tells THIS(interfaceobject), that it
                  * needs to redraw itself. UpdateRect is the 
                  * rectangle that needs to be updated expressed
                  * in the coordinate system of this(interfaceObject).
                  *)
                 (# updateRect:
                      (# value: ^rectangle;
                      ...
                      exit value[]
                      #)
                 do INNER 
                 #);
               <B>onRefresh</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onRefresh.4(36)"></A><A name="onRefresh.4(36)"></A>:&lt; refresh;
               <B>activate</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:activate.4(37)"></A><A name="activate.4(37)"></A>: basicEvent
                 (* Send when THIS(interfaceObject) becomes active *)
                 (# do INNER #);
               <B>onActivate</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onActivate.4(38)"></A><A name="onActivate.4(38)"></A>:&lt; activate;
               <B>deactivate</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:deactivate.4(39)"></A><A name="deactivate.4(39)"></A>: basicEvent
                 (* Send when THIS(interfaceObject) becomes inactive
                  *)
                 (# do INNER #);
               <B>onDeactivate</B><A name="GUIenv.1:interfaceObject.2:eventhandler.3:onDeactivate.4(40)"></A><A name="onDeactivate.4(40)"></A>:&lt; deactivate;
            #);
          <B>action</B><A name="GUIenv.1:interfaceObject.2:action.3(41)"></A><A name="action.3(41)"></A>:
            (* Actions is a means of subscribing to events.  The
             * desired event is specified by further binding
             * eventType.  Actions can be prepended or appended to
             * THIS(interfaceobject).  When some event is called, the
             * prepended actions for the event is called *before* the
             * INNER and the appended actions are called after.
             *)
            (# &lt;&lt;SLOT actionLib: attributes&gt;&gt;;
               eventType:&lt; theEventhandler.event;
               theEvent: ^eventType;
            enter theEvent[]
            do INNER;
            #);
          <B>prependAction</B><A name="GUIenv.1:interfaceObject.2:prependAction.3(42)"></A><A name="prependAction.3(42)"></A>:
            (* Prepends the action, so it will be executed before the
             * event is subscribes to
             *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>appendAction</B><A name="GUIenv.1:interfaceObject.2:appendAction.3(43)"></A><A name="appendAction.3(43)"></A>:
            (* Appends the action, so it will be executed after the
             * event is subscribes to.
             *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>deleteAction</B><A name="GUIenv.1:interfaceObject.2:deleteAction.3(44)"></A><A name="deleteAction.3(44)"></A>:
            (* Remove the action *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>open</B><A name="GUIenv.1:interfaceObject.2:open.3(45)"></A><A name="open.3(45)"></A>:&lt; 
            (* must be called before any other operation on
             * THIS(interfaceObject).
             *)
            (# create:&lt; (# ... #);
            ...
            #);
          <B>close</B><A name="GUIenv.1:interfaceObject.2:close.3(46)"></A><A name="close.3(46)"></A>:&lt; 
            (* closes THIS(interfaceObject) and dispose all related
             *              structures
             *)
            (# ... #);
          <B>enableEventType</B><A name="GUIenv.1:interfaceObject.2:enableEventType.3(47)"></A><A name="enableEventType.3(47)"></A>:&lt;
            (* makes THIS(interfaceObject) sensible to the specified
             * type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            ...
            #);
          <B>disableEventType</B><A name="GUIenv.1:interfaceObject.2:disableEventType.3(48)"></A><A name="disableEventType.3(48)"></A>:&lt;
            (* makes THIS(interfaceObject) insensible to the
             * specified type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            ...
            #);
          <B>interfaceObjectException</B><A name="GUIenv.1:interfaceObject.2:interfaceObjectException.3(49)"></A><A name="interfaceObjectException.3(49)"></A>: exception
            (* abstract superpattern for exceptiosn related to
             * THIS(interfaceObject).
             *)
            (# 
            ... 
            #);
          <B>notOpenedException</B><A name="GUIenv.1:interfaceObject.2:notOpenedException.3(50)"></A><A name="notOpenedException.3(50)"></A>: interfaceObjectException
            (# location: ^text
            enter location[]
            ...
            #);
          <B>notOpenedError</B><A name="GUIenv.1:interfaceObject.2:notOpenedError.3(51)"></A><A name="notOpenedError.3(51)"></A>:&lt; 
            (* this exception is raised if any operation is performed
             * on THIS(interfaceObject) is called before open is
             * called.  This will also happen if "close" is called
             * twice
             *)
            notOpenedException;
          <B>private</B><A name="GUIenv.1:interfaceObject.2:private.3(52)"></A><A name="private.3(52)"></A>: @...;
       do INNER
       #) (* interfaceObject *);
     <B>menubar</B><A name="GUIenv.1:menubar.2(53)"></A><A name="menubar.2(53)"></A>: interfaceObject
       (* menubar is a bar containing the titles of the contained
        * menus. A menu is pulled down by clicking at the title,
        * allowing the user to select a menuitem in the menu.  A
        * menubar is only visible if it is installed - either as the
        * global menubar or as the menubar in some window.
        *)
       (# &lt;&lt;SLOT menubarLib: attributes&gt;&gt;;
          <B>append</B><A name="GUIenv.1:menubar.2:append.3(54)"></A><A name="append.3(54)"></A>: 
            (* inserts a menu after all menues in the menubar.  If
             * the menu is already in the menu bar, nothing happens
             *)
            (# theMenu: ^menu;
            enter theMenu[]
            ...
            #);
          <B>delete</B><A name="GUIenv.1:menubar.2:delete.3(55)"></A><A name="delete.3(55)"></A>: 
            (* deletes a menu from the menu bar. The menu titles
             * following the deleted menu will move over to fill the
             * vacancy
             *)
            (# theMenu: ^menu
            enter theMenu[]
            ...
            #);
          <B>clear</B><A name="GUIenv.1:menubar.2:clear.3(56)"></A><A name="clear.3(56)"></A>: 
            (* removes all menues from the menu bar when you want to
             * start with new menues
             *)
            (# ... #);
          <B>appendMenubar</B><A name="GUIenv.1:menubar.2:appendMenubar.3(57)"></A><A name="appendMenubar.3(57)"></A>: 
            (* inserts all menues in another menubar after all menues
             * in THIS(menubar).  This is the same as calling
             * insertMenubar with NONE as afterMenu.
             *)
            (# theMenubar: ^menubartype;
            enter theMenubar[]
            ...
            #);
          <B>replaceMenubar</B><A name="GUIenv.1:menubar.2:replaceMenubar.3(58)"></A><A name="replaceMenubar.3(58)"></A>: 
            (* replace all menues in theMenubar with all menues in
             * replacementMenubar in THIS(menubar).
             *)
            (# theMenubar, replacementMenubar: ^menubartype
            enter (theMenubar[], replacementMenubar[])
            ...
            #);
          <B>deleteMenubar</B><A name="GUIenv.1:menubar.2:deleteMenubar.3(59)"></A><A name="deleteMenubar.3(59)"></A>: 
            (* deletes all menues in theMenubar from
             * THIS(menubar). The menu titles following the menues in
             * the deleted menubar will move over to fill the vacancy
             *)
            (# theMenubar: ^menubartype
            enter theMenubar[]
            ...
            #);
          <B>scan</B><A name="GUIenv.1:menubar.2:scan.3(60)"></A><A name="scan.3(60)"></A>: 
            (* iterates over all menues currently inserted in the
             * menubar
             *)
            (# current: ^menu;
            ... #);
          <B>open</B><A name="GUIenv.1:menubar.2:open.3(61)"></A><A name="open.3(61)"></A>::&lt;(# create::&lt; (# ... #);
            ...
            #);
          <B>close</B><A name="GUIenv.1:menubar.2:close.3(62)"></A><A name="close.3(62)"></A>::&lt;
            (# 
            ...
            #);
          <B>private</B><A name="GUIenv.1:menubar.2:private.3(63)"></A><A name="private.3(63)"></A>: @...; 
       #) (* menubar *);
     <B>menu</B><A name="GUIenv.1:menu.2(64)"></A><A name="menu.2(64)"></A>: interfaceObject
       (* menu contains a group of menuitems and is usefull for
        * letting the user perform commands or set settings in the
        * application. A menu can be installed in a menubar, as a
        * submenu to some menuitem or simply be popped up on the
        * screen.
        *)
       (# &lt;&lt;SLOT menuLib: attributes&gt;&gt;;
          <B>name</B><A name="GUIenv.1:menu.2:name.3(65)"></A><A name="name.3(65)"></A>:
            (* the name of the menu as shown in the menubar.  if the
             * menu is not in a menubar, the name is not visible
             *)
            (# <B>theName</B><A name="GUIenv.1:menu.2:name.3:theName.4(66)"></A><A name="theName.4(66)"></A>: ^text
            enter (# enter theName[] ... #)
            exit (# ... exit theName[] #)
            #);
          <B>eventhandler</B><A name="GUIenv.1:menu.2:eventhandler.3(67)"></A><A name="eventhandler.3(67)"></A>::&lt;
            (# <B>select</B><A name="GUIenv.1:menu.2:eventhandler.3:select.4(68)"></A><A name="select.4(68)"></A>: event
                 (* executed when the user selects THIS(menu) (or
                  * pops it up) just before the menu is shown.
                  *)
                 (# do INNER #);
               <B>onSelect</B><A name="GUIenv.1:menu.2:eventhandler.3:onSelect.4(69)"></A><A name="onSelect.4(69)"></A>:&lt; select;
            #);
          <B>menuitem</B><A name="GUIenv.1:menu.2:menuitem.3(70)"></A><A name="menuitem.3(70)"></A>: interfaceObject
            (* menuitem is used for letting the user perform commands
             * in the application or display the state of some option,
             * by checking and unchecking the menuitem. It can also
             * serve as the title of a submenu.
             *)
            (# &lt;&lt;SLOT menuitemLib: attributes&gt;&gt;;
               <B>key</B><A name="GUIenv.1:menu.2:menuitem.3:key.4(71)"></A><A name="key.4(71)"></A>: 
                 (* the key shortcut of THIS(menuitem), allows the
                  * user to select THIS(menuitem) without using the
                  * mouse.
                  *)
                 (# c: @char
                 enter (# enter c ... #)
                 exit (# ... exit c #)
                 #);
               <B>name</B><A name="GUIenv.1:menu.2:menuitem.3:name.4(72)"></A><A name="name.4(72)"></A>: 
                 (* models the name of THIS(menuitem).  Evaluate the
                  * enter-part to set the name.  Evaluate the
                  * exit-part to get the name
                  *)
                 (# t: ^text;
                 enter (# enter t[] ... #)
                 exit (# ... exit t[] #)
                 #);
               <B>checked</B><A name="GUIenv.1:menu.2:menuitem.3:checked.4(73)"></A><A name="checked.4(73)"></A>:
                 (* when THIS(menuitem) is checked, a check mark is
                  * displayed at the left side the menuitem
                  *)
                 (# checked: @boolean
                 enter (# enter checked ... #)
                 exit (# ... exit checked #)
                 #);
               <B>subMenu</B><A name="GUIenv.1:menu.2:menuitem.3:subMenu.4(74)"></A><A name="subMenu.4(74)"></A>:
                 (* if a submenu is attached to THIS(menuitem), that
                  * menu is pulled down by selecting
                  * THIS(menuitem). In that case onSelect is never
                  * issued for THIS(menuitem)
                  *)
                 (# theMenu: ^menu;
                 enter (# enter theMenu[] ... #)
                 exit (# ... exit theMenu[] #)
                 #);
               <B>position</B><A name="GUIenv.1:menu.2:menuitem.3:position.4(75)"></A><A name="position.4(75)"></A>: IntegerValue
                 (* the position of THIS(menuitem) in its menu,
                  * separator items are counted as well
                  *)
                 (# 
                 ...
                 #);
               <B>eventhandler</B><A name="GUIenv.1:menu.2:menuitem.3:eventhandler.4(76)"></A><A name="eventhandler.4(76)"></A>::&lt;
                 (# <B>onStatus</B><A name="GUIenv.1:menu.2:menuitem.3:eventhandler.4:onStatus.5(77)"></A><A name="onStatus.5(77)"></A>:&lt; booleanValue
                      (* executed just before THIS(menuitem) is
                       * shown.  should return true if THIS(menuitem)
                       * is enabled.  Default is true
                       *)
                      (# ... #);
                    <B>select</B><A name="GUIenv.1:menu.2:menuitem.3:eventhandler.4:select.5(78)"></A><A name="select.5(78)"></A>: event
                      (* executed when THIS(menuitem) is selected in
                       * the menu.  If a submenu is attached, it will
                       * not be executed - instead the submenu is
                       * pulled down
                       *)
                      (# do INNER #);
                    <B>onSelect</B><A name="GUIenv.1:menu.2:menuitem.3:eventhandler.4:onSelect.5(79)"></A><A name="onSelect.5(79)"></A>:&lt; select;
                 #);
               <B>open</B><A name="GUIenv.1:menu.2:menuitem.3:open.4(80)"></A><A name="open.4(80)"></A>::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               <B>private</B><A name="GUIenv.1:menu.2:menuitem.3:private.4(81)"></A><A name="private.4(81)"></A>: @...;
            do INNER
            #) (* menuitem *);
          <B>dynamicMenuitem</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3(82)"></A><A name="dynamicMenuitem.3(82)"></A>: menuitem
            (* dynamic menuitem does not call its own onStatus and
             * onSelect events, instead these events are called on the
             * attached action, if any is attached
             *)
            (# &lt;&lt;SLOT dynamicItemLib: attributes&gt;&gt;;
               <B>theAction</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:theAction.4(83)"></A><A name="theAction.4(83)"></A>: ^menuAction;
               <B>attach</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:attach.4(84)"></A><A name="attach.4(84)"></A>: 
                 (* anAction is attached to THIS(menuitem) *)
                 (# anAction: ^menuAction;
                 enter anAction[]
                 ...
                 #);
               <B>detach</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:detach.4(85)"></A><A name="detach.4(85)"></A>:
                 (* the menuitemHandler that is currently attached to
                  * THIS(menuitem) is detached, meaning that no action
                  * is attached
                  *)
                 (# ... #);
               <B>eventhandler</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:eventhandler.4(86)"></A><A name="eventhandler.4(86)"></A>::&lt;(# <B>onStatus</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:eventhandler.4:onStatus.5(87)"></A><A name="onStatus.5(87)"></A>::&lt; (# ... #);
                    <B>onSelect</B><A name="GUIenv.1:menu.2:dynamicMenuitem.3:eventhandler.4:onSelect.5(88)"></A><A name="onSelect.5(88)"></A>::&lt; (# ... #);
                 #);
            #) (* dynamicMenuitem *);
          <B>menuAction</B><A name="GUIenv.1:menu.2:menuAction.3(89)"></A><A name="menuAction.3(89)"></A>:
            (* a menuAction can dynamicly be attached to
             * dynamicMenuitems within THIS(menu), meaning that the
             * onStatus and onSelect events of THIS(menuAction) will
             * be executed instead of these events of the
             * dynamicMenuitem. The pointer "theMenuitem" refers to
             * the dynamicMenuitem THIS(menuAction) is currently
             * attached to
             *)
            (# <B>theMenuitem</B><A name="GUIenv.1:menu.2:menuAction.3:theMenuitem.4(90)"></A><A name="theMenuitem.4(90)"></A>:
                 (* the menuitem THIS(menuAction) is attached to *)
                 ^dynamicMenuitem;
               <B>onStatus</B><A name="GUIenv.1:menu.2:menuAction.3:onStatus.4(91)"></A><A name="onStatus.4(91)"></A>:&lt; booleanValue
                 (* this status is evaluated instead of the status of
                  * the actual menuitem (theMenuitem) THIS(menuAction)
                  * is attached to.  Default returns true
                  *)
                 (# ... #);
               <B>onSelect</B><A name="GUIenv.1:menu.2:menuAction.3:onSelect.4(92)"></A><A name="onSelect.4(92)"></A>:&lt; 
                 (* onSelect is executed from the hit of the actual
                  * dynamicMenuitem THIS(action) is attached to
                  *)
                 object;
            #) (* action *);
          <B>separator</B><A name="GUIenv.1:menu.2:separator.3(93)"></A><A name="separator.3(93)"></A>: menuitem
            (* defines a menu separator, which is a unselectable line
             * in the menu, dividing groups of menuitems.
             *)
            (# open::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               close::&lt; (# ... #);
            #);
          <B>append</B><A name="GUIenv.1:menu.2:append.3(94)"></A><A name="append.3(94)"></A>:
            (* appends the menuitem to THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            ...
            #);
          <B>delete</B><A name="GUIenv.1:menu.2:delete.3(95)"></A><A name="delete.3(95)"></A>: 
            (* deletes the menuitem from THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            ...
            #);
          <B>scan</B><A name="GUIenv.1:menu.2:scan.3(96)"></A><A name="scan.3(96)"></A>: 
            (* iterates over all menuitems in THIS(menu) *)
            (# current: ^menuitem
              ...
            #);
          <B>clear</B><A name="GUIenv.1:menu.2:clear.3(97)"></A><A name="clear.3(97)"></A>:
            (* deletes all menuitems in  THIS(menu) *)
            (#
            ...
            #);
          <B>noOfMenuitems</B><A name="GUIenv.1:menu.2:noOfMenuitems.3(98)"></A><A name="noOfMenuitems.3(98)"></A>: integerValue
            (* returns the number of menuitems in THIS(menu) *)
            (# ... #);
          <B>popUp</B><A name="GUIenv.1:menu.2:popUp.3(99)"></A><A name="popUp.3(99)"></A>: 
            (* THIS(menu) is popped up as follows: The menuitem
             * indexed by "popupWith" is selected (not checked but
             * hilited) and popupAt is the top left corner of that
             * menuitem in the coordinate system of the popupIn
             * window.
             *)
            (# popupWith: @integer;
               popupAt: @point;
               popupIn: ^window.windowitem;
            enter (popupWith,popupAt,popupIn[])
            ...
            #);
          <B>getMenuitemByNumber</B><A name="GUIenv.1:menu.2:getMenuitemByNumber.3(100)"></A><A name="getMenuitemByNumber.3(100)"></A>: 
            (* returns a reference to the menuitem at the specified
             * position in the menu
             *)
            (# number: @integer;
               theMenuitem: ^menuitem;
            enter number
            ...
            exit theMenuitem[]
            #);
          <B>enable</B><A name="GUIenv.1:menu.2:enable.3(101)"></A><A name="enable.3(101)"></A>: (* enable THIS(menu) *)
            (# ... #);
          <B>disable</B><A name="GUIenv.1:menu.2:disable.3(102)"></A><A name="disable.3(102)"></A>: (* disable THIS(menu) *)
            (# ... #);
          <B>enabled</B><A name="GUIenv.1:menu.2:enabled.3(103)"></A><A name="enabled.3(103)"></A>:&lt; booleanValue
            (* should return true if THIS(menu) is enabled *)
            (# ... #);
          <B>open</B><A name="GUIenv.1:menu.2:open.3(104)"></A><A name="open.3(104)"></A>::&lt; 
            (* the menu is not automatically inserted in the
             * menubar. You have to do this yourself
             *)
            (# create::&lt; (# ... #);
            ... 
            #);
          <B>close</B><A name="GUIenv.1:menu.2:close.3(105)"></A><A name="close.3(105)"></A>::&lt; (# ... #);
          <B>private</B><A name="GUIenv.1:menu.2:private.3(106)"></A><A name="private.3(106)"></A>: @...;
       #) (* menu *);
     <B>standardMenubar</B><A name="GUIenv.1:standardMenubar.2(107)"></A><A name="standardMenubar.2(107)"></A>: menubar
       (# <B>standardFileMenu</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3(108)"></A><A name="standardFileMenu.3(108)"></A>: menu
            (# <B>newMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:newMenuitem.4(109)"></A><A name="newMenuitem.4(109)"></A>: @dynamicMenuitem;
               <B>openMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:openMenuitem.4(110)"></A><A name="openMenuitem.4(110)"></A>: @dynamicMenuitem;
               <B>closeMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:closeMenuitem.4(111)"></A><A name="closeMenuitem.4(111)"></A>: @dynamicMenuitem;
               <B>saveMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:saveMenuitem.4(112)"></A><A name="saveMenuitem.4(112)"></A>: @dynamicMenuitem;
               <B>saveAsMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:saveAsMenuitem.4(113)"></A><A name="saveAsMenuitem.4(113)"></A>: @dynamicMenuitem;
               <B>revertMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:revertMenuitem.4(114)"></A><A name="revertMenuitem.4(114)"></A>: @dynamicMenuitem;
               <B>printMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:printMenuitem.4(115)"></A><A name="printMenuitem.4(115)"></A>: @dynamicMenuitem;
               <B>pageSetUpMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:pageSetUpMenuitem.4(116)"></A><A name="pageSetUpMenuitem.4(116)"></A>: @dynamicMenuitem;
               <B>quitMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:quitMenuitem.4(117)"></A><A name="quitMenuitem.4(117)"></A>: @dynamicMenuitem;
               <B>open</B><A name="GUIenv.1:standardMenubar.2:standardFileMenu.3:open.4(118)"></A><A name="open.4(118)"></A>::&lt; (# ... #);    
            #) (* standardFileMenu *);
          <B>fileMenu</B><A name="GUIenv.1:standardMenubar.2:fileMenu.3(119)"></A><A name="fileMenu.3(119)"></A>:&lt; menu;
          <B>theFileMenu</B><A name="GUIenv.1:standardMenubar.2:theFileMenu.3(120)"></A><A name="theFileMenu.3(120)"></A>: ^fileMenu;
          <B>standardEditMenu</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3(121)"></A><A name="standardEditMenu.3(121)"></A>: menu
            (# <B>undoMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:undoMenuitem.4(122)"></A><A name="undoMenuitem.4(122)"></A>: @dynamicMenuitem;
               <B>cutMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:cutMenuitem.4(123)"></A><A name="cutMenuitem.4(123)"></A>: @dynamicMenuitem;
               <B>copyMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:copyMenuitem.4(124)"></A><A name="copyMenuitem.4(124)"></A>: @dynamicMenuitem;
               <B>pasteMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:pasteMenuitem.4(125)"></A><A name="pasteMenuitem.4(125)"></A>: @dynamicMenuitem;
               <B>clearMenuitem</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:clearMenuitem.4(126)"></A><A name="clearMenuitem.4(126)"></A>: @dynamicMenuitem;
               <B>open</B><A name="GUIenv.1:standardMenubar.2:standardEditMenu.3:open.4(127)"></A><A name="open.4(127)"></A>::&lt; (# ... #);
            #) (* standardEditMenu *);
          <B>editMenu</B><A name="GUIenv.1:standardMenubar.2:editMenu.3(128)"></A><A name="editMenu.3(128)"></A>:&lt; menu;
          <B>theEditMenu</B><A name="GUIenv.1:standardMenubar.2:theEditMenu.3(129)"></A><A name="theEditMenu.3(129)"></A>: ^editMenu;
          <B>open</B><A name="GUIenv.1:standardMenubar.2:open.3(130)"></A><A name="open.3(130)"></A>::&lt;
            (# 
            ...
            #);
       #);
     <B>window</B><A name="GUIenv.1:window.2(131)"></A><A name="window.2(131)"></A>: interfaceObject
       (* user interaction with the window such as dragging and
        * resizing is taken care of by the window manager.  Anything
        * visible you may want to place in the window is subpatterns
        * of the abstract pattern windowitem, which is a subpattern of
        * interfaceObject. The window can be used as a modal dialog by
        * means of the pattern "showModal"
        *)
       (# &lt;&lt;SLOT windowLib: attributes&gt;&gt;;
          <B>eventhandler</B><A name="GUIenv.1:window.2:eventhandler.3(132)"></A><A name="eventhandler.3(132)"></A>::&lt;
            (# <B>aboutToClose</B><A name="GUIenv.1:window.2:eventhandler.3:aboutToClose.4(133)"></A><A name="aboutToClose.4(133)"></A>: event
                 (* is called whenever the user has performed an
                  * action that causes THIS(window) to close.  Further
                  * bind this to perform actions before the window is
                  * actually closed.  You can prevent the window from
                  * closing by assigning false to the boolean
                  * 'okToClose'
                  *)
                 (# okToClose: @boolean
                 do true -&gt; okToClose;
                    INNER
                 exit okToClose
                 #);
               <B>onAboutToClose</B><A name="GUIenv.1:window.2:eventhandler.3:onAboutToClose.4(134)"></A><A name="onAboutToClose.4(134)"></A>:&lt;  aboutToClose;
               <B>onActivate</B><A name="GUIenv.1:window.2:eventhandler.3:onActivate.4(135)"></A><A name="onActivate.4(135)"></A>::&lt;
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# ... #);
               <B>onDeactivate</B><A name="GUIenv.1:window.2:eventhandler.3:onDeactivate.4(136)"></A><A name="onDeactivate.4(136)"></A>::&lt;
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# ... #);
            #);
          <B>theMenubar</B><A name="GUIenv.1:window.2:theMenubar.3(137)"></A><A name="theMenubar.3(137)"></A>:
            (* is used to install a menubar for THIS(window), and to
             * gain access to the menubar of THIS(window)
             *)
            (# theBar: ^menubartype
            enter (# enter theBar[] ... #)
            exit (# ... exit theBar[] #)
            #);
          <B>menubarType</B><A name="GUIenv.1:window.2:menubarType.3(138)"></A><A name="menubarType.3(138)"></A>:&lt;
            (* if further bound, an instance of menubarType is
             * automatically installed for THIS(window)
             *)
            menubar;
          <B>menubarVisible</B><A name="GUIenv.1:window.2:menubarVisible.3(139)"></A><A name="menubarVisible.3(139)"></A>:&lt; 
            (* Specifies if the menubar should be visible. *)
            trueObject;
          <B>type</B><A name="GUIenv.1:window.2:type.3(140)"></A><A name="type.3(140)"></A>:&lt;
            (* The type can be one of the following:
             *   windowTypes.normal  &lt;- default
             *   windowTypes.dialog
             *   windowTypes.palette
             *)
            integerValue;
          <B>resizeable</B><A name="GUIenv.1:window.2:resizeable.3(141)"></A><A name="resizeable.3(141)"></A>:&lt; booleanValue
            (# 
            do (if type=windowTypes.normal then
                   true -&gt; value; INNER 
               if);
            #);
          <B>title</B><A name="GUIenv.1:window.2:title.3(142)"></A><A name="title.3(142)"></A>: 
            (* the title of the window is displayed in the windows
             * title-bar if the window has one.
             *)
            (# theTitle: ^text
            enter (# enter theTitle[] ... #)
            exit (# ... exit theTitle[] #)
            #);
          <B>position</B><A name="GUIenv.1:window.2:position.3(143)"></A><A name="position.3(143)"></A>: 
            (* the window's position is the coordinates of the
             * topLeft corner of the window's inside rectangle on the
             * screen
             *)
            (# pt: @point;
            enter (# enter pt ... #)
            exit (# ... exit pt #)
            #);
          <B>size</B><A name="GUIenv.1:window.2:size.3(144)"></A><A name="size.3(144)"></A>: 
            (* the size is the size of the inside rectangle of the
             * window
             *)
            (# width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>frame</B><A name="GUIenv.1:window.2:frame.3(145)"></A><A name="frame.3(145)"></A>:
            (* the frame is defined as the rectangle THIS(window)
             * occupies on the screen = (position,position + size)
             *)
            (# theFrame: @rectangle;
            enter (# enter theFrame ... #)
            exit (# ... exit theFrame #)
            #);
          <B>insideRectangle</B><A name="GUIenv.1:window.2:insideRectangle.3(146)"></A><A name="insideRectangle.3(146)"></A>: 
            (* the inside rectangle is the window's content rectangle
             * in terms of local coordinates in the window.  The top
             * left corner is (0, 0) and the bottom right corner is
             * the window's size
             *)
            (# theRectangle: @rectangle;
            ...
            exit theRectangle
            #);
          <B>show</B><A name="GUIenv.1:window.2:show.3(147)"></A><A name="show.3(147)"></A>: 
            (* shows THIS(window) in front of other windows *)
            (# ... #);
          <B>showModal</B><A name="GUIenv.1:window.2:showModal.3(148)"></A><A name="showModal.3(148)"></A>:
            (* shows THIS(window) in a modal way. Interaction with
             * other windows is prevented until THIS(window) is either
             * closed or hidden, and then showModal returns to the
             * caller
             *)
            (# ... #);
          <B>hide</B><A name="GUIenv.1:window.2:hide.3(149)"></A><A name="hide.3(149)"></A>: 
            (* hides THIS(window), i.e. make it invisible without
             * destroying it. Can be made visible again using show
             *)
            (# ... #);
          <B>visible</B><A name="GUIenv.1:window.2:visible.3(150)"></A><A name="visible.3(150)"></A>:
            (* The visibility of the window. *)
            (# value: @boolean;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>maxSize</B><A name="GUIenv.1:window.2:maxSize.3(151)"></A><A name="maxSize.3(151)"></A>: 
            (* use this to set the maximum size THIS(window) is
             * allowed to get, when resized by the user. maxSize
             * doesn't affect the behaviour of setSize.
             *)
            (# width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>minSize</B><A name="GUIenv.1:window.2:minSize.3(152)"></A><A name="minSize.3(152)"></A>: 
            (* use this to set the minimum size THIS(window) is
             * allowed to get, when resized by the user. minSize
             * doesn't affect the behaviour of setSize
             *)
            (#  width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>bringToFront</B><A name="GUIenv.1:window.2:bringToFront.3(153)"></A><A name="bringToFront.3(153)"></A>: 
            (* THIS(window) is brought to the front of all other
             * windows
             *)
            (# ... #);
          <B>bringBack</B><A name="GUIenv.1:window.2:bringBack.3(154)"></A><A name="bringBack.3(154)"></A>: 
            (* THIS(window) is placed behind all other windows *)
            (# ... #);
          <B>bringBehind</B><A name="GUIenv.1:window.2:bringBehind.3(155)"></A><A name="bringBehind.3(155)"></A>: 
            (* THIS(window) is placed behind the window referred to
             * by "theWindow"
             *)
            (# theWindow: ^window;
            enter theWindow[]
            ...
            #);
          <B>update</B><A name="GUIenv.1:window.2:update.3(156)"></A><A name="update.3(156)"></A>: 
            (* Updates the window by posting a refresh event.  If
             * emmediate is true, the refresh event will be processed
             * immediately.
             *)
            (# immediate: @boolean;
            enter immediate
            ...
            #);
          <B>backgroundColor</B><A name="GUIenv.1:window.2:backgroundColor.3(157)"></A><A name="backgroundColor.3(157)"></A>:
            (* Sets backgroundcolor of this window *)
            (# theColor: @color
            enter theColor
            ...
            #);
          <B>contents</B><A name="GUIenv.1:window.2:contents.3(158)"></A><A name="contents.3(158)"></A>:
            (* The contents of THIS(window) is the father of all
             * other windowitems in THIS(window).
             *)
            (# theContents: ^canvas;
            ...
            exit theContents[]
            #);
          <B>target</B><A name="GUIenv.1:window.2:target.3(159)"></A><A name="target.3(159)"></A>: 
            (* the window's target is a reference to the windowitem
             * that receives keyDown. You are responsible for making
             * sure the window's target is the windowitem that is
             * affected by menu commands. The eventhandler of
             * windowitem has two events: "enableTarget" and
             * "disableTarget". When a windowitem is becomming the new
             * target, first "disableTarget" is called for the old
             * target then "enableTarget" is called for the new target
             *)
            (# theTarget: ^windowitem;
            enter (# enter theTarget[] ... #)
            exit (# ... exit theTarget[] #)
            #);
          <B>windowitem</B><A name="GUIenv.1:window.2:windowitem.3(160)"></A><A name="windowitem.3(160)"></A>: interfaceObject
            (* superclass for all interfaceobjects in this window.  A
             * windowitem is always part of a canvas (father)
             *)
            (# &lt;&lt;SLOT windowitemLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4(161)"></A><A name="eventhandler.4(161)"></A>::&lt;
                 (# <B>visibleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:visibleChanged.5(162)"></A><A name="visibleChanged.5(162)"></A>: event
                      (* is called, when THIS(windowitem) is hidden
                       * or shown
                       *)
                      (# do INNER #);
                    <B>onVisibleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onVisibleChanged.5(163)"></A><A name="onVisibleChanged.5(163)"></A>:&lt; visibleChanged;
                    <B>frameChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:frameChanged.5(164)"></A><A name="frameChanged.5(164)"></A>: event
                      (* is called whenever the frame of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do INNER 
                      #);
                    <B>onFrameChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onFrameChanged.5(165)"></A><A name="onFrameChanged.5(165)"></A>:&lt; frameChanged;
                    <B>fatherFrameChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:fatherFrameChanged.5(166)"></A><A name="fatherFrameChanged.5(166)"></A>: event
                      (* is called when the frame of the father of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do INNER 
                      #);
                    <B>onFatherFrameChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onFatherFrameChanged.5(167)"></A><A name="onFatherFrameChanged.5(167)"></A>:&lt; fatherFrameChanged;
                    <B>enabledChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:enabledChanged.5(168)"></A><A name="enabledChanged.5(168)"></A>: event
                      (* is called, when THIS(windowitem) is
                       * enabled/disabled
                       *)
                      (# do INNER #);
                    <B>onEnabledChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onEnabledChanged.5(169)"></A><A name="onEnabledChanged.5(169)"></A>:&lt; enabledChanged;
                    <B>enableTarget</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:enableTarget.5(170)"></A><A name="enableTarget.5(170)"></A>: event
                      (* is called when THIS(windowitem) is becomming
                       * target in the window
                       *)
                      (# do INNER #);
                    <B>onEnableTarget</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onEnableTarget.5(171)"></A><A name="onEnableTarget.5(171)"></A>:&lt; enableTarget;
                    <B>disableTarget</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:disableTarget.5(172)"></A><A name="disableTarget.5(172)"></A>: event
                      (* is called when THIS(windowitem) was target
                       * and another windowitem is becomming target
                       *)
                      (# do INNER #);
                    <B>onDisableTarget</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onDisableTarget.5(173)"></A><A name="onDisableTarget.5(173)"></A>:&lt; disableTarget;
                    <B>borderVisibleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:borderVisibleChanged.5(174)"></A><A name="borderVisibleChanged.5(174)"></A>: event
                      (* is called, when the border of 
                       * THIS(windowitem) is shown or hidden
                       *)
                      (# do INNER #);
                    <B>onBorderVisibleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onBorderVisibleChanged.5(175)"></A><A name="onBorderVisibleChanged.5(175)"></A>:&lt; borderVisibleChanged;
                    <B>borderStyleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:borderStyleChanged.5(176)"></A><A name="borderStyleChanged.5(176)"></A>: event
                      (* is called, when the border style of
                       * THIS(windowitem) is changed
                       *)
                      (# do INNER #);
                    <B>onBorderStyleChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onBorderStyleChanged.5(177)"></A><A name="onBorderStyleChanged.5(177)"></A>:&lt; borderStyleChanged;
                    <B>theCursorChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:theCursorChanged.5(178)"></A><A name="theCursorChanged.5(178)"></A>: event
                      (* is called, when THIS(windowitem) is assigned
                       * a new cursor
                       *)
                      (# do INNER #);
                    <B>onTheCursorChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onTheCursorChanged.5(179)"></A><A name="onTheCursorChanged.5(179)"></A>:&lt; theCursorChanged;
                    <B>hiliteChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:hiliteChanged.5(180)"></A><A name="hiliteChanged.5(180)"></A>: event
                      (* Is called when THIS(windowitem) is hilited
                       * or dehilited
                       *)
                      (# do INNER; #);
                    <B>onHiliteChanged</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onHiliteChanged.5(181)"></A><A name="onHiliteChanged.5(181)"></A>:&lt; hiliteChanged;
                    <B>onRefresh</B><A name="GUIenv.1:window.2:windowitem.3:eventhandler.4:onRefresh.5(182)"></A><A name="onRefresh.5(182)"></A>::&lt; (# ... #);
                 #);
               <B>father</B><A name="GUIenv.1:window.2:windowitem.3:father.4(183)"></A><A name="father.4(183)"></A>: ^
                 (* father is the canvas that THIS(windowitem) is a
                  * child of
                  *)
                 canvas;
               <B>frame</B><A name="GUIenv.1:window.2:windowitem.3:frame.4(184)"></A><A name="frame.4(184)"></A>: 
                 (* the frame is defined as the rectangle
                  * THIS(windowitem) occupies in the coordinate system
                  * of the father. When the frame is changed
                  * THIS(windowitem) is updated and the father is
                  * informed about the change.  If you need other
                  * actions to take place, when changing the frame,
                  * you must further bind the event onFrameChanged
                  *)
                 (# theFrame: @rectangle;
                 enter (# enter theFrame ... #)
                 exit (# ... exit theFrame #)
                 #);
               <B>position</B><A name="GUIenv.1:window.2:windowitem.3:position.4(185)"></A><A name="position.4(185)"></A>: 
                 (* the position of THIS(windowitem) is defined as
                  * the topLeft corner of the bounding frame. When the
                  * position is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# pt: @point;
                 enter (# enter pt ... #)
                 exit (# ... exit pt #)
                 #);
               <B>move</B><A name="GUIenv.1:window.2:windowitem.3:move.4(186)"></A><A name="move.4(186)"></A>: 
                 (* moves THIS(windowitem) relative (dh, dv), by
                  * setting the position, meaning that the
                  * onFrameChanged event is called
                  *)
                 (# dh, dv: @integer;
                 enter (dh, dv)
                 ...
                 #);
               <B>size</B><A name="GUIenv.1:window.2:windowitem.3:size.4(187)"></A><A name="size.4(187)"></A>: 
                 (* the size of THIS(windowitem) is defined as the
                  * height and width of the bounding frame. When the
                  * size is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# width, height: @integer;
                 enter (# enter (width, height) ... #)
                 exit (# ... exit (width, height) #)
                 #);
               <B>fitToContents</B><A name="GUIenv.1:window.2:windowitem.3:fitToContents.4(188)"></A><A name="fitToContents.4(188)"></A>:&lt;
                 (* Adjusts the size of THIS(windowItem) to 
                  * fit the contents
                  *)
                 (# doneInInner: @boolean;
                 ...
                 #);
               <B>bindLeft</B><A name="GUIenv.1:window.2:windowitem.3:bindLeft.4(189)"></A><A name="bindLeft.4(189)"></A>,<B> bindRight</B><A name="GUIenv.1:window.2:windowitem.3:bindRight.4(190)"></A><A name="bindRight.4(190)"></A>,<B> bindBottom</B><A name="GUIenv.1:window.2:windowitem.3:bindBottom.4(191)"></A><A name="bindBottom.4(191)"></A>,<B> bindTop</B><A name="GUIenv.1:window.2:windowitem.3:bindTop.4(192)"></A><A name="bindTop.4(192)"></A>: @
                 (* these attributes specify how THIS(windowitem)
                  * shall behave when the father changes it's
                  * frame. If e.g. "bindLeft" is true, the leftSide
                  * will have the same constant distance to the
                  * leftSide of the father, when the father is resized
                  *)
                 boolean;
               <B>visible</B><A name="GUIenv.1:window.2:windowitem.3:visible.4(193)"></A><A name="visible.4(193)"></A>:
                 (* an invisible windowitem will be ingored w.r.t.
                  * user interaction (it is not visible on the screen)
                  *)
                 (# value: @boolean;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>hilite</B><A name="GUIenv.1:window.2:windowitem.3:hilite.4(194)"></A><A name="hilite.4(194)"></A>:
                 (# value: @boolean;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>show</B><A name="GUIenv.1:window.2:windowitem.3:show.4(195)"></A><A name="show.4(195)"></A>: 
                 (* makes THIS(windowitem) visible *)
                 (# ... #);
               <B>hide</B><A name="GUIenv.1:window.2:windowitem.3:hide.4(196)"></A><A name="hide.4(196)"></A>: 
                 (* makes THIS(windowitem) invisible *)
                 (# ... #);
               <B>enabled</B><A name="GUIenv.1:window.2:windowitem.3:enabled.4(197)"></A><A name="enabled.4(197)"></A>:
                 (* if THIS(windowitem) is enabled it receives mouse
                  * events or key events
                  *)
                 (# value: @boolean
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>enable</B><A name="GUIenv.1:window.2:windowitem.3:enable.4(198)"></A><A name="enable.4(198)"></A>:
                 (* enables THIS(windowitem) so it can receive mouse
                  * or key events
                  *)
                 (# ... #);
               <B>disable</B><A name="GUIenv.1:window.2:windowitem.3:disable.4(199)"></A><A name="disable.4(199)"></A>:
                 (* disables THIS(windowitem) so it does not receive
                  * any mouse or key events
                  *)
                 (# ... #);
               <B>backgroundColor</B><A name="GUIenv.1:window.2:windowitem.3:backgroundColor.4(200)"></A><A name="backgroundColor.4(200)"></A>:
                 (# theColor: @color;
                 enter (# enter theColor ... #)
                 exit (# ... exit theColor #)
                 #);
               <B>border</B><A name="GUIenv.1:window.2:windowitem.3:border.4(201)"></A><A name="border.4(201)"></A>: @
                 (* the border around THIS(windowitem) makes it 
                  * apparent, where it is located on the screen.
                  *)
               (# <B>visible</B><A name="GUIenv.1:window.2:windowitem.3:border.4:visible.5(202)"></A><A name="visible.5(202)"></A>:
                    (* if the border is visible, the insideRect of
                     * THIS(windowitem) is inset depending on the
                     * style of the border.
                     *) 
                    (# value: @boolean;
                    enter (# enter value ... #)
                    exit (# ... exit value #)
                    #);
                  <B>style</B><A name="GUIenv.1:window.2:windowitem.3:border.4:style.5(203)"></A><A name="style.5(203)"></A>:
                    (* the border style can be one of the
                     * following:
                     *   borderStyles.simple: 
                     *      A simple one pixel wide border.
                     *   borderStyles.shadowIn:
                     *      Draws the border so THIS(windowitem)
                     *      appears inset.
                     *   borderStyles.shadowOut:
                     *      Draws the border so THIS(windowitem)
                     *      appears outset.
                     *   borderStyles.etchedIn:
                     *      Draws the border using a double line
                     *      giving the effect of a line etched
                     *      into the window.
                     *   borderStyles.etchedOut:
                     *      Draws the border using a double line
                     *      giving the effect of a line comming
                     *      out of the window.
                     *)
                    (# value: @integer;
                    enter (# enter value ... #)
                    exit (# ... exit value #)
                    #);
               #);
               <B>insideRectangle</B><A name="GUIenv.1:window.2:windowitem.3:insideRectangle.4(204)"></A><A name="insideRectangle.4(204)"></A>:
                 (* insideRectangle is the area inside the border of
                  * THIS(windowitem).
                  *)
                 (# theRectangle: @rectangle;
                 ...
                 exit theRectangle
                 #);
               <B>theCursor</B><A name="GUIenv.1:window.2:windowitem.3:theCursor.4(205)"></A><A name="theCursor.4(205)"></A>:
                 (* theCursor is used to install a cursor for
                  * THIS(windowitem), and to gain access to the cursor
                  * of THIS(windowitem)
                  *)
                 (# theCur: ^cursor;
                 enter (# enter theCur[] ... #)
                 exit (# ... exit theCur[] #)
                 #);
               <B>cursorType</B><A name="GUIenv.1:window.2:windowitem.3:cursorType.4(206)"></A><A name="cursorType.4(206)"></A>:&lt;
                 (* if further bound, an instance of cursorType is
                  * automatically installed for THIS(windowitem)
                  *)
                 cursor;
               <B>trackMouse</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4(207)"></A><A name="trackMouse.4(207)"></A>: 
                 (* this is a control pattern usually evaluated from
                  * a mouseDown eventhandler. Initially 'mousePress'
                  * is evaluated, then 'mouseMove' is evaluated
                  * whenever the mouse moves as long as the mouse is
                  * stillDown - (h, v) will be the horizontal and
                  * vertical distance the mouse has moved since the
                  * last call to 'mouseMove'.  When the user releases
                  * the mouse, 'mouseRelease' is evaluated.  If the
                  * mouse isn't stillDown (see stillDown) when track
                  * is called nothing will happen.  All the
                  * coordinates are local to THIS(WindowItem).
                  *)
                 (# <B>mousePress</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4:mousePress.5(208)"></A><A name="mousePress.5(208)"></A>:&lt; object;
                    <B>mouseMove</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4:mouseMove.5(209)"></A><A name="mouseMove.5(209)"></A>:&lt; 
                      (# h, v: @integer;
                      enter (h, v)
                      do INNER
                      #);
                    <B>mouseRelease</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4:mouseRelease.5(210)"></A><A name="mouseRelease.5(210)"></A>:&lt; object;
                    <B>curPt</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4:curPt.5(211)"></A><A name="curPt.5(211)"></A>,<B> prevPt</B><A name="GUIenv.1:window.2:windowitem.3:trackMouse.4:prevPt.5(212)"></A><A name="prevPt.5(212)"></A>: @point;
                 ...
                 #);
               <B>drag</B><A name="GUIenv.1:window.2:windowitem.3:drag.4(213)"></A><A name="drag.4(213)"></A>: 
                 (* lets the user drag a gray outline of this
                  * windowitem
                  *)
                 (# ... #);
               <B>resize</B><A name="GUIenv.1:window.2:windowitem.3:resize.4(214)"></A><A name="resize.4(214)"></A>: 
                 (* lets the user resize this windowitem by dragging
                  * a gray outline
                  *)
                 (# ... #);
               <B>update</B><A name="GUIenv.1:window.2:windowitem.3:update.4(215)"></A><A name="update.4(215)"></A>: 
                 (* THIS(windowitem) is updated, by posting an
                  * refresh event to the window. If "immediate" is
                  * true the update is performed immediately,
                  * otherwise the update is performed, when there is
                  * no other event waiting (this is normally what you
                  * want)
                  *)
                 (# immediate: @boolean;
                 enter immediate
                 ...
                 #);
               <B>open</B><A name="GUIenv.1:window.2:windowitem.3:open.4(216)"></A><A name="open.4(216)"></A>::&lt; 
                 (* initially a windowitem is visible and active *)
                 (# create::&lt; (# ... #);
                 enter father[]
                 ...
                 #);
               <B>close</B><A name="GUIenv.1:window.2:windowitem.3:close.4(217)"></A><A name="close.4(217)"></A>::&lt; 
                 (* no actions are performed at this level *)
                 (# ... #);
               <B>private</B><A name="GUIenv.1:window.2:windowitem.3:private.4(218)"></A><A name="private.4(218)"></A>: @...;
            #); (* windowitem *)
          <B>separator</B><A name="GUIenv.1:window.2:separator.3(219)"></A><A name="separator.3(219)"></A>: windowitem
            (* a separator is a horzontal or vertical separating line
             *)
            (# &lt;&lt;SLOT separatorLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1:window.2:separator.3:eventhandler.4(220)"></A><A name="eventhandler.4(220)"></A>::&lt;
                 (# <B>styleChanged</B><A name="GUIenv.1:window.2:separator.3:eventhandler.4:styleChanged.5(221)"></A><A name="styleChanged.5(221)"></A>: event
                      (* Called when the style is changed *)
                      (# do INNER #);
                    <B>onStyleChanged</B><A name="GUIenv.1:window.2:separator.3:eventhandler.4:onStyleChanged.5(222)"></A><A name="onStyleChanged.5(222)"></A>:&lt; styleChanged;
                    <B>onRefresh</B><A name="GUIenv.1:window.2:separator.3:eventhandler.4:onRefresh.5(223)"></A><A name="onRefresh.5(223)"></A>::&lt; (# ... #);
                 #);
               <B>vertical</B><A name="GUIenv.1:window.2:separator.3:vertical.4(224)"></A><A name="vertical.4(224)"></A>:&lt; 
                 (* Further bind to specify the orientation of
                  * THIS(separator) default is horizontal
                  *)
                 booleanObject;
               <B>style</B><A name="GUIenv.1:window.2:separator.3:style.4(225)"></A><A name="style.4(225)"></A>:
                 (* the  style can be one of the following:
                  *   lineStyles.singleLine: 
                  *     A single line is drawn.
                  *   lineStyles.doubleLine:
                  *     A double line is drawn.
                  *   lineStyles.dashedSingleLine:
                  *     A dashed single line is drawn.
                  *   lineStyles.dashedDoubleLine:
                  *     A dashed double line is drawn.
                  *   lineStyles.etchedIn:
                  *     A double line is drawn giving the effect of
                  *     a line etched into the window.
                  *   lineStyles.etchedOut:
                  *     A double line is drawn giving the effect of
                  *     a line comming of of the window.
                  *)
                 (# value: @integer;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>open</B><A name="GUIenv.1:window.2:separator.3:open.4(226)"></A><A name="open.4(226)"></A>::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               <B>close</B><A name="GUIenv.1:window.2:separator.3:close.4(227)"></A><A name="close.4(227)"></A>::&lt;(# ... #);
               <B>private</B><A name="GUIenv.1:window.2:separator.3:private.4(228)"></A><A name="private.4(228)"></A>: @...;
            #);
          <B>canvas</B><A name="GUIenv.1:window.2:canvas.3(229)"></A><A name="canvas.3(229)"></A>: windowitem
            (* A canvas is a sub-window in the window.  Only the
             * windowitems located inside the frame of THIS(canvas)
             * will be visible
             *)
            (# &lt;&lt;SLOT canvasLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4(230)"></A><A name="eventhandler.4(230)"></A>::&lt;
                 (# <B>childFrameChanged</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:childFrameChanged.5(231)"></A><A name="childFrameChanged.5(231)"></A>: event
                      (* is called when a child of THIS(canvas) has
                       * changed frame
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame) 
                      do INNER 
                      #);
                    <B>onChildFrameChanged</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onChildFrameChanged.5(232)"></A><A name="onChildFrameChanged.5(232)"></A>:&lt; childFrameChanged;
                    <B>onActivate</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onActivate.5(233)"></A><A name="onActivate.5(233)"></A>::&lt; (# ... #);
                    <B>onDeactivate</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onDeactivate.5(234)"></A><A name="onDeactivate.5(234)"></A>::&lt; (# ... #);
                    <B>onMouseDown</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onMouseDown.5(235)"></A><A name="onMouseDown.5(235)"></A>::&lt; (# ... #);
                    <B>onRefresh</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onRefresh.5(236)"></A><A name="onRefresh.5(236)"></A>::&lt; (# ... #);
                    <B>onMouseUp</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onMouseUp.5(237)"></A><A name="onMouseUp.5(237)"></A>::&lt; (# ... #);
                    <B>onFrameChanged</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onFrameChanged.5(238)"></A><A name="onFrameChanged.5(238)"></A>::&lt; (# ... #);
                    <B>onVisibleChanged</B><A name="GUIenv.1:window.2:canvas.3:eventhandler.4:onVisibleChanged.5(239)"></A><A name="onVisibleChanged.5(239)"></A>::&lt; (# ... #);
                 #);
               <B>selection</B><A name="GUIenv.1:window.2:canvas.3:selection.4(240)"></A><A name="selection.4(240)"></A>: @
                 (# <B>add</B><A name="GUIenv.1:window.2:canvas.3:selection.4:add.5(241)"></A><A name="add.5(241)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>set</B><A name="GUIenv.1:window.2:canvas.3:selection.4:set.5(242)"></A><A name="set.5(242)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>remove</B><A name="GUIenv.1:window.2:canvas.3:selection.4:remove.5(243)"></A><A name="remove.5(243)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>empty</B><A name="GUIenv.1:window.2:canvas.3:selection.4:empty.5(244)"></A><A name="empty.5(244)"></A>: booleanValue
                      (# 
                      ...
                      #);
                    <B>scan</B><A name="GUIenv.1:window.2:canvas.3:selection.4:scan.5(245)"></A><A name="scan.5(245)"></A>:
                      (# current: ^windowitem;
                      ...
                      #);
                    <B>clear</B><A name="GUIenv.1:window.2:canvas.3:selection.4:clear.5(246)"></A><A name="clear.5(246)"></A>:
                      (# 
                      ...
                      #);
                 #);
               <B>scan</B><A name="GUIenv.1:window.2:canvas.3:scan.4(247)"></A><A name="scan.4(247)"></A>:
                 (* Scan operation on the children of THIS(canvas) *)
                 (# current: ^windowitem;
                 ...
                 #);
               <B>open</B><A name="GUIenv.1:window.2:canvas.3:open.4(248)"></A><A name="open.4(248)"></A>::&lt; 
                 (* The canvas is opened and displayed. *)
                 (# create::&lt; (# ... #);
                 ... 
                 #);
               <B>close</B><A name="GUIenv.1:window.2:canvas.3:close.4(249)"></A><A name="close.4(249)"></A>::&lt; 
                 (* close is called for all the children of
                  * THIS(canvas)
                  *)
                 (# ... #);
               <B>private</B><A name="GUIenv.1:window.2:canvas.3:private.4(250)"></A><A name="private.4(250)"></A>: @...;
            #) (* canvas *);
          <B>localToGlobal</B><A name="GUIenv.1:window.2:localToGlobal.3(251)"></A><A name="localToGlobal.3(251)"></A>:
            (* Translate the point from global coordinates to window
             * coordinates.
             *)
            (# <B>local</B><A name="GUIenv.1:window.2:localToGlobal.3:local.4(252)"></A><A name="local.4(252)"></A>,<B> global</B><A name="GUIenv.1:window.2:localToGlobal.3:global.4(253)"></A><A name="global.4(253)"></A>: @point;
            enter local
            ...
            exit global
            #);
          <B>globalToLocal</B><A name="GUIenv.1:window.2:globalToLocal.3(254)"></A><A name="globalToLocal.3(254)"></A>:
            (* Translates the point to window coordinates to global
             * local coordinates
             *)
            (# <B>global</B><A name="GUIenv.1:window.2:globalToLocal.3:global.4(255)"></A><A name="global.4(255)"></A>,<B> local</B><A name="GUIenv.1:window.2:globalToLocal.3:local.4(256)"></A><A name="local.4(256)"></A>: @point;
            enter global
            ...
            exit local
            #);
          <B>open</B><A name="GUIenv.1:window.2:open.3(257)"></A><A name="open.3(257)"></A>::&lt; (# create::&lt; (# ... #);
            ... 
            #);
          <B>close</B><A name="GUIenv.1:window.2:close.3(258)"></A><A name="close.3(258)"></A>::&lt; 
            (* the windows close operation is normally automatically
             * called from the content's aboutToGoAway event.  You can
             * also call it directly. theContents.close is called to
             * close all of the windows internal structures
             *)
            (# ... #);
          &lt;&lt;SLOT BifrostAttributes: attributes&gt;&gt;;
          <B>private</B><A name="GUIenv.1:window.2:private.3(259)"></A><A name="private.3(259)"></A>: @...;
       #) (* window *);
     <B>cursor</B><A name="GUIenv.1:cursor.2(260)"></A><A name="cursor.2(260)"></A>: 
       (* A cursor is the raster attached to the mouse pointer *)
       (# &lt;&lt;SLOT cursorLib: attributes&gt;&gt;;
          <B>private</B><A name="GUIenv.1:cursor.2:private.3(261)"></A><A name="private.3(261)"></A>: @... 
       #);  
     <B>pixmap</B><A name="GUIenv.1:pixmap.2(262)"></A><A name="pixmap.2(262)"></A>:
       (* Pixmap pattern *)
       (# &lt;&lt;SLOT pixmapLib: attributes&gt;&gt;;
          <B>read</B><A name="GUIenv.1:pixmap.2:read.3(263)"></A><A name="read.3(263)"></A>:
            (* Reads the specified file into THIS(pixmap). 
             * The type of the  file are guessed by looking 
             * at the extension, or the the first few bytes,
             * or the macintosh file type - all depending
             * on the platform
             *)
            (# name: ^text;
               error:&lt; exception
                 (# what: ^text;
                 enter what[]
                 do what[] -&gt; msg.append;
                    INNER;
                 #);
            enter name[]
            ...
            #);
          <B>clear</B><A name="GUIenv.1:pixmap.2:clear.3(264)"></A><A name="clear.3(264)"></A>:
             (* Clear the Pixmap with the specified color *)
             (# theColor: @Color;
             enter theColor
             ...
             #);
          <B>init</B><A name="GUIenv.1:pixmap.2:init.3(265)"></A><A name="init.3(265)"></A>:&lt;
            (* Intializes the raster to have the specified width 
             * and height. Allocates any data needed - 
             * you have to call dispose to free that data.
             *)
            (# width, height: @integer;
            enter (width, height)
            ...
            #);
          <B>dispose</B><A name="GUIenv.1:pixmap.2:dispose.3(266)"></A><A name="dispose.3(266)"></A>:&lt;
            (* call this to dispose the memory occupied 
             * by THIS(pixmap) when completely done with 
             * THIS(pixmap)
             *)
            (#
            ...
            #);
          <B>width</B><A name="GUIenv.1:pixmap.2:width.3(267)"></A><A name="width.3(267)"></A>: integerValue
            (* returns the width set by init or by 
             * read operations 
             *)
            (# ... #);
          <B>height</B><A name="GUIenv.1:pixmap.2:height.3(268)"></A><A name="height.3(268)"></A>: integerValue
            (* returns the height set by init or 
             * by read operations 
             *)
            (# ... #);
          <B>transparent</B><A name="GUIenv.1:pixmap.2:transparent.3(269)"></A><A name="transparent.3(269)"></A>:
             (* Specifies that the "background" of this(pixmap) is
              * transparent.
              * This attribute is automatically set to TRUE 
              * If a transparentColor or a mask is specified.
              * If "transparent" is set to FALSE, the transparentColor
              * or mask will be cleared.
              *)
             (# value: @boolean;
             enter (# enter value ... #)
             exit (# ... exit value #)
             #);
          <B>transparentColor</B><A name="GUIenv.1:pixmap.2:transparentColor.3(270)"></A><A name="transparentColor.3(270)"></A>:
            (* Specify which color in the pixmap should be transparent.
             * This will normally be the background color in the pixmap.
             * When a transparentColor is specified the "transparent" 
             * attribute will be set to TRUE.
             * If the "transparent" is set to FALSE, any transparentColor
             * will be cleared.
             *)
            (# theColor: @color;
            enter (# enter theColor ... #)
            exit (# ... exit theColor #)
            #);
          <B>mask</B><A name="GUIenv.1:pixmap.2:mask.3(271)"></A><A name="mask.3(271)"></A>:
            (* Specify a mask for this(pixmap). A mask is a one-depth
             * pixmap. Only the pixels in this(pixmap) that has 
             * corresponding pixel in the mask with the value 1, will
             * be drawn on the screen, when drawing this(pixmap).
             * If a mask is specified the "transparent" attribute will
             * be set to TRUE. If transparent is set to FALSE, any mask
             * will be cleared.
             *)
            (# theMask: ^pixmap;
            enter (# enter theMask[] ... #)
            exit (# ... exit theMask[] #)
            #);
          <B>drawPixmap</B><A name="GUIenv.1:pixmap.2:drawPixmap.3(272)"></A><A name="drawPixmap.3(272)"></A>:
            (* Draw the pixmap "other" on this(pixmap) *)
            (# other: ^pixmap;
               from, to: @point;
               width, height: @integer;
            enter (other[], from, to, width, height)
            ...
            #);
          <B>private</B><A name="GUIenv.1:pixmap.2:private.3(273)"></A><A name="private.3(273)"></A>: @...;
       #);
     <B>textStyle</B><A name="GUIenv.1:textStyle.2(274)"></A><A name="textStyle.2(274)"></A>: 
       (* textStyle is font, size and face. You can use this pattern
        * to communicate stylic changes to layout-text and
        * document-text - or to get information about the dimension of
        * text drawn in a specific textStyle
        *)
       (# &lt;&lt;SLOT textStyleLib: attributes&gt;&gt;;
          <B>name</B><A name="GUIenv.1:textStyle.2:name.3(275)"></A><A name="name.3(275)"></A>:
            (* models the name of the font of THIS(textStyle). *)
            (# theName: ^text;
            enter (# enter theName[] ... #)
            exit (#  ... exit theName[] #)
            #);
          <B>size</B><A name="GUIenv.1:textStyle.2:size.3(276)"></A><A name="size.3(276)"></A>:
            (# value: @integer;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>face</B><A name="GUIenv.1:textStyle.2:face.3(277)"></A><A name="face.3(277)"></A>:
            (# value: @integer;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>ascent</B><A name="GUIenv.1:textStyle.2:ascent.3(278)"></A><A name="ascent.3(278)"></A>: integerValue
            (* ascent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go above the base line
             *)
            (# ... #);
          <B>descent</B><A name="GUIenv.1:textStyle.2:descent.3(279)"></A><A name="descent.3(279)"></A>: integerValue
            (* descent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go below the base line
             *)
            (# ... #);
          <B>leading</B><A name="GUIenv.1:textStyle.2:leading.3(280)"></A><A name="leading.3(280)"></A>: integerValue
            (* leading is the vertical distance between the descent
             * of one line and the ascent of the next line
             *)
            (# ... #);
          <B>lineHeight</B><A name="GUIenv.1:textStyle.2:lineHeight.3(281)"></A><A name="lineHeight.3(281)"></A>: integerValue
            (* the line height (in pixels) is determined by adding
             * the ascent, descent, and leading
             *)
            (# ... #);
          <B>maxChWidth</B><A name="GUIenv.1:textStyle.2:maxChWidth.3(282)"></A><A name="maxChWidth.3(282)"></A>: integerValue
            (* the greatest distance the pen will move when a
             * character is drawn
             *)
            (# ... #);
          <B>widthOfChar</B><A name="GUIenv.1:textStyle.2:widthOfChar.3(283)"></A><A name="widthOfChar.3(283)"></A>: integerValue
            (* in most fonts the width of the characters
             * differs. This method returns the width of the character
             * "ch" when drawn in THIS(textStyle)
             *)
            (# ch: @char
            enter ch
            ...
            #);
          <B>widthOfText</B><A name="GUIenv.1:textStyle.2:widthOfText.3(284)"></A><A name="widthOfText.3(284)"></A>: integerValue
            (* widthOfText returns the width of the given text
             * string, when drawn in THIS(textStyle), which it
             * calculates by adding the charWidths of all the
             * characters in the string
             *)
            (# str: ^text
            enter str[]
            ...
            #);
          <B>availableSizes</B><A name="GUIenv.1:textStyle.2:availableSizes.3(285)"></A><A name="availableSizes.3(285)"></A>: 
            (* an INNER is executed for all available sizes in the
             * font of THIS(textStyle)
             *)
            (# thisSize: @integer;
            ...
            #);
          <B>private</B><A name="GUIenv.1:textStyle.2:private.3(286)"></A><A name="private.3(286)"></A>: @...;
       #) (* textStyle *);
     <B>color</B><A name="GUIenv.1:color.2(287)"></A><A name="color.2(287)"></A>:
       (* A Color has three components: red, green and blue. *)
       (# &lt;&lt;SLOT colorLib: attributes&gt;&gt;;
          <B>red</B><A name="GUIenv.1:color.2:red.3(288)"></A><A name="red.3(288)"></A>,<B>green</B><A name="GUIenv.1:color.2:green.3(289)"></A><A name="green.3(289)"></A>,<B>blue</B><A name="GUIenv.1:color.2:blue.3(290)"></A><A name="blue.3(290)"></A>: @integer;
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     
     <B>timer</B><A name="GUIenv.1:timer.2(291)"></A><A name="timer.2(291)"></A>:
       (# &lt;&lt;SLOT timerLib: attributes&gt;&gt;;
          <B>once</B><A name="GUIenv.1:timer.2:once.3(292)"></A><A name="once.3(292)"></A>:&lt; booleanValue;
          
          <B>start</B><A name="GUIenv.1:timer.2:start.3(293)"></A><A name="start.3(293)"></A>:
            (# interval: @integer
            enter interval
            ...
            #);
          <B>stop</B><A name="GUIenv.1:timer.2:stop.3(294)"></A><A name="stop.3(294)"></A>:
            (# ... #);
          <B>action</B><A name="GUIenv.1:timer.2:action.3(295)"></A><A name="action.3(295)"></A>:&lt;
            object;
          <B>private</B><A name="GUIenv.1:timer.2:private.3(296)"></A><A name="private.3(296)"></A>: @...;
       #);

     <B>clipboard</B><A name="GUIenv.1:clipboard.2(297)"></A><A name="clipboard.2(297)"></A>: @
       (* models the clipboard, which is used to transport pictures
        * and text between applications
        *)
       (# &lt;&lt;SLOT clipBoardLib: attributes&gt;&gt;;
          <B>hasText</B><A name="GUIenv.1:clipboard.2:hasText.3(298)"></A><A name="hasText.3(298)"></A>: booleanValue 
            (* returns true if the contents of the clipBoard is text
             *) 
            (# ... #);
          <B>textContents</B><A name="GUIenv.1:clipboard.2:textContents.3(299)"></A><A name="textContents.3(299)"></A>: 
            (* evaluate the enter-part to set the clipboards
             * text-contents, and evaluate the exit-part to get the
             * clipboards text-contents.  If the clipboard doesn't
             * contain text, NONE is returned.  You can call hasText,
             * before calling getTextContents to determine if there is
             * text to get
             *)
            (# txt: ^text;
            enter (# enter txt[] ... #)
            exit (# ... exit txt[] #)
            #);
          <B>clearContents</B><A name="GUIenv.1:clipboard.2:clearContents.3(300)"></A><A name="clearContents.3(300)"></A>:
            (* call this to empty all contents of the clipboard *)
            (# ... #);
       #) (* clipboard *);
     <B>mouse</B><A name="GUIenv.1:mouse.2(301)"></A><A name="mouse.2(301)"></A>: @
       (* models the mouse *)
       (# &lt;&lt;SLOT mouseLib: attributes&gt;&gt;;
          <B>globalPosition</B><A name="GUIenv.1:mouse.2:globalPosition.3(302)"></A><A name="globalPosition.3(302)"></A>: 
            (* the global position of the mouse is returned. You
             * can't set the position
             *)
            (# pt: @point;
            ...
            exit pt
            #);
          <B>buttonState</B><A name="GUIenv.1:mouse.2:buttonState.3(303)"></A><A name="buttonState.3(303)"></A>: integerValue
            (* the number designating the button, currently pressed
             * down - 0 means 'no button'.  This value depends on the
             * number of buttons on the mouse - Typically 1, 2 or 3.
             *) 
            (# 
            ...
            #);
          <B>busyCursor</B><A name="GUIenv.1:mouse.2:busyCursor.3(304)"></A><A name="busyCursor.3(304)"></A>:
            (* A busy cursor is a sign to the user that the
             * application are doing some processing. You will
             * normally use cursors.watch for this purpose. Set
             * busyCursor to none, when done processing.
             *)
            (# theCur: ^cursor;
            enter (#  enter theCur[] ... #)
            exit (# ... exit theCur[] #)
            #);
       #) (* mouse *);
     
     (* These models different properties of the current system 
      * next 5 patterns was formerly in a systempattern      
      *)
     
     <B>screenRectangle</B><A name="GUIenv.1:screenRectangle.2(305)"></A><A name="screenRectangle.2(305)"></A>: 
       (* the rectangle of the main screen. *)
       (# <B>theRectangle</B><A name="GUIenv.1:screenRectangle.2:theRectangle.3(306)"></A><A name="theRectangle.3(306)"></A>: @rectangle;
       ...
       exit theRectangle
       #);
     <B>screenRgn</B><A name="GUIenv.1:screenRgn.2(307)"></A><A name="screenRgn.2(307)"></A>: 
       (* the region defining the screen(s) *)
       (# <B>rgn</B><A name="GUIenv.1:screenRgn.2:rgn.3(308)"></A><A name="rgn.3(308)"></A>: ^region;
       ...
       exit rgn[]
       #);
     <B>standardTextStyle</B><A name="GUIenv.1:standardTextStyle.2(309)"></A><A name="standardTextStyle.2(309)"></A>: 
       (* the textStyle used by the system to draw menutitles
        * etc.
        *)
       @textStyle;
     <B>beep</B><A name="GUIenv.1:beep.2(310)"></A><A name="beep.2(310)"></A>:
       (* beeps using the current beep in the system *)
       (# ... #);
     <B>guienvWait</B><A name="GUIenv.1:guienvWait.2(311)"></A><A name="guienvWait.2(311)"></A>: 
       (* delays the specified number of ticks (1 tick = 1/60
        * sec.)
        *)
       (# <B>ticks</B><A name="GUIenv.1:guienvWait.2:ticks.3(312)"></A><A name="ticks.3(312)"></A>: @integer;
       enter ticks
       ...
       #);
     <B>transferModes</B><A name="GUIenv.1:transferModes.2(313)"></A><A name="transferModes.2(313)"></A>: @
       (# <B>copy</B><A name="GUIenv.1:transferModes.2:copy.3(314)"></A><A name="copy.3(314)"></A>: (# exit 0 #);
          <B>invertCopy</B><A name="GUIenv.1:transferModes.2:invertCopy.3(315)"></A><A name="invertCopy.3(315)"></A>: (# exit 1 #);
          <B>erase</B><A name="GUIenv.1:transferModes.2:erase.3(316)"></A><A name="erase.3(316)"></A>: (# exit 2 #);
          <B>andBlend</B><A name="GUIenv.1:transferModes.2:andBlend.3(317)"></A><A name="andBlend.3(317)"></A>: (# exit 3 #);
          <B>orBlend</B><A name="GUIenv.1:transferModes.2:orBlend.3(318)"></A><A name="orBlend.3(318)"></A>: (# exit 4 #);
          <B>xorBlend</B><A name="GUIenv.1:transferModes.2:xorBlend.3(319)"></A><A name="xorBlend.3(319)"></A>: (# exit 5 #);
          <B>notAndBlend</B><A name="GUIenv.1:transferModes.2:notAndBlend.3(320)"></A><A name="notAndBlend.3(320)"></A>: (# exit 6 #);
          <B>notOrBlend</B><A name="GUIenv.1:transferModes.2:notOrBlend.3(321)"></A><A name="notOrBlend.3(321)"></A>: (# exit 7 #);
       #);
     <B>textFaces</B><A name="GUIenv.1:textFaces.2(322)"></A><A name="textFaces.2(322)"></A>: @
       (# &lt;&lt;SLOT textFacesLib: attributes&gt;&gt;;
          <B>plain</B><A name="GUIenv.1:textFaces.2:plain.3(323)"></A><A name="plain.3(323)"></A>: (# exit  0 #);
          <B>bold</B><A name="GUIenv.1:textFaces.2:bold.3(324)"></A><A name="bold.3(324)"></A>: (# exit  1 #);
          <B>italic</B><A name="GUIenv.1:textFaces.2:italic.3(325)"></A><A name="italic.3(325)"></A>: (# exit  2 #);
       #);
     <B>patterns</B><A name="GUIenv.1:patterns.2(326)"></A><A name="patterns.2(326)"></A>: @
       (# <B>black</B><A name="GUIenv.1:patterns.2:black.3(327)"></A><A name="black.3(327)"></A>,<B> dkGray</B><A name="GUIenv.1:patterns.2:dkGray.3(328)"></A><A name="dkGray.3(328)"></A>,<B> gray</B><A name="GUIenv.1:patterns.2:gray.3(329)"></A><A name="gray.3(329)"></A>,<B> ltGray</B><A name="GUIenv.1:patterns.2:ltGray.3(330)"></A><A name="ltGray.3(330)"></A>,<B> white</B><A name="GUIenv.1:patterns.2:white.3(331)"></A><A name="white.3(331)"></A>: ^pixmap #);
     <B>cursors</B><A name="GUIenv.1:cursors.2(332)"></A><A name="cursors.2(332)"></A>: @
       (# <B>arrow</B><A name="GUIenv.1:cursors.2:arrow.3(333)"></A><A name="arrow.3(333)"></A>,<B> iBeam</B><A name="GUIenv.1:cursors.2:iBeam.3(334)"></A><A name="iBeam.3(334)"></A>,<B> watch</B><A name="GUIenv.1:cursors.2:watch.3(335)"></A><A name="watch.3(335)"></A>,<B> cross</B><A name="GUIenv.1:cursors.2:cross.3(336)"></A><A name="cross.3(336)"></A>,<B> plus</B><A name="GUIenv.1:cursors.2:plus.3(337)"></A><A name="plus.3(337)"></A>: @cursor #);
     <B>borderStyles</B><A name="GUIenv.1:borderStyles.2(338)"></A><A name="borderStyles.2(338)"></A>: @
       (# <B>simple</B><A name="GUIenv.1:borderStyles.2:simple.3(339)"></A><A name="simple.3(339)"></A>: (# exit 1 #);
          <B>etchedOut</B><A name="GUIenv.1:borderStyles.2:etchedOut.3(340)"></A><A name="etchedOut.3(340)"></A>: (# exit 2 #);
          <B>etchedIn</B><A name="GUIenv.1:borderStyles.2:etchedIn.3(341)"></A><A name="etchedIn.3(341)"></A>: (# exit 3 #);
          <B>shadowIn</B><A name="GUIenv.1:borderStyles.2:shadowIn.3(342)"></A><A name="shadowIn.3(342)"></A>: (# exit 4 #);
          <B>shadowOut</B><A name="GUIenv.1:borderStyles.2:shadowOut.3(343)"></A><A name="shadowOut.3(343)"></A>: (# exit 5 #);
       #);
     <B>separatorStyles</B><A name="GUIenv.1:separatorStyles.2(344)"></A><A name="separatorStyles.2(344)"></A>: @
       (# <B>singleLine</B><A name="GUIenv.1:separatorStyles.2:singleLine.3(345)"></A><A name="singleLine.3(345)"></A>: (# exit 1 #);
          <B>doubleLine</B><A name="GUIenv.1:separatorStyles.2:doubleLine.3(346)"></A><A name="doubleLine.3(346)"></A>: (# exit 2 #);
          <B>singleDashedLine</B><A name="GUIenv.1:separatorStyles.2:singleDashedLine.3(347)"></A><A name="singleDashedLine.3(347)"></A>: (# exit 3 #);
          <B>doubleDashedLine</B><A name="GUIenv.1:separatorStyles.2:doubleDashedLine.3(348)"></A><A name="doubleDashedLine.3(348)"></A>: (# exit 4 #);
          <B>etchedIn</B><A name="GUIenv.1:separatorStyles.2:etchedIn.3(349)"></A><A name="etchedIn.3(349)"></A>: (# exit 5 #);
          <B>etchedOut</B><A name="GUIenv.1:separatorStyles.2:etchedOut.3(350)"></A><A name="etchedOut.3(350)"></A>: (# exit 6 #);
       #);
     <B>windowTypes</B><A name="GUIenv.1:windowTypes.2(351)"></A><A name="windowTypes.2(351)"></A>: @
       (# <B>normal</B><A name="GUIenv.1:windowTypes.2:normal.3(352)"></A><A name="normal.3(352)"></A>: integerValue (# do 0 -&gt; value #);
          <B>dialog</B><A name="GUIenv.1:windowTypes.2:dialog.3(353)"></A><A name="dialog.3(353)"></A>: integerValue (# do 1 -&gt; value #);
          <B>palette</B><A name="GUIenv.1:windowTypes.2:palette.3(354)"></A><A name="palette.3(354)"></A>: integerValue (# do 2 -&gt; value #);
          <B>modelessDialog</B><A name="GUIenv.1:windowTypes.2:modelessDialog.3(355)"></A><A name="modelessDialog.3(355)"></A>: integerValue (# do 3 -&gt; value #);
       #);
     <B>private</B><A name="GUIenv.1:private.2(356)"></A><A name="private.2(356)"></A>: @...;
     <B>trace</B><A name="GUIenv.1:trace.2(357)"></A><A name="trace.2(357)"></A>:
       (* For debugging. If doTrace is true, INNER is called. *)
       (#
       do (if doTrace then INNER if);
       #);
     <B>doTrace</B><A name="GUIenv.1:doTrace.2(358)"></A><A name="doTrace.2(358)"></A>: @Boolean;
     (* Additions needed for bifrost *)
     <B>bifrostprivate</B><A name="GUIenv.1:bifrostprivate.2(359)"></A><A name="bifrostprivate.2(359)"></A>: @...;
     <B>displaywarnings</B><A name="GUIenv.1:displaywarnings.2(360)"></A><A name="displaywarnings.2(360)"></A>: @boolean
       (* If displayWarnings is true, various warnings about bifrost
        * errors that are not fatal, but may affect the behaviour, is
        * displayed. Defaults to true.
        *);
     <B>warnStream</B><A name="GUIenv.1:warnStream.2(361)"></A><A name="warnStream.2(361)"></A>: ^stream
       (* The stream bifrost warnings are put to. Defaults to
        * screen.
        *);
     
     (* Additions needed for systemenv *)
     <B>doSetup</B><A name="GUIenv.1:doSetup.2(362)"></A><A name="doSetup.2(362)"></A>: 
       (# 
       do (if not setupDone then
              ...; 
              true -&gt; setupDone 
          if)
       #);
     <B>setupDone</B><A name="GUIenv.1:setupDone.2(363)"></A><A name="setupDone.2(363)"></A>: @Boolean;
     <B>XsystemEnvPresent</B><A name="GUIenv.1:XsystemEnvPresent.2(364)"></A><A name="XsystemEnvPresent.2(364)"></A>: @Boolean; 
     (* TRUE if this is a XsystemEnv program.  In this case,
      * callbacks are executed by a separate thread as synchronisation
      * via semaphores between x-callbacks and other coroutines would
      * not be possible otherwise. (It could lead to suspend of
      * coroutines with C stackparts.  If TRUE,
      * XsystemEnvHandleCallback should not be NONE.
      *)
     <B>XsystemEnvHandleCallbackP</B><A name="GUIenv.1:XsystemEnvHandleCallbackP.2(365)"></A><A name="XsystemEnvHandleCallbackP.2(365)"></A>: 
       (# <B>cb</B><A name="GUIenv.1:XsystemEnvHandleCallbackP.2:cb.3(366)"></A><A name="cb.3(366)"></A>: ^Object; enter cb[] do INNER #);
     <B>XsystemEnvHandleCallback</B><A name="GUIenv.1:XsystemEnvHandleCallback.2(367)"></A><A name="XsystemEnvHandleCallback.2(367)"></A>: 
       ^XsystemEnvHandleCallbackP;
  ...
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="stddialogs.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
