<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Guienv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="guienv">Guienv Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'guienv' '../lib';
INCLUDE '~beta/containers/list';
INCLUDE 'graphmath';
BODY  'private/guienvbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1991-96
 *       All rights reserved.
 *)
-- lib: attributes --
<B>GUIenv</B><A name="GUIenv.1(384)"></A>: 
  (# &lt;&lt;SLOT guienvLib: attributes&gt;&gt;;
     <B>onStartApplication</B><A name="GUIenv.1.onStartApplication.2(385)"></A><A name="onStartApplication.2(385)"></A>:&lt; 
       (* is called when this application is started with no
        * documents. You can for example further bind this to show a
        * splash screen
        *)
       (# do INNER #);
     <B>onOpenDocument</B><A name="GUIenv.1.onOpenDocument.2(386)"></A><A name="onOpenDocument.2(386)"></A>:&lt;
       (* is called whenever a user opens a document created by this
        * application
        *)
       (# <B>fileName</B><A name="GUIenv.1.onOpenDocument.2.fileName.3(387)"></A><A name="fileName.3(387)"></A>: ^text;
       enter fileName[]
       do INNER
       #);
     <B>onQuit</B><A name="GUIenv.1.onQuit.2(388)"></A><A name="onQuit.2(388)"></A>:&lt;
       (* is called when application is going to quit, either
        * because terminate is called or because the system are
        * are going to shut down.
        * If okToQuit is set to false the application will
        * not quit.
        *)
       (# <B>okToQuit</B><A name="GUIenv.1.onQuit.2.okToQuit.3(389)"></A><A name="okToQuit.3(389)"></A>: @boolean;
       do true -&gt; okToQuit;
          INNER;
       exit okToQuit
       #);
     <B>terminate</B><A name="GUIenv.1.terminate.2(390)"></A><A name="terminate.2(390)"></A>:
       (* will terminate the entire application if invoked 
        * Terminate calls onQuit and will only quit if
        * onQuit returns true.
        *) 
       (# ... #);
     <B>applicationMenubar</B><A name="GUIenv.1.applicationMenubar.2(391)"></A><A name="applicationMenubar.2(391)"></A>:
       (* applicationMenubar is used to install a menubar with
        * functionality that is common for all parts for the
        * application.
        *)
       (# <B>theMenubar</B><A name="GUIenv.1.applicationMenubar.2.theMenubar.3(392)"></A><A name="theMenubar.3(392)"></A>: ^menubarType
       enter (# enter theMenubar[] ... #)
       exit (# ... exit theMenuBar[] #)
       #);
     <B>menubarType</B><A name="GUIenv.1.menubarType.2(393)"></A><A name="menubarType.2(393)"></A>:&lt;
       (* if further bound, an instance of menubarType is
        * automatically installed for the application. Further bind it
        * to standardMenubar if you want the standard menubar (file
        * and edit menu)
        *)
       menubar;
     <B>interfaceObject</B><A name="GUIenv.1.interfaceObject.2(394)"></A><A name="interfaceObject.2(394)"></A>: 
       (* superpattern for all objects used for interaction with the
        * user
        *)
       (# &lt;&lt;SLOT interfaceObjectLib: attributes&gt;&gt;;
          <B>theEventhandler</B><A name="GUIenv.1.interfaceObject.2.theEventhandler.3(395)"></A><A name="theEventhandler.3(395)"></A>: 
            (* The only instance of the eventhandler virtual *)
            @eventhandler;
          <B>eventhandler</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3(396)"></A><A name="eventhandler.3(396)"></A>:&lt;
            (* Encapsulates the patterns related to event handling *)
            (# &lt;&lt;SLOT eventhandlerLib: attributes&gt;&gt;;
               <B>event</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.event.4(397)"></A><A name="event.4(397)"></A>: 
                 (* the abstract superpattern of all events *)
                 (# &lt;&lt;SLOT eventLib: attributes&gt;&gt;;
                 ...
                 #) (* event *);
               <B>basicEvent</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4(398)"></A><A name="basicEvent.4(398)"></A>: event 
                 (* abstract superpattern for all events
                  * originating directly from the OS 
                  *)
                 (# &lt;&lt;SLOT basicEventLib: attributes&gt;&gt;;
                    <B>shiftKey</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.shiftKey.5(399)"></A><A name="shiftKey.5(399)"></A>: booleanValue
                      (* true if the shiftkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>altKey</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.altKey.5(400)"></A><A name="altKey.5(400)"></A>: booleanValue
                      (* true if the altkey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>metaKey</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.metaKey.5(401)"></A><A name="metaKey.5(401)"></A>: booleanValue
                      (* true if the metakey was the down, when
                       * THIS(basicEvent) occurred
                       *) 
                      (# 
                      ...
                      #);
                    <B>controlKey</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.controlKey.5(402)"></A><A name="controlKey.5(402)"></A>: booleanValue
                      (* true if the controlkey was the down, when
                       * THIS(basicEvent) occurred
                       *)
                      (# 
                      ...
                      #);
                    <B>buttonState</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.buttonState.5(403)"></A><A name="buttonState.5(403)"></A>: integerValue
                      (* the number designating the button, which was
                       * pressed down, when THIS(basicEvent) occurred
                       * - 0 means 'no button'.  This value depe nds
                       * on the number of buttons on the mouse -
                       * Typically 1, 2 or 3.
                       *)
                      (# 
                      ...
                      #);
                    <B>when</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.when.5(404)"></A><A name="when.5(404)"></A>: integerValue
                      (* the tick count when THIS(basicEvent)
                       * occurred.  1 tick = 1/60 sec.
                       *)
                      (# 
                      ...
                      #);
                    <B>globalPosition</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.globalPosition.5(405)"></A><A name="globalPosition.5(405)"></A>: 
                      (* global coordinates of the mouse, when
                       * THIS(basicEvent) occurred
                       *)
                      (# p: @point;
                      ...
                      exit p
                      #);
                    <B>localPosition</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.basicEvent.4.localPosition.5(406)"></A><A name="localPosition.5(406)"></A>: 
                      (* local coordinates of the mouse, when
                       * THIS(basicEvent) occurred - relative to
                       * THIS(inteefaceObject)
                       *)
                      (# p: @point;
                      ...
                      exit p
                      #);
                 do INNER;
                 #);
               <B>mouseEvent</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.mouseEvent.4(407)"></A><A name="mouseEvent.4(407)"></A>: basicEvent
                 (* abstract superpattern for events related to the
                  * mouse
                  *)
                 (# &lt;&lt;SLOT mouseEventLib: attributes&gt;&gt;;
                    <B>doubleClick</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.mouseEvent.4.doubleClick.5(408)"></A><A name="doubleClick.5(408)"></A>: booleanValue
                      (* true if THIS(mouseEvent) is a doubleclick.
                       * For a mouse click to qualify as doubleclick
                       * it must happen close in time and space, and
                       * with the same mouse button
                       *)
                      (# 
                      ...
                      #);
                 do INNER;
                 #);
               <B>keyEvent</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.keyEvent.4(409)"></A><A name="keyEvent.4(409)"></A>: basicEvent
                 (* abstract superpattern for events related to the
                  * keyboard.
                  *)
                 (# &lt;&lt;SLOT keyEventLib: attributes&gt;&gt;;
                    <B>ch</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.keyEvent.4.ch.5(410)"></A><A name="ch.5(410)"></A>:
                      (* the key on the keyboard, related to
                       * THIS(keyEvent)
                       *)
                      (# theChar: @char;
                      ...
                      exit theChar
                      #);
                 do INNER
                 #);
               <B>mouseDown</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.mouseDown.4(411)"></A><A name="mouseDown.4(411)"></A>: mouseEvent
                 (* This event occurs when the user presses any mouse
                  * button down on THIS(interfaceObject)
                  *)
                 (# &lt;&lt;SLOT mouseDownLib: attributes&gt;&gt;;
                    <B>delay</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.mouseDown.4.delay.5(412)"></A><A name="delay.5(412)"></A>:
                      (* used to wait for period ticks to pass, while
                       * mouse.isStillDown is true, and then execute
                       * INNER.  If mouseStillDown becomes false
                       * before period ticks, INNER is not executed
                       *)
                      (# period: @integer
                      enter period
                      ...
                      #)
                 do INNER
                 #);
               <B>onMouseDown</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onMouseDown.4(413)"></A><A name="onMouseDown.4(413)"></A>:&lt; mouseDown;
               <B>mouseUp</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.mouseUp.4(414)"></A><A name="mouseUp.4(414)"></A>: mouseEvent 
                 (* This event occurs when the user releases any
                  * mouse button after having pressed it on
                  * THIS(interfaceObject)
                  *)
                 (# do INNER #);
               <B>onMouseUp</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onMouseUp.4(415)"></A><A name="onMouseUp.4(415)"></A>:&lt; mouseUp;
               <B>keyDown</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.keyDown.4(416)"></A><A name="keyDown.4(416)"></A>: keyEvent
                 (* Occurs when the user presses a key, related to
                  * THIS(interfaceObject)
                  *)
                 (# do INNER #);
               <B>onKeyDown</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onKeyDown.4(417)"></A><A name="onKeyDown.4(417)"></A>:&lt; keyDown;
               <B>refresh</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.refresh.4(418)"></A><A name="refresh.4(418)"></A>: basicEvent
                 (* This event tells THIS(interfaceobject), that it
                  * needs to redraw itself. UpdateRect is the 
                  * rectangle that needs to be updated expressed
                  * in the coordinate system of this(interfaceObject).
                  *)
                 (# updateRect:
                      (# value: ^rectangle;
                      ...
                      exit value[]
                      #)
                 do INNER 
                 #);
               <B>onRefresh</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onRefresh.4(419)"></A><A name="onRefresh.4(419)"></A>:&lt; refresh;
               <B>activate</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.activate.4(420)"></A><A name="activate.4(420)"></A>: basicEvent
                 (* Send when THIS(interfaceObject) becomes active *)
                 (# do INNER #);
               <B>onActivate</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onActivate.4(421)"></A><A name="onActivate.4(421)"></A>:&lt; activate;
               <B>deactivate</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.deactivate.4(422)"></A><A name="deactivate.4(422)"></A>: basicEvent
                 (* Send when THIS(interfaceObject) becomes inactive
                  *)
                 (# do INNER #);
               <B>onDeactivate</B><A name="GUIenv.1.interfaceObject.2.eventhandler.3.onDeactivate.4(423)"></A><A name="onDeactivate.4(423)"></A>:&lt; deactivate;
            #);
          <B>action</B><A name="GUIenv.1.interfaceObject.2.action.3(424)"></A><A name="action.3(424)"></A>:
            (* Actions is a means of subscribing to events.  The
             * desired event is specified by further binding
             * eventType.  Actions can be prepended or appended to
             * THIS(interfaceobject).  When some event is called, the
             * prepended actions for the event is called *before* the
             * INNER and the appended actions are called after.
             *)
            (# &lt;&lt;SLOT actionLib: attributes&gt;&gt;;
               eventType:&lt; theEventhandler.event;
               theEvent: ^eventType;
            enter theEvent[]
            do INNER;
            #);
          <B>prependAction</B><A name="GUIenv.1.interfaceObject.2.prependAction.3(425)"></A><A name="prependAction.3(425)"></A>:
            (* Prepends the action, so it will be executed before the
             * event is subscribes to
             *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>appendAction</B><A name="GUIenv.1.interfaceObject.2.appendAction.3(426)"></A><A name="appendAction.3(426)"></A>:
            (* Appends the action, so it will be executed after the
             * event is subscribes to.
             *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>deleteAction</B><A name="GUIenv.1.interfaceObject.2.deleteAction.3(427)"></A><A name="deleteAction.3(427)"></A>:
            (* Remove the action *)
            (# theAction: ^action;
            enter theAction[]
            ...
            #);
          <B>open</B><A name="GUIenv.1.interfaceObject.2.open.3(428)"></A><A name="open.3(428)"></A>:&lt; 
            (* must be called before any other operation on
             * THIS(interfaceObject).
             *)
            (# create:&lt; (# ... #);
            ...
            #);
          <B>close</B><A name="GUIenv.1.interfaceObject.2.close.3(429)"></A><A name="close.3(429)"></A>:&lt; 
            (* closes THIS(interfaceObject) and dispose all related
             *              structures
             *)
            (# ... #);
          <B>enableEventType</B><A name="GUIenv.1.interfaceObject.2.enableEventType.3(430)"></A><A name="enableEventType.3(430)"></A>:&lt;
            (* makes THIS(interfaceObject) sensible to the specified
             * type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            ...
            #);
          <B>disableEventType</B><A name="GUIenv.1.interfaceObject.2.disableEventType.3(431)"></A><A name="disableEventType.3(431)"></A>:&lt;
            (* makes THIS(interfaceObject) insensible to the
             * specified type of events
             *)
            (# ev: ##theEventhandler.event
            enter ev##
            ...
            #);
          <B>interfaceObjectException</B><A name="GUIenv.1.interfaceObject.2.interfaceObjectException.3(432)"></A><A name="interfaceObjectException.3(432)"></A>: exception
            (* abstract superpattern for exceptiosn related to
             * THIS(interfaceObject).
             *)
            (# 
            ... 
            #);
          <B>notOpenedException</B><A name="GUIenv.1.interfaceObject.2.notOpenedException.3(433)"></A><A name="notOpenedException.3(433)"></A>: interfaceObjectException
            (# location: ^text
            enter location[]
            ...
            #);
          <B>notOpenedError</B><A name="GUIenv.1.interfaceObject.2.notOpenedError.3(434)"></A><A name="notOpenedError.3(434)"></A>:&lt; 
            (* this exception is raised if any operation is performed
             * on THIS(interfaceObject) is called before open is
             * called.  This will also happen if "close" is called
             * twice
             *)
            notOpenedException;
          <B>private</B><A name="GUIenv.1.interfaceObject.2.private.3(435)"></A><A name="private.3(435)"></A>: @...;
       do INNER
       #) (* interfaceObject *);
     <B>menubar</B><A name="GUIenv.1.menubar.2(436)"></A><A name="menubar.2(436)"></A>: interfaceObject
       (* menubar is a bar containing the titles of the contained
        * menus. A menu is pulled down by clicking at the title,
        * allowing the user to select a menuitem in the menu.  A
        * menubar is only visible if it is installed - either as the
        * global menubar or as the menubar in some window.
        *)
       (# &lt;&lt;SLOT menubarLib: attributes&gt;&gt;;
          <B>append</B><A name="GUIenv.1.menubar.2.append.3(437)"></A><A name="append.3(437)"></A>: 
            (* inserts a menu after all menues in the menubar.  If
             * the menu is already in the menu bar, nothing happens
             *)
            (# theMenu: ^menu;
            enter theMenu[]
            ...
            #);
          <B>delete</B><A name="GUIenv.1.menubar.2.delete.3(438)"></A><A name="delete.3(438)"></A>: 
            (* deletes a menu from the menu bar. The menu titles
             * following the deleted menu will move over to fill the
             * vacancy
             *)
            (# theMenu: ^menu
            enter theMenu[]
            ...
            #);
          <B>clear</B><A name="GUIenv.1.menubar.2.clear.3(439)"></A><A name="clear.3(439)"></A>: 
            (* removes all menues from the menu bar when you want to
             * start with new menues
             *)
            (# ... #);
          <B>appendMenubar</B><A name="GUIenv.1.menubar.2.appendMenubar.3(440)"></A><A name="appendMenubar.3(440)"></A>: 
            (* inserts all menues in another menubar after all menues
             * in THIS(menubar).  This is the same as calling
             * insertMenubar with NONE as afterMenu.
             *)
            (# theMenubar: ^menubartype;
            enter theMenubar[]
            ...
            #);
          <B>replaceMenubar</B><A name="GUIenv.1.menubar.2.replaceMenubar.3(441)"></A><A name="replaceMenubar.3(441)"></A>: 
            (* replace all menues in theMenubar with all menues in
             * replacementMenubar in THIS(menubar).
             *)
            (# theMenubar, replacementMenubar: ^menubartype
            enter (theMenubar[], replacementMenubar[])
            ...
            #);
          <B>deleteMenubar</B><A name="GUIenv.1.menubar.2.deleteMenubar.3(442)"></A><A name="deleteMenubar.3(442)"></A>: 
            (* deletes all menues in theMenubar from
             * THIS(menubar). The menu titles following the menues in
             * the deleted menubar will move over to fill the vacancy
             *)
            (# theMenubar: ^menubartype
            enter theMenubar[]
            ...
            #);
          <B>scan</B><A name="GUIenv.1.menubar.2.scan.3(443)"></A><A name="scan.3(443)"></A>: 
            (* iterates over all menues currently inserted in the
             * menubar
             *)
            (# current: ^menu;
            ... #);
          <B>open</B><A name="GUIenv.1.menubar.2.open.3(444)"></A><A name="open.3(444)"></A>::&lt;(# create::&lt; (# ... #);
            ...
            #);
          <B>close</B><A name="GUIenv.1.menubar.2.close.3(445)"></A><A name="close.3(445)"></A>::&lt;
            (# 
            ...
            #);
          <B>private</B><A name="GUIenv.1.menubar.2.private.3(446)"></A><A name="private.3(446)"></A>: @...; 
       #) (* menubar *);
     <B>menu</B><A name="GUIenv.1.menu.2(447)"></A><A name="menu.2(447)"></A>: interfaceObject
       (* menu contains a group of menuitems and is usefull for
        * letting the user perform commands or set settings in the
        * application. A menu can be installed in a menubar, as a
        * submenu to some menuitem or simply be popped up on the
        * screen.
        *)
       (# &lt;&lt;SLOT menuLib: attributes&gt;&gt;;
          <B>name</B><A name="GUIenv.1.menu.2.name.3(448)"></A><A name="name.3(448)"></A>:
            (* the name of the menu as shown in the menubar.  if the
             * menu is not in a menubar, the name is not visible
             *)
            (# <B>theName</B><A name="GUIenv.1.menu.2.name.3.theName.4(449)"></A><A name="theName.4(449)"></A>: ^text
            enter (# enter theName[] ... #)
            exit (# ... exit theName[] #)
            #);
          <B>eventhandler</B><A name="GUIenv.1.menu.2.eventhandler.3(450)"></A><A name="eventhandler.3(450)"></A>::&lt;
            (# <B>select</B><A name="GUIenv.1.menu.2.eventhandler.3.select.4(451)"></A><A name="select.4(451)"></A>: event
                 (* executed when the user selects THIS(menu) (or
                  * pops it up) just before the menu is shown.
                  *)
                 (# do INNER #);
               <B>onSelect</B><A name="GUIenv.1.menu.2.eventhandler.3.onSelect.4(452)"></A><A name="onSelect.4(452)"></A>:&lt; select;
            #);
          <B>menuitem</B><A name="GUIenv.1.menu.2.menuitem.3(453)"></A><A name="menuitem.3(453)"></A>: interfaceObject
            (* menuitem is used for letting the user perform commands
             * in the application or display the state of some option,
             * by checking and unchecking the menuitem. It can also
             * serve as the title of a submenu.
             *)
            (# &lt;&lt;SLOT menuitemLib: attributes&gt;&gt;;
               <B>key</B><A name="GUIenv.1.menu.2.menuitem.3.key.4(454)"></A><A name="key.4(454)"></A>: 
                 (* the key shortcut of THIS(menuitem), allows the
                  * user to select THIS(menuitem) without using the
                  * mouse.
                  *)
                 (# c: @char
                 enter (# enter c ... #)
                 exit (# ... exit c #)
                 #);
               <B>name</B><A name="GUIenv.1.menu.2.menuitem.3.name.4(455)"></A><A name="name.4(455)"></A>: 
                 (* models the name of THIS(menuitem).  Evaluate the
                  * enter-part to set the name.  Evaluate the
                  * exit-part to get the name
                  *)
                 (# t: ^text;
                 enter (# enter t[] ... #)
                 exit (# ... exit t[] #)
                 #);
               <B>checked</B><A name="GUIenv.1.menu.2.menuitem.3.checked.4(456)"></A><A name="checked.4(456)"></A>:
                 (* when THIS(menuitem) is checked, a check mark is
                  * displayed at the left side the menuitem
                  *)
                 (# checked: @boolean
                 enter (# enter checked ... #)
                 exit (# ... exit checked #)
                 #);
               <B>subMenu</B><A name="GUIenv.1.menu.2.menuitem.3.subMenu.4(457)"></A><A name="subMenu.4(457)"></A>:
                 (* if a submenu is attached to THIS(menuitem), that
                  * menu is pulled down by selecting
                  * THIS(menuitem). In that case onSelect is never
                  * issued for THIS(menuitem)
                  *)
                 (# theMenu: ^menu;
                 enter (# enter theMenu[] ... #)
                 exit (# ... exit theMenu[] #)
                 #);
               <B>position</B><A name="GUIenv.1.menu.2.menuitem.3.position.4(458)"></A><A name="position.4(458)"></A>: IntegerValue
                 (* the position of THIS(menuitem) in its menu,
                  * separator items are counted as well
                  *)
                 (# 
                 ...
                 #);
               <B>eventhandler</B><A name="GUIenv.1.menu.2.menuitem.3.eventhandler.4(459)"></A><A name="eventhandler.4(459)"></A>::&lt;
                 (# <B>onStatus</B><A name="GUIenv.1.menu.2.menuitem.3.eventhandler.4.onStatus.5(460)"></A><A name="onStatus.5(460)"></A>:&lt; booleanValue
                      (* executed just before THIS(menuitem) is
                       * shown.  should return true if THIS(menuitem)
                       * is enabled.  Default is true
                       *)
                      (# ... #);
                    <B>select</B><A name="GUIenv.1.menu.2.menuitem.3.eventhandler.4.select.5(461)"></A><A name="select.5(461)"></A>: event
                      (* executed when THIS(menuitem) is selected in
                       * the menu.  If a submenu is attached, it will
                       * not be executed - instead the submenu is
                       * pulled down
                       *)
                      (# do INNER #);
                    <B>onSelect</B><A name="GUIenv.1.menu.2.menuitem.3.eventhandler.4.onSelect.5(462)"></A><A name="onSelect.5(462)"></A>:&lt; select;
                 #);
               <B>open</B><A name="GUIenv.1.menu.2.menuitem.3.open.4(463)"></A><A name="open.4(463)"></A>::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               <B>private</B><A name="GUIenv.1.menu.2.menuitem.3.private.4(464)"></A><A name="private.4(464)"></A>: @...;
            do INNER
            #) (* menuitem *);
          <B>dynamicMenuitem</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3(465)"></A><A name="dynamicMenuitem.3(465)"></A>: menuitem
            (* dynamic menuitem does not call its own onStatus and
             * onSelect events, instead these events are called on the
             * attached action, if any is attached
             *)
            (# &lt;&lt;SLOT dynamicItemLib: attributes&gt;&gt;;
               <B>theAction</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.theAction.4(466)"></A><A name="theAction.4(466)"></A>: ^menuAction;
               <B>attach</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.attach.4(467)"></A><A name="attach.4(467)"></A>: 
                 (* anAction is attached to THIS(menuitem) *)
                 (# anAction: ^menuAction;
                 enter anAction[]
                 ...
                 #);
               <B>detach</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.detach.4(468)"></A><A name="detach.4(468)"></A>:
                 (* the menuitemHandler that is currently attached to
                  * THIS(menuitem) is detached, meaning that no action
                  * is attached
                  *)
                 (# ... #);
               <B>eventhandler</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.eventhandler.4(469)"></A><A name="eventhandler.4(469)"></A>::&lt;(# <B>onStatus</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.eventhandler.4.onStatus.5(470)"></A><A name="onStatus.5(470)"></A>::&lt; (# ... #);
                    <B>onSelect</B><A name="GUIenv.1.menu.2.dynamicMenuitem.3.eventhandler.4.onSelect.5(471)"></A><A name="onSelect.5(471)"></A>::&lt; (# ... #);
                 #);
            #) (* dynamicMenuitem *);
          <B>menuAction</B><A name="GUIenv.1.menu.2.menuAction.3(472)"></A><A name="menuAction.3(472)"></A>:
            (* a menuAction can dynamicly be attached to
             * dynamicMenuitems within THIS(menu), meaning that the
             * onStatus and onSelect events of THIS(menuAction) will
             * be executed instead of these events of the
             * dynamicMenuitem. The pointer "theMenuitem" refers to
             * the dynamicMenuitem THIS(menuAction) is currently
             * attached to
             *)
            (# <B>theMenuitem</B><A name="GUIenv.1.menu.2.menuAction.3.theMenuitem.4(473)"></A><A name="theMenuitem.4(473)"></A>:
                 (* the menuitem THIS(menuAction) is attached to *)
                 ^dynamicMenuitem;
               <B>onStatus</B><A name="GUIenv.1.menu.2.menuAction.3.onStatus.4(474)"></A><A name="onStatus.4(474)"></A>:&lt; booleanValue
                 (* this status is evaluated instead of the status of
                  * the actual menuitem (theMenuitem) THIS(menuAction)
                  * is attached to.  Default returns true
                  *)
                 (# ... #);
               <B>onSelect</B><A name="GUIenv.1.menu.2.menuAction.3.onSelect.4(475)"></A><A name="onSelect.4(475)"></A>:&lt; 
                 (* onSelect is executed from the hit of the actual
                  * dynamicMenuitem THIS(action) is attached to
                  *)
                 object;
            #) (* action *);
          <B>separator</B><A name="GUIenv.1.menu.2.separator.3(476)"></A><A name="separator.3(476)"></A>: menuitem
            (* defines a menu separator, which is a unselectable line
             * in the menu, dividing groups of menuitems.
             *)
            (# open::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               close::&lt; (# ... #);
            #);
          <B>append</B><A name="GUIenv.1.menu.2.append.3(477)"></A><A name="append.3(477)"></A>:
            (* appends the menuitem to THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            ...
            #);
          <B>delete</B><A name="GUIenv.1.menu.2.delete.3(478)"></A><A name="delete.3(478)"></A>: 
            (* deletes the menuitem from THIS(menu) *)
            (# theMenuitem: ^menuitem
            enter theMenuitem[]
            ...
            #);
          <B>scan</B><A name="GUIenv.1.menu.2.scan.3(479)"></A><A name="scan.3(479)"></A>: 
            (* iterates over all menuitems in THIS(menu) *)
            (# current: ^menuitem
              ...
            #);
          <B>clear</B><A name="GUIenv.1.menu.2.clear.3(480)"></A><A name="clear.3(480)"></A>:
            (* deletes all menuitems in  THIS(menu) *)
            (#
            ...
            #);
          <B>noOfMenuitems</B><A name="GUIenv.1.menu.2.noOfMenuitems.3(481)"></A><A name="noOfMenuitems.3(481)"></A>: integerValue
            (* returns the number of menuitems in THIS(menu) *)
            (# ... #);
          <B>popUp</B><A name="GUIenv.1.menu.2.popUp.3(482)"></A><A name="popUp.3(482)"></A>: 
            (* THIS(menu) is popped up as follows: The menuitem
             * indexed by "popupWith" is selected (not checked but
             * hilited) and popupAt is the top left corner of that
             * menuitem in the coordinate system of the popupIn
             * window.
             *)
            (# popupWith: @integer;
               popupAt: @point;
               popupIn: ^window.windowitem;
            enter (popupWith,popupAt,popupIn[])
            ...
            #);
          <B>getMenuitemByNumber</B><A name="GUIenv.1.menu.2.getMenuitemByNumber.3(483)"></A><A name="getMenuitemByNumber.3(483)"></A>: 
            (* returns a reference to the menuitem at the specified
             * position in the menu
             *)
            (# number: @integer;
               theMenuitem: ^menuitem;
            enter number
            ...
            exit theMenuitem[]
            #);
          <B>enable</B><A name="GUIenv.1.menu.2.enable.3(484)"></A><A name="enable.3(484)"></A>: (* enable THIS(menu) *)
            (# ... #);
          <B>disable</B><A name="GUIenv.1.menu.2.disable.3(485)"></A><A name="disable.3(485)"></A>: (* disable THIS(menu) *)
            (# ... #);
          <B>enabled</B><A name="GUIenv.1.menu.2.enabled.3(486)"></A><A name="enabled.3(486)"></A>:&lt; booleanValue
            (* should return true if THIS(menu) is enabled *)
            (# ... #);
          <B>open</B><A name="GUIenv.1.menu.2.open.3(487)"></A><A name="open.3(487)"></A>::&lt; 
            (* the menu is not automatically inserted in the
             * menubar. You have to do this yourself
             *)
            (# create::&lt; (# ... #);
            ... 
            #);
          <B>close</B><A name="GUIenv.1.menu.2.close.3(488)"></A><A name="close.3(488)"></A>::&lt; (# ... #);
          <B>private</B><A name="GUIenv.1.menu.2.private.3(489)"></A><A name="private.3(489)"></A>: @...;
       #) (* menu *);
     <B>standardMenubar</B><A name="GUIenv.1.standardMenubar.2(490)"></A><A name="standardMenubar.2(490)"></A>: menubar
       (# <B>standardFileMenu</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3(491)"></A><A name="standardFileMenu.3(491)"></A>: menu
            (# <B>newMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.newMenuitem.4(492)"></A><A name="newMenuitem.4(492)"></A>: @dynamicMenuitem;
               <B>openMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.openMenuitem.4(493)"></A><A name="openMenuitem.4(493)"></A>: @dynamicMenuitem;
               <B>closeMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.closeMenuitem.4(494)"></A><A name="closeMenuitem.4(494)"></A>: @dynamicMenuitem;
               <B>saveMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.saveMenuitem.4(495)"></A><A name="saveMenuitem.4(495)"></A>: @dynamicMenuitem;
               <B>saveAsMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.saveAsMenuitem.4(496)"></A><A name="saveAsMenuitem.4(496)"></A>: @dynamicMenuitem;
               <B>revertMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.revertMenuitem.4(497)"></A><A name="revertMenuitem.4(497)"></A>: @dynamicMenuitem;
               <B>printMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.printMenuitem.4(498)"></A><A name="printMenuitem.4(498)"></A>: @dynamicMenuitem;
               <B>pageSetUpMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.pageSetUpMenuitem.4(499)"></A><A name="pageSetUpMenuitem.4(499)"></A>: @dynamicMenuitem;
               <B>quitMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.quitMenuitem.4(500)"></A><A name="quitMenuitem.4(500)"></A>: @dynamicMenuitem;
               <B>open</B><A name="GUIenv.1.standardMenubar.2.standardFileMenu.3.open.4(501)"></A><A name="open.4(501)"></A>::&lt; (# ... #);    
            #) (* standardFileMenu *);
          <B>fileMenu</B><A name="GUIenv.1.standardMenubar.2.fileMenu.3(502)"></A><A name="fileMenu.3(502)"></A>:&lt; menu;
          <B>theFileMenu</B><A name="GUIenv.1.standardMenubar.2.theFileMenu.3(503)"></A><A name="theFileMenu.3(503)"></A>: ^fileMenu;
          <B>standardEditMenu</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3(504)"></A><A name="standardEditMenu.3(504)"></A>: menu
            (# <B>undoMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.undoMenuitem.4(505)"></A><A name="undoMenuitem.4(505)"></A>: @dynamicMenuitem;
               <B>cutMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.cutMenuitem.4(506)"></A><A name="cutMenuitem.4(506)"></A>: @dynamicMenuitem;
               <B>copyMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.copyMenuitem.4(507)"></A><A name="copyMenuitem.4(507)"></A>: @dynamicMenuitem;
               <B>pasteMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.pasteMenuitem.4(508)"></A><A name="pasteMenuitem.4(508)"></A>: @dynamicMenuitem;
               <B>clearMenuitem</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.clearMenuitem.4(509)"></A><A name="clearMenuitem.4(509)"></A>: @dynamicMenuitem;
               <B>open</B><A name="GUIenv.1.standardMenubar.2.standardEditMenu.3.open.4(510)"></A><A name="open.4(510)"></A>::&lt; (# ... #);
            #) (* standardEditMenu *);
          <B>editMenu</B><A name="GUIenv.1.standardMenubar.2.editMenu.3(511)"></A><A name="editMenu.3(511)"></A>:&lt; menu;
          <B>theEditMenu</B><A name="GUIenv.1.standardMenubar.2.theEditMenu.3(512)"></A><A name="theEditMenu.3(512)"></A>: ^editMenu;
          <B>open</B><A name="GUIenv.1.standardMenubar.2.open.3(513)"></A><A name="open.3(513)"></A>::&lt;
            (# 
            ...
            #);
       #);
     <B>window</B><A name="GUIenv.1.window.2(514)"></A><A name="window.2(514)"></A>: interfaceObject
       (* user interaction with the window such as dragging and
        * resizing is taken care of by the window manager.  Anything
        * visible you may want to place in the window is subpatterns
        * of the abstract pattern windowitem, which is a subpattern of
        * interfaceObject. The window can be used as a modal dialog by
        * means of the pattern "showModal"
        *)
       (# &lt;&lt;SLOT windowLib: attributes&gt;&gt;;
          <B>eventhandler</B><A name="GUIenv.1.window.2.eventhandler.3(515)"></A><A name="eventhandler.3(515)"></A>::&lt;
            (# <B>aboutToClose</B><A name="GUIenv.1.window.2.eventhandler.3.aboutToClose.4(516)"></A><A name="aboutToClose.4(516)"></A>: event
                 (* is called whenever the user has performed an
                  * action that causes THIS(window) to close.  Further
                  * bind this to perform actions before the window is
                  * actually closed.  You can prevent the window from
                  * closing by assigning false to the boolean
                  * 'okToClose'
                  *)
                 (# okToClose: @boolean
                 do true -&gt; okToClose;
                    INNER
                 exit okToClose
                 #);
               <B>onAboutToClose</B><A name="GUIenv.1.window.2.eventhandler.3.onAboutToClose.4(517)"></A><A name="onAboutToClose.4(517)"></A>:&lt;  aboutToClose;
               <B>onActivate</B><A name="GUIenv.1.window.2.eventhandler.3.onActivate.4(518)"></A><A name="onActivate.4(518)"></A>::&lt;
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# ... #);
               <B>onDeactivate</B><A name="GUIenv.1.window.2.eventhandler.3.onDeactivate.4(519)"></A><A name="onDeactivate.4(519)"></A>::&lt;
                 (* is send to contents, which takes care of sending
                  * the event to all children
                  *)
                 (# ... #);
            #);
          <B>theMenubar</B><A name="GUIenv.1.window.2.theMenubar.3(520)"></A><A name="theMenubar.3(520)"></A>:
            (* is used to install a menubar for THIS(window), and to
             * gain access to the menubar of THIS(window)
             *)
            (# theBar: ^menubartype
            enter (# enter theBar[] ... #)
            exit (# ... exit theBar[] #)
            #);
          <B>menubarType</B><A name="GUIenv.1.window.2.menubarType.3(521)"></A><A name="menubarType.3(521)"></A>:&lt;
            (* if further bound, an instance of menubarType is
             * automatically installed for THIS(window)
             *)
            menubar;
          <B>menubarVisible</B><A name="GUIenv.1.window.2.menubarVisible.3(522)"></A><A name="menubarVisible.3(522)"></A>:&lt; 
            (* Specifies if the menubar should be visible. *)
            trueObject;
          <B>type</B><A name="GUIenv.1.window.2.type.3(523)"></A><A name="type.3(523)"></A>:&lt;
            (* The type can be one of the following:
             *   windowTypes.normal  &lt;- default
             *   windowTypes.dialog
             *   windowTypes.palette
             *)
            integerValue;
          <B>resizeable</B><A name="GUIenv.1.window.2.resizeable.3(524)"></A><A name="resizeable.3(524)"></A>:&lt; booleanValue
            (# 
            do (if type=windowTypes.normal then
                   true -&gt; value; INNER 
               if);
            #);
          <B>title</B><A name="GUIenv.1.window.2.title.3(525)"></A><A name="title.3(525)"></A>: 
            (* the title of the window is displayed in the windows
             * title-bar if the window has one.
             *)
            (# theTitle: ^text
            enter (# enter theTitle[] ... #)
            exit (# ... exit theTitle[] #)
            #);
          <B>position</B><A name="GUIenv.1.window.2.position.3(526)"></A><A name="position.3(526)"></A>: 
            (* the window's position is the coordinates of the
             * topLeft corner of the window's inside rectangle on the
             * screen
             *)
            (# pt: @point;
            enter (# enter pt ... #)
            exit (# ... exit pt #)
            #);
          <B>size</B><A name="GUIenv.1.window.2.size.3(527)"></A><A name="size.3(527)"></A>: 
            (* the size is the size of the inside rectangle of the
             * window
             *)
            (# width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>frame</B><A name="GUIenv.1.window.2.frame.3(528)"></A><A name="frame.3(528)"></A>:
            (* the frame is defined as the rectangle THIS(window)
             * occupies on the screen = (position,position + size)
             *)
            (# theFrame: @rectangle;
            enter (# enter theFrame ... #)
            exit (# ... exit theFrame #)
            #);
          <B>insideRectangle</B><A name="GUIenv.1.window.2.insideRectangle.3(529)"></A><A name="insideRectangle.3(529)"></A>: 
            (* the inside rectangle is the window's content rectangle
             * in terms of local coordinates in the window.  The top
             * left corner is (0, 0) and the bottom right corner is
             * the window's size
             *)
            (# theRectangle: @rectangle;
            ...
            exit theRectangle
            #);
          <B>show</B><A name="GUIenv.1.window.2.show.3(530)"></A><A name="show.3(530)"></A>: 
            (* shows THIS(window) in front of other windows *)
            (# ... #);
          <B>showModal</B><A name="GUIenv.1.window.2.showModal.3(531)"></A><A name="showModal.3(531)"></A>:
            (* shows THIS(window) in a modal way. Interaction with
             * other windows is prevented until THIS(window) is either
             * closed or hidden, and then showModal returns to the
             * caller
             *)
            (# ... #);
          <B>hide</B><A name="GUIenv.1.window.2.hide.3(532)"></A><A name="hide.3(532)"></A>: 
            (* hides THIS(window), i.e. make it invisible without
             * destroying it. Can be made visible again using show
             *)
            (# ... #);
          <B>visible</B><A name="GUIenv.1.window.2.visible.3(533)"></A><A name="visible.3(533)"></A>:
            (* The visibility of the window. *)
            (# value: @boolean;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>maxSize</B><A name="GUIenv.1.window.2.maxSize.3(534)"></A><A name="maxSize.3(534)"></A>: 
            (* use this to set the maximum size THIS(window) is
             * allowed to get, when resized by the user. maxSize
             * doesn't affect the behaviour of setSize.
             *)
            (# width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>minSize</B><A name="GUIenv.1.window.2.minSize.3(535)"></A><A name="minSize.3(535)"></A>: 
            (* use this to set the minimum size THIS(window) is
             * allowed to get, when resized by the user. minSize
             * doesn't affect the behaviour of setSize
             *)
            (#  width, height: @integer;
            enter (# enter (width, height) ... #)
            exit (# ... exit (width, height) #)
            #);
          <B>bringToFront</B><A name="GUIenv.1.window.2.bringToFront.3(536)"></A><A name="bringToFront.3(536)"></A>: 
            (* THIS(window) is brought to the front of all other
             * windows
             *)
            (# ... #);
          <B>bringBack</B><A name="GUIenv.1.window.2.bringBack.3(537)"></A><A name="bringBack.3(537)"></A>: 
            (* THIS(window) is placed behind all other windows *)
            (# ... #);
          <B>bringBehind</B><A name="GUIenv.1.window.2.bringBehind.3(538)"></A><A name="bringBehind.3(538)"></A>: 
            (* THIS(window) is placed behind the window referred to
             * by "theWindow"
             *)
            (# theWindow: ^window;
            enter theWindow[]
            ...
            #);
          <B>update</B><A name="GUIenv.1.window.2.update.3(539)"></A><A name="update.3(539)"></A>: 
            (* Updates the window by posting a refresh event.  If
             * emmediate is true, the refresh event will be processed
             * immediately.
             *)
            (# immediate: @boolean;
            enter immediate
            ...
            #);
          <B>backgroundColor</B><A name="GUIenv.1.window.2.backgroundColor.3(540)"></A><A name="backgroundColor.3(540)"></A>:
            (* Sets backgroundcolor of this window *)
            (# theColor: @color
            enter theColor
            ...
            #);
          <B>contents</B><A name="GUIenv.1.window.2.contents.3(541)"></A><A name="contents.3(541)"></A>:
            (* The contents of THIS(window) is the father of all
             * other windowitems in THIS(window).
             *)
            (# theContents: ^canvas;
            ...
            exit theContents[]
            #);
          <B>target</B><A name="GUIenv.1.window.2.target.3(542)"></A><A name="target.3(542)"></A>: 
            (* the window's target is a reference to the windowitem
             * that receives keyDown. You are responsible for making
             * sure the window's target is the windowitem that is
             * affected by menu commands. The eventhandler of
             * windowitem has two events: "enableTarget" and
             * "disableTarget". When a windowitem is becomming the new
             * target, first "disableTarget" is called for the old
             * target then "enableTarget" is called for the new target
             *)
            (# theTarget: ^windowitem;
            enter (# enter theTarget[] ... #)
            exit (# ... exit theTarget[] #)
            #);
          <B>windowitem</B><A name="GUIenv.1.window.2.windowitem.3(543)"></A><A name="windowitem.3(543)"></A>: interfaceObject
            (* superclass for all interfaceobjects in this window.  A
             * windowitem is always part of a canvas (father)
             *)
            (# &lt;&lt;SLOT windowitemLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4(544)"></A><A name="eventhandler.4(544)"></A>::&lt;
                 (# <B>visibleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.visibleChanged.5(545)"></A><A name="visibleChanged.5(545)"></A>: event
                      (* is called, when THIS(windowitem) is hidden
                       * or shown
                       *)
                      (# do INNER #);
                    <B>onVisibleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onVisibleChanged.5(546)"></A><A name="onVisibleChanged.5(546)"></A>:&lt; visibleChanged;
                    <B>frameChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.frameChanged.5(547)"></A><A name="frameChanged.5(547)"></A>: event
                      (* is called whenever the frame of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do INNER 
                      #);
                    <B>onFrameChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onFrameChanged.5(548)"></A><A name="onFrameChanged.5(548)"></A>:&lt; frameChanged;
                    <B>fatherFrameChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.fatherFrameChanged.5(549)"></A><A name="fatherFrameChanged.5(549)"></A>: event
                      (* is called when the frame of the father of
                       * THIS(windowitem) is changed
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame)
                      do INNER 
                      #);
                    <B>onFatherFrameChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onFatherFrameChanged.5(550)"></A><A name="onFatherFrameChanged.5(550)"></A>:&lt; fatherFrameChanged;
                    <B>enabledChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.enabledChanged.5(551)"></A><A name="enabledChanged.5(551)"></A>: event
                      (* is called, when THIS(windowitem) is
                       * enabled/disabled
                       *)
                      (# do INNER #);
                    <B>onEnabledChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onEnabledChanged.5(552)"></A><A name="onEnabledChanged.5(552)"></A>:&lt; enabledChanged;
                    <B>enableTarget</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.enableTarget.5(553)"></A><A name="enableTarget.5(553)"></A>: event
                      (* is called when THIS(windowitem) is becomming
                       * target in the window
                       *)
                      (# do INNER #);
                    <B>onEnableTarget</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onEnableTarget.5(554)"></A><A name="onEnableTarget.5(554)"></A>:&lt; enableTarget;
                    <B>disableTarget</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.disableTarget.5(555)"></A><A name="disableTarget.5(555)"></A>: event
                      (* is called when THIS(windowitem) was target
                       * and another windowitem is becomming target
                       *)
                      (# do INNER #);
                    <B>onDisableTarget</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onDisableTarget.5(556)"></A><A name="onDisableTarget.5(556)"></A>:&lt; disableTarget;
                    <B>borderVisibleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.borderVisibleChanged.5(557)"></A><A name="borderVisibleChanged.5(557)"></A>: event
                      (* is called, when the border of 
                       * THIS(windowitem) is shown or hidden
                       *)
                      (# do INNER #);
                    <B>onBorderVisibleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onBorderVisibleChanged.5(558)"></A><A name="onBorderVisibleChanged.5(558)"></A>:&lt; borderVisibleChanged;
                    <B>borderStyleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.borderStyleChanged.5(559)"></A><A name="borderStyleChanged.5(559)"></A>: event
                      (* is called, when the border style of
                       * THIS(windowitem) is changed
                       *)
                      (# do INNER #);
                    <B>onBorderStyleChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onBorderStyleChanged.5(560)"></A><A name="onBorderStyleChanged.5(560)"></A>:&lt; borderStyleChanged;
                    <B>theCursorChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.theCursorChanged.5(561)"></A><A name="theCursorChanged.5(561)"></A>: event
                      (* is called, when THIS(windowitem) is assigned
                       * a new cursor
                       *)
                      (# do INNER #);
                    <B>onTheCursorChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onTheCursorChanged.5(562)"></A><A name="onTheCursorChanged.5(562)"></A>:&lt; theCursorChanged;
                    <B>hiliteChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.hiliteChanged.5(563)"></A><A name="hiliteChanged.5(563)"></A>: event
                      (* Is called when THIS(windowitem) is hilited
                       * or dehilited
                       *)
                      (# do INNER; #);
                    <B>onHiliteChanged</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onHiliteChanged.5(564)"></A><A name="onHiliteChanged.5(564)"></A>:&lt; hiliteChanged;
                    <B>onRefresh</B><A name="GUIenv.1.window.2.windowitem.3.eventhandler.4.onRefresh.5(565)"></A><A name="onRefresh.5(565)"></A>::&lt; (# ... #);
                 #);
               <B>father</B><A name="GUIenv.1.window.2.windowitem.3.father.4(566)"></A><A name="father.4(566)"></A>: ^
                 (* father is the canvas that THIS(windowitem) is a
                  * child of
                  *)
                 canvas;
               <B>frame</B><A name="GUIenv.1.window.2.windowitem.3.frame.4(567)"></A><A name="frame.4(567)"></A>: 
                 (* the frame is defined as the rectangle
                  * THIS(windowitem) occupies in the coordinate system
                  * of the father. When the frame is changed
                  * THIS(windowitem) is updated and the father is
                  * informed about the change.  If you need other
                  * actions to take place, when changing the frame,
                  * you must further bind the event onFrameChanged
                  *)
                 (# theFrame: @rectangle;
                 enter (# enter theFrame ... #)
                 exit (# ... exit theFrame #)
                 #);
               <B>position</B><A name="GUIenv.1.window.2.windowitem.3.position.4(568)"></A><A name="position.4(568)"></A>: 
                 (* the position of THIS(windowitem) is defined as
                  * the topLeft corner of the bounding frame. When the
                  * position is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# pt: @point;
                 enter (# enter pt ... #)
                 exit (# ... exit pt #)
                 #);
               <B>move</B><A name="GUIenv.1.window.2.windowitem.3.move.4(569)"></A><A name="move.4(569)"></A>: 
                 (* moves THIS(windowitem) relative (dh, dv), by
                  * setting the position, meaning that the
                  * onFrameChanged event is called
                  *)
                 (# dh, dv: @integer;
                 enter (dh, dv)
                 ...
                 #);
               <B>size</B><A name="GUIenv.1.window.2.windowitem.3.size.4(570)"></A><A name="size.4(570)"></A>: 
                 (* the size of THIS(windowitem) is defined as the
                  * height and width of the bounding frame. When the
                  * size is changed, the frame is changed, so the
                  * onFrameChanged event is called
                  *)
                 (# width, height: @integer;
                 enter (# enter (width, height) ... #)
                 exit (# ... exit (width, height) #)
                 #);
               <B>fitToContents</B><A name="GUIenv.1.window.2.windowitem.3.fitToContents.4(571)"></A><A name="fitToContents.4(571)"></A>:&lt;
                 (* Adjusts the size of THIS(windowItem) to 
                  * fit the contents
                  *)
                 (# doneInInner: @boolean;
                 ...
                 #);
               <B>bindLeft</B><A name="GUIenv.1.window.2.windowitem.3.bindLeft.4(572)"></A><A name="bindLeft.4(572)"></A>,<B> bindRight</B><A name="GUIenv.1.window.2.windowitem.3.bindRight.4(573)"></A><A name="bindRight.4(573)"></A>,<B> bindBottom</B><A name="GUIenv.1.window.2.windowitem.3.bindBottom.4(574)"></A><A name="bindBottom.4(574)"></A>,<B> bindTop</B><A name="GUIenv.1.window.2.windowitem.3.bindTop.4(575)"></A><A name="bindTop.4(575)"></A>: @
                 (* these attributes specify how THIS(windowitem)
                  * shall behave when the father changes it's
                  * frame. If e.g. "bindLeft" is true, the leftSide
                  * will have the same constant distance to the
                  * leftSide of the father, when the father is resized
                  *)
                 boolean;
               <B>visible</B><A name="GUIenv.1.window.2.windowitem.3.visible.4(576)"></A><A name="visible.4(576)"></A>:
                 (* an invisible windowitem will be ingored w.r.t.
                  * user interaction (it is not visible on the screen)
                  *)
                 (# value: @boolean;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>hilite</B><A name="GUIenv.1.window.2.windowitem.3.hilite.4(577)"></A><A name="hilite.4(577)"></A>:
                 (# value: @boolean;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>show</B><A name="GUIenv.1.window.2.windowitem.3.show.4(578)"></A><A name="show.4(578)"></A>: 
                 (* makes THIS(windowitem) visible *)
                 (# ... #);
               <B>hide</B><A name="GUIenv.1.window.2.windowitem.3.hide.4(579)"></A><A name="hide.4(579)"></A>: 
                 (* makes THIS(windowitem) invisible *)
                 (# ... #);
               <B>enabled</B><A name="GUIenv.1.window.2.windowitem.3.enabled.4(580)"></A><A name="enabled.4(580)"></A>:
                 (* if THIS(windowitem) is enabled it receives mouse
                  * events or key events
                  *)
                 (# value: @boolean
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>enable</B><A name="GUIenv.1.window.2.windowitem.3.enable.4(581)"></A><A name="enable.4(581)"></A>:
                 (* enables THIS(windowitem) so it can receive mouse
                  * or key events
                  *)
                 (# ... #);
               <B>disable</B><A name="GUIenv.1.window.2.windowitem.3.disable.4(582)"></A><A name="disable.4(582)"></A>:
                 (* disables THIS(windowitem) so it does not receive
                  * any mouse or key events
                  *)
                 (# ... #);
               <B>backgroundColor</B><A name="GUIenv.1.window.2.windowitem.3.backgroundColor.4(583)"></A><A name="backgroundColor.4(583)"></A>:
                 (# theColor: @color;
                 enter (# enter theColor ... #)
                 exit (# ... exit theColor #)
                 #);
               <B>border</B><A name="GUIenv.1.window.2.windowitem.3.border.4(584)"></A><A name="border.4(584)"></A>: @
                 (* the border around THIS(windowitem) makes it 
                  * apparent, where it is located on the screen.
                  *)
               (# <B>visible</B><A name="GUIenv.1.window.2.windowitem.3.border.4.visible.5(585)"></A><A name="visible.5(585)"></A>:
                    (* if the border is visible, the insideRect of
                     * THIS(windowitem) is inset depending on the
                     * style of the border.
                     *) 
                    (# value: @boolean;
                    enter (# enter value ... #)
                    exit (# ... exit value #)
                    #);
                  <B>style</B><A name="GUIenv.1.window.2.windowitem.3.border.4.style.5(586)"></A><A name="style.5(586)"></A>:
                    (* the border style can be one of the
                     * following:
                     *   borderStyles.simple: 
                     *      A simple one pixel wide border.
                     *   borderStyles.shadowIn:
                     *      Draws the border so THIS(windowitem)
                     *      appears inset.
                     *   borderStyles.shadowOut:
                     *      Draws the border so THIS(windowitem)
                     *      appears outset.
                     *   borderStyles.etchedIn:
                     *      Draws the border using a double line
                     *      giving the effect of a line etched
                     *      into the window.
                     *   borderStyles.etchedOut:
                     *      Draws the border using a double line
                     *      giving the effect of a line comming
                     *      out of the window.
                     *)
                    (# value: @integer;
                    enter (# enter value ... #)
                    exit (# ... exit value #)
                    #);
               #);
               <B>insideRectangle</B><A name="GUIenv.1.window.2.windowitem.3.insideRectangle.4(587)"></A><A name="insideRectangle.4(587)"></A>:
                 (* insideRectangle is the area inside the border of
                  * THIS(windowitem).
                  *)
                 (# theRectangle: @rectangle;
                 ...
                 exit theRectangle
                 #);
               <B>theCursor</B><A name="GUIenv.1.window.2.windowitem.3.theCursor.4(588)"></A><A name="theCursor.4(588)"></A>:
                 (* theCursor is used to install a cursor for
                  * THIS(windowitem), and to gain access to the cursor
                  * of THIS(windowitem)
                  *)
                 (# theCur: ^cursor;
                 enter (# enter theCur[] ... #)
                 exit (# ... exit theCur[] #)
                 #);
               <B>cursorType</B><A name="GUIenv.1.window.2.windowitem.3.cursorType.4(589)"></A><A name="cursorType.4(589)"></A>:&lt;
                 (* if further bound, an instance of cursorType is
                  * automatically installed for THIS(windowitem)
                  *)
                 cursor;
               <B>trackMouse</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4(590)"></A><A name="trackMouse.4(590)"></A>: 
                 (* this is a control pattern usually evaluated from
                  * a mouseDown eventhandler. Initially 'mousePress'
                  * is evaluated, then 'mouseMove' is evaluated
                  * whenever the mouse moves as long as the mouse is
                  * stillDown - (h, v) will be the horizontal and
                  * vertical distance the mouse has moved since the
                  * last call to 'mouseMove'.  When the user releases
                  * the mouse, 'mouseRelease' is evaluated.  If the
                  * mouse isn't stillDown (see stillDown) when track
                  * is called nothing will happen.  All the
                  * coordinates are local to THIS(WindowItem).
                  *)
                 (# <B>mousePress</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4.mousePress.5(591)"></A><A name="mousePress.5(591)"></A>:&lt; object;
                    <B>mouseMove</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4.mouseMove.5(592)"></A><A name="mouseMove.5(592)"></A>:&lt; 
                      (# h, v: @integer;
                      enter (h, v)
                      do INNER
                      #);
                    <B>mouseRelease</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4.mouseRelease.5(593)"></A><A name="mouseRelease.5(593)"></A>:&lt; object;
                    <B>curPt</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4.curPt.5(594)"></A><A name="curPt.5(594)"></A>,<B> prevPt</B><A name="GUIenv.1.window.2.windowitem.3.trackMouse.4.prevPt.5(595)"></A><A name="prevPt.5(595)"></A>: @point;
                 ...
                 #);
               <B>drag</B><A name="GUIenv.1.window.2.windowitem.3.drag.4(596)"></A><A name="drag.4(596)"></A>: 
                 (* lets the user drag a gray outline of this
                  * windowitem
                  *)
                 (# ... #);
               <B>resize</B><A name="GUIenv.1.window.2.windowitem.3.resize.4(597)"></A><A name="resize.4(597)"></A>: 
                 (* lets the user resize this windowitem by dragging
                  * a gray outline
                  *)
                 (# ... #);
               <B>update</B><A name="GUIenv.1.window.2.windowitem.3.update.4(598)"></A><A name="update.4(598)"></A>: 
                 (* THIS(windowitem) is updated, by posting an
                  * refresh event to the window. If "immediate" is
                  * true the update is performed immediately,
                  * otherwise the update is performed, when there is
                  * no other event waiting (this is normally what you
                  * want)
                  *)
                 (# immediate: @boolean;
                 enter immediate
                 ...
                 #);
               <B>open</B><A name="GUIenv.1.window.2.windowitem.3.open.4(599)"></A><A name="open.4(599)"></A>::&lt; 
                 (* initially a windowitem is visible and active *)
                 (# create::&lt; (# ... #);
                 enter father[]
                 ...
                 #);
               <B>close</B><A name="GUIenv.1.window.2.windowitem.3.close.4(600)"></A><A name="close.4(600)"></A>::&lt; 
                 (* no actions are performed at this level *)
                 (# ... #);
               <B>private</B><A name="GUIenv.1.window.2.windowitem.3.private.4(601)"></A><A name="private.4(601)"></A>: @...;
            #); (* windowitem *)
          <B>separator</B><A name="GUIenv.1.window.2.separator.3(602)"></A><A name="separator.3(602)"></A>: windowitem
            (* a separator is a horzontal or vertical separating line
             *)
            (# &lt;&lt;SLOT separatorLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1.window.2.separator.3.eventhandler.4(603)"></A><A name="eventhandler.4(603)"></A>::&lt;
                 (# <B>styleChanged</B><A name="GUIenv.1.window.2.separator.3.eventhandler.4.styleChanged.5(604)"></A><A name="styleChanged.5(604)"></A>: event
                      (* Called when the style is changed *)
                      (# do INNER #);
                    <B>onStyleChanged</B><A name="GUIenv.1.window.2.separator.3.eventhandler.4.onStyleChanged.5(605)"></A><A name="onStyleChanged.5(605)"></A>:&lt; styleChanged;
                    <B>onRefresh</B><A name="GUIenv.1.window.2.separator.3.eventhandler.4.onRefresh.5(606)"></A><A name="onRefresh.5(606)"></A>::&lt; (# ... #);
                 #);
               <B>vertical</B><A name="GUIenv.1.window.2.separator.3.vertical.4(607)"></A><A name="vertical.4(607)"></A>:&lt; 
                 (* Further bind to specify the orientation of
                  * THIS(separator) default is horizontal
                  *)
                 booleanObject;
               <B>style</B><A name="GUIenv.1.window.2.separator.3.style.4(608)"></A><A name="style.4(608)"></A>:
                 (* the  style can be one of the following:
                  *   lineStyles.singleLine: 
                  *     A single line is drawn.
                  *   lineStyles.doubleLine:
                  *     A double line is drawn.
                  *   lineStyles.dashedSingleLine:
                  *     A dashed single line is drawn.
                  *   lineStyles.dashedDoubleLine:
                  *     A dashed double line is drawn.
                  *   lineStyles.etchedIn:
                  *     A double line is drawn giving the effect of
                  *     a line etched into the window.
                  *   lineStyles.etchedOut:
                  *     A double line is drawn giving the effect of
                  *     a line comming of of the window.
                  *)
                 (# value: @integer;
                 enter (# enter value ... #)
                 exit (# ... exit value #)
                 #);
               <B>open</B><A name="GUIenv.1.window.2.separator.3.open.4(609)"></A><A name="open.4(609)"></A>::&lt;(# create::&lt; (# ... #);
                 ...
                 #);
               <B>close</B><A name="GUIenv.1.window.2.separator.3.close.4(610)"></A><A name="close.4(610)"></A>::&lt;(# ... #);
               <B>private</B><A name="GUIenv.1.window.2.separator.3.private.4(611)"></A><A name="private.4(611)"></A>: @...;
            #);
          <B>canvas</B><A name="GUIenv.1.window.2.canvas.3(612)"></A><A name="canvas.3(612)"></A>: windowitem
            (* A canvas is a sub-window in the window.  Only the
             * windowitems located inside the frame of THIS(canvas)
             * will be visible
             *)
            (# &lt;&lt;SLOT canvasLib: attributes&gt;&gt;;
               <B>eventhandler</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4(613)"></A><A name="eventhandler.4(613)"></A>::&lt;
                 (# <B>childFrameChanged</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.childFrameChanged.5(614)"></A><A name="childFrameChanged.5(614)"></A>: event
                      (* is called when a child of THIS(canvas) has
                       * changed frame
                       *)
                      (# oldFrame, newFrame: @rectangle;
                      enter (oldFrame, newFrame) 
                      do INNER 
                      #);
                    <B>onChildFrameChanged</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onChildFrameChanged.5(615)"></A><A name="onChildFrameChanged.5(615)"></A>:&lt; childFrameChanged;
                    <B>onActivate</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onActivate.5(616)"></A><A name="onActivate.5(616)"></A>::&lt; (# ... #);
                    <B>onDeactivate</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onDeactivate.5(617)"></A><A name="onDeactivate.5(617)"></A>::&lt; (# ... #);
                    <B>onMouseDown</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onMouseDown.5(618)"></A><A name="onMouseDown.5(618)"></A>::&lt; (# ... #);
                    <B>onRefresh</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onRefresh.5(619)"></A><A name="onRefresh.5(619)"></A>::&lt; (# ... #);
                    <B>onMouseUp</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onMouseUp.5(620)"></A><A name="onMouseUp.5(620)"></A>::&lt; (# ... #);
                    <B>onFrameChanged</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onFrameChanged.5(621)"></A><A name="onFrameChanged.5(621)"></A>::&lt; (# ... #);
                    <B>onVisibleChanged</B><A name="GUIenv.1.window.2.canvas.3.eventhandler.4.onVisibleChanged.5(622)"></A><A name="onVisibleChanged.5(622)"></A>::&lt; (# ... #);
                 #);
               <B>selection</B><A name="GUIenv.1.window.2.canvas.3.selection.4(623)"></A><A name="selection.4(623)"></A>: @
                 (# <B>add</B><A name="GUIenv.1.window.2.canvas.3.selection.4.add.5(624)"></A><A name="add.5(624)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>set</B><A name="GUIenv.1.window.2.canvas.3.selection.4.set.5(625)"></A><A name="set.5(625)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>remove</B><A name="GUIenv.1.window.2.canvas.3.selection.4.remove.5(626)"></A><A name="remove.5(626)"></A>:
                      (# theWindowitem: ^windowitem;
                      enter theWindowitem[]
                      ...
                      #);
                    <B>empty</B><A name="GUIenv.1.window.2.canvas.3.selection.4.empty.5(627)"></A><A name="empty.5(627)"></A>: booleanValue
                      (# 
                      ...
                      #);
                    <B>scan</B><A name="GUIenv.1.window.2.canvas.3.selection.4.scan.5(628)"></A><A name="scan.5(628)"></A>:
                      (# current: ^windowitem;
                      ...
                      #);
                    <B>clear</B><A name="GUIenv.1.window.2.canvas.3.selection.4.clear.5(629)"></A><A name="clear.5(629)"></A>:
                      (# 
                      ...
                      #);
                 #);
               <B>scan</B><A name="GUIenv.1.window.2.canvas.3.scan.4(630)"></A><A name="scan.4(630)"></A>:
                 (* Scan operation on the children of THIS(canvas) *)
                 (# current: ^windowitem;
                 ...
                 #);
               <B>open</B><A name="GUIenv.1.window.2.canvas.3.open.4(631)"></A><A name="open.4(631)"></A>::&lt; 
                 (* The canvas is opened and displayed. *)
                 (# create::&lt; (# ... #);
                 ... 
                 #);
               <B>close</B><A name="GUIenv.1.window.2.canvas.3.close.4(632)"></A><A name="close.4(632)"></A>::&lt; 
                 (* close is called for all the children of
                  * THIS(canvas)
                  *)
                 (# ... #);
               <B>private</B><A name="GUIenv.1.window.2.canvas.3.private.4(633)"></A><A name="private.4(633)"></A>: @...;
            #) (* canvas *);
          <B>localToGlobal</B><A name="GUIenv.1.window.2.localToGlobal.3(634)"></A><A name="localToGlobal.3(634)"></A>:
            (* Translate the point from global coordinates to window
             * coordinates.
             *)
            (# <B>local</B><A name="GUIenv.1.window.2.localToGlobal.3.local.4(635)"></A><A name="local.4(635)"></A>,<B> global</B><A name="GUIenv.1.window.2.localToGlobal.3.global.4(636)"></A><A name="global.4(636)"></A>: @point;
            enter local
            ...
            exit global
            #);
          <B>globalToLocal</B><A name="GUIenv.1.window.2.globalToLocal.3(637)"></A><A name="globalToLocal.3(637)"></A>:
            (* Translates the point to window coordinates to global
             * local coordinates
             *)
            (# <B>global</B><A name="GUIenv.1.window.2.globalToLocal.3.global.4(638)"></A><A name="global.4(638)"></A>,<B> local</B><A name="GUIenv.1.window.2.globalToLocal.3.local.4(639)"></A><A name="local.4(639)"></A>: @point;
            enter global
            ...
            exit local
            #);
          <B>open</B><A name="GUIenv.1.window.2.open.3(640)"></A><A name="open.3(640)"></A>::&lt; (# create::&lt; (# ... #);
            ... 
            #);
          <B>close</B><A name="GUIenv.1.window.2.close.3(641)"></A><A name="close.3(641)"></A>::&lt; 
            (* the windows close operation is normally automatically
             * called from the content's aboutToGoAway event.  You can
             * also call it directly. theContents.close is called to
             * close all of the windows internal structures
             *)
            (# ... #);
          &lt;&lt;SLOT BifrostAttributes: attributes&gt;&gt;;
          <B>private</B><A name="GUIenv.1.window.2.private.3(642)"></A><A name="private.3(642)"></A>: @...;
       #) (* window *);
     <B>cursor</B><A name="GUIenv.1.cursor.2(643)"></A><A name="cursor.2(643)"></A>: 
       (* A cursor is the raster attached to the mouse pointer *)
       (# &lt;&lt;SLOT cursorLib: attributes&gt;&gt;;
          <B>private</B><A name="GUIenv.1.cursor.2.private.3(644)"></A><A name="private.3(644)"></A>: @... 
       #);  
     <B>pixmap</B><A name="GUIenv.1.pixmap.2(645)"></A><A name="pixmap.2(645)"></A>:
       (* Pixmap pattern *)
       (# &lt;&lt;SLOT pixmapLib: attributes&gt;&gt;;
          <B>read</B><A name="GUIenv.1.pixmap.2.read.3(646)"></A><A name="read.3(646)"></A>:
            (* Reads the specified file into THIS(pixmap). 
             * The type of the  file are guessed by looking 
             * at the extension, or the the first few bytes,
             * or the macintosh file type - all depending
             * on the platform
             *)
            (# name: ^text;
               error:&lt; exception
                 (# what: ^text;
                 enter what[]
                 do what[] -&gt; msg.append;
                    INNER;
                 #);
            enter name[]
            ...
            #);
          <B>clear</B><A name="GUIenv.1.pixmap.2.clear.3(647)"></A><A name="clear.3(647)"></A>:
             (* Clear the Pixmap with the specified color *)
             (# theColor: @Color;
             enter theColor
             ...
             #);
          <B>init</B><A name="GUIenv.1.pixmap.2.init.3(648)"></A><A name="init.3(648)"></A>:&lt;
            (* Intializes the raster to have the specified width 
             * and height. Allocates any data needed - 
             * you have to call dispose to free that data.
             *)
            (# width, height: @integer;
            enter (width, height)
            ...
            #);
          <B>dispose</B><A name="GUIenv.1.pixmap.2.dispose.3(649)"></A><A name="dispose.3(649)"></A>:&lt;
            (* call this to dispose the memory occupied 
             * by THIS(pixmap) when completely done with 
             * THIS(pixmap)
             *)
            (#
            ...
            #);
          <B>width</B><A name="GUIenv.1.pixmap.2.width.3(650)"></A><A name="width.3(650)"></A>: integerValue
            (* returns the width set by init or by 
             * read operations 
             *)
            (# ... #);
          <B>height</B><A name="GUIenv.1.pixmap.2.height.3(651)"></A><A name="height.3(651)"></A>: integerValue
            (* returns the height set by init or 
             * by read operations 
             *)
            (# ... #);
          <B>transparent</B><A name="GUIenv.1.pixmap.2.transparent.3(652)"></A><A name="transparent.3(652)"></A>:
             (* Specifies that the "background" of this(pixmap) is
              * transparent.
              * This attribute is automatically set to TRUE 
              * If a transparentColor or a mask is specified.
              * If "transparent" is set to FALSE, the transparentColor
              * or mask will be cleared.
              *)
             (# value: @boolean;
             enter (# enter value ... #)
             exit (# ... exit value #)
             #);
          <B>transparentColor</B><A name="GUIenv.1.pixmap.2.transparentColor.3(653)"></A><A name="transparentColor.3(653)"></A>:
            (* Specify which color in the pixmap should be transparent.
             * This will normally be the background color in the pixmap.
             * When a transparentColor is specified the "transparent" 
             * attribute will be set to TRUE.
             * If the "transparent" is set to FALSE, any transparentColor
             * will be cleared.
             *)
            (# theColor: @color;
            enter (# enter theColor ... #)
            exit (# ... exit theColor #)
            #);
          <B>mask</B><A name="GUIenv.1.pixmap.2.mask.3(654)"></A><A name="mask.3(654)"></A>:
            (* Specify a mask for this(pixmap). A mask is a one-depth
             * pixmap. Only the pixels in this(pixmap) that has 
             * corresponding pixel in the mask with the value 1, will
             * be drawn on the screen, when drawing this(pixmap).
             * If a mask is specified the "transparent" attribute will
             * be set to TRUE. If transparent is set to FALSE, any mask
             * will be cleared.
             *)
            (# theMask: ^pixmap;
            enter (# enter theMask[] ... #)
            exit (# ... exit theMask[] #)
            #);
          <B>drawPixmap</B><A name="GUIenv.1.pixmap.2.drawPixmap.3(655)"></A><A name="drawPixmap.3(655)"></A>:
            (* Draw the pixmap "other" on this(pixmap) *)
            (# other: ^pixmap;
               from, to: @point;
               width, height: @integer;
            enter (other[], from, to, width, height)
            ...
            #);
          <B>private</B><A name="GUIenv.1.pixmap.2.private.3(656)"></A><A name="private.3(656)"></A>: @...;
       #);
     <B>textStyle</B><A name="GUIenv.1.textStyle.2(657)"></A><A name="textStyle.2(657)"></A>: 
       (* textStyle is font, size and face. You can use this pattern
        * to communicate stylic changes to layout-text and
        * document-text - or to get information about the dimension of
        * text drawn in a specific textStyle
        *)
       (# &lt;&lt;SLOT textStyleLib: attributes&gt;&gt;;
          <B>name</B><A name="GUIenv.1.textStyle.2.name.3(658)"></A><A name="name.3(658)"></A>:
            (* models the name of the font of THIS(textStyle). *)
            (# theName: ^text;
            enter (# enter theName[] ... #)
            exit (#  ... exit theName[] #)
            #);
          <B>size</B><A name="GUIenv.1.textStyle.2.size.3(659)"></A><A name="size.3(659)"></A>:
            (# value: @integer;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>face</B><A name="GUIenv.1.textStyle.2.face.3(660)"></A><A name="face.3(660)"></A>:
            (# value: @integer;
            enter (# enter value ... #)
            exit (# ... exit value #)
            #);
          <B>ascent</B><A name="GUIenv.1.textStyle.2.ascent.3(661)"></A><A name="ascent.3(661)"></A>: integerValue
            (* ascent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go above the base line
             *)
            (# ... #);
          <B>descent</B><A name="GUIenv.1.textStyle.2.descent.3(662)"></A><A name="descent.3(662)"></A>: integerValue
            (* descent is the maximum amount of pixels a character
             * drawn in THIS(textStyle) will go below the base line
             *)
            (# ... #);
          <B>leading</B><A name="GUIenv.1.textStyle.2.leading.3(663)"></A><A name="leading.3(663)"></A>: integerValue
            (* leading is the vertical distance between the descent
             * of one line and the ascent of the next line
             *)
            (# ... #);
          <B>lineHeight</B><A name="GUIenv.1.textStyle.2.lineHeight.3(664)"></A><A name="lineHeight.3(664)"></A>: integerValue
            (* the line height (in pixels) is determined by adding
             * the ascent, descent, and leading
             *)
            (# ... #);
          <B>maxChWidth</B><A name="GUIenv.1.textStyle.2.maxChWidth.3(665)"></A><A name="maxChWidth.3(665)"></A>: integerValue
            (* the greatest distance the pen will move when a
             * character is drawn
             *)
            (# ... #);
          <B>widthOfChar</B><A name="GUIenv.1.textStyle.2.widthOfChar.3(666)"></A><A name="widthOfChar.3(666)"></A>: integerValue
            (* in most fonts the width of the characters
             * differs. This method returns the width of the character
             * "ch" when drawn in THIS(textStyle)
             *)
            (# ch: @char
            enter ch
            ...
            #);
          <B>widthOfText</B><A name="GUIenv.1.textStyle.2.widthOfText.3(667)"></A><A name="widthOfText.3(667)"></A>: integerValue
            (* widthOfText returns the width of the given text
             * string, when drawn in THIS(textStyle), which it
             * calculates by adding the charWidths of all the
             * characters in the string
             *)
            (# str: ^text
            enter str[]
            ...
            #);
          <B>availableSizes</B><A name="GUIenv.1.textStyle.2.availableSizes.3(668)"></A><A name="availableSizes.3(668)"></A>: 
            (* an INNER is executed for all available sizes in the
             * font of THIS(textStyle)
             *)
            (# thisSize: @integer;
            ...
            #);
          <B>private</B><A name="GUIenv.1.textStyle.2.private.3(669)"></A><A name="private.3(669)"></A>: @...;
       #) (* textStyle *);
     <B>color</B><A name="GUIenv.1.color.2(670)"></A><A name="color.2(670)"></A>:
       (* A Color has three components: red, green and blue. *)
       (# &lt;&lt;SLOT colorLib: attributes&gt;&gt;;
          <B>red</B><A name="GUIenv.1.color.2.red.3(671)"></A><A name="red.3(671)"></A>,<B>green</B><A name="GUIenv.1.color.2.green.3(672)"></A><A name="green.3(672)"></A>,<B>blue</B><A name="GUIenv.1.color.2.blue.3(673)"></A><A name="blue.3(673)"></A>: @integer;
       enter (red,green,blue)
       exit (red,green,blue)
       #);
     
     <B>timer</B><A name="GUIenv.1.timer.2(674)"></A><A name="timer.2(674)"></A>:
       (# &lt;&lt;SLOT timerLib: attributes&gt;&gt;;
          <B>once</B><A name="GUIenv.1.timer.2.once.3(675)"></A><A name="once.3(675)"></A>:&lt; booleanValue;
          
          <B>start</B><A name="GUIenv.1.timer.2.start.3(676)"></A><A name="start.3(676)"></A>:
            (# interval: @integer
            enter interval
            ...
            #);
          <B>stop</B><A name="GUIenv.1.timer.2.stop.3(677)"></A><A name="stop.3(677)"></A>:
            (# ... #);
          <B>action</B><A name="GUIenv.1.timer.2.action.3(678)"></A><A name="action.3(678)"></A>:&lt;
            object;
          <B>private</B><A name="GUIenv.1.timer.2.private.3(679)"></A><A name="private.3(679)"></A>: @...;
       #);

     <B>clipboard</B><A name="GUIenv.1.clipboard.2(680)"></A><A name="clipboard.2(680)"></A>: @
       (* models the clipboard, which is used to transport pictures
        * and text between applications
        *)
       (# &lt;&lt;SLOT clipBoardLib: attributes&gt;&gt;;
          <B>hasText</B><A name="GUIenv.1.clipboard.2.hasText.3(681)"></A><A name="hasText.3(681)"></A>: booleanValue 
            (* returns true if the contents of the clipBoard is text
             *) 
            (# ... #);
          <B>textContents</B><A name="GUIenv.1.clipboard.2.textContents.3(682)"></A><A name="textContents.3(682)"></A>: 
            (* evaluate the enter-part to set the clipboards
             * text-contents, and evaluate the exit-part to get the
             * clipboards text-contents.  If the clipboard doesn't
             * contain text, NONE is returned.  You can call hasText,
             * before calling getTextContents to determine if there is
             * text to get
             *)
            (# txt: ^text;
            enter (# enter txt[] ... #)
            exit (# ... exit txt[] #)
            #);
          <B>clearContents</B><A name="GUIenv.1.clipboard.2.clearContents.3(683)"></A><A name="clearContents.3(683)"></A>:
            (* call this to empty all contents of the clipboard *)
            (# ... #);
       #) (* clipboard *);
     <B>mouse</B><A name="GUIenv.1.mouse.2(684)"></A><A name="mouse.2(684)"></A>: @
       (* models the mouse *)
       (# &lt;&lt;SLOT mouseLib: attributes&gt;&gt;;
          <B>globalPosition</B><A name="GUIenv.1.mouse.2.globalPosition.3(685)"></A><A name="globalPosition.3(685)"></A>: 
            (* the global position of the mouse is returned. You
             * can't set the position
             *)
            (# pt: @point;
            ...
            exit pt
            #);
          <B>buttonState</B><A name="GUIenv.1.mouse.2.buttonState.3(686)"></A><A name="buttonState.3(686)"></A>: integerValue
            (* the number designating the button, currently pressed
             * down - 0 means 'no button'.  This value depends on the
             * number of buttons on the mouse - Typically 1, 2 or 3.
             *) 
            (# 
            ...
            #);
          <B>busyCursor</B><A name="GUIenv.1.mouse.2.busyCursor.3(687)"></A><A name="busyCursor.3(687)"></A>:
            (* A busy cursor is a sign to the user that the
             * application are doing some processing. You will
             * normally use cursors.watch for this purpose. Set
             * busyCursor to none, when done processing.
             *)
            (# theCur: ^cursor;
            enter (#  enter theCur[] ... #)
            exit (# ... exit theCur[] #)
            #);
       #) (* mouse *);
     
     (* These models different properties of the current system 
      * next 5 patterns was formerly in a systempattern      
      *)
     
     <B>screenRectangle</B><A name="GUIenv.1.screenRectangle.2(688)"></A><A name="screenRectangle.2(688)"></A>: 
       (* the rectangle of the main screen. *)
       (# <B>theRectangle</B><A name="GUIenv.1.screenRectangle.2.theRectangle.3(689)"></A><A name="theRectangle.3(689)"></A>: @rectangle;
       ...
       exit theRectangle
       #);
     <B>screenRgn</B><A name="GUIenv.1.screenRgn.2(690)"></A><A name="screenRgn.2(690)"></A>: 
       (* the region defining the screen(s) *)
       (# <B>rgn</B><A name="GUIenv.1.screenRgn.2.rgn.3(691)"></A><A name="rgn.3(691)"></A>: ^region;
       ...
       exit rgn[]
       #);
     <B>standardTextStyle</B><A name="GUIenv.1.standardTextStyle.2(692)"></A><A name="standardTextStyle.2(692)"></A>: 
       (* the textStyle used by the system to draw menutitles
        * etc.
        *)
       @textStyle;
     <B>beep</B><A name="GUIenv.1.beep.2(693)"></A><A name="beep.2(693)"></A>:
       (* beeps using the current beep in the system *)
       (# ... #);
     <B>guienvWait</B><A name="GUIenv.1.guienvWait.2(694)"></A><A name="guienvWait.2(694)"></A>: 
       (* delays the specified number of ticks (1 tick = 1/60
        * sec.)
        *)
       (# <B>ticks</B><A name="GUIenv.1.guienvWait.2.ticks.3(695)"></A><A name="ticks.3(695)"></A>: @integer;
       enter ticks
       ...
       #);
     <B>transferModes</B><A name="GUIenv.1.transferModes.2(696)"></A><A name="transferModes.2(696)"></A>: @
       (# <B>copy</B><A name="GUIenv.1.transferModes.2.copy.3(697)"></A><A name="copy.3(697)"></A>: (# exit 0 #);
          <B>invertCopy</B><A name="GUIenv.1.transferModes.2.invertCopy.3(698)"></A><A name="invertCopy.3(698)"></A>: (# exit 1 #);
          <B>erase</B><A name="GUIenv.1.transferModes.2.erase.3(699)"></A><A name="erase.3(699)"></A>: (# exit 2 #);
          <B>andBlend</B><A name="GUIenv.1.transferModes.2.andBlend.3(700)"></A><A name="andBlend.3(700)"></A>: (# exit 3 #);
          <B>orBlend</B><A name="GUIenv.1.transferModes.2.orBlend.3(701)"></A><A name="orBlend.3(701)"></A>: (# exit 4 #);
          <B>xorBlend</B><A name="GUIenv.1.transferModes.2.xorBlend.3(702)"></A><A name="xorBlend.3(702)"></A>: (# exit 5 #);
          <B>notAndBlend</B><A name="GUIenv.1.transferModes.2.notAndBlend.3(703)"></A><A name="notAndBlend.3(703)"></A>: (# exit 6 #);
          <B>notOrBlend</B><A name="GUIenv.1.transferModes.2.notOrBlend.3(704)"></A><A name="notOrBlend.3(704)"></A>: (# exit 7 #);
       #);
     <B>textFaces</B><A name="GUIenv.1.textFaces.2(705)"></A><A name="textFaces.2(705)"></A>: @
       (# &lt;&lt;SLOT textFacesLib: attributes&gt;&gt;;
          <B>plain</B><A name="GUIenv.1.textFaces.2.plain.3(706)"></A><A name="plain.3(706)"></A>: (# exit  0 #);
          <B>bold</B><A name="GUIenv.1.textFaces.2.bold.3(707)"></A><A name="bold.3(707)"></A>: (# exit  1 #);
          <B>italic</B><A name="GUIenv.1.textFaces.2.italic.3(708)"></A><A name="italic.3(708)"></A>: (# exit  2 #);
       #);
     <B>patterns</B><A name="GUIenv.1.patterns.2(709)"></A><A name="patterns.2(709)"></A>: @
       (# <B>black</B><A name="GUIenv.1.patterns.2.black.3(710)"></A><A name="black.3(710)"></A>,<B> dkGray</B><A name="GUIenv.1.patterns.2.dkGray.3(711)"></A><A name="dkGray.3(711)"></A>,<B> gray</B><A name="GUIenv.1.patterns.2.gray.3(712)"></A><A name="gray.3(712)"></A>,<B> ltGray</B><A name="GUIenv.1.patterns.2.ltGray.3(713)"></A><A name="ltGray.3(713)"></A>,<B> white</B><A name="GUIenv.1.patterns.2.white.3(714)"></A><A name="white.3(714)"></A>: ^pixmap #);
     <B>cursors</B><A name="GUIenv.1.cursors.2(715)"></A><A name="cursors.2(715)"></A>: @
       (# <B>arrow</B><A name="GUIenv.1.cursors.2.arrow.3(716)"></A><A name="arrow.3(716)"></A>,<B> iBeam</B><A name="GUIenv.1.cursors.2.iBeam.3(717)"></A><A name="iBeam.3(717)"></A>,<B> watch</B><A name="GUIenv.1.cursors.2.watch.3(718)"></A><A name="watch.3(718)"></A>,<B> cross</B><A name="GUIenv.1.cursors.2.cross.3(719)"></A><A name="cross.3(719)"></A>,<B> plus</B><A name="GUIenv.1.cursors.2.plus.3(720)"></A><A name="plus.3(720)"></A>: @cursor #);
     <B>borderStyles</B><A name="GUIenv.1.borderStyles.2(721)"></A><A name="borderStyles.2(721)"></A>: @
       (# <B>simple</B><A name="GUIenv.1.borderStyles.2.simple.3(722)"></A><A name="simple.3(722)"></A>: (# exit 1 #);
          <B>etchedOut</B><A name="GUIenv.1.borderStyles.2.etchedOut.3(723)"></A><A name="etchedOut.3(723)"></A>: (# exit 2 #);
          <B>etchedIn</B><A name="GUIenv.1.borderStyles.2.etchedIn.3(724)"></A><A name="etchedIn.3(724)"></A>: (# exit 3 #);
          <B>shadowIn</B><A name="GUIenv.1.borderStyles.2.shadowIn.3(725)"></A><A name="shadowIn.3(725)"></A>: (# exit 4 #);
          <B>shadowOut</B><A name="GUIenv.1.borderStyles.2.shadowOut.3(726)"></A><A name="shadowOut.3(726)"></A>: (# exit 5 #);
       #);
     <B>separatorStyles</B><A name="GUIenv.1.separatorStyles.2(727)"></A><A name="separatorStyles.2(727)"></A>: @
       (# <B>singleLine</B><A name="GUIenv.1.separatorStyles.2.singleLine.3(728)"></A><A name="singleLine.3(728)"></A>: (# exit 1 #);
          <B>doubleLine</B><A name="GUIenv.1.separatorStyles.2.doubleLine.3(729)"></A><A name="doubleLine.3(729)"></A>: (# exit 2 #);
          <B>singleDashedLine</B><A name="GUIenv.1.separatorStyles.2.singleDashedLine.3(730)"></A><A name="singleDashedLine.3(730)"></A>: (# exit 3 #);
          <B>doubleDashedLine</B><A name="GUIenv.1.separatorStyles.2.doubleDashedLine.3(731)"></A><A name="doubleDashedLine.3(731)"></A>: (# exit 4 #);
          <B>etchedIn</B><A name="GUIenv.1.separatorStyles.2.etchedIn.3(732)"></A><A name="etchedIn.3(732)"></A>: (# exit 5 #);
          <B>etchedOut</B><A name="GUIenv.1.separatorStyles.2.etchedOut.3(733)"></A><A name="etchedOut.3(733)"></A>: (# exit 6 #);
       #);
     <B>windowTypes</B><A name="GUIenv.1.windowTypes.2(734)"></A><A name="windowTypes.2(734)"></A>: @
       (# <B>normal</B><A name="GUIenv.1.windowTypes.2.normal.3(735)"></A><A name="normal.3(735)"></A>: integerValue (# do 0 -&gt; value #);
          <B>dialog</B><A name="GUIenv.1.windowTypes.2.dialog.3(736)"></A><A name="dialog.3(736)"></A>: integerValue (# do 1 -&gt; value #);
          <B>palette</B><A name="GUIenv.1.windowTypes.2.palette.3(737)"></A><A name="palette.3(737)"></A>: integerValue (# do 2 -&gt; value #);
          <B>modelessDialog</B><A name="GUIenv.1.windowTypes.2.modelessDialog.3(738)"></A><A name="modelessDialog.3(738)"></A>: integerValue (# do 3 -&gt; value #);
       #);
     <B>private</B><A name="GUIenv.1.private.2(739)"></A><A name="private.2(739)"></A>: @...;
     <B>trace</B><A name="GUIenv.1.trace.2(740)"></A><A name="trace.2(740)"></A>:
       (* For debugging. If doTrace is true, INNER is called. *)
       (#
       do (if doTrace then INNER if);
       #);
     <B>doTrace</B><A name="GUIenv.1.doTrace.2(741)"></A><A name="doTrace.2(741)"></A>: @Boolean;
     (* Additions needed for bifrost *)
     <B>bifrostprivate</B><A name="GUIenv.1.bifrostprivate.2(742)"></A><A name="bifrostprivate.2(742)"></A>: @...;
     <B>displaywarnings</B><A name="GUIenv.1.displaywarnings.2(743)"></A><A name="displaywarnings.2(743)"></A>: @boolean
       (* If displayWarnings is true, various warnings about bifrost
        * errors that are not fatal, but may affect the behaviour, is
        * displayed. Defaults to true.
        *);
     <B>warnStream</B><A name="GUIenv.1.warnStream.2(744)"></A><A name="warnStream.2(744)"></A>: ^stream
       (* The stream bifrost warnings are put to. Defaults to
        * screen.
        *);
     
     (* Additions needed for systemenv *)
     <B>doSetup</B><A name="GUIenv.1.doSetup.2(745)"></A><A name="doSetup.2(745)"></A>: 
       (# 
       do (if not setupDone then
              ...; 
              true -&gt; setupDone 
          if)
       #);
     <B>setupDone</B><A name="GUIenv.1.setupDone.2(746)"></A><A name="setupDone.2(746)"></A>: @Boolean;
     <B>XsystemEnvPresent</B><A name="GUIenv.1.XsystemEnvPresent.2(747)"></A><A name="XsystemEnvPresent.2(747)"></A>: @Boolean; 
     (* TRUE if this is a XsystemEnv program.  In this case,
      * callbacks are executed by a separate thread as synchronisation
      * via semaphores between x-callbacks and other coroutines would
      * not be possible otherwise. (It could lead to suspend of
      * coroutines with C stackparts.  If TRUE,
      * XsystemEnvHandleCallback should not be NONE.
      *)
     <B>XsystemEnvHandleCallbackP</B><A name="GUIenv.1.XsystemEnvHandleCallbackP.2(748)"></A><A name="XsystemEnvHandleCallbackP.2(748)"></A>: 
       (# <B>cb</B><A name="GUIenv.1.XsystemEnvHandleCallbackP.2.cb.3(749)"></A><A name="cb.3(749)"></A>: ^Object; enter cb[] do INNER #);
     <B>XsystemEnvHandleCallback</B><A name="GUIenv.1.XsystemEnvHandleCallback.2(750)"></A><A name="XsystemEnvHandleCallback.2(750)"></A>: 
       ^XsystemEnvHandleCallbackP;
  ...
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Guienv Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
