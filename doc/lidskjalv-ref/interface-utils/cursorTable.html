<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<!-- Autogenerated file - do not edit -->
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>CursorTable Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="decorator.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="colorTable.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>

<H1>CursorTable Interface</H1>
<PRE CLASS=interface>
ORIGIN '../guienv';
BODY 'private/cursorTableBody'

(* This fragment adds cursor-table facilities to guienv.  
 * A 'cursorTable' pattern have been added. 
 *
 * cursorTable
 * ----------
 *
 * This pattern defines facilities for maintaining mappings between
 * textual names of cursors, and their numerical representations (in terms 
 * of 'cursor' values). 'cursorTable' defines four functions:
 *
 * define: defines the text in 'cursorName' to refer to the current
 *   cursor of 'cursorValue'.  If 'cursorName' is already defined, it
 *   will be redefined to refer to the cursor of 'cursorValue'.
 *
 * lookup: sets the cursor values of 'cursorValue' to the cursor values
 *   referred to by 'cursorName'.  If 'cursorName' is not defined in the
 *   cursortable, 'cursorValue' will be set to 'black'
 *
 * loadFile: load the cursor definitions found in the file 'filename' into
 *   the cursor table.
 *
 *   If 'overwrite' is bound to 'trueObject'
 *   (i.e. 'overwrite::trueObject'), then the new cursor definitions
 *   will replace any previously existing cursor definition with the
 *   same cursor name.
 *
 *   If 'merge' is not bound to 'trueObject' - i.e. not
 *   'merge::trueObject', then clear the cursor table.
 *
 *   If 'filename' is empty, or cannot be read, the result will be
 *   that all cursor definitions will be erased, i.e. a way to clear
 *   all existing cursor definitions is merely by executing:
 *
 *      ct.loadFile; ('ct' assumed to be an instance of 'cursorTable')
 *
 * scan: scans the defined cursornames in the cursor table and their
 *   cursor values.
 *
 * In multi-fragment guienv programs it can be a problem to
 * reach the single cursortable instans. This problem can be 
 * solved using the object-pool. 
 * 
 * Main fragment:
 * ct:@cursortable;
 * ...
 * ct[]-&gt;objectPool.put;
 * 
 * Other fragment:
 * ct:^cursortable;
 * ...
 * objectPool.get(# type::&lt;cursortable; #)-&gt;ct[];
 * 
 * see basiclib reference manual p 12&amp;23
 *)

---cursorlib: attributes ---
     <B>load</B><A name="load.1(27)"></A>:
       (# <B>x11ID</B><A name="load.1:x11ID.2(28)"></A><A name="x11ID.2(28)"></A>:&lt; (# ID: @integer do INNER exit ID #);
          <B>macID</B><A name="load.1:macID.2(29)"></A><A name="macID.2(29)"></A>:&lt; (# ID: @integer do INNER exit ID #);
          <B>ntiID</B><A name="load.1:ntiID.2(30)"></A><A name="ntiID.2(30)"></A>:&lt; (# ID: @integer do INNER exit ID #);
          <B>ntiNAME</B><A name="load.1:ntiNAME.2(31)"></A><A name="ntiNAME.2(31)"></A>:&lt; (# ID: ^text do INNER exit ID[] #);
       ...
       #);

--- guienvlib: attributes ---
<B>cursorTable</B><A name="cursorTable.1(32)"></A>:
  (# &lt;&lt;SLOT cursortablelib: attributes&gt;&gt;;
     <B>init</B><A name="cursorTable.1:init.2(33)"></A><A name="init.2(33)"></A>:&lt; (* is called automatically to enable automatic load of cursors *)
       (# do INNER init #);
     <B>create</B><A name="cursorTable.1:create.2(34)"></A><A name="create.2(34)"></A>:
       (# x11ID:&lt; (# ID: @integer do INNER exit ID #);
          macID:&lt; (# ID: @integer do INNER exit ID #);
          ntiID:&lt; (# ID: @integer do INNER exit ID #);
          ntiNAME:&lt; (# ID: ^text do INNER exit ID[] #);
          cursorName: ^text;
          c: ^(*private*)cursor;
       enter cursorName[]
       ...
       #);
     <B>define</B><A name="cursorTable.1:define.2(35)"></A><A name="define.2(35)"></A>:
       (* defines the text in 'cursorName' to refer to the current
        * cursor of 'cursorRef'.  If 'cursorName' is already defined,
        * it will be redefined to refer to the cursor of 'cursorRef'.
        *)
       (# cursorName: ^text; cursorRef: ^cursor
       enter (cursorName[], cursorRef[])
       ...
       #);
     <B>lookup</B><A name="cursorTable.1:lookup.2(36)"></A><A name="lookup.2(36)"></A>:
       (* sets 'cursorRef' to refer to the cursor
        * referred to by 'cursorName'.  If 'cursorName' is not defined
        * in the cursortable, 'cursorRef' will be set to 'arrow'
        *)
       (# cursorName: ^text; cursorRef: ^cursor
       enter cursorName[]
       ...
       exit cursorRef[]
       #);
     <B>load</B><A name="cursorTable.1:load.2(37)"></A><A name="load.2(37)"></A>:
       (* reads cursor definitions from a stream
        * into the cursor table.
        *
        * If 'overwrite' is bound to 'trueObject'
        * (i.e. 'overwrite::trueObject'), then the new cursor
        * definitions will replace any previously existing cursor
        * definition with the same cursor name.
        *
        * If 'merge' is not bound to 'trueObject' - i.e. not
        * 'merge::trueObject', then clear the cursor table.
        *)
       (# cursorstream: ^stream;
          overwrite:&lt; booleanValue;
          merge:&lt; booleanValue;
       enter cursorstream[]
       ...
       #);
     <B>loadFile</B><A name="cursorTable.1:loadFile.2(38)"></A><A name="loadFile.2(38)"></A>:
       (* load the cursor definitions found in the file 'filename'
        * into the cursor table.
        *
        * If 'overwrite' is bound to 'trueObject'
        * (i.e. 'overwrite::trueObject'), then the new cursor
        * definitions will replace any previously existing cursor
        * definition with the same cursor name.
        *
        * If 'merge' is not bound to 'trueObject' - i.e. not
        * 'merge::trueObject', then clear the cursor table.
        *
        * If 'filename' is empty, or cannot be read, the result will
        * be that all cursor definitions will be erased, i.e. a way to
        * clear all existing cursor definitions is merely by executing:
        *
        *      ct.load; ('ct' assumed to be an instance of 'cursorTable')
        *)
       (# filename: ^text;
          overwrite:&lt; booleanValue;
          merge:&lt; booleanValue;
       enter filename[]
       ...
       #);
     <B>scan</B><A name="cursorTable.1:scan.2(39)"></A><A name="scan.2(39)"></A>:
       (* scans the defined cursornames in the cursor table and their cursor
        * values.
        *)
       (# currentName: ^text; currentCursor: ^cursor;
       ...
       #);
     <B>private</B><A name="cursorTable.1:private.2(40)"></A><A name="private.2(40)"></A>: @...
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P></P>
<A HREF="decorator.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="colorTable.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
