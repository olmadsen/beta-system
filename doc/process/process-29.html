
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Managing a Pool of Connections</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>
</HEAD>
<BODY>
<A NAME=HEADING29></A>
<A HREF="process-30.html"><IMG ALIGN="BOTTOM" ALT="Next" BORDER=0 SRC="../images/next.gif">
</A> <A HREF="process-28.html"><IMG ALIGN="BOTTOM" ALT="Previous" BORDER=0 SRC="../images/prev.gif">

</A> <A HREF="../index.html"><IMG ALIGN="BOTTOM" ALT="Top" BORDER=0 SRC="../images/top.gif">
</A> <A HREF="index.html#_toc"><IMG ALIGN="BOTTOM" ALT="Contents" BORDER=0 SRC="../images/content.gif">
</A> <A HREF="inx.html"><IMG ALIGN="BOTTOM" ALT="Index" BORDER=0 SRC="../images/index.gif">
</A><P>Process Reference Manual<P>
<A NAME=HEADING29-0></A>
<H1> <A NAME=MARKER-9-81></A><A NAME=MARKER-8-82></A>Managing a Pool of Connections</H1>
 A connection pool manages a number of client side communication interfaces (e.g. active sockets), and allows choosing which one of them to use for a communication transfer by means of a portableCommAddress. This abstracts away the need to establish connections: whenever a connection as specified is available in the pool, we use it. Otherwise, such a connection will implicitly be established and added to the pool. If this process runs out of resources associated with these connections (e.g. file handles), it is possible to ask the pool to close the least recently used connection.<P>

 The connections are subject to concurrency control<A NAME=MARKER-2-83></A>, so they must be used in a <B>take-it, use-it, give-it-back</B> fashion. This is achieved by the pattern communication. The concurrency control is necessary to prevent the situation where two users of the pool both transmit messages to some other party on one given connection, and randomly divide the incoming messages on that connection between them, both believing to have the other party for themselves. Using the pattern communication, at most one user of the pool communicates on any given connection at any given point of time.<P>

 By now, the only variant of connection pool implemented is the binaryConnectionPool<A NAME=MARKER-2-84></A>. Instances of binaryConnectionPool are used for managing a number of binary socket connections. Before usage, initialize it. The user of a binaryConnectionPool gives a specification of the receiver, the type of connection, the quality of service etc. in a portableCommAddress to a (specialization of) the control pattern communication. This is used as follows (where bcPool is an instance of binaryConnectionPool):<P>
<PRE CLASS=beta>
  addr[] -&gt; bcPool.communication
  (# (* Extend error callbacks here *)
  do
    (* Within this dopart: use 'sock' to communicate *)
    (* Do not bring references to sock outside *)
  #);
</PRE>
 If you want to leave the dopart of a specialization of a communication, use a construction like leaving(# do leave L #) in stead of leave L. Otherwise some resources may be rendered inaccessible.<P>
 Whenever the pool establishes a new connection, the hook onNewConnection of communication is executed. In a extending of this hook, a reference to the newly established connection is available, and by assigning a co-routine to actor, the connection gets associated with this co-routine. This is used to handle incoming messages to connections in the pool, which are not the immediate response to an outgoing message transmitted in a usage of communication: have the co-routine sit around waiting for the incoming messages. To support such things, one must specialize binaryConnectionPool.<P>
 If the connection delivered as sock within a specialization of communication is to be taken away from the pool and used outside, execute removeSock and bring out a reference to sock. If it is known that the connection will not be useful anymore, execute removeSock and sock.close.<P>
 The operation markAsDead<A NAME=MARKER-2-85></A> is used to tell the pool that it certainly cannot have a connection like the one entered. If a communication partner closes a connection (or perhaps terminates unexpectedly), and the other end of that connection is in a connection pool, it could happen that this connection is not chosen in any communication for some time. If a new connection is created, the operating system may then reuse the local connection identifier (file handle, in case of UNIX sockets), giving a totally different connection, which is then administrated by some new BETA socket object. Now two BETA socket objects will talk to the same OS level connection (file handle), but this means that the first object (in the pool) has silently been <B>redirected</B> to a new communication partner. Of course, this leads to strange errors.<P>
 So, whenever creating a BETA socket object OUTSIDE a connection pool, please tell it by means of markAsDead, that any connections in the pool with the same OS level identifier must have died silently and thus should be removed from the pool. Internally, the connection pool handles this automatically.<P>
 Please note that this problem is not specific for connection pools, for the process library, or even for BETA programs, for that matter. But it occurs mainly in the presence of complicated and very dynamic communication topologies, which are more likely to appear with connection pools. It would actually be best to carry out similar checks (using sameConnection) also when using only simple socket objects in an application.<P>
 removeSomeConnection<A NAME=MARKER-2-86></A> will seek through all unused connections in the pool. An unused connection is a connection such that no instance of communication in any co-routine of this process currently refers to it with its sock attribute. From this set of unused connections, it chooses the least recently used (as reported by its usageTimestamp), closes it, and removes it from the pool. If all connections are currently in use, application specific actions must be taken to free some of them. The callback noConnectionsRemovable is executed in this situation. It does not terminate the application by default, so beware of the possible infinite retry loop if removeSomeConnection is used in response to resourceError, and no connections could actually be removed.<P>
 When done with a connectionPool, close it to close all of the connections contained within it.<P>
<!-- TOC -->
<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Process Reference Manual</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<A HREF="process-30.html"><IMG ALIGN="BOTTOM" ALT="Next" BORDER=0 SRC="../images/next.gif">
</A> <A HREF="process-28.html"><IMG ALIGN="BOTTOM" ALT="Previous" BORDER=0 SRC="../images/prev.gif">

</A> <A HREF="../index.html"><IMG ALIGN="BOTTOM" ALT="Top" BORDER=0 SRC="../images/top.gif">
</A> <A HREF="index.html#_toc"><IMG ALIGN="BOTTOM" ALT="Contents" BORDER=0 SRC="../images/content.gif">
</A> <A HREF="inx.html"><IMG ALIGN="BOTTOM" ALT="Index" BORDER=0 SRC="../images/index.gif">
</A><P>
</BODY>
</HTML> 