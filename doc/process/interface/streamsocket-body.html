<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Streamsocket Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("streamsocket");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="streamsocket">Streamsocket Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/basicsystemenv';
LIB_DEF 'processstream' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1995-97
 *       All rights reserved.
 *)

INCLUDE 'basicsocket';
BODY 'private/streamsocketbody';

--- systemlib:attributes ---
<B>StreamSocket</B><A name="StreamSocket.1(154)"></A>: Stream
  (# &lt;&lt;SLOT streamsocketlib:attributes&gt;&gt;;
     
     <B>theSocket</B><A name="StreamSocket.1.theSocket.2(155)"></A><A name="theSocket.2(155)"></A>: @basicSocket  
       (* The socket communication goes through *)
       (# error::
            (# 
            do (if value=errCB_initialValue then
                   (* Error not handled yet *)
                   (value,cleanup[])-&gt;this(StreamSocket).error-&gt;value;
                   (if value=errCB_initialValue then
                       this(StreamSocket).otherError;
                       (* If otherError did not terminate the
                        * program, let it continue here as well
                        *)
                       errCB_continueOperation-&gt;value;
                   if)
               if)
            #)
       #);

     (* basics *)
     <B>timeoutValue</B><A name="StreamSocket.1.timeoutValue.2(156)"></A><A name="timeoutValue.2(156)"></A>:&lt; 
       (* Length in seconds.  
        * All operations that do not enter a timeout
        * themselves uses this timeout.
        *)
       integerValue(# do waitForever-&gt;value; INNER #);
     
     (* operations *)
     <B>sameConnection</B><A name="StreamSocket.1.sameConnection.2(157)"></A><A name="sameConnection.2(157)"></A>: booleanValue
       (* do 'this' and 'other' wrap 
        * the same OS level connection? 
        *)
       (# other: ^StreamSocket;
       enter other[]
       ...
       #);
     
     <B>flush</B><A name="StreamSocket.1.flush.2(158)"></A><A name="flush.2(158)"></A>: theSocket.withIdle
       (# 
       ... 
       #);
     
     <B>close</B><A name="StreamSocket.1.close.2(159)"></A><A name="close.2(159)"></A>: theSocket.withPE
       (* Close socket completely. Any further operations are
        * disallowed and the other end gets EOS if it tries *)
       (# ... #);

     <B>closeRead</B><A name="StreamSocket.1.closeRead.2(160)"></A><A name="closeRead.2(160)"></A>: theSocket.closeRead
     (* Close socket partially. closeRead makes further reads
      * at this end of the socket and further writes at
      * the other end fail with EOS. *)
       (# #);
     
     <B>closeWrite</B><A name="StreamSocket.1.closeWrite.2(161)"></A><A name="closeWrite.2(161)"></A>: theSocket.closeWrite
     (* Close socket partially. closeWrite makes further writes
      * at this end of the socket and further reads at
      * the other end fail with EOS. *)
       (# #);
     
     <B>put</B><A name="StreamSocket.1.put.2(162)"></A><A name="put.2(162)"></A>::
       (# Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
       ...
       #);
     
     <B>puttext</B><A name="StreamSocket.1.puttext.2(163)"></A><A name="puttext.2(163)"></A>::
       (# Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
       ...
       #);
     
     <B>get</B><A name="StreamSocket.1.get.2(164)"></A><A name="get.2(164)"></A>::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -&gt; value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
       ...
       #);
     
     <B>peek</B><A name="StreamSocket.1.peek.2(165)"></A><A name="peek.2(165)"></A>::
       (# theIdle: @theSocket.withIdle
            (# connBrokenError::
                 (# do errCB_abortOperation -&gt; value;
                    this(Stream).EOSerror;
                 #)
            #);
          Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
       ...
       #);
     
     <B>getline</B><A name="StreamSocket.1.getline.2(166)"></A><A name="getline.2(166)"></A>::
       (# priv: @...;
          Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
          timedOut: @Boolean;
       do priv;
       #);
     
     <B>getAtom</B><A name="StreamSocket.1.getAtom.2(167)"></A><A name="getAtom.2(167)"></A>::
       (# ch: @Char;
          Idle:&lt; (# do INNER #);
          Blocking:&lt; (# do INNER #);
       ...
       #);
     
     <B>eos</B><A name="StreamSocket.1.eos.2(168)"></A><A name="eos.2(168)"></A>::
       (# priv: @...
       do priv;
       #);
     
     <B>getPos</B><A name="StreamSocket.1.getPos.2(169)"></A><A name="getPos.2(169)"></A>::
       (# 
       do -1 -&gt; value;
       #);
     
     <B>setPos</B><A name="StreamSocket.1.setPos.2(170)"></A><A name="setPos.2(170)"></A>::
       (# 
       do this(Stream).otherError;
       #);
     
     <B>init</B><A name="StreamSocket.1.init.2(171)"></A><A name="init.2(171)"></A>:&lt; (# do theSocket.init; INNER #);
     <B>forceTimeout</B><A name="StreamSocket.1.forceTimeout.2(172)"></A><A name="forceTimeout.2(172)"></A>:&lt; (# do theSocket.forceTimeout #);
     <B>usageTimestamp</B><A name="StreamSocket.1.usageTimestamp.2(173)"></A><A name="usageTimestamp.2(173)"></A>:&lt; integerValue
       (# do theSocket.usageTimestamp -&gt; value #);

     (* nonBlockingScope support *)
     (* Note: don`t 'leave' a 'nonBlockingScope'. 
      * Use 'leaveNBScope' 
      *)
     <B>nonBlockingScope</B><A name="StreamSocket.1.nonBlockingScope.2(174)"></A><A name="nonBlockingScope.2(174)"></A>: theSocket.nonBlockingScope(# do INNER #);
     <B>leaveNBScope</B><A name="StreamSocket.1.leaveNBScope.2(175)"></A><A name="leaveNBScope.2(175)"></A>: theSocket.nonBlockingScope(# do INNER #);

     <B>connect</B><A name="StreamSocket.1.connect.2(176)"></A><A name="connect.2(176)"></A>: theSocket.connect(# do INNER #);

     <B>Idle</B><A name="StreamSocket.1.Idle.2(177)"></A><A name="Idle.2(177)"></A>:&lt; Object; (* every local 'Idle' executes this global one *)
     
     (* socket level error callback *)
     <B>error</B><A name="StreamSocket.1.error.2(178)"></A><A name="error.2(178)"></A>:&lt; hiErrCB(# do INNER #);

     (* attributes *)
     <B>host</B><A name="StreamSocket.1.host.2(179)"></A><A name="host.2(179)"></A>: (# enter theSocket.host exit theSocket.host #);
     <B>port</B><A name="StreamSocket.1.port.2(180)"></A><A name="port.2(180)"></A>: (# enter theSocket.port exit theSocket.port #);
     <B>inetAddr</B><A name="StreamSocket.1.inetAddr.2(181)"></A><A name="inetAddr.2(181)"></A>: (# enter theSocket.inetAddr exit theSocket.inetAddr #); 

     (* private *)
     <B>private</B><A name="StreamSocket.1.private.2(182)"></A><A name="private.2(182)"></A>: @...;
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Streamsocket Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
