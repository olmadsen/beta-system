<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Commaddress Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="commaddress">Commaddress Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'processaddress' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1994-97
 *       All rights reserved.
 *)

BODY 'private/commaddressbody';

(* CONTENTS
 * ========
 *
 * Defines patterns for representing communication addresses.
 *
 * The most abstract pattern, portableCommAddress, models a
 * portable communication address. This specifies the address
 * of a single destination or the address(es) of a group of
 * destinations.
 *
 * The patterns portableMultiAddress and portablePortAddress
 * specialize portableCommAddress into concrete patterns for
 * the multiple-destination case and one-destination case,
 * respectively.
 *
 * The pattern concretePortAddress and its specializations
 * represent non-portable, protocol specific communication
 * port addresses. These are kept in portableCommAddresses
 * and selected according to protocol specifications, given
 * as protocolSpec objects.
 * 
 * As a best-fit addition, there are also some patterns
 * to aid the process of looking up TCP/IP hosts, getting the
 * hostname of this machine, etc.
 * 
 *)

--- lib:attributes ---
(* Reliability
 * ===========
 *
 * Used to specify the reliability proporties
 * required for a transfer (in a protocolSpec).
 * The proporties are additive. 
 *)

<B>commRely_dontcare</B><A name="commRely_dontcare.1(1)"></A>:   (# exit 0 #);
<B>commRely_loss</B><A name="commRely_loss.1(2)"></A>:       (# exit 2 #); (* packets are not lost *)
<B>commRely_dup</B><A name="commRely_dup.1(3)"></A>:        (# exit 4 #); (* packets are not duplicated *)
<B>commRely_order</B><A name="commRely_order.1(4)"></A>:      (# exit 8 #); (* packets arrive 
                                    * in correct order *)
<B>commRely_contents</B><A name="commRely_contents.1(5)"></A>:   (# exit 16 #); (* corrupt data unlikely 
                                     * (e.g. checksum) *)

<B>commRely_unreliable</B><A name="commRely_unreliable.1(6)"></A>: (# exit 1 #); (* ensures none of the above *)
<B>commRely_reliable</B><A name="commRely_reliable.1(7)"></A>:   (# exit 31 #); (* ensure loss, dup, 
                                     * order &amp; contents *)

(* Type of connection protocol
 * ===========================
 *
 * OS level category of connection. An implementation
 * level description of an individual connection
 * managed by a connectionPool. Weird numbers chosen
 * to make data containing these constants recognizable
 * in a raw communication dump.
 *)

<B>commProtocol_dontcare</B><A name="commProtocol_dontcare.1(8)"></A>:   (# exit 0 #);
<B>commProtocol_tcp</B><A name="commProtocol_tcp.1(9)"></A>:        (# exit 72301 #); (* TCP/IP *)
<B>commProtocol_udp</B><A name="commProtocol_udp.1(10)"></A>:        (# exit 72302 #); (* UDP/IP *)
<B>commProtocol_unix</B><A name="commProtocol_unix.1(11)"></A>:       (# exit 72303 #); (* UNIX domain 
                                            * (socket as file) *)
<B>commProtocol_ppc</B><A name="commProtocol_ppc.1(12)"></A>:        (# exit 72304 #); (* Mac PPC ToolBox *)
<B>commProtocol_mem</B><A name="commProtocol_mem.1(13)"></A>:        (# exit 72305 #); (* Shared memory buffer *)

(* Mnemonic names of the protocols *)
<B>commProtName_tcp</B><A name="commProtName_tcp.1(14)"></A>:        (# exit 'TCP' #);
<B>commProtName_udp</B><A name="commProtName_udp.1(15)"></A>:        (# exit 'UDP' #);
<B>commProtName_unix</B><A name="commProtName_unix.1(16)"></A>:       (# exit 'UNIX' #);
<B>commProtName_ppc</B><A name="commProtName_ppc.1(17)"></A>:        (# exit 'PPC' #);
<B>commProtName_mem</B><A name="commProtName_mem.1(18)"></A>:        (# exit 'MEM' #);

(* Specification of connection requirements
 * ========================================
 *
 * Used to package spec. of requirements to a communication
 * transfer, and then given to a portablePortAddress, which
 * will use it when choosing an appropriate channel.
 *)
<B>protocolSpec</B><A name="protocolSpec.1(19)"></A>:
  (#
     <B>cType</B><A name="protocolSpec.1.cType.2(20)"></A><A name="cType.2(20)"></A>: @integer; (* one of 'commProtocol_.*'
                       * dontcare is default *)
     <B>rType</B><A name="protocolSpec.1.rType.2(21)"></A><A name="rType.2(21)"></A>: @integer; (* one of 'commRely_.*'
                       * dontcare is default *)
     (* bandwidth/r-rr-rra/etc *)
  enter (cType, rType)
  exit cType
  #);

(* Portable communication address
 * ==============================
 *
 * Specifies identity of an abstract communication address.
 * This pattern is abstract, and no instances of it are
 * expected to exist. The patterns portableMultiAddress and
 * portablePortAddress are non-abstract specializations.
 *
 * Any portableCommAddress is able to express its value
 * in textual form, by 'asText'.
 * 
 * Tell a portableCommAddress what proporties are required
 * of the communications associated with it by entering
 * a protocolSpec object. This affects its choice of
 * concrete communication port(s) in subsequent
 * communications.
 *)
<B>portableCommAddress</B><A name="portableCommAddress.1(22)"></A>:
  (#
     <B>init</B><A name="portableCommAddress.1.init.2(23)"></A><A name="init.2(23)"></A>:&lt; Object;
     <B>asText</B><A name="portableCommAddress.1.asText.2(24)"></A><A name="asText.2(24)"></A>: @asTextPattern;

     (* private *)
     <B>asTextPattern</B><A name="portableCommAddress.1.asTextPattern.2(25)"></A><A name="asTextPattern.2(25)"></A>:&lt; (# t: ^text do INNER exit t[] #);
     <B>enterSpec</B><A name="portableCommAddress.1.enterSpec.2(26)"></A><A name="enterSpec.2(26)"></A>: @...;
     <B>private</B><A name="portableCommAddress.1.private.2(27)"></A><A name="private.2(27)"></A>: @...;
  enter enterSpec
  #);

(* Portable communication address constructor
 * ==========================================
 *
 * Function. Takes a text value, which is expected to have
 * been produced by some instance X of a specialization of
 * portableCommAddress using its 'asText'. Returns an object
 * with the same value as X.
 *
 * Problems are reported by invoking 'parseError'. The 
 * application will then terminate with an exception,
 * unless you furtherbind parseError to leave it.
 *)
<B>portableCommAddressFromText</B><A name="portableCommAddressFromText.1(28)"></A>:
  (# 
     <B>parseError</B><A name="portableCommAddressFromText.1.parseError.2(29)"></A><A name="parseError.2(29)"></A>:&lt;
       (# msg: ^text;
       enter msg[]
       ...
       #);
     <B>txt</B><A name="portableCommAddressFromText.1.txt.2(30)"></A><A name="txt.2(30)"></A>: ^text;
     <B>addr</B><A name="portableCommAddressFromText.1.addr.2(31)"></A><A name="addr.2(31)"></A>: ^portableCommAddress;
     &lt;&lt;SLOT portableCommAddressFromTextLib:attributes&gt;&gt;;
  enter txt[]
  ...
  exit addr[]
  #);

(* Portable multicast address
 * ==========================
 *
 * Specifies identities of the members of a group of
 * communication destinations.
 *
 * The group can be built from scratch or enhanced
 * by 'insert'ing members. It can be reduced by
 * 'delete'ing members. 
 *)
<B>portableMultiAddress</B><A name="portableMultiAddress.1(32)"></A>: portableCommAddress
  (#
     <B>init</B><A name="portableMultiAddress.1.init.2(33)"></A><A name="init.2(33)"></A>::&lt; (# ... #);

     <B>insert</B><A name="portableMultiAddress.1.insert.2(34)"></A><A name="insert.2(34)"></A>:
       (# addr: ^portablePortAddress;
       enter addr[]
       ...
       #);

     <B>delete</B><A name="portableMultiAddress.1.delete.2(35)"></A><A name="delete.2(35)"></A>:
       (# addr: ^portablePortAddress;
       enter addr[]
       ...
       #);
     
     (* private *)
     <B>asTextPattern</B><A name="portableMultiAddress.1.asTextPattern.2(36)"></A><A name="asTextPattern.2(36)"></A>::&lt; (# ... #);
     <B>private2</B><A name="portableMultiAddress.1.private2.2(37)"></A><A name="private2.2(37)"></A>: @...;
  #);

(* Portable communication port address
 * ===================================
 *
 * Specifies identity of one logical communication destination.
 * A logical destination corresponds to a number of concrete
 * communication ports, represented by instances of
 * specializations of concretePortAddress.
 *
 * A portablePortAddress can be built from scratch by
 * by 'insert'ing such instances. Only one concrete address
 * is allowed for each known type - inserting a second instance
 * overrides the previously inserted one. 
 *)
<B>portablePortAddress</B><A name="portablePortAddress.1(38)"></A>: portableCommAddress
  (#
     <B>insert</B><A name="portablePortAddress.1.insert.2(39)"></A><A name="insert.2(39)"></A>:
       (# addr: ^concretePortAddress;
          addrHasUnknownType:&lt; exception;
       enter addr[]
       ...
       #);
     <B>delete</B><A name="portablePortAddress.1.delete.2(40)"></A><A name="delete.2(40)"></A>:
       (# prot: @integer; (* one of 'commProtocol_.*' *)
          addrHasUnknownType:&lt; exception;
       enter prot
       ...
       #);
     <B>getTcpPort</B><A name="portablePortAddress.1.getTcpPort.2(41)"></A><A name="getTcpPort.2(41)"></A>:
       (# addr: ^tcpPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getUdpPort</B><A name="portablePortAddress.1.getUdpPort.2(42)"></A><A name="getUdpPort.2(42)"></A>:
       (# addr: ^udpPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getUnixPort</B><A name="portablePortAddress.1.getUnixPort.2(43)"></A><A name="getUnixPort.2(43)"></A>:
       (# addr: ^unixPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getPpcPort</B><A name="portablePortAddress.1.getPpcPort.2(44)"></A><A name="getPpcPort.2(44)"></A>:
       (# addr: ^ppcPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getMemPort</B><A name="portablePortAddress.1.getMemPort.2(45)"></A><A name="getMemPort.2(45)"></A>:
       (# addr: ^memPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);

     (* private *)
     <B>asTextPattern</B><A name="portablePortAddress.1.asTextPattern.2(46)"></A><A name="asTextPattern.2(46)"></A>::&lt; (# ... #);
     <B>private2</B><A name="portablePortAddress.1.private2.2(47)"></A><A name="private2.2(47)"></A>: @...;
  #);

(* Concrete communication port address
 * ===================================
 *
 * Abstract superpattern for specifying the address
 * of a concrete communication port, such as a UN*X
 * stream socket, a Mac PPC ToolBox session, a shared
 * memory buffer etc.
 *
 * Is able to express its value textually with 'asText',
 * and to characterize its communication protocol
 * with 'commType'. 
 *)
<B>concretePortAddress</B><A name="concretePortAddress.1(48)"></A>:
  (#
     <B>asText</B><A name="concretePortAddress.1.asText.2(49)"></A><A name="asText.2(49)"></A>: @asTextPattern;
     <B>asTextPattern</B><A name="concretePortAddress.1.asTextPattern.2(50)"></A><A name="asTextPattern.2(50)"></A>:&lt; (# t: ^text do INNER exit t[] #);
     
     <B>protocol</B><A name="concretePortAddress.1.protocol.2(51)"></A><A name="protocol.2(51)"></A>:&lt; integerValue; (* one of 'commProtocol_.*' *)
     <B>protName</B><A name="concretePortAddress.1.protName.2(52)"></A><A name="protName.2(52)"></A>:&lt; (# t: ^text do &amp;text[] -&gt; t[]; INNER exit t[] #);
     <B>conformsTo</B><A name="concretePortAddress.1.conformsTo.2(53)"></A><A name="conformsTo.2(53)"></A>: BooleanValue
       (# p: @integer;
       enter p
       ...
       #);
     <B>private</B><A name="concretePortAddress.1.private.2(54)"></A><A name="private.2(54)"></A>: @...;
  #);

(* Unix communication port address types
 * =====================================
 *
 * The pattern unixAbstractPortAddress captures similarities
 * between TCP and UDP ports, represented by
 * tcpPortAddress and udpPortAddress. 
 *
 * The pattern unixPortAddress represents an AF_UNIX address
 * family socket, i.e. it appears as a name in some directory,
 * just like a file. 
 * 
 * NB: The tcpPortAddress also fits a MacTCP port.
 *)
<B>unixAbstractPortAddress</B><A name="unixAbstractPortAddress.1(55)"></A>: concretePortAddress
  (#
     <B>inetAddr</B><A name="unixAbstractPortAddress.1.inetAddr.2(56)"></A><A name="inetAddr.2(56)"></A>: @integer;
     <B>portNo</B><A name="unixAbstractPortAddress.1.portNo.2(57)"></A><A name="portNo.2(57)"></A>: @integer;
     <B>asTextPattern</B><A name="unixAbstractPortAddress.1.asTextPattern.2(58)"></A><A name="asTextPattern.2(58)"></A>::&lt; (# ... #);
  #);

<B>tcpPortAddress</B><A name="tcpPortAddress.1(59)"></A>: unixAbstractPortAddress
  (#
     <B>protocol</B><A name="tcpPortAddress.1.protocol.2(60)"></A><A name="protocol.2(60)"></A>::&lt; (# do commProtocol_tcp -&gt; value #);
     <B>protName</B><A name="tcpPortAddress.1.protName.2(61)"></A><A name="protName.2(61)"></A>::&lt; (# do commProtName_tcp -&gt; t #);
  #);

<B>udpPortAddress</B><A name="udpPortAddress.1(62)"></A>: unixAbstractPortAddress
  (#
     <B>protocol</B><A name="udpPortAddress.1.protocol.2(63)"></A><A name="protocol.2(63)"></A>::&lt; (# do commProtocol_udp -&gt; value #);
     <B>protName</B><A name="udpPortAddress.1.protName.2(64)"></A><A name="protName.2(64)"></A>::&lt; (# do commProtName_udp -&gt; t #);
  #);

<B>unixPortAddress</B><A name="unixPortAddress.1(65)"></A>: concretePortAddress
  (#
     <B>asTextPattern</B><A name="unixPortAddress.1.asTextPattern.2(66)"></A><A name="asTextPattern.2(66)"></A>::&lt; (# ... #);
     <B>pathName</B><A name="unixPortAddress.1.pathName.2(67)"></A><A name="pathName.2(67)"></A>: @text;
     <B>protocol</B><A name="unixPortAddress.1.protocol.2(68)"></A><A name="protocol.2(68)"></A>::&lt; (# do commProtocol_unix -&gt; value #);
     <B>protName</B><A name="unixPortAddress.1.protName.2(69)"></A><A name="protName.2(69)"></A>::&lt; (# do commProtName_unix -&gt; t #);
  #);

(* Mac communication port address
 * ==============================
 *
 * Represents a PPC ToolBox session.
 *)
<B>ppcPortAddress</B><A name="ppcPortAddress.1(70)"></A>: concretePortAddress
  (#
     <B>host</B><A name="ppcPortAddress.1.host.2(71)"></A><A name="host.2(71)"></A>: @text;
     <B>portNo</B><A name="ppcPortAddress.1.portNo.2(72)"></A><A name="portNo.2(72)"></A>: @integer;
     <B>sessionId</B><A name="ppcPortAddress.1.sessionId.2(73)"></A><A name="sessionId.2(73)"></A>: @integer;
     <B>asTextPattern</B><A name="ppcPortAddress.1.asTextPattern.2(74)"></A><A name="asTextPattern.2(74)"></A>::&lt; (# ... #);
     <B>protocol</B><A name="ppcPortAddress.1.protocol.2(75)"></A><A name="protocol.2(75)"></A>::&lt; (# do commProtocol_ppc -&gt; value #);
     <B>protName</B><A name="ppcPortAddress.1.protName.2(76)"></A><A name="protName.2(76)"></A>::&lt; (# do commProtName_ppc -&gt; t #);
  #);

(* Shared memory buffer port address
 * =================================
 * 
 * Corresponding communication support NOT IMPLEMENTED.
 * Could be very fast, perhaps for communicating within
 * one process, using the same source code as for remote
 * communication.
 *)
<B>memPortAddress</B><A name="memPortAddress.1(77)"></A>: concretePortAddress
  (#
     <B>bufferID</B><A name="memPortAddress.1.bufferID.2(78)"></A><A name="bufferID.2(78)"></A>: @integer; (* !!! This may have to change *)
     <B>asTextPattern</B><A name="memPortAddress.1.asTextPattern.2(79)"></A><A name="asTextPattern.2(79)"></A>::&lt; (# ... #);
     <B>protocol</B><A name="memPortAddress.1.protocol.2(80)"></A><A name="protocol.2(80)"></A>::&lt; (# do commProtocol_mem -&gt; value #);
     <B>protName</B><A name="memPortAddress.1.protName.2(81)"></A><A name="protName.2(81)"></A>::&lt; (# do commProtName_mem -&gt; t #);
  #);

(* IPv4 Miscellaneous address conversions *)

(* Look up the IPv4 address of a given host. *)
<B>gethostbyname</B><A name="gethostbyname.1(82)"></A>:
  (#
     <B>notfound</B><A name="gethostbyname.1.notfound.2(83)"></A><A name="notfound.2(83)"></A>:&lt; Exception;
     <B>name</B><A name="gethostbyname.1.name.2(84)"></A><A name="name.2(84)"></A>: ^Text;     
     <B>inadr</B><A name="gethostbyname.1.inadr.2(85)"></A><A name="inadr.2(85)"></A>: @Integer; 
  enter name[]
  ...
  exit inadr
  #);

(* Find the name and IPv4 address of this host. *)
<B>thisHost</B><A name="thisHost.1(86)"></A>:
  (# <B>name</B><A name="thisHost.1.name.2(87)"></A><A name="name.2(87)"></A>: ^Text;
     <B>inadr</B><A name="thisHost.1.inadr.2(88)"></A><A name="inadr.2(88)"></A>: @Integer;
     <B>err</B><A name="thisHost.1.err.2(89)"></A><A name="err.2(89)"></A>: @Integer; (* Private *)
     ...
  exit (name[], inadr)
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Commaddress Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
