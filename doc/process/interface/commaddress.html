<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Commaddress Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="commpipe.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="binarysocket.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Commaddress Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'processaddress' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1994-97
 *       All rights reserved.
 *)

BODY 'private/commaddressbody';

(* CONTENTS
 * ========
 *
 * Defines patterns for representing communication addresses.
 *
 * The most abstract pattern, portableCommAddress, models a
 * portable communication address. This specifies the address
 * of a single destination or the address(es) of a group of
 * destinations.
 *
 * The patterns portableMultiAddress and portablePortAddress
 * specialize portableCommAddress into concrete patterns for
 * the multiple-destination case and one-destination case,
 * respectively.
 *
 * The pattern concretePortAddress and its specializations
 * represent non-portable, protocol specific communication
 * port addresses. These are kept in portableCommAddresses
 * and selected according to protocol specifications, given
 * as protocolSpec objects.
 * 
 * As a best-fit addition, there are also some patterns
 * to aid the process of looking up TCP/IP hosts, getting the
 * hostname of this machine, etc.
 * 
 *)

--- lib:attributes ---
(* Reliability
 * ===========
 *
 * Used to specify the reliability proporties
 * required for a transfer (in a protocolSpec).
 * The proporties are additive. 
 *)

<B>commRely_dontcare</B><A name="commRely_dontcare.1(48)"></A>:   (# exit 0 #);
<B>commRely_loss</B><A name="commRely_loss.1(49)"></A>:       (# exit 2 #); (* packets are not lost *)
<B>commRely_dup</B><A name="commRely_dup.1(50)"></A>:        (# exit 4 #); (* packets are not duplicated *)
<B>commRely_order</B><A name="commRely_order.1(51)"></A>:      (# exit 8 #); (* packets arrive 
                                    * in correct order *)
<B>commRely_contents</B><A name="commRely_contents.1(52)"></A>:   (# exit 16 #); (* corrupt data unlikely 
                                     * (e.g. checksum) *)

<B>commRely_unreliable</B><A name="commRely_unreliable.1(53)"></A>: (# exit 1 #); (* ensures none of the above *)
<B>commRely_reliable</B><A name="commRely_reliable.1(54)"></A>:   (# exit 31 #); (* ensure loss, dup, 
                                     * order &amp; contents *)

(* Type of connection protocol
 * ===========================
 *
 * OS level category of connection. An implementation
 * level description of an individual connection
 * managed by a connectionPool. Weird numbers chosen
 * to make data containing these constants recognizable
 * in a raw communication dump.
 *)

<B>commProtocol_dontcare</B><A name="commProtocol_dontcare.1(55)"></A>:   (# exit 0 #);
<B>commProtocol_tcp</B><A name="commProtocol_tcp.1(56)"></A>:        (# exit 72301 #); (* TCP/IP *)
<B>commProtocol_udp</B><A name="commProtocol_udp.1(57)"></A>:        (# exit 72302 #); (* UDP/IP *)
<B>commProtocol_unix</B><A name="commProtocol_unix.1(58)"></A>:       (# exit 72303 #); (* UNIX domain 
                                            * (socket as file) *)
<B>commProtocol_ppc</B><A name="commProtocol_ppc.1(59)"></A>:        (# exit 72304 #); (* Mac PPC ToolBox *)
<B>commProtocol_mem</B><A name="commProtocol_mem.1(60)"></A>:        (# exit 72305 #); (* Shared memory buffer *)

(* Mnemonic names of the protocols *)
<B>commProtName_tcp</B><A name="commProtName_tcp.1(61)"></A>:        (# exit 'TCP' #);
<B>commProtName_udp</B><A name="commProtName_udp.1(62)"></A>:        (# exit 'UDP' #);
<B>commProtName_unix</B><A name="commProtName_unix.1(63)"></A>:       (# exit 'UNIX' #);
<B>commProtName_ppc</B><A name="commProtName_ppc.1(64)"></A>:        (# exit 'PPC' #);
<B>commProtName_mem</B><A name="commProtName_mem.1(65)"></A>:        (# exit 'MEM' #);

(* Specification of connection requirements
 * ========================================
 *
 * Used to package spec. of requirements to a communication
 * transfer, and then given to a portablePortAddress, which
 * will use it when choosing an appropriate channel.
 *)
<B>protocolSpec</B><A name="protocolSpec.1(66)"></A>:
  (#
     <B>cType</B><A name="protocolSpec.1:cType.2(67)"></A><A name="cType.2(67)"></A>: @integer; (* one of 'commProtocol_.*'
                       * dontcare is default *)
     <B>rType</B><A name="protocolSpec.1:rType.2(68)"></A><A name="rType.2(68)"></A>: @integer; (* one of 'commRely_.*'
                       * dontcare is default *)
     (* bandwidth/r-rr-rra/etc *)
  enter (cType, rType)
  exit cType
  #);

(* Portable communication address
 * ==============================
 *
 * Specifies identity of an abstract communication address.
 * This pattern is abstract, and no instances of it are
 * expected to exist. The patterns portableMultiAddress and
 * portablePortAddress are non-abstract specializations.
 *
 * Any portableCommAddress is able to express its value
 * in textual form, by 'asText'.
 * 
 * Tell a portableCommAddress what proporties are required
 * of the communications associated with it by entering
 * a protocolSpec object. This affects its choice of
 * concrete communication port(s) in subsequent
 * communications.
 *)
<B>portableCommAddress</B><A name="portableCommAddress.1(69)"></A>:
  (#
     <B>init</B><A name="portableCommAddress.1:init.2(70)"></A><A name="init.2(70)"></A>:&lt; Object;
     <B>asText</B><A name="portableCommAddress.1:asText.2(71)"></A><A name="asText.2(71)"></A>: @asTextPattern;

     (* private *)
     <B>asTextPattern</B><A name="portableCommAddress.1:asTextPattern.2(72)"></A><A name="asTextPattern.2(72)"></A>:&lt; (# t: ^text do INNER exit t[] #);
     <B>enterSpec</B><A name="portableCommAddress.1:enterSpec.2(73)"></A><A name="enterSpec.2(73)"></A>: @...;
     <B>private</B><A name="portableCommAddress.1:private.2(74)"></A><A name="private.2(74)"></A>: @...;
  enter enterSpec
  #);

(* Portable communication address constructor
 * ==========================================
 *
 * Function. Takes a text value, which is expected to have
 * been produced by some instance X of a specialization of
 * portableCommAddress using its 'asText'. Returns an object
 * with the same value as X.
 *
 * Problems are reported by invoking 'parseError'. The 
 * application will then terminate with an exception,
 * unless you furtherbind parseError to leave it.
 *)
<B>portableCommAddressFromText</B><A name="portableCommAddressFromText.1(75)"></A>:
  (# 
     <B>parseError</B><A name="portableCommAddressFromText.1:parseError.2(76)"></A><A name="parseError.2(76)"></A>:&lt;
       (# msg: ^text;
       enter msg[]
       ...
       #);
     <B>txt</B><A name="portableCommAddressFromText.1:txt.2(77)"></A><A name="txt.2(77)"></A>: ^text;
     <B>addr</B><A name="portableCommAddressFromText.1:addr.2(78)"></A><A name="addr.2(78)"></A>: ^portableCommAddress;
     &lt;&lt;SLOT portableCommAddressFromTextLib:attributes&gt;&gt;;
  enter txt[]
  ...
  exit addr[]
  #);

(* Portable multicast address
 * ==========================
 *
 * Specifies identities of the members of a group of
 * communication destinations.
 *
 * The group can be built from scratch or enhanced
 * by 'insert'ing members. It can be reduced by
 * 'delete'ing members. 
 *)
<B>portableMultiAddress</B><A name="portableMultiAddress.1(79)"></A>: portableCommAddress
  (#
     <B>init</B><A name="portableMultiAddress.1:init.2(80)"></A><A name="init.2(80)"></A>::&lt; (# ... #);

     <B>insert</B><A name="portableMultiAddress.1:insert.2(81)"></A><A name="insert.2(81)"></A>:
       (# addr: ^portablePortAddress;
       enter addr[]
       ...
       #);

     <B>delete</B><A name="portableMultiAddress.1:delete.2(82)"></A><A name="delete.2(82)"></A>:
       (# addr: ^portablePortAddress;
       enter addr[]
       ...
       #);
     
     (* private *)
     <B>asTextPattern</B><A name="portableMultiAddress.1:asTextPattern.2(83)"></A><A name="asTextPattern.2(83)"></A>::&lt; (# ... #);
     <B>private2</B><A name="portableMultiAddress.1:private2.2(84)"></A><A name="private2.2(84)"></A>: @...;
  #);

(* Portable communication port address
 * ===================================
 *
 * Specifies identity of one logical communication destination.
 * A logical destination corresponds to a number of concrete
 * communication ports, represented by instances of
 * specializations of concretePortAddress.
 *
 * A portablePortAddress can be built from scratch by
 * by 'insert'ing such instances. Only one concrete address
 * is allowed for each known type - inserting a second instance
 * overrides the previously inserted one. 
 *)
<B>portablePortAddress</B><A name="portablePortAddress.1(85)"></A>: portableCommAddress
  (#
     <B>insert</B><A name="portablePortAddress.1:insert.2(86)"></A><A name="insert.2(86)"></A>:
       (# addr: ^concretePortAddress;
          addrHasUnknownType:&lt; exception;
       enter addr[]
       ...
       #);
     <B>delete</B><A name="portablePortAddress.1:delete.2(87)"></A><A name="delete.2(87)"></A>:
       (# prot: @integer; (* one of 'commProtocol_.*' *)
          addrHasUnknownType:&lt; exception;
       enter prot
       ...
       #);
     <B>getTcpPort</B><A name="portablePortAddress.1:getTcpPort.2(88)"></A><A name="getTcpPort.2(88)"></A>:
       (# addr: ^tcpPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getUdpPort</B><A name="portablePortAddress.1:getUdpPort.2(89)"></A><A name="getUdpPort.2(89)"></A>:
       (# addr: ^udpPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getUnixPort</B><A name="portablePortAddress.1:getUnixPort.2(90)"></A><A name="getUnixPort.2(90)"></A>:
       (# addr: ^unixPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getPpcPort</B><A name="portablePortAddress.1:getPpcPort.2(91)"></A><A name="getPpcPort.2(91)"></A>:
       (# addr: ^ppcPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);
     <B>getMemPort</B><A name="portablePortAddress.1:getMemPort.2(92)"></A><A name="getMemPort.2(92)"></A>:
       (# addr: ^memPortAddress;
       ...
       exit addr[] (* NONE if not present *)
       #);

     (* private *)
     <B>asTextPattern</B><A name="portablePortAddress.1:asTextPattern.2(93)"></A><A name="asTextPattern.2(93)"></A>::&lt; (# ... #);
     <B>private2</B><A name="portablePortAddress.1:private2.2(94)"></A><A name="private2.2(94)"></A>: @...;
  #);

(* Concrete communication port address
 * ===================================
 *
 * Abstract superpattern for specifying the address
 * of a concrete communication port, such as a UN*X
 * stream socket, a Mac PPC ToolBox session, a shared
 * memory buffer etc.
 *
 * Is able to express its value textually with 'asText',
 * and to characterize its communication protocol
 * with 'commType'. 
 *)
<B>concretePortAddress</B><A name="concretePortAddress.1(95)"></A>:
  (#
     <B>asText</B><A name="concretePortAddress.1:asText.2(96)"></A><A name="asText.2(96)"></A>: @asTextPattern;
     <B>asTextPattern</B><A name="concretePortAddress.1:asTextPattern.2(97)"></A><A name="asTextPattern.2(97)"></A>:&lt; (# t: ^text do INNER exit t[] #);
     
     <B>protocol</B><A name="concretePortAddress.1:protocol.2(98)"></A><A name="protocol.2(98)"></A>:&lt; integerValue; (* one of 'commProtocol_.*' *)
     <B>protName</B><A name="concretePortAddress.1:protName.2(99)"></A><A name="protName.2(99)"></A>:&lt; (# t: ^text do &amp;text[] -&gt; t[]; INNER exit t[] #);
     <B>conformsTo</B><A name="concretePortAddress.1:conformsTo.2(100)"></A><A name="conformsTo.2(100)"></A>: BooleanValue
       (# p: @integer;
       enter p
       ...
       #);
     <B>private</B><A name="concretePortAddress.1:private.2(101)"></A><A name="private.2(101)"></A>: @...;
  #);

(* Unix communication port address types
 * =====================================
 *
 * The pattern unixAbstractPortAddress captures similarities
 * between TCP and UDP ports, represented by
 * tcpPortAddress and udpPortAddress. 
 *
 * The pattern unixPortAddress represents an AF_UNIX address
 * family socket, i.e. it appears as a name in some directory,
 * just like a file. 
 * 
 * NB: The tcpPortAddress also fits a MacTCP port.
 *)
<B>unixAbstractPortAddress</B><A name="unixAbstractPortAddress.1(102)"></A>: concretePortAddress
  (#
     <B>inetAddr</B><A name="unixAbstractPortAddress.1:inetAddr.2(103)"></A><A name="inetAddr.2(103)"></A>: @integer;
     <B>portNo</B><A name="unixAbstractPortAddress.1:portNo.2(104)"></A><A name="portNo.2(104)"></A>: @integer;
     <B>asTextPattern</B><A name="unixAbstractPortAddress.1:asTextPattern.2(105)"></A><A name="asTextPattern.2(105)"></A>::&lt; (# ... #);
  #);

<B>tcpPortAddress</B><A name="tcpPortAddress.1(106)"></A>: unixAbstractPortAddress
  (#
     <B>protocol</B><A name="tcpPortAddress.1:protocol.2(107)"></A><A name="protocol.2(107)"></A>::&lt; (# do commProtocol_tcp -&gt; value #);
     <B>protName</B><A name="tcpPortAddress.1:protName.2(108)"></A><A name="protName.2(108)"></A>::&lt; (# do commProtName_tcp -&gt; t #);
  #);

<B>udpPortAddress</B><A name="udpPortAddress.1(109)"></A>: unixAbstractPortAddress
  (#
     <B>protocol</B><A name="udpPortAddress.1:protocol.2(110)"></A><A name="protocol.2(110)"></A>::&lt; (# do commProtocol_udp -&gt; value #);
     <B>protName</B><A name="udpPortAddress.1:protName.2(111)"></A><A name="protName.2(111)"></A>::&lt; (# do commProtName_udp -&gt; t #);
  #);

<B>unixPortAddress</B><A name="unixPortAddress.1(112)"></A>: concretePortAddress
  (#
     <B>asTextPattern</B><A name="unixPortAddress.1:asTextPattern.2(113)"></A><A name="asTextPattern.2(113)"></A>::&lt; (# ... #);
     <B>pathName</B><A name="unixPortAddress.1:pathName.2(114)"></A><A name="pathName.2(114)"></A>: @text;
     <B>protocol</B><A name="unixPortAddress.1:protocol.2(115)"></A><A name="protocol.2(115)"></A>::&lt; (# do commProtocol_unix -&gt; value #);
     <B>protName</B><A name="unixPortAddress.1:protName.2(116)"></A><A name="protName.2(116)"></A>::&lt; (# do commProtName_unix -&gt; t #);
  #);

(* Mac communication port address
 * ==============================
 *
 * Represents a PPC ToolBox session.
 *)
<B>ppcPortAddress</B><A name="ppcPortAddress.1(117)"></A>: concretePortAddress
  (#
     <B>host</B><A name="ppcPortAddress.1:host.2(118)"></A><A name="host.2(118)"></A>: @text;
     <B>portNo</B><A name="ppcPortAddress.1:portNo.2(119)"></A><A name="portNo.2(119)"></A>: @integer;
     <B>sessionId</B><A name="ppcPortAddress.1:sessionId.2(120)"></A><A name="sessionId.2(120)"></A>: @integer;
     <B>asTextPattern</B><A name="ppcPortAddress.1:asTextPattern.2(121)"></A><A name="asTextPattern.2(121)"></A>::&lt; (# ... #);
     <B>protocol</B><A name="ppcPortAddress.1:protocol.2(122)"></A><A name="protocol.2(122)"></A>::&lt; (# do commProtocol_ppc -&gt; value #);
     <B>protName</B><A name="ppcPortAddress.1:protName.2(123)"></A><A name="protName.2(123)"></A>::&lt; (# do commProtName_ppc -&gt; t #);
  #);

(* Shared memory buffer port address
 * =================================
 * 
 * Corresponding communication support NOT IMPLEMENTED.
 * Could be very fast, perhaps for communicating within
 * one process, using the same source code as for remote
 * communication.
 *)
<B>memPortAddress</B><A name="memPortAddress.1(124)"></A>: concretePortAddress
  (#
     <B>bufferID</B><A name="memPortAddress.1:bufferID.2(125)"></A><A name="bufferID.2(125)"></A>: @integer; (* !!! This may have to change *)
     <B>asTextPattern</B><A name="memPortAddress.1:asTextPattern.2(126)"></A><A name="asTextPattern.2(126)"></A>::&lt; (# ... #);
     <B>protocol</B><A name="memPortAddress.1:protocol.2(127)"></A><A name="protocol.2(127)"></A>::&lt; (# do commProtocol_mem -&gt; value #);
     <B>protName</B><A name="memPortAddress.1:protName.2(128)"></A><A name="protName.2(128)"></A>::&lt; (# do commProtName_mem -&gt; t #);
  #);

(* IPv4 Miscellaneous address conversions *)

(* Look up the IPv4 address of a given host. *)
<B>gethostbyname</B><A name="gethostbyname.1(129)"></A>:
  (#
     <B>notfound</B><A name="gethostbyname.1:notfound.2(130)"></A><A name="notfound.2(130)"></A>:&lt; Exception;
     <B>name</B><A name="gethostbyname.1:name.2(131)"></A><A name="name.2(131)"></A>: ^Text;     
     <B>inadr</B><A name="gethostbyname.1:inadr.2(132)"></A><A name="inadr.2(132)"></A>: @Integer; 
  enter name[]
  ...
  exit inadr
  #);

(* Find the name and IPv4 address of this host. *)
<B>thisHost</B><A name="thisHost.1(133)"></A>:
  (# <B>name</B><A name="thisHost.1:name.2(134)"></A><A name="name.2(134)"></A>: ^Text;
     <B>inadr</B><A name="thisHost.1:inadr.2(135)"></A><A name="inadr.2(135)"></A>: @Integer;
     <B>err</B><A name="thisHost.1:err.2(136)"></A><A name="err.2(136)"></A>: @Integer; (* Private *)
     ...
  exit (name[], inadr)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="commpipe.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="binarysocket.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
