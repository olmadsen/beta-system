<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Basicsocket Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="binarygenerator.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Basicsocket Interface</H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/basicsystemenv';
LIB_DEF 'processbasic' '../lib';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics 1995-97
 *       All rights reserved.
 *)
INCLUDE 'errorcallback';
INCLUDE 'commaddress';

--- systemlib:attributes ---
(* Used for timeouts *)
<B>waitForever</B><A name="waitForever.1(1)"></A>: (# exit -1 #);

(* Used to make it checkable whether something is uninitialized *)
<B>assignGuard</B><A name="assignGuard.1(2)"></A>: (# <B>assigned</B><A name="assignGuard.1:assigned.2(3)"></A><A name="assigned.2(3)"></A>: @Boolean do true -&gt; assigned #);

(* The number 127.0.0.1 by convention is 'this host' *)
<B>localHost_IP_number</B><A name="localHost_IP_number.1(4)"></A>: (# exit 2130706433 #);

<B>BasicSocket</B><A name="BasicSocket.1(5)"></A>: 
  (# &lt;&lt;SLOT socketlib:attributes&gt;&gt;;

     (* OPERATIONS
      * ==========
      *)

     (* do 'this' and 'other' wrap the same OS level connection? *)
     <B>sameConnection</B><A name="BasicSocket.1:sameConnection.2(6)"></A><A name="sameConnection.2(6)"></A>: booleanValue
       (# other: ^basicSocket;
       enter other[]
       ...
       #);
     
     (* construct portable address for this connection *)
     <B>getPortableAddress</B><A name="BasicSocket.1:getPortableAddress.2(7)"></A><A name="getPortableAddress.2(7)"></A>:
       (# addr: ^portablePortAddress;
       ...
       exit addr[]
       #);

     (* Initiator of socket communication. 
      * Pass 'host' and 'port' to 'connect' to connect 
      * to a passive socket to establish communication.
      * If you need to control the local port number, 
      * use firstLocalPort and lastLocalPort. These are then 
      * tried one at a time starting with first and ending 
      * with last. None of them can be zero.
      *)
     <B>connect</B><A name="BasicSocket.1:connect.2(8)"></A><A name="connect.2(8)"></A>: open
       (# accessError:&lt; loErrCB(# do INNER #);
          resourceError:&lt; loErrCB(# do INNER #);
          addressError:&lt; loErrCB(# do INNER #);
          refusedError:&lt; loErrCB(# do INNER #);
          intrError:&lt; loErrCB(# do INNER #);
          getHostError:&lt; loErrCB(# do INNER #);
          firstLocalPort:&lt;IntegerValue;
          lastLocalPort:&lt;IntegerValue;
          aHost: ^Text;
          aPort: @Integer;
       enter (aHost[],aPort)
       ...
       #);
     
     (* provoke a timeout error in the current operation *)
     <B>forceTimeout</B><A name="BasicSocket.1:forceTimeout.2(9)"></A><A name="forceTimeout.2(9)"></A>:&lt; (# ... #);

     (* return timestamp of latest operation on this socket *)
     <B>usageTimestamp</B><A name="BasicSocket.1:usageTimestamp.2(10)"></A><A name="usageTimestamp.2(10)"></A>:&lt; integerValue
       (# ... #);
     
     (* return true iff no data is 
      * immediately available for reading 
      *)
     <B>endOfDataPattern</B><A name="BasicSocket.1:endOfDataPattern.2(11)"></A><A name="endOfDataPattern.2(11)"></A>:
       (# error:&lt; hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if value=errCB_initialValue then
                   (value,cleanup[])-&gt;this(basicSocket).error-&gt;value;
               if);
            #);
          loErrCB: errCB (* superpattern for 
                          * concrete error callbacks *)
            (#
            do INNER;
               (if value=errCB_initialValue then
                   (value,cleanup[])-&gt;error-&gt;value;
               if);
            #);
          connBrokenError:&lt; loErrCB(# do INNER #);
          internalError:&lt; loErrCB(# do INNER #);
          unknownError:&lt; loErrCB(# do INNER #);
          value: @boolean;
       ...
       exit value
       #);

     (* Close socket completely. Any further operations are
      * disallowed and the other end gets EOS if it tries *)
     <B>close</B><A name="BasicSocket.1:close.2(12)"></A><A name="close.2(12)"></A>: withIdle(# ... #);

     (* Close socket partially. closeRead makes further reads
      * at this end of the socket and further writes at
      * the other end fail with EOS. *)
     <B>closeRead</B><A name="BasicSocket.1:closeRead.2(13)"></A><A name="closeRead.2(13)"></A>: (# ... #);
     
     (* Close socket partially. closeWrite makes further writes
      * at this end of the socket and further reads at
      * the other end fail with EOS. *)
     <B>closeWrite</B><A name="BasicSocket.1:closeWrite.2(14)"></A><A name="closeWrite.2(14)"></A>: (# ... #);
     
     (* CALLBACKS
      * =========
      *)

     (* every local 'idle' executes this global one *)
     <B>idle</B><A name="BasicSocket.1:idle.2(15)"></A><A name="idle.2(15)"></A>:&lt; Object;

     (* socket level error callback *)
     <B>error</B><A name="BasicSocket.1:error.2(16)"></A><A name="error.2(16)"></A>:&lt; hiErrCB(# do INNER #);

     (* EXPLICIT SCHEDULING
      * ===================
      *)

     (* NB: don`t 'leave' a 'nonBlockingScope'. Use 'leaveNBScope'. *)
     <B>nonBlockingScope</B><A name="BasicSocket.1:nonBlockingScope.2(17)"></A><A name="nonBlockingScope.2(17)"></A>: (# ... #);
     <B>leaveNBScope</B><A name="BasicSocket.1:leaveNBScope.2(18)"></A><A name="leaveNBScope.2(18)"></A>: (# ... #);

     (* ATTRIBUTES
      * ==========
      *)

     <B>host</B><A name="BasicSocket.1:host.2(19)"></A><A name="host.2(19)"></A>: @assignGuard(# t: @text; enter t exit t #);
     <B>port</B><A name="BasicSocket.1:port.2(20)"></A><A name="port.2(20)"></A>: @assignGuard(# rep: @integer enter rep exit rep #);
     <B>inetAddr</B><A name="BasicSocket.1:inetAddr.2(21)"></A><A name="inetAddr.2(21)"></A>: @assignGuard(# rep: @integer enter rep exit rep #);

     (* AUXILIARY PATTERNS
      * ==================
      *)

     <B>withPE</B><A name="BasicSocket.1:withPE.2(22)"></A><A name="withPE.2(22)"></A>:
       (# error:&lt; hiErrCB (* operation level error callback *)
            (#
            do INNER;
               (if value=errCB_initialValue then
                   (value,cleanup[])-&gt;this(basicSocket).error-&gt;value;
               if);
            #);
          loErrCB: errCB (* superpattern for 
                          * concrete error callbacks *)
            (#
            do INNER;
               (if value=errCB_initialValue then
                   (value,cleanup[])-&gt;error-&gt;value;
               if);
            #);
          timedOut:&lt; loErrCB(# do INNER #);
          timedOutInTransfer:&lt; loErrCB(# do INNER #);
          internalError:&lt; loErrCB(# do INNER #);
          connBrokenError:&lt; loErrCB(# do INNER #);
          usageError:&lt; loErrCB(# do INNER #);
          unknownError:&lt; loErrCB(# do INNER #);
          resourceError:&lt; loErrCB(# do INNER #);
          badMsgError:&lt; loErrCB(# do INNER #);
          timeout: @integer;
       enter timeout
       do INNER
       #);

     <B>withIdle</B><A name="BasicSocket.1:withIdle.2(23)"></A><A name="withIdle.2(23)"></A>: withPE
       (# idle:&lt; (# do INNER; this(basicSocket).idle #);
          blocking:&lt;(# continue: (# do true-&gt;doContinue #);
               doContinue: @boolean;
            do INNER;
               (if not doContinue then leaveNBScope if);
               idle;
            #);
       do INNER
       #);

     <B>open</B><A name="BasicSocket.1:open.2(24)"></A><A name="open.2(24)"></A>: withIdle(# ... #);
     <B>init</B><A name="BasicSocket.1:init.2(25)"></A><A name="init.2(25)"></A>:&lt; (# ... #);

     <B>private</B><A name="BasicSocket.1:private.2(26)"></A><A name="private.2(26)"></A>: @...;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="binarygenerator.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
