<H1> <A NAME=MARKER-9-18></A><A NAME=MARKER-8-19></A>Communicating with other Processes</H1>

<H2> <A NAME=MARKER-7-1>Communication Concepts</A></H2>
 Inter-process communication<A NAME=MARKER-2-20></A> is usually described as <B>message based</B> or as <B>connection based</B>. In both cases, any primitive communication act has a number of participants, playing roles as the receiving or the transmitting end. In this context, there will always be exactly one transmitting party and one receiving party. There is support for specifying a group address, but there is not currently any ready-made implementation of a group communication protocol.<P>
 For a message based communication, each message is sent to an explicitly specified receiver. For a connection based communication, at first a connection between two parties is established. From that point, messages can be transmitted via this connection without any explicit reference to their destination. Here, the model of communication is connection oriented.<P>

 For operating systems that support a notion of standard channels for receiving input and delivering output and possibly other things, it is possible for the communicating processes to be unaware (i.e. independent) of the fact that standard input comes from another process or that standard output goes to another process: It all looks the same as if the data came from a keyboard and went to a display or whatever. On the other hand, this level of abstraction implies that the connection lifetime will be the lifetime of the process and that there cannot be more connections than standard channels. Like standard output and standard input, each connection only supports sending data in one direction. Pipes establish this kind of connections. Use the pattern pipe.<P>

 To implement more elaborate patterns of communication, one must be able to create and destroy connections during the execution of a process, and to explicitly choose with whom to communicate. Sockets are used for this, and with sockets, every connection is two-way. Sockets come in two main variants: passive and active. A passive socket is used to define a name, which may be used by active sockets when establishing an actual connection. The interplay is like:<P>
<PRE CLASS=beta>
Passive: &quot;Here I am! My name is Bob&quot;
...
Active-1: &quot;I want to speak with Bob&quot;
Passive(Bob): &quot;OK, here's a connection&quot;
...
Active-2: &quot;I want to speak with Bob&quot;
Passive(Bob): &quot;OK, here's a connection&quot;
...
Active-3: &quot;I want to speak with Cindy&quot;
(Error: Here's no such thing as &quot;Cindy&quot;)
...
</PRE>
 I.e. active sockets connect by name, and more than one connection may be
established by means of one passive socket. The <B>name</B> is actually a
pair whose first part is an identification of the host (its IP address) and
whose second part is an integer (the port number). This pair is unique for
each passive socket, at least from the time where the operating system
accepts registration of the name until the passive socket is closed. After
that, the pair may be reused, that is: the port number may be reused on the
given host, if the operating system wishes to do so.<P>
 In this library, sockets are also divided along another axis, namely into
stream sockets and binary sockets. Stream sockets are specializations of
the basic stream pattern, and support textual communication. Binary sockets
support transfers of blocks of data with a well-known size.<P>
 The patterns related to these concepts are: StreamSocket<A
NAME=MARKER-2-23></A>, BinarySocket<A NAME=MARKER-2-24></A> and
SocketGenerator<A NAME=MARKER-2-25></A>. SocketGenerators are used to
accept incoming connection requests. When a request arrives, a new socket
of the specified type is created and connected to the requesting party.<P>




