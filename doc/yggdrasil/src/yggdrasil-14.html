<H2><INX>Constructing a Grammar</INX></H2>
<P>We are assuming that an ordinary context-free grammar is given for the selected language. Strategies for constructing such a grammar can be found in most textbooks, that deal with compiler construction. In order for the grammar to be useful, it has to fullfill the following requirements:</P>
<OL>
<LI> The grammar must be converted into a structured context-free grammar. Since any context-free grammar can be converted into a structured grammar, this step should not cause major difficulties (except possibly for the restriction that the resulting hierarchy must be tree-structured, as discussed in chapter 2).
<LI> The resulting structured context-free grammar has to be LALR(1). This requirement may be ignored, if there is no need for generating a parser for that language (i.e. all programs in that language will be manipulated, using the editor and the meta programming system). Unless otherwise explicitly noted, we will, in the following, always be refering to the structured context-free grammar when we are discussing the grammar.
<LI> Along with the grammar, several additional properties of the grammar need to be specified, namely unused predefined nonterminals, the comment symbols of the grammar, the string symbol of the grammar, etc. All these options are described in chapter 6. We will discuss here only the most commonly used options.
</OL>
<P> The grammar definition is divided into five parts: the <INX>fragment part</INX>, the <INX>naming part</INX>, the <INX>options part</INX>, the <INX>rules part</INX>, and the <INX>attributes part</INX>: The naming part specifies the name of the grammar, the options part specifies the valid options of that grammar, the rules part contains the productions of the grammar, and the attributes part specifies for each nonterminal, the number of semantic attributes defined at the semantic level for that nonterminal. The options part and the attributes part are optional parts and may thus be absent from the grammar definition. The meta grammar describing the language for grammar specification is given in appendix 1. </P>
<A NAME=HEADING14-6></A>
<H3>The <INX>Fragment Part</INX></H3>
<P> In order to make the grammar specification readable for the various grammar tools, it must start with a fragment form specification.  The format of a fragment form specification for a grammar is:</P>
<BETA>
-- name: aGrammar: metagrammar --
</BETA>
<P> where name must be the name chosen for this grammar. </P>
<A NAME=HEADING14-10></A>
<H3>The <INX>Naming Part</INX></H3>
<P> The grammar definition must begin by naming the grammar. This is done in the naming part of the grammar. The naming part consists of one clause: </P>
<BETA>
Grammar name: 
</BETA>
<P> where name must be the name chosen for this grammar. </P>
<A NAME=HEADING14-14></A>
<H3>The <INX>Options Part</INX></H3>
<P> The options part of the grammar contains various settings of variables, that control the way in which the grammar processor treats the productions in the rules part, and other issues. </P>
<P> Each option is specified by the name of the option followed by &quot;=&quot; followed by the value of the option. The valid options are:</P>
<UL>
<LI> <INX>version</INX>: Defines the version number of the grammar. The version number is used by the meta programming system to ensure that different AST's handled in a meta program are using the same version of the grammar. Default is 'undefined'.
<LI> <INX>astVersion</INX>: Defines the version of the metaprogramming system to be used for this grammar. Default is the same version as the version used for the generator.
<LI> <INX>comBegin</INX>: Defines the string that signifies a beginning of comment in the language of the grammar. Default is '(*'.
<LI> <INX>comEnd</INX>: Defines the string that signifies the end of comment in the language of the grammar. If the string is the empty string, end of line acts as the comment end string. Default is '*)'
<LI> <INX>stringChar</INX>: Defines the string literal enclosing symbol (e.g. in a Pascal grammar, stringChar will be &quot;). containing programs, written in the language of this grammar. Default is ' (single quote)
<LI> <INX>Unused Lexem Terminals</INX>: If not all lexem terminals (e.g. &lt;nameApp&gt; are used in the grammar, these should be marked as unused. This is done by using the name of the lexem terminal as the option name and associate the value unused to it (e.g nameApp = unused). Default is none.
<LI> <INX>substanceSlot</INX>: Specifies an identifiers: id. The result of specifying this identifier is, tha the metaprogramming system will generate the following attribute in the generared context-free interface fragment: id: &lt;&lt;SLOT id: descritor&gt;&gt;.
<LI> <INX>subOf</INX>: Specifies the pattern name to be used as the superpattern for the context free level patterns. Default is 'treelevel'.
<LI> <INX>BobsOptions</INX>: String containing a comma separated list of options to be passed to the BOBS compiler-compiler. Default is '32,34,59'.
<LI> <INX>splitOnFiles</INX>: Specifies that the generated BETA patterns, interfacing to the context free level should be split on the given number of files. Default is 1.
<LI> <INX>suffix</INX>: Defines the file name suffix, that is expected on files, containing programs in the syntax of this grammar. Default is '.text'.
<LI> <INX>startsymbol</INX>: Defines the startsymbol of the grammar. If no startsymbol option is defined for the grammar, the nonterminal on the left-hand side of the first production of the rules part of the grammar is chosen as the startsymbol of the grammar.
</UL>
<A NAME=HEADING14-29></A>
<H3>The <INX>Rules Part</INX></H3>
<P> The rules part of the grammar contains the specifications of the productions of the grammar. </P>
<P> The productions must follow the structure of a structured context-free grammar, as described ealier. Terminals have the form 'w', i.e. a string enclosed in single quotes (e.g. 'enter'). Nonterminals has either the form &lt;A&gt; or &lt;t:A&gt;, where t is a tag-name, and A is the syntactical category. If no tag-name is provided, the name of the syntactic category is used as the default tag-name.</P>
<P> The complete grammar must be LALR(1), if a parser needs to be generated by the metaprogramming system.</P>
<A NAME=HEADING14-33></A>
<H3>The <INX>Attributes Part</INX></H3>
<P> The attributes part of the grammar is a specification of the additional memory, the metaprogramming system needs to allocate in order to be able to handle the semantic attributes defined at the semantic level of the grammar. </P>
<P> The attributes part is a list of </P>
<BETA>
<nonterminalName>: number
</BETA>
<P>  <BR>where &lt;nonterminalName&gt; is the name of a nonterminal of the grammar, and number is the size of the semantic attributes defined for this nonterminal. These semantic attributes are saved as part of the AST, when it is stored on some file. Please note, that for efficiency reasons, the number of attributes must be even (or zero). </P>
<P> As a side effect of specifying the nonterminal in the attributes part, that the generated context-free level interface pattern for that pattern will contain an attributes slot: </P>
<BETA>
<<SLOT nonterminalNameAttributes: attributes>>
</BETA>
<A NAME=HEADING14-40></A>
<H3>An <INX>Example Grammar</INX></H3>
<P> The following grammar will be used in the following to illustrate the various tools:</P>
<P> </P>
<BETA>
-- mylang: aGrammar: metagrammar --
grammar mylang:
rule
<module>        ::= 'module' <module:id> ';' <importOpt>
                    'begin' <statement> 'end';
<id>            ::= <nameDecl>;
<importOpt>     ::? <import>;
<import>        ::= 'import' <nameList> ';';
<nameList>      ::+ <nameDecl> ',';
<statement>     ::| <if> | <while> | <procCall>;
<if>            ::= 'if' <condition:exp>
                    'then' <thenPart:statement>
                    'else' <elsePart:statement> 'endif';
<while>         ::= 'while' <condition:exp>
                    'do' <statementList> 'end';
<statementList> ::* <statement> ';';
<exp>           ::| <expProcCall> | <text> | <number>;
<text>          ::= <string>;
<number>        ::= <const>;
<expProcCall>   ::= <procCall>;
<procCall>      ::= <nameAppl> '(' ')'
</BETA>





