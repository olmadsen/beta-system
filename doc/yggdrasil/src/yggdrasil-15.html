<H1> <A NAME="LINK-yggdrasil-_Toc364700515"><A NAME=MARKER-9-134></A>Generating the Grammar-Based Information</A></H1>
<P> After having constructed the grammar, several grammar analysis tools needs to be invoked in order to analyse the grammar and generate the necessary information for the various tools. In the following discussion, we will assume the grammar is named mylang and the grammar is residing on the file mylang-meta.gram.</P>
<P> The naming conventions used here are mandatory: <BR>A grammar must reside on a file with a name that is the name of the grammar (as specified in the Grammar clause of the grammar) followed by -meta.gram. </P>
<A NAME=HEADING15-3></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700516"><A NAME=MARKER-9-136></A>Generating the Metaprogramming Interface</A></H1>
<P> In order to generate the predefined patterns that constitute the tree- and context-free level interface to the AST's generated by the grammar, we have to invoke the generator tool:</P>
<PRE CLASS=beta>
generator<A NAME=MARKER-2-138></A> mylang
</PRE>
<P> The generator checks whether the grammar is a valid structured context-free grammar, and generates the following files:</P>
<UL>
<LI> mylang-meta.ast<A NAME=MARKER-2-139></A>: This file contains an AST of the grammar itself. This AST is in accordance with the metagrammar specification given in appendix 1.
<LI> mylangcfl.bet: This file contains BETA patterns, constituting the BETA interface (as described above) to the context-free level of AST's that will be generated by the parser (or other tools, such as the editor). If the grammar options (discussed later) specify that these patterns should be split on several files, the files mylang2.bet, mylang3.bet, etc. will also exist.
<LI> mylang-parser.bobs<A NAME=MARKER-2-140></A>: This file contains the grammar in a special format to be used by the parser generator (see below).
</UL>
<A NAME=HEADING15-10></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700517"><A NAME=MARKER-9-141></A>Generating Parser and Parser Tables</A></H1>
<P> The next step is to analyse the grammar (to check that the grammar is LALR(1) and otherwise well-formed). This is done by the bobsit tool:</P>
<PRE CLASS=beta>
bobsit<A NAME=MARKER-2-143></A> mylang
</PRE>
<P> Besides analysing the grammar, the bobsit tool generates the file: </P>
<UL>
<LI> mylang-parser.btab<A NAME=MARKER-2-144></A>: This file contains the parser tables, needed by mylang-parser.bet.
</UL>
<P> Bobsit may find errors in the grammar (such as the grammar not being LALR(1), nonterminals that cannot be reached from the startsymbol, etc). If a parser is not to be used at all for the mylang grammar (i.e. all AST's of the grammar is generated by grammar-based tools) these errors may be ignored. </P>
<P> Bobsit is a revised version of the BOBS compiler generator.</P>
<A NAME=HEADING15-17></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700518"><A NAME=MARKER-9-145></A>Generating Pretty-printer Specification</A></H1>
<P> Having analysed and checked the grammar, generated the AST interface to the grammar, generated the BETA interface to the AST's of the language, and generated the parser and parser tables, the next step is to generate a pretty-printer specification for the language. This is done by the makepretty tool:</P>
<PRE CLASS=beta>
makepretty<A NAME=MARKER-2-147></A> mylang
</PRE>
<P> Makepretty generates the default pretty-printer specification for the grammar mylang on the file:</P>
<UL>
<LI> mylang-pretty.pgram<A NAME=MARKER-2-148></A>
</UL>
<P> This default pretty-printer specification is often not the best possible pretty-printer specification for the given grammar. The default pretty-printer specification is therefore often modified in order give a better reflection of the semantical structure of the language. These modifications are done manually and discussed later. </P>
<A NAME=HEADING15-23></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700519"><A NAME=MARKER-9-149></A>Generating Pretty-printer Specification Tables</A></H1>
<P> As the final step in generating the grammar-based information to be used by the various grammar-based tools, the pretty-printer specification tables need to be generated. This in done by the morepretty tool:</P>
<PRE CLASS=beta>
morepretty<A NAME=MARKER-2-151></A> mylang
</PRE>
<P> Morepretty analyses and checks the pretty-printer specification on the file mylang-pretty.pgram and generates the pretty-printer specification tables on the file:</P>
<UL>
<LI> mylang-pretty.ptbl<A NAME=MARKER-2-152></A>
</UL>
<A NAME=HEADING15-28></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700520"><A NAME=MARKER-9-153></A>Generating the Grammar-based Information Easily</A></H1>
<P> In order to make it easier to run these four tools in the right sequence, a utility tool is available:</P>
<PRE CLASS=beta>
dogram<A NAME=MARKER-2-155></A> mylang
</PRE>
<P> which runs generator, bobsit, makepretty and morepretty in that sequence.  Please note, that the dogram tool will overwrite any existing manually edited pretty-printer specifications.  If these should be retained, either run the three other tools (e.g. except makepretty) manually, or copy the manually edited pretty-printer specification file to a safe place before invoking dogram.</P>
<A NAME=HEADING15-32></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700521"><A NAME=MARKER-9-156></A>Registering the new grammar</A></H1>
<P> <A NAME=MARKER-2-158></A>The grammar is now ready for being used by the different grammar-based tools in the Mj&oslash;lner BETA System.  The grammar-based tools uses a particular searching strategy, when trying to locate the grammar to be used for interpreting a given file (textual source file, of a group file, containing the ASTs).  This searching strategy is implemented in the findGrammar<A NAME=MARKER-2-159></A> fragment, described later.  This strategy is the following:</P>
<OL>
<LI>First try to locate the grammar in the current directory.
<LI> Then try to find the grammar among the grammars specified in one of the grammar specification files:
<OL type="a">
<LI> First try among the grammars defined in the MBSgrammars.text<A NAME=MARKER-2-160></A> file located in the current directory.
<LI> Then try among the grammars defined in the MBSgrammars.text <A NAME=MARKER-2-161></A>file located in the HOME directory of the user.
<LI> Then try among the grammars defined in the MBSgrammars_DEMO.text <A NAME=MARKER-2-162></A>file located in the ~beta directory.
<LI> Finally try among the grammars defined in the MBSgrammars_STD.text <A NAME=MARKER-2-163></A>file located in the ~beta directory.
</OL>
</OL>
<P> The first grammar found in this sequence will be used.  The format of these grammar specification files are:</P>
<PRE CLASS=beta>
[[
-- INCLUDE 'filename of grammar'
-- INCLUDE 'filename of grammar'
... etc. ...
-- INCLUDE 'filename of grammar'
]]
</PRE>
<P> The filename of the grammar should not include the -meta<A NAME=MARKER-2-164></A> suffix.  If we assume that your new grammar mylang is located in the ~you/mylang directory, you can specify the grammar by inserting the following line in one of the grammar specification files:</P>
<PRE CLASS=beta>
-- INCLUDE '~you/mylang/mylang'
</PRE>
<P> In order to have your new grammar being usable by the grammar-based tools, you therefore either have to have the grammar files located in the current directory, or have the grammar specified in one of the above mentioned grammar specification files.  Since the grammarsDEMO.text and grammarsSTD.text files are located in the ~beta directory, these files will not usually be modifyable by the normal users.  You will therefore most often be specifying your grammar in one of the .MBSgrammars.text files mentioned above.</P>
<BLOCKQUOTE>
<P>Important note:  In this release, it is necessary to specify the grammar also in the file</P>
<P>MBSgrammarsExt.text </P>
<P>to make the grammar usable for the grammar-based tools (Sif, Freja, Frigg, Valhalla).</P>
</BLOCKQUOTE>
<A NAME=HEADING15-55></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700522"><A NAME=MARKER-9-165></A>Using the Pretty-printer and the Hyper-structure Editor</A></H1>
<P> After having specified your grammar, you will be able to use the new grammar with the pretty-printer <A NAME=MARKER-2-167></A>and the hyper-structure editor<A NAME=MARKER-2-168></A>.  </P>
<P> In order to make a pretty-print of the mylang program on the file tst.mylang, the pp tool must be used:</P>
<PRE CLASS=beta>
pp<A NAME=MARKER-2-169></A> tst.mylang &gt; tst.pp
</PRE>
<P> This will pretty-print the file tst.mylang (or tst.ast) and deliver the pretty-print on the file tst.pp. pp accepts two options:</P>
<UL>
<LI>-p ppSpecFile: name of a pretty-print specification to be used for this pretty-print
<LI>-d ppDepth: the depth of the AST to be pretty-printed. Can be used for making abstract interface descriptions.
</UL>
<P> The grammar is now also ready for use by the hyper-structure editor Sif in the Mjolner tool.  Usage of mylang in Sif is described in detail in the Mjolner manual <A HREF="../bibliography/index.html#mia99-34">[MIA 99-34]</A>.  However, in order to be able to utilize the automatic contraction facilities of Sif, the grammar specification needs to be augmented with one additional section, namely definition of the contractionCategories property.  This property is specified at the very beginning of the grammar specification (in the form of a fragment property).  As an example, we can define the contractionCategories property for the mylang grammar:</P>
<PRE CLASS=beta>
contractioncategories
	module
	import
	if
	while;
-- mylang: aGrammar: metagrammar --
grammar mylang:
rule
&lt;module&gt;        ::= 'module' &lt;module:id&gt; ';' &lt;importOpt&gt;
                    'begin' &lt;statement&gt; 'end';
&lt;id&gt;            ::= &lt;nameDecl&gt;;
&lt;importOpt&gt;     ::? &lt;import&gt;;

etc. as previously
</PRE>
<P> In this example, we have specified the rules module, import, if and while as the contractions categories.  This implies, that Sif automatically will contract these parts when displaying a program derived from mylang.  Please refer to the Sif.</P>
<P> Please note, that we in this example shows the entire file, including the fragment syntax needed:</P>
<PRE CLASS=beta>
-- mylang: aGrammar: metagrammar --
</PRE>
<P> Note, that aGrammar and metagrammar are mandatory names, whereas mylang can be freely chosen.</P>
<A NAME=HEADING15-77></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700523"><A NAME=MARKER-9-170></A>Modifying the Pretty-print Specification</A></H1>
<P> If you want to modify the specification, then modify the file: mylang-pretty.pgram either by means of a text editor or the pretty-print specification language-editor. After modifying the pretty-print specification morepretty is used again to create new tables for the editor. Note that if the grammar is modified, then the file mylang-pretty.pgram must be updated accordingly, e.g. a new production in the grammar might require a new production in the pretty-print specification grammar. In order to be able to modify the pretty-print specification the user must know the pretty-print algorithm.</P>
<A NAME=HEADING15-79></A>
<H2> The Pretty-print Algorithm<A NAME=MARKER-2-172></A></H2>
<P> The pretty-print algorithm is an adaptive pretty-printer, i.e. the pretty-printer always tries to print as much as possible on each line. If the pretty-printed text cannot fit on one line, the pretty-print specification tells where to break the line. For each production in the grammar, there is a specification of how to pretty-print that production. Furthermore it is indicated where to associate a possible comment. </P>
<P> The pretty-printer algorithm takes as input a stream of tokens. A token is a text string, a break or a block. </P>
<UL>
<LI> a text string is a sequence of characters
<LI> a break specifies, where a line may be broken
<LI> a block is specified by means of two delimitor tokens: [ and ].
</UL>
<P> A stream is defined by </P>
<UL>
<LI> a text string is a stream and 
<LI> if s1, s2, ... sn is a stream then [ s1 &lt;break&gt; s2 &lt;break&gt; .. &lt;break&gt; sn ] is also a stream.
</UL>
<P> The algorithm gives a text string as output. The text string has a fixed maximal width. The block concept is used in the following way: the algorithm tries to break onto different lines as few blocks as possible according to the maximal width. If a block cannot fit on one line the block has to be broken. The breaks are used to specify where to break the block. A break has a length and an indention. The length specifies the number of single space characters to be written if the block is not broken. The indention specifies the number single space characters to be written (relative to the surrounding block) at the beginning of a new line if the block is broken. </P>
<P> There exist two types of blocks: consistent and inconsistent blocks. If a consistent block cannot be written on one line the substreams of the block will be written on separate lines. I.e. all breaks in the block will imply a line break. If an inconsistent block cannot be written on one line the substreams are only written on a separate line if they cannot be written on the rest of the current line. </P>
<P> The reason for the distinction between consistent and inconsistent blocks is that one might prefer:</P>
<PRE CLASS=beta>
if &lt;&lt;condition:exp&gt;&gt; then
       &lt;&lt;thenPart:statement&gt;&gt;
else
       &lt;&lt;elsePart:statement&gt;&gt;
endif
</PRE>
to
<PRE class=beta>
if &lt;&lt;condition:exp&gt;&gt; then &lt;&lt;thenPart:statement&gt;&gt; else
&lt;&lt;elsePart:statement&gt;&gt; endif
</PRE>
and
<PRE class=beta>
import a,b,
       c
</PRE>
to<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-4">[4]</A></EM>
<PRE class=beta>
import a,
       b,
       c
</PRE>
<A NAME=HEADING15-103></A>
<H2> The Pretty-print Specification</H2>
<P> The pretty-printer is based on the algorithm just described, but because the internal representation of a document is an abstract syntax tree, the input stream to the pretty-printer algorithm must be generated from the AST. This step is called unparsing. The structure of an AST is described by means of a grammar. The pretty-print specification defines for each production in the grammar how it shall be unparsed. </P>
<P> Only those productions, that result in nodes in the AST, has a corresponding specification. The productions are constructor and list productions as described previously.</P>
<P> The grammar for pretty-print specifications is described in appendix 2. </P>
<P> The pretty-print specification of a constructor production has the following form: </P>
<PRE CLASS=beta>
&lt;Constructor&gt; ::= &lt;ProductionName:nameAppl&gt; '=' &lt;Stream:ItemList&gt;;
&lt;ItemList&gt;    ::* &lt;Item&gt;;
&lt;Item&gt;        ::| &lt;Terminal&gt; | &lt;NontTerm&gt; | &lt;Break&gt; 
                | &lt;Block&gt; | &lt;CommentPlace&gt;
</PRE>
<P> The ProductionName is the name of the syntactic category on the left side of the corresponding production in the language grammar. The items in the stream can be terminals, nonterminals, breaks, blocks or comment places: </P>
<UL>
<LI> A terminal <A NAME=MARKER-2-173></A>can be a terminal symbol from the corresponding production. This is specified by T:n, where n is the terminal number in the production. A terminal can also be an explicit terminal symbol: abc. 
<LI> A nonterminal <A NAME=MARKER-2-174></A>is referring to the nonterminal symbol in the corresponding production or, if the nonterminal has been expanded, to the underlying sub-AST. Like terminals the nonterminals are numbered (N:n). 
<LI> A break <A NAME=MARKER-2-175></A>is specified by $&lt;length&gt;,&lt;indention&gt;. The meaning of length and indention is described above. The default break $$ has length 0 and indention 1. 
<LI> A consistent block <A NAME=MARKER-2-176></A>is specified by [c ... ] and an inconsistent block is specified by [i ... ]. 
<LI> The comment place <A NAME=MARKER-2-177></A>character * is used to indicate where to pretty-print the comment that may be associated with the node (corresponding to the production) in the AST. A comment place character shall be positioned after a terminal symbol and cannot be used in a list production. 
</UL>
<P> The pretty-print specification of a list production has the following form: </P>
<PRE CLASS=beta>
&lt;ListProd&gt; ::= &lt;ProductionName:nameAppl&gt; '=' '(' &lt;ListSpec&gt; ')';
&lt;ListSpec&gt; ::= &lt;Beginning:ItemList&gt; 
               '{' &lt;BlockType&gt; &lt;Separator:ItemList&gt; '}' 
               &lt;Ending:ItemList&gt; 
</PRE>
<P> The list production specifies what is going to be pretty-printed before the list, between the list elements and after the list. A list is always surrounded by a block. Note the the block delimitors for lists are { and }. </P>
<P> The pretty-print specification must always start with a fragment form soecification (similar to the grammar specification).  For a pretty-print specification the syntax is:</P>
<PRE CLASS=beta>
-- name: prettyprint: prettyprint --
</PRE>
<P> where name must be the name chosen for this grammar. </P>
<A NAME=HEADING15-127></A>
<H2> An Example of Modifying the Pretty-print Specification</H2>
<P> As mentioned the makepretty script generates a default pretty-print specification. This section illustrates the default pretty-print specification of the sample grammar and how the specification can be improved to obtain a more &quot;pretty&quot; pretty-printing.</P>
<P> The default pretty-print specification for mylang (mylang-pretty.pgram) might looks like<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-5">[5]</A></EM>: </P>
<PRE CLASS=beta>
-- mylang: prettyprint: prettyprint --
PrettyPrintScheme mylangSpec
for mylang:
module	=  T:1 $$ * $$ N:1 $$ T:2 $$ N:2 $$ T:3 $$ N:3 $$ T:4;
id	=  N:1;
importOpt	=  N:1 ;
import	=  T:1 $$ * $$ N:1 $$ T:2;
nameList	=  ( {c T:1 $$ } );
statement	=  N:1 ;
if	=  T:1 $$ * $$ N:1 $$ T:2 $$ N:2 $$ T:3 $$ N:3 $$ T:4;
while	=  T:1 $$ * $$ N:1 $$ T:2 $$ N:2 $$ T:3;
statementList	=  ( {c T:1 $$ } );
exp	=  N:1 ;
text	=  N:1;
number	=  N:1;
expProcCall	=  N:1;
procCall	=  N:1 $$ T:1 $$ * $$ T:2
</PRE>
<P> As can be seen the default specification uses default breaks; there are no blocks except in lists; the block type of a list is consistent and only the list separator is specified; comments are only associated with constructor productions and always after the first terminal symbol. </P>
<P> Let us look at the following source file:</P>
<PRE CLASS=beta>
-- test: module: mylang --
module pip;
(* Copyright 1992*)
(* Mj&oslash;lner Informatics *)
import dyt, baat, olsen; (* some imported operations *)
begin
  while olsen() do
     if (* the test condition will be filled out later *) &lt;&lt;condition:exp&gt;&gt;
     then
        dyt()
     else if &lt;&lt;condition:exp&gt;&gt; then baat() else &lt;&lt;elsePart:statement&gt;&gt; endif
     endif;
     &lt;&lt;statement&gt;&gt;
  end
end
</PRE>
<P> Using the default pretty-printer specification as generated by the makepretty tool (see above) results in the following pretty-print<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-6">[6]</A></EM>: </P>
<PRE CLASS=beta>
-- test: module: mylang --
module (* Copyright 1992 *)
(* Mj&oslash;lner Informatics *) pip ; import
(* some imported operations *) dyt, baat, olsen ; begin while olsen ( ) do
if
(* the test condition will be filled out later *)
&lt;&lt;condition: exp&gt;&gt;
then
dyt
(
)
else
if
&lt;&lt;condition: exp&gt;&gt;
then
baat
(
)
else
&lt;&lt;elsePart: statement&gt;&gt;
endif
endif;
&lt;&lt;statement&gt;&gt; end end  
</PRE>
<P> Because there are no blocks in the specification, the pretty-printer tries to write as much as possible on each line as can be seen on the first three lines of the program. Note that no blocks in the specification has the same effect as one surrounding inconsistent block. After the third line each item is written on a separate line. This is caused by the statementList, that introduces a consistent block of statements. </P>
<P> This pretty-printing is certainly not very pretty, but only a few modifications of the specifiation improves the layout drastically. Consider the following modified specification: </P>
<PRE CLASS=beta>
-- mylang: prettyprint: prettyprint --
PrettyPrintScheme mylangSpec
for mylang:
module	=  [c [i T:1 $$ N:1 T:2 ] $$ * $$ N:2 $$ [c T:3 $1,2 N:3 $$ T:4] ];
id	=  N:1;
importOpt	=  N:1 ;
import	=  [i T:1 $$ N:1 T:2 $$ *];
nameList	=  ( {i T:1 $$ } );
statement	=  N:1 ;
if	=  [c [i T:1 $$ * $1,3 N:1 $$ T:2 ] $1,3 N:2 $$ [i T:3 $1,3 N:3] $$ T:4 ];
while	=  [c [i T:1 $$ * $$ N:1 $$ T:2 ] $1,3 N:2 $$ T:3];
statementList	=  ( {c T:1 $$ } );
exp	=  N:1 ;
text	=  N:1;
number	=  N:1;
expProcCall	=  N:1;
procCall	=  N:1 T:1 T:2 $$ *
</PRE>
<P> The test program now looks much nicer: </P>
<PRE CLASS=beta>
-- test: module: mylang --
module pip;
(* Copyright 1992 *)
(* Mj&oslash;lner Informatics *)
import dyt, baat, olsen; (* some imported operations *)
begin
  while olsen() do
     if (* the test condition will be filled out later *)
        &lt;&lt;condition: exp&gt;&gt; then
        dyt()
     else
        if &lt;&lt;condition: exp&gt;&gt; then
           baat()
        else &lt;&lt;elsePart: statement&gt;&gt;
        endif
     endif;
     &lt;&lt;statement&gt;&gt;
  end
end  
</PRE>
<P> The following changes have been made: In the module production some blocks have been introduced: one that surrounds the whole production, one that surrounds the header of the module and one that surrounds the body of the module. It is important that the block types of the first and the last block are consistent. The break between the module name and the &quot;:&quot; have been removed. The comment character have been moved. The break between the begin keyword and the &lt;statement&gt; has been changed to an indention of two characters. </P>
<P> In the nameList production, the block type has been changed to inconsistent. The import production is surrounded by an inconsistent block in order to &quot;overload&quot; the consistent block of the start production. In the if and while productions, blocks has been introduced and the indention has been changed. In the procCall production, the breaks has been removed. </P>
<P> The reader is recommended to try to understand the effect of these modifications in order to gain insight into the workings of the pretty-print specification.</P>






<HR>

<A NAME=FOOTNOTE-4>[4] </A>
 Naturally, we are assuming that the line width is not sufficient to have the entire  import a, b, c on one single line
<HR>

<A NAME=FOOTNOTE-5>[5] </A>
 This default pretty-print speficication is subject to changes. The default pretty-print specification on your system might differ from the one shown here. Especially will all construction nonterminals have consistent blocks surrounding their right-hand pretty-print specifications.
<HR>

<A NAME=FOOTNOTE-6>[6] </A>
 Since the default pretty-print specification might differ on your system, the same applies for this pretty-print example.







