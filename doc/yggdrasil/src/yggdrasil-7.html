<H1>The <INX>Context-Free Level</INX></H1>
<P>The context-free level has explicit knowledge about the grammar for the language. For each nonterminal A of the grammar, a corresponding pattern is automatically generated, depending on the defining rule for A. For each rule type described in section 2, the list below describes the corresponding generated patterns.</P>

<OL>
<LI> <INX>Alternation</INX>: A pattern of the following form is generated:
<BETA>
A: P(# #)
</BETA>
where P is the pattern corresponding to the super-category of A. The pattern P is thus the super-pattern for A.
<LI><INX>Constructor</INX>: A pattern of the following form is generated:
<BETA>
A: P
   (#
	getT1: getson1(# #)
	putT1: putson1(# #)
	getT2: getson2(# #)
	putT2: putson2(# #)
	... 
	getTn: getsonn(# #)
	putTn: putsonn(# #)
   #)
</BETA>
where P is the super-category of A. There is an attribute corresponding to each nonterminal on the right side of the rule. The suffix of the get- and put- attributes (Ti) is the same as the corresponding tag-name.
<BR>
If T is an instance of A, the i'th sub-AST can be accessed and changed through the get- and putTi operations. The put- and getsoni patterns have enter (respectively exit) parameters such that an AST can be inserted as the i'th sub-AST by ... &AElig; T.putTi and will be delivered by T.getTi &AElig; ...
<LI> <INX>List</INX>: A pattern of the following form is generated:
<BETA>
A: List(# sonCat::< B #)
</BETA>
 where B is the name of the nonterminal on the right side of the rule. The super-pattern is List as the super-category of A is List.
</OL>

<P> Constructor rules are thus mapped into a composition hierarchy and alternation rules into a classification hierarchy.</P>
<P> By using the context-free level it is not possible for a programmer to construct an AST that violates the context-free syntax.</P>





