<H1> <A NAME="LINK-yggdrasil-_Toc364700501"><A NAME=MARKER-9-65></A>The Context-Free Level</A></H1>
<P> <A NAME=MARKER-2-67></A>The context-free level has explicit knowledge about the grammar for the language. For each nonterminal A of the grammar, a corresponding pattern is automatically generated, depending on the defining rule for A. For each rule type described in section 2, the list below describes the corresponding generated patterns.</P>

<OL>
<LI> Alternation<A NAME=MARKER-2-68></A>: A pattern of the following form is generated:
<PRE CLASS=beta>
A: P(# #)
</PRE>
where P is the pattern corresponding to the super-category of A. The pattern P is thus the super-pattern for A.
<LI>Constructor<A NAME=MARKER-2-69></A>: A pattern of the following form is generated:
<PRE CLASS=beta>
A: P
   (#
	getT1: getson1(# #)
	putT1: putson1(# #)
	getT2: getson2(# #)
	putT2: putson2(# #)
	... 
	getTn: getsonn(# #)
	putTn: putsonn(# #)
   #)
</PRE>
where P is the super-category of A. There is an attribute corresponding to each nonterminal on the right side of the rule. The suffix of the get- and put- attributes (Ti) is the same as the corresponding tag-name.
<BR>
If T is an instance of A, the i'th sub-AST can be accessed and changed through the get- and putTi operations. The put- and getsoni patterns have enter (respectively exit) parameters such that an AST can be inserted as the i'th sub-AST by ... &AElig; T.putTi and will be delivered by T.getTi &AElig; ...
<LI> List<A NAME=MARKER-2-70></A>: A pattern of the following form is generated:
<PRE CLASS=beta>
A: List(# sonCat::&lt; B #)
</PRE>
 where B is the name of the nonterminal on the right side of the rule. The super-pattern is List as the super-category of A is List.
</OL>

<P> Constructor rules are thus mapped into a composition hierarchy and alternation rules into a classification hierarchy.</P>
<P> By using the context-free level it is not possible for a programmer to construct an AST that violates the context-free syntax.</P>





