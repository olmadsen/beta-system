<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE> Structured Context-Free Grammars</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>

</HEAD>
<BODY>


<A NAME=HEADING5></A>


<P><A HREF=yggdrasil-6.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=yggdrasil-4.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=yggdrasil-4.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>
<P> Introduction to Context-Free Grammers</P>


<A NAME=HEADING5-0></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700498"><A NAME=MARKER-9-30></A>Structured Context-Free Grammars</A></H1>
<P> The grammar formalism used in the metaprogramming system is a variant of context-free grammars. The main reason for introducing this formalism is to make it possible automatically to generate pattern definitions from a grammar.</P>
<P> A structured context-free grammar <A NAME=MARKER-2-32></A>is a context-free grammar where the rules (productions) satisfy a certain structure.</P>
<P> Each nonterminal must be defined by exactly one of the following rules:</P>

<UL>
<LI>An alternation rule <A NAME=MARKER-2-33></A>has the following form: 
<PRE CLASS=beta>
&lt;A0&gt;::| &lt;A1&gt; | &lt;A2&gt; | ... | &lt;An&gt;
</PRE>
where &lt;A0&gt;, &lt;A1&gt;,..., &lt;An&gt; are nonterminal symbols. The rule specifies that &lt;A0&gt; derives one of &lt;A1&gt;, &lt;A2&gt;,..., or &lt;An&gt;.
<LI>A constructor rule <A NAME=MARKER-2-34></A>has the following form: 
<PRE CLASS=beta>
&lt;A0&gt;::= w0 &lt;t1:A1&gt; w1 ... &lt;tn:An&gt; wn
</PRE>
where &lt;A0&gt;, &lt;t1:A1&gt;, ..., &lt;tn:An&gt; are nonterminal symbols and w0, w1, ..., wn are possibly empty strings of terminal symbols. This rule describes that &lt;A0&gt; derives the string w0 &lt;A1&gt; w1... &lt;An&gt;. A nonterminal on the right side of the rule has the form &lt;t:A&gt; where t is a tag-name and A is the syntactic category. Tag-names are used to distinguish between nonterminals belonging to the same syntactic category. Consequently all tag-names in a rule must be different. If no tag-name is provided the name of the syntactic category is used as a tag-name.
<LI>A list rule <A NAME=MARKER-2-35></A>has one of the following forms: 
<PRE CLASS=beta>
&lt;A&gt;::+ &lt;B&gt; w
&lt;A&gt;::* &lt;B&gt; w
</PRE>
where &lt;B&gt; is a nonterminal and w is a possibly empty string of terminal symbols. The nonterminal &lt;A&gt; generates a list of &lt;B&gt;'s separated by w's: &lt;B&gt; w &lt;B&gt; w... w &lt;B&gt;. The +-rule specifies that at least one element is generated; the *-rule specifies that the list may be empty.
<LI>An optional rule <A NAME=MARKER-2-36></A>has the following form: 
<PRE CLASS=beta>
&lt;A&gt;::? &lt;B&gt;
</PRE>
where &lt;B&gt; is a nonterminal. The nonterminal &lt;A&gt; may generate either the same strings as &lt;B&gt; may generate, or the empty string (i.e. nothing).
</UL>

<P> There exists four predefined nonterminal symbols named &lt;NameDecl<A NAME=MARKER-2-37></A>&gt;, &lt;NameAppl<A NAME=MARKER-2-38></A>&gt;, &lt;String<A NAME=MARKER-2-39></A>&gt; and &lt;Const<A NAME=MARKER-2-40></A>&gt;. These nonterminals are called lexem-symbols. They derive identifiers, character-strings and integer constants. A lexem-symbol may also have a tag-name, like &lt;Title:NameAppl&gt;.</P>

<P> A nonterminal may only appear once on the left-hand side of a rule, and the complete grammar must be LALR<A NAME=MARKER-2-41></A>(1)<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-2">[2]</A></EM>. The limitations on the rules which can be used in a structured context-free grammar do not restrict the class of languages that can be described. Any context-free language may be generated by a structured context-free grammar. It may perhaps be awkward to be forced to follow the rules. On the other hand being forced to structure a grammar using the rules often results in a more readable grammar.</P>

<P> There is one important representation for sentential forms and sentences of any context-free grammar, the abstract syntax tree<A NAME=MARKER-2-42></A>. An abstract syntax tree (for short AST<A NAME=MARKER-2-43></A>) represents how a sentential form (or sentence) has been derived from the grammar (or how it has been constructed by the parser). The AST does not represent the terminals of the grammar, only the involved nonterminals. The nodes in an AST are productions and the branches in the AST signifies derivations of the nonterminals involved in the production in that node. The leaves of the AST are lexems, if the AST represents sentences. If the AST represents a sentential form, leaves may also be nonterminals. ASTs are a very convenient representation of programs and many manipulations of programs may be specified as manipulations on the underlying AST. </P>

<P> A context-free grammar for a language induces an abstract syntax that may be used to give an AST-definition. In the Mj&oslash;lner BETA System, the representation of a program as an AST is defined by means of a context-free grammar for the language. In addition there is a set of rules that specify how the context-free grammar is mapped into a set of data types. The context-free grammar is then part of the specification of the environment. </P>
<P> The metaprogramming system is an object-oriented model of the ASTs.  An AST is modelled as an instance of a pattern.  There is a pattern corresponding to each syntactic category (nonterminal) of the grammar.  ASTs derived from a syntactic category are then modelled as instances of the corresponding pattern.  The grammar hierarchy is modelled by a corresponding pattern hierarchy. </P>
<P> Special grammar symbols are shown enclosed by &lt;&lt; and
&gt;&gt;.  These symbols are called placeholders.  Placeholders are
always associated with a nonterminal of the grammar.  A placeholder
may have a tag-name in order to be able to distinguish between several
instances of the same nonterminal in a program.
I.e. &lt;&lt;PopLib:attributes&gt;&gt; is a placeholder, where
attributes specifies the syntactic category and PopLib is the
tag-name.  As illustrated below, some placeholders are also equipped
with the symbols SLOT or &quot;...&quot;.  These will be explained
below</P>

<PRE class=beta>
(# Private: @&lt;&lt;SLOT PrivateBody:descriptor&gt;&gt;;
   Push: (# e: @integer                            
         enter e                                  
         do &lt;&lt;SLOT PushBody:descriptor&gt;&gt;     
         #);                                       
   Pop: (# &lt;&lt;PopLib:attributes&gt;&gt; ... #); 
   &lt;&lt;attributes&gt;&gt;                     
#) 
</PRE>
                                           

<P> The above is a BETA pattern for a Stack. The pattern is not fully specified in the sense that the pattern contains placeholders that have not been expanded. </P>
<P> Generally, programs may contain placeholders of three different types: nonterminals, slots or contractions.  Nonterminals and slots denote unexpanded nonterminals of the underlying grammar, whereas contractions denote expanded nonterminals of the underlying grammar.  I.e. a program containing nonterminals and slots are sentential forms of the BETA language, whereas programs only containing contractions are sentences of the BETA language. </P>
<P> Nonterminals  are indications that these parts of the program have not been specified yet (e.g. &lt;&lt;PopLib:attributes&gt;&gt;).  The ability to leave nonterminals in the program is the means for allowing syntax directed editing. </P>
<P> Slots  are indications of parts of the program that deliberately have been kept open (e.g. &lt;&lt;SLOT PushBody:descriptor&gt;&gt;).  Slots are a means for specifying a program in which parts are separately specified (these parts are indicated by the slots).  A program with slots may be separately compiled, and other programs may contain the slot definition to be applied later. </P>
<P> Contractions  are placeholders indicating that this part of the program, derived from the nonterminal, is not shown (e.g. ...). I.e.  contractions are a means for suppressing details that are otherwise present in the program.  Note that contractions may suppress other placeholders, i.e. nonterminals, slots and other contractions may appear within a contraction.   Contractions are merely a means for presenting an overview of programs etc., and the handlig of contractions are therefore totally controlled by the different tools (i.e. not managed by the metaprogramming system)</P>
<P> In terms of the underlying AST of the program, nonterminals are leaves in the tree, slots are references from one AST to another AST (possibly not yet derived), and contractions indicates a sub-AST that is not shown (i.e. only represented by the syntactic category of the root of the sub-AST. </P>
<P> The super-category of a given syntactic category A is defined as follows:</P>
<UL>
<LI> If &lt;A&gt; appears on the right side of an alternation rule of the form: 
<PRE CLASS=beta>
&lt;B&gt;::| ... | &lt;A&gt; | ... | ...
</PRE>
then the super-category of A is B.
<LI> If &lt;A&gt; appears in a list rule in one of the forms: 
<PRE CLASS=beta>
&lt;A&gt;::+ &lt;B&gt; ...
&lt;A&gt;::* &lt;B&gt; ... 
</PRE>
then the super-category of A is List<A NAME=MARKER-2-44></A>.
<LI> If &lt;A&gt; appears in an optional rule:
<PRE CLASS=beta>
&lt;A&gt; ::? &lt;B&gt;
</PRE>
then no category A is defined (to be discussed later).
<LI> Otherwise the super-category of A is Cons<A NAME=MARKER-2-45></A>.
</UL>
<P> The inheritance hierarchy of the generated patterns of the context-free level is the same as the classification hierarchy of the syntactic categories. In general a syntactic category may have more than one super-category. This corresponds to multiple inheritance in object-oriented languages. Since BETA currently does not support multiple inheritance, there is the additional restriction that the hierarchy must be tree structured. That is, the following grammar will not be a legal grammar:</P>
<PRE CLASS=beta>
&lt;A&gt; ::| &lt;B&gt; | &lt;C&gt;
&lt;B&gt; ::+ &lt;D&gt;
&lt;C&gt; ::= &lt;E&gt; terminal &lt;F&gt; 
</PRE>
<P> since &lt;B&gt; will have both List and A as super-category.</P>
<A NAME=HEADING5-59></A>
<H1> <A NAME="LINK-yggdrasil-_Toc364700499"><A NAME=MARKER-9-46></A>Example of Structured Context-Free Grammar</A></H1>
<P> Below an example of a structured context-free grammar is given<EM><A REL=FOOTNOTE HREF="#FOOTNOTE-3">[3]</A></EM>.</P>

<PRE CLASS=beta>
Grammar Small:
	&lt;Block&gt;::= begin &lt;DclPart:DclLst&gt;
                  do &lt;ImpPart:ImpLst&gt;
                  end
	&lt;Dcl&gt;::| &lt;VarDcl&gt; | &lt;ProcDcl&gt;
	&lt;VarDcl&gt;::= var &lt;Name:NameDecl&gt;: &lt;VarType:Type&gt;
	&lt;ProcDcl&gt;::= proc &lt;Name:NameDecl&gt; &lt;Body:Block&gt;
	&lt;Imp&gt;::| &lt;IfImp&gt; | &lt;AssignmentImp&gt; | &lt;ProcCall&gt;
	&lt;IfImp&gt;::= if &lt;Condition:Exp&gt; 
                  then &lt;ThenPart: ImpLst&gt;
                  else &lt;ElsePart: ImpLst&gt; endif
	&lt;AssignmentImp&gt;::= &lt;Var:NameAppl&gt; := &lt;Value:Exp&gt;
	&lt;ProcCall&gt;::= &lt;Proc:NameAppl&gt;
	&lt;DclLst&gt;::* &lt;Dcl&gt;;
	&lt;ImpLst&gt;::* &lt;Imp&gt;;
</PRE>
<P> The nonterminals &lt;Type&gt; and &lt;Exp&gt; will not be defined.</P>
<P> The syntactic categories of a structured context-free grammar may be organized into a classification hierarchy according to the set of strings being generated. The hierarchy mainly derives from the alternation rules of the grammar. The hierarchy for the example grammar is:</P>

<center> <IMG ALIGN=TOP SRC=example-hierarchy.gif></center>
<P> The categories Cons and List generalize all categories according to the rule type that defines the category. &lt;Imp&gt; is a super-category of &lt;IfImp&gt; since any string generated by &lt;IfImp&gt; may be generated by &lt;Imp&gt;.</P>






<HR>

<A NAME=FOOTNOTE-2>[2] </A>
 However, this restriction is only neceaasry if the grammar is to be used for parsing purposes (see chapter 7 for more details). 
<HR>

<A NAME=FOOTNOTE-3>[3] </A>
 Please note, that this grammar specification (as the previous grammar) is not fully consistent with the actual grammar specification syntax of the metaprogramming system (see chapter 7).






<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Metaprogramming System</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=yggdrasil-6.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=yggdrasil-4.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=yggdrasil-4.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>


</BODY>
</HTML>
